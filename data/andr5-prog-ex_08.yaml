- en: Chapter 8. Apps for TVs, Cars, and Wearables
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 适用于电视、汽车和可穿戴设备的App
- en: One of the most exciting new directions that Android has gone in recently, is
    the extension of the platform from phones and tablets to televisions, car dashboards
    and wearables such as watches. These new devices allow us to provide added functionality
    to our existing apps, as well as creating wholly original apps designed specifically
    for these new environments.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 近期Android发展中最令人兴奋的新方向之一，是将平台从手机和平板电脑扩展到电视、汽车仪表盘以及如手表这样的可穿戴设备。这些新设备使我们能够为现有的应用提供附加功能，同时还能创建专门为这些新环境设计的全新应用。
- en: We have already acquired the skills needed to develop such apps and this chapter
    is really more concerned with explaining the idiosyncrasies of each platform and
    the guidelines Google is keen for us to follow. This is particularly vital when
    it comes to developing apps that people will use when driving, as safety has to
    be of prime importance. There are also certain technical issues that need to be
    addressed when developing wearable apps, such as the pairing of the device with
    a handset and the entirely different UI and methods of use.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经掌握了开发此类应用所需的技能，而本章的主要内容是解释每个平台的独特之处以及谷歌希望我们遵循的指南。当涉及到开发人们在驾驶时使用的应用时，这一点尤为重要，因为安全必须是首要考虑的因素。在开发可穿戴应用时，还需要解决某些技术问题，例如将设备与手机配对以及完全不同的UI和使用方法。
- en: 'In this chapter, you will:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将：
- en: Create wearable AVDs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可穿戴AVD
- en: Connect a wearable emulator to a handset with adb commands
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用adb命令将可穿戴模拟器连接到手机
- en: Connect a wearable emulator to a handset emulator
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将可穿戴模拟器连接到手机模拟器
- en: Create a project with both mobile and wearable modules
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建包含移动和可穿戴模块的项目
- en: Use the Wearable UI Library
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可穿戴UI库
- en: Create shape-aware layouts
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建形状感知布局
- en: Create and customize cards for wearables
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和自定义可穿戴设备的卡片
- en: Understand wearable design principles
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解可穿戴设计原则
- en: Access wearable sensors
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问可穿戴传感器
- en: Make an app available for Google TV
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使应用可在Google TV上使用
- en: Include Leanback support
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含Leanback支持
- en: Understand Android Auto safety guidelines
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Android Auto安全指南
- en: Configure an Auto project
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Auto项目
- en: Install Google simulators
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Google模拟器
- en: Send SMS messages using the Android Device Monitor
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Android设备监控器发送短信
- en: Android Wear
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android Wear
- en: Creating or adapting apps for wearables is probably the most complicated of
    the three form factors dealt with in this chapter and requires a little more setting
    up than the other projects. However, wearables often give us access to one of
    the more fun new sensors, the heart rate monitor. In seeing how this works, we
    also get to see, how to manage sensors in general.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 创建或修改适用于可穿戴设备的应用可能是本章中处理的三种形式因素中最复杂的一种，并且需要比其他项目更多的设置。然而，可穿戴设备通常使我们能够访问一些更有趣的新传感器，如心率监测器。通过了解它是如何工作的，我们还可以了解如何管理传感器。
- en: Do not worry if you do not have access to an Android wearable device, as we
    will be constructing AVDs. You will ideally have an actual Android 5 handset,
    if you wish to pair it with the AVD. If you do not, it is still possible to work
    with two emulators but it is a little more complex to set up. Bearing this in
    mind, we can now prepare our first wearable app.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您无法访问Android可穿戴设备，请不要担心，因为我们将会构建AVD。如果您希望将实际Android 5手机与AVD配对，理想情况下您应该拥有这样一部手机。如果没有，仍然可以使用两个模拟器进行工作，但设置起来会稍微复杂一些。考虑到这一点，我们现在可以准备我们的第一个可穿戴应用。
- en: Constructing and connecting to a wearable AVD
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建和连接到可穿戴AVD
- en: It is perfectly possible to develop and test wearable apps on the emulator alone,
    but if we want to test all wearable features, we will need to pair it with a phone
    or a tablet. The next exercise assumes that you have an actual device. If you
    do not, still complete tasks 1 through 4 and we will cover how the rest can be
    achieved with an emulator a little later on.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟器上独立开发和测试可穿戴应用是完全可能的，但如果我们想测试所有可穿戴功能，我们需要将其与手机或平板电脑配对。下一个练习假设您拥有实际设备。如果您没有，仍然完成任务1至4，我们稍后会介绍如何使用模拟器完成剩余部分。
- en: Open Android Studio. You do not need to start a project at this point.![Constructing
    and connecting to a wearable AVD](img/B04321_08_01.jpg)
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Android Studio。在此阶段，您不需要启动项目。![构建和连接到可穿戴AVD](img/B04321_08_01.jpg)
- en: Start the SDK Manager and ensure you have the relevant packages installed.
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 启动SDK管理器并确保已安装相关包。
- en: Open the AVD Manager.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开AVD管理器。
- en: Create two new Android Wear AVDs, one round and one square, like so:![Constructing
    and connecting to a wearable AVD](img/B04321_08_02.jpg)
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个新的 Android Wear AVD，一个圆形和一个方形，如下所示：![构建和连接到可穿戴 AVD](img/B04321_08_02.jpg)
- en: Ensure USB Debugging is selected on your handset.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在手机上选中了 USB 调试。
- en: 'Install the Android Wear app from the Play Store at this URL: [https://play.google.com/store/apps/details?id=com.google.android.wearable.app](https://play.google.com/store/apps/details?id=com.google.android.wearable.app).
    Connect it to your computer and start one of the AVDs we just created.'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Play Store 在此 URL 安装 Android Wear 应用程序：[https://play.google.com/store/apps/details?id=com.google.android.wearable.app](https://play.google.com/store/apps/details?id=com.google.android.wearable.app)。将其连接到计算机并启动我们刚刚创建的其中一个
    AVD。
- en: Locate and open the folder containing the `adb.exe` file. It will probably be
    something like `user\AppData\Local\Android\sdk\platform-tools\`.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位并打开包含 `adb.exe` 文件的文件夹。它可能类似于 `user\AppData\Local\Android\sdk\platform-tools\`。
- en: Using *Shift* + right-click, select **Open command window here**.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 *Shift* + 右键单击，选择 **在此处打开命令窗口**。
- en: 'In the command window, issue the following command:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令窗口中，输入以下命令：
- en: '`adb -d forward tcp:5601 tcp:5601`'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`adb -d forward tcp:5601 tcp:5601`'
- en: Launch the companion app and follow the instructions to pair the two devices.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动配套应用程序，按照说明将两个设备配对。
- en: Being able to connect a real-world device to an AVD is a great way to develop
    form factors without having to own the devices. The wearable companion app simplifies
    the process of connecting the two. If you have had the emulator running for any
    length of time, you will have noticed that many actions, such as notifications,
    are sent to the wearable automatically. This means that very often our apps will
    link seamlessly with a wearable device, without us having to include code to pre-empt
    this.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 能够将真实世界设备连接到 AVD 是一种很好的开发形式，而不必拥有这些设备。可穿戴配套应用程序简化了连接两个设备的过程。如果你已经运行仿真器一段时间，你会注意到许多操作，如通知，会自动发送到可穿戴设备。这意味着我们的应用程序通常可以无缝地与可穿戴设备链接，而无需我们编写代码来预先处理这种情况。
- en: The `adb.exe` (**Android Debug Bridge**) is a vital part of our development
    toolkit. Most of the time, the Android Studio manages it for us. However, it is
    useful to know that it is there and a little about how to interact with it. We
    used it here to manually open a port between our wearable AVD and our handset.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`adb.exe`（**Android 调试桥**）是我们开发工具包的重要组成部分。大多数时候，Android Studio 会为我们管理它。然而，了解它的存在以及如何与之交互是有用的。我们在这里使用它来手动在我们的可穿戴
    AVD 和手机之间打开一个端口。'
- en: There are many `adb` commands that can be issued from the command prompt and
    perhaps the most useful is `adb devices`, which lists all currently debuggable
    devices and emulators, and is very handy when things are not working, to see if
    an emulator needs restarting. Switching the ADB off and on can be achieved using
    `adb kill-server` and `adb start-server` respectively. Using `adb help` will list
    all available commands.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多可以从命令提示符发出的 `adb` 命令，其中最有用的是 `adb devices`，它列出了所有当前可调试的设备和仿真器，当事情不正常时非常方便，可以查看是否需要重新启动仿真器。通过使用
    `adb kill-server` 和 `adb start-server` 分别关闭和启动 ADB。使用 `adb help` 将列出所有可用的命令。
- en: Tip
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The port forwarding command we used in step 10, needs to be issued every time
    the phone is disconnected from the computer.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 10 中使用的端口转发命令需要在手机从计算机断开连接时每次发出。
- en: Without writing any code as such, we have already seen some of the features
    that are built into an Android Wear device and the way that the Wear UI differs
    from most other Android devices.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在不编写任何代码的情况下，我们已经看到了一些内置在 Android Wear 设备中的功能以及 Wear UI 与大多数其他 Android 设备的不同之处。
- en: Even if you usually develop with the latest Android hardware, it is often still
    a good idea to use an emulator, especially for testing the latest SDK updates
    and pre-releases. If you do not have a real device, then the next, small section
    will show you how to connect your wearable AVD to a handset AVD.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你通常使用最新的 Android 硬件进行开发，使用仿真器通常仍然是一个好主意，特别是用于测试最新的 SDK 更新和预发布版本。如果你没有真实设备，接下来的小节将展示如何将你的可穿戴
    AVD 连接到手机 AVD。
- en: Connecting a wearable AVD with another emulator
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将可穿戴 AVD 与另一个仿真器连接
- en: 'Pairing two emulators is very similar to pairing with a real device. The main
    difference is the way we install the companion app without access to the Play
    Store. Follow these steps to see how it is done:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 配对两个仿真器与配对真实设备非常相似。主要区别是我们如何在没有访问 Play Store 的情况下安装配套应用程序。按照以下步骤查看如何操作：
- en: Start up, an AVD. This will need to be targeting Google APIs as seen here:![Connecting
    a wearable AVD with another emulator](img/B04321_08_03.jpg)
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个AVD。这需要针对Google API，如这里所示：![连接可穿戴AVD与其他模拟器](img/B04321_08_03.jpg)
- en: Download the `com.google.android.wearable.app-2.apk`. There are many places
    online where it can be found with a simple search, I used [www.file-upload.net/download](http://www.file-upload.net/download).
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载`com.google.android.wearable.app-2.apk`。在网上有很多地方可以通过简单的搜索找到它，我使用了[www.file-upload.net/download](http://www.file-upload.net/download)。
- en: Place the file in your `sdk/platform-tools` directory.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件放置在您的`sdk/platform-tools`目录中。
- en: '*Shift* + right-click in this folder and select **Open command window here**.'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此文件夹中*Shift* + 右键单击，然后选择**在此处打开命令窗口**。
- en: 'Enter the following command:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下命令：
- en: '[PRE0]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Start your wearable AVD.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动您的可穿戴AVD。
- en: 'Enter `adb devices` into the command prompt, making sure that both emulators
    are visible with an output similar to this:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令提示符中输入`adb devices`，确保两个模拟器都可见，输出类似于以下内容：
- en: '[PRE1]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Enter `adb telnet localhost 5554` at the command prompt, where `5554` is the
    phone emulator.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令提示符中输入`adb telnet localhost 5554`，其中`5554`是手机模拟器。
- en: Next, enter `adb redir add tcp:5601:5601`.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，输入`adb redir add tcp:5601:5601`。
- en: You can now use the Wear app on the handheld AVD to connect to the watch.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在可以使用手持AVD上的可穿戴应用程序连接到手表。
- en: As we've just seen, setting up a Wear project takes a little longer than some
    of the other exercises we have performed. Once set up though, the process is very
    similar to that of developing for other form factors, and something we can now
    get on with.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，设置可穿戴项目比我们之前执行的一些其他练习要花更长的时间。一旦设置完成，过程与为其他形式因素开发的过程非常相似，我们现在可以继续进行。
- en: Creating a wearable project
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建可穿戴项目
- en: All of the apps that we have developed so far, have required just a single module,
    and this makes sense as we have only been building for single devices. In this
    next step, we will be developing across two devices and so will need two modules.
    This is very simple to do, as you will see in these next steps.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止开发的所有应用程序都只需要一个模块，这是有道理的，因为我们只为单个设备构建。在接下来的步骤中，我们将跨两个设备进行开发，因此需要两个模块。这非常简单，您将在接下来的步骤中看到。
- en: Start a new project in the Android Studio and call it something like `Wearable
    App`.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android Studio中创建一个新的项目，并将其命名为类似`Wearable App`的名称。
- en: On the **Target Android Devices** screen, select both **Phone and Tablet** and
    **Wear**, like so:![Creating a wearable project](img/B04321_08_04.jpg)
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**目标Android设备**屏幕上，选择**手机和平板电脑**以及**可穿戴**，如下所示：![创建可穿戴项目](img/B04321_08_04.jpg)
- en: You will be asked to add two Activities. Select **Blank Activity** for the Mobile
    Activity and **Blank Wear Activity** for Wear.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将被要求添加两个活动。对于移动活动，选择**空白活动**，对于可穿戴设备，选择**空白可穿戴活动**。
- en: Everything else can be left as it is.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其他所有内容都可以保持不变。
- en: Run the app on both round and square virtual devices.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在圆形和方形虚拟设备上运行应用程序。
- en: The first thing you will have noticed is the two modules, mobile and wear. The
    first is the same as we have seen many times, but there are a few subtle differences
    with the wear module and it is worth taking a little look at. The most important
    difference is the `WatchViewStub` class. The way it is used can be seen in the
    `activity_main.xml` and `MainActivity.java` files of the wear module.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您首先会注意到有两个模块，移动和可穿戴。第一个模块与我们之前看到的相同，但与可穿戴模块有一些细微的差别，值得稍微看一下。最重要的差别是`WatchViewStub`类。它在可穿戴模块的`activity_main.xml`和`MainActivity.java`文件中的使用方式可以查看。
- en: 'This frame layout extension is designed specifically for wearables and detects
    the shape of the device, so that the appropriate layout is inflated. Utilizing
    the `WatchViewStub` is not quite as straightforward, as one might imagine, as
    the appropriate layout is only inflated after the `WatchViewStub` has done its
    thing. This means that, to access any views within the layout, we need to employ
    a special listener that is called once the layout has been inflated. How this
    `OnLayoutInflatedListener()` works can be seen by opening the `MainActivity.java`
    file in the wear module and examining the `onCreate()` method, which will look
    like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个帧布局扩展专门为可穿戴设备设计，可以检测设备的形状，以便填充适当的布局。利用`WatchViewStub`并不像想象中那么简单，因为适当的布局只有在`WatchViewStub`完成其操作后才会被填充。这意味着，为了访问布局中的任何视图，我们需要使用一个特殊的监听器，该监听器在布局被填充后会被调用。如何通过打开可穿戴模块中的`MainActivity.java`文件并检查`onCreate()`方法来了解`OnLayoutInflatedListener()`的工作方式，该`onCreate()`方法看起来如下：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Other than the way that wearable apps and devices are set up for developing,
    the other significant difference is the UI. The widgets and layouts that we use
    for phones and tablets are not suitable, in most cases, for the diminished size
    of a watch screen. Android provides a whole new set of UI components, that we
    can use and this is what we will look at next.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可穿戴应用程序和设备在开发中的设置方式外，另一个显著的不同之处在于UI。我们用于手机和平板电脑的小部件和布局在大多数情况下不适用于手表屏幕较小的尺寸。Android提供了一套全新的UI组件，我们可以使用，这就是我们接下来要探讨的内容。
- en: Designing a UI for wearables
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计可穿戴设备的UI
- en: As well as having to consider the small size of wearable when designing layouts,
    we also have the issue of shape. Designing for a round screen brings its own challenges,
    but fortunately the **Wearable UI Library** makes this very simple. As well as
    the `WatchViewStub`, that we encountered in the previous section that inflates
    the correct layout, there is also a way to design a single layout that inflates
    in such a way, that it is suitable for both square and round screens.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在设计布局时必须考虑可穿戴设备的小尺寸外，我们还有形状问题。为圆形屏幕设计会带来自己的挑战，但幸运的是，**Wearable UI库**使这一点变得非常简单。除了我们在上一节中遇到的`WatchViewStub`，它能够填充正确的布局外，还有一种方法可以设计一个布局，使其既适用于方形屏幕也适用于圆形屏幕。
- en: Designing the layout
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计布局
- en: 'The project setup wizard included this library for us automatically in the
    `build.gradle (Module: wear)` file as a dependency:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '项目设置向导自动在`build.gradle (Module: wear)`文件中将此库作为依赖项包含：'
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following steps demonstrate how to create a shape-aware layout with a `BoxInsetLayout`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤演示了如何使用`BoxInsetLayout`创建一个形状感知布局：
- en: Open the project we created in the last section.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开上一节中创建的项目。
- en: 'You will need three images that must be placed in the `drawable` folder of
    the wear module: one called `background_image` of around 320 x 320 px and two
    of around 50 x 50 px, called `right_icon` and `left_icon`.'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要三个图像，必须放置在可穿戴模块的`drawable`文件夹中：一个名为`background_image`的图像，大小约为320 x 320 px，以及两个大小约为50
    x 50 px的图像，分别命名为`right_icon`和`left_icon`。
- en: Open the `activity_main.xml` file in the wear module.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在可穿戴模块中打开`activity_main.xml`文件。
- en: 'Replace its content with the following code:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下代码替换其内容：
- en: '[PRE4]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Inside the `BoxInsetLayout`, add the following `FrameLayout`:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`BoxInsetLayout`内部添加以下`FrameLayout`：
- en: '[PRE5]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Inside this, add these three views:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中添加以下三个视图：
- en: '[PRE6]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Open the `MainActivity.java` file in the wear module.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在可穿戴模块中打开`MainActivity.java`文件。
- en: In the `onCreate()` method, delete all lines after the line `setContentView(R.layout.activity_main);`.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate()`方法中，删除`setContentView(R.layout.activity_main);`行之后的所有行。
- en: Now, run the app on both square and round emulators.![Designing the layout](img/B04321_08_05.jpg)
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在方形和圆形模拟器上运行应用程序。![设计布局](img/B04321_08_05.jpg)
- en: As we can see, the `BoxInsetLayout` does a fine job of inflating our layout
    regardless of screen shape. How it works is very simple. The `BoxInsetLayout`
    creates a square region, that is as large as can fit inside the circle of a round
    screen. This is set with the `app:layout_box="all"` instruction, which can also
    be used for positioning components, as we will see in a minute.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`BoxInsetLayout`在无论屏幕形状如何的情况下都能很好地填充我们的布局。其工作原理非常简单。`BoxInsetLayout`创建一个正方形区域，其大小可以适应圆形屏幕的圆形。这是通过`app:layout_box="all"`指令设置的，该指令也可以用于定位组件，正如我们将在下一分钟看到的那样。
- en: We have also set the padding of the `BoxInsetLayout` to 15 dp and that of the
    `FrameLayout` to 5 dp. This has the effect of a margin of 5 dp on round screens
    and 15 dp on square ones.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将`BoxInsetLayout`的填充设置为15 dp，而`FrameLayout`的填充设置为5 dp。这会在圆形屏幕上产生5 dp的边距，在方形屏幕上产生15
    dp的边距。
- en: Whether you use the `WatchViewStub` and create separate layouts for each screen
    shape or `BoxInsetLayout` and just one layout file depends entirely on your preference
    and the purpose and design of your app. Whichever method you choose, you will
    no doubt want to add Material Design elements to your wearable app, the most common
    and versatile of these being the card. In the following section, we will explore
    the two ways that we can do this, the `CardScrollView` and the `CardFragment`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是使用`WatchViewStub`并为每种屏幕形状创建单独的布局，还是使用`BoxInsetLayout`并仅创建一个布局文件，这完全取决于您的偏好以及您应用程序的目的和设计。无论您选择哪种方法，您无疑都希望将Material
    Design元素添加到您的可穿戴应用程序中，其中最常见且最灵活的是卡片。在下一节中，我们将探讨两种实现方式，即`CardScrollView`和`CardFragment`。
- en: Adding cards
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加卡片
- en: 'The `CardFragment` class provides a default card view, providing two text views
    and an image. It is beautifully simple to set up, has all the Material Design
    features such as rounded corners and a shadow, and is suitable for nearly all
    purposes. It can be customized, as we will see, although the `CardScrollView`
    is often a better option. First, let us see, how to implement a default card for
    wearables:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`CardFragment` 类提供了一个默认的卡片视图，包含两个文本视图和一个图像。它设置起来非常简单，具有所有 Material Design 特性，如圆角和阴影，几乎适用于所有用途。它可以进行定制，正如我们将看到的，尽管
    `CardScrollView` 通常是一个更好的选择。首先，让我们看看如何为可穿戴设备实现默认卡片：'
- en: Open the `activity_main.xml` file in the wear module of the current project.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开当前项目中 wear 模块中的 `activity_main.xml` 文件。
- en: Delete or comment out the the text view and two image views.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除或注释掉文本视图和两个图像视图。
- en: Open the `MainActivity.java` file in the wear module.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 wear 模块中的 `MainActivity.java` 文件。
- en: 'In the `onCreate()` method, add the following code:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onCreate()` 方法中，添加以下代码：
- en: '[PRE7]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Run the app on one or other of the wearable emulators to see how the default
    card looks.![Adding cards](img/B04321_08_06.jpg)
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在可穿戴设备模拟器中运行应用，看看默认卡片的外观。![添加卡片](img/B04321_08_06.jpg)
- en: 'We met the `FragmentManager` in [Chapter 6](ch06.html "Chapter 6. Notifications
    and the Action Bar"), *Notifications and the Action Bar* and here it operates
    in a very similar fashion and requires little explanation. The way we created
    the `CardFragment` itself, is also very straightforward. We used two string parameters
    here, but there is a third, drawable parameter and if the line is changed to `CardFragment
    cardFragment = CardFragment.create("TITLE", "with description and drawable", R.drawable.left_icon);`
    then we will get the following output:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [第 6 章](ch06.html "第 6 章。通知和动作栏") 中遇到了 `FragmentManager`，*通知和动作栏*，在这里它以非常相似的方式运行，并且需要很少的解释。我们创建
    `CardFragment` 的方式也非常直接。我们在这里使用了两个字符串参数，但还有一个第三个参数，即可绘制参数，如果将行更改为 `CardFragment
    cardFragment = CardFragment.create("TITLE", "with description and drawable", R.drawable.left_icon);`，那么我们将得到以下输出：
- en: '![Adding cards](img/B04321_08_07.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![添加卡片](img/B04321_08_07.jpg)'
- en: This default implementation for cards on wearable is fine for most purposes
    and it can be customized by overriding its `onCreateContentView()` method. However,
    the `CardScrollView` is a very handy alternative, and this is what we will look
    at next.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可穿戴设备上的卡片，这个默认实现对于大多数用途来说都很好，并且可以通过重写其 `onCreateContentView()` 方法进行定制。然而，`CardScrollView`
    是一个非常方便的替代方案，这是我们接下来要探讨的。
- en: Customizing cards
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定制卡片
- en: 'The `CardScrollView` is defined from within our layout and furthermore it detects
    screen shape and adjusts the margins to suit each shape. To see how this is done,
    follow these steps:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`CardScrollView` 在我们的布局内部定义，并且它能够检测屏幕形状并调整边距以适应每个形状。要了解这是如何实现的，请按照以下步骤操作：'
- en: Open the `activity_main.xml` file in the wear module.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 wear 模块中的 `activity_main.xml` 文件。
- en: Delete or comment out every element, except the root `BoxInsetLayout`.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除或注释掉每个元素，除了根 `BoxInsetLayout`。
- en: 'Place the following `CardScrollView` inside the `BoxInsetLayout`:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `BoxInsetLayout` 内放置以下 `CardScrollView`：
- en: '[PRE8]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Inside this, add this `CardFrame`:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中添加以下 `CardFrame`：
- en: '[PRE9]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Inside the `CardFrame`, add a `LinearLayout`.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `CardFrame` 内部添加一个 `LinearLayout`。
- en: Add some views to this, so that the preview resembles the layout here:![Customizing
    cards](img/B04321_08_08.jpg)
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向其中添加一些视图，以便预览与这里的布局相似：![定制卡片](img/B04321_08_08.jpg)
- en: Open the `MainActivity.java` file.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainActivity.java` 文件。
- en: 'Replace the code we added to the `onCreate()` method with this:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们添加到 `onCreate()` 方法中的代码替换为以下内容：
- en: '[PRE10]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can now test the app on an emulator, which will produce the following result:![Customizing
    cards](img/B04321_08_09.jpg)
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以在模拟器上测试应用，这将产生以下结果：![定制卡片](img/B04321_08_09.jpg)
- en: Tip
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: As can be seen in the previous image, the Android Studio has preview screens
    for both wearable shapes. Like some other previews, these are not always what
    you will see on a device, but they allow us to put layouts together very quickly,
    by dragging and dropping widgets.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，Android Studio 为可穿戴设备形状提供了预览屏幕。像一些其他预览一样，这些并不总是你将在设备上看到的样子，但它们允许我们通过拖放小部件来快速组合布局。
- en: As we can see, the `CardScrollView` and `CardFrame` are even easier to implement
    than the `CardFragment` and also far more flexible, as we can design almost any
    layout we can imagine. We assigned `app:layout_box` here again, only this time
    using `bottom`, causing the card to be placed as low on the screen as possible.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`CardScrollView` 和 `CardFrame` 的实现甚至比 `CardFragment` 更简单，而且更加灵活，因为我们几乎可以设计出任何我们想象的布局。我们在这里再次分配了
    `app:layout_box`，但这次使用 `bottom`，使得卡片尽可能低地放置在屏幕上。
- en: It is very important, when designing for such small screens, to keep our layouts
    as clean and simple as possible. Google's design principles state that wearable
    apps should be glanceable. This means that, as with a traditional wrist watch,
    the user should be able to glance at our app and immediately take in the information
    and return to what they were doing.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在为如此小的屏幕设计时，保持我们的布局尽可能干净和简单是非常重要的。谷歌的设计原则指出，可穿戴应用应该是可一目了然的。这意味着，就像传统的手表一样，用户应该能够快速查看我们的应用并立即获取信息，然后返回他们之前正在做的事情。
- en: Another of Google's design principle—*Zero to low interaction*—is only a single
    tap or swipe a user needs to do to interact with our app. With these principles
    in mind, let us create a small app, with some actual functionality. In the next
    section, we will take advantage of the new heart rate sensor found in many wearable
    devices and display current beats-per-minute on the display.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个谷歌的设计原则——*零到低交互*——用户只需要单次点击或滑动就能与我们的应用交互。带着这些原则，让我们创建一个小型应用，其中包含一些实际的功能。在下一节中，我们将利用许多可穿戴设备中找到的新心率传感器，并在显示屏上显示每分钟的当前心跳次数。
- en: Accessing sensor data
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问传感器数据
- en: 'The location of an Android Wear device on the user''s wrist, makes it the perfect
    piece of hardware for fitness apps, and not surprisingly, these apps are immensely
    popular. As with most features of the SDK, accessing sensors is pleasantly simple,
    using classes such as managers and listeners and requiring only a few lines of
    code, as you will see by following these steps:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Android Wear 设备在用户手腕上的位置，使其成为健身应用的完美硬件，而且不出所料，这些应用非常受欢迎。与 SDK 的大多数功能一样，访问传感器非常简单，使用管理器和监听器类，并且只需要几行代码，正如您通过以下步骤将看到的那样：
- en: Open the project we have been working on in this chapter.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开本章中我们一直在工作的项目。
- en: Replace the background image with one that might be suitable for a fitness app.
    I have used a simple image of a heart.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将背景图片替换为可能适合健身应用的图片。我使用了一个简单的爱心图片。
- en: Open the `activity_main.xml` file.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `activity_main.xml` 文件。
- en: Delete everything, except the root `BoxInsetLayout`.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除除根 `BoxInsetLayout` 之外的所有内容。
- en: 'Place this `TextView` inside it:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此 `TextView` 放置在其中：
- en: '[PRE11]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Open the Manifest file in the wear module.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开可穿戴模块中的 Manifest 文件。
- en: 'Add the following permission inside the root manifest node:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根 Manifest 节点内添加以下权限：
- en: '[PRE12]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Open the `MainActivity.java` file in the wear module.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开可穿戴模块中的 `MainActivity.java` 文件。
- en: 'Add the following fields:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下字段：
- en: '[PRE13]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Implement a `SensorEventListener` on the Activity:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Activity 中实现 `SensorEventListener`：
- en: '[PRE14]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Implement the two methods required by the listener.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现监听器所需的两个方法。
- en: 'Edit the `onCreate()` method, like this:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `onCreate()` 方法，如下所示：
- en: '[PRE15]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add this `onResume()` method:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加这个 `onResume()` 方法：
- en: '[PRE16]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And this `onPause()` method:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以及这个 `onPause()` 方法：
- en: '[PRE17]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Edit the `onSensorChanged()` callback, like so:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `onSensorChanged()` 回调，如下所示：
- en: '[PRE18]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you do not have access to a real device, you can download a sensor simulator
    from here:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您无法访问真实设备，您可以从这里下载传感器模拟器：
- en: '[https://code.google.com/p/openintents/wiki/SensorSimulator](https://code.google.com/p/openintents/wiki/SensorSimulator)'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://code.google.com/p/openintents/wiki/SensorSimulator](https://code.google.com/p/openintents/wiki/SensorSimulator)'
- en: The app is now ready to test.![Accessing sensor data](img/B04321_08_10.jpg)
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用现在已准备好测试。![访问传感器数据](img/B04321_08_10.jpg)
- en: We began by adding a permission in the `AndroidManifest.xml` file in the appropriate
    module; this is something we have done before and need to do any time we are using
    features, that require the user's permission before installing.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在 `AndroidManifest.xml` 文件中适当的模块中添加了一个权限；这是我们之前做过的事情，每次我们使用需要用户在安装前给予权限的功能时都需要这样做。
- en: The inclusion of a background image may seem necessary, but an appropriate background
    is a real aid to glancability as the user can tell instantly which app they are
    looking at.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 包含背景图片可能看起来是必要的，但合适的背景确实有助于提高可一目了然的特性，因为用户可以立即知道他们正在查看哪个应用。
- en: It should be clear, from the way the `SensorManager` and the `Sensor` are set
    up in the `onCreate()` method, that all sensors are accessed in the same way and
    different sensors can be accessed with different constants. We used `TYPE_HEART_RATE`
    here, but any other sensor can be started with the appropriate constant, and all
    sensors can be managed with the same basic structures as we found here, the only
    real difference being the way each sensor returns `SensorEvent.values[]`. A comprehensive
    list of all sensors, and descriptions of the values they produce can be found
    at [http://developer.android.com/reference/android/hardware/Sensor.html](http://developer.android.com/reference/android/hardware/Sensor.html).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 从`SensorManager`和`Sensor`在`onCreate()`方法中的设置方式来看，很明显所有传感器都以相同的方式访问，并且可以通过不同的常量访问不同的传感器。在这里我们使用了`TYPE_HEART_RATE`，但任何其他传感器都可以使用适当的常量启动，所有传感器都可以使用我们在这里找到的相同的基本结构来管理，唯一的真正区别是每个传感器返回`SensorEvent.values[]`的方式。所有传感器的完整列表及其产生的值的描述可以在[http://developer.android.com/reference/android/hardware/Sensor.html](http://developer.android.com/reference/android/hardware/Sensor.html)找到。
- en: As with any time our apps utilize functions that run in the background, it is
    vital that we unregister our listeners, whenever they are no longer needed, in
    our Activity's `onPause()` method. We didn't use the `onAccuracyChanged()` callback
    here, but its purpose should be clear and there are many possible apps where its
    use is essential.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的应用在任何时候利用后台运行的功能一样，我们至关重要地需要在Activity的`onPause()`方法中注销我们的监听器，无论何时它们不再需要。在这里我们没有使用`onAccuracyChanged()`回调，但它的目的应该是清晰的，并且有许多可能的应用需要其使用。
- en: This concludes our exploration of wearable apps and how they are put together.
    Such devices continue to become more prevalent and the possibility of ever more
    imaginative uses is endless. Providing we consider why and how people use smart
    watches, and the like, and develop to take advantage of the location of these
    devices by programming glanceable interfaces that require the minimum of interactivity,
    Android Wear seems certain to grow in popularity and use, and the developers will
    continue to produce ever more innovative apps.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们对可穿戴应用及其构建方式的探索结束。这类设备继续变得越来越普遍，而且更多富有创意的使用方式的可能性是无限的。只要我们考虑人们为什么以及如何使用智能手表等设备，并通过编程实现需要最小交互性的可查看界面来利用这些设备的地理位置，Android
    Wear似乎注定会越来越受欢迎和使用，开发者也将继续生产出更多创新的应用。
- en: Android TV
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android TV
- en: At the opposite end of the size spectrum to Android Wear, is Android TV. Like
    Wear, the size of this form factor is all important, when it comes to how we design
    apps for it. The main consideration is the distance the user is from the screen,
    which is usually around 10 feet. This means designing simple and clean layouts
    and avoiding small and/or lengthy text.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 与Android Wear相比，Android TV位于大小谱的另一端。就像Wear一样，当我们为这种形态设计应用时，其大小至关重要。主要考虑因素是用户与屏幕的距离，这通常在10英尺左右。这意味着设计简单、干净的布局，并避免使用小而/或长的文本。
- en: Unlike Wear, many of the apps we design for phones and tablets can be made available
    for TVs as well. As one would imagine, this requires some fiddling around with
    the manifest, so as to make our apps visible to users searching for TV-specific
    apps in the Google Play store. Also, TVs do not have many of the functions that
    our phones do, such as GPS and touchscreens, and we need to take this into consideration
    as well.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 与Wear不同，我们为手机和平板电脑设计的许多应用也可以提供给电视。正如人们所想象的那样，这需要我们对清单进行一些调整，以便让我们的应用在Google
    Play商店中可见，供搜索特定电视应用的用户使用。此外，电视没有我们手机上的一些功能，如GPS和触摸屏，我们也需要考虑这一点。
- en: The TV app template generated by the project wizard in Android Studio has bugs,
    and unless Google have fixed it by the time you read this, it is far from straightforward
    to use it to generate a working app. It is still worth taking a look though, as
    the Java directory contains over a dozen purpose-built classes that are very handy
    for apps designed for streaming and broadcasting television shows and the like.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio中由项目向导生成的电视应用模板存在bug，除非谷歌在你阅读此内容时已经修复了它，否则使用它来生成一个可工作的应用远非直截了当。尽管如此，它仍然值得一看，因为Java目录中包含十几个专为流媒体和电视节目等应用设计的类，这些类非常方便。
- en: The fact that the template does not work, is actually a good thing in our case,
    as we can use this section to see how to build a TV-compatible app from scratch
    or, if you prefer, how to convert an already developed app so that it is available
    to install on an Android TV.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 模板无法工作的事实，在我们的情况下实际上是一件好事，因为我们可以利用这个部分来了解如何从头开始构建一个兼容电视的应用程序，或者如果您愿意，如何将已经开发的应用程序转换为可以在Android
    TV上安装的形式。
- en: The following exercise can be carried out using a blank activity template for
    a phone and a tablet or any app you have developed.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下练习可以使用空白活动模板进行，适用于手机和平板电脑或您已经开发的应用程序。
- en: Open your project's manifest file.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您项目的清单文件。
- en: 'Inside the root manifest node, add these permissions:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根清单节点内部，添加以下权限：
- en: '[PRE19]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the same node, add these feature uses:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一节点中添加以下功能使用：
- en: '[PRE20]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Find or create a 320 x 180 px `xhdpi` banner image to represent your app. Ideally,
    it should contain text as well as an identifiable image, such as the following:![Android
    TV](img/B04321_08_11.jpg)
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到一个或创建一个320 x 180 px的`xhdpi`横幅图像来代表您的应用程序。理想情况下，它应该包含文本以及一个可识别的图像，如下所示：![Android
    TV](img/B04321_08_11.jpg)
- en: Place the image in your `drawable` folder, and call it `banner`.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图像放置在您的`drawable`文件夹中，并命名为`banner`。
- en: 'Add the following line inside the application node:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序节点内部添加以下行：
- en: '[PRE21]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Open your `build.gradle` file and add this dependency:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的`build.gradle`文件并添加以下依赖项：
- en: '[PRE22]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Back in the manifest, change the theme declaration line to the following:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在清单文件中，将主题声明行更改为以下内容：
- en: '[PRE23]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Create a TV AVD and test the app.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个电视AVD并测试应用程序。
- en: Although, we have not had to do very much here, there is still quite a lot to
    explain. Most of what we have done, is to make sure that our app is visible when
    browsing the Play store for TV apps. TVs do not support portrait screen layouts,
    so if this feature is required, it will simply not appear in the Play store as
    available for TV. We want to include the feature for devices that do support this
    orientation, and this is how we do that and still make our app available to TV
    users. We have to include the permission to record audio with all TV apps, but
    TVs do not generally support microphones.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在这里我们并没有做很多，但还有很多东西需要解释。我们大部分的工作都是为了确保我们的应用程序在浏览Play商店的电视应用程序时是可见的。电视不支持纵向屏幕布局，因此如果需要此功能，它将简单地不会出现在Play商店中作为电视可用。我们希望包括支持此方向设备的特性，这就是我们如何做到这一点，同时仍然使我们的应用程序对电视用户可用。我们必须在所有电视应用程序中包含录制音频的权限，但电视通常不支持麦克风。
- en: The **Leanback Support Library** that we added in step 7 is a very useful tool
    for developing for TV. It provides a very suitable theme, `Theme.Leanback`, several
    useful widgets designed for TV, and it manages margins in such a way that our
    layout is not clipped. Without it, we would have to set wide margins of about
    10 percent to avoid this kind of TV over-scanning. If we wanted to write specifically
    for TV, we would also have changed the category inside our main activity's intent
    filter to `<category android:name="android.intent.category.LEANBACK_LAUNCHER"
    />`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第7步中添加的**Leanback支持库**是开发电视应用程序的一个非常有用的工具。它提供了一个非常合适的主题`Theme.Leanback`，几个专为电视设计的实用小部件，并且以这种方式管理边距，以确保我们的布局不会被裁剪。如果没有它，我们可能需要设置大约10%的宽边距来避免这种电视过度扫描。如果我们想专门为电视编写，我们也会更改主活动意图过滤器内的类别`<category
    android:name="android.intent.category.LEANBACK_LAUNCHER" />`。
- en: There is quite a lot more to programming for Android TV, especially when it
    comes to broadcasting and streaming, that we cannot cover here. Generally speaking
    though, developing TV apps requires the same skills as programming for handheld
    devices and many apps run perfectly well on both formats. Providing we take into
    account the distance the user is from the screen and the limited input methods,
    we can write programs that provide a satisfying experience across all platforms.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Android TV的编程，尤其是广播和流媒体方面，还有很多内容我们在这里无法涵盖。不过，一般来说，开发电视应用程序所需的技能与手持设备编程相同，许多应用程序在两种格式上都能运行得很好。只要我们考虑到用户与屏幕的距离以及有限的输入方式，我们就可以编写出能够在所有平台上提供满意体验的程序。
- en: The Android OS is a very flexible system and well suited to a wide variety of
    form factors. We've seen how it can run on screens as small as an inch and a half
    or as large as a home cinema. Android Lollipop heralded yet another new and exciting
    platform, allowing users to run Android apps when they are out in their cars.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Android操作系统是一个非常灵活的系统，非常适合各种形态。我们已经看到它可以在半英寸到家庭影院大小的屏幕上运行。Android Lollipop预示着另一个新的令人兴奋的平台，允许用户在驾驶汽车时运行Android应用程序。
- en: Android Auto
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android Auto
- en: 'Android Auto apps are apps that, when connected to a compatible car dashboard,
    run certain restricted content on the driver''s dashboard. When developing for
    cars, the primary concern has to be safety and no Auto app that does not meet
    these strict standard will not be published on the Play store. Many Android apps
    are far too distracting to be suitable for use when driving. In fact, Android
    Auto really only supports two functions: audio playback and text-to-speech messaging.
    It is beyond the scope of this book to explore this comprehensively, but this
    is certainly a good time to see how such apps are set up and how to use the media
    and messaging simulators provided in the SDK. First though, we need to take a
    look at the safety rules insisted on by Google for Auto apps:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Android Auto应用是在连接到兼容的车载仪表盘时，在驾驶员仪表盘上运行某些受限内容的应用。当为汽车开发时，主要关注的是安全，任何不符合这些严格标准的Auto应用都不会在Play商店发布。许多Android应用在驾驶时过于分散注意力，不适合使用。实际上，Android
    Auto真正支持的功能只有两个：音频播放和文本到语音消息。本书的范围不涉及这一方面的全面探讨，但这是一个很好的时机来了解这类应用的设置方式以及如何使用SDK中提供的媒体和消息模拟器。首先，我们需要看看谷歌对Auto应用坚持的安全规则：
- en: There must be no animated elements on the Auto screen
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在自动屏幕上不得有动画元素
- en: Only audio ads are allowed
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只允许音频广告
- en: Apps must support voice control
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用必须支持语音控制
- en: All buttons and clickable controls must respond within two seconds
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有按钮和可点击控件必须在两秒内响应用户操作
- en: Text must be longer than 120 characters and must always be in the default Roboto
    font
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本必须超过120个字符，并且必须始终使用默认的Roboto字体
- en: Icons must be white, so that the system can control contrast
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图标必须是白色，以便系统可以控制对比度
- en: Apps must support day and night mode
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用必须支持日间和夜间模式
- en: App must support voice commands
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用必须支持语音命令
- en: App-specific buttons must respond to user actions with no more than a two-second
    delay
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用特定的按钮必须以不超过两秒的延迟响应用户操作
- en: 'IMPORTANT: These, and several other stipulations, will be tested by Google
    before publication, so it is essential that you run all of these tests yourself.
    The full list can be found at [http://developer.android.com/distribute/essentials/quality/auto.html](http://developer.android.com/distribute/essentials/quality/auto.html).'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 重要：这些以及其他一些规定，在发布前将由谷歌进行测试，因此您自己运行所有这些测试至关重要。完整列表可以在[http://developer.android.com/distribute/essentials/quality/auto.html](http://developer.android.com/distribute/essentials/quality/auto.html)找到。
- en: Tip
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Designing apps that are suitable for day and night modes and that can have contrast
    controlled by the system to automatically remain readable in different light conditions,
    is quite a detailed subject and Google has produced a very useful guide to this,
    which can be found at [http://commondatastorage.googleapis.com/androiddevelopers/shareables/auto/AndroidAuto-custom-colors.pdf](http://commondatastorage.googleapis.com/androiddevelopers/shareables/auto/AndroidAuto-custom-colors.pdf).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 设计适合日间和夜间模式的应用，并且可以通过系统自动在不同光照条件下保持可读性，这是一个相当详细的主题，谷歌为此提供了一份非常有用的指南，可以在[http://commondatastorage.googleapis.com/androiddevelopers/shareables/auto/AndroidAuto-custom-colors.pdf](http://commondatastorage.googleapis.com/androiddevelopers/shareables/auto/AndroidAuto-custom-colors.pdf)找到。
- en: 'Despite the restrictions we have covered Auto apps are developed in the same
    way as any other. There is one minor difference though, when developing for Auto,
    we need to define which in-car capabilities our app is using. This is done using
    an XML file. Follow these short steps, to see how:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们有这些限制，但Auto应用的开发方式与其他应用相同。不过有一个小差别，当为Auto开发时，我们需要定义我们的应用使用哪些车载功能。这是通过一个XML文件来完成的。按照以下简短的步骤，看看如何操作：
- en: Start a new Android Studio project for phone and tablet, or open an existing
    one.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为手机和平板电脑启动一个新的Android Studio项目，或者打开一个现有的项目。
- en: Create a new **Android resource directory** inside the `res` directory and call
    it `xml`.![Android Auto](img/B04321_08_12.jpg)
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`res`目录内创建一个新的**Android资源目录**，并命名为`xml`。![Android Auto](img/B04321_08_12.jpg)
- en: Inside this `xml` folder, create a new Android resource file and call it something
    like `auto_config.xml`.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个`xml`文件夹内，创建一个新的Android资源文件，并命名为类似`auto_config.xml`。
- en: 'Complete it as follows:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式完成：
- en: '[PRE24]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Open the manifest file.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开清单文件。
- en: 'Add these lines inside the `application` node:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`application`节点内添加以下行：
- en: '[PRE25]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: That's it, our app will now detect whether its host device is connected to a
    car dashboard.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就这样，我们的应用现在将检测其宿主设备是否连接到车载仪表盘。
- en: There are just two things here that need to be pointed out here. The two named
    uses are for running audio playback apps and receiving messages respectively.
    We would only need both, if our app was designed for both functions.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这里只需指出两点。这两个名称用途分别是用于运行音频播放应用和接收消息。只有当我们的应用被设计为同时具备这两个功能时，我们才需要两者。
- en: 'Google provide simulators for testing both media browsing and messaging apps,
    letting us test projects from the safety of a desk. The following steps demonstrate
    how to install them and use a telnet connection to send dummy SMS messages:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Google 为测试媒体浏览和消息应用提供了模拟器，让我们可以在桌面上安全地测试项目。以下步骤演示了如何安装它们以及如何使用 telnet 连接发送模拟短信：
- en: From Android studio, open the SDK Manager.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Android Studio 中打开 SDK 管理器。
- en: Make sure you have the latest versions of the Android Auto API Simulators, which
    are in the `Extras` folder.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你有最新的 Android Auto API 模拟器版本，它们位于 `Extras` 文件夹中。
- en: Connect a device or an emulator.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接一个设备或模拟器。
- en: Go to your `sdk/extras/google/simulators` folder and open the command window
    there, with *Shift* + right-click.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往你的 `sdk/extras/google/simulators` 文件夹，并在此处使用 *Shift* + 右键点击打开命令窗口。
- en: Check that your device is connected with `adb devices`.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `adb devices` 检查你的设备是否已连接。
- en: 'Enter these two commands to install both simulators:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下两个命令来安装这两个模拟器：
- en: '[PRE26]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Tip
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you are using a third party virtual device, such as Genymotion, you will
    be able to install these apps by dragging and dropping them onto the emulator's
    screen.
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你使用的是第三方虚拟设备，例如 Genymotion，你将能够通过将它们拖放到模拟器屏幕上来安装这些应用。
- en: Installing the simulators with an `adb` command is very simple, and of course
    any .`apk` file can be installed this way to a connected device. The media browser
    simulator can be tested with most media services such as Play Music.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `adb` 命令安装模拟器非常简单，当然，任何 `.apk` 文件都可以通过这种方式安装到已连接的设备上。媒体浏览器模拟器可以用大多数媒体服务进行测试，例如
    Play Music。
- en: '![Android Auto](img/B04321_08_13.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![Android Auto](img/B04321_08_13.jpg)'
- en: Text can be sent to the messaging simulator by launching the **Android Device
    Monitor** from the **Emulator Control** tab.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过从 **Emulator Control** 选项卡启动 **Android Device Monitor** 来向消息模拟器发送文本。
- en: That's about as much as we can cover of Android Auto here. The platform provides
    some of the most exciting new possibilities offered by Lollipop, and no doubt
    Android will be found in more and more vehicles in the future.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在 Android Auto 中能涵盖的所有内容。该平台提供了 Lollipop 提供的最激动人心的新可能性之一，毫无疑问，Android 将在未来越来越多地出现在车辆中。
- en: Summary
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Android Wear, TV, and Auto represent radical departures from traditional form
    factors and are equally different from each other. This means that we have had
    to cover a lot of varied ground here.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Android Wear、TV 和 Auto 与传统形态有根本性的不同，彼此之间也完全不同。这意味着我们在这里必须涵盖很多不同的领域。
- en: Despite their diminutive size and functionality, wearables offer us an enormous
    range of possibilities. We know now how to create and connect wearable AVDs and
    how to develop easily for both square and round devices. We then went on to see
    what is required to set up a TV app, how to convert existing apps to be available
    on TV and about the useful library and features provided by Leanback support.
    We concluded by exploring the stringent safety rules that must be applied when
    developing and the tools available for testing Auto on.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们的体积和功能相对较小，但可穿戴设备为我们提供了巨大的可能性。我们现在知道如何创建和连接可穿戴 AVD，以及如何轻松地为方形和圆形设备开发。然后我们探讨了设置
    TV 应用所需的条件，如何将现有应用转换为可在电视上使用，以及 Leanback 支持提供的有用库和功能。我们最后探讨了在开发过程中必须遵守的严格安全规则，以及用于测试
    Auto on 的工具。
- en: One of the biggest overhauls, although perhaps less visible to the user, involves
    the camera APIs. These are entirely new to Lollipop and these along with adding
    multimedia to our apps is what we will move on to in the next chapter.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的改进之一，尽管可能对用户来说不太明显，涉及相机 API。这些 API 对 Lollipop 来说是全新的，而且添加多媒体到我们的应用也是我们在下一章将要讨论的内容。
