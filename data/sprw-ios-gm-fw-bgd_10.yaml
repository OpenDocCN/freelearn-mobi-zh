- en: Chapter 10. Polishing Our Game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。润色我们的游戏
- en: '*In the previous chapter, we added sound and music to our game. We also learned
    about audio file formats and even how to generate our own sound effects.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*在上一章中，我们为游戏添加了声音和音乐。我们还学习了音频文件格式，甚至如何生成我们自己的音效。*'
- en: 'In this chapter, we are going to polish our game. We will be covering the following
    topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将润色我们的游戏。在本章中，我们将涵盖以下主题：
- en: Improving the game over mechanism
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进游戏结束机制
- en: Adding a minimalistic tutorial
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个简约的教程
- en: Loading and saving the current state of the game
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载和保存当前游戏状态
- en: Polishing is the process of giving the last finishing touches to the game. There
    is a saying in software development that the last 20 percent of the development
    feels as hard as the first 80 percent. With such motivation, let's polish our
    game, shall we?
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 磨光是对游戏进行最后润色处理的过程。在软件开发中有一句话，即开发的最后20%感觉和最初的80%一样困难。有了这样的动力，让我们来润色我们的游戏，怎么样？
- en: Adding additional scenes
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加额外的场景
- en: Our game still feels rough around the edges. Our first order of business is
    to add more scenes, which should make the game feel more rounded, especially when
    starting the game and when the game is over.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏仍然感觉边缘粗糙。我们的首要任务是添加更多场景，这应该使游戏感觉更加完整，尤其是在开始游戏和游戏结束时。
- en: The game over scene
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏结束场景
- en: Currently, the game over mechanism is a bit too minimalistic. While the player
    can lose and win the game, they can't restart the game once it is over. The player
    needs to shut down the application and open it again.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，游戏结束机制有点过于简约。虽然玩家可以输赢游戏，但一旦游戏结束，他们就不能重新开始游戏。玩家需要关闭应用程序并重新打开。
- en: This is counterintuitive as the default behavior of iOS apps is to freeze the
    app instead of shutting it down. So in the worst case, our game with the **Game
    Over** message stays in the memory until the device is rebooted or the user kills
    the application from the app switcher.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这与直觉相反，因为iOS应用的默认行为是冻结应用而不是关闭它。所以，在最坏的情况下，带有**游戏结束**信息的我们的游戏将停留在内存中，直到设备重启或用户从应用切换器中杀死应用程序。
- en: Creating the game over scene
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建游戏结束场景
- en: As our first task, we are going to decouple the game over logic and move it
    into a separate scene. Our game over scene should show whether the game was won
    or lost.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们的第一个任务，我们将解耦游戏结束逻辑并将其移动到单独的场景中。我们的游戏结束场景应该显示游戏是赢了还是输了。
- en: Time for action – showing the game over scene
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 显示游戏结束场景
- en: 'Use the following steps to create the game over scene:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下步骤创建游戏结束场景：
- en: Open our Xcode project if it's not already open.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果还没有打开，请打开我们的Xcode项目。
- en: Create a new Objective-C class inside the `GameScenes` group.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GameScenes`组内创建一个新的Objective-C类。
- en: Call this class `GameOver` it should be a subclass of `Scene`.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个类命名为`GameOver`，它应该是`Scene`的子类。
- en: Switch to the `GameOver.h` file.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`GameOver.h`文件。
- en: 'Using the following line of code, add a property called `message`:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码行，添加一个名为`message`的属性：
- en: '[PRE0]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Using the following line of code, add another property to indicate whether
    the game was won:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码行，添加另一个属性以指示游戏是否赢了：
- en: '[PRE1]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Switch to `GameOver.m`.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`GameOver.m`。
- en: 'Import the `SceneDirector.h`, `Assets.h`, and the `World.h` files, as shown
    in the following code:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下代码导入`SceneDirector.h`、`Assets.h`和`World.h`文件：
- en: '[PRE2]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add an initializer for this new scene, as shown in the following code:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为这个新场景添加一个初始化器，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add a getter for the `gameWon` property, as shown in the following code:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`gameWon`属性的getter，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, add the setter for the `gameWon` property, as shown in the following code:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加`gameWon`属性的setter，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Switch to `Game.m`.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`Game.m`。
- en: 'Import the `GameOver.h` file using the following line of code:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码行导入`GameOver.h`文件：
- en: '[PRE6]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, create an instance of the `GameOver` scene using the following code:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用以下代码创建`GameOver`场景的一个实例：
- en: '[PRE7]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the game over instance to the scene director using the following code:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码将游戏结束实例添加到场景导演中：
- en: '[PRE8]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Show the game over scene by default using the following line of code:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码行默认显示游戏结束场景：
- en: '[PRE9]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Run the example and we will see the game over scene, as shown in the following
    screenshot:![Time for action – showing the game over scene](img/1509OS_10_01.jpg)
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例，我们将看到游戏结束场景，如下面的截图所示：![行动时间 – 显示游戏结束场景](img/1509OS_10_01.jpg)
- en: '*What just happened?*'
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: As we have done before, we opened our Xcode project. Then, we created a class,
    which is going to be our game over scene. It's called `GameOver` and is a subclass
    of `Scene`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所做的那样，我们打开了我们的Xcode项目。然后，我们创建了一个类，这个类将成为我们的游戏结束场景。它被命名为`GameOver`，是`Scene`的子类。
- en: In the `GameOver` header file, we added two properties in step 5 and 6, respectively.
    The first property is the message that will be displayed on the screen. The second
    is to indicate whether the game was won. We added a custom getter and setter for
    this property later on. We marked this property as non-atomic, as we don't really
    need thread safety and we used only one thread anyway.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GameOver`头文件中，我们在第5步和第6步分别添加了两个属性。第一个属性是将在屏幕上显示的消息。第二个是用来指示游戏是否获胜。稍后我们为这个属性添加了自定义的getter和setter。我们将这个属性标记为非原子性，因为我们实际上不需要线程安全，而且我们只使用了一个线程。
- en: 'In the `GameOver.m` file, we imported all the necessary headers, which are
    as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GameOver.m`文件中，我们导入了所有必要的头文件，如下所示：
- en: The asset manager from `Assets.h`, as it is most likely that we load an asset
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`Assets.h`中的资源管理器，因为我们很可能要加载一个资源
- en: The scene director from `SceneDirector.h`, because we need to switch to another
    scene
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`SceneDirector.h`中的场景导演，因为我们需要切换到另一个场景
- en: The `World` class from `World.h`, as we need to reset our in-game values
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`World.h`中的`World`类，因为我们需要重置游戏中的值
- en: 'Then, we added the initializer. Our game over scene consists of the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加了初始化器。我们的游戏结束场景由以下内容组成：
- en: Water as the background
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以水作为背景
- en: The text field which is the `message` property
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为`message`属性的文本字段
- en: The reset button
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重置按钮
- en: In this example, we used the `SPTextField` factory method (also known as a convenience
    constructor) that lets us define the width, height, text, font name, font size,
    and color in a single step. One thing we need to consider is to keep the font
    size similar to the original bitmap font size. If it's much bigger than the original
    size, the font gets all pixelated and washed out.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了`SPTextField`工厂方法（也称为便利构造函数），它允许我们在一步中定义宽度、高度、文本、字体名称、字体大小和颜色。我们需要考虑的一件事是保持字体大小与原始位图字体大小相似。如果它比原始大小大得多，字体就会变得像素化并且模糊不清。
- en: 'There is a way to get around this though: if we set `SP_NATIVE_FONT_SIZE` as
    the font size for the font instance, it will automatically calculate its actual
    size so that it is displayed as sharp as possible.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，有一种方法可以绕过这个问题：如果我们将`SP_NATIVE_FONT_SIZE`设置为字体实例的字体大小，它将自动计算其实际大小，以便尽可能清晰地显示。
- en: We defined the touch event for the reset button as a block and reset all of
    our in-game values and switched to the pirate cove scene. After this, we added
    all of our display objects to the display tree.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重置按钮的触摸事件定义为块，并重置所有游戏中的值，并切换到海盗湾场景。之后，我们将所有显示对象添加到显示树中。
- en: 'Then, we defined our custom getter and setter for our `gameWon` property:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为我们的`gameWon`属性定义了自定义的getter和setter：
- en: '**Getter**: This simply returns the internal `_gameWon` value'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Getter**：这仅仅返回内部的`_gameWon`值'
- en: '**Setter**: After we set the property value, we updated the message depending
    on its value'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Setter**：在设置属性值后，我们根据其值更新了消息'
- en: In the `Game` class, we need to create an instance of the `GameOver` scene,
    which we then added to the scene director. In step 16, we updated the default
    scene to be the game over scene.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Game`类中，我们需要创建`GameOver`场景的实例，然后将其添加到场景导演中。在第16步中，我们将默认场景更新为游戏结束场景。
- en: When we ran the example in the last step, we saw the game over scene.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行上一步的示例时，我们看到了游戏结束场景。
- en: Connecting the game over scene
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接游戏结束场景
- en: Now that we have our game over scene, let's integrate it into the game.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了游戏结束场景，让我们将其集成到游戏中。
- en: Time for action – having the game over scene show up
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候让游戏结束场景出现了
- en: 'To incorporate the game over scene into the game, use the following steps:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要将游戏结束场景纳入游戏，请按照以下步骤操作：
- en: Switch to the `Battlefield.h` file.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`Battlefield.h`文件。
- en: Remove both the `textGameWon` and `textGameLost` properties.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`textGameWon`和`textGameLost`这两个属性。
- en: Switch to the `Battlefield.m` file.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`Battlefield.m`文件。
- en: Remove all references to the `textGameWon` and `textGameLost` properties.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除对`textGameWon`和`textGameLost`属性的任何引用。
- en: 'In the `GameOver.m` file, add a `reset` method using the following code:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GameOver.m`文件中，添加一个`reset`方法，如下所示：
- en: '[PRE10]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the `SceneDirector.h` file, add a property called `currentScene` using the
    following code:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SceneDirector.h`文件中，使用以下代码添加一个名为`currentScene`的属性：
- en: '[PRE11]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the `SceneDirector.m` file, update the `showScene` method to set the `currentScene`
    property, as shown in the following code:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SceneDirector.m` 文件中，更新 `showScene` 方法以设置 `currentScene` 属性，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Switch to the `Battlefield.m` file.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到 `Battlefield.m` 文件。
- en: 'Update the `reset` method to set the visibility of the ships, as shown in the
    following code:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `reset` 方法以设置船只的可见性，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Update the condition to win the game, as shown in the following code:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新胜利游戏的条件，如下面的代码所示：
- en: '[PRE14]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, update the condition to lose the game, as shown in the following code:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，更新游戏失败的条件，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In `Game.m`, change the default scene back to the pirate cove.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Game.m` 中，将默认场景切换回海盗湾。
- en: Run the example. When we run the example and once we actually lose the game,
    we see the following screen:![Time for action – having the game over scene show
    up](img/1509OS_10_02.jpg)
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例。当我们运行示例并实际输掉游戏时，我们会看到以下屏幕：![行动时间 – 游戏结束场景出现](img/1509OS_10_02.jpg)
- en: '*What just happened?*'
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: In the `Battlefield` header file, we removed the text field properties that
    show up when the game was won or lost. Then, we removed all code portions that
    reference these properties in `Battlefield.m`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Battlefield` 头文件中，我们移除了显示游戏胜利或失败时出现的文本字段属性。然后，我们在 `Battlefield.m` 中移除了所有引用这些属性的代码部分。
- en: In step 5, we added a `reset` method for our `GameOver` scene, where we set
    the `gameWon` property to `NO`. The difference between this scene switch is that
    we need to set the `gameWon` property after the scene has been switched. In order
    to facilitate this, we updated the scene director.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 5 步中，我们为 `GameOver` 场景添加了一个 `reset` 方法，其中我们将 `gameWon` 属性设置为 `NO`。与场景切换的区别在于，我们需要在场景切换后设置
    `gameWon` 属性。为了方便这一操作，我们更新了场景导演。
- en: In the next step, we added a read-only property called `currentScene` that gives
    us a reference to the current scene. After this, we updated the `showScene` method
    to set the current scene. This happened right after we set the current scene to
    be visible and called the `reset` method.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们添加了一个只读属性 `currentScene`，它为我们提供了对当前场景的引用。在此之后，我们更新了 `showScene` 方法以设置当前场景。这发生在我们将当前场景设置为可见并调用
    `reset` 方法之后。
- en: In the battlefield scene, we first updated the visibilities of our ships. If
    we hadn't done this, the enemy ships would stay visible even after we reset the
    game.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在战场场景中，我们首先更新了我们的船只的可见性。如果我们没有这样做，敌军船只即使在重置游戏后仍然可见。
- en: In steps 10 and 11, we updated the win and lose conditions. We imported the
    `GameOver.h` file here as well, in order to cast the `currentScene` property to
    a pointer to the `GameOver` class.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 10 步和第 11 步中，我们更新了胜利和失败的条件。在这里，我们也导入了 `GameOver.h` 文件，以便将 `currentScene`
    属性转换为指向 `GameOver` 类的指针。
- en: The last thing we did was change back to the pirate cove scene. When we ran
    the example and when we lost or won the game, the game over scene was shown and
    we were able to restart the game.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后做的事情是将场景切换回海盗湾。当我们运行示例，无论我们输赢游戏，都会显示游戏结束场景，并且我们可以重新开始游戏。
- en: Adding a main menu
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加主菜单
- en: Next, we are going to add a simple main menu.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个简单的主菜单。
- en: Time for action – integrating the main menu into our game
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 将主菜单集成到我们的游戏中
- en: 'Use the following steps to add a main menu:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下步骤添加主菜单：
- en: Add a new class called `MainMenu` which should be a subclass of `Scene`.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `MainMenu` 的新类，它应该是 `Scene` 的子类。
- en: Switch to `MainMenu.m`.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到 `MainMenu.m`。
- en: Import `Assets.h` and `SceneDirector.h`.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `Assets.h` 和 `SceneDirector.h`。
- en: 'Add the initializer for the main menu, as shown in the following code:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加主菜单的初始化器，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Switch to `Game.m`.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到 `Game.m`。
- en: 'Import `MainMenu.h` using the following line of code:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码导入 `MainMenu.h`：
- en: '[PRE17]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Using the following code, create a local variable for the main menu that will
    hold an instance of the `MainMenu` class.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码为 `MainMenu` 类创建一个局部变量，该变量将保存一个 `MainMenu` 类的实例。
- en: '[PRE18]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add the `mainMenu` instance to the director, as shown in the following code:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `mainMenu` 实例添加到导演中，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Update the `showScene` call to the main menu scene, as shown in the following
    code:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `showScene` 调用以显示主菜单场景，如下面的代码所示：
- en: '[PRE20]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Run the example and we will see the main menu, as shown in the following screenshot:![Time
    for action – integrating the main menu into our game](img/1509OS_10_03.jpg)
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例，我们将看到主菜单，如下面的截图所示：![行动时间 – 将主菜单集成到我们的游戏中](img/1509OS_10_03.jpg)
- en: '*What just happened?*'
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: To add a main menu, we needed a class subclassed from `Scene`. Once the class
    was created, we imported the asset management system and the scene director.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加主菜单，我们需要一个从 `Scene` 继承的类。一旦创建了类，我们就导入了资产管理系统和场景导演。
- en: 'In step 3, we added the initializer. Our main menu consists of the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 3 中，我们添加了初始化器。我们的主菜单包括以下内容：
- en: The same background that we used in the battlefield and other scenes
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与战场和其他场景中使用的相同背景
- en: A pirate ship
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一艘海盗船
- en: A button to start a new game
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个启动新游戏的按钮
- en: A button to continue the game
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个继续游戏的按钮
- en: For the new game, we used a block for its touch event, which switches to the
    pirate cove scene. The **Continue** button does not have an event yet and is disabled.
    After this, we need to take all our elements to the display tree.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于新游戏，我们使用了一个用于触摸事件的块，它切换到海盗湾场景。**继续**按钮还没有事件并且被禁用。在此之后，我们需要将所有元素添加到显示树中。
- en: In steps 5 to 9, we added the main menu to our game class in a manner similar
    to how we added the game over scene.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 5 到 9 中，我们以类似于添加游戏结束场景的方式将主菜单添加到我们的游戏类中。
- en: When we ran the example, we saw the main menu.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行示例时，我们看到了主菜单。
- en: Have a go hero
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 来试试英雄
- en: The main menu now only has two buttons. Typically, a main menu offers a bit
    more than this such as buttons to switch to the options menu or the credits screen.
    In some instances, the main menu even has buttons to navigate to social sites.
    Go ahead and add the options and credits screens, which can be opened from the
    main menu.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在主菜单只有两个按钮。通常，主菜单会提供更多选项，例如切换到选项菜单或信用屏幕的按钮。在某些情况下，主菜单甚至有按钮可以导航到社交网站。现在添加选项和信用屏幕，这些可以从主菜单打开。
- en: Adding an intro scene
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加开场场景
- en: An intro scene is a perfect way to introduce the player to the characters, the
    story or the art style of a game. An intro is not necessary for all games; in
    fact, it's best used if it fits into the overall game and style of the game.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一个开场场景是向玩家介绍游戏角色、故事或艺术风格的完美方式。并非所有游戏都需要开场场景；实际上，如果它适合整体游戏和游戏风格，那么使用它是最合适的。
- en: As we don't have a story or characters, we are going to show two ships moving
    near each other, shooting each other, and eventually one of the ships sinks.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有故事或角色，我们将展示两艘船相互靠近、相互射击，最终其中一艘船沉没。
- en: Time for action – creating an intro for our game
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候为我们的游戏创建一个开场了
- en: 'Use the following steps to add the intro scene:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下步骤添加开场场景：
- en: This is as good a time as any to move the collision detection code into a separate
    file. Create a new group called `Logic` and add a class inside this group called
    `Collision` which is a subclass of `NSObject`.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候将碰撞检测代码移动到单独的文件中了。创建一个名为 `Logic` 的新组，并在该组内添加一个名为 `Collision` 的类，它是 `NSObject`
    的子类。
- en: 'Declare this static method in the `Collision` class, as shown in the following
    code:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Collision` 类中声明此静态方法，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Inside `Collision.m`, implement the `checkShipCollision` method with the following
    lines of code:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Collision.m` 文件中，使用以下代码实现 `checkShipCollision` 方法：
- en: '[PRE22]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In order for this code to work, we need to import `Assets.h` and `World.h` in
    the `Collision.m` file.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使此代码工作，我们需要在 `Collision.m` 文件中导入 `Assets.h` 和 `World.h`。
- en: 'In `Battlefield.m`, delete the collision code, import `Collision.h`, and use
    the new method from the `Collision` class now:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Battlefield.m` 中，删除碰撞代码，导入 `Collision.h`，并使用 `Collision` 类的新方法：
- en: '[PRE23]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Add the intro scene by subclassing `Scene` and call it `Intro`. This should
    be done inside the `GameScenes` group.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过继承 `Scene` 并命名为 `Intro` 来添加开场场景。这应该在 `GameScenes` 组内完成。
- en: 'In `Intro.h`, import `Ship.h` and add two instance variables, one for the pirate
    ship and one for the enemy ship, as shown in the following code:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Intro.h` 中，导入 `Ship.h` 并添加两个实例变量，一个用于海盗船，一个用于敌船，如下面的代码所示：
- en: '[PRE24]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Switch to `Intro.m`.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到 `Intro.m`。
- en: 'Add an initializer for the `Intro` class with the help of the following code:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码为 `Intro` 类添加一个初始化器：
- en: '[PRE25]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add the event listener for `onEnterFrame`, as shown in the following code:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `onEnterFrame` 事件监听器，如下面的代码所示：
- en: '[PRE26]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add a reset method, as shown in the following code:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个重置方法，如下面的代码所示：
- en: '[PRE27]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In `MainMenu.m`, show the intro scene if the new game button has been touched.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainMenu.m` 中，如果新游戏按钮被触摸，则显示开场场景。
- en: In `Game.m`, import `Intro.h`, create an instance of the `Intro` class, and
    add it the director.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Game.m` 中，导入 `Intro.h`，创建 `Intro` 类的实例，并将其添加到导演中。
- en: Run the example.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例。
- en: 'When we start a new game, we see the intro in action, as shown in the following
    code:'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们开始新游戏时，我们看到简介正在运行，如下所示：
- en: '![Time for action – creating an intro for our game](img/1509OS_10_04.jpg)'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 – 为我们的游戏创建一个简介](img/1509OS_10_04.jpg)'
- en: '*What just happened?*'
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: As we needed the collision detection in both the intro and the game itself,
    we moved it into its own class. When we moved the checkShipCollision method, we
    added an additional parameter. This parameter was then passed as a reference to
    the `boundsInSpace` method. We imported the asset management and the `World` class
    for this code snippet to work.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要在简介和游戏本身中实现碰撞检测，我们将它移动到了自己的类中。当我们移动`checkShipCollision`方法时，我们添加了一个额外的参数。然后这个参数被作为引用传递给了`boundsInSpace`方法。为了使这段代码正常工作，我们导入了资产管理类和`World`类。
- en: In the next step, we updated the collision in the battlefield scene.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们更新了战场场景中的碰撞。
- en: 'We then added a new scene called `Intro`, where we first added two instance
    variables, one for our own ship and one for the pirate ship. In step 9, we added
    the initializer, which perform the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后添加了一个名为`Intro`的新场景，我们首先添加了两个实例变量，一个用于我们的船只，一个用于海盗船。在步骤9中，我们添加了初始化器，它执行以下操作：
- en: Add the water background
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加水背景
- en: Initialize both ship instances
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化两个船只实例
- en: Add a button to skip the intro
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个按钮来跳过简介
- en: We then added an event listener to skip the event listener and switch to the
    pirate cove scene. We also added an event listener for the enter frame event.
    We then added all elements to the display tree
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后添加了一个事件监听器来跳过事件监听器并切换到海盗湾场景。我们还添加了一个事件监听器用于进入帧事件。然后我们将所有元素添加到显示树中
- en: In step 10, we implemented the `onEnterFrame` event listener, which calls the
    collision method and advances the time of both ships.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤10中，我们实现了`onEnterFrame`事件监听器，它调用碰撞方法并推进两艘船的时间。
- en: The `reset` method calls the `reset` method of these ships and moves the ships
    to the center of the screen. The enemy ship can shoot only once, while the pirate
    ships can shoot multiple times to kill the enemy ship.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`reset`方法调用这些船只的`reset`方法，并将船只移动到屏幕中心。敌舰只能射击一次，而海盗船可以多次射击以击毁敌舰。'
- en: We showed the intro scene in the main menu. After this, we added the `Intro`
    class to the game class, and when we ran the example, we saw the intro scene when
    we started a new game.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在主菜单中展示了简介场景。之后，我们将`Intro`类添加到游戏类中，当我们运行示例时，我们在开始新游戏时看到了简介场景。
- en: Implementing tutorial mechanics
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现教程机制
- en: There are many different ways for tutorials to be implemented. It may range
    from just showing an image with controls, to having an interactive experience,
    to displaying a control scheme each time the player is about to perform an action.
    In general, the last two options could be achieved with a finite state machine,
    similar to the one we used for our artificial intelligence.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 实现教程有许多不同的方法。它可能只是显示一个带有控制器的图像，到拥有一个交互式体验，再到每次玩家即将执行动作时显示控制方案。一般来说，后两种选项可以通过有限状态机实现，类似于我们用于人工智能的那个。
- en: For our purposes, we will update the intro scene to display hints while the
    animation is playing.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们的目的，我们将更新简介场景，在动画播放时显示提示。
- en: Time for action – adding a tutorial to our intro scene
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 将教程添加到我们的简介场景
- en: 'Follow these steps to display hints during the intro:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在简介期间显示提示：
- en: 'In `Intro.h`, add an instance variable called message:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Intro.h`中添加一个名为`message`的实例变量：
- en: '[PRE28]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Switch to `Intro.m`.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`Intro.m`。
- en: 'Update the initializer with the help of the following code:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码更新初始化器：
- en: '[PRE29]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Update the `reset` method, as shown in the following code:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`reset`方法，如下所示：
- en: '[PRE30]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Run the example and when we see the intro, we now have hints displayed on the
    screen:![Time for action – adding a tutorial to our intro scene](img/1509OS_10_05.jpg)
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例，当我们看到简介时，我们现在在屏幕上看到了提示信息：![行动时间 – 将教程添加到我们的简介场景](img/1509OS_10_05.jpg)
- en: '*What just happened?*'
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We first added an instance variable to display our hints. We then updated the
    initializer to initialize this instance variable and have a black but slightly
    opaque background. We added these two elements to the display tree.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先添加了一个实例变量来显示我们的提示。然后我们更新了初始化器来初始化这个实例变量，并有一个黑色但略微不透明的背景。我们将这两个元素添加到显示树中。
- en: In step 4, we updated the `reset` method to change the text of the message to
    show how the core gameplay elements work.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤4中，我们更新了`reset`方法，以更改消息文本，显示核心游戏元素的工作方式。
- en: When we ran the example, the hints were displayed during the intro.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行示例时，在简介期间显示了提示。
- en: Loading and saving the current state
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载和保存当前状态
- en: So far we can play the game, but as soon as we end the game, we have to start
    the game from the beginning.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止我们可以玩游戏，但一旦游戏结束，我们必须从头开始玩游戏。
- en: Time for action – loading and saving the last played game
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候行动了——加载和保存最后玩的游戏
- en: 'Follow these steps to load and save the current state:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤加载和保存当前状态：
- en: 'In `World.h`, declare methods to serialize and deserialize data:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `World.h` 中声明序列化和反序列化数据的方法：
- en: '[PRE31]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Implement these serializers with the following lines of code:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码实现这些序列化器：
- en: '[PRE32]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In `MainMenu.m`, add `World.h` to the import section and update the initializer:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainMenu.m` 中，将 `World.h` 添加到导入部分并更新初始化器：
- en: '[PRE33]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In `AppDelegate.m`, we import `World.h` and add a new method, as shown in the
    following code:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `AppDelegate.m` 中，我们导入 `World.h` 并添加一个新方法，如下面的代码所示：
- en: '[PRE34]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Run the example to see the result. When we start the game, we can now continue
    the game:![Time for action – loading and saving the last played game](img/1509OS_10_06.jpg)
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例以查看结果。当我们开始游戏时，我们现在可以继续游戏：![是时候行动了——加载和保存最后玩的游戏](img/1509OS_10_06.jpg)
- en: '*What just happened?*'
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: First, we added the serializer and deserializer methods to our `World` class.
    The serializer takes values from the `World` class and places them in `NSDictionary`.
    The deserializer works the other way around. It takes values from `NSDictionary`
    and updates the values in the `World` class.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将序列化和反序列化方法添加到我们的 `World` 类中。序列化方法从 `World` 类中提取值并将它们放置在 `NSDictionary`
    中。反序列化方法则相反。它从 `NSDictionary` 中提取值并更新 `World` 类中的值。
- en: In the main menu scene, we checked whether there is already something saved
    and we deserialize the data in case there is any data. We added an event listener
    for our **Continue** button, which directly switches to the pirate cove scene.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在主菜单场景中，我们检查是否已经保存了某些内容，并在有数据的情况下反序列化数据。我们为我们的 **继续** 按钮添加了一个事件监听器，它直接切换到海盗湾场景。
- en: In step 4, we saved the game data once the application was not active any more.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 4 中，一旦应用程序不再活跃，我们就保存了游戏数据。
- en: When we ran the example, we were able to resume the game.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行示例时，我们能够继续游戏。
- en: Pop quiz
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速问答
- en: Q1\. When we override the font size for a bitmap font in SPTextField, it scales
    to that size.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 当我们在 SPTextField 中覆盖位图字体的大小时，它会缩放到那个大小。
- en: 'True'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是
- en: 'False'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否
- en: Q2\. When is it a good idea to encapsulate code snippets into their own class
    or methods?
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Q2. 什么情况下将代码片段封装到它们自己的类或方法中是一个好主意？
- en: Always, even if it's just used a single time
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 总是，即使只使用一次
- en: If the code snippet is being used multiple times
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果代码片段被多次使用
- en: Never
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从不
- en: Q3\. `NSUserDefaults` provides a way to store data.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Q3. `NSUserDefaults` 提供了一种存储数据的方式。
- en: 'True'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是
- en: 'False'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否
- en: Summary
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about polishing our game. Specifically, we covered
    adding more scenes such as a main menu and an intro, and we touched upon tutorial
    mechanics.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何润色我们的游戏。具体来说，我们涵盖了添加更多场景，如主菜单和简介，并简要介绍了教程机制。
- en: Now that our game almost feels like an actual game, let's see how we can integrate
    third-party services—which is the topic of the next chapter.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们几乎感觉我们的游戏就像一个真正的游戏，让我们看看我们如何集成第三方服务——这是下一章的主题。
