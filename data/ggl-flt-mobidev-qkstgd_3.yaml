- en: Widgets, Widgets Everywhere
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件，无处不在的组件
- en: In Flutter, the concept of widgets is very important. As stated in [Chapter
    1](6f964d6d-1e08-460b-9c4b-79023fa9816d.xhtml), *Introducing Flutter*, everything
    in Flutter is a widget. You might have a lot of questions about widgets, such
    as "What are the basic types of widgets?", "How do I create one?", "What are some
    good example of widgets?",and so on.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Flutter 中，组件的概念非常重要。正如 [第 1 章](6f964d6d-1e08-460b-9c4b-79023fa9816d.xhtml)
    中所述，*介绍 Flutter*，Flutter 中的所有内容都是一个组件。你可能会对组件有很多疑问，例如“组件的基本类型有哪些？”“我如何创建一个组件？”“有哪些好的组件示例？”等等。
- en: 'In this chapter, we will explore these questions together. We will first take
    a look at the widgets catalog and understand the fundamental widgets that will
    help you build apps with Flutter. We will also learn how to create custom widgets
    and then take a look at the concept of routing and navigating in a Flutter app.
    All of these topics will be covered in the following sections:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将一起探讨这些问题。我们首先将查看组件目录，了解将帮助你使用 Flutter 构建应用程序的基本组件。我们还将学习如何创建自定义组件，然后查看
    Flutter 应用程序中路由和导航的概念。所有这些主题将在以下章节中介绍：
- en: Widgets Catalog
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Widgets Catalog
- en: Creating widgets
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建组件
- en: Routing and navigation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由和导航
- en: Widgets Catalog
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Widgets Catalog
- en: The Flutter team built this very good website called the **Widgets Catalog** ([https://flutter.io/widgets/](https://flutter.io/widgets/))
    where you can explore the variety of components that already exist in Flutter,
    divided by category. You will be using a lot of these widgets in your applications,
    so the more you know about them, the more efficiently you can use them in your
    application.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Flutter 团队构建了这个名为 **Widgets Catalog** 的非常好用的网站（[https://flutter.io/widgets/](https://flutter.io/widgets/))，在这里你可以探索
    Flutter 中已经存在的各种组件，它们被按类别划分。你将在你的应用程序中使用很多这些组件，所以你对它们了解得越多，你就能在应用程序中使用得越高效。
- en: 'However, there are a few fundamental widgets listed that will help you get
    familiar with the types of widgets you will find in the Widgets Catalog. The following
    is a list of those widgets:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一些基本的组件被列出，这将帮助你熟悉你在 Widgets Catalog 中将找到的组件类型。以下是一个这些组件的列表：
- en: '`Container`'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Container`'
- en: '`Image`'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`图片`'
- en: '`Text`'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Text`'
- en: '`Icon`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`图标`'
- en: '`RaisedButton`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RaisedButton`'
- en: '`Scaffold`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Scaffold`'
- en: '`Appbar`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Appbar`'
- en: '`PlaceHolder`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PlaceHolder`'
- en: '`Row`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Row`'
- en: '`Column`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Column`'
- en: '`ListView`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ListView`'
- en: Let's explore these widgets one by one in detail.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一详细探索这些组件。
- en: Container
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器
- en: This is one of the complex widgets in the catalog. It is used to contain a child
    widget within your parent widget, which it does by applying some styling properties
    on it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这是目录中复杂组件之一。它用于在父组件中包含子组件，通过应用一些样式属性来实现。
- en: A container makes it possible to apply a variety of features, for example, background
    color, aligning the child within the container, setting some constraints to the
    size of the child, and applying some decoration or transformation property to
    the child (for example, you can rotate a widget). When we look at the amount of
    things you can do with this widget, it can be considered a complex widget. But
    in most cases, we will need only a couple of its features.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 容器使得应用各种功能成为可能，例如，设置背景颜色，在容器内对齐子组件，对子组件的大小设置一些约束，以及应用一些装饰或转换属性到子组件（例如，你可以旋转一个组件）。当我们查看你可以用这个组件做什么时，它可以被认为是一个复杂的组件。但在大多数情况下，我们只需要它的几个功能。
- en: 'Now, let''s take a look at the code to display the widget. The code will look
    as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看显示组件的代码。代码将如下所示：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following output will be displayed:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 将显示以下输出：
- en: '![](img/69d034f0-00c5-4654-b184-efd3d15efff3.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69d034f0-00c5-4654-b184-efd3d15efff3.png)'
- en: 'Sometimes, you will need to show a widget based on a conditional expression—for
    example, in this case:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你需要根据条件表达式显示组件——例如，在这个例子中：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding code shows the conditional expression for a container. It works
    like most of the conditional expressions, where if the condition is true, you
    will get your regular widget. But if the condition is false, you will get something
    called a**null** widget.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码展示了容器条件表达式的示例。它的工作方式与大多数条件表达式类似，如果条件为真，你将得到你的常规组件。但如果条件为假，你将得到一个称为**null**组件的东西。
- en: Image
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图片
- en: 'Displaying images on your application is one feature that your app must have.
    There are hardly any apps today that lack the functionality to display an image.
    And, to do this, the image widget comes into the picture. We can use the following
    code to use an image widget:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的应用程序中显示图片是您必须拥有的一个功能。如今几乎没有应用程序缺少显示图片的功能。为此，图片小部件就派上用场了。我们可以使用以下代码来使用图片小部件：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following output will be displayed when you use the preceding code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用前面的代码时，将显示以下输出：
- en: '![](img/464b9cba-65c7-4b61-95bc-76167d9db23b.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/464b9cba-65c7-4b61-95bc-76167d9db23b.png)'
- en: You can explore the several constructors it has to offer, but I suggest that
    you try and use them depending on the source you want to use. For example, if
    you have an `imageProvider`, you will use the default constructor, but if you
    have the image in an `AssetBundle`, you should use the `Image.asset` constructor.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以探索它提供的几个构造函数，但我建议您根据您想要使用的源来尝试使用它们。例如，如果您有一个`imageProvider`，您将使用默认构造函数，但如果图片在`AssetBundle`中，您应该使用`Image.asset`构造函数。
- en: 'This is an image-displaying widget, and images come in a few different formats.
    Here''s the list of image formats supported by the image widget:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个显示图片的小部件，图片有几种不同的格式。以下是图像小部件支持的图像格式列表：
- en: '`JPEG`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JPEG`'
- en: '`PNG`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PNG`'
- en: '`GIF`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GIF`'
- en: '`Animated GIF`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Animated GIF`'
- en: '`WebP`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebP`'
- en: '`Animated WebP`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Animated WebP`'
- en: '`BMP`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BMP`'
- en: '`WBMP`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WBMP`'
- en: Text
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Text`'
- en: This widget is as self-explanatory as the last one. It is used for displaying
    text on the screen with a single style. We can also display the text on a single
    line or multiple lines; this depends on the layout constraints. The style argument
    when using this widget is optional. If the style argument is not provided, the
    widget will use the style from enclosing `DefaultTextStyle`, and if the provided
    style's `TextStyle.inherit` property is true, the given style will be merged with
    the default one.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此小部件与上一个小部件一样简单易懂。它用于在屏幕上以单一样式显示文本。我们还可以在单行或多行上显示文本；这取决于布局约束。使用此小部件时的样式参数是可选的。如果没有提供样式参数，则小部件将使用包围的`DefaultTextStyle`的样式，如果提供的样式的`TextStyle.inherit`属性为true，则给定样式将与默认样式合并。
- en: 'The following code can be used for using a text widget:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码可以用来使用文本小部件：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following screenshot will display how the widget is displayed on the screen:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图将显示小部件在屏幕上的显示方式：
- en: '![](img/2f16ef43-e15f-4e4c-a4b5-79fe15e8a754.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f16ef43-e15f-4e4c-a4b5-79fe15e8a754.png)'
- en: There may be instances when you want to do more with this text widget. For example,
    to apply more than one style (to display some bold words in a line) to text, you
    can use the `TextSpan.rich` constructor, or to add interactivity to the text,
    you can use use a `GestureDetector`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候您可能想要对这个文本小部件做更多的事情。例如，为了将多个样式（在行中显示一些粗体字）应用于文本，您可以使用`TextSpan.rich`构造函数，或者为了给文本添加交互性，您可以使用`GestureDetector`。
- en: I would suggest using `FlatButton`, instead of a text widget for interactivity.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议使用`FlatButton`而不是文本小部件来进行交互。
- en: Icon
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Icon`'
- en: The icon widget is used to draw an icon using the font described in `IconData`,
    such as a material's predefined `IconData` in the `Icon` class.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图标小部件用于使用`IconData`中描述的字体绘制图标，例如`Icon`类中预定义的材质`IconData`。
- en: 'The following code can be used to use the `Icon` widget:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码可以用来使用`Icon`小部件：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following is a screenshot displaying how the `Icon` widget looks on the
    screen:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了`Icon`小部件在屏幕上的外观：
- en: '![](img/3c2a4a8a-fe6a-4bef-bd9f-3ce6c596047c.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3c2a4a8a-fe6a-4bef-bd9f-3ce6c596047c.png)'
- en: Just like the text widget, we can add interactivity with the `Icon` widget too.
    To do that, we can use `GestureDetector`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 就像文本小部件一样，我们也可以使用`Icon`小部件添加交互性。为此，我们可以使用`GestureDetector`。
- en: RaisedButton
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`RaisedButton`'
- en: This widget is used to display a simple elevated button. The button is elevated
    because the button is based on a material widget whose elevation increases when
    the button is pressed. If the `onPressed` callback is null, then the button will
    be disabled, and it will resemble a flat button in `disabledColor`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此小部件用于显示一个简单的提升按钮。按钮是提升的，因为按钮基于一个材质小部件，当按钮被按下时，其提升会增加。如果`onPressed`回调为空，则按钮将被禁用，并且它将类似于`disabledColor`中的平面按钮。
- en: 'The following code can be used to use the `RaisedButton` widget:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码可以用来使用`RaisedButton`小部件：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following screenshot will be displayed when you use the preceding code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用前面的代码时，将显示以下截图：
- en: '![](img/37aa21dd-e07c-4788-b2b8-44b595ad7183.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/37aa21dd-e07c-4788-b2b8-44b595ad7183.png)'
- en: The suggestion is to use `RaisedButton` to add dimension in otherwise mostly
    flat layouts. I would recommend not using such a button in a dialog or a card.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 建议使用`RaisedButton`在否则主要平坦的布局中添加维度。我建议不要在对话框或卡片中使用此类按钮。
- en: Scaffold
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scaffold
- en: '**Scaffold** is a basic layout structure based on material design. In practice,
    if you use material design, every screen of your app will have a `Scaffold` as
    its base. The `Scaffold` widget is used for showing drawers, snackbars, bottomsheets,
    floating-action buttons, and so on, by offering APIs. To display a snackbar or
    a bottomsheet, you must use `Scaffoldstate` for the current context. We can use
    it via `Scaffold.of` and use the `ScaffoldState.showSnackbar` function.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**Scaffold**是基于材料设计的基本布局结构。在实践中，如果你使用材料设计，你的应用中的每个屏幕都将有一个`Scaffold`作为其基础。`Scaffold`小部件通过提供API用于显示抽屉、snackbars、底部面板、浮动操作按钮等。要显示snackbar或底部面板，你必须使用`Scaffoldstate`当前上下文。我们可以通过`Scaffold.of`来使用它，并使用`ScaffoldState.showSnackbar`函数。'
- en: 'The following code can be used to display a `snackbar` using `Scaffold`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码可以用于使用`Scaffold`显示`snackbar`：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following is the output that will be displayed using the preceding code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述代码将显示以下输出：
- en: '![](img/996b8ed0-4a35-47dd-b1fb-46f363220e03.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/996b8ed0-4a35-47dd-b1fb-46f363220e03.png)'
- en: AppBar
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AppBar
- en: '`AppBar` is basically used as a property of `Scaffold`, and the majority of
    `Scaffold`s have app bars. The app bar consists of a toolbar and potentially other
    widgets. For example, it can host `TabBar`, `FlexibleSpaceBar`, or some actions
    optionally followed by `PopupMenuButton` for less common operations.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppBar`基本上被用作`Scaffold`的一个属性，大多数`Scaffold`都有应用栏。应用栏由一个工具栏和可能的其他小部件组成。例如，它可以托管`TabBar`、`FlexibleSpaceBar`，或者可选地跟随`PopupMenuButton`以执行较少见的操作。'
- en: 'The property that''s used for `AppBar` is `Scaffold.appBar`. It looks as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 用于`AppBar`的属性是`Scaffold.appBar`。它看起来如下：
- en: '![](img/657a576e-36b4-479d-a94c-d2e09baf555e.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/657a576e-36b4-479d-a94c-d2e09baf555e.png)'
- en: The preceding diagram displays where each widget will be placed by the `appBar`
    component.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表显示了`appBar`组件将放置每个小部件的位置。
- en: If the leading widget is omitted and `Scaffold` has a drawer, then `appBar`
    will place a button to open the drawer. If the nearest navigator has any previous
    routes, a `BackButton` will be inserted.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略了前导小部件，并且`Scaffold`有一个抽屉，那么`appBar`将放置一个按钮以打开抽屉。如果最近的导航器有任何之前的路由，将插入一个`BackButton`。
- en: PlaceHolder
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PlaceHolder
- en: '`PlaceHolder` is another widget that explains itself through its name. The
    `PlaceHolder` widget is used for holding a place for a widget. It draws a box
    that represents where other widgets will be added later.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlaceHolder`是另一个通过其名称解释自己的小部件。`PlaceHolder`小部件用于为小部件保留位置。它绘制一个表示稍后添加其他小部件的框。'
- en: 'The following code can be used for a `PlaceHolder` widget:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码可以用于`PlaceHolder`小部件：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding code will display the following output:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将显示以下输出：
- en: '![](img/c622dd11-9e66-49fc-ab3d-c93292da18e1.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c622dd11-9e66-49fc-ab3d-c93292da18e1.png)'
- en: Column
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Column
- en: '`Column` is essential for composing layout in Flutter apps. It displays its
    children in a vertical array. The following code can be used for the `Column`
    widget:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`Column`对于在Flutter应用中组合布局至关重要。它以垂直数组显示其子项。以下代码可以用于`Column`小部件：'
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following output will be displayed:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 将显示以下输出：
- en: '![](img/ba02c14e-4061-43f2-926c-5dd57b6223bc.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ba02c14e-4061-43f2-926c-5dd57b6223bc.png)'
- en: The `Column` widget, however, does not support scrolling; for that, we can use
    `ListView`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`Column`小部件不支持滚动；为此，我们可以使用`ListView`。
- en: Note that it will be considered as an error by the system if you have more children
    in a column that will fit into the available room. That's because the column doesn't
    have the ability to recycle the layout.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你在列中有更多的子项，而它们将适合可用的空间，系统会将其视为一个错误。这是因为列没有回收布局的能力。
- en: Row
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Row
- en: The `Row` widget is similar to the `Column` widget, but still different. We
    can say that it is the horizontal version of `column`. It draws the children in
    a horizontal array.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`Row`小部件类似于`Column`小部件，但仍有不同。我们可以说是`column`的水平版本。它在水平数组中绘制子项。'
- en: 'The following code can be used for a `Row` widget:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码可以用于`Row`小部件：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following output will be displayed:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 将显示以下输出：
- en: '![](img/a31ab713-91b4-48a4-a69f-61fda765c3af.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a31ab713-91b4-48a4-a69f-61fda765c3af.png)'
- en: The story in regard to scrolling remains the same as for the `Column` widget.
    It is recommended to use `ListView` if you want to scroll the children.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 关于滚动的相关故事与`Column`小部件相同。如果你想要滚动子项，建议使用`ListView`。
- en: ListView
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ListView
- en: '`ListView` behaves similar to a column or a row; the only difference is that
    its children can be scrolled.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListView`的行为类似于列或行；唯一的区别是它的子项可以滚动。'
- en: 'There are three constructors for the `ListView` widget:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListView`小部件有三个构造函数：'
- en: The default takes a list of widgets in its children property. This is a good
    choice for small lists because to build it, the list will process every child.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，它在其子属性中接受小部件列表。这对于小列表来说是一个不错的选择，因为构建它时，列表将处理每个子项。
- en: '`ListView.builder` takes an indexed builder to build the children on demand.
    This is the choice to pick if you have a large number of children, because every
    time the list processes only the visible children.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ListView.builder`接受一个索引构建器，按需构建子项。如果你有很多子项，这是一个不错的选择，因为每次列表处理只有可见的子项。'
- en: '`ListView.custom` takes `SliverChildDelegate`, which provides the ability to
    customize more aspects of `ListView`.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ListView.custom`接受`SliverChildDelegate`，它提供了自定义`ListView`更多方面的能力。'
- en: A note about Row, Column, and ListView
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于Row、Column和ListView的注意事项
- en: Sometimes, it can happen that you get a runtime exception at the time of building
    a row or a column that's been placed in another row/column or in any scenario
    that does not provide a maximum height constraint.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在构建放置在另一个行/列或任何未提供最大高度约束的场景中的行或列时，可能会在运行时遇到异常。
- en: The problem is that the inner widget should fill all the remaining space, but
    the outer widget has no specific size and should fill the available space too.
    So, they can't understand where to stop, and then an exception is thrown.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于内部小部件应该填充所有剩余空间，但外部小部件没有特定的尺寸，也应该填充可用空间。因此，它们无法理解在哪里停止，然后抛出异常。
- en: 'To solve such a problem, you must understand why the inner column/row is receiving
    unbounded constraints. Consider the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这样的问题，你必须理解为什么内部列/行正在接收无界约束。考虑以下：
- en: If the column/row is placed in another column/row, you can try to wrap the inner
    widget in an expanded widget, indicating that it should take the remaining space
    of the outer widget and not all the space it desires
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果列/行被放置在另一个列/行中，你可以尝试将内部小部件包裹在一个expanded小部件中，表示它应该占用外部小部件的剩余空间，而不是它所希望的全部空间
- en: If the widget is placed in a `Listview` and is wrapped in an expanded or flexible, then
    that key is to remove that wrapping widget and to set the size of the inner widget
    manually
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果小部件被放置在`Listview`中，并且被包裹在expanded或flexible中，那么关键是要移除那个包裹小部件，并手动设置内部小部件的尺寸
- en: 'Another problem you may have to encounter the yellow-and-black-striped banner
    as shown in following screenshot:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还会遇到以下截图所示的黄色和黑色条纹横幅的问题：
- en: '![](img/1cbd5007-fc27-4e4c-b7de-813e4ee51547.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1cbd5007-fc27-4e4c-b7de-813e4ee51547.png)'
- en: This banner indicates that a row or column overflows its size. The solution
    is to use `ListView` and let the content scroll, or just to reduce the size of
    the children.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个横幅表明行或列超出了其大小。解决方案是使用`ListView`并让内容滚动，或者只是减少子项的大小。
- en: Creating widgets
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建小部件
- en: We saw a number of widgets in the previous section, but there might be a possibility
    that you don't find the right ready-to-use widget that you want or that you want
    to combine more widgets in order to create a reusable group. Therefore, you have
    to create a custom widget.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节中看到了许多小部件，但可能存在你找不到正确现成的你想要的小部件，或者你想要将更多小部件组合起来以创建一个可重用组的情况。因此，你必须创建一个自定义小部件。
- en: 'There are two types of widget in Flutter that you can use to create your own
    custom widgets:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在Flutter中，你可以使用两种类型的小部件来创建自己的自定义小部件：
- en: Stateless widgets
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无状态小部件
- en: Stateful widgets
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有状态小部件
- en: Let's take a look at them in a bit more detail.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看它们。
- en: Stateless widgets
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无状态小部件
- en: '**Stateless widgets** remain the same even if the user interacts with them.
    This kind of widget has no state, so they can''t change according to an internal
    state. They can only react to higher widget changes.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**无状态小部件**即使在用户与之交互时也保持不变。这种小部件没有状态，因此它们不能根据内部状态改变。它们只能对更高层的小部件变化做出反应。'
- en: 'To build a stateless widget, we will extend the `StatelessWidget` abstract
    class, as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建无状态小部件，我们将扩展`StatelessWidget`抽象类，如下所示：
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Stateful widgets
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有状态小部件
- en: '**Stateful widgets** are dynamic components that have an internal state to
    manage. A stateful widget can react to state changes and change accordingly. The
    state is stored in a `State` object. To create a `StatefulWidget`, you have to
    extend the `StatefulWidget` abstract class, as shown in the following code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**有状态的组件**是具有内部状态以进行管理的动态组件。有状态的组件可以响应状态变化并相应地改变。状态存储在`State`对象中。要创建`StatefulWidget`，你必须扩展`StatefulWidget`抽象类，如下面的代码所示：'
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The state will be a class extending the `State<T extends StatefulWidget>` abstract
    class. Let''s take a look at example where the widget changes the background color
    according to its state. The code for this is as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 状态将是一个扩展了`State<T extends StatefulWidget>`抽象类的类。让我们看看一个示例，其中小部件根据其状态改变背景颜色。相应的代码如下：
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To trigger the framework to rebuild the widget and apply the changes, you have
    to call the `setState()` function, or it won't see any changes.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要触发框架重新构建小部件并应用更改，你必须调用`setState()`函数，否则它将看不到任何更改。
- en: Routing and navigation
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由和导航
- en: We've just looked at how to use widgets, but you won't be using just one widget.
    In a typical application, it's normal to find more than one screen. When an application
    has more than one screen, it is essential for the users to have a clear route
    to move through those pages, and to do so routing and navigating through the pages
    becomes very important for your application.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看了如何使用小部件，但你不会只使用一个小部件。在一个典型的应用程序中，通常会有多个屏幕。当应用程序有多个屏幕时，用户有一个清晰的路径来浏览这些页面变得非常重要，为此，在应用程序中通过路由和导航页面变得非常重要。
- en: To do this, if you are from an Android background, you would use more activities
    or fragments, and in iOS, you would create a new `viewControllers`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，如果你来自Android背景，你会使用更多的活动或片段，而在iOS中，你会创建新的`viewControllers`。
- en: 'In the Flutter world, new screens are widgets! To navigate to a new route,
    we can use the `Navigator.push()` function, passing as an argument the current
    context and a new `MaterialPageRoute`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在Flutter的世界里，新屏幕是组件！要导航到新路由，我们可以使用`Navigator.push()`函数，将当前上下文和一个新的`MaterialPageRoute`作为参数传递：
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `SecondScreen` will be a normal widget that builds the screen. For example:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`SecondScreen`将是一个普通的小部件，用于构建屏幕。例如：'
- en: '[PRE14]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To navigate back, we will use another function of the navigator: `Navigator.pop()`.
    This function will remove the current route from the stack of routes that are
    managed by the navigator. We can also use this function to return a value to the
    users when moving through the screen. Let's take a look at this in detail in the
    next section.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要返回，我们将使用导航器的另一个函数：`Navigator.pop()`。此函数将从导航器管理的路由堆栈中删除当前路由。我们还可以使用此函数在浏览屏幕时向用户返回值。让我们在下一节中详细探讨这一点。
- en: Returning a value when navigating
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航时返回值
- en: Returning a value to the readers when moving from one screen to another screen
    can improve the user experience of your application. For example, just a simple
    `welcome` on the screen when opening an app, will increase the user experience.
    For this purpose, in Flutter, we have `Navigator.pop()`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在从一个屏幕切换到另一个屏幕时向读者返回值可以提高你应用程序的用户体验。例如，当打开应用程序时，屏幕上简单的`welcome`可以提高用户体验。为此目的，在Flutter中，我们有`Navigator.pop()`。
- en: '`Navigator.pop()` takes the current context as an argument, but it has an optional
    dynamic argument. This means that you can return any value when popping a screen.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`Navigator.pop()`函数接受当前上下文作为参数，但它有一个可选的动态参数。这意味着在弹出屏幕时，你可以返回任何值。'
- en: 'Taking a look at the return value of `Navigator.push()`, you can see that it
    returns a `Future<dynamic>`. So, when pushing a new screen, you can wait for the
    popped return value. For example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 查看一下`Navigator.push()`的返回值，你可以看到它返回一个`Future<dynamic>`。因此，在推送新屏幕时，你可以等待弹出的返回值。例如：
- en: '[PRE15]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `ConfirmationScreen` will be as shown:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConfirmationScreen`将如下所示：'
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went through the widget catalog; this catalog consists of
    a number basic widgets that we can start using instantly in our applications without
    building our own widgets. It is good to understand these basic widgets, as you
    will be using them in your application a lot. But there will be times when you
    will need a customized widget, to help you with that we went through stateless
    and stateful widgets, that will help you customize your widgets. And, finally,
    we learned how to navigate and route through those widgets.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们浏览了小部件目录；这个目录包含了一些基本的小部件，我们可以在不构建自己的小部件的情况下立即在我们的应用程序中使用它们。了解这些基本小部件是很有好处的，因为你在你的应用程序中会大量使用它们。但有时你将需要定制化的小部件，为了帮助你，我们介绍了无状态和有状态的小部件，这将帮助你定制你的小部件。最后，我们学习了如何在这些小部件中进行导航和路由。
- en: What's next? There are more and more widgets you can use to build your apps.
    In the next chapter, we'll see some of them that can be used to build beautiful
    layouts.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是什么？你可以使用的更多小部件来构建你的应用程序。在下一章中，我们将看到一些可以用来构建美观布局的小部件。
