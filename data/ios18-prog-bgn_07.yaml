- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Functions and Closures
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数和闭包
- en: At this point, you can write reasonably complex programs that can make decisions
    and repeat instruction sequences. You can also store data for your programs using
    collection types. As the programs you write grow in size and complexity, it will
    become harder to comprehend what they do.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可以编写相对复杂的程序，这些程序可以做出决策并重复指令序列。你还可以使用集合类型为你的程序存储数据。随着你编写的程序在大小和复杂性上增长，理解它们所做的工作将变得更加困难。
- en: To make large programs easier to understand, Swift allows you to create **functions**,
    which let you combine several instructions and execute them by calling a single
    name. You can also create **closures**, which let you combine several instructions
    without a name and assign them to a constant or variable.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使大型程序更容易理解，Swift 允许你创建**函数**，这让你可以通过调用单个名称来组合多个指令并执行它们。你还可以创建**闭包**，这让你可以组合多个指令而不命名，并将它们分配给常量或变量。
- en: By the end of this chapter, you’ll have learned about functions, nested functions,
    functions as return types, functions as arguments, and the `guard` statement.
    You’ll also have learned how to create and use closures.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解函数、嵌套函数、作为返回类型的函数、作为参数的函数以及`guard`语句。你还将了解如何创建和使用闭包。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Exploring functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索函数
- en: Exploring closures
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索闭包
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The Xcode playground for this chapter is in the `Chapter06` folder of the code
    bundle for this book, which can be downloaded here:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的 Xcode 游乐场位于本书代码包的`Chapter06`文件夹中，可以在此处下载：
- en: '[https://github.com/PacktPublishing/iOS-18-Programming-for-Beginners-Ninth-Edition](https://github.com/PacktPublishing/iOS-18-Programming-for-Beginners-Ninth-Edition)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/iOS-18-Programming-for-Beginners-Ninth-Edition](https://github.com/PacktPublishing/iOS-18-Programming-for-Beginners-Ninth-Edition)'
- en: 'Check out the following video to see the code in action:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，看看代码的实际效果：
- en: '[https://youtu.be/lgPDkddf_tc](https://youtu.be/lgPDkddf_tc%0D)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://youtu.be/lgPDkddf_tc](https://youtu.be/lgPDkddf_tc)'
- en: If you wish to start from scratch, create a new playground and name it `FunctionsAndClosures`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望从头开始，创建一个新的游乐场，并将其命名为`FunctionsAndClosures`。
- en: You can type in and run all the code in this chapter as you go along. Let’s
    start by learning about functions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在进行过程中输入并运行本章中的所有代码。让我们先了解函数。
- en: Exploring functions
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索函数
- en: 'Functions are useful for encapsulating several instructions that collectively
    perform a specific task, such as the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 函数对于封装执行特定任务的多个指令非常有用，如下所示：
- en: Calculating the 10% service charge for a meal at a restaurant
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算餐厅餐费的10%服务费
- en: Calculating the monthly payment for a car that you wish to purchase
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算你希望购买的汽车的月供
- en: 'Here’s what a function looks like:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是函数的样子：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Every function has a descriptive name. You can define one or more values that
    the function takes as input, known as **parameters**. You can also define what
    the function will output when done, known as its **return type**. Both parameters
    and return types are optional.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数都有一个描述性的名称。你可以定义一个或多个作为输入值的函数，这些值被称为**参数**。你还可以定义函数完成后的输出，这被称为其**返回类型**。参数和返回类型都是可选的。
- en: 'You “call” a function’s name to execute it. This is what a function call looks
    like:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你“调用”函数的名称来执行它。这就是函数调用的样子：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You provide input values (known as **arguments**) that match the type of the
    function’s parameters.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你提供与函数参数类型匹配的输入值（称为**参数**）。
- en: To learn more about functions, visit [https://docs.swift.org/swift-book/documentation/the-swift-programming-language/functions/](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/functions/).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于函数的信息，请访问[https://docs.swift.org/swift-book/documentation/the-swift-programming-language/functions/](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/functions/)。
- en: Let’s see how you can create a function to calculate a service charge in the
    next section.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看看如何创建一个函数来计算服务费。
- en: Creating a function
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建函数
- en: In its simplest form, a function just executes some instructions and does not
    have any parameters or return types. You’ll see how this works by writing a function
    to calculate the service charge for a meal. The service charge should be 10% of
    the meal cost.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单的形式中，函数只是执行一些指令，没有任何参数或返回类型。你将通过编写一个计算餐费服务费的函数来了解这是如何工作的。服务费应该是餐费的10%。
- en: 'Add the following code to your playground to create and call this function
    and run it:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到你的游乐场中，创建并调用此函数并运行它：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You’ve just created a very simple function named `serviceCharge()`. All it does
    is calculate the 10% service charge for a meal costing $50, which is `50 / 10`,
    returning `5`. You then call this function using its name. You’ll see **Service
    charge is 5** displayed in the Debug area.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚创建了一个名为`serviceCharge()`的非常简单的函数。它所做的只是计算价值50美元的餐费的10%服务费，即`50 / 10`，返回`5`。然后你使用其名称调用此函数。你将在调试区域看到**服务费是5**的显示。
- en: This function is not very useful because `mealCost` is always `50` every time
    you call this function. Also, the result is only printed in the Debug area and
    can’t be used elsewhere in your program. Let’s add some parameters and a return
    type to this function to make it more useful.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数不是很实用，因为每次调用这个函数时`mealCost`总是`50`。此外，结果只打印在调试区域，不能在程序的其他地方使用。让我们给这个函数添加一些参数和一个返回类型，使其更有用。
- en: 'Modify your code as shown:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下所示修改你的代码：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is much better. Now, you can set the meal cost when you call the `serviceCharge(mealCost:)`
    function, and the result can be assigned to a variable or constant. It looks a
    bit awkward, though. You should try to make function signatures in Swift read
    like an English sentence, as this is considered a best practice. Let’s see how
    to do that in the next section, where you’ll use **custom labels** to make your
    function more English-like and easier to understand.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就更好了。现在，你可以在调用`serviceCharge(mealCost:)`函数时设置餐费，并将结果分配给一个变量或常量。尽管这样看起来有点别扭。你应该尝试使Swift中的函数签名读起来像英语句子，因为这被认为是一种最佳实践。让我们看看如何在下一节中做到这一点，你将使用**自定义标签**使你的函数更符合英语风格，更容易理解。
- en: Using custom argument labels
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自定义参数标签
- en: Note that the `serviceCharge(mealCost:)` function is not very English-like.
    You can add a custom label to the parameter to make the function easier to understand.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`serviceCharge(mealCost:)`函数不太符合英语风格。你可以给参数添加一个自定义标签，使函数更容易理解。
- en: 'Modify your code as shown:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下所示修改你的代码：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The function works the same as before, but to call it, you use `serviceCharge(forMealPrice:)`.
    This sounds more like English and makes it easier to figure out what the function
    does. Also, note that if your function body only consists of a single statement,
    the `return` keyword is optional.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的工作方式与之前相同，但调用它时，你使用`serviceCharge(forMealPrice:)`。这听起来更像是英语，更容易弄清楚函数的作用。此外，注意如果你的函数体只包含一个语句，则`return`关键字是可选的。
- en: In the next section, you’ll learn how to use several smaller functions within
    the bodies of other functions, and these are known as **nested functions**.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将学习如何在其他函数体内使用几个较小的函数，这些被称为**嵌套函数**。
- en: Using nested functions
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用嵌套函数
- en: It’s possible to have a function within the body of another function, and these
    are called nested functions. This allows you to keep a number of related functions
    together in one place and makes the enclosing function easier to understand.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个函数体内有一个函数，这些被称为嵌套函数。这允许你将多个相关函数放在一起，使封装函数更容易理解。
- en: A nested function can use the variables of the enclosing function. Let’s see
    how nested functions work by writing a function to calculate monthly payments
    for a loan.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套函数可以使用封装函数的变量。让我们通过编写一个计算贷款月供的函数来了解嵌套函数是如何工作的。
- en: 'Type in and run the following code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 输入并运行以下代码：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, there are three functions within `calculateMonthlyPayments(carPrice:downPayment:interestRate:paymentTerm:)`.
    Let’s look at them:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，在`calculateMonthlyPayments(carPrice:downPayment:interestRate:paymentTerm:)`中有三个函数。让我们来看看它们：
- en: The first nested function, `loanAmount()`, calculates the total loan amount
    by subtracting `downPayment` from `carPrice`. It returns `50000 - 5000` = `45000`.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个嵌套函数`loanAmount()`通过从`carPrice`中减去`downPayment`来计算总贷款金额。它返回`50000 - 5000`
    = `45000`。
- en: The second nested function, `totalInterest()`, calculates the total interest
    amount incurred for the payment term by multiplying `interestRate` by `paymentTerm`.
    It returns `3.5 * 7` = `24.5`.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个嵌套函数`totalInterest()`通过将`interestRate`乘以`paymentTerm`来计算支付期限产生的总利息金额。它返回`3.5
    * 7` = `24.5`。
- en: The third nested function, `numberOfMonths()`, calculates the total number of
    months in the payment term by multiplying `paymentTerm` by `12`. It returns `7
    * 12` = `84`.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个嵌套函数`numberOfMonths()`通过将`paymentTerm`乘以`12`来计算支付期限的总月份数。它返回`7 * 12` = `84`。
- en: Note that the three nested functions all use the variables of the enclosing
    function. The value returned is `( 45000 + ( 45000 * 24.5 / 100 ) ) / 84` = `666.96`,
    which is the amount you must pay monthly for seven years to buy this car.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，三个嵌套函数都使用了封装函数的变量。返回的值是 `( 45000 + ( 45000 * 24.5 / 100 ) ) / 84` = `666.96`，这是您为了购买这辆车每月必须支付的金额。
- en: As you have seen, functions in Swift are like functions in other languages,
    but they have a cool feature. Functions are **first-class types** in Swift, so
    they can be used as parameters and return types. Let’s see how that is done in
    the next section.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Swift中的函数与其他语言中的函数类似，但有一个酷炫的特性。在Swift中，函数是**一等类型**，因此它们可以用作参数和返回类型。让我们在下一节中看看这是如何实现的。
- en: Using functions as return types
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用函数作为返回类型
- en: 'A function can return another function as its return type. Type in and run
    the following code to create a function that generates the value of pi using one
    of two possible ways:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数可以作为其返回类型返回另一个函数。输入并运行以下代码以创建一个函数，该函数使用两种可能的方法之一生成π的值：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Both `approximateValueOfPi1()` and `approximateValueOfPi2()` are functions that
    have no parameters and return the approximate value of pi. The `pi()` function’s
    return type is a function that has no parameters and returns a `Double`. This
    means that it can either return `approximateValueOfPi1` (as shown here) or `approximateValueOfPi2`,
    since both functions match the expected return type.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`approximateValueOfPi1()` 和 `approximateValueOfPi2()` 都是没有任何参数并返回π近似值的函数。`pi()`
    函数的返回类型是一个没有参数并返回 `Double` 类型的函数。这意味着它可以返回 `approximateValueOfPi1`（如所示）或 `approximateValueOfPi2`，因为这两个函数都符合预期的返回类型。'
- en: '`pi()()` calls the function `approximateValueOfPi1`, which returns `3.14159`.
    **3.14159** is displayed in the Results area.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`pi()()` 调用了返回 `3.14159` 的函数 `approximateValueOfPi1`。**3.14159** 在结果区域中显示。'
- en: Let’s see how a function can be used as a parameter for another function in
    the next section.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在下一节中如何将一个函数用作另一个函数的参数。
- en: Using functions as parameters
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用函数作为参数
- en: 'A function can take another function as a parameter. Type in and run the following
    code to create a function that determines whether a number meeting a certain condition
    exists within a list of numbers:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数可以将另一个函数作为参数。输入并运行以下代码以创建一个函数，该函数用于判断一个满足特定条件的数字是否存在于数字列表中：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`isThereAMatch(listOfNumbers:condition:)` has two parameters: an array of integers
    and a function. The function provided as an argument must take an integer value
    and return a Boolean value.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`isThereAMatch(listOfNumbers:condition:)` 有两个参数：一个整数数组和函数。提供的作为参数的函数必须接受一个整数值并返回一个布尔值。'
- en: Both `numberIsOdd(number:)` and `numberIsEven(_:)` take an integer and return
    a Boolean value, which means either function can be an argument for the second
    parameter. `numbersList`, an array containing odd numbers, is used as the argument
    for the first parameter. When `numberIsOdd` is used as an argument for the second
    parameter, `isThereAMatch(listOfNumbers:condition:)` will return `true` when called.
    Try using `numberisEven` as an argument for the second parameter as well.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`numberIsOdd(number:)` 和 `numberIsEven(_:)` 都接受一个整数并返回一个布尔值，这意味着任一函数都可以作为第二个参数的参数。包含奇数的数组
    `numbersList` 用作第一个参数的参数。当 `numberIsOdd` 作为第二个参数的参数时，`isThereAMatch(listOfNumbers:condition:)`
    被调用时会返回 `true`。尝试使用 `numberisEven` 作为第二个参数的参数。'
- en: Functions as parameters and return types can be difficult to understand, but
    are relatively rare at this point in your learning journey, so don’t worry if
    you don’t get it at first. As you gain experience, it will become clearer to you.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 函数作为参数和返回类型可能难以理解，但在您学习旅程的这个阶段相对较少，所以如果您一开始不理解，请不要担心。随着您经验的积累，这会变得更容易理解。
- en: In the next section, you’ll see how you can perform an early exit on a function
    if the arguments used are not suitable.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将了解如果使用的参数不合适，如何从函数中提前退出。
- en: Using a guard statement to exit a function early
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用守卫语句提前退出函数
- en: Let’s say you need a function to be used in an online purchasing terminal. This
    function will calculate the remaining balance of a debit or credit card when you
    buy something. The price of the item that you want to buy is entered in a text
    field.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您需要一个函数用于在线购物终端。这个函数将在您购买东西时计算借记卡或信用卡的剩余余额。您想要购买的物品价格输入在一个文本字段中。
- en: The value in the text field is converted into an integer so that you can calculate
    the remaining card balance. If there is something wrong with the input data, it
    is useful to be able to exit a function early.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 文本框中的值被转换为整数，这样你就可以计算剩余的卡余额。如果输入数据有问题，能够提前退出函数是非常有用的。
- en: 'Type in and run the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 输入并运行以下代码：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You should see this result in the Debug area:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试区域看到这个结果：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Let’s see how this function works. The first line in the function body is a
    `guard` statement. This checks to see whether a condition is `true`; if not, it
    exits the function. Here, it is used to check and see whether the user entered
    a valid price in the online purchasing terminal.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个函数是如何工作的。函数体内的第一行是一个`guard`语句。这个语句检查一个条件是否为`true`；如果不是，它将退出函数。在这里，它被用来检查用户是否在在线购买终端输入了有效的价格。
- en: If so, the value can be converted successfully into an integer, and you can
    calculate the remaining card balance. Otherwise, the `else` clause in the `guard`
    statement is executed. An error message is printed to the Debug area and the unchanged
    card balance is returned.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样，该值可以成功转换为整数，你可以计算剩余的卡余额。否则，`guard`语句中的`else`子句将被执行。错误信息将被打印到调试区域，并且返回未更改的卡余额。
- en: 'For `print(buySomething(itemValueEntered: "10", cardBalance: 50))`, the item
    price is deducted successfully from the card balance, and `40` is returned.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '对于`print(buySomething(itemValueEntered: "10", cardBalance: 50))`，项目价格成功从卡余额中扣除，并返回`40`。'
- en: 'For `print(buySomething(itemValueEntered: "blue", cardBalance: 50))`, the `guard`
    statement’s condition fails and its `else` clause is executed, resulting in an
    error message being printed to the Debug area and `50` being returned.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '对于`print(buySomething(itemValueEntered: "blue", cardBalance: 50))`，`guard`语句的条件失败，其`else`子句被执行，导致错误信息被打印到调试区域，并返回`50`。'
- en: You now know how to create and use functions. You have also seen how to use
    custom argument labels, nested functions, functions as parameters or return types,
    and the `guard` statement.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经知道了如何创建和使用函数。你还看到了如何使用自定义参数标签、嵌套函数、函数作为参数或返回类型，以及`guard`语句。
- en: Now, let’s look at closures. Like functions, closures allow you to combine several
    instructions, but closures do not have names and can be assigned to a constant
    or a variable. You’ll see how they work in the next section.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看闭包。与函数一样，闭包允许你组合多个指令，但闭包没有名字，并且可以被分配给一个常量或变量。你将在下一节中看到它们是如何工作的。
- en: Exploring closures
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索闭包
- en: A closure, like a function, contains a sequence of instructions and can take
    arguments and return values. However, closures don’t have names. The sequence
    of instructions in a closure is surrounded by curly braces (`{ }`), and the `in`
    keyword separates the arguments and return type from the closure body.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包，就像函数一样，包含一系列指令，可以接受参数并返回值。然而，闭包没有名字。闭包中的指令序列被大括号(`{ }`)包围，`in`关键字将参数和返回类型与闭包体分开。
- en: Closures can be assigned to a constant or variable, so they’re handy if you
    need to pass them around inside your program. For instance, let’s say you have
    an app that downloads a file from the internet, and you need to do something to
    the file once it has finished downloading. You can put a list of instructions
    to process the file inside a closure and have your program execute it once the
    file finishes downloading.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包可以被分配给一个常量或变量，所以当你需要在程序内部传递它们时，它们非常方便。例如，假设你有一个从互联网下载文件的应用程序，并且你需要在文件下载完成后对文件进行一些操作。你可以在闭包内部放置一个处理文件的指令列表，并在文件下载完成后让程序执行它。
- en: To learn more about closures, visit [https://docs.swift.org/swift-book/documentation/the-swift-programming-language/closures/](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/closures/).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于闭包的信息，请访问[https://docs.swift.org/swift-book/documentation/the-swift-programming-language/closures/](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/closures/)。
- en: 'You’ll now write a closure that applies a calculation to each element of an
    array of numbers. Add the following code to your playground and click the **Run**
    button to run it:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在将编写一个闭包，该闭包将对数字数组中的每个元素应用计算。将以下代码添加到你的游乐场中，然后点击**运行**按钮来运行它：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This assigns a closure that calculates a number’s power of two to `myClosure`.
    The `map()` function then applies this closure to every element in `numbersArray`.
    Each element is multiplied by itself, and `[4, 16, 36, 49]` appears in the Results
    area.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这将一个计算数字的平方的闭包赋值给 `myClosure`。然后 `map()` 函数将此闭包应用于 `numbersArray` 中的每个元素。每个元素都乘以自身，并在结果区域出现
    `[4, 16, 36, 49]`。
- en: It’s possible to write closures in a more concise fashion, and you’ll see how
    to do that in the next section.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以以更简洁的方式编写闭包，您将在下一节中看到如何做到这一点。
- en: Simplifying closures
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简化闭包
- en: 'One of the things that new developers have trouble with is the very concise
    method used by experienced Swift programmers to write closures. Consider the code
    shown in the following example:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 新开发者遇到困难的一件事是经验丰富的 Swift 程序员编写闭包时使用的非常简洁的方法。考虑以下示例中的代码：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, you have `testNumbers`, an array of numbers, and you use the `map(_:)`
    function to map a closure to each element of the array in turn. The code in the
    closure multiplies the number by itself, generating the square of that number.
    The result, **[4, 16, 36, 49]**, is then printed to the Debug area. As you will
    see, the closure code can be written more concisely.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您有 `testNumbers`，一个数字数组，您使用 `map(_:)` 函数依次将闭包映射到数组的每个元素。闭包中的代码将数字乘以自身，生成该数字的平方。结果
    **[4, 16, 36, 49]** 然后打印到调试区域。您将看到，闭包代码可以写得更加简洁。
- en: 'When a closure’s type is already known, you can remove the parameter type,
    return type, or both. Single-statement closures implicitly return the value of
    their only statement, which means you can remove the `return` statement as well.
    So, you can write the closure as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当闭包的类型已知时，您可以删除参数类型、返回类型或两者。单行闭包隐式返回其唯一语句的值，这意味着您可以删除 `return` 语句。因此，您可以按如下方式编写闭包：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When a closure is the only argument to a function, you can omit the parentheses
    enclosing the closure, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当闭包是函数的唯一参数时，您可以省略包围闭包的括号，如下所示：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can refer to parameters by a number expressing their relative position
    in the list of arguments instead of by name, as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用表示它们在参数列表中相对位置的数字来引用参数，而不是使用名称，如下所示：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: So, the closure is now very concise indeed, but will be challenging for new
    developers to understand. Feel free to write closures in a way that you are comfortable
    with.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，闭包现在确实非常简洁，但对于新开发者来说可能难以理解。请随意以您舒适的方式编写闭包。
- en: You now know how to create and use closures, and how to write them more concisely.
    Great!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经知道如何创建和使用闭包，以及如何更简洁地编写它们。太棒了！
- en: Summary
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you studied how to group statements into functions. You learned
    how to use custom argument labels, functions inside other functions, functions
    as return types, functions as parameters, and the `guard` statement. This will
    be useful later when you need to accomplish the same task at different points
    in your program.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何将语句分组到函数中。您学习了如何使用自定义参数标签、函数内的函数、函数作为返回类型、函数作为参数以及 `guard` 语句。当您需要在程序的不同点完成相同任务时，这将很有用。
- en: You also learned how to create closures. This will be useful when you need to
    pass around blocks of code within your program.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您还学习了如何创建闭包。当您需要在程序中传递代码块时，这将很有用。
- en: In the next chapter, we will study classes, structures, and enumerations. Classes
    and structures allow for the creation of complex objects that can store state
    and behavior, and enumerations can be used to limit the values that can be assigned
    to a variable or constant, reducing the chances of error.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将研究类、结构和枚举。类和结构允许创建可以存储状态和行为复杂对象，枚举可以用来限制可以分配给变量或常量的值，从而减少出错的可能性。
- en: Join us on Discord!
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord！
- en: Read this book alongside other users, experts, and the author himself. Ask questions,
    provide solutions to other readers, chat with the author via Ask Me Anything sessions,
    and much more. Scan the QR code or visit the link to join the community.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、专家和作者本人一起阅读这本书。提出问题，为其他读者提供解决方案，通过 Ask Me Anything 会话与作者聊天，等等。扫描二维码或访问链接加入社区。
- en: '[https://packt.link/ios-Swift](https://packt.link/ios-Swift%0D)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/ios-Swift](https://packt.link/ios-Swift%0D)'
- en: '[![](img/QR_Code2370024260177612484.png)](https://packt.link/ios-Swift%0D)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](img/QR_Code2370024260177612484.png)](https://packt.link/ios-Swift%0D)'
