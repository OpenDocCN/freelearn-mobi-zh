- en: Debugging the Boot Up Process Using a Customized ramdisk
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自定义ramdisk调试启动过程
- en: 'In the last chapter, we learnt to enable Houdini in the Android emulator using
    our own x86emu device. With that, we can move on to more challenging tasks in
    the next few chapters. Most device- or system-level customization will involve
    changes to the Android system start up sequence. In this chapter, we will analyze
    the Android system start up sequence and learn the knowledge related to the customization
    and debugging of the start up sequence. In this chapter, we will cover the following
    topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何在安卓模拟器中使用自己的x86emu设备启用Houdini。有了这个，我们可以在接下来的几章中继续进行更具挑战性的任务。大多数设备或系统级别的定制都将涉及对安卓系统启动顺序的更改。在本章中，我们将分析安卓系统启动顺序，并学习与启动顺序的定制和调试相关的知识。在本章中，我们将涵盖以下主题：
- en: Android start up process analysis
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安卓启动过程分析
- en: Starting up process for the Android-x86
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android-x86的启动过程
- en: Creating a filesystem for the Android-x86 `initrd.img`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Android-x86的`initrd.img`创建文件系统
- en: We will start with the analysis of a normal Android boot up process. After that,
    we will introduce the Android-x86 two-stage boot up. We will build a filesystem
    for the Android emulator that can work with Android-x86 `initrd.img`. This method
    provides a flexible way to help the debugging of start up process.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从分析正常的安卓启动过程开始。之后，我们将介绍Android-x86的双阶段启动。我们将为安卓模拟器构建一个文件系统，它可以与Android-x86的`initrd.img`一起工作。这种方法提供了一种灵活的方式来帮助调试启动过程。
- en: Analyzing the Android start up process
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析安卓启动过程
- en: 'The Android system boot up sequence is similar to other embedded Linux systems
    that start from the Boot ROM inside the processor. The Boot ROM will find the
    bootloader. The bootloader will load the kernel and ramdisk image. The kernel
    uses the ramdisk as the root filesystem. In a desktop Linux environment, once
    the kernel initializes the essential devices, it will remount the root filesystem
    on physical storage such as a hard disk. In Android, the various partitions (system,
    data, cache, and so on) will be mounted to the root filesystem in memory instead
    of a storage device. The kernel will invoke the i**nit** process in the ramdisk
    to start the rest of the system, as shown in the following figure:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓系统的启动顺序与其他从处理器内部的Boot ROM开始的嵌入式Linux系统类似。Boot ROM将找到引导加载程序。引导加载程序将加载内核和ramdisk镜像。内核使用ramdisk作为根文件系统。在桌面Linux环境中，一旦内核初始化了基本设备，它将在硬盘等物理存储上重新挂载根文件系统。在安卓中，各种分区（系统、数据、缓存等）将挂载到内存中的根文件系统，而不是存储设备。内核将在ramdisk中调用**init**进程以启动系统的其余部分，如图所示：
- en: '![](img/image_06_001.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_06_001.png)'
- en: Bootloader and the kernel
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引导加载程序和内核
- en: As we can see, we won't be able to avoid the bootloader when we build our own
    devices. However, we won't spend too much time on this topic, since the bootloader
    is not our focus in this book. In the Android emulator, it is not necessary to
    have a bootloader, since there is a minimal bootloader built inside the emulator
    itself.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，当我们构建自己的设备时，我们无法避免引导加载程序。然而，我们不会在这个主题上花费太多时间，因为引导加载程序不是本书的重点。在安卓模拟器中，不需要有引导加载程序，因为模拟器内部已经构建了一个最小化的引导加载程序。
- en: A very small bootloader in QEMU to boot LinuxIf you are interested in the small
    bootloader in QEMU, you can refer to the AOSP source code at `$AOSP/external/qemu/hw/arm/boot.c`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: QEMU中的一个非常小的引导加载程序来启动Linux如果您对QEMU中的小引导加载程序感兴趣，可以参考位于`$AOSP/external/qemu/hw/arm/boot.c`的AOSP源代码。
- en: Since the bootloader is hardware platform-specific, the bootloader implementation
    in QEMU is different for various hardware architectures, such as ARM, x86, or
    MIPS. The reason why I refer to the ARM implementation is because it is the cleanest
    and easiest to understand.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 由于引导加载程序是硬件平台特定的，因此QEMU中的引导加载程序实现对于不同的硬件架构（如ARM、x86或MIPS）是不同的。我之所以提到ARM实现，是因为它是最干净且最容易理解的。
- en: You can refer to the book *Embedded Programming with Android* written by myself
    and published by Addison-Wesley Professional to find out more about bootloader
    for the Android emulator.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考由我撰写并由Addison-Wesley Professional出版的《嵌入式编程与安卓》一书，以了解更多关于安卓模拟器引导加载程序的信息。
- en: For VirtualBox, which we will use as the virtual hardware from Chapter 8, *Creating
    Your Own Device on VirtualBox* till Chapter 11, *Enabling VirtualBox-Specific
    Hardware Interfaces*, we will use the network boot to resolve the bootloader issue.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们将从第8章的*在VirtualBox上创建自己的设备*到第11章的*启用VirtualBox特定硬件接口*使用的虚拟硬件，我们将使用网络引导来解决引导加载程序问题。
- en: The Linux kernel is one of the key elements to support various hardware devices.
    We will discuss the customization and configuration of the Linux kernel throughout
    this book. In this chapter, we will focus on the init process and see how it works
    in the Android system.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核是支持各种硬件设备的关键元素之一。我们将在本书中讨论Linux内核的定制和配置。在本章中，我们将重点关注init进程，并了解它在Android系统中的工作方式。
- en: Analyzing the init process and ramdisk
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析init进程和ramdisk
- en: 'The implementation of the init process can be found in the `$AOSP/system/core/init`
    directory. If we look at the `main` function in `init.cpp`, it includes the code
    for `ueventd` and `watchdogd`, as shown in the following code snippet:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: init进程的实现可以在`$AOSP/system/core/init`目录中找到。如果我们查看`init.cpp`中的`main`函数，它包括`ueventd`和`watchdogd`的代码，如下面的代码片段所示：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We won''t discuss `ueventd` and `watchdogd`, since they are not related to
    our topics. We will focus on the mainline code of `init.cpp`. The mainline code
    of init implements the following logic:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会讨论`ueventd`和`watchdogd`，因为它们与我们的主题无关。我们将专注于`init.cpp`的主线代码。init的主线代码实现了以下逻辑：
- en: Preparation for the environment, such as creating system folders, setting up
    the standard I/O, initialization of logging systems, and so on. The environment
    setup also includes the SELinux setup and loading the SELinux policy.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 环境准备，例如创建系统文件夹、设置标准I/O、初始化日志系统等。环境设置还包括SELinux设置和加载SELinux策略。
- en: Parsing init scripts `init.rc`, `init.${ro.hardware}.rc`, and so on. Add items
    from the init scripts to the action or service in `action_list` and `service_list`.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析init脚本`init.rc`、`init.${ro.hardware}.rc`等。将init脚本中的项目添加到`action_list`和`service_list`中的动作或服务。
- en: Execute the `early-init` action in `action_list`.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`action_list`中执行`early-init`动作。
- en: Execute the `init` action in `action_list`.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`action_list`中执行`init`动作。
- en: Execute the `late-init` action in `action_list`.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`action_list`中执行`late-init`动作。
- en: 'Enter an infinite loop to perform the following tasks:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入一个无限循环以执行以下任务：
- en: Execute the action in `action_queue`.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`action_queue`中执行动作。
- en: Restart the service marked as `SVC_RESTARTING` in `service_list`.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`service_list`中重启标记为`SVC_RESTARTING`的服务。
- en: Provide the property service, handling `/dev/keychord` events.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供属性服务，处理`/dev/keychord`事件。
- en: Monitor system property changes, signals, and keyboard events.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 监控系统属性变化、信号和键盘事件。
- en: 'The init scripts are stored in the ramdisk and are loaded in memory by the
    bootloader during boot up. If we look at the content of the x86emu `ramdisk.img`,
    we will see the following files:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: init脚本存储在ramdisk中，并在引导过程中由引导加载程序加载到内存中。如果我们查看x86emu的`ramdisk.img`内容，我们将看到以下文件：
- en: '![](img/image_06_002.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_06_002.png)'
- en: 'The init scripts define two types of element: **actions** and **services**.
    The init process parses all the scripts and runs the tasks depending on the type
    of element.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: init脚本定义了两种类型的元素：**动作**和**服务**。init进程解析所有脚本并根据元素的类型运行任务。
- en: Actions
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动作
- en: 'The action syntax is as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 动作语法如下：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Actions begin with the keyword `on`, followed by a trigger. Actions are left-aligned
    and the commands that follow are indented, as shown in the preceding snippet.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 动作以关键字`on`开头，后跟一个触发器。动作左对齐，后续的命令缩进，如前文所示片段。
- en: 'For example, we mount all partitions for the emulator using `fstab.goldfish`
    on trigger `fs`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们使用`fstab.goldfish`在触发`fs`时挂载所有模拟器的分区：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Triggers** are strings that can be used to match certain kinds of event and
    they are used to cause an action to occur. There are two types of action triggers:
    **predefined triggers** and **triggers activated on property-value changes**.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**触发器**是用于匹配某些类型事件的字符串，并且它们用于触发动作的发生。有两种类型的动作触发器：**预定义触发器**和**属性值变化激活的触发器**。'
- en: Predefined triggers could be `early-init`, `init`, `early-fs`, `fs`, `post-fs`,
    `early-boot`, or `boot` as defined in the init scripts.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 预定义触发器可以是`early-init`、`init`、`early-fs`、`fs`、`post-fs`、`early-boot`或`boot`，如init脚本中定义的那样。
- en: 'Property-value triggers are in the following form:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 属性值触发器具有以下形式：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Triggers of this form occur when the `<name>` property is set to a specific
    value `<value>`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当`<name>`属性设置为特定值`<value>`时，这种形式的触发器会发生。
- en: 'For example, when the `sys.init_log_level` property is changed, we need to
    reset the log level as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当`sys.init_log_level`属性更改时，我们需要按照以下方式重置日志级别：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Commands in init scripts reassemble the shell commands and also add init-specific
    ones.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化脚本中的命令重新组装了shell命令，并添加了init特定的命令。
- en: Services
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务
- en: 'Services are programs that init launches and (optionally) restarts when they
    exit. Services take the form of:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 服务是init启动的程序，并在它们退出时（可选地）重新启动。服务的形式如下：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The service will be known by init as `<name>`. The actual name of the binary
    that is pointed to by `<pathname>` will not be recognized.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 服务将以`<name>`的形式被init所知。指向`<pathname>`的实际二进制文件名将不会被识别。
- en: 'Options are modifiers to services. They affect how and when init runs the service.
    We can use the following goldfish-specific service as an example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 选项是服务的修饰符。它们影响init如何以及何时运行服务。我们可以使用以下goldfish特定的服务作为例子：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The name of the service is `goldfish-setup` and it runs the `init.goldfish.sh`
    script as the root user. The `oneshot` option means that this service won't restart
    when it exits.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 服务的名称是`goldfish-setup`，它以root用户身份运行`init.goldfish.sh`脚本。`oneshot`选项意味着当它退出时，此服务不会重新启动。
- en: 'A complete list of `init` commands and `service` options can be found in the
    following file:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的`init`命令和`service`选项列表可以在以下文件中找到：
- en: '`$AOSP/system/core/init/readme.txt`'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`$AOSP/system/core/init/readme.txt`'
- en: Device-specific actions and services
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备特定的动作和服务
- en: The source code of system-generated init scripts is located in the `$AOSP/system/core/rootdir`
    folder. They are copied to `$OUT/root` in the build process.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 系统生成的初始化脚本的源代码位于`$AOSP/system/core/rootdir`文件夹中。它们在构建过程中被复制到`$OUT/root`。
- en: 'The init process parses the `init.rc` script first. All other scripts are imported
    by `init.rc` and then parsed by the init process. If we look at the following
    code snippet of `init.rc`, we can see that there are a few scripts that are imported
    by `init.rc`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化进程首先解析`init.rc`脚本。所有其他脚本都由`init.rc`导入，然后由初始化进程解析。如果我们查看以下`init.rc`代码片段，我们可以看到有几个脚本是由`init.rc`导入的：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `init.${ro.hardware}.rc` script is the one that can be used to customize
    for device-specific changes. The `ro.hardware` property is passed to init at runtime
    so that init can load the right one for the device. We should try to avoid changes
    to other init scripts and keep the device-specific changes in `init.${ro.hardware}.rc`
    only.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`init.${ro.hardware}.rc`脚本是可以用来为设备特定更改进行定制的脚本。`ro.hardware`属性在运行时传递给init，以便init可以加载适合设备的正确版本。我们应该尽量避免更改其他init脚本，并将设备特定的更改仅保留在`init.${ro.hardware}.rc`中。'
- en: 'If we look at the goldfish or ranchu device specifically, there are `init.goldfish.rc`
    and `init.ranchu.rc` scripts for them, respectively. Both scripts are part of
    the goldfish device, which can be found at `$AOSP/device/generic/goldfish`, as
    we can see in the following snippet. They are copied to `$OUT/root` in the build
    process:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们具体查看goldfish或ranchu设备，它们分别有`init.goldfish.rc`和`init.ranchu.rc`脚本。这两个脚本都是goldfish设备的一部分，可以在`$AOSP/device/generic/goldfish`中找到，如下面的代码片段所示。它们在构建过程中被复制到`$OUT/root`。
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Inside `init.goldfish.rc` or `init.ranchu.rc`, a `goldfish-setup` service is
    defined as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在`init.goldfish.rc`或`init.ranchu.rc`内部，定义了一个`goldfish-setup`服务，如下所示：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the last chapter, we added Houdini initialization to the `init.goldfish.sh`
    script and this is how Houdini can be initialized during boot up.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们在`init.goldfish.sh`脚本中添加了Houdini初始化，这就是Houdini在启动过程中初始化的方式。
- en: 'The hardware name in the Android emulator is passed by the kernel command line.
    When you start the emulator with `-verbose` and `-show-kernel`, you will see the
    following command-line parameters in the console:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android模拟器中，硬件名称是通过内核命令行传递的。当你以`-verbose`和`-show-kernel`选项启动模拟器时，你将在控制台看到以下命令行参数：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: These parameters are passed to the kernel as kernel command-line parameters
    and then used by init to decide the hardware name. Since we cannot change the
    kernel parameters in the emulator, we cannot use our own script such as `init.x86emu.rc`
    in our device. If we want to customize the start up sequence, we should change
    the code in `$AOSP/device/generic/goldfish` and this is what we did in the last
    chapter.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数作为内核命令行参数传递给内核，然后由init用来决定硬件名称。由于我们无法在模拟器中更改内核参数，因此我们无法在我们的设备中使用自己的脚本，如`init.x86emu.rc`。如果我们想自定义启动顺序，我们应该更改`$AOSP/device/generic/goldfish`中的代码，这正是我们在上一章所做的事情。
- en: The ideal approach to customizing the start up sequence is to keep all customizations
    under our own `device` folder, such as `$AOSP/device/generic/x86emu`. In that
    case, we can upgrade to the newer Android version very easily. The more general
    AOSP code we change, the more difficult it is to move to a new Android version.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 定制启动序列的理想方法是将所有定制内容放在我们自己的 `device` 文件夹下，例如 `$AOSP/device/generic/x86emu`。在这种情况下，我们可以非常容易地升级到新的
    Android 版本。我们更改的 AOSP 代码越通用，迁移到新 Android 版本就越困难。
- en: If we can have control of the bootloader, we can pass our own kernel parameters
    through the bootloader. We will see this when we work on the x86vbox device in
    Chapter 8, *Creating Your Own Device on VirtualBox* till Chapter 11, *Enabling
    VirtualBox-Specific Hardware Interfaces*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能控制引导加载程序，我们就可以通过引导加载程序传递自己的内核参数。我们将在第 8 章 *在 VirtualBox 上创建自己的设备* 中看到这一点，直到第
    11 章 *启用 VirtualBox 特定硬件接口*。
- en: If you really need to change `init.rc` so that you can fully customize the boot
    up sequence, you can define the `TARGET_PROVIDES_INIT_RC := true` variable in
    your `BoardConfig.mk`. With this definition, you can copy `init.rc` to your `device`
    folder and change it for your device.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的需要更改 `init.rc` 以完全定制启动序列，你可以在你的 `BoardConfig.mk` 中定义 `TARGET_PROVIDES_INIT_RC
    := true` 变量。有了这个定义，你就可以将 `init.rc` 复制到你的 `device` 文件夹中，并为你自己的设备进行更改。
- en: Source code and manifest changes
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源代码和清单文件更改
- en: Now that we have been introduced to Android start up processes, we will now
    apply the two-stage boot up process from the Android-x86 project to the Android
    emulator. Before we talk about the two-stage boot up process, let's have a look
    at the changes for the AOSP source code and manifest file.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了 Android 启动过程，接下来我们将把 Android-x86 项目的双阶段启动过程应用到 Android 模拟器中。在讨论双阶段启动过程之前，让我们先看看
    AOSP 源代码和清单文件的变化。
- en: 'If we look at the following manifest file that we will use for this chapter,
    we can see that we only changed `kernel`, the `x86emu` device, and `newinstaller`
    from the Android-x86 project:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看我们将用于本章的以下清单文件，我们可以看到我们只更改了 `kernel`、`x86emu` 设备和来自 Android-x86 项目的 `newinstaller`：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With the `newinstaller` project, we will build another ramdisk image, `initrd.img`,
    which will be used in the two stage boot up process.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `newinstaller` 项目，我们将构建另一个 ramdisk 映像，`initrd.img`，它将在双阶段启动过程中使用。
- en: A Git tag, `android-7.1.1_r4_x86emu_ch06_r1`, is used to baseline the source
    code changes in this chapter.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Git 标签 `android-7.1.1_r4_x86emu_ch06_r1` 作为本章源代码更改的基准。
- en: The Android-x86 start up process
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android-x86 启动过程
- en: In [Chapter 1](4ddc5eff-b4d7-452c-b83c-0c3c1d40da57.xhtml), *Introduction to
    Android System Programming*, we introduced the Android-x86 project, which is an
    open source project to provide the Android **Board Support Package** (**BSP**)
    for Intel devices. It uses an approach similar to Microsoft Windows or Linux distributions
    for desktops by using universal media to boot all kinds of Intel devices.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 1 章](4ddc5eff-b4d7-452c-b83c-0c3c1d40da57.xhtml) *Android 系统编程简介* 中，我们介绍了
    Android-x86 项目，这是一个开源项目，为英特尔设备提供 Android **板级支持包**（**BSP**）。它使用类似于微软 Windows 或桌面
    Linux 分发的通用媒体来启动各种英特尔设备。
- en: In order to achieve the goal of using one medium to boot all devices, it splits
    the boot sequence into two stages. The first stage is to boot a minimum embedded
    Linux environment to enable hardware devices. In the second stage, it switches
    to the Android system through `chroot` or `switch_root`. The second stage of the
    boot process is the same as we discussed previously. Let's look at the first stage
    of the Android-x86 boot process in detail. We will reuse it for the Android emulator
    in this chapter. This approach can help to simplify the start up process and it
    can also help us a lot with the debugging of start up processes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现使用一种介质启动所有设备的目标，它将启动序列分为两个阶段。第一阶段是启动一个最小的嵌入式 Linux 环境，以启用硬件设备。在第二阶段，它通过
    `chroot` 或 `switch_root` 切换到 Android 系统。启动过程的第二阶段与我们之前讨论的相同。让我们详细看看 Android-x86
    的启动过程的第一阶段。我们将在本章中重用它来模拟 Android 模拟器。这种方法可以帮助简化启动过程，同时也有助于我们调试启动过程。
- en: The first-stage boot using initrd.img
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 initrd.img 的第一阶段启动
- en: 'The first stage of the start up process in Android-x86 uses a specific ramdisk
    `initrd.img`. The source code can be found at `$AOSP/bootable/newinstaller`. This
    project is duplicated from the Android-x86 project. As it is hosted in GitHub,
    I can make my own changes:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Android-x86 的启动过程第一阶段使用特定的 ramdisk `initrd.img`。源代码可以在 `$AOSP/bootable/newinstaller`
    找到。该项目是从 Android-x86 项目复制的。因为它托管在 GitHub 上，我可以对其进行自己的修改：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we look at the contents in this `newinstaller` folder, we can see the preceding
    folders and files. The following is the explanation about the content of `newinstaller`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看 `newinstaller` 文件夹中的内容，我们可以看到前面的文件夹和文件。以下是对 `newinstaller` 内容的解释：
- en: '`boot`: This is the bootloader for the installation media. The images of Android-x86
    can be built into different formats (ISO, UEFI, and so on)'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boot`: 这是安装媒体的引导加载程序。Android-x86 的镜像可以构建成不同的格式（ISO、UEFI 等）'
- en: '`editdisklbl`: A host tool used to edit system image partitions'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`editdisklbl`: 用于编辑系统镜像分区的宿主工具'
- en: '`initrd`: The ramdisk for the first-stage boot'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initrd`: 第一阶段引导的 ramdisk'
- en: '`install` : The installer for Android-x86'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`install` : Android-x86 的安装程序'
- en: '`Android.mk` : Android Makefile for `newinstaller`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Android.mk` : `newinstaller` 的 Android Makefile'
- en: 'If we build `newinstaller`, it can generate a few different image formats,
    such as ISO, USB, or UEFI. To build a specified image, you can run the following
    command after you set up the environment and choose a build target:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们构建 `newinstaller`，它可以生成几种不同的镜像格式，如 ISO、USB 或 UEFI。在设置好环境并选择构建目标后，可以运行以下命令来构建指定的镜像：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Besides an installation image, it also produces another two images, `initrd.img`
    and `install.img`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 除了安装镜像，它还会生成另外两个镜像，`initrd.img` 和 `install.img`：
- en: '`initrd.img` : The ramdisk image for the first stage boot up'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initrd.img` : 第一阶段引导的 ramdisk 镜像'
- en: '`install.img` : The image contains the Android-x86 installer'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`install.img` : 包含 Android-x86 安装程序的镜像'
- en: We will look at the details about both `initrd.img` and `install.img` to understand
    how the first stage boot works in Android-x86.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细了解 `initrd.img` 和 `install.img`，以了解 Android-x86 中第一阶段引导的工作原理。
- en: Inside initrd.img
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 `initrd.img` 内
- en: 'If we look at the `initrd` folder, we can see the following contents:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看 `initrd` 文件夹，我们可以看到以下内容：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The content of `initrd.img` consists of a minimal Linux environment based on
    busybox. We can find busybox at `bin/busybox` and shared libraries required by
    busybox at `lib/`. There is an executable `init` file and a few folders inside
    the `initrd` folder. We know that the init process is the first process invoked
    by the kernel when the system starts. Android-x86 provides a separate init process
    to start the system inside `initrd.img`. This version of init is actually a shell
    script instead of a binary executable file:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`initrd.img` 的内容由基于 busybox 的最小 Linux 环境组成。我们可以在 `bin/busybox` 中找到 busybox，以及
    busybox 所需的共享库在 `lib/` 中。`initrd` 文件夹内有一个可执行的 `init` 文件和一些文件夹。我们知道，init 进程是系统启动时内核调用的第一个进程。Android-x86
    提供了一个单独的 init 进程来在 `initrd.img` 内启动系统。这个版本的 init 实际上是一个 shell 脚本而不是二进制可执行文件：'
- en: '![](img/image_06_003.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_06_003.png)'
- en: 'This shell script will perform the tasks shown in the preceding figure:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 shell 脚本将执行前面图示中的任务：
- en: When the kernel invokes the script, it prepares the environment first. This
    includes the controlling tty setup, the initialization of debug logs, and the
    debug level.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当内核调用脚本时，它首先准备环境。这包括控制台 tty 设置、调试日志的初始化和调试级别。
- en: After the environment is ready, it will try to find either an existing Android
    system or an installation media on the storage devices. In this step, `ramdisk.img`
    must be found, otherwise, it will return with an error.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 环境准备就绪后，它将尝试在存储设备上找到现有的 Android 系统或安装媒体。在这一步，必须找到 `ramdisk.img`，否则将返回错误。
- en: Once an Android system or installation media is found; it will extract `ramdisk.img`
    to the working folder `/android`. If the `INSTALL` variable is set, it will extract
    `install.img` to the filesystem root as well. The working folder `/android` is
    used as the root of the Android system, while the current root is the image of
    `initrd.img`.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦找到 Android 系统或安装媒体，它将 `ramdisk.img` 提取到工作文件夹 `/android`。如果设置了 `INSTALL` 变量，它还将
    `install.img` 提取到文件系统根目录。工作文件夹 `/android` 用作 Android 系统的根目录，而当前根目录是 `initrd.img`
    的镜像。
- en: It now loads all additional scripts to prepare for the next steps. If the environment
    variable `INSTALL` is set to `1`, it will invoke the installation script to install
    Android-x86 to a storage device such as a hard disk.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，它将加载所有额外的脚本以准备下一步。如果环境变量 `INSTALL` 设置为 `1`，它将调用安装脚本将 Android-x86 安装到硬盘等存储设备。
- en: Before it switches to the Android system, it will load all the kernel modules
    for the devices, mount data and SD card partitions, set up the touch screen and
    display DPI, and so on.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在切换到 Android 系统之前，它将加载所有设备的内核模块，挂载数据和 SD 卡分区，设置触摸屏和显示 DPI 等。
- en: Once everything is ready, it switches to the Android system using `/android`
    as the new root and invokes `/init` under the new root. The Android system will
    be started from this point onwards.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一切准备就绪后，它将使用 `/android` 作为新的根目录切换到 Android 系统，并在新的根目录下调用 `/init`。从这一点开始，Android
    系统将被启动。
- en: 'Let''s look at a few important code snippets in the script to get a real feel
    for it:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看脚本中的一些重要代码片段，以真正了解其感觉：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding code snippet, we can see that it invokes the shell function
    `check_root` to find the root of the Android system in an infinite loop. If it
    could not find the root file system, it is stuck in this loop.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们可以看到它通过无限循环调用 shell 函数 `check_root` 来寻找 Android 系统的根。如果它找不到根文件系统，它将卡在这个循环中。
- en: 'In the following `check_root` function, the environment variable `SRC` is passed
    from the kernel command line and specifies the path of the filesystem root. It
    will check whether a `ramdisk.img` can be found in this path or not. If a `ramdisk.img`
    can be found, it will be extracted to the `/android` path, which is the current
    directory, otherwise; it will return an error:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的 `check_root` 函数中，环境变量 `SRC` 从内核命令行传递，并指定文件系统根路径。它将检查在这个路径中是否可以找到 `ramdisk.img`。如果在这个路径中找到了
    `ramdisk.img`，它将被提取到 `/android` 路径，即当前目录，否则；它将返回错误：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After the root filesystem is detected, it will check the environment variable
    `INSTALL`. This `INSTALL` variable is also passed from the kernel command line.
    If `INSTALL` is set, it will extract `install.img` to the current root. This will
    overwrite some of the files in `initrd.img` and we will discuss this in more detail
    later:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在检测到根文件系统后，它将检查环境变量 `INSTALL`。这个 `INSTALL` 变量也是从内核命令行传递的。如果设置了 `INSTALL`，它将提取
    `install.img` 到当前根目录。这将覆盖 `initrd.img` 中的某些文件，我们将在稍后详细讨论这一点：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then it will load all other shell scripts from either the `/scripts` or `/src/scripts`
    folders:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它将从 `/scripts` 或 `/src/scripts` 文件夹加载所有其他 shell 脚本：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once all the shell scripts are loaded in memory, it will check the `INSTALL`
    variable again to see whether it should execute the installation script:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有 shell 脚本都加载到内存中，它将再次检查 `INSTALL` 变量，以查看是否应该执行安装脚本：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: No matter whether it executes the installation script or not, it will prepare
    the environment for the Android system to start. It will load kernel modules,
    mount `data/sdcard` partitions, and set up all other environment-related requirements.
    Lastly, it will execute `switch_root` or `chroot` to switch to the Android system.
    The Android system will be started from this point onwards.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是否执行安装脚本，它都会为 Android 系统的启动准备环境。它将加载内核模块，挂载数据/SD 卡分区，并设置所有其他环境相关要求。最后，它将执行
    `switch_root` 或 `chroot` 以切换到 Android 系统。从这一点开始，Android 系统将被启动。
- en: The main difference between switch_root and chroot**switch_root** is intended
    to switch the complete system over to a new root directory and remove dependencies
    on the old one, so that you can unmount the original root directory and proceed
    as if it had never been in use.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch_root` 和 `chroot` 之间的主要区别在于，**switch_root** 的目的是将整个系统切换到新的根目录，并移除对旧目录的依赖，这样你就可以卸载原始根目录并继续使用，就像它从未被使用过一样。'
- en: '**chroot** is intended to be applied for the lifetime of a single process,
    with the rest of the system continuing to run in the old root directory, and the
    system being unchanged when the chrooted process exits.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**chroot** 的目的是应用于单个进程的生命周期，其余的系统继续在旧的根目录中运行，当 chrooted 进程退出时，系统保持不变。'
- en: In Android-x86, `switch_root` is used in release mode and `chroot` is used in
    debug mode.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android-x86 中，`switch_root` 用于发布模式，而 `chroot` 用于调试模式。
- en: Inside install.img
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 `install.img` 内部
- en: We have analyzed most of the first stage start up processes for Android-x86\.
    One thing that we want to do more analysis on is how `install.img` works in the
    first stage start up process.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经分析了Android-x86的大部分第一阶段启动过程。我们还想进行更多分析的是`install.img`在第一阶段启动过程中的工作方式。
- en: 'If the `INSTALL` environment variable is set, `install.img` will be extracted.
    This will overwrite some of the contents from `initrd.img`. Let''s take a look
    at this now. If we list the contents of both directories `initrd` and `install`,
    we can see that `bin/`, `lib/`, `sbin/`, and `scripts/` are duplicated in both
    images in the following screenshot:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置了`INSTALL`环境变量，`install.img`将被提取。这将覆盖`initrd.img`中的一些内容。现在让我们看看这个。如果我们列出`initrd`和`install`两个目录的内容，我们可以看到以下截图中的`bin/`、`lib/`、`sbin/`和`scripts/`在两个镜像中都存在重复：
- en: '![](img/image_06_004.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_06_004.png)'
- en: In the `bin/`, `sbin/`, and `lib/` folders, there are tools such as `cfdisk`,
    `cgdisk`, `mkntfs`, `grub`, and so on. These are the tools used to partition hard
    disks, format extra filesystems, and so on.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在`bin/`、`sbin/`和`lib/`文件夹中，有诸如`cfdisk`、`cgdisk`、`mkntfs`、`grub`等工具。这些工具用于分区硬盘、格式化额外的文件系统等。
- en: The `scripts/` folder includes the installation script and we will look at `scripts/`
    to explore how the Android-x86 installation works.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`scripts/`文件夹包括安装脚本，我们将查看`scripts/`以探索Android-x86安装的工作原理。'
- en: 'If we look at the script files in both the `initrd` and `install` folders,
    we find that both include a `1-install` script. `initrd.img` is used as the root
    filesystem in the first stage boot. If the `INSTALL` variable is set, `install.img`
    will be extracted to the root as well. In that case, the one in the `install`
    folder will overwrite the one in the `initrd` folder. We can see from the following
    figure how `initrd.img`, `ramdisk.img`, and `install.img` are integrated to form
    the first stage and the second-stage filesystem:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看`initrd`和`install`文件夹中的脚本文件，我们会发现两者都包含一个`1-install`脚本。`initrd.img`在第一阶段引导时用作根文件系统。如果设置了`INSTALL`变量，`install.img`也将被提取到根目录。在这种情况下，`install`文件夹中的脚本将覆盖`initrd`文件夹中的脚本。我们可以从以下图中看到`initrd.img`、`ramdisk.img`和`install.img`是如何集成以形成第一阶段和第二阶段文件系统的：
- en: '![](img/image_06_005.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_06_005.png)'
- en: 'If we look at `1-install` under the `initrd/scripts` folder, we will see the
    following shell script function:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看`initrd/scripts`文件夹下的`1-install`，我们将看到以下shell脚本函数：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It implements a `do_install` function, which will return an error message.
    If this script is not overwritten by the one from `install.img`, it means the
    installer is not available. If `install.img` is extracted, the real `do_install`
    function will be invoked to start the installation:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 它实现了一个`do_install`函数，该函数将返回错误信息。如果此脚本没有被`install.img`中的脚本覆盖，这意味着安装程序不可用。如果提取了`install.img`，则将调用真正的`do_install`函数以启动安装：
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `do_install` function will call another function, `install_hd`, and `install_hd`
    will call an `install_to` function to perform the actual installation. The `install_to`
    function takes a parameter that is the target device for the installation. It
    will perform the following installation tasks:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`do_install`函数将调用另一个函数`install_hd`，而`install_hd`将调用`install_to`函数以执行实际安装。`install_to`函数接受一个参数，即安装的目标设备。它将执行以下安装任务：'
- en: It will format the target device first and then mount the device to the `/hd`
    folder.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将首先格式化目标设备，然后将设备挂载到`/hd`文件夹。
- en: It will install GRUB as the bootloader.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将安装GRUB作为引导加载程序。
- en: It will create a folder using the `android-$VER` naming convention in the `/hd`
    folder as the target installation folder. For example, as our device is x86emu,
    the installation target will be `/hd/android-x86emu`.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将在`/hd`文件夹中使用`android-$VER`命名约定创建一个文件夹，作为目标安装文件夹。例如，由于我们的设备是x86emu，安装目标将是`/hd/android-x86emu`。
- en: It will use the `cpio` command to copy the files from the installation media
    to the installation target. These files include `kernel`, `initrd.img`, `ramdisk.img`,
    and everything under the `system` folder from the AOSP build. It depends on the
    configuration; it may either copy the `system.sfs` or `system.img` image file,
    or it may copy everything in the `system` folder directly to `/hd/android-$VER/system`.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将使用`cpio`命令将文件从安装介质复制到安装目标。这些文件包括`kernel`、`initrd.img`、`ramdisk.img`以及来自AOSP构建的`system`文件夹下的所有内容。它取决于配置；它可能复制`system.sfs`或`system.img`镜像文件，或者它可能直接将`system`文件夹中的所有内容复制到`/hd/android-$VER/system`。
- en: In the following sections, we need to repeat the installation procedure to create
    a filesystem that can be used for the Android-x86 two-stage boot sequence.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们需要重复安装过程以创建一个可用于 Android-x86 双阶段引导序列的文件系统。
- en: Building x86emu with initrd.img
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 initrd.img 构建 x86emu
- en: After we did all the analysis of `initrd.img` for Android-x86, we can build
    a similar one for the Android emulator now. Be aware that this can work only with
    ranchu, but not with goldfish. The goldfish emulator uses an older version of
    QEMU and it doesn't support the additional storage devices for the emulator. To
    support the boot from `initrd.img`, we have to change the layout of the filesystem.
    It is not good to change the original filesystem image in AOSP. We will create
    another file image to be used for the boot with `initrd.img`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对 Android-x86 的 `initrd.img` 进行了所有分析之后，我们现在可以为 Android 模拟器构建一个类似的镜像。请注意，这只能在
    ranchu 上工作，而不能在 goldfish 上工作。goldfish 模拟器使用较旧的 QEMU 版本，并且不支持模拟器的附加存储设备。为了支持从 `initrd.img`
    启动，我们必须更改文件系统的布局。在 AOSP 中更改原始文件系统镜像并不是一个好的选择。我们将创建另一个用于与 `initrd.img` 启动的文件镜像。
- en: 'In the ranchu emulator, the images are emulated as virtio block devices. After
    we start the emulator, we can inspect the mount points, as shown in the following
    screenshot. We can see that `system.img` is mounted as `/dev/block/vda`, `userdata.img`
    as `/dev/block/vdb`, and `cache.img` as `/dev/block/vdc`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ranchu 模拟器中，镜像被模拟为 virtio 块设备。在我们启动模拟器后，我们可以检查挂载点，如下面的屏幕截图所示。我们可以看到 `system.img`
    被挂载为 `/dev/block/vda`，`userdata.img` 为 `/dev/block/vdb`，而 `cache.img` 为 `/dev/block/vdc`：
- en: '![](img/image_06_006.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_06_006.png)'
- en: ranchu images emulated as virtio block devices
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ranchu 镜像模拟为 virtio 块设备
- en: 'All partitions in the ranchu emulator are mounted using the `fstab.ranchu`
    file, as we can see in the following snippet:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ranchu 模拟器中，所有分区都使用 `fstab.ranchu` 文件挂载，如下面的代码片段所示：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: With the ranchu emulator, we can easily add another storage device with the
    `-hda` QEMU option. With this option, we can see that a new block device, `/dev/block/sda`,
    is available after the emulator starts. We will discuss this in more detail later.
    Before we can test this idea, we need to create the disk image first.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ranchu 模拟器，我们可以轻松地通过 `-hda` QEMU 选项添加另一个存储设备。使用此选项，我们可以看到在模拟器启动后，一个新的块设备
    `/dev/block/sda` 可用。我们将在稍后详细讨论这个问题。在我们能够测试这个想法之前，我们需要首先创建磁盘镜像。
- en: Creating a filesystem image
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建文件系统镜像
- en: 'There are many ways that we can create disk images. QEMU can support many disk
    image formats. If you want to find details about the image formats that can be
    supported by QEMU, you can check using the following Linux command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建磁盘镜像的方法有很多。QEMU 支持许多磁盘镜像格式。如果您想查找 QEMU 可以支持哪些图像格式的详细信息，可以使用以下 Linux 命令进行查看：
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The supported image formats are:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的图像格式有：
- en: '**raw**: This plain disk image format has the advantage of being simple and
    easily exportable to all other emulators.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**raw**：这种简单的磁盘镜像格式具有简单且易于导出到所有其他模拟器的优势。'
- en: '**qcow2**: This is the QEMU image format, which is the most versatile format.
    It is a compressed image format, so it has a smaller image size and can support
    snapshots.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**qcow2**：这是 QEMU 镜像格式，是最通用的格式。它是一种压缩镜像格式，因此具有更小的镜像大小，并且可以支持快照。'
- en: '**qcow**: This is the old QEMU image format.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**qcow**：这是旧的 QEMU 镜像格式。'
- en: '**cow**: This is the User Mode Linux Copy-On-Write image format.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cow**：这是 User Mode Linux Copy-On-Write 镜像格式。'
- en: '**vdi**: This is the VirtualBox 1.1-compatible image format.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**vdi**：这是与 VirtualBox 1.1 兼容的镜像格式。'
- en: '**vmdk**: This is the VMware 3- and 4-compatible image format.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**vmdk**：这是 VMware 3 和 4 兼容的镜像格式。'
- en: '**vpc**: This is the VirtualPC-compatible image format (VHD).'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**vpc**：这是与 VirtualPC 兼容的镜像格式（VHD）。'
- en: '**cloop**: This is the Linux compressed loop image, useful only to reuse directly
    compressed CD-ROM images present, for example, in Knoppix CD-ROMs.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cloop**：这是 Linux 压缩循环镜像，仅适用于直接重用现有的压缩 CD-ROM 镜像，例如 Knoppix CD-ROM。'
- en: 'We will use the qcow2 file format to test our `initrd.img` for the Android
    emulator. In order to create a file image in qcow2 format, we need to add the
    following code in the `Android.mk` Makefile of `bootable/newinstaller`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 qcow2 文件格式来测试 Android 模拟器的 `initrd.img`。为了创建 qcow2 格式的文件镜像，我们需要在 `bootable/newinstaller`
    的 `Android.mk` Makefile 中添加以下代码：
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The first thing that we have to do in the preceding Makefile is to create a
    directory layout that can be used by `initrd.img`, as shown in the following snippet:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 Makefile 中，我们必须做的第一件事是创建一个目录布局，该布局可以被 `initrd.img` 使用，如下面的代码片段所示：
- en: '![](img/image_06_007.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_06_007.png)'
- en: Directory layout of x86emu_x86.img
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: x86emu_x86.img 的目录布局
- en: We create a `data` folder to be used as data storage. Then, we move existing
    image files in the AOSP output folder to the `$OUT/x86emu_tmp/x86emu_x86` directory
    in order to create the preceding directory structure. These file images will be
    moved back after the file image is generated.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个 `data` 文件夹作为数据存储使用。然后，我们将 AOSP 输出文件夹中的现有镜像文件移动到 `$OUT/x86emu_tmp/x86emu_x86`
    目录，以创建前面的目录结构。这些文件镜像将在文件镜像生成后移回。
- en: 'Once we have the right directory structure, we can use the `make_ext4fs` command
    to create a raw filesystem image with the following options:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了正确的目录结构，我们就可以使用 `make_ext4fs` 命令创建具有以下选项的原始文件系统镜像：
- en: '[PRE25]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The size of the filesystem is `BOARD_SYSTEMIMAGE_PARTITION_SIZE`; additionally,
    `X86EMU_EXTRA_SIZE`. `BOARD_SYSTEMIMAGE_PARTITION_SIZE` is defined in the board
    configuration file for the system image size. `X86EMU_EXTRA_SIZE` is for the space
    of ramdisk and kernel images.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统的尺寸是 `BOARD_SYSTEMIMAGE_PARTITION_SIZE`；此外，`X86EMU_EXTRA_SIZE`。`BOARD_SYSTEMIMAGE_PARTITION_SIZE`
    定义在系统镜像大小的板级配置文件中。`X86EMU_EXTRA_SIZE` 是用于 ramdisk 和内核镜像的空间。
- en: The next step is to generate the qcow2 format from the raw file image using
    the `qemu-img` command. Both raw and qcow2 format images can be used by the emulator,
    but the raw file image is much larger than the qcow2 image.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用 `qemu-img` 命令将原始文件镜像转换为 qcow2 格式。原始和 qcow2 格式的镜像都可以由模拟器使用，但原始文件镜像比 qcow2
    镜像大得多。
- en: 'Since the qcow2 image can support the snapshot feature, we can also generate
    a snapshot image (`x86emu_x86.img`) based on the qcow2 image (`x86emu_x86-qcow2.img`).
    If we use the snapshot image, we can restore to the original qcow2 image at any
    time. The snapshot image can be created using the following commands:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 qcow2 镜像支持快照功能，我们也可以根据 qcow2 镜像（`x86emu_x86-qcow2.img`）生成快照镜像（`x86emu_x86.img`）。如果我们使用快照镜像，我们可以在任何时候恢复到原始的
    qcow2 镜像。可以使用以下命令创建快照镜像：
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After the image is generated, we can inspect it using the `qemu-img` command
    as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像生成后，我们可以使用以下 `qemu-img` 命令检查它：
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We see that the `x86emu_x86.img` image is the snapshot image of `x86emu_x86-qcow2.img`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 `x86emu_x86.img` 镜像是 `x86emu_x86-qcow2.img` 的快照镜像。
- en: In the image that we just created, there are no partitions created. When we
    mount it in the Android emulator, it will appear as a `/dev/sda` or `/dev/block/sda`
    device. If we want to create partitions for the image file, we need to use the
    `edit_mbr` tool to do so. You can explore this option on your own. With multiple
    partitions, we can put the system, data, and cache into different partitions,
    which is closer to the disk layout in most mobile devices.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚刚创建的镜像中，没有创建分区。当我们将其挂载到 Android 模拟器中时，它将显示为 `/dev/sda` 或 `/dev/block/sda`
    设备。如果我们想为镜像文件创建分区，我们需要使用 `edit_mbr` 工具来完成。您可以自行探索这个选项。使用多个分区，我们可以将系统、数据和缓存放入不同的分区，这更接近大多数移动设备的磁盘布局。
- en: Kernel changes
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核更改
- en: With effect from Android 4.4, SELinux is on by default. When we change the filesystem
    in Android, we have to take care of the SELinux settings as well. This will make
    the configuration more complicated than what we expect. If you are interested
    in this, you can do your homework to configure SELinux for this case.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Android 4.4 开始，SELinux 默认启用。当我们更改 Android 中的文件系统时，我们还需要注意 SELinux 设置。这将使配置比我们预期的更复杂。如果您对此感兴趣，您可以为此情况配置
    SELinux，并完成您的作业。
- en: 'In this book, we will disable SELinux by default so that we can concentrate
    on our topics. To disable SELinux, we have to make some changes the kernel configuration
    file. You can check the changes using the `git` command as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将默认禁用 SELinux，以便我们可以专注于我们的主题。要禁用 SELinux，我们必须对内核配置文件进行一些更改。您可以使用以下 `git`
    命令检查更改：
- en: '[PRE28]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can see the changes in the `android-x86emu-3.10` branch using `gitk`, as
    shown in the following screenshot. We can see that we set the default security
    to DAC and removed the SELinux setting, `CONFIG_SECURITY_SELINUX=y`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `gitk` 查看在 `android-x86emu-3.10` 分支中的更改，如下所示截图。我们可以看到我们设置了默认的安全策略为 DAC，并移除了
    SELinux 设置，`CONFIG_SECURITY_SELINUX=y`：
- en: '![](img/image_06_008.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_06_008.png)'
- en: Disabling SELinux in the ranchu kernel
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ranchu 内核中禁用 SELinux
- en: Booting a disk image on the Android emulator
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Android 模拟器上启动磁盘镜像
- en: 'Once we have done all the changes, we can build the qcow2 image using the following
    command:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了所有更改，我们可以使用以下命令构建 qcow2 镜像：
- en: '[PRE29]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As we can see from the preceding command-line output, `system.img` will be
    built as usual. After that, the ramdisk image, `initrd.img`, will be created as
    follows. Pay attention to the `VER` environment variable. We changed the script
    to set it as `x86emu`. The original one in Android-x86 is the current date, such
    as 2016-11-11:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述命令行输出所示，`system.img`将按常规构建。之后，将创建ramdisk镜像`initrd.img`，如下所示。请注意`VER`环境变量。我们将脚本更改为将其设置为`x86emu`。Android-x86中的原始版本是当前日期，例如2016-11-11：
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This variable is used as part of the installation folder name. Let''s continue
    reviewing the build log:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 此变量用作安装文件夹名称的一部分。让我们继续审查构建日志：
- en: '[PRE31]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After ramdisk `initrd.img` is created, the raw and qcow2 file images will be
    created as we have added in the `Android.mk` file for `bootable/newinstaller`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建ramdisk `initrd.img`之后，将根据我们在`Android.mk`文件中为`bootable/newinstaller`添加的内容创建原始和qcow2文件镜像：
- en: '[PRE32]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We have the `x86emu_x86-qcow2.img` qcow2 image and the `x86emu_x86.img` snapshot
    image now. In order to test the images, we can use a shell script to help us.
    The shell script can be downloaded from GitHub at the following URL:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有`x86emu_x86-qcow2.img` qcow2镜像和`x86emu_x86.img`快照镜像。为了测试这些镜像，我们可以使用一个shell脚本来帮助我们。这个shell脚本可以从以下GitHub
    URL下载：
- en: '[https://github.com/shugaoye/asp-sample/blob/master/scripts/test-initrd.sh](https://github.com/shugaoye/asp-sample/blob/master/scripts/test-initrd.sh)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/shugaoye/asp-sample/blob/master/scripts/test-initrd.sh](https://github.com/shugaoye/asp-sample/blob/master/scripts/test-initrd.sh)'
- en: 'To run this script, you should set up your SDK environment first so that we
    can find the emulator in the `$PATH` environment variable:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此脚本，您应该首先设置您的SDK环境，这样我们就可以在`$PATH`环境变量中找到模拟器：
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To launch this script, you can use the AOSP build result directly or you can
    download the images from SourceForge at the following URL:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动此脚本，您可以直接使用AOSP构建结果，或者您可以从以下SourceForge URL下载镜像：
- en: '[https://sourceforge.net/projects/android-system-programming/files/android-7/ch06/ch06.zip/download](https://sourceforge.net/projects/android-system-programming/files/android-7/ch06/ch06.zip/download)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://sourceforge.net/projects/android-system-programming/files/android-7/ch06/ch06.zip/download](https://sourceforge.net/projects/android-system-programming/files/android-7/ch06/ch06.zip/download)'
- en: If you use the AOSP build result, the script will use the `$OUT` environment
    variable to look for the images. If the `$OUT` environment variable is not set,
    it will assume that the images are stored in the current directory.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用AOSP构建结果，脚本将使用`$OUT`环境变量来查找镜像。如果`$OUT`环境变量未设置，它将假定镜像存储在当前目录中。
- en: To run the Android emulator in a remote *X* window session, we need to use VirtualGL
    for OpenGL ES support. With any command-line parameter, the script will launch
    the emulator using VirtualGL. If you use a Linux machine with a local *X* window
    session, you don't have to do this.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要在远程*X*窗口会话中运行Android模拟器，我们需要使用VirtualGL来支持OpenGL ES。无论使用哪个命令行参数，脚本都会使用VirtualGL启动模拟器。如果你使用带有本地*X*窗口会话的Linux机器，你不需要这样做。
- en: 'To use `initrd.img` as the ramdisk, we can see that we specify `initrd.img`
    in the `-ramdisk` option in the emulator command line. The next thing that we
    need to pay attention to is the QEMU options. We can specify QEMU options after
    the `-qemu` Android emulator option. We use two QEMU options, `-append` and `-hda`.
    With the `-hda` option, we can add the `x86emu_x86-qcow2.img` image or the `x86emu_x86.img`
    snapshot image as another hard disk for the emulator. With the `-append` option,
    we can provide kernel parameters that we want to pass to the ranchu kernel. All
    other kernel parameters are the same as the one provided by the emulator except
    for the following parameters:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`initrd.img`作为ramdisk，我们可以看到在模拟器命令行中我们指定了`initrd.img`在`-ramdisk`选项中。接下来我们需要注意的点是QEMU选项。我们可以在`-qemu`
    Android模拟器选项之后指定QEMU选项。我们使用两个QEMU选项，`-append`和`-hda`。使用`-hda`选项，我们可以将`x86emu_x86-qcow2.img`镜像或`x86emu_x86.img`快照镜像作为模拟器的另一个硬盘。使用`-append`选项，我们可以提供我们想要传递给ranchu内核的内核参数。所有其他内核参数与模拟器提供的相同，除了以下参数：
- en: '`DEBUG=2`: This option sets the debug level to `2` so that we can get the debug
    console during boot up'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DEBUG=2`：此选项将调试级别设置为`2`，这样我们就可以在启动时获取调试控制台'
- en: '`root=/dev/sda`: This option specifies the root device as `/dev/sda`, which
    is the `x86emu_x86-qcow2.img` image or the `x86emu_x86.img` snapshot image that
    we provide as a QEMU option'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`root=/dev/sda`：此选项指定根设备为`/dev/sda`，这是我们作为QEMU选项提供的`x86emu_x86-qcow2.img`镜像或`x86emu_x86.img`快照镜像'
- en: '`SRC=x86emu_x86`: This option defines the folder name on the root device that
    init can use to find all images'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SRC=x86emu_x86`：此选项定义了 init 可以在根设备上使用的文件夹名称，以查找所有镜像'
- en: 'You can launch the script from the command line and you will see the following
    screen output:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从命令行启动脚本，您将看到以下屏幕输出：
- en: '[PRE34]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the command-line log and the following screenshot, you can see that the
    `/dev/sda` root device is found and mounted at `/mnt`. The Android system image
    is mounted as a loop device to `/dev/loop0`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行日志和下面的屏幕截图中，你可以看到 `/dev/sda` 根设备已被找到并挂载到 `/mnt`。Android 系统镜像被挂载为循环设备到 `/dev/loop0`：
- en: '![](img/image_06_009.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_06_009.png)'
- en: Debug console of initrd.img
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: initrd.img 的调试控制台
- en: After you exit the shell console, the Android system will start up as usual.
    With this approach, you can get a debug console at the point when you want to
    troubleshoot any issues. You can also change any Android startup scripts on-the-fly
    without rebuilding a new image to test. All the flexibilities in this setup will
    help debugging of the boot up process a lot.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 退出 shell 控制台后，Android 系统将像往常一样启动。使用这种方法，您可以在需要调试任何问题时获得调试控制台。您还可以即时更改任何 Android
    启动脚本，而无需重新构建新镜像进行测试。这种设置中的所有灵活性都将极大地帮助调试启动过程。
- en: Summary
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learnt about the startup process for the Android system.
    After that, we dived deep into the startup process for Android-x86\. We found
    a new way to boot up the system to a minimum Linux environment first and then
    use that environment to boot the Android system. In this process, we can gain
    control by obtaining a shell console so that we can examine the system at a given
    point. To support this kind of boot, we learnt how to build a system image that
    can be used together with `initrd.img`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 Android 系统的启动过程。之后，我们深入探讨了 Android-x86 的启动过程。我们发现了一种新的启动系统的方法，首先将系统启动到最小
    Linux 环境，然后使用该环境启动 Android 系统。在这个过程中，我们可以通过获取 shell 控制台来获得控制权，以便在特定点检查系统。为了支持这种启动方式，我们学习了如何构建可以与
    `initrd.img` 一起使用的系统镜像。
- en: In the next chapter, we will continue exploring how to customize the Android
    emulator by adding a Wi-Fi connection to it.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续探讨如何通过添加 Wi-Fi 连接来自定义 Android 模拟器。
