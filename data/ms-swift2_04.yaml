- en: Chapter 4. Control Flow and Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。控制流和函数
- en: While I was learning BASIC programming on my Vic-20, every month I would read
    several of the early computer magazines such as *Byte Magazine*. I remember one
    particular review that I read; it was for a game called *Zork*. While *Zork* was
    not a game that was available for my Vic-20, the concept of the game fascinated
    me because I was really into Sci-Fi and fantasy. I remember thinking how cool
    it would be to write a game like that, so I decided to figure out how to do it.
    One of the biggest concepts that I had to grasp at that time was controlling the
    flow of the application depending on the user's actions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在我的Vic-20上学习BASIC编程时，每个月我都会阅读几本早期的计算机杂志，如《Byte杂志》。我记得我阅读的一个特别评论；它是一篇关于一款名为《Zork》的游戏的评论。虽然《Zork》不是为我的Vic-20提供的游戏，但游戏的概念深深吸引了我，因为我真的很喜欢科幻和奇幻。我记得在想，写一个那样的游戏会多么酷，所以我决定找出如何做到这一点。当时我必须掌握的最大概念之一是根据用户的操作控制应用程序的流程。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What are conditional statements and how to use them
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件语句是什么以及如何使用它们
- en: What are loops and how to use them
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环是什么以及如何使用它们
- en: What are control transfer statements and how to use them
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制转移语句是什么以及如何使用它们
- en: How to create and use functions in Swift
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在Swift中创建和使用函数
- en: What we have learned so far
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们到目前为止学到了什么
- en: Up to this point, we have been laying the foundation for writing applications
    with Swift. While it is possible to write a very basic application with what we
    have learned so far, it would be really difficult to write a useful application
    using only what we covered in the first three chapters.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在为使用Swift编写应用程序打下基础。虽然我们可以用我们学到的东西编写一个非常基础的程序，但仅使用我们前三章中涵盖的内容来编写一个有用的应用程序将会非常困难。
- en: Starting with this chapter, we will begin to move away from the foundations
    of the Swift language, and begin to learn the building blocks of application development
    with Swift. In this chapter, we will go over control flow and functions. To become
    a master of the Swift programming language, it is important that you fully understand
    and comprehend the concepts discussed in this chapter and in [Chapter 5](ch05.html
    "Chapter 5. Classes and Structures"), *Classes and Structures*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章开始，我们将开始从Swift语言的根基中走出来，并开始学习使用Swift进行应用开发的构建块。在本章中，我们将介绍控制流和函数。要成为Swift编程语言的大师，完全理解和掌握本章以及[第5章](ch05.html
    "第5章。类和结构")中讨论的概念是非常重要的。
- en: Before we cover control flow and functions, let's take a look at how curly brackets
    and parentheses are used in Swift.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们介绍控制流和函数之前，让我们看看在Swift中如何使用花括号和括号。
- en: Curly brackets
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 括号
- en: 'In Swift, unlike other C-like languages, curly brackets are required for conditional
    statements and loops. In other C-like languages, if there is only one statement
    to execute for a conditional statement or a loop, the curly brackets around that
    line are optional. This has lead to numerous errors and bugs, such as Apple''s
    `goto fail` bug; therefore, when Apple was designing Swift, they decided to use
    curly brackets, even when there is only one line of code to execute. Let''s look
    at some code that illustrates this. This first example is not valid in Swift because
    it is missing the curly brackets; however, it will be valid in most other languages:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，与其它C-like语言不同，条件语句和循环需要使用花括号。在其它C-like语言中，如果条件语句或循环只有一个要执行的语句，那么围绕该行的花括号是可选的。这导致了大量的错误和bug，例如苹果的`goto
    fail` bug；因此，当苹果设计Swift时，他们决定使用花括号，即使只有一行代码要执行。让我们看看一些说明这一点的代码。以下第一个例子在Swift中是无效的，因为它缺少花括号；然而，它将在大多数其它语言中是有效的：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In Swift, you are required to have the curly brackets, as illustrated in the
    following example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，你需要使用花括号，如下面的例子所示：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Parentheses
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 括号
- en: 'Unlike other C-like languages, the parentheses around conditional expressions
    in Swift are optional. In the preceding example, we put parentheses around the
    conditional expression, but they are not required. The following example would
    be valid in Swift, but not valid in most C-like languages:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 与其它C-like语言不同，Swift中条件表达式的括号是可选的。在上面的例子中，我们围绕条件表达式放置了括号，但它们不是必需的。以下例子在Swift中是有效的，但在大多数C-like语言中则不是：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Control flow
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制流
- en: Control flow, also known as flow of control, refers to the order in which statements,
    instructions, or functions are executed within an application. Swift supports
    all of the familiar control flow statements that are in C-like languages. These
    include loops (including `for` and `while`), conditional statements (including
    `if` and `switch`) and the transfer of the control statements (including `break`
    and `continue`). In addition to the standard C control flow statements, Swift
    has also added additional statements, such as the `for-in` loop, and enhanced
    some of the existing statements, such as the `switch` statement.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 控制流，也称为流程控制，指的是在应用程序中语句、指令或函数执行的顺序。Swift 支持所有熟悉的 C 类语言中的控制流语句。这包括循环（包括 `for`
    和 `while`）、条件语句（包括 `if` 和 `switch`）和控制语句的转移（包括 `break` 和 `continue`）。除了标准的 C 控制流语句之外，Swift
    还添加了额外的语句，例如 `for-in` 循环，并增强了一些现有的语句，例如 `switch` 语句。
- en: Let's begin by looking at conditional statements in Swift.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看 Swift 中的条件语句开始。
- en: Conditional statements
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件语句
- en: A conditional statement will check a condition and execute a block of code only
    if the condition is true. Swift provides both the `if` and `if-else` conditional
    statements. Let's take a look at how to use these conditional statements to execute
    blocks of code if a specified condition is true.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句将检查条件，并且只有当条件为真时才会执行代码块。Swift 提供了 `if` 和 `if-else` 条件语句。让我们看看如何使用这些条件语句在指定的条件为真时执行代码块。
- en: The if statement
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`if` 语句'
- en: 'The `if` statement will check the conditional statement and if it is true,
    it will execute the block of code. The `if` statement takes the following format:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 语句将检查条件语句，如果条件为真，它将执行代码块。`if` 语句采用以下格式：'
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, let''s look at how to use the `if` statement:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用 `if` 语句：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding example, we begin by setting the `teamOneScore` and `teamTwoScore`
    constants. We then use the `if` statement to check whether the value of `teamOneScore`
    is greater than the value of `teamTwoScore`. If the value is greater, we print
    `Team One Won` to the console. If we run this code, we will indeed see that `Team
    One Won` is printed to the console, but if the value of `teamTwoScore` was greater
    than the value of `teamOneScore`, nothing would be printed to the console. That
    would not be the best way to write an application because we would want the user
    to know which team actually won. The `if-else` statement can help us with this
    problem.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们首先设置了 `teamOneScore` 和 `teamTwoScore` 常量。然后我们使用 `if` 语句来检查 `teamOneScore`
    的值是否大于 `teamTwoScore` 的值。如果值更大，我们将 `Team One Won` 打印到控制台。如果我们运行此代码，我们确实会看到 `Team
    One Won` 被打印到控制台，但如果 `teamTwoScore` 的值大于 `teamOneScore` 的值，则不会打印任何内容到控制台。这并不是编写应用程序的最佳方式，因为我们希望用户知道哪个队伍实际上获胜了。`if-else`
    语句可以帮助我们解决这个问题。
- en: Conditional code execution with the if-else statement
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `if-else` 语句进行条件代码执行
- en: 'The `if-else` statement will check the conditional statement and if it is true,
    it will execute a block of code. If the conditional statement is not true, it
    will execute a separate block of code. The `if-else` statement follows this format:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`if-else` 语句将检查条件语句，如果条件为真，它将执行一个代码块。如果条件语句不为真，它将执行另一个代码块。`if-else` 语句遵循以下格式：'
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s modify the preceding example to use the `if-else` statement to tell
    the user which team won:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改前面的示例，使用 `if-else` 语句来告诉用户哪个队伍获胜：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This new version will print out `Team One Won`, if the value of `teamOneScore`
    is greater than the value of `teamTwoScore`; otherwise, it will print out the
    message, `Team Two Won`. What do you think the code will do if the value of `teamOneScore`
    was equal to the value of `teamTwoScore`? In the real world, we will have a tie,
    but in the preceding code, we will print out `Team Two Won`; this would not be
    fair to team one. In cases like this, we can use multiple `else if` statements
    and a plain `else` statement, as shown in the following example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新版本将在 `teamOneScore` 的值大于 `teamTwoScore` 的值时打印出 `Team One Won`；否则，它将打印出消息，`Team
    Two Won`。你认为如果 `teamOneScore` 的值等于 `teamTwoScore` 的值，代码会做什么？在现实世界中，我们将会有平局，但在前面的代码中，我们将打印出
    `Team Two Won`；这对第一队来说是不公平的。在这种情况下，我们可以使用多个 `else if` 语句和一个普通的 `else` 语句，如下面的示例所示：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, if the value of `teamOneScore` is greater than the value
    of `teamTwoScore`, we print `Team One Won` to the console. We then have another
    `if` statement that checks to see whether the value of `teamTwoScore` is greater
    than the value of `teamOneScore`, but this `if` statement follows an `else` statement,
    which means the `if` statement is checked only if the previous conditional statement
    is false. Finally, if both the `if` statements were false, then we assume that
    the values are equal and print `We have a tie` to the console.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，如果 `teamOneScore` 的值大于 `teamTwoScore` 的值，我们将打印 `Team One Won` 到控制台。然后我们还有一个
    `if` 语句来检查 `teamTwoScore` 的值是否大于 `teamOneScore` 的值，但这个 `if` 语句跟随一个 `else` 语句，这意味着只有当前面的条件语句为假时，才会检查这个
    `if` 语句。最后，如果两个 `if` 语句都为假，那么我们假设值是相等的，并将 `We have a tie` 打印到控制台。
- en: A conditional statement checks the condition once, and if the condition is met,
    it executes the block of code. What if we wanted to continuously execute the block
    of code until a condition is met? For this, we would use one of the looping statements
    that are in Swift. Let's take a look at looping statements in Swift.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句会检查条件一次，如果条件满足，它将执行代码块。如果我们想连续执行代码块直到满足条件怎么办？为此，我们将使用 Swift 中的循环语句之一。让我们看看
    Swift 中的循环语句。
- en: The for loops
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: For 循环
- en: The for loop variants are probably the most widely used looping statements.
    Swift offers the standard C-based for loop and also an extra `for-in` loop. The
    standard C-based `for` loop executes a block of code until a condition is met,
    usually by incrementing or decrementing a counter. The `for-in` statement will
    execute a block of code for each item in a range, collection, or sequence. We
    usually use one of the for loop variants when we need to iterate over a collection,
    or have a set number of times we want to execute a block of code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环的变体可能是最广泛使用的循环语句。Swift 提供了基于 C 的标准 `for` 循环以及额外的 `for-in` 循环。基于 C 的标准
    `for` 循环会执行代码块直到满足条件，通常是通过增加或减少计数器来实现的。`for-in` 语句将为范围、集合或序列中的每个项目执行代码块。当我们需要遍历集合或有一个固定次数要执行代码块时，我们通常使用
    `for` 循环的变体之一。'
- en: Using the for loop variant
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `for` 循环变体
- en: 'Let''s begin by looking at the standard C-based `for` loop and how we would
    use it. The format for the `for` statement looks similar to this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看基于 C 的标准 `for` 循环及其使用方法开始。`for` 语句的格式看起来类似于这个：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As shown in the preceding format, the `for` loop has three sections:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的格式所示，`for` 循环有三个部分：
- en: '`Initialization`: This is where we initialize any variables needed; this can
    contain multiple initializations, separated by commas, if needed'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`初始化`：这是初始化所需变量的地方；如果需要，可以包含多个初始化，用逗号分隔'
- en: '`Condition`: This is the condition to check; when the condition is false, the
    loop will exit'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`条件`：这是需要检查的条件；当条件为假时，循环将退出'
- en: '`Update-rule`: This is what needs to be updated at the end of each loop'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`更新规则`：这是每个循环结束时需要更新的内容'
- en: It is important to understand the order in which the sections are called. When
    the execution of the code encounters a `for` loop, the initialization section
    of the `for` loop is called to initialize the variables. Next, the condition section
    is executed to verify whether the block of code should be executed, and, if so,
    it will execute the block of code. Finally, the update-rule is called to perform
    any updates before looping back and starting over.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 理解各个部分被调用的顺序是很重要的。当代码执行遇到一个 `for` 循环时，会调用 `for` 循环的初始化部分来初始化变量。接下来，执行条件部分以验证是否应该执行代码块，如果是的话，它将执行代码块。最后，调用更新规则来在循环回跳并重新开始之前执行任何更新。
- en: 'The following example shows how to use the `for` loop to go through a range
    of numbers:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何使用 `for` 循环遍历一系列数字：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding example, the `index` variable is initialized to the number
    `1`. At the beginning of each loop, we check whether the `index` variable is equal
    to or less than number `4`. If the `index` variable is equal to or less than number
    `4`, the inner block of code is executed, and this prints the value of the `index`
    variable to the console. Finally, we increment the `index` variable before looping
    back and starting over. Once the index variable is greater than `4`, the `for`
    loop exits. If we run the preceding example, the numbers `1` through `4` will
    indeed be printed to the console.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`index` 变量被初始化为数字 `1`。在每次循环的开始，我们检查 `index` 变量是否等于或小于数字 `4`。如果 `index`
    变量等于或小于数字 `4`，则执行代码的内层块，并将 `index` 变量的值打印到控制台。最后，我们在循环回跳并重新开始之前增加 `index` 变量。一旦
    `index` 变量大于 `4`，`for` 循环就会退出。如果我们运行前面的例子，数字 `1` 到 `4` 将确实被打印到控制台。
- en: 'One of the most common uses of a `for` loop is to iterate through a collection
    and perform a block of code for each item in that collection. Let''s look at how
    to loop through an array, followed by an example of how to loop through a dictionary:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环最常见的一个用途是遍历一个集合并对该集合中的每个项目执行一段代码。让我们看看如何遍历一个数组，然后通过一个例子来看看如何遍历一个字典：'
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding example, we begin by initializing the `countries` array with
    the abbreviations of three countries. In the `for` loop, we initialize the `index`
    variable to `0` (the first index of the array), and in the condition statement
    of the `for` loop, we check whether the index variable is less than the number
    of elements in the `countries` array. Each time we loop, we retrieve and print
    the value from the `countries` array at the index specified by the `index` variable.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们首先使用三个国家的缩写初始化 `countries` 数组。在 `for` 循环中，我们将 `index` 变量初始化为 `0`（数组的第一个索引），并在
    `for` 循环的条件语句中检查 `index` 变量是否小于 `countries` 数组中的元素数量。每次循环时，我们从 `countries` 数组中检索并打印由
    `index` 变量指定的索引处的值。
- en: One of the biggest mistakes that new programmers make when they use a `for`
    loop to iterate through an array is to use the less than or equal to (`<=`) operator
    rather than the less than (`<`) operator. Using a less than or equal to (`<=`)
    operator would cause one too many iterations through the loop and generate an
    `Index out of Bounds` exception when the code is run. In the preceding example,
    a less than or equal to operator will generate a count from 0 to 3 inclusively
    because there are three elements in the array; however, the elements in the array
    have indexes from 0 to 2 (0, 1, and 2). So, when we try to retrieve the value
    at index `3`, the `Index out of Bounds` exception will be thrown. It is recommended
    to use a `for-in` loop to iterate through an array rather than a standard `for`
    loop. We will look at the `for-in` loop a little later in this chapter.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 新程序员在使用 `for` 循环遍历数组时犯的最大错误之一是使用小于或等于 (`<=`) 操作符而不是小于 (`<`) 操作符。使用小于或等于 (`<=`)
    操作符会导致循环迭代次数过多，并在代码运行时生成 `Index out of Bounds` 异常。在前面的例子中，小于或等于 (`<=`) 操作符将生成从
    `0` 到 `3`（包括）的计数，因为数组中有三个元素；然而，数组中的元素索引从 `0` 到 `2`（0、1 和 2）。因此，当我们尝试获取索引 `3` 的值时，将抛出
    `Index out of Bounds` 异常。建议使用 `for-in` 循环遍历数组而不是标准 `for` 循环。我们将在本章稍后讨论 `for-in`
    循环。
- en: 'Let''s look at how we would iterate through a dictionary with a standard C-based
    `for` loop:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用基于 C 的标准 `for` 循环遍历字典：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding example, we begin by creating a dictionary object that contains
    country names as the values with their abbreviations as the keys. We then use
    the `keys` property of the dictionary to get an array of keys. In the `for` loop,
    we initialize the `index` variable to `0`, verify whether the `index` variable
    is less than the number of elements in the countries array, and increment the
    `index` variable at the end of each loop. Each time we loop, we print the country's
    name to the console.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们首先创建了一个包含国家名称作为值、缩写作为键的字典对象。然后我们使用字典的 `keys` 属性来获取键的数组。在 `for` 循环中，我们将
    `index` 变量初始化为 `0`，验证 `index` 变量是否小于国家数组中的元素数量，并在每次循环结束时增加 `index` 变量。每次循环时，我们将打印国家的名称到控制台。
- en: Now, let's look at how to use the `for-in` statement and how it can help prevent
    common mistakes that occur when we use the standard `for` statement.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用 `for-in` 语句以及它如何帮助我们防止在使用标准 `for` 语句时出现的常见错误。
- en: Using the for-in loop variant
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `for-in` 循环变体
- en: In the standard `for` loop, we provide an index and then loop until a condition
    is met. While this approach is very good, when we want to loop through a range
    of numbers, it can cause bugs, as mentioned earlier, if our conditional statements
    are not correct. The `for-in` loop is designed to prevent these types of exceptions.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准的`for`循环中，我们提供一个索引，然后循环直到满足条件。虽然这种方法非常好，但当我们想要遍历一系列数字时，它可能会导致错误，正如之前提到的，如果我们的条件语句不正确。`for-in`循环旨在防止这些类型的异常。
- en: 'The `for-in` loop iterates over a collection of items or a range of numbers
    and executes a block of code for each item in the collection or range. The format
    for the `for-in` statement looks similar to this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`for-in`循环遍历一个项集合或数字范围，并为集合或范围中的每个项执行一段代码。`for-in`语句的格式看起来类似于以下：'
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As we can see in the preceding code, the `for-in` loop has two sections:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，`for-in`循环有两个部分：
- en: '`Variable`: This variable will change each time the `for-in` loop executes
    and hold the current item from the collection or range'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`变量`: 这个变量会在每次`for-in`循环执行时改变，并保存集合或范围内的当前项'
- en: '`Collection/Range`: This is the collection or range to iterate through'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`集合/范围`: 这是遍历的集合或范围'
- en: 'Let''s take a look at how to use the `for-in` loop to iterate through a range
    of numbers:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`for-in`循环遍历一系列数字：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding example, we iterate over a range of numbers from `1` to `5`
    and print each of the numbers to the console. This particular `for-in` statement
    uses the closed range operator (`…`) to give the `for-in` loop a range to go through.
    Swift also provides a second range operation called the half-open range operator
    (`..<`). The half-open range operator iterates through the range of numbers, but
    does not include the last number. Let''s look at how to use the half-range operator:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们遍历了从`1`到`5`的数字范围，并将每个数字打印到控制台。这个特定的`for-in`语句使用了闭包范围运算符（`…`）为`for-in`循环提供一个遍历的范围。Swift还提供了一个名为半开范围运算符的第二个范围操作（`..<`）。半开范围运算符遍历数字范围，但不包括最后一个数字。让我们看看如何使用半开范围运算符：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the closed range operator example (`…`), we will see the numbers `1` though
    `5` printed to the console. In the half-range operator example, the last number
    (`5`) will be excluded; therefore, we will see the numbers `1` though `4` printed
    to the console.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在闭包范围运算符示例（`…`）中，我们将看到数字`1`到`5`被打印到控制台。在半开范围运算符示例中，最后一个数字（`5`）将被排除；因此，我们将看到数字`1`到`4`被打印到控制台。
- en: 'Now, let''s look at how to iterate over an array with the `for-in` loop:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用`for-in`循环遍历数组：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding example, we iterate through the `countries` array and print
    each element of the `counties` array to the console. As we can see, iterating
    through an array with the `for-in` loop is safer, cleaner, and a lot easier than
    using the standard C-based `for` loop. Using the `for-in` loop prevents us from
    making common mistakes, such as using the `<=` (less than or equal too) operator
    rather than the `<` (less than) operator in our conditional statement.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们遍历了`countries`数组，并将`countries`数组中的每个元素打印到控制台。正如我们所见，使用`for-in`循环遍历数组比使用标准的基于C的`for`循环更安全、更简洁，也更简单。使用`for-in`循环可以防止我们犯一些常见的错误，例如在条件语句中使用`<=`（小于等于）运算符而不是`<`（小于）运算符。
- en: 'Let''s look at how to iterate over a dictionary with the `for-in` loop:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`for-in`循环遍历字典：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding example, we used the `for-in` loop to iterate through each
    key-value pair of a dictionary. In this example, each item in the dictionary is
    returned as a (key,value) tuple. We can decompose (key,value) tuple members as
    named constants within the body of the `for-in` loop. One thing to note is that
    since a dictionary does not guarantee the order that items are stored in, the
    order that they are iterated over may not be the same as the order they were inserted
    in.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用了`for-in`循环来遍历字典中的每个键值对。在这个例子中，字典中的每个项都作为（键，值）元组返回。我们可以在`for-in`循环体中将（键，值）元组成员分解为命名常量。需要注意的是，由于字典不保证存储项的顺序，遍历的顺序可能与插入的顺序不同。
- en: Now, let's look at another type of loop, the `while` loop.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看另一种类型的循环，即`while`循环。
- en: The while loop
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`while`循环'
- en: The `while` loop executes a block of code until a condition is met. Swift provides
    two forms of `while` loops; these are the `while` and `repeat-while` loops. In
    Swift 2.0, Apple replaced the `do-while` loop with the `repeat-while` loop. The
    `repeat-while` loop functions exactly as what the `do-while` loop did. Apple now
    uses the `do` statement for error handling.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环会执行一个代码块，直到满足某个条件。Swift提供了两种`while`循环的形式；这些是`while`循环和`repeat-while`循环。在Swift
    2.0中，Apple用`repeat-while`循环替换了`do-while`循环。`repeat-while`循环的功能与`do-while`循环完全相同。现在，Apple使用`do`语句来进行错误处理。'
- en: We use the `while` loops when the number of iterations to perform is not known
    and is usually dependent on some business logic. A `while` loop is used when you
    want to run a loop zero or more times, while a `repeat-while` loop is used when
    you want to run the loop one or more times.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当要执行的迭代次数未知且通常依赖于某些业务逻辑时，我们使用`while`循环。当你想运行零次或多次循环时，使用`while`循环；而当你想运行一次或多次循环时，使用`repeat-while`循环。
- en: Using the while loop
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`while`循环
- en: 'The `while` loop starts by evaluating a conditional statement and then repeatedly
    executes a block of code if the conditional statement is true. The format for
    the `while` statement is as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环首先评估一个条件语句，然后如果条件语句为真，则重复执行一个代码块。`while`语句的格式如下：'
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s look at how to use a `while` loop. In the following example, the `while`
    loop will continue to loop if a randomly-generated number is less than `4`. In
    this example, we are using the `arc4random()` function to generate a random number
    between `0` and `4`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`while`循环。在下面的例子中，如果生成的随机数小于`4`，`while`循环将继续循环。在这个例子中，我们使用`arc4random()`函数在`0`和`4`之间生成一个随机数：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding example, we begin by initializing the `ran` variable to `0`.
    The `while` loop then checks the `ran` variable, and if its value is less than
    `4`, a new random number, between `0` and `4`, is generated. The `while` loop
    will continue to loop while the randomly-generated number is less than `4`. Once
    the randomly-generated number is equal to or greater than `4`, the `while` loop
    will exit.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们首先将`ran`变量初始化为`0`。然后`while`循环检查`ran`变量，如果其值小于`4`，就会生成一个新的随机数，介于`0`和`4`之间。只要生成的随机数小于`4`，`while`循环将继续循环。一旦生成的随机数等于或大于`4`，`while`循环将退出。
- en: In the preceding example, the `while` loop checks the conditional statement
    prior to generating a new random number. What if we did not want to check the
    conditional statement prior to generating a random number? We could generate a
    random number when we first initialize the `ran` variable, but that would mean
    we would need to duplicate the code that generates the random numbers, and duplicating
    code is never an ideal solution. It would be preferable to use the `repeat-while`
    loop for such instances.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`while`循环在生成新的随机数之前会检查条件语句。如果我们不想在生成随机数之前检查条件语句呢？我们可以在第一次初始化`ran`变量时生成一个随机数，但这意味着我们需要复制生成随机数的代码，而复制代码永远不是一种理想的做法。在这种情况下，使用`repeat-while`循环会更合适。
- en: Using the repeat-while loop
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`repeat-while`循环
- en: 'The difference between the `while` and `repeat-while` loops is that the `while`
    loops check the conditional statement prior to executing the block of code the
    first time; therefore, all the variables in the conditional statements need to
    be initialized prior to executing the `while` loop. The `repeat-while` loop will
    run through the loop block prior to checking the `conditional` statement for the
    first time; this means that we can initialize the variables in the conditional
    block of code. Use of the `repeat-while` loop is preferred when the conditional
    statement is dependent on the code in the loop block. The `repeat-while` loop
    takes the following format:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环和`repeat-while`循环的区别在于，`while`循环在第一次执行代码块之前会检查条件语句；因此，所有在条件语句中的变量都需要在执行`while`循环之前初始化。`repeat-while`循环会在第一次检查条件语句之前运行循环块；这意味着我们可以在条件代码块中初始化变量。当条件语句依赖于循环块中的代码时，`repeat-while`循环的使用更为合适。`repeat-while`循环的格式如下：'
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s take a look at this specific example by creating a `repeat-while` loop
    where we initialize the variable we are checking, in the conditional `while` statement,
    within the loop block:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个`repeat-while`循环来查看这个具体的例子，在这个循环中，我们在循环块内初始化我们要检查的变量，在条件`while`语句中：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding example, we define the `ran` variable as an `Int`, but we do
    not initialize it until we enter the loop block and generate a random number.
    If we try to do this with the `while` loop (leaving the `ran` variable uninitialized),
    we will receive a `Variable used before being initialized` exception.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们将`ran`变量定义为`Int`类型，但我们直到进入循环块并生成随机数之前都没有初始化它。如果我们尝试使用`while`循环（未初始化`ran`变量），我们会收到一个`变量在使用前未初始化`异常。
- en: The switch statement
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`switch`语句'
- en: 'The `switch` statement takes a value and then compares it to the several possible
    matches, and executes the appropriate block of code based on the first successful
    match. The `switch` statement is an alternative to using the `if-else` statement
    when there could be several possible matches. The `switch` statement takes the
    following format:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句取一个值，然后将其与几个可能的匹配项进行比较，并根据第一次成功的匹配执行相应的代码块。当可能有多个匹配项时，`switch`语句是`if-else`语句的替代方案。`switch`语句的格式如下：'
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Unlike the `switch` statements in most other languages, in Swift, it does not
    fall through to the next `case` statement; therefore, we do not need to use a
    `break` statement to prevent the fall through. This is another safety feature
    that is built into Swift since one of the most common programming mistakes, with
    the `switch` statement, made by beginner programmers is to forget the `break`
    statement at the end of the `case` statement. Let''s look at how to use the `switch`
    statement:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数其他语言中的`switch`语句不同，在Swift中，它不会自动跳转到下一个`case`语句；因此，我们不需要使用`break`语句来防止跳转。这是Swift内置的另一个安全特性，因为初学者在`switch`语句中最常见的编程错误之一就是忘记在`case`语句的末尾添加`break`语句。让我们看看如何使用`switch`语句：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding example, the `switch` statement takes the value of the `speed`
    variable and compares it to the two `case` statements, and if the value of speed
    matches either case, it will print out what the speed is. If the `switch` statement
    does not find a match, it will print out the `Unknown speed` message.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`switch`语句将`speed`变量的值与两个`case`语句进行比较，如果`speed`的值与任一`case`匹配，它将打印出速度是多少。如果`switch`语句找不到匹配项，它将打印出`Unknown
    speed`消息。
- en: 'Every `switch` statement must have a match for all the possible values. This
    means that unless we are matching against an enum, each `switch` statement must
    have a `default` case. Let''s look at a case where we do not have a `default`
    case:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`switch`语句都必须匹配所有可能的值。这意味着除非我们是在匹配枚举，否则每个`switch`语句都必须有一个`default`情况。让我们看看没有`default`情况的例子：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If we put the preceding code into a Playground and attempt to compile the code,
    we will receive a `switch must be exhaustive, consider adding a default clause`
    error. This is a compile time error; therefore, we will not be notified until
    we attempt to compile the code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将前面的代码放入游乐场并尝试编译，我们会收到一个`switch必须完整，考虑添加默认情况`错误。这是一个编译时错误；因此，我们只有在尝试编译代码时才会收到通知。
- en: 'It is possible to include multiple items in a single case. To set multiple
    items within a single case, we would need to separate the items with a comma.
    Let''s look at how we would use the `switch` statement to tell us if a character
    was a vowel or a consonant:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在单个`case`中可以包含多个项。要在单个`case`中设置多个项，我们需要用逗号分隔这些项。让我们看看我们如何使用`switch`语句来判断一个字符是元音还是辅音：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We can see in the preceding example that each case has its multiple items. Commas
    separate these items and the `switch` statement will attempt to match the `char`
    variable to each item listed in the `case` statement.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在前面的例子中看到，每个`case`都有多个项。这些项用逗号分隔，`switch`语句将尝试将`char`变量与`case`语句中列出的每个项匹配。
- en: 'It is also possible to check the value of a `switch` statement to see whether
    it is included in a range. To do this, we would use a range operator in the `case`
    statement, as shown in the following example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以检查`switch`语句的值，看看它是否包含在某个范围内。为此，我们会在`case`语句中使用范围运算符，如下面的示例所示：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding example, the `switch` statement takes the `grade` variable
    and compares it with the `grade` ranges in each `case` statement, and prints out
    the appropriate grade.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`switch`语句将`grade`变量与每个`case`语句中的`grade`范围进行比较，并打印出相应的等级。
- en: 'In Swift, any `case` statement can contain an optional guard condition that
    can provide an additional condition to validate. The guard condition is defined
    with the `where` keyword. Let''s say, in our preceding example, we had students
    who were receiving special assistance in the class and we wanted to define a grade
    of `D` for them in the range of `55` to `69`. The following example shows how
    to do this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，任何 `case` 语句都可以包含一个可选的 guard 条件，它可以提供额外的条件来验证。guard 条件是用 `where` 关键字定义的。假设，在我们的上一个例子中，我们有一些学生在课堂上得到了特殊帮助，我们想要为他们定义一个
    `D` 等级，范围在 `55` 到 `69` 之间。以下示例展示了如何做到这一点：
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'One thing to keep in mind with the guard expression is that Swift will attempt
    to match the value starting with the first case statement and working its way
    down checking each case statement in order. This means that if we put the `case`
    statement with the guard expression after the Grade F `case` statement, then the
    `case` statement with the guard expression would never be reached. The following
    example illustrates this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理 guard 表达式时，需要注意的一点是，Swift 将尝试从第一个 `case` 语句开始匹配值，并按顺序检查每个 `case` 语句。这意味着如果我们把带有
    guard 表达式的 `case` 语句放在 Grade F `case` 语句之后，那么带有 guard 表达式的 `case` 语句将永远不会被触及。以下示例说明了这一点：
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A good rule of thumb is that if you are using guard expressions, always put
    the `case` statements with the guard condition before any similar `case` statements
    without guard expressions.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的经验法则是，如果你正在使用 guard 表达式，总是把带有 guard 条件的 `case` 语句放在任何没有 guard 表达式的类似 `case`
    语句之前。
- en: '`Switch` statements are also extremely useful for evaluating enumerations.
    Since an enumeration has a finite number of values, if we provide a `case` statement
    for all the values in the enumeration, we do not need to provide a default case.
    The following example shows how we can use a `switch` statement to evaluate an
    enumeration:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`Switch` 语句对于评估枚举也非常有用。由于枚举具有有限数量的值，如果我们为枚举中的所有值提供了 `case` 语句，我们就不需要提供默认情况。以下示例展示了我们如何使用
    `switch` 语句来评估枚举：'
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this example, we begin by defining an enumeration named `Product` with two
    values each with the associated values. We then create an `order` variable of
    the product type and use the `switch` statement to evaluate it. Notice that we
    did not put a default case at the end of the `switch` statement. If we add additional
    values to the product enumeration at a later time, we would need to either put
    a default case at the end of the `switch` statement or add additional `case` statements
    to handle the additional values.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先定义了一个名为 `Product` 的枚举，它有两个值，每个值都关联着相应的值。然后我们创建了一个 `order` 变量，其类型为产品类型，并使用
    `switch` 语句来评估它。请注意，我们在 `switch` 语句的末尾没有放置默认情况。如果我们稍后向产品枚举中添加额外的值，我们需要在 `switch`
    语句的末尾放置一个默认情况，或者添加额外的 `case` 语句来处理额外的值。
- en: Using case and where statements with conditional statements
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `case` 和 `where` 语句与条件语句
- en: As we saw in the last section, the `case` and `where` statements within a `switch`
    statement can be very powerful. Starting with Swift 2, we are able to use these
    statements with other conditional statements such as the `if`, `for`, and `while`
    statements. Using the `case` and `where` statements within our conditional statements
    can make our code much smaller and easier to read. Let's look at some examples
    starting off with using the `where` statement to filter the results in a `for-in`
    loop.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中看到的，`switch` 语句中的 `case` 和 `where` 语句可以非常强大。从 Swift 2 开始，我们能够使用这些语句与
    `if`、`for` 和 `while` 等其他条件语句一起使用。在我们的条件语句中使用 `case` 和 `where` 语句可以使我们的代码更加紧凑且易于阅读。让我们看看一些示例，从使用
    `where` 语句在 `for-in` 循环中过滤结果开始。
- en: Filtering with the where statement
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `where` 语句进行过滤
- en: 'In this section, we will see how we can use the `where` statement to filter
    the results of a `for-in` loop. For the example, we will take an array of integers
    and print out only the even numbers; however, before we look at how we would filter
    the results with the `where` statement, let''s look at how we would do this without
    the `where` statement:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到如何使用 `where` 语句来过滤 `for-in` 循环的结果。为了举例，我们将使用一个整数数组，并只打印出偶数；然而，在我们查看如何使用
    `where` 语句过滤结果之前，让我们看看没有使用 `where` 语句会如何做：
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In this example, we use a `for-in` loop to cycle through the numbers `1` to
    `30`. Within the `for-in` loop, we use an `if` conditional statement to filter
    out the odd numbers. In this simple example, the code is fairly easy to read,
    but let''s see how we can use the `where` statement to use less lines of code
    and make it easier to read:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用一个 `for-in` 循环来遍历数字 `1` 到 `30`。在 `for-in` 循环内部，我们使用一个 `if` 条件语句来过滤出奇数。在这个简单的例子中，代码读起来相当容易，但让我们看看我们如何使用
    `where` 语句来减少代码行数并使其更容易阅读：
- en: '[PRE30]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We still have the same `for-in` loop as the previous example; however, now we
    put the `where` statement at the end, which, in this particular example, we only
    loop through the even numbers. Using the `where` statement shortens our example
    by two lines and also makes it easier to read because the filter statement is
    on the same line as the `for-in` loop rather than being embedded in the loop itself.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然有与上一个例子相同的 `for-in` 循环；然而，现在我们将 `where` 语句放在最后，在这个特定的例子中，我们只遍历偶数。使用 `where`
    语句缩短了我们的例子两行，并且也使其更容易阅读，因为过滤语句与 `for-in` 循环在同一行，而不是嵌入在循环本身中。
- en: Now let's look at how we could filter with the `for-case` statement.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用 `for-case` 语句进行过滤。
- en: Filtering with the for-case statement
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `for-case` 语句进行过滤
- en: 'In this next example, we will use the `for-case` statement to filter through
    an array of tuples and print out only the results that match our criteria. The
    `for-case` example is very similar to using the `where` statement that we saw
    earlier where it is designed to eliminate the need for an `if` statement within
    a loop to filter the results. In this example, we will use the `for-case` statement
    to filter through a list of World Series winners and print out the year(s) a particular
    team won the World Series:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个例子中，我们将使用 `for-case` 语句来过滤一个元组数组，并仅打印出符合我们标准的结果。`for-case` 例子与我们之前看到的 `where`
    语句非常相似，它旨在消除循环中过滤结果时需要 `if` 语句的需求。在这个例子中，我们将使用 `for-case` 语句来过滤一系列世界系列冠军，并打印出特定球队赢得世界系列赛的年份：
- en: '[PRE31]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this example, we create an array of tuples named `worldSeriesWinners`, where
    each tuple in the array contains the name of the team and the year that they won
    the World Series. We then use the `for-case` statement to filter through the array
    and only print out the years that the Red Sox won the World Series. The filtering
    is done within the `case` statement where the `("Red Sox", year)` says that we
    want all the results that have the String, `"Red Sox"`, in the first item of the
    tuple and the value of the second item into the `year` constant. The `for` loop
    then loops through the results of the `case` statement, and we print out the value
    of the `year` constant.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个名为 `worldSeriesWinners` 的元组数组，其中数组中的每个元组都包含球队的名称和他们赢得世界系列赛的年份。然后我们使用
    `for-case` 语句来过滤这个数组，并仅打印出红袜队赢得世界系列赛的年份。过滤是在 `case` 语句中完成的，其中 `("Red Sox", year)`
    表示我们想要所有第一个元素为字符串 `"Red Sox"` 且第二个元素的值赋给 `year` 常量的结果。然后 `for` 循环遍历 `case` 语句的结果，并打印出
    `year` 常量的值。
- en: 'The `for-case` statement also makes it very easy to filter out the nil values
    in an array of optionals. Let''s take a look at an example of this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`for-case` 语句也使得在可选数组中过滤出 nil 值变得非常容易。让我们看看一个这样的例子：'
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In this example, we create an array of optionals named `myNumbers` that may
    contain an integer value or may contain nil. As we will see in [Chapter 10](ch10.html
    "Chapter 10. Using Optional Types"), *Using Optional Types*, an optional is defined
    as an enum internally, as shown in the following code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个名为 `myNumbers` 的可选数组，它可能包含一个整数值，也可能包含 nil。正如我们将在[第 10 章](ch10.html
    "第 10 章。使用可选类型")中看到的那样，*使用可选类型*，可选在内部被定义为枚举，如下面的代码所示：
- en: '[PRE33]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If an optional is set to nil, it will have a value of `None`, but if it is not
    nil, then it will have a value of `Some` with an associate type of the actual
    value. In our example, when we filter for `.Some(num)` , we are looking for any
    optional that has the value of `.Some (non-nil value)`. As shorthand for `.Some()`,
    we could use the `?` (question mark) symbol, as we will see in the following example.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个可选被设置为 nil，它将有一个值为 `None`，但如果它不是 nil，那么它将有一个值为 `Some`，并关联实际值的类型。在我们的例子中，当我们过滤
    `.Some(num)` 时，我们正在寻找任何具有 `.Some (非 nil 值)` 的可选。作为 `.Some()` 的简写，我们可以使用 `?`（问号）符号，正如我们将在下面的例子中看到的那样。
- en: 'We can also combine `for-case` with a `where` statement to do additional filtering,
    as shown in the following example:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将 `for-case` 与 `where` 语句结合使用以进行额外的过滤，如下例所示：
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This example is the same as the previous example except that we added the additional
    filtering with the `where` statement. In the previous example, we looped through
    all of the non-nil values, but in this example, we loop through the non-nil values
    that are greater than 3\. Let''s see how we do this same filtering without the
    `case` or `where` statements:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子与上一个例子相同，只是我们添加了 `where` 语句的额外过滤。在上一个例子中，我们遍历了所有非 nil 值，但在本例中，我们遍历了大于 3
    的非 nil 值。让我们看看我们如何在不使用 `case` 或 `where` 语句的情况下进行相同的过滤：
- en: '[PRE35]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As we can see, using the `for-case` and `where` statements can greatly reduce
    the number of lines needed. It also makes our code much easier to read because
    all of the filtering statements are on the same line.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，使用 `for-case` 和 `where` 语句可以大大减少所需的行数。它还使我们的代码更容易阅读，因为所有过滤语句都在同一行上。
- en: Let's look at one more filtering example. This time, we will look at the `if-case`
    statement.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一个过滤示例。这次，我们将查看 `if-case` 语句。
- en: Using the if-case statement
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `if-case` 语句
- en: 'Using the `if-case` statement is very similar to using the `switch` statement.
    The majority of time the `switch` statement is preferred, but there are instances
    where the `if-case` statement is better. One of these times is when we are only
    looking for one or two possible matches, and we do not want to handle all of the
    possible matches. Let''s look at an example of this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `if-case` 语句与使用 `switch` 语句非常相似。大多数情况下，`switch` 语句是首选，但在某些情况下，`if-case` 语句更好。其中一种情况是我们只寻找一两个可能的匹配项，并且我们不希望处理所有可能的匹配项。让我们看看这个例子：
- en: '[PRE36]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In this example, we create an enumeration named `Identifier` that contains
    three possible values: `Name`, `Number`, and `NoIdentifier`. We create an instance
    of the `Identifier` enumeration named `playerIdentifier` with a value of `Number`
    and an associated value of `42`. We then use the `if-case` statement to see if
    the `playerIdentifier` has a value of `Number`, and if so, we print a message
    to the console.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个名为 `Identifier` 的枚举，其中包含三个可能的值：`Name`、`Number` 和 `NoIdentifier`。我们创建了一个名为
    `playerIdentifier` 的 `Identifier` 枚举实例，其值为 `Number`，关联值为 `42`。然后我们使用 `if-case`
    语句检查 `playerIdentifier` 是否具有 `Number` 值，如果是，则向控制台打印一条消息。
- en: 'Just like the `for-case` statement, we are able to do additional filtering
    with the `where` statement. The following example uses the same `Identifier` enumeration
    as we used in the previous example:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `for-case` 语句一样，我们能够使用 `where` 语句进行额外的过滤。以下示例使用了我们在上一个例子中使用的相同的 `Identifier`
    枚举：
- en: '[PRE37]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this example, we still use the `if-case` statement to see if the `playerIdentifier`
    has a value of `Number`, but we added the `where` statement to see if the associate
    value is equal to `42`, and if so, we identify the player as either `Xander Bogarts
    or Derek Jeter`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们仍然使用 `if-case` 语句来检查 `playerIdentifier` 是否具有 `Number` 值，但我们添加了 `where`
    语句来检查关联值是否等于 `42`，如果是，我们将玩家标识为 `Xander Bogarts 或 Derek Jeter`。
- en: As we saw in our examples, using the `case` and `where` statements with our
    conditional statements can reduce the number of lines needed to do certain types
    of filtering. It can also make our code easier to read. Now let's take a look
    at control transfer statements.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在示例中看到的那样，使用 `case` 和 `where` 语句与我们的条件语句结合可以减少进行某些类型过滤所需的行数。它还可以使我们的代码更容易阅读。现在让我们看看控制转移语句。
- en: Control transfer statements
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制转移语句
- en: Control transfer statements are used to transfer control to another part of
    the code. Swift offers five control transfer statements; these are `continue`,
    `break`, `fallthrough`, `guard`, `throws`, and `return`. We will look at the `return`
    statement in the *Functions* section later in this chapter and will discuss the
    `throws` statement in [Chapter 7](ch07.html "Chapter 7. Writing Safer Code with
    Availability and Error Handling"), *Writing Safer Code with Availability and Error
    Handling*.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 控制转移语句用于将控制权转移到代码的另一个部分。Swift 提供了五种控制转移语句；这些是 `continue`、`break`、`fallthrough`、`guard`、`throws`
    和 `return`。我们将在本章后面的 *函数* 部分中查看 `return` 语句，并在 [第 7 章](ch07.html "第 7 章。使用可用性和错误处理编写更安全的代码")
    中讨论 `throws` 语句，*使用可用性和错误处理编写更安全的代码*。
- en: The continue statement
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`continue` 语句'
- en: 'The `continue` statement tells a loop to stop executing the code block and
    go to the next iteration of the loop. The following example shows how to use a
    `continue` statement to print out only the odd numbers in a range:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue` 语句告诉循环停止执行代码块并转到循环的下一个迭代。以下示例展示了如何使用 `continue` 语句仅打印出范围内的奇数：'
- en: '[PRE38]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the preceding example, we loop through a range of `1` through `10`. For
    each iteration of the `for-in` loop, we use the remainder (`%`) operator to see
    whether the number is odd or even. If the number is even, the `continue` statement
    tells the loop to immediately go to the next iteration of the loop. If the number
    is odd, we print out the number is odd and then move ahead. The output of the
    preceding code is as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们遍历 `1` 到 `10` 的范围。对于 `for-in` 循环的每次迭代，我们使用取余 (`%`) 运算符来判断数字是奇数还是偶数。如果数字是偶数，`continue`
    语句告诉循环立即转到下一个迭代。如果数字是奇数，我们打印出该数字是奇数，然后继续前进。前面代码的输出如下：
- en: '[PRE39]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now, let's look at the `break` statement.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `break` 语句。
- en: The break statement
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`break` 语句'
- en: 'The `break` statement immediately ends the execution of a code block within
    the control flow. The following example shows how to break out of a `for` loop
    when we encounter the first even number:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`break` 语句立即结束控制流中的代码块执行。以下示例展示了当我们遇到第一个偶数时如何从 `for` 循环中退出：'
- en: '[PRE40]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the preceding example, we loop through the range of `1` through `10`. For
    each iteration of the `for` loop, we use the remainder (`%`) operator to see whether
    the number is odd or even. If the number is even, we use the `break` statement
    to immediately exit the loop. If the number is odd, we print out that the number
    is odd and then go to the next iteration of the loop. The preceding code has the
    following output:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们遍历 `1` 到 `10` 的范围。对于 `for` 循环的每次迭代，我们使用取余 (`%`) 运算符来判断数字是奇数还是偶数。如果数字是偶数，我们使用
    `break` 语句立即退出循环。如果数字是奇数，我们打印出该数字是奇数，然后进入循环的下一个迭代。前面的代码有以下输出：
- en: '[PRE41]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The fallthrough statement
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跌落语句
- en: 'In Swift, the `switch` statements do not fall through like other languages;
    however, we can use the `fallthrough` statement to force them to fall through.
    The `fallthrough` statement can be very dangerous because once a match is found,
    the next case defaults to true and that code block is executed. The following
    example illustrates this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，`switch` 语句不像其他语言那样会跌落；然而，我们可以使用 `fallthrough` 语句来强制它们跌落。`fallthrough`
    语句可能非常危险，因为一旦找到匹配项，下一个情况默认为真，并且执行该代码块。以下示例说明了这一点：
- en: '[PRE42]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the preceding example, since the first case, `Baseball`, matches the code
    and the remaining code blocks also execute, the output looks similar to this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，由于第一个情况 `Baseball` 与代码匹配，并且剩余的代码块也执行，输出看起来类似于以下内容：
- en: '[PRE43]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The guard statement
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`guard` 语句'
- en: 'In Swift and most modern languages, our conditional statements tend to focus
    on testing if a condition is true. As an example, the following code tests to
    see whether the variable `x` is greater than `10`, and if so, we preform some
    function; otherwise, we handle the error condition:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 和大多数现代语言中，我们的条件语句往往侧重于测试一个条件是否为真。例如，以下代码检查变量 `x` 是否大于 `10`，如果是，则执行某些函数；否则，处理错误条件：
- en: '[PRE44]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This type of code leads us to having our functional code embedded within our
    checks and with the error conditions tucked away at the end of our functions,
    but what if that is not what we really want. Sometimes, it may be nice to take
    care of our error conditions at the beginning of the function. I know, in our
    simple example, we could easily check if `x` is less than or equal to `10`, and
    if so, we perform the error condition, but not all the conditional statements
    are that easy to rewrite, especially the items such as optional binding.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的代码导致我们的功能代码嵌入到我们的检查中，并且错误条件被放在函数的末尾，但如果我们不希望这样呢？有时，在函数的开始处理错误条件可能更好。我知道，在我们的简单示例中，我们可以轻松检查
    `x` 是否小于或等于 `10`，如果是，则执行错误条件，但并非所有条件语句都那么容易重写，尤其是像可选绑定这样的项目。
- en: 'With Swift 2, Apple introduced the new `guard` statement. The `guard` statement
    focuses on performing a function if a condition is false; this allows us to trap
    errors and perform the error conditions early in our functions. We could rewrite
    our previous example using the `guard` statement like this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 2 中，Apple 引入了新的 `guard` 语句。`guard` 语句侧重于在条件为假时执行一个函数；这允许我们在函数的早期捕获错误并执行错误条件。我们可以使用
    `guard` 语句重写之前的示例，如下所示：
- en: '[PRE45]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In this new example, we check to see whether the variable `x` is greater than
    `10`, and if not, we perform our error condition. If the variable `x` is greater
    than `10`, our code continues. We notice that we have a `return` statement embedded
    within the error condition code. The code within the `guard` statement must contain
    a transfer of control statement; this is what prevents the rest of the code from
    executing. If we forget the transfer of `control` statement, Swift will show a
    compile time error.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新示例中，我们检查变量 `x` 是否大于 `10`，如果不是，我们执行错误条件。如果变量 `x` 大于 `10`，我们的代码将继续执行。我们注意到在错误条件代码中嵌入了一个
    `return` 语句。`guard` 语句中的代码必须包含一个控制转移语句；这正是防止其他代码执行的原因。如果我们忘记了控制转移语句，Swift 将在编译时显示错误。
- en: 'Let''s look at some more examples of the `guard` statement. The following example
    shows how we would use the `guard` statement to verify that an optional contains
    a valid value:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `guard` 语句的一些更多示例。以下示例展示了我们如何使用 `guard` 语句来验证一个可选值是否包含有效值：
- en: '[PRE46]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In this example, we create a function named `guardFunction()` that accepts an
    optional that contains a string or nil value. We then use the `guard` statement
    with optional binding to verify that the string optional does not contain a nil.
    If it does contain nil, then that code within the `guard` statement is executed
    and the `return` statement is used to exit the function. The really nice thing
    about using the guard statement with optional binding is the new variable is in
    scope for the rest of the function rather than just within the scope of the optional
    binding statement.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们创建了一个名为 `guardFunction()` 的函数，它接受一个包含字符串或 `nil` 值的可选值。然后我们使用 `guard`
    语句和可选绑定来验证字符串可选值不包含 `nil`。如果它包含 `nil`，则执行 `guard` 语句中的代码，并使用 `return` 语句退出函数。使用
    `guard` 语句和可选绑定时真正令人愉快的事情是，新变量在整个函数的范围内有效，而不仅仅是可选绑定语句的范围内。
- en: Now that we have seen how the control flow statements work in Swift, let's give
    an introduction to functions and classes in Swift.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了Swift中控制流语句的工作方式，让我们来介绍Swift中的函数和类。
- en: Functions
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: In Swift, a function is a self-contained block of code that performs a specific
    task. Functions are generally used to logically break our code into reusable named
    blocks. We use the function's name to call the function.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，函数是一个执行特定任务的独立代码块。函数通常用于将我们的代码逻辑上分解成可重用的命名块。我们使用函数的名称来调用函数。
- en: When we define a function, we can also optionally define one or more parameters
    (also known as arguments). Parameters are named values that are passed into the
    function by the code that calls it. These parameters are generally used within
    the function to perform the task of the function. We can also define default values
    for the parameters to simplify how the function is called.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义一个函数时，我们还可以选择性地定义一个或多个参数（也称为参数）。参数是通过调用它的代码传递到函数中的命名值。这些参数通常在函数内部用于执行函数的任务。我们还可以为参数定义默认值，以简化函数的调用方式。
- en: Every Swift function has a type associated with it. This type is referred to
    as the return type and it defines the type of data returned from the function
    to the code that called it. If a value is not returned from a function, the return
    type is `Void`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Swift函数都有一个与其关联的类型。这个类型被称为返回类型，它定义了从函数返回到调用它的代码的数据类型。如果一个函数没有返回值，则返回类型为 `Void`。
- en: Let's look at how to define functions in Swift.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在Swift中定义函数。
- en: Using a single parameter function
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用单个参数函数
- en: 'The syntax used to define a function in Swift is very flexible. This flexibility
    makes it easy for us to define simple C style functions or more complex Objective-C
    style functions, with local and external parameter names. Let''s look at some
    examples of how to define functions. The following example accepts one parameter
    and does not return any value back to the code that called it (return type—`void`):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 定义Swift中函数的语法非常灵活。这种灵活性使得我们能够轻松地定义简单的C风格函数或更复杂的Objective-C风格函数，包括局部和外部参数名称。让我们看看如何定义函数的一些示例。以下示例接受一个参数，并且不向调用它的代码返回任何值（返回类型—`void`）：
- en: '[PRE47]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In the preceding example, we defined a function named `sayHello` that accepts
    one variable that is named `name`. Inside the function, we print out a `Hello`
    greeting to the name of the person. Once the code within the function gets executed,
    the function exits and the control is returned back to the code that called it.
    Rather than printing out the greeting, if we want to return the greeting back
    to the code that called it, we can add a return type, as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们定义了一个名为 `sayHello` 的函数，它接受一个名为 `name` 的变量。在函数内部，我们打印出一个 `Hello` 问候语给这个人的名字。一旦函数内部的代码执行完毕，函数就会退出，控制权返回给调用它的代码。如果我们不想打印问候语，而是想将问候语返回给调用它的代码，我们可以添加一个返回类型，如下所示：
- en: '[PRE48]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `->` string defines that the return type associated with the function is
    a string. This means that the function must return a `string` variable back to
    the code that calls it. Inside the function, we build a `string` constant with
    the greeting message and then use the `return` keyword to return the `string`
    constant.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`->` 字符串定义了与函数相关联的返回类型是一个字符串。这意味着该函数必须将一个 `string` 变量返回给调用它的代码。在函数内部，我们构建一个包含问候信息的
    `string` 常量，然后使用 `return` 关键字返回这个 `string` 常量。'
- en: 'Calling a Swift function is very similar to how we call functions or methods
    in other languages such as C or Java. The following example shows how to call
    the `sayHello()` function that prints the greeting message to the screen from
    within the function:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 Swift 函数与在其他语言（如 C 或 Java）中调用函数或方法非常相似。以下示例展示了如何在函数内部调用将问候消息打印到屏幕上的 `sayHello()`
    函数：
- en: '[PRE49]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, let''s look at how to call the `sayHello2()` function that returns a value
    back to the code that called it:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何调用返回值的 `sayHello2()` 函数，该函数将值返回给调用它的代码：
- en: '[PRE50]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In the preceding example, we call the `sayHello2()` function and put the value
    returned in the `message` variable. If a function defines a return type, such
    as the `sayHello2()` function does, it must return a value of that type to the
    code that called it. Therefore, every possible conditional path within the function
    must end by returning a value of the specified type. This does not mean that the
    code that called the function has to retrieve the returned value. As an example,
    both lines in the following examples are valid:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们调用了 `sayHello2()` 函数，并将返回的值存储在 `message` 变量中。如果一个函数定义了返回类型，例如 `sayHello2()`
    函数那样，它必须返回一个与该类型相匹配的值给调用它的代码。因此，函数内的每一个可能的条件路径都必须以返回指定类型的值结束。这并不意味着调用函数的代码必须检索返回的值。以下是一个例子，其中两行都是有效的：
- en: '[PRE51]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: If you do not specify a variable for the return value to go into, the value
    is dropped.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有指定一个变量来存储返回值，该值将被丢弃。
- en: Using a multiparameter function
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用多参数函数
- en: 'We are not limited to just one parameter with our functions, we can also define
    multiple parameters. To create a multiparameter function, we list the parameters
    in the parentheses and separate the parameter definitions with commas. Let''s
    look at how to define multiple parameters in a function:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在函数中不仅限于只有一个参数，我们还可以定义多个参数。要创建一个多参数函数，我们在括号中列出参数，并用逗号分隔参数定义。让我们看看如何在函数中定义多个参数：
- en: '[PRE52]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In the preceding example, the function accepts two arguments: `name` and `greeting`.
    We then print a `greeting` to the console using both the parameters.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，该函数接受两个参数：`name` 和 `greeting`。然后我们使用这两个参数在控制台上打印一个 `greeting`。
- en: 'Calling a multiparameter function is a little different from calling a single
    parameter function. When calling a multiparameter function, we separate the parameters
    with commas. We also need to include the parameter name for all the parameters
    except for the first one. The following example shows how to call a multiparameter
    function:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 调用一个多参数函数与调用一个单参数函数略有不同。在调用多参数函数时，我们用逗号分隔参数，并且除了第一个参数之外，我们还需要包括所有其他参数的名称。以下示例展示了如何调用一个多参数函数：
- en: '[PRE53]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We do not need to supply an argument for each parameter of the function if we
    define default values. Let's look at how to configure default values for our parameters.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为参数定义了默认值，我们不需要为函数的每个参数提供一个参数。让我们看看如何为我们的参数配置默认值。
- en: Defining a parameter's default values
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义参数的默认值
- en: 'We can define default values for parameters by using the equal to operator
    (`=`) within the function definition when we declare the variables. The following
    example shows how to declare a function with parameter default values:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在函数定义中通过使用等于运算符（`=`）为参数定义默认值，当我们声明变量时。以下示例展示了如何声明一个具有默认参数值的函数：
- en: '[PRE54]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In the function declaration, we define one parameter without a default value
    (`name: String`) and one parameter with a default value (`greeting: String = "Bonjour"`).
    When a parameter has a default value declared, we are able to call the function
    with or without setting a value for that parameter. The following example shows
    how to call the `sayHello()` function without setting the `greeting` parameter,
    and also how to call it with setting the `greeting` parameter:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '在函数声明中，我们定义了一个没有默认值（`name: String`）的参数和一个具有默认值（`greeting: String = "Bonjour"`）的参数。当一个参数有默认值声明时，我们可以选择在调用函数时为该参数设置值或不设置值。以下示例展示了如何调用
    `sayHello()` 函数而不设置 `greeting` 参数，以及如何设置 `greeting` 参数来调用它：'
- en: '[PRE55]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In the `sayHello("Jon")` line, the `sayHello()` function will print out the
    message `Bonjour Jon` since it uses the default value for the `greeting` parameter.
    In the `sayHello("Jon", greeting: "Hello")` line, the `sayHello()` function will
    print out the message `Hello Jon` since we override the default value for the
    `greeting` parameter.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '在 `sayHello("Jon")` 行中，`sayHello()` 函数将输出消息 `Bonjour Jon`，因为它使用了 `greeting`
    参数的默认值。在 `sayHello("Jon", greeting: "Hello")` 行中，`sayHello()` 函数将输出消息 `Hello Jon`，因为我们覆盖了
    `greeting` 参数的默认值。'
- en: 'We can declare multiple parameters with default values and override only the
    ones we want by using the parameter names. The following example shows how we
    would do this by overriding one of the default values when we call it:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用参数名称来声明多个具有默认值的参数，并且只覆盖我们想要的那些。以下示例展示了我们如何通过在调用时覆盖其中一个默认值来实现这一点：
- en: '[PRE56]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In the preceding example, we declare one parameter without a default value
    (`name: String`) and two parameters with default values (`name2: String = "Kim",
    greeting: String = "Bonjour"`). We then call the function leaving the `name2`
    parameter with its default value, but override the default value of the `greeting`
    parameter.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '在上述示例中，我们声明了一个没有默认值（`name: String`）的参数和两个具有默认值（`name2: String = "Kim", greeting:
    String = "Bonjour"`）的参数。然后我们调用函数，让 `name2` 参数保持其默认值，但覆盖了 `greeting` 参数的默认值。'
- en: The preceding example would print out the message, `Hello Jon and Kim`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例将输出消息，“Hello Jon and Kim”。
- en: Returning multiple values from a function
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从函数中返回多个值
- en: 'There are a couple of ways to return multiple values from a Swift function.
    One of the most common ways is to put the values into a collection type (array
    or dictionary) and return the collection. The following example shows how to return
    a collection type from a Swift function:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以从 Swift 函数中返回多个值。最常见的方法是将值放入集合类型（数组或字典）中，然后返回该集合。以下示例展示了如何从 Swift 函数中返回一个集合类型：
- en: '[PRE57]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In the preceding example, we declare the `getNames()` function with no parameters
    and a return type of `[String]`. The return type of `[String]` specifies the return
    type to be an array of string types.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，我们声明了没有参数且返回类型为 `[String]` 的 `getNames()` 函数。`[String]` 返回类型指定返回类型为字符串类型的数组。
- en: One of the drawbacks of returning a collection type is that the values of the
    collection must be of the same type, or we must declare our collection type to
    be of the `AnyObject` type. In the preceding example, our array could only return
    string types. If we needed to return numbers with our strings, we could return
    an array of `AnyObjects` and then use typecasting to specify the object type.
    However, this would not be a very good design for our application since it would
    be very prone to errors. A better way to return values of different types would
    be to use a tuple type.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 返回集合类型的一个缺点是集合中的值必须是同一类型，或者我们必须将我们的集合类型声明为 `AnyObject` 类型。在上述示例中，我们的数组只能返回字符串类型。如果我们需要与字符串一起返回数字，我们可以返回一个
    `AnyObjects` 类型的数组，然后使用类型转换来指定对象类型。然而，这并不是我们应用程序的一个很好的设计，因为它很容易出错。返回不同类型值的一个更好的方式是使用元组类型。
- en: 'When we return a tuple from a function, it is recommended that we use a named
    tuple to allow us to use the dot syntax to access the returned values. The following
    example shows how to return a named tuple from a function and access the values
    from the named tuple that is returned:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从函数返回一个元组时，建议我们使用命名元组，这样我们可以使用点语法来访问返回的值。以下示例展示了如何从函数中返回一个命名元组并访问返回的命名元组的值：
- en: '[PRE58]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In the preceding example, we define the `getTeam()` function that returns a
    named tuple that contains three values—`String`, `Int`, and `Double`. Within the
    function, we create the tuple that we are going to return. Notice that we do not
    need to define the tuple that we are going to return as a named tuple as long
    as the value types within the tuple match the value types in the function definition.
    We can then call the function, as we would any other function, and use the dot
    syntax to access the values of the tuple that is returned. In the preceding example,
    the code would print out the following line:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们定义了`getTeam()`函数，该函数返回一个包含三个值（`String`、`Int`和`Double`）的命名元组。在函数内部，我们创建了将要返回的元组。注意，只要元组中的值类型与函数定义中的值类型匹配，我们就不需要将将要返回的元组定义为命名元组。然后我们可以像调用其他函数一样调用该函数，并使用点语法来访问返回的元组的值。在前面示例中，代码会打印出以下行：
- en: '[PRE59]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Returning optional values
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回可选值
- en: 'In the previous sections, we returned non-nil values from our function; however,
    that is not always what we need our code to do. What happens if we need to return
    a nil value from a function? The following code would throw an `expression does
    not conform to type ''NilLiteralConvertible''` exception:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们从函数中返回了非`nil`值；然而，这并不总是我们所需要的。如果我们需要从函数中返回一个`nil`值，会发生什么？以下代码会抛出`expression
    does not conform to type 'NilLiteralConvertible'`异常：
- en: '[PRE60]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The reason this code throws an exception is we define the return type as a
    `string` value; however, we are attempting to return `nil`. If there is a reason
    to return `nil`, we need to define the return type as an optional type to let
    the code calling it know that the value may be `nil`. To define the return type
    as an optional type, we use the question mark(`?`) the same way that we did when
    we defined a variable as an optional type. The following example shows how to
    define an optional return type:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码抛出异常的原因是我们将返回类型定义为`string`值；然而，我们尝试返回`nil`。如果有必要返回`nil`，我们需要将返回类型定义为可选类型，以便调用它的代码知道该值可能是`nil`。要定义返回类型为可选类型，我们使用问号(`?`)的方式，就像我们定义一个变量为可选类型时一样。以下示例展示了如何定义可选返回类型：
- en: '[PRE61]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The preceding code would not throw an exception.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码不会抛出异常。
- en: 'We can also set a tuple as an optional type or any value within a tuple as
    an optional type. The following example shows how we would return a tuple as an
    optional type:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将元组设置为可选类型，或者将元组中的任何值设置为可选类型。以下示例展示了我们如何将元组作为可选类型返回：
- en: '[PRE62]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In the following example, we could return a tuple as defined within our function
    definition or a `nil`; either option is valid. If we needed an individual value
    within our tuple to be `nil`, we would need to add an optional type within our
    tuple. The following example shows how to return a `nil` within our tuple:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们可以返回一个在函数定义中定义的元组，或者返回一个`nil`；这两种选项都是有效的。如果我们需要元组中的某个值是`nil`，我们需要在元组中添加一个可选类型。以下示例展示了如何在元组中返回一个`nil`：
- en: '[PRE63]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In the preceding example, we can set the `percent` value to either a `Double`
    value or `nil`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们可以将`percent`值设置为`Double`值或`nil`。
- en: Adding external parameter names
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加外部参数名称
- en: In the preceding examples in this section, the parameters were defined similar
    to how we would define the parameters in C code, where we define the parameter
    names and value types. When we call the function, we also call the function similar
    to how we would call functions in C code, where we use the function name and specify
    the values we are passing to the function within parenthesis. In Swift, we are
    not limited to this syntax; we can also use external parameter names.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节前面的示例中，参数的定义方式类似于我们在C代码中定义参数的方式，即我们定义参数名称和值类型。当我们调用函数时，我们也可以像调用C代码中的函数一样调用它，其中我们使用函数名称并在括号内指定传递给函数的值。在Swift中，我们不仅限于这种语法；我们还可以使用外部参数名称。
- en: External parameter names are used when we call a function to indicate the purpose
    of each parameter. If we want to use external parameter names with our functions,
    we would need to define an external parameter name for each parameter in addition
    to its local parameter name. The external parameter name is added before the local
    parameter name in the function definition. The external and local parameter names
    are separated by a space.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用一个函数以指示每个参数的目的时，会使用外部参数名称。如果我们想在函数中使用外部参数名称，我们需要为每个参数定义一个外部参数名称，除了其局部参数名称之外。外部参数名称在函数定义中添加在局部参数名称之前。外部和局部参数名称之间用空格分隔。
- en: 'Let''s look at how to use external parameter names. But before we do so, let''s
    review how we have previously defined functions. In the next two examples, we
    will define a function without external parameter names and then we will redefine
    that function with external parameter names:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用外部参数名称。但在这样做之前，让我们回顾一下我们之前是如何定义函数的。在接下来的两个示例中，我们将定义一个没有外部参数名称的函数，然后我们将使用外部参数名称重新定义该函数：
- en: '[PRE64]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In the preceding example, we define the `winPercentage()` function that accepts
    three parameters. These parameters are `team`, `wins`, and `loses`. The `team`
    parameter is a `String` type and the `wins` and `loses` parameters are `Int` types.
    The following line of code shows how to call the `winPercentage()` function:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们定义了接受三个参数的`winPercentage()`函数。这些参数是`team`、`wins`和`loses`。`team`参数是`String`类型，而`wins`和`loses`参数是`Int`类型。以下代码行展示了如何调用`winPercentage()`函数：
- en: '[PRE65]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now, let''s define the same function with external parameter names:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用外部参数名称定义相同的函数：
- en: '[PRE66]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In the preceding example, we redefine the `winPercentage` function with external
    parameter names. In this redefinition, we have the same three parameters: `team`,
    `wins`, and `losses`. The difference is how we define the parameters. When using
    external parameters, we define each parameter with both an external parameter
    name and a local parameter name separated by a space. In the preceding example,
    the first parameter has an external parameter name of `BaseballTeam`, an internal
    parameter name of `team`, and a type of `String`.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用外部参数名称重新定义了`winPercentage`函数。在这个重新定义中，我们有相同的三个参数：`team`、`wins`和`losses`。区别在于我们定义参数的方式。当使用外部参数时，我们使用外部参数名称和局部参数名称（两者之间用空格分隔）来定义每个参数。在前面的示例中，第一个参数有一个外部参数名称`BaseballTeam`，内部参数名称`team`，以及类型`String`。
- en: 'When we call a function with external parameter names, we need to include the
    external parameter names in the function call. The following code shows how to
    call the function in the preceding example:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用外部参数名称调用一个函数时，我们需要在函数调用中包含外部参数名称。以下代码展示了如何调用前面示例中的函数：
- en: '[PRE67]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: While using external parameter names requires more typing, it does make your
    code easier to read. In the preceding example, it is easy to see that the function
    is looking for the name of a baseball team, the second parameter is the number
    of wins, and the last parameter is the number of losses.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用外部参数名称需要更多的输入，但它确实使代码更容易阅读。在前面的示例中，很容易看出函数正在寻找一支棒球队的名称，第二个参数是获胜次数，最后一个参数是失败次数。
- en: Using variadic parameters
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用可变参数
- en: 'A variadic parameter is one that accepts zero or more values of a specified
    type. Within the functions definition, we define a variadic parameter by appending
    three periods(`...`) to the parameter''s type name. The values of a variadic parameter
    are made available to the function as an array of the specified type. The following
    example shows how we would use a variadic parameter with a function:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 可变参数是指可以接受零个或多个指定类型的值的参数。在函数定义内部，我们通过在参数类型名称后附加三个点（`...`）来定义可变参数。可变参数的值以指定类型的数组形式提供给函数。以下示例展示了我们如何在一个函数中使用可变参数：
- en: '[PRE68]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: In the preceding example, the `sayHello()` function takes two parameters. The
    first parameter is a String type, which is the greeting to use. The second parameter
    is a variadic parameter of the String type, which are the names to send the greeting
    to. Within the function, a variadic parameter is an array that contains the type
    specified; therefore, in our example, the `names` parameter is an array of `String`
    values. In this example, we use a `for-in` loop to access the values within the
    `names` parameter.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`sayHello()`函数接受两个参数。第一个参数是字符串类型，即要使用的问候语。第二个参数是字符串类型的可变参数，即要向其发送问候语的名字。在函数内部，可变参数是一个包含指定类型的数组；因此，在我们的示例中，`names`参数是一个包含`String`值的数组。在这个例子中，我们使用一个`for-in`循环来访问`names`参数中的值。
- en: 'The following line of code shows how to call the `sayHello()` function with
    a variadic parameter:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行代码展示了如何使用可变参数调用`sayHello()`函数：
- en: '[PRE69]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The preceding line of code will print two greetings: `Hello Jon` and `Hello
    Kim`.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 上一行代码将打印两个问候语：`Hello Jon`和`Hello Kim`。
- en: Parameters as variables
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数作为变量
- en: 'Parameters are constants by default, which means they cannot be changed within
    the function. Let''s look at the following example:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，参数是常量，这意味着它们在函数内部不能被更改。让我们看看以下示例：
- en: '[PRE70]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: If we try to run this example, we will get an exception because we will have
    attempted to change the value of the `count` parameter with the decrement operator
    (`--`). If we need to change the value of a parameter within our function, we
    need to specify that the parameter is a variable by using the `var` keyword in
    the function definition.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试运行此示例，我们将得到一个异常，因为我们尝试使用递减运算符（`--`）更改`count`参数的值。如果我们需要在函数内部更改参数的值，我们需要通过在函数定义中使用`var`关键字来指定该参数是一个变量。
- en: 'The following example shows how to declare the `count` parameter as a variable
    (rather than a constant) so that we can change the value within the function:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何将`count`参数声明为一个变量（而不是一个常量），这样我们就可以在函数内部更改其值：
- en: '[PRE71]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: You can see how we added the `var` keyword prior to the `count` parameter name
    in the preceding example. This specifies whether the parameter is a variable and
    not a constant; therefore, we can change the value of the `count` parameter in
    the function.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到在前面的示例中，我们在`count`参数名称之前添加了`var`关键字。这指定了参数是一个变量而不是常量；因此，我们可以在函数中更改`count`参数的值。
- en: Using inout parameters
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`inout`参数
- en: Variable parameters, as we just described, can only change the value of the
    parameter within the function; therefore, any changes are lost after the function
    ends. If we want the changes to a parameter to persist once the function ends,
    we need to define the parameter as an `inout` parameter. Any changes made to an
    `inout` parameter are passed back to the variable that was used in the function
    call.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们刚才所描述的，变量参数只能更改函数内部的参数值；因此，任何更改在函数结束后都会丢失。如果我们希望参数的更改在函数结束后仍然持续，我们需要将参数定义为`inout`参数。对`inout`参数所做的任何更改都会传递回函数调用中使用的变量。
- en: Two items to keep in mind when we use `inout` parameters are that these parameters
    cannot have default values and they cannot be a variadic parameter.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`inout`参数时有两个需要注意的事项：这些参数不能有默认值，也不能是可变参数。
- en: 'Let''s look at how to use the `inout` parameters to swap the values of two
    variables:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`inout`参数来交换两个变量的值：
- en: '[PRE72]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This function will accept two parameters and swap the values of the variables
    that are used in the function call. When we make the function call, we put an
    ampersand (`&`) in front of the variable name indicating that the function can
    modify its value. The following example shows how to call the reverse function:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将接受两个参数，并交换函数调用中使用的变量的值。当我们调用函数时，我们在变量名称前放置一个井号（`&`），表示函数可以修改其值。以下示例展示了如何调用反转函数：
- en: '[PRE73]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In the preceding example, we set variable `one` to the value `One` and variable
    `two` to the value `Two`. We then call the reverse function with the `one` and
    `two` variables. Once the swap function returns, the variable named `one` will
    contain the value `Two`, while the variable named `two` will contain the value
    `One`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们将变量`one`设置为值`One`，变量`two`设置为值`Two`。然后我们使用`one`和`two`变量调用反转函数。一旦交换函数返回，名为`one`的变量将包含值`Two`，而名为`two`的变量将包含值`One`。
- en: Nesting functions
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数嵌套
- en: All the functions that we have shown so far are examples of global functions.
    Global functions are the ones that are defined at a global scope within the class
    or file that they are in. Swift also allows us to nest one function within another.
    Nested functions can only be called within the enclosed function; however, the
    enclosed function can return a nested function that allows it to be used outside
    the scope of the enclosed function. We will cover returning a function in [Chapter
    12](ch12.html "Chapter 12. Working with Closures"), *Working with Closures*, later
    in this book.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止所展示的所有函数都是全局函数的例子。全局函数是在它们所在的类或文件中的全局作用域内定义的。Swift还允许我们在一个函数内部嵌套另一个函数。嵌套函数只能在封装函数内部调用；然而，封装函数可以返回一个嵌套函数，这允许它在封装函数的作用域之外使用。我们将在本书的[第12章](ch12.html
    "第12章。使用闭包")中介绍如何返回一个函数，*使用闭包*。
- en: 'Let''s look at how to nest functions by creating a simple sort function that
    will take an array of integers and sort it:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何通过创建一个简单的排序函数来嵌套函数，该函数将接受一个整数数组并对其进行排序：
- en: '[PRE74]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: In the preceding code, we begin by creating a global function named `sort` that
    accepts an `inout` parameter, that is, an array of `Ints`. Within the `sort` function,
    the first thing we do is define the nested function that is named `reverse`. A
    function needs to be defined in the code prior to calling it, so it is good practice
    to put all the nested functions at the start of the global function so that we
    know they are defined prior to calling them. The `reverse` function simply swaps
    the two values that are passed in.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先创建了一个名为`sort`的全局函数，它接受一个`inout`参数，即`Ints`数组。在`sort`函数内部，我们首先定义了一个名为`reverse`的嵌套函数。函数需要在调用之前在代码中定义，因此将所有嵌套函数放在全局函数的开始部分是一个好习惯，这样我们就可以在调用它们之前知道它们已经被定义了。`reverse`函数简单地交换传入的两个值。
- en: 'Within the body of the `sort` function, we implement the logic for the simple
    sort. Within that logic, we compare two numbers in the array, and if the numbers
    need to be reversed, we call the nested `reverse` function to swap the two numbers.
    This example shows how we can effectively use a nested function to organize our
    code to make it easy to maintain and read. Let''s look at how to call the global
    sort function:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在`sort`函数的主体中，我们实现了简单排序的逻辑。在这个逻辑中，我们比较数组中的两个数字，如果需要交换这两个数字，我们就调用嵌套的`reverse`函数来交换这两个数字。这个例子展示了我们如何有效地使用嵌套函数来组织我们的代码，使其易于维护和阅读。让我们看看如何调用全局的排序函数：
- en: '[PRE75]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The preceding code creates an array of five integers and then passes the array
    to the `sort` function. When the `sort` function returns the `nums` array, it
    contains a sorted array.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了一个包含五个整数的数组，然后将该数组传递给`sort`函数。当`sort`函数返回`nums`数组时，它包含了一个排序后的数组。
- en: Note
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Nested functions, when used properly, can be very useful. However, it is really
    easy to overuse them. Before creating a nested function, you might want to ask
    yourself why you want to use a nested function and what problem are you solving
    by using a nested function.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 正确使用嵌套函数时，它们可以非常有用。然而，过度使用它们是非常容易的。在创建嵌套函数之前，你可能想问自己为什么想要使用嵌套函数，以及通过使用嵌套函数你解决了什么问题。
- en: Putting it all together
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有这些放在一起
- en: 'To reinforce what we learned in this chapter, let''s look at one more example.
    For this example, we will create a function that will test to see if a string
    value contains a valid IPv4 address or not. An IPv4 address is the address assigned
    to a computer that uses the Internet Protocol to communicate. An IP address consists
    of four numeric values, ranging from 0-255, separated by a dot (period). An example
    of a valid IP address is 10.0.1.250:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 为了巩固我们在本章学到的内容，让我们再看一个例子。对于这个例子，我们将创建一个函数来测试一个字符串值是否包含有效的IPv4地址。IPv4地址是分配给使用互联网协议进行通信的计算机的地址。IP地址由四个数值组成，范围从0-255，由点（句号）分隔。一个有效的IP地址示例是10.0.1.250：
- en: '[PRE76]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Since the parameter for the `isValidIp()` function is an optional type, the
    first thing we do is verify that the `ipAddr` parameter is not nil. To do this,
    we used a `guard` statement with optional binding and if the optional binding
    fails, we return a Boolean `false` value because nil is not a valid IP address.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`isValidIp()`函数的参数是可选类型，我们首先需要验证`ipAddr`参数是否不为nil。为此，我们使用了一个带有可选绑定的`guard`语句，如果可选绑定失败，则返回一个布尔值`false`，因为nil不是一个有效的IP地址。
- en: If the `ipAddr` parameter contains a non-nil value, we then split the string
    into an array of strings, at the dots. Since an IP address is suppose to contain
    four numbers separated by a dot, we use the `guard` statement to check whether
    the array contains four elements. If it does not, we return `false` because we
    know that the `ipAddr` parameter did not contain a valid IP address.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `ipAddr` 参数包含一个非空值，我们将字符串分割成字符串数组，以点为分隔符。由于 IP 地址应该包含由点分隔的四个数字，我们使用 `guard`
    语句来检查数组是否包含四个元素。如果不包含，我们返回 `false`，因为我们知道 `ipAddr` 参数没有包含有效的 IP 地址。
- en: Next, we create a nested function named `validOctet()` that has one String parameter
    named `octet`. This nested function will verify that the `octet` parameter contains
    a numeric value between 0 and 255, and if so, it will return a Boolean `true`
    value, otherwise, it will return a `false` Boolean value.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建了一个名为 `validOctet()` 的嵌套函数，它有一个名为 `octet` 的 String 参数。这个嵌套函数将验证 `octet`
    参数是否包含介于 0 和 255 之间的数值，如果是，它将返回一个 Boolean `true` 值，否则，它将返回一个 `false` Boolean 值。
- en: Finally, we loop through a values in the array that we created by splitting
    the original `ipAddr` parameter at the dots and pass the values to the `validOctet()`
    nested function. If all the four values get verified by the `validOctet()` function,
    we have a valid IP address and we return a Boolean `true` value; however, if any
    of the values fail the `validOctet()` function, we return a Boolean `false` value.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们遍历通过在点处分割原始 `ipAddr` 参数创建的数组中的值，并将这些值传递给 `validOctet()` 嵌套函数。如果所有四个值都通过
    `validOctet()` 函数的验证，我们就有一个有效的 IP 地址，并返回一个 Boolean `true` 值；然而，如果任何一个值未能通过 `validOctet()`
    函数的验证，我们返回一个 Boolean `false` 值。
- en: Summary
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered control flow and functions in Swift. It is essential
    to understand the concepts in this chapter before going on. Every application
    that we write, beyond the simple Hello World applications, will rely very heavily
    on the control flow statements and functions.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 Swift 中的控制流和函数。在继续学习之前，理解本章中的概念是至关重要的。我们编写的每一个应用程序，除了简单的 Hello World
    应用程序之外，都将非常依赖控制流语句和函数。
- en: The control flow statements are used to make decisions within our application,
    and the functions will be used to group our code into the sections that are reusable
    and organized.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 控制流语句用于在应用程序中做出决策，而函数将用于将我们的代码分组到可重用和组织化的部分。
