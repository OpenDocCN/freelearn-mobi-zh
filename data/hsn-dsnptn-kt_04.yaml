- en: Getting Familiar with Behavioral Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 熟悉行为模式
- en: This chapter discusses behavioral patterns with Kotlin. Behavioral patterns
    deal with how objects interact with one another.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了Kotlin中的行为模式。行为模式处理对象之间的交互方式。
- en: We'll see how an object can behave in a totally different manner based on the
    situation, how objects can communicate without knowledge of one another, and how
    we can iterate over complex structures easily.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到对象如何根据情况以完全不同的方式表现，对象如何在不了解彼此的情况下进行通信，以及我们如何轻松地遍历复杂结构。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Strategy
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略
- en: Iterator
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器
- en: State
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态
- en: Command
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令
- en: Chain of responsibility
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 责任链
- en: Interpreter
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释器
- en: Mediator
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调解者
- en: Memento
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 备忘录
- en: Visitor
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问者
- en: Template method
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板方法
- en: Observer
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者
- en: Strategy
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 策略
- en: Remember *Maronic,* the platformer we were designing in [Chapter 3](part0080.html#2C9D00-6704093aa34748cfa77c54bdc1a20dc7), *Understanding
    Structural Patterns*, while discussing the **Facade** design pattern?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们在[第3章](part0080.html#2C9D00-6704093aa34748cfa77c54bdc1a20dc7)中讨论**外观**设计模式时设计的平台游戏**Maronic**吗？
- en: Well, canary Michael, who acts as a game designer in our small indie game development
    company, came up with a great idea. What if we were to give our hero an arsenal
    of weapons to protect us from those horrible carnivorous snails?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，作为我们小型独立游戏开发公司中的游戏设计师，迈克尔想出了一个很好的主意。如果我们给我们的英雄提供一套武器来保护我们免受那些可怕的肉食性蜗牛的伤害，会怎么样呢？
- en: 'Weapons all shoot projectiles (you don''t want to get close to those dangerous
    snails) in the direction our hero is facing:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 所有武器都会朝着我们英雄面对的方向发射弹丸（你不想靠近那些危险的蜗牛），：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'All projectiles should have a pair of coordinates (our game is 2D, remember?)
    and a direction:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 所有弹丸都应该有一对坐标（记住，我们的游戏是2D的？）和一个方向：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If we were to shoot only one type of projectile, that would be simple, since
    we already covered the **Factory** pattern in [Chapter 2](part0054.html#1JFUC0-6704093aa34748cfa77c54bdc1a20dc7),
    *Working with Creational Patterns*:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只发射一种类型的弹丸，那会很简单，因为我们已经在[第2章](part0054.html#1JFUC0-6704093aa34748cfa77c54bdc1a20dc7)中介绍了**工厂**模式，*使用创建型模式*：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'But Michael wants our hero to have at least three different weapons:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 但迈克尔希望我们的英雄至少有三种不同的武器：
- en: '**Peashooter**: Shoots small peas that fly straight. Our hero starts with it.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**豌豆射手**：发射直飞的豌豆。我们的英雄一开始就有它。'
- en: '**Pomegranate**: Explodes when hitting an enemy, much like a grenade.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**石榴**：击中敌人时会爆炸，就像手榴弹一样。'
- en: '**Banana**: Returns like a boomerang when it reaches the end of the screen.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**香蕉**：当它到达屏幕末端时会像回旋镖一样返回。'
- en: Come on, Michael, give us some slack! Can't you just stick with regular guns
    that all work the same?!
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 来吧，迈克尔，给我们点空间！你不能就坚持使用所有都一样的普通枪吗？！
- en: Fruit arsenal
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 果实军火库
- en: First, let's discuss how we could solve this in *the Java way*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们讨论一下如何用**Java方式**解决这个问题。
- en: 'In Java, we would have created an interface, that abstracts the changes. In
    our case, what changes is our hero''s weapon:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，我们会创建一个接口，来抽象变化。在我们的情况下，变化的是我们的英雄的武器：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then all other weapons would implement this interface:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然后所有其他武器都会实现这个接口：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then our hero would hold a reference to a weapon (`Peashooter` at the beginning):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们的英雄会持有一个武器的引用（最初是`Peashooter`）：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It would delegate the actual shooting process to it:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 它会将实际的射击过程委托给它：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'What''s left is the ability to equip another weapon:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是装备另一件武器的能力：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: And that's what the **Strategy** design pattern is all about. Now, our algorithms
    (Maronic's weapons, in that case) are interchangeable.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是**策略**设计模式的主要内容。现在，我们的算法（Maronic的武器，在这种情况下）是可互换的。
- en: Citizen function
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 市民函数
- en: With Kotlin, there's a more efficient way to implement the same functionality
    using fewer classes. That's thanks to the fact that functions in Kotlin are *first-class
    citizens*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，有一个更有效的方法来实现相同的功能，使用更少的类。这要归功于Kotlin中函数是**一等公民**的事实。
- en: What does that mean?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是什么意思？
- en: For one, we can assign functions to the variables of our class, like any other
    normal value.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以将函数分配给类的变量，就像任何其他正常值一样。
- en: 'It makes sense that you can assign a primitive value to your variable:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你可以将一个原始值分配给你的变量：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You could either assign an object to it:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将其分配给一个对象：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'So, why should you be able to assign a function to your variable? As follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么你应该能够将一个函数分配给你的变量？如下所示：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With Kotlin, this is totally valid.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，这是完全有效的。
- en: Switching sides
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换立场
- en: So, how do higher-order functions help us here?
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，高阶函数是如何帮助我们这里的呢？
- en: 'First, we''ll define a namespace for all our weapons. This is not mandatory,
    but helps to keep everything in check:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将为所有武器定义一个命名空间。这不是强制性的，但有助于保持一切井然有序：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, instead of classes, each of our weapons will become a function:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，而不是类，我们每件武器都将成为一个函数：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The most interesting part is our hero. It now holds two functions:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最有趣的部分是我们的英雄。它现在持有两个函数：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The interchangeable part is `currentWeapon`, while `shoot` is now an anonymous
    function that wraps it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 可互换的部分是 `currentWeapon`，而 `shoot` 现在是一个包装它的匿名函数。
- en: 'To test that our idea works, we can shoot the default weapon once, then switch
    to `Banana` and shoot it again:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的想法是否可行，我们可以先射击默认武器一次，然后切换到“香蕉”并再次射击：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice that this dramatically reduces the number of classes we have to write,
    while keeping the functionality the same.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这大大减少了我们需要编写的类的数量，同时保持了相同的功能。
- en: Iterator
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代器
- en: When we were discussing the **Composite** design pattern in the previous chapter,
    we noted that the design pattern felt a bit incomplete. Now is the time to reunite
    the twins separated at birth. Much like Arnold Schwarzenegger and Danny DeVito,
    they're very different, but complement each other well.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章讨论 **组合** 设计模式时，我们注意到这个设计模式感觉有点不完整。现在是时候让出生时分开的双胞胎重聚了。就像阿诺德·施瓦辛格和丹尼·德维托一样，他们非常不同，但很好地互补。
- en: One, two... many
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一，二...许多
- en: 'We''re back to our squads and platoons in our *CatsCraft 2: Revenge of the
    Dogs* strategy game.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '我们回到了我们的小队和班在 *CatsCraft 2: Dogs的复仇* 策略游戏中。'
- en: 'As you may remember from the previous chapter, `Squad` consists of `InfantryUnits`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如你从上一章所记得的，`Squad` 由 `InfantryUnits` 组成：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Each squad should also get a commander now.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 每个小队现在也应该有一个指挥官了。
- en: 'The commander of a squad called `Sergeant` is also an `InfantryUnit`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 叫做“军士”的小队指挥官也是一个 `InfantryUnit`：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Please disregard the fact that our sergeant doesn't have a name and gets created
    on the fly. We're two days short of releasing this game and beating the competition.
    Names are not important now.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 请忽略我们的军士没有名字并且是即时创建的事实。我们离发布这款游戏并击败竞争对手还有两天。名字现在不重要。
- en: 'The platoon is a collection of squads, and it also has a commander, called `Lieutenant`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 班是由小队组成的，它也有一个指挥官，称为 `中尉`：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: What our CEO wants is a platoon, and to be able to know which units it consists
    of.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的首席执行官想要的是一个班，并且能够知道它由哪些单位组成。
- en: 'So, when we have the following lines in our code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们在代码中有以下行时：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We would print by order of seniority:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照资历顺序打印：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Nowadays, this task may seem trivial to you, especially if you come from the
    Java world. But back in '94, data structures were mostly arrays of primitive types.
    Yes, `Array<Int>`, I'm looking at you.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个任务可能对你来说微不足道，尤其是如果你来自Java世界。但在1994年，数据结构主要是原始类型的数组。是的，`Array<Int>`，我在看着你。
- en: 'Iterating over an array wouldn''t be that hard, even in Java:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中遍历数组并不难：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: What are we to do with something much more complex?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的东西我们该怎么办？
- en: Running through the values
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传递价值观
- en: 'If you''re using an IDE such as IntelliJ, it will give you a hint on what the
    problem may be:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用像IntelliJ这样的IDE，它将给出有关可能问题的提示：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: So, our Platoon needs to have a function called `iterator()`. And since it's
    a special function, we'll need to use the `operator` keyword.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的班需要有一个名为 `iterator()` 的函数。由于它是一个特殊函数，我们需要使用 `operator` 关键字。
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'What our function returns is an anonymous object that implements the `Iterator<T>`
    interface:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们函数返回的是一个实现了 `Iterator<T>` 接口的匿名对象：
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The idea behind the iterator design pattern is to separate how the object stores
    data (in our case, it''s something like a tree) and how we can go over this data.
    As you may know, trees can be iterated in one of two ways:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器设计模式背后的思想是将对象存储数据的方式（在我们的例子中，它类似于一棵树）与我们遍历这些数据的方式分开。正如你可能知道的，树可以通过两种方式之一进行迭代：
- en: depth-first (also known as **depth-first search** (**DFS**))
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深度优先（也称为 **深度优先搜索** (**DFS**))
- en: breadth-first (also known as **breadth-first search** (**BFS**))
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 广度优先（也称为 **广度优先搜索** (**BFS**))
- en: But do we really care when we need to fetch all the elements?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 但当我们需要获取所有元素时，我们真的在乎吗？
- en: 'So, we separate these two concerns: storage aside, repeating aside.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将这两个关注点分开：存储一边，重复一边。
- en: To go over all the elements, we need to implement two methods, one to fetch
    the next element, and one to let the loop know when to stop.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要遍历所有元素，我们需要实现两个方法，一个用于获取下一个元素，另一个用于让循环知道何时停止。
- en: As an example, we'll implement this object for `Squad`. For Platoon, the logic
    would be similar, but requires a bit more math.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 作为例子，我们将为`Squad`实现这个对象。对于排，逻辑将是类似的，但需要更多的数学。
- en: 'First, we need a state for our iterator. It will remember that the last element
    is returned:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要为我们的迭代器提供一个状态。它将记住最后返回的元素：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, we need to tell it when to stop. In our case, the total number of elements
    is all the units of the squad, plus the sergeant:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要告诉它何时停止。在我们的例子中，元素的总数是队伍的所有单位加上中士：
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, we need to know which unit to return. If that was the first call,
    we''ll return the sergeant. The next calls will return one of the squad members:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要知道返回哪个单位。如果是第一次调用，我们将返回中士。接下来的调用将返回队伍成员之一：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that we want to return the next unit, but also to increase our counter.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们想要返回下一个单位，同时也要增加我们的计数器。
- en: For that, we use the also `{}` block.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个，我们使用`also` `{}`块。
- en: That's only one of the usages of this pattern.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是这个模式的一种用法。
- en: The same object may also have more than one iterator. For example, we could
    have the second iterator for our squad that would go over elements in reverse
    order.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 同一个对象也可能有多个迭代器。例如，我们可以有一个用于我们的队伍的第二个迭代器，它会按顺序遍历元素。
- en: 'To use it, we''ll need to call it by name:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，我们需要通过名称调用它：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Since it''s just a simple function that returns an iterator now, we don''t
    need the `operator` keyword:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于现在它只是一个返回迭代器的简单函数，我们不需要`operator`关键字：
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The only changes are coming in the `next()` method:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的变化发生在`next()`方法中：
- en: '[PRE29]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Sometimes, it also makes sense to receive an iterator as a parameter for a
    function:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，将迭代器作为函数的参数也是有意义的：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This function will iterate over anything that supplies an iterator:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将遍历任何提供迭代器的对象：
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This will print our squad members twice, once in regular and once in reverse
    order.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印我们的队伍成员两次，一次是正常顺序，一次是逆序。
- en: As a regular developer who doesn't invent new data structures for his or her
    living, you may now implement iterators often. But it's important to know how
    they work behind the scenes nevertheless.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名普通的开发者，他或她并不以发明新的数据结构为生，你现在可能经常实现迭代器。但了解它们在幕后是如何工作的仍然很重要。
- en: State
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态
- en: You can think of the **State** design pattern as an opinionated Strategy, which
    we discuss at the beginning of this chapter. But while Strategy is changed from
    the outside, by the *client*, the State may change internally, based solely on
    the input it gets.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将**状态**设计模式视为一个有偏见的策略，我们在本章的开头讨论了它。但是，虽然策略是由外部，即*客户*改变的，状态可能会根据它接收到的输入内部改变。
- en: 'Look at this dialog a client wrote with Strategy:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个客户与策略之间的对话：
- en: Client: Here’s a new thing to do, start doing it from now on.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 客户：这里有一些新的事情要做，从现在开始做。
- en: 'Strategy: OK, no problem.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 策略：好的，没问题。
- en: 'Client: What I like about you is that you never argue with me.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 客户：我喜欢你的地方是，你从不和我争论。
- en: 'Compare it with this one:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 与这个比较一下：
- en: 'Client: Here’s some new input I got from you.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 客户：这里有一些我从你那里得到的新输入。
- en: 'State: Oh, I don''t know. Maybe I''ll start doing something differently. Maybe
    not.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 状态：哦，我不知道。也许我会开始做一些不同的事情。也许不会。
- en: 'The client should also expect that the State may even reject some of its inputs:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 客户应该也期望状态可能会拒绝一些输入：
- en: 'Client: Here''s something for you to ponder, State.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 客户：这里有一些东西让你思考，状态。
- en: 'State: I don''t know what it is! Don''t you see I''m busy? Go bother some Strategy
    with this!'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 状态：我不知道那是什么！你没看到我很忙吗？去烦一下策略吧！
- en: So, why do clients still tolerate that State of ours? Well, State is really
    good at keeping everything under control.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么客户仍然容忍我们那个状态呢？嗯，状态真的很擅长控制一切。
- en: Fifty shades of State
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 五十种状态
- en: Carnivorous snails have had enough of this Maronic hero. He throws peas and
    bananas at them, only to get to another sorry castle. Now they shall act!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 肉食性蜗牛对这个马罗尼英雄已经受够了。他向它们扔豌豆和香蕉，结果却只是到达另一个令人遗憾的城堡。现在它们要行动了！
- en: By default, the snail should stand still to conserve snail energy. But when
    the hero gets close, it dashes towards him aggressively.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，蜗牛应该静止不动以节省蜗牛能量。但是当英雄靠近时，它将积极地向他冲刺。
- en: If the hero manages to injure it, it should retreat to lick its wounds. Then
    it will repeat attacking, until one of them is dead.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果英雄设法伤害了它，它应该撤退去舔伤口。然后它将重复攻击，直到其中一个死去。
- en: 'First, we''ll declare what can happen during a snail''s life:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明蜗牛生命中可能发生的事情：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Our snail implements this interface, so it can get notified of anything that
    may happen to it and act accordingly:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的蜗牛实现了这个接口，因此它可以被通知任何可能发生的事情，并相应地采取行动：
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, we declare the `Mood` class, which we mark with the `sealed` keyword:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们声明`Mood`类，我们用`sealed`关键字标记它：
- en: '[PRE34]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Sealed classes are abstract and cannot be instantiated. We''ll see the benefit
    of using them in a moment. But before that, let''s declare other states:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 密封类是抽象的，不能被实例化。我们将在稍后看到使用它们的优点。但在那之前，让我们声明其他状态：
- en: '[PRE35]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Those are all different states, sorry, moods, of our snail.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是我们蜗牛的不同状态，对不起，是情绪。
- en: 'In State design pattern terms, `Snail` is the context. It holds the state.
    So, we declare a member for it:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在状态设计模式术语中，`Snail`是上下文。它持有状态。因此，我们为它声明一个成员：
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now let''s define what `Snail` should do when it sees our hero:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们定义当`Snail`看到我们的英雄时应该做什么：
- en: '[PRE37]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Compilation error! Well, that's where the `sealed` class comes into play. Much
    like with an `enum`, Kotlin knows that there's a finite number of classes that
    extend from it. So, it requires that our `when` is exhaustive and specifies all
    different cases in it.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 编译错误！嗯，这就是`sealed`类发挥作用的地方。就像`enum`一样，Kotlin知道从它扩展的类数量是有限的。因此，它要求我们的`when`是详尽的，并在其中指定所有不同的案例。
- en: If you're using IntelliJ as your IDE, it will even suggest you "add remaining
    branches" automatically.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用IntelliJ作为你的IDE，它甚至会自动建议你“添加剩余的分支”。
- en: 'Let''s describe our state:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们描述我们的状态：
- en: '[PRE38]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Of course, `else` still works:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`else`仍然有效：
- en: '[PRE39]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'When the snail gets hit, we need to decide if it''s dead or not. For that,
    we can use `when` without an argument:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当蜗牛被击中时，我们需要决定它是死是活。为此，我们可以使用不带参数的`when`：
- en: '[PRE40]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note that we use the `is` keyword, which is the same as `instanceof` in Java,
    but more concise.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用了`is`关键字，这与Java中的`instanceof`相同，但更简洁。
- en: State of the Nation
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 国家状况
- en: The previous approach has most of the logic in our *context*. You may sometimes see
    a different approach, which is valid as your *context* grows bigger.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的方法在大多数逻辑都在我们的*上下文*中。你有时可能会看到不同的方法，这在你的*上下文*变大时是有效的。
- en: 'In this approach, `Snail` would become really thin:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，`Snail`会变得非常瘦：
- en: '[PRE41]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note that we marked `mood` as `internal`. That lets other classes in that package
    alter it.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将`mood`标记为`internal`。这允许同一包中的其他类修改它。
- en: 'Instead of `Snail` implementing `WhatCanHappen`, our Mood will:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是让`Snail`实现`WhatCanHappen`，我们的`Mood`将：
- en: '[PRE42]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'And now the logic resides within our state objects:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在逻辑位于我们的状态对象中：
- en: '[PRE43]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note that our state objects now receive a reference to their context in the
    constructor.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的状态对象现在在构造函数中接收对其上下文的引用。
- en: 'That''s the first time we''ve met the `run` extension function. It''s equivalent
    would be:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一次遇到`run`扩展函数。它的等效函数将是：
- en: '[PRE44]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: By using run, we can preserve the same logic, but omit the function body.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`run`，我们可以保留相同的逻辑，但省略函数体。
- en: You'll need to decide what approach to use. In our example, this will actually
    produce much more code, will have to implement all the methods by itself.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要决定使用哪种方法。在我们的例子中，这实际上会产生更多的代码，将不得不自己实现所有的方法。
- en: Command
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令
- en: This design pattern allows you to encapsulate action inside an object to be
    executed sometime later.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计模式允许你将动作封装在对象中，稍后执行。
- en: Furthermore, if we can execute one action later on, why not execute many? Why
    not schedule exactly when to execute?
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们可以在稍后执行一个动作，为什么不执行多个呢？为什么不精确地安排何时执行？
- en: 'That''s exactly what we need to do in our *CatsCraft 2: Revenge of the Dogs* game
    now*. *Dave, a new developer that we''ve hired lately, was working hard the whole
    weekend, while no one was allowed to bother him. He implemented the following
    abstract methods for our furry soldiers:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '这正是我们现在在**CatsCraft 2: 狗的复仇**游戏中需要做的。*Dave，我们最近雇佣的一位新开发者，整个周末都在努力工作，没有人敢打扰他。他为我们的毛茸茸的士兵实现了以下抽象方法*：'
- en: '[PRE45]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: He probably even used the **Bridge** design pattern from the previous chapter
    to do that.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 他甚至可能使用了上一章中提到的**桥接**设计模式来做到这一点。
- en: 'The problem we need to solve now is that the soldier can remember exactly one
    *command*. That''s it. If he starts at `(0, 0)`, the top of the screen, we first
    tell him to `move(20, 0)`, that''s 20 steps right, and then to `move(20, 20)`,
    so he''ll move straight to `(20, 20)`, and will probably get totally destroyed,
    because there are dog enemies to avoid at all costs:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要解决的问题是士兵只能记住一个*命令*。就是这样。如果他从`(0, 0)`，屏幕的顶部开始，我们首先告诉他`move(20, 0)`，即向右移动20步，然后到`move(20,
    20)`，所以他将会直线移动到`(20, 20)`，并且可能会被完全摧毁，因为必须不惜一切代价避开狗敌人：
- en: '[PRE46]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If you've been following this book from the start, or at least joined at [Chapter
    3](part0080.html#2C9D00-6704093aa34748cfa77c54bdc1a20dc7), *Understanding Structural
    Patterns*, you probably have an idea of what we need to do, since we already discussed
    the concept of *functions as first-class citizens* in the language.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从本书的开头开始阅读，或者至少从[第3章](part0080.html#2C9D00-6704093aa34748cfa77c54bdc1a20dc7)，“理解结构型模式”开始加入，你可能已经有一个想法，我们需要做什么，因为我们已经讨论了语言中*函数作为一等公民*的概念。
- en: But even if you decided to just figure out how the Command design pattern should
    work in Kotlin, or opened this book randomly to this section, we'll give you a
    brief explanation on how that dog obstacle could be solved.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 但即使你决定只是弄清楚命令设计模式在Kotlin中应该如何工作，或者随机打开这本书到这一节，我们也会简要解释如何解决这个狗障碍。
- en: 'Let''s sketch a skeleton for that. We know that we want to hold a list of objects,
    but we don''t know yet what type they should be. So we''ll use `Any` for now:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为它画一个骨架。我们知道我们想要保持一个对象的列表，但我们还不知道它们应该是哪种类型。所以现在我们将使用`Any`：
- en: '[PRE47]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Then, we want to iterate over the list and execute the orders we have:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们想要遍历列表并执行我们拥有的命令：
- en: '[PRE48]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'So, even if you''re not familiar with the Command design pattern, you can guess
    that we can define an interface with a single method, `execute()`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，即使你不熟悉命令设计模式，你也可以猜到我们可以定义一个只有一个方法的接口，`execute()`：
- en: '[PRE49]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'And then hold a list of the same time in a member property:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在成员属性中保持相同时间的一个列表：
- en: '[PRE50]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Implement this interface as needed. That's basically what the Java implementation
    of this pattern would suggest in most cases. But isn't there a better way?
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 根据需要实现此接口。这基本上就是大多数情况下Java实现此模式所建议的。但难道没有更好的方法吗？
- en: 'Let''s look at the Command again. Its `execute()` method receives nothing,
    returns nothing, and does something. It''s the same as writing the following code
    then:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看命令。它的`execute()`方法不接收任何东西，也不返回任何东西，但做了一些事情。它与以下代码相同：
- en: '[PRE51]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'It''s not different at all. We could simplify this further:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 完全没有区别。我们可以进一步简化这个：
- en: '[PRE52]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Instead of having an interface for that called `Command`, we''ll have a `typealias`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再需要一个名为`Command`的接口，而将使用`typealias`：
- en: '[PRE53]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, this line stops compiling again:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这一行再次停止编译：
- en: '[PRE54]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Well, that''s because `execute()` is just some name we invented. In Kotlin,
    functions use `invoke()`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，那是因为`execute()`只是我们发明的一个名字。在Kotlin中，函数使用`invoke()`：
- en: '[PRE55]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: That's nice, but the functions Dave wrote receive arguments, and our function
    has no parameters at all.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但Dave编写的函数接收参数，而我们的函数没有任何参数。
- en: 'One option would be to change the signature of our `Command` to receive two
    parameters:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一个选项是改变我们的`Command`签名以接收两个参数：
- en: '[PRE56]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: But what if some commands receive no arguments, or only one, or more than two?
    We also need to remember what to pass to `invoke()` at each step.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果某些命令不接收任何参数，或者只接收一个，或者接收两个以上呢？我们还需要记住在每一步传递给`invoke()`的内容。
- en: A much better way is to have a function generator. That is, a function that
    returns another function.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的方法是拥有一个函数生成器。也就是说，一个返回另一个函数的函数。
- en: 'If you ever worked with JavaScript language, that''s a common practice to use
    closures to limit the scope and *remember* stuff. We''ll do the same:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用过JavaScript语言，使用闭包来限制作用域和*记住*东西是一种常见的做法。我们也会这样做：
- en: '[PRE57]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'When called with proper arguments, `moveGenerator` will return a new function.
    That function can be invoked whenever we find it suitable, and it will *remember*:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当用适当的参数调用时，`moveGenerator`将返回一个新的函数。这个函数可以在我们找到合适的时候调用，并且它将*记住*：
- en: What method to call
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用哪个方法
- en: With which arguments
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用哪些参数
- en: On which object
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在哪个对象上
- en: 'Now, our `Soldier` may have a method like this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的`Soldier`可能有一个像这样的方法：
- en: '[PRE58]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'It provides us with a nice fluent syntax:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 它为我们提供了一个流畅的语法：
- en: '[PRE59]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This code will print the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将打印以下内容：
- en: '[PRE60]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Undoing commands
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 撤销命令
- en: While not directly related, one of the advantages of the Command design pattern
    is the ability to undo commands. What if we wanted to support such a functionality?
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不是直接相关，但命令设计模式的一个优点是能够撤销命令。如果我们想要支持这样的功能呢？
- en: 'Undoing is usually very tricky, because it involves one of the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 撤销通常非常棘手，因为它涉及到以下之一：
- en: Returning to the previous state (impossible if there's more than one client,
    requires a lot of memory)
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回到之前的状态（如果有多个客户端则不可能，需要大量内存）
- en: Computing deltas (tricky to implement)
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算增量（实现起来很棘手）
- en: Defining opposite operations (not always possible)
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义相反的操作（不一定总是可能的）
- en: 'In our case, the opposite of the command *move from (0,0) to (0, 20)* would
    be *move from wherever you''re now to (0,0)*. This could be achieved by storing
    a pair of commands:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，命令*从(0,0)移动到(0,20)*的反面将是*从你现在所在的位置移动到(0,0)*。这可以通过存储一对命令来实现：
- en: '[PRE61]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'You can also add pairs of commands:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以添加命令对：
- en: '[PRE62]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Actually, computing the opposite move is quite complex, as we don't save the
    position of our soldier currently (it was something Dave should have implemented
    anyway), and we'll also have to deal with some edge cases.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，计算反走法相当复杂，因为我们没有保存我们士兵当前的位置（这本来是戴夫应该实现的事情），我们还得处理一些边缘情况。
- en: Chain of responsibility
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 责任链
- en: I'm a horrible software architect, and I don't like to speak with people. Hence,
    while sitting in The Ivory Tower (that's the name of the cafe I often visit),
    I wrote a small web application. If a developer has a question, he shouldn't approach
    me directly, oh no. He'll need to send me a proper request through this system,
    and I shall answer him only if I deem this request worthy.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我是一个糟糕的软件架构师，我不喜欢和人说话。因此，当我坐在 The Ivory Tower（这是我经常去的咖啡馆的名字）里时，我写了一个小的网络应用程序。如果一个开发者有问题，他不应该直接找我，哦不。他需要通过这个系统给我发送一个适当的请求，而我只有在我认为这个请求有价值时才会回答他。
- en: 'A filter chain is a very common concept in web servers. Usually, when a request
    reaches to you, it''s expected that:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤链是网络服务器中一个非常常见的概念。通常，当一个请求到达你那里时，预期的是：
- en: Its parameters are already validated
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的参数已经过验证
- en: The user is already authenticated, if possible
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可能的话，用户已经认证过了
- en: User roles and permissions are known, and the user is authorized to perform
    an action
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户角色和权限已知，并且用户被授权执行操作
- en: 'So, the code I initially wrote looked something like this:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我最初写的代码看起来像这样：
- en: '[PRE63]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: A bit messy, but it works.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 稍显混乱，但它是有效的。
- en: Then I noticed that some developers decide they can send me two questions at
    once. Gotta add some more logic to this function. But wait, I'm an architect,
    after all. Isn't there a better way to *delegate* this?
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我注意到一些开发者决定他们可以一次性给我提出两个问题。我得给这个函数添加更多的逻辑。但是等等，我毕竟是个架构师。难道没有更好的方法来*委派*这个任务吗？
- en: 'This time, we won''t learn new Kotlin tricks, but use those that we already
    learned. We could start with implementing an interface such as this one:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们不会学习新的 Kotlin 技巧，而是使用我们已经学过的。我们可以从一个这样的接口开始实现：
- en: '[PRE64]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We never discussed what my response to one of the developers looked like. That''s
    because I keep my chain of responsibility so long and complex that usually, they
    tend to solve problems by themselves. I''ve never had to answer one of them, quite
    frankly. But at least we know what their requests look like:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从未讨论过我对开发者的回应是什么样子。那是因为我保持我的责任链非常长且复杂，通常，他们倾向于自己解决问题。坦白说，我从未需要回答过他们中的任何一个。但至少我们知道他们的请求看起来是什么样子：
- en: '[PRE65]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Then we could do it the Java way, and start implementing each piece of logic
    inside its own handler:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以用 Java 的方式来做，并在每个处理器内部实现每块逻辑：
- en: '[PRE66]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Other filters would look very similar to this one. We can compose them in any
    order we want:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 其他过滤器看起来会非常类似这个。我们可以按任何顺序组合它们：
- en: '[PRE67]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'But I won''t even ask you the rhetoric question this time about better ways.
    Of course there''s a better way, we''re in the Kotlin world now. And we''ve seen
    the usage of functions in the previous section. So, we''ll define a function for
    that task:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 但这次我不会问你关于更好方法的修辞问题。当然有更好的方法，我们现在在 Kotlin 世界。我们已经在上一节中看到了函数的使用。所以，我们将为那个任务定义一个函数：
- en: '[PRE68]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Why have a separate class and interface for something that receives a request
    and returns a response in a nutshell:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会有一个单独的类和接口来接收请求并返回响应，简而言之：
- en: '[PRE69]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Here, `authentication` is a function that literally receives a function and
    returns a function.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`authentication`是一个函数，它实际上接收一个函数并返回一个函数。
- en: 'Again, we can compose those functions:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以组合这些函数：
- en: '[PRE70]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: It's up to you which method you choose. Using interfaces is more explicit, and
    would better suit you if you're creating your own library or framework that others
    may want to extend.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 选择哪种方法取决于你。使用接口更明确，如果你正在创建一个其他人可能想要扩展的库或框架，这将更适合你。
- en: Using functions is more concise, and if you just want to split your code in
    a more manageable way, it may be the better choice.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数更简洁，如果你只是想以更可管理的方式分割你的代码，这可能是一个更好的选择。
- en: Interpreter
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释器
- en: This design pattern may seem very simple or very hard, all based on how much
    background you have in computer science. Some books that discuss classical software
    design patterns even decide to omit it altogether, or put it somewhere at the
    end, for curious readers only.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计模式可能看起来非常简单或非常复杂，这完全取决于你在计算机科学方面的背景。一些讨论经典软件设计模式的书籍甚至决定完全省略它，或者把它放在最后，仅供好奇的读者阅读。
- en: The reason behind this is that the interpreter design pattern deals with translating
    certain languages. But why would we need that? Don't we have compilers to do that
    anyway?
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这背后的原因是解释器设计模式处理翻译某些语言。但为什么我们需要这样做呢？我们不是已经有编译器来做了吗？
- en: We need to go deeper
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们需要更深入地了解
- en: In this section we discuss that all developers have to speak many languages
    or sub-languages. Even as regular developers, we use more than one language. Think
    of tools that build your projects, like Maven or Gradle. You can consider their
    configuration files, **build scripts**, as languages with specific grammar. If
    you put elements out of order, your project won't be built correctly. And that's
    because such projects have interpreters to analyze configuration files and act
    upon them.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了所有开发者都必须掌握多种语言或子语言。即使是普通开发者，我们也使用不止一种语言。想想那些构建你项目的工具，比如 Maven 或 Gradle。你可以将它们的配置文件、**构建脚本**视为具有特定语法的语言。如果你将元素顺序搞错，你的项目将无法正确构建。这是因为这样的项目有解释器来分析配置文件并对它们进行操作。
- en: Other examples would be **query languages**, be it one of the SQL variations
    or one of the languages specific to NoSQL databases.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 其他例子可以是 **查询语言**，无论是 SQL 的变体之一还是特定于 NoSQL 数据库的语言之一。
- en: If you're an Android developer, you may think of XML layouts as such languages
    too. Even HTML could be considered a language that defines **user interfaces**.
    And there are others, of course.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一名 Android 开发者，你可能也会将 XML 布局视为这类语言。甚至 HTML 也可以被视为定义 **用户界面** 的语言。当然，还有其他语言。
- en: 'Maybe you''ve worked with one of the **testing frameworks** that define a custom
    language for testing, such as Cucumber: [github.com/cucumber](https://github.com/cucumber).'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你曾经使用过定义了自定义测试语言的测试框架之一，例如 Cucumber：[github.com/cucumber](https://github.com/cucumber)。
- en: Each of these examples can be called a **Domain Specific Language** (**DSL**).
    A language inside a language. We'll discuss how it works in the next section.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例中的每一个都可以被称为 **领域特定语言**（**DSL**）。一种语言中的语言。我们将在下一节中讨论它是如何工作的。
- en: A language of your own
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你自己的语言
- en: 'In this section, we''ll define a simple DSL-for-SQL language. We won''t define
    the format or grammar for it, but only an example of what it should look like:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将定义一个简单的 DSL-for-SQL 语言。我们不会定义其格式或语法，而只是提供一个示例，说明它应该看起来像什么：
- en: '[PRE71]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The goal of our language is to improve readability and prevent some common SQL
    mistakes, such as typos (like FORM instead of FROM). We'll get compile time validations
    and autocompletion along the way.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们语言的目标是提高可读性并防止一些常见的 SQL 错误，例如拼写错误（如 FORM 而不是 FROM）。我们将在过程中获得编译时验证和自动完成。
- en: 'We''ll start with the easiest part—`select`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从最简单的一部分——`select`——开始：
- en: '[PRE72]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: We could write this using single expression notation, but we use the more verbose
    version for clarity of the example.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用单表达式表示法来写这个，但我们使用更冗长的版本以便于示例的清晰性。
- en: This is a function that has two parameters. The first is a `String`, which is
    simple. The second is another function that receives nothing and returns nothing.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有两个参数的函数。第一个是一个 `String`，很简单。第二个是一个接收什么都不返回的函数。
- en: 'The most interesting part is that we specify the receiver for our lambda:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 最有趣的部分是我们为我们的 lambda 指定了接收者：
- en: '[PRE73]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'This is a very smart trick, so be sure to follow along:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常聪明的技巧，所以请确保跟得上：
- en: '[PRE74]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Although it may seem that this lambda receives nothing, it actually receives
    one argument, an object of type `SelectClause`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然看起来这个 lambda 没有接收任何东西，但实际上它接收了一个参数，一个类型为 `SelectClause` 的对象。
- en: The second trick lies in the usage of the `apply()` function we've seen before.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个技巧在于使用我们之前见过的 `apply()` 函数。
- en: 'Look at this:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个：
- en: '[PRE75]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'It translates to this:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这翻译成这样：
- en: '[PRE76]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Here are the steps the preceding code will perform:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将执行的前置代码的步骤：
- en: Initialize `SelectClause`, which is a simple object that receives one argument
    in its constructor.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化 `SelectClause`，这是一个简单的对象，它在构造函数中接收一个参数。
- en: Call the `from()` function with an instance of `SelectClause` as its only argument.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `from()` 函数，并传入一个 `SelectClause` 实例作为唯一参数。
- en: Return an instance of `SelectClause`.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回一个 `SelectClause` 实例。
- en: That code only makes sense if `from()` does something useful with `SelectClause`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 那段代码只有在 `from()` 对 `SelectClause` 做一些有用的事情时才有意义。
- en: 'Let''s look at our DSL example again:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看我们的 DSL 示例：
- en: '[PRE77]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: We've made the receiver explicit now, meaning that the `from()` function will
    call the `from()` method on the `SelectClause` object.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经明确指定了接收者，这意味着 `from()` 函数将调用 `SelectClause` 对象上的 `from()` 方法。
- en: 'You can start guessing what this method looks like. It clearly receives a `String`
    as its first argument, and another lambda as its second:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以开始猜测这个方法的样子。很明显，它接收一个 `String` 作为其第一个参数，并接收另一个 lambda 作为其第二个参数：
- en: '[PRE78]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: This could again be shortened, but then we'd need to use `apply()` within `apply()`,
    which may seem confusing at this point.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这又可以进一步缩短，但这样我们可能需要在 `apply()` 中使用 `apply()`，这可能会让人感到困惑。
- en: That's the first time we've met the `lateinit` keyword. This keyword is quite
    dangerous, so use it with some restraint. Remember that the Kotlin compiler is
    very serious about null safety. If we omit `lateinit`, it will require us to initialize
    the variable with a default value. But since we'll know it only at a later time,
    we ask the compiler to relax a bit. Note that if we don't make good on our promises
    and forget to initialize it, we'll get `UninitializedPropertyAccessException` when
    first accessing it.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一次遇到 `lateinit` 关键字。这个关键字相当危险，所以请谨慎使用。记住，Kotlin 编译器对空安全非常严格。如果我们省略 `lateinit`，它将要求我们使用默认值初始化变量。但由于我们将在稍后知道它，我们要求编译器稍微放松一下。注意，如果我们没有履行我们的承诺并忘记初始化它，当我们第一次访问它时，我们会得到
    `UninitializedPropertyAccessException`。
- en: 'Back to our code; all we do is:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的代码；我们做的只是：
- en: Create an instance of `FromClause`
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `FromClause` 的实例
- en: Store it as a member of `SelectClause`
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其存储为 `SelectClause` 的成员
- en: Pass an instance of `FromClause` to the `where` lambda
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `FromClause` 的实例传递给 `where` lambda
- en: Return an instance of `FromClause`
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回一个 `FromClause` 的实例
- en: 'Hopefully, you''re starting to get the gist of it:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你现在开始理解其精髓：
- en: '[PRE79]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'What does it mean? After understanding the `from()` method, this should be
    much simpler. The `FromClause` must have a method called `where()` that receives
    one argument, of the `String` type:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着什么？在理解了 `from()` 方法之后，这应该会简单得多。`FromClause` 必须有一个名为 `where()` 的方法，它接收一个
    `String` 类型的参数：
- en: '[PRE80]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Note that we made good on our promise and shortened the method this time.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们这次履行了我们的承诺，缩短了方法。
- en: 'We initialized an instance of `WhereClause` with the string we received, and
    returned it. Simple as that:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用接收到的字符串初始化了一个 `WhereClause` 的实例，并返回了它。就这么简单：
- en: '[PRE81]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '`WhereClause` only prints the word `WHERE` and the conditions it received:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`WhereClause` 只打印出单词 `WHERE` 和它接收到的条件：'
- en: '[PRE82]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '`FromClause` prints the word `FROM` as well as the table name it received,
    and everything `WhereClause` printed:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`FromClause` 打印出单词 `FROM` 以及它接收到的表名，以及 `WhereClause` 打印出的所有内容：'
- en: '[PRE83]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '`SelectClause` prints the word `SELECT`, the columns it got, and whatever `FromClause`
    printed.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`SelectClause` 打印出单词 `SELECT`，它获取的列，以及 `FromClause` 打印出的任何内容。'
- en: Taking a break
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 休息一下
- en: Kotlin provides beautiful capabilities to create readable and type-safe DSLs.
    But the interpreter design pattern is one of the hardest in the toolbox. If you
    didn't get it from the get-go, take some time to debug this code. Understand what
    `this` means at each step, as well as when we call a function and when we call
    a method of an object.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 提供了创建可读性和类型安全的 DSL 的美丽功能。但解释器设计模式是工具箱中最难的一个。如果你一开始没有理解，请花些时间调试这段代码。理解每一步中的
    `this` 的含义，以及我们调用函数和调用对象方法的时候。
- en: Call suffix
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用后缀
- en: In order not to confuse you, we left out one last notion of Kotlin DSL until
    the end of this section.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 为了不让你感到困惑，我们在本节结束前省略了一个 Kotlin DSL 的最后概念。
- en: 'Look at this DSL:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个 DSL：
- en: '[PRE84]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'It could be rewritten as:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以被重写为：
- en: '[PRE85]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: This is common practice in Kotlin. If our function receives another function
    as its last argument, we can pass it out of parentheses.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这在 Kotlin 中是一种常见做法。如果我们的函数接收另一个函数作为其最后一个参数，我们可以将其传递出括号。
- en: This results in a much clearer DSL, but may be confusing at first.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得 DSL 更加清晰，但一开始可能会让人感到困惑。
- en: Mediator
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中介
- en: There's no way around it. The **Mediator** design pattern is simply a control
    freak. It doesn't like it when one object speaks to the other directly. It gets
    mad sometimes when that happens. No, everybody should speak only through him.
    What's his explanation? It reduces coupling between objects. Instead of knowing
    some other objects, everybody should know only him, the Mediator.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 没有其他办法。**中介者**设计模式就是一个控制狂。它不喜欢一个对象直接与另一个对象交流。当这种情况发生时，它有时会变得很生气。不，每个人都应该只通过他来交流。他的解释是什么？它减少了对象之间的耦合。不是每个人都应该知道一些其他对象，而是每个人都应该只认识他，即中介者。
- en: Trouble in the Jungle
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 森林中的麻烦
- en: Architectural jokes aside, we, the *Maronic* development team, have some real
    problems. And they're not related to code directly. As you may remember, our little
    indie company consists of only me, a canary named Michael that acts as a product
    manager, and two cat designers that sleep most of the day, but do produce some
    decent mockups from time to time. We have no QA (that's quality assurance guys)
    whatsoever. Maybe that's one of the reasons our game keeps crashing all the time.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 抛开建筑笑话不谈，我们，*Maronic* 开发团队，确实有一些实际问题。这些问题与代码没有直接关系。你可能还记得，我们的小型独立公司只有我一个人，一只名叫迈克尔的金丝雀，它担任产品经理，还有两位猫设计师，他们大部分时间都在睡觉，但偶尔也会制作出一些不错的原型。我们没有质量保证团队（即质量保证人员）。也许这就是我们的游戏总是频繁崩溃的原因之一。
- en: 'Lately, Michael has introduced me to a parrot named `Kenny`, who happens to
    be QA:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，迈克尔介绍我认识了一只名叫 `Kenny` 的鹦鹉，他恰好是质量保证人员：
- en: '[PRE86]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: This section will use objects for the sake of simplicity.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，本节将使用对象。
- en: 'Parrot QAs are very motivated. They''re ready to test the latest version of
    my game any time. But they really don''t like to be bothered when they are either
    sleeping or eating:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 鹦鹉质量保证人员非常有动力。他们随时准备测试我游戏的最新版本。但他们真的很不喜欢在睡觉或吃饭时被打扰：
- en: '[PRE87]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'In case `Kenny` had any questions, I gave him my direct number:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `Kenny` 有任何问题，我会给他我的直接电话号码：
- en: '[PRE88]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '`Kenny` was a hard-working parrot. But we had so many bugs that we also had
    to hire a second parrot QA, Brad. If `Kenny` is free, I give the job to him, as
    he''s more acquainted with our project. But if he''s busy, I check if Brad is
    free, and give this task to him:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`Kenny` 是一只勤奋的鹦鹉。但我们有如此多的虫子，以至于我们不得不雇佣第二只鹦鹉质量保证人员，Brad。如果 `Kenny` 有空，我会把工作交给他，因为他更熟悉我们的项目。但如果他忙，我会检查
    Brad 是否有空，然后把这项任务交给他：'
- en: '[PRE89]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '`Brad`, being more junior, usually checks up with `Kenny` first. And `Kenny`
    also gave my number to him:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`Brad` 作为初级成员，通常会先向 `Kenny` 汇报。而且 `Kenny` 也把我的电话号码给了他：'
- en: '[PRE90]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Then Brad introduces me to `George`. `George` is an owl, so he sleeps at different
    times than `Kenny` and Brad. That means that he can check my code at night. The
    problem is, `George` is an avid football fan. So before calling him, we need to
    check if he''s watching a game now:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 然后 Brad 介绍我认识 `George`。`George` 是一只猫头鹰，所以他的睡眠时间与 `Kenny` 和 Brad 不同。这意味着他可以在夜间检查我的代码。问题是，`George`
    是一名狂热的足球迷。所以在给他打电话之前，我们需要检查他是否正在看比赛：
- en: '[PRE91]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '`Kenny` as a habit checks with `George` too, because `George` is a very knowledgeable
    owl:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`Kenny` 习惯性地也会向 `George` 汇报，因为 `George` 是一只非常博学的猫头鹰：'
- en: '[PRE92]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'And `George` checks with `Kenny`, because `Kenny` is also into football, it
    seems:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`George` 会检查 `Kenny`，因为 `Kenny` 似乎也对足球感兴趣：'
- en: '[PRE93]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '`George` loves to call me during the night with his questions:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`George` 喜欢在夜间用他的问题打扰我：'
- en: '[PRE94]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Then there''s `Sandra`. She''s a different kind of bird, because she''s not
    a QA, but a copywriter:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是 `Sandra`。她是一种不同类型的鸟，因为她不是质量保证人员，而是一名文案：
- en: '[PRE95]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'I try not to bother her, unless it''s a major release:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我尽量不去打扰她，除非是重大发布：
- en: '[PRE96]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'OK, now I have a few problems:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，现在我有一些问题：
- en: First, my mind almost explodes trying to remember all those names. So might
    yours.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我试图记住所有这些名字时，我的大脑几乎要爆炸了。你的可能也是。
- en: Second, I also need to remember how to interact with each one. I'm the one doing
    all the checks before calling them.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，我还需要记住如何与每个人互动。在给他们打电话之前，所有的检查都是由我来做的。
- en: Third, notice how George tries to confirm everything with Kenny, and Kenny with
    George? Luckily, up until now, George is always watching a football game when
    Kenny calls him. And Kenny is asleep when George needs to confirm something with
    him. Otherwise, they would get stuck on the phone for eternity...
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三，注意乔治如何试图与肯尼确认每一件事，肯尼也总是与乔治确认？幸运的是，到目前为止，乔治总是在肯尼打电话时看足球比赛。而肯尼在乔治需要确认某事时却在睡觉。否则，他们可能会在电话上陷入永恒的僵局...
- en: Fourth, and what bothers me the most, is that Kenny plans to leave soon to open
    his own startup, ParrotPi. Imagine all the code we'll have to change now!
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四，最让我烦恼的是，`Kenny` 打算不久后离开去开创自己的创业公司，ParrotPi。想象一下我们现在得改多少代码！
- en: All I want to do is to check if everything is alright with my code. Someone
    else should do all this talking!
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我只想检查我的代码是否一切正常。其他人应该做所有这些谈话！
- en: The middleman
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中间人
- en: 'So, I decided that Michael should manage all those processes:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我决定迈克尔应该管理所有这些流程：
- en: '[PRE97]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Only he will know all the other *birds*:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 只有他知道所有其他的*鸟儿*：
- en: '[PRE98]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'I''ll remember only him, and he''ll do the rest:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我只会记住他，他会做剩下的：
- en: '[PRE99]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'I''ll also change my phone number, and make sure that everybody gets only Michael''s:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我也会更改我的电话号码，并确保每个人都只得到迈克尔的：
- en: '[PRE100]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Now, if somebody needs somebody else's opinion, they need to go through Michael
    first.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果有人需要别人的意见，他们需要先通过迈克尔。
- en: '[PRE101]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Flavors
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 风味
- en: There are two *flavors* to Mediator. We'll call them *strict* and *loose*. The
    strict version we've seen previously. We tell Mediator exactly what to do, and
    expect an answer from it.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 中介有两个*风味*。我们将它们称为*严格*和*宽松*。我们之前看到的是严格版本。我们告诉中介确切要做什么，并期望它给出回应。
- en: The *loose* version will expect us to notify Mediator of what happened, but
    not to expect an immediate answer. Instead, if he needs to notify us in return,
    he should call us instead.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '*宽松*版本将期望我们通知中介发生了什么，但不需要期望立即的回应。相反，如果他需要反过来通知我们，他应该调用我们。'
- en: Caveats
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注意事项
- en: Michael suddenly becomes ever so important. Everybody knows only him, and only
    he can manage their interactions. He may even become a *God Object*, all-knowing
    and almighty, which is an antipattern from [Chapter 9](part0215.html#6D18U0-6704093aa34748cfa77c54bdc1a20dc7),
    *Designed for Concurrency*. Even if he's so important, be sure to define what
    this Mediator should, and, even more importantly, what it shouldn't, do.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 迈克尔突然变得非常重要。每个人都只知道他，而且只有他可以管理他们的互动。他甚至可能成为一个*神对象*，无所不知且全能，这是来自[第9章](part0215.html#6D18U0-6704093aa34748cfa77c54bdc1a20dc7)的反模式，*设计用于并发*。即使他如此重要，也一定要定义这个中介应该做什么，更重要的是，它不应该做什么。
- en: Memento
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 备忘录
- en: Since Michael became a manager, it's been very hard to catch him if I have a
    question. And when I do ask him something, he just throws something and runs to
    the next meeting.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 自从迈克尔成为经理以来，如果我有问题很难找到他。而且当我确实问他问题时，他只是扔下东西就跑向下一个会议。
- en: Yesterday, I asked him what the next weapon we would introduce in our *Maronic*
    game should be. He told me it should be a Coconut Cannon, clear as day. But today,
    when I presented him with this feature, he chirped at me angrily! He said he told
    me to implement a Pineapple Launcher instead. I'm lucky he's just a canary still...
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 昨天，我问他我们将在我们的*Maronic*游戏中引入的下一件武器应该是什么。他告诉我应该是一个椰子大炮，一目了然。但今天，当我向他展示这个功能时，他愤怒地对我尖叫！他说他告诉我实现一个菠萝发射器。我很幸运他只是一个金丝雀...
- en: But it would be great if I could just record him, and when we have another meeting
    that goes awry because he's not paying full attention, I would just replay everything
    he said.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我能记录他，当我们在另一次会议中遇到麻烦，因为他没有全神贯注时，我就可以重新播放他说的所有内容。
- en: Remembrance
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记忆
- en: 'Summing up my problems first—Michael''s thoughts are his and his only:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 首先总结我的问题——迈克尔的想法是他的，而且只有他的：
- en: '[PRE102]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Moreover, they''re quite complex and scattered. I have no access to them, but
    only to their byproduct:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它们相当复杂且分散。我无法访问它们，只能访问它们的副产品：
- en: '[PRE103]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Even recording what he says is quite hard (because he doesn't return anything).
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 即使记录他说的内容也很困难（因为他不返回任何东西）。
- en: 'And even if I did record him, Michael can claim it''s what he said, not what
    he meant:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我真的记录了他，迈克尔也可以声称那是他说的话，而不是他的意思：
- en: Why did you bring me tea? I wanted coffee!
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 你为什么给我带茶？我想要咖啡！
- en: 'The solution may seem quite obvious. Let''s use an inner class, thought, that
    will capture this last thought:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案可能看起来很明显。让我们使用一个内部类，`thought`，来捕捉这个最后的想法：
- en: '[PRE104]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The only problem is that this code doesn't compile. It's because we're missing
    a new keyword, `inner`, to mark our class. If we omit this keyword, the class
    is called `Nested`, and is similar to the static nested class from Java.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的问题是这个代码无法编译。这是因为我们遗漏了一个新的关键字，`inner`，用来标记我们的类。如果我们省略这个关键字，类将被称为`Nested`，类似于Java中的静态嵌套类。
- en: 'Now we can *record* what Michael says at this moment:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以*记录*迈克尔此刻说的话：
- en: '[PRE105]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Let''s assume that Michael changes his mind at some point. We''ll add another
    function for that:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设迈克尔在某个时刻改变了主意。我们将添加另一个函数来处理这种情况：
- en: '[PRE106]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'We can always repeat the thought that we captured:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以反复思考我们捕捉到的想法：
- en: '[PRE107]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'This will print:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印：
- en: '[PRE108]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Let''s check what we''ve captured:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查我们捕捉到了什么：
- en: '[PRE109]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'This will print:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印：
- en: '[PRE110]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'We can even rewind Michael''s thoughts if he would allow it:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 如果迈克尔允许，我们甚至可以倒带他的想法：
- en: '[PRE111]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Note how here we use the `with` standard function to avoid repeating `previousThought`
    on each line.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里我们如何使用 `with` 标准函数来避免在每一行重复 `previousThought`。
- en: Visitor
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问者
- en: This design pattern is usually a close friend of the **Composite** design pattern
    that we discussed in [Chapter 3](part0080.html#2C9D00-6704093aa34748cfa77c54bdc1a20dc7), *Understanding
    Structural Patterns*. It can either extract data from a complex tree-like structure
    or add behavior to each node of the tree, much like the **Decorator** design pattern.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计模式通常是我们在 [第 3 章](part0080.html#2C9D00-6704093aa34748cfa77c54bdc1a20dc7)
    讨论的 **Composite** 设计模式的亲密朋友，*理解结构型模式*。它可以从复杂的树形结构中提取数据，或者向树的每个节点添加行为，就像 **Decorator**
    设计模式一样。
- en: So, my plan, being a lazy software architect, worked out quite well. Both my
    mail-sending system from **Builder** and my request-answering system from **Chain
    of Responsibility** worked quite well. But some developers still begin to suspect
    that I'm a bit of a fraud.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，作为一个懒惰的软件架构师，我的计划实施得相当顺利。我的邮件发送系统来自 **Builder**，我的请求回答系统来自 **Chain of Responsibility**，都运行得相当好。但一些开发者开始怀疑我有点儿骗子。
- en: To confuse them, I plan to produce weekly emails with links to all the latest
    buzzword articles. Of course, I don't plan to read them myself, just collect them
    from some popular technology sites.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 为了混淆他们，我计划每周发送包含所有最新流行词汇文章链接的电子邮件。当然，我并不打算亲自阅读它们，只是从一些流行的技术网站上收集它们。
- en: Writing a crawler
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写爬虫
- en: 'Let''s look at the following structure, which is very similar to what we had
    when discussing the **Iterator** design pattern:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下结构，这与我们讨论 **Iterator** 设计模式时非常相似：
- en: '[PRE112]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: The `Page` is a container for other `HtmlElements`, but not `HtmlElement` by
    itself. `Container` holds other containers, tables, links, and images. `Image`
    holds its link in the `src` attribute. `Link` has the `href` attribute instead.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '`Page` 是其他 `HtmlElements` 的容器，但本身不是 `HtmlElement`。`Container` 持有其他容器、表格、链接和图像。`Image`
    在 `src` 属性中持有其链接。`Link` 有 `href` 属性。'
- en: 'We start by creating a function that will receive the root of our object tree,
    a `Page` in this case, and return a list of all available links:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个函数，该函数将接收我们的对象树根，在这个例子中是一个 `Page`，并返回所有可用的链接列表：
- en: '[PRE113]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Using `run` allows us to control what we return from the block body. In this
    case, we would return the `links` we've gathered.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `run` 允许我们控制从块体返回的内容。在这种情况下，我们将返回我们收集到的 `links`。
- en: 'In Java, the suggested way to implement the **Visitor** design pattern is to
    add a method for each class that would accept our new functionality. We''ll do
    the same, but not for all classes. Instead, we''ll define this method only for
    container elements:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，实现 **Visitor** 设计模式的建议是为每个接受我们新功能的类添加一个方法。我们将这样做，但不是为所有类。相反，我们只为容器元素定义此方法：
- en: '[PRE114]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Our feature will need to hold a collection internally, and expose it only for
    read purposes. In Java, we would specify only the getter and no setter for that
    member. In Kotlin, we can specify the value without a backing field:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的功能需要内部持有集合，并且仅暴露读取目的。在 Java 中，我们会为该成员指定只读的 getter 而没有 setter。在 Kotlin 中，我们可以指定值而不需要后端字段：
- en: '[PRE115]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: We wish for our data structure to be immutable. That's the reason we're calling
    `toList()` on it.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的数据结构是不可变的。这就是我们调用 `toList()` 的原因。
- en: The functions that iterate over branches could be further simplified if we use
    the **Iterator** design pattern.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 **Iterator** 设计模式，迭代分支的函数可以进一步简化。
- en: 'For containers, we simply pass their elements further:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 对于容器，我们只需将它们的元素传递下去：
- en: '[PRE116]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Specifying the parent class as `sealed` helps the compiler further:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 将父类指定为 `sealed` 帮助编译器进一步优化：
- en: '[PRE117]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The most interesting logic is in the leaves:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 最有趣的逻辑在叶子节点：
- en: '[PRE118]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Note that in some cases, we don't want to do anything. That's specified by an
    empty block in our else: `else -> {}`.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在某些情况下，我们不想做任何事情。这通过 else 中的空块来指定：`else -> {}`。
- en: That's the first time we've seen **smart casts** in Kotlin.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一次在 Kotlin 中看到 **smart casts**。
- en: Notice that after we checked that the element is a `Link`, we gained type-safe
    access to its `href` attribute. That's because the compiler is doing the casts
    for us. The same holds true for the `Image` element as well.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在我们检查元素是 `Link` 之后，我们获得了对其 `href` 属性的类型安全访问。这是因为编译器为我们做了类型转换。同样，对于 `Image`
    元素也是如此。
- en: Although we achieved our goals, the usability of this pattern can be argued.
    As you can see, it's one of the more verbose elements, and introduces tight coupling
    between classes receiving additional behavior and Visitor itself.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们实现了我们的目标，但这个模式的可用性可以争论。正如你所看到的，它是一个更冗长的元素之一，并且引入了接收额外行为和访问者本身的紧密耦合。
- en: Template method
  id: totrans-431
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板方法
- en: 'Some lazy people make art out of their laziness. Take me for example. Here''s
    my daily schedule:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 一些懒惰的人将他们的懒惰变成了艺术。以我为例。以下是我的日常日程：
- en: '8:00–9:00: Arrive at the office'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '8:00–9:00: 到达办公室'
- en: '9:00–10:00: Drink coffee'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '9:00–10:00: 喝咖啡'
- en: '10:00–12:00: Attend some meetings or review code'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '10:00–12:00: 参加一些会议或审查代码'
- en: '12:00–13:00: Go out for lunch'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '12:00–13:00: 外出吃午餐'
- en: 13:00–16:00: Attend some meetings or review code
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '13:00–16:00: 参加一些会议或审查代码'
- en: '16:00: Sneak out home'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '16:00: 悄悄溜回家'
- en: As you can see, some of the parts of the schedule never change, and some do.
    At first, I thought I could *decorate* my changing schedule with that `setup`
    and `teardown` logic, which happens *before* and *after*. But then there's lunch,
    which is holy for architects and happens *in between*.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，日程表的一些部分永远不会改变，而有些则会改变。起初，我以为我可以用那个 `setup` 和 `teardown` 逻辑来“装饰”我变化的日程，这些逻辑发生在“之前”和“之后”。但午餐是神圣的，对于建筑师来说，它发生在“之间”。
- en: 'Java is pretty clear on what you should do. First, you create an abstract class.
    All methods that you want to implement by yourself you mark as private:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: Java 在你该做什么方面非常明确。首先，你创建一个抽象类。所有你想自己实现的方法你标记为私有：
- en: '[PRE119]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'For all methods that are changing from day to day, you define an abstract:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有每天都会变化的方法，你定义一个抽象类：
- en: '[PRE120]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'If you allow the changing of a method, but want to provide a default implementation,
    you leave it public:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你允许方法的变化，但想提供一个默认实现，你可以将其设置为公开：
- en: '[PRE121]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'And finally, you have a method that executes your algorithm. It''s final by
    default:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你有一个执行你算法的方法。默认情况下它是最终的：
- en: '[PRE122]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'If we now want to have a schedule for Monday, we simply implement the missing
    parts:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在想有一个周一的日程表，我们只需实现缺失的部分：
- en: '[PRE123]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: What does Kotlin add on top of that? What it usually does—conciseness. As we've
    seen previously, this can be achieved through functions.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 在这个基础上添加了什么？它通常做的事情——简洁。正如我们之前所看到的，这可以通过函数来实现。
- en: 'We have three *moving parts*—two mandatory activities (the software architect
    must do something before and after lunch) and one optional (the boss may stop
    him before he sneaks off home or not):'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三个“移动部件”——两个强制性活动（软件架构师必须在午餐前后做些事情）和一个可选的（老板可能在他在家之前或之后偷偷溜走之前阻止他）：
- en: '[PRE124]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'We''ll have a function that accepts up to three other functions as its arguments.
    The first two are mandatory, and the third may not be supplied at all, or assigned
    with `null` to explicitly state that we don''t want that function to happen:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将有一个函数，它接受最多三个其他函数作为其参数。前两个是强制性的，第三个可能根本不提供，或者用 `null` 分配，以明确表示我们不希望该函数发生：
- en: '[PRE125]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Inside this function, we'll have our algorithm. Invocations of `beforeLunch()`
    and `afterLunch()` should be clear; after all, those are the functions that are
    passed to us as arguments. The third one, bossHook, may be null, so we execute
    it only if it's not: `?.let { it() }`.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数内部，我们将有我们的算法。对 `beforeLunch()` 和 `afterLunch()` 的调用应该是清晰的；毕竟，这些是我们作为参数传递给我们的函数。第三个，bossHook，可能为
    null，所以我们只有在它不为 null 时才执行它：`?.let { it() }`。
- en: 'But what about the other functions, those we want to always implement by ourselves?
    Kotlin has a notion of local functions. Those are functions that reside in other
    functions:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 但其他函数怎么办，那些我们希望总是自己实现的函数呢？Kotlin 有一个局部函数的概念。这些函数位于其他函数中：
- en: '[PRE126]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Those are all valid ways to declare a local function. No matter how you define
    them, they're invoked in the same way.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是声明局部函数的有效方式。无论你如何定义它们，它们的调用方式都是相同的。
- en: 'We''re left with the same result, as you can see. Define the algorithm structure,
    but let others decide what to do at some points: that''s what the Template Method
    is all about.'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了相同的结果，正如你所看到的。定义算法结构，但让其他人决定在某些点的操作：这就是模板方法的核心。
- en: Observer
  id: totrans-460
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者
- en: Probably one of the highlights of this chapter, this design pattern will provide
    us with a bridge to the following chapters, dedicated to functional programming.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是本章的一个亮点，这个设计模式将为我们提供一个通往以下章节的桥梁，这些章节专门介绍函数式编程。
- en: So, what is Observer pattern about? You have one *publisher*, which may also
    be called a *subject*, that may have many *subscribers*, which may also be called *observers*.
    Each time something interesting happens with the publisher, it should update all
    of its subscribers.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，观察者模式是什么？你有一个*发布者*，它也可能被称为*主题*，它可能有多个*订阅者*，它们也可能被称为*观察者*。每当发布者发生有趣的事情时，它应该更新所有订阅者。
- en: This may look a lot like the Mediator design pattern, but there's a twist. Subscribers
    should be able to register or unregister themselves at runtime.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来很像中介者设计模式，但有一个转折。订阅者应该能够在运行时注册或注销自己。
- en: In the classical implementation, all subscribers/observers need to implement
    a certain interface in order for the publisher to be able to update them. But
    since Kotlin has higher-order functions, we can omit this part. The publisher
    will still have to provide means for observers to be able to subscribe and unsubscribe.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典实现中，所有订阅者/观察者都需要实现一个特定的接口，以便发布者能够更新它们。但是，由于 Kotlin 有高阶函数，我们可以省略这部分。发布者仍然需要提供观察者订阅和取消订阅的方式。
- en: Animal Choir
  id: totrans-465
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动物合唱团
- en: So, animals have decided to have a choir of their own. The cat was elected as
    the conductor of the choir (it didn't like to sing anyway).
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，动物们决定有自己的合唱团。猫被选为合唱团的指挥（它根本不喜欢唱歌）。
- en: 'The problem is that animals escaped from the Java world, and don''t have a
    common interface. Instead, each has a different method to make a sound:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于动物们逃离了 Java 世界，没有共同的接口。相反，每个动物都有自己的方法来发出声音：
- en: '[PRE127]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Luckily, the cat was elected not only because it was vocally challenged, but
    also because it was smart enough to follow this chapter until now. So it knows
    that in the Kotlin world, it can accept functions:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，猫不仅因为嗓音不佳而被选为指挥，而且因为它足够聪明，能够一直读到这一章。所以它知道在 Kotlin 世界中，它可以接受函数：
- en: '[PRE128]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Previously, we've seen how to pass a new function as an argument, as well as
    passing a literal function. But how do we pass a reference to a member function?
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们看到了如何传递一个新函数作为参数，以及如何传递一个字面函数。但是，我们如何传递成员函数的引用？
- en: 'That''s what member reference operator is for—`::`:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是成员引用操作符的作用——`::`：
- en: '[PRE129]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Now the cat needs to save all those subscribers somehow. Luckily, we can put
    them on a map. What would be the key? It could be the function itself:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，猫需要以某种方式保存所有这些订阅者。幸运的是，我们可以把它们放在一个映射中。那这个键会是什么？它可以是函数本身：
- en: '[PRE130]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: If all those `()->Unit` instances are making you dizzy, be sure to use `typealias`
    to give them more semantic meaning, such as subscriber.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有这些`()->Unit`实例让你感到头晕，请务必使用`typealias`来赋予它们更多的语义意义，例如订阅者。
- en: 'The bat decides to leave the choir. After all, no one is able to hear its beautiful
    singing anyway:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 蝙蝠决定离开合唱团。毕竟，没有人能听到它那美妙的歌声：
- en: '[PRE131]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'All `Bat` needs to do is to pass its subscriber function again:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 所有`Bat`需要做的就是再次传递其订阅者函数：
- en: '[PRE132]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'That''s the reason we used the map in the first place. Now `Cat` can call all
    its choir members and tell them to sing. Well, produce sounds:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们最初使用映射的原因。现在`Cat`可以调用所有合唱团成员并告诉他们唱歌。好吧，发出声音：
- en: '[PRE133]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'The rehearsal went well. But `Cat` feels very tired after doing all those loops.
    It would rather delegate the job to choir members. That''s not a problem at all:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 排练进行得很顺利。但`Cat`在做了所有这些循环之后感到非常累。它宁愿将工作委托给合唱团成员。这根本不是问题：
- en: '[PRE134]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Our subscribers all look like turkeys here:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的所有订阅者看起来都像火鸡：
- en: '[PRE135]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Actually, it is a bit of a problem. What if the `Cat` was to tell each animal
    what sound to make: high or low? We''ll have to change all subscribers again,
    and the `Cat` too.'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这有点问题。如果`Cat`要告诉每个动物发出什么声音：高音还是低音？我们不得不再次更改所有订阅者，以及`Cat`本身。
- en: 'While designing your publisher, pass single data classes with many properties,
    instead of sets of data classes or other types. That way, you''ll have to refactor
    your subscribers less, in case new properties are added:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计你的发布者时，传递具有许多属性的单个数据类，而不是数据类的集合或其他类型。这样，如果添加了新的属性，你就不必重构你的订阅者：
- en: '[PRE136]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Make sure that your messages are immutable. Otherwise, you may experience strange
    behavior!
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的消息是不可变的。否则，你可能会遇到奇怪的行为！
- en: What if you have sets of different messages you're sending from the same publisher?
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有来自同一发布者的不同消息集合，你会怎么办？
- en: 'Use smart casts:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 使用智能转换：
- en: '[PRE137]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Summary
  id: totrans-494
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: That was a long chapter. But we've also learned a lot. We finished covering
    all classical design patterns, including eleven behavioral ones. In Kotlin, functions
    can be passed to other functions, returned from functions, and assigned to variables.
    That's what the "functions as first-class citizens" concept is all about. If your
    class is all about behavior, it often makes sense to replace it with a function. Iterator
    is yet another `operator` in the language. Sealed classes help in making `when`
    statements exhaustive. The `run` extension function allows for controlling what
    will be returned from it. A lambda with a receiver allows more clear syntax in
    your DSLs. Another keyword, `lateinit`, tells the compiler to relax a bit in its
    null safety checks. Use with care! And finally, we covered how to reference an
    existing method with `::`.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一章很长的内容。但我们同时也学到了很多。我们已经完成了对所有经典设计模式的覆盖，包括十一个行为模式。在 Kotlin 中，函数可以被传递给其他函数，从函数中返回，以及分配给变量。这就是“函数作为一等公民”的概念所在。如果你的类主要是关于行为，那么用函数来替换它通常是有意义的。迭代器是语言中的另一个
    `operator`。密封类有助于使 `when` 语句变得详尽。`run` 扩展函数允许控制从它返回的内容。带有接收器的 lambda 在你的 DSLs
    中提供了更清晰的语法。另一个关键字 `lateinit` 告诉编译器在它的空安全检查上稍微放松一些。请谨慎使用！最后，我们介绍了如何使用 `::` 引用现有方法。
- en: In the next chapter, we'll move on from an object-oriented programming paradigm
    with its well-known design patterns to another paradigm—functional programming.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从具有众所周知设计模式的面向对象编程范式转向另一种范式——函数式编程。
