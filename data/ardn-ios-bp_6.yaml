- en: Chapter 6. Automatic Garage Door Opener
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 自动车库门开启器
- en: This project is about an emerging technology called **iBeacon** that is based
    on the Bluetooth BLE communication protocol. Basically, an iBeacon is a small
    device that continuously transmits a unique coded signal. An iOS device can detect
    iBeacon to determine whether it is more or less near an iBeacon and trigger actions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目是关于一种基于蓝牙BLE通信协议的新兴技术——iBeacon。基本上，iBeacon是一种持续传输独特编码信号的小型设备。iOS设备可以检测iBeacon，以确定其与iBeacon的距离是更近还是更远，并触发动作。
- en: Tip
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**iBeacon is an Apple technology**'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**iBeacon是苹果的技术**'
- en: iBeacon is a technology that was invented by Apple, and the protocol has not
    been disclosed (if you can find any information on the Internet, Google is your
    friend). So, to work with iBeacon devices, you need an iOS device and the API
    provided by Apple.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: iBeacon是由苹果公司发明的一项技术，该协议尚未公开（如果你在互联网上找到了任何信息，谷歌是你的朋友）。因此，要使用iBeacon设备，你需要一个iOS设备和苹果公司提供的API。
- en: There is another standard that is emerging and which can also work with Android
    devices—AltBeacon (for more information, visit [http://bit.ly/1KsXD17](http://bit.ly/1KsXD17)).
    The AltBeacon site has a lot of useful information for iOS too.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个正在出现的标准也可以与Android设备一起工作——AltBeacon（更多信息，请访问[http://bit.ly/1KsXD17](http://bit.ly/1KsXD17)）。AltBeacon网站也为iOS提供了大量有用的信息。
- en: We are going to use these technologies to open our garage door as soon as we
    get close enough to it. You may wonder what the difference is between this and
    a traditional garage remote control or the numerous remote control apps that are
    available for iOS devices. The main difference is that everything happens automatically
    (automagically?); you don't even need to touch your phone. Believe it or not,
    you don't even need the controller app running.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这些技术在我们靠近车库门时立即打开它。你可能想知道这与传统的车库遥控器或iOS设备上可用的众多遥控应用程序有什么区别。主要区别是这一切都是自动发生的（自动魔法？）；你甚至不需要触摸你的手机。信不信由你，你甚至不需要控制器应用程序运行。
- en: Tip
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Don''t have a garage?**'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**没有车库？**'
- en: This project can be used to open any kind of door, but you may need to adapt
    or change your lock to something that can be controlled by an electric signal.
    Alternatively, you can use this project to control internal/external lights. There's
    no chance of getting bored!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目可以用来打开任何类型的门，但你可能需要调整或更换你的锁，使其能够通过电信号控制。或者，你也可以使用这个项目来控制内部/外部灯光。绝对不会感到无聊！
- en: Let's get started by having a closer look at iBeacon.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过更仔细地了解iBeacon来开始吧。
- en: iBeacon – a technical overview
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: iBeacon – 技术概述
- en: An iBeacon is a small device that, leveraging the Bluetooth BLE, establishes
    a region around itself. Any iOS device that supports Bluetooth BLE can determine
    whether it has entered or exited the region and roughly estimate the distance
    from the iBeacon.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: iBeacon是一种小型设备，利用蓝牙BLE技术在其周围建立区域。任何支持蓝牙BLE的iOS设备都可以确定自己是否进入了该区域，并大致估算与iBeacon的距离。
- en: We can put an iBeacon close to each museum artwork and write an iOS application
    that shows artwork information as soon as a visitor gets close to it. This is
    a typical example of how iBeacon is used.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在每件博物馆艺术品附近放置一个iBeacon，并编写一个iOS应用程序，当参观者靠近时立即显示艺术品信息。这是一个典型的iBeacon应用示例。
- en: iBeacon is univocally identified by three values—a UUID (a 16 bytes universal
    identifier), major (2 bytes), and minor (2 bytes), which are constantly transmitted
    over the Bluetooth signal.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: iBeacon通过三个值唯一标识——UUID（一个16字节的通用标识符）、major（2字节）和minor（2字节），这些值通过蓝牙信号持续传输。
- en: Tip
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**All that you need to know** **about iBeacon**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**所有你需要了解的** **关于iBeacon的信息**'
- en: You can find all that you need to know at [https://developer.apple.com/ibeacon/](https://developer.apple.com/ibeacon/)
    and [https://developer.apple.com/ibeacon/Getting-Started-with-iBeacon.pdf](https://developer.apple.com/ibeacon/Getting-Started-with-iBeacon.pdf).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://developer.apple.com/ibeacon/](https://developer.apple.com/ibeacon/)和[https://developer.apple.com/ibeacon/Getting-Started-with-iBeacon.pdf](https://developer.apple.com/ibeacon/Getting-Started-with-iBeacon.pdf)找到所有你需要了解的信息。
- en: Referring to the next diagram, you can see that there is a region around the
    iBeacon (the iBeacon region). The iOS application that registers to this region
    (with the UUID, major, and minor of the iBeacon) receives an "entering" notification
    when the iOS device crosses this region's border and enters it, and an "exiting"
    notification when the iOS device crosses the region's border and exits it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 参考下图的下一个图，你可以看到iBeacon周围有一个区域（即iBeacon区域）。当iOS设备穿过这个区域的边界并进入时，注册了这个区域的iOS应用程序（使用iBeacon的UUID、major和minor）会收到一个“进入”通知；当iOS设备穿过区域的边界并退出时，会收到一个“退出”通知。
- en: 'We will discuss the details of this in the following sections:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下章节中详细讨论这个问题：
- en: '![iBeacon – a technical overview](img/image00213.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![iBeacon – 技术概述](img/image00213.jpeg)'
- en: In open air, the iBeacon region is about 30 meters wide, but this size widely
    depends on the hardware design, configuration, obstacles, and the way of installation.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在开阔空间中，iBeacon区域大约有30米宽，但这个大小很大程度上取决于硬件设计、配置、障碍物以及安装方式。
- en: When inside the region, an iOS device can continuously monitor the distance
    from the iBeacon device. This distance is returned as Far, Near, or Immediate.
    Apple doesn't declare the actual size of these distances, most likely because
    they are really influenced by the iBeacon's transmitting power, obstacles between
    the iBeacon and the iOS device, the iOS device orientation, and other factors.
    Anyway, this information can be used to change the application's behavior with
    the distance from iBeacon.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当在区域内时，iOS设备可以持续监控与iBeacon设备的距离。这个距离以远、近或立即返回。苹果没有声明这些距离的实际大小，很可能是由于这些距离实际上受到iBeacon的发射功率、iBeacon与iOS设备之间的障碍物、iOS设备的朝向以及其他因素的影响。无论如何，这些信息可以用来根据与iBeacon的距离改变应用程序的行为。
- en: Tip
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**iBeacon distance calculation**'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**iBeacon距离计算**'
- en: An iOS device can find out the signal strength of the iBeacon. It can calculate
    the distance from the iBeacon by using a formula that describes the signal attenuation
    with distance. Unfortunately, since an iBeacon signal has a lot of fluctuations
    and its propagation is influenced by a lot of factors, the formula gives a very
    poor estimation of the distance. Probabilistic techniques have to be used to get
    the estimation of the distance to use this value for practical applications. We
    cannot cover these techniques in this book.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: iOS设备可以检测到iBeacon的信号强度。它可以通过一个描述距离衰减的公式来计算与iBeacon的距离。不幸的是，由于iBeacon信号有很多波动，并且其传播受到许多因素的影响，这个公式对距离的估计非常不准确。为了在实际应用中使用这个值，必须使用概率技术来获取距离的估计值。我们无法在本书中涵盖这些技术。
- en: An interesting feature of how the iBeacon notifications are handled by the iOS
    is that even if the application is not running, the entering and exiting notifications
    are received and they start the application. To save the iOS device power, the
    application is started just for a few seconds (for about 3 seconds) and then paused.
    Then, the application has to complete every operation in this short interval.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: iOS处理iBeacon通知的一个有趣特性是，即使应用程序没有运行，进入和退出通知也会被接收，并且它们会启动应用程序。为了节省iOS设备的电量，应用程序只运行几秒钟（大约3秒钟）然后暂停。然后，应用程序必须在这个短暂的时间间隔内完成每一个操作。
- en: I have to point out that usually, an iOS app receives an entering notification
    almost as soon as it crosses the iBeacon region. Conversely, the exiting notification
    may be received even a few minutes after the region border is crossed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须指出，通常情况下，iOS应用在穿过iBeacon区域时几乎立即就会收到进入通知。相反，退出通知可能在穿过区域边界后几分钟才会收到。
- en: The garage door opener requirements and design constraints
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 汽车库门开启器的要求和设计限制
- en: Knowing the capabilities of the iBeacon, it's not hard to imagine how a garage
    door opener may work. The iBeacon is installed just behind the garage door. An
    Arduino with the BLE board listens for commands from the iOS device and controls
    the garage door opener. An iOS app sends an "Open" command when entering into
    the iBeacon region and a "Close" command when exiting the iBeacon region. Very
    simple, isn't it?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 了解iBeacon的能力后，想象一个车库门开启器的工作方式并不困难。iBeacon安装在车库门后面。一个带有BLE板的Arduino监听来自iOS设备的命令并控制车库门开启器。iOS应用程序在进入iBeacon区域时发送“打开”命令，在退出iBeacon区域时发送“关闭”命令。非常简单，不是吗？
- en: Unfortunately, we have to face the potentially long delay when receiving an
    exiting notification. When driving a car, you can cover a great distance traveling
    away from your garage in a few minutes; an iOS device cannot connect to the Arduino
    in such a long time.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们必须面对接收退出通知时可能出现的长时间延迟。当你开车时，你可以在几分钟内覆盖很大的距离，远离你的车库；iOS设备无法在这么长时间内连接到Arduino。
- en: Moreover, after taking a look at the next picture, you may realize that the
    iBeacon region may also cover only a part of the house. We obviously don't want
    that walking around the house with the iOS device in our pockets, the garage door
    would open and close randomly.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在查看下一张图片后，你可能意识到iBeacon区域也可能只覆盖房子的一部分。显然，我们不希望带着iOS设备在口袋里在房子周围走动时，车库门会随机开启和关闭。
- en: '![The garage door opener requirements and design constraints](img/image00214.jpeg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![车库门开启器的要求和设计限制](img/image00214.jpeg)'
- en: A simple solution could be adding as many iBeacons as needed across the house,
    all with the same UUID, major, and minor, in order to extend the iBeacon region.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的解决方案是在房子的各个地方添加所需的iBeacon，所有这些iBeacon都具有相同的UUID、major和minor，以扩展iBeacon区域。
- en: 'However, this solution will be too expensive. We are going to use another power
    feature of the iOS to overcome these two issues—geofencing:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个解决方案将会太昂贵。我们将利用iOS的另一个电源特性来克服这两个问题——地理围栏：
- en: '![The garage door opener requirements and design constraints](img/image00215.jpeg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![车库门开启器的要求和设计限制](img/image00215.jpeg)'
- en: We can register a geofencing region (using the latitude and longitude of the
    center and the radius) that covers our entire house. On crossing the geofencing
    region's border, we get a notification (or even better, two notifications—one
    when entering the region and the other when exiting).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以注册一个地理围栏区域（使用中心点的纬度和经度以及半径），覆盖我们整个房子。一旦穿过地理围栏区域的边界，我们会收到通知（或者更好的是，两个通知——一个在进入区域时，另一个在离开区域时）。
- en: You may wonder why we don't simply use only a geofencing region to open the
    garage door. The reason behind not doing this is that the geofencing notifications
    are not very precise. They may have a very long delay and may not work in all
    areas. By combining the two technologies, we get exactly what we want to achieve.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么我们不简单地只使用地理围栏区域来开启车库门。不这样做的原因是地理围栏通知并不非常精确。它们可能有很大的延迟，并且可能不在所有区域工作。通过结合这两种技术，我们得到了我们想要实现的确切结果。
- en: 'We eventually overcame all the design challenges that involve tracking the
    entering of the device in the iBeacon region and its exiting from the geofencing
    region. This is how the automatic garage door opener works:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终克服了所有涉及在iBeacon区域内跟踪设备进入和从地理围栏区域退出的设计挑战。这就是自动车库门开启器的工作原理：
- en: Let's assume that we are outside both the regions. When we cross the geofencing
    region, nothing happens, because the app recognizes only the exiting notification.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们假设我们同时位于两个区域之外。当我们穿过地理围栏区域时，不会发生任何事情，因为应用程序只识别退出通知。
- en: As soon as we cross the iBeacon region a few meters away from the garage, the
    iOS device gets a notification, and it sends an opening command to the Arduino
    board, which controls the door, thereby opening the door.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们穿过离车库几米远的iBeacon区域，iOS设备就会收到通知，并发送一个开启命令到控制门的Arduino板，从而打开门。
- en: The door is automatically closed after a short time. This allows us to park
    the car inside the garage.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 门会在短时间内自动关闭。这允许我们将车停放在车库内。
- en: From now on, the action of crossing the iBeacon region is ignored. Then, in
    case we cross the iBeacon region while moving around the house, the garage will
    not be opened.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从现在起，穿过iBeacon区域的行为将被忽略。然后，如果我们移动到房子周围时穿过iBeacon区域，车库将不会开启。
- en: When we leave, we eventually cross the geofencing region. This event again enables
    the receiving of the iBeacon entering notification. We are in the same state that
    was described in step 1.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们离开时，我们最终会穿过地理围栏区域。这个事件再次启用了接收iBeacon进入通知。我们处于与步骤1中描述的相同状态。
- en: 'We can describe the behavior of the app by using the following state diagram
    (strictly speaking, it''s a Mealy State Machine; for more information, visit [http://bit.ly/1hmZs3V](http://bit.ly/1hmZs3V)):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下状态图来描述应用程序的行为（严格来说，它是一个Mealy状态机；更多信息，请访问[http://bit.ly/1hmZs3V](http://bit.ly/1hmZs3V)）：
- en: '![The garage door opener requirements and design constraints](img/image00216.jpeg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![车库门开启器的要求和设计限制](img/image00216.jpeg)'
- en: We obviously don't want anyone else to open our garage. So, each authorized
    user must identify themselves by using a PIN (personal identification number).
    Assigning a new PIN, you allow others to get access to your garage. You can revoke
    access just by removing the PIN from the authorization list.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们显然不希望其他人打开我们的车库。因此，每个授权用户必须通过使用PIN（个人识别号码）来识别自己。分配新的PIN，您允许其他人获取对车库的访问权限。您可以通过从授权列表中移除PIN来撤销访问权限。
- en: Then, the app has to manage the PINs, and we need a master PIN, which is wired
    into the Arduino code. Only the person who knows the master PIN is authorized
    to manage PINs.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，应用程序必须管理PIN，我们需要一个主PIN，它被连接到Arduino代码中。只有知道主PIN的人才有权管理PIN。
- en: Tip
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**A security warning!**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全警告！**'
- en: Even if the iOS app requires a PIN in order to open the garage door, the app
    is not completely secure since it doesn't provide any encryption mechanism. Anyone
    can access the PIN by using a Bluetooth protocol sniffer. It's not so easy, but
    it's possible. You have been warned! Making the communication secure could be
    a good chance to learn more about encryption and how to implement encryption using
    the little memory and little processing power available on Arduino.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 即使iOS应用需要PIN才能打开车库门，该应用也不是完全安全的，因为它不提供任何加密机制。任何人都可以通过使用蓝牙协议嗅探器来访问PIN。这并不容易，但却是可能的。我们已经警告过您！使通信安全可能是学习更多关于加密以及如何在Arduino上使用有限的内存和处理器能力实现加密的好机会。
- en: Hardware
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 硬件
- en: The main hardware component that we need is the iBeacon. We have used the one
    that is shown at [http://redbear.net](http://redbear.net). Many products are available
    on the market at almost any price. When choosing an iBeacon, make sure that it
    is compatible with the iBeacon Apple protocol, since there are products that are
    not.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的最主要硬件组件是iBeacon。我们使用的是[http://redbear.net](http://redbear.net)上展示的那个。市场上几乎任何价格都有很多产品。在选择iBeacon时，请确保它与iBeacon
    Apple协议兼容，因为有些产品并不兼容。
- en: Tip
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**An iOS device as an iBeacon**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**作为iBeacon的iOS设备**'
- en: If you have two iOS devices, you can use one of them to act as an iBeacon that
    running via one of the apps that are available on the iTunes store. I have published
    my own app for this purpose, which can be found at [http://apple.co/1hmZt80](http://apple.co/1hmZt80).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有两个iOS设备，您可以使用其中一个作为通过iTunes商店中可用的应用程序运行的iBeacon。我已经为这个目的发布了自己的应用程序，可以在[http://apple.co/1hmZt80](http://apple.co/1hmZt80)找到。
- en: Depending on the iBeacon enclosure, it can be mounted inside or outside the
    garage. It is better if it is placed at a higher position. Usually, the battery
    that powers the iBeacon should last for at least one year. Consider battery replacement
    anyway while positioning it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 根据iBeacon外壳，它可以安装在车库内部或外部。如果放置在较高的位置会更好。通常，为iBeacon供电的电池应该至少可以使用一年。定位时，无论如何都要考虑更换电池。
- en: Additional electronic components
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附加电子元件
- en: 'In this project, we will need the following additional components:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们需要以下附加元件：
- en: 'A BJT transistor: P2N2222 (see the details in the text)'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个P2N2222 BJT晶体管（详见文本）
- en: An NMOSFET transistor BS170 (see the details in the text)
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个BS170 NMOSFET晶体管（详见文本）
- en: A 10K resistor (see the details in the text)
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个10K欧姆电阻（详见文本）
- en: A 1.5K resistor (see the details in the text)
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个1.5K欧姆电阻（详见文本）
- en: A diode 1N4001 (see the details in the text)
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个1N4001二极管（详见文本）
- en: 'A relay: coil voltage 5 and contact current max 1A (see the details in the
    text)'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个继电器：线圈电压5V，接触电流最大1A（详见文本）
- en: Electronic circuit
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 电子电路
- en: 'The following picture shows the electric diagram of the electronic circuit
    that we need for the project:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片显示了项目所需的电子电路的电原理图：
- en: '![Electronic circuit](img/image00217.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![电子电路](img/image00217.jpeg)'
- en: Usually, the relay current is about 40 mA, which exceeds the maximum amount
    of current that Arduino can provide. There are relays that draw less current,
    but to avoid burning the Arduino, we can use a transistor to power the relay.
    When the relay is turned off, the energy stored in the coil is discharged against
    the transistor as reverse current, and this can damage the transistor. The diode
    (a flyback diode) shorts this current, protecting the transistor from damage.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，继电器电流约为40 mA，这超过了Arduino可以提供的最大电流。有一些继电器消耗的电流更少，但为了避免烧毁Arduino，我们可以使用晶体管来供电继电器。当继电器关闭时，线圈中储存的能量会以反向电流的形式放电到晶体管上，这可能会损坏晶体管。二极管（反向恢复二极管）短路这个电流，保护晶体管免受损坏。
- en: 'The following diagram shows how to mount the circuit on a breadboard:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示展示了如何在面包板上安装电路：
- en: '![Electronic circuit](img/image00218.jpeg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![电子电路](img/image00218.jpeg)'
- en: 'A relay is an electromechanical device that drains current, and it is subject
    to faults. So, you can use a more reliable circuit by using N-MOSFET. This alternative
    circuit is shown in the following diagram:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 电磁继电器是一种消耗电流的机电设备，容易发生故障。因此，你可以通过使用N-MOSFET来使用更可靠的电路。这个替代电路在下面的图中展示：
- en: '![Electronic circuit](img/image00219.jpeg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![电子电路](img/image00219.jpeg)'
- en: 'The following diagram shows how to mount the circuit on a breadboard:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示展示了如何在面包板上安装电路：
- en: '![Electronic circuit](img/image00220.jpeg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![电子电路](img/image00220.jpeg)'
- en: The R1 resistor pulls down the gate of the MOSFET. So, it turns off when the
    driving pin (7) is LOW and the pin is floating like that during the powering on
    phase of Arduino.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: R1电阻下拉MOSFET的栅极。因此，当驱动引脚（7）为低电平且引脚在Arduino的供电阶段浮动时，它会关闭。
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may need to adjust the value of R1 in the range of 1K to 1M in order to
    ensure that the MOSFET doesn't turn on when not expected to.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要将R1的值调整到1K到1M的范围内，以确保当不需要时MOSFET不会打开。
- en: Tip
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**RFduino instead of Arduino**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用RFduino而不是Arduino**'
- en: For this project, we can use RFduino instead of Arduino (for more information,
    visit [http://www.rfduino.com](http://www.rfduino.com)). It is compatible with
    Arduino, and also includes the Bluetooth device and the related software stack.
    Moreover, it can act as an iBeacon at the same time. One device could cover all
    the hardware requirements for the project. It doesn't have the EEPROM that we
    are going to use to store PINs, but we can store them in flash. The original version
    of this project was on RFduino and was a commercial product. For this book, I
    chose to work with Arduino to avoid buying another piece of hardware and because
    RFduino requires a more complex code to use Bluetooth for receiving commands and
    acting as an iBeacon at the same time. You can try to build the project on RFduino
    yourself. This could be a good opportunity to learn more. Check out RFduino. It's
    an amazing product!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们可以使用RFduino而不是Arduino（更多信息，请访问[http://www.rfduino.com](http://www.rfduino.com)）。它与Arduino兼容，还包括蓝牙设备和相关的软件栈。此外，它还可以同时充当iBeacon。一个设备可以满足项目的所有硬件需求。它没有我们将用来存储引脚的EEPROM，但我们可以将它们存储在闪存中。这个项目的原始版本是在RFduino上，并且是一个商业产品。对于这本书，我选择使用Arduino来避免购买另一件硬件，因为RFduino需要更复杂的代码来同时使用蓝牙接收命令和充当iBeacon。你可以尝试自己在这个RFduino上构建项目。这可以是一个学习更多的好机会。查看RFduino。它是一个惊人的产品！
- en: Arduino code
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Arduino代码
- en: The full code of this project can be downloaded from [https://www.packtpub.com/books/content/support](https://www.packtpub.com/books/content/support).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目的完整代码可以从[https://www.packtpub.com/books/content/support](https://www.packtpub.com/books/content/support)下载。
- en: For a better understanding of the explanations in the next paragraphs, open
    the downloaded code while reading them.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解下一段落的解释，请在阅读时打开下载的代码。
- en: In this project, we are going to use EEPROM to store PINS. In fact, this memory
    doesn't lose its content when it's not powered.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将使用EEPROM来存储引脚。实际上，当没有供电时，这种内存不会丢失其内容。
- en: To store a PIN, we use the first character to indicate whether it is used or
    not and the last five characters to store the actual PIN (which is exactly five
    characters long). PINs are stored sequentially in EEPROM, starting from address
    0.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要存储一个引脚，我们使用第一个字符来表示是否使用，并使用最后五个字符来存储实际的引脚（正好是五个字符长）。引脚在EEPROM中按顺序存储，从地址0开始。
- en: Setup code
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置代码
- en: Please refer to the downloaded code. Since the setup code is quite simple, it
    doesn't require a detailed explanation.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考下载的代码。由于设置代码相当简单，不需要详细的解释。
- en: 'The setup code is not much different from the setup code of other projects.
    Let''s take a look at the EEPROM initialization instead:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 设置代码与其他项目的设置代码没有太大区别。让我们来看看EEPROM初始化的部分：
- en: '[PRE0]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `for` loop initializes the EEPROM locations that are used to initialize
    PINs to 0\. This loop has to be executed only the first time the code is executed,
    otherwise, it clears the stored PINS. In the *Testing and tuning* section, we
    will provide more details on this.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环初始化用于初始化引脚的EEPROM位置为0。这个循环只需要在代码第一次执行时执行，否则它会清除存储的引脚。在*测试和调整*部分，我们将提供更多细节。'
- en: The last few lines write the master PIN from location 1 (the master PIN is 12345
    in the example). The location 0 is set to 1 to indicate that the next five locations
    are used to store a PIN.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后几行将主PIN从位置1（示例中的主PIN为12345）写入。位置0设置为1，以指示下一个五个位置用于存储PIN。
- en: Main program
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主程序
- en: The loop function is very easy. It only checks whether the door has been opened,
    and after this, `CLOSING_DOOR_INTERVAL` closes it by calling the `pulseOutput`
    function that pulses the relay for 300 ms.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 循环函数非常简单。它只检查门是否已经打开，然后通过调用`pulseOutput`函数（该函数使继电器脉冲300毫秒）来关闭`CLOSING_DOOR_INTERVAL`。
- en: The rest of the Arduino code is used to react to the messages that are received
    in the `rxCallback` function.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino代码的其余部分用于在`rxCallback`函数中接收到的消息上做出反应。
- en: Each message is made up of a PIN (five characters) followed by a few other characters.
    The PIN is checked, and if it's not recognized, the message is rejected.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 每条消息由一个PIN（五个字符）和一些其他字符组成。该PIN将被检查，如果未识别，则消息将被拒绝。
- en: 'The main message is used to open the garage door: <PIN>O=1, where <PIN> is
    the 5 characters long PIN assigned to the user who is opening the door. When it''s
    received, it pulses the relay and opens the door.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 主要消息用于打开车库门：<PIN>O=1，其中<PIN>是分配给开门用户的5个字符长的PIN。当它被接收时，它会触发继电器并打开门。
- en: 'All the other messages, which are as follows, are related to PIN management:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下所有其他消息都与PIN管理相关：
- en: '`P`, when the iOS device requests the list of the current PINs stored in the
    Arduino EEPROM.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`P`，当iOS设备请求当前存储在Arduino EEPROM中的PIN列表。'
- en: '`A`, when the iOS device needs to add a new PIN. The next 5 bytes after the
    command are the actual PIN.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`A`，当iOS设备需要添加新的PIN时。命令后的下一个5个字节是实际的PIN。'
- en: '`E`, when the iOS device needs to update an existing PIN. The first byte after
    the command is the index of the PIN that needs to be edited, which is followed
    by 5 bytes of the new PIN.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`E`，当iOS设备需要更新现有的PIN时。命令后的第一个字节是需要编辑的PIN的索引，其后是5个字节的新PIN。'
- en: '`D`, when the iOS device needs to delete an existing PIN. The first byte after
    the command is the index of the PIN that needs to be deleted.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`D`，当iOS设备需要删除现有的PIN时。命令后的第一个字节是需要删除的PIN的索引。'
- en: The functions, which implement each command, don't require much explanation.
    Note that the master PIN (PIN at the location 0 in EEPROM) is never transferred
    to the iOS application. To change the master PIN, it has to be changed directly
    in the code. The `printPins` function that dumps all the stored PINs can help
    you understand how the functions work. Comment out the calls that are already
    in the code.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 实现每个命令的功能不需要太多解释。请注意，主PIN（EEPROM中的位置0处的PIN）永远不会传输到iOS应用程序。要更改主PIN，必须直接在代码中更改。`printPins`函数（将所有存储的PIN输出）可以帮助你理解函数的工作方式。注释掉代码中已经存在的调用。
- en: iOS code
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: iOS代码
- en: In this chapter, we are going to look at the iOS application that monitors the
    iBeacon region and the geofencing region and sends a command to open the door.
    The same application manages the PINs that can be assigned to relatives, guests,
    and friends in order to open your garage.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将查看iOS应用程序，该应用程序监控iBeacon区域和地理围栏区域，并发送命令打开门。该应用程序还管理可以分配给亲属、访客和朋友的PIN，以便打开你的车库。
- en: The application can also be used to open the garage door manually like a traditional
    remote control.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序还可以像传统遥控器一样手动打开车库门。
- en: The full code of this project can be downloaded from [https://www.packtpub.com/books/content/support](https://www.packtpub.com/books/content/support).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的完整代码可以从[https://www.packtpub.com/books/content/support](https://www.packtpub.com/books/content/support)下载。
- en: To understand better the explanations in the next paragraphs, open the downloaded
    code while reading.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解下一段落的解释，请在阅读时打开下载的代码。
- en: Creating the Xcode project
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建Xcode项目
- en: 'We will create a new project as we have done in the previous chapters. The
    following are the steps that you need to perform:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的项目，就像在前几章中做的那样。以下是你需要执行的步骤：
- en: 'The following are the parameters for the new project:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是新项目的参数：
- en: '**Project Type**: Tabbed application'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目类型**：标签应用'
- en: '**Product Name**: GarageiBeacon'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**产品名称**：GarageiBeacon'
- en: '**Language**: Objective-C'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语言**：Objective-C'
- en: '**Devices**: Universal'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设备**：通用'
- en: 'We have to set a capability for this project, as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须为此项目设置一个能力，如下所示：
- en: Select the project in the left pane of Xcode.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Xcode的左侧面板中选择项目。
- en: Select **Capabilities** in the right pane.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右侧面板中选择 **能力**。
- en: Turn on the **Background Modes** option and select **Location updates** (see
    the following screenshot):![Creating the Xcode project](img/image00221.jpeg)
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **Background Modes** 选项并选择 **位置更新**（见以下截图）：![创建Xcode项目](img/image00221.jpeg)
- en: 'Once more, since the structure of this project is very close to the Pet Door
    Locker, we can reuse a part of the user interface and code by following these
    steps (for more details, go back to the iOS guided rover project in [Chapter 4](part0033.xhtml#aid-VF2I1
    "Chapter 4. iOS Guided Rover"), *iOS Guided Rover*, where we did almost the same
    thing as this):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个项目的结构非常接近宠物门锁，我们可以通过以下步骤重用一部分用户界面和代码（更多详情，请回到第4章中关于iOS引导漫游器的项目[part0033.xhtml#aid-VF2I1
    "第4章. iOS引导漫游器"]，*iOS引导漫游器*，在那里我们几乎做了与这次相同的事情）：
- en: Select **FirstViewController.h** and **FirstViewController.m**, right-click
    on them, click on **Delete**, and select **Move to Trash**.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **FirstViewController.h** 和 **FirstViewController.m**，右键点击它们，点击 **删除**，然后选择
    **移动到废纸篓**。
- en: Using the same procedure, delete **SecondViewController** and **Main.storyboard**.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相同的程序，删除 **SecondViewController** 和 **Main.storyboard**。
- en: Open the **PetDoorLocker** project in Xcode.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Xcode中打开 **PetDoorLocker** 项目。
- en: 'Select the following files and drag and drop them to this project:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择以下文件并将它们拖放到此项目中：
- en: '**BLEConnectionViewController.h**'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BLEConnectionViewController.h**'
- en: '**BLEConnectionViewController.m**'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BLEConnectionViewController.m**'
- en: '**Main.storyboard**'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Main.storyboard**'
- en: Ensure that **Copy items if needed** is selected and then click on **Finish**.
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保已选择 **如果需要则复制项目**，然后点击 **完成**。
- en: Copy the icon that was used for the BLEConnectionViewController view controller.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制用于BLEConnectionViewController视图控制器的图标。
- en: Create a new View Controller class called `GarageViewController`.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的视图控制器类，名为 `GarageViewController`。
- en: Open the **Main.storyboard** and locate the main View Controller.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **Main.storyboard** 并定位主视图控制器。
- en: Delete all the graphical components.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除所有图形组件。
- en: Open the **Identity Inspector** and change the **Class** to **GarageViewController**.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **身份检查器**并将 **类** 更改为 **GarageViewController**。
- en: In order to make location properly ask for authorization, we need to add a new
    file. Do this by navigating to **File** | **New** | **File…** and then select
    **iOS - Resource** and **Strings File**. Click on **Next** and enter the name
    of the file, `InfoPlist`. Finally, click on **Create**.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使位置请求授权正确，我们需要添加一个新文件。通过导航到 **文件** | **新建** | **文件…** 然后选择 **iOS - 资源** 和
    **字符串文件**。点击 **下一步**并输入文件名，`InfoPlist`。最后，点击 **创建**。
- en: 'Open the newly created file and enter the following line:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开新创建的文件并输入以下行：
- en: '[PRE1]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, we are ready to create the new application!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已准备好创建新的应用程序！
- en: Designing the user interface for BLEConnectionViewController
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为BLEConnectionViewController设计用户界面
- en: We have to add many components to this view controller to add our personal PIN
    and information related to the geofencing region.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须向这个视图控制器添加许多组件以添加我们的个人PIN和与地理围栏区域相关的信息。
- en: 'By now, you should be a master in adding UIKit components and the related Layout
    Constraints. So, we won''t spend much time on this subject. Your final result
    should look similar to the one in the following picture. Anyway, you can always
    refer to the downloaded code, in case you need to:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该已经精通添加UIKit组件及其相关的布局约束。因此，我们不会在这个主题上花费太多时间。您的最终结果应该类似于以下图片。无论如何，如果您需要，您始终可以参考下载的代码：
- en: '![Designing the user interface for BLEConnectionViewController](img/image00222.jpeg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![为BLEConnectionViewController设计用户界面](img/image00222.jpeg)'
- en: We also need to set the delegate outlet of the **PIN** text field to the BLEConnectionViewController
    in order to know when it changes. You can do this by using the Connection Inspector.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将 **PIN** 文本字段的代理出口设置为 BLEConnectionViewController，以便知道何时发生变化。您可以通过使用连接检查器来完成此操作。
- en: 'For the PIN text field, we need to mask the values that will be entered. To
    do this, perform the following steps:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于PIN文本字段，我们需要屏蔽将要输入的值。为此，请执行以下步骤：
- en: Select the field.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择字段。
- en: Open the Attributes Inspector.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开属性检查器。
- en: Select the **Secure Text Entry** checkbox.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **Secure Text Entry** 复选框。
- en: 'Linking the new components to the code, you should end up with the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 将新组件链接到代码，您应该得到以下结果：
- en: '[PRE2]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The **Set House Position** button will be used to set the center of the geofencing
    region around the house, and the **House Region Size** segment will be used to
    set the radius of the geofencing region itself.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**设置房屋位置**按钮将用于设置围绕房屋的地理围栏区域中心，而**房屋区域大小**段将用于设置地理围栏区域的半径。'
- en: 'The button is connected to the method, as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮连接到以下方法：
- en: '[PRE3]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The segment is connected to the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 该段连接到以下内容：
- en: '[PRE4]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Designing the user interface for GarageViewController
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计 GarageViewController 的用户界面
- en: This view controller is the main view controller of the application, and it
    should contain the button to manually open/close the garage door, just in case!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图控制器是应用程序的主要视图控制器，它应该包含一个手动打开/关闭车库门的按钮，以防万一！
- en: Since this is a learning project, we added some components to give the user
    a lot more information about their position with respect to the iBeacon and geofencing
    regions.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个学习项目，我们添加了一些组件，以便用户能够获得更多关于其相对于 iBeacon 和地理围栏区域位置的信息。
- en: 'The GUI should look like the following screenshot:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: GUI 应该看起来像以下截图：
- en: '![Designing the user interface for GarageViewController](img/image00223.jpeg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![设计 GarageViewController 的用户界面](img/image00223.jpeg)'
- en: 'This time, the two buttons have a background (you can copy it from the downloaded
    code; it is named `buttonBackground.png`). To add it, select the button, open
    the **Attribute Inspector**, and select **buttonBackground.png** for the **Background**
    (see the following screenshot):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，两个按钮都有一个背景（你可以从下载的代码中复制它；它被命名为 `buttonBackground.png`）。要添加它，选择按钮，打开**属性检查器**，然后为**背景**选择**buttonBackground.png**（见以下截图）：
- en: '![Designing the user interface for GarageViewController](img/image00224.jpeg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![设计 GarageViewController 的用户界面](img/image00224.jpeg)'
- en: Don't forget to change the **Text Color** to white.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记将**文本颜色**更改为白色。
- en: You can also copy the images for the three LEDs (`blueLED.png` and `grayLED.png`)
    from the downloaded project.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以从下载的项目中复制三个 LED 图像（`blueLED.png` 和 `grayLED.png`）。
- en: 'Once you have linked the GUI components to the code, you should end up with
    the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将 GUI 组件链接到代码，你应该得到以下结果：
- en: '[PRE5]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Moreover, the two buttons are linked to the two methods respectively, as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，两个按钮分别链接到两个方法，如下所示：
- en: '[PRE6]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'and:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 和：
- en: '[PRE7]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Designing the user interface for PinsViewController
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计 PinsViewController 的用户界面
- en: We need another view controller to manage the PINs. Create and link it to the
    main view controller like we did in the previous projects and embed it into a
    Navigation Controller. To do this, select the new view controller and navigate
    to **Editor** | **Embed In Navigation Controller**. This creates a Navigation
    Bar, where we can drop a button for adding the PINs (see the circled area in the
    following screenshot).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要另一个视图控制器来管理 PIN。创建并链接到主视图控制器，就像我们在前面的项目中做的那样，并将其嵌入到导航控制器中。为此，选择新的视图控制器，导航到
    **Editor** | **Embed In Navigation Controller**。这创建了一个导航栏，我们可以在其中放置一个用于添加 PIN
    的按钮（见以下截图中的圆形区域）。
- en: 'The GUI components are shown in the following screenshot. Basically, they are
    a Table View to show the enabled PINs and a field where one can enter the Master
    PIN. Only the person who knows the Master PIN can manage the other pins:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: GUI 组件在以下截图中显示。基本上，它们是一个用于显示启用 PIN 的 Table View 和一个可以输入主 PIN 的字段。只有知道主 PIN 的人才能管理其他
    PIN：
- en: '![Designing the user interface for PinsViewController](img/image00225.jpeg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![设计 PinsViewController 的用户界面](img/image00225.jpeg)'
- en: 'Before moving on to the next section, perform the following steps:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续下一节之前，执行以下步骤：
- en: Create a new class named PinsViewController that is inherited from UIViewController.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 PinsViewController 的新类，该类继承自 UIViewController。
- en: Select the PinsViewController in the storyboard, open the Identity Inspector,
    and select PinsViewController for **Class**.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在故事板中选择 PinsViewController，打开身份检查器，并将 **Class** 选择为 PinsViewController。
- en: Open the Connections Inspector (browse **View** | **Utilities** | **Show Connections
    Inspector**).
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开连接检查器（浏览 **View** | **Utilities** | **Show Connections Inspector**）。
- en: Select the Table View, drag the dataSource, and delegate outlets to the PinsViewController
    class (see the following screenshot). This tells the Table View to ask for items
    to show and inform about the events in the PinsViewController:![Designing the
    user interface for PinsViewController](img/image00226.jpeg)
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 Table View，将 dataSource 和 delegate 输出口拖到 PinsViewController 类（见以下截图）。这告诉
    Table View 向 PinsViewController 请求显示的项目和通知事件：![设计 PinsViewController 的用户界面](img/image00226.jpeg)
- en: Set the delegate outlet of the master PIN field to the view controller.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将主 PIN 字段的控制委托设置为视图控制器。
- en: Set the **Secure Text Entry** checkbox for the master PIN.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为主 PIN 设置 **安全文本输入** 复选框。
- en: 'Linking the GUI components with the code, you should end up with the following:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 GUI 组件与代码链接起来，你应该得到以下结果：
- en: '[PRE8]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'and with the method:'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以及以下方法：
- en: '[PRE9]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Writing code for BLEConnectionViewController
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为 BLEConnectionViewController 编写代码
- en: Since we copied this View Controller from the Pet Door Locker project, we need
    to make only a few changes.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们从 Pet Door Locker 项目中复制了这个视图控制器，我们只需要做几处修改。
- en: 'First, we need to open the **BLEConnectionViewController.h** file and add the
    following import:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要打开 **BLEConnectionViewController.h** 文件并添加以下导入：
- en: '[PRE10]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We also need to make a change to the following lines:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要对以下行进行修改：
- en: '[PRE11]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Change the preceding lines to the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的行更改为以下内容：
- en: '[PRE12]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, open the `BLEConnectionViewController.m` to make the rest of the changes.
    Let''s add a new property, as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，打开 `BLEConnectionViewController.m` 文件，进行其余的修改。让我们添加一个新属性，如下所示：
- en: '[PRE13]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The location manager allows us to get the geographical coordinates (through
    the GPS receiver of our iOS device) of our house. This will be used to create
    the geofencing region.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 位置管理器允许我们通过我们 iOS 设备的 GPS 接收器获取我们房屋的地理坐标。这将用于创建地理围栏区域。
- en: 'To initialize the location manager, we have to change the `viewDidAppear` method
    to the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要初始化位置管理器，我们必须将 `viewDidAppear` 方法更改为以下内容：
- en: '[PRE14]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The location manager has to be authorized by the user to work. For this reason,
    we need to issue the following method call:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 位置管理器必须经过用户授权才能工作。因此，我们需要发出以下方法调用：
- en: '[PRE15]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Calling this method, the iOS starts an authorization request to the user that
    contains the message we added to the InfoPlist file we created in the previous
    section. The code that is needed to start receiving the position of your own house
    is as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此方法，iOS 会启动一个包含我们在上一节中添加到 InfoPlist 文件中的消息的授权请求。开始接收您自己房屋位置的所需代码如下：
- en: '[PRE16]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The code doesn't require any explanation.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码不需要任何解释。
- en: 'Once the GPS receiver has located the position, the following method is called,
    and we can store the longitude and latitude of the house:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 GPS 接收器定位了位置，就会调用以下方法，我们可以存储房屋的经纬度：
- en: '[PRE17]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Please note that once the coordinates are available, we stop the location manager
    to update them (`[manager stopUpdatingLocation]`). We do this to save batteries
    and because we do not check the coordinates anymore to know whether we are inside
    or outside the region around the house. See the following sections to understand
    how we get this information.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一旦坐标可用，我们就停止位置管理器来更新它们（`[manager stopUpdatingLocation]`）。我们这样做是为了节省电池电量，因为我们不再检查坐标来确定我们是否在房屋周围的区域内。请参阅以下部分以了解我们如何获取这些信息。
- en: 'When we change the size of the geofencing region, the following method is called:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们更改地理围栏区域的大小时，会调用以下方法：
- en: '[PRE18]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is where we store the size of the region itself.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们存储区域本身大小的位置。
- en: 'The last method that we need to write is used to store the personal PIN once
    it is modified:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要编写的最后一个方法是在 PIN 修改后存储个人 PIN：
- en: '[PRE19]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To initialize the values of the text fields when the view controller is started,
    change the `viewDidLoad` method to the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要在视图控制器启动时初始化文本字段的值，将 `viewDidLoad` 方法更改为以下内容：
- en: '[PRE20]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When the view controller is not shown on the screen, we can free both the location
    manager and the central manager, as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当视图控制器不在屏幕上显示时，我们可以释放位置管理器和中央管理器，如下所示：
- en: '[PRE21]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, we are ready to work on the GarageViewController, which is much more interesting.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好开始编写 GarageViewController 的代码了，它要有趣得多。
- en: Writing code for GarageViewController
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为 GarageViewController 编写代码
- en: 'Since we use both the location manager and the central manager, we need to
    update **GarageViewController.h** with the required includes and protocols ending
    with:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们同时使用位置管理器和中央管理器，我们需要更新 **GarageViewController.h** 文件，添加所需的包含和协议，以以下内容结束：
- en: '[PRE22]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Then, we open the **GarageViewController.m** to add the code to manage the notifications
    from the geofencing regions and the iBeacon region, and to send an opening message
    to the Arduino.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们打开 **GarageViewController.m** 文件，添加代码来管理来自地理围栏区域和 iBeacon 区域的通知，并向 Arduino
    发送开启消息。
- en: 'Add the following properties:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下属性：
- en: '[PRE23]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, we can add the code used to manage the Bluetooth communication with Arduino.
    This code is almost the same as what we used in the previous chapters. So, we
    don''t have to spend much time on it. We just point out the following:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以添加用于管理与Arduino蓝牙通信的代码。此代码几乎与我们在前几章中使用的一样。因此，我们不必在这方面花费太多时间。我们只需指出以下几点：
- en: Since we don't receive any data from Arduino via Bluetooth, the `didUpdateValueForCharacteristic`
    function can be removed, and we don't need to look for the characteristic that
    was used to receive data
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们没有通过蓝牙从Arduino接收任何数据，因此可以删除`didUpdateValueForCharacteristic`函数，我们也不需要寻找用于接收数据的特征
- en: Once the application gets connected to Arduino, it immediately sends the opening
    command
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦应用程序连接到Arduino，它立即发送开启命令
- en: 'The `didDiscoverCharacteristicsForService` method is slightly different from
    what we used in the other projects:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`didDiscoverCharacteristicsForService`方法与我们用于其他项目的略有不同：'
- en: '[PRE24]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Once the view controller is started, we have to initialize the location manager
    and create the geofencing region and iBeacon region, if they are not yet created:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启动视图控制器，我们必须初始化位置管理器，并创建地理围栏区域和iBeacon区域，如果它们尚未创建：
- en: '[PRE25]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Once the location manager is initialized and authorized by the user, the following
    method is called and the iBeacon region is created (we will discuss the actual
    iBeacon region creation later in this section):'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦位置管理器初始化并由用户授权，将调用以下方法并创建iBeacon区域（我们将在本节后面讨论实际的iBeacon区域创建）：
- en: '[PRE26]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then we call a method:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们调用一个方法：
- en: '[PRE27]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This method activates a key-value observer in user defaults, where information
    about the geofencing region is stored.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法在用户默认设置中激活了一个键值观察者，其中存储有关地理围栏区域的信息。
- en: Tip
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Key-value observing**'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**键值观察**'
- en: For more information about key-value observing, take a look at the Apple documentation
    at [http://apple.co/1PZ6aJm](http://apple.co/1PZ6aJm).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 关于键值观察的更多信息，请参阅苹果文档[http://apple.co/1PZ6aJm](http://apple.co/1PZ6aJm)。
- en: Now, every time the `HouseLongitude` changes, the `observeValueForKeyPath` method
    is called, and this allows us to create or update the geofencing region. Note
    that `HouseLongitude` changes in the BLEConnectionViewController when the user
    locates the house. The KVO technique allows you to automatically keep the geofencing
    region updated. The KVO is also set for the `HouseSize` user default property
    so that the region gets updated when the user changes the size of the region itself.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次`HouseLongitude`发生变化时，`observeValueForKeyPath`方法都会被调用，这使我们能够创建或更新地理围栏区域。请注意，当用户定位房子时，`HouseLongitude`在BLEConnectionViewController中发生变化。KVO技术允许我们自动保持地理围栏区域的更新。KVO还设置为`HouseSize`用户默认属性，以便在用户更改区域大小时更新区域。
- en: We can also set the KVO for the `insideHouse` property. We will talk about this
    later on.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以为`insideHouse`属性设置KVO。我们将在稍后讨论这一点。
- en: 'Let''s take a look at the `observeValueForKeyPath` method where the geofencing
    region is actually created:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`observeValueForKeyPath`方法，其中实际上创建了地理围栏区域：
- en: '[PRE28]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To create the geofencing region, we need to define its center, which is the
    location of the house, and a radius that is manually chosen. Then, call the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建地理围栏区域，我们需要定义其中心，即房子的位置，以及一个手动选择的半径。然后，调用以下：
- en: '[PRE29]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The iOS knows that we need to receive a notification as soon as we enter or
    exit the geofencing region. Therefore, we call:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: iOS知道我们需要在进入或退出地理围栏区域时立即接收通知。因此，我们调用：
- en: '[PRE30]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We request the iOS to establish whether we are inside or outside the geofencing
    region and call the `locationManager:(CLLocationManager *)manager didDetermineState:(CLRegionState)state
    forRegion:(CLRegion *)region` method to inform us about the same (we'll talk about
    this method later).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们请求iOS确定我们是在地理围栏区域内还是外部，并调用`locationManager:(CLLocationManager *)manager didDetermineState:(CLRegionState)state
    forRegion:(CLRegion *)region`方法来通知我们（我们将在后面讨论此方法）。
- en: 'Let''s see how iBeacon is created instead. Remember that when the location
    manager is authorized and the central manager, which manages the Bluetooth connections
    and communication, is turned on, the following method is called in order to create
    the iBeacon region:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建iBeacon。记住，当位置管理器获得授权并且中央管理器（它管理蓝牙连接和通信）开启时，会调用以下方法以创建iBeacon区域：
- en: '[PRE31]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The creation of the region is quite similar to that of the geofencing region.
    This time, the region has an UUID, a major, and a minor instead of a center and
    a radius.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 区域的创建与地理围栏区域的创建非常相似。这次，区域有一个UUID、一个major和一个minor，而不是一个中心和半径。
- en: Once the iBeacon region is created, we ask the iOS to start monitoring it (`[_locationManager
    startMonitoringForRegion:beaconRegion]`) and immediately tell us whether we are
    inside or outside the region itself (`[_locationManager requestStateForRegion:beaconRegion]`).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了iBeacon区域，我们就请求iOS开始监控它(`[_locationManager startMonitoringForRegion:beaconRegion]`)，并立即告诉我们我们是否在区域内部或外部(`[_locationManager
    requestStateForRegion:beaconRegion]`)。
- en: Now, let's take a look at the most important part of the code—the code that
    actually manages the regions' boundary crossing and sends the command of opening
    the garage door.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看代码中最重要的一部分——实际管理区域边界跨越并发送打开车库门命令的代码。
- en: 'Every time we enter a region, the `didEnterRegion` method is called:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们进入一个区域，都会调用`didEnterRegion`方法：
- en: '[PRE32]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The first few lines send a local notification to the user to inform them that
    the region border has been crossed going into it.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 前几行向用户发送本地通知，告知他们已经进入了区域边界。
- en: If you are entering the iBeacon region and you are inside the house (`_insideHouse
    = YES`), nothing happens. This means that if the iBeacon region cannot cover the
    entire house and if you exit the iBeacon region by moving inside your house, you
    don't open the garage door unexpectedly.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在进入iBeacon区域，并且你在房子内部(`_insideHouse = YES`)，则不会发生任何事。这意味着如果iBeacon区域无法覆盖整个房子，并且如果你通过进入房子内部离开iBeacon区域，你不会意外地打开车库门。
- en: If you are not in the house, the app gets connected to Arduino (via Bluetooth)
    and the garage door opens. Don't forget that the actual opening command is sent
    into the `didDiscoverCharacteristicsForService` method.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不在房子里，应用程序会通过蓝牙连接到Arduino，并打开车库门。别忘了实际的开启命令是发送到`didDiscoverCharacteristicsForService`方法的。
- en: Forget `[_locationManager startRangingBeaconsInRegion:(CLBeaconRegion *)region]`
    for now.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在先忘记`[_locationManager startRangingBeaconsInRegion:(CLBeaconRegion *)region]`。
- en: Tip
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Enabling local notifications**'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**启用本地通知**'
- en: In order to send local notifications, they have to be authorized by the user.
    To do this, we need to call the `[application registerUserNotificationSettings:[UIUserNotificationSettings
    settingsForTypes:UIUserNotificationTypeAlert|UIUserNotificationTypeBadge|UIUserNotificationTypeSound
    categories:nil]]` method as soon as the application starts. The `didFinishLaunchingWithOptions`
    method is the place where we call it.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 为了发送本地通知，它们必须得到用户的授权。为此，我们需要在应用程序启动时立即调用`[application registerUserNotificationSettings:[UIUserNotificationSettings
    settingsForTypes:UIUserNotificationTypeAlert|UIUserNotificationTypeBadge|UIUserNotificationTypeSound
    categories:nil]]`方法。`didFinishLaunchingWithOptions`方法是我们调用它的地方。
- en: 'Every time we get into a region, the `didExitRegion` method is called:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们进入一个区域，都会调用`didExitRegion`方法：
- en: '[PRE33]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: After sending a local notification, if we are exiting the geofencing region,
    we can set the `insideHouse` property to `NO` so that when we enter the iBeacon
    region again, the opening command is sent. Forget `[_locationManager stopRangingBeaconsInRegion:(CLBeaconRegion
    *)region]` for now.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在发送本地通知后，如果我们正在退出地理围栏区域，我们可以将`insideHouse`属性设置为`NO`，这样当我们再次进入iBeacon区域时，就会发送开启命令。现在先忘记`[_locationManager
    stopRangingBeaconsInRegion:(CLBeaconRegion *)region]`。
- en: 'Why don''t we use the traditional code (`_insideHouse = YES`) to set the property?
    In the `viewDidLoad` method, we set an observer for the property so that every
    time it changes, the `observeValueForKeyPath` is called. The traditional code
    doesn''t start the `observeValueForKeyPath` method, and we need to use `[self
    setInsideHouse:NO]` instead. When the `observeValueForKeyPath` is called because
    `insideHouse` changes, we update the image of the `readyToOpen`, keeping the user
    informed about whether the app will send the opening command on entering the iBeacon
    region or not. To do this, we need these few lines of code into the `observeValueForKeyPath`
    method:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们不使用传统的代码(`_insideHouse = YES`)来设置属性？在`viewDidLoad`方法中，我们为属性设置了一个观察者，以便每次它改变时，都会调用`observeValueForKeyPath`。传统的代码不会启动`observeValueForKeyPath`方法，我们需要使用`[self
    setInsideHouse:NO]`代替。当`observeValueForKeyPath`因为`insideHouse`改变而被调用时，我们更新`readyToOpen`的图像，让用户了解应用程序是否会在进入iBeacon区域时发送开启命令。为此，我们需要将这些代码行放入`observeValueForKeyPath`方法中：
- en: '[PRE34]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Tip
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Working in the background**'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**后台工作**'
- en: What makes the iBeacon technology along with geofencing particularly interesting
    is that `didEnterRegion` and `didExitRegion` are also called when the application
    is either running in the background, or not even running. Unfortunately, when
    the application is not running, the iOS starts it and keeps it running for some
    period of time (for about 3s) to save the batteries. So, any kind of action that
    is required to respond to the event has to be very quick. In the code, we just
    connect to the Arduino and send a few bytes to it, and this takes up much less
    time than 3s.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: iBeacon技术与地理围栏特别有趣的地方在于，即使在应用在后台运行或根本未运行时，`didEnterRegion`和`didExitRegion`也会被调用。不幸的是，当应用未运行时，iOS会启动它并保持运行一段时间（大约3秒）以节省电池。因此，任何需要响应事件的动作都必须非常迅速。在代码中，我们只是连接到Arduino并发送一些字节到它，这比3秒的时间要少得多。
- en: 'The last relevant method that we need to write is `didDetermineState`, which
    is called to find out where the device is with respect to a region (calling `[_locationManager
    startMonitoringForRegion:beaconRegion]` or `[_locationManager startMonitoringForRegion:houseRegion]`)
    or when the iOS recognizes that something has changed. In this function, we update
    the indicators that visually inform the user that they are in one of the monitored
    regions, as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要编写的最后一个相关方法是`didDetermineState`，当需要确定设备相对于一个区域的位置（调用`[_locationManager startMonitoringForRegion:beaconRegion]`或`[_locationManager
    startMonitoringForRegion:houseRegion]`）或当iOS识别到有变化时会被调用。在这个函数中，我们更新指示器，以视觉方式告知用户他们位于被监控区域之一，如下所示：
- en: '[PRE35]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note that the visual information (inside the iBeacon and geofencing region,
    ready to open the garage door) is not strictly needed. We put that in the app
    to make you experiment with iBeacon and geofencing.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，视觉信息（在iBeacon和地理围栏区域内，准备打开车库门）并不是严格必需的。我们将其放入应用中是为了让你尝试使用iBeacon和地理围栏。
- en: 'The last two methods are as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个方法如下：
- en: '`manualOperation`: This manually opens the garage door by sending the opening
    command.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`manualOperation`：通过发送开启命令手动打开车库门。'
- en: '`simulateHomeRegionExit`: This simulates the exit from the geofencing region
    by manually setting the `insideHouse` property to `NO`. This can be useful in
    the debugging phase or if you wish to learn how the application works without
    having to actually drive away from your house (which we did too many times!).'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`simulateHomeRegionExit`：通过手动将`insideHouse`属性设置为`NO`来模拟从地理围栏区域退出。这在调试阶段或如果你希望在不实际开车离开你的房子的情况下了解应用的工作原理时可能很有用（我们确实这样做了很多次！）。'
- en: 'The code is very simple and doesn''t require much explanation:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 代码非常简单，不需要太多解释：
- en: '[PRE36]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The very last two methods (we promise!) that you need to look at are as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个方法（我们保证！）你需要查看的是以下内容：
- en: '`didRangeBeacons`: This method is not used in this project, but we have shown
    it because it may be very useful in another iBeacon project, as it gives an estimation
    of the distance between an iOS device and each iBeacon in range. Ranging iBeacons
    can be started and stopped by using `[_locationManager startRangingBeaconsInRegion:(CLBeaconRegion
    *)region]` and `[_locationManager stopRangingBeaconsInRegion:(CLBeaconRegion *)region]`
    respectively.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`didRangeBeacons`：这个方法在本项目中没有使用，但我们展示了它，因为它可能在另一个iBeacon项目中非常有用，因为它可以估算iOS设备和每个范围内的iBeacon之间的距离。可以通过使用`[_locationManager
    startRangingBeaconsInRegion:(CLBeaconRegion *)region]`和`[_locationManager stopRangingBeaconsInRegion:(CLBeaconRegion
    *)region]`分别启动和停止iBeacon的测距。'
- en: '`monitoringDidFailForRegion`: This method tells us whether something is wrong
    in the monitoring of any region. Never forget to implement it.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`monitoringDidFailForRegion`：这个方法告诉我们是否在监控任何区域时出现了问题。永远不要忘记实现它。'
- en: '[PRE37]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Writing code for PinsViewController
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为PinsViewController编写代码
- en: This view controller manages the PINs that are required to authorize your relatives
    and friends so that they can access your garage. It works almost in the same way
    as the ActivationsTableViewController in the Power Plug project. So, we won't
    spend much time on it.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图控制器管理着授权你的亲戚和朋友访问你的车库所需的PIN码。它几乎与Power Plug项目中的ActivationsTableViewController以相同的方式工作。因此，我们不会在这个问题上花费太多时间。
- en: The main difference here is that we have to enter just a PIN, and it doesn't
    make sense to create a screen for that. We take advantage of a feature of UIAlertView.
    By setting its style to `UIAlertViewStylePlainTextInput`, it presents a text field
    in which we can enter the PIN. This is very easy and convenient.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要区别在于我们只需要输入一个PIN，为它创建一个屏幕没有意义。我们利用UIAlertView的一个特性。通过将其样式设置为`UIAlertViewStylePlainTextInput`，它将显示一个文本框，我们可以输入PIN。这非常简单方便。
- en: You should be able to write this view controller yourself and compare your results
    with the downloaded code. Let's give it a try.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够自己编写这个视图控制器，并将你的结果与下载的代码进行比较。让我们试试。
- en: Testing and tuning
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试和调整
- en: We are now ready to test this project and impress our neighbors. First, you
    have to set the iBeacon parameters. If you are using RedLab iBeacon, you can set
    it by using the iOS app that is available from the iTunes Store for free ([https://itunes.apple.com/it/app/redbear-beacontool/id828819434?l=en&mt=8](https://itunes.apple.com/it/app/redbear-beacontool/id828819434?l=en&mt=8)).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已准备好测试这个项目并给邻居留下深刻印象。首先，你必须设置iBeacon参数。如果你使用RedLab iBeacon，你可以通过免费从iTunes
    Store获取的iOS应用来设置它（[https://itunes.apple.com/it/app/redbear-beacontool/id828819434?l=en&mt=8](https://itunes.apple.com/it/app/redbear-beacontool/id828819434?l=en&mt=8)）。
- en: 'You have to enter the following values:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须输入以下值：
- en: '**UUID**: 00000000-0000-0000-0000-0000000000FF'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UUID**：00000000-0000-0000-0000-0000000000FF'
- en: '**Major**: 0'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主要**：0'
- en: '**Minor**: 1'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**次要**：1'
- en: '**Advertising Interval**: 250 ms'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**广告间隔**：250 ms'
- en: '**TX Power**: 0'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TX功率**：0'
- en: Note
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Double-check the UUID. It's a long string, and any error prevents the iBeacon
    from being recognized by the application.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细检查UUID。它是一个长字符串，任何错误都会阻止iBeacon被应用程序识别。
- en: Tip
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Tuning the iBeacon parameters**'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '**调整iBeacon参数**'
- en: Once everything works as expected, you can try reducing the TX power and/or
    Advertising Interval. The lower they are, the more battery you save, and the longer
    the iBeacon works without you having to replace the batteries. Moreover, reducing
    the TX power allows you to send the opening command when you are closer to your
    garage. Let's make some tests to detect the best values for you.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦一切按预期工作，你可以尝试降低TX功率和/或广告间隔。它们越低，你就能节省更多的电量，iBeacon在没有更换电池的情况下工作的时间就越长。此外，降低TX功率允许你在靠近车库时发送开启命令。让我们进行一些测试，以检测最适合你的值。
- en: If you are using a different iBeacon, ask the manufacturer how to set the parameters
    so they are exactly the same.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是不同的iBeacon，请询问制造商如何设置参数，以确保它们完全相同。
- en: Now, you should place the iBeacon near your garage door at a high position and
    leave it turned off.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该将iBeacon放置在你车库门附近的高处，并保持关闭状态。
- en: Wire the relay contacts or the MOSFET pins to your garage door opener (please
    refer to the electric diagrams provided at the beginning of this chapter). There
    are a lot of different models out there, so you need to do this yourself. The
    general advice is that you have to put the relay exit (or the exit connected to
    the MOSFET) in parallel to the push button that you use to manually open and close
    the garage door. Take a look at your garage door opener instruction manual for
    more information and directions.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 将继电器触点或MOSFET引脚连接到你的车库门开启器（请参阅本章开头提供的电气图）。市面上有很多不同的型号，所以你需要自己来做。一般建议是将继电器输出（或连接到MOSFET的输出）并联到你用来手动开启和关闭车库门的按钮。查看你的车库门开启器说明书以获取更多信息和建议。
- en: 'Before starting the test phase, we need to set up the Arduino code to properly
    clean up the EEPROM and store the master PIN. To do this, perform the following
    procedure:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始测试阶段之前，我们需要设置Arduino代码，以便正确清理EEPROM并存储主PIN。为此，请执行以下步骤：
- en: 'In the `setup` function, comment out the following lines, which clean up the
    EEPROM and store the master PIN:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setup`函数中，注释掉以下行，这些行清理EEPROM并存储主PIN：
- en: '[PRE38]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can change the master PIN (12345) to your preferred code here.
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以将主PIN（12345）更改为你喜欢的代码。
- en: Upload the code to Arduino.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将代码上传到Arduino。
- en: Comment the previous code again and upload it to Arduino. Now, the EEPROM is
    cleared and the master PIN is stored.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次注释掉之前的代码并将其上传到Arduino。现在，EEPROM已清除，主PIN已存储。
- en: 'Now, when you open the app, you will see a message. You have to respond to
    this message by selecting **Allow**:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你打开应用时，你会看到一个消息。你必须通过选择**允许**来响应此消息：
- en: '![Testing and tuning](img/image00227.jpeg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![测试和调整](img/image00227.jpeg)'
- en: In the app, open the Configuration tab, scan for the RF8001, choose your personal
    PIN, enter it in the PIN field, and then tap on Set House Position. A few seconds
    later, you should see the longitude and latitude of your house, as acquired by
    the GPS.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用中打开配置标签页，扫描RF8001，选择您的个人PIN，将其输入到PIN字段中，然后点击设置房屋位置。几秒钟后，您应该看到通过GPS获取到的您家的经纬度。
- en: Set the **House Region Size** to 100 meters. Change it to a higher value only
    if your garage door opens unexpectedly when you are inside your house or if you
    have a very large house (lucky you!).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 将**房屋区域大小**设置为100米。只有当您在屋内时车库门意外打开，或者您有一个非常大的房子（真幸运！），才将其更改为更高的值。
- en: Tap the **PINS** tab, enter the master PIN (`12345`, if you have not changed
    it in the Arduino code), and tap *Enter*. You should see an empty list. Tap on
    the add button (**+**) and enter your personal PIN that you chose before.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**PINS**标签页，输入主PIN（如果未在Arduino代码中更改，则为`12345`），然后点击*Enter*。您应该看到一个空列表。点击添加按钮（**+**）并输入您之前选择的个人PIN。
- en: Tap on the Main tab and then tap on the **Open** button. Now, your garage should
    open and then close about 30 seconds later.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 点击主标签页，然后点击**打开**按钮。现在，您的车库应该打开，然后大约30秒后关闭。
- en: Note
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To change the closing delay time, you have to change the value of CLOSING_DOOR_INTERVAL
    in the Arduino code. Moreover, to operate the garage door opener, Arduino shorts
    the control line for about 300 ms. If this is not enough for your device, you
    can change the delay in the `pulseOutput` function.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改关闭延迟时间，您必须更改Arduino代码中的CLOSING_DOOR_INTERVAL的值。此外，为了操作车库门开启器，Arduino会短接控制线大约300毫秒。如果这对您的设备来说不够，您可以在`pulseOutput`函数中更改延迟。
- en: 'Now, we are going to test the most exciting feature—opening the garage automatically:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将测试最令人兴奋的功能——自动打开车库：
- en: Open the Main tab again.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次打开主标签页。
- en: You should see the **In House Region** indicator turned on, the **In Garage
    Region** turned off, and the **Ready To Open** turned on.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该看到**在房屋区域**指示灯已开启，**在车库区域**指示灯已关闭，以及**准备打开**指示灯已开启。
- en: If the **Ready To Open** indicator is off, tap on **Simulate Exit**.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果**准备打开**指示灯是关闭的，请点击**模拟退出**。
- en: Close your app, sending it to the background or closing it from the task list.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭您的应用，将其发送到后台或从任务列表中关闭。
- en: Turn on the iBeacon.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开iBeacon。
- en: You should see a notification on the screen and hear a short sound, and your
    garage should start opening.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该在屏幕上看到一个通知，并听到短促的声音，然后您的车库门应该开始打开。
- en: Now, if you move around and inside your house, your garage shouldn't open anymore
    (the **Ready To Open** indicator should remain off).
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果您在屋内或屋外移动，您的车库不应该再打开（**准备打开**指示灯应该保持关闭状态）。
- en: Drive away from your house until you hear a sound notification from your iOS
    device. Please drive safely. You don't need to look at your iOS device while driving.
    The sound notification alerts you.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 驾车离开您的住所，直到您从iOS设备中听到声音通知。请安全驾驶。在驾驶时，您不需要看您的iOS设备。声音通知会提醒您。
- en: Make a stop and check the application. Now, the **Ready To Open** indicator
    should be on.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停车并检查应用。现在，**准备打开**指示灯应该已开启。
- en: Drive back to your house. As soon as you are close enough to the iBeacon, you
    should hear a notification, and the garage door should start opening.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 驾车返回您的住所。一旦您靠近iBeacon，您应该会听到通知，并且车库门应该开始打开。
- en: Now, you are ready to impress your neighbors!
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经准备好让您的邻居们印象深刻了！
- en: How to go further
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何进一步操作
- en: 'Some improvements that could be done to this project are as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 可以对这个项目进行的改进如下：
- en: Setting the automatic door closing interval directly from the app instead of
    changing the Arduino code.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接从应用中设置自动门关闭间隔，而不是更改Arduino代码。
- en: Turning the garage lights on and off on entering and exiting the garage.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在进入和离开车库时开关车库灯。
- en: Opening the garage door from the inside by using the noise generated by the
    car engine instead of manually. This requires listening to the motor noise from
    the iOS device and comparing it with a pre-recorded noise of the motor. This is
    done to avoid a situation where a noise inside or outside the garage unexpectedly
    opens the door. For signal comparison, you can use an operation called the correlation
    of two signals (take a look at the Accelerate framework that is available in iOS),
    but you have to pay attention to the fact that the acquired signal and the pre-recorded
    signal may have different lengths and/or may be time shifted. Okay, this is a
    big challenge, but this is the last chapter of the book, and you should be a master
    of Arduino and iOS programming by now. Digital signal processing is an art that
    you may be interested in.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用汽车发动机产生的噪音而不是手动操作来从内部打开车库门。这需要监听iOS设备上的电机噪音并将其与预先录制的电机噪音进行比较。这样做是为了避免意外情况下车库内或外的噪音打开门的情况。对于信号比较，你可以使用两个信号的互相关操作（查看iOS中可用的Accelerate框架），但你必须注意，获取的信号和预先录制的信号可能长度不同，或者可能存在时间偏移。好吧，这是一个大挑战，但这本书的最后一章，你现在应该已经是Arduino和iOS编程的大师了。数字信号处理是一门你可能感兴趣的技艺。
- en: Checking whether the garage door is effectively closed by using a reed switch,
    a hall effect sensor, or an ultrasonic distance sensor, and having a notification
    sent to your phone. You may need the WiFi Shield to take advantage of one of the
    available IoT services to send the notification.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用翻板开关、霍尔效应传感器或超声波距离传感器来检查车库门是否有效关闭，并将通知发送到您的手机。您可能需要WiFi盾牌来利用可用的物联网服务之一发送通知。
- en: Summary
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: While building this project, you learned a lot, especially with regards to iOS.
    You learned how to create and manage the geofencing and iBeacon regions. This
    opens the door to many different projects on iOS with or without the Arduino integration.
    Moreover, you learned how to monitor changes in properties (KVO), which is a technique
    that lies at the base of good programming together with the help of Model-View-Controller
    model. This can be applied many times. On Arduino, you learned how to use EEPROM
    to store information that needs to be permanently stored on the board to control
    the behavior of your programs.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建这个项目的过程中，你学到了很多，特别是在iOS方面。你学会了如何创建和管理地理围栏和iBeacon区域。这为iOS上的许多不同项目打开了大门，无论是与Arduino集成还是不集成。此外，你还学会了如何监控属性的变化（KVO），这是一种在Model-View-Controller模型帮助下，位于良好编程基础的技术。这可以多次应用。在Arduino上，你学会了如何使用EEPROM来存储需要永久存储在板上以控制程序行为的信息。
- en: This project ends this long journey of Arduino and iOS programming and the two
    platforms' integration.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目结束了Arduino和iOS编程以及这两个平台集成的漫长旅程。
- en: I hope that you had fun reading the book, coding, and building at least some
    of the proposed projects (or maybe all!). Mostly, I hope that you learned more
    about Arduino, iOS, and their integration so that from now on, you can design
    and build your own projects.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你在阅读这本书、编码和构建至少一些提议的项目（或者也许全部！）的过程中感到愉快！主要的是，我希望你更多地了解了Arduino、iOS及其集成，从现在开始，你可以设计和构建你自己的项目。
- en: Have a great time making some revolutionary and game-changing projects!
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 制作一些革命性和改变游戏规则的项目，享受乐趣吧！
