- en: Chapter 8. Creating Data Storage Mechanisms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章. 创建数据存储机制
- en: 'We now turn our attention to data storage requirements. We need a way to store
    a list of **Point of Interest** (**POI**) data fetched from the server and make
    the list accessible when a device runs offline. This chapter shows how to use
    the built-in SQLite database engine to store and retrieve the POI data in a cross-platform
    way. The following topics will be covered in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在转向数据存储需求。我们需要一种方法来存储从服务器获取的 **兴趣点**（**POI**）数据列表，并在设备离线时使列表可访问。本章将展示如何使用内置的
    SQLite 数据库引擎以跨平台的方式存储和检索 POI 数据。本章将涵盖以下主题：
- en: Approaches to data storage solutions
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据存储解决方案的方法
- en: Different app storage options in Android
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android 中不同的应用程序存储选项
- en: Using preferences to store key-value pairs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用首选项存储键值对
- en: SQLite database storage in Xamarin.Android
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Xamarin.Android 中使用 SQLite 数据库存储
- en: Using the SQLite.NET ORM component
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SQLite.NET ORM 组件
- en: Performing database CRUD operations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行数据库 CRUD 操作
- en: Unit testing the Android app using NUnitLite
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 NUnitLite 对 Android 应用进行单元测试
- en: Implementing caching to `POIApp`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `POIApp` 中实现缓存
- en: 'Data storage solutions mainly fall into two general categories: storing in
    Cloud using web services or using the device''s local storage. Saving data in
    the Cloud provides great advantages over local data storage options, but in certain
    cases, such as apps that run offline or for games, generally you are required
    to store the data locally in the device''s storage.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 数据存储解决方案主要分为两大类：使用网络服务在云端存储或使用设备的本地存储。在云端存储数据相对于本地数据存储选项提供了巨大的优势，但在某些情况下，例如运行离线应用程序或游戏，通常需要将数据存储在设备的存储中。
- en: The current `POIApp` uses web services to store the POI list in the server,
    and the mobile app retrieves the list by making REST API calls. So far, it works
    great. However, it always requires an Internet connection to fetch and display
    the POI list. Let's overcome this problem by storing the list of POIs locally
    and accessing them even when the device is offline.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的 `POIApp` 使用网络服务将 POI 列表存储在服务器上，而移动应用程序通过发出 REST API 调用来检索列表。到目前为止，它运行得很好。然而，它始终需要互联网连接来获取和显示
    POI 列表。让我们通过在本地存储 POI 列表并即使在设备离线时也能访问它们来克服这个问题。
- en: Data storage in Android
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android 中的数据存储
- en: Android supports several solutions that can be used for persisting data locally.
    The persisted data can be accessible even when the application shuts down or when
    a device restarts. The examples of such data include the device settings, contacts
    list, browser bookmarks, or any such app-specific data.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Android 支持多种用于本地持久化数据的解决方案。即使应用程序关闭或设备重启，持久化的数据仍然可以访问。此类数据的例子包括设备设置、联系人列表、浏览器书签或任何此类特定应用程序的数据。
- en: 'The following table depicts the different data storage options available in
    the Android platform:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 下表展示了 Android 平台可用的不同数据存储选项：
- en: Storage options
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 存储选项
- en: Description
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 描述
- en: Shared preferences
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 共享首选项
- en: This is the private data storage for your application that persists primitive
    key-value data pairs only. When the user uninstalls the application, this data
    is removed.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您的应用程序的私有数据存储，仅持久化原始键值数据对。当用户卸载应用程序时，此数据将被删除。
- en: Internal storage
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 内部存储
- en: This stores data in the device internal memory and is available until the app
    is uninstalled from the device. This data is private to your application and other
    apps cannot access it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这将数据存储在设备的内部内存中，直到应用程序从设备中卸载，数据都是可用的。这些数据仅对您的应用程序是私有的，其他应用程序无法访问它。
- en: External file storage
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 外部文件存储
- en: This stores data in shared external storage such as an external SD card. The
    data stored is public. Other applications or users can access these files by connecting
    the device to a computer.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这将数据存储在共享的外部存储中，如外部 SD 卡。存储的数据是公开的。其他应用程序或用户可以通过将设备连接到计算机来访问这些文件。
- en: SQLite storage
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 存储
- en: This is a structured private data store. SQLite databases created from an app
    can only be accessed from the same application.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个结构化的私有数据存储。从应用程序创建的 SQLite 数据库只能由同一应用程序访问。
- en: This chapter briefly covers the shared preferences and SQLite storage options
    only. You can research the internal and external storage options on your own from
    the official Xamarin website.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本章简要介绍了共享首选项和 SQLite 存储选项。您可以从官方 Xamarin 网站自行研究内部和外部存储选项。
- en: Shared preferences
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享首选项
- en: Shared preferences are persistence **key/value** data pairs that are used to
    store primitive data pairs, such as **bool**, **float**, **int**, **string**,
    and **long**. The data saved in the Android preference is persisted across different
    app sessions and is private to the application it has created. Any other application
    cannot access it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 共享偏好是持久化的 **键/值** 数据对，用于存储原始数据对，例如 **bool**、**float**、**int**、**string** 和 **long**。在Android偏好中保存的数据在不同的应用程序会话之间持久化，并且对创建它的应用程序是私有的。任何其他应用程序都无法访问它。
- en: 'For using shared preferences to save data pairs, you first need to get an instance
    of the `ISharedPreferences` interface. A shared preference can be specific to
    an activity or made global to all the activities in the application. If you want
    to create a single preference file specific to an activity, you can use `Activity.GetPreferences`
    to get an instance of the `ISharedPreferences` interface, or you can call the
    `GetSharedPreferences` method on the application context by passing the preference
    name and mode of operation to get the application level preference:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用共享偏好保存数据对，您首先需要获取 `ISharedPreferences` 接口的实例。共享偏好可以特定于一个活动，也可以使应用程序中所有活动的共享偏好全局化。如果您想创建一个特定于活动的单个偏好文件，可以使用
    `Activity.GetPreferences` 来获取 `ISharedPreferences` 接口的实例，或者您可以通过传递偏好名称和操作模式到应用程序上下文中调用
    `GetSharedPreferences` 方法来获取应用程序级别的偏好：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, let''s call the `Edit()` method to get an instance of `ISharedPreferencesEditor`.
    This matches all of the changes made to values in shared preferences and only
    saves when a call to `Commit()` or `Apply()` is made:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们调用 `Edit()` 方法来获取 `ISharedPreferencesEditor` 的实例。这将匹配对共享偏好中值所做的所有更改，并且只有在调用
    `Commit()` 或 `Apply()` 时才会保存：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To read values from shared preferences, we can use the `GetXX()` methods by
    providing the same key that was used while saving data, where `XX` represents
    the supported primitive types. The following code snippet retrieves the values
    stored in the previous step:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要从共享偏好中读取值，我们可以通过提供保存数据时使用的相同键来使用 `GetXX()` 方法，其中 `XX` 代表支持的原始类型。以下代码片段检索了之前步骤中存储的值：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The SQLite database storage
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQLite数据库存储
- en: SQLite is an open source, lightweight, and transactional database engine shipped
    with mobile platforms including Android, iOS, and Windows phones. According to
    the official documentation, Android is using **SQLite Version 3.4.0**. It is a
    widely used, standalone, relational database engine that requires no separate
    server process.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 是一个开源、轻量级且支持事务的数据库引擎，它随移动平台（包括 Android、iOS 和 Windows 手机）一起提供。根据官方文档，Android
    正在使用 **SQLite 版本 3.4.0**。它是一个广泛使用的、独立的、关系型数据库引擎，不需要单独的服务器进程。
- en: 'The following are some of the advantages that make the SQLite database engine
    one of the most shipped database engines today:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些使 SQLite 数据库引擎成为当今最广泛使用的数据库引擎之一的优点：
- en: It is an open source project and a large open source community is actively working
    on it.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它是一个开源项目，一个庞大的开源社区正在积极为其工作。
- en: It doesn't have a server, so it requires no server infrastructure.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它没有服务器，因此不需要服务器基础设施。
- en: It is a lightweight engine that provides a set of classes to perform database
    transactions.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它是一个轻量级引擎，提供了一套用于执行数据库事务的类。
- en: The complete database is a single file stored in the device memory that is private
    to your application. The privacy of the SQLite database boils down to the platform
    filesystem privacy.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完整的数据库是一个存储在设备内存中的单个文件，该文件对您的应用程序是私有的。SQLite数据库的隐私性归结为平台文件系统的隐私性。
- en: As such, we have decided to go with SQLite for caching the POI list. When the
    list is downloaded successfully, we will save the POI in the database and update
    it periodically whenever the download is successful. When a device runs offline
    or is unable to fetch the updated list from the server, the cached POI list can
    be presented on the screen.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们决定使用SQLite来缓存POI列表。当列表成功下载后，我们将把POI保存到数据库中，并在下载成功时定期更新它。当设备离线或无法从服务器获取更新列表时，缓存的POI列表可以在屏幕上显示。
- en: Although SQLite is built in Android and provides a set of APIs to perform all
    the database CRUD (Create, Read, Update, and Delete) operations, we will use the
    SQLite.ORM component from the component store. The following section walks you
    through the steps to perform different database operations using the SQLite.ORM
    component.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然SQLite内置在Android中，并提供了一套API来执行所有数据库CRUD（创建、读取、更新和删除）操作，但我们将使用组件存储库中的SQLite.ORM组件。下一节将指导您使用SQLite.ORM组件执行不同的数据库操作。
- en: Using the SQLite.net ORM component
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SQLite.net ORM 组件
- en: SQLite.NET **Object Relational Mapping** (**ORM**) is an open source library
    that allows .NET and Mono applications to store data objects in the SQLite database.
    It is a lightweight and easy to use component that allows you to save and retrieve
    data objects, without having to worry about writing any SQL query. This is a free
    component available in the Xamarin Component Store. It was earlier designed to
    work for MonoTouch on iPhone, but later it was extended to support other platforms,
    including Android, Windows, and Silverlight platforms. Thanks to **Frank A. Krueger**
    for developing and maintaining this component.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite.NET **对象关系映射**（**ORM**）是一个开源库，允许 .NET 和 Mono 应用程序将数据对象存储在 SQLite 数据库中。它是一个轻量级且易于使用的组件，允许你保存和检索数据对象，无需担心编写任何
    SQL 查询。这是一个在 Xamarin 组件商店中可用的免费组件。它最初是为 iPhone 上的 MonoTouch 设计的，但后来扩展到支持其他平台，包括
    Android、Windows 和 Silverlight 平台。感谢 **Frank A. Krueger** 开发和维护此组件。
- en: 'There are three ways to add SQLite.NET ORM to the Xamarin application. Either
    you can add it by downloading the required files from the GitHub open source code
    repository, NuGet, or the Xamarin Component Store:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种方法可以将 SQLite.NET ORM 添加到 Xamarin 应用程序中。你可以通过从 GitHub 开源代码仓库、NuGet 或 Xamarin
    组件商店下载所需文件来实现：
- en: SQLite.NET is a very thin library with a single file. Download the `SQLite.cs`
    file from GitHub and add it to your application. The SQLite.NET library binds
    directly to the SQLite database engine on each platform.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite.NET 是一个非常薄的库，只有一个文件。从 GitHub 下载 `SQLite.cs` 文件并将其添加到你的应用程序中。SQLite.NET
    库直接绑定到每个平台的 SQLite 数据库引擎。
- en: To add it from the Xamarin Component Store, you need to follow the same steps
    we used while adding the `UrlImageViewHelper` component in Chapter 4, *Adding
    a List View*.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要从 Xamarin 组件商店添加，你需要遵循我们在第 4 章 *添加列表视图* 中添加 `UrlImageViewHelper` 组件时使用的相同步骤。
- en: To add it as a NuGet package bundle, you can navigate to **Packages** | **Add
    packages** from your Solution Explorer to open the NuGet gallery window. Search
    for `SQlite.NET` and select it to add it to your project.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将其作为 NuGet 包捆绑添加，你可以从你的解决方案资源管理器导航到 **包** | **添加包** 以打开 NuGet 画廊窗口。搜索 `SQlite.NET`
    并选择它以将其添加到你的项目中。
- en: Once the reference to the SQlite.NET ORM component is added to the project,
    we can focus on performing database operations.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将 SQlite.NET ORM 组件的引用添加到项目中，我们就可以专注于执行数据库操作。
- en: Using attributes to mark POIApp to be persisted
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用属性标记 POIApp 以进行持久化
- en: 'SQLite.NET ORM brings a set of attributes that allows you to mark classes and
    fields that are to be persisted to the database. You can apply any of the following
    attributes to control the construction of a table:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite.NET ORM 带来一组属性，允许你标记要持久化到数据库的类和字段。你可以应用以下任何属性来控制表的构建：
- en: Attribute
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 属性
- en: Usage
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 用法
- en: '`Table`'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`Table`'
- en: By default, the class names are used as table names. You can use this attribute
    if you want to specify your own table name. This is an optional attribute applied
    to a class.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，类名称用作表名称。如果你想要指定自己的表名称，可以使用此属性。这是一个应用于类的可选属性。
- en: '`Column`'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`Column`'
- en: By default, the property names are used as column names. This attribute provides
    you the control to specify your own column name.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，属性名称用作列名称。此属性提供你指定自己的列名称的控制权。
- en: '`PrimaryKey`'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`PrimaryKey`'
- en: This property is the primary key of the table. Only single-column primary keys
    are supported.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性是表的键。仅支持单列主键。
- en: '`AutoIncrement`'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`AutoIncrement`'
- en: This property is automatically generated by the database upon insert. The property
    type should be an integer and should also be marked with the `PrimaryKey` attribute.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性在插入时由数据库自动生成。属性类型应为整数，并且还应标记为 `PrimaryKey` 属性。
- en: '`Indexed`'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`Indexed`'
- en: This property should have an index created for it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 应为此属性创建一个索引。
- en: '`Unique`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`Unique`'
- en: This property will be unique in the table.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性将在表中是唯一的。
- en: '`MaxLength`'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`MaxLength`'
- en: This property specifies the `varchar` max size. The default max length is `140`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性指定 `varchar` 的最大长度。默认最大长度为 `140`。
- en: '`Ignore`'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ignore`'
- en: This property will not be in the table.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性将不会在表中。
- en: '`NotNull`'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`NotNull`'
- en: This property cannot be left null.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性不能为空。
- en: 'For `POIApp`, let''s use some of the attributes from the preceding list of
    the `PointOfInterest` class:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `POIApp`，我们可以使用 `PointOfInterest` 类前述列表中的某些属性：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code snippet, notice that we declared that the table name will
    be `POITable`, the `Id` field is marked as the primary key, and the `Name` field
    cannot be null.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，请注意我们声明了表名将是 `POITable`，`Id` 字段被标记为主键，并且 `Name` 字段不能为空。
- en: Adding a database helper class
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加数据库辅助类
- en: Now we need to create a standard class that will define the set of methods to
    allow basic CRUD operations. This class is likely to be accessed multiple times;
    therefore, we will mark this class as a singleton class to prevent multiple instances
    of the same class.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要创建一个标准类，该类将定义一组方法以允许基本的 CRUD 操作。此类可能被多次访问；因此，我们将此类标记为单例类以防止创建相同类的多个实例。
- en: 'To create the database helper implementation class, perform the following steps:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建数据库辅助实现类，请执行以下步骤：
- en: Create a class called `DBManager`.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `DBManager` 的类。
- en: 'To make the `DBManager` class a singleton class, first declare the default
    constructor private:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使 `DBManager` 类成为单例类，首先声明默认构造函数为私有：
- en: '[PRE4]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now declare a private static instance of the `DBManager` class and do the early
    initialization. We need to add a static getter method to make the `DBManager`
    class accessible. Add the following code snippet to the `DBManager` class:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在声明一个 `DBManager` 类的私有静态实例并执行早期初始化。我们需要添加一个静态获取方法来使 `DBManager` 类可访问。将以下代码片段添加到
    `DBManager` 类中：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that there are different ways to create a singleton class. I have chosen
    to use the singleton class using the *early initialization* method. For more information
    on singleton class implementation, follow the MSDN developer site.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，创建单例类的方法有很多种。我选择使用 *早期初始化* 方法来使用单例类。有关单例类实现的更多信息，请访问 MSDN 开发者网站。
- en: 'Before saving the data, we need to first create a database. Let''s create a
    blank database or open an existing one by passing the file path to the `SQLiteConnection`
    class constructor. Add the following `CreateTable()` method to your `DBManager`
    class:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在保存数据之前，我们首先需要创建一个数据库。让我们通过传递文件路径到 `SQLiteConnection` 类构造函数来创建一个空数据库或打开一个现有的数据库。将以下
    `CreateTable()` 方法添加到您的 `DBManager` 类中：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Notice the following in the preceding code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下代码：
- en: The `DB_NAME` constant defines a name for the database. The database file will
    be created with this name and saved to the location specified in the path variable.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DB_NAME` 常量定义了数据库的名称。数据库文件将使用此名称创建，并保存到路径变量指定的位置。'
- en: The SQLite database file path can be different for different platforms. Both
    Android and iOS use the environment class to construct a valid path.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite 数据库文件路径可能因平台而异。Android 和 iOS 都使用环境类来构建有效的路径。
- en: The `SQLiteConnection` class constructor opens the database if it already exists
    with the specified name, or else it creates a new database.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SQLiteConnection` 类构造函数如果已存在则使用指定名称打开数据库，否则创建一个新的数据库。'
- en: The `CreateTable()` method opens the table if it exists, or else it creates
    a new table.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreateTable()` 方法如果存在则打开表，否则创建一个新的表。'
- en: Creating or updating the POI record
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建或更新 POI 记录
- en: Once your database connection is open, we can perform different database operations.
    To begin with, let's create a method named `SavePOI()` to save the POI object
    in the database. The `SQLiteConnection` class provides methods, such as **Insert**,
    `InsertOrReplace`, `InsertAll`, `Update`, and `UpdateAll`, to create or update
    a record in the database.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的数据库连接打开，我们就可以执行不同的数据库操作。首先，让我们创建一个名为 `SavePOI()` 的方法来保存数据库中的 POI 对象。`SQLiteConnection`
    类提供了如 **Insert**、`InsertOrReplace`、`InsertAll`、`Update` 和 `UpdateAll` 等方法，用于在数据库中创建或更新记录。
- en: We will use the `InsertOrReplace` method, as it is convenient for us. This method
    looks up for the same record in the database, updates it if it already exists,
    or else inserts a new one. For the `InsertOrReplace()` method to work, your table
    must have a primary key.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `InsertOrReplace` 方法，因为它对我们来说很方便。此方法在数据库中查找相同的记录，如果它已经存在，则更新它，否则插入一个新的记录。为了使
    `InsertOrReplace()` 方法正常工作，您的表必须有一个主键。
- en: 'Let''s add the following code snippet to the `DBManager` class in the `SavePOI`
    method:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `SavePOI` 方法中添加以下代码片段：
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Reading POI details from the database
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从数据库中读取 POI 详细信息
- en: 'The `POIApp` reads the list of POI objects while the device runs in the offline
    mode, or if the app has failed to download the POI list data from the server.
    Add the following `GetPOIListFromCache()` method to retrieve all the records from
    the database:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当设备处于离线模式运行，或者如果应用未能从服务器下载POI列表数据时，`POIApp`会读取POI对象的列表。将以下`GetPOIListFromCache()`方法添加到数据库中检索所有记录：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `GetPOIListFromCache` method returns the list of all POIs available in
    the database. The following method will help you if you are looking for a particular
    POI by its ID:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetPOIListFromCache`方法返回数据库中所有可用的POI列表。如果你正在通过ID查找特定的POI，以下方法将帮助你：'
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Deleting the POI data from the database
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从数据库中删除POI数据
- en: 'Like reading records from a database, we can either clear all of the database
    records or delete records one by one by the POI ID. Add the following methods
    to the `DBManager` class. They are straightforward and quite self-explanatory:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 就像从数据库中读取记录一样，我们可以通过POI ID逐个删除记录，或者清除所有数据库记录。将以下方法添加到`DBManager`类中。它们简单直接，相当直观：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now that we have defined all the methods to perform different database operations.
    The next step is to validate each method by writing unit test cases before using
    them in `POIApp`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了执行不同数据库操作的所有方法。下一步是在使用`POIApp`之前，通过编写单元测试用例来验证每个方法。
- en: Using the Xamarin.Android NUnitLite
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Xamarin.Android NUnitLite
- en: You may be familiar with a process called **test-driven development** (**TDD**).
    At a high-level, the approach proposes that you create automated unit test cases
    to test the features that your software will need to support, and use these test
    cases to drive the development and unit testing cycle.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能熟悉一个叫做**测试驱动开发**（**TDD**）的过程。从高层次来看，这种方法建议你创建自动化的单元测试用例来测试你的软件需要支持的功能，并使用这些测试用例来驱动开发和单元测试周期。
- en: This chapter will not cover the concepts behind test-driven development in detail,
    but we will introduce a feature delivered with Xamarin.Android, which supports
    teams using TDD. This feature is **NUnitLite**. NUnitLite is a lightweight, open
    source testing framework, which is based on the same ideas as **NUnit**. This
    has been designed to use minimal resources, making it ideal for embedded and mobile
    software development.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不会详细介绍测试驱动开发背后的概念，但我们将介绍Xamarin.Android提供的一个功能，该功能支持使用TDD的团队。这个功能是**NUnitLite**。NUnitLite是一个轻量级、开源的测试框架，其理念与**NUnit**相同。它被设计为使用最少的资源，非常适合嵌入式和移动软件开发。
- en: When working with NUnitLite, you create classes called test fixtures. These
    classes contain test methods that are used to test the various facets of the testing
    target; in our case, the `DBManager` class. To designate a class as a test fixture
    or a method as a test method, NUnitLite uses the .NET attributes. Once the test
    fixtures and test methods have been created, Xamarin.Android provides a user interface
    that allows the tests to be executed within the Android emulator or on a device.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 NUnitLite 时，你创建名为测试固定点的类。这些类包含用于测试测试目标的各个方面的测试方法；在我们的案例中，是`DBManager`类。为了将一个类指定为测试固定点或方法指定为测试方法，NUnitLite使用.NET属性。一旦创建了测试固定点和测试方法，Xamarin.Android提供了一个用户界面，允许在Android模拟器或设备上执行测试。
- en: To start using NUnitLite, we need to create a test project in the Solution pad
    that we have been working with.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 NUnitLite，我们需要在我们一直在使用的解决方案面板中创建一个测试项目。
- en: 'To create a test project, perform the following steps:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个测试项目，执行以下步骤：
- en: Select the `POIApp` solution from the **Solution** pad in Xamarin Studio.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Xamarin Studio的**解决方案**面板中选择`POIApp`解决方案。
- en: Right-click on it and select **Add New Project**.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击并选择**添加新项目**。
- en: On the left-hand side of the **New Project** dialog box, go to **C#** | **Android**.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**新项目**对话框的左侧，转到**C#** | **Android**。
- en: In the template list, in the middle of the dialog box, select the **Android
    Unit Test** project.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在对话框的模板列表中，选择对话框中间的**Android单元测试**项目。
- en: Enter `POITestApp` for the name and click on **OK**. The new unit test project
    is created and added to the `POIApp` solution.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`POITestApp`作为名称，然后点击**确定**。新的单元测试项目被创建并添加到`POIApp`解决方案中。
- en: Go to the **Options** dialog box for the new project, and set the **Package**
    name to `POITestApp`, and verify that the **Target framework** is set to the latest
    available Android SDK framework.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往新项目的**选项**对话框，将**包名**设置为`POITestApp`，并确认**目标框架**设置为最新的可用Android SDK框架。
- en: 'You will notice that the new unit test project has the following files:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到新的单元测试项目有以下文件：
- en: '`MainActivity.cs`: This activity inherits from `TestSuiteActivity` and provides
    a test suite user interface when we run our tests. Basically, it allows us to
    run our tests and see the results.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MainActivity.cs`：此活动继承自 `TestSuiteActivity`，并在我们运行测试时提供测试套件用户界面。基本上，它允许我们运行测试并查看结果。'
- en: '`TestsSample.cs`: This class acts as a test fixture and allows us to add test
    methods that will exercise the features provided by `DBManager`.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TestsSample.cs`：此类充当测试固定装置，并允许我们添加测试方法，这些方法将测试 `DBManager` 提供的功能。'
- en: Now, we need to create the test methods in order to exercise the features of
    our database operation performed by the `DBManager` class.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建测试方法来测试 `DBManager` 类执行的数据操作功能。
- en: Setting up for tests
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备测试
- en: 'NUnitLite provides a place to execute any initialization code that may be required
    by the tests. In our case, we need to create an instance of the `DBManager` class,
    which the test methods will later interact with. The `Setup()` method is the perfect
    place since it will be called before each test. The following will steps help
    you to set up a new test case in Xamarin Studio:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: NUnitLite 提供了一个执行可能需要的任何初始化代码的地方。在我们的情况下，我们需要创建 `DBManager` 类的实例，测试方法稍后会与其交互。`Setup()`
    方法是完美的选择，因为它将在每个测试之前被调用。以下步骤将帮助你在 Xamarin Studio 中设置一个新的测试用例：
- en: Rename the `TestsSample.cs` file `POITestFixture.cs`. Rename the corresponding
    class inside the file as well.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `TestsSample.cs` 文件重命名为 `POITestFixture.cs`。同时，将文件内的相应类也重命名。
- en: In `POITestApp`, select **References**, right-click on it, and select **Edit
    References**. Select the **Projects** tab in the **Edit References** dialog box,
    check on the `POIApp` project, and click on **OK**. `POITestApp` needs to reference
    `POIApp` so that it can work with the `DBManager` class.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `POITestApp` 中，选择 **引用**，右键单击它，然后选择 **编辑引用**。在 **编辑引用** 对话框中，选择 **项目** 选项卡，勾选
    `POIApp` 项目，然后单击 **确定**。`POITestApp` 需要引用 `POIApp`，以便它可以与 `DBManager` 类一起工作。
- en: Tip
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Some version of Xamarin Studio have a bug, where the project references are
    not linked even after adding them to a test project. In such cases, you need go
    to the .NET Assembly tab in the **Edit References** dialog box and browse manually
    to the `POIApp/bin/Debug/POIApp.dll` file.
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一些版本的 Xamarin Studio 存在一个错误，即使将项目引用添加到测试项目中，引用也不会链接。在这种情况下，您需要转到 **编辑引用** 对话框中的
    .NET 程序集选项卡，并手动浏览到 `POIApp/bin/Debug/POIApp.dll` 文件。
- en: Open the `POITestFixture` class and delete all the other methods except `Setup()`.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `POITestFixture` 类并删除除 `Setup()` 之外的所有其他方法。
- en: 'In the `Setup()` method, call the `CreateTable()` method from the `DBManager`
    class:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Setup()` 方法中，从 `DBManager` 类调用 `CreateTable()` 方法：
- en: '[PRE11]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Creating the test methods
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建测试方法
- en: 'Now the real work begins; we need to create test methods to test each significant
    scenario. In the case of the data service, we need to be sure that we cover the
    following topics:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在真正的任务开始了；我们需要创建测试方法来测试每个重要的场景。在数据服务的情况下，我们需要确保我们涵盖了以下主题：
- en: Creating a new POI
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的 POI
- en: Updating an existing POI
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新现有的 POI
- en: Deleting an existing POI
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除现有的 POI
- en: There are many more scenarios we could choose to test, but the preceding small
    set should help you verify that the basics of our database logic are functioning.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择测试的情景还有很多，但前面的小集合应该有助于验证我们数据库逻辑的基本功能。
- en: The CreatePOI test
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CreatePOI 测试
- en: 'The first test method we will start with is `CreatePOI()` and, as the name
    implies, we will test the process of creating and saving a new POI. To accomplish
    this, we need to perform the following steps:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先开始的第一个测试方法是 `CreatePOI()`，正如其名称所暗示的，我们将测试创建和保存新 POI 的过程。为了完成这个任务，我们需要执行以下步骤：
- en: Create a new instance of `PointOfInterest` and fill out some attributes.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `PointOfInterest` 的新实例并填写一些属性。
- en: Call the `SavePOI()` method on the `DBManager` class.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `DBManager` 类上调用 `SavePOI()` 方法。
- en: The `save` method returns an integer, indicating the number of records updated.
    Ensure that it returns the value `1`.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`save` 方法返回一个整数，表示更新的记录数。确保它返回值 `1`。'
- en: Call `GetPOI()` to retrieve the POI, based on the saved ID.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据保存的 ID 调用 `GetPOI()` 来检索 POI。
- en: Use the `Assert` class to ascertain that the POI was retrieved (the reference
    is not null) and the name of the POI is what it was expected to be.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Assert` 类来确认检索到的 POI（引用不是 null）以及 POI 的名称符合预期。
- en: 'The following code shows an implementation of `CreatePOI()`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了 `CreatePOI()` 的实现：
- en: '[PRE12]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The DeletePOI test
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除 POI 测试
- en: Next, we will implement `DeletePOI()`. Again, we want `DeletePOI()` to be independent
    of other tests, so we will first need to create a POI which will be deleted later.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现`DeletePOI()`。同样，我们希望`DeletePOI()`独立于其他测试，因此我们首先需要创建一个稍后将被删除的POI。
- en: 'On calling `DeletePOI()`, the following steps will be performed:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`DeletePOI()`时，将执行以下步骤：
- en: Create a new instance of `PointOfInterest` and fill out some attributes.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`PointOfInterest`实例并填写一些属性。
- en: Call the `SavePOI()` method on the `DBManager` class.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DBManager`类上调用`SavePOI()`方法。
- en: '`GetPOI()` to retrieve the POI, based on the saved ID.'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`GetPOI()`根据保存的ID检索POI。
- en: '`DeletePOI()` to delete the POI file and remove it from the database.'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`DeletePOI()`来删除POI文件并将其从数据库中删除。
- en: '`GetPOI()` to retrieve the POI, based on the saved ID.'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`GetPOI()`根据保存的ID检索POI。
- en: Use the `Assert` class to ensure that the POI is not found (the reference is
    null).
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Assert`类来确保找不到POI（引用为null）。
- en: 'The following code shows an implementation of `DeletePOI()`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了`DeletePOI()`的实现：
- en: '[PRE13]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Additionally, we will implement `ClearCache()` to verify that the call to `ClearPOICache()`
    clears all the database records. We will perform the following steps will be performed
    in the `ClearCache` test method:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将实现`ClearCache()`以验证对`ClearPOICache()`的调用是否清除了所有数据库记录。以下步骤将在`ClearCache`测试方法中执行：
- en: Call `ClearPOICache()` on the `DBManager` class to delete all records from the
    database.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DBManager`类上调用`ClearPOICache()`以从数据库中删除所有记录。
- en: Call `GetPOIListFromCache` on the `DBManager` class to get a list of records
    from the database.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DBManager`类上调用`GetPOIListFromCache`以从数据库中获取记录列表。
- en: Use the `Assert` class to ensure that the number of records fetched from the
    server is `0`.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Assert`类来确保从服务器检索的记录数为`0`。
- en: 'The following code shows an implementation of `ClearCache()`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了`ClearCache()`的实现：
- en: '[PRE14]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Executing the tests
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行测试
- en: 'Now that the tests have been developed, we are ready to execute them. To do
    this, we simply run the test app using the Android emulator or a physical device.
    To execute the tests in an emulator, perform the following steps:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试已经开发完毕，我们准备执行它们。为此，我们只需使用Android模拟器或物理设备运行测试应用。要在模拟器中执行测试，请执行以下步骤：
- en: Run `POITestApp` using the Android emulator. Note that `POITestApp` is not set
    as the startup project, so you will need to select the project when you select
    **Run**. You can make `POITestApp` the startup project by selecting it, right-clicking
    on it, and choosing **Set as Startup Project**. Once `POITestApp` is running,
    you should see the following screen when the app has been deployed and started:![](img/U0zngXrn.jpg)
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Android模拟器运行`POITestApp`。请注意，`POITestApp`没有被设置为启动项目，所以当你选择**运行**时，你需要选择项目。你可以通过选择它，右键单击它，并选择**设置为启动项目**来将`POITestApp`设置为启动项目。一旦`POITestApp`开始运行，你应该会看到以下屏幕，当应用已部署并启动时：![](img/U0zngXrn.jpg)
- en: Execute the tests by clicking on the **Run Tests** label. You should see a green
    message label, indicating that all the tests have passed.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**运行测试**标签来执行测试。你应该会看到一个绿色的消息标签，表示所有测试都已通过。
- en: If the test case fails, the message will be shown in red, and you can further
    drill down into the tests to see the failure details.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果测试用例失败，消息将以红色显示，你可以进一步深入测试以查看失败详情。
- en: So far, we have created the `DBManager` class and have a suite of automated
    tests to test the CRUD methods. It is now time to focus on filling in the logic
    so that `POIApp` can save and fetch the data from the database.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了`DBManager`类，并有一套自动化测试来测试CRUD方法。现在是时候专注于填充逻辑，以便`POIApp`可以从数据库中保存和检索数据。
- en: NUnitLite is a great framework to implement the unit testing strategy for the
    Android application development, but it's not all about testing. You need to implement
    some sort of UI automation testing framework to test most of your application
    components, including the user interfaces.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: NUnitLite是一个优秀的框架，用于实现Android应用开发的单元测试策略，但它不仅仅关于测试。你需要实现某种UI自动化测试框架来测试大多数应用组件，包括用户界面。
- en: Xamarin brings yet another platform; Xamarin Test Cloud makes it possible to
    test mobile apps written in any language on a collection of real devices from
    around the world. You can write your test scripts using the Xamarin testing framework
    and automate your app testing from CI systems. This book doesn't cover the UI
    automation frameworks and Xamarin Test Cloud service. You can visit the official
    [http://xamarin.com/](http://xamarin.com/) website for more information.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin带来了另一个平台；Xamarin Test Cloud使得可以在全球各地的真实设备上测试用任何语言编写的移动应用。您可以使用Xamarin测试框架编写测试脚本，并从CI系统中自动化应用测试。本书不涵盖UI自动化框架和Xamarin
    Test Cloud服务。您可以访问官方[http://xamarin.com/](http://xamarin.com/)网站获取更多信息。
- en: Implementing the caching logic to POIApp
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现缓存逻辑到POIApp
- en: 'The `DBManager` class is now tested and ready to use straightaway on `POIApp`.
    The `POIApp` will save the POI records when the download is completed, and the
    list will be retrieved later when the app is unable to fetch the updated list
    from the server. Perform the following steps to integrate the `DBManager` class
    with `POIApp`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`DBManager`类现在经过测试并可以直接在`POIApp`中使用。当下载完成时，`POIApp`将保存POI记录，当应用无法从服务器获取更新列表时，稍后将从列表中检索。执行以下步骤以将`DBManager`类集成到`POIApp`中：'
- en: 'Call the `CreateTable()` method on the `POIListActivity` class to initiate
    the database:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`POIListActivity`类上调用`CreateTable()`方法以初始化数据库：
- en: '[PRE15]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Open the `POIListFragment` class and go to the `DownloadPoisListAsync()` method.
    We have used this method to download the POI list from the server. The following
    updates are required here:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`POIListFragment`类并进入`DownloadPoisListAsync()`方法。我们已使用此方法从服务器下载POI列表。以下是需要在此处进行的更新：
- en: Clear the database cache when the POI downloads from the server are successful.
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当从服务器成功下载POI时清除数据库缓存。
- en: Save the newly fetched POI data to the database.
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新获取的POI数据保存到数据库中。
- en: When a device is not connected to the network, return the cached data from the
    database.
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当设备未连接到网络时，从数据库返回缓存数据。
- en: 'The following code snippet depicts the the updated version of the `DownloadPoisListAsync()`
    method:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了更新后的`DownloadPoisListAsync()`方法：
- en: '[PRE16]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding code block, we save all of the POI list data received from
    the server. However, when a user edits and saves any of the POI data, we need
    to update the local database for that POI.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们保存了从服务器接收到的所有POI列表数据。然而，当用户编辑并保存任何POI数据时，我们需要更新该POI的本地数据库。
- en: 'To do this, let''s call the `SavePOI()` method from the `POIDetailFragment`
    class in the `CreateOrUpdatePOIAsync()` method:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，让我们在`CreateOrUpdatePOIAsync()`方法中从`POIDetailFragment`类调用`SavePOI()`方法：
- en: '[PRE17]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When the POI record is deleted from the server in the `POIDetailFragment` class,
    in the `DeletePOIAsync()` method we need to call the `DeletePOI()` method to delete
    the same POI from the local device database.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在`POIDetailFragment`类中从服务器删除POI记录时，在`DeletePOIAsync()`方法中我们需要调用`DeletePOI()`方法来从本地设备数据库中删除相同的POI。
- en: 'The following code snippet depicts the updated version of the `DeletePOIAsync()`
    method:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了更新后的`DeletePOIAsync()`方法：
- en: '[PRE18]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now we have implemented the database logic for the `POIApp` to work offline.
    Run the app; when connected to the network, it will download and cache the POI
    list. Now restart the application while the device is offline and notice that
    the same old cached POI list is presented on the screen.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了`POIApp`的离线数据库逻辑。运行应用；当连接到网络时，它将下载并缓存POI列表。现在在设备离线状态下重新启动应用，注意屏幕上显示的是相同的旧缓存POI列表。
- en: Summary
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we used SQLite.ORM to save the POI records to the database
    and created a series of unit tests to verify that the database operations were
    functioning well.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用了SQLite.ORM将POI记录保存到数据库中，并创建了一系列单元测试来验证数据库操作是否正常工作。
- en: In the next chapter, we will continue integrating with device capabilities by
    adding camera support to capture and save the POI image.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过添加相机支持来捕获和保存POI图像，继续集成设备功能。
