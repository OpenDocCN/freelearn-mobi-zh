- en: Chapter 4. Creating Build Variants
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 创建构建变体
- en: 'When you are developing an app, you usually have a few different versions.
    The most common scenario is that you have a staging version that is used to manually
    test the app and assure its quality, and a production version. These versions
    usually have different settings. For example, the URL of the staging API can be
    different from the production API. In addition, you may have a free basic version
    of your app, and a paid version that has some extra features. In that case, you
    are already dealing with four different versions: staging free, staging paid,
    production free, and production paid. Having different configurations for every
    version can easily get very complicated.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在开发一个应用时，你通常有几个不同的版本。最常见的情况是，你有一个用于手动测试应用并确保其质量的预发布版本，以及一个生产版本。这些版本通常有不同的设置。例如，预发布API的URL可能不同于生产API。此外，你可能有一个免费的基本版本的应用，以及一个具有一些额外功能的付费版本。在这种情况下，你已经在处理四个不同的版本：预发布免费、预发布付费、生产免费和生产付费。为每个版本设置不同的配置可能会变得非常复杂。
- en: Gradle has some convenient and extensible concepts to address this common issue.
    We already mentioned the `debug` and `release` build types that are created by
    Android Studio for every new project. There is another concept called product
    flavors, which adds even more possibilities for managing several versions of an
    app or library. Build types and product flavors are always combined, and make
    it easy to handle the scenario with free and paid versions of staging and production
    apps. The result of combining a build type and a product flavor is called a build
    variant.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle有一些方便且可扩展的概念来解决这个常见问题。我们之前已经提到了Android Studio为每个新项目创建的`debug`和`release`构建类型。还有一个叫做产品风味的概念，它为管理应用或库的多个版本提供了更多的可能性。构建类型和产品风味总是结合使用，使得处理预发布和发布应用免费和付费版本的情况变得容易。将构建类型和产品风味结合的结果称为构建变体。
- en: We will start this chapter by looking at build types, what they can do to make
    a developer's life easier, and how to make the most of them. Then, we will discuss
    the difference between build types and product flavors and how both are used.
    We will also take a look at signing configurations, which is a necessity to publish
    apps, and how we can set a different signing configuration for every build variant.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个章节开始，先看看构建类型，它们如何让开发者的生活变得更轻松，以及如何充分利用它们。然后，我们将讨论构建类型和产品风味的区别以及它们的使用方法。我们还将探讨签名配置，这是发布应用所必需的，以及我们如何为每个构建变体设置不同的签名配置。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Build types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建类型
- en: Product flavors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品风味
- en: Build variants
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建变体
- en: Signing configurations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 签名配置
- en: Build types
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建类型
- en: 'In the Android plugin for Gradle, a build type is used to define how an app
    or library should be built. Every build type can specify whether the debug symbols
    should be included, what the application ID has to be, whether unused resources
    should be removed, and so on. You can define build types within a `buildTypes`
    block. This is what a standard `buildTypes` block looks like in a build file created
    by Android Studio:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在Gradle的Android插件中，构建类型用于定义应用或库应该如何构建。每个构建类型都可以指定是否包含调试符号，应用程序ID必须是什么，是否应该删除未使用的资源，等等。你可以在`buildTypes`块内定义构建类型。这是由Android
    Studio创建的构建文件中的标准`buildTypes`块的样子：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The default `build.gradle` file for a new module configures a build type called
    `release`. This build type does nothing more than disabling removal of unused
    resources (by setting `minifyEnabled` to `false`) and defining the location of
    the default ProGuard configuration file. This is to make it straightforward for
    developers to start using ProGuard for their production build, whenever they are
    ready for it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 新模块的默认`build.gradle`文件配置了一个名为`release`的构建类型。这个构建类型除了禁用删除未使用资源（通过将`minifyEnabled`设置为`false`）和定义默认ProGuard配置文件的位置之外，没有做更多的事情。这是为了让开发者能够方便地开始使用ProGuard进行他们的生产构建，无论何时他们准备好了。
- en: The `release` build type is not the only build type that is already created
    for your project, though. By default, every module has a `debug` build type. It
    is set to sensible defaults, but you can change its configuration by including
    it in the `buildTypes` block, and overriding the properties you want to change.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`release`构建类型不是为你的项目预先创建的唯一构建类型。默认情况下，每个模块都有一个`debug`构建类型。它被设置为合理的默认值，但你可以通过将其包含在`buildTypes`块中并覆盖你想要更改的属性来更改其配置。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `debug` build type has its own default settings to make it easy to debug.
    When you create your own build type, different defaults apply. For example, the
    `debuggable` property is set to `true` for the `debug` build type, but is set
    to `false` in any other build type you create.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`debug`构建类型有自己的默认设置，以便于调试。当您创建自己的构建类型时，将应用不同的默认设置。例如，`debuggable`属性对于`debug`构建类型设置为`true`，但在您创建的任何其他构建类型中都设置为`false`。'
- en: Creating build types
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建构建类型
- en: 'When the default settings are not enough, it is easy to create your own custom
    build types. All that is required for a new build type is a new object within
    the `buildTypes` block. Here is an example of a custom build type called `staging`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当默认设置不足时，创建自己的自定义构建类型很容易。对于新的构建类型，只需要在`buildTypes`块内创建一个新的对象。以下是一个名为`staging`的自定义构建类型的示例：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `staging` build type defines a new suffix for the application ID, making
    it different from the application ID of the debug and release versions. Assuming
    you have the default build configuration, plus the staging build type, the application
    IDs for the build types look like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`staging`构建类型为应用程序ID定义了一个新的后缀，使其与调试和发布版本的应用程序ID不同。假设您有默认的构建配置，以及`staging`构建类型，构建类型的应用程序ID看起来像这样：'
- en: 'Debug: `com.package`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试：`com.package`
- en: 'Release: `com.package`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布：`com.package`
- en: 'Staging: `com.package.staging`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阶段配置：`com.package.staging`
- en: This means that you will be able to install both the staging version and the
    release version on the same device without causing any conflicts. The `staging`
    build type also has a version name suffix, which is useful to differentiate several
    versions of the app on the same device. The `buildConfigField` property defines
    a custom URL for the API, using a build configuration field, as we saw in [Chapter
    2](ch02.html "Chapter 2. Basic Build Customization"), *Basic Build Customization*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着您可以在同一设备上安装预发布版本和发布版本，而不会引起任何冲突。`staging`构建类型还有一个版本名称后缀，这有助于在同一设备上区分应用程序的多个版本。`buildConfigField`属性定义了一个用于API的自定义URL，使用构建配置字段，正如我们在[第2章](ch02.html
    "第2章。基本构建自定义")中看到的，*基本构建自定义*。
- en: 'You do not always have to start from scratch when creating a new build type.
    It is possible to initialize a build type that copies the properties of another
    build type:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新的构建类型时，您不必总是从头开始。可以初始化一个构建类型，该类型复制另一个构建类型的属性：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `initWith()` method creates a new build type and copies all properties from
    an existing build type to the newly created one. It is possible to override properties
    or define extra properties by simply defining them in the new build type object.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`initWith()`方法创建一个新的构建类型，并将所有属性从现有构建类型复制到新创建的构建类型中。您可以通过在新的构建类型对象中简单地定义它们来覆盖属性或定义额外的属性。'
- en: Source sets
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 源集
- en: When you create a new build type, Gradle also creates a new source set. By default,
    the source set directory is assumed to have the same name as the build type. The
    directory is not automatically created when you define a new build type, though.
    You have to create the source set directory yourself before you can use custom
    source code and resources for a build type.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建一个新的构建类型时，Gradle也会创建一个新的源集。默认情况下，源集目录假定与构建类型具有相同的名称。尽管如此，当您定义一个新的构建类型时，目录不会自动创建。您必须自己创建源集目录，然后才能为构建类型使用自定义源代码和资源。
- en: 'This is what the directory structure can look like with the standard `debug`
    and `release` build type, plus an extra staging build type:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是标准`debug`和`release`构建类型，加上额外的预发布构建类型的目录结构可能看起来像这样：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: These source sets open up a world of possibilities. For example, you can override
    certain properties for specific build types, add custom code to certain build
    types, and add customized layouts or strings to different build types.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些源集打开了一个无限可能的世界。例如，您可以针对特定的构建类型覆盖某些属性，为某些构建类型添加自定义代码，以及为不同的构建类型添加自定义布局或字符串。
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When adding Java classes to build types, it is important to keep in mind that
    this process is mutually exclusive. This means that if you add class `CustomLogic.java`
    to the staging source set, you will be able to add the same class to the debug
    and release source sets, but not to the main source set. The class would then
    be defined twice, throwing an exception when you try to build.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在向构建类型添加Java类时，重要的是要注意这个过程是互斥的。这意味着如果您将`CustomLogic.java`类添加到预发布源集，您将能够将该类添加到调试和发布源集，但不能添加到主源集。类将被定义两次，当您尝试构建时将抛出异常。
- en: Resources are handled in a special way when using different source sets. Drawables
    and layout files will completely override the resources with the same name in
    the main source set, but files in the `values` directory (such as `strings.xml`)
    will not. Gradle will instead merge the content of the build type resources with
    the main resources.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用不同的源集时，资源将以特殊方式处理。可绘制资源和布局文件将完全覆盖主源集中具有相同名称的资源，但`values`目录中的文件（如`strings.xml`）则不会。Gradle将合并构建类型资源的内容与主资源。
- en: 'For example, if you have a `strings.xml` file in the main source set that looks
    like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您在主源集中有一个`strings.xml`文件，如下所示：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And if you have a `strings.xml` file in the `staging` build type source set
    like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在`staging`构建类型源集中有一个`strings.xml`文件，如下所示：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, the merged `strings.xml` file will look like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，合并后的`strings.xml`文件将看起来像这样：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When you build a build type that is not staging, the final `strings.xml` file
    will just be the `strings.xml` file from the main source set.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当您构建非`staging`的构建类型时，最终的`strings.xml`文件将只是主源集中的`strings.xml`文件。
- en: The same is true for manifest files. If you create a manifest file for a build
    type, you do not need to copy the entire manifest file from the main source set;
    you can just add the tags you need. The Android plugin will merge the manifests
    together.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于清单文件也是如此。如果您为构建类型创建了一个清单文件，您不需要从主源集中复制整个清单文件；您只需添加所需的标签即可。Android插件将合并清单。
- en: We will talk about merging in more detail later in this chapter.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的后面部分更详细地讨论合并。
- en: Dependencies
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖项
- en: 'Every build type can have its own dependencies. Gradle automatically creates
    new dependency configurations for every build type. If you want to add a logging
    framework only for `debug` builds, for example, you can do it like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 每个构建类型都可以有自己的依赖项。Gradle会自动为每个构建类型创建新的依赖配置。例如，如果您只想为`debug`构建添加日志框架，您可以这样做：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can combine any build type with any dependency configuration in this manner.
    This gives you the possibility to get very specific with dependencies.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用这种方式将任何构建类型与任何依赖配置组合在一起。这使您能够对依赖项进行非常具体的配置。
- en: Product flavors
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产品风味
- en: As opposed to build types, which are used to configure several different builds
    of the same app or library, product flavors are used to create different versions
    of the same app. The typical example is an app that has a free and a paid version.
    Another common scenario is an agency that builds apps that have the same functionality
    for several clients, where only the branding changes. This is very common in the
    taxi industry or with banking apps, where one company creates an app that can
    be reused for all clients in the same category. The only things that change are
    the main colors, the logo, and the URL of the backend. Product flavors greatly
    simplify the process of having different versions of an app based on the same
    code.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 与用于配置同一应用或库的多个不同构建的构建类型不同，产品风味用于创建同一应用的不同版本。一个典型的例子是具有免费版和付费版的应用。另一个常见的场景是，一家机构为几个客户构建具有相同功能的应用，其中只有品牌发生变化。这在出租车行业或银行应用中非常常见，其中一家公司创建的应用可以用于同一类别的所有客户。唯一改变的是主要颜色、标志和后端URL。产品风味极大地简化了基于相同代码的不同版本应用的过程。
- en: If you are unsure whether you need a new build type, or a new product flavor,
    you should ask yourself if you want to create a new build of the same app for
    internal use, or a new APK to publish to Google Play. If you need an entirely
    new app that needs to be published separately from what you already have, then
    product flavors are the way to go. Otherwise, you should stick to using build
    types.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不确定是否需要新的构建类型或新的产品风味，您应该问自己是否想要为内部使用创建同一应用的新的构建版本，或者为发布到Google Play创建新的APK。如果您需要完全新的应用，该应用需要独立于您已有的内容发布，那么产品风味就是您应该选择的方式。否则，您应该坚持使用构建类型。
- en: Creating product flavors
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建产品风味
- en: 'Creating product flavors is very similar to creating build types. You can create
    a new product flavor by adding it to the `productFlavor` block, like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 创建产品风味与创建构建类型非常相似。您可以通过将其添加到`productFlavor`块中来创建一个新的产品风味，如下所示：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Product flavors have different properties than build types. That is because
    product flavors are objects of the `ProductFlavor` class, just like the `defaultConfig`
    object that is present in all build scripts. This means that `defaultConfig` and
    all your product flavors share the same properties.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 产品香味与构建类型具有不同的属性。这是因为产品香味是 `ProductFlavor` 类的对象，就像所有构建脚本中存在的 `defaultConfig`
    对象一样。这意味着 `defaultConfig` 和你的所有产品香味共享相同的属性。
- en: Source sets
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 源集
- en: Just like with build types, product flavors can have their own source set directories.
    Creating a folder for a specific flavor is as easy as creating a folder with the
    flavor name. You can even go one step further and create a folder specifically
    for a combination of a certain build type and flavor. The name of the folder would
    then be the flavor name followed by the build type name. For example, if you want
    to have a different app icon specifically for the release version of the blue
    flavor, the folder would have to be called `blueRelease`. The components of the
    combined folder will have a higher priority than the components from both the
    build type folder and the product flavor folder.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 就像构建类型一样，产品香味可以有自己的源集目录。为特定香味创建一个文件夹就像创建一个带有香味名称的文件夹一样简单。你甚至可以更进一步，为特定构建类型和香味的组合创建一个文件夹。文件夹的名称将是香味名称后跟构建类型名称。例如，如果你想为蓝色香味的发布版本有特定的应用程序图标，文件夹名称必须是
    `blueRelease`。组合文件夹的组件将比构建类型文件夹和产品香味文件夹的组件具有更高的优先级。
- en: Multiflavor variants
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多香味变体
- en: 'In some cases, you might want to take it further and create combinations of
    product flavors. For example, client A and client B might each want free and paid
    versions of their app, which is based on the same code base, but has different
    branding. Creating four different flavors would mean having several duplicate
    settings, so that is not the way to go. Combining flavors in an efficient way
    is possible using flavor dimensions, like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能希望更进一步，创建产品香味的组合。例如，客户A和客户B可能各自希望他们的应用程序有免费和付费版本，这些应用程序基于相同的代码库，但有不同的品牌。创建四种不同的香味意味着会有几个重复的设置，所以这不是正确的方法。使用香味维度以高效的方式组合香味是可能的，如下所示：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As soon as you add the flavor dimensions, Gradle expects you to specify a dimension
    for each flavor. If you forget, you will get a build error with a message explaining
    the issue. The `flavorDimensions` array defines the dimensions, and the order
    of the dimensions is very important. When combining two flavors, they might have
    defined the same properties or resources. In that case, the order of the flavor
    dimensions array determines which flavor configuration overrides the other. In
    the earlier example, the color dimension overrides the price dimension. The order
    also determines the name of the build variant.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你添加了香味维度，Gradle 就期望你为每个香味指定一个维度。如果你忘记了，你会得到一个带有解释问题的构建错误。`flavorDimensions`
    数组定义了维度，维度的顺序非常重要。当组合两个香味时，它们可能已经定义了相同的属性或资源。在这种情况下，香味维度数组的顺序决定了哪个香味配置覆盖了另一个。在早期示例中，颜色维度覆盖了价格维度。顺序还决定了构建变体的名称。在早期示例中，颜色维度覆盖了价格维度。顺序还决定了构建变体的名称。
- en: 'Assuming the default build configuration with the debug and release build types,
    defining the flavors as shown in the previous example will generate all of these
    build variants:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 假设默认的构建配置与调试和发布构建类型，按照前一个示例定义的香味将生成所有这些构建变体：
- en: '`blueFreeDebug` and `blueFreeRelease`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blueFreeDebug` 和 `blueFreeRelease`'
- en: '`bluePaidDebug` and `bluePaidRelease`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bluePaidDebug` 和 `bluePaidRelease`'
- en: '`redFreeDebug` and `redFreeRelease`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redFreeDebug` 和 `redFreeRelease`'
- en: '`redPaidDebug` and `redPaidRelease`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redPaidDebug` 和 `redPaidRelease`'
- en: Build variants
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建变体
- en: 'Build variants are simply the result of combining build types and product flavors.
    Whenever you create a build type or product flavor, new variants are created as
    well. For example, if you have the standard `debug` and `release` build types,
    and you create a red and blue product flavor, the following build variants will
    be generated:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 构建变体仅仅是构建类型和产品香味的组合结果。每次你创建一个构建类型或产品香味时，也会创建新的变体。例如，如果你有标准的 `debug` 和 `release`
    构建类型，并且创建了一个红色和蓝色产品香味，以下构建变体将被生成：
- en: '![Build variants](img/B01061_04_01.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![构建变体](img/B01061_04_01.jpg)'
- en: This is a screenshot of the **Build Variants** tool window in Android Studio.
    You can find the tool window in the bottom-left corner of the editor, or open
    it from **View** | **Tool Windows** | **Build Variants**. This tool window lists
    all the build variants, but also allows you to switch between them. Changing the
    selected build variant here will affect which variant runs when the **Run** button
    is clicked.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Android Studio中**构建变体**工具窗口的截图。你可以在编辑器的左下角找到该工具窗口，或者从**视图** | **工具窗口** | **构建变体**打开它。此工具窗口列出了所有构建变体，同时也允许你在它们之间切换。在此处更改选定的构建变体将影响点击**运行**按钮时运行的变体。
- en: If you have no product flavors, variants will simply consist of build types.
    It is impossible to not have any build types. Even if you do not define any build
    types yourself, the Android plugin for Gradle always creates a debug build type
    for your app or library.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有产品风味，变体将仅由构建类型组成。不可能没有任何构建类型。即使你自己没有定义任何构建类型，Gradle的Android插件也会为你的应用或库创建一个调试构建类型。
- en: Tasks
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务
- en: 'The Android plugin for Gradle will create tasks for every build variant you
    configure. A new Android app has `debug` and `release` build types by default,
    so you already have `assembleDebug` and `assembleRelease` to build both APKs separately,
    and `assemble` to create both with a single command. When you add a new build
    type, a new task will be created as well. As soon as you start adding flavors
    into the mix, a whole new range of tasks is created, because the tasks for every
    build type are combined with tasks for every product flavor. This means that for
    a simple setup with one build type and one flavor, you already have three tasks
    to build all the variants:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle的Android插件将为你配置的每个构建变体创建任务。新的Android应用默认有`debug`和`release`构建类型，因此你已经有了`assembleDebug`和`assembleRelease`来分别构建APK，以及`assemble`来通过单个命令创建它们。当你添加新的构建类型时，也会创建新的任务。一旦你开始添加风味，就会创建一系列全新的任务，因为每个构建类型的任务都会与每个产品风味的任务相结合。这意味着对于只有一个构建类型和一个风味的简单设置，你已经有了三个任务来构建所有变体：
- en: '`assembleBlue` uses the blue flavor configuration and assembles both `BlueRelease`
    and `BlueDebug`.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assembleBlue` 使用蓝色风味配置，并组装`BlueRelease`和`BlueDebug`。'
- en: '`assembleDebug` uses the debug build type configuration and assembles a debug
    version for every product flavor.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assembleDebug` 使用调试构建类型配置，并为每个产品风味组装一个调试版本。'
- en: '`assembleBlueDebug` combines the flavor configuration with the build type configuration,
    and the flavor settings override the build type settings.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assembleBlueDebug` 将风味配置与构建类型配置相结合，并且风味设置会覆盖构建类型设置。'
- en: New tasks are created for every build type, for every product flavor, and for
    every combination of build type and product flavor.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个构建类型、每个产品风味以及每个构建类型和产品风味的组合创建新任务。
- en: Source sets
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 源集
- en: Build variants that are a combination of a build type and one or more product
    flavors can also have their own source set directories. For example, the variant
    created from the `debug` build type, the blue flavor and the free flavor, can
    have its own source set in `src/blueFreeDebug/java/`. It is possible to override
    the location for the directory using the `sourceSets` block, which we saw in [Chapter
    1](ch01.html "Chapter 1. Getting Started with Gradle and Android Studio"), *Getting
    Started with Gradle and Android Studio*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 组合了构建类型和一个或多个产品风味的构建变体也可以有自己的源集目录。例如，由`debug`构建类型、蓝色风味和免费风味创建的变体可以在`src/blueFreeDebug/java/`中拥有自己的源集。可以使用我们在[第1章](ch01.html
    "第1章。使用Gradle和Android Studio入门")中看到的`sourceSets`块来覆盖目录的位置，即*使用Gradle和Android Studio入门*。
- en: Resource and manifest merging
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源和清单合并
- en: The introduction of source sets adds extra complexity to the build process.
    The Android plugin for Gradle needs to merge the main source set and the build
    type source sets together before packaging the app. In addition, library projects
    can also provide extra resources, and those need to be merged in as well. The
    same goes for manifest files. You may need extra Android permissions in the debug
    variant of your app to store log files, for example. You do not want to declare
    this permission on the main source set because that might scare potential users.
    Instead, you would add an extra manifest file in the `debug` build type source
    set to declare the extra permission.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 源集的引入给构建过程增加了额外的复杂性。Gradle的Android插件需要在打包应用程序之前将主源集和构建类型源集合并在一起。此外，库项目也可以提供额外的资源，这些资源也需要合并。清单文件也是如此。例如，你可能需要在应用程序的调试变体中声明额外的Android权限来存储日志文件。你不想在主源集上声明这个权限，因为这可能会吓到潜在的用户。相反，你会在`debug`构建类型源集中添加一个额外的清单文件来声明额外的权限。
- en: 'The priority order for resources and manifests looks like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 资源和清单的优先级顺序如下：
- en: '![Resource and manifest merging](img/B01061_04_05.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![资源清单合并](img/B01061_04_05.jpg)'
- en: If a resource is declared in a flavor and in the main source set, the one from
    the flavor will be given a higher priority. In this case, the resource in the
    flavor source set will be packaged, and not the one in the main source set. Resources
    declared in library projects always have the lowest priority.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个资源在风味和主源集中声明，那么来自风味的资源将具有更高的优先级。在这种情况下，风味源集中的资源将被打包，而不是主源集中的资源。在库项目中声明的资源始终具有最低优先级。
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is a lot more to learn about resource and manifest merging. It is an incredibly
    complicated subject, and if we were to explain its details, we would need to dedicate
    an entire chapter to it. Instead, if you want to learn more, it is a good idea
    to read the official documentation on the topic at [http://tools.android.com/tech-docs/new-build-system/user-guide/manifest-merger](http://tools.android.com/tech-docs/new-build-system/user-guide/manifest-merger).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 关于资源清单合并，还有很多东西要学习。这是一个极其复杂的话题，如果我们想要解释其细节，我们需要为它专门写一整章。相反，如果你想了解更多，阅读关于该主题的官方文档是一个好主意，请参阅[http://tools.android.com/tech-docs/new-build-system/user-guide/manifest-merger](http://tools.android.com/tech-docs/new-build-system/user-guide/manifest-merger)。
- en: Creating build variants
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建构建变体
- en: 'Gradle makes it easy to handle the complexity of build variants. Even when
    creating and configuring two build types and two product flavors, the build file
    is still concise:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle使得处理构建变体的复杂性变得简单。即使创建和配置两个构建类型和两个产品风味，构建文件仍然简洁：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this example, we have created four different build variants: `blueDebug`,
    `blueStaging`, `redDebug`, and `redStaging`. Each variant has its own combination
    of API URL and flavor color. This is what `blueDebug` looks like on a phone:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了四个不同的构建变体：`blueDebug`、`blueStaging`、`redDebug`和`redStaging`。每个变体都有自己的API
    URL和风味颜色的组合。这是`blueDebug`在手机上的样子：
- en: '![Creating build variants](img/B01061_04_02.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![创建构建变体](img/B01061_04_02.jpg)'
- en: 'And this is the `redStaging` variant of the same app:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是同一应用程序的`redStaging`变体：
- en: '![Creating build variants](img/B01061_04_03.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![创建构建变体](img/B01061_04_03.jpg)'
- en: The first screenshot shows the `blueDebug` variant, which uses the URL defined
    in the `debug` build type, and makes its text blue, based on `flavor_color` defined
    for the blue product flavor. The second screenshot shows `redStaging`, with the
    staging URL and red text. The red staging version also has a different app icon,
    because the drawable folders in the source set for the `staging` build type have
    their own app icon images.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 第一张截图显示了`blueDebug`变体，它使用`debug`构建类型中定义的URL，并根据为蓝色产品风味定义的`flavor_color`将文本设置为蓝色。第二张截图显示了`redStaging`，具有预发布URL和红色文本。红色预发布版本还有一个不同的应用程序图标，因为`staging`构建类型的源集中的可绘制文件夹有自己的应用程序图标图像。
- en: Variant filters
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变体过滤器
- en: It is possible to entirely ignore certain variants in your build. This way,
    you can speed up the process of building all variants with the general `assemble`
    command, and your list of tasks will not be polluted with tasks that should not
    be executed. This also ensures that the build variant does not show up in the
    Android Studio build variants switcher.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建过程中，你可以完全忽略某些变体。这样，你可以通过通用的`assemble`命令加快构建所有变体的过程，并且你的任务列表不会被不应该执行的任务所污染。这也确保了构建变体不会出现在Android
    Studio的构建变体切换器中。
- en: 'You can filter out variants, using this code in the root level of the `build.gradle`
    file of your app or library:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下代码在应用的`build.gradle`文件根级别过滤变体：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, we first check if the variant's build type has the name `release`.
    Then, we extract the names of all the product flavors. When using flavors without
    dimensions, there is only one product flavor in the flavors array. As soon as
    you start applying flavor dimensions, the flavor array will hold as many flavors
    as there are dimensions. In the example script, we check for the blue product
    flavor, and tell the build script to ignore this particular variant.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们首先检查变体的构建类型是否有名称`release`。然后，我们提取所有产品变体的名称。当使用没有维度的变体时，变体数组中只有一个产品变体。一旦开始应用变体维度，变体数组将包含与维度数量一样多的变体。在示例脚本中，我们检查蓝色产品变体，并告诉构建脚本忽略这个特定的变体。
- en: 'This is the result of the variant filter in the build variant switcher in Android
    Studio:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Android Studio中构建变体切换器中变体过滤器的结果：
- en: '![Variant filters](img/B01061_04_04.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![变体过滤器](img/B01061_04_04.jpg)'
- en: You can see that the two blue release variants (`blueFreeRelease` and `bluePaidRelease`)
    are filtered out of the list of build variants. If you were to run `gradlew tasks`
    now, you would notice that all the tasks related to those variants do not exist
    anymore.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，两个蓝色的发布变体（`blueFreeRelease`和`bluePaidRelease`）被过滤出了构建变体列表。如果您现在运行`gradlew
    tasks`，您会注意到与这些变体相关的所有任务都不再存在。
- en: Signing configurations
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 签名配置
- en: Before you can publish an app on Google Play or any other app store, you need
    to sign it with a private key. If you have a paid and free version or different
    apps for different clients, you need to sign every flavor with a different key.
    This is where signing configurations come in handy.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在您可以在Google Play或任何其他应用商店发布应用之前，您需要使用私钥对其进行签名。如果您有一个付费版和免费版或针对不同客户的不同应用，您需要为每个版本使用不同的密钥进行签名。这就是签名配置派上用场的地方。
- en: 'Signing configurations can be defined like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 签名配置可以定义如下：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, we create two different signing configurations.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们创建了两个不同的签名配置。
- en: The debug configuration is automatically set up by the Android plugin and makes
    use of a general keystore with a known password, so it is not necessary to create
    a signing configuration for this build type.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 调试配置由Android插件自动设置，并使用一个具有已知密码的通用密钥库，因此不需要为这种构建类型创建签名配置。
- en: The staging configuration in the example uses `initWith()`, which copies all
    properties from another signing configuration. This means that the staging builds
    are signed with the debug key, instead of defining its own.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中的预发布配置使用`initWith()`，它从另一个签名配置复制所有属性。这意味着预发布构建使用的是调试密钥，而不是定义自己的密钥。
- en: The release configuration uses `storeFile` to specify the path of the keystore
    file and then defines the key alias and both passwords.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 发布配置使用`storeFile`指定密钥库文件的路径，然后定义密钥别名和两个密码。
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As mentioned earlier, it is not a good idea to store credentials in the build
    configuration file. A better idea would be to use a Gradle properties file. In
    [Chapter 7](ch07.html "Chapter 7. Creating Tasks and Plugins"), *Creating Tasks
    and Plugins*, there is an entire section dedicated to a task to deal with signing
    configuration passwords.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，将凭据存储在构建配置文件中不是一个好主意。更好的办法是使用Gradle属性文件。在[第7章](ch07.html "第7章。创建任务和插件")中，专门有一个部分介绍如何处理签名配置密码的任务。
- en: 'After you define the signing configurations, you need to apply them to your
    build types or flavors. Build types and flavors both have a property called `signingConfig`,
    which can be used like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在您定义签名配置后，您需要将它们应用到您的构建类型或变体上。构建类型和变体都有一个名为`signingConfig`的属性，可以像这样使用：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This example uses build types, but if you want to use different certificates
    for every flavor you create, you need to create different signing configurations.
    You can define those in the exact same way:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用构建类型，但如果您想为每个创建的变体使用不同的证书，您需要创建不同的签名配置。您可以用完全相同的方式定义它们：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Using signing configurations this way leads to problems though. When assigning
    a configuration to a flavor, you are actually overriding the signing configurations
    for the build types. What you want to do instead, when using flavors, is to have
    a different key per build type per flavor:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用签名配置会导致问题。当将配置分配给版本时，您实际上是在覆盖构建类型的签名配置。在使用版本时，您实际上想要为每个版本和构建类型使用不同的密钥：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The example shows how to use different signing configurations for the red and
    blue flavors that use the release build type, without influencing the debug and
    staging build types.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 示例展示了如何为使用发布构建类型的红色和蓝色版本使用不同的签名配置，而不会影响调试和预发布构建类型。
- en: Summary
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we talked about build types, product flavors, and all their
    possible combinations. These are very powerful tools that can be used in any application.
    From a simple setup with different URLs and keys to more complicated apps that
    share the same source code and resources but have different branding and several
    versions; build types and product flavors can make your life considerably easier.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了构建类型、产品版本以及它们所有可能的组合。这些是非常强大的工具，可以在任何应用程序中使用。从具有不同URL和密钥的简单设置到更复杂的共享相同源代码和资源但具有不同品牌和多个版本的应用程序；构建类型和产品版本可以使您的生活大大简化。
- en: We also talked about signing configurations and applying them, and mentioned
    a common pitfall when signing product flavors.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了签名配置及其应用，并提到了在签名产品版本时常见的陷阱。
- en: Next, you will be introduced to multimodule builds. These are useful when you
    want to extract code into a library or a library project, or when you want to
    include, for example, an Android Wear module into your app.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将了解多模块构建。当您想要将代码提取到库或库项目中，或者想要将例如Android Wear模块包含到您的应用中时，这些非常有用。
