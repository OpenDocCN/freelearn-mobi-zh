- en: Chapter 8. Shoot, Scroll, Shoot Again
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 射击，滚动，再射击
- en: In this chapter, we will be creating a game using tile maps and an on-screen
    joystick. We will explore how to use **Tiled**, the free tile map editor, as well
    as how to implement SneakyJoystick. As a stretch, we will also use some advanced
    pathfinding code to make slightly smarter enemies.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用瓦片地图和屏幕上的摇杆创建一个游戏。我们将探讨如何使用免费的瓦片地图编辑器**Tiled**，以及如何实现SneakyJoystick。作为一个挑战，我们还将使用一些高级路径查找代码来制作稍微聪明一点的敌人。
- en: 'In this chapter, we cover the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: Tiled
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tiled
- en: SneakyJoystick
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SneakyJoystick
- en: Tilt Controls
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 倾斜控制
- en: Separating our game layers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分离我们的游戏层
- en: Semi-smart enemies
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 半智能敌人
- en: The game is…
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏是…
- en: In this chapter, we will be building a top-down scrolling shooter. It sounds
    simple, but we will be making it a little more challenging with on-screen joystick
    control, enemy AI, and some more sophisticated layer designs. Traditionally, this
    type of game is military-themed, with soldiers running around shooting each other.
    For our game, we have decided it is fruits versus vegetables battling in the desert.
    We don't really have a good backstory to explain this. However, if millions of
    mobile gamers accept that birds and pigs are mortal enemies, then you can certainly
    invent an equally improbable storyline to explain this odd pairing.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个自上而下的滚动射击游戏。听起来很简单，但我们将通过屏幕上的摇杆控制、敌人AI和一些更复杂的层设计来使其更具挑战性。传统上，这类游戏以军事主题为主，士兵们四处奔跑互相射击。对于我们的游戏，我们决定让水果和蔬菜在沙漠中战斗。我们并没有一个很好的背景故事来解释这一点。然而，如果数百万的移动游戏玩家接受鸟类和猪是宿敌，那么你当然可以发明一个同样不可能的故事情节来解释这种奇怪的配对。
- en: Design review
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计回顾
- en: 'The design of this game is based on a decent sized tile map, 50 tiles wide
    and 50 tiles high. Our basic tile size (non-Retina) is 32 x 32 pixels. We will
    implement the tile map as a single scrolling layer, keeping our hero centered
    on the screen (except near the edges, but we''ll get to that). The goal of the
    hero is to pick up three goal "signposts" scattered around the map. There will
    also be health power-ups on the map to restore the hero''s health. We want to
    have two types of enemies. The first will move in a straight path toward the hero.
    The second type will be a little smarter. When they run into an impassable wall,
    we will use an `A* Pathfinding` algorithm to find a way around the wall, and then
    revert to the same straight line toward the hero logic. The player will be able
    to control the hero using either an on-screen joystick or tilt controls. With
    either method, there will be a fire button on-screen to shoot. We will break out
    our game into three layers for easier management: the map layer, the Heads-Up
    Display (HUD) layer, and the control layer. This will keep our code cleaner, and
    avoid the problem of having our controls scroll off-screen when the tile map moves.
    Shall we get started?'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本游戏的设计基于一个相当大的瓦片地图，宽度为50个瓦片，高度为50个瓦片。我们的基本瓦片大小（非Retina）为32 x 32像素。我们将实现瓦片地图作为一个单独的滚动层，保持我们的英雄在屏幕中央（除了边缘附近，但我们会处理这一点）。英雄的目标是收集散布在地图上的三个目标“路标”。地图上还会有恢复英雄健康的健康提升物品。我们希望有两种类型的敌人。第一种将沿着直线向英雄移动。第二种类型会聪明一些。当它们遇到不可逾越的墙壁时，我们将使用`A*路径查找`算法找到绕过墙壁的方法，然后恢复到向英雄移动的同一直线逻辑。玩家将能够使用屏幕上的摇杆或倾斜控制来控制英雄。无论哪种方法，屏幕上都有一个射击按钮。我们将把游戏分成三个层以便于管理：地图层、抬头显示（HUD）层和控制层。这将使我们的代码更干净，并避免当瓦片地图移动时我们的控制滚动出屏幕的问题。我们开始吧？
- en: Tiled – a primer
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Tiled – 入门指南
- en: Tiled is an open source tile map editor available at [http://mapeditor.org](http://mapeditor.org).
    It is available for Mac, Windows, and Linux. As Tiled is an open source program,
    you can also download the source code if you want to see what is "under the hood".
    We are using Tiled version 0.8.1, which is the current version at the same time
    writing.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Tiled是一个开源的瓦片地图编辑器，可在[http://mapeditor.org](http://mapeditor.org)找到。它适用于Mac、Windows和Linux。由于Tiled是一个开源程序，如果你想查看“内部结构”，你也可以下载源代码。我们正在使用Tiled版本0.8.1，这是写作时的当前版本。
- en: 'When you first load Tiled, you will create a new map. Go to **File** | **New**
    from the menu. In the **New Map** dialog box, configure your map like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次打开Tiled时，你将创建一个新的地图。从菜单中选择**文件** | **新建**。在**新建地图**对话框中，按照以下方式配置你的地图：
- en: '![Tiled – a primer](img/9007_08_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![Tiled – 入门指南](img/9007_08_01.jpg)'
- en: For our game, we will be building our map using non-Retina assets and will later
    "fake" a Retina sizing. Normally, you would be building the Retina version first,
    and then "shrink" the map for the non-Retina version. The same techniques work
    both ways, so we will leave it to you to decide. Anyway, most of these settings
    are self-explanatory, except perhaps the "Orientation". **Orthogonal** is a term
    most people are not familiar with. Basically, it means normal square grid, aligned
    to the x and y axes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的游戏，我们将使用非Retina资源构建我们的地图，并且稍后会“伪造”Retina尺寸。通常，您会首先构建Retina版本，然后“缩小”地图以用于非Retina版本。这两种方法都使用相同的技巧，所以我们将留给您来决定。无论如何，大多数这些设置都是不言自明的，也许“方向”除外。**正交**是一个大多数人不太熟悉的概念。基本上，它意味着正常的正方形网格，与x轴和y轴对齐。
- en: 'You will now be presented with a blank grid of squares. We need to have some
    tiles to use, so we use the menu option **Map** | **NewTileset…**, and are presented
    with the following dialog:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将看到一个空白的方格网格。我们需要一些瓦片来使用，因此我们使用菜单选项**地图** | **新建瓦片集…**，然后出现以下对话框：
- en: '![Tiled – a primer](img/9007_08_02.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![Tiled – 入门指南](img/9007_08_02.jpg)'
- en: For our game, we will be using the tile map file `tmw_desert_spacing.png` that
    is bundled with the Tiled download under the folder `examples`. (This image is
    also included in the cocos2D downloadable as well, under `Resources/TileMaps`.)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的游戏，我们将使用与Tiled下载一起打包在`examples`文件夹下的瓦片地图文件`tmw_desert_spacing.png`。（此图像也包含在cocos2D可下载资源中，位于`Resources/TileMaps`目录下。）
- en: We select this as our image in the dialog box, and then we need to adjust the
    parameters at the bottom of the window. Our tiles are 32 x 32, so we set those
    values for the **Tile width** and **Tile height**. If you look at the tile image,
    you will see that the tiles are not exactly touching. There are black boundaries
    that enforce the grid so you can see which tile is which easily. Because of this,
    we need to set the **Margin** to `1` and the **Spacing** to `1`. You will know
    these settings are correct because in the **Tilesets** window (by default in the
    lower-right pane), you will see the tiles arranged nicely without any traces of
    the black gridlines between them. Tiled shows the tiles with white separators,
    which is fine.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在对话框中选择这张图像，然后需要调整窗口底部的参数。我们的瓦片是32 x 32，因此我们将这些值设置为**瓦片宽度**和**瓦片高度**。如果您查看瓦片图像，您会看到瓦片并没有完全接触。存在黑色边界，强制网格以便您可以轻松地看到哪个是哪个。正因为如此，我们需要将**边距**设置为`1`和**间距**设置为`1`。您将知道这些设置是正确的，因为在**瓦片集**窗口（默认在显示窗口的左下角），您将看到瓦片整齐地排列，它们之间没有任何黑色网格线的痕迹。Tiled使用白色分隔符显示瓦片，这是可以的。
- en: Drawing the ground
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制地面
- en: To draw your map, you simply select the tile you want to use from the **Tilesets**
    pane, and draw on the grid. (If the **Tilesets** pane is not visible, you can
    turn it on under the **View** | **Tilesets** in the menu.)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制您的地图，您只需从**瓦片集**面板中选择您想要使用的瓦片，并在网格上绘制。（如果**瓦片集**面板不可见，您可以在菜单中的**视图** | **瓦片集**下将其打开。）
- en: 'One of the strengths of Tiled is that you can define multiple layers on a map.
    These layers are visible in the **Layers** pane, which is normally at the top
    left of the display. We start by drawing our basic ground layer, so we rename
    the default layer from **Tile Layer 1** to `ground`. Before we go any further,
    let''s see part of our ground layer that we have drawn:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Tiled的一个优点是您可以在地图上定义多个层。这些层在**层**面板中可见，通常位于显示窗口的左上角。我们首先绘制我们的基本地面层，因此我们将默认层从**瓦片层1**重命名为`ground`。在我们继续之前，让我们看看我们绘制的地面层的一部分：
- en: '![Drawing the ground](img/9007_08_03.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![绘制地面](img/9007_08_03.jpg)'
- en: 'When we drew our ground layer, we avoided drawing anything that would be picked
    up from the map. In our game, we will be able to pick up health and our goals.
    The reason we avoid drawing those on the ground layer is that when we pick them
    up, the image will be removed from the map. If we had the pickups on the ground
    layer, we would have a blank spot in the map after we picked them up. Instead,
    we create a new layer, name it `pickups`, and draw the items we want to be picked
    up. The following screenshot shows the same area of the map, with the ground layer
    turned off, and only the pickups layer visible:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们绘制地面层时，我们避免绘制任何可以从地图中拾取的内容。在我们的游戏中，我们将能够拾取生命值和我们的目标。我们避免在地面层上绘制这些内容的原因是，当我们拾取它们时，图像将从地图中移除。如果我们把拾取物放在地面层上，我们在拾取它们之后会在地图上留下一个空白区域。相反，我们创建一个新的层，命名为`pickups`，并绘制我们想要拾取的项目。以下截图显示了地图的同一区域，地面层已关闭，只显示拾取层：
- en: '![Drawing the ground](img/9007_08_04.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![绘制地面](img/9007_08_04.jpg)'
- en: As you see, the goal marker (the signpost) will be inside the building, and
    the health (flowery cactus thing) will be near the top-left corner. Simply adding
    the graphics is not enough. We need to be able to add triggers to the map to be
    able to easily interpret the map. We will handle this by building what we refer
    to as "logic layers" into the map. These will not be seen by the user, but will
    be used to trigger events in the code.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，目标标记（路标）将位于建筑物内，而健康（花状仙人掌）将位于左上角附近。仅仅添加图形是不够的。我们需要能够向地图中添加触发器，以便能够轻松解释地图。我们将通过在地图中构建我们所说的“逻辑层”来处理这个问题。这些层不会被用户看到，但将被用来在代码中触发事件。
- en: Logic layers
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑层
- en: To identify where tiles should have some logic associated with them, we need
    a new tileset. We have built another tileset called `tile_markers.png` that we
    need to load. This tileset is simply three semi-transparent boxes of different
    colors. When you load this, it is important to change the spacing and margin to
    0 (we didn't use any grid lines in this PNG file.) Also, since we have transparency
    saved in the image file, make sure the **Use transparent color** box is *not*
    checked. If it is, then any transparency in the loaded image will be discarded,
    and our nicely transparent tiles will be opaque.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定哪些瓦片应该与某些逻辑相关联，我们需要一个新的瓦片集。我们构建了另一个名为`tile_markers.png`的瓦片集，需要加载。这个瓦片集只是三种不同颜色的半透明框。当你加载它时，重要的是将间距和边距更改为0（我们在这个PNG文件中没有使用任何网格线。）此外，由于我们在图像文件中保存了透明度，请确保**使用透明颜色**框没有被勾选。如果是的话，那么加载的图像中的任何透明度都将被丢弃，我们的透明瓦片将变得不透明。
- en: 'Once the tileset is loaded, select it from the **Tilesets** pane. You will
    see three tiles: blue, green, and red. Right-click (or *Ctrl* + click) on the
    blue tile and select **Tile Properties…**. Double-click on **<new property>**
    and name it `Goal`. Under **Value**, enter `Yes`. Then click on **OK** to store
    the property. This will identify the blue tile as a goal tile. Repeat the same
    process for the green tile, except name it `Health` with a value of `Yes`. Finally,
    the red tile should be set with the property `Blocked` with a value of `Yes`.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦加载了瓦片集，从**瓦片集**面板中选择它。你会看到三个瓦片：蓝色、绿色和红色。右键单击（或*Ctrl* + 点击）蓝色瓦片，选择**瓦片属性…**。双击**<新属性**>并命名为`Goal`。在**值**下，输入`Yes`。然后点击**确定**来存储属性。这将识别蓝色瓦片为目标瓦片。对绿色瓦片重复相同的步骤，除了将其命名为`Health`并设置值为`Yes`。最后，红色瓦片应该设置属性`Blocked`，值为`Yes`。
- en: Now that we have our logic tiles defined, we need to build something with them.
    Create a new layer, named **triggers**. With the **triggers** layer selected,
    draw blue tiles on the positions of the goal markers, and draw green layers on
    our health cacti. Because the tiles have partial transparency, you can see the
    ground tile through the colored tile.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了逻辑瓦片，我们需要用它们来构建一些东西。创建一个新的层，命名为**触发器**。当选择**触发器**层时，在目标标记的位置绘制蓝色瓦片，并在我们的健康仙人掌上绘制绿色层。因为瓦片具有部分透明度，你可以透过彩色瓦片看到地面瓦片。
- en: Our next logic layer we need is to define the walls and other impassable tiles.
    We create a new layer, named `walls`. (Make sure you are drawing on the correct
    layer; the layer currently active will be highlighting in the **Layers** pane.)
    Using the red tile, we draw over all walls and rocks in the tile map.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来需要的逻辑层是定义墙壁和其他不可通行瓦片。我们创建了一个新的层，命名为`walls`。（确保你在正确的层上绘制；当前活动的层将在**图层**面板中突出显示。）使用红色瓦片，我们在瓦片地图中的所有墙壁和岩石上绘制。
- en: 'The same area of the map now looks like the following screenshot:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 地图的同一区域现在看起来如下截图所示：
- en: '![Logic layers](img/9007_08_05.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![逻辑层](img/9007_08_05.jpg)'
- en: Spawn layer
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 出生层
- en: 'We have only one more layer to complete the tile map. We now add an **Object
    Layer** to the map. Objects are features on the map that do not necessarily correspond
    to tiles. We will be using this layer to identify spawn points for both the hero
    and the enemies. Let''s create an object layer, and name it `spawns`. With the
    spawn layer selected, you will see that different options in the toolbar are selected.
    Select the **Insert Object** button from the toolbar. The following screenshot
    shows how it looks:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要再添加一层来完成瓦片地图。我们现在将一个**对象层**添加到地图中。对象是地图上的特征，它们不一定对应于瓦片。我们将使用这个层来识别英雄和敌人的出生点。让我们创建一个对象层，并将其命名为`spawns`。当选择出生层时，你会看到工具栏中的不同选项被选中。从工具栏中选择**插入对象**按钮。以下截图显示了它的样子：
- en: '![Spawn layer](img/9007_08_06.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![出生层](img/9007_08_06.jpg)'
- en: Now click on the map to create an object near the opening in the walls on the
    left side of the map. It will display as a grey square. Now you can right-click
    (or *Ctrl* + click) on the box to get a menu. Select **Object Properties**. In
    the window, name this "playerSpawn". This will be the location where the hero
    will be created. You will notice that there are both x and y coordinates, as well
    as width and height. For our use, we will not be using the width and height. The
    x and y coordinates look a little odd. That is because these are tile coordinates.
    Tile coordinates are similar to the coordinates we are used to in cocos2d, except
    the (0, 0) coordinate corresponds to the top-left corner, not the bottom-left.
    When we use these, we will have to do some translation on these coordinates, but
    we will deal with that later.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击地图以在地图左侧墙壁的开口附近创建一个对象。它将显示为一个灰色方块。现在你可以右键单击（或 *Ctrl* + 点击）该方块以获取菜单。选择 **对象属性**。在窗口中，将其命名为
    "playerSpawn"。这将是在英雄将被创建的位置。你会注意到既有 x 和 y 坐标，也有宽度和高度。对于我们的用途，我们不会使用宽度和高度。x 和 y
    坐标看起来有点奇怪。这是因为这些是瓦片坐标。瓦片坐标与我们熟悉的 cocos2d 中的坐标类似，但 (0, 0) 坐标对应的是左上角，而不是左下角。当我们使用这些坐标时，我们将在这些坐标上进行一些转换，但我们会稍后处理这个问题。
- en: Now, we need to make a few more objects on the tile map, preferably keeping
    most of them farther away from the hero's spawn point. For each of these, we will
    name them with incremental names `EnemySpawn1`, `EnemySpawn2`, and so on. For
    our game, we have chosen to have 11 enemy spawn points to add some variety. Once
    these are all created, let's save the map as `desert_map.tmx`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们还需要在瓦片地图上创建一些更多的对象，最好让它们大多数都远离英雄的出生点。对于这些中的每一个，我们将使用递增的名称 `EnemySpawn1`、`EnemySpawn2`
    等来命名。对于我们的游戏，我们选择了 11 个敌人出生点以增加一些多样性。一旦所有这些都被创建，让我们将地图保存为 `desert_map.tmx`。
- en: Understanding TMX format
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 TMX 格式
- en: 'Now, we will go ahead and add our `.tmx` file and our two PNG files to our
    project. If you select the `.tmx` file in Xcode, you can read and edit it directly
    in the Xcode editor. Go ahead and look at the `desert_map.tmx`. It is a plain
    XML file, so it is fairly easy to understand most of the parameters. For now,
    look at the top of the file where the `<tileset>` tags are. You need to make sure
    there isn''t a file path attached to the source value. The first few lines of
    the file should look like the following screenshot:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将继续添加我们的 `.tmx` 文件和两个 PNG 文件到我们的项目中。如果你在 Xcode 中选择 `.tmx` 文件，你可以在 Xcode
    编辑器中直接读取和编辑它。接下来，查看 `desert_map.tmx`。它是一个普通的 XML 文件，所以理解大多数参数相对容易。现在，看看文件顶部 `<tileset>`
    标签的位置。你需要确保源值中没有附加文件路径。文件的前几行应该看起来像以下截图：
- en: '![Understanding TMX format](img/9007_08_07.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![理解 TMX 格式](img/9007_08_07.jpg)'
- en: Here you can see that all of the parameters we put in Tiled for the map and
    the tilesets is all represented in easily readable and *changeable* text. This
    is important for creating the Retina version of this map.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们为地图和瓦片集在 Tiled 中设置的参数都表示为易于阅读和 *可更改* 的文本。这对于创建此地图的 Retina 版本非常重要。
- en: Creating an HD map
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建高清地图
- en: As we said earlier, the usual direction is to create the HD version of everything
    first, and downscale it to the SD resolution. Because we started with a tile set
    that was in non-Retina resolution, we opted to build that version first, and then
    upscale everything.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说的，通常的做法是首先创建所有内容的高清版本，然后将其下采样到 SD 分辨率。因为我们开始时使用的是一个非 Retina 分辨率的瓦片集，所以我们选择首先构建这个版本，然后放大所有内容。
- en: The first thing we need to do is take both of our tile set PNG images and convert
    them into HD sized assets. We did this by using Photoshop, and resized them to
    200 percent, and then saved them as -hd files. When doing the resizing (regardless
    of the tool), make sure that it is not doing any clever antialiasing or anything
    like that. By allowing Photoshop to use its **Resample Image** option, it will
    leave strange edges on all the tiles, where it feathers out the black separator
    lines into the tiles themselves. We just need a straight doubling of the pixels
    for this operation.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是将我们的两个瓦片集 PNG 图像转换为高清尺寸的资产。我们通过使用 Photoshop 完成了这项工作，将它们调整到 200% 的大小，然后保存为
    -hd 文件。在调整大小（无论使用什么工具）时，确保它没有进行任何复杂的抗锯齿或其他类似操作。通过允许 Photoshop 使用其 **重采样图像** 选项，它会在所有瓦片上留下奇怪的边缘，将黑色分隔线羽化到瓦片本身中。我们只需要对这个操作进行像素的简单加倍。
- en: Now comes the easier part of making an HD map. Copy the `desert_map.tmx` as
    a new file, `desert_map-hd.tmx`. Add all three of these -hd files into Xcode as
    well, and edit the new TMX file. Since we have just doubled all of the tile sizes,
    we need to edit the sizes in the TMX file. In the `<map>` section, change the
    `tilewidth` and `tileheight` properties to `64`, since that is our HD tile size.
    Make the same changes to the parameters for both `<tileset>` sections. We also
    need to change the `spacing` and `margin` on the desert tileset to `2` and `2`.
    Finally, the width and height for both `<image>` sections need to be doubled from
    their former values.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是制作高清地图更容易的部分。将`desert_map.tmx`复制为一个新的文件，`desert_map-hd.tmx`。将这三个-hd文件也添加到Xcode中，并编辑新的TMX文件。由于我们已经将所有瓦片大小加倍，我们需要在TMX文件中编辑大小。在`<map>`部分，将`tilewidth`和`tileheight`属性更改为`64`，因为这是我们的高清瓦片大小。同样更改两个`<tileset>`部分的参数。我们还需要将沙漠瓦片集的`spacing`和`margin`更改为`2`和`2`。最后，需要将两个`<image>`部分的宽度和高度从原来的值加倍。
- en: As a final step, we need to change the image source values to reflect the –hd
    filenames. These should be `tmw_desert_spacing-hd.png` and `tile_markers-hd.png`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，我们需要更改图像源值以反映-hd文件名。这些应该是`tmw_desert_spacing-hd.png`和`tile_markers-hd.png`。
- en: There is one set of values that will not be correct – the object positions.
    Since these are not tile-based, they will look a little odd if you reload the
    new –hd tilemap into Tiled. You could compensate for this in code, but our preference
    is to reload the –hd tilemap into Tiled, and manually move these around. That
    is the approach we used for this game.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个值集将不会正确——这是对象位置。由于这些不是基于瓦片的，如果你将新的-hd瓦片图重新加载到Tiled中，它们看起来会有些奇怪。你可以在代码中对此进行补偿，但我们的偏好是重新将-hd瓦片图加载到Tiled中，并手动移动这些对象。这就是我们在这个游戏中采用的方法。
- en: Implementing the tilemap
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现瓦片图
- en: So far, we've spent considerable time without really building the project, so
    now let's turn our attention to our Xcode project. The first thing we need to
    do is load the tilemap into the layer. We will need to persist the tilemap, so
    first let's look at the header to see our variables.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们花费了相当多的时间而没有真正构建项目，所以现在让我们将注意力转向我们的Xcode项目。我们需要做的第一件事是将瓦片图加载到层中。我们需要持久化瓦片图，所以首先让我们看看头文件来查看我们的变量。
- en: '**Filename**: `TDPlayfieldLayer.h` (partial)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `TDPlayfieldLayer.h`（部分）'
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here you see that we keep the tilemap, as well as individual variables for each
    layer. We also introduce a few `NSInteger` variables to store the values of several
    important numbers, as a shorthand to avoid repeatedly writing a relatively long
    bit of code. Let's look at the relevant sections of the `init` method.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们保留了瓦片图，以及每个层的单个变量。我们还引入了一些`NSInteger`变量来存储几个重要数字的值，作为避免反复编写相对较长的代码的快捷方式。让我们看看`init`方法的相关部分。
- en: '**Filename**: `TDPlayfieldLayer.m` (partial)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `TDPlayfieldLayer.m`（部分）'
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: That is all it takes to load the tilemap on a layer. You will notice we set
    the visible attributes for both the triggers and walls to `NO`. For debugging,
    you can easily set these to `YES`, and the map will look more like it does in
    Tiled, with the colored overlays on the trigger tiles. You will also notice we
    only add the `_tileMap` to self, and not the layers within the tilemap. This is
    because the TMX handling classes of cocos2d are built to assume the tilemap should
    be kept together and used together. Finally, we load the `spawns` object group
    a little differently, because object layers are stored a little differently in
    the file.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个层上加载瓦片图只需要做这么多。你会注意到我们将触发器和墙壁的可视属性都设置为`NO`。对于调试，你可以轻松地将这些设置为`YES`，这样地图看起来会更像在Tiled中的样子，带有触发瓦片上的彩色叠加。你也会注意到我们只添加了`_tileMap`到self中，而没有添加瓦片图内的层。这是因为cocos2d的TMX处理类是构建为假设瓦片图应该一起保留并一起使用。最后，我们以不同的方式加载`spawns`对象组，因为对象层在文件中的存储方式略有不同。
- en: There is a second set of initializations that we do to make it easier to write
    the code later.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还进行了一组初始化，以便以后编写代码更容易。
- en: '**Filename**: `TDPlayfieldLayer.m`'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `TDPlayfieldLayer.m`'
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here we are using the "shorthand" variables that we identified in the header
    file. This allows us to write shorter lines of code when referencing any of these
    values. Because the tiles are represented in pixel sizes only, we divide them
    by the `CC_CONTENT_SCALE_FACTOR()` to ensure that we are dealing with the sizes
    in points, not pixels.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用在头文件中确定的“简写”变量。这允许我们在引用这些值时编写更短的代码行。因为瓦片只以像素大小表示，所以我们通过除以`CC_CONTENT_SCALE_FACTOR()`来确保我们处理的是以点为单位的大小，而不是像素。
- en: Adding our hero
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加我们的英雄
- en: Now that we have a world to live in, we need to add our hero. We have broken
    out our hero into a separate class, but first let's look at how we figure out
    where the hero will spawn. As you may recall, we have the location **playerSpawn**
    marked on the map. Now, we need to translate that location into game coordinates.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个世界可以生活，我们需要添加我们的英雄。我们已经将英雄分解为一个单独的类，但首先让我们看看我们是如何确定英雄将在哪里生成的。正如你可能记得的，我们在地图上标记了**playerSpawn**的位置。现在，我们需要将这个位置转换成游戏坐标。
- en: '**Filename**: `TDPlayfieldLayer.m`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `TDPlayfieldLayer.m`'
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here you see that we create an `NSMutableDictionary` from the `playerSpawn`.
    The data is stored in this way inside the TMX map, because the format does allow
    us to add other properties to the objects (in our case, we care only about the
    coordinates). We extract the x and y coordinates for the `playerSpawn` object,
    but then we alter the coordinates by dividing them by the `CC_CONTENT_SCALE_FACTOR()`.
    Why? Remember that the TMX file format produced by Tiled is not a cocos2d-specific
    format, so everything is represented as pixels. We divide the coordinates by the
    `CC_CONTENT_SCALE_FACTOR()`, which will give us the correct location in points.
    We then call the constructor for our `TDHero` class, and add the hero to the layer.
    We also store a reference to the hero in the `hero` variable. Now let's see how
    the `TDHero` is constructed.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我们从一个`playerSpawn`创建了一个`NSMutableDictionary`。数据以这种方式存储在TMX地图中，因为该格式允许我们向对象添加其他属性（在我们的情况下，我们只关心坐标）。我们提取`playerSpawn`对象的x和y坐标，但然后我们通过除以`CC_CONTENT_SCALE_FACTOR()`来改变坐标。为什么？记住，Tiled生成的TMX文件格式不是cocos2d特定的格式，所以一切都是以像素表示的。我们通过除以`CC_CONTENT_SCALE_FACTOR()`来分割坐标，这将给我们正确的点坐标。然后我们调用我们的`TDHero`类的构造函数，并将英雄添加到层中。我们还将在`hero`变量中存储对英雄的引用。现在让我们看看`TDHero`是如何构建的。
- en: '**Filename**: `TDHero.h`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `TDHero.h`'
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The hero keeps a reference to the `TDPlayfieldLayer` (using a forward declaration
    to avoid an import loop), and we keep a reference to the sprite. You will notice
    that we have `TDHero` as a subclass of `CCNode`, not `CCSprite`. We do this to
    keep the class more uniform with the `TDEnemy` class we will look at later. By
    having the `CCSprite` as a variable inside a `CCNode` subclass, it makes it easier
    to use a single class with different graphics. By keeping these two classes more
    uniform, it makes it easier to remember how to code the collision and movement
    classes. Now let''s look at the implementation:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 英雄对象保持对`TDPlayfieldLayer`的引用（使用前向声明以避免导入循环），并且我们保持对精灵的引用。你会注意到我们将`TDHero`作为`CCNode`的子类，而不是`CCSprite`。我们这样做是为了使类与稍后我们将要查看的`TDEnemy`类更加统一。通过在`CCNode`子类内部将`CCSprite`作为变量，这使得使用具有不同图形的单个类变得更加容易。通过使这两个类更加统一，这使得记住如何编写碰撞和移动类变得更加容易。现在让我们看看实现：
- en: '**Filename**: `TDHero.m`'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `TDHero.m`'
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here we have a convenience constructor, and the `init` method. We keep a reference
    to the parent layer, build a sprite, set its opening position, and add the sprite
    to the parent layer. Yes, we already added the hero (of `TDHero` class) to the
    parent layer. That is a "handle" on the `CCNode` that we need to keep to avoid
    having it autorelease. But that does not add the sprite to the layer, so we add
    that separately. We want our hero to be able to rotate in the direction he is
    heading, so we will add a rotation method.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个便利的构造函数和`init`方法。我们保持对父层的引用，构建一个精灵，设置其起始位置，并将精灵添加到父层。是的，我们已经在父层中添加了英雄（`TDHero`类）。这是一个我们需要保留以避免自动释放的`CCNode`的“句柄”。但这并没有将精灵添加到层中，所以我们单独添加它。我们希望我们的英雄能够朝着他前进的方向旋转，所以我们将添加一个旋转方法。
- en: '**Filename**: `TDHero.m`'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `TDHero.m`'
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is a fairly standard rotation method that is often used in sample projects.
    It calculates the angle between the sprite and the target coordinate passed to
    it. The calculation results in radians, converts that to degrees, and sets the
    new rotation.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当标准的旋转方法，常用于示例项目中。它计算精灵和传递给它的目标坐标之间的角度。计算结果以弧度为单位，将其转换为度数，并设置新的旋转。
- en: 'Our hero also needs to be able to shoot. Let''s take a look at that:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的英雄还需要能够射击。让我们看看这一点：
- en: '**Filename**: `TDHero.m`'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`TDHero.m`'
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here we see that we will also have a `TDBullet` class as a factory for new bullets.
    We will take a closer look at bullets later in the chapter. For now, you see that
    we set the bullet to be at the same position and rotation as the hero, and we
    set an `isEnemy` flag, so we can make friendly-fire impossible. We send the bullet
    to the parent layer to be added, and we play a sound effect.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们还将有一个 `TDBullet` 类作为新子弹的工厂。我们将在本章的后面更详细地了解子弹。现在，你可以看到我们将子弹设置在英雄相同的位子和旋转位置，并设置一个
    `isEnemy` 标志，这样我们就可以使友军互射成为不可能。我们将子弹发送到父层以添加，并播放一个音效。
- en: Focus on the hero
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关注英雄
- en: 'If we were to go forward with the code thus far, we have a slight problem.
    The hero is nowhere on the screen, as we see in the following screenshot:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们继续使用到目前为止的代码，我们会遇到一个小问题。英雄在屏幕上无处可寻，正如我们在以下截图中所看到的：
- en: '![Focus on the hero](img/9007_08_08.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![关注英雄](img/9007_08_08.jpg)'
- en: We need a way to focus the view on the hero, but at the same time we need to
    make sure that we never see any area outside the map. Ray Wenderlich posted a
    wonderfully compact method of doing this in one of his tutorials at [http://www.raywenderlich.com](http://www.raywenderlich.com).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法来聚焦视图在英雄上，但同时也需要确保我们永远不会看到地图之外的任何区域。Ray Wenderlich 在他的一篇教程中发布了一个非常紧凑的方法来做这件事，可以在
    [http://www.raywenderlich.com](http://www.raywenderlich.com) 找到。
- en: '**Filename**: `TDPlayfieldLayer.m`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`TDPlayfieldLayer.m`'
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first `x` and `y` assignments get the `MAX` value of either middle of the
    screen, or the passed position. Then it takes that result and selects the `MIN`
    of that value or the right edge of the map minus half a screen. This paired calculation
    will give you the coordinates of the hero, unless he is near the edge of the screen,
    in which case it will give the coordinates of a point that is exactly half a screen
    away from the nearest edge. We then subtract the center of the screen size from
    the actual position on the map, and we end up with a screen coordinate perfect
    for the layer's position. You will notice that this actually works by repositioning
    the layer itself. Here we use it only for following the hero, but if you wanted
    to call the player's attention to some other feature of the map (show them the
    goal, for example) you can use this same method by passing it a different coordinate.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `x` 和 `y` 赋值将获得屏幕中间或传递位置的 `MAX` 值。然后它取那个结果，并选择该值的最小值或地图右边缘减去半个屏幕的值。这种配对计算将给出英雄的坐标，除非他靠近屏幕边缘，在这种情况下，它将给出一个距离最近边缘正好半个屏幕的点坐标。然后我们从地图上的实际位置减去屏幕中心的大小，最终得到一个完美的屏幕坐标，适用于层的位置。你会注意到这实际上是通过重新定位层本身来实现的。在这里，我们只使用它来跟随英雄，但如果你想要将玩家的注意力吸引到地图的某个其他功能（例如显示目标）上，你可以通过传递不同的坐标来使用这个相同的方法。
- en: Controlling the hero with SneakyJoystick
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SneakyJoystick 控制英雄
- en: Now, we need a way to control our hero. For our game, we will be using two different
    control methods, joystick and tilt. We will look at the joystick control first.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一种控制我们的英雄的方法。对于我们的游戏，我们将使用两种不同的控制方法：摇杆和倾斜。我们首先看看摇杆控制。
- en: Our joystick control will use the `SneakyJoystick` class, available at [https://github.com/sneakyness/SneakyInput](https://github.com/sneakyness/SneakyInput).
    `SneakyInput`/`SneakyJoystick`. This is probably the most commonly used joystick
    class in the cocos2d community. It has a lot of features (such as skinning the
    joystick with better graphics), which we will not be using in this project, but
    which are definitely worth exploring in the projects you will create.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的摇杆控制将使用 `SneakyJoystick` 类，可在 [https://github.com/sneakyness/SneakyInput](https://github.com/sneakyness/SneakyInput)
    找到。`SneakyInput`/`SneakyJoystick`。这可能是 cocos2d 社区中最常用的摇杆类。它有很多功能（例如用更好的图形对摇杆进行皮肤化），我们在这个项目中不会使用，但在你将创建的项目中绝对值得探索。
- en: We create a new layer to handle the controls, `TDControlLayer`. In some projects,
    it doesn't make a big difference how you organize your objects on layers. When
    you are using a scrolling tilemap, however, separation of your layers is essential.
    If you don't put your controls on a separate layer, as soon as you scroll the
    tilemap, the controls will scroll off-screen. By keeping them as a separate layer
    (that is *not* a child of the tilemap's layer), the controls will be fixed in
    the screen positioning you want, regardless of any map scrolling.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个新的层来处理控制，`TDControlLayer`。在一些项目中，你在层上如何组织对象并没有太大的区别。然而，当你使用滚动瓦片地图时，层之间的分离是至关重要的。如果你不将控制放在一个单独的层上，一旦滚动瓦片地图，控制就会滚动出屏幕。通过将它们保持为单独的层（这不是瓦片地图层的子层），控制将固定在您想要的屏幕位置，无论地图如何滚动。
- en: '**Filename**: `TDControlLayer.m`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `TDControlLayer.m`'
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Most of this method is concerned with the building of the images used for the
    sprite. We are using a simple example with colored circles to represent the base
    of the joystick and the thumb. (The "thumb" is the movable part of the joystick,
    adopting the term from scrollbar controls). We build the joystick, and add it
    to the layer.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法的大部分内容都关注于用于精灵的图像的构建。我们使用一个简单的示例，用彩色圆圈来表示摇杆的基座和拇指。（“拇指”是摇杆的可移动部分，采用滚动条控制的术语。）我们构建摇杆，并将其添加到层中。
- en: We also need a fire button in our game, so we will use the `SneakyButton` class
    for it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中，我们还需要一个射击按钮，因此我们将使用`SneakyButton`类来实现它。
- en: '**Filename**: `TDControlLayer.m`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `TDControlLayer.m`'
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The setup of the `SneakyButton` is very similar to the `SneakyJoystick`, except
    instead of the base and thumb images, we set up the alternate images for the button
    press.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`SneakyButton`的设置与`SneakyJoystick`非常相似，除了我们设置了按钮按下的替代图像。'
- en: Now that we have built the controls, let's see how to use them. We schedule
    an `update` method on this layer, and the `update` handles parsing the controls.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了控制，让我们看看如何使用它们。我们在这一层上安排了一个`update`方法，`update`负责解析控制。
- en: '**Filename**: `TDControlLayer.m`'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `TDControlLayer.m`'
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is all of the `update` method, except for the tilt control section, which
    we will get to in a few moments. We handle a couple of standard cases first (`preventTouches`
    and `isGameOver`), and then we check the joystick. If the `stickPosition` is equal
    to `CGPointZero`, it means the stick is centered, so we don't actually have any
    movement requested. If they are not equal, then we need to send the message to
    the hero to move. We do this by sending a call to the playfield layer (`pf` is
    a reference to it), and pass some parameters to it. (The method call is a fairly
    standard one when using `SneakyJoystick`. That is why the terminology in the method
    call is a little different from the other code.) We then check to see if the button
    has its `active` property set. If it does, then we need to shoot. We again pass
    that call to the playfield layer to set a Boolean variable, `heroShooting`. This
    class does not have any direct connections to the `TDHero` class. The call routing
    is done by way of the playfield layer, which acts as liaison between the two classes.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的内容是所有`update`方法的全部，除了倾斜控制部分，我们将在接下来的几分钟内讨论它。我们首先处理几个标准情况（`preventTouches`和`isGameOver`），然后检查摇杆。如果`stickPosition`等于`CGPointZero`，这意味着摇杆处于中心位置，所以我们实际上没有请求任何移动。如果不相等，那么我们需要向英雄发送移动的消息。我们通过向游戏场层发送调用（`pf`是它的引用）并传递一些参数来实现这一点。（当使用`SneakyJoystick`时，这个方法调用是一个相当标准的调用。这就是为什么方法调用中的术语与其他代码略有不同。）然后我们检查按钮是否设置了`active`属性。如果设置了，那么我们需要射击。我们再次将这个调用传递给游戏场层来设置一个布尔变量，`heroShooting`。这个类与`TDHero`类没有直接连接。调用路由是通过游戏场层完成的，它作为两个类之间的联络人。
- en: Tilt controls
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 倾斜控制
- en: The addition of tilt controls to our game is almost trivial. Since the tilt
    control will only be replacing the joystick, we will still need the button to
    be used, so it makes sense for these two control methods to be housed in the same
    class.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中添加倾斜控制几乎是微不足道的。由于倾斜控制将仅替换摇杆，我们仍然需要使用按钮，因此将这两个控制方法放在同一个类中是有意义的。
- en: '**Filename**: `TDControlLayer.m`'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `TDControlLayer.m`'
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With these two simple methods, we have most of the code we need to make the
    tilt controls functional. In the `addTiltControl` method, we turn on the accelerometer
    and set its delegate to this class. That delegate uses a callback, which is the
    second method listed in the preceding code. At the frequency specified, the `accelerometer:didAccelerate:`
    method will be called. On each call, we store a modified version of the acceleration
    values in our `accelX` and `accelY` variables. Because our game is in landscape
    and the accelerometer reports only in portrait-based values, we reverse the `x`
    and `y` values. We multiply them by `7` to provide a larger change value. Testing
    found `7` to be a good multiplier value.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这两个简单的方法，我们已经拥有了使倾斜控制功能化的大部分代码。在`addTiltControl`方法中，我们打开加速度计并将其代理设置为这个类。这个代理使用回调，即前面代码中列出的第二个方法。在指定的频率下，`accelerometer:didAccelerate:`方法将被调用。在每次调用中，我们将加速度值的修改版存储在我们的`accelX`和`accelY`变量中。因为我们的游戏是横屏的，而加速度计只报告基于竖屏的值，所以我们反转`x`和`y`值。我们将它们乘以`7`以提供更大的变化值。测试发现`7`是一个很好的乘数值。
- en: Finally, we have a small bit of code to add into our update method.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将一小段代码添加到我们的更新方法中。
- en: '**Filename**: `TDControlLayer.m` (`update` method, under `Tilt Code here`):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `TDControlLayer.m`（在`Tilt Code here`下的`update`方法）:'
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here we could have easily taken the same approach as with the joystick and passed
    everything to the playfield layer, but we wanted to show an alternate approach
    with this control. There is no difference in the performance of having the code
    here or in the playfield layer (as all called methods are in `pf` anyway). The
    code itself calculates a new position for the hero by adding the `accelX` and
    `accelY` values to the coordinates. It then calls to rotate the hero, and then
    move the hero.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们本可以像摇杆一样采取相同的方法，将一切传递给游戏场层，但我们想展示一种不同的控制方法。代码本身在这里或游戏场层（因为所有调用方法都在`pf`中）的性能没有区别。代码本身通过将`accelX`和`accelY`值加到坐标上来计算英雄的新位置。然后它调用旋转英雄，然后移动英雄。
- en: To wrap up the control section, let's look at the constructor and the `init`
    methods.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结控制部分，让我们看看构造函数和`init`方法。
- en: '**Filename**: `TDControlLayer.m`'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `TDControlLayer.m`'
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We will be creating the control layer with two parameters: the playfield layer,
    and a Boolean value to indicate if we want tilt controls or not. Based on the
    `isTilt` value, we either create the joystick or we start with tilt. That''s all
    it takes to implement both control mechanisms.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用两个参数创建控制层：游戏场层和一个布尔值，表示我们是否想要倾斜控制。根据`isTilt`值，我们或者创建摇杆，或者从倾斜开始。这就是实现两种控制机制的全部内容。
- en: Interpreting the controls
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释控制
- en: 'Now we turn our attention to the `TDPlayfieldLayer` class to see how we fully
    interpret the control methods that were called in the control layer. We''ll start
    with the joystick control:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将注意力转向`TDPlayfieldLayer`类，看看我们如何完全解释在控制层中调用的控制方法。我们将从摇杆控制开始：
- en: '**Filename**: `TDPlayfieldLayer.m`'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `TDPlayfieldLayer.m`'
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We start by creating a `scaledVelocity` variable, which is the data from the
    joystick times `200`, to give a larger value than the joystick's reading. We then
    apply this to the hero's position. You will notice we multiply the `scaledVelocity`
    by the delta time. We do this to allow for variable update time, so the movement
    is not jerky, if there is any lag. We then tell the hero to rotate toward the
    new position, and set the hero's position to the new value.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个`scaledVelocity`变量，它是摇杆数据乘以`200`的结果，以提供一个比摇杆读数更大的值。然后我们将这个值应用到英雄的位置上。你会注意到我们乘以了`scaledVelocity`和delta时间。我们这样做是为了允许可变更新时间，以便在有任何延迟的情况下，移动不会显得突然。然后我们告诉英雄转向新的位置，并将英雄的位置设置为新的值。
- en: Now we will look at an abbreviated version of the `setHeroPos` method. We will
    revisit this later to add some more logic to it. For now, it is very simple.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将查看`setHeroPos`方法的简略版。我们稍后会重新访问它以添加一些更多逻辑。现在，它非常简单。
- en: '**Filename**: `TDPlayfieldLayer.m`'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `TDPlayfieldLayer.m`'
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: For now, the `setHeroPos` method simply sets the hero's position and then centers
    the view on the hero. Nothing fancy, but it gets the job done. At this point,
    we have used a couple of small pass-through methods that we should mention.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`setHeroPos`方法只是设置英雄的位置，然后使视图居中在英雄上。没有什么花哨的，但能完成任务。在这个阶段，我们已经使用了一些小型传递方法，我们应该提到。
- en: '**Filename**: `TDPlayfieldLayer.m`'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `TDPlayfieldLayer.m`'
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As we mentioned before, we want the playfield to be the central point of contact,
    so these two methods provide easy data pass-throughs that can be called from other
    classes. Both of these classes were used in the control layer, but they really
    do nothing special except reduce the number of classes that are directly connected
    to each other.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，我们希望游戏场是接触的中心点，因此这两个方法提供了易于数据传递的接口，可以从其他类中调用。这两个类都在控制层中使用，但它们实际上并没有做什么特别的事情，只是减少了直接相互连接的类的数量。
- en: Building the HUD
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建HUD
- en: We have a third layer that we need to build, the heads-up display (HUD) layer.
    This is a mostly trivial layer to implement, but it must be its own layer, for
    the same reasons we discussed with the controls. If this were on the main layer,
    the HUD would scroll off-screen whenever we moved away from the first view.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要构建一个第三层，即抬头显示层（HUD）。这个层实现起来主要是琐碎的，但它必须是一个独立的层，原因与我们在控制层讨论的原因相同。如果这个层在主层上，那么当我们从第一个视图移开时，HUD就会滚动出屏幕。
- en: '**Filename**: `TDHUDLayer.m`'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`TDHUDLayer.m`'
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'By now this should be simple code to read. We create three labels that are
    the fixed names of the stats presented: kills, health, and goals. We then create
    three counter labels for the corresponding values. This handles the initial construction
    of the layer, but we need to be able to update the values easily, so we create
    three helper methods.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，这应该是一段容易阅读的代码。我们创建了三个标签，它们是展示的统计数据固定名称：击杀数、生命值和目标。然后我们为相应的值创建了三个计数标签。这处理了层的初始构建，但我们需要能够轻松地更新值，因此我们创建了三个辅助方法。
- en: '**Filename**: `TDHUDLayer.m`'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`TDHUDLayer.m`'
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now we have three methods that allow us to easily change the values of the counter
    labels as needed. As you probably figured out, we will be calling these directly
    from the playfield layer. There is nothing fancy here, just code that works. You
    could always embellish this by adding some animation when the values change, or
    some other graphic flair. Since this code is self contained in its own layer,
    you can expand this without any changes to the playfield layer.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有三个方法，允许我们根据需要轻松地更改计数标签的值。正如你可能已经猜到的，我们将直接从游戏场层调用这些方法。这里没有什么花哨的，只是能工作的代码。你总是可以通过添加一些动画来装饰这个代码，当值改变时，或者添加一些其他的图形效果。由于这段代码在其自己的层中是自包含的，你可以扩展它而不需要修改游戏场层。
- en: Scene construction
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 场景构建
- en: We now have three layers for our game, and some layers need to know about the
    others. Nothing can be a child of the playfield layer, due to the scrolling issue.
    This is exactly the type of situation that causes us to prefer the separation
    of scene and layer files, unlike the common template format (a scene method embedded
    in the `CCLayer` class). If we were to do that, in which class would you include
    the scene method, since there is really not one parent layer? (Some would argue
    that the HUD should be the master layer, with others as children of it. Technically,
    that works too. We're not fans of that structure, however). Our solution is in
    the construction of the `TDPlayfieldScene` class.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们游戏有三个层，有些层需要了解其他层。由于滚动问题，没有任何东西可以是游戏场层的子层。这正是那种让我们倾向于场景和层文件分离的情况，与常见的模板格式（一个场景方法嵌入在`CCLayer`类中）不同。如果我们那样做，你会在哪个类中包含场景方法，因为实际上并没有一个父层？（有些人可能会争论HUD应该是主层，其他层作为其子层。技术上，这也行得通。但我们并不喜欢这种结构）。我们的解决方案在于构建`TDPlayfieldScene`类。
- en: '**Filename**: `TDPlayfieldScene.m`'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`TDPlayfieldScene.m`'
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This allows us to build all three layers in the correct order, with all being
    children of the scene. This way, none of the layers are children of each other.
    The playfield layer can be initialized with a reference to the HUD layer, and
    the controls can be initialized with a reference to the playfield layer. Everything
    works, and it is easily readable. This construction also makes it trivial to determine
    the hierarchy of the scenes and layers. The following screenshot shows what our
    game looks like with all layers included:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们以正确的顺序构建所有三个层，所有层都是场景的子层。这样，没有任何层是彼此的子层。游戏场层可以用对HUD层的引用进行初始化，控制层可以用对游戏场层的引用进行初始化。一切正常，而且易于阅读。这种构建方式也使得确定场景和层的层次结构变得非常简单。下面的截图显示了包含所有层的游戏外观：
- en: '![Scene construction](img/9007_08_09.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![场景构建](img/9007_08_09.jpg)'
- en: Tile helper methods
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 瓦片辅助方法
- en: 'One of the challenges in using tile maps is that we have at least two different
    coordinate positions that can be used to refer to a position on the map: pixels
    on the tilemap, and the tile coordinates. The tile coordinates relate to each
    individual tile, so the top left tile is (0,0) and the bottom right is (49,49)
    for our 50 by 50 map. What we need are some helper methods to easily convert between
    the two.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用瓦片地图时，我们面临的一个挑战是，我们至少有两种不同的坐标位置可以用来指代地图上的位置：瓦片地图上的像素和瓦片坐标。瓦片坐标与每个单独的瓦片相关，因此对于我们的50x50地图，左上角的瓦片是（0,0），右下角是（49,49）。我们需要一些辅助方法来轻松地在两者之间进行转换。
- en: '**Filename**: `TDPlayfieldLayer.m`'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `TDPlayfieldLayer.m`'
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here we are finally making use of the shorthand variables we saw in the `init`
    method. As a refresher, the variables are as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们终于开始使用我们在`init`方法中看到的缩写变量。作为一个提醒，变量如下：
- en: '`tmw` = tilemap width'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tmw` = 瓦片地图宽度'
- en: '`tmh` = tilemap height'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tmh` = 瓦片地图高度'
- en: '`tw` = tile width'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tw` = 瓦片宽度'
- en: '`th` = tile height'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`th` = 瓦片高度'
- en: So the `x` value is the position divided by the tile width. For the `y` value,
    the calculation is a little longer, because the origin point of the tile map is
    top left instead of bottom left. By multiplying the tilemap height times the tile
    height we have the total map height. From that we subtract the position, and then
    divide the result by the tile height. This gives us the reversed `y` positioning
    that we need. The final `CGPoint` from this method is the tile coordinate for
    the given position.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`x`值是位置除以瓦片宽度。对于`y`值，计算稍微长一些，因为瓦片地图的原点在左上角而不是左下角。通过将瓦片地图高度乘以瓦片高度，我们得到总地图高度。从那个值中减去位置，然后除以瓦片高度。这给了我们所需的反转`y`定位。此方法最终返回的`CGPoint`是给定位置的瓦片坐标。
- en: '**Filename**: `TDPlayfieldLayer.m`'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `TDPlayfieldLayer.m`'
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This method reverses the same calculation that we just saw. One callout on this
    method is the last bit of each formula. The "core" of the formulas will result
    in the edge of the tile being converted. By adding half the tile width (or subtracting
    half of the tile height), the end result is the center of the tile, which is what
    we want.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法反转了我们刚刚看到的相同计算。此方法的一个调用是每个公式的最后一位。公式的“核心”将导致瓦片的边缘被转换。通过添加瓦片宽度的一半（或减去瓦片高度的一半），最终结果是瓦片的中心，这正是我们想要的。
- en: Tile self-identification
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 瓦片自我识别
- en: We need some methods to perform what we refer to as self-identification. This
    is where we can "ask" each tile about any special properties.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些方法来执行我们所说的自我识别。这是我们可以“询问”每个瓦片关于任何特殊属性的地方。
- en: '**Filename**: `TDPlayfieldLayer.m`'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `TDPlayfieldLayer.m`'
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The first of these methods is the `isValidTileCoord` method, so we can check
    to see if a tile coordinate being passed is even on the map. A simple check on
    the lower bounds (zero) and the upper bounds (tilemap width, tilemap height) will
    allow us to return a Boolean value to identify if this is a valid tile.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法中的第一个是`isValidTileCoord`方法，因此我们可以检查传入的瓦片坐标是否在地图上。对下限（零）和上限（瓦片地图宽度，瓦片地图高度）的简单检查将允许我们返回一个布尔值来识别这是否是一个有效的瓦片。
- en: '**Filename**: `TDPlayfieldLayer.m`'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `TDPlayfieldLayer.m`'
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This method uses the `isValidTileCoord:` method to determine if the tile is
    valid. If it is not, then we can treat it as though it is a wall and return `YES`.
    Otherwise, we get the tile's GID for the specified tile coordinate in the walls
    layer. ( **GID** is a **Global Identifier** used by the tilemap.) We then poll
    the tilemap to get any properties related to that tile. We return the value for
    the key `Blocked`. If you recall when we built the map in Tiled, we gave the red
    tile a property of `Blocked`, with a value of `Yes`. Here is where we get the
    benefit of that tilemap. With this simple check, we can "ask" the map if there
    is a wall, and get a definitive answer. How easy is that?
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法使用`isValidTileCoord:`方法来确定瓦片是否有效。如果不是，则我们可以将其视为墙壁并返回`YES`。否则，我们获取墙壁层中指定瓦片坐标的瓦片的GID。（**GID**是瓦片地图使用的**全局标识符**。）然后我们查询瓦片地图以获取与该瓦片相关的任何属性。我们返回`Blocked`键的值。如果您还记得我们在Tiled中构建地图时，我们给红色瓦片分配了`Blocked`属性，其值为`Yes`。这里就是我们得到瓦片地图好处的地方。通过这个简单的检查，我们可以“询问”地图是否有墙壁，并得到一个明确的答案。这有多简单？
- en: We follow the same basic logic to identify both goal markers and health powerups.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遵循相同的基本逻辑来识别目标标记和健康增益。
- en: '**Filename**: `TDPlayfieldLayer.m`'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `TDPlayfieldLayer.m`'
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, the code is virtually identical between these methods. If you
    were so inclined, you could extrapolate a base method that could do both, but
    we prefer explicit method calls in this case, mostly because we only have two
    types of triggers.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这些方法之间的代码几乎完全相同。如果您愿意，可以推断出一个可以完成这两项任务的基础方法，但我们更喜欢在这种情况下使用显式的方法调用，主要是因为我们只有两种类型的触发器。
- en: Smarter hero walking
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更聪明的英雄行走
- en: With the code that we have covered so far, our hero will walk around without
    any awareness of the special tiles that we have placed, so he will walk right
    through walls. We need to fix this. Now that we have added methods to make it
    fairly simple to determine where our special triggers are, we can revisit the
    `setHeroPos` method, which we started earlier. This is a complete replacement
    of the earlier method.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的英雄将在没有任何对放置的特殊瓷砖的意识的情况下四处走动，所以他可以直接穿过墙壁。我们需要解决这个问题。现在我们已经添加了方法来使确定我们的特殊触发器位置变得相当简单，我们可以重新审视我们之前开始编写的`setHeroPos`方法。这是对之前方法的完全替换。
- en: '**Filename**: `TDPlayfieldLayer.m`'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`TDPlayfieldLayer.m`'
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We begin the method by converting the new hero position to a tile coordinate.
    We then check to see if this is actually a wall. If the desired coordinate is
    a blocked tile, then the method will return without moving the hero. This will
    effectively prevent the hero from walking on any of the blocked tiles. We then
    check for health powerups or goal markers, using our helper methods. If we have
    picked up a goal or health, we remove the corresponding tile from both the `_triggers`
    and the `_pickups` layers. Removing it from the `_pickups` layer will take away
    the visible tile, and removing it from the `_triggers` layer will prevent us from
    triggering the same event the next time the player passes over this tile. In both
    cases, we call out to the appropriate handling method to take action on the item
    that was picked up. After this new code, we see the same hero positioning and
    viewpoint centering code we saw earlier. Let's look at the item pickup handler
    methods.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从将新的英雄位置转换为瓷砖坐标开始这个方法。然后我们检查这实际上是否是一堵墙。如果所需的坐标是一个被阻挡的瓷砖，那么方法将返回而不移动英雄。这将有效地防止英雄在任何被阻挡的瓷砖上行走。然后我们检查健康提升或目标标记，使用我们的辅助方法。如果我们拾取了一个目标或健康，我们将相应的瓷砖从`_triggers`和`_pickups`层中移除。从`_pickups`层中移除它将移除可见的瓷砖，而从`_triggers`层中移除它将防止我们在玩家下次经过这个瓷砖时触发相同的事件。在这两种情况下，我们调用适当的手柄方法来对拾取的物品采取行动。在这段新代码之后，我们看到与之前相同的英雄定位和视点居中代码。让我们看看物品拾取处理方法。
- en: '**Filename**: `TDPlayfieldLayer.m`'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`TDPlayfieldLayer.m`'
- en: '[PRE27]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We decided that the hero should have a 40 point boost to his health when he
    picks up one of the odd cactus things. We update the `heroHealth` variable, and
    update the HUD by calling out to the `hudLayer` for the `changeHealthTo`: method
    we saw earlier.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定，当英雄拾取其中一个奇特的仙人掌物品时，他的健康应该增加40点。我们更新`heroHealth`变量，并通过调用`hudLayer`的`changeHealthTo`方法来更新HUD，这是我们之前看到的。
- en: '**Filename**: `TDPlayfieldLayer.m`'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`TDPlayfieldLayer.m`'
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: For the goal, we adjust the `heroGoalsRemaining` variable and change the HUD
    in a similar fashion. However, since the goals are the point of the game, we check
    to see if all the goals have been reached (picked up). If so, we set the `isGameOver`
    and `preventTouches` to `YES`, which will end the game when the next `update`
    loop runs.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于目标，我们调整`heroGoalsRemaining`变量并按类似方式更改HUD。然而，由于目标是游戏的核心，我们需要检查是否所有目标都已达成（被拾取）。如果是这样，我们将`isGameOver`和`preventTouches`设置为`YES`，这样在下一次`update`循环运行时将结束游戏。
- en: Time for bullets
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候发射子弹了
- en: All this running around and hitting walls is fine and good, but we need to be
    able to shoot, don't we? As you may recall from our discussion of the `TDControlLayer`
    class, you will recall that when the button is pressed we simply set the Boolean
    variable `heroShooting` to `YES`. We handle this value in the `TDPlayfieldLayer`
    update method.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些四处奔跑和撞墙的行为都很好，但我们确实需要能够射击，不是吗？如您从我们对`TDControlLayer`类的讨论中回忆起来，当按钮被按下时，我们只是将布尔变量`heroShooting`设置为`YES`。我们在`TDPlayfieldLayer`更新方法中处理这个值。
- en: '**Filename**: `TDPlayfieldLayer.m`'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`TDPlayfieldLayer.m`'
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We have left a few blanks here to fill in later, but this is the structure of
    the entire `update` method. When the `heroShooting` variable is `YES`, we evaluate
    the `currHeroShootSpeed` variable. If it is greater than zero, we subtract the
    delta time from it. If it has reached zero, we call the hero's `shoot` method.
    We then reset the `currHeroShootSpeed` to the value of the `shootSpeed` variable.
    This is set in the `init` method, and is set to a value of `0.2` to avoid ridiculous
    machine-gunning of bullets. This means you can only shoot a maximum of once every
    0.2 seconds. That's still fast enough, isn't it? If the hero is not shooting (that
    is, not pressing the shoot button), then we reset the `currHeroShootSpeed` variable
    to `0`. This allows the hero to shoot immediately when they press the button without
    having this "cooldown" timer delaying their shot.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里留下了一些空白，稍后填写，但这就是整个 `update` 方法的结构。当 `heroShooting` 变量为 `YES` 时，我们评估 `currHeroShootSpeed`
    变量。如果它大于零，我们从它中减去时间差。如果它已经达到零，我们调用英雄的 `shoot` 方法。然后我们将 `currHeroShootSpeed` 重置为
    `shootSpeed` 变量的值。这在 `init` 方法中设置，设置为 `0.2` 以避免子弹的疯狂扫射。这意味着您每0.2秒只能射击一次。这仍然很快，不是吗？如果英雄没有射击（即，没有按下射击按钮），那么我们将
    `currHeroShootSpeed` 变量重置为 `0`。这允许英雄在按下按钮时立即射击，而无需这个“冷却”计时器延迟射击。
- en: TDBullet class
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TDBullet 类
- en: Now that we know how to shoot, we need to know what we're shooting.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何射击，我们需要知道我们要射击什么。
- en: '**Filename**: `TDBullet.m`'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `TDBullet.m`'
- en: '[PRE30]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here we use the convenience method `bulletFactoryForLayer` to build the bullet.
    Because the `TDBullet` is a `CCSprite` subclass, we can use a call to `super initWithSpriteFrameName`
    to build the sprite. We keep a reference to the parent layer, and we set the `totalMoveDist`
    variable to be our limit of how far the bullet can travel before it expires. The
    variable `thisMoveDist` is used to determine how far on each update the bullet
    should travel. Most of the work of this class is done in the `update` method.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用便利方法 `bulletFactoryForLayer` 来构建子弹。因为 `TDBullet` 是 `CCSprite` 的子类，我们可以使用调用
    `super initWithSpriteFrameName` 来构建精灵。我们保留对父层的引用，并将 `totalMoveDist` 变量设置为子弹在过期前可以移动的最大距离。变量
    `thisMoveDist` 用于确定每次更新子弹应该移动多远。这个类的大部分工作都是在 `update` 方法中完成的。
- en: '**Filename**: `TDBullet.m`'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `TDBullet.m`'
- en: '[PRE31]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We begin this method by checking to make sure this bullet is not dead. It is
    possible to call `update` on a bullet in the process of being discarded, so this
    will prevent us from trying to move an object as it is being dereferenced. We
    then go through a bit of code that takes the current rotation and calculates a
    target in that direction that is `thisMoveDist` away from the current position.
    We subtract this from the `totalMoveDist` value, so we can keep track of how far
    the bullet has left to move. If the `totalMoveDist` variable reaches zero, then
    we call to the `parentLayer` object to remove the bullet. If it is not zero, we
    convert the bullet's current position to a tile coordinate using the method in
    the `parentLayer`. We then check to see if the tile is a wall. If it is, the bullet
    is removed, because we do not want the bullets to go through the walls.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从这个方法开始，检查确保这个子弹没有死亡。在丢弃子弹的过程中，可能调用 `update`，所以这将防止我们尝试移动正在解引用的对象。然后我们通过一段代码，获取当前旋转并计算一个在当前位置
    `thisMoveDist` 远的方向上的目标。我们从 `totalMoveDist` 值中减去这个值，这样我们就可以跟踪子弹还剩下多远可以移动。如果 `totalMoveDist`
    变量达到零，那么我们调用 `parentLayer` 对象来移除子弹。如果它不是零，我们使用 `parentLayer` 中的方法将子弹的当前位置转换为瓦片坐标。然后我们检查这个瓦片是否是墙壁。如果是，子弹将被移除，因为我们不希望子弹穿过墙壁。
- en: We also have two bullet-handling methods in the playfield layer.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏场层中，我们还有两个处理子弹的方法。
- en: '**Filename**: `TDPlayfieldLayer.m`'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `TDPlayfieldLayer.m`'
- en: '[PRE32]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If you recall from our review of the `TDHero` class, when the `shoot` method
    is called, it builds a bullet and then passes that bullet to the `addBullet` method
    of the layer stored in the `parentLayer` variable. Here you can see what that
    does. It adds it to the layer, and then adds the bullet to the `bulletArray` array.
    When we need to remove a bullet, we first set the bullet's `isDead` property to
    `YES`, and then remove the bullet from the array and the layer.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得我们之前对 `TDHero` 类的回顾，当调用 `shoot` 方法时，它会构建一个子弹，然后将该子弹传递给存储在 `parentLayer`
    变量中的层的 `addBullet` 方法。在这里，您可以看到它做了什么。它将其添加到层中，然后将子弹添加到 `bulletArray` 数组中。当我们需要移除子弹时，我们首先将子弹的
    `isDead` 属性设置为 `YES`，然后从数组和中移除子弹。
- en: 'The final bit of the bullet movement code that we need is in the `update` method
    of the `TDPlayfieldLayer`. We need to add a couple of lines there:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的子弹移动代码的最后部分在`TDPlayfieldLayer`的`update`方法中。我们需要在那里添加几行代码：
- en: '**Filename**: `TDPlayfieldLayer.m` (update method, under `Move The Bullets`):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `TDPlayfieldLayer.m`（在`Move The Bullets`下的`update`方法）:'
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is nicely compact code, just as we like it. Here we iterate through all
    the bullets in the `bulletArray`, and call each one's `update` method, with the
    current delta. We iterate using a traditional `for` loop instead of fast enumeration
    (that is `for (TDBullet *aBullet in bulletArray)`) because we may be calling for
    some bullets to die in this loop. Mutating the array while using fast enumeration
    will cause a crash. Don't believe us? Try it and you'll see for yourself.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码非常紧凑，正如我们所期望的那样。在这里，我们遍历`bulletArray`中的所有子弹，并调用每个子弹的`update`方法，使用当前的delta值。我们使用传统的`for`循环而不是快速枚举（即`for
    (TDBullet *aBullet in bulletArray)`)，因为我们可能在这个循环中调用某些子弹死亡。在快速枚举的同时修改数组会导致崩溃。你不相信我们？试试看，你自己就会看到。
- en: Building the enemy
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建敌人
- en: Now we have a world to run around in and bullets to shoot, but nobody to stop
    us from reaching our goals. We need to add some enemies to spice it up. As we
    go through the enemy handling code, keep in mind how we set up the hero. You will
    see a lot of similarities, and we could have compressed them into a single base
    class, but opted not to do so for clarity's sake.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个可以四处奔跑的世界和可以射击的子弹，但没有阻止我们达到目标的人。我们需要添加一些敌人来增加趣味性。当我们遍历敌人处理代码时，请记住我们是如何设置英雄的。你会看到很多相似之处，我们本可以将它们压缩到一个基类中，但为了清晰起见，我们选择没有这样做。
- en: '**Filename**: `TDEnemy.m`'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `TDEnemy.m`'
- en: '[PRE34]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here we have the constructors for the `TDEnemy` class. We keep a reference to
    the `parentLayer`, set the `maxShootSpeed` variable, and we call out to the `buildEnemySpriteAtPos`
    method.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`TDEnemy`类的构造函数。我们保留了对`parentLayer`的引用，设置了`maxShootSpeed`变量，并调用了`buildEnemySpriteAtPos`方法。
- en: '**Filename**: `TDEnemy.m`'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `TDEnemy.m`'
- en: '[PRE35]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Why did we break this method out separately, instead of embedding these two
    lines in the `init` method? We did this to make subclassing of the `TDEnemy` class
    easier. Because we have kept this separate, we can override this method without
    needing to override the `init` method in any subclasses of the `TDEnemy`. This
    allows us to not repeat the boilerplate `init` method for both enemy classes,
    when the only difference is the sprite used.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们要将这个方法单独提取出来，而不是将其嵌入到`init`方法中？我们这样做是为了使`TDEnemy`类的子类化更加容易。因为我们将其独立出来，所以我们可以在`TDEnemy`的任何子类中重写这个方法，而不需要重写`init`方法。这允许我们不必为两个敌人类重复编写样板`init`方法，因为它们之间唯一的区别是使用的精灵。
- en: '**Filename**: `TDEnemy.m`'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `TDEnemy.m`'
- en: '[PRE36]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This rotation method works the same way that the rotation method in the hero
    class operates. It determines the angle toward the specified target, and rotates
    accordingly.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个旋转方法与英雄类中的旋转方法工作方式相同。它确定指向指定目标的角度，并相应地旋转。
- en: '**Filename**: `TDEnemy.m`'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `TDEnemy.m`'
- en: '[PRE37]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here we are using some basic movement code. The enemy will determine the most
    direct path toward the hero, and try to move there. Just as we did with the hero
    and bullets, the enemies are unable to pass through walls. We don't have any special
    handling for the enemy to do something different when they hit a wall, so they
    will continue to try to move into a wall for as long as it is between the hero
    and the enemy. Not too smart, but this is supposed to be your basic enemy grunt.
    Not too bright.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用了一些基本的移动代码。敌人将确定通往英雄的最直接路径，并尝试移动到那里。就像我们对英雄和子弹所做的那样，敌人无法穿过墙壁。我们没有为敌人设置任何特殊处理，以便在它们碰到墙壁时做不同的事情，所以它们会继续尝试移动到墙壁，只要墙壁在英雄和敌人之间。不是很聪明，但这是你的基本敌人小兵。不是很聪明。
- en: '**Filename**: `TDEnemy.m`'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `TDEnemy.m`'
- en: '[PRE38]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This method is virtually identical to the hero's `shoot` method, with two exceptions.
    The first is that we set the `isEnemy` variable to `YES`, to identify that this
    is a bullet fired by an enemy unit. The second is that we set the bullet's color
    to red. The sprite we are using is blue, so this gives the enemy a "bad guys shoot
    red" effect. Everything else in this method is identical.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法几乎与英雄的`shoot`方法完全相同，有两个例外。第一个是我们将`isEnemy`变量设置为`YES`，以标识这是由敌人单位发射的子弹。第二个是我们将子弹的颜色设置为红色。我们使用的精灵是蓝色的，所以这给敌人一个“坏蛋射击红色”的效果。这个方法中的其他所有内容都是相同的。
- en: '**Filename**: `TDEnemy.m`'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `TDEnemy.m`'
- en: '[PRE39]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the enemy's `update` method, we move toward the hero's position on each update.
    We also check to see if the distance from the enemy to the hero is less than `250`
    points. If it is, then the enemy will try to shoot. Since he is already rotated
    toward the hero, he will always shoot directly at the hero.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在敌人的 `update` 方法中，我们每次更新时都向英雄的位置移动。我们还检查敌人到英雄的距离是否小于 `250` 点。如果是，那么敌人将尝试射击。由于他已经朝向英雄旋转，所以他总是会直接射击英雄。
- en: Just as with the bullets, we need to make a small addition to the main layer's
    `update` method to make the enemies move.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 就像子弹一样，我们需要在主层的 `update` 方法中添加一个小小的修改，以便让敌人移动。
- en: '**Filename**: `TDPlayfieldLayer.m` (update method, under `Move The Enemies`):'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `TDPlayfieldLayer.m` (更新方法，在 `Move The Enemies` 下):'
- en: '[PRE40]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This is virtually identical to the movement code for the bullets. For each update,
    we instruct each enemy to move himself.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎与子弹的移动代码相同。对于每次更新，我们指示每个敌人移动自己。
- en: Adding the enemies
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加敌人
- en: We now know how the enemy class is constructed, and how to make them move, so
    next we need to add them to the game itself.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了敌人类的构建方式和如何让它们移动，所以接下来我们需要将它们添加到游戏本身中。
- en: '**Filename**: `TDPlayfieldLayer.m`'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `TDPlayfieldLayer.m`'
- en: '[PRE41]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If you recall when we built the tilemap, we designated objects on the map named
    `EnemySpawn1`, `EnemySpawn2`, and so on. Now we can finally use those spawn points.
    We don't like the idea of enemies always spawning at the same spot, so we randomly
    pick a number between `1` and `11` using `arc4random()`. We use this to build
    a string that corresponds to an object name on our `spawns` layer of the tilemap.
    We can't use these values directly, because of the points versus pixels issue,
    so we divide the `x` and `y` coordinates by the `CC_CONTENT_SCALE_FACTOR()` to
    get the correct positioning.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得我们构建瓦片图时，我们指定了地图上的对象，命名为 `EnemySpawn1`、`EnemySpawn2` 等等。现在我们终于可以使用这些出生点了。我们不希望敌人总是在同一个地方出生，所以我们使用
    `arc4random()` 随机选择一个介于 `1` 和 `11` 之间的数字。我们使用这个数字构建一个与瓦片图的 `spawns` 层上的对象名称对应的字符串。我们不能直接使用这些值，因为存在点与像素的问题，所以我们将
    `x` 和 `y` 坐标除以 `CC_CONTENT_SCALE_FACTOR()` 来获取正确的定位。
- en: 'Here you see we have defined two types of enemy: `kEnemyEasy` and `kEnemyHard`.
    We use the same basic constructor for both, but the hard enemy will use the `TDEnemySmart`
    class instead (we''ll get to that later).'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到我们定义了两种类型的敌人：`kEnemyEasy` 和 `kEnemyHard`。我们为两者使用相同的构造函数，但困难敌人将使用 `TDEnemySmart`
    类（我们稍后会介绍）。
- en: Now, we need to be able to build enemies of both types in the game.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要能够在游戏中构建两种类型的敌人。
- en: '**Filename**: `TDPlayfieldLayer.m`'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `TDPlayfieldLayer.m`'
- en: '[PRE42]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We simply step through two `for` loops to add the specified number of enemies
    for each type. The numbers are arbitrarily chosen, and you can adjust them as
    you see fit to provide a hard enough challenge for you.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单地通过两个 `for` 循环来添加每种类型指定的敌人数量。这些数字是任意选择的，你可以根据需要调整它们，以提供足够困难的挑战。
- en: Collision handling
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞处理
- en: At this point we have everything we need, except for a way to make bullets hit
    the hero and enemies. What fun is shooting if you can't hit anything?
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经拥有了所有需要的东西，除了让子弹击中英雄和敌人的方法。如果你不能击中任何东西，射击还有什么乐趣呢？
- en: '**Filename**: `TDPlayfieldLayer.m`'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `TDPlayfieldLayer.m`'
- en: '[PRE43]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As we have seen, all the bullets in the game are stored in a single array, `bulletArray`.
    We iterate through that array and first check to see if a bullet hit the hero.
    We use `CGRectIntersectsRect` to see if there is any overlap of the `boundingBox`
    objects of the bullet and the hero. We also check the bullet's `isEnemy` property
    to make sure it is an enemy bullet. (Remember, we don't want any friendly-fire!)
    If the bullet is touching the hero and an enemy fired it, we register the collision.
    We call the `heroGetsHit` method, add the bullet to the `bulletsToDelete` array,
    and remove the bullet from the layer. Why didn't we use the `removeBullet` method
    that we saw earlier? We can't use that because we would be removing the bullet
    from the array while iterating through it, which would cause a mutation (leading
    to a crash). Because we need to remove the bullets after the iteration is done,
    we use the `bulletsToDelete` array instead.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，游戏中的所有子弹都存储在单个数组`bulletArray`中。我们遍历这个数组，首先检查子弹是否击中了英雄。我们使用`CGRectIntersectsRect`来查看子弹和英雄的`boundingBox`对象是否有任何重叠。我们还检查子弹的`isEnemy`属性，确保它是一个敌人子弹。（记住，我们不想有任何友军火力！）如果子弹触碰到英雄，并且是由敌人发射的，我们记录碰撞。我们调用`heroGetsHit`方法，将子弹添加到`bulletsToDelete`数组中，并从层中移除子弹。为什么我们没有使用之前看到的`removeBullet`方法呢？我们不能使用那个方法，因为我们会在遍历数组的同时移除子弹，这会导致突变（导致崩溃）。因为我们需要在迭代完成后移除子弹，所以我们使用`bulletsToDelete`数组。
- en: If the hero was not hit by a bullet, we then iterate through all enemies in
    the `enemyArray`. We do a similar check of each `boundingBox` and make sure it
    is not an enemy-fired bullet. If the enemy is hit, we call the `enemyGetsHit`
    method, and pass it a reference to the enemy that was hit.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果英雄没有被子弹击中，我们就遍历`enemyArray`中的所有敌人。我们对每个`boundingBox`进行类似的检查，确保它不是敌人发射的子弹。如果敌人被击中，我们调用`enemyGetsHit`方法，并传递被击中的敌人引用。
- en: Finally, we remove all bullets from the `bulletsToDelete` array (when the other
    loops are done) so we can remove them safely.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在其他循环完成后从`bulletsToDelete`数组中移除所有子弹（以便安全地移除）。
- en: We trigger the collision check in the update method, as follows.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在更新方法中触发碰撞检查，如下所示。
- en: '**Filename**: `TDPlayfieldLayer.m` (update method, under `Check collisions`):'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`TDPlayfieldLayer.m`（更新方法，在`检查碰撞`部分）：'
- en: '[PRE44]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We check for collisions at the end of every update, so we can always be using
    the current state of the game field.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在每个更新结束时检查碰撞，这样我们就可以始终使用游戏场的当前状态。
- en: Everybody gets hit
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每个人都被击中
- en: Now, we will look at the methods that were called when the hero or an enemy
    gets hit by a bullet. First, we will look at the hero.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将查看当英雄或敌人被子弹击中时调用的方法。首先，我们将查看英雄。
- en: '**Filename**: `TDPlayfieldLayer.m`'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`TDPlayfieldLayer.m`'
- en: '[PRE45]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Our hero is pretty tough, so a single bullet isn't enough to kill him. Instead,
    we subtract `20` from his health and update the HUD. If his health has reached
    zero, he is dead. We set the `isGameOver` variable to `YES` so it will be handled
    at the end of the update loop. This is why collisions are handled after the movement,
    and game over is checked for after the collision handler.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的英雄相当坚强，所以一枪不足以杀死他。相反，我们从他的生命值中减去`20`，并更新HUD。如果他的生命值达到零，他就死了。我们将`isGameOver`变量设置为`YES`，这样它将在更新循环的末尾被处理。这就是为什么碰撞处理在移动之后进行，游戏结束检查在碰撞处理之后进行。
- en: '**Filename**: `TDPlayfieldLayer.m`'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`TDPlayfieldLayer.m`'
- en: '[PRE46]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: When an enemy gets hit, they die immediately. We could have given them a health
    level like the hero, but who wants really strong enemies? We remove the enemy
    from the layer and remove it from the `enemyArray`. Because we want to track our
    hero's kill count, we increment his kills and call to the `hudLayer` to update
    the display. We then play a death sound, and spawn a new enemy. As it is written,
    we will only spawn easy enemies when any enemy dies. This could be modified, if
    you prefer to do something like randomly picking a new enemy type. We decided
    that the hard enemies were the commanders, and you can't as easily replace a commander
    as a grunt.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当敌人被击中时，他们会立即死亡。我们本可以给他们设置一个像英雄那样的生命值，但谁会想要真的强大的敌人呢？我们将敌人从层中移除，并从`enemyArray`中移除。因为我们想跟踪英雄的击杀数，所以我们增加他的击杀数，并调用`hudLayer`来更新显示。然后我们播放死亡声音，并生成一个新的敌人。按照目前的代码，当任何敌人死亡时，我们只会生成简单的敌人。这可以修改，如果你更喜欢随机选择一个新的敌人类型。我们决定困难敌人是指挥官，你不能像普通士兵那样轻易地替换指挥官。
- en: Game over, man
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏结束，伙计
- en: We have seen where we set game over conditions, so let's look at the actual
    game over method. It's pretty basic, but it serves its purpose.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了我们设置游戏结束条件的地方，那么让我们看看实际的游戏结束方法。它相当基础，但达到了目的。
- en: '**Filename**: `TDPlayfieldLayer.m`'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `TDPlayfieldLayer.m`'
- en: '[PRE47]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The first thing we do at game over is to unschedule the update so the enemies
    stop moving. As you may recall, when we have been setting the `isGameOver` variable,
    we have also been setting `preventTouches` to `YES`. That flag will stop any input
    from being accepted (as we saw in the `update` method of the `TDControlLayer`
    class), so here we just need to stop everything else from moving. If the hero
    is out of health, he died. Otherwise, they must have won, since the only two ways
    for the game to end are dying or collecting all of the goals. We call out the
    `hudLayer` to the `showGameOver` method, and then we set up a `3.0` second delay
    before the `preventTouches` is reset to `NO`. Once `preventTouches` is reset to
    `NO` from within the `CCCallBlock` action, then the `TDControlLayer` will accept
    the next touch to send the player back to the menu.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏结束时我们做的第一件事是取消更新计划，这样敌人就会停止移动。你可能还记得，当我们设置`isGameOver`变量时，我们也在设置`preventTouches`为`YES`。这个标志将阻止任何输入被接受（正如我们在`TDControlLayer`类的`update`方法中看到的那样），所以这里我们只需要停止其他所有东西的移动。如果英雄的生命值耗尽，他就死了。否则，他们必须已经赢了，因为游戏结束的唯一两种方式是死亡或收集所有目标。我们调用`hudLayer`到`showGameOver`方法，然后在将`preventTouches`重置为`NO`之前设置一个`3.0`秒的延迟。一旦`preventTouches`在`CCCallBlock`动作内部重置为`NO`，那么`TDControlLayer`将接受下一个触摸，将玩家送回菜单。
- en: You might be asking why we put the game over message in the `hudLayer` class.
    This is for convenience, since we really don't want to display user messages on
    the same layer as the tilemap. We could have created another layer for just the
    game over message, but that seemed like extra code that wasn't really needed.
    So we put it in the `hudLayer` class.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问为什么我们把游戏结束消息放在`hudLayer`类中。这是为了方便，因为我们真的不希望将用户消息显示在与瓦片图相同的层上。我们本可以创建一个仅用于游戏结束消息的另一个层，但这似乎是不必要的额外代码。所以我们把它放在了`hudLayer`类中。
- en: '**Filename**: `TDHUDLayer.m`'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `TDHUDLayer.m`'
- en: '[PRE48]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We display the message that was passed as the contents of a label, which we
    center on the screen. Obviously, this is pretty simple and barebones, but it serves
    its purpose. Feel free to dress it up and make it more sensational, if you so
    desire. For now, this is what you see when you die:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们显示传递给标签的内容作为消息，并将其居中显示在屏幕上。显然，这相当简单和基础，但它达到了目的。如果你愿意，可以随意装饰它，让它更加引人注目。现在，当你死亡时，你看到的是：
- en: '![Game over, man](img/9007_08_10.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![游戏结束，伙计](img/9007_08_10.jpg)'
- en: Smarter enemies
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更聪明的敌人
- en: We have a fully functional game at this point, except for fleshing out the smarter
    enemies. After quite a bit of experimentation, we have found several things that
    don't work to improve the enemies, and a couple of things we can do to make them
    better. We tried using an enemy that used `A* Pathfinding`, which is considered
    the "gold standard" of pathfinding algorithms. However, this was not a great answer
    for the enemies, as they would stop and pause to recalculate a new route, which
    would often take a second or two, depending on how far away from the hero they
    were. If you had a couple of these enemies in the game at the same time, the entire
    system would freeze for a second or two. Not good.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个功能齐全的游戏，除了完善更聪明的敌人。经过相当多的实验，我们发现了一些不起作用的方法来改善敌人，以及一些我们可以做的来使它们变得更好的方法。我们尝试使用一个使用`A*路径查找`的敌人，这被认为是路径查找算法的“黄金标准”。然而，这对敌人来说并不是一个好的答案，因为它们会停下来并暂停以重新计算新的路线，这通常需要一秒钟或两秒钟，具体取决于它们离英雄有多远。如果你在游戏中同时有几个这样的敌人，整个系统会冻结一秒钟或两秒钟。这不好。
- en: After trying some different approaches (and different `A*` implementations),
    we have settled on a hybrid enemy pathfinding. Most of the time it works like
    a standard enemy. The difference is when it hits a wall, it changes to use `A*
    Pathfinding` to negotiate a route to the hero around the wall. As soon as it reaches
    that destination, it reverts to the standard movement code.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试了不同的方法（以及不同的`A*`实现）之后，我们决定采用混合敌人路径查找。大多数时候它就像一个标准的敌人。区别在于当它撞到墙时，它会改为使用`A*路径查找`来绕过墙壁找到英雄的路线。一旦它到达那个目的地，它就会恢复到标准移动代码。
- en: Code not covered here
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这里未涵盖的代码
- en: We have decided that, far from being experts at `A* Pathfinding`, we will be
    using the `A*` code written by Johann Fradj, and published in a tutorial at [http://www.raywenderlich.com](http://www.raywenderlich.com).
    We have included it in this project with the permission of both Johann Fradj and
    Ray Wenderlich. (Thanks to you both!)
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定，我们远非 `A* 路径查找` 的专家，我们将使用 Johann Fradj 编写的 `A*` 代码，并在 [http://www.raywenderlich.com](http://www.raywenderlich.com)
    的教程中发布。我们已经在 Johann Fradj 和 Ray Wenderlich 的许可下将其包含在这个项目中。（感谢你们两位！）
- en: 'Instead of covering this code method by method, I will instead refer you to
    his tutorial, from which this code was taken:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会逐个方法地介绍这段代码，而是会向您推荐他的教程，这段代码就是从那里来的：
- en: '[http://www.raywenderlich.com/4970/how-to-implement-a-pathfinding-with-cocos2d-tutorial](http://www.raywenderlich.com/4970/how-to-implement-a-pathfinding-with-cocos2d-tutorial)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.raywenderlich.com/4970/how-to-implement-a-pathfinding-with-cocos2d-tutorial](http://www.raywenderlich.com/4970/how-to-implement-a-pathfinding-with-cocos2d-tutorial)'
- en: He explains it better than we can, and it is a very good explanation. Instead
    of quoting his code in detail here, we will instead explain our modifications
    to his code, and our rationale for doing so. (We might miss some minor modifications,
    but we'll try to cover the major ones.)
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 他解释得比我们更好，这是一个非常好的解释。我们不会在这里详细引用他的代码，而是会解释我们对他的代码的修改，以及我们这样做的原因。（我们可能错过了一些小的修改，但我们会尽量涵盖主要的修改。）
- en: The first major modification we made is to rename the class `ShortestPathStep`
    to `AStarNode`. This is because it is a shorter name, and it was originally being
    overlaid on an earlier code base. Really, it was mostly because we wanted a shorter
    name that felt like a better description to us.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做的第一个主要修改是将类 `ShortestPathStep` 重命名为 `AStarNode`。这是因为名字更短，而且它最初是叠加在一个较早的代码库上的。实际上，这主要是因为我们想要一个更短的名字，这个名字对我们来说感觉像是一个更好的描述。
- en: Our entrance to the `A*` code is in the `moveTowardWithPathfinding` method in
    the `TDEnemySmart` class. We perform our `rotateToTarget` at the beginning of
    this class, so we are always pointed in the right direction.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进入 `A*` 代码的入口是在 `TDEnemySmart` 类中的 `moveTowardWithPathfinding` 方法。我们在本类的开头执行
    `rotateToTarget`，因此我们始终指向正确的方向。
- en: The other major change we made to the code is to insert the Boolean variable
    `isUsingPathfinding` to control when the `A*` code would recursively call itself.
    Because we wanted to revert to simple pathfinding after an obstacle was passed,
    we turn off the `isUsingPathfinding` in each of the `if` statements in the `popStepAndAnimate`
    method.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对代码做的另一个主要修改是在代码中插入布尔变量 `isUsingPathfinding` 来控制 `A*` 代码何时会递归地调用自己。因为我们希望在通过障碍物后恢复到简单的路径查找，所以在
    `popStepAndAnimate` 方法中的每个 `if` 语句中关闭了 `isUsingPathfinding`。
- en: We urge you to read Johann's wonderful tutorial (as well as a related *Introduction
    To A* Pathfinding* that is linked to from that tutorial) to learn more about how
    `A* Pathfinding` works, as well as consulting the source code bundle for this
    chapter to see how our `TDEnemySmart` class is constructed.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们敦促您阅读 Johann 的精彩教程（以及从该教程链接的 *A* 路径查找简介*），以了解更多关于 `A* 路径查找` 的工作原理，以及查阅本章的源代码包，以了解我们的
    `TDEnemySmart` 类是如何构建的。
- en: Summary
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have covered a lot of material that is familiar yet new here. We have leveraged
    quite a few community resources for this project. We built our tile map with Tiled.
    We used SneakyJoystick rather than build our own joystick and button classes.
    We have dipped our toe in the `A*` waters with the help of Johann Fradj. We kept
    our layers separated into functional units so we could keep our code cleaner and
    more performant. Not to mention we had the opportunity to ponder why an orange
    would be the mortal enemy of lettuce.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们覆盖了大量的熟悉而又新的材料。我们为这个项目利用了许多社区资源。我们使用 Tiled 构建了我们的瓦片地图。我们使用了 SneakyJoystick
    而不是自己构建摇杆和按钮类。在 Johann Fradj 的帮助下，我们尝试了 `A*` 的水。我们保持我们的层分离成功能单元，这样我们可以保持我们的代码更干净、性能更高。不用说，我们还有机会思考为什么橙子会是生菜的致命敌人。
- en: This game is very basic on purpose. Once you master the concepts we covered
    here, it is easy to leverage this project to power a much bigger (and more sensible,
    perhaps) game. One of the great things about creating a game with tilemaps is
    that there is a lot of directly reusable code from game to game. For instance,
    the `isValidTile`, `isWall`, and so on methods are easily adaptable to any tilemap-based
    project. Reusability of code is key to writing code faster.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这款游戏故意设计得非常基础。一旦你掌握了我们在这里介绍的概念，利用这个项目来驱动一个更大（也许更合理）的游戏就变得轻而易举。使用瓦片地图创建游戏的一个优点是，从一款游戏到另一款游戏，有很多可以直接复用的代码。例如，`isValidTile`、`isWall`等方法很容易适应任何基于瓦片地图的项目。代码的可复用性是快速编写代码的关键。
- en: As we have probably made clear, we are big fans of open source tools and projects,
    both to use for our own development, but also to learn from those with much more
    experience.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们可能已经明确指出的，我们是开源工具和项目的忠实粉丝，不仅用于我们自己的开发，还从那些经验更丰富的人那里学习。
- en: 'Now we need to take a deep breath before we take on the final project of this
    book: An endless runner.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要在着手进行本书的最终项目——无尽跑酷游戏之前深呼吸一下。
