- en: '*Chapter 2*: Working with Dark Mode'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第二章*: 与DarkMode一起工作'
- en: We all love it…well most of us do anyway, and those who do have been asking
    for it for a while now too. Apple first took the plunge into Dark Mode with macOS
    Mojave back in 2018, not only changing the way users interacted with the OS but
    also paving the way for developers to build native dark-themed apps for the first
    time.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都喜欢它……嗯，至少我们大多数人都是这样，而且那些喜欢它的人也已经期待它有一段时间了。苹果首次在2018年macOS Mojave中尝试Dark Mode，不仅改变了用户与操作系统交互的方式，还为开发者首次构建原生深色主题应用铺平了道路。
- en: Dark mode for iPhone wasn't announced until WWDC 2019, but we all knew it was
    coming, and with everything that AppKit had offered, we knew we were in for a
    treat with what UIKit would have to offer.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: iPhone的DarkMode直到2019年WWDC才宣布，但我们都知道它即将到来，而且有了AppKit所提供的一切，我们知道UIKit将提供什么，我们将会享受到一份大礼。
- en: In this chapter, we'll cover everything you need to know to get up and running
    with dark mode in iOS and iPadOS; everything from taking an existing app and making
    the necessary adjustments to support dark mode, to all the little hidden extras
    that we can add in when building our app to ensure we give the user the best possible
    experience. We'll also touch on best practices too – taking note of the little
    things we can do that allow Dark Mode in UIKit to make our lives so much easier
    from the start.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖您需要了解的所有内容，以便在iOS和iPadOS中启动并运行DarkMode；从将现有应用进行调整以支持DarkMode，到在构建我们的应用时添加的所有小而隐藏的额外功能，以确保我们为用户提供最佳体验。我们还将讨论最佳实践——注意我们可以做的那些小事，让UIKit中的DarkMode从一开始就使我们的生活变得容易得多。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: What is Dark Mode?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是DarkMode？
- en: Working with views in Dark Mode
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在DarkMode中与视图一起工作
- en: Working with assets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与资产一起工作
- en: Further exploring Dark Mode
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进一步探索Dark Mode
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you'll need to download Xcode version 11.4 or above from Apple's
    App Store.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您需要从苹果的App Store下载Xcode版本11.4或更高版本。
- en: You'll also need to be running the latest version of macOS (Catalina or above).
    Simply search for Xcode in the App Store and select and download the latest version.
    Launch Xcode and follow any additional installation instructions that your system
    may prompt you with. Once Xcode has fully launched, you're ready to go.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要运行最新版本的macOS（Catalina或更高版本）。只需在App Store中搜索Xcode，选择并下载最新版本。启动Xcode，并遵循系统可能提示的任何附加安装说明。一旦Xcode完全启动，您就可以开始了。
- en: 'Download the sample code from the following GitHub link: [https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition](https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下GitHub链接下载示例代码：[https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition](https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition)。
- en: What is Dark Mode?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是DarkMode？
- en: In this section, we'll start by taking a look at what exactly Dark Mode is,
    how we can use it, and what it can do not only for the end user but also for developers.
    We'll cover everything from enabling it on our devices to using environment overrides
    in Xcode and developer options in the simulator.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将首先探讨Dark Mode究竟是什么，我们如何使用它，以及它不仅对最终用户，也对开发者能做什么。我们将从在我们的设备上启用它，到在Xcode中使用环境覆盖以及在模拟器中的开发者选项，涵盖所有内容。
- en: Understanding why we would need Dark Mode
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解为什么我们需要DarkMode
- en: As I covered in the introduction of this chapter, most of us have been craving
    dark mode in iOS for a very long time now. Us developers got our Xcode fix back
    in 2018 – but one of the burning questions I've been asked many times (especially
    in the past 12 months) is…why?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在本章引言中提到的，我们大多数人已经非常渴望iOS中的DarkMode有一段时间了。我们开发者早在2018年就解决了Xcode的问题——但我在很多次（尤其是在过去12个月里）被问到的热门问题之一是……为什么？
- en: It could be down to something as simple as the time of the day. Satellite navigation
    systems have been doing it in our cars for years – as soon as the sun goes down,
    our system switches, and a more relaxing, subtle version of our road home pops
    up on our screen – so why not do that for our apps?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能只是因为一天中的某个简单时间。卫星导航系统在我们的汽车中已经这样做了很多年——一旦太阳下山，我们的系统就会切换，屏幕上就会弹出更加轻松、微妙的回家路线——那么为什么不为我们的应用做同样的事情呢？
- en: Well, it turns out that some apps have already been doing that for a while (to
    a degree), while not necessarily offering an automatic nocturnal mode. The Twitter
    app for iOS offered a "dark mode" option long before the WWDC 19 announcement.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，事实证明，一些应用程序已经这样做了一段时间（在一定程度上），尽管它们并不一定提供自动夜间模式。iOS 的 Twitter 应用在 WWDC 19 宣布之前就提供了“暗黑模式”选项。
- en: 'Let''s stop for a moment and think about the logic behind such a control, along
    with everything you''d need to change to achieve this. I''m sure a company as
    big as Twitter has written their own internal framework to handle this, but under
    the hood, it''s basically going look a lot like the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们停下来，思考一下这种控制的逻辑，以及你需要改变的一切来实现这一点。我相信像 Twitter 这样的大公司已经编写了自己的内部框架来处理这个问题，但底层基本上看起来会像以下这样：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Everything will have to be taken into consideration, from the text color to
    the drop shadows that you might have decorating your UIButton or UIViews.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从文本颜色到可能装饰你的 UIButton 或 UIViews 的阴影，所有这些都需要考虑。
- en: The background is a massive change to consider too. One common pattern that
    a lot of iOS developers follow is to quite simply develop a brand-new app on top
    of a white canvas; from here, we don't need to worry about controlling the background
    color or keeping track of it with an IBOutlet – it's simply the tablecloth for
    the rest of our app to sit on.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 背景也是一个需要考虑的重大变化。许多 iOS 开发者遵循的一个常见模式是，简单地在白色画布上开发全新的应用程序；从这里开始，我们不需要担心控制背景颜色或用
    IBOutlet 跟踪它——它只是我们应用程序其余部分的桌布。
- en: With implementing a dark mode feature, everything needs to be changed – even
    asset images that sit proudly on one style of background could be lost in another.
    Let's take a look at some of the developer features that come bundled with Xcode
    when implementing Dark Mode.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现暗黑模式功能后，一切都需要改变——甚至那些自豪地坐在一种背景风格上的资产图像，在另一种背景下可能会消失。让我们看看在实现暗黑模式时，Xcode附带的一些开发者功能。
- en: Core developer concepts of Dark Mode
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 暗黑模式的核心开发者概念
- en: 'Let''s start by taking a look at how we go about developing with Dark Mode
    by switching to it on our device. If you''ve not already done this, you can simply
    toggle it by going to **Settings** | **Display & Brightness**, and you should
    be presented with the following screen:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从如何在设备上开启暗黑模式来开发开始看起。如果你还没有这样做，你可以通过前往**设置** | **显示与亮度**来简单地切换它，你应该会看到以下屏幕：
- en: '![Figure 2.1 – Display and brightness'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.1 – Display and brightness'
- en: '](img/Figure_2.01_B14717.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_2.01_B14717.jpg]'
- en: Figure 2.1 – Display and brightness
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 显示与亮度
- en: You'll also notice the **Automatic** toggle option too, giving us the ability
    to use either **Sunset to Sunrise** or a custom schedule, which will automatically
    switch between light and dark appearance (just like our sat nav).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会注意到**自动**切换选项，这让我们能够使用**日落至日出**或自定义计划，这将自动在亮暗外观之间切换（就像我们的卫星导航一样）。
- en: 'Now that we''ve got that covered, let''s take a look at some options given
    to developers in the iOS simulator. Let''s start by taking the following steps:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经覆盖了这一点，让我们看看 iOS 模拟器提供给开发者的选项。让我们先采取以下步骤：
- en: Open up Xcode.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Xcode。
- en: Launch the simulator (**Xcode | Open Developer Tool | Simulator**).
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动模拟器（**Xcode | 打开开发者工具 | 模拟器**）。
- en: 'In a slightly different location than the end user''s version of iOS, you''ll
    find the dark toggle under the developer settings (**Settings | Developer | Dark
    Appearance**):'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在比最终用户版本的 iOS 略有不同的位置，你会在开发者设置下找到暗黑模式切换（**设置 | 开发者 | 暗黑外观**）：
- en: '![Figure 2.2 – Dark mode developer settings'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.2 – Dark mode developer settings'
- en: '](img/Figure_2.02_B14717.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_2.02_B14717.jpg]'
- en: Figure 2.2 – Dark mode developer settings
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – 暗黑模式开发者设置
- en: Rather than a fancy interface like we saw earlier, we're presented with just
    the standard toggle. Let's take a look now at what we can do as developers with
    Dark Mode.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前看到的复杂界面不同，我们只看到了标准的切换按钮。现在让我们看看作为开发者，我们可以用暗黑模式做些什么。
- en: Dark mode from inside Xcode
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Xcode 内部的暗黑模式
- en: Now that we've taken a look at how iOS handles switching to dark mode, let's
    have a look at how we, the developer, can do the same in Xcode.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 iOS 如何处理切换到暗黑模式，让我们看看我们，作为开发者，如何在 Xcode 中做到同样的事情。
- en: Out of the box, all new projects building against the iOS 13 SDK will automatically
    support dark mode; however, building against any earlier SDKs won't.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，所有针对 iOS 13 SDK 的新项目都将自动支持暗黑模式；然而，针对任何更早的 SDK 的构建则不会。
- en: This helps out a little as your existing app may not have all the necessary
    tweaks to support dark mode yet and you don't want to release an update to find
    you have broken your app for those now running dark mode.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这对现有应用可能没有所有必要的调整来支持深色模式有些帮助，而且你不想发布更新后发现自己破坏了运行深色模式的应用。
- en: However, if you update your project to the iOS 13 SDK, then you could potentially
    run into this problem, but don't worry, we'll cover getting your existing app
    ready for dark mode later, in the *Migrating existing apps to Dark Mode* section
    in this chapter.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你将你的项目更新到 iOS 13 SDK，那么你可能会遇到这个问题，但不用担心，我们将在本章后面的 *将现有应用迁移到深色模式* 部分介绍如何让你的现有应用为深色模式做好准备。
- en: Let's start by having a look at storyboards – we all love them (or hate them)
    but the one thing they have done over the years is present themselves on a whiter-than-white
    canvas.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看故事板——我们都喜欢它们（或者讨厌它们），但多年来它们所做的一件事就是在一个比白色还要白的画布上展示自己。
- en: 'Let''s get started:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: Launch Xcode and create a new **Single View - Storyboard** project.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Xcode 并创建一个新的 **单视图 - 故事板**项目。
- en: Call this anything you want (I'll call mine `Chapter 2 - Dark Mode`).
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以将其命名为任何你想要的名字（我将命名为“第 2 章 - 深色模式”）。
- en: You can either follow along throughout this chapter or download the sample code
    from GitHub.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以跟随本章的内容进行学习，或者从 GitHub 下载示例代码。
- en: 'Once created, click on **Main.Storyboard** and you should be presented with
    the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 创建完成后，点击 **Main.Storyboard**，你应该会看到以下内容：
- en: '![Figure 2.3 – Xcode interface style'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.3 – Xcode 界面风格'
- en: '](img/Figure_2.03_B14717.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.03_B14717.jpg)'
- en: Figure 2.3 – Xcode interface style
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – Xcode 界面风格
- en: I've highlighted in the preceding screenshot our area of interest – here, we
    have a preview toggle for both light and dark appearances from within the storyboard,
    so at a quick glance, we can see what the objects we've added to our canvas look
    like without the need to launch the simulator.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我突出显示了我们的兴趣区域——在这里，我们可以在故事板中预览浅色和深色外观的切换，因此我们可以快速看到我们添加到画布上的对象的外观，而无需启动模拟器。
- en: Now, this won't always help us as some of our UILabels or UIButtons could be
    decorated programmatically. However, it's a great start and will most definitely
    come in useful during the development cycle of any app.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这并不总是能帮到我们，因为我们的某些 UILabel 或 UIButtons 可能会通过编程方式装饰。然而，这是一个很好的开始，并且肯定会在任何应用的开发周期中派上用场。
- en: 'Let''s take a look at our labels in action. Here, we''ve added a UILabel straight
    out of the box. **Light Appearance** is selected, and the label looks just how
    we are used to seeing things at this stage:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的标签在实际应用中的样子。这里，我们直接添加了一个 UILabel。**浅色外观**被选中，标签看起来就像我们在这个阶段习惯看到的那样：
- en: '![Figure 2.4 – Main storyboard'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.4 – 主故事板'
- en: '](img/Figure_2.04_B14717.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.04_B14717.jpg)'
- en: Figure 2.4 – Main storyboard
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – 主故事板
- en: 'Now, let''s switch the toggle to **Dark Appearance** and see what happens:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们切换到 **深色外观**并看看会发生什么：
- en: '![Figure 2.5 – Main storyboard – dark mode'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.5 – 主故事板 – 深色模式'
- en: '](img/Figure_2.05_B14717.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.05_B14717.jpg)'
- en: Figure 2.5 – Main storyboard – dark mode
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – 主故事板 – 深色模式
- en: As if by magic, our canvas enters dark mode, and the color of our UILabel is
    automatically adjusted. We can see straight away, without the need to compile
    or run the app on a device or in the simulator, how it will look with each interface
    style.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 就像魔法一样，我们的画布进入了深色模式，我们的 UILabel 的颜色会自动调整。我们可以立即看到，无需在设备或模拟器上编译或运行应用，每个界面风格下的外观。
- en: I guess the million-dollar question is *how did iOS know to switch the color
    of the UILabel's font?* Good question, and we'll cover that in more detail in
    the *Working with views and Dark Mode* section later in this chapter.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我想一百万个问题中的一个是 *iOS 是如何知道切换 UILabel 字体的颜色的？* 好问题，我们将在本章后面的 *与视图和深色模式一起工作* 部分更详细地介绍。
- en: However, as I mentioned earlier, there are going to be occasions where you'll
    need to test your app in the simulator. Labels and views will not always be static
    and could be generated dynamically – this is where environment overrides come
    in.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如我之前提到的，有些时候你需要在模拟器中测试你的应用。标签和视图不总是静态的，可能会动态生成——这就是环境覆盖的作用所在。
- en: 'We''ll start by launching our app in the simulator. Once successfully launched,
    you should see the following highlighted option available in Xcode:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在模拟器中启动我们的应用。一旦成功启动，你应该在 Xcode 中看到以下高亮选项：
- en: '![Figure 2.6 – Environment Overrides'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.6 – 环境覆盖'
- en: '](img/Figure_2.06_B14717.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 2.06_B14717.jpg](img/Figure_2.06_B14717.jpg)'
- en: Figure 2.6 – Environment Overrides
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 – 环境覆盖
- en: Click on this icon and you'll be presented with the **Environment Overrides**
    popup. Here, you'll have the option to toggle the **Interface Style** overrides,
    which in turn will allow you to choose between light and dark appearance.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 点击此图标，你将看到一个 **环境覆盖** 弹出窗口。在这里，你可以选择切换 **界面样式** 覆盖，这反过来又允许你选择亮色和暗色外观。
- en: If you flick the toggle and switch between each option, you'll see your app
    in the simulator automatically update without the need to close your app, change
    the settings, and re-launch. Very nice indeed – thanks, Xcode!
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你切换开关并在每个选项之间切换，你会在模拟器中看到你的应用自动更新，无需关闭应用、更改设置和重新启动。确实非常不错——感谢，Xcode！
- en: 'One last little thing to point out before we move on: we mentioned previously
    that existing apps built with previous iOS SDKs won''t be affected by dark mode,
    but should you choose to update your app to the iOS 13 SDK, you may run into a
    couple of issues.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，有一点需要指出：我们之前提到，使用旧版 iOS SDK 开发的现有应用不会受到深色模式的影响，但如果你选择将你的应用更新到 iOS 13
    SDK，你可能会遇到一些问题。
- en: Tight deadlines and urgent bug fixes might not necessarily give you the chance
    to adopt dark mode in your app, so Xcode gives you the option to force light appearance
    regardless of the user's preference.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 紧迫的截止日期和紧急的 bug 修复可能不会给你机会在你的应用中采用深色模式，所以 Xcode 给你提供了强制亮色外观的选项，无论用户的偏好如何。
- en: 'In `Info.plist` (or the `Light`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Info.plist`（或 `Light`：
- en: '[PRE1]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![Figure 2.7 – Info.plist – User Interface Style'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.7 – Info.plist – 用户界面样式'
- en: '](img/Figure_2.07_B14717.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 2.07_B14717.jpg](img/Figure_2.07_B14717.jpg)'
- en: Figure 2.7 – Info.plist – User Interface Style
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 – Info.plist – 用户界面样式
- en: You'll now see that even with the environment overrides, you won't be able to
    switch to dark mode.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你会发现，即使在环境覆盖的情况下，你也不能切换到暗色模式。
- en: In this section, we got up and running with Dark Mode in iOS and, more importantly,
    Xcode, and learned about the little things that Xcode does to get us ready for
    developing our apps in both light and dark appearance. In the next section, we'll
    begin to look at how Xcode handles views and introduce ourselves to semantic "dynamic"
    colors.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们开始使用 iOS 和，更重要的是，Xcode 的深色模式，并了解了 Xcode 为我们准备开发具有亮色和暗色外观的应用所做的小事情。在下一节中，我们将开始探讨
    Xcode 如何处理视图，并介绍语义“动态”颜色。
- en: Working with views in Dark Mode
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在深色模式下使用视图
- en: So far in this chapter, we've covered not only what dark mode is but also what
    it has to offer from a development perspective.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们不仅介绍了深色模式是什么，还介绍了它从开发角度提供了什么。
- en: In this chapter, we're going to deep dive further into dark mode by looking
    at how Xcode dynamically handles our UIViews (and objects that are sub-classed
    from UIViews).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将进一步深入研究深色模式，看看 Xcode 如何动态处理我们的 UIView（以及从 UIView 派生的对象）。
- en: We'll start by understanding the core concept behind adaptive and semantic colors,
    and by following a simple pattern, Xcode can do so much of the heavy lifting for
    us.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将理解自适应和语义颜色的核心概念，并通过遵循一个简单的模式，Xcode 可以为我们做很多繁重的工作。
- en: We'll then dive further and take a look at the various levels of semantic colors
    available to us, including primary, secondary, and tertiary options, but more
    importantly, when we would be expected to use them.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将进一步深入，看看我们可用的各种语义颜色级别，包括主要、次要和三级选项，但更重要的是，我们何时会期望使用它们。
- en: What are adaptive colors?
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是自适应颜色？
- en: For me, this was a major step in getting developers on board with designing
    and developing their apps for dark mode and, of course, it was well within Apple's
    interest to make it as seamless as possible for the developer.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，这是让开发者参与设计和开发他们的深色模式应用的一个重大步骤，当然，苹果公司也有兴趣让开发者体验尽可能无缝。
- en: 'Adaptive colors are a way of defining a single color type or style for a particular
    appearance. Let''s start by diving straight into Xcode and seeing this for ourselves:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 自适应颜色是定义特定外观的单个颜色类型或风格的一种方式。让我们直接进入 Xcode，看看我们自己的情况：
- en: Head back on over to the project you previously created and highlight the UILabel
    we added in.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到你之前创建的项目，并突出显示你添加的 UILabel。
- en: 'Now, take a look at the **Color** property in the **Attributes Inspector**
    window:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，看看 **属性检查器** 窗口中的 **颜色** 属性：
- en: '![Figure 2.8 – Label properties'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.8 – 标签属性'
- en: '](img/Figure_2.08_B14717.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 2.08_B14717.jpg](img/Figure_2.08_B14717.jpg)'
- en: Figure 2.8 – Label properties
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8 – 标签属性
- en: You'll notice that the color selected is **Default (Label Color)** – **Label
    Color** is our adaptive color.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到选中的颜色是**默认（标签颜色）**——**标签颜色**是我们的自适应颜色。
- en: 'But what does that mean? Actually, it''s very simple: it means that for one
    interface style it''s one color, and for the other, it''s a different color.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 但这究竟意味着什么？实际上，这非常简单：它意味着对于一种界面风格，它是一种颜色，而对于另一种，则是不同的颜色。
- en: In the case of our previous example, our UILabel was black in light mode and
    white in dark mode – makes sense, right?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，我们的UILabel在浅色模式下是黑色，在深色模式下是白色——这说得通，对吧？
- en: Well, to a degree is does, but surely it depends on what type of background
    our UILabel sits on – let's take a look.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，在某种程度上是的，但当然这取决于我们的UILabel所在的背景类型——让我们看看。
- en: 'Back in our storyboard, highlight the background of our view and again head
    over to the **Attributes Inspector** window:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的故事板中，突出显示我们的视图的背景，然后再次转到**属性检查器**窗口：
- en: '![Figure 2.9 – Background color properties'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.9 – 背景颜色属性'
- en: '](img/Figure_2.09_B14717.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.09_B14717.jpg)'
- en: Figure 2.9 – Background color properties
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 – 背景颜色属性
- en: Again, here we have our adaptive color, **System Background Color**. Xcode is
    doing all the work for us when we need to switch appearances.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这里我们有我们的自适应颜色，**系统背景颜色**。当我们需要切换外观时，Xcode会为我们做所有的工作。
- en: The preceding parts in the section are a great example of contrasting between
    two primary colors (black and white used in our labels), which itself is the stereotypical
    understanding between what colors should be in light and dark appearance – but
    we're not always going to be using black or white, are we?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 该节前面的部分是两个主要颜色（在我们的标签中使用黑色和白色）之间对比的一个很好的例子，这本身就是对浅色和深色外观中颜色应该是什么的典型理解——但我们并不总是使用黑色或白色，对吧？
- en: So, Apple has updated all their available system colors to be adaptive. Let's
    take a look.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，苹果已经更新了所有可用的系统颜色以使其具有自适应功能。让我们看看。
- en: 'Head back over to Xcode and highlight our UILabel, and change **Color** to
    **System Indigo Color**:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 回到Xcode，突出显示我们的UILabel，并将**颜色**更改为**系统靛蓝色**：
- en: '![Figure 2.10 – Font color properties'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.10 – 字体颜色属性'
- en: '](img/Figure_2.10_B14717.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.10_B14717.jpg)'
- en: Figure 2.10 – Font color properties
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 – 字体颜色属性
- en: 'Now, let''s switch between light and dark mode using the toggle in Xcode''s
    storyboard. What do we see? The color indigo, just as we expected:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用Xcode的故事板中的切换按钮在浅色模式和深色模式之间切换。我们看到的是什么？正是我们预期的靛蓝色：
- en: '![Figure 2.11 – Light mode with Indigo text color'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.11 – 带有靛蓝色文字的浅色模式'
- en: '](img/Figure_2.11_B14717.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.11_B14717.jpg)'
- en: Figure 2.11 – Light mode with Indigo text color
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11 – 带有靛蓝色文字的浅色模式
- en: 'The following screenshot shows the screen with dark mode:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了深色模式的屏幕：
- en: '![Figure 2.12 – Dark mode with indigo text color'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.12 – 带有靛蓝色文字的深色模式'
- en: '](img/Figure_2.12_B14717.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.12_B14717.jpg)'
- en: Figure 2.12 – Dark mode with indigo text color
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12 – 带有靛蓝色文字的深色模式
- en: 'However, each system color has been specifically adapted to each appearance.
    Let''s take a look at the RGB values for each appearance:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，每个系统颜色都已被专门调整为每个外观。让我们看看每个外观的RGB值：
- en: '`R 94: G 92: B 230`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`R 94: G 92: B 230`'
- en: '`R 88: G 86: B 214`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`R 88: G 86: B 214`'
- en: Although there is a subtle difference in each RGB value, it has a massive effect
    in terms of appearance and allowing it to stand out against other adapted colors
    defined by Apple (such as our system background color).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管每个RGB值之间有细微的差别，但在外观上它有巨大的影响，并且使其能够突出显示苹果定义的（如我们的系统背景颜色）的其他自适应颜色。
- en: Now that we've learned all about adaptive colors, let's take a look at semantic
    colors and how Apple helps us pre-define not only the colors we want to use but
    also where a type of color should be used.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了所有关于自适应颜色的知识，让我们看看语义颜色以及苹果如何帮助我们预先定义我们想要使用的颜色以及某种颜色应该在哪里使用。
- en: What are semantic colors?
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是语义颜色？
- en: To answer the questions of this section requires us to take a quick look back
    at what we already covered in the *What are adaptive colors?* section, because
    we've already touched on semantic colors.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要回答本节的问题，我们需要快速回顾一下我们在*什么是自适应颜色？*部分已经覆盖的内容，因为我们已经触及了语义颜色。
- en: Remember **Label Color** from our UILabel and **System Background Color**? These
    are all semantic colors – not so much by physical color, but more by their definition
    and intended purpose.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们UILabel中的**标签颜色**和**系统背景颜色**吗？这些都是语义颜色——与其物理颜色无关，更多的是与其定义和预期用途有关。
- en: With semantic colors, Apple has created a whole pre-defined range of adaptive
    colors that are designed specifically for objects such as labels, backgrounds,
    and grouped content such as table views. Each of these has additional primary,
    secondary, and tertiary variants.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通过语义颜色，苹果创建了一个专为标签、背景以及表格视图等分组内容设计的预定义的自适应颜色范围。每个颜色都有额外的首选、次要和三级变体。
- en: 'Let''s put this into practice and update our current Xcode project:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这些应用到我们的当前Xcode项目中：
- en: '![Figure 2.13 – UILabel with semantic variants'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.13 – 带语义变体的UILabel'
- en: '](img/Figure_2.13_B14717.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.13_B14717.jpg)'
- en: Figure 2.13 – UILabel with semantic variants
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13 – 带语义变体的UILabel
- en: 'I''ve added a couple more UILabels here and just done a little bit of re-arranging
    (nothing special), but what I have done is set the semantic variant for each **Label**
    with a corresponding variant – let''s take a look:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里添加了几个更多的UILabel，并做了一点简单的重新排列（没有什么特别的），但我所做的是为每个**标签**设置了相应的语义变体 – 让我们看看：
- en: '![Figure 2.14 – Color options'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.14 – 颜色选项'
- en: '](img/Figure_2.14_B14717.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.14_B14717.jpg)'
- en: Figure 2.14 – Color options
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14 – 颜色选项
- en: If we expand the color options for our UILabel, we can see a list of all the
    pre-defined adaptive/semantic and system and variant colors available to us. I've
    highlighted the colors I've chosen for each of the new labels.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们展开我们的UILabel的颜色选项，我们可以看到所有可用的预定义自适应/语义和系统以及变体颜色的列表。我突出显示了为每个新标签选择的颜色。
- en: 'Now, let''s switch the appearance to dark and see how it looks:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们切换外观到暗色，看看效果如何：
- en: '![Figure 2.15 – Semantic labels in Dark Mode'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.15 – 暗色模式下的语义标签'
- en: '](img/Figure_2.15_B14717.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.15_B14717.jpg)'
- en: Figure 2.15 – Semantic labels in Dark Mode
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.15 – 暗色模式下的语义标签
- en: 'Let''s go a step further and add some more adaptive content in there. Here,
    I''ve dropped in a UIView to act as a separator between content, a UIButton, which
    will be a URL link, and a UITableView:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更进一步，添加一些更多自适应内容。在这里，我添加了一个UIView作为内容之间的分隔符，一个UIButton，它将是一个URL链接，以及一个UITableView：
- en: '![Figure 2.16 – Separators and other background colors'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.16 – 分隔符和其他背景颜色'
- en: '](img/Figure_2.16_B14717.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.16_B14717.jpg)'
- en: Figure 2.16 – Separators and other background colors
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.16 – 分隔符和其他背景颜色
- en: 'I''ve assigned the following semantic colors to each of my new views:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我为我的每个新视图分配了以下语义颜色：
- en: '**Separator**: **Separator Color**'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分隔符**：**分隔符颜色**'
- en: '**Button**: **Link Color**'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按钮**：**链接颜色**'
- en: '**Table View**: **Group Table View Background Color**'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表格视图**：**分组表格视图背景颜色**'
- en: 'Let''s fire this up in the iOS simulator and see side by side how it looks.
    You''ll notice something interesting:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在iOS模拟器中运行它，并看看并排效果。你会注意到一些有趣的事情：
- en: '![Figure 2.17 – Table view in light and Dark Mode'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.17 – 亮色和暗色模式下的表格视图'
- en: '](img/Figure_2.17_B14717.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.17_B14717.jpg)'
- en: Figure 2.17 – Table view in light and Dark Mode
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.17 – 亮色和暗色模式下的表格视图
- en: In the light appearance, you can clearly see the table view's group background
    color against the system background color; yet if we take a look at this in the
    dark appearance, you don't see it as much. That's because with a much darker primary
    background color, the separation isn't needed as much; the black on black doesn't
    get lost and looks more natural, whereas white on white does.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在亮色外观中，你可以清楚地看到表格视图的分组背景颜色与系统背景颜色形成对比；然而，如果我们看看暗色外观，你就不太能看到它。这是因为随着更深的背景颜色，分隔不需要那么明显；黑色对黑色不会丢失，看起来更自然，而白色对白色则不然。
- en: This all looks great built into Interface Builder, but now let's take a look
    at how we would do this programmatically.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都看起来在Interface Builder中构建得很好，但现在让我们看看我们如何以编程方式实现它。
- en: Using the programmatic approach
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用程序化方法
- en: 'Let''s start by creating IBOutlets for each of our objects. If you''re unfamiliar
    with creating an outlet, simply, in `ViewController`, we do the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先为我们的每个对象创建IBOutlets。如果你不熟悉创建出口，简单地说，在`ViewController`中，我们做以下操作：
- en: Declare all our outlet properties first.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先声明所有我们的出口属性。
- en: Then, from the `IBOutlet` connector (just to the left of your property), press
    *Command* + *Primary Cursor Click*.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，从`IBOutlet`连接器（位于您的属性左侧），按*Command* + *主光标点击*。
- en: Hold and drag this to the UIView or object you want to connect to.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住并拖动此控件到您想要连接的UIView或对象上。
- en: 'Opening both Interface Builder and `ViewController` in separate windows will
    really help this process too:'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在单独的窗口中打开Interface Builder和`ViewController`将真正有助于这个过程：
- en: '![Figure 2.18 – Creating an outlet'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图2.18 – 创建出口'
- en: '](img/Figure_2.18_B14717.jpg)'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_2.18_B14717.jpg)'
- en: Figure 2.18 – Creating an outlet
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 2.18 – 创建出口
- en: 'We''ll need to create these in our `ViewController.swift` file just inside
    the class declaration. Copy the following highlighted code into your class:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在`ViewController.swift`文件中的类声明内创建这些。将以下突出显示的代码复制到你的类中：
- en: '[PRE2]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we can programmatically assign our colors. Inside the `viewDidLoad()`
    function, add the following highlighted code:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以通过编程方式分配我们的颜色。在`viewDidLoad()`函数内部，添加以下突出显示的代码：
- en: '[PRE3]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you launch the app in the simulator, you'll see that everything should stay
    the same. If we really want to test our logic, head back on over to Interface
    Builder and set one of our UILabels to **System Green Color**. Re-run the app
    and watch the programmatic code take precedence and override Interface Builder.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你启动模拟器中的应用，你会看到一切应该保持不变。如果我们真的想测试我们的逻辑，请回到界面构建器，并将我们的一个UILabel设置为**系统绿色颜色**。重新运行应用，并观察程序代码如何优先级更高并覆盖界面构建器。
- en: In this section, we've looked at how working with views for Dark Mode either
    in Interface Builder or programmatically is possible with the use of adaptive
    and semantic colors. We also looked at and understood the value behind using color
    variations and saw the effect they both have in both light and dark appearance.
    In the next section, we'll take a look at the asset catalog and how we can create
    custom adaptive colors and images for use in our app.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了如何在界面构建器或通过编程方式使用自适应和语义颜色与视图一起工作，我们了解了使用颜色变体的价值，并看到了它们在浅色和深色外观中的效果。在下一节中，我们将探讨资产目录以及我们如何为我们的应用创建自定义的自适应颜色和图像。
- en: Working with the asset catalog for Dark Mode
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用资产目录进行深色模式的工作
- en: Since the ability to add colors to the asset catalog became available back in
    Xcode 9, there is now even more reason to take full advantage of one of Xcode's
    prized assets.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在Xcode 9中添加颜色到资产目录的能力变得可用，现在有更多理由充分利用Xcode的宝贵资产之一。
- en: In this section, we'll look at how we can use the asset catalog not only to
    create our custom colors but also to create our own adaptive colors and images,
    allowing us to harness the power of Xcode when developing dynamic appearance applications.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨我们如何使用资产目录不仅创建我们的自定义颜色，还可以创建我们自己的自适应颜色和图像，从而让我们在开发动态外观应用时充分利用Xcode的功能。
- en: Using custom adaptive colors
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自定义自适应颜色
- en: 'Sticking with our current project, head on over to the file inspector, and
    highlight the `Assets.xcassets` folder. With the following layout visible, click
    on the **+** button highlighted in the following screenshot and select **New Color
    Set** from the list of options:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用我们当前的项目，转到文件检查器，并突出显示`Assets.xcassets`文件夹。在以下布局可见的情况下，点击以下截图中的突出显示的**+**按钮，并从选项列表中选择**新建颜色集**：
- en: '![Figure 2.19 – Creating a color set'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.19 – 创建颜色集'
- en: '](img/Figure_2.19_B14717.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.19_B14717.jpg)'
- en: Figure 2.19 – Creating a color set
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.19 – 创建颜色集
- en: 'Add in another three color sets and name them the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 添加另外三个颜色集，并命名为以下：
- en: '`brandLabel`'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`brandLabel`'
- en: '`brandSecondaryLabel`'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`brandSecondaryLabel`'
- en: '`brandTertiaryLabel`'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`brandTertiaryLabel`'
- en: 'Highlight `brandLabel`, and then highlight the option in the central asset
    preview window. Notice the list of attribute options now made available to us
    in the **Attributes Inspector** pane:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 突出显示`brandLabel`，然后突出显示中央资产预览窗口中的选项。注意现在在**属性检查器**面板中向我们提供的属性选项列表：
- en: '![Figure 2.20 – Adding a color set'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.20 – 添加颜色集'
- en: '](img/Figure_2.20_B14717.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.20_B14717.jpg)'
- en: Figure 2.20 – Adding a color set
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.20 – 添加颜色集
- en: As you can see, we can now define the `brandLabel` color that we want to use.
    But first, let's make it adaptive. In the **Attributes Inspector** pane, change
    **Appearance** from **None** to **Any, Light, Dark**.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们现在可以定义我们想要使用的`brandLabel`颜色。但首先，让我们使其自适应。在**属性检查器**面板中，将**外观**从**无**更改为**任何，浅色，深色**。
- en: 'You''ll have noticed on the dropdown that there was another option of **Any,
    Dark**, so let''s go through what this means:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在下拉菜单中注意到还有一个选项是**任何，深色**，那么让我们来看看这代表什么：
- en: '**None**: This is a default color and won''t be adaptive to your selected appearance.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无**：这是一个默认颜色，不会适应你选择的外观。'
- en: '**Any, Dark**: In this scenario, **Any** will support legacy versions of your
    app, along with any other variations that aren''t dark (so light, basically).
    **Dark** will be dark…'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任何，深色**：在这种情况下，**任何**将支持你应用的旧版本，以及任何其他不是深色的变体（基本上就是浅色）。**深色**将会是深色…'
- en: '**Any, Light, Dark**: Same as the preceding but will allow you to specifically
    select a value for legacy and light (along with dark).'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任何，浅色，深色**：与前面相同，但将允许你为旧版和浅色（以及深色）选择特定的值。'
- en: 'So, with that covered, let''s add some colors. Now, as mentioned before, this
    is where you can be really specific with your color choices, either by personal
    preference or brand guidelines you have to follow. For me, I''m just going to
    click **Show Color Picker** and pick my favorite colors:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，关于这一点我们已经了解了，现在让我们添加一些颜色。正如之前提到的，这是你可以非常具体地选择颜色的地方，无论是根据个人喜好还是你必须遵循的品牌指南。对我来说，我只需要点击**显示颜色选择器**并选择我最喜欢的颜色：
- en: Tangerine for **Any (Legacy)** and light
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任何（旧版）** 和浅色使用橙汁色'
- en: 'A more subtle **Cantaloupe** for dark:'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深色模式下更细腻的**哈密瓜**色：
- en: '![Figure 2.21 – Choosing a color'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.21 – 选择颜色'
- en: '](img/Figure_2.21_B14717.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.21_B14717.jpg)'
- en: Figure 2.21 – Choosing a color
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.21 – 选择颜色
- en: Do the same for `brandSecondaryLabel` and `brandTertiaryLabel`, remembering
    to slightly alter the colors based on the semantic purpose you intend to use them
    for.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `brandSecondaryLabel` 和 `brandTertiaryLabel` 也做同样的操作，记得根据你打算使用的语义目的稍微调整颜色。
- en: 'Once you''ve done that, head back on over to Interface Builder and highlight
    `primaryLabel`, then bring open the options of colors from **Attributes Inspector**.
    You should see the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，回到 Interface Builder，突出显示 `primaryLabel`，然后打开 **属性检查器** 中的颜色选项。你应该会看到以下内容：
- en: '![Figure 2.22 – Default label color'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.22 – 默认标签颜色'
- en: '](img/Figure_2.22_B14717.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.22_B14717.jpg)'
- en: Figure 2.22 – Default label color
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.22 – 默认标签颜色
- en: 'All the color sets you created in the asset catalog are available to use right
    there in Interface Builder. Go ahead and add them in for each label and see how
    they look by switching appearance in Interface Builder:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你在资产目录中创建的所有颜色集都可以在 Interface Builder 中直接使用。继续为每个标签添加它们，并通过在 Interface Builder
    中切换外观来查看它们的外观：
- en: '![Figure 2.23 – Color set, light mode versus dark mode'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.23 – 颜色集，浅色模式与深色模式'
- en: '](img/Figure_2.23_B14717.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.23_B14717.jpg)'
- en: Figure 2.23 – Color set, light mode versus dark mode
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.23 – 颜色集，浅色模式与深色模式
- en: With that done, you've created your very own adaptive, semantic and dynamic
    colors for your app – all within the power of Xcode.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做之后，你就在 Xcode 的力量下为你的应用创建了自己的自适应、语义和动态颜色 – 所有这些都在 Xcode 的能力范围内。
- en: If you wanted to use the colors programmatically, you can do that by simply
    referring to the asset name in a couple of different ways.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要通过编程使用颜色，你可以通过简单地以几种不同的方式引用资产名称来实现。
- en: 'First is a direct reference to the name of the assets:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是直接引用资产名称：
- en: '[PRE4]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Alternatively, you can select the asset directly from the media library by pressing
    *Shift* + *CMD* + *M* and selecting **show color palette** from the icon options
    and selecting the color you want.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以通过按 *Shift* + *CMD* + *M* 并从图标选项中选择**显示颜色调板**来直接从媒体库中选择资产，并选择你想要的颜色。
- en: 'This will insert the color from the assets catalog as a swatch, directly inside
    your code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在你的代码中直接插入来自资产目录的颜色作为色样：
- en: '![Figure 2.24 – Assigning a color set programmatically'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.24 – 通过编程分配颜色集'
- en: '](img/Figure_2.24_B14717.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.24_B14717.jpg)'
- en: Figure 2.24 – Assigning a color set programmatically
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.24 – 通过编程分配颜色集
- en: 'Or another option, if you really wanted to keep your code clean, would be to
    create an extension of UIColor allowing you to define your own property:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你真的想保持你的代码干净，你可以创建一个 UIColor 的扩展，允许你定义自己的属性：
- en: '[PRE5]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This can now be used just like this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以这样使用：
- en: '[PRE6]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is a nice, clean, and manageable way to look after your custom color sets
    programmatically, but this really is a personal preference, and each to their
    own. If you're working with a large alternative color guideline, making the change
    to a primary color in one extension will roll the change out to your entire app
    without the worry of missing a label or two.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种很好、干净且易于管理的方式来通过编程管理你的自定义颜色集，但这完全是个人的偏好，各花入各眼。如果你正在处理一个大型替代颜色指南，将主颜色在一个扩展中更改，将自动将更改推广到你的整个应用，无需担心遗漏一个或两个标签。
- en: Next, let's take a look at the same approach but for images.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看同样的方法，但这次是针对图像的。
- en: Using custom adaptive images
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自定义自适应图像
- en: We've learned a lot about how the asset catalog works with adaptive images from
    the previous section, *Custom adaptive colors*, and luckily, we can take full
    advantage of that in creating adaptive images for our project.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前一节中学习了关于资产目录如何与自适应图像一起工作的很多知识，*自定义自适应颜色*，幸运的是，我们可以在为我们的项目创建自适应图像时充分利用这一点。
- en: 'In the same way that we created a new color set, let''s follow these steps:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们创建新的颜色集一样，让我们按照以下步骤进行：
- en: Head on back over to **Assets.xcassets**.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到**Assets.xcassets**。
- en: Create a new image set:![Figure 2.25 – New image set
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的图像集：![图 2.25 – 新的图像集
- en: '](img/Figure_2.25_B14717.jpg)'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_2.25_B14717.jpg)'
- en: Figure 2.25 – New image set
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 2.25 – 新的图像集
- en: 'Name your new image **header**, highlight it, and change the appearance in
    the **Attributes Inspector** window to **Any, Dark**. You should now see the following:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的新图像命名为**header**，高亮显示它，并在**属性检查器**窗口中将外观更改为**任何，暗**。你现在应该会看到以下内容：
- en: '![Figure 2.26 – Add new image set'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.26 – 添加新的图像集'
- en: '](img/Figure_2.26_B14717.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.26_B14717.jpg)'
- en: Figure 2.26 – Add new image set
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.26 – 添加新的图像集
- en: When adding an image to the image catalog, you'll be given the option for adding
    **1x**, **2x**, or **3x** images – these are different image scales you can set
    for various screen sizes. For further information, see the following from Apple's
    documentation.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当向图像目录添加图像时，你会得到添加**1x**、**2x**或**3x**图像的选项 – 这些是你可以为不同屏幕大小设置的不同图像比例。有关更多信息，请参阅以下来自Apple文档的内容。
- en: 'For this example, we are going to add in two different images to the **2x**
    option: one for **Any** and the other for **Dark**. You can grab the images I''ve
    used from the sample project found in GitHub or choose your own – it''s up to
    you. From the Finder, simply drag and drop the images into the **2x** placeholder
    inside Xcode. You should see the following once done:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将向**2x**选项添加两张不同的图像：一张用于**任何**，另一张用于**暗**。你可以从GitHub中找到我使用的示例项目中的图像，或者选择你自己的图像
    – 这取决于你。从Finder中，只需将图像拖放到Xcode中**2x**占位符即可。完成操作后，你应该会看到以下内容：
- en: '![Figure 2.27 – New image set variants'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.27 – 新的图像集变体'
- en: '](img/Figure_2.27_B14717.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.27_B14717.jpg)'
- en: Figure 2.27 – New image set variants
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.27 – 新的图像集变体
- en: Now, head back on over to your storyboard and add in a UIImageView to your project.
    Add this to the top of `ViewController` to act as a header.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到你的故事板，并在项目中添加一个UIImageView。将其添加到`ViewController`的顶部以作为头部。
- en: 'Once in place, head on over to the **Attributes Inspector** pane and select
    the dropdown for the **Image** option – there, you should see your newly created
    asset, **header**:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置好，请转到**属性检查器**面板，并选择**图像**选项的下拉菜单 – 在那里，你应该能看到你新创建的资产，**头部**：
- en: '![Figure 2.28 – Setting header from the image set'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.28 – 从图像集中设置头部'
- en: '](img/Figure_2.28_B14717.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.28_B14717.jpg)'
- en: Figure 2.28 – Setting header from the image set
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.28 – 从图像集中设置头部
- en: Select this and take a look (depending on the size of the image you chose, you
    may need to set **Content Mode** to **Aspect Fill** – these options can also be
    found in **Attributes Inspector**).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 选择它并查看（根据你选择的图像大小，你可能需要将**内容模式**设置为**填充** – 这些选项也可以在**属性检查器**中找到）。
- en: Run the simulator and have a look at everything you've achieved so far in this
    chapter, remembering to switch from light to dark appearance by using the environment
    override in Xcode… looks pretty good, right?
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 运行模拟器并查看本章到目前为止你所取得的成就，记得通过使用Xcode中的环境覆盖来在亮模式和暗模式之间切换…看起来相当不错，对吧？
- en: '![Figure 2.29 – Header light mode versus dark mode'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.29 – 亮模式与暗模式下的头部灯光'
- en: '](img/Figure_2.29_B14717.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.29_B14717.jpg)'
- en: Figure 2.29 – Header light mode versus dark mode
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.29 – 亮模式与暗模式下的头部灯光
- en: 'Just like we did with color sets, we can of course handle this programmatically,
    should we wish. Let''s add another extension to our app to handle this for us:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们处理颜色集一样，如果我们愿意，当然可以以编程方式处理。让我们给我们的应用程序添加另一个扩展来处理这一点：
- en: '[PRE7]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can again use this in just the same way as before:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以再次像之前一样使用：
- en: '[PRE8]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We do this by assigning our header image directly onto our UIImageView.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将头部图像直接分配给我们的UIImageView来实现这一点。
- en: In this section, we harnessed the power of the asset catalog to allow us to
    create custom adaptive and dynamic colors and images for our app. In the next
    section, we'll take a look at how best to update a legacy app to support dark
    mode with everything we've learned so far, and also how best to identify the little
    things we can do to futureproof our apps for various appearances.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们利用了资产目录的力量，使我们能够为我们的应用创建自定义的适应性和动态颜色和图像。在下一节中，我们将探讨如何利用我们迄今为止所学的一切来最佳地更新遗留应用以支持深色模式，以及如何最佳地识别我们可以做的那些小事来为各种外观确保我们的应用未来可兼容。
- en: Further exploring Dark Mode
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步探索深色模式
- en: In the previous sections, we gave you a lot to think about when either creating
    or migrating existing apps to Dark Mode under specific circumstances. In this
    section, we'll take a look at a couple of little "nice to knows" that should always
    be in the back of your mind when approaching Dark Mode.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们向您介绍了在特定情况下创建或迁移现有应用至深色模式时需要考虑的许多因素。在本节中，我们将探讨一些应该始终牢记在心的“小贴士”，这些小贴士在您接近深色模式时应该放在心中。
- en: Using Dark Mode with SwiftUI
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 SwiftUI 深色模式
- en: With the announcement of SwiftUI back in June 2019, a massive shift in focus
    on UI-based development took place. Released at the same time as Dark Mode, and
    as expected, SwiftUI takes full advantage of switching appearances.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 2019 年 6 月宣布 SwiftUI 以来，对基于 UI 的开发的关注发生了巨大转变。与深色模式同时发布，正如预期的那样，SwiftUI 充分利用了外观切换。
- en: 'Let''s start by taking a look at how we could detect dark mode programmatically
    in SwiftUI:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看如何在 SwiftUI 中程序化地检测深色模式：
- en: 'First, we''ll create an environment variable that allows us to access the current
    state of the appearance of the device:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个环境变量，使我们能够访问设备当前的外观状态：
- en: '[PRE9]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, let''s use a simple ternary operator to display some text based on the
    current appearance:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们使用一个简单的三元运算符根据当前外观显示一些文本：
- en: '[PRE10]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It really is that simple.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 真的是非常简单。
- en: Now, let's have a look at the options available to us in the automatic preview
    window. SwiftUI uses `PreviewProvider`, which allows us to display dynamically
    what we are designing/developing.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看自动预览窗口中可用的选项。SwiftUI 使用 `PreviewProvider`，它允许我们动态地显示我们正在设计/开发的内容。
- en: 'To enable Dark Mode in `PreviewProvider`, simply add the following highlighted
    code and hot refresh:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 `PreviewProvider` 中启用深色模式，只需添加以下突出显示的代码并启用热刷新：
- en: '[PRE11]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, we''ve added a modifier to set the `.colorScheme` environment variable
    to `.dark`. If we want to preview both `.light` and `.dark` side by side, we can
    simply do the following:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个修改器来设置 `.colorScheme` 环境变量为 `.dark`。如果我们想并排预览 `.light` 和 `.dark`，我们可以简单地做以下操作：
- en: '[PRE12]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Tip
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'To learn more about SwiftUI, take a look at *Learn SwiftUI*, available from
    Packt Publishing: [https://www.packtpub.com/business-other/learn-swiftui](https://www.packtpub.com/business-other/learn-swiftui).'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 SwiftUI 的信息，请查看 Packt Publishing 提供的 *Learn SwiftUI*：[https://www.packtpub.com/business-other/learn-swiftui](https://www.packtpub.com/business-other/learn-swiftui)。
- en: Programatically handling changes with trait collection
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用特性集合程序化处理变化
- en: During the development of your new app, there could be a couple of occasions
    where you might need to handle a specific scenario based on the current appearance.
    However, we'll need to take a slightly different approach to this than what we
    did with the SwiftUI example previously.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发您的新应用期间，可能会有一些场合需要根据当前的外观处理特定的场景。然而，我们需要采取与之前在 SwiftUI 示例中不同的方法来处理这个问题。
- en: 'The interface style is part of the `UITraitCollection` class (which, in turn,
    is part of UIKit). We can do a conditional check against a value using the following
    anywhere in our `ViewController`:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 接口样式是 `UITraitCollection` 类的一部分（它反过来又是 UIKit 的一部分）。我们可以在 `ViewController` 中的任何地方使用以下方式对值进行条件检查：
- en: '[PRE13]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Unlike SwiftUI, we can''t just use a simple ternary operator as there are more
    than two values for `userInterfaceStyle`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 与 SwiftUI 不同，我们不能简单地使用三元运算符，因为 `userInterfaceStyle` 有超过两个值：
- en: '[PRE14]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**Unspecified** is an option too (think **Any**, back in our asset catalog),
    so it''s best to use another approach when detecting changes to our interface
    style.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '**未指定**也是一个选项（想想我们资产目录中的 **Any**），因此在检测我们界面样式的变化时最好使用另一种方法。'
- en: 'Let''s start by heading back into our `ViewController.swift` file and adding
    in the following `override` function:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先回到我们的 `ViewController.swift` 文件，并添加以下 `override` 函数：
- en: '[PRE15]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This override is called whenever a change is made to a trait (such as appearance).
    From this, we now action any changes we would like to make, but the problem we
    have is traits are used for more than just appearances, and this override could
    be called for a variety of reasons.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 每当对特性（如外观）进行更改时，都会调用此重写方法。从这一点出发，我们现在可以采取任何我们想要进行的更改，但我们面临的问题是特性不仅用于外观，而且这个重写方法可能因各种原因而被调用。
- en: 'So, if we are looking particularly for changes in our appearance, we can use
    the `previousTrait` property passed into our delegate function and compare against
    the current system trait – if there is a difference, we know the appearance has
    changed. Let''s take a look at how we''d do this:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们特别关注外观的变化，我们可以使用传递给我们的代理函数的 `previousTrait` 属性，并与当前系统特性进行比较——如果有差异，我们就知道外观已经改变。让我们看看我们如何做到这一点：
- en: '[PRE16]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: By using the `hasDifferentColorAppearance` method, we can now easily compare
    the previous trains against the current one to see whether there have been any
    changes – the resulting method returns a Boolean, so we can use this at our convenience.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `hasDifferentColorAppearance` 方法，我们现在可以轻松地比较之前的特性与当前的特性，看看是否有任何变化——这个方法返回一个布尔值，因此我们可以方便地使用它。
- en: Specifying an appearance for views, ViewControllers, and windows
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为视图、ViewController 和窗口指定外观
- en: You may, in some circumstances, wish to specify an appearance based on a particular
    area of your app or if you are migrating to dark mode (but need a little more
    time for a certain feature). Simply drop in the following appropriate code to
    meet your desire.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能希望根据你的应用程序的特定区域指定外观，或者如果你正在迁移到暗黑模式（但需要更多时间来实现某个功能）。只需插入以下适当的代码即可满足你的需求。
- en: Views
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 视图
- en: 'Here, we''ll create and instantiate a basic UIView:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将创建并实例化一个基本的 UIView：
- en: '[PRE17]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We assign either a light or dark value.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们分配亮色或暗色值。
- en: ViewController
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ViewController
- en: 'If we wanted to do this in a UIViewController, we would simply just do the
    following:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在 UIViewController 中实现这个功能，我们只需做以下操作：
- en: '[PRE18]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Again, we assign either a light or dark value (usually within `viewDidLoad()`).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们通常在 `viewDidLoad()` 方法中分配亮色或暗色值（通常如此）。
- en: Window
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 窗口
- en: 'If we need to access the current window, we could do so as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要访问当前窗口，可以按照以下方式操作：
- en: '[PRE19]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: (This is not a recommended approach and you would be hard-pressed to find any
    real reason to want to do this…)
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: （这不是一个推荐的方法，而且你很难找到任何真正的理由想要这样做……）
- en: Accessibility in Dark Mode
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 暗黑模式下的可访问性
- en: Ask around and someone will joke about how **Dark Mode** has existed in iOS
    for years, either as the **Classic Invert** or **Smart Invert** accessibility
    feature. I even had it on one of my slides at a conference about 2 months prior
    to Dark Mode being officially announced.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 询问一下，有人会开玩笑说 **暗黑模式** 在 iOS 中已经存在多年了，无论是作为 **经典反转** 还是 **智能反转** 的可访问性功能。我甚至在官方宣布暗黑模式两个月前的一个会议幻灯片中提到了它。
- en: But with this in mind, a lot of things started to be said about accessibility
    in iOS – some comments referring to Dark Mode as "Apple finally supporting accessibility,"
    which I have to be honest makes me very sad.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 但考虑到这一点，关于 iOS 中可访问性的讨论开始增多——一些评论将暗黑模式称为“苹果终于支持可访问性”，这让我非常难过。
- en: Accessibility has always played a massive part in iOS regardless of the appearance
    – but, even with the introduction of Dark Mode, this still goes unchanged as Dark
    Mode supports all accessibility features.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 无论外观如何，可访问性始终在 iOS 中扮演着重要角色——但是，即使引入了暗黑模式，这一点仍然没有改变，因为暗黑模式支持所有可访问性功能。
- en: If you refer back to an earlier section in this chapter, *Core development concepts
    in Dark Mode*, you'll remember that we mentioned the option to schedule our light
    and dark appearances – much like you could with Nightshift that was introduced
    in iOS 9, again another element with a focus on accessibility.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回顾本章早先的部分，*暗黑模式的核心开发概念*，你会记得我们提到了可以安排我们的亮色和暗色外观——就像你可以在 iOS 9 中使用的 Nightshift
    一样，这同样是一个关注可访问性的元素。
- en: In this section, we went a little outside of the box with regard to Dark Mode
    and stepped away from the basic implementation, allowing us to look at the wider
    options available to use and things to think about when implementing Dark Mode
    in our apps.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们在暗黑模式方面做了一些创新，脱离了基本实现，使我们能够查看可用的更广泛选项以及在我们应用程序中实现暗黑模式时需要考虑的事情。
- en: Summary
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've covered a lot about Dark Mode – not only from a programmatic
    perspective but also the theory behind the appearances and purpose of colors used
    within our apps.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细介绍了深色模式的相关内容——不仅从编程的角度，还包括了我们应用中使用的颜色外观和目的背后的理论。
- en: We started by taking a look at how Xcode and iOS are set up for Dark Mode, learning
    about the environment overrides used in Xcode, and how we can even switch appearances
    in our storyboard while developing.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先查看Xcode和iOS如何为深色模式进行设置，学习了Xcode中使用的环境覆盖，以及我们如何在开发过程中切换Storyboard中的外观。
- en: Next, we covered adaptive and semantic colors, and learned not only how these
    are used with Apple's default system colors but also how we can create dynamic
    and adaptive color sets ourselves.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们介绍了自适应和语义颜色，并学习了如何使用苹果的默认系统颜色，以及我们如何自己创建动态和自适应的颜色集。
- en: Following on from what we learned about color sets, we applied this to images
    and harnesses the power of the assets catalog.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习了颜色集之后，我们将这些知识应用到图像上，并利用了资产目录的力量。
- en: Finally, we covered some "great to know" topics, such as Dark Mode in SwiftUI,
    programmatically hailing appearances, and accessibility.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们介绍了一些“值得了解”的主题，例如SwiftUI中的深色模式、程序化召唤外观以及无障碍性。
- en: In the next chapter, we'll take a look at lists in iOS 14, covering everything
    you need to know about UITableViews and UICollectionViews.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨iOS 14中的列表，涵盖关于UITableViews和UICollectionViews你需要知道的一切。
- en: Further reading
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '**Apple human interface guidelines (dark mode)**: [https://developer.apple.com/design/human-interface-guidelines/ios/visual-design/dark-mode/](https://developer.apple.com/design/human-interface-guidelines/ios/visual-design/dark-mode/)'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**苹果人机界面指南（深色模式）**: [https://developer.apple.com/design/human-interface-guidelines/ios/visual-design/dark-mode/](https://developer.apple.com/design/human-interface-guidelines/ios/visual-design/dark-mode/)'
- en: '**Apple human interface guidelines (color)**: [https://developer.apple.com/design/human-interface-guidelines/ios/visual-design/color/](https://developer.apple.com/design/human-interface-guidelines/ios/visual-design/color/)'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**苹果人机界面指南（颜色）**: [https://developer.apple.com/design/human-interface-guidelines/ios/visual-design/color/](https://developer.apple.com/design/human-interface-guidelines/ios/visual-design/color/)'
- en: '**Asset catalog reference**: [https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_ref-Asset_Catalog_Format/index.html](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_ref-Asset_Catalog_Format/index.html)'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资产目录参考**: [https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_ref-Asset_Catalog_Format/index.html](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_ref-Asset_Catalog_Format/index.html)'
