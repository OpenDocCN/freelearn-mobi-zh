- en: Overview of Kotlin
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin 概述
- en: Kotlin is the official Android programming language and is statically typed.
    It is fully interoperable with Java, meaning that any Kotlin user can use the
    Java framework and mix commands from both Kotlin and Java without any limitations.
    In this chapter, we will cover the basics of Kotlin and will look at how to set
    up the environment. We will also look at its flow structures, such as `if { ...
    } else { ... }` expressions and loops. In addition to this, we will look into
    object-oriented programming for Kotlin, and we will cover classes, interfaces,
    and objects. Functions will also be covered, along with parameters, constructors,
    and syntax.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 是官方的 Android 编程语言，并且是静态类型的。它与 Java 完全兼容，这意味着任何 Kotlin 用户都可以使用 Java 框架，并且可以无限制地混合
    Kotlin 和 Java 的命令。在本章中，我们将介绍 Kotlin 的基础知识，并探讨如何设置环境。我们还将探讨其流程结构，例如 `if { ... }
    else { ... }` 表达式和循环。此外，我们还将探讨 Kotlin 的面向对象编程，包括类、接口和对象。函数也将被介绍，包括参数、构造函数和语法。
- en: 'This chapter will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Setting up the environment
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置环境
- en: Build tools
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建工具
- en: Basic syntax
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本语法
- en: Object-oriented programming
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象编程
- en: Functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数
- en: Control flow
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制流程
- en: Ranges
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围
- en: String templates
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串模板
- en: Null safety, reflection, and annotations
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空安全、反射和注解
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To run the code in this chapter, you will just need Android Studio and Git installed.
    This chapter won't require any additional installations.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本章中的代码，您只需安装 Android Studio 和 Git 即可。本章不需要任何额外的安装。
- en: You can find examples from this chapter on GitHub, at the following link: [https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/app/src/main/java/com/packt/learn_spring_for_android_application_development/chapter2](https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/app/src/main/java/com/packt/learn_spring_for_android_application_development/chapter2).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 上找到本章的示例，链接如下：[https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/app/src/main/java/com/packt/learn_spring_for_android_application_development/chapter2](https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/app/src/main/java/com/packt/learn_spring_for_android_application_development/chapter2)。
- en: Introduction to Kotlin
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin 简介
- en: 'The 3.0 version of Android Studio was released by Google, and it promoted Kotlin
    as a first class language for Android development. Kotlin is developed by JetBrains
    in the same way as the Intellij IDEA platform, which is the basis of Android Studio.
    This language was released in February 2016, it was in development for five years
    before it was released. It''s easy to gradually convert the code base of a project
    from Java to Kotlin, and a developer that is familiar with Java can learn Kotlin
    in a few weeks. Kotlin became popular before its release, because this language
    is full of features and is designed to interoperate with Java. The following diagram
    shows how Kotlin and Java code are compiled to the same bytecode:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio 的 3.0 版本由 Google 发布，并推广 Kotlin 作为 Android 开发的第一类语言。Kotlin 由 JetBrains
    开发，与 Intellij IDEA 平台相同，这是 Android Studio 的基础。这种语言于 2016 年 2 月发布，在发布前已经开发了五年。将项目的代码库从
    Java 转换为 Kotlin 很容易，熟悉 Java 的开发者可以在几周内学会 Kotlin。Kotlin 在发布前就已经很受欢迎，因为这种语言功能丰富，并且设计用于与
    Java 兼容。以下图表显示了 Kotlin 和 Java 代码是如何编译成相同的字节码的：
- en: '![](img/88d1e3c9-8429-433c-8b21-a7d3866c1895.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/88d1e3c9-8429-433c-8b21-a7d3866c1895.png)'
- en: As you can see, part of our application can be written in Java and another part
    in Kotlin. The **kotlinc** compiler compiles Kotlin source code to the same bytecode
    as the **javac** compiler.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的应用程序的一部分可以用 Java 编写，另一部分可以用 Kotlin 编写。**kotlinc** 编译器将 Kotlin 源代码编译成与
    **javac** 编译器相同的字节码。
- en: Setting up the environment
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置环境
- en: To get started with Android development, you will need to download and install
    the **Java Development Kit** (**JDK**) from [http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html).
    You will also need to download and install the Android Studio **Integrated Development
    Environment** (**IDE**), from [https://developer.android.com/studio/](https://developer.android.com/studio/).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始 Android 开发，您需要从 [http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html)
    下载并安装 **Java 开发工具包**（**JDK**）。您还需要从 [https://developer.android.com/studio/](https://developer.android.com/studio/)
    下载并安装 Android Studio **集成开发环境**（**IDE**）。
- en: 'To create a new project, launch Android Studio and press **Start** **a new
    Android Studio project**. Then, you should type a project name and your unique
    application ID, as shown in the following screenshot:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的项目，启动Android Studio并按下**创建一个新的Android Studio项目**。然后，你应该输入项目名称和你的唯一应用程序ID，如下面的截图所示：
- en: '![](img/b5d7680a-910b-439f-bf86-cf254b9c9294.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b5d7680a-910b-439f-bf86-cf254b9c9294.png)'
- en: 'In the preceding screenshot, the **Application name** field is filled according
    to the name of this book, and the **Company domain** field is  `packt.com`. Android
    Studio concatenates these two values and creates the **Package name** identifier
    that is equal to the application ID identifier. In our case, the application ID
    is as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，**应用程序名称**字段根据本书的名称填写，**公司域名**字段为`packt.com`。Android Studio将这两个值连接起来，创建一个等于应用程序ID标识符的**包名**标识符。在我们的情况下，应用程序ID如下所示：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Build tools
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建工具
- en: 'Android Studio is an official IDE for Android development, and it is based
    on the Intellij IDEA platform and uses the Gradle build tool system. A typical
    project structure looks as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio是Android开发的官方IDE，它基于IntelliJ IDEA平台，并使用Gradle构建工具系统。一个典型的项目结构如下所示：
- en: '![](img/1d345d27-3148-48a1-9a2a-3011d474804b.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1d345d27-3148-48a1-9a2a-3011d474804b.png)'
- en: 'The `build.gradle` file contains the project configuration and manages the
    library dependencies. To add a dependency to the Spring for Android extension,
    we should add the following lines:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`build.gradle`文件包含项目配置并管理库依赖项。要添加对Spring for Android扩展的依赖项，我们应该添加以下行：'
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Basic syntax
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本语法
- en: Syntax is a significant part of the programming language, defining a set of
    rules that must be applied to combinations of symbols. Otherwise, a program can't
    be compiled, and will be considered incorrect.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 语法是编程语言的一个重要部分，定义了一组必须应用于符号组合的规则。否则，程序无法编译，将被视为不正确。
- en: 'This section will describe the basic syntax of Kotlin, covering the following
    topics:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将描述Kotlin的基本语法，包括以下主题：
- en: Defining packages
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义包
- en: Defining variables
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义变量
- en: Defining functions
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义函数
- en: Defining classes
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义类
- en: Defining packages
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义包
- en: 'Packaging is a mechanism that allows us to group classes, interfaces, and sub-packages.
    In our case, a declaration of a package in a file may look as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 打包是一种机制，允许我们将类、接口和子包分组。在我们的情况下，文件中包的声明可能如下所示：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: All citizens of the file belong to this package and must be located in the appropriate
    folder.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 文件中的所有公民都属于这个包，并且必须位于适当的文件夹中。
- en: Defining variables
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义变量
- en: In Kotlin, we can define a read-only variable using the `val` keyword, and we
    can use the `var` keyword for mutable variables. In Kotlin, a **variable** can
    be defined as a first class citizen, meaning that we don't have to create a class
    of a function to hold variables. Instead, we can declare them directly in a file.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，我们可以使用`val`关键字定义只读变量，并可以使用`var`关键字定义可变变量。在Kotlin中，**变量**可以被定义为第一类公民，这意味着我们不需要创建一个包含变量的类或函数。相反，我们可以直接在文件中声明它们。
- en: 'The following example shows how to define read-only and mutable variables:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何定义只读和可变变量：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Defining functions
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义函数
- en: 'To define a function, we have to use the `fun` keyword; this also can be declared
    as a first class citizen. This means that a function can only be defined in a
    file. We will touch on functions in greater detail in the *Functions* section,
    but for now, let''s look at a simple example that changes the value of the `mutable`
    variable:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个函数，我们必须使用`fun`关键字；这也可以被声明为第一类公民。这意味着函数只能在一个文件中定义。我们将在*函数*部分更详细地介绍函数，但就目前而言，让我们看看一个简单的例子，该例子会改变`mutable`变量的值：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the previous snippet, we can see that the `changeMutable` function can be declared as
    a first class citizen in the same file as the `mutable` variable, or in any other
    place.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们可以看到`changeMutable`函数可以在与`mutable`变量相同的文件中声明为第一类公民，或者在任何其他位置。
- en: Defining classes
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义类
- en: 'To define a class, we have to use the `class` keyword. All of the classes in
    Kotlin are final by default, and if we want to extend a class, we should declare
    it with the `open` keyword. A class that holds the `readOnly` and `mutable` variables,
    as well as the `changeMutable` method, may look like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个类，我们必须使用`class`关键字。在Kotlin中，所有类默认都是最终的，如果我们想扩展一个类，我们应该使用`open`关键字声明它。一个包含`readOnly`和`mutable`变量以及`changeMutable`方法的类可能看起来像这样：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It is worth mentioning that a function that is a class member is called a **method**.
    In this way, we can explicitly specify that a function belongs to a class.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，作为类成员的函数被称为**方法**。通过这种方式，我们可以明确指定一个函数属于一个类。
- en: Object-oriented programming
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象编程
- en: '**Object-oriented programming** is a model of programming language that is
    based on objects that can represent data. Kotlin supports object-oriented programming
    in the same way that Java does, but even more strictly. This is because Kotlin
    doesn''t have primitive types and static members. Instead, it provides a `companion
    object`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向对象编程**是一种基于可以表示数据的对象的编程语言模型。Kotlin 以与 Java 相同的方式支持面向对象编程，但更为严格。这是因为 Kotlin
    没有原始类型和静态成员。相反，它提供了一个`companion object`：'
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `companion object` is an object that is created once, during class initialization.
    In Kotlin, we can refer to members of `companion object` in the same way as `static`
    in Java:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`companion object` 是在类初始化期间创建一次的对象。在 Kotlin 中，我们可以像在 Java 中的 `static` 一样引用
    `companion object` 的成员：'
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'However, under the hood, the nested `Companion` class is created, and we actually
    use an instance of this class, as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在底层，嵌套的 `Companion` 类被创建，我们实际上使用这个类的实例，如下所示：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Moreover, Kotlin supports the following concepts, which make the type system
    stronger:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Kotlin 支持以下概念，这使得类型系统更加强大：
- en: Nullable types
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可空类型
- en: Read-only and mutable collections
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只读和可变集合
- en: No raw type of collections
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合没有原始类型
- en: 'The last point means that we can''t compile code, as shown in the following
    screenshot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点意味着我们无法编译代码，如下面的截图所示：
- en: '![](img/08e33769-7b0e-486b-a7f5-93ef898c6c3c.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/08e33769-7b0e-486b-a7f5-93ef898c6c3c.png)'
- en: This message means that we have to provide a generic to specify a certain type
    of this collection.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这条消息意味着我们必须提供一个泛型来指定此集合的特定类型。
- en: From the object-oriented programming viewpoint, Kotlin supports the same features
    as Java. These include encapsulation, inheritance, polymorphism, composition,
    and delegation. It even provides a language-level construction that helps to implement
    these concepts.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 从面向对象编程的角度来看，Kotlin 支持与 Java 相同的功能。这包括封装、继承、多态、组合和委托。它甚至提供了一个语言级别的构造，有助于实现这些概念。
- en: Functions
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: 'To define a function in Kotlin, you have to use the `fun` keyword, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Kotlin 中定义一个函数，你必须使用 `fun` 关键字，如下所示：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding snippet demonstrates that we can declare functions as first class
    citizens. We can also define functions as class members, as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段演示了我们可以将函数声明为第一类公民。我们还可以将函数定义为类成员，如下所示：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'A `local` function is a function that is declared in another one, as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `local` 函数是在另一个函数中声明的函数，如下所示：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding snippet, the `local` function is declared inside of the `outer`
    function. The `local` functions are only available in the scope of a function
    where they were declared. This approach can be useful if we want to avoid duplicate
    code inside of a function.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`local` 函数是在 `outer` 函数内部声明的。`local` 函数仅在它们被声明的函数的作用域内可用。如果我们想避免在函数内部重复代码，这种方法可能很有用。
- en: 'This section will cover the following topics:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将涵盖以下主题：
- en: Functional programming
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程
- en: Higher-order functions
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高阶函数
- en: Lambdas
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda
- en: Functional programming
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程
- en: Kotlin particularly supports a functional style that allows us to operate functions
    in the same way as variables. This approach brings many features to Kotlin, as
    well as new ways to describe the flow of a program more concisely.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 特别支持一种函数式风格，允许我们以与变量相同的方式操作函数。这种方法为 Kotlin 带来了许多功能，以及更简洁地描述程序流程的新方法。
- en: 'This subsection will cover the following topics:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节将涵盖以下主题：
- en: Declarative and imperative styles
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明式和命令式风格
- en: Extension functions
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展函数
- en: Collections in Kotlin
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin 中的集合
- en: Declarative and imperative styles
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明式和命令式风格
- en: We used to use the imperative style of programming when writing object-oriented
    programming, but for functional programming, a more natural style is declarative.
    The declarative style assumes that our code describes what to do, instead of how
    to do it, as is usual with imperative programming.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们过去在编写面向对象编程时使用命令式编程风格，但对于函数式编程来说，一种更自然的风格是声明式。声明式风格假设我们的代码描述了要做什么，而不是如何做，这与命令式编程的常规做法不同。
- en: 'The following example demonstrates how functional programming can be useful
    in certain cases. Let''s imagine that we have a list of numbers, and we want to
    find the number that is greater than `4`. In the imperative style, this may look
    as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了函数式编程在特定情况下如何有用。让我们想象我们有一个数字列表，我们想要找到大于`4`的数字。在命令式风格中，这可能会如下所示：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As you can see, we have to use a lot of control flow statements to implement
    this simple logic. In the declarative style, it may look as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们必须使用大量的控制流语句来实现这个简单的逻辑。在声明式风格中，它可能看起来如下：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding snippet demonstrates the power of functional programming. This
    code looks concise and readable. The Kotlin standard library contains a lot of
    extension functions that extend the functionality of the list type.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段展示了函数式编程的强大功能。这段代码看起来简洁易读。Kotlin标准库包含许多扩展函数，这些函数扩展了列表类型的功能。
- en: Extension functions
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展函数
- en: The extension functions feature of Kotlin doesn't relate to functional programming,
    but it's better to explain this concept before moving forward. This feature allows
    us to extend a class or type with a new functionality, without using inheritance or
    any software design patterns, such as decorators.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin的扩展函数特性与函数式编程无关，但最好在继续前进之前解释这个概念。这个特性允许我们通过不使用继承或任何软件设计模式（如装饰者模式），向一个类或类型添加新的功能。
- en: In object-oriented programming, a decorator is a design pattern that allows
    us to add a behavior to an object dynamically, without affecting other objects
    from the same class.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，装饰器是一种设计模式，允许我们动态地向一个对象添加行为，而不影响同一类中的其他对象。
- en: 'In the following code snippet, the `extension` function is added to the functionality
    of the `A` class:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，`extension`函数被添加到`A`类的功能中：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you can see, it''s easy to use this feature. We just need to specify a class
    name and declare a function name after the dot. Now, we can invoke the extension
    function as usual:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用这个特性很容易。我们只需要指定一个类名，在点号后面声明一个函数名。现在，我们可以像通常一样调用扩展函数：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Collections in Kotlin
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin中的集合
- en: The `find` function that we've seen is contained in the `Collections.kt` file
    from the Kotlin standard library. This file contains a lot of extension functions
    that bring a functional approach to Kotlin and extend the functionality of Java's
    collection, in order to simplify work with them.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到的`find`函数包含在Kotlin标准库的`Collections.kt`文件中。这个文件包含许多扩展函数，这些函数将函数式方法引入Kotlin，并扩展了Java集合的功能，以便简化与之相关的操作。
- en: A collections is a hierarchy of classes and interfaces that are used to store
    and manipulate a group of objects.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是一系列用于存储和操作一组对象的类和接口的层次结构。
- en: 'The most common functions from the `Collections.kt` file are as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collections.kt`文件中最常见的函数如下：'
- en: '`filter`: This returns a new list that contains elements that only matched
    a passed predicate'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter`：这个函数返回一个新列表，其中只包含匹配了传入谓词的元素'
- en: '`find`: This returns an element that matched a passed predicate'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find`：这个函数返回一个匹配了传入谓词的元素'
- en: '`forEach`: This performs an approved action on each element'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forEach`：这个函数对每个元素执行一个批准的操作'
- en: '`map`: This returns a new list, where each element was transformed according
    to the passed function'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map`：这个函数返回一个新列表，其中每个元素都根据传入的函数进行了转换'
- en: All of these are referred to as higher-order functions.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都被称为高阶函数。
- en: Higher-order functions
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高阶函数
- en: A function is called **higher-order** if it can take or return another function.
    The following diagrams show the different cases of higher-order functions.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数可以接收或返回另一个函数，那么它被称为**高阶函数**。以下图例展示了高阶函数的不同情况。
- en: 'The first diagram demonstrates a case in which the `f` function takes the lambda
    and returns a simple object:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个图例演示了`f`函数接收lambda并返回一个简单对象的情况：
- en: '![](img/4bfacce2-1793-4da8-90da-cbe8a9c8940d.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4bfacce2-1793-4da8-90da-cbe8a9c8940d.png)'
- en: 'The second diagram demonstrates a case in which the `f` function takes an object
    and returns a function:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个图例演示了`f`函数接收一个对象并返回一个函数的情况：
- en: '![](img/f7cab906-b4cd-4c48-af5d-ea50b8c3f209.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f7cab906-b4cd-4c48-af5d-ea50b8c3f209.png)'
- en: 'Finally, the third diagram demonstrates a case in which the `f` function takes
    and returns lambdas:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，第三个图例演示了一个`f`函数接收并返回lambda的情况：
- en: '![](img/2d5b3d03-2f47-4d57-88bd-034011937008.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2d5b3d03-2f47-4d57-88bd-034011937008.png)'
- en: 'Let''s look at the implementation of the `firstOrNull` function, as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`firstOrNull`函数的实现，如下所示：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `firstOrNull` function is an extension that takes a lambda as a parameter
    and invokes it as the usual function—`predicate(element)`. This returns the first
    element that matches the `predicate` in a collection; it is `null` if there is
    no other element that meets a condition.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`firstOrNull`函数是一个扩展函数，它接受一个Lambda作为参数，并以通常的方式调用它——`predicate(element)`。它返回集合中第一个匹配`predicate`的元素；如果没有其他元素满足条件，则为`null`。'
- en: Lambdas
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambdas
- en: A lambda is a function that is not declared. This is useful when we need to
    invoke an action, but we don't need to define a function for it, because we will
    use it only once, or only in one scope. A lambda is an expression, meaning that
    it returns a value. All of the functions in Kotlin are expressions, and even a
    scope of a function doesn't contain the `return` keyword; it returns a value that
    is evaluated at the end.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda是一个未声明的函数。这在我们需要执行一个动作，但又不需要为它定义一个函数时很有用，因为我们只会使用它一次，或者只在一个作用域中使用。Lambda是一个表达式，意味着它返回一个值。Kotlin中的所有函数都是表达式，甚至一个函数的作用域也不包含`return`关键字；它返回一个在末尾评估的值。
- en: 'The following lambda expression returns an object of the `Unit` type, implicitly:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Lambda表达式返回一个隐式的`Unit`类型的对象：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'A declaration of the `Unit` object looks as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`Unit`对象的声明如下：'
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'A reference to a lambda can be saved to a variable:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda的引用可以保存到变量中：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can use this variable to invoke the saved lambda:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个变量来调用保存的Lambda：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Control flow elements
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制流元素
- en: 'In Kotlin, control flow elements are expressions. This is different from Java,
    in which they are statements. Statements just specify the flow of a program, and
    don''t return any values. This section will cover the following control flow elements:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，控制流元素是表达式。这与Java不同，在Java中它们是语句。语句仅指定程序的流程，不返回任何值。本节将涵盖以下控制流元素：
- en: The `if { ... } else { ... }` expression
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if { ... } else { ... }`表达式'
- en: The `when { ... }` expression
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`when { ... }`表达式'
- en: The if { ... } else { ... } expression
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`if { ... } else { ... }`表达式'
- en: 'In Kotlin, the `if` control flow element can be used in the same way as it
    is used in Java. The following example demonstrates the use of `if` as a usual
    statement:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，`if`控制流元素可以像在Java中使用一样使用。以下示例演示了`if`作为常规语句的使用：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you are using the `if { ... } else { ... }` control flow element as an expression,
    you have to declare the `else` block, as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`if { ... } else { ... }`控制流元素作为表达式，你必须声明`else`块，如下所示：
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The preceding example shows that `if { ... } else { ... }` returns a value.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例显示`if { ... } else { ... }`返回一个值。
- en: The when { ... } expression
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`when { ... }`表达式'
- en: The `switch { ... }` control flow element is replaced by `when { ... }`. The
    `when { ... }` element of Kotlin is much more flexible than the `switch { ...
    }` element in Java, because it can take a value of any type. A branch only has
    to contain a matched condition.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin中的`switch { ... }`控制流元素被`when { ... }`所取代。Kotlin中的`when { ... }`元素比Java中的`switch
    { ... }`元素更加灵活，因为它可以接受任何类型的值。一个分支只需要包含一个匹配条件。
- en: 'The following example demonstrates how to use `when { ... }` as a statement:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了如何使用`when { ... }`作为语句：
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The preceding code snippet contains the `else` branch, which is optional for
    a case with a statement. The `else` branch is invoked if all other branches don''t
    have a matching condition. The `else` branch is mandatory if you use `when { ...
    }` as an expression and the compiler can''t be sure that all possible cases are
    covered. The following expression returns `Unit`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段包含`else`分支，对于具有语句的案例，它是可选的。如果所有其他分支都没有匹配的条件，则调用`else`分支。如果您使用`when {
    ... }`作为表达式，并且编译器无法确定所有可能的案例都被覆盖，则`else`分支是必需的。以下表达式返回`Unit`：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, expressions provide a much more concise way to write code. To
    be sure that your branches cover all of the possible cases, you can use enums
    or sealed classes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，表达式提供了一种更简洁的编写代码的方式。为了确保您的分支覆盖了所有可能的案例，您可以使用枚举或Sealed类。
- en: An enum is a special kind of class that is used to define a set of constants.
    A sealed class is a parent class that has a restricted hierarchy of subclasses.
    All of the subclasses can only be defined in the same file as a sealed class.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Enum是一个特殊类型的类，用于定义一组常量。Sealed类是一个具有受限子类层次结构的父类。所有子类都必须在Sealed类所在的同一文件中定义。
- en: 'In Kotlin, enums work similarly to how they work in Java. Sealed classes can
    be used if we want to restrict a class hierarchy. This works in the following
    way:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，枚举的工作方式与Java中的方式类似。如果我们想限制类层次结构，可以使用密封类。这如下所示：
- en: You should declare a class using the `sealed` keyword
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该使用`sealed`关键字声明一个类
- en: All inheritors of your sealed class must be declared in the same file as their
    parent
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您密封类的所有继承者必须在与其父类相同的文件中声明。
- en: 'The following example demonstrates how this can be implemented:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了如何实现这一点：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With the `when { ... }` expression, we can use classes of the `Method` type,
    in the following way:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`when { ... }`表达式，我们可以使用`Method`类型的类，如下所示：
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, using this approach, we don't have to use the `else` branch.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用这种方法，我们不必使用`else`分支。
- en: Loops
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环
- en: 'A loop is a special statement that allows us to execute code repeatedly. Kotlin
    supports two types of loops, as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 循环是一个特殊语句，允许我们重复执行代码。Kotlin支持两种类型的循环，如下所示：
- en: '`for`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for`'
- en: '`while`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while`'
- en: for loops
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: for循环
- en: A `for` loop statement allows us to iterate anything that contains the `iterate()`
    method. In turn, this provides an instance that matches the iterator interface
    through the principle of duck typing.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环语句允许我们迭代任何包含`iterate()`方法的任何内容。反过来，这通过鸭子类型原则提供了一个符合迭代器接口的实例。'
- en: The duck typing principle means that an interface is implemented implicitly
    if all of the methods that it contains are implemented.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 鸭子类型原则意味着如果一个接口包含的所有方法都被实现，则该接口被隐式实现。
- en: 'The `Iterator` interface looks as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`Iterator`接口如下所示：'
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If we want to provide the `iterator()`, `hasNext()`, and `next()` methods as
    class members, we have to declare them with the `operator` keyword. The following
    example demonstrates a case of this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想将`iterator()`、`hasNext()`和`next()`方法作为类成员提供，我们必须使用`operator`关键字声明它们。以下示例演示了这种情况：
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `Numbers` class can be used as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`Numbers`类可以如下使用：'
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'An implementation using extension functions is as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用扩展函数的实现如下：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see, extension functions allow us to make preexisting classes iterable.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，扩展函数使我们能够使现有的类可迭代。
- en: while loops
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: while循环
- en: 'The `while() { ... }` and `do { ... } while()` statements work in the same
    way that they work in Java. The `while` statement takes a condition, and `do`
    specifies a block of code that should be invoked while the condition is `true`.
    The following example demonstrates how `do { ... } while()` looks in Kotlin:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`while() { ... }`和`do { ... } while()`语句的工作方式与Java中的方式相同。`while`语句接受一个条件，而`do`指定了一个在条件为`true`时应调用的代码块。以下示例演示了`do
    { ... } while()`在Kotlin中的样子：'
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see, the `do { ... } while` construction works in the same way that
    it does in other C-like languages.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`do { ... } while`构造与在其他C-like语言中的工作方式相同。
- en: Ranges
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 范围
- en: 'Kotlin supports the concept of ranges, which represent sequences of comparable
    types. To create a range, we can use the `rangeTo` methods that are implemented
    in classes, such as `Int`, in the following way:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin支持范围的概念，它表示可比较类型的序列。要创建范围，我们可以使用在类中实现的`rangeTo`方法，如下所示：
- en: '[PRE32]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'So, we have two options for creating a range, as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有两种创建范围的方法，如下所示：
- en: Using the `rangeTo` method. This may look as follows—`1.rangeTo(100)`.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`rangeTo`方法。这可能看起来如下——`1.rangeTo(100)`。
- en: Using the `..` operator. This may look as follows—`1..100`.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`..`运算符。这可能看起来如下——`1..100`。
- en: 'Ranges are extremely useful when we work with loops:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 范围在我们使用循环时非常有用：
- en: '[PRE33]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `0..100` range is equal to the  `1 <= i && i <= 100` statement.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`0..100`范围等于`1 <= i && i <= 100`语句。'
- en: 'If you want to exclude the last value, you can use the `until` function, in
    the following way:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想排除最后一个值，可以使用`until`函数，如下所示：
- en: '[PRE34]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can also use the `step` function, as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`step`函数，如下所示：
- en: '[PRE35]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The preceding snippet represents a range like the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段表示如下范围：
- en: '[PRE36]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'It''s worth mentioning that ranges support a lot of `until` functions, such
    as `filter` or `map`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，范围支持许多`until`函数，例如`filter`或`map`：
- en: '[PRE37]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: String templates
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串模板
- en: Kotlin supports one more powerful feature—string templates. Strings can contain
    code expressions that can be executed, and their results concatenated to the string.
    The syntax of the string template assumes that we use the `$` symbol at the start
    of an expression. If the expression contains some evaluation, it has to be surrounded
    by curly braces.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 支持一个更强大的功能——字符串模板。字符串可以包含可执行的代码表达式，并将它们的结果连接到字符串中。字符串模板的语法假设我们在表达式的开头使用
    `$` 符号。如果表达式包含一些评估，它必须被大括号包围。
- en: 'The simplest use of string templates looks like the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串模板的最简单用法如下所示：
- en: '[PRE38]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'A more advanced example that contains an expression is as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 包含表达式的更高级示例如下：
- en: '[PRE39]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As you can see, the string templates feature allows us to write code in a more
    concise way than the usual concatenation or the `StringBuilder` class.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，字符串模板功能允许我们以比通常的连接或 `StringBuilder` 类更简洁的方式编写代码。
- en: Null safety, reflection, and annotations
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空安全、反射和注解
- en: Although we have already covered the most common topics that relate to a basic
    overview of Kotlin, there are a few more topics that have to be touched upon.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经涵盖了与 Kotlin 基本概述相关的大部分常见主题，但仍有一些更多的话题需要涉及。
- en: 'This section will introduce the following topics:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将介绍以下主题：
- en: Null safety
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空安全
- en: Reflection
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反射
- en: Annotations
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注解
- en: Null safety
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空安全
- en: 'Kotlin supports a more strict type system when compared to Java, and divides
    all types into two groups, as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Java 相比，Kotlin 支持更严格的类型系统，并将所有类型分为两组，如下所示：
- en: Nullable
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可空
- en: No-nullable
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可空
- en: One of the most popular causes of an app crashing is the `NullPointerException`.
    This happens as a result of accessing a member of a `null` reference. Kotlin provides
    a mechanism that helps us to avoid this error by using a type system.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序崩溃的最常见原因之一是 `NullPointerException`。这发生在访问 `null` 引用的成员时。Kotlin 提供了一种机制，通过使用类型系统来帮助我们避免这种错误。
- en: 'The following diagram shows what the class hierarchy looks like in Kotlin:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了 Kotlin 中的类层次结构看起来像什么：
- en: '![](img/e15195cc-ae8a-43cc-acca-9fd4de20fa01.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e15195cc-ae8a-43cc-acca-9fd4de20fa01.png)'
- en: In Kotlin, nullable types have the same names as no-nullable types, except with
    the `?` character at the end.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，可空类型与不可空类型的名称相同，只是在末尾带有 `?` 字符。
- en: 'If we use a no-nullable variable, we can''t assign `null` to it, and the following
    code can''t be compiled:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用不可空变量，则不能将其赋值为 `null`，以下代码无法编译：
- en: '[PRE40]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To be able to compile this code, we have to explicitly declare the `name` variable
    as nullable:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够编译此代码，我们必须显式声明 `name` 变量为可空：
- en: '[PRE41]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'After doing this, we cannot compile the following code:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成此操作后，我们无法编译以下代码：
- en: '[PRE42]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To access members of nullable types, we have to use the `?.` operator, like
    in the following example:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问可空类型的成员，我们必须使用 `?.` 操作符，如下例所示：
- en: '[PRE43]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'One expression can contain the `?.` operator as many times as needed:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 一个表达式可以多次包含 `?.` 操作符，所需次数如下：
- en: '[PRE44]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If a member in this chain is `null`, the next member can't be invoked.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果链中的某个成员为 `null`，则无法调用下一个成员。
- en: 'To provide an alternative program flow, if `null` is encountered, we can use
    the Elvis operator (`?:`). This can be used in the following way:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供一个替代的程序流程，如果遇到 `null`，我们可以使用 Elvis 操作符 (`?:`)。这可以按以下方式使用：
- en: '[PRE45]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The preceding snippet demonstrates that the Elvis operator can be used if we
    want invoke a block of code if an expression returns as `null`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段演示了，如果我们想在一个表达式返回 `null` 时调用代码块，可以使用 Elvis 操作符。
- en: Reflection
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反射
- en: Reflection allows us to introspect code at runtime; this is implemented by a
    set of languages and standard library features. The Kotlin standard library contains
    the `kotlin.reflect` package that, in turn, contains classes that represent references
    to elements, such as classes, functions, or properties.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 反射允许我们在运行时对代码进行元编程；这是通过一组语言和标准库功能实现的。Kotlin 标准库包含 `kotlin.reflect` 包，该包反过来包含表示元素引用的类，例如类、函数或属性。
- en: 'To obtain a reference to an element, we should use the `::` operator. The following
    example demonstrates how to obtain a reference to a class:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取元素引用，我们应该使用 `::` 操作符。以下示例演示了如何获取类引用：
- en: '[PRE46]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As you can see, references to classes are represented by the `KClass` class.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，类引用由 `KClass` 类表示。
- en: 'References to functions can also be passed to high-order functions. The following
    example shows how this may look:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 函数引用也可以传递给高阶函数。以下示例显示了这可能看起来像什么：
- en: '[PRE47]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'A reference to a property is represented by the `KProperty` class, and this
    can be obtained in the following way:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 属性的引用由 `KProperty` 类表示，并且可以通过以下方式获得：
- en: '[PRE48]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '`KProperty` is a class that represents a property of a class, and it can be
    used to retrieve metadata, such as names or types.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`KProperty` 是一个表示类属性的类，它可以用来检索元数据，例如名称或类型。'
- en: Annotations
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注释
- en: 'Annotations are used to attach metadata to code. This is created using the
    `annotation` keyword:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 注解用于将元数据附加到代码。这是使用 `annotation` 关键字创建的：
- en: '[PRE49]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In the most common cases, annotations are used by annotation processing tools
    to generate or modify code. Let''s look at the following example:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在最常见的情况下，注解由注解处理工具使用，以生成或修改代码。让我们看看以下示例：
- en: '[PRE50]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The Kotlin bytecode viewer shows the following code:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 字节码查看器显示了以下代码：
- en: '[PRE51]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'As you can see, the `Example1` class contains the nested `Companion` class
    that contains the `companionClassMember` method. We can mark the `companionClassMember`
    method when the `@JvmStatic` annotation and the decompiled code to Java code version
    looks as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`Example1` 类包含嵌套的 `Companion` 类，该类包含 `companionClassMember` 方法。当使用 `@JvmStatic`
    注解和反编译后的 Java 代码版本时，我们可以标记 `companionClassMember` 方法，其代码如下：
- en: '[PRE52]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The preceding snippet contains the additional static `companionClassMember` function
    in the `Example1` class that invokes the method of the `Companion` class. Using
    the `@JvmStatic` annotation, we tell the compiler to generate an additional method
    that can be used from the Java side.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段包含在 `Example1` 类中定义的额外静态 `companionClassMember` 函数，该函数调用 `Companion`
    类的方法。使用 `@JvmStatic` 注解，我们告诉编译器生成一个额外的可以从 Java 端使用的方法。
- en: Summary
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we took a close look at the basic syntax of Kotlin. We also
    introduced and looked at examples of some features, such as lambdas, string templates,
    and ranges. Furthermore, you learned that control flow elements, such as `if {
    ... } else { ... }` and `when { ... }`, can be used as expressions that can make
    our code more concise and readable.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们仔细研究了 Kotlin 的基本语法。我们还介绍并探讨了某些特性的示例，例如 lambda 表达式、字符串模板和范围。此外，你了解到控制流元素，如
    `if { ... } else { ... }` 和 `when { ... }`，可以用作表达式，可以使我们的代码更加简洁和易读。
- en: In the next chapter, we will take a look at an overview of the Spring framework.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将概述 Spring 框架。
- en: Questions
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is Kotlin?
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 Kotlin？
- en: How does Kotlin support object-oriented programming?
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kotlin 如何支持面向对象编程？
- en: How does Kotlin support functional programming?
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kotlin 如何支持函数式编程？
- en: How do we define variables in Kotlin?
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在 Kotlin 中定义变量？
- en: How do we define functions in Kotlin?
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在 Kotlin 中定义函数？
- en: Further reading
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Kotlin Quick Start Guide* ([https://www.packtpub.com/application-development/kotlin-quick-start-guide](https://www.packtpub.com/application-development/kotlin-quick-start-guide)) by
    Marko Devcic, published by Packt.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '*Kotlin 快速入门指南* ([https://www.packtpub.com/application-development/kotlin-quick-start-guide](https://www.packtpub.com/application-development/kotlin-quick-start-guide))，作者
    Marko Devcic，由 Packt 出版。'
