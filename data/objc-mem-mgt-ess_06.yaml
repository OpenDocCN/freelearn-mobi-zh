- en: Chapter 6. Using Core Data for Persistence
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. 使用Core Data进行持久化
- en: If you do any serious form of iOS development, data persistence is something
    that you are bound to come across sooner rather than later. After all, what good
    is an app when it does not save your user data and requires you to fill it in
    again when you start the app again subsequently?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您进行任何严肃的iOS开发，数据持久化是您迟早会遇到的事情。毕竟，如果一个应用程序不能保存用户数据，并且需要在您再次启动应用程序时重新填写，那么这个应用程序有什么好处呢？
- en: This is where data persistence comes into the scene. As it is, iOS developers
    have a few options for data persistence ranging from property list, binary format
    to SQLite, and so on.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是数据持久化出现的地方。实际上，iOS开发者有几个数据持久化的选项，从属性列表、二进制格式到SQLite等。
- en: As with these options, each has its good and bad points, and when to use each
    particular method of persistence will depend on your use case. You will also have
    to write specific code to handle data persistence for SQLite and binary data.
    Core Data can be used to store data in **plist**, SQLite, and other formats, which
    makes it a pretty powerful framework in itself as we will see in this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 与这些选项一样，每个选项都有其优点和缺点，何时使用每种特定的持久化方法将取决于您的用例。您还必须编写特定的代码来处理SQLite和二进制数据的数据持久化。Core
    Data可以用于将数据存储在**plist**、SQLite和其他格式中，这使得它本身就是一个相当强大的框架，正如我们将在本章中看到的那样。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Why use Core Data?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么使用Core Data？
- en: Core Data concepts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Core Data概念
- en: Putting Core Data into practice
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Core Data付诸实践
- en: Getting into the code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进入代码编写
- en: Saving data into the persistent store
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据保存到持久存储中
- en: Deleting data from the persistent store
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从持久存储中删除数据
- en: Why use Core Data?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么使用Core Data？
- en: You might be thinking to yourself, "Why do I have to learn another method when
    there are so many ways already available to us?" So, in this section and on the
    following pages, we will see why Core Data is the preferred way to store data
    on iOS and the Mac OS platform.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能正在想，“为什么我必须学习另一种方法，因为我们已经有了这么多方法？”因此，在本节和随后的页面上，我们将看到为什么Core Data是iOS和Mac
    OS平台上存储数据的首选方式。
- en: The first thing you need to know is that Core Data is not another method of
    data persistence per se; it is actually an abstraction over SQLite, plists, and
    so on. This means that you can actually use Apple's Core Data API to save your
    data into the persistent store just by using the Core Data API without needing
    to write plist-specific or SQLite-specific code if you choose to store your data
    as plists or SQLite respectively. This abstraction layer illustrates the basic
    concept of why Core Data is so powerful.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要知道的第一件事是，Core Data本身不是另一种数据持久化方法；它实际上是SQLite、plists等之上的抽象。这意味着您实际上可以使用Apple的Core
    Data API将数据保存到持久存储中，只需使用Core Data API，无需编写plist特定或SQLite特定代码，如果您选择将数据存储为plists或SQLite。这个抽象层说明了为什么Core
    Data如此强大的基本概念。
- en: Now that you have your mind blown, the abstraction layer means that you can
    just use the Core Data APIs, and the abstraction layer will handle all the storage-specific
    code for you as all this high-level stuff will help you get away from writing
    low-level stuff, specific for each different data persistent format such as SQLite,
    property list, and so on.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经感到震惊，抽象层意味着您只需使用Core Data API，抽象层将为您处理所有特定存储的代码，因为所有这些高级功能都将帮助您摆脱编写低级代码，这些代码针对每种不同的数据持久化格式，如SQLite、属性列表等。
- en: Core Data integrates very tightly with iCloud and provides a host of benefits
    related to iCloud, such as data synching. It also allows you to do entity modeling
    with the benefits of querying while making it very fast in terms of access speed
    plus giving you the freedom to choose the storage type that can be SQLite, XML,
    or NSDate. With all the benefits that Core Data provides, it comes with a trade-off
    in which you need to write a bit more code compared to NSCoding. However, as we
    will see later, the amount of code is not a lot, and the Core Data framework is
    not complex to understand too.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Core Data与iCloud紧密集成，并提供了一系列与iCloud相关的优势，如数据同步。它还允许您在查询的同时进行实体建模，使其在访问速度方面非常快，并给您选择存储类型的自由，可以是SQLite、XML或NSDate。鉴于Core
    Data提供的所有优势，它需要与NSCoding相比编写更多的代码。然而，正如我们稍后将会看到的，代码量并不多，Core Data框架也不难理解。
- en: A few more things that I would like to mention about Core Data is that since
    it is so tightly integrated into the Apple platforms, you can have access to a
    lot of related classes such as `NSFetchedResultsController` that make it easy
    for you to get your entities into `UITableViews`. It also has a nice graphical
    object model editor that allows you to easily think about your object/entity design
    and conceptualize it easily using Core Data's visual tools. With all these benefits,
    let's dig into Core Data now.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Core Data，我还想提到几点：由于它与Apple平台紧密集成，你可以访问许多相关类，如`NSFetchedResultsController`，这使得你轻松地将实体添加到`UITableViews`中。它还提供了一个不错的图形对象模型编辑器，允许你轻松地思考你的对象/实体设计，并使用Core
    Data的视觉工具轻松地概念化它。有了所有这些好处，现在让我们深入了解Core Data。
- en: Understanding Core Data concepts
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Core Data概念
- en: 'Core Data allows you to store your data in a variety of storage types. So,
    if you want to use other types of memory store, such as XML or binary store, you
    can use the following store types:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Core Data允许你以多种存储类型存储数据。因此，如果你想使用其他类型的内存存储，如XML或二进制存储，你可以使用以下存储类型：
- en: '`NSSQLiteStoreType`: This is the option you most commonly use as it just stores
    your database in a SQLite database.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NSSQLiteStoreType`: 这是最常用的选项，因为它只是将你的数据库存储在SQLite数据库中。'
- en: '`NSXMLStoreType`: This will store your data in an XML file, which is slower,
    but you can open the XML file and it will be human readable. This has the option
    of helping you debug errors relating to storage of data. However, do note that
    this storage type is only available for Mac OS X.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NSXMLStoreType`: 这种存储方式会将你的数据保存在一个XML文件中，速度较慢，但你可以打开XML文件，它将是可读的。这个选项可以帮助你调试与数据存储相关的错误。然而，请注意，这种存储类型仅适用于Mac
    OS X。'
- en: '`NSBinaryStoreType`: This occupies the least amount of space and also produces
    the fastest speed as it stores all data as a binary file, but the entire database
    binary need to be able to fit into memory in order to work properly.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NSBinaryStoreType`: 这种存储方式占用的空间最少，并且由于它将所有数据存储为二进制文件，因此速度最快，但整个数据库二进制文件需要能够适应内存才能正常工作。'
- en: '`NSInMemoryStoreType`: This stores all data in memory and provides the fastest
    access speed. However, the size of your database to be saved cannot exceed the
    available free space in memory since the data is stored in memory. However, do
    note that memory storage is ephemeral and is not stored permanently to disk.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NSInMemoryStoreType`: 这种存储方式将所有数据保存在内存中，并提供最快的访问速度。然而，要保存的数据库大小不能超过内存中可用的空闲空间，因为数据是保存在内存中的。然而，请注意，内存存储是短暂的，并且不会永久保存在磁盘上。'
- en: 'Next, there are two concepts that you need to know, and they are:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，有两个概念你需要了解，它们是：
- en: Entity
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体
- en: Attributes
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性
- en: Now, these terms may be foreign to you. However, for those of you who have knowledge
    of databases, you will know it as tables and columns. So, to put it in an easy-to-understand
    picture, think of Core Data entities as your database tables and Core Data attributes
    as your database columns.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这些术语可能对你来说很陌生。然而，对于那些了解数据库的人来说，你会知道它们是表格和列。所以，为了便于理解，可以把Core Data实体看作是你的数据库表格，Core
    Data属性看作是你的数据库列。
- en: So, Core Data handles data persistence using the concepts of entity and attributes,
    which are abstract data types, and actually saves the data into plists, SQLite
    databases, or even XML files (applicable only to the Mac OS). Going back a bit
    in time, Core Data is a descendant of Apple's **Enterprise Objects Framework**
    (**EOF**), which was introduced by NeXT, Inc in 1994, and EOF is an **Object-relational
    mapper** (**ORM**), but Core Data itself is not an ORM. Core Data is a framework
    for managing the object graph, and one of its powerful capabilities is that it
    allows you to work with extremely large datasets and object instances that normally
    would not fit into memory by putting objects in and out of memory when necessary.
    Core Data will map the Objective-C data type to the related data types, such as
    string, date, and integer, which will be represented by `NSString`, `NSDate`,
    and `NSNumber` respectively. So, as you can see, Core Data is not a radically
    new concept that you need to learn as it is grounded in the simple database concepts
    that we all know. Since entity and attributes are abstract data types, you cannot
    access them directly as they do not exist in physical terms. So to access them,
    you need to use the Core Data classes and methods provided by Apple.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Core Data通过使用实体和属性的概念来处理数据持久化，这些是抽象数据类型，实际上将数据保存到属性列表、SQLite数据库或甚至XML文件（仅适用于Mac
    OS）。回顾一下，Core Data是Apple的**企业对象框架**（**EOF**）的后代，EOF由NeXT, Inc在1994年引入，EOF是一个**对象关系映射器**（**ORM**），但Core
    Data本身不是一个ORM。Core Data是一个用于管理对象图框架，它的一项强大功能是它允许你在必要时将对象放入和移出内存，从而处理通常无法适应内存的极大规模数据集和对象实例。Core
    Data将Objective-C数据类型映射到相关数据类型，如字符串、日期和整数，分别由`NSString`、`NSDate`和`NSNumber`表示。所以，正如你所见，Core
    Data不是一个需要学习的全新概念，因为它基于我们所有人都知道的简单数据库概念。由于实体和属性是抽象数据类型，你不能直接访问它们，因为它们在物理上不存在。因此，要访问它们，你需要使用Apple提供的Core
    Data类和方法。
- en: 'The number of classes for Core Data is actually pretty long, and you won''t
    be using all of them regularly. So, here is a list of the more commonly used classes:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Core Data的类实际上相当多，你不会经常使用它们的所有类。所以，这里有一个更常用类的列表：
- en: '| Class name | Example use case |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 类名 | 示例用途 |'
- en: '| --- | --- |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `NSManagedObject` | Accessing attributes and rows of data |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `NSManagedObject` | 访问属性和数据行 |'
- en: '| `NSManagedObjectContext` | Fetching data and saving data |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `NSManagedObjectContext` | 检索数据和保存数据 |'
- en: '| `NSManagedObjectModel` | Storage |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `NSManagedObjectModel` | 存储 |'
- en: '| `NSFetchRequest` | Requesting data |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `NSFetchRequest` | 请求数据 |'
- en: '| `NSPersistentStoreCoordinator` | Persisting data |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `NSPersistentStoreCoordinator` | 持久化数据 |'
- en: '| `NSPredicate` | Data query |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `NSPredicate` | 数据查询 |'
- en: 'Now, explore each of these classes in depth:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，深入探索这些类：
- en: '`NSManagedObject`: This is a record that you will use and perform operations
    on and all entities will extend this class.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NSManagedObject`：这是一个你将使用并对其执行操作的记录，所有实体都将扩展这个类。'
- en: '`NSManagedObjectContext`: This can be thought of as an intelligent scratchpad
    where temporary copies are brought into it after you fetch objects from the persistent
    store. So, any modifications done in this intelligent scratchpad are not saved
    until you save those changes into the persistent store, `NSManagedObjectModel`.
    Think of this as a collection of entities or a database schema, if you will.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NSManagedObjectContext`：这可以被视为一个智能便签本，在你从持久化存储中检索对象后，临时副本会被带入其中。因此，在这个智能便签本中进行的任何修改都不会保存，直到你将这些更改保存到持久化存储，即`NSManagedObjectModel`。如果你愿意，可以将其视为实体集合或数据库模式。 '
- en: '`NSFetchRequest`: This is an operation that describes the search criteria,
    which you will use to retrieve data from the persistent store, a kind of the common
    SQL query that most developers are familiar with.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NSFetchRequest`：这是一个描述搜索条件的操作，你将使用它从持久化存储中检索数据，类似于大多数开发者熟悉的常见SQL查询。'
- en: '`NSPersistentStoreCoordinator`: This is like the glue that associates your
    managed object context and persistent.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NSPersistentStoreCoordinator`：这就像是粘合剂，将你的托管对象上下文和持久化存储关联起来。'
- en: '`NSPersistentStoreCoordinator`: Without this, your modifications will not be
    saved to the persistent store.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NSPersistentStoreCoordinator`：没有这个，你的修改将不会保存到持久化存储中。'
- en: '`NSPredicate`: This is used to define logical conditions used in a search or
    for filtering in-memory. Basically, it means that `NSPredicate` is used to specify
    how data is to be fetched or filtered and you can use it together with `NSFetchRequest`
    as `NSFetchRequest` has a predicate property.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NSPredicate`：这用于定义在搜索或内存过滤中使用的逻辑条件。基本上，这意味着`NSPredicate`用于指定数据如何被检索或过滤，并且您可以与`NSFetchRequest`一起使用，因为`NSFetchRequest`有一个谓词属性。'
- en: Putting it into practice
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 付诸实践
- en: 'Now that we have covered the basics of Core Data, let''s proceed with some
    code examples of how to use Core Data, where we use Core Data to store customer
    details in a `Customer` table. The information we want to store is:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了Core Data的基础知识，让我们继续一些代码示例，展示如何使用Core Data，其中我们使用Core Data在`Customer`表中存储客户详细信息。我们想要存储的信息是：
- en: '`name`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`'
- en: '`email`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`email`'
- en: '`phone_number`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`phone_number`'
- en: '`address`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`address`'
- en: '`age`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`age`'
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Do note that all attribute names must be in lowercase and should not have spaces
    in them. For example, we will use Core Data to store customer details mentioned
    earlier as well as retrieve, update, and delete the customer records using the
    Core Data framework and methods.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所有属性名称必须全部小写，并且不应包含空格。例如，我们将使用Core Data存储之前提到的客户详细信息，以及使用Core Data框架和方法检索、更新和删除客户记录。
- en: First, we will select **File** | **New** | **File** and then select **iOS**
    | **Core Data**:![Putting it into practice](img/00026.jpeg)
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将选择**文件** | **新建** | **文件**，然后选择**iOS** | **Core Data**：![付诸实践](img/00026.jpeg)
- en: Then, we will proceed to create a new **Entity** called **Customer** by clicking
    on the **Add Entity** button in the bottom left of the screen, as shown here:![Putting
    it into practice](img/00027.jpeg)
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将通过点击屏幕左下角的**添加实体**按钮来创建一个新的**实体**，名为**Customer**，如下截图所示：![付诸实践](img/00027.jpeg)
- en: Then, we will proceed to add in the attributes for our **Customer** entity and
    give them the appropriate **Type**, which can be **String** for attributes such
    as **name** or **address** and **Integer 16** for **age**:![Putting it into practice](img/00028.jpeg)
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将继续添加**Customer**实体的属性，并给它们分配适当的**类型**，例如，对于**name**或**address**等属性，可以使用**String**类型，对于**age**可以使用**Integer
    16**类型：![付诸实践](img/00028.jpeg)
- en: Lastly, we need to add **CoreData.framework**, as shown in the following screenshot:![Putting
    it into practice](img/00029.jpeg)
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要添加**CoreData.framework**，如下截图所示：![付诸实践](img/00029.jpeg)
- en: So with this, we have created a Core Data model class consisting of a `Customer`
    entity and some attributes. Do note that all core model classes have the `.xcdatamodeld`
    file extension and for us, we can save our Core Data model as `Model.xcdatamodeld`.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们已经创建了一个由`Customer`实体和一些属性组成的Core Data模型类。请注意，所有核心模型类都有`.xcdatamodeld`文件扩展名，对于我们来说，我们可以将Core
    Data模型保存为`Model.xcdatamodeld`。
- en: 'Next, we will create a sample application that uses Core Data in the following
    ways:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个示例应用程序，该应用程序以下列方式使用Core Data：
- en: Saving a record
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存记录
- en: Searching for a record
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索记录
- en: Deleting a record
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除记录
- en: Loading records
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载记录
- en: 'Now, I won''t cover the usage of UIKit and storyboard, but instead focus on
    the core code needed to give you an example of Core Data works. So, to start things
    off, here are a few screenshots of the application for you to have a look at to
    see what we''ll do:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我不会涵盖UIKit和storyboard的使用，而是专注于核心代码，以向您展示Core Data的工作示例。因此，为了开始，这里有一些应用程序的截图供您查看，以了解我们将做什么：
- en: This is the main screen when you start the app:![Putting it into practice](img/00030.jpeg)
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是启动应用程序时的主屏幕：![付诸实践](img/00030.jpeg)
- en: The screen to insert a record is shown here:![Putting it into practice](img/00031.jpeg)
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入记录的屏幕如下所示：![付诸实践](img/00031.jpeg)
- en: The screen to list all records from our persistent store is as follows:![Putting
    it into practice](img/00032.jpeg)
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出我们从持久存储中所有记录的屏幕如下所示：![付诸实践](img/00032.jpeg)
- en: By deleting a record from the persistent store, you will get the following output:![Putting
    it into practice](img/00033.jpeg)
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过从持久存储中删除记录，您将得到以下输出：![付诸实践](img/00033.jpeg)
- en: Getting into the code
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进入代码
- en: 'Let''s get started with our code examples:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从代码示例开始：
- en: 'For our code, we will first declare some Core Data objects in our `AppDelegate`
    class inside our `AppDelegate.h` file such as:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的代码，我们首先需要在`AppDelegate.h`文件中的`AppDelegate`类中声明一些Core Data对象，例如：
- en: '[PRE0]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: These are declared here so that we can access them easily from any screen.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些在这里声明，以便我们可以轻松地从任何屏幕访问它们。
- en: 'Next, we will declare the code for each of the objects in `AppDelegate.m` such
    as the following lines of code that will create an instance of `NSManagedObjectContext`
    and return an existing instance if the instance already exists. This is important
    as you want only one instance of the context to be present to avoid conflicting
    access to the context:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将声明在 `AppDelegate.m` 中每个对象的代码，例如以下创建 `NSManagedObjectContext` 实例并返回已存在实例的代码行。这很重要，因为你希望只有一个上下文实例存在，以避免对上下文的冲突访问：
- en: '[PRE1]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This method will create the `NSManagedObjectModel` instance and then return
    the instance, but it will return an existing `NSManagedObjectModel` instance if
    it already exists:'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法将创建 `NSManagedObjectModel` 实例并返回该实例，但如果已经存在，则返回现有的 `NSManagedObjectModel`
    实例：
- en: '[PRE2]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This method will create an instance of the `NSPersistentStoreCoordinator` class
    if it does not exist, and also return an existing instance if it already exists.
    We will also make some logs appear in our Xcode console using the `NSLog` method
    to tell the user if the instance of `NSPersistentStoreCoordinator` is nil and
    use the `NSSQLiteStoreType` keyword to signify to the system that we intend to
    store the data in a SQLite database:'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法将在不存在时创建 `NSPersistentStoreCoordinator` 类的实例，并在存在时返回现有实例。我们还将使用 `NSLog` 方法在我们的
    Xcode 控制台中添加一些日志，以告知用户 `NSPersistentStoreCoordinator` 的实例是否为 nil，并使用 `NSSQLiteStoreType`
    关键字向系统表明我们打算将数据存储在 SQLite 数据库中：
- en: '[PRE3]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following lines of code will return a URL of the location to store your
    data on the device:'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下代码行将返回设备上存储数据的URL：
- en: '[PRE4]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, what we have done is to check whether the objects such as `_managedObjectModel`
    are nil and if they are not nil, then we return the object, or we will create
    the object and then return it. This concept is exactly the same concept of lazy
    loading, which we covered in [Chapter 5](part0044_split_000.html#page "Chapter 5. Managing
    Your Application Data"), *Managing Your Application Data*. We apply the same methodology
    to `managedObjectContext` and `persistentStoreCoordinator`. We did this so that
    we know that we only have one instance of `managedObjectModel`, `managedObjectContext`,
    and `persistentStoreCoordinator` created and present at any given time. This is
    to help us avoid having multiple copies of these objects, which will increase
    the chance of a memory leak.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，我们所做的是检查像 `_managedObjectModel` 这样的对象是否为 nil，如果不是 nil，则返回该对象，或者我们会创建该对象然后返回它。这个概念与我们在[第
    5 章](part0044_split_000.html#page "第 5 章. 管理你的应用程序数据")中讨论的懒加载概念完全相同，即*管理你的应用程序数据*。我们将同样的方法应用到
    `managedObjectContext` 和 `persistentStoreCoordinator` 上。我们这样做是为了确保在任何给定时间我们只有一个
    `managedObjectModel`、`managedObjectContext` 和 `persistentStoreCoordinator` 的实例被创建和存在。这是为了帮助我们避免有多个这些对象的副本，这将增加内存泄漏的机会。
- en: Note
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that memory management is still a real issue in the post-ARC world. So
    what we have done is follow best practices that will help us avoid memory leaks.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 ARC 之后的世界上，内存管理仍然是一个真正的问题。所以我们所做的是遵循最佳实践，这将帮助我们避免内存泄漏。
- en: In the example code that was shown, we adopted a structure so that only one
    instance of `managedObjectModel`, `managedObjectContext`, and `persistentStoreCoordinator`
    is available at any given time.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前展示的示例代码中，我们采用了一种结构，以确保在任何给定时间只有一个 `managedObjectModel`、`managedObjectContext`
    和 `persistentStoreCoordinator` 的实例可用。
- en: Next, let's move on to showing you how to store data in our persistent store.
    As you can see in the preceding screenshot, we have fields such as `name`, `age`,
    `address`, `email`, and `phone_number`, which correspond to the appropriate fields
    in our `Customer` entity.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们继续展示如何在我们的持久存储中存储数据。如前一个截图所示，我们有 `name`、`age`、`address`、`email` 和 `phone_number`
    等字段，它们对应于我们的 `Customer` 实体中的相应字段。
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The example code in this chapter will be provided in its entirety on the Packt
    Publishing website, and you can download it and run the Xcode project directly.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例代码将在 Packt Publishing 网站上提供完整内容，你可以下载它并直接运行 Xcode 项目。
- en: Saving data into the persistent store
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据保存到持久存储
- en: 'To do a successful save using Core Data, you require:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功使用 Core Data 进行保存，你需要：
- en: '`NSManagedObject`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NSManagedObject`'
- en: '`NSManagedObjectContext`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NSManagedObjectContext`'
- en: '`NSPersistentStoreCoordinator`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NSPersistentStoreCoordinator`'
- en: '`NSManagedObjectModel`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NSManagedObjectModel`'
- en: 'So, in our screen that saves these variables into our `Customer` entity, the
    following code fragment does all the magic for the `(IBAction)save:(id)sender`
    method. This will enable us to save our data from a new customer or update an
    existing customer''s information:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的屏幕中，这些变量被保存到我们的 `Customer` 实体中，以下代码片段为 `(IBAction)save:(id)sender` 方法执行所有魔法。这将使我们能够从新客户或更新现有客户的信息中保存数据：
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'So, the steps we need to remember are:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要记住的步骤是：
- en: Get the instance of `NSManagedObjectContext`, which sets `persistentStoreCoordinator`
    using `managedObjectModel`.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取`NSManagedObjectContext`的实例，它使用`managedObjectModel`设置`persistentStoreCoordinator`。
- en: Create an instance of `NSManagedObject` and set the values you want to save.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`NSManagedObject`的实例，并设置你想要保存的值。
- en: Use an object of the `NSManagedObjectContext` type and call the `save` method
    since the context will represent all changes that you have done and you need to
    call the `save` method in order to save the changes from the context to disk.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `NSManagedObjectContext` 类型的对象并调用 `save` 方法，因为上下文将代表你所做的所有更改，你需要调用 `save`
    方法以将上下文中的更改保存到磁盘。
- en: Deleting data from the persistent store
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从持久存储中删除数据
- en: 'We will now move on to delete a record from the persistent store. In our table
    view, we will load the customers using an instance of `NSFetchRequest`, as shown:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将继续学习如何从持久存储中删除记录。在我们的表格视图中，我们将使用 `NSFetchRequest` 的实例来加载客户，如下所示：
- en: '[PRE6]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, we will declare `customers` as a mutable array to store our records from
    the `Customer` entity:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`customers`声明为一个可变数组，用于存储来自`Customer`实体的记录：
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To delete a record, we just need to get our `Customer` record, which is an
    instance of `NSManagedObject` from the `customers` array, then use an instance
    of `managedObjectContext` to call the `deleteObject` method on it, and finally,
    call the `save` method to save our updated records:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除一条记录，我们只需从`customers`数组中获取我们的`Customer`记录，这是一个`NSManagedObject`的实例，然后使用`managedObjectContext`的实例调用其上的`deleteObject`方法，最后调用`save`方法来保存我们的更新记录：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Updating data
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新数据
- en: 'Finally, to update a record, it is much simpler than you think, thanks to the
    abstraction layer. To update data, we just assign the values to our `customer`
    object in the `(IBAction)save:(id)sender` method, which you saw earlier:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要更新一条记录，比你想象的要简单得多，多亏了抽象层。要更新数据，我们只需在`(IBAction)save:(id)sender`方法中将值分配给我们的`customer`对象，这个方法你之前已经看到了：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We will add the following code after we set the values of our `customer` object:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们设置`customer`对象的值之后，我们将添加以下代码：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, `customer` is an instance of `NSManagedObject`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`customer`是一个`NSManagedObject`的实例：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The code for updating data is to be added after the following code fragment,
    inside the – `(IBAction)save:(id)sender` method:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 更新数据的代码需要添加到以下代码片段之后，在`-(IBAction)save:(id)sender`方法内部：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Summary
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: So, to wrap it all up, Core Data is not something that is overly complex and
    the code to use Core Data is pretty straightforward as we have seen in our code
    examples shown earlier. The Core Data framework is a relatively easy framework
    to use to handle data storage abstraction without worrying about different data
    storage formats.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结一下，Core Data 并不是特别复杂的东西，使用 Core Data 的代码如我们之前在代码示例中所见，相当直接。Core Data 框架是一个相对容易使用的框架，用于处理数据存储抽象，无需担心不同的数据存储格式。
- en: The concepts that you have to know are the Core Data classes such as `NSManagedObject`,
    `NSManagedObjectContext`, `NSPersistentStoreCoordinator`, and so on and the related
    methods such as `save` and `deleteObject`. With these simple lines of code, you
    can leverage the power of the Core Data framework to do data persistence on a
    high-level abstraction without concerning yourself with the low-level data format
    specifications.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须了解的概念是 Core Data 类，如 `NSManagedObject`、`NSManagedObjectContext`、`NSPersistentStoreCoordinator`
    等，以及相关的 `save` 和 `deleteObject` 等方法。通过这些简单的代码行，你可以利用 Core Data 框架在高级抽象层面上进行数据持久化，无需关心低级数据格式规范。
- en: In the next chapter, we will be introduced to key-value programming and how
    it can be used to allow us to be notified of state changes. So, I hope you enjoyed
    this chapter on Core Data!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍键值编程以及它是如何被用来允许我们通知状态变化的。所以，我希望你喜欢我们关于 Core Data 的这一章！
