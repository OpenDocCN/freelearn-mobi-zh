- en: '*Chapter 1*: Getting Started with Kotlin'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 1 章*：Kotlin 入门'
- en: The bulk of this chapter will be dedicated to basic Kotlin syntax. It is important
    to be comfortable with a language before we start implementing any design patterns
    in it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的大部分内容将致力于基本 Kotlin 语法。在我们开始实现任何设计模式之前，对语言感到舒适是很重要的。
- en: We'll also briefly discuss what problems design patterns solve and why you should
    use them in Kotlin. This will be helpful to those who are less familiar with the
    concept of design patterns. But even for experienced engineers, it may provide
    an interesting perspective.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将简要讨论设计模式解决的问题以及为什么应该在 Kotlin 中使用它们。这对那些对设计模式概念不太熟悉的人会有所帮助。但对于经验丰富的工程师来说，这也可能提供一个有趣的视角。
- en: This chapter doesn't aim to cover the entire language vocabulary but to get
    you familiar with some basic concepts and idioms. The following chapters will
    expose you to even more language features as they become relevant to the design
    patterns that we'll discuss.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标不是涵盖整个语言词汇，而是让你熟悉一些基本概念和习惯用语。接下来的章节将随着我们讨论的设计模式的相关性，让你接触到更多的语言特性。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Basic language syntax and features
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本语言语法和特性
- en: Understanding Kotlin code structure
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Kotlin 代码结构
- en: Type system and `null` safety
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型系统和 `null` 安全性
- en: Reviewing Kotlin data structures
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复习 Kotlin 数据结构
- en: Control flow
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制流程
- en: Working with text and loops
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理文本和循环
- en: Classes and inheritance
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类和继承
- en: Extension functions
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展函数
- en: Introduction to design patterns
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计模式简介
- en: By the end of this chapter, you'll have a knowledge of Kotlin's basics, which
    will be the foundation for the following chapters.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将掌握 Kotlin 的基础知识，这将是后续章节的基础。
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow the instructions in this chapter, you''ll need the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章中的说明，你需要以下内容：
- en: IntelliJ IDEA Community Edition ([https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/))
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IntelliJ IDEA Community Edition ([https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/))
- en: OpenJDK 11 or higher ([https://openjdk.java.net/install/](https://openjdk.java.net/install/))
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenJDK 11 或更高版本 ([https://openjdk.java.net/install/](https://openjdk.java.net/install/))
- en: The code files for this chapter are available at [https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter01](https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter01).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可在 [https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter01](https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter01)
    找到。
- en: Basic language syntax and features
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本语言语法和特性
- en: Whether you come from **Java**, **C#**, **Scala**, or any other statically typed
    programming language, you'll find Kotlin syntax quite familiar. This is not by
    coincidence but to make the transition to this new language as smooth as possible
    for those with previous experience in other languages. Besides that familiarity,
    Kotlin brings a vast amount of features, such as better type safety. As we move
    ahead, you'll notice that all of them are attempting to solve real-world problems.
    That pragmatic approach is remarkably consistent across the language. For example,
    one of the strongest benefits of Kotlin is complete Java interoperability. You
    can have Java and Kotlin classes alongside each other and freely use any library
    that is available in Java for a Kotlin project.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是来自 **Java**、**C#**、**Scala** 或任何其他静态类型编程语言，你都会发现 Kotlin 语法非常熟悉。这不是巧合，而是为了让那些在其他语言中有经验的人尽可能顺利地过渡到这门新语言。除了这种熟悉感之外，Kotlin
    还带来了大量的特性，如更好的类型安全性。随着我们继续前进，你会发现它们都在试图解决现实世界的问题。这种实用主义方法在整个语言中都非常一致。例如，Kotlin
    最强的优势之一是完整的 Java 互操作性。你可以在 Java 和 Kotlin 类旁边使用，并自由地使用 Kotlin 项目中可用的任何 Java 库。
- en: 'To summarize, the goals of the language are as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，该语言的目标如下：
- en: '**Pragmatic**: Makes things we do often easy to achieve'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实用主义**：使经常做的事情变得容易实现'
- en: '**Readable**: Keeps a balance between conciseness and clarity on what the code
    does'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可读性**：在简洁性和代码所做之事的清晰性之间保持平衡'
- en: '**Easy to reuse**: Supports adapting code to different situations'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于重用**：支持将代码适应不同的情况'
- en: '**Safe**: Makes it hard to write code that crashes'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全**：使编写崩溃的代码变得困难'
- en: '**Interoperable**: Allows the use of existing libraries and frameworks'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**互操作性**：允许使用现有的库和框架'
- en: This chapter will discuss how these goals are achieved.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论如何实现这些目标。
- en: Multi-paradigm language
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多范式语言
- en: Some of the major paradigms in programming languages are procedural, object-oriented,
    and functional paradigms.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言中的主要范式包括过程式、面向对象和函数式范式。
- en: Being pragmatic, Kotlin allows for any of these paradigms. It has classes and
    inheritance, coming from the object-oriented approach. It has higher-order functions
    from functional programming. You don't have to wrap everything in classes if you
    don't want to, though. Kotlin allows you to structure your entire code as just
    a set of procedures and structs if you need to. You will see how all these approaches
    come together, as different examples will combine different paradigms to solve
    the problems discussed.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种实用主义，Kotlin允许使用这些范式中的任何一个。它有类和继承，来自面向对象的方法。它有来自函数式编程的高阶函数。不过，如果你不想的话，你不需要将所有内容都封装在类中。如果你需要，Kotlin允许你将整个代码结构作为一组过程和结构。你将看到所有这些方法是如何结合在一起的，因为不同的示例将结合不同的范式来解决讨论中的问题。
- en: Instead of covering all aspects of a topic from start to finish, we will be
    building the knowledge as we go.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会从头到尾全面覆盖一个主题的所有方面，而是会在前进的过程中构建知识。
- en: Understanding Kotlin code structure
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Kotlin代码结构
- en: The first thing you'll need to do when you start programming in Kotlin is to
    create a new file. Kotlin's file extension is usually `.kt`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始用Kotlin编程时，你需要做的第一件事是创建一个新文件。Kotlin的文件扩展名通常是`.kt`。
- en: Unlike Java, there's no strong relationship between the filename and class name.
    You can put as many public classes in your file as you want, as long as the classes
    are related to one another and your file doesn't grow too long to read.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 与Java不同，文件名和类名之间没有强关联关系。你可以根据需要将尽可能多的公共类放入你的文件中，只要这些类彼此相关，并且你的文件不会因为过长而难以阅读。
- en: Naming conventions
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名约定
- en: As a convention, if your file contains a single class, name your file the same
    as your class.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，如果你的文件中只有一个类，那么你应该将文件名与类名相同。
- en: 'If your file contains more than one class, then the filename should describe
    the common purpose of those classes. Use Camel case when naming your files, as
    per the Kotlin coding conventions: [https://kotlinlang.org/docs/coding-conventions.html](https://kotlinlang.org/docs/coding-conventions.html).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的文件包含多个类，那么文件名应该描述这些类的共同目的。根据Kotlin编码约定，在命名文件时使用驼峰式命名法：[https://kotlinlang.org/docs/coding-conventions.html](https://kotlinlang.org/docs/coding-conventions.html)。
- en: The main file in your Kotlin project should usually be named `Main.kt`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你的Kotlin项目中的主文件通常应该命名为`Main.kt`。
- en: Packages
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包
- en: A **package** is a collection of files and classes that all share a similar
    purpose or domain. Packages are a convenient way to have all your classes and
    functions under the same namespace, and often in the same folder. That's the reason
    Kotlin, similar to many other languages, uses the notion of a package.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**包**是一组文件和类，它们具有相似的目的或领域。包是方便地将所有类和函数放在同一个命名空间中，通常在同一个文件夹中的方法。这就是为什么Kotlin，类似于许多其他语言，使用包的概念。'
- en: 'The package that the file belongs to is declared using a `package` keyword:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 文件所属的包使用`package`关键字声明：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Similar to placing classes in files, you can put any package in any directory
    or file, but if you're mixing Java and Kotlin, Kotlin files should follow Java
    package rules, as given at [https://docs.oracle.com/javase/tutorial/java/package/namingpkgs.html](https://docs.oracle.com/javase/tutorial/java/package/namingpkgs.html).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于将类放入文件中，你可以将任何包放在任何目录或文件中，但如果你在Java和Kotlin之间混合使用，Kotlin文件应遵循Java包规则，如[https://docs.oracle.com/javase/tutorial/java/package/namingpkgs.html](https://docs.oracle.com/javase/tutorial/java/package/namingpkgs.html)中所述。
- en: In purely Kotlin projects, common package prefixes can be omitted from the folder
    structure. For example, if all your projects are under the `me.soshin` package,
    and part of your application deals with mortgages, you can place your files directly
    in the `/mortgages` folder and not in the `/me/soshin/mortgages` folder like Java
    requires.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯Kotlin项目中，可以省略文件夹结构中的常见包前缀。例如，如果你的所有项目都在`me.soshin`包下，并且你的应用程序的一部分处理抵押贷款，你可以直接将文件放在`/mortgages`文件夹中，而不是像Java那样放在`/me/soshin/mortgages`文件夹中。
- en: There is no need to declare a package for your `Main.kt` file.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你的`Main.kt`文件，没有必要声明包。
- en: Comments
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释
- en: Going forward, we will be documenting parts of the code using `//` for a single-line
    comment and `/* */` for multiline comments.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的工作中，我们将使用`//`来注释单行注释，使用`/* */`来注释多行注释。
- en: Comments are a useful way to provide more context both to other developers and
    to your future self. Now, let's write our first Kotlin program and discuss how
    Kotlin's guiding principles are applied to it.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注释是向其他开发者和未来的自己提供更多上下文的有用方式。现在，让我们编写我们的第一个 Kotlin 程序，并讨论 Kotlin 的指导原则是如何应用于其中的。
- en: Hello Kotlin
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Hello Kotlin
- en: There's no book dedicated to a programming language that can avoid the ubiquitous
    *Hello World* example. We're certainly not going to challenge that honored tradition.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一本关于编程语言的书籍可以避免无处不在的 *Hello World* 示例。我们当然不会挑战这一光荣传统。
- en: 'To begin learning how Kotlin works, let''s put the following code in our `Main.kt`
    file and run it:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始学习 Kotlin 的工作原理，让我们将以下代码放入我们的 `Main.kt` 文件中并运行它：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When your run this example, for example by pressing the **Run** button in your
    IntelliJ IDEA, it simply outputs the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个示例时，例如通过在 IntelliJ IDEA 中按下 **运行** 按钮，它简单地输出以下内容：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There are some interesting attributes in that piece of code in comparison to
    the following Java code that does exactly the same:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 与下面这段执行相同功能的 Java 代码相比，这段代码中有一些有趣的属性：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Let's focus on those attributes in the next sections.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中关注这些属性。
- en: No wrapping class
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 没有包装类
- en: In Java, C#, Scala, and many other languages, it's necessary to wrap every function
    in a class for it to become executable.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java、C#、Scala 以及许多其他语言中，为了使函数可执行，必须将其包装在类中。
- en: Kotlin, though, has the concept of **package-level functions**. If your function
    doesn't need to access properties of a class, you don't need to wrap it in a class.
    It's as simple as that.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Kotlin 有 **包级别函数** 的概念。如果你的函数不需要访问类的属性，你不需要将其包装在类中。就这么简单。
- en: We'll discuss package-level functions in more detail in the following chapters.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中更详细地讨论包级别函数。
- en: 'Important Note:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: From here on, we'll use ellipsis notation (*three dots*) to indicate that some
    parts of the code were omitted to focus on the important bits. You can always
    find the full code examples at the GitHub link for this chapter.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们将使用省略号表示法（*三个点*）来表示代码中省略了一些部分，以便关注重要部分。你可以在本章的 GitHub 链接中找到完整的代码示例。
- en: No arguments
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 没有参数
- en: 'Arguments, supplied as an array of strings, are a way to configure your command-line
    application. In Java, you cannot have a runnable `main()` function that doesn''t
    take this array of arguments:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 作为字符串数组提供的参数是配置命令行应用程序的一种方式。在 Java 中，你不能有一个不接受此参数数组的可运行的 `main()` 函数：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: But in Kotlin, those are entirely optional.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 但在 Kotlin 中，这些是完全可以选择的。
- en: No static modifier
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 没有静态修饰符
- en: Some languages use the `static` keyword to indicate that a function in a class
    can be executed without the need to instantiate the class. The `main()` function
    is one such example.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言使用 `static` 关键字来表示类中的函数可以在不实例化类的情况下执行。`main()` 函数就是一个这样的例子。
- en: In Kotlin, there's no such limitation. If your function doesn't have any state,
    you can place it outside of a class, and there is no `static` keyword in Kotlin.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，没有这样的限制。如果你的函数没有任何状态，你可以将其放置在类之外，Kotlin 中也没有 `static` 关键字。
- en: A less verbose print function
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个更简洁的打印函数
- en: Instead of the verbose `System.out.println` method that outputs a string to
    the standard output, Kotlin provides us with an alias called `println()` that
    does exactly the same.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 与输出字符串到标准输出的冗长 `System.out.println` 方法相比，Kotlin 提供了一个名为 `println()` 的别名，它做的是完全相同的事情。
- en: No semicolons
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 没有分号
- en: 'In Java, and many other languages, every statement or expression must be terminated
    with a semicolon, as shown in the following example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 以及许多其他语言中，每个语句或表达式都必须以分号结束，如下面的示例所示：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Kotlin is a pragmatic language. So, instead, it infers during compilation where
    it should put the semicolons:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 是一种实用主义语言。因此，相反，它在编译期间推断出应该放置分号的位置：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Most of the time, you won't need to put semicolons in your code. They're considered
    optional.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，你不需要在代码中放置分号。它们被认为是可选的。
- en: This is an excellent example of how pragmatic and concise Kotlin is. It sheds
    lots of fluff and lets you focus on what's important.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的例子，说明了 Kotlin 如何既实用又简洁。它去掉了许多冗余，让你专注于重要的事情。
- en: 'Important Note:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: 'You don''t have to write your code in a file for simple snippets. You can also
    play with the language online: try [https://play.kotlinlang.org/](https://play.kotlinlang.org/)
    or use a REPL and an interactive shell after installing Kotlin and running `kotlinc`.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的代码片段，你不必在文件中编写代码。你还可以在线使用该语言：尝试 [https://play.kotlinlang.org/](https://play.kotlinlang.org/)
    或者在安装 Kotlin 并运行 `kotlinc` 后使用 REPL 和交互式 shell。
- en: Understanding types
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解类型
- en: Previously, we said that Kotlin is a type-safe language. Let's examine the Kotlin
    type system and compare it to what Java provides.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们提到 Kotlin 是一种类型安全的语言。现在让我们来检查 Kotlin 的类型系统，并将其与 Java 提供的类型进行比较。
- en: 'Important Note:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: The Java examples are for familiarity and not to prove that Kotlin is superior
    to Java in any way.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Java 示例是为了熟悉，而不是为了证明 Kotlin 在任何方面优于 Java。
- en: Basic types
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本类型
- en: Some languages make a distinction between primitive types and objects. Taking
    Java as an example, there is the `int` type and `Integer` – the former being more
    memory-efficient and the latter more expressive by supporting a lack of value
    and having methods.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言在原始类型和对象之间做出区分。以 Java 为例，有 `int` 类型和 `Integer` ——前者更节省内存，后者通过支持缺少值和具有方法而更具表现力。
- en: There is no such distinction in Kotlin. From a developer's perspective, all
    the types are the same.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中没有这样的区别。从开发者的角度来看，所有类型都是相同的。
- en: But it doesn't mean that Kotlin is less efficient than Java in that aspect.
    The Kotlin compiler optimizes types. So, you don't need to worry about it much.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不意味着 Kotlin 在这个方面比 Java 效率低。Kotlin 编译器优化类型。所以，你不必过于担心它。
- en: Most of the Kotlin types are named similarly to Java, the exceptions being Java's
    `Integer` being called `Int` and Java's void being called `Unit`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Kotlin 类型与 Java 类似命名，例外的是 Java 的 `Integer` 被称为 `Int`，Java 的 void 被称为 `Unit`。
- en: 'It doesn''t make much sense to list all the types, but here are some examples:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 列出所有类型没有太多意义，但这里有一些例子：
- en: '![Table 1.1 - Kotlin types'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![表 1.1 - Kotlin 类型'
- en: '](img/B17816_01_Table01.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17816_01_Table01.jpg)'
- en: Table 1.1 - Kotlin types
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1.1 - Kotlin 类型
- en: Type inference
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型推断
- en: 'Let''s declare our first Kotlin variable by extracting the string from our
    `Hello Kotlin` example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过从我们的 `Hello Kotlin` 示例中提取字符串来声明我们的第一个 Kotlin 变量：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that nowhere in our code is it stated that `greeting` is of the `String`
    type. Instead, the compiler decides what type of variable should be used. Unlike
    interpreted languages, such as JavaScript, Python, or Ruby, the type of variable
    is defined only once.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在我们的代码中并没有声明 `greeting` 是 `String` 类型。相反，编译器决定应该使用哪种类型的变量。与 JavaScript、Python
    或 Ruby 等解释型语言不同，变量的类型只定义一次。
- en: 'In Kotlin, this will produce an error:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，这将产生一个错误：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you''d like to define the type of variable explicitly, you may use the following
    notation:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望明确定义变量的类型，可以使用以下符号：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Values
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 值
- en: 'In Java, variables can be declared `final`. Final variables can be assigned
    only once and their reference is effectively immutable:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，变量可以被声明为 `final`。final 变量只能赋值一次，并且它们的引用实际上是不可变的：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Kotlin urges us to use immutable data as much as possible. Immutable variables
    in Kotlin are called `val` keyword:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 强调我们应该尽可能使用不可变数据。Kotlin 中的不可变变量称为 `val` 关键字：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Values are preferable over variables. Immutable data is easier to reason about,
    especially when writing concurrent code. We'll touch more on that in [*Chapter
    5*](B17816_05_ePub.xhtml#_idTextAnchor144), *Introducing Functional Programming*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 值比变量更可取。不可变数据更容易推理，尤其是在编写并发代码时。我们将在 [*第 5 章*](B17816_05_ePub.xhtml#_idTextAnchor144)
    中进一步探讨这一点，*介绍函数式编程*。
- en: Comparison and equality
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较和相等
- en: We were taught very early in Java that comparing objects using `==` won't produce
    the expected results, since it tests for reference equality – whether two pointers
    are the same, and not whether two objects are equal.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Java 中很早就被教导，使用 `==` 比较对象不会产生预期的结果，因为它是测试引用相等性——两个指针是否相同，而不是两个对象是否相等。
- en: Instead, in Java, we use `equals()` for objects and `==` to compare only primitives,
    which may cause some confusion.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，在 Java 中，我们使用 `equals()` 来比较对象，而使用 `==` 仅比较原始数据类型，这可能会导致一些混淆。
- en: 'JVM does integer caching and string interning to prevent that in some basic
    cases, so for the sake of the example, we''ll use a large integer:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: JVM 对整数进行缓存和字符串池化，以防止在某些基本情况下发生这种情况，因此为了示例，我们将使用一个大的整数：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This behavior is far from intuitive. Instead, Kotlin translates `==` to `equals()`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为远非直观。相反，Kotlin 将 `==` 转换为 `equals()`：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If you do want to check for reference equality, use `===`. This won''t work
    for some of the basic types, though:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实想检查引用等价性，请使用`===`。但这对于一些基本类型是不适用的：
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We'll discuss referential equality more when we learn how to instantiate classes.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们学习如何实例化类时，我们将更详细地讨论引用等价性。
- en: Declaring functions
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明函数
- en: In Java, every method must be wrapped by a class or interface, even if it doesn't
    rely on any information from it. You're probably familiar with many `Util` classes
    in Java that only have static methods, and their only purpose is to satisfy the
    language requirements and bundle those methods together.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，每个方法都必须被一个类或接口包裹，即使它不依赖于任何信息。你可能熟悉Java中许多只包含静态方法的`Util`类，它们的唯一目的是满足语言要求并将这些方法捆绑在一起。
- en: 'We already mentioned earlier that in Kotlin, a function can be declared outside
    of a class. We''ve seen it with the `main()` function. The keyword to declare
    a function is `fun`. The argument type comes after the argument name, and not
    before:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经提到，在Kotlin中，函数可以声明在类之外。我们已经通过`main()`函数看到了这一点。声明函数的关键字是`fun`。参数类型位于参数名称之后，而不是之前：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If you need to return a result, its type will come after the function declaration:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要返回一个结果，其类型将位于函数声明之后：
- en: '[PRE34]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You can try this out yourself:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以亲自尝试一下：
- en: '[PRE37]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If the function doesn't return anything, the return type can be omitted completely.
    There's no need to declare it as `void`, or its Kotlin counterpart, `Unit`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数不返回任何内容，可以完全省略返回类型。无需将其声明为`void`，或其Kotlin对应类型`Unit`。
- en: 'When a function is very short and consists of just a single expression, such
    as our `getGreeting()` function, we can remove the return type and the curly brackets,
    and use a shorter notation:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数非常短，仅由一个表达式组成，例如我们的`getGreeting()`函数，我们可以省略返回类型和大括号，并使用更简短的表示法：
- en: '[PRE40]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, the Kotlin compiler will infer that we're returning a `String` type.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Kotlin编译器会推断出我们返回的是`String`类型。
- en: Unlike some scripting languages, the order in which functions are declared is
    not important. Your `main` function will have access to all the other functions
    in its scope, even if those are declared after it in the code file.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 与某些脚本语言不同，函数声明的顺序并不重要。你的`main`函数将能够访问其作用域内的所有其他函数，即使这些函数在代码文件中位于其后。
- en: There are many other topics regarding function declarations, such as named arguments,
    default parameters, and variable numbers of arguments. We'll introduce them in
    the following chapters with relevant examples.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 关于函数声明还有很多其他主题，例如命名参数、默认参数和可变数量的参数。我们将在接下来的章节中通过相关示例介绍它们。
- en: 'Important Note:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: Many examples in this book assume that the code we provide is wrapped in the
    `main` function. If you don't see a signature of the function, it probably should
    be part of the `main` function. As an alternative, you can also run the examples
    in an IntelliJ scratch file.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的许多示例都假设我们提供的代码被包裹在`main`函数中。如果你没有看到函数的签名，它可能应该是`main`函数的一部分。作为替代，你还可以在IntelliJ的临时文件中运行这些示例。
- en: Null safety
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空安全
- en: 'Probably the most notorious exception in the Java world is `NullPointerException`.
    The reason behind this exception is that every object in Java can be `null`. The
    code here shows us why this is a problem:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java世界中，最臭名昭著的异常可能是`NullPointerException`。这个异常背后的原因是Java中的每个对象都可以是`null`。这里的代码展示了为什么这是一个问题：
- en: '[PRE41]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'It''s not like Java didn''t attempt to solve that problem, though. Since `Optional`
    construct that represents a value that may not be there:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Java没有尝试解决这个问题，但`Optional`构造函数表示可能不存在值的值：
- en: '[PRE44]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'But it doesn''t solve our problem. If our function receives `Optional` as an
    argument, we can still pass it a `null` value and crash the program at runtime:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并没有解决我们的问题。如果我们的函数接收`Optional`作为参数，我们仍然可以传递一个`null`值，并在运行时崩溃程序：
- en: '[PRE48]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Kotlin checks for nulls during compile time:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin在编译时检查`null`：
- en: '[PRE55]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Let''s take a look at the `printLength()` function written in Kotlin:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看用Kotlin编写的`printLength()`函数：
- en: '[PRE56]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Calling this function with `null` won''t compile at all:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`null`调用此函数根本无法编译：
- en: '[PRE59]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'If you specifically want your type to be able to receive nulls, you''ll need
    to mark it as nullable using the question mark:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望你的类型能够接收`null`值，你需要使用问号将其标记为可空：
- en: '[PRE61]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: There are multiple techniques in Kotlin for dealing with nulls, such as smart
    casts, the Elvis operator, and so on. We'll discuss alternatives to nulls in [*Chapter
    4*](B17816_04_ePub.xhtml#_idTextAnchor115), *Getting Familiar with Behavioral
    Patterns*. Let's now move on to data structures in Kotlin.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin中有多种处理空值的技术，例如智能转换、Elvis运算符等。我们将在[*第4章*](B17816_04_ePub.xhtml#_idTextAnchor115)“熟悉行为模式”中讨论空值的替代方案。现在让我们继续讨论Kotlin中的数据结构。
- en: Reviewing Kotlin data structures
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾Kotlin数据结构
- en: 'There are three important groups of data structures we should get familiar
    with in Kotlin: lists, sets, and maps. We''ll cover each briefly, then discuss
    some other topics related to data structures, such as mutability and tuples.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，我们应该熟悉三个重要的数据结构组：列表、集合和映射。我们将简要介绍每个，然后讨论一些与数据结构相关的话题，例如可变性和元组。
- en: Lists
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表
- en: 'A `listOf()` function:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`listOf()`函数：
- en: '[PRE62]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Note that we didn't specify the type of the list. The reason is that the type
    inference can also be used when constructing collections in Kotlin, the same as
    when initializing variables.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们没有指定列表的类型。原因是Kotlin在构建集合时也可以使用类型推断，就像在初始化变量时一样。
- en: 'If you want to provide the type of the list, you similarly do that for defining
    arguments for a function:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想提供列表的类型，你可以在定义函数参数时这样做：
- en: '[PRE63]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'To access an element in the list at a particular index, we use square brackets:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问列表中特定索引的元素，我们使用方括号：
- en: '[PRE64]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The preceding code will output this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码将输出以下内容：
- en: '[PRE65]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Sets
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合
- en: A **set** represents a collection of unique elements. Looking for the presence
    of an element in a set is much faster than looking it up in a list. But, unlike
    lists, sets don't provide indexes access.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**集合**表示一组唯一元素。在集合中查找元素的存在比在列表中查找要快得多。但与列表不同，集合不提供索引访问。
- en: 'Let''s create a set of football World Cup champions until after 1994:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一组直到1994年之后的足球世界杯冠军：
- en: '[PRE66]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'You can see that each country exists in a set exactly once. To check whether
    an element is in a `Set` collection, you can use the `in` function:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到每个国家在集合中恰好存在一次。要检查元素是否在`Set`集合中，你可以使用`in`函数：
- en: '[PRE68]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This gives us the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们以下结果：
- en: '[PRE70]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Note that although sets, in general, do not guarantee the order of elements,
    the current implementation of a `setOf()` function returns `LinkedHashSet`, which
    preserves insertion order – `France` appears first in the output, since it was
    the first country in the input.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管集合通常不保证元素的顺序，但`setOf()`函数的当前实现返回`LinkedHashSet`，它保留了插入顺序——“法国”在输出中首先出现，因为它是在输入中第一个国家。
- en: Maps
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射
- en: A `to`. In fact, this is not a real keyword but a special function. We'll learn
    about it more in [*Chapter 5*](B17816_05_ePub.xhtml#_idTextAnchor144), *Introducing
    Functional Programming*.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`to`。实际上，这并不是一个真正的关键字，而是一个特殊函数。我们将在[*第5章*](B17816_05_ePub.xhtml#_idTextAnchor144)“介绍函数式编程”中了解更多。
- en: 'In the meantime, let''s create a map of some of the Batman movies and the actors
    that played Bruce Wayne in them:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，让我们创建一个包含一些蝙蝠侠电影及其扮演布鲁斯·韦恩的演员的映射：
- en: '[PRE72]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'This prints the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印以下内容：
- en: '[PRE78]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'To access a value by its key, we use square brackets and provide the key:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过键访问值，我们使用方括号并提供键：
- en: '[PRE81]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The preceding code will output this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码将输出以下内容：
- en: '[PRE82]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Those data structures also support checking that an element doesn''t exist:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据结构也支持检查元素是否存在：
- en: '[PRE83]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'We get the following output:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '[PRE84]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Mutability
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可变性
- en: All of the data structures we have discussed so far are immutable or, more correctly,
    read-only.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止讨论的所有数据结构都是不可变的，或者更准确地说，是只读的。
- en: 'There are no methods to add new elements to a list we create with the `listOf()`
    function, and we also cannot replace any element:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`listOf()`函数创建的列表没有添加新元素的方法，我们也不能替换任何元素：
- en: '[PRE85]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Immutable data structures are great for writing concurrent code. But, sometimes,
    we still need a collection we can modify. In order to do that, we can use the
    mutable counterparts of the collection functions:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变数据结构非常适合编写并发代码。但有时，我们仍然需要一个可以修改的集合。为了做到这一点，我们可以使用集合函数的可变版本：
- en: '[PRE86]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Editable collection types have functions such as `add()` that allow us to modify
    or, in other words, mutate them.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 可编辑的集合类型具有如`add()`这样的函数，允许我们修改它们，换句话说，对它们进行变异。
- en: Alternative implementations for collections
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合的替代实现
- en: If you have worked with JVM before, you may know that there are other implementations
    of sets and maps. For example, `TreeMap` stores the keys in a sorted order.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前与JVM合作过，你可能知道还有其他集合和映射的实现。例如，`TreeMap` 按顺序存储键。
- en: 'Here''s how you can instantiate them in Kotlin:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你在Kotlin中实例化它们的方法：
- en: '[PRE88]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'We will get the following output:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '[PRE98]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Note that the names of the *Three Little Pigs* are ordered alphabetically.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，*三只小猪* 的名字是按字母顺序排列的。
- en: Arrays
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: There is one other data structure we should cover in this section – `String[]`,
    while a list of strings is declared as `List<String>`. An element in a Java array
    is accessed using square brackets, while an element in a list is accessed using
    the `get()` method.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们还应介绍另一个数据结构 – `String[]`，而字符串列表声明为 `List<String>`。Java数组中的元素使用方括号访问，而列表中的元素使用
    `get()` 方法访问。
- en: To get the number of elements in an array in Java, we use the `length()` method,
    and to do the same with a collection, we use the `size()` method. This is part
    of Java's legacy and its attempts to resemble C++.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Java中获取数组中的元素数量，我们使用 `length()` 方法，要获取集合中的相同操作，我们使用 `size()` 方法。这是Java遗产的一部分，以及它试图与C++相似的努力。
- en: 'In Kotlin, array syntax is consistent with other types of collections. An array
    of strings is declared as `Array<String>`:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，数组语法与其他类型的集合保持一致。字符串数组声明为 `Array<String>`：
- en: '[PRE99]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: This is the first time we see angle brackets in Kotlin code. Similar to Java
    or TypeScript, the type between them is called **type argument**. It indicates
    that this array contains strings. We'll discuss this topic in detail in [*Chapter
    4*](B17816_04_ePub.xhtml#_idTextAnchor115), *Getting Familiar with Behavioral
    Patterns*, while covering generics.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一次在Kotlin代码中看到尖括号。类似于Java或TypeScript，它们之间的类型被称为 **类型参数**。它表示这个数组包含字符串。我们将在
    [*第4章*](B17816_04_ePub.xhtml#_idTextAnchor115)，*熟悉行为模式* 中详细讨论这个主题，同时介绍泛型。
- en: 'If you already have a collection and would like to convert it into an array,
    use the `toTypedArray` function:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经有一个集合并且想要将其转换为数组，请使用 `toTypedArray` 函数：
- en: '[PRE100]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: In terms of its abilities, a Kotlin array is very similar to a list. For example,
    to get the number of elements in a Kotlin array, we use the same `size` property
    as other collections.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在其能力方面，Kotlin数组与列表非常相似。例如，要获取Kotlin数组中的元素数量，我们使用与其他集合相同的 `size` 属性。
- en: '*When would you need to use arrays then?* One example is accepting arguments
    in the `main` function. Previously, we''ve seen only main functions without arguments,
    but sometimes you want to pass them from a command line.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '*你什么时候需要使用数组呢？* 一个例子是在 `main` 函数中接受参数。之前，我们只看到没有参数的main函数，但有时你希望从命令行传递它们。'
- en: 'Here''s an example of a `main` function that accepts arguments from a command
    line and prints all of them, separated by commas:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个接受命令行参数并打印所有参数的 `main` 函数的示例，参数之间用逗号分隔：
- en: '[PRE101]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Other cases include invoking Java functions that expect arrays or using `varargs`
    syntax, which we will discuss in [*Chapter 3*](B17816_03_ePub.xhtml#_idTextAnchor080),
    *Understanding Structural Patterns*.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 其他情况包括调用期望数组作为参数的Java函数或使用我们将要讨论的 `varargs` 语法，这将在 [*第3章*](B17816_03_ePub.xhtml#_idTextAnchor080)，*理解结构模式*
    中介绍。
- en: As we are now familiar with some basic data structures, it's time to discuss
    how we can apply logic to them using `if` and `when` expressions.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在已经熟悉了一些基本数据结构，现在是时候讨论如何使用 `if` 和 `when` 表达式对它们应用逻辑了。
- en: Control flow
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制流
- en: You could say that the control flow is the bread and butter of writing programs.
    We'll start with two conditional expressions, `if` and `when`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以说，控制流是编写程序的基础。我们将从两个条件表达式开始，`if` 和 `when`。
- en: The if expression
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: if 表达式
- en: 'In Java, `if` is a statement. Statements do not return any value. Let''s look
    at the following function, which returns one of two possible values:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，`if` 是一个语句。语句不会返回任何值。让我们看看以下函数，它返回两个可能值中的一个：
- en: '[PRE104]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: While this example is easy to follow, in general, having multiple `return` statements
    is considered bad practice because they often make the code harder to comprehend.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个例子很容易理解，但通常情况下，有多个 `return` 语句被认为是坏习惯，因为它们往往使代码更难理解。
- en: 'We could rewrite this method using Java''s `var` keyword:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Java的 `var` 关键字重写这个方法：
- en: '[PRE112]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Now, we have a single `return` statement, but we had to introduce a mutable
    variable. Again, with such a simple example, this is not an issue. But, in general,
    you should try to avoid mutable shared state as much as possible, since such code
    is not thread-safe.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个单独的`return`语句，但我们必须引入一个可变变量。同样，在这个简单的例子中，这不是问题。但，一般来说，你应该尽可能避免可变共享状态，因为这样的代码不是线程安全的。
- en: '*Why are we having problems writing that in the first place, though?*'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么我们一开始就遇到问题呢？*'
- en: 'Contrary to Java, in Kotlin, `if` is an expression, meaning it returns a value.
    We could rewrite the previous function in Kotlin as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 与Java不同，在Kotlin中，`if`是一个表达式，意味着它返回一个值。我们可以将之前的函数重写为以下Kotlin版本：
- en: '[PRE119]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Or we could use a shorter form:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以使用更简短的形式：
- en: '[PRE126]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Due to the fact that `if` is an expression, we didn't need to introduce any
    local variables.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`if`是一个表达式，我们不需要引入任何局部变量。
- en: Here, we're again making use of single-expression functions and type inference.
    The important part is that `if` returns a value of the `String` type. There's
    no need for multiple return statements or mutable variables whatsoever.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们再次利用单表达式函数和类型推断。重要的是`if`返回一个`String`类型的值。根本不需要多个返回语句或可变变量。
- en: 'Important Note:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: Single-line functions in Kotlin are very cool and pragmatic, but you should
    make sure that somebody else other than you understands what they do. Use with
    care.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin的单行函数非常酷且实用，但你应该确保其他人除了你之外也能理解它们的作用。请谨慎使用。
- en: The when expression
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`when`表达式'
- en: '*What if (no pun intended) we want to have more conditions in our* `if` *statement?*'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果我们想在* `if` *语句中添加更多条件怎么办？（没有双关语的意思）*'
- en: 'In Java, we use the `switch` statement. In Kotlin, there''s a `when` expression,
    which is a lot more powerful, since it can embed some other Kotlin features. Let''s
    create a method that''s given a superhero and tells us who their archenemy is:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，我们使用`switch`语句。在Kotlin中，有一个`when`表达式，它要强大得多，因为它可以嵌入一些其他Kotlin特性。让我们创建一个方法，给定一个超级英雄并告诉我们他们的宿敌是谁：
- en: '[PRE127]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: The `when` expression is very powerful. In the next chapters, we will elaborate
    on how we can combine it with ranges, `enums`, and `sealed` classes as well.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`when`表达式非常强大。在接下来的章节中，我们将详细说明如何将它与范围、`enums`和`sealed`类结合使用。'
- en: As a general rule, use `when` if you have more than two conditions. Use `if`
    for simple cases.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般规则，如果你有超过两个条件，请使用`when`。对于简单情况，请使用`if`。
- en: Working with text
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本处理
- en: We've already seen many examples of working with text in the previous section.
    After all, it's not possible to print `Hello Kotlin` without using a string, or
    at least it would be very awkward and inconvenient.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节中已经看到了许多处理文本的例子。毕竟，没有使用字符串就无法打印`Hello Kotlin`，或者至少会非常尴尬和不方便。
- en: In this section, we'll discuss some of the more advanced features that allow
    you to manipulate text efficiently.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论一些更高级的特性，这些特性允许你有效地操作文本。
- en: String interpolation
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串插值
- en: Let's assume now we would like to actually print the results from the previous
    section.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 假设现在我们想要实际打印上一节的结果。
- en: First, as you may have already noticed, in one of the previous examples, Kotlin
    provides a nifty `println()` standard function that wraps the bulkier `System.out.println`
    command from Java.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，正如你可能已经注意到的，在之前的某个例子中，Kotlin提供了一个巧妙的`println()`标准函数，它封装了Java中更庞大的`System.out.println`命令。
- en: 'But, more importantly, as in many other modern languages, Kotlin supports string
    interpolation using the `${}` syntax. Let''s take the example from before:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 但，更重要的是，就像许多其他现代语言一样，Kotlin支持使用`${}`语法进行字符串插值。让我们以前面的例子为例：
- en: '[PRE133]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'The preceding code would print as follows:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将按以下方式打印：
- en: '[PRE135]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Note that if you're interpolating a value of a function, you need to wrap it
    in curly braces. If it's a variable, curly braces could be omitted.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你正在插值一个函数的值，你需要将其包裹在花括号中。如果是变量，则可以省略花括号。
- en: Multiline strings
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多行字符串
- en: Kotlin supports multiline strings, also known as **raw strings**. This feature
    exists in many modern languages, and was brought to **Java 15** as **text blocks**.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin支持多行字符串，也称为**原始字符串**。这个特性存在于许多现代语言中，并被引入到**Java 15**中的**文本块**。
- en: 'The idea is quite simple. If we want to print a piece of text that spans multiple
    lines, let''s say something from *Alice''s Adventures in Wonderland* by Lewis
    Carroll, one way is to concatenate it:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法很简单。如果我们想要打印跨越多行的文本，比如说来自刘易斯·卡罗尔的《爱丽丝梦游仙境》的一段，一种方法是将它们连接起来：
- en: '[PRE136]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: While this approach certainly works, it's quite cumbersome.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法确实有效，但它相当繁琐。
- en: 'Instead, we could define the same string literal using triple quotes:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以使用三引号定义相同的字符串字面量：
- en: '[PRE142]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: This is a much cleaner way to achieve the same goal. If you execute this example,
    you may be surprised that the poem is not indented correctly. The reason is that
    multiline strings preserve whitespace characters, such as tabs.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种更干净地实现相同目标的方法。如果你执行这个示例，你可能会惊讶地发现诗歌的缩进不正确。原因是多行字符串保留了空白字符，例如制表符。
- en: 'To print the results correctly, we need to add a `trimIndent()` invocation:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确打印结果，我们需要添加一个`trimIndent()`调用：
- en: '[PRE148]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Multiline strings also have another benefit – there''s no need to escape quotes
    in them. Let''s look at the following example:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 多行字符串还有另一个好处——不需要在它们中转义引号。让我们看看以下示例：
- en: '[PRE152]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: Notice how the quote characters that are part of the text had to be escaped
    using the backslash character.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，文本中的引号字符必须使用反斜杠字符进行转义。
- en: 'Now, let''s look at the same text using multiline syntax:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用多行语法查看相同的文本：
- en: '[PRE153]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: Note that there's no need for escape characters anymore.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，不再需要转义字符。
- en: Loops
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环
- en: Now, let's discuss another typical control structure – a **loop**. Loops are
    a very natural construct for most developers. Without loops, it would be tough
    to repeat the same code block more than once (although we will discuss how to
    do that without loops in later chapters).
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论另一个典型的控制结构——循环。循环对于大多数开发者来说是一个非常自然的结构。没有循环，重复相同的代码块将非常困难（尽管我们将在后面的章节中讨论如何在没有循环的情况下做到这一点）。
- en: for-each loop
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: for-each循环
- en: 'Probably the most helpful type of a loop in Kotlin is a `for`-`each` loop.
    This loop can iterate over strings, data structures, and basically everything
    that has an iterator. We''ll learn more about iterators in [*Chapter 4*](B17816_04_ePub.xhtml#_idTextAnchor115),
    *Getting Familiar with Behavioral Patterns*, so for now, let''s demonstrate their
    use on a simple string:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，最有助于理解循环类型的是`for`-`each`循环。这个循环可以遍历字符串、数据结构和基本上所有具有迭代器的对象。我们将在[*第4章*](B17816_04_ePub.xhtml#_idTextAnchor115)“熟悉行为模式”中了解更多关于迭代器的知识，所以现在让我们通过一个简单的字符串来演示它们的使用：
- en: '[PRE154]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'This will print the following:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印以下内容：
- en: '[PRE157]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'The `for`-`each` loop works on all the types of data structures we already
    discussed as well, that is, lists, sets, and maps. Let''s take a list as an example:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`-`each`循环适用于我们之前讨论的所有数据结构类型，即列表、集合和映射。让我们以列表为例：'
- en: '[PRE161]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'We''ll get the following output:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '[PRE165]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: You'll see this loop many more times in this book, as it's very useful.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本书中多次看到这个循环，因为它非常有用。
- en: The for loop
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: for循环
- en: While in some languages `for`-`each` and `for` loops are two completely different
    constructs, in Kotlin a `for` loop is simply a `for`-`each` loop over a range.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在某些语言中`for`-`each`和`for`循环是完全不同的结构，但在Kotlin中，`for`循环只是一个对范围的`for`-`each`循环。
- en: 'To understand it better, let''s look at a `for` loop that prints all the single-digit
    numbers:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解它，让我们看看一个打印所有单个数字的`for`循环：
- en: '[PRE168]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: This doesn't look anything like a Java `for` loop and may remind you more of
    Python. The two dots are called a **range operator**.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来与Java的`for`循环完全不同，可能更让你想起Python。这两个点被称为**范围运算符**。
- en: 'If you run this code, you will notice that this loop is inclusive. It prints
    all the numbers, including `9`. This is similar to the following Java code:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这段代码，你会注意到这个循环是包含的。它打印了所有的数字，包括`9`。这类似于以下Java代码：
- en: '[PRE171]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'If you want your range to be exclusive and not to include the last element,
    you can use the `until` function:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要你的范围是排他的，不包括最后一个元素，你可以使用`until`函数：
- en: '[PRE172]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'If you''d like to print the numbers in reverse order, you can use the `downTo`
    function:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要以相反的顺序打印数字，可以使用`downTo`函数：
- en: '[PRE177]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: It may seem confusing that `until` and `downTo` are called functions, although
    they look more like operators. This is another interesting Kotlin feature called
    **infix call**, which will be discussed later.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然看起来它们更像操作符，但`until`和`downTo`被称为函数可能会让人感到困惑。这是Kotlin的另一个有趣特性，称为**中缀调用**，稍后我们将对其进行讨论。
- en: The while loop
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当循环
- en: 'There are no changes to the `while` loop functionality compared to some other
    languages, so we''ll cover them very briefly:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他一些语言相比，`while`循环的功能没有变化，所以我们非常简短地介绍它们：
- en: '[PRE180]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'This will print numbers from `1` to `10`. Note that we are forced to define
    `x` as `var`. The lesser-used `do while` loop is also present in the language:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印从`1`到`10`的数字。请注意，我们被迫将`x`定义为`var`。较少使用的`do while`循环也存在于该语言中：
- en: '[PRE185]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: Most probably, you won't be using the `while` loop and especially the `do while`
    loop much in Kotlin. In the following chapters, we'll discuss much more idiomatic
    ways to do this.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能，你不会在Kotlin中经常使用`while`循环和`do while`循环。在接下来的章节中，我们将讨论更多更符合习惯的做法。
- en: Classes and inheritance
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类和继承
- en: Although Kotlin is a multi-paradigm language, it has a strong affinity to the
    Java programming language, which is based on classes. Keeping Java and JVM interoperability
    in mind, it's no wonder that Kotlin also has the notion of classes and classical
    inheritance.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Kotlin是一种多范式语言，但它与基于类的Java编程语言有着强烈的亲和力。考虑到Java和JVM的互操作性，Kotlin也有类和经典继承的概念也就不足为奇了。
- en: In this section, we'll cover the syntax for declaring classes, interfaces, abstract
    classes, and data classes.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍声明类、接口、抽象类和数据类的语法。
- en: Classes
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类
- en: A `class` keyword, exactly like Java.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '`class`关键字，就像Java一样。'
- en: 'Let''s imagine we''re building a video game. We can define a class to represent
    the player as follows:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象我们正在开发一个视频游戏。我们可以定义一个类来表示玩家，如下所示：
- en: '[PRE190]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'The instantiation of a class simply looks like this:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 类的实例化看起来就像这样：
- en: '[PRE192]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: Note that there's no `new` keyword in Kotlin. The Kotlin compiler knows that
    we want to create a new instance of that class by the **round brackets** after
    the class name.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Kotlin中没有`new`关键字。Kotlin编译器知道我们想要通过类名后面的**圆括号**创建该类的新实例。
- en: 'If the class has no body, as in this simple example, we can omit the curly
    braces:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类没有主体，就像这个简单的例子一样，我们可以省略大括号：
- en: '[PRE193]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: Classes without any functions or properties aren't particularly useful, but
    we'll explore in [*Chapter 4*](B17816_04_ePub.xhtml#_idTextAnchor115), *Getting
    Familiar with Behavioral Patterns*, why this syntax exists and how it is consistent
    with other language features.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何函数或属性的类并不特别有用，但我们在[*第4章*](B17816_04_ePub.xhtml#_idTextAnchor115)中会探讨为什么存在这种语法，以及它如何与其他语言特性保持一致，即*熟悉行为模式*。
- en: Primary constructor
  id: totrans-432
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主要构造函数
- en: 'It would be useful for the player to be able to specify their name during creation.
    In order to do that, let''s add a primary constructor to our class:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家在创建时能够指定他们的姓名将是有用的。为了做到这一点，让我们给我们的类添加一个主要构造函数：
- en: '[PRE194]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'Now, this declaration won''t work anymore:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个声明将不再有效：
- en: '[PRE195]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'Also, we''ll have to provide a name for every new player we instantiate:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要为每个新实例化的玩家提供一个名称：
- en: '[PRE196]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: We'll return to constructors soon enough. But for now, let's discuss properties.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就会回到构造函数。但到目前为止，让我们讨论属性。
- en: Properties
  id: totrans-440
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性
- en: 'In Java, we are used to the concept of getters and setters. If we were to write
    a class representing a player in a game in Kotlin using Java idioms, it may have
    looked like this:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，我们习惯于getter和setter的概念。如果我们用Java习惯用法在Kotlin中编写表示游戏玩家的类，它可能看起来像这样：
- en: '[PRE197]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: If we want to get a player's name, we invoke the `getName()` method. If we want
    to change a player's name, we invoke the `setName()` method. That's quite simple
    to follow but very verbose.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要获取玩家的姓名，我们调用`getName()`方法。如果我们想更改玩家的姓名，我们调用`setName()`方法。这很简单，但很冗长。
- en: It is the first time we see the `this` keyword in Kotlin, so let's quickly explain
    what it means. Similar to many other languages, `this` holds the reference to
    the current object of that class. In our case, it points to the instance of a
    `Player` class.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在Kotlin中第一次看到`this`关键字，所以让我们快速解释一下它的含义。类似于许多其他语言，`this`持有对该类当前对象的引用。在我们的例子中，它指向`Player`类的实例。
- en: '*Why don''t we write our classes like that, though?*'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '*那么，我们为什么不这样写我们的类呢？*'
- en: '[PRE206]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: Seems like this approach has lots of benefits. It is much less verbose for sure.
    Reading a person's name is now much shorter – `player.name`.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法似乎有很多好处。当然，它比以前更简洁。现在读取一个人的姓名要短得多——`player.name`。
- en: Also, changing the name is much more intuitive – `player.name = "Alex";`.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，更改名称的方式更加直观——`player.name = "Alex";`。
- en: But by doing so, we lost a lot of control over our object. We cannot make `Player`
    immutable, for example. If we want everybody to be able to read the player's name,
    they'll also be able to change it at any point in time. This is a significant
    problem if we want to change that code later. With a setter, we can control that,
    but not with a public field.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 但这样做，我们失去了对对象的很多控制。例如，我们无法使`Player`不可变。如果我们想让每个人都能在任何时候读取玩家的姓名，他们也将能够更改它。如果我们以后想更改代码，这将是一个重大问题。使用setter，我们可以控制这一点，但使用公共字段则不行。
- en: 'Kotlin properties provide a solution for all those problems. Let''s look at
    the following class definition:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 属性为所有这些问题提供了一个解决方案。让我们看看以下类定义：
- en: '[PRE209]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: Note that this is almost the same as the example from the *Primary constructor*
    section, but now `name` has a `val` modifier.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这几乎与*主构造函数*部分中的示例相同，但现在`name`有一个`val`修饰符。
- en: This may look the same as the `PublicPerson` Java example, with all its problems.
    But actually, this implementation is similar to `ImmutablePerson`, with all its
    benefits.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来与所有问题的`PublicPerson` Java 示例相同，但实际上，这种实现与`ImmutablePerson`类似，具有所有优点。
- en: '*How is that possible?* Behind the scenes, Kotlin will generate a member and
    a getter with the same name for our convenience. We can set the property value
    in the constructor and then access it using its name:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '*这是怎么可能的？* 在幕后，Kotlin 将为我们的便利生成具有相同名称的成员和获取器。我们可以在构造函数中设置属性值，然后使用其名称访问它：'
- en: '[PRE210]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: 'Trying to change the name of our `Player` will result in an error, though:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试更改我们的`Player`的名称将导致错误：
- en: '[PRE212]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: 'Since we defined this property as a value, it is read-only. To be able to change
    a property, we need to define it as mutable. Prefixing a constructor parameter
    with `var` will automatically generate both a getter and a setter:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将此属性定义为值，因此它是只读的。要能够更改属性，我们需要将其定义为可变的。在构造函数参数前加上`var`会自动生成一个获取器和设置器：
- en: '[PRE213]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: 'If we don''t want the ability to provide the value at construction time, we
    can move the property inside the class body:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不想在构造时提供值的能力，我们可以将属性移动到类体内部：
- en: '[PRE214]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: Note that now we must also provide a default value for that property, since
    it cannot be simply `null`.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，现在我们必须为该属性提供一个默认值，因为它不能简单地是`null`。
- en: Custom setters and getters
  id: totrans-476
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义设置器和获取器
- en: 'Although we can set a score now easily, its value may be invalid. Take the
    following example:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们现在可以轻松地设置分数，但其价值可能无效。以下是一个例子：
- en: '[PRE217]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: 'If we want to have a mutable property with some validations, we need to define
    an explicit setter for it, using `set` syntax:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要有一个具有一些验证的可变属性，我们需要为它定义一个显式的设置器，使用`set`语法：
- en: '[PRE218]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: Here, `value` is the new value of the property and `field` is its current value.
    If our new value is negative, we decide to use a default value.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`value`是属性的新的值，而`field`是其当前值。如果我们的新值是负数，我们决定使用默认值。
- en: 'Coming from Java, you may be tempted to write the following code in your setter
    instead:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 Java，你可能会倾向于在你的设置器中编写以下代码：
- en: '[PRE228]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: 'But, in Kotlin, this will create an infinite recursion. You must remember that
    Kotlin generates a setter for mutable properties. So, the previous code will be
    translated to something like this:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在 Kotlin 中，这将创建一个无限递归。你必须记住 Kotlin 为可变属性生成设置器。因此，前面的代码将被翻译成类似以下的内容：
- en: '[PRE231]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: For that reason, we use the `field` identifier, which is provided automatically.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们使用自动提供的`field`标识符。
- en: 'In a similar manner, we can declare a custom getter:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，我们可以声明一个自定义获取器：
- en: '[PRE237]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: 'First, we save a value received as a constructor argument into a field with
    the same name. Then, we define a custom getter that will convert all characters
    in this property to uppercase:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将作为构造函数参数接收的值保存到具有相同名称的字段中。然后，我们定义一个自定义获取器，该获取器将转换此属性中的所有字符为大写：
- en: '[PRE241]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: 'We''ll get this as our output:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '[PRE242]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: Interfaces
  id: totrans-512
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口
- en: You are probably already familiar with the concept of **interfaces** from other
    languages. But let's quickly recap.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经熟悉其他语言中的**接口**概念。但让我们快速回顾一下。
- en: In typed languages, interfaces provide a way to define behavior that some class
    will have to implement. The keyword to define an interface is simply `interface`.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型化语言中，接口提供了一种定义某些类必须实现的行为的方式。定义接口的关键字很简单，就是`interface`。
- en: 'Let''s now define an interface for rolling a die:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们定义一个用于掷骰子的接口：
- en: '[PRE243]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: To implement the interface, a class specifies its name after a colon. There's
    no `implement` keyword in Kotlin.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现接口，一个类在冒号后指定其名称。在 Kotlin 中没有`implement`关键字。
- en: '[PRE246]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: This is also the first time we see the `import` keyword. As the name implies,
    it allows us to import another package, such as `kotlin.random`, from the Kotlin
    standard library.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是我们第一次看到`import`关键字。正如其名所示，它允许我们从 Kotlin 标准库中导入另一个包，例如`kotlin.random`。
- en: 'Interfaces in Kotlin also support default functions. If a function doesn''t
    rely on any state, such as this function that simply rolls a random number between
    `0` and `5`, we can move it into the interface:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 中的接口也支持默认函数。如果一个函数不依赖于任何状态，例如这个简单地掷出`0`到`5`之间随机数的函数，我们可以将其移动到接口中：
- en: '[PRE252]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: Abstract classes
  id: totrans-531
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象类
- en: '`interface`, an abstract class can contain state.'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '`interface`，一个抽象类可以包含状态。'
- en: 'Let''s create an abstract class that is able to move our player on the board
    or, for the sake of simplicity, just store the new coordinates:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个抽象类，使其能够移动我们的玩家在棋盘上，或者为了简化，只需存储新的坐标：
- en: '[PRE255]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: Any class that implements `Moveable` will inherit a `move()` function as well.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 任何实现了`Moveable`接口的类都将继承一个`move()`函数。
- en: Now, let's discuss in some more detail the `private` keyword you see here for
    the first time.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更详细地讨论一下这里第一次出现的`private`关键字。
- en: Visibility modifiers
  id: totrans-544
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可见性修饰符
- en: We mentioned the `private` keyword earlier in this chapter but didn't have a
    chance to explain it. The `private` properties or functions are only accessible
    to the class that declared them – `Moveable`, in this case.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章前面提到了`private`关键字，但没有机会解释它。`private`属性或函数仅对其声明的类（在这种情况下为`Moveable`）可访问。
- en: The default visibility of classes and properties is public, so there is no need
    to use the `public` keyword all the time.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 类和属性的默认可见性是公共的，所以没有必要总是使用`public`关键字。
- en: In order to extend an abstract class, we simply put its name after a colon.
    There's also no `extends` keyword in Kotlin.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 为了扩展一个抽象类，我们只需在它的名字后面加上一个冒号。在Kotlin中也没有`extends`关键字。
- en: '[PRE263]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '*How would you be able to differentiate between an abstract class and an interface,
    then?*'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '*那么，你如何区分抽象类和接口呢？*'
- en: An abstract class has round brackets after its name to indicate that it has
    a constructor. In the upcoming chapters, we'll see some uses of that syntax.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类在其名称后面有圆括号，表示它有一个构造函数。在接下来的章节中，我们将看到这个语法的其他用途。
- en: Inheritance
  id: totrans-553
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承
- en: Apart from extending abstract classes, we can also extend regular classes as
    well.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 除了扩展抽象类之外，我们还可以扩展常规类。
- en: Let's try to extend our `Player` class using the same syntax we used for an
    abstract class. We will attempt to create a `ConfusedPlayer` class, that is, a
    player that when given (*x* and *y*) moves to (*y* and *x*) instead.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用与抽象类相同的语法扩展我们的`Player`类。我们将尝试创建一个`ConfusedPlayer`类，即当给定(*x*和*y*)时，移动到(*y*和*x*)的玩家。
- en: 'First, let''s just create a class that inherits from `Player`:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个继承自`Player`的类：
- en: '[PRE266]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: Here, you can see the reason for round brackets even in abstract classes. This
    allows passing arguments to the parent class constructor. This is similar to using
    the `super` keyword in Java.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你可以看到为什么即使在抽象类中也需要圆括号。这允许向父类构造函数传递参数。这类似于在Java中使用`super`关键字。
- en: Surprisingly, this doesn't compile. The reason for this is that all classes
    in Kotlin are final by default and cannot be inherited from.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 意外地，这段代码无法编译。原因是Kotlin中的所有类默认都是最终的，不能被继承。
- en: 'To allow other classes to inherit from them, we need to declare them `open`:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许其他类从它们继承，我们需要将它们声明为`open`：
- en: '[PRE267]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: 'Let''s now try and override the `move` method now:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试重写`move`方法：
- en: '[PRE270]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: Overriding allows us to redefine the behavior of a function from a parent class.
    Whereas in Java, `@Override` is an optional annotation, in Kotlin `override` is
    a mandatory keyword. You cannot hide supertype methods, and code that doesn't
    use `override` explicitly won't compile.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 重写允许我们重新定义父类中函数的行为。在Java中，`@Override`是一个可选的注解，而在Kotlin中`override`是一个强制关键字。你不能隐藏超类型方法，并且没有显式使用`override`的代码无法编译。
- en: There are two other problems that we introduced in that piece of code. First,
    we cannot override a method that is not declared `open` as well. Second, we cannot
    modify the coordinates of our player from a child class since both coordinates
    are `private`.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 在那段代码中，我们引入了两个其他问题。首先，我们不能重写未声明为`open`的方法。其次，由于两个坐标都是`private`的，我们不能从子类中修改我们的玩家坐标。
- en: 'Let''s use the `protected` visibility modifier the makes the properties accessible
    to child classes and mark the function as `open` to be able to override it:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`protected`可见性修饰符使属性对子类可访问，并将函数标记为`open`以能够重写它：
- en: '[PRE277]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: Now, both of the problems are fixed. You also see the `protected` keyword here
    for the first time. Similar to Java, this visibility modifier makes a property
    or a method visible only to the class itself and to its subclasses.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，两个问题都已经解决。你在这里也第一次看到了`protected`关键字。类似于Java，这个可见性修饰符使得属性或方法只对类本身及其子类可见。
- en: Data classes
  id: totrans-584
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据类
- en: Remember that Kotlin is all about productiveness. One of the most common tasks
    for Java developers is to create yet another `equals` or `hashCode` methods. This
    task is so common that Kotlin has it built into the language. It's called a **data
    class**.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，Kotlin 的一切都是关于生产力。Java 开发者最常见的任务之一是创建另一个 `equals` 或 `hashCode` 方法。这个任务如此常见，以至于
    Kotlin 将其内置到语言中。它被称为 **data 类**。
- en: 'Let''s take a look at the following example:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例：
- en: '[PRE285]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: This will generate us a class with two getters and no setters (note the `val`
    part), which will also implement `equals`, `hashCode`, and `clone` functions in
    the correct way.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们生成一个具有两个获取器而没有设置器（注意 `val` 部分）的类，它还将以正确的方式实现 `equals`、`hashCode` 和 `clone`
    函数。
- en: 'The introduction of `data` classes is one of the most significant improvements
    in reducing the amount of boilerplate in the Kotlin language. Just like the regular
    classes, `data` classes can have their own functions:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '`data` 类的引入是 Kotlin 语言在减少样板代码方面最显著的改进之一。就像常规类一样，`data` 类可以有自己的函数：'
- en: '[PRE287]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: Compared to regular classes, the main limitation of `data` classes is that they
    are always `final`, meaning that no other class can inherit from them. But it's
    a small price to pay to have `equals` and `hashCode` functions generate automatically.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 与常规类相比，`data` 类的主要限制是它们总是 `final` 的，这意味着没有其他类可以从它们继承。但为了自动生成 `equals` 和 `hashCode`
    函数，这只是一个微不足道的代价。
- en: Kotlin data classes versus Java records
  id: totrans-598
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Kotlin `data` 类与 Java 记录
- en: 'Learning from Kotlin, Java 15 introduced the notion of `record`:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Kotlin 中学习，Java 15 引入了 `record` 的概念：
- en: '[PRE293]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: Both syntaxes are pretty concise. *Are there any differences, though?*
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种语法都很简洁。*但是，它们之间有区别吗？*
- en: Kotlin `data` classes a have `copy()` function that records lack. We'll cover
    it in [*Chapter 2*](B17816_02_ePub.xhtml#_idTextAnchor062), *Working with Creational
    Patterns*, while discussing the **prototype** design pattern.
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin `data` 类有一个 `copy()` 函数，记录没有。我们将在 [*第 2 章*](B17816_02_ePub.xhtml#_idTextAnchor062)
    中介绍它，*使用创建型模式*，同时讨论 **原型** 设计模式。
- en: In a record, all properties must be `final`, or, in Kotlin terms, records support
    only values and not variables.
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在记录中，所有属性都必须是 `final` 的，或者用 Kotlin 的话说，记录只支持值而不是变量。
- en: The `data` classes can inherit from other classes, while records don't allow
    that.
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data` 类可以继承自其他类，而记录不允许这样做。'
- en: 'To summarize, `data` classes are superior to records in many ways. But both
    are great features of the respective languages. And since Kotlin is built with
    interoperability in mind, you can also easily mark a `data` class as a record
    to be accessible from Java:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`data` 类在许多方面优于记录。但两者都是各自语言的优秀特性。由于 Kotlin 是以互操作性为设计理念的，你还可以轻松地将 `data`
    类标记为记录，以便从 Java 访问：
- en: '[PRE294]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: Extension functions
  id: totrans-608
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展函数
- en: The last feature we'll cover in this chapter before moving on is `final`. For
    example, you would like to have a string that has the `hidePassword()` function
    from the previous section.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续下一章内容之前，我们将介绍最后一个特性 `final`。例如，你可能希望有一个字符串具有上一节中的 `hidePassword()` 函数。
- en: 'One way to achieve that is to declare a class that wraps the string for us:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的其中一种方法是为我们声明一个包装字符串的类：
- en: '[PRE296]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: This solution is quite wasteful, though. It adds another level of indirection.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案相当浪费。它增加了另一个间接层。
- en: In Kotlin, there's a better way to implement this.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，有更好的方法来实现这一点。
- en: 'To extend a class without inheriting from it, we can prefix the function name
    with the name of the class we''d like to extend:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 要扩展一个类而不从它继承，我们可以在函数名前加上我们想要扩展的类的名称：
- en: '[PRE299]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: This looks almost like a regular top-level function declaration, but with one
    crucial change – before the function name comes a class name. That class is called
    a **method receiver**.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来几乎像是一个常规的顶层函数声明，但有一个关键的变化——在函数名之前是一个类名。这个类被称为 **方法接收者**。
- en: Inside the function body, `this` will refer to any `String` class that the function
    was invoked on.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内部，`this` 将指向函数被调用的任何 `String` 类。
- en: 'Now, let''s declare a regular string and try to invoke this new function on
    it:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们声明一个常规字符串并尝试在其上调用这个新函数：
- en: '[PRE300]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '[PRE301]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: 'This prints the following:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印以下内容：
- en: '[PRE302]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '*What black magic is this?* We managed to add a function to a `final` class,
    something that technically should be impossible.'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: '*这是什么黑魔法吗？* 我们成功地向一个 `final` 类添加了一个函数，这在技术上应该是不可行的。'
- en: 'This is another feature of the Kotlin compiler, one among many. This extension
    function will be compiled to the following code:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Kotlin 编译器的一个特性，是众多特性之一。这个扩展函数将被编译成以下代码：
- en: '[PRE303]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '[PRE304]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '[PRE305]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '[PRE306]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: You can see that, in fact, this is a regular top-level function. Its first argument
    is an instance of the class that we extend. This also might remind you of how
    methods on structs in **Go** work.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，实际上，这是一个常规的顶级函数。它的第一个参数是我们扩展的类的实例。这也可能让你想起**Go**语言中结构体的方法是如何工作的。
- en: 'The code that prints the masked password will be adapted accordingly:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 打印加密密码的代码将被相应地调整：
- en: '[PRE307]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '[PRE308]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: For that reason, the extension functions cannot override the member function
    of the class, or access its `private` or `protected` properties.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，扩展函数不能覆盖类的成员函数，也不能访问其`private`或`protected`属性。
- en: Introduction to design patterns
  id: totrans-636
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式简介
- en: Now that we are a bit more familiar with basic Kotlin syntax, we can move on
    to discuss what design patterns are all about.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对基本的Kotlin语法有了更多的了解，我们可以继续讨论设计模式到底是什么。
- en: What are design patterns?
  id: totrans-638
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是设计模式？
- en: 'There are different misconceptions surrounding design patterns. In general,
    they are as follows:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 围绕设计模式存在不同的误解。一般来说，它们如下：
- en: Design patterns are just missing language features.
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计模式只是缺少语言特性。
- en: Design patterns are not necessary in a dynamic language.
  id: totrans-641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态语言中不需要设计模式。
- en: Design patterns are only relevant to object-oriented languages.
  id: totrans-642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计模式仅与面向对象的语言相关。
- en: Design patterns are only used in enterprises.
  id: totrans-643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计模式仅在企业中使用。
- en: Actually, design patterns are just a proven way to solve a common problem. As
    a concept, they are not limited to a specific programming language (Java), nor
    to a family of languages (the C family, for example), nor are they limited to
    programming in general. You may have even heard of design patterns in software
    architecture, which discuss how different systems can efficiently communicate
    with each other. There are service-oriented architectural patterns, which you
    may know as **Service-Oriented Architecture** (**SOA**), and microservice design
    patterns that evolved from SOA and emerged over the past few years. The future
    will, for sure, bring us even more design pattern families.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，设计模式只是解决常见问题的一种经过验证的方法。作为一个概念，它们并不局限于特定的编程语言（例如Java），也不局限于语言家族（例如C家族），也不局限于编程本身。你可能甚至听说过软件架构中的设计模式，它们讨论了不同的系统如何高效地相互通信。有面向服务的架构模式，你可能知道它为**服务导向架构**（**SOA**），以及从SOA演变而来的微服务设计模式，这些模式在过去几年中涌现出来。未来肯定会带来更多的设计模式家族。
- en: Even in the physical world, outside software development, we're surrounded by
    design patterns and commonly accepted solutions to a particular problem. Let's
    look at an example.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在物理世界中，在软件开发之外，我们也被设计模式和针对特定问题的普遍接受解决方案所包围。让我们看看一个例子。
- en: Design patterns in real life
  id: totrans-646
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生活中的设计模式
- en: '*Did you ride an elevator lately? Was there a mirror on the wall of the elevator?
    Why is that? How did you feel when you last rode an elevator that had no mirror
    and no glass walls?*'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '*你最近乘坐过电梯吗？电梯墙上有没有镜子？为什么会有镜子？当你最后一次乘坐没有镜子也没有玻璃墙的电梯时，你感觉如何？*'
- en: The main reason we commonly have mirrors in our elevators is to solve a frequent
    problem – riding in an elevator is boring. We could put in a picture. But a picture
    would also get boring after a while, if you rode the same elevator at least twice
    a day. Cheap, but not much of an improvement.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在电梯中通常放置镜子的主要原因是为了解决一个常见问题——乘坐电梯很无聊。我们本可以放一张图片。但如果每天至少乘坐同一部电梯两次，图片也会很快变得无聊。虽然便宜，但改善不大。
- en: We could put in a TV screen, as some do. But it makes the elevator more expensive.
    And it also requires a lot of maintenance. We need to put some content on the
    screen to make it not too repetitive. So, either there's a person whose responsibility
    is to renew the content once in a while or a third-party company that does it
    for us. We'll also have to handle different problems that may occur with screen
    hardware and the software behind it. Seeing the *blue screen of death* is amusing,
    of course, but only mildly.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像一些人做的那样放一个电视屏幕。但这会使电梯更贵。而且它还需要大量的维护。我们需要在屏幕上放置一些内容，以避免重复。所以，要么有一个人负责偶尔更新内容，要么有第三方公司为我们做这件事。我们还得处理屏幕硬件及其背后的软件可能出现的不同问题。当然，看到*蓝屏死机*是很有趣的，但只是轻微的。
- en: Some architects even go for putting elevator shafts on the building exterior
    and making part of the walls transparent. This may provide some exciting views.
    But this solution also requires maintenance (dirty windows don't make for the
    best view) and a lot of architectural planning.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 一些建筑师甚至选择将电梯井设置在建筑外部，并使部分墙壁透明。这可能会提供一些令人兴奋的视野。但这个解决方案也需要维护（脏窗户不会带来最佳的视野）以及大量的建筑规划。
- en: So, we put in a mirror. You get to watch an attractive person even if you ride
    alone. Some studies indicate that we find ourselves more attractive than we are,
    anyway. Maybe you get a chance to review your appearances one last time before
    that important meeting. Mirrors visually expand the visual space and make the
    entire trip less claustrophobic or less awkward if it's the start of a day and
    the elevator is really crowded.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们放了一面镜子。即使你独自乘坐，你也能看到一位有吸引力的人。一些研究表明，无论如何，我们都会觉得自己比实际更有吸引力。也许你有机会在重要会议之前最后一次审视你的外表。镜子从视觉上扩展了空间，使整个旅程不那么压抑或尴尬，尤其是在一天的开始，电梯真的很拥挤。
- en: Design process
  id: totrans-652
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计过程
- en: Let's try and understand what we did just now.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试理解我们刚才做了什么。
- en: We didn't invent mirrors in elevators. We've seen them thousands of times. But
    we formalized the problem (riding in an elevator is boring) and discussed alternative
    solutions (TV screens and glass walls) and the benefits of the commonly used solution
    (solves the problem and is easy to implement). That's what design patterns are
    all about.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并没有在电梯里发明镜子。我们见过它们成千上万次。但我们正式化了这个问题（乘坐电梯很无聊）并讨论了替代方案（电视屏幕和玻璃墙）以及常用解决方案的好处（解决问题且易于实施）。这就是设计模式的所有内容。
- en: 'The basic steps of the design process are as follows:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 设计过程的基本步骤如下：
- en: Define exactly what the current problem is.
  id: totrans-656
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 明确当前问题的定义。
- en: Consider different alternatives, based on the pros and cons.
  id: totrans-657
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑不同的替代方案，基于利弊。
- en: Choose the solution that solves the problem while best fitting your specific
    constraints.
  id: totrans-658
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择解决问题的方案，同时最好地适应你的具体约束。
- en: Why use design patterns in Kotlin?
  id: totrans-659
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么在 Kotlin 中使用设计模式？
- en: Kotlin comes to solve the real-world problems of today. In the following chapters,
    we will discuss both the *design patterns* first introduced by the *Gang of Four*
    back in 1994, as well as design patterns that emerged from the functional programming
    paradigm and the design patterns that we use to handle concurrency in our applications.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 出现是为了解决当今的现实世界问题。在接下来的章节中，我们将讨论 1994 年由“四人帮”首次提出的 *设计模式*，以及从函数式编程范式和用于处理应用程序并发的设计模式中出现的模式。
- en: You'll find that some of the design patterns are so common or useful that they're
    already built into the language as reserved keywords or standard functions. Some
    of them will need to combine a set of language features. And some are not so useful
    anymore, since the world has moved forward, and other patterns are replacing them.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现一些设计模式非常常见或有用，以至于它们已经作为保留关键字或标准函数内置到语言中。其中一些需要结合一组语言特性。而有些则不再那么有用，因为世界已经前进，其他模式正在取代它们。
- en: But in any case, familiarity with design patterns and best practices expands
    your *developer toolbox* and creates a shared vocabulary between you and your
    colleagues.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 但无论如何，熟悉设计模式和最佳实践扩展了你的 *开发者工具箱*，并在你和你同事之间创造了一个共享的词汇。
- en: Summary
  id: totrans-663
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we covered the main goals of the Kotlin programming language.
    We learned how variables are declared, the basic types, `null` safety, and type
    inference. We observed how program flow is controlled by commands such as `if`,
    `when`, `for`, and `while`, and we also took a look at the different keywords
    used to define classes and interfaces: class, interface, `data` class, and `abstract`
    class. We learned how to construct new classes and how to implement interfaces
    and inherit from other classes. Finally, we covered what design patterns are suitable
    for and why we need them in Kotlin.'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 Kotlin 编程语言的主要目标。我们学习了如何声明变量、基本类型、`null` 安全性和类型推断。我们观察到程序流程是通过诸如
    `if`、`when`、`for` 和 `while` 等命令控制的，我们还研究了用于定义类和接口的不同关键字：`class`、`interface`、`data`
    类和 `abstract` 类。我们学习了如何构建新的类以及如何实现接口和继承其他类。最后，我们讨论了在 Kotlin 中哪些设计模式是合适的以及为什么我们需要它们。
- en: Now, you should be able to write simple programs in Kotlin that are pragmatic
    and type-safe. There are many more aspects of the language we need to discuss.
    We'll cover them in later chapters once we need to apply them.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够编写简单且类型安全的 Kotlin 程序。我们还需要讨论语言的其他许多方面。一旦需要应用它们，我们将在后面的章节中介绍这些内容。
- en: In the next chapter, we'll discuss the first of the three design pattern families
    – creation patterns.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论三种设计模式家族中的第一个——创建型模式。
- en: Questions
  id: totrans-667
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What's the difference between `var` and `val` in Kotlin?
  id: totrans-668
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kotlin 中 `var` 和 `val` 有什么区别？
- en: How do you extend a class in Kotlin?
  id: totrans-669
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在 Kotlin 中扩展一个类？
- en: How do you add functionality to a `final` class?
  id: totrans-670
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何向一个 `final` 类添加功能？
