- en: Chapter 9. Advanced Build Customization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章. 高级构建定制
- en: Now that you know how Gradle works, how to create your own tasks and plugins,
    how to run tests, and how to set up continuous integration, you can almost call
    yourself a Gradle expert. This chapter contains a few tips and tricks that we
    have not mentioned in the previous chapters that make it easier to build, develop,
    and deploy Android projects using Gradle.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了 Gradle 的工作原理，如何创建自己的任务和插件，如何运行测试，以及如何设置持续集成，你几乎可以称自己为 Gradle 专家。本章包含了一些我们之前章节中没有提到的技巧和窍门，这些技巧和窍门使得使用
    Gradle 构建、开发和部署 Android 项目变得更加容易。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Reducing the APK file size
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减小 APK 文件大小
- en: Speeding up builds
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加速构建
- en: Ignoring Lint
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忽略 Lint
- en: Using Ant from Gradle
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Gradle 使用 Ant
- en: Advanced app deployment
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级应用部署
- en: We will start out by looking at how we can reduce the size of the build output
    and why that is useful.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先探讨如何减小构建输出的尺寸以及为什么这很有用。
- en: Reducing the APK file size
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减小 APK 文件大小
- en: The size of APK files has been increasing dramatically in the last few years.
    There are several causes for this—more libraries have become available to Android
    developers, more densities have been added, and apps are getting more functionality
    in general.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，APK 文件的大小急剧增加。这有几个原因——更多的库对 Android 开发者可用，增加了更多的密度，并且应用在功能上总体上变得更加丰富。
- en: It is a good idea to keep APKs as small as possible. Not only because there
    is a 50 MB limit on APK files in Google Play, but a smaller APK also means that
    users can download and install an app faster, and it keeps the memory footprint
    down.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量保持 APK 尽可能小是一个好主意。这不仅因为 Google Play 上的 APK 文件有 50 MB 的限制，而且较小的 APK 也意味着用户可以更快地下载和安装应用，并且可以降低内存占用。
- en: In this section, we will look at a few properties in the Gradle build configuration
    file that we can manipulate to shrink APK files.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看 Gradle 构建配置文件中的一些属性，我们可以通过操作这些属性来减小 APK 文件。
- en: ProGuard
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ProGuard
- en: '**ProGuard** is a Java tool that can not only shrink, but also optimize, obfuscate,
    and preverify your code at compile time. It goes through all the code paths in
    your app to find code that is not used and deletes it. ProGuard also renames your
    classes and fields. This process keeps the footprint of the app down, and makes
    the code more difficult to reverse engineer.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**ProGuard** 是一个 Java 工具，它不仅可以在编译时缩小、优化、混淆和预验证你的代码，还可以在编译时进行这些操作。它遍历你的应用中的所有代码路径，以找到未使用的代码并将其删除。ProGuard
    还会重命名你的类和字段。这个过程可以降低应用的占用空间，并使代码更难以逆向工程。'
- en: 'The Android plugin for Gradle has a Boolean property called `minifyEnabled`
    on the build type that you need to set to true to enable ProGuard:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Android 插件 Gradle 有一个布尔属性，称为 `minifyEnabled`，在构建类型上需要将其设置为 true 以启用 ProGuard：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When you set `minifyEnabled` to `true`, the `proguardRelease` task is executed
    and invokes ProGuard during the build process.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将 `minifyEnabled` 设置为 `true` 时，`proguardRelease` 任务将被执行，并在构建过程中调用 ProGuard。
- en: 'It is a good idea to retest your entire application after enabling ProGuard,
    because it might remove some code that you still need. This is an issue that has
    made lots of developers weary of ProGuard. To solve this problem, you can define
    ProGuard rules to exclude certain classes from getting removed or obfuscated.
    The `proguardFiles` property is used to define the files that contain ProGuard
    rules. For example, to keep a class, you can add a simple rule like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在启用 ProGuard 后重新测试你的整个应用是一个好主意，因为它可能会删除你仍然需要的某些代码。这是一个让许多开发者对 ProGuard 产生警惕的问题。为了解决这个问题，你可以定义
    ProGuard 规则以排除某些类被删除或混淆。`proguardFiles` 属性用于定义包含 ProGuard 规则的文件。例如，为了保留一个类，你可以添加一个简单的规则，如下所示：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `getDefaultProguardFile('proguard-android.txt')` method fetches the default
    ProGuard settings from a file called `proguard-android.txt`, which comes with
    the Android SDK in the `tools/proguard` folder. The `proguard-rules.pro` file
    gets added to new Android modules by default by Android Studio, so you can simply
    add rules specific to the module in that file.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`getDefaultProguardFile(''proguard-android.txt'')` 方法从名为 `proguard-android.txt`
    的文件中获取默认的 ProGuard 设置，该文件位于 Android SDK 的 `tools/proguard` 文件夹中。`proguard-rules.pro`
    文件默认情况下会被 Android Studio 添加到新的 Android 模块中，因此你可以在该文件中简单地添加针对模块的特定规则。'
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The ProGuard rules are different for each app or library you build, so we will
    not go into too much detail in this book. If you want to know more about ProGuard
    and ProGuard rules, check the official Android ProGuard documentation at [http://developer.android.com/tools/help/proguard.html](http://developer.android.com/tools/help/proguard.html).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ProGuard规则对您构建的每个应用或库都不同，因此在这本书中我们不会过多地详细介绍。如果您想了解更多关于ProGuard和ProGuard规则的信息，请查看官方Android
    ProGuard文档[http://developer.android.com/tools/help/proguard.html](http://developer.android.com/tools/help/proguard.html)。
- en: Besides shrinking the Java code, it is also a good idea to shrink the used resources.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 除了压缩Java代码外，压缩使用的资源也是一个好主意。
- en: Shrinking resources
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源压缩
- en: Gradle and the Android plugin for Gradle can get rid of all unused resources
    at build time, when the app is being packaged. This can be useful if you have
    old resources that you forgot to remove. Another use case is when you import a
    library that has lots of resources, but you only use a small subset of them. You
    can fix this by enabling resource shrinking. There are two ways to go about shrinking
    resources, automatic or manual.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle和Gradle的Android插件可以在构建时移除所有未使用的资源，当应用正在打包时。如果您忘记移除旧资源，这可能会很有用。另一个用例是当您导入一个包含大量资源的库，但您只使用其中的一小部分时。您可以通过启用资源压缩来修复这个问题。有自动或手动两种方法来压缩资源。
- en: Automatic shrinking
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动压缩
- en: The easiest way is to configure the `shrinkResources` property on your build.
    If you set this property to `true`, the Android build tools will automatically
    try to determine which resources are not used, and not include them in the APK.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是配置构建中的`shrinkResources`属性。如果您将此属性设置为`true`，Android构建工具将自动尝试确定哪些资源未使用，并且不会将它们包含在APK中。
- en: There is one requirement for using this feature, though you have to enable ProGuard
    as well. This is due to the way the resource shrinking works, as the Android build
    tools cannot figure out which resources are unused until the code that references
    these resources has been removed.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您必须启用ProGuard，但使用此功能有一个要求。这是由于资源压缩的工作方式，因为Android构建工具无法确定哪些资源未使用，直到引用这些资源的代码被移除。
- en: 'The following snippet shows how to configure automatic resource shrinking on
    a certain build type:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段显示了如何在特定构建类型上配置自动资源压缩：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you want to see exactly how much smaller your APK becomes after enabling
    automatic resource shrinking, you can run the `shrinkReleaseResources` task. This
    task prints out how much it has reduced the package in size:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想查看启用自动资源压缩后APK变得多小，您可以运行`shrinkReleaseResources`任务。此任务会打印出它减少了多少包的大小：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can get a detailed overview of the resources that are stripped from the
    APK, by adding the `--info` flag to your build command:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在构建命令中添加`--info`标志来获取从APK中移除的资源详细概述：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When you use this flag, Gradle prints out a lot of extra information about the
    build process, including every resource it does not include in the final build
    output.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用此标志时，Gradle会打印出大量有关构建过程的额外信息，包括它未包含在最终构建输出中的每个资源。
- en: 'One problem with automatic resource shrinking is that it might remove too many
    resources. Especially resources that are used dynamically might be accidentally
    stripped out. To prevent this, you can define exceptions in a file called `keep.xml`
    that you place in `res/raw/`. A simple `keep.xml` file will look like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 自动资源压缩的一个问题是可能会移除过多的资源。特别是动态使用的资源可能会意外被移除。为了防止这种情况，您可以在`res/raw/`目录下放置一个名为`keep.xml`的文件中定义异常。一个简单的`keep.xml`文件看起来像这样：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `keep.xml` file itself will also be stripped out of the final result.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`keep.xml`文件本身也将从最终结果中移除。'
- en: Manual shrinking
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动压缩
- en: A less drastic way to strip out resources is to get rid of certain language
    files or images for certain densities. Some libraries, such as Google Play Services,
    include a lot of languages. If your app only supports one or two languages, it
    does not make sense to include all the language files from these libraries in
    the final APK. You can use the `resConfigs` property to configure the resources
    you want to keep, and then the rest will be thrown out.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一种不那么激进的移除资源的方法是移除某些语言文件或特定密度的图像。一些库，如Google Play Services，包含很多语言。如果您的应用只支持一到两种语言，那么在最终的APK中包含这些库的所有语言文件就没有意义了。您可以使用`resConfigs`属性来配置您想要保留的资源，其余的将被丢弃。
- en: 'If you want to keep only English, Danish, and Dutch strings, you can use `resConfigs`
    like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想保留英语、丹麦语和荷兰语字符串，你可以这样使用 `resConfigs`：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can do this for density buckets as well, like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以为密度桶做同样的事情，如下所示：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It is even possible to combine languages and densities. In fact, every type
    of resource can be restricted using this property.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至可以将语言和密度结合起来。事实上，可以使用这个属性限制每种类型的资源。
- en: If you are having a hard time setting up ProGuard, or you just want to get rid
    of resources for languages or densities your app does not support, then using
    `resConfigs` is a good way to get started with resource shrinking.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你设置 ProGuard 遇到困难，或者你只是想移除你的应用不支持的语言或密度的资源，那么使用 `resConfigs` 是开始资源缩减的好方法。
- en: Speeding up builds
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加快构建速度
- en: A lot of Android developers that start using Gradle complain about the prolonged
    compilation time. Builds can take longer than they do with Ant, because Gradle
    has three phases in the build lifecycle that it goes through every time you execute
    a task. This makes the whole process very configurable, but also quite slow. Luckily,
    there are several ways to speed up Gradle builds.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开始使用 Gradle 的 Android 开发者抱怨编译时间过长。构建可能比使用 Ant 更长，因为 Gradle 在每次执行任务时都会经历构建生命周期的三个阶段。这使得整个过程非常可配置，但也相当慢。幸运的是，有几种方法可以加快
    Gradle 构建速度。
- en: Gradle properties
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Gradle 属性
- en: One way to tweak the speed of a Gradle build is to change some of the default
    settings. We already mentioned in parallel build execution in [Chapter 5](ch05.html
    "Chapter 5. Managing Multimodule Builds"), *Managing Multimodule Builds*, but
    there are a few more settings that you can adjust.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 调整 Gradle 构建速度的一种方法是通过更改一些默认设置。我们已经在[第 5 章](ch05.html "第 5 章。管理多模块构建")中提到了并行构建执行，*管理多模块构建*，但还有一些其他设置你可以调整。
- en: 'Just to recap, you can enable parallel builds by setting a property in a `gradle.properties`
    file that is placed in the root of a project. All you need to do is add the following
    line:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 只为了回顾一下，你可以通过在项目根目录中的 `gradle.properties` 文件中设置一个属性来启用并行构建。你只需要添加以下这一行：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Another easy win is to enable the Gradle daemon, which starts a background
    process when you run a build the first time. Any subsequent builds will then reuse
    that background process, thus cutting out the startup cost. The process is kept
    alive as long as you use Gradle, and is terminated after three hours of idle time.
    Using the daemon is particularly useful when you use Gradle several times in a
    short time span. You can enable the daemon in the `gradle.properties` file like
    this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个容易实现的改进是启用 Gradle 守护进程，当你第一次运行构建时，它会启动一个后台进程。随后的构建将重用那个后台进程，从而减少了启动成本。只要你在使用
    Gradle，进程就会保持活跃，并在空闲三小时后终止。在短时间内多次使用 Gradle 时，使用守护进程特别有用。你可以在 `gradle.properties`
    文件中这样启用守护进程：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In Android Studio, the Gradle daemon is enabled by default. This means that
    after the first build from inside the IDE, the next builds are a bit faster. If
    you build from the command-line interface; however, the Gradle daemon is disabled,
    unless you enable it in the properties.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中，Gradle 守护进程默认是启用的。这意味着在 IDE 内部进行第一次构建之后，接下来的构建会稍微快一些。然而，如果你从命令行界面进行构建；那么
    Gradle 守护进程是禁用的，除非你在属性中启用它。
- en: 'To speed up the compilation itself, you can tweak parameters on the Java Virtual
    Machine (JVM). There is a Gradle property called `jvmargs` that enables you to
    set different values for the memory allocation pool for the JVM. The two parameters
    that have a direct influence on your build speed are `Xms` and `Xmx`. The `Xms`
    parameter is used to set the initial amount of memory to be used, while the `Xmx`
    parameter is used to set a maximum. You can manually set these values in the `gradle.properties`
    file like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加快编译本身的速度，你可以调整 Java 虚拟机（JVM）的参数。有一个名为 `jvmargs` 的 Gradle 属性，它允许你为 JVM 的内存分配池设置不同的值。有两个参数直接影响你的构建速度，即
    `Xms` 和 `Xmx`。`Xms` 参数用于设置要使用的初始内存量，而 `Xmx` 参数用于设置最大值。你可以在 `gradle.properties`
    文件中手动设置这些值，如下所示：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You need to set the desired amount and a unit, which can be k for kilobytes,
    m for megabytes, and g for gigabytes. By default, the maximum memory allocation
    (`Xmx`) is set to 256 MB, and the starting memory allocation (`Xms`) is not set
    at all. The optimal settings depend on the capabilities of your computer.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要设置一个数量和一个单位，这个单位可以是 k（千字节）、m（兆字节）或 g（千兆字节）。默认情况下，最大内存分配（`Xmx`）设置为 256 MB，而起始内存分配（`Xms`）则没有设置。最佳设置取决于你电脑的能力。
- en: The last property you can configure to influence build speed is `org.gradle.configureondemand`.
    This property is particularly useful if you have complex projects with several
    modules, as it tries to limit the time spent in the configuration phase, by skipping
    modules that are not required for the task that is being executed. If you set
    this property to `true`, Gradle will try to figure out which modules have configuration
    changes and which ones do not, before it runs the configuration phase. This is
    a feature that will not be very useful if you only have an Android app and a library
    in your project. If you have a lot of modules that are loosely coupled, though,
    this feature can save you a lot of build time.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个可以配置以影响构建速度的属性是 `org.gradle.configureondemand`。如果您有包含多个模块的复杂项目，这个属性尤其有用，因为它试图通过跳过对执行任务不是必需的模块来限制配置阶段的时间。如果您将此属性设置为
    `true`，Gradle 将在运行配置阶段之前尝试确定哪些模块有配置更改，哪些没有。如果您项目中只有一个 Android 应用和一个库，这个功能可能不太有用。如果您有很多松散耦合的模块，这个功能可以为您节省大量的构建时间。
- en: Tip
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**System-wide Gradle properties**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**系统级 Gradle 属性**'
- en: If you want to apply these properties system-wide to all your Gradle-based projects,
    you can create a `gradle.properties` file in the `.gradle` folder in your home
    directory. On Microsoft Windows, the full path to this directory is `%UserProfile%\.gradle`,
    on Linux and Mac OS X it is `~/.gradle`. It is a good practice to set these properties
    in your home directory, rather than on the project level. The reason for this
    is that you usually want to keep memory consumption down on build servers, and
    the build time is of less importance.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想将这些属性系统性地应用到所有基于 Gradle 的项目中，您可以在家目录中的 `.gradle` 文件夹中创建一个 `gradle.properties`
    文件。在 Microsoft Windows 上，此目录的完整路径是 `%UserProfile%\.gradle`，在 Linux 和 Mac OS X
    上是 `~/.gradle`。在您的家目录中设置这些属性是一个好习惯，而不是在项目级别上。这样做的原因是您通常希望降低构建服务器上的内存消耗，而构建时间则不那么重要。
- en: Android Studio
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android Studio
- en: 'The Gradle properties you can change to speed up the compilation process are
    also configurable in the Android Studio settings. To find the compiler settings,
    open the **Settings** dialog, and then navigate to **Build, Execution, Deployment**
    | **Compiler**. On that screen, you can find settings for parallel builds, JVM
    options, configure on demand, and so on. These settings only show up for Gradle-based
    Android modules. Have a look at the following screenshot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 可以更改以加快编译过程的 Gradle 属性也可以在 Android Studio 设置中配置。要查找编译器设置，请打开 **设置** 对话框，然后导航到
    **构建、执行、部署** | **编译器**。在该屏幕上，您可以找到并行构建、JVM 选项、按需配置等设置。这些设置仅适用于基于 Gradle 的 Android
    模块。请查看以下截图：
- en: '![Android Studio](img/B01061_09_01.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![Android Studio](img/B01061_09_01.jpg)'
- en: Configuring these settings from Android Studio is easier than configuring them
    manually in the build configuration file, and the settings dialog makes it easy
    to find properties that influence the build process.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中配置这些设置比在构建配置文件中手动配置要容易，设置对话框使得查找影响构建过程的属性变得简单。
- en: Profiling
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析
- en: If you want to find out which parts of the build are slowing the process down,
    you can profile the entire build process. You can do this by adding the `--profile`
    flag whenever you execute a Gradle task. When you provide this flag, Gradle creates
    a profiling report, which can tell you which parts of the build process are the
    most time consuming. Once you know where the bottlenecks are, you can make the
    necessary changes. The report is saved as an HTML file in your module in `build/reports/profile`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想找出哪些构建部分减慢了进程，您可以分析整个构建过程。您可以通过在执行 Gradle 任务时添加 `--profile` 标志来实现这一点。当您提供此标志时，Gradle
    会创建一个分析报告，该报告可以告诉您构建过程中哪些部分耗时最长。一旦您知道了瓶颈在哪里，您就可以进行必要的更改。报告以 HTML 文件的形式保存在您的模块中的
    `build/reports/profile` 目录下。
- en: 'This is the report generated after executing the build task on a multimodule
    project:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是执行多模块项目构建任务后生成的报告：
- en: '![Profiling](img/B01061_09_02.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![分析](img/B01061_09_02.jpg)'
- en: The profiling report shows an overview of the time spent in each phase while
    executing the task. Below that summary is an overview of how much time Gradle
    spent on the configuration phase for each module. There are two more sections
    in the report that are not shown in the screenshot. The **Dependency Resolution**
    section shows how long it took to resolve dependencies, per module. Lastly, the
    **Task Execution** section contains an extremely detailed task execution overview.
    This overview has the timing for every single task, ordered by execution time
    from high to low.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 性能报告显示了在执行任务时每个阶段花费的时间概述。在以下摘要下方是Gradle为每个模块配置阶段花费时间的概述。报告中有两个更多部分在截图中没有显示。**依赖解析**部分显示了解析依赖项所需的时间，按模块划分。最后，**任务执行**部分包含了一个非常详细的任务执行概述。这个概述按执行时间从高到低排列了每个任务的计时。
- en: Jack and Jill
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Jack和Jill
- en: If you are willing to use experimental tools, you can enable Jack and Jill to
    speed up builds. **Jack** (**Java Android Compiler Kit**) is a new Android build
    toolchain that compiles Java source code directly to the Android Dalvik executable
    (dex) format. It has its own `.jack` library format and takes care of packaging
    and shrinking as well. **Jill** (**Jack Intermediate Library Linker**) is a tool
    that can convert `.aar` and `.jar` files to `.jack` libraries. These tools are
    still quite experimental, but they were made to improve build times and to simplify
    the Android build process. It is not recommended to start using Jack and Jill
    for production versions of your projects, but they are made available so that
    you can try them out.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意使用实验性工具，你可以启用Jack和Jill来加速构建过程。**Jack**（**Java Android Compiler Kit**）是一个新的Android构建工具链，它可以将Java源代码直接编译成Android
    Dalvik可执行文件（dex）格式。它有自己的`.jack`库格式，并负责打包和压缩。**Jill**（**Jack Intermediate Library
    Linker**）是一个可以将`.aar`和`.jar`文件转换为`.jack`库的工具。这些工具仍然相当实验性，但它们被制作出来是为了提高构建时间和简化Android构建过程。不建议在生产版本的项目中开始使用Jack和Jill，但它们被提供出来，以便你可以尝试它们。
- en: 'To be able to use Jack and Jill, you need to use build tools version 21.1.1
    or higher, and the Android plugin for Gradle version 1.0.0 or higher. Enabling
    Jack and Jill is as easy as setting one property in the `defaultConfig` block:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Jack和Jill，你需要使用版本21.1.1或更高版本的构建工具，以及Gradle的Android插件版本1.0.0或更高。启用Jack和Jill就像在`defaultConfig`块中设置一个属性一样简单：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can also enable Jack and Jill on a certain build type or product flavor.
    This way, you can continue using the regular build toolchain, and have an experimental
    build on the side:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在特定的构建类型或产品风味上启用Jack和Jill。这样，你就可以继续使用常规构建工具链，并在旁边进行实验性构建：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As soon as you set `useJack` to `true`, minification and obfuscation will not
    go through ProGuard anymore, but you can still use the ProGuard rules syntax to
    specify certain rules and exceptions. Use the same `proguardFiles` method that
    we mentioned before, when talking about ProGuard.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将`useJack`设置为`true`，最小化和混淆将不再通过ProGuard进行，但你仍然可以使用ProGuard规则语法来指定某些规则和异常。使用我们之前在讨论ProGuard时提到的相同的`proguardFiles`方法。
- en: Ignoring Lint
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 忽略Lint
- en: 'When you execute a release build with Gradle, a Lint check will be performed
    on your code. Lint is a static code analysis tool that flags potential bugs in
    your layouts and Java code. In some cases, it might even block the build process.
    If you have not used Lint on your project before, and you want to migrate to Gradle,
    Lint might come up with a lot of errors. To at least make the build work, you
    can configure Gradle to ignore Lint errors and prevent them from aborting the
    build, by disabling `abortOnError`. This should only be a temporary solution,
    because ignoring Lint errors can result in issues like missing translations, which
    can cause the app to crash. To prevent Lint from blocking the build process, disable
    `abortOnError` like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用Gradle执行发布构建时，会对你的代码执行Lint检查。Lint是一个静态代码分析工具，它会标记出布局和Java代码中的潜在错误。在某些情况下，它甚至可能阻止构建过程。如果你之前没有在项目中使用过Lint，并且想要迁移到Gradle，Lint可能会出现很多错误。为了至少让构建工作，你可以配置Gradle忽略Lint错误，并通过禁用`abortOnError`来防止它们终止构建。这应该只是一种临时解决方案，因为忽略Lint错误可能会导致诸如缺失翻译等问题，这些问题可能导致应用崩溃。为了防止Lint阻止构建过程，可以像这样禁用`abortOnError`：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Temporarily disabling the Lint abort can make it easier to migrate an existing
    Ant build process to Gradle. Another way to make the transition smoother is to
    execute Ant tasks directly from Gradle.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 临时禁用Lint终止可以更容易地将现有的Ant构建过程迁移到Gradle。使过渡更平滑的另一种方法是直接从Gradle执行Ant任务。
- en: Using Ant from Gradle
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Gradle 的 Ant
- en: If you have invested a lot of time in setting up a build with Ant, the switch
    to Gradle might sound scary. In that case, Gradle cannot only execute Ant tasks,
    it can also expand them. This means you can migrate from Ant to Gradle in smaller
    steps, instead of spending several days on converting your entire build configuration.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在设置 Ant 构建上投入了大量时间，那么切换到 Gradle 可能听起来有些可怕。在这种情况下，Gradle 不仅能够执行 Ant 任务，还可以扩展它们。这意味着您可以从
    Ant 迁移到 Gradle，而不是花费几天时间转换整个构建配置。
- en: Gradle uses Groovy's **AntBuilder** for the Ant integration. The AntBuilder
    enables you to execute any standard Ant task, your own custom Ant tasks, and entire
    Ant builds. It also makes it possible to define Ant properties in your Gradle
    build configuration.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle 使用 Groovy 的 **AntBuilder** 来实现 Ant 集成。AntBuilder 允许您执行任何标准 Ant 任务、您自己的自定义
    Ant 任务以及整个 Ant 构建。它还使得在 Gradle 构建配置中定义 Ant 属性成为可能。
- en: Running Ant tasks from Gradle
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 Gradle 运行 Ant 任务
- en: 'Running a standard Ant task from Gradle is straightforward. You just need to
    prepend the task name with `ant.` and everything works out of the box. For example,
    to create an archive, you can use this task:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Gradle 运行标准 Ant 任务很简单。您只需在任务名称前加上 `ant.` 前缀，一切就会自动工作。例如，要创建一个存档，您可以使用此任务：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The task is defined in Gradle, but makes use of two Ant tasks, `echo` and `zip`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 该任务在 Gradle 中定义，但使用了两个 Ant 任务，`echo` 和 `zip`。
- en: 'Of course you should always consider the Gradle alternatives for the standard
    Ant tasks. To create an archive like in the previous example, you can define a
    Gradle task that can handle this for you:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您应该始终考虑 Gradle 的标准 Ant 任务的替代方案。例如，要创建一个与上一个示例中类似的存档，您可以定义一个 Gradle 任务来处理此操作：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The task for the Gradle-based archive is more concise and easy to understand.
    Because it does not need to go through the AntBuilder, it is also slightly faster
    than using the Ant tasks.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 Gradle 的存档任务更加简洁且易于理解。因为它不需要通过 AntBuilder，所以它也比使用 Ant 任务稍微快一些。
- en: Importing an entire Ant script
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入整个 Ant 脚本
- en: If you have created an Ant script to build your app, you can import the whole
    build configuration, using `ant.importBuild`. All Ant targets are then automatically
    converted to Gradle tasks that you can access by their original name.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经创建了一个用于构建您的应用的 Ant 脚本，您可以使用 `ant.importBuild` 导入整个构建配置。然后，所有 Ant 目标都会自动转换为
    Gradle 任务，您可以通过它们原始的名称访问这些任务。
- en: 'For example, take the following Ant build file:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下 Ant 构建文件：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can import this build file into your Gradle build like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将此构建文件导入到您的 Gradle 构建中，方法如下：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This will expose the hello task to your Gradle build, so you can execute it
    like a regular Gradle task, and it will print out `Hello, Ant`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使 hello 任务暴露给您的 Gradle 构建，因此您可以像执行常规 Gradle 任务一样执行它，并将打印出 `Hello, Ant`：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Because the Ant task is converted to a Gradle task, you can also extend it
    using the `doFirst` and `doLast` blocks, or the `<<` shortcut. For example, you
    can print another line to the console:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Ant 任务被转换为 Gradle 任务，所以您也可以使用 `doFirst` 和 `doLast` 块或 `<<` 快捷方式来扩展它。例如，您可以向控制台打印另一行文本：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you execute the `hello` task now, it looks like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在执行 `hello` 任务，它看起来像这样：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can also depend on tasks imported from Ant, just like you usually would.
    For example, if you want to create a new task that depends on the hello task,
    you can simply do this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以像通常一样依赖于从 Ant 导入的任务。例如，如果您想创建一个依赖于 hello 任务的新的任务，您可以简单地这样做：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Using `dependsOn` makes sure the `hello` task gets triggered when executing
    the `hi` task:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `dependsOn` 确保在执行 `hi` 任务时触发 `hello` 任务：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you need to, you can even make an Ant task depend on a Gradle task. To accomplish
    this, you need to add the `depends` attribute to the task in the `build.xml` file,
    like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，您甚至可以使 Ant 任务依赖于 Gradle 任务。为了实现这一点，您需要在 `build.xml` 文件中将 `depends` 属性添加到任务中，如下所示：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you have a big Ant build file, and you want to make sure none of the task
    names overlap, you can rename all the Ant tasks on import, using this code snippet:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个大的 Ant 构建文件，并且想确保没有任务名称重叠，您可以在导入时使用此代码片段重命名所有 Ant 任务：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If you decide to rename all the Ant tasks, keep in mind that if you have an
    Ant task that depends on a Gradle task, then that Gradle task needs to be prefixed
    as well. Otherwise, Gradle will not be able to find it and throw an `UnknownTaskException`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您决定重命名所有 Ant 任务，请记住，如果您有一个依赖于 Gradle 任务的 Ant 任务，那么该 Gradle 任务也需要加上前缀。否则，Gradle
    将无法找到它并抛出 `UnknownTaskException`。
- en: Properties
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性
- en: 'Gradle and Ant cannot only share tasks, but you can also define properties
    in Gradle that can be used in your Ant build files. Consider this Ant target,
    which prints out a property called `version`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle和Ant不仅可以共享任务，你还可以在Gradle中定义可以在你的Ant构建文件中使用的属性。考虑以下Ant目标，它打印出一个名为`version`的属性：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can define the version property in the Gradle build configuration by prepending
    the property name with `ant.`, just like with tasks. This is the shortest way
    to define an Ant property:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Gradle构建配置中定义版本属性，就像在任务中一样，在属性名前加上`ant.`。这是定义Ant属性的最短方式：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Groovy hides a lot of the implementation here. If you write the property definition
    in full, it looks like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy在这里隐藏了很多实现细节。如果你完整地编写属性定义，它看起来像这样：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Executing the `version` task will do exactly what you would expect, namely
    printing out `1.0` to the console:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`version`任务将做你预期的事情，即打印出`1.0`到控制台：
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Having deep Ant integration in Gradle makes it a lot easier to transition from
    Ant-based builds to Gradle, and you can do it at a pace that you are comfortable
    with.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在Gradle中深度集成Ant使得从基于Ant的构建过渡到Gradle变得容易得多，你可以按照自己舒适的节奏进行。
- en: Advanced app deployment
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级应用部署
- en: In [Chapter 4](ch04.html "Chapter 4. Creating Build Variants"), *Creating Build
    Variants*, we looked at several ways to create multiple versions of the same app,
    using build types and product flavors. However, in some cases, it might be easier
    to use a more specific technique, such as APK splits.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章。创建构建变体")“创建构建变体”中，我们探讨了使用构建类型和产品风味创建同一应用多个版本的好几种方法。然而，在某些情况下，使用更具体的技巧，如APK分割可能更容易。
- en: Split APK
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分割APK
- en: Build variants can be seen as separate entities, that can each have their own
    code, resources, and manifest file. APK splits, on the other hand, only impact
    the packaging of an app. The compilation, shrinking, obfuscation, and so on are
    still shared. This mechanism allows you to split APKs based on either density
    or **application binary interface** (**ABI**).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 构建变体可以被视为独立的实体，每个都可以有自己的代码、资源和清单文件。另一方面，APK分割仅影响应用的打包。编译、缩减、混淆等操作仍然是共享的。这种机制允许你根据密度或**应用二进制接口**（**ABI**）来分割APK。
- en: You can configure splits by defining a `splits` block inside the `android` configuration
    block. To configure density splits, create a `density` block inside the `splits`
    block. If you want to set up ABI splits, use an `abi` block.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在`android`配置块内定义一个`splits`块来配置分割。要配置密度分割，在`splits`块内创建一个`density`块。如果你要设置ABI分割，使用一个`abi`块。
- en: 'If you enable density splits, Gradle creates a separate APK for each density.
    You can manually exclude certain densities if you do not need them, to speed up
    the build process. This example shows how to enable density splits and exclude
    devices with low density:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你启用了密度分割，Gradle将为每个密度创建一个单独的APK。如果你不需要某些密度，可以手动排除它们，以加快构建过程。以下示例展示了如何启用密度分割并排除低密度设备：
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If you only support a few densities, you can use `include` to create a whitelist
    of densities. To use include, you first need to use the `reset()` property, which
    resets the list of included densities to an empty string.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只支持少数几种密度，你可以使用`include`来创建一个密度的白名单。要使用`include`，你首先需要使用`reset()`属性，该属性将包含的密度列表重置为空字符串。
- en: The `compatibleScreens` property in the preceding snippet is optional, and injects
    a matching node in the manifest file. The configuration in the example is for
    an app that supports normal to extra large screens, excluding devices with small
    screens.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个代码片段中的`compatibleScreens`属性是可选的，并在清单文件中注入一个匹配的节点。示例中的配置适用于支持从正常到超大屏幕的应用，排除了小屏幕设备。
- en: Splitting APKs based on the ABI works in the same way, and all of the properties
    are the same as the properties for density splits, except for `compatibleScreens`.
    ABI splits have nothing to do with screen size, so there is no property called
    `compatibleScreens`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 根据ABI分割APK的方式与此相同，所有属性都与密度分割的属性相同，除了`compatibleScreens`。ABI分割与屏幕大小无关，因此没有名为`compatibleScreens`的属性。
- en: 'The result of executing a build after configuring the density splits is that
    Gradle now creates one universal APK and several density-specific APKs. This means
    you will end up with a collection of APKs like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 配置密度分割后执行构建的结果是Gradle现在创建了一个通用APK和几个特定密度的APK。这意味着你最终会得到一个像这样的APK集合：
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: There is one caveat to using APK splits, though. If you want to push multiple
    APKs to Google Play, you will need to make sure every APK has a different version
    code. This means that each split should have a unique version code. Luckily, by
    now you are able to do this in Gradle by looking at the `applicationVariants`
    property.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用 APK 分割有一些注意事项。如果您想将多个 APK 推送到 Google Play，您需要确保每个 APK 都有不同的版本码。这意味着每个分割都应该有一个唯一的版本码。幸运的是，到目前为止，您已经能够在
    Gradle 中通过查看 `applicationVariants` 属性来完成这项操作。
- en: 'The following snippet comes straight from the Android plugin for Gradle documentation,
    and shows how to generate different version codes for each APK:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段直接来自 Gradle Android 插件的文档，展示了如何为每个 APK 生成不同的版本码：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This little snippet checks which ABI is used on a build variant, and then applies
    a multiplier to the version code to make sure each variant has a unique version
    code.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小代码片段检查构建变体中使用了哪种 ABI，然后对版本码应用一个乘数，以确保每个变体都有一个唯一的版本码。
- en: Summary
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: After reading this chapter, you know how to reduce the size of your build outputs,
    and how to speed up builds by configuring Gradle and the JVM. Big migration projects
    should not frighten you anymore. You also learned some tricks that make development
    and deployment easier.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章之后，您将了解如何减小构建输出的体积，以及如何通过配置 Gradle 和 JVM 来加速构建。大型迁移项目再也不应该让您感到害怕了。您还学到了一些使开发和部署更简单的技巧。
- en: And with that, you have reached the end of the book! Now that you know the possibilities
    of Gradle, you can tweak and customize the build processes of your Android projects
    to the point where you will not need to do any manual work, except for executing
    tasks. You can configure build variants, manage dependencies, and configure multimodule
    projects. The Gradle DSL makes sense to you because you understand Groovy syntax,
    and you are comfortable with hooking into the Android plugin. You can even create
    tasks or plugins and share them, to help others automate their builds. All you
    need to do now is to apply your new skills!
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，您已经到达了本书的结尾！现在您已经了解了 Gradle 的可能性，您可以调整和自定义 Android 项目的构建过程，直到您不需要进行任何手动工作，除了执行任务。您可以配置构建变体，管理依赖项，并配置多模块项目。Gradle
    DSL 对您来说是有意义的，因为您理解 Groovy 语法，并且您对钩入 Android 插件感到舒适。您甚至可以创建任务或插件并共享它们，以帮助他人自动化他们的构建。现在您需要做的就是应用您的新技能！
