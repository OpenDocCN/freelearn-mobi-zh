- en: Chapter 6. Animating Sprites, Controls, and SceneKit
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. 动画精灵、控件和SceneKit
- en: In the previous chapter, we learned about physics engine in detail. We discussed
    `SKPhysicsBody`, that is, edge-based and volume-based physics bodies. We also
    got to know about the various initialization methods and physics properties, which
    helped us in integrating physics into our *Platformer* game. Now we have a much
    clear idea about how to simulate physics in a Sprite Kit game.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们详细学习了物理引擎。我们讨论了`SKPhysicsBody`，即基于边缘和体积的物理体。我们还了解了各种初始化方法和物理属性，这些帮助我们将物理集成到我们的*平台游戏*中。现在我们对如何在Sprite
    Kit游戏中模拟物理有了更清晰的认识。
- en: It is always good to have nice animated features in our game to enhance the
    user experience; this Sprite Kit has the `SKAction` class, which helps us to apply
    actions on nodes such as moving of nodes, rotating of nodes, scaling of nodes,
    and so on. For example, using animations during player movement or depicting collisions
    using animations, and so on. It's time for us to discuss about the `SKAction`
    class and also about implementing animations in our *Platformer* game.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中拥有良好的动画特性总是很好的，这可以增强用户体验；这个Sprite Kit拥有`SKAction`类，它帮助我们应用动作到节点上，例如节点的移动、旋转、缩放等。例如，在玩家移动时使用动画或使用动画来描绘碰撞等。现在是时候讨论`SKAction`类以及在我们*平台游戏*中实现动画了。
- en: Along with animation, we are also going to discuss about how we can provide
    controls in our game, such as having a reaction when the user taps on the screen
    or using the accelerometer to respond to directions in a game. We will also implement
    controls in our *Platformer* game and add a jump button to make the player jump
    over the blocks.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 除了动画，我们还将讨论如何在我们的游戏中提供控制，例如当用户触摸屏幕时产生反应或使用加速度计来响应游戏中的方向。我们还将在我们*平台游戏*中实现控制，并添加一个跳跃按钮，使玩家能够跳过方块。
- en: Scene Kit is a 3D graphics framework provided by Apple, we can use SceneKit's
    3D elements in our Sprite Kit game to further enhance the gaming experience and
    have a better gameplay if required. We are going to discuss about how we can integrate
    SceneKit in a Sprite Kit game.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Scene Kit是苹果提供的一个3D图形框架，我们可以在Sprite Kit游戏中使用SceneKit的3D元素来进一步增强游戏体验，并在需要时拥有更好的游戏玩法。我们将讨论如何将SceneKit集成到Sprite
    Kit游戏中。
- en: Animating nodes
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画节点
- en: Animated pictures give a very dynamic and polished feel during a gameplay; it
    is always preferred to have animations in our game. To add animations in Sprite
    Nodes, we can use the `SKAction` class properties and methods, which add the animations
    to the Sprite Kit nodes. Let's discuss about the `SKAction` class in detail.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 动画图片在游戏过程中提供了非常动态和精致的感觉；在我们的游戏中总是偏好拥有动画。要在Sprite节点中添加动画，我们可以使用`SKAction`类的属性和方法，这些方法将动画添加到Sprite
    Kit节点中。让我们详细讨论`SKAction`类。
- en: SKAction
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SKAction
- en: Properties and methods of the `SKAction` class help in providing the actions
    to the nodes in a scene. Actions are used to change the arrangement and appearance
    of the node to which they are attached. Actions in a node are executed when the
    scene runs its nodes.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`SKAction`类的属性和方法有助于向场景中的节点提供动作。动作用于改变它们所附加的节点的排列和外观。当场景运行其节点时，节点中的动作会被执行。'
- en: To assign an action we can call the particular `SKAction` class method as required.
    Then, we can configure the properties of the actions. In the end, for the execution
    of the action, we call the node object's `runAction()` method and pass the action's
    object.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要分配一个动作，我们可以根据需要调用特定的`SKAction`类方法。然后，我们可以配置动作的属性。最后，为了执行动作，我们调用节点对象的`runAction()`方法并传递动作对象。
- en: Adding a single action to a node
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将单个动作添加到节点
- en: 'There are two steps to add a single action to the node:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 将单个动作添加到节点的步骤有两个：
- en: '**Creating an action**: First of all, we create an action which can perform
    a particular activity such as rotating, scaling, moving, and so on, on the Sprite
    Kit node.'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建动作**：首先，我们创建一个动作，它可以在Sprite Kit节点上执行特定的活动，如旋转、缩放、移动等。'
- en: '**Executing an action**: Finally, we run the action on the node by calling
    the `runAction()` method on that node.'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**执行动作**：最后，我们通过在该节点上调用`runAction()`方法来运行动作。'
- en: Adding multiple actions to a node
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将多个动作添加到节点
- en: 'There are three steps involved in the process of adding multiple actions to
    the node:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在将多个动作添加到节点过程中的涉及三个步骤：
- en: '**Creating actions**: Here, instead of creating a single action, we can create
    multiple actions to perform different behaviors on the Sprite Kit node.'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建动作**：在这里，我们不仅可以创建单个动作，还可以创建多个动作，以在Sprite Kit节点上执行不同的行为。'
- en: '**Creating action sequence**: Here, we are going to create the order of execution
    in which the actions should behave in the Sprite Kit node.'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建动作序列**：在这里，我们将创建在Sprite Kit节点中动作应该表现出的执行顺序。'
- en: '**Executing the action**: Finally, we are going to run the action by specifying
    the action sequence in the `runAction()` method on the node.'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**执行动作**：最后，我们将通过在节点的`runAction()`方法中指定动作序列来运行动作。'
- en: Creating actions
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建动作
- en: There are various types of actions which can be applied on a node to make it
    behave differently, now we are going to study about most of them in detail.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 可以对节点应用各种类型的动作，以使其表现出不同的行为，现在我们将详细研究其中大部分。
- en: Moving nodes using actions
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用动作移动节点
- en: 'The `SKAction` class provides various action methods for moving nodes on a
    scene. They are as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`SKAction`类为在场景中移动节点提供了各种动作方法。它们如下：'
- en: '`func moveByX( x: CGFloat, y : CGFloat, duration sec: NSTimeInterval)`: This
    will move the node to its new position. Here, Delta of `x`, Delta of `y`, and
    duration in seconds are passed as parameters.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func moveByX( x: CGFloat, y : CGFloat, duration sec: NSTimeInterval)`: 这将使节点移动到其新位置。这里，`x`和`y`的增量以及持续时间的秒数作为参数传递。'
- en: '`func moveBy( delta: CGVector, duration sec: NSTimeInterval)`: This will move
    the node relative to its current position. Here, Delta vector pointing to a new
    position and duration in seconds are passed as parameters.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func moveBy( delta: CGVector, duration sec: NSTimeInterval)`: 这将使节点相对于其当前位置移动。这里，指向新位置的增量向量和持续时间的秒数作为参数传递。'
- en: '`moveTo(location: CGPoint, duration sec: NSTimeInterval)`: This will move the
    node to a new position. Location of the new position and duration in seconds are
    passed as parameters. Here location is a `CGpoint` value whose default value is
    `(0,0)`.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`moveTo(location: CGPoint, duration sec: NSTimeInterval)`: 这将使节点移动到新位置。新位置的坐标和持续时间的秒数作为参数传递。这里的位置是一个`CGPoint`值，其默认值为`(0,0)`。'
- en: '`func moveToX( x: CGFloat, duration sec: NSTimeInterval)`: This will move the
    node horizontally. In this, the `x` value and the duration of the action are passed
    as parameters.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func moveToX( x: CGFloat, duration sec: NSTimeInterval)`: 这将使节点水平移动。在这里，`x`值和动作的持续时间作为参数传递。'
- en: '`func moveToY(y: CGFloat, duration sec: NSTimeInterval)`: This will move the
    node vertically along a relative path. In this, the `y` value and the duration
    of the action in seconds are passed as parameters.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func moveToY(y: CGFloat, duration sec: NSTimeInterval)`: 这将使节点沿着相对路径垂直移动。在这里，`y`值和动作的持续时间（以秒为单位）作为参数传递。'
- en: '`func followPath( path: CGPath, duration sec: NSTimeInterval)`: This will move
    the node along a relative path. `path` and `sec` are taken as parameters, in which
    path is a `CGpath` value which is relative to the current position of the node.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func followPath( path: CGPath, duration sec: NSTimeInterval)`: 这将使节点沿着相对路径移动。`path`和`sec`作为参数，其中`path`是一个相对于节点当前位置的`CGPath`值。'
- en: '`func followPath( path: CGPath, speed: CGFloat)`: This will move the node along
    a relative path at a specified speed. The unit of speed is points per second.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func followPath( path: CGPath, speed: CGFloat)`: 这将使节点以指定的速度沿着相对路径移动。速度的单位是每秒点数。'
- en: '`func followPath( path: CGPath, asOffset : Bool, orientToPath : Bool, duration
    : NSTimeInterval )`: This function will move the node along the path. In this
    function, we pass four parameters: one is the `path` on which the node will move;
    the second is the `offset` parameter, which is either `true` or `false`. `true`
    represents that the points in the path are relative offsets to the initial position
    of the node, and on the other hand `false` represents that the points are absolute
    in nature. `orientToPath` will be a Boolean property if the true node can follow
    the path along the `z` axis.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func followPath( path: CGPath, asOffset : Bool, orientToPath : Bool, duration
    : NSTimeInterval )`: 此函数将使节点沿着路径移动。在这个函数中，我们传递四个参数：一个是节点将要移动的`path`；第二个是`offset`参数，它可以是`true`或`false`。`true`表示路径中的点相对于节点初始位置的相对偏移，而另一方面`false`表示点具有绝对性质。`orientToPath`将是一个布尔属性，如果节点可以沿着`z`轴跟随路径。'
- en: '`func followPath( path: CGPath, asOffset : Bool, orientToPath : Bool, speed
    : CGFloat)`: This function will move the node along the path at a specified speed.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func followPath( path: CGPath, asOffset : Bool, orientToPath : Bool, speed
    : CGFloat)`: 此函数将以指定的速度沿着路径移动节点。'
- en: Rotating nodes using actions
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用动作旋转节点
- en: 'The `SKAction` class provides various action methods for rotating nodes on
    a scene. They are:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`SKAction` 类提供了各种用于在场景中旋转节点的动作方法。它们是：'
- en: '`func rotateByAngle( radians: CGFloat, duration sec: NSTimeInterval)`: This
    functions helps in rotating the node at a specified angle. It takes two parameters:
    one is the amount in which the node is to be rotated in `radians`, and the other
    is the duration of the rotation in `seconds`. This rotation is relative to the
    node.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func rotateByAngle( radians: CGFloat, duration sec: NSTimeInterval)`: 此函数有助于在指定角度旋转节点。它接受两个参数：一个是节点旋转的
    `radians` 数量，另一个是旋转的持续时间（以秒为单位）。此旋转相对于节点。'
- en: '`func rotateToAngle( radians: CGFloat, duration sec: NSTimeInterval)`: This
    function helps in rotating the node to an absolute angle, in the counterclockwise
    direction. It also takes two parameters: one is the angle to rotate the node,
    which is measured in `radians`, and the other is the duration of the animation
    in seconds.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func rotateToAngle( radians: CGFloat, duration sec: NSTimeInterval)`: 此函数有助于将节点旋转到绝对角度，逆时针方向。它也接受两个参数：一个是旋转节点的角度，以
    `radians` 为单位测量，另一个是以秒为单位的动画持续时间。'
- en: '`func rotateToAngle(radians: CGFloat, duration sec: NSTimeInterval, shortestUnitArc
    shortestUnitArc: Bool)`: This function helps in rotating the node to an absolute
    angle. It takes three parameters: one is the angle to which the node is to be
    rotated, the second is the duration in seconds, and the third is a Boolean value
    to assign whether we want the smallest rotation path or not. If `true,` then the
    rotation will be in the shortest direction, otherwise the rotation will be interpolated
    within the discrete points.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func rotateToAngle(radians: CGFloat, duration sec: NSTimeInterval, shortestUnitArc
    shortestUnitArc: Bool)`: 此函数有助于将节点旋转到绝对角度。它接受三个参数：一个是节点要旋转到的角度，第二个是持续时间（以秒为单位），第三个是布尔值，用于指定我们是否想要最小的旋转路径。如果
    `true`，则旋转将沿最短方向进行，否则旋转将在离散点之间插值。'
- en: Changing the animation speed of a node
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改节点的动画速度
- en: 'The `SKAction` class provides various action methods for changing a node''s
    animation speed. They are as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`SKAction` 类提供了各种用于更改节点动画速度的动作方法。它们如下：'
- en: '`func speedBy(speed: CGFloat, duration sec: NSTimeInterval)`: With this function,
    we can control the speed of a node''s actions. It takes two parameters: one is
    the amount of `speed` to be added in the node, and the other is the `duration`
    of the animation in seconds.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func speedBy(speed: CGFloat, duration sec: NSTimeInterval)`: 使用此函数，我们可以控制节点动作的速度。它接受两个参数：一个是节点中要添加的
    `speed` 量，另一个是以秒为单位的动画持续时间。'
- en: '`func speedTo(speed: CGFloat, duration sec: NSTimeInterval)`: With this function
    too, we can control the speed of the node''s actions. But instead of passing the
    parameter that adds its value to the previous speed, this function changes the
    `speed` to the set value. The other parameter passed is the `duration` of animation
    in seconds.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func speedTo(speed: CGFloat, duration sec: NSTimeInterval)`: 使用此函数同样可以控制节点动作的速度。但与传递参数以将其值添加到先前速度不同，此函数将
    `speed` 更改为设置的值。另一个传递的参数是动画的持续时间（以秒为单位）。'
- en: Changing the scale position of a node
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改节点的缩放位置
- en: 'The `SKAction` class provides various action methods for scaling a node. They
    are as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`SKAction` 类提供了各种用于缩放节点的动作方法。它们如下：'
- en: '`func scaleBy( scale: CGFloat, duration sec: NSTimeInterval)`: With this function,
    you can change the `xScale` and `yScale` values of a node. This function takes
    two parameters: one is the amount to be added in the `x` and `y` values of the
    node, and the other is the duration of the animation. This scaling applies to
    the current size.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func scaleBy( scale: CGFloat, duration sec: NSTimeInterval)`: 使用此函数，您可以更改节点的
    `xScale` 和 `yScale` 值。此函数接受两个参数：一个是节点 `x` 和 `y` 值中要添加的量，另一个是动画的持续时间。此缩放应用于当前大小。'
- en: '`func scaleTo( scale: CGFloat, duration sec: NSTimeInterval)`: With this function
    too, you can change the `x` and `y` values of a node. It takes two parameters:
    one is the new value of the node''s `x` and `y` values, and the other is the duration
    of the animation.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func scaleTo( scale: CGFloat, duration sec: NSTimeInterval)`: 使用此函数同样可以更改节点的
    `x` 和 `y` 值。它接受两个参数：一个是节点 `x` 和 `y` 值的新值，另一个是动画的持续时间。'
- en: '`func scaleXBy ( xScale: CGFloat, y yScale: CGFloat, duration sec: NSTimeInterval)`:
    With this function, you can change the `x` and `y` values of the node. Three parameters
    are passed in this function: first is the amount to be added in the node''s `x`
    value, second is the amount to be added in the node''s `y` value, and the third
    is the duration of the animation. This function is used when you have to scale
    the `x` and `y` of a node with different values.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func scaleXBy(xScale: CGFloat, y yScale: CGFloat, duration sec: NSTimeInterval)`:
    使用此函数，您可以更改节点的`x`和`y`值。在此函数中传递了三个参数：第一个是要添加到节点`x`值中的量，第二个是要添加到节点`y`值中的量，第三个是动画的持续时间。当您必须使用不同的值缩放节点的`x`和`y`时，使用此函数。'
- en: '`func scaleXTo( xScale: CGFloat, y yScale: CGFloat, duration sec: NSTimeInterval)`:
    With this function too, you can change the `x` and `y` values of the node differently.
    But instead of passing the value to add in the `x` and `y`, you can set the `x`
    and `y` scale to new values by passing the respective parameters.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func scaleXTo(xScale: CGFloat, y yScale: CGFloat, duration sec: NSTimeInterval)`:
    此函数同样可以更改节点的`x`和`y`值，但不是传递要添加到`x`和`y`中的值，而是通过传递相应的参数将`x`和`y`缩放设置为新的值。'
- en: '`func scaleXTo( scale: CGFloat, duration sec: NSTimeInterval)`: With this function,
    you can only change the `x` value of a node to a new value. It takes two parameters:
    one is the node''s `x` value and the other is the `duration` of the animation.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func scaleXTo(scale: CGFloat, duration sec: NSTimeInterval)`: 使用此函数，您只能将节点的`x`值更改为新值。它接受两个参数：一个是节点的`x`值，另一个是动画的`duration`。'
- en: '`func scaleYTo( scale: CGFloat, duration sec: NSTimeInterval)`: With this function,
    you can only change the `y` value of a node to a new value. It takes two parameters:
    one is the node''s `y` value and the other is the `duration` of the animation.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func scaleYTo(scale: CGFloat, duration sec: NSTimeInterval)`: 使用此函数，您只能将节点的`y`值更改为新值。它接受两个参数：一个是节点的`y`值，另一个是动画的`duration`。'
- en: Showing or hiding a node
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示或隐藏节点
- en: 'The `SKAction` class provides various action methods for hiding or showing
    a node on a scene. Let''s have a look at both of these functions:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`SKAction`类为在场景上隐藏或显示节点提供了各种动作方法。让我们看看这两个函数：'
- en: '`func unhide()`: With this function, you can create an action to make a node
    visible. This function was introduced in iOS 8.0.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func unhide()`: 使用此函数，您可以创建一个使节点可见的动作。此函数是在iOS 8.0中引入的。'
- en: '`func hide()`: With this function, you can create an action to make a node
    hidden. This function was introduced in iOS 8.0 as well.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func hide()`: 使用此函数，您可以创建一个使节点隐藏的动作。此函数也是在iOS 8.0中引入的。'
- en: Changing the transparency of a node
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改节点的透明度
- en: 'With the help of `SKAction`, you can also change the transparency of a node.
    The following functions help you achieve this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SKAction`的帮助下，您还可以更改节点的透明度。以下函数可以帮助您实现这一点：
- en: '`func fadeInWithDuration( sec: NSTimeInterval)`: You can change the alpha value
    of a node to `1.0` with this function. Only one parameter is passed with this
    function, which is the duration of the animation.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func fadeInWithDuration(sec: NSTimeInterval)`: 您可以使用此函数将节点的alpha值更改为`1.0`。此函数只传递一个参数，即动画的持续时间。'
- en: '`func fadeOutWithDuration( sec: NSTimeInterval)`: You can change the alpha
    value of a node to `0.0` with this function. Only one parameter is passed with
    this function, which is the duration of the animation.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func fadeOutWithDuration(sec: NSTimeInterval)`: 您可以使用此函数将节点的alpha值更改为`0.0`。此函数只传递一个参数，即动画的持续时间。'
- en: '`func fadeAlphaBy( factor: CGFloat, duration sec: NSTimeInterval)`: With this
    function, you can control the amount of alpha value to be added to the node. You
    pass two parameters in this function: one is the amount to be added to the alpha
    value of the node, and the other is the `duration` of the node.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func fadeAlphaBy(factor: CGFloat, duration sec: NSTimeInterval)`: 使用此函数，您可以控制要添加到节点中的alpha值的量。在此函数中，您传递两个参数：一个是添加到节点alpha值中的量，另一个是节点的`duration`。'
- en: '`func fadeAlphaTo(alpha: CGFloat, duration sec: NSTimeInterval)`: With this
    function, you can set a new alpha value for the node. Two parameters are passed
    in this function: one is the node''s new alpha value and the other is the `duration`
    of the node.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func fadeAlphaTo(alpha: CGFloat, duration sec: NSTimeInterval)`: 使用此函数，您可以设置节点的新alpha值。在此函数中传递了两个参数：一个是节点的新alpha值，另一个是节点的`duration`。'
- en: Changing the content of a sprite node
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改精灵节点的内容
- en: 'With some `SKAction` functions, you can create actions to change the content
    of a sprite node. Let''s have a look at them:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一些`SKAction`函数，您可以创建动作来更改精灵节点的内容。让我们看看它们：
- en: '`func resizeByWidth( width: CGFloat, height: CGFloat, duration: NSTimeInterval)`:
    This function creates an action which adjusts the size of a sprite node. This
    function takes three parameters: the first is the amount to be added to the sprite''s
    `width`, the second is the amount to be added to the sprite''s `height`, and the
    third is the `duration` of the animation.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func resizeByWidth(width: CGFloat, height: CGFloat, duration: NSTimeInterval)`:
    这个函数创建一个动作，调整精灵节点的尺寸。这个函数接受三个参数：第一个是添加到精灵 `width` 的量，第二个是添加到精灵 `height` 的量，第三个是动画的
    `duration`。'
- en: '`func resizeToHeight( height: CGFloat, duration: NSTimeInterval)`: This function
    creates an action that changes the `height` of a sprite to a new value. One parameter
    passed is the new `height` of the sprite, and the second parameter is the `duration`
    of the animation.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func resizeToHeight(height: CGFloat, duration: NSTimeInterval)`: 这个函数创建一个动作，将精灵的
    `height` 更改为新值。传递的一个参数是精灵的新 `height`，另一个参数是动画的 `duration`。'
- en: '`func resizeToWidth(width: CGFloat, duration: NSTimeInterval)`: This function
    creates an action that changes the `width` of a sprite to a new value. One parameter
    passed is the new `width` of the sprite, and the second parameter is the `duration`
    of the animation.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func resizeToWidth(width: CGFloat, duration: NSTimeInterval)`: 这个函数创建一个动作，将精灵的
    `width` 更改为新值。传递的一个参数是精灵的新 `width`，另一个参数是动画的 `duration`。'
- en: '`func resizeToWidth( width: CGFloat, height: CGFloat, duration: NSTimeInterval)`:
    This function creates an action that changes the `width` and `height` of a sprite
    node to a new value. You can specify the new `height` and `width` separately in
    this function. It takes three parameters: one is the new `width` of the sprite,
    the second is the new `height` of the sprite, and the third is the `duration`
    of the animation.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func resizeToWidth(width: CGFloat, height: CGFloat, duration: NSTimeInterval)`:
    这个函数创建一个动作，将精灵节点的 `width` 和 `height` 更改为新值。在这个函数中，您可以分别指定新的 `height` 和 `width`。它接受三个参数：一个是精灵的新
    `width`，二是精灵的新 `height`，三是动画的 `duration`。'
- en: '`func setTexture(texture: SKTexture)`: This function helps in creating an action
    that changes the sprite''s texture. Only one parameter is passed in this function,
    which is the sprite''s new `texture`.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func setTexture(texture: SKTexture)`: 这个函数有助于创建一个改变精灵纹理的动作。这个函数只传递了一个参数，即精灵的新
    `texture`。'
- en: '`func setTexture( texture: SKTexture, resize: Bool)`: This function helps in
    creating an action that changes the sprite''s texture. Along with this, you can
    also control whether the sprite should be resized to match the new texture or
    not. The two parameters passed are the new `texture` to use on the sprite and
    the Boolean to control the resizing.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func setTexture(texture: SKTexture, resize: Bool)`: 这个函数有助于创建一个改变精灵纹理的动作。除了这个之外，您还可以控制精灵是否应该调整大小以匹配新纹理。传递的两个参数是用于精灵的新
    `texture` 和控制调整大小的布尔值。'
- en: '`func animateWithTextures(textures: [AnyObject], timePerFrame sec: NSTimeInterval)`:
    This function creates an action that animates changes in a sprite''s texture.
    When the action executes, the `texture` property animates the array of the `texture`,
    which is passed as a parameter. The action continues until all the textures in
    the array have finished animating. Two parameters are passed in this function:
    one is the array of `textures`, and the other is the time in which each texture
    in the array will be displayed.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func animateWithTextures(textures: [AnyObject], timePerFrame sec: NSTimeInterval)`:
    这个函数创建一个动作，用于动画化精灵纹理的变化。当动作执行时，`texture` 属性会动画化传递作为参数的纹理数组。动作会持续进行，直到数组中的所有纹理都完成动画。这个函数传递了两个参数：一个是纹理数组，另一个是数组中每个纹理显示的时间。'
- en: '`func animateWithTextures( textures: [AnyObject], timePerFrame sec: NSTimeInterval,
    resize: Bool, restore: Bool)`: This function creates an action which animates
    changes to the sprite''s texture and can also resize the sprite to the new texture,
    if required. It takes four parameters: one is the array of `textures` that are
    used when animating the sprite, the second is the time in which each texture will
    be displayed, the third is a Boolean value to control the resizing of the sprite
    to match the new texture, and the fourth is the restoring of the size of the sprite
    to the original texture size.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func animateWithTextures(textures: [AnyObject], timePerFrame sec: NSTimeInterval,
    resize: Bool, restore: Bool)`: 这个函数创建一个动作，可以动画化精灵纹理的变化，并在需要时调整精灵大小以匹配新纹理。它接受四个参数：一个是用于动画精灵的纹理数组，第二个是每个纹理显示的时间，第三个是布尔值，用于控制精灵是否调整大小以匹配新纹理，第四个是恢复精灵大小到原始纹理大小。'
- en: '`func colorizeWithColor(color: UIColor, colorBlendFactor: CGFloat, duration
    sec: NSTimeInterval)`: This function creates an animation that animates a sprite''s
    color and blend factor. Three parameters are passed in this function: one is `color`
    for the new sprite, the second is the new blend factor, and the third is the `duration`
    of the animation.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func colorizeWithColor(color: UIColor, colorBlendFactor: CGFloat, duration
    sec: NSTimeInterval)`: 此函数创建一个动画，该动画会动画化精灵的颜色和混合因子。此函数中传递了三个参数：一个是用于新精灵的 `color`，第二个是新混合因子，第三个是动画的
    `duration`。'
- en: '`func colorizeWithColorBlendFactor( colorBlendFactor: CGFloat, duration sec:
    NSTimeInterval)`: This function will create an animation that animates the sprite''s
    blend factor. It takes two parameters: one is the new blend factor and the other
    is the `duration` of the animation.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func colorizeWithColorBlendFactor( colorBlendFactor: CGFloat, duration sec:
    NSTimeInterval)`: 此函数将创建一个动画，该动画会动画化精灵的混合因子。它接受两个参数：一个是新的混合因子，另一个是动画的 `duration`。'
- en: Some other important actions
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些其他重要的动作
- en: 'By now, we have discussed most of the important functions that are used to
    create actions on a node. Now, we are going to have a look at some other important
    functions used in creating actions on a node in Sprite Kit:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了大多数用于在节点上创建动作的重要函数。现在，我们将看看在 Sprite Kit 中创建节点动作的一些其他重要函数：
- en: '`func runAction( action: SKAction, onChildWithName name: String)`: This function
    will create an `action` that will, in turn, run an `action` on a node''s child.
    You pass the `action` to execute and take the `name` of the child object as parameters.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func runAction( action: SKAction, onChildWithName name: String)`: 此函数将创建一个
    `action`，然后在该节点的子节点上运行 `action`。您需要传递要执行的 `action` 和子对象的 `name` 作为参数。'
- en: '`func group( actions: [AnyObject])`: You can run a collection of `actions`
    in parallel, using this function''s action. It takes an array of `SKAction` objects
    as a parameter.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func group( actions: [AnyObject])`: 您可以使用此函数的动作并行运行一系列 `actions`。它接受一个 `SKAction`
    对象的数组作为参数。'
- en: '`func sequence( actions: [AnyObject])`: You can run a collection of actions
    sequentially, using this function''s action. It takes an array of `SKAction` objects
    as a parameter. The order of actions is the same as the order of actions passed
    in the array.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func sequence( actions: [AnyObject])`: 您可以使用此函数的动作按顺序运行一系列动作。它接受一个 `SKAction`
    对象的数组作为参数。动作的顺序与数组中传递的动作顺序相同。'
- en: '`func repeatAction( action: SKAction, count count: Int)`: You can create an
    action to repeat an action that is specified to repeat a number of times. The
    `action` to repeat and the `count` of repetitions are passed as parameters.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func repeatAction( action: SKAction, count count: Int)`: 您可以创建一个动作来重复指定次数的动作。将重复的动作和重复次数作为参数传递。'
- en: '`func repeatActionForever( action: SKAction)`: It creates an action that, in
    turn, repeats another action forever. It takes the `action` to repeat as a parameter.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func repeatActionForever( action: SKAction)`: 它创建一个动作，该动作会无限期地重复另一个动作。它接受要重复的动作作为参数。'
- en: '`func reversedAction()`: With this action, you can reverse the behavior of
    another action.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func reversedAction()`: 使用此动作，您可以反转另一个动作的行为。'
- en: Adding controls in Sprite Kit
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Sprite Kit 中添加控制
- en: 'Adding controls in a Sprite Kit doesn''t need any external predefined framework;
    we can implement the controls in Sprite Kit using the following methods:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Sprite Kit 中添加控制不需要任何外部预定义框架；我们可以使用以下方法在 Sprite Kit 中实现控制：
- en: Tapping
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击
- en: Gesture recognitions (swiping in any direction, pinching, rotating)
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手势识别（任意方向的滑动、捏合、旋转）
- en: Moving sprites using the accelerometer
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用加速度计移动精灵
- en: Let's discuss each of the preceding controls in detail and also how we can implement
    them in our game.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细讨论前面提到的每个控制，以及我们如何在游戏中实现它们。
- en: Node tapping and clicking
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 节点点击和双击
- en: 'We have four override methods for handling touch events with a `UIResponder`
    class, which is part of `UIKit` provided by Apple. Let''s learn about them:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有四个重载方法用于处理带有 `UIResponder` 类的触摸事件，这是 Apple 提供的 `UIKit` 的一部分。让我们来了解一下：
- en: '`func touchesBegan(touches:Set<NSObject>, withEvent event:UIEvent)`: This method
    is called whenever a user touches the view/window'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func touchesBegan(touches:Set<NSObject>, withEvent event:UIEvent)`: 当用户触摸视图/窗口时，会调用此方法'
- en: '`func touchesMoved(touches:Set<NSObject>, withEvent event:UIEvent)`: This method
    is called whenever a user moves his finger on the view/window'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func touchesMoved(touches:Set<NSObject>, withEvent event:UIEvent)`: 当用户在视图/窗口上移动手指时，会调用此方法'
- en: '`func touchesEnded(touches:Set<NSObject>, withEvent event:UIEvent)`: This method
    is called whenever a user removes the finger from view/window'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func touchesEnded(touches:Set<NSObject>, withEvent event:UIEvent)`: 当用户从视窗/窗口移除手指时，此方法会被调用'
- en: '`func touchesCancelled(touches:Set<NSObject>!, withEvent event:UIEvent!)`:
    This method is called whenever system events, such as low memory warnings and
    so on, happen'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func touchesCancelled(touches:Set<NSObject>!, withEvent event:UIEvent!)`:
    当系统事件发生时，如内存警告等，此方法会被调用'
- en: To implement an action when someone taps on a node on the scene, we will first
    get the tapped location on the scene, and if the tapped location is within the
    node's co-ordinate axis points, then we can define the actions for that tap. This
    will be implemented in the `touchesBegan()` method.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要在场景中的节点上点击时实现一个动作，我们首先获取场景上的点击位置，如果点击位置在节点的坐标轴点上，那么我们可以为该点击定义动作。这将在`touchesBegan()`方法中实现。
- en: Sprite Kit includes a category in `UITouch`; this is one of its best features.
    `UITouch` comes with two methods, namely, `locationInNode()` and `previousLocationInNode()`.
    These methods find the coordinates of a touch within an `SKNode` object's coordinate
    system.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Sprite Kit在`UITouch`中包含一个类别；这是其最佳特性之一。`UITouch`包含两个方法，即`locationInNode()`和`previousLocationInNode()`。这些方法在`SKNode`对象坐标系内找到触摸的坐标。
- en: In our game, we will use it to find out where the touch happened within the
    scene's coordinate system.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中，我们将使用它来确定触摸在场景坐标系中的位置。
- en: Gesture recognitions (swiping in any direction, pinching, or rotating)
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手势识别（在任何方向上滑动、捏合或旋转）
- en: If you need to detect gestures in your game, such as taps, pinches, pans, or
    rotations, it's extremely easy with Swift and the built-in `UIGestureRecognizer`
    classes.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要在游戏中检测手势，如点击、捏合、拖动或旋转，使用Swift和内置的`UIGestureRecognizer`类将非常容易。
- en: Following is a code snippet for gesture recognitions in Swift; it will implement
    swiping left, right, top, and bottom.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个Swift中手势识别的代码片段；它将实现左右、上下滑动。
- en: 'First, we set up four functions, one for each direction, to handle whatever
    we want to do when the user swipes the screen in those directions. Then, in the
    `didMoveToView` statement, we create the `UISwipeGestureRecognizer` variables
    for each direction and add them to the view. Notice the `action`: `selector` part
    of each, calls their respective functions in the following code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '首先，我们为每个方向设置四个函数，以便处理用户在屏幕上向这些方向滑动时想要执行的操作。然后，在`didMoveToView`语句中，我们为每个方向创建`UISwipeGestureRecognizer`变量并将它们添加到视图中。注意每个`action`:
    `selector`部分，在下面的代码中调用它们各自的功能：'
- en: '[PRE0]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Using the preceding code block, you can implement swipe control in a Sprite
    Kit game. When the user swipes in a particular direction, the `UISwipeGestureRecognizer`
    will recognize the direction of the user's swipe and the swipe gesture object
    will be added to the gesture through the `addGestureRecognizer()` method. So,
    the particular object will be sent for the function and the appropriate method
    will be called, and after that, the respective actions will be executed as desired.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的代码块，你可以在Sprite Kit游戏中实现滑动控制。当用户向特定方向滑动时，`UISwipeGestureRecognizer`将识别用户滑动方向，并通过`addGestureRecognizer()`方法将滑动手势对象添加到手势中。因此，特定的对象将被发送到函数，并调用适当的方法，然后执行相应的动作。
- en: Moving sprites with an accelerometer
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用加速度计移动精灵
- en: An accelerometer is a sensor that measures proper acceleration ("g-force").
    Proper acceleration is not the same as coordinate acceleration (rate of change
    of velocity). A lot of games use an accelerometer as a controller. We can also
    use it in our Sprite Kit game.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 加速度计是一种测量实际加速度（“g-force”）的传感器。实际加速度与坐标加速度（速度变化率）不同。许多游戏使用加速度计作为控制器。我们也可以在我们的Sprite
    Kit游戏中使用它。
- en: Let's have a look at how we can implement an accelerometer in a Sprite Kit game.
    We will not be using an accelerometer in our *Platformer* game, but it would be
    good to have knowledge of the same.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在Sprite Kit游戏中实现加速度计。我们不会在我们的*平台游戏*中使用加速度计，但了解相关知识会很好。
- en: 'As a primary point, we need to read values from the accelerometer, so we need
    to import the `CoreMotion` framework. Add the following line right after the `import
    SpriteKit` line:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 作为主要点，我们需要从加速度计读取值，因此我们需要导入`CoreMotion`框架。在`import SpriteKit`行之后添加以下行：
- en: '[PRE1]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `CMMotionManager` object is the gateway to the motion services provided
    by iOS. In the `didMoveToView` method, the custom code is executed. Let''s have
    a look at it:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMMotionManager` 对象是访问 iOS 提供的运动服务的入口。在 `didMoveToView` 方法中执行自定义代码。让我们看看它：'
- en: '[PRE2]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Please refer the comments in the preceding code to the following points:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考前面代码中的注释，以下是一些要点：
- en: The image will be loaded and centered in the main view.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图片将被加载并居中显示在主视图中。
- en: The `startAccelerometerUpdatesQueue` method reads input from the accelerometer
    and constantly gets new updates.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`startAccelerometerUpdatesQueue` 方法读取加速度计的输入并持续获取新的更新。'
- en: If the acceleration value is negative, the value is subtracted from the `x`
    position, hence the airplane will move left. If the acceleration value is positive,
    the value will be added to the `x` position.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果加速度值是负数，则从 `x` 位置减去该值，因此飞机将向左移动。如果加速度值是正数，则将该值添加到 `x` 位置。
- en: The actual movement will be done on the update method, which will be called
    at each frame.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实际移动将在更新方法中完成，该方法将在每一帧被调用。
- en: '[PRE3]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A `moveToX` action is assigned to the airplane. This code will be a helpful
    reference if you want to implement accelerometer for controlling a game. Now,
    let's read about SceneKit.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `moveToX` 动作分配给飞机。如果你想要实现用于控制游戏的加速度计，这段代码将是一个有用的参考。现在，让我们来了解一下 SceneKit。
- en: An introduction to SceneKit
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SceneKit 简介
- en: SceneKit is a framework that can be used to implement the features of 3D graphic
    components into our iOS games. SceneKit provides a facility for integrating a
    high performance rendering engine at a greater level. It also offers a facility
    for importing, manipulating, and rendering 3D graphic assets.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: SceneKit 是一个框架，可以用来将 3D 图形组件的功能实现到我们的 iOS 游戏中。SceneKit 提供了一种在更高层次上集成高性能渲染引擎的设施。它还提供了导入、操作和渲染
    3D 图形资源的设施。
- en: It is fairly easy in iOS 8, to integrate SceneKit elements in a Sprite Kit game.
    First of all, you just have to import the SceneKit framework in the required Sprite
    Kit class. Then, you are all set to access all the methods and properties of SceneKit.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在 iOS 8 中，将 SceneKit 元素集成到 Sprite Kit 游戏中相当简单。首先，你只需要在所需的 Sprite Kit 类中导入 SceneKit
    框架。然后，你就可以访问 SceneKit 的所有方法和属性了。
- en: Adding animations and controls in our Platformer game
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的 Platformer 游戏中添加动画和控制
- en: After discussing about the `SKAction` class and various methods to add controls
    in our game, it's time to revisit our *Platformer* game and implement some of
    them.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了 `SKAction` 类和向我们的游戏添加控制的各种方法之后，是时候回顾我们的 *Platformer* 游戏，并实现其中的一些方法了。
- en: Adding actions
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加动作
- en: Now, it's time to add actions in our game. Let's start with adding animation
    to the player and block collision. Until the last chapter, there was no collision
    effect between the player and the blocks.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候在我们的游戏中添加动作了。让我们从给玩家和方块碰撞添加动画开始。直到最后一章，玩家和方块之间没有碰撞效果。
- en: Here we will add collision between the block and the player. Along with this,
    we can make the player die in an animated way. We can denote the animation after
    the player and block collision as a player death animation.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将添加方块和玩家的碰撞。同时，我们可以让玩家以一种动画的方式死亡。我们可以将玩家和方块碰撞后的动画表示为玩家死亡动画。
- en: First of all, we will update the maximum size of the X-axis for the blocks,
    because currently, the blocks are being destroyed before the end of the running
    bar. Hence, we will replace the respective code with an updated one.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将更新方块 X 轴的最大尺寸，因为目前方块在跑步条结束之前就被销毁了。因此，我们将用更新的代码替换相应的代码。
- en: Replace `self.blockMaxX = 0 - self.block1.size.width / 2` with `self.blockMaxX
    = 0 - self.runningBar.size.width` in the `addBlocks()` method, in the `GameScene.swift`
    file.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `GameScene.swift` 文件中的 `addBlocks()` 方法中，将 `self.blockMaxX = 0 - self.block1.size.width
    / 2` 替换为 `self.blockMaxX = 0 - self.runningBar.size.width`。
- en: Now, we will work on the part where the block and the player collides. For this,
    we will use a library method function, `didBeginContact()`, which is called when
    the collision happens, as we have already set all the required physics properties
    such as, `contactTestBitMask`, `categoryBitMask`, and `collisionBitMask` for the
    blocks and the player in the `addBlocks()` method, in the `GameScene.swift` file.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将处理方块和玩家碰撞的部分。为此，我们将使用库方法函数 `didBeginContact()`，当发生碰撞时会被调用，因为我们已经在 `GameScene.swift`
    文件中的 `addBlocks()` 方法中设置了所有必要的物理属性，例如，`contactTestBitMask`、`categoryBitMask` 和
    `collisionBitMask` 对于方块和玩家。
- en: 'Include the `didBeginContact()` method and add the following code, in which
    we are defining actions when the player and the block collide:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 包含`didBeginContact()`方法，并添加以下代码，其中我们定义了玩家和方块碰撞时的动作：
- en: '[PRE4]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding function, we used `inOutWhenPlayerDied` for scaling a player
    by multiplying a float value of `0.5` and also specifying the `duration` as `0.5`
    seconds. In `upActionWhenPlayerDied`, we moved the player along the y-axis by
    multiplying the player's `height` with a float value `4`, with the duration of
    animation as `2` seconds.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的函数中，我们使用`inOutWhenPlayerDied`通过乘以浮点值`0.5`来缩放玩家，并指定`duration`为`0.5`秒。在`upActionWhenPlayerDied`中，我们通过将玩家的`height`乘以浮点值`4`，动画持续时间为`2`秒，沿着y轴移动玩家。
- en: After these animations, we should also remove the player from the scene, and
    also from the node tree. This is taken care of by `removeFromParent`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些动画之后，我们还应该从场景和节点树中移除玩家。这是由`removeFromParent`处理的。
- en: Next, we call the action in the desired sequence.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们按照所需的顺序调用动作。
- en: 'If you notice in the preceding function that we just added in our *Platformer*
    game, when calling the sequence, we have also reversed an action by using `reversedAction()`.
    We also call the `gotoMenuScreen` function in our sequence. Let''s discuss about
    the same:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到的函数，我们刚刚添加到我们的*Platformer*游戏中，在调用序列时，我们还通过使用`reversedAction()`反转了一个动作。我们还调用了`gotoMenuScreen`函数。让我们讨论一下相同的内容：
- en: 'This is how our game will look after adding this action sequence:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 添加此动作序列后，我们的游戏将看起来像这样：
- en: '![Adding actions](img/4201_06_01.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![添加动作](img/4201_06_01.jpg)'
- en: The animation for when the player collides with a block.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家与方块碰撞时的动画。
- en: Transiting from GameScene to MenuScene
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从GameScene过渡到MenuScene
- en: 'After the player''s death, it is time to call the `gotoMenuScreen()` method
    for transiting to the `MenuScreen`. Add the following function in the `GameScene`
    class to do the same:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家死亡后，是时候调用`gotoMenuScreen()`方法以过渡到`MenuScreen`了。在`GameScene`类中添加以下函数来完成此操作：
- en: '[PRE5]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'A slight glimpse of the transition:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 略微一瞥过渡效果：
- en: '![Transiting from GameScene to MenuScene](img/4201_06_02.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![从GameScene过渡到MenuScene](img/4201_06_02.jpg)'
- en: The door close transition after the player's death.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家死亡后的门关闭过渡。
- en: Adding controls in our game
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在我们的游戏中添加控制
- en: For controlling the player, we can make him jump over the blocks and save him
    from dying. Currently, this is being done by tapping on the player, but it is
    better to have a button for this action.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制玩家，我们可以让他跳过方块并救他免于一死。目前，这是通过点击玩家来完成的，但有一个按钮执行此动作会更好。
- en: 'To implement the **JUMP** button in our game, first we need to create a sprite
    node for the **JUMP** button in the `GameScene.swift` file. Create a sprite node
    with the name, `btnjump`, and then assign the node with an image for the button;
    we can call the image `jump`. Add the following code for this feature:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的游戏中实现**JUMP**按钮，首先我们需要在`GameScene.swift`文件中为**JUMP**按钮创建一个精灵节点。创建一个名为`btnjump`的精灵节点，然后为节点分配一个按钮图像；我们可以将其命名为`jump`。为此功能添加以下代码：
- en: '[PRE6]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, we need to position our button on the `GameScene`. For this, we can add
    the following code before the `addBackground()` function call in the `didMoveToView()`
    method.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将我们的按钮放置在`GameScene`上。为此，我们可以在`didMoveToView()`方法中调用`addBackground()`函数之前添加以下代码。
- en: '[PRE7]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And now your `didMoveToView()` function should look like the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的`didMoveToView()`函数应该看起来像以下这样：
- en: '[PRE8]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Till now, we have just added the **JUMP** button on scene but we didn''t define
    the action of when the button will be clicked. So, let''s write a block of code
    for performing this action:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是在场景中添加了**JUMP**按钮，但尚未定义按钮被点击时的动作。因此，让我们为执行此动作编写一段代码块：
- en: '[PRE9]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add the preceding block of code in the `touchesBegan` method of `GameScene.swift`.
    Now your `touchesBegan()` method function should look like the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GameScene.swift`的`touchesBegan`方法中添加前面的代码块。现在你的`touchesBegan()`方法函数应该看起来像以下这样：
- en: '[PRE10]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Following is how the `GameScene` will look after adding the **JUMP** button:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是添加**JUMP**按钮后`GameScene`的外观：
- en: '![Adding controls in our game](img/4201_06_03.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![在我们的游戏中添加控制](img/4201_06_03.jpg)'
- en: The JUMP button now appears on the screen
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: JUMP按钮现在出现在屏幕上
- en: 'Now, if you run the game, there will be two major changes: one is the animation
    of the player''s death during collision with the blocks, and the other is the
    **JUMP** button to make the player jump over the blocks.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你运行游戏，将有两个主要变化：一个是玩家与方块碰撞时玩家死亡动画，另一个是**JUMP**按钮，使玩家能够跳过方块。
- en: Summary
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we learned about the `SKAction` class in detail; this class
    is responsible for creating actions for nodes. We also discussed about various
    types of controls by which a Sprite Kit game can be played (such as, tapping,
    gesture recognition, and accelerometer). We also read about SceneKit and how we
    can integrate SceneKit in a Sprite Kit game. Now, our *Platformer* game has two
    new features. One is the player's death animation and the other is the **JUMP**
    button to control the player's jump.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细学习了`SKAction`类；这个类负责为节点创建动作。我们还讨论了各种控制方式，通过这些方式可以玩Sprite Kit游戏（例如，点击、手势识别和加速度计）。我们还阅读了关于SceneKit的内容以及如何在Sprite
    Kit游戏中集成SceneKit。现在，我们的*平台游戏*有了两个新功能。一个是玩家的死亡动画，另一个是控制玩家跳跃的**跳跃**按钮。
- en: In the next chapter, we will learn about the particle system and shaders. Along
    with this, we will also add particle effects in our *Platformer* game, to enhance
    gameplay experience.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习粒子系统和着色器。与此同时，我们还将在我们的*平台游戏*中添加粒子效果，以增强游戏体验。
