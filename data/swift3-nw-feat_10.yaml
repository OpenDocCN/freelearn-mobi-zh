- en: Chapter 10. Exploring Swift on the Server
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章. 在服务器上探索 Swift
- en: Unless you're making a really basic app, chances are that you will need some
    form of server backend to make your app really useful. Swift running on Linux
    is a big deal, especially with Linux's popularity for hosting and running servers.
    Swift 3 opens up possibilities for developers to create server-side applications
    using the same Swift that they use to create applications on iOS, macOS, tvOS,
    and watchOS. By the end of this chapter, you will have a server-side app written
    completely in Swift that can run seamlessly on a Linux box.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 除非您正在制作一个非常基础的应用程序，否则您很可能需要某种形式的后端服务器来使您的应用程序真正有用。Swift 在 Linux 上运行是一个大事件，尤其是考虑到
    Linux 在托管和运行服务器方面的普及。Swift 3 为开发者打开了使用与他们在 iOS、macOS、tvOS 和 watchOS 上创建应用程序相同的
    Swift 创建服务器端应用程序的可能性。在本章结束时，您将拥有一个完全使用 Swift 编写的服务器端应用程序，它可以在 Linux 服务器上无缝运行。
- en: IBM Swift Package catalog
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IBM Swift 包目录
- en: In [Chapter 2](ch02.html "Chapter 2. Discovering New Territories – Linux at
    Last!"), *Discovering New Territories* – *Linux at Last!* we covered installing
    Swift toolchains and configuring environments for Linux. We wrote our first program
    in Swift and leveraged the Swift Package Manager to manage our dependencies. With
    the basics out of the way, I want to mention IBM's Swift Package Catalog.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 2 章](ch02.html "第 2 章. 发现新领域 – Linux 终于来了！") 中，我们介绍了在 Linux 上安装 Swift 工具链和配置环境的步骤。我们用
    Swift 编写了第一个程序，并利用 Swift 包管理器来管理我们的依赖项。在完成基础知识后，我想提及 IBM 的 Swift 包目录。
- en: The IBM Swift Package Catalog is a site that hosts links to Swift libraries
    and modules that you can use with the Swift Package Manager. IBM wants it to be
    a community resource for developers to find and share code for their projects.
    You can find the site listed at the following link [https://developer.ibm.com/swift/the-ibm-swift-package-catalog](https://developer.ibm.com/swift/the-ibm-swift-package-catalog).
    You should definitely keep this link handy, as it will be a site that you will
    use often. You can explore projects based on rank, popularity, or keywords.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: IBM Swift 包目录是一个托管 Swift 库和模块链接的网站，您可以使用 Swift 包管理器使用这些库和模块。IBM 希望它成为一个社区资源，让开发者能够找到并分享他们项目的代码。您可以在以下链接中找到该网站：[https://developer.ibm.com/swift/the-ibm-swift-package-catalog](https://developer.ibm.com/swift/the-ibm-swift-package-catalog)。您绝对应该保留这个链接，因为它将是一个您经常使用的网站。您可以根据排名、受欢迎程度或关键词探索项目。
- en: Introducing our server project
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍我们的服务器项目
- en: Let's go out with a bang! For this last chapter, we are going to create a small
    project to test developing a server app in Swift. We will use the IBM Swift Package
    Catalog to find a web server framework. I really like using Slack for team communication.
    If you haven't tried it, you should consider evaluating whether it could be a
    good tool for your team. One of the powerful features of Slack is the array of
    integration options you have to customize the experience for your team. Slack
    has opened many of its APIs to developers for customization and integration. Slack
    even provides an App Store for users to add third-party apps that their teams
    can use together. The catch, if there is one, is that your third-party app or
    integration has to be hosted on an outside server. We are going to create a Slack
    integration that you can later modify into a full Slack app of your own. Our Slack
    integration will be written entirely in Swift, and it could be hosted on a Linux
    virtual machine in the cloud with a provider such as Heroku, Digital Ocean, or
    Amazon Web Services.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一场盛宴结束！对于最后一章，我们将创建一个小项目来测试使用 Swift 开发服务器应用程序。我们将使用 IBM Swift 包目录来查找网络服务器框架。我非常喜欢使用
    Slack 进行团队沟通。如果您还没有尝试过，您应该考虑评估它是否可以成为您团队的好工具。Slack 的一个强大功能是您有一系列集成选项可以自定义团队体验。Slack
    已经向开发者开放了许多 API，以便进行定制和集成。Slack 甚至为用户提供了一个应用商店，让他们可以添加第三方应用程序，以便团队共同使用。唯一的缺点是，您的第三方应用程序或集成必须托管在外部服务器上。我们将创建一个
    Slack 集成，您稍后可以将其修改成您自己的完整 Slack 应用程序。我们的 Slack 集成将完全使用 Swift 编写，并且可以托管在云中的 Linux
    虚拟机上，例如 Heroku、Digital Ocean 或亚马逊网络服务。
- en: Note
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can download the code for this project from [http://www.packtpub.com/support](http://www.packtpub.com/support)
    .
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 [http://www.packtpub.com/support](http://www.packtpub.com/support) 下载此项目的代码。
- en: Project description and dependencies
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目描述和依赖项
- en: Our project needs a web server framework to work properly. We could write one
    from scratch, or we could see what third-party frameworks are available. Using
    the IBM Swift Package Catalog, I found several web application frameworks that
    are highly rated and are both actively developed and popular with developers.
    IBM's Kitura, Perfect by PerfectlySoft, and Vapor by Vapor are all viable candidates
    from which to choose. Each of these projects will feel familiar to you if you
    have ever dabbled with Node.js and Express, or with Ruby on Rails. While any of
    these frameworks would work for our project, I selected the Vapor project for
    our app because it was at the top of the list in the "essential" category at the
    time I was writing this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目需要一个能够正常工作的网络服务器框架。我们可以从头开始编写一个，或者查看可用的第三方框架。使用IBM Swift包目录，我找到了几个高度评价且正在积极开发且深受开发者喜爱的网络应用框架。IBM的Kitura、Perfect
    by PerfectlySoft和Vapor by Vapor都是可行的候选框架。如果你曾经接触过Node.js和Express，或者Ruby on Rails，那么这些项目对你来说都会感到熟悉。虽然这些框架中的任何一个都可以用于我们的项目，但我选择了Vapor项目作为我们的应用程序，因为它在我编写这一章的时候在“基本”类别中排名首位。
- en: According to Vapor, their project is the most used web framework written for
    Swift. You can learn more about Vapor, including the Swift version it supports
    and links to the documentation, at [https://swiftpkgs.ng.bluemix.net/package/vapor/vapor](https://swiftpkgs.ng.bluemix.net/package/vapor/vapor).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Vapor的说法，他们的项目是最常用的Swift编写的网络框架。你可以了解更多关于Vapor的信息，包括它支持的Swift版本和文档链接，请访问[https://swiftpkgs.ng.bluemix.net/package/vapor/vapor](https://swiftpkgs.ng.bluemix.net/package/vapor/vapor)。
- en: Now that we have covered the libraries and frameworks that we will use, let
    me give you a description of the server application that we will be building together.
    Slack gives developers the option to create custom integrations for their own
    team or to make Slack apps that would be available to any team. We are going to
    create a custom integration for a single team. However, you could easily convert
    our customization into a full app for any team to discover.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了我们将要使用的库和框架，让我给你描述一下我们将一起构建的服务器应用程序。Slack为开发者提供了创建自定义集成或制作可供任何团队使用的Slack应用程序的选项。我们将为单个团队创建一个自定义集成。然而，你可以轻松地将我们的定制转换为任何团队都可以发现的全功能应用程序。
- en: We are going to build a storefront web application to sell widgets. As a user
    purchases a widget from us, we will process the order and send the order to our
    order-tracking channel in Slack. In the interest of keeping this application simple,
    we are going to take some shortcuts.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个用于销售小工具的店面网络应用程序。当用户从我们这里购买小工具时，我们将处理订单并将订单发送到我们的Slack订单跟踪频道。为了保持这个应用程序的简单性，我们将采取一些捷径。
- en: Setting up our environment and project
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置我们的环境和项目
- en: Since you learned how to install Swift in [Chapter 2](ch02.html "Chapter 2. Discovering
    New Territories – Linux at Last!"), *Discovering New Territories – Linux at Last!* we
    will skip over that step and move on to installing the Vapor framework. We are
    going to add Vapor's command line toolkit to gain access to shortcut commands
    and assistance for common tasks.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你在[第2章](ch02.html "第2章. 发现新大陆 – Linux终于来了！")中学习了如何安装Swift，我们将跳过这一步，直接进入安装Vapor框架。我们将添加Vapor的命令行工具包，以便访问快捷命令和常见任务的辅助功能。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can find detailed links to documentation and examples on how to use Vapor
    at [https://vapor.github.io/documentation/](https://vapor.github.io/documentation/).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://vapor.github.io/documentation/](https://vapor.github.io/documentation/)找到详细的文档链接和使用Vapor的示例。
- en: 'Here''s how you do it:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何做的：
- en: 'To install the toolkit, run the following command in a terminal:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装工具包，请在终端中运行以下命令：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can verify that the command worked by running:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行以下命令来验证命令是否成功：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, let''s create a new Vapor project and name it `storefront`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个新的Vapor项目，并将其命名为`storefront`：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Our newly created project will have the following file structure:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们新创建的项目将具有以下文件结构：
- en: '![Setting up our environment and project](img/image_10_001.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![设置我们的环境和项目](img/image_10_001.jpg)'
- en: The file structure should be familiar to you, as it follows the structure required
    for the Swift Package Manager to work. Under the cover, vapor creates a new project
    with *swift package init--type executable*. The Vapor script also adds the vapor
    framework as a dependency in `Package.swift`. Our `main.swift` is our entry point,
    since we created an executable program.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 文件结构应该对你来说很熟悉，因为它遵循Swift Package Manager所需的结构。在幕后，vapor使用`swift package init--type
    executable`创建一个新的项目。Vapor脚本还将在`Package.swift`中将vapor框架作为依赖项添加。我们的`main.swift`是我们的入口点，因为我们创建了一个可执行程序。
- en: 'I''m going to develop my code on a Mac and then deploy it to a Linux VM in
    the cloud. For me, the benefit is that I can use Xcode and it''s debugging tools
    for my local development. In fact, the Vapor framework supports this concept by
    offering a command in their toolkit to generate an Xcode project for development.
    Let''s create an Xcode project that we can use for development of our *storefront*
    app:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我打算在我的Mac上开发我的代码，然后将其部署到云中的Linux虚拟机。对我来说，好处是，我可以使用Xcode及其调试工具进行本地开发。实际上，Vapor框架通过提供工具包中的命令来生成用于开发的Xcode项目，支持这一概念。让我们创建一个可以用于我们*店面*应用开发的Xcode项目：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When Vapor creates a companion Xcode project, it first checks to see if you
    are missing any dependencies specified in the Package.swift file. Vapor will download
    any missing dependencies for you, prior to creating the Xcode Project. In addition,
    Vapor will create a scheme to use for running your app in Xcode. Finally, Vapor
    will show you which toolchain the Xcode project expects to be linked against:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当Vapor创建一个配套的Xcode项目时，它首先检查你是否缺少在`Package.swift`文件中指定的任何依赖项。在创建Xcode项目之前，Vapor会为你下载任何缺少的依赖项。此外，Vapor将创建一个用于在Xcode中运行你的应用程序的方案。最后，Vapor将显示Xcode项目期望链接的哪个工具链：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Whenever you create new dependencies for your project, you have to rebuild
    the project so that the Swift Package Manager can download your new dependency
    before attempting to compile your code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你为项目创建新的依赖项时，你必须重新构建项目，以便Swift Package Manager可以在尝试编译你的代码之前下载你的新依赖项：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let's take a quick look at `Package.swift` to see what the Vapor create command
    generated for us. We can configure the name of the app with something that better
    suits our project. The current default name is `VaporApp`, but we could change
    this to `Storefront`. You should also notice that the vapor framework is added
    for us as a dependency.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速查看`Package.swift`文件，看看Vapor为我们创建了什么。我们可以使用更适合我们项目的名称来配置应用程序的名称。当前的默认名称是`VaporApp`，但我们可以将其更改为`Storefront`。你也应该注意到，vapor框架已作为依赖项为我们添加。
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When you use the Vapor CLI to create a new project, Vapor adds example code
    with documentation to project. Open `main.swift` and glance over the included
    routes and comments. Delete everything in this file, and we will be build our
    app from scratch.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用Vapor CLI创建新项目时，Vapor会在项目中添加带有文档的示例代码。打开`main.swift`并浏览包含的路由和注释。删除此文件中的所有内容，我们将从头开始构建我们的应用程序。
- en: The Vapor framework
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Vapor框架
- en: In Vapor terminology, a Droplet is a service container that acts as a gateway
    to Vapor's service offerings. Use a Droplet to register routes and add middleware
    to start your server. To get things started, we need to import Vapor and create
    an instance of a Droplet.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vapor术语中，Droplet是一个服务容器，充当Vapor服务提供的网关。使用Droplet注册路由并添加中间件以启动服务器。为了开始，我们需要导入Vapor并创建一个Droplet实例。
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can also customize the behavior of our Droplet instance via properties. You
    can read more about options in Vapor's documentation.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过属性来定制我们的Droplet实例的行为。你可以在Vapor的文档中了解更多关于选项的信息。
- en: Routing
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路由
- en: 'Now that we have a Droplet instance, we need to talk about routing. Routing
    is an essential function for every web framework. When an incoming request is
    received, we need to have a way to appropriately filter and handle each request.
    Vapor gives you multiple options for addressing your routing concerns. We are
    going to create two routes for our application: one to serve our shop page, and
    the other to respond to *post* requests when a user purchases an item on our page.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了Droplet实例，我们需要讨论路由。路由是每个Web框架的基本功能。当接收到一个传入请求时，我们需要有一种适当过滤和处理每个请求的方法。Vapor为你提供了多种解决路由问题的选项。我们将为我们的应用程序创建两个路由：一个用于服务我们的商店页面，另一个用于当用户在我们的页面上购买商品时响应*post*请求。
- en: A basic route in Vapor is composed of a method, path, and closure. Two of our
    routes fall into this category. Vapor routing supports the standard RESTful HTTP
    methods (get, post, put, patch, delete, and options). We register routes by calling
    the corresponding method on our Droplet instance, passing in our route path and
    returning a closure we define.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vapor中，一个基本的路由由一个方法、路径和闭包组成。我们的两个路由属于这一类别。Vapor路由支持标准的RESTful HTTP方法（get、post、put、patch、delete和options）。我们通过在Droplet实例上调用相应的方法来注册路由，传递我们的路由路径，并返回我们定义的闭包。
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Our first route handles all *get* requests for the root directory of our website.
    When this route is requested, we return the `shop.html` view. Our second route
    handles *post* requests for the `/purchase` route. Once we finish carrying out
    work, we return a response to the requester with a status and JSON payload.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一条路由处理我们网站根目录的所有*get*请求。当请求此路由时，我们返回`shop.html`视图。我们的第二条路由处理`/purchase`路由的*post*请求。一旦我们完成工作，我们就向请求者返回一个带有状态和JSON有效负载的响应。
- en: Vapor also supports nested routes and parameters. Creating a nested route is
    as easy as replacing the forward slashes in the URL with commas when registering
    your route.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Vapor还支持嵌套路由和参数。创建一个嵌套路由就像在注册路由时将URL中的正斜杠替换为逗号一样简单。
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Vapor handles parameters by making them type safe. Many web frameworks default
    to using strings for route parameters and types, which can be error prone. Using
    Swift's closures allows for a safer way to access route parameters. In the following
    example, we define the route to accept an *Int* parameter. Our route matches *artboard/:id*
    where our *:id* parameter must be an Integer value.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Vapor通过使参数类型安全来处理参数。许多Web框架默认使用字符串作为路由参数和类型，这可能导致错误。使用Swift的闭包允许更安全地访问路由参数。在以下示例中，我们定义了一个接受*Int*参数的路由。我们的路由匹配*artboard/:id*，其中我们的*：id*参数必须是一个整数值。
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We could have also written this without using route parameters and then access
    our parameters on the request object.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以不使用路由参数来编写这个，然后通过请求对象访问我们的参数。
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Creating views
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建视图
- en: When you want to send HTML from your application, you create views. You can
    create a view from an HTML document or you can build your views using renderers
    like Mustache. By default, views are stored in the *Resources/Views* directory.
    Going back to the first route registered for our root directory, we used a view
    to return an HTML document (`shop.html`). You create an instance of a view by
    calling the `view.make` method on your Droplet instance.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想从你的应用程序发送HTML时，你创建视图。你可以从一个HTML文档创建视图，或者使用Mustache等渲染器构建你的视图。默认情况下，视图存储在*Resources/Views*目录中。回到为我们根目录注册的第一个路由，我们使用视图返回一个HTML文档（`shop.html`）。你通过在Droplet实例上调用`view.make`方法来创建视图的实例。
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: More complex documents, such as mustache templates, need more information to
    process and create a view. This additional information is passed to the *view.make*
    method as the second argument.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的文档，如mustache模板，需要更多信息来处理和创建视图。这些附加信息作为第二个参数传递给*view.make*方法。
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Public resources
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 公共资源
- en: For the most part, we want all of our server code and files protected from snooping
    eyes and web crawlers. Vapor handles that for us. When we need to provide resources
    that are reachable from our views, we use the `Public` folder created at the root
    of our application. We will store our images, scripts, and styles nested under
    the `Public` folder.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大部分情况，我们希望我们的服务器代码和文件免受窥探的眼睛和网页爬虫的侵害。Vapor为我们处理这个问题。当我们需要提供可以从我们的视图中访问的资源时，我们使用在应用程序根目录下创建的`Public`文件夹。我们将我们的图片、脚本和样式存储在`Public`文件夹的嵌套目录中。
- en: Defining our shop view
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义我们的商店视图
- en: When we serve the root level document on our application, we return a `shop.html`
    view. Our simple page displays a welcome message and details of three products.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在应用程序上提供根级文档时，我们返回一个`shop.html`视图。我们的简单页面显示一条欢迎信息和三个产品的详细信息。
- en: '![Defining our shop view](img/image_10_002.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![定义我们的商店视图](img/image_10_002.jpg)'
- en: When a user clicks the buy now button, we execute a jQuery Ajax post command
    to communicate with our server. We send the product ID of the product we want
    to purchase to our `"/purchase"` route.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击“立即购买”按钮时，我们执行一个jQuery Ajax post命令与我们的服务器通信。我们将我们想要购买的产品ID发送到我们的`"/purchase"`路由。
- en: On the server, when we receive a request that matches this route, we extract
    the product ID and search for a matching product in our local store. Of course,
    in a production app, we would use a database to house our products and even populate
    our store listings. In situations where we can't find a valid product ID on our
    request object or where we can't find a matching product for a supplied product
    ID, we throw an error that is sent back to the client.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器上，当我们收到与这个路由匹配的请求时，我们会提取产品 ID 并在我们的本地商店中搜索匹配的产品。当然，在一个生产应用中，我们会使用数据库来存储我们的产品，甚至填充我们的商店列表。在无法在我们的请求对象中找到有效的产品
    ID 或无法为提供的产品 ID 找到匹配的产品的情况下，我们会抛出一个错误，并将其发送回客户端。
- en: Finally, we create a JSON payload that contains some of our product details
    and return it to the client with a successful status code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建一个包含我们产品的一些详细信息的 JSON 负载，并带有成功的状态码将其返回给客户端。
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When our client receives the post response, we display an alert dialog that
    thanks the user for their purchase. We also display the returned JSON data in
    a console.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的客户端收到 post 响应时，我们会显示一个感谢用户购买的提示对话框。我们还在控制台中显示返回的 JSON 数据。
- en: Slack integration
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Slack 集成
- en: Now that we covered the basics of our web app, let's make it a bit more interesting
    by integrating with Slack. Using Slack's APIs, we can extend Slack to make our
    workflow better. In our case, we want to notify our operations team of new orders
    so that they can immediately start processing them. We are going to take advantage
    of incoming webhooks to send messages into Slack from our Swift server. While
    this webhook will only be for our team, you can read the documentation [https://api.slack.com/](https://api.slack.com/)
    and easily convert our custom integration into a Slack app that any team could
    incorporate into their workflows.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了我们网络应用的基础，让我们通过集成 Slack 来让它变得更有趣。使用 Slack 的 API，我们可以扩展 Slack，使我们的工作流程更加完善。在我们的案例中，我们希望通知我们的运营团队新的订单，以便他们可以立即开始处理。我们将利用
    incoming webhooks 从我们的 Swift 服务器向 Slack 发送消息。虽然这个 webhook 只会用于我们的团队，但你可以在[https://api.slack.com/](https://api.slack.com/)的文档中阅读，并轻松地将我们的自定义集成转换为任何团队都可以将其纳入其工作流程的
    Slack 应用。
- en: Making a custom integration
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建自定义集成
- en: 'Since our custom integration will only work with a single Slack team, you will
    need to create an account and team on Slack if you don''t already have one. Once
    you do that, you can navigate to the build section of the Slack app directory
    located at :'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的自定义集成只与单个 Slack 团队一起工作，如果你还没有，你需要创建一个 Slack 账户和团队。一旦你这样做，你可以导航到 Slack 应用目录的构建部分，位于：
- en: Click on the **Make a Custom Integration** button.![Making a custom integration](img/image_10_003.jpg)
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“**创建自定义集成**”按钮。![创建自定义集成](img/image_10_003.jpg)
- en: Select the **Incoming WebHooks** link next.![Making a custom integration](img/image_10_004.jpg)
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来选择“**Incoming WebHooks**”链接。![创建自定义集成](img/image_10_004.jpg)
- en: Choose a channel to post your messages to or create a new channel. I chose to
    send my messages to my orders channel. After picking your channel, press the "**Add
    Incoming WebHooks integration**" button.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个频道来发布你的消息或者创建一个新的频道。我选择将我的消息发送到我的订单频道。选择好你的频道后，点击“**添加 incoming WebHooks
    集成**”按钮。
- en: '![Making a custom integration](img/image_10_005.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![创建自定义集成](img/image_10_005.jpg)'
- en: On this view, you can see instructions for setting things up as well as the
    fields you can customize for your use case. You can provide an optional descriptive
    label for this integration along with a user name. The default name is `incoming-webhook`,
    but I changed mine to `OrderUp`. I also added an emoji to serve as my icon for
    the messages I add to this channel. Once you have previewed your settings, you
    just need to click on the **Save Settings** button to make your changes go live.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个视图中，你可以看到设置说明以及你可以为你的用例自定义的字段。你可以为这个集成提供一个可选的描述性标签以及用户名。默认名称是 `incoming-webhook`，但我将其改为了
    `OrderUp`。我还添加了一个表情符号，作为我添加到这个频道的消息的图标。一旦你预览了你的设置，你只需点击“**保存设置**”按钮，你的更改就会生效。
- en: Updating our server to post to Slack
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新我们的服务器以向 Slack 发布
- en: 'Before we close this view, we need to copy the Webhook URL to use from our
    external service. You can click on the **Copy URL** button, and it will be added
    to your clipboard. Let''s head back to Swift and open `main.swift`. Update your
    purchase route to create a JSON payload for Slack to send our post request to
    Slack''s servers:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们关闭这个视图之前，我们需要将 Webhook URL 复制到我们的外部服务中。你可以点击 **复制 URL** 按钮，它将被添加到你的剪贴板。让我们回到
    Swift 并打开 `main.swift`。更新你的购买路由以创建 Slack 发送 POST 请求到 Slack 服务器的 JSON 有效负载：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Our formatted message payload sends a general message, which will show up in
    your Slack notifications on desktop and mobile (`"New purchase Request"`). We
    also use the attachment syntax to provide details on the product order. We pass
    the product name and price.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们格式化的消息有效负载发送了一条通用消息，该消息将在你的桌面和移动端 Slack 通知中显示（`"New purchase Request"`）。我们还使用附件语法提供了有关产品订单的详细信息。我们传递了产品名称和价格。
- en: Now, when you make a purchase on the website, you will also get a real-time
    message sent to the orders channel in Slack for your team.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你在这个网站上购买时，你还会收到一条实时消息发送到 Slack 的订单频道。
- en: '![Updating our server to post to Slack](img/image_10_007.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![更新我们的服务器以向 Slack 发布](img/image_10_007.jpg)'
- en: Summary
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored Swift on the server. We developed a web application
    that runs entirely in Swift. Our application also communicates with Slack to post
    messages. We used the Vapor web framework to create a Swift web server, and you
    learned how to call Slack webhooks from Swift. While our example was fairly simple,
    it is easy to see how we could expand it to a larger and more complex application
    leveraging the power of Swift.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了服务器上的 Swift。我们开发了一个完全用 Swift 运行的 Web 应用程序。我们的应用程序还与 Slack 通信以发布消息。我们使用
    Vapor Web 框架创建了一个 Swift Web 服务器，并学习了如何从 Swift 调用 Slack Webhooks。虽然我们的例子相当简单，但很容易看出我们可以如何利用
    Swift 的力量将其扩展到更大、更复杂的应用程序。
- en: This brings us to the end of the book. We've covered a lot of material and learned
    the new features of Swift 3\. We discussed Apple's motivation and objectives for
    the evolution of Swift. I have shown you where to find documentation on the language
    and how to get involved with the future direction of Swift. We explored Swift
    on Linux and some of the possibilities this creates for server-side Swift applications.
    Swift 3 adds new language features that improve many of the libraries that you
    will use everyday in your coding projects.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这就带我们来到了本书的结尾。我们涵盖了大量的内容，并学习了 Swift 3 的新特性。我们讨论了苹果对 Swift 进化的动机和目标。我向你展示了如何找到关于该语言的文档以及如何参与
    Swift 的未来方向。我们探讨了 Linux 上的 Swift 以及这为服务器端 Swift 应用程序带来的可能性。Swift 3 添加了新的语言特性，这些特性改进了你将在日常编码项目中使用的许多库。
- en: It's my hope that this book will prove to be a reference for you as dive into
    developing for Swift 3\. While we have examined many of the features of the language,
    it isn't feasible to cover every single change to the language. While this book
    provides a good base for understanding the changes for Swift 3, you will need
    to apply what you've learned in your code. In addition, you should refer to Apple's
    documentation, and the Swift community to stay on top of the latest developments
    to the language. The best developers never rely on their current knowledge. They
    actively seek to learn more and more. If you want to master Swift 3, you will
    have to use all of the resources at your disposal to build on the base we created
    together. I know you can do it, and I wish you the best of luck in your journey.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这本书能成为你在深入开发 Swift 3 时的参考。虽然我们已经探讨了该语言的大部分特性，但全面覆盖语言的所有变化并不现实。虽然这本书为理解 Swift
    3 的变化提供了良好的基础，但你仍需要在代码中应用你所学的知识。此外，你应该参考苹果的文档和 Swift 社区，以保持对语言最新发展的了解。最优秀的开发者永远不会依赖他们当前的知识。他们积极寻求学习更多。如果你想掌握
    Swift 3，你必须利用你所能利用的所有资源来构建我们共同创建的基础。我知道你可以做到，并祝愿你在旅程中一切顺利。
