- en: Chapter 8. Artificial Intelligence and Game Progression
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。人工智能和游戏进度
- en: '*In the previous chapter, we learned about adding user interface elements to
    our game. We added a hit points representation above our ships, added buttons,
    and even created our own dialog.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*在上一章中，我们学习了如何向我们的游戏添加用户界面元素。我们在船只上方添加了生命值表示，添加了按钮，甚至创建了我们的对话框。*'
- en: 'In this chapter, we will add artificial intelligence to our game. The following
    are the topics we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向我们的游戏添加人工智能。以下是我们将要涵盖的主题：
- en: The concepts of fuzzy logic and state machines
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模糊逻辑和状态机的概念
- en: Enemy ships should move and attack
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 敌舰应该移动并攻击
- en: Adding some kind of progression to the game
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在游戏中添加某种进步
- en: Winning and losing the game
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赢得和输掉游戏
- en: However, before we get to the actual coding, let's see the concepts of artificial
    intelligence that we will implement.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们实际编码之前，让我们看看我们将要实现的人工智能的概念。
- en: Artificial intelligence in theory
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理论上的人工智能
- en: The goal for the enemy ships is to move around and attack our ships if they
    get close enough. There are two concepts we need to look into in detail to help
    us implement this logic; we will discuss these in the following sections.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 敌舰的目标是四处移动，如果它们足够接近，就攻击我们的船只。为了帮助我们实现这一逻辑，我们需要详细研究两个概念；我们将在接下来的章节中讨论这些内容。
- en: Explaining fuzzy logic
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释模糊逻辑
- en: Let's take a moving train as an example. We could use a Boolean value to describe
    its state. If it is set to true, it's moving fast; if it's set to false, it's
    not moving fast.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一辆行驶的火车为例。我们可以使用布尔值来描述其状态。如果设置为true，它正在快速移动；如果设置为false，它没有快速移动。
- en: However, that will not be enough. Let's say the train is moving at 80 miles
    per hour and then at 100 miles per hour. At both speeds, our Boolean value will
    be true, but we have no way of differentiating it further. Also, we don't have
    a state if the train is not moving.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这还不够。假设火车以每小时80英里的速度行驶，然后以每小时100英里的速度行驶。在这两种速度下，我们的布尔值都将为true，但我们无法进一步区分它。此外，如果火车没有移动，我们也没有状态。
- en: 'Fuzzy logic describes an interval of values put into a colloquial term. Let''s
    take a step back and compare it to mathematical logic. Binary (two-valued) logic
    has two values: true and false. An expression such as *1 + 1 = 2* evaluates to
    "true". The expression "Adding one to one is most likely going to be two" will
    not make much sense in binary logic, but it will be possible in fuzzy logic.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊逻辑描述了一个被放入日常用语中的值区间。让我们退一步，将其与数学逻辑进行比较。二进制（二值）逻辑有两个值：true和false。一个如*1 + 1
    = 2*的表达式评估为“true”。表达式“给一加一很可能是两个”在二进制逻辑中可能没有太多意义，但在模糊逻辑中是可能的。
- en: Fuzzy logic doesn't have the two values true and false, but it has in-between
    values such as a bit, quite, or about. This is similar to human thinking.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊逻辑没有true和false这两个值，但它有介于两者之间的值，如bit、quite或about。这与人类的思维相似。
- en: 'To illustrate this point further, let''s take a look at what our moving train
    example looks like if put in table form:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步说明这一点，让我们看看我们的移动火车示例如果以表格形式呈现会是什么样子：
- en: '| Term | Speed |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 术语 | 速度 |'
- en: '| --- | --- |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Not moving | 0 miles per hour |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 未移动 | 0英里/小时 |'
- en: '| Really slow | 1 to 9 miles per hour |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 非常慢 | 1至9英里/小时 |'
- en: '| Almost fast | 10 to 49 miles per hour |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 几乎快 | 10至49英里/小时 |'
- en: '| Quite fast | 50 to 89 miles per hour |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 相当快 | 50至89英里/小时 |'
- en: '| Really fast | 90 to 119 miles per hour |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 非常快 | 90至119英里/小时 |'
- en: 'For our game, we can apply this to a similar value: the distance between the
    enemy ship and our own ship.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的游戏，我们可以将此应用于类似的价值：敌舰与我们自己的船只之间的距离。
- en: Explaining state machines
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释状态机
- en: 'State machines are a number of states put into a sequential logic circuit.
    This sounds abstract, so let''s explain it in detail: a state, first of all, is
    a value that changes if a different state becomes active. A door has two states:
    locked and unlocked. If the door is locked, it stays locked until it''s unlocked.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机是一系列状态放入顺序逻辑电路中。这听起来很抽象，所以让我们详细解释一下：首先，状态是一个值，如果不同的状态变得活跃，它就会改变。门有两个状态：锁定和未锁定。如果门是锁着的，它会保持锁定状态，直到它被解锁。
- en: 'Here is an example that is closer to our game: we need a number of states,
    for example, **Move to player**, **Wait 3 seconds**, and **Attack player**.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个更接近我们游戏的例子：我们需要多个状态，例如，**移动到玩家**、**等待3秒**和**攻击玩家**。
- en: 'Now, we need to put these states in some kind of order. Let''s say the enemy
    first moves to the player, and then it attacks and waits for 3 seconds. Then,
    the process starts again, as demonstrated in the following diagram:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将这些状态以某种顺序排列。比如说，敌舰首先移动到玩家那里，然后攻击并等待3秒钟。然后，过程再次开始，如下面的图表所示：
- en: '![Explaining state machines](img/1509OS_08_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![解释状态机](img/1509OS_08_01.jpg)'
- en: So far, we know about states and state machines. Finite state machines are state
    machines with a finite number of states. The preceding figure is of course a simplified
    example of how finite state machines can work. Some of the models also have transitions
    to describe the action taken to move from one state to another. In illustrations,
    transitions are often accompanied by conditions such as "Is the player in sight?"
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了状态和状态机。有限状态机是具有有限状态的状态机。前面的图当然是一个简化的有限状态机如何工作的例子。一些模型也有转换来描述从一种状态移动到另一种状态所采取的动作。在插图上，转换通常伴随着条件，例如“玩家是否在视线中？”
- en: 'Most simple AIs employ this strategy. One of the most prominent examples is
    **Quake**. To be fair, different AI mechanics are used in more complex and modern
    games. One example is the AI adapting to the player''s actions: if in a strategy
    game, the player chooses to attack a specific point, the AI would adapt to defend
    this position more and more depending on how often the player attacked.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数简单的AI都采用这种策略。最突出的例子之一是**Quake**。公平地说，在更复杂和现代的游戏中，使用的AI机制各不相同。一个例子是AI适应玩家的动作：如果在策略游戏中，玩家选择攻击一个特定的点，AI就会根据玩家攻击的频率越来越多地适应防御这个位置。
- en: 'For our purposes, a finite state machine is more than enough. So, let''s see
    what states we need for the enemy ship:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，有限状态机已经足够。那么，让我们看看敌舰需要哪些状态：
- en: We want the enemy ship to wander around
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望敌舰四处游荡
- en: We want the enemy ship to move to the vicinity of the player
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望敌舰移动到玩家的附近
- en: We want the enemy ship to attack
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望敌舰进行攻击
- en: We want the enemy ship to wait a bit after an attack (for the player to recuperate)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望敌舰在攻击后稍作等待（让玩家恢复）
- en: 'Let''s put these states into a diagram as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这些状态以如下所示的图表形式表示：
- en: '![Explaining state machines](img/1509OS_08_02.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![解释状态机](img/1509OS_08_02.jpg)'
- en: Letting the enemy ship move and attack
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让敌舰移动和攻击
- en: Now that we know about fuzzy logic and state machines, we can implement these
    as mechanics for our artificial intelligence.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了模糊逻辑和状态机，我们可以将这些作为人工智能的机制实现。
- en: Moving the ship
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动舰船
- en: First of all, we want the ship to move around—both wander around and move to
    the player ship.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们希望舰船四处移动——既四处游荡又移动到玩家舰船。
- en: Time for action – getting the enemy ship to move around
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 让敌舰移动
- en: 'In order for the enemy ship to move around, we need to use the following steps:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让敌舰能够移动，我们需要使用以下步骤：
- en: Open our Xcode project if it's not already open.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果Xcode项目尚未打开，请打开我们的Xcode项目。
- en: Open the `Battlefield.h` file.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Battlefield.h` 文件。
- en: 'Define all AI states as `enum`, as shown in the following code:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义所有AI状态为 `enum`，如下面的代码所示：
- en: '[PRE0]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Inside the `Battlefield` scene, add a new instance variable called `_aiState`,
    which is of the `AIState` type.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Battlefield` 场景内部，添加一个新的实例变量 `_aiState`，其类型为 `AIState`。
- en: Open the `Ship.h` file.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Ship.h` 文件。
- en: 'Add a callback block type, as shown in the following line of code:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个回调块类型，如下面的代码行所示：
- en: '[PRE1]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Declare three new methods for the `Ship` class, as shown in the following code:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `Ship` 类声明三个新的方法，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Open the `Ship.m` file.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Ship.m` 文件。
- en: Move the contents of the `-(void) moveToX:(float) x andY:(float) y` method into
    the `-(void) moveToX:(float)x andY:(float)y withBlock:(ShipCallback) block` method.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `-(void) moveToX:(float) x andY:(float) y` 方法的内容移动到 `-(void) moveToX:(float)x
    andY:(float)y withBlock:(ShipCallback) block` 方法中。
- en: 'Inside the new `moveTo` method, add the following code just after the `[tweenY
    animateProperty:@"y" targetValue:targetY];` line:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的 `moveTo` 方法中，在 `[tweenY animateProperty:@"y" targetValue:targetY];` 行之后添加以下代码：
- en: '[PRE3]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Implement the `checkDistanceToShip` method with the following code:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码实现 `checkDistanceToShip` 方法：
- en: '[PRE4]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `moveToShip` method should have the following body:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`moveToShip` 方法应该具有以下内容：'
- en: '[PRE5]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Reimplement the `moveToX:(float)x andY:(float)y` method, as shown in the following
    code:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新实现 `moveToX:(float)x andY:(float)y` 方法，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Move on to the `Battlefield.m` file.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续到 `Battlefield.m` 文件。
- en: 'Inside the initializer, set the `_aiState` instance variable to `StateWanderAround`,
    as shown in the following line of code:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在初始化器内部，将 `_aiState` 实例变量设置为 `StateWanderAround`，如下面的代码行所示：
- en: '[PRE7]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Remove the tween and the juggler.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除补间动画和杂技演员。
- en: 'Let''s declare a helper method for getting a random position on the screen,
    as shown in the following code:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们声明一个辅助方法来获取屏幕上的随机位置，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Define a method called `updateAI`, as shown in the following code:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为 `updateAI` 的方法，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Call the `updateAI` method at the point where we initialized the juggler previously,
    as shown in the following code:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在初始化杂技演员之前的位置调用 `updateAI` 方法，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Run the example.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例。
- en: We now see that our own ship and the enemy ship are moving around on their own.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在看到我们的船和敌船正在各自移动。
- en: '![Time for action – getting the enemy ship to move around](img/1509OS_08_03.jpg)'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 – 让敌船移动](img/1509OS_08_03.jpg)'
- en: '*What just happened?*'
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: In step 1, we opened our game project; in the next step, we looked into the
    `Battlefield.h` file. All of the AI states we previously mentioned were put into
    `enum`. In step 4, we defined an instance variable that holds the default AI state.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 1 步，我们打开了我们的游戏项目；在下一步中，我们查看了 `Battlefield.h` 文件。我们之前提到的所有 AI 状态都被放入了 `enum`
    中。在第 4 步，我们定义了一个实例变量来保存默认的 AI 状态。
- en: We already had a `moveTo` method in our `Ship` class which lets us move any
    ship around on the screen. Unfortunately, we currently don't have a way of knowing
    when the movement is over. We can employ an Objective-C language feature which
    we used in the previous chapters, that is, blocks. We defined a block as a parameter;
    when the movement was over, the block was called. In step 6, we defined our block
    type.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 `Ship` 类中有一个 `moveTo` 方法，它允许我们在屏幕上移动任何船。不幸的是，我们目前还没有一种方法来知道移动何时结束。我们可以使用在前面章节中使用过的
    Objective-C 语言特性，即块。我们将块定义为参数；当移动结束时，块会被调用。在第 6 步，我们定义了我们的块类型。
- en: 'In the next step, we declared the general methods for our `Ship` class:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们为我们的 `Ship` 类声明了通用方法：
- en: Moving to a position and using a callback once the movement is done
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动到某个位置，并在移动完成后使用回调
- en: Checking the distance between the current ship and any other ship
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查当前船与任何其他船之间的距离
- en: Moving to another ship and using a callback once the operation is over
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动到另一艘船，并在操作完成后使用回调
- en: We then got ready to implement these methods in step 8\. We first moved the
    contents of the old `moveTo` method to the new one with the callback.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们准备在第 8 步实现这些方法。我们首先将旧 `moveTo` 方法的内容移动到带有回调的新方法中。
- en: Then, we just needed to call the callback block once the animation was over.
    Since the tweens could potentially have two different speeds depending on the
    distance between the touch point and the ship, we needed to record whether each
    tween was completed for both of the tweens. To check if the tween was actually
    complete, we added a block to the `onComplete` property of the tween. Once the
    tween was done, the block got called. Inside this block, we set a Boolean value
    to flag that the current tween was complete, and if both tweens are complete,
    we invoked the callback. To be able to use our local variables in the `onComplete`
    blocks, we needed to prefix them with `__blocks`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们只需在动画完成后调用回调块。由于补间动画可能根据触摸点与船之间的距离具有两种不同的速度，我们需要记录每个补间动画是否完成，对于两个补间动画都这样做。为了检查补间动画是否实际上已完成，我们在补间的
    `onComplete` 属性中添加了一个块。一旦补间完成，该块就会被调用。在这个块内部，我们设置一个布尔值来标记当前的补间已完成，如果两个补间都已完成，我们就调用回调。为了能够在
    `onComplete` 块中使用我们的局部变量，我们需要在它们前面加上 `__blocks` 前缀。
- en: 'In step 11, we implemented a method that calculates the distance between two
    ships: we took the center of both ships, converted them into `SPPoint`, and utilized
    the static `distanceFromPoint` method that `SPPoint` provides. We only needed
    to return the result.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 11 步，我们实现了一个计算两艘船之间距离的方法：我们取了两艘船的中心，将它们转换为 `SPPoint`，并利用 `SPPoint` 提供的静态
    `distanceFromPoint` 方法。我们只需要返回结果。
- en: The `moveToShip` method called the `moveTo` method with the coordinates of the
    ship passed in and some randomness attached to it. We used the `arc4random` function
    to get a random value. The `arc4random` function returned a floating point number
    between zero and one. The `arc4random_uniform` function took a parameter and created
    a random number between zero and the passed-in parameter minus one. In step 13,
    the `moveTo` method without the callback just called the `moveTo` version, with
    the callback passing through `nil` as the callback parameter.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`moveToShip` 方法调用了带有飞船坐标和附加随机性的 `moveTo` 方法。我们使用了 `arc4random` 函数来获取一个随机值。`arc4random`
    函数返回一个介于零和一之间的浮点数。`arc4random_uniform` 函数接受一个参数，并创建一个介于零和传入参数减一之间的随机数。在第13步中，没有回调的
    `moveTo` 方法只是调用了带有回调的 `moveTo` 版本，回调参数通过 `nil` 传递。'
- en: When we moved to the `Battlefield.m` file, we set the `_aiState` instance variable
    to the `WanderState` AI state. We then safely removed the tween and the juggler,
    which were previously responsible for the enemy ships' move animation.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们移动到 `Battlefield.m` 文件时，我们将 `_aiState` 实例变量设置为 `WanderState` AI状态。然后我们安全地移除了之前负责敌人飞船移动动画的补间和
    `juggler`。
- en: In step 17, we implemented a method that gets us a random position on the screen.
    We also set a margin so that the position was definitely within the borders of
    the screen. We used the `SPPoint` class factory method to store both the `x` and
    `y` positions.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在第17步中，我们实现了一个获取屏幕上随机位置的方法。我们还设置了一个边距，以确保位置肯定在屏幕的边界内。我们使用了 `SPPoint` 类的工厂方法来存储
    `x` 和 `y` 位置。
- en: 'In the next step, we implemented the method that updates the AI:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们实现了更新AI的方法：
- en: If the ship is wandering around, we get a random position and move there.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果飞船正在四处游荡，我们会得到一个随机位置并移动到那里。
- en: If the ship has moved, it checks if the distance between the player and the
    ship parameter is less than 200 points. The ship then moves to the player. If
    that's not the case, we call the `updateAI` method again with the `WanderState`
    AI state.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果飞船已经移动，它会检查玩家与飞船参数之间的距离是否小于200点。然后飞船移动到玩家那里。如果不是这种情况，我们再次调用 `updateAI` 方法，并使用
    `WanderState` AI状态。
- en: If the ship moved to the player, it checks again for the distance. If it's lower
    than 100 points, it begins attacking, else it's back to wandering around.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果飞船移动到玩家附近，它会再次检查距离。如果距离小于100点，它开始攻击，否则它就回到四处游荡的状态。
- en: Inside the initializer, we called the `updateAI` method with the enemy ship
    and our default AI state. This should be right where we previously initialized
    our instance variable `_juggler`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化器内部，我们使用敌人飞船和我们的默认AI状态调用了 `updateAI` 方法。这应该就是我们之前初始化实例变量 `_juggler` 的地方。
- en: When we ran the example, the enemy ship moved around if it was in the correct
    state. It moved to the player ship if it was in sight. If the enemy ship was getting
    too close to the player, it just stopped.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行示例时，如果敌人飞船处于正确的状态，它会四处游荡。如果它在视线范围内，它会移动到玩家飞船那里。如果敌人飞船离玩家太近，它就会停止。
- en: Attacking other ships
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 攻击其他飞船
- en: Now that the enemy ship is moving around, let's get it to attack our own ship.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在敌人飞船正在四处游荡，让我们让它攻击我们的飞船。
- en: Time for action – the enemy should attack the player
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 敌人应该攻击玩家
- en: 'For the enemy to attack the players'' ship, use the following steps:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让敌人攻击玩家的飞船，请按照以下步骤操作：
- en: Open the `Ship.h` file.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Ship.h` 文件。
- en: 'Refactor our `_juggler` instance variable to be a property, as shown in the
    following line of code:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的 `_juggler` 实例变量重构为属性，如下面的代码行所示：
- en: '[PRE11]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Using the following line of code, add a method called `shootWithBlock` that
    should shoot and have a callback as its parameter:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码行，添加一个名为 `shootWithBlock` 的方法，该方法应该射击并带有作为参数的回调：
- en: '[PRE12]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Open the `Ship.m` file and move the contents of the `shoot` method into the
    `shootWithBlock` method.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Ship.m` 文件，并将 `shoot` 方法的全部内容移动到 `shootWithBlock` 方法中。
- en: In the `shootWithBlock` method, invoke the callback as its last statement inside
    the complete listener of the `currentClip` variable.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `shootWithBlock` 方法中，在 `currentClip` 变量的完整监听器内部调用回调作为其最后一条语句。
- en: Update the `shoot` method to call the `shootWithBlock` method with `nil`.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `shoot` 方法更新为调用 `shootWithBlock` 方法并传递 `nil`。
- en: 'Open the `Battlefield.m` file and add a method for collision detection, as
    shown in the following code:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Battlefield.m` 文件，并添加一个碰撞检测方法，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Inside the `onEnterFrame` method, replace the current collision detection with
    the `checkShipCollision` method, as shown in the following code:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onEnterFrame`方法内部，将当前的碰撞检测替换为`checkShipCollision`方法，如下面的代码所示：
- en: '[PRE14]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Update the `WanderAround` AI state with an additional attack opportunity, as
    shown in the following code:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码更新`WanderAround` AI状态，增加一个额外的攻击机会：
- en: '[PRE15]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As shown in the following code, add these states to our `switch`-`case` statements
    in our `updateAI` method:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如以下代码所示，将以下状态添加到我们的`updateAI`方法中的`switch`-`case`语句中：
- en: '[PRE16]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Run the example to see the result.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例以查看结果。
- en: 'If the enemy ship gets close enough to our ship and is in the attacking state,
    it begins to attack our ship. Refer to the following screenshot:'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果敌舰足够接近我们的船并且在攻击状态中，它开始攻击我们的船。参见图表：
- en: '![Time for action – the enemy should attack the player](img/1509OS_08_04.jpg)'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 – 敌舰应该攻击玩家](img/1509OS_08_04.jpg)'
- en: '*What just happened?*'
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: In the `Ship.h` file, we refactored the `_juggler` instance variable into a
    property since we needed to access it from the battlefield scene and its access
    should not be limited to a `Ship` instance. We added the `shootWithBlock` method,
    which we implemented in step 4, where we moved the contents of the `shoot` method
    to the new `shootWithBlock` method.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Ship.h`文件中，我们将`_juggler`实例变量重构为一个属性，因为我们需要从战场场景中访问它，并且其访问不应仅限于`Ship`实例。我们添加了`shootWithBlock`方法，我们在第4步中实现了它，将`shoot`方法的内容移动到新的`shootWithBlock`方法中。
- en: We then invoked the callback that should now be the last statement in the event
    listener where the `currentClip` tween is completed. In step 6, we updated the
    `shoot` method to call the `shootWithBlock` method with an empty block, just like
    we did in the previous example.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用了应该现在是事件监听器中完成`currentClip`缓动的最后一个回调。在第6步中，我们将`shoot`方法更新为调用带有空块的`shootWithBlock`方法，就像我们在上一个示例中所做的那样。
- en: Since we used collision detection more than once, we put it into a separate
    method in the next step. Now, we can replace our old collision detection logic
    by calling the new collision detection. We need to call it twice, once with `_pirateShip`
    as the first parameters and `_enemyShip` as the second parameter. The order of
    the parameter needs to be the other way around when we call `checkShipCollision`
    for the second time.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们多次使用了碰撞检测，我们在下一步将其放入一个单独的方法中。现在，我们可以通过调用新的碰撞检测来替换我们旧的碰撞检测逻辑。我们需要调用两次，第一次将`_pirateShip`作为第一个参数，将`_enemyShip`作为第二个参数。当我们第二次调用`checkShipCollision`时，参数的顺序需要相反。
- en: 'In step 9, we added an additional state transition. If the distance between
    the pirate ship and the enemy ship was less than 100 points, it attacked directly
    instead of moving to the player first. In the following steps, we added the following
    two missing states:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在第9步中，我们添加了一个额外的状态转换。如果海盗船和敌舰之间的距离小于100点，它将直接攻击而不是先移动到玩家那里。在接下来的步骤中，我们添加了以下两个缺失的状态：
- en: In the attack state, we called the `shootWithBlock` method, and when the shooting
    was complete, we moved to the recuperating state
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在攻击状态中，我们调用了`shootWithBlock`方法，当射击完成时，我们移动到恢复状态
- en: In the `StateRecuperate` AI state, we waited for 0.3 seconds and then moved
    on to wandering around
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`StateRecuperate` AI状态中，我们等待了0.3秒，然后继续四处游荡
- en: When we ran the example, our state machine was completely finished and all states
    were being used.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行示例时，我们的状态机已经完全完成，所有状态都被使用。
- en: Adding fuzzy values to the AI
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向AI添加模糊值
- en: Our AI works so far, but we don't have any fuzzy logic yet.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的人工智能目前运行良好，但我们还没有任何模糊逻辑。
- en: Time for action – spicing up the AI with fuzzy values
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 使用模糊值增强AI
- en: 'To replace our hardcoded values, we need to use the following steps:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换我们硬编码的值，我们需要使用以下步骤：
- en: Open the `Battlefield.m` file.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Battlefield.m`文件。
- en: 'Add a new method called `fuzzyValue`, as shown in the following code:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`fuzzyValue`的新方法，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Using the following code, update the hardcoded values with the values from
    the `fuzzyValue` method:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码，将硬编码的值更新为`fuzzyValue`方法中的值：
- en: '[PRE18]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Run the example. If we were to insert logging to see what the values actually
    are, we would see the following output:![Time for action – spicing up the AI with
    fuzzy values](img/1509OS_08_05.jpg)
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例。如果我们插入日志来查看实际的值，我们会看到以下输出：![行动时间 – 使用模糊值增强AI](img/1509OS_08_05.jpg)
- en: '*What just happened?*'
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: The goal for this example is to replace our hardcoded values with something
    that resembles fuzzy logic. In step 2, we added a method that checks against the
    value and returns a new random value each time. The randomness is not a necessary
    factor of fuzzy logic, but it is used in this case so that the values are inside
    a specific range.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的目标是将我们的硬编码值替换为类似于模糊逻辑的东西。在步骤2中，我们添加了一个检查值并返回新随机值的方法。随机性不是模糊逻辑的必要因素，但在这个案例中使用了它，以便值在特定范围内。
- en: If we were to have more fuzzy values, it would be a good idea to hold those
    values inside `NSDictionary`. This dictionary would have a colloquial term as
    its key and a block for its value. Inside the block would be logic to return a
    random number. If the fuzzy value gets passed in, we call the block and get a
    random number.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有多于模糊值，将那些值保存在`NSDictionary`中是个好主意。这个字典将使用口语术语作为键，并为值提供一个块。在块内部将包含返回随机数的逻辑。如果模糊值被传递进来，我们调用块并得到一个随机数。
- en: Next up, we updated the hardcoded values with the `fuzzyValue` method and put
    it in a colloquial term each time.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`fuzzyValue`方法更新了硬编码的值，并将其放在每次的口语术语中。
- en: When we ran the example, the AI worked like it did before, but it had additional
    randomness now.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行示例时，AI的工作方式与之前一样，但现在有了额外的随机性。
- en: Have a go hero
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 来试试英雄
- en: We can improve the AI quite a bit by moving the AI logic away from the battlefield
    scene into a separate class. Since we used the strings for our fuzzy values quite
    a lot, it may be a good idea to move them into constants or even create our own
    macros.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将AI逻辑从战场场景移到单独的类中来大大提高AI。由于我们使用了大量的字符串作为模糊值，可能将它们移动到常量中甚至创建我们自己的宏是个好主意。
- en: Adding progression to our game
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加游戏进度
- en: Now that our AI is implemented, let's add some progression to our game. We will
    need to add levels. Each level should have one more enemy ship, and we can upgrade
    the damage and hit points of our ship in between the levels.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了AI，让我们给我们的游戏添加一些进度。我们需要添加等级。每个等级应该有一个更多的敌舰，我们可以在等级之间升级我们的船的伤害和生命值。
- en: Adding a World class
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加World类
- en: We need to keep some values, such as the current level, in a separate entity,
    which we will describe as a `World` class.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要保留一些值，例如当前级别，在一个单独的实体中，我们将描述为`World`类。
- en: Time for action – adding a World class
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 添加World类
- en: 'To implement our `World` class, we need to use the following steps:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现我们的`World`类，我们需要使用以下步骤：
- en: Add a new Objective-C class called `World`, which is derived from `NSObject`.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`World`的新Objective-C类，它从`NSObject`派生。
- en: 'To add a `level` property from the `int` type, do the following:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加一个`level`属性，其类型为`int`，请执行以下操作：
- en: 'Add a static variable called `level` in `World.h`, as shown in the following
    line of code:'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`World.h`中添加一个名为`level`的静态变量，如下面的代码行所示：
- en: '[PRE19]'
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add a static getter with the same name that returns the static variable, as
    shown in the following line of code:'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个具有相同名称的静态获取器，它返回静态变量，如下面的代码行所示：
- en: '[PRE20]'
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add a static setter (`setLevel`) that sets the static variable, as shown in
    the following line of code:'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个静态设置器（`setLevel`），它设置静态变量，如下面的代码行所示：
- en: '[PRE21]'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Repeat step 2 for the properties `gold`, `hitpoints`, and `damage`.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对属性`gold`、`hitpoints`和`damage`重复步骤2。
- en: We also need a `levelMax` property, but this one does not have a setter.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一个`levelMax`属性，但这个属性没有设置器。
- en: We need to import the `Assets.h` file inside the `World.m` file.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在`World.m`文件中导入`Assets.h`文件。
- en: 'Add a static `reset` method that needs to be declared in `World.h`. It should
    look like the following piece of code:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个需要在`World.h`中声明的静态`reset`方法。它应该看起来像以下代码片段：
- en: '[PRE22]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We also need a `log` method. It needs to be declared in `World.h` and needs
    to look like the following code:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一个`log`方法。它需要在`World.h`中声明，并看起来像以下代码：
- en: '[PRE23]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In `Game.m`, we need to call the `World` methods inside its initializer, as
    shown in the following code:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Game.m`中，我们需要在其初始化器中调用`World`方法，如下面的代码所示：
- en: '[PRE24]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Run the example to see the result. We should now see the following output in
    the console:![Time for action – adding a World class](img/1509OS_08_06.jpg)
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例以查看结果。我们现在应该在控制台中看到以下输出：![行动时间 – 添加World类](img/1509OS_08_06.jpg)
- en: '*What just happened?*'
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: First of all, we created the `World` class. Objective-C does not support static
    properties. We can imitate that behavior of having a static property if we add
    static methods that have `methodName` as their name where we return a value. We
    also need to define a method called `setMethodName` that has a parameter. Now
    we can access `methodName` just like a property. However, inside the pseudo-getter,
    we can only access static variables.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了 `World` 类。Objective-C 不支持静态属性。如果我们添加具有 `methodName` 作为名称的静态方法，并返回一个值，我们可以模仿具有静态属性的行为。我们还需要定义一个名为
    `setMethodName` 的方法，它有一个参数。现在我们可以像访问属性一样访问 `methodName`。然而，在伪获取器内部，我们只能访问静态变量。
- en: After we were done with the setup, we needed to import the `Assets` class in
    step 5\. After that, we added a `reset` method, which loaded the damage and hit
    points from our `gameplay.json` file. We set the `gold`, `level`, and `levelMax`
    variables to default values. In our case, the current level was the first one;
    we had a maximum of three levels, and 200 was the amount we had at our disposal
    at the start for the `gold` variable.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成设置后，我们需要在第 5 步中导入 `Assets` 类。之后，我们添加了一个 `reset` 方法，该方法从我们的 `gameplay.json`
    文件中加载伤害和生命值。我们将 `gold`、`level` 和 `levelMax` 变量设置为默认值。在我们的例子中，当前级别是第一个；我们最多有三个级别，初始时
    `gold` 变量的金额是 200。
- en: The `log` method that we implemented later logged all values except for the
    `levelMax` value. In step 8, we called the `reset` method, and we called `log`
    directly after that. When we ran the example, we saw the log output in the console.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们后来实现的 `log` 方法记录了所有值，除了 `levelMax` 值。在第 8 步中，我们调用了 `reset` 方法，并在之后直接调用了 `log`。当我们运行示例时，我们在控制台中看到了日志输出。
- en: Have a go hero
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 勇敢的尝试者
- en: Right now, the `gold`, `level`, and `levelMax` variables are being set directly
    in the code. It's a better idea to load them from the `gameplay.json` file.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`gold`、`level` 和 `levelMax` 变量是直接在代码中设置的。从 `gameplay.json` 文件中加载它们会更好。
- en: Updating the scene and dialog classes
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新场景和对话框类
- en: 'Before we move on to implementing the progression system, there are a few small
    things we need to refactor. Let''s tackle these issues:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实现进度系统之前，还有一些小事情需要重构。让我们解决这些问题：
- en: We have no way of resetting a scene if it's being shown again
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果场景再次显示，我们无法重置场景
- en: Multiline strings in dialogs are not displayed correctly
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对话框中的多行字符串显示不正确
- en: We cannot access the dialog's buttons outside the `Dialog` class
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们无法在 `Dialog` 类外部访问对话框的按钮
- en: The dialog doesn't close after clicking on the buttons
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击按钮后，对话框不会关闭
- en: Time for action – updating the scene and dialog classes
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新场景和对话框类的时间到了
- en: 'To add our first buttons, use the following steps:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加我们的第一个按钮，请按照以下步骤操作：
- en: Open the `Dialog.h` file.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Dialog.h` 文件。
- en: 'Add properties for both **Yes** and **No** buttons using the following code:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码为 **是** 和 **否** 按钮添加属性：
- en: '[PRE25]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Switch to `Dialog.m`.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到 `Dialog.m`。
- en: Refactor all references from the local variables to use the properties.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有对局部变量的引用重构为使用属性。
- en: 'Update the positions of `_title` and `_content` using the following code:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码更新 `_title` 和 `_content` 的位置：
- en: '[PRE26]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In both `onButtonYes` and `onButtonNo`, add `self.visible = NO;` as the first
    statement.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onButtonYes` 和 `onButtonNo` 中，将 `self.visible = NO;` 作为第一条语句添加。
- en: 'In `Scene.h`, declare a method called `reset` using the following line of code:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Scene.h` 中，使用以下代码声明一个名为 `reset` 的方法：
- en: '[PRE27]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In `Scene.m`, implement the `reset` method with an empty body.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Scene.m` 中，实现一个空的 `reset` 方法。
- en: 'In `SceneDirector.m`, update this portion of code in the `showScene` method:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SceneDirector.m` 中，更新 `showScene` 方法中的这段代码：
- en: '[PRE28]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Run the example.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例。
- en: 'If we were to implement the `reset` method to the battlefield scene and add
    a logger message to the `reset` method of the battlefield scene, our output would
    change to this:'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们将 `reset` 方法实现到战场场景中，并向战场场景的 `reset` 方法添加一个日志消息，我们的输出将变为如下：
- en: '![Time for action – updating the scene and dialog classes](img/1509OS_08_07.jpg)'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![更新场景和对话框类的时间到了](img/1509OS_08_07.jpg)'
- en: '*What just happened?*'
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We tackled the dialog issues first. In steps 2 to 4, we moved the buttons to
    be properties and updated all references inside the `Dialog` implementation. We
    then updated the position of the title and the message content. Long strings were
    not wider than the bounds of the dialog. In step 6, we hid the dialog once we
    tapped on any button.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先解决了对话框问题。在第 2 到 4 步中，我们将按钮移动到属性中，并更新了 `Dialog` 实现内部的所有引用。然后我们更新了标题和消息内容的位置。长字符串不会超过对话框的边界。在第
    6 步中，我们在点击任何按钮后隐藏了对话框。
- en: For a scene to be able to reset itself, we first needed to add the `reset` method
    and just implement it as an empty method in `Scene.m`. We then needed to update
    the scene director to call the `reset` method from the current scene just after
    the scene turned visible.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使场景能够重置自己，我们首先需要添加 `reset` 方法，并在 `Scene.m` 中将其实现为一个空方法。然后我们需要更新场景导演，在场景变为可见后立即调用当前场景的
    `reset` 方法。
- en: If we ran the example now, and if we implemented the `reset` method in the battlefield
    scene and added a logger message, we would see that the `reset` method from the
    battlefield scene would actually be called.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行示例，并且我们在战场场景中实现了 `reset` 方法并添加了日志消息，我们会看到战场场景中的 `reset` 方法实际上会被调用。
- en: Adding game mechanics to the pirate cove
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为海盗湾添加游戏机制
- en: Now that we have a `World` class and we have updated the `Dialog` and `Scene`
    classes to fit our needs, we can add some game mechanics to the pirate cove. The
    pirate cove is the place where we can upgrade our ship.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了 `World` 类，并且我们已经更新了 `Dialog` 和 `Scene` 类以适应我们的需求，我们可以在海盗湾中添加一些游戏机制。海盗湾是我们升级船只的地方。
- en: Time for action – making the pirate cove playable
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 使海盗湾可玩
- en: 'To add game mechanics to the pirate cove, use the following steps:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要为海盗湾添加游戏机制，请按照以下步骤操作：
- en: Move the line of code `[SPTextField registerBitmapFontFromFile:@"PirateFont.fnt"];`
    from `Dialog.m` to the beginning of the `Game.m` file.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将代码行 `[SPTextField registerBitmapFontFromFile:@"PirateFont.fnt"];` 从 `Dialog.m`
    移动到 `Game.m` 文件的开始部分。
- en: 'Add a button in `PirateCove.m`, as shown in the following code:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PirateCove.m` 中添加一个按钮，如下所示：
- en: '[PRE29]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Add the button to the display tree using the following line of code:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码行将按钮添加到显示树中：
- en: '[PRE30]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the following code, we add a text field to display the current amount of
    gold, which needs to be declared as an instance variable first:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下代码中，我们添加了一个文本字段来显示当前的金币数量，首先需要将其声明为实例变量：
- en: '[PRE31]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Add the text field to the display tree using the following line of code:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码行将文本字段添加到显示树中：
- en: '[PRE32]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Add a method that updates the amount of gold on the screen using the following
    code:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个方法来更新屏幕上的金币数量，如下所示：
- en: '[PRE33]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Inside the `PirateCove.h` file, add an instance variable called`_dialogUpdateDamage`
    using the following line of code:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PirateCove.h` 文件中，添加一个名为 `_dialogUpdateDamage` 的实例变量，如下所示：
- en: '[PRE34]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Add an instance variable called `_goldDamage` as shown in the following line
    of code:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `_goldDamage` 的实例变量，如下所示：
- en: '[PRE35]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Inside the initializer, add the following piece of code for the first dialog:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在初始化器中，为第一个对话框添加以下代码：
- en: '[PRE36]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Add the dialog to the display tree using the following line of code:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码行将对话框添加到显示树中：
- en: '[PRE37]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Add the method `onUpdateDamage` as follows:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `onUpdateDamage` 方法，如下所示：
- en: '[PRE38]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Repeat steps 7 to 11 for the dialog that upgrades the hit points.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对升级生命值的对话框重复步骤 7 到 11。
- en: 'Add a `reset` method to the pirate cove scene as follows:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式为海盗湾场景添加一个 `reset` 方法：
- en: '[PRE39]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Update the statement in the `Game.m` file to show the pirate cove when starting
    the game.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `Game.m` 文件中的语句，以在开始游戏时显示海盗湾。
- en: Run the example to see the result. We can now upgrade our ship in the pirate
    cove, as shown in the following screenshot:![Time for action – making the pirate
    cove playable](img/1509OS_08_08.jpg)
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例以查看结果。我们现在可以在海盗湾中升级我们的船只，如下面的截图所示：![行动时间 – 使海盗湾可玩](img/1509OS_08_08.jpg)
- en: '*What just happened?*'
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: In step 1, we moved the registration of the bitmap font to the `Game` class.
    We only needed it once. Since we only had one dialog previously, it didn't really
    matter where we registered the font. However, as we now have multiple dialogs,
    the initializer of the dialog would register the font multiple times.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 1 中，我们将位图字体的注册移动到了 `Game` 类中。我们只需要它一次。由于我们之前只有一个对话框，所以注册字体的位置并不重要。然而，现在我们有多个对话框，对话框的初始化器会多次注册字体。
- en: In step 2, we added a button that will be able to switch to the battlefield
    scene when we tap it. After we added the button to the display tree, we also added
    a text field to display the current amount of gold. We subsequently added the
    text field to the display tree. We also added a method that updates the text field.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2步中，我们添加了一个按钮，当我们点击它时可以切换到战场场景。在将按钮添加到显示树之后，我们还添加了一个文本字段来显示当前的金币数量。随后我们将文本字段添加到显示树中。我们还添加了一个更新文本字段的方法。
- en: In steps 6 to 11, we added a dialog to the screen that pops up when we tap the
    weaponsmith. It checks if we have enough gold at our disposal and lets us upgrade
    our damage if we do.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6步到第11步中，我们在屏幕上添加了一个对话框，当点击武器师时会弹出。它检查我们是否有足够的金币可以使用，并且如果有的话，允许我们升级我们的伤害。
- en: In step 13, we implemented the `reset` method. The intention is to make upgrading
    the ship more and more expensive depending on the current level.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在第13步中，我们实现了`reset`方法。目的是使升级船只的成本随着当前级别的提高而越来越高。
- en: Adding progression to the game
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加游戏进度
- en: Everything is set in place for adding progression to the game.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 为添加游戏进度已经一切准备就绪。
- en: Have a go hero –turning our game into a real game
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试成为英雄——将我们的游戏变成真正的游戏
- en: 'Let''s go ahead and implement game progression. The following are a few things
    you should keep in mind:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续实现游戏进度。以下是一些你应该记住的事项：
- en: The `World` values need to be reset before the battlefield instance is created
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建战场实例之前需要重置`World`值
- en: Update the amount of gold once the player gets to a higher level
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当玩家达到更高等级时更新金币数量
- en: Use the `reset` method of the battlefield scene to reset position and hit points
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用战场场景的`reset`方法重置位置和生命值
- en: There needs to be a way to keep track of all the sunken ships
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要有一种方法来跟踪所有沉没的船只
- en: The enemies should probably be array-like objects
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 敌人可能应该是类似数组的对象
- en: The game itself should not start when the battlefield is initialized
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当战场初始化时，游戏本身不应启动
- en: 'After considering the preceding points, the game should look like what is shown
    in the following screenshot:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑了前面的点之后，游戏应该看起来像以下截图所示：
- en: '![Have a go hero –turning our game into a real game](img/1509OS_08_09.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![尝试成为英雄——将我们的游戏变成真正的游戏](img/1509OS_08_09.jpg)'
- en: Note
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Take a look at how the preceding points can be implemented, and take these
    source files as the base for the following exercises:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 查看如何实现前面的点，并将这些源文件作为以下练习的基础：
- en: '`Battlefield.h`: [https://raw.github.com/freezedev/pirategame/9d5f53b5cb5e2e9bad822f0abd944e539e9bbf58/Classes/Battlefield.h](https://raw.github.com/freezedev/pirategame/9d5f53b5cb5e2e9bad822f0abd944e539e9bbf58/Classes/Battlefield.h)'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Battlefield.h`: [https://raw.github.com/freezedev/pirategame/9d5f53b5cb5e2e9bad822f0abd944e539e9bbf58/Classes/Battlefield.h](https://raw.github.com/freezedev/pirategame/9d5f53b5cb5e2e9bad822f0abd944e539e9bbf58/Classes/Battlefield.h)'
- en: '`Battlefield.m`: [https://raw.github.com/freezedev/pirategame/9d5f53b5cb5e2e9bad822f0abd944e539e9bbf58/Classes/Battlefield.m](https://raw.github.com/freezedev/pirategame/9d5f53b5cb5e2e9bad822f0abd944e539e9bbf58/Classes/Battlefield.m)'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Battlefield.m`: [https://raw.github.com/freezedev/pirategame/9d5f53b5cb5e2e9bad822f0abd944e539e9bbf58/Classes/Battlefield.m](https://raw.github.com/freezedev/pirategame/9d5f53b5cb5e2e9bad822f0abd944e539e9bbf58/Classes/Battlefield.m)'
- en: '`Game.m`: [https://raw.github.com/freezedev/pirategame/9d5f53b5cb5e2e9bad822f0abd944e539e9bbf58/Classes/Game.m](https://raw.github.com/freezedev/pirategame/9d5f53b5cb5e2e9bad822f0abd944e539e9bbf58/Classes/Game.m)'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Game.m`: [https://raw.github.com/freezedev/pirategame/9d5f53b5cb5e2e9bad822f0abd944e539e9bbf58/Classes/Game.m](https://raw.github.com/freezedev/pirategame/9d5f53b5cb5e2e9bad822f0abd944e539e9bbf58/Classes/Game.m)'
- en: '`Ship.h`: [https://raw.github.com/freezedev/pirategame/9d5f53b5cb5e2e9bad822f0abd944e539e9bbf58/Classes/Ship.h](https://raw.github.com/freezedev/pirategame/9d5f53b5cb5e2e9bad822f0abd944e539e9bbf58/Classes/Ship.h)'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ship.h`: [https://raw.github.com/freezedev/pirategame/9d5f53b5cb5e2e9bad822f0abd944e539e9bbf58/Classes/Ship.h](https://raw.github.com/freezedev/pirategame/9d5f53b5cb5e2e9bad822f0abd944e539e9bbf58/Classes/Ship.h)'
- en: '`Ship.m`: [https://raw.github.com/freezedev/pirategame/9d5f53b5cb5e2e9bad822f0abd944e539e9bbf58/Classes/Ship.m](https://raw.github.com/freezedev/pirategame/9d5f53b5cb5e2e9bad822f0abd944e539e9bbf58/Classes/Ship.m)'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ship.m`: [https://raw.github.com/freezedev/pirategame/9d5f53b5cb5e2e9bad822f0abd944e539e9bbf58/Classes/Ship.m](https://raw.github.com/freezedev/pirategame/9d5f53b5cb5e2e9bad822f0abd944e539e9bbf58/Classes/Ship.m)'
- en: '`gameplay.json`: [https://raw.github.com/freezedev/pirategame/9d5f53b5cb5e2e9bad822f0abd944e539e9bbf58/gameplay.json](https://raw.github.com/freezedev/pirategame/9d5f53b5cb5e2e9bad822f0abd944e539e9bbf58/gameplay.json)'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gameplay.json`: [https://raw.github.com/freezedev/pirategame/9d5f53b5cb5e2e9bad822f0abd944e539e9bbf58/gameplay.json](https://raw.github.com/freezedev/pirategame/9d5f53b5cb5e2e9bad822f0abd944e539e9bbf58/gameplay.json)'
- en: Adding win and lose conditions
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加胜利和失败条件
- en: The last thing we will do in this chapter is add win and lose conditions for
    our game. Right now, we will just show a text field that displays whether we have
    won or lost.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后一件事情是为我们的游戏添加赢和输的条件。现在，我们将只显示一个文本字段，显示我们是否赢了或输了。
- en: Time for action – being able to win or lose
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 能够赢或输
- en: 'To be able to win or lose the game, use the following steps:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够赢或输游戏，请按照以下步骤操作：
- en: 'In `Ship.h`, add a callback property using the following line of code:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Ship.h`中，使用以下代码行添加一个回调属性：
- en: '[PRE40]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This callback property gets invoked if the ship is equal to or less than zero
    hit points, as shown in the following code:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果飞船的击中点数等于或小于零，则此回调属性会被调用，如下面的代码所示：
- en: '[PRE41]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the `Battlefield.h` file, add two properties for our new text fields as
    shown:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Battlefield.h`文件中，为我们的新文本字段添加两个属性，如下所示：
- en: '[PRE42]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the initializer, add the following piece of code:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在初始化器中，添加以下代码片段：
- en: '[PRE43]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Inside the `onEnterFrame` method, update the progression system by adding the
    winning condition as shown:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onEnterFrame`方法内部，通过添加赢的条件来更新进度系统，如下所示：
- en: '[PRE44]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Run the example to see the result.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例以查看结果。
- en: 'If we now win or lose the game, a text field will be displayed on the screen,
    as shown in the following screenshot:'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们现在赢得或输掉游戏，屏幕上会显示一个文本字段，如下面的截图所示：
- en: '![Time for action – being able to win or lose](img/1509OS_08_10.jpg)'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 – 能够赢或输](img/1509OS_08_10.jpg)'
- en: '*What just happened?*'
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We needed to know the exact point when a ship gets destroyed, so we added a
    callback in steps 1 and 2\. Precisely at the moment when the player ship gets
    destroyed, we wanted to display something to inform that the player has lost the
    game.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要知道飞船被摧毁的确切时刻，因此我们在步骤1和2中添加了一个回调。精确到玩家飞船被摧毁的那一刻，我们想要显示一些信息来告知玩家已经输掉了游戏。
- en: We then added the text fields in steps 3 and 4\. The only thing we needed to
    consider here is that we need to access `self` (the instance itself) inside the
    block. Typically, we can't access any property from `self` in the block, but we
    do need this because the text field is a property on the instance itself. So,
    we needed to use an unsafe reference by using the `__weak` keyword. This is something
    that should be used with caution and, in general, only as a last resort. We also
    needed to make sure that the text fields were added as the last elements to the
    display tree so that they were always on top of all other elements. After we added
    the lose condition, we added the win condition in step 5\. When we ran the example,
    we saw a text popping up if we either lost or won the game.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在步骤3和4中添加了文本字段。这里唯一需要考虑的是，我们需要在块内部访问`self`（实例本身）。通常情况下，我们无法在块中访问`self`的任何属性，但我们需要这样做，因为文本字段是实例本身的属性。因此，我们需要使用`__weak`关键字来使用不安全的引用。这是一件应该谨慎使用的事情，通常情况下，只有作为最后的手段。我们还需要确保文本字段作为最后一个元素添加到显示树中，这样它们就始终位于所有其他元素之上。在添加输掉条件后，我们在步骤5中添加了赢的条件。当我们运行示例时，如果我们输掉或赢掉游戏，我们会看到文本弹出。
- en: Technically, we could also have created the text field dynamically once we won.
    It is best practice, however, to create everything at the beginning, especially
    with complex projects.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，我们也可以在我们赢了之后动态创建文本字段。然而，最佳实践是在一开始就创建所有内容，尤其是在复杂的项目中。
- en: Pop quiz
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小测验
- en: Q1\. `SPPoint` provides a method to get the distance between two points.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. `SPPoint`提供了一个方法来获取两点之间的距离。
- en: 'True'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'True'
- en: 'False'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'False'
- en: Q2\. A finite state machine always needs transitions.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: Q2. 有限状态机始终需要转换。
- en: 'True'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'True'
- en: 'False'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'False'
- en: Q3\. If we want to modify a local variable inside a block, what do we need to
    do?
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: Q3. 如果我们想在块内部修改一个局部变量，我们需要做什么？
- en: Make it a weak reference
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使其成为一个弱引用
- en: Prefix the variable with `__block`
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在变量前加上`__block`
- en: Refactor it to a property
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其重构为属性
- en: Summary
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we learned about artificial intelligence. Specifically, we
    covered fuzzy logic and finite state machines, and we also added more gameplay
    elements.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了人工智能。具体来说，我们涵盖了模糊逻辑和有限状态机，并且还增加了更多的游戏元素。
- en: Now that our game is feature-complete but rough around the edges, let's add
    some audio to our game—which is the topic of the next chapter.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在既然我们的游戏功能完整但边缘粗糙，让我们给我们的游戏添加一些音频——这是下一章的主题。
