- en: Chapter 11. Anti-aliasing Techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章 抗锯齿技术
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Understanding the sampling rate technique
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解采样率技术
- en: Understanding the post processing technique
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解后期处理技术
- en: Implementing fast approximate anti-aliasing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现快速近似抗锯齿
- en: Implementing adaptive anti-aliasing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现自适应抗锯齿
- en: Implementing an antialiased circle geometry
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现抗锯齿圆几何形状
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Anti-aliasing is a technique in computer graphics that improves the quality
    of the rendered image or video output displayed on the screen by minimizing jagged
    lines or the stair-step case effect. The raster screen is composed of hundreds
    of tiny square pixels arranged in a grid format. These pixels are sampled during
    the image rasterization process according to the shape of the geometry. Basically,
    the cause of anti-aliasing is the point sampling. These samples are represented
    by rectangular pixels, which are not sufficient to produce curved shapes. Edges
    in the image, which are round (not horizontal or vertical), are responsible for
    this stair-step case effect as it ends up coloring pixels like a stair arrangement.
    The aliasing problem is not much noticeable when an image or scene is still, but
    as soon as they are in motion, jagged edges are highly visible. The following
    image shows the rendering of an infinite detailed isosceles right triangle (**A**).
    The rasterization stage performs the sampling and displays it on the screen with
    limited sampling grid. Clearly, the stair-step case effect is easily visible on
    the hypotenuse (**B**). However, the edges of the base and perpendicular are aligned
    with horizontal and vertical grid pixels (**C**), thereby causing no jagged edges.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 抗锯齿是计算机图形学中的一种技术，通过最小化锯齿线或阶梯效应来提高屏幕上显示的渲染图像或视频输出的质量。光栅屏幕由成百上千个排列成网格格式的微小正方形像素组成。这些像素在图像光栅化过程中根据几何形状进行采样。基本上，抗锯齿的原因是点采样。这些样本由矩形像素表示，这些像素不足以产生曲线形状。图像中的边缘（圆形而非水平或垂直）负责这种阶梯效应，因为它最终像阶梯一样着色像素。当图像或场景静止时，锯齿问题并不明显，但一旦它们运动起来，锯齿边缘就非常明显。以下图像显示了无限详细等腰直角三角形（**A**）的渲染。光栅化阶段执行采样并在有限的采样网格上显示它。显然，阶梯效应在斜边（**B**）上很容易看到。然而，底边和垂直边的边缘与水平和垂直网格像素（**C**）对齐，因此不会产生锯齿边缘。
- en: 'However, as soon as the triangle rotates, all edges will show the aliased effect:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一旦三角形旋转，所有边缘都会显示出锯齿效应：
- en: '![Introduction](img/5527OT_11_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![简介](img/5527OT_11_01.jpg)'
- en: The anti-aliasing takes samples from nearby or background pixels and blends
    them with the color of the edge pixel to generate a smooth approximation such
    that it minimizes the stair-step case effect and makes the edges appear smooth.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 抗锯齿从附近的或背景像素中采样，并将它们与边缘像素的颜色混合，以生成平滑的近似值，从而最小化阶梯效应，使边缘看起来平滑。
- en: Anti-aliasing can be caused from other various factors, such as specular highlights,
    shadows boundaries, geometry outlines, and so on, resulting in a rapid change
    in the color frequencies.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 抗锯齿可能由其他各种因素引起，例如高光、阴影边界、几何轮廓等，导致颜色频率的快速变化。
- en: 'Anti-aliasing techniques can be categorized into two types: sampling rate and
    post processing techniques.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 抗锯齿技术可以分为两种类型：采样率和后期处理技术。
- en: Understanding the sampling rate technique
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解采样率技术
- en: In sampling rate technique, an increase in the amount of the sample rate in
    a pixel is used to decide the color of the pixel based on samples. This includes
    techniques, such as Super Sample Anti-aliasing (SSAA), Multi Sample Anti-aliasing
    (MSAA), Coverage Sampling Anti-aliasing (CSAA), which is usually driven on GPU
    hardware.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在采样率技术中，通过增加像素中样本率的数量来决定像素的颜色，这是基于样本的。这包括诸如超级采样抗锯齿（SSAA）、多采样抗锯齿（MSAA）、覆盖采样抗锯齿（CSAA）等技术，这些技术通常在GPU硬件上驱动。
- en: How to do it...
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: This section is a bit different from the rest of the *How to do it...* sections
    that we followed in the chapters. In this, we will discuss the various sampling
    rate techniques mentioned previously and the procedural difference between each
    of them. Let's discuss them in detail.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这一节与其他章节中我们遵循的*如何做...*部分略有不同。在本节中，我们将讨论之前提到的各种采样率技术以及它们之间的程序差异。让我们详细讨论一下。
- en: '**Super Sample Anti-aliasing** (**SSAA**): This technique is also known as
    **Full-Scene Anti-Aliasing** (**FSAA**). Here, the scene is first rendered to
    higher resolution and then downsampled to its original resolution by taking the
    average of its neighboring pixels. For example, if a given scene needs to be rendered
    to a resolution of 1920 x 1080, it''s first rendered to a higher resolution of
    3840 x 2160 on an off screen surface and downsampled. The off screen surface is
    four times bigger, resulting in 2 x 2 samples per pixels when downsized to its
    original resolution. The logic of FSAA is simple and results in fine quality,
    but it all comes at a very high computational cost because it requires all pixels
    to be available with the color and depth information per sample. This technique
    was available in early video cards and is no longer widely used in real time applications
    due to its tremendous computation cost.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**超采样抗锯齿**（**SSAA**）：这种技术也被称为**全场景抗锯齿**（**FSAA**）。在这里，场景首先渲染到更高的分辨率，然后通过取其相邻像素的平均值将其下采样到原始分辨率。例如，如果给定的场景需要渲染到1920
    x 1080的分辨率，它首先在一个离屏表面上渲染到3840 x 2160的高分辨率，然后进行下采样。离屏表面是四倍大的，当缩小到原始分辨率时，每个像素产生2
    x 2样本。FSAA的逻辑简单，质量细腻，但它的计算成本非常高，因为它需要每个样本都具有颜色和深度信息。这种技术在早期的显卡中可用，但由于其巨大的计算成本，不再在实时应用中广泛使用。'
- en: '**Accumulation Buffer** (**AA**): This technique is similar to the FSAA, but
    here the buffers are used with the same resolution and with more bits of color
    than the desired image. In order to produce the same 2 x 2 sample per pixel, four
    image buffers are created where each image view is moved half a pixel along the
    *x* or y axis as needed. These images are then summed up in the GPUs accumulation
    buffer and averaged to produce the anti-aliased output. The modern GPUs hardware
    does not have accumulation buffers. Instead, this can be performed using fragment
    shaders. The precision used in the pixel shader must be higher (10 to 16 bits
    per channel) to store the accumulated resultant color. The 8 bit precision may
    result in color banding artifact when blending is performed.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**累积缓冲区**（**AA**）：这种技术与FSAA类似，但在这里使用的缓冲区具有与所需图像相同的分辨率，并且比所需图像具有更多的颜色位。为了产生每个像素的2
    x 2样本，创建了四个图像缓冲区，其中每个图像视图根据需要沿*x*或y轴移动半个像素。然后，这些图像在GPU的累积缓冲区中相加并平均，以产生抗锯齿输出。现代GPU硬件没有累积缓冲区。相反，这可以通过片段着色器来完成。在像素着色器中使用的精度必须更高（每通道10到16位）以存储累积的结果颜色。8位精度在混合时可能会导致颜色带状伪影。'
- en: '**Multi-Sampling Anti-aliasing** (**MSAA**): The large computational cost of
    SSAA results in the advent of MSAA. This technique produces lower acceptable quality,
    but it saves tremendous computation cost and has become the number one choice
    of GPU hardware vendors for a long time. Multisample takes more than one sample
    in the computation process for a given pixel in a single pass. There exists various
    pixel sampling schemes, as shown in the following image:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**多重采样抗锯齿**（**MSAA**）：由于全采样抗锯齿（SSAA）的计算成本较高，因此出现了多重采样抗锯齿。这种技术产生的可接受质量较低，但它节省了大量的计算成本，并且长期以来一直是GPU硬件供应商的首选。多重采样在单次计算过程中对给定像素进行多个样本采样。存在各种像素采样方案，如下面的图像所示：'
- en: '![How to do it...](img/5527OT_11_02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/5527OT_11_02.jpg)'
- en: The sample rate may vary depending on the rate of the change in color frequencies.
    Cases such as shadows and geometry edges show a higher variation. Therefore, it
    requires more samples to process better results. The shading is computed from
    each fragment only once, which makes it faster than SSAA. For each sample, the
    corresponding color and depth information is stored separately.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 样本率可能因颜色频率变化率的不同而不同。例如，阴影和几何边缘的情况变化较大。因此，需要更多的样本来处理更好的结果。着色是从每个片段只计算一次，这使得它比SSAA更快。对于每个样本，相应的颜色和深度信息被分别存储。
- en: 'The following image shows 1x and 4x sampling schemes. In the former case, the
    sampling position is not sufficient to overlap with the green triangle, thereby
    resulting in pixels that are colored in white. However, in the latter case, two
    out of four sampling locations are successfully in the geometry. Therefore, the
    interpolated resultant color falls in between these two colors, the extreme right-hand
    side image shows a shade bar of the 4x sampling scheme:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了1x和4x采样方案。在前者的情况下，采样位置不足以与绿色三角形重叠，因此导致白色着色的像素。然而，在后一种情况下，四个采样位置中有两个成功位于几何形状中。因此，插值后的结果颜色位于这两种颜色之间，最右侧的图像显示了4x采样方案的色阶条：
- en: '![How to do it...](img/5527OT_11_03.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/5527OT_11_03.jpg)'
- en: '**Coverage Sampling Anti-aliasing** (**CSAA**): This technique is an improved
    version compared to MSAA. MSAA stores the color and depth information separately
    for each sample. However, this storage is unnecessary and can be completely avoided.
    The CSAA technique takes advantage of this drawback and avoids separate storages
    for the color and depth information; it uses an index-based approach. In this,
    each subpixel or sample stores an index to the fragment shader to which it''s
    associated. All fragments are stored in a table format, which contains the color
    and depth information. Each fragment is identified by its unique index.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**覆盖采样抗锯齿**（**CSAA**）：这项技术是比MSAA改进的版本。MSAA为每个样本分别存储颜色和深度信息。然而，这种存储是不必要的，并且可以完全避免。CSAA技术利用这一缺点，避免了颜色和深度信息的单独存储；它采用基于索引的方法。在这种情况下，每个子像素或样本存储一个指向与之关联的片段着色器的索引。所有片段都存储在一个表格格式中，其中包含颜色和深度信息。每个片段通过其唯一的索引来识别。'
- en: Understanding the post processing technique
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解后处理技术
- en: In this type of technique, a scene is rendered to an off screen surface and
    processed with anti-aliasing algorithms. The process output is split up on the
    on screen surface. This type of anti-aliasing includes AMD's Morphological Filtering
    (MLAA), Fast Approximate Anti-aliasing (FXAA), Subpixel Morphological Anti-aliasing
    (SMAA), and so on.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种技术中，场景被渲染到离屏表面，并使用抗锯齿算法进行处理。处理输出在屏幕表面分割。这种类型的抗锯齿包括AMD的形态学滤波（MLAA）、快速近似抗锯齿（FXAA）、子像素形态学抗锯齿（SMAA）等。
- en: How to do it...
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this, we will discuss the various post processing techniques mentioned earlier.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将讨论之前提到的各种后处理技术。
- en: '**Fast Approximate Anti-aliasing** (**FXAA**): FXAA is a post-processing filtering
    technique. This filter primarily does two things: it first detects edges and then
    applies the blurring algorithm to aliased edges. Like previous techniques, which
    are hardware dependent, FXAA can be highly useful for cases where anti-aliasing
    options are limited. FXAA gives very good performance. It''s faster compared to
    MSAA and SSAA, making it a preferred choice for the gaming industry. This technique
    works in the image space. Therefore, it can be used in any case, such as the forward
    rendered image or the deferred rendered image:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速近似抗锯齿**（**FXAA**）：FXAA是一种后处理过滤技术。此过滤器主要执行两项任务：首先检测边缘，然后对锯齿边缘应用模糊算法。像之前依赖于硬件的技术一样，FXAA在抗锯齿选项有限的情况下非常有用。FXAA提供了非常好的性能。与MSAA和SSAA相比，它更快，因此成为游戏行业的首选选择。这项技术在工作在图像空间中。因此，它可以在任何情况下使用，例如前向渲染图像或延迟渲染图像：'
- en: '![How to do it...](img/5527OT_11_04.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/5527OT_11_04.jpg)'
- en: '**Forward rendering**: This is the traditional path of the rendering execution
    model, where the geometry is first fed to the vertex shader followed by the fragment
    shader. Finally, the processed visual is rendered to the target. This whole procedure
    consists of four steps:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**前向渲染**：这是渲染执行模型的传统路径，其中首先将几何形状输入到顶点着色器，然后是片段着色器。最后，将处理后的视觉效果渲染到目标。整个过程包括四个步骤：'
- en: The geometry is computed.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算几何形状。
- en: Material characteristics, such as normals, bidirectional tangents, and so on,
    are defined.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 材料特性，如法线、双向切线等，被定义。
- en: The direction of the incident light is computed.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算入射光的方向。
- en: Object surfaces and light interactions are computed.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象表面和光线交互被计算。
- en: '**Deferred rendering**: In the deferred rendering technique, the first two
    steps are separated from the last two steps, performing each of these in discrete
    stages of the rendering pipeline. Here, the scene is divided into two passes.
    The first pass is never used to perform any kind of shading. However, during this
    pass, the vital information required for shading is gathered (position, normals,
    material, and depth) in a set of textures and used in the second pass where the
    direct and indirect light information is computed to light the objects.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**延迟渲染**：在延迟渲染技术中，前两步与最后两步分开，在渲染管道的离散阶段执行每个步骤。在这里，场景被分为两个遍历。第一个遍历永远不会用于执行任何类型的着色。然而，在这个遍历期间，用于着色的必要信息（位置、法线、材料和深度）被收集到一组纹理中，并在第二个遍历中使用，在第二个遍历中计算直接和间接光照信息以照亮对象。'
- en: Implementing fast approximate anti-aliasing
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现快速近似抗锯齿
- en: 'There are two very important factors in anti-aliasing: performance and quality.
    A good anti-aliasing technique must be fast and should produce acceptable quality
    results. FXAA stands very positive on these aspects. It''s faster compared to
    MSAA, which provides roughly 25 percent reduction in performance overhead compared
    to the SSAA technique. This works in the same resolution as the texture, which
    eliminates extra overhead similar to other techniques, where the texture has scaled
    to a higher resolution and then downsampled.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在抗锯齿中有两个非常重要的因素：性能和质量。一个好的抗锯齿技术必须快速，并且应该产生可接受的质量结果。FXAA在这些方面表现非常积极。与MSAA相比，它更快，与SSAA技术相比，性能开销减少了大约25%。它以与纹理相同的分辨率工作，这消除了类似于其他技术的额外开销，在这些技术中，纹理被缩放到更高的分辨率然后下采样。
- en: FXAA works on the specific details of an image; it systematically detects the
    stair-step case effect in the given image and blurs it out. Stair-steps are recognized
    with an edge detection algorithm. Therefore, the quality of edge detection and
    blurring algorithm are very important factors here. An incorrect algorithm may
    miss important edges or detect incorrect edges, which may produce an unpleasant
    quality after blurring.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: FXAA作用于图像的特定细节；它系统地检测给定图像中的阶梯效应并将其模糊掉。阶梯效应通过边缘检测算法识别。因此，边缘检测和模糊算法的质量是这里非常重要的因素。一个错误的算法可能会错过重要的边缘或检测到错误的边缘，这可能导致模糊后的质量不令人满意。
- en: Getting ready
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will implement the FXAA technique. Let's understand this
    implementation at a higher level.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将实现FXAA技术。让我们从更高层次理解这个实现。
- en: The FXAA technique first renders a scene to an off screen surface using the
    **Frame Buffer Objects** (**FBO**). Like other screen space-based techniques,
    which operates a full scene, the FXAA technique can be run on selective areas
    that requires anti-aliasing. FXAA is implemented as a postprocessing shader. It
    detects edges in the rendered scene on the basis of the pixel luminosity. The
    detected edges are then smoothed out using their gradient. Both these processing
    are done under a single pass.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: FXAA技术首先使用**帧缓冲对象**（**FBO**）将场景渲染到离屏表面。与其他基于屏幕空间的技术类似，它操作整个场景，FXAA技术可以在需要抗锯齿的选定区域运行。FXAA作为一个后处理着色器实现，它根据像素亮度检测渲染场景中的边缘。然后使用它们的梯度对这些检测到的边缘进行平滑处理。这两个处理都在单次遍历中完成。
- en: 'This recipe is like any other postprocessing recipe:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱就像任何其他后处理菜谱一样：
- en: Create a FBO with the required dimensions.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建具有所需尺寸的FBO。
- en: Create a scene and render it to the FBO off screen surface.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个场景并将其渲染到离屏FBO表面。
- en: Apply the FXAA technique in a single pass to the FBO-textured scene.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将FXAA技术单次应用到FBO纹理场景中。
- en: Note
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In this recipe, we will describe the third step, where we will implement the
    FXAA algorithm in the fragment shader. For more information on post screen techniques,
    refer to [Chapter 9](ch09.html "Chapter 9. Postscreen Processing and Image Effects"),
    *Postscreen Processing and Image Effects*.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将描述第三步，在那里我们将实现片段着色器中的FXAA算法。有关后屏幕技术的更多信息，请参阅[第9章](ch09.html "第9章。后屏幕处理和图像效果")，《后屏幕处理和图像效果》。
- en: How to do it...
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following code implements the FXAA technique algorithm in the fragment
    shader; this fragment shader operates on an off screen scene texture image:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码在片段着色器中实现了FXAA技术算法；此片段着色器在离屏场景纹理图像上操作：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works...
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The FXAA technique uses an interesting property of the human eye, which is luminosity
    or color brightness; our eyes are highly sensitive to it. Human eyes are very
    much capable of noticing the slightest change in luminosity. Detecting edges with
    color brightness works with almost all types of aliasing effect, such as specular
    or geometric aliasing. Luminosity or grayscale provides the brightness level in
    an image; it's helpful in detecting light and dark regions in the image space.
    The sharp transition in luminosity between two samples hints at the presence of
    an edge.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: FXAA技术利用了人眼的一个有趣特性，即亮度或颜色亮度；我们对它非常敏感。人眼非常能够注意到亮度最轻微的变化。使用颜色亮度检测边缘与几乎所有类型的走样效果一起工作，例如镜面或几何走样。亮度或灰度图提供了图像中的亮度级别；它在检测图像空间中的亮暗区域时很有帮助。两个样本之间亮度的急剧变化暗示了边缘的存在。
- en: 'The FXAA filter implemented in this recipe takes five samplings around the
    current texel and analyzes these for the presence of an edge. The following image
    shows a triangle whose hypotenuse is suffering from the stair-step case effect
    (**A**). A certain section of its edge is processed with the FXAA filter to perform
    the anti-aliasing (**B**). This filter takes five samples and coverts them to
    luminous texels for edge-detection (**C**). This information is used by the blurring
    algorithm to blur the color intensity based on neighboring samples (**D**):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方中实现的FXAA过滤器在当前texel周围进行五次采样，并分析这些采样以检测边缘的存在。以下图像显示了一个斜边受到阶梯效应（**A**）影响的三角形。其边缘的某一部分经过FXAA过滤器处理以执行抗锯齿（**B**）。此过滤器进行五次采样并将它们转换为用于边缘检测的发光texel（**C**）。此信息被模糊算法用于根据相邻样本模糊颜色强度（**D**）：
- en: '![How it works...](img/5527OT_11_05.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/5527OT_11_05.jpg)'
- en: 'The `FBS` contains the size of the current off screen surface texture (FBO)
    and its reciprocal gives the dimension of a unit texel. This unit texel is added
    to the current texel (**M**) in various directions (top, bottom, left, and right)
    to produce new sampling texels **NW** (top-left), **NE** (top-right), **SW** (bottom-left),
    and SE (bottom-right) around the center texel (**M**). As the UV coordinate system
    has the inverted **Y** direction compared to the Cartesian coordinate system,
    we need to invert the North and South directions. As a result, you can see a negative
    sign for the north and south components:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`FBS`包含当前离屏表面纹理（FBO）的大小，其倒数给出单位texel的尺寸。这个单位texel被添加到当前texel（**M**）的各个方向（顶部、底部、左侧和右侧），以产生围绕中心texel（**M**）的新采样texel
    **NW**（左上）、**NE**（右上）、**SW**（左下）和**SE**（右下）。由于UV坐标系统相对于笛卡尔坐标系统具有反转的**Y**方向，我们需要反转南北方向。因此，你可以看到南北分量的负号：'
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `FXAALuma` function calculates the luminous weight for NW, NE, SW, SE and
    M samples as shown in the next image; these weights are used to find the direction
    of the blur.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`FXAALuma`函数根据下一图像计算NW、NE、SW、SE和M样本的发光权重；这些权重用于找到模糊的方向。'
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following image gives the formula to calculate the direction of the edge.
    If the result is a nonzero magnitude for the *x* and *y* component, an edge exists.
    As you can see, the directional formula determines the components of the edge
    direction along the *x* and *y* axis. Now, using this information, blurring can
    be performed in a specific direction:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像给出了计算边缘方向的公式。如果*x*和*y*分量的结果是非零幅度，则存在边缘。正如你所见，方向公式确定了沿*x*和*y*轴的边缘方向分量。现在，使用这些信息，可以在特定方向上进行模糊处理：
- en: '![How it works...](img/5527OT_11_06.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/5527OT_11_06.jpg)'
- en: 'You may have noticed that the direction of *x* is inverted (negative). This
    is because the inverted signs used for north and south components are mentioned
    in the preceding code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到*x*的方向被反转（负值）。这是因为用于北和南分量的反转符号在前面代码中提到：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We have got the direction. Now, we have to determine how far we should blur
    it in the given direction. In order to find the distance, we roughly normalized
    the direction vector in such a way that the smallest components become unity.
    For this, the magnitude of this direction vector (`rcpDirMin`) can be calculated
    taking the reciprocal of the smallest component directional vector. Now, the resultant
    is undefined if there occurs a divide by zero condition. For this, a delta component
    is added. We called this as reduced direction (`dirReduce`):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经得到了方向。现在，我们必须确定在给定方向上应该模糊多远。为了找到距离，我们大致归一化方向向量，使得最小的分量成为单位。为此，可以通过取最小分量方向向量的倒数来计算这个方向向量的模（`rcpDirMin`）。现在，如果发生除以零的情况，结果将是未定义的。为此，添加了一个delta分量。我们称之为减少方向（`dirReduce`）：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The reduced direction calculation is pretty much easy; it''s the maximum value
    of the product of the `FXAA_REDUCE_MUL` constant and the average value of all
    luminous intensities and the `FXAA_REDUCE_MIN` constant. These constants are very
    much dependent on the user observation. Therefore, it can be defined as uniforms
    to allow these experiments:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 减少方向计算相当简单；它是`FXAA_REDUCE_MUL`常量与所有亮度强度的平均值以及`FXAA_REDUCE_MIN`常量乘积的最大值。这些常量非常依赖于用户的观察。因此，可以将它们定义为uniforms，以允许进行这些实验：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The unit directional vector can be calculated as `dir = dir * rcpDirMin`, but
    there is another problem here. What if the resultant product is very large. This
    will produce texels, which are far away from the current texel. We certainly don''t
    want this because we are only interested in texels located nearby. So, we need
    to clamp the spanning of this resultant directional vector to some limited range
    using the following path. The `FXAA_SPAN_MAX` is a constant (8.0). The division
    of the result with FBS gives us the direction of the texture space for a unit
    texel in the UV direction:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 单位方向向量可以计算为`dir = dir * rcpDirMin`，但这里还有一个问题。如果结果乘积非常大，这将产生远离当前texel的texels。我们当然不希望这样，因为我们只对附近的texels感兴趣。因此，我们需要使用以下方法将这个结果方向向量的跨度限制在某个有限范围内。`FXAA_SPAN_MAX`是一个常量（8.0）。结果除以FBS给出了UV方向中单位texel在纹理空间的方向：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we have the directional magnitude for blurring purposes. To perform the
    blur, take two samples along the same direction of the edge. The first sample,
    `rgbA` uses one-sixth of the forward (*dir * (2.0/3.0 - 0.5)*) and backward (*dir
    *(1.0/3.0 - 0.5)*) direction (*dir*) to calculate two samples from the `Tex1`
    texture. The resultant intensity is reduced by half:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了用于模糊的方向模。为了执行模糊，沿着边缘的相同方向取两个样本。第一个样本`rgbA`使用前向（*dir * (2.0/3.0 - 0.5)）和后向（*dir
    * (1.0/3.0 - 0.5)）方向（*dir*）从`Tex1`纹理中计算两个样本。结果强度减少到一半：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Similarly, the other sample, namely, `rgbB,` also comprises of two inner samples,
    which are half in the forward (*dir * (3.0/3.0 - 0.5)*) and backward (*dir * (0.0/3.0
    - 0.5*) direction from the current texel. Here, the resultant intensity is reduced
    by one-fourth and mixed with the resultant of `rgbA`. As the intensity of `rgbA`
    is already reduced by half, it''s further reduced to one-fourth before mixing
    it with the resultant sampling vectors:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，另一个样本，即`rgbB`，也包含两个内部样本，它们分别位于当前texel的前向（*dir * (3.0/3.0 - 0.5)）和后向（*dir
    * (0.0/3.0 - 0.5)）方向，各占一半。在这里，结果强度减少到四分之一，并与`rgbA`的结果混合。由于`rgbA`的强度已经减少到一半，因此在混合之前进一步减少到四分之一：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'These two sample vectors (`rgbA` and `rgbB`) are used to perform a test to
    check if the sampled texture is too far. For this, we calculate the minimum and
    maximum luminosity from the given samples in `lumaMin` and `lumaMax`. Similarly,
    compute the luminosity for `lumaB` and store it in the `rgbB` variable:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个样本向量（`rgbA`和`rgbB`）用于执行测试，以检查采样纹理是否太远。为此，我们从给定的样本中计算最小和最大亮度，分别存储在`lumaMin`和`lumaMax`中。同样，计算`lumaB`的亮度并将其存储在`rgbB`变量中：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If the luminosity of `rgbB` is less than the minimum luminosity or greater
    than the maximum one, clearly, it''s outside the expected range of the luminosity
    that we sampled. In this case, we will color the current fragment with `rgbA`,
    which is much closer to the sampled directed edge. On the other hand, if the luminosity
    range is within the expected range, use the `rgbB` color:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`rgbB`的亮度小于最小亮度或大于最大亮度，显然它超出了我们采样亮度的预期范围。在这种情况下，我们将使用`rgbA`着色当前片段，它更接近于采样的定向边缘。另一方面，如果亮度范围在预期范围内，则使用`rgbB`颜色：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There's more...
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: 'In this section, we will discuss the advantages and disadvantage of using FXAA:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论使用FXAA的优点和缺点：
- en: '**Advantages**:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点**:'
- en: FXAA is faster compared to MSAA and yet consumes less memory.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与MSAA相比，FXAA更快，但占用的内存更少。
- en: This technique works in the image space as a filter. Therefore, it's easy to
    integrate it into the shader and does not require a highly computational cost.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种技术作为图像空间中的过滤器工作。因此，它很容易集成到着色器中，并且不需要高计算成本。
- en: FXAA smoothens edges that are produced by alpha-blended textures and those resulted
    from fragment shader effects. It works on any technique, such as forward images
    or defer-rendered images.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FXAA平滑了由alpha混合纹理和片段着色器效果产生的边缘。它适用于任何技术，例如前向图像或延迟渲染图像。
- en: The cost of anti-aliasing is independent of the cost of rendering a scene. Therefore,
    the executional time for anti-aliasing a complex scene with millions of vertices
    and hundreds of texture is the same as a simple one, which contains a few hundred
    vertices with a handful of textures.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抗锯齿的成本与渲染场景的成本无关。因此，对包含数百万个顶点和数百个纹理的复杂场景进行抗锯齿的执行时间与包含数百个顶点和少量纹理的简单场景相同。
- en: The FXAA technique can be combined with other postprocessing filtering techniques.
    This will completely remove the extra cost of the anti-aliasing pass.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FXAA技术可以与其他后处理过滤技术结合使用。这将完全消除抗锯齿通过的额外成本。
- en: If the information is available ahead of time to know which parts of the scene
    are going to be anti-aliased, using features, such as scissor testing, viewport
    information, the FXAA can be applied to selected regions.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果提前知道哪些场景部分将要进行抗锯齿处理，可以使用诸如剪裁测试、视口信息等特性，将FXAA应用于所选区域。
- en: '**Disadvantages**:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺点**:'
- en: It requires a good quality edge detection algorithm; a poor quality algorithm
    may miss some of the edges that need to be aliased.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它需要一个高质量的边缘检测算法；一个低质量的算法可能会错过一些需要抗锯齿的边缘。
- en: Similarly, a good blurring algorithm needs to blur correct results.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，一个好的模糊算法需要模糊出正确的结果。
- en: It does not handle the temporal anti-aliasing.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不处理时间抗锯齿。
- en: Note
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Temporal anti-aliasing causes the rendering objects to hop to appear to jump
    instead of giving an impression of smoothly moving objects towards them. The reason
    behind this kind of behavior is the rate at which the scene is sampled; the sampling
    rate is much lower compared to the transformation speed of objects in the scene.
    In order to avoid temporal anti-aliasing effects, the sampling rate of a scene
    must be at least twice as high as the fastest moving object.
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 时间抗锯齿会导致渲染对象跳跃出现，给人一种物体突然跳动的印象，而不是给人一种物体平滑移动的印象。这种行为的背后原因是场景采样的速率；与场景中对象的变换速度相比，采样速率要低得多。为了避免时间抗锯齿效果，场景的采样率必须至少是最快移动对象的两倍。
- en: See also
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the *Procedural texture shading with texture coordinates* recipe in
    [Chapter 6](ch06.html "Chapter 6. Working with Shaders"), *Working with Shaders*
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考[第6章的“使用纹理坐标进行过程纹理着色”配方](ch06.html "第6章。使用着色器")，*使用着色器*
- en: Refer to the *Implementing render to texture with Frame Buffer Objects* recipe
    in [Chapter 7](ch07.html "Chapter 7. Textures and Mapping Techniques"), *Textures
    and Mapping Techniques*
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考[第7章的“使用帧缓冲对象实现渲染到纹理”配方](ch07.html "第7章。纹理和映射技术")，*纹理和映射技术*
- en: Implementing adaptive anti-aliasing
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现自适应抗锯齿
- en: The adaptive anti-aliasing mitigates the aliasing effects caused during the
    implementation of procedural shaders. As procedural shaders are programmed to
    produce dynamic textures, transition from the low to high frequency is very much
    known to the programmer, as they are the one to program it. For example, the polka
    dot recipe implementation generates dot patterns using a circle or sphere computational
    logic. It paints the fragment shader with one type of color if it falls inside
    the circle; otherwise, it uses the background color. In this case, the programmer
    knows very well that the transition from one color to another will be very sharp.
    This is where adaptive anti-aliasing is useful. It avoids such sharp color transitions
    by interpolating colors between two colors. These sharp transitions can be made
    smoother using many built-in shading language APIs, such as smooth, mix, and clamp.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 自适应抗锯齿减轻了在实现进程式着色器过程中产生的锯齿效应。由于进程式着色器是编程来生成动态纹理的，从低频到高频的过渡对程序员来说非常清楚，因为他们是编写它的人。例如，圆点图案的实现使用圆或球体计算逻辑生成点图案。如果片段着色器落在圆内，它将用一种颜色绘制；否则，它使用背景颜色。在这种情况下，程序员非常清楚从一种颜色到另一种颜色的过渡将非常尖锐。这就是自适应抗锯齿发挥作用的地方。它通过在两种颜色之间插值颜色来避免这种尖锐的颜色过渡。这些尖锐的过渡可以通过许多内置的着色语言API（如smooth、mix和clamp）来使它们更加平滑。
- en: In this recipe, we will produce an animated strip pattern and remove the aliasing
    effects on the strip edges by implementing an anti-aliasing procedural texture.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将通过实现抗锯齿的进程式纹理来生成一个动画条纹图案并移除条纹边缘的锯齿效应。
- en: How to do it...
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Use the following fragment shader to implement the adaptive anti-aliasing:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下片段着色器来实现自适应抗锯齿：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: This recipe implements animated horizontal strip patterns. It uses the vertical
    component of object coordinates to produce this pattern. The object coordinates
    of the 3D mesh model on which the pattern is to be generated are passed on to
    the vertex shader, where it's shared with the fragment shader in the `objectY`
    variable. The vertical component of these object coordinates are added with the
    `offset` variable. The offset variable is a function of time. This animates the
    strip pattern by displacing it from its last position to some new position each
    time a new frame is rendered. These strip patterns will animate continuously from
    the top to bottom direction.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方实现了动画水平条纹图案。它使用对象坐标的垂直分量来生成这个图案。要生成图案的3D网格模型的对象坐标被传递到顶点着色器，在那里它在`objectY`变量中与片段着色器共享。这些对象坐标的垂直分量与`offset`变量相加。`offset`变量是时间的函数。每次渲染新帧时，通过将其从最后的位置移动到某个新位置来通过位移动画条纹图案。这些条纹图案将从顶部到底部方向连续动画。
- en: 'The `Frequency` variable controls the number of strips on an object. It is
    multiplied with object coordinates to scale its range. The `fract()` API of the
    shading language produces a decimal number ranging form 0.0 to 0.9, producing
    a pattern (**A**) that resembles a sawtooth. Multiplying these values with two
    and subtracting by one, we get a function that restricts the range between -1.0
    and 1.0 (**B**). Finally, taking these absolute values produces a positive continuous
    range that varies from 1.0 to 1.0 (**C**), which are stored in the triangle variable:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`Frequency`变量控制对象上的条纹数量。它与对象坐标相乘以缩放其范围。着色语言的`fract()` API产生一个从0.0到0.9的小数，产生一个类似于锯齿的图案（**A**）。将这些值乘以2并减去1，我们得到一个限制在-1.0和1.0之间的范围的功能（**B**）。最后，取这些绝对值产生一个从1.0到1.0的正连续范围（**C**），这些值存储在三角形变量中：'
- en: '![How it works...](img/5527OT_11_07.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/5527OT_11_07.jpg)'
- en: 'The strip pattern produces using the GLSL step API. This API returns 0.0 if
    the triangle is smaller than 0.5 and 1.0 if bigger, as show in the following figure
    (**D**):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GLSL step API生成的条纹图案。此API如果三角形小于0.5则返回0.0，如果大于则返回1.0，如下面的图所示（**D**）：
- en: '![How it works...](img/5527OT_11_08.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/5527OT_11_08.jpg)'
- en: 'The output produced by the `step` API is shown in the following image (refer
    to the left-hand side of the red line). Clearly, aliased effects can be seen easily
    because output values switch from 0.0 to 1.0 and vice versa directly. This aliasing
    effect can be removed using an alternate API of GLSL called `smoothstep`. This
    API takes two parameters as an input value and performs the interpolation between
    the two. It avoids a sharp transition and interpolates a smooth range, as shown
    in the preceding image (**E**). Two input parameters in the `smoothstep` API are
    functions of the partial derivatives of the object coordinates along the *x* and
    *y* components:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`step` API生成的输出显示在以下图像中（参考红色线的左侧）。很明显，由于输出值直接从0.0切换到1.0，反之亦然，因此锯齿效应很容易看到。这种锯齿效应可以使用GLSL的另一个API
    `smoothstep` 来消除。这个API接受两个参数作为输入值，并在两者之间执行插值。它避免了尖锐的过渡，并插值出一个平滑的范围，如前图（**E**）所示。`smoothstep`
    API中的两个输入参数是对象坐标沿*x*和*y*分量的偏导数的函数：'
- en: '![How it works...](img/5527OT_11_09.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/5527OT_11_09.jpg)'
- en: See also
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the *Procedural texture shading with texture coordinates* recipe in
    [Chapter 6](ch06.html "Chapter 6. Working with Shaders"), *Working with Shaders*
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考[第6章](ch06.html "第6章。使用着色器")中的*使用纹理坐标进行程序纹理着色*食谱，*使用着色器*
- en: '*Implementing an anti-aliased circle geometry*'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实现抗锯齿圆几何形状*'
- en: Implementing an anti-aliased circle geometry
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现抗锯齿圆几何形状
- en: A circle is a very common geometric shape that is widely used across a variety
    of computer graphics application, such as rendering statistics with pie graphs,
    drawing sign boards, animating dot patterns, and so on. In this recipe, we will
    implement an antialiased circle geometry with the help of texture coordinates
    and make it smoother using the adaptive anti-aliasing technique from the previous
    recipe.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 圆是一个非常常见的几何形状，在各种计算机图形应用中被广泛使用，例如用饼图渲染统计数据、绘制标志牌、动画点图案等等。在本食谱中，我们将借助纹理坐标实现一个抗锯齿圆几何形状，并使用之前食谱中的自适应抗锯齿技术使其更加平滑。
- en: One way to implement the antialiased circle geometry is to generate a set of
    vertices along the circumference of the circle, where every two consecutive vertices
    are connected to the center vertex (origin), creating a triangular slice. Several
    such slices are required to create the skeleton of the circle, as shown in the
    following image. When these vertices are rendered with the triangle primitive,
    they produce a filled circle pattern. The smoothness of the produced circle shape
    is highly dependent on the number of vertices used along the circumference. The
    use of more vertices may degrade its performance as we try to achieve smoother
    edges along the circumference.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 实现抗锯齿圆几何形状的一种方法是在圆的周长上生成一组顶点，其中每两个连续的顶点都连接到中心顶点（原点），形成一个三角形切片。需要多个这样的切片来创建圆的骨架，如图所示。当这些顶点使用三角形原语渲染时，它们会产生一个填充的圆形图案。产生的圆形形状的平滑度高度依赖于沿周长使用的顶点数量。使用更多的顶点可能会降低其性能，因为我们试图在周长上实现更平滑的边缘。
- en: '**Advantages**:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点**:'
- en: As the circle geometry is represented with the vertices itself, the collision
    detection and pick test will be highly accurate.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于圆的几何形状是通过顶点本身来表示的，因此碰撞检测和拾取测试将非常准确。
- en: '**Disadvantages**:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺点**:'
- en: More and more vertices are required for smoother edges. Eventually, this comes
    at a cost of more performance overhead.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了使边缘更加平滑，需要越来越多的顶点。最终，这会带来更多性能开销。
- en: By default, the edges of the circle are not anti-aliasing. Such geometric techniques
    may be very complex in terms of implementation.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，圆的边缘没有抗锯齿。这类几何技术从实现角度来看可能非常复杂。
- en: Changes in the dimension of the geometry may surface the aliased edges:![Implementing
    an anti-aliased circle geometry](img/5527OT_11_10.jpg)
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几何形状尺寸的变化可能会暴露出锯齿边缘：![实现抗锯齿圆几何形状](img/5527OT_11_10.jpg)
- en: In an alternate, we can use procedural shaders to produce circular geometries
    with the help of texture coordinates. One thing to note here is that the circle
    geometry produced in this technique is not a really a circle; it's a fake geometry
    that only comprises of four vertices. Irrespective of how big the circle is, it
    always uses the same number of vertices (4) to render a circle shape.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用程序着色器，借助纹理坐标生成圆形几何形状。需要注意的是，这种技术产生的圆形几何形状实际上并不是真正的圆形；它是一个由四个顶点组成的假几何形状。无论圆的大小如何，它始终使用相同数量的顶点（4个）来渲染圆形形状。
- en: The basic principle of this technique is very simple. It uses four vertices
    to create a square and produces a perfect logical circle inscribed in it. Fragments
    that fall inside this circle are colored and the rest are masked by the alpha
    channel.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术的原理非常简单。它使用四个顶点创建一个正方形，并产生一个完美的逻辑圆，该圆内嵌其中。落在该圆内的片段被着色，其余的片段通过 alpha 通道被屏蔽。
- en: The circumference or edges of the circle are made smoother by processing it
    with the adaptive anti-aliasing technique. Here, a small portion along the circumference
    is interpolated from inside to outside to produce a smooth gradient.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通过自适应抗锯齿技术处理，圆的周长或边缘变得更加平滑。在这里，沿着周长的一小部分从内部插值到外部，以产生平滑的渐变。
- en: Getting ready
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s take a look at the high level implementation of this recipe:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个菜谱的高级实现：
- en: Create a quad with vertices, as shown in the following image. The center of
    the quad must be at the origin (0.0, 0.0, 0.0).
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有顶点的四边形，如下面的图像所示。四边形的中心必须位于原点（0.0, 0.0, 0.0）。
- en: Assign each vertex with a texture coordinate as follows. As per the texture
    coordinate convention, the origin always exists at the bottom-left part of the
    quad:![Getting ready](img/5527OT_11_11.jpg)
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式为每个顶点分配一个纹理坐标。根据纹理坐标惯例，原点始终位于四边形的左下角：![准备工作](img/5527OT_11_11.jpg)
- en: Specify the winding of vertices in an anticlockwise direction (**V0** > **V1**
    > **V2** > **V3**).
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以逆时针方向指定顶点的环绕顺序（**V0** > **V1** > **V2** > **V3**）。
- en: In the fragment shader, subtract each texture coordinate with a half vector
    along the UV direction. This will displace the origin from the bottom-left to
    the center of the quad.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在片段着色器中，将每个纹理坐标与沿 UV 方向的半向量相减。这将使原点从左下角移动到四边形的中心。
- en: Check each fragment distance from the displaced origin. If the current fragment
    is inside the outer radius range (say 0.5), then paint it with the required color;
    otherwise, alpha blend the fragment with the background color.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查每个片段与偏移原点的距离。如果当前片段位于外半径范围内（例如 0.5），则用所需颜色绘制它；否则，将片段与背景颜色进行 alpha 混合。
- en: For anti-aliasing, take another radii called inner radius with a value smaller
    than the outer radii (say 0.4) and interpolate the color value based on the weight
    calculated from the position of the fragment texture coordinate inside the region
    between the inner and outer radii [0.4 0.5].
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于抗锯齿，取另一个半径称为内半径，其值小于外半径（例如 0.4），并根据从内半径和外半径之间（[0.4 0.5]）的片段纹理坐标位置计算出的权重来插值颜色值。
- en: How to do it...
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Here are the steps to understand the step-by-step implementation of this recipe:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 理解此菜谱逐步实现的步骤如下：
- en: Create a class called `Circle` in `Circle.h`/`.cpp`.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Circle.h`/`.cpp` 中创建一个名为 `Circle` 的类。
- en: 'In the class constructor, define the vertex and texture coordinate in the vertices
    and `texCoords` variables respectively:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类构造函数中，分别在 `vertices` 和 `texCoords` 变量中定义顶点和纹理坐标：
- en: '[PRE12]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create the vertex shader file called `AACircleVertex.glsl`:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `AACircleVertex.glsl` 的顶点着色器文件：
- en: '[PRE13]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Similarly, create `AACircleFragment.glsl` and add the following code:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，创建 `AACircleFragment.glsl` 并添加以下代码：
- en: '[PRE14]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Define the scene in the `NativeTemplate.cpp`, as shown in the following code:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `NativeTemplate.cpp` 中定义场景，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'This recipe mainly consists of two parts: the creation of the circle and smoothening
    the edges of the created circle. In the first part, the geometry is defined to
    create a base shape. The base shape is made up of four vertices to create a perfect
    square. These vertices are shared with the vertex shader to produce eye coordinates.
    Each of the vertex contains associated texture coordinates that are also passed
    on to the vertex shader and shared with the fragment shader. The fragment shader
    controls the shaded region of the perfect square in such a way that it appears
    as a perfect circle. All this is done using the texture coordinate manipulation.
    The following image shows the incoming texture coordinates mapped on the square
    geometry (**A**). As you can see, the origin in the first image appears in the
    bottom-left corner. This origin is logically moved to the center part of the square
    (**B**) by subtracting the texture coordinate with half the total dimension of
    the texture coordinate span in the UV direction.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方主要包含两个部分：创建圆形和光滑创建圆形的边缘。在第一部分，定义了几何形状以创建基础形状。基础形状由四个顶点组成，以创建一个完美的正方形。这些顶点与顶点着色器共享，以产生视点坐标。每个顶点都包含相关的纹理坐标，这些坐标也被传递到顶点着色器并与片段着色器共享。片段着色器以这种方式控制完美正方形的着色区域，使其看起来像一个完美的圆形。所有这些操作都是通过纹理坐标操作完成的。以下图像显示了映射到正方形几何形状上的输入纹理坐标（**A**）。如图所示，第一幅图中的原点出现在左下角。这个原点通过从UV方向上纹理坐标跨度的一半减去纹理坐标，逻辑上移动到正方形的中心部分（**B**）。
- en: 'This way, all texture coordinates get displaced with respect to the new origin
    in the center of the square:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，所有纹理坐标都相对于正方形中心的新的原点发生位移：
- en: '[PRE16]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The distance of the displaced texture coordinate is calculated and checked
    against the circle radii. If it''s smaller than the given radii, it means that
    it''s inside the circle and needs to be painted with `PaintColor`. The inner part
    will be colored with alpha 1.0 to appear solid. If the distance of the current
    fragment texture coordinate appears outside the given radius, then it''s colored
    with alpha 0.0\. This will make the outer part of the circle disappear:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 计算并检查位移纹理坐标的距离，并与圆半径进行比较。如果它小于给定的半径，则意味着它在圆内，需要用`PaintColor`进行绘制。内部部分将以alpha
    1.0着色，以看起来是实心的。如果当前片段纹理坐标的距离看起来在给定的半径之外，则用alpha 0.0着色。这将使圆的外部部分消失：
- en: '![How it works...](img/5527OT_11_12.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/5527OT_11_12.jpg)'
- en: 'The second part of this technique makes the edges soft by processing it through
    adaptive anti-aliasing. For this, two radii (`InnerRadius` and `OuterRadius`)
    are used, as shown in the preceding image (**C**). Fragments that fall under the
    band of these two radii are interpolated for their color values on the basis of
    the weights obtained from the position of the texture coordinate in this band:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术的第二部分通过自适应抗锯齿处理使其边缘变得柔和。为此，使用两个半径（`InnerRadius`和`OuterRadius`），如图所示的前一个图像（**C**）。位于这两个半径带之下的片段将根据从该带中纹理坐标的位置获得的权重插值其颜色值：
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![How it works...](img/5527OT_11_13.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/5527OT_11_13.jpg)'
- en: 'This technique has some pros and cons:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术有一些优点和缺点：
- en: '**Pros**:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点**:'
- en: This technique is highly performance efficient.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种技术具有很高的性能效率。
- en: This technique produces high quality circle shapes with smooth edges.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种技术可以产生具有平滑边缘的高质量圆形形状。
- en: Edge sharpness can be adjusted at runtime.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边缘的尖锐度可以在运行时进行调整。
- en: The border of the circle can be rendered.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 圆的边缘可以被渲染。
- en: Scaling does not effect the quality of the image. It can be adaptive.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩放不会影响图像质量。它可以自适应。
- en: '**Cons**:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺点**:'
- en: This technique cannot perform the collision detection or pick test with high
    accuracy.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种技术无法以高精度执行碰撞检测或拾取测试。
- en: This technique produces high quality shapes with smooth edges.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种技术可以产生具有平滑边缘的高质量形状。
- en: See also
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the *Creating a circular pattern and making them revolve* recipe in
    [Chapter 6](ch06.html "Chapter 6. Working with Shaders"), *Working with Shaders*
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考[第6章](ch06.html "第6章。使用着色器")中关于*创建圆形图案并使其旋转*的配方，*使用着色器*
- en: '*Implementing adaptive anti-aliasing*'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实现自适应抗锯齿*'
