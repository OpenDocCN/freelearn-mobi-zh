- en: Chapter 6. Map, Filter, and Reduce
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章：映射、过滤和归约
- en: In previous chapters, we briefly touched on the `map` function as an example
    of built-in higher-order functions. In this chapter, we will explore this topic
    further and get familiar with `map`, `flatMap`, `filter`, and `reduce` functions
    in Swift with examples. We will also get familiar with the category theory concepts
    such as Monad, Functor, and Applicative Functor.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们简要介绍了`map`函数作为内置高阶函数的例子。在本章中，我们将进一步探讨这个主题，并通过示例熟悉Swift中的`map`、`flatMap`、`filter`和`reduce`函数。我们还将熟悉诸如模态、函子和应用函子等范畴论概念。
- en: 'This chapter will cover the following topics with coding examples:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将通过代码示例涵盖以下主题：
- en: Functor
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函子
- en: Applicative Functor
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用函子
- en: Monad
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模态
- en: Map
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射
- en: FlatMap and flatten
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平铺和扁平化
- en: Filter
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤
- en: Reduce
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 归约
- en: Apply
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用
- en: Join
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接
- en: Chaining higher-order functions
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接高阶函数
- en: Zip
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Zip
- en: Practical examples
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际例子
- en: Collections are used everywhere in our day-to-day development, and to be able
    to use collections declaratively, we need means such as `map`, `filter`, and `reduce`.
    Before going through these functions that are built-in into Swift, let's explore
    the theoretical background of these concepts.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的日常开发中，集合被到处使用，为了能够声明式地使用集合，我们需要像`map`、`filter`和`reduce`这样的手段。在探讨这些内置到Swift中的函数之前，让我们探索这些概念的理论背景。
- en: Functor
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函子
- en: The name of Functor comes from the category theory. In the category theory,
    a Functor contains morphisms such as a `map` function, which transforms the Functor.
    We can think about a Functor as a functional design pattern.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 函子的名称来源于范畴论。在范畴论中，函子包含诸如`map`函数这样的态射，它转换函子。我们可以将函子视为一种函数式设计模式。
- en: Knowing the category theory is great but we do not have to, so simply put, a
    Functor is a structure that we can map over. In other words, a Functor is any
    type that implements the `map` function. Examples of Functors are `Dictionary`,
    `Array`, `Optional`, and `Closure` types. Whenever we talk about Functors, the
    first thing that comes to our mind is that we can call the `map` function over
    them and transform them.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 了解范畴论很好，但我们不必这样做，简单来说，函子是我们可以在其上映射的结构。换句话说，函子是任何实现了`map`函数的类型。函子的例子包括`Dictionary`、`Array`、`Optional`和`Closure`类型。每当谈到函子时，我们首先想到的是我们可以调用`map`函数来操作和转换它们。
- en: Unlike its name, the concept is very simple. We will talk about the `map` function
    in more detail in the upcoming sections and explore the usage of Functors.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 与其名字不同，这个概念非常简单。我们将在接下来的部分中更详细地讨论`map`函数，并探索函子的用法。
- en: Applicative Functor
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用函子
- en: The name of Applicative Functor also comes from the category theory and we can
    think of an **Applicative Functor** as a functional design pattern.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 应用函子的名称也来自范畴论，我们可以将**应用函子**视为一种函数式设计模式。
- en: An Applicative Functor is a Functor equipped with a function that takes a value
    to an instance of a Functor containing that value. Applicative Functors provide
    us the ability to operate on not just values, but values in a functorial context,
    such as optionals, without needing to unwrap or `map` over their contents.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 应用函子是一种配备了将值映射到包含该值的函子实例的函数的函子。应用函子为我们提供了在函子上下文中操作值的能力，例如可选值，而无需解包或对它们的内容进行`map`操作。
- en: Let's suppose that we have an optional Functor (an optional that has the `map`
    function). We cannot directly apply the `map` function on optionals as we need
    to unwrap them first. Applicative Functors come to the rescue. They add a new
    function, for instance, `apply` to the Functor to make it possible to apply `map`
    on the Functor. Again, unlike its name, the concept is simple; we will talk about
    the `apply` function in an upcoming section.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个可选函子（一个具有`map`函数的可选值）。我们不能直接在可选值上应用`map`函数，因为我们需要先解包它们。应用函子就派上用场了。它们为函子添加了一个新函数，例如`apply`，使得可以在函子上应用`map`。再次强调，与它的名字不同，这个概念很简单；我们将在接下来的部分中讨论`apply`函数。
- en: Monad
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模态
- en: The name of Monad comes from the category theory too and again we can think
    of a Monad as a functional design pattern.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 模态的名称也来自范畴论，我们也可以将模态视为一种函数式设计模式。
- en: A Monad is a type of Functor, a type which, along with `map`, implements the
    `flatMap` function. It is simple, right? We have a Functor with an extra functionality
    and that's the `flatMap` implementation. So, any type that we can call `map` and
    `flatMap` functions over are Monads. In the following sections, we will talk about
    `map` and `flatMap` functions.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Monad 是一种 Functor 类型，它是一种类型，除了 `map` 之外，还实现了 `flatMap` 函数。这很简单，对吧？我们有一个具有额外功能的
    Functor，那就是 `flatMap` 实现。所以，任何我们可以对其调用 `map` 和 `flatMap` 函数的类型都是 Monads。在接下来的章节中，我们将讨论
    `map` 和 `flatMap` 函数。
- en: So far, we learned that Functors are structures with `map` functions. Applicative
    Functors are Functors with `apply` functions and Monads are Functors with `flatMap`
    functions. Now, let's talk about these important functions.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们了解到 Functors 是具有 `map` 函数的结构。Applicative Functors 是具有 `apply` 函数的 Functors，而
    Monads 是具有 `flatMap` 函数的 Functors。现在，让我们来谈谈这些重要的函数。
- en: Map
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Map
- en: 'Swift has a built-in higher-order function named `map` that can be used with
    collection types such as arrays. The `map` function solves the problem of transforming
    the elements of an array using a function. The following example presents two
    different approaches to transform a set of numbers:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 内置了一个名为 `map` 的高阶函数，它可以与数组等集合类型一起使用。`map` 函数解决了使用函数转换数组元素的问题。以下示例展示了两种不同的方法来转换一组数字：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first approach to solve the problem is imperative and uses for-in loops
    to go through the collection and transform each element in the array. This iteration
    technique is known as external iteration because we specify how to iterate. It
    requires us to explicitly access the elements sequentially from beginning to end.
    Also, it is required to create a variable that is mutated repeatedly while the
    task is performed in the loop.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的第一种方法是命令式，使用 for-in 循环遍历集合并转换数组中的每个元素。这种迭代技术被称为外部迭代，因为我们指定了如何迭代。它要求我们显式地从开始到结束按顺序访问元素。此外，它还需要在循环执行任务时创建一个被反复修改的变量。
- en: This process is error prone as we could initialize `formattedNumbers` incorrectly.
    Instead of the external iteration technique, we can use the internal iteration
    technique.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程容易出错，因为我们可能会错误地初始化 `formattedNumbers`。而不是使用外部迭代技术，我们可以使用内部迭代技术。
- en: Without specifying how to iterate through the elements or declare and use any
    mutable variables, Swift can determine how to access all the elements to perform
    the task and hide the details from us. This technique is known as internal iteration.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 没有指定如何遍历元素或声明和使用任何可变变量，Swift 可以确定如何访问所有元素以执行任务，并隐藏这些细节。这种技术被称为内部迭代。
- en: 'One of the internal iteration methods is the `map` method. The `map` method
    elegantly simplifies our code and makes it declarative. Let''s examine the second
    approach using the `map` function this time:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 内部迭代方法之一是 `map` 方法。`map` 方法优雅地简化了我们的代码，使其具有声明性。让我们使用 `map` 函数来检查第二种方法：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As seen in this example, we could achieve the same result in one line of code.
    One of the benefits of using `map` is that we can clearly declare the transformation
    that we are trying to apply to the list of elements. The `map` function allows
    us to declare what we want to achieve rather than how it is implemented. This
    makes reading and reasoning about our code simpler.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如此示例所示，我们可以用一行代码实现相同的结果。使用 `map` 的一大好处是我们可以清楚地声明我们试图应用于元素列表的转换。`map` 函数允许我们声明我们想要实现的目标，而不是它的实现方式。这使得阅读和推理我们的代码变得更加简单。
- en: The `map` function can be applied to any container type that wraps a value or
    multiple values inside itself. Any container that provides the `map` function
    becomes the Functor, as we have seen before.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`map` 函数可以应用于任何包含自身内部值或多个值的容器类型。任何提供 `map` 函数的容器都成为 Functor，正如我们之前所看到的。'
- en: We know what the benefits of the `map` function/method usage are and how it
    is used. Let's explore the dynamics of it and create a `map` function.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道 `map` 函数/方法使用的优点以及它的用法。让我们探索它的动态特性并创建一个 `map` 函数。
- en: 'In [Chapter 5](ch05.html "Chapter 5. Generics and Associated Type Protocols")
    , *Generics and Associated Type Protocols*, we had the following example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 5 章](ch05.html "第 5 章。泛型和关联类型协议") 中，*泛型和关联类型协议*，我们有以下示例：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `calculate` function could take `a`, `b`, `funcA`, and `funcB` as parameters.
    Let''s simplify this function with only two parameters and change the return type:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`calculate` 函数可以接受 `a`、`b`、`funcA` 和 `funcB` 作为参数。让我们简化这个函数，只使用两个参数并更改返回类型：'
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, the `calculate` function takes `a` of type `T` and `funcA` that transforms
    `T` into `U`. The `calculate` function returns `U`. Even though this function
    does not work on arrays, it would be easy to add the array transformation:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`calculate` 函数接受类型为 `T` 的 `a` 和将 `T` 转换为 `U` 的 `funcA`。`calculate` 函数返回 `U`。尽管这个函数不适用于数组，但添加数组转换会很容易：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: So far, we have a `calculate` function that takes an array of the generic type
    `T` and a function that transforms an array of `T` into an array of `U` and finally
    returns the transformed array of `U`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个 `calculate` 函数，它接受一个泛型类型 `T` 的数组和一个将 `T` 类型的数组转换为 `U` 类型的数组的函数，并最终返回转换后的
    `U` 类型的数组。
- en: 'By just changing the name of the function and parameters, we can make this
    even more generic. So let''s change the function and parameter names:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 只需更改函数和参数的名称，我们就可以使这个函数更加通用。所以让我们更改函数和参数的名称：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: At this point, we have a half-baked `map` function that takes an array of `T`
    and applies the `transform` function to it to return a transformed array of `U`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个半成品 `map` 函数，它接受一个 `T` 类型的数组，并将其应用于 `transform` 函数，以返回一个转换后的 `U`
    类型的数组。
- en: 'In fact, this function does nothing and mapping happens in the transform. Let''s
    make this function usable and more understandable:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这个函数什么也不做，映射发生在 transform 中。让我们使这个函数可用并更易于理解：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, our `map` function takes an array of elements (domain in the category theory),
    iterates through each element in array, transforms it, and appends it to a new
    array (codomain in the category theory).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的 `map` 函数接受一个元素数组（范畴论中的域），遍历数组中的每个元素，将其转换，并将其追加到新数组中（范畴论中的陪域）。
- en: 'The result will be another array of the `ElementResult` type, which has in
    fact transformed elements of the input array. Let''s test this function:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是一个 `ElementResult` 类型的数组，它实际上已经转换了输入数组的元素。让我们测试这个函数：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The result will be `[12, 32, 93, 52, 102, 41, 76]`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是 `[12, 32, 93, 52, 102, 41, 76]`。
- en: This example shows us that with higher-order functions and generics, we are
    able to define functions such as `map` that are already a part of the Swift language.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子表明，通过高阶函数和泛型，我们能够定义像 `map` 这样的函数，这些函数已经是 Swift 语言的一部分。
- en: 'Now, let''s examine the `map` function provided in Swift:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查 Swift 中提供的 `map` 函数：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This definition is very similar to our implementation with some differences
    that we will cover here.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义与我们的实现非常相似，只是在一些我们将在这里讨论的不同之处。
- en: First of all, this is a method that can be called on collections such as an
    array, so we do not need any input type such as `[ElementInput]`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这是一个可以在数组等集合上调用的方法，因此我们不需要任何如 `[ElementInput]` 这样的输入类型。
- en: Secondly, `@noescape` is an attribute in Swift that is used to communicate to
    the function user that the argument will not live longer than the call. In escape
    scenarios, if the function dispatches to a different thread, an argument may be
    captured so that it will exist at a later time when its needed. The `@noescape`
    attribute ensures that this will not happen for this function.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，`@noescape` 是 Swift 中用于告知函数用户该参数不会比调用持续更长时间的属性。在逃逸场景中，如果函数调度到不同的线程，参数可能会被捕获，以便在需要时在稍后的时间存在。`@noescape`
    属性确保这种情况不会发生。
- en: Finally, `transform` is the name of the parameter. The type of the parameter
    is declared as `(Self.Generator.Element) -> T`. This is a closure that takes an
    argument of the `Self.Generator.Element` type and returns an instance of the `T`
    type. The `Self.Generator.Element` type is the same type of object as the type
    contained in the collection.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`transform` 是参数的名称。参数的类型声明为 `(Self.Generator.Element) -> T`。这是一个闭包，它接受 `Self.Generator.Element`
    类型的参数并返回 `T` 类型的实例。`Self.Generator.Element` 类型与集合中包含的类型相同。
- en: FlatMap and flatten
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FlatMap 和 flatten
- en: 'The `flatMap` method on arrays can be used to flatten one level of dimension
    of an array. The following example presents a two-dimensional array, in other
    words, nested arrays. Calling `flatMap` on this array reduces one dimension and
    flattens it so the resulting array becomes `[1, 3, 5, 2, 4, 6]`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的 `flatMap` 方法可以用来扁平化数组的某一维度的维度。以下示例展示了一个二维数组，换句话说，嵌套数组。在这个数组上调用 `flatMap`
    会减少一个维度并将其扁平化，使得结果数组变为 `[1, 3, 5, 2, 4, 6]`：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this example, `flatMap` returns an `Array` containing the concatenated results
    of the mapping transform over itself. We can achieve the same result by calling
    flatten on our array and then map, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`flatMap` 返回一个包含映射转换结果的 `Array`，我们可以通过在数组上调用 flatten 然后进行 map 来达到相同的结果，如下所示：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To be able to transform each element into an array, we will need to provide
    a `map` method as the closure to the `flatMap` method as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够将每个元素转换为一个数组，我们需要将 `map` 方法作为闭包提供给 `flatMap` 方法，如下所示：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The result will be `[3, 5, 7, 4, 6, 8]`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是 `[3, 5, 7, 4, 6, 8]`。
- en: 'The same result can be achieved with the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下方式获得相同的结果：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s examine another example with an `Array` of three dimensions:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个三维 `Array` 的例子来检查另一个例子：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The resulting array will be `[1, [3, 5], 2, [4, 6]]`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 结果数组将是 `[1, [3, 5], 2, [4, 6]]`。
- en: Therefore, `flatMap` and `flatten` only flatten one dimension, and to handle
    more dimensions and transformations, we need to call the `flatMap` and `map` methods
    multiple times accordingly.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`flatMap` 和 `flatten` 只能扁平化一个维度，要处理更多维度和转换，我们需要相应地多次调用 `flatMap` 和 `map`
    方法。
- en: We also know that `twoDimensionalArray` and `threeDimensionalArray` are Monads,
    as we could call `map` and `flatMap` on them.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还知道 `twoDimensionalArray` 和 `threeDimensionalArray` 是 Monads，因为我们可以在它们上调用
    `map` 和 `flatMap`。
- en: Filter
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤
- en: 'The `filter` function takes a function that, given an element in `Array`, returns
    `Bool` indicating whether the element should be included in the resulting `Array`.
    The `filter` method is declared as follows in Swift:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter` 函数接收一个函数，该函数给定 `Array` 中的一个元素，返回一个 `Bool` 值，指示该元素是否应包含在结果 `Array`
    中。在 Swift 中，`filter` 方法声明如下：'
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The definition is similar to the `map` method with the following differences:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 其定义与 `map` 方法类似，但有以下区别：
- en: The `filter` function takes a closure that receives elements of itself and returns
    a `Bool` value
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter` 函数接收一个闭包，该闭包接收自身元素并返回一个 `Bool` 值'
- en: The result of the `filter` method will be an array of its own type
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter` 方法的输出将是一个其自身类型的数组'
- en: 'Let''s examine the following code to understand how it works:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查以下代码以了解其工作原理：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The resulting `evenNumbers` array will be `[10, 30, 50, 100, 74]`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的 `evenNumbers` 数组将是 `[10, 30, 50, 100, 74]`。
- en: 'Let''s implement the `filter` function ourselves. In fact, its implementation
    is going to be similar to the implementation of `map`, except that it does not
    require a second generic specifying the codomain. Instead, it conditionally adds
    the original elements to the new `Array`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们亲自实现 `filter` 函数。实际上，它的实现将与 `map` 的实现类似，只是它不需要指定第二个泛型来指定陪域。相反，它有条件地将原始元素添加到新的
    `Array` 中：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `filter` function iterates through each element in our `Array` and applies
    the predicate to it. If the result of the predicate function becomes `true`, then
    `element` is added to our new `Array`. We can test our `filter` function as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter` 函数遍历 `Array` 中的每个元素，并对其应用谓词。如果谓词函数的结果为 `true`，则 `element` 被添加到我们的新
    `Array` 中。我们可以如下测试我们的 `filter` 函数：'
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The resulting array will be `[10, 30, 50, 100, 74]`, which is identical to the
    Swift-provided `filter` method.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 结果数组将是 `[10, 30, 50, 100, 74]`，这与 Swift 提供的 `filter` 方法相同。
- en: Reduce
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少
- en: 'The `reduce` function reduces a list into a single value. Often referred to
    as `fold` or `aggregate`, it takes two parameters: a starting value and a function.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce` 函数将列表缩减为一个单一值。通常被称为 `fold` 或 `aggregate`，它接受两个参数：一个起始值和一个函数。'
- en: A function takes a running total and an element of the list as parameters and
    returns a value that is created by combining the elements in the list.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 函数接受一个累计总和和列表中的一个元素作为参数，并返回一个通过组合列表中的元素创建的值。
- en: Unlike `map`, `filter`, and `flatMap`, which would return the same type, `reduce`
    changes the type. In other words, `map`, `filter`, and `flatMap` would take `Array`
    and provide a changed `Array`. This is not the case with `reduce` as it can change
    an array to, for instance, a tuple or single value.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `map`、`filter` 和 `flatMap` 不同，这些方法会返回相同类型的结果，`reduce` 会改变类型。换句话说，`map`、`filter`
    和 `flatMap` 会将 `Array` 转换为改变了的 `Array`。这与 `reduce` 不同，因为它可以将数组转换为元组或单个值。
- en: 'Swift provides the `reduce` method on arrays and has the following definition:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 为数组提供了 `reduce` 方法，其定义如下：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If we use the `reduce` method on our `numbers` `Array`, the result of this
    call becomes `394`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 `numbers` 数组上使用 `reduce` 方法，这次调用的结果变为 `394`：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We could also call `reduce`, as follows, as the `+` operator is a function
    in Swift:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将 `reduce` 称为 `+` 操作符，因为在 Swift 中它是一个函数：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Like the `map` and `filter` methods, developing a `reduce` function is also
    simple:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `map` 和 `filter` 方法一样，开发 `reduce` 函数也很简单：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can achieve the same result (`394`) with the following call:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下调用获得相同的结果（`394`）：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `reduce` method can be used with other types such as arrays of Strings.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce` 方法可以与其他类型一起使用，例如字符串数组。'
- en: The map function in terms of reduce
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 `reduce` 的角度来理解 `map` 函数
- en: 'The reduction pattern is so powerful that every other function that traverses
    a list can be specified in terms of it. Let''s develop a `map` function in terms
    of `reduce`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 减少模式非常强大，以至于任何遍历列表的其他函数都可以用它的术语来指定。让我们用 `reduce` 来开发一个 `map` 函数：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The result is identical to our `map` function's result that we developed earlier
    in this chapter. This is a good example to understand the basics of `reduce`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 结果与我们在本章早期开发的 `map` 函数的结果相同。这是一个理解 `reduce` 基础的好例子。
- en: In the function body, we provide `elements` and an initial empty array of `ElementResult`,
    and finally, we provide a closure to combine the elements.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体中，我们提供 `elements`，一个空的初始 `ElementResult` 数组，最后提供一个闭包来组合元素。
- en: The filter function in terms of reduce
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 `reduce` 的角度来理解 `filter` 函数
- en: 'It is also possible to develop a `filter` function in terms of `reduce`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以开发一个从 `reduce` 的角度来理解的 `filter` 函数：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Again, the result is identical to our previously developed filter function.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，结果与之前开发的 `filter` 函数相同。
- en: In the function body, we provide elements, an empty initial array, and finally
    `predicate` as a combinator.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体中，我们提供 `elements`，一个空的初始 `ElementResult` 数组，最后提供 `predicate` 作为组合器。
- en: The flatMap function in terms of reduce
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 `reduce` 的角度来理解 `flatMap` 函数
- en: 'To understand the power of reduce, we can implement the `flatMap` function
    in terms of reduce as well:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解 `reduce` 的强大之处，我们可以用 `reduce` 来实现 `flatMap` 函数：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The flatten function in terms of reduce
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 `reduce` 的角度来理解 `flatten` 函数
- en: 'Finally, let''s implement the `flatten` function in terms of `reduce`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们用 `reduce` 来实现 `flatten` 函数：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This function takes a two-dimensional array and converts it to a one-dimensional
    array. Let''s test this function:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受一个二维数组并将其转换为单维数组。让我们测试这个函数：
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The result will be `[1, 3, 5, 2, 4, 6]`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是 `[1, 3, 5, 2, 4, 6]`。
- en: Apply
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Apply
- en: Apply is a function that applies a function to a list of arguments.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Apply 是一个将函数应用于一系列参数的函数。
- en: 'Unfortunately, Swift does not provide any `apply` method on `Arrays`. To be
    able to implement Applicative Functors, we need to develop the `apply` function.
    The following code presents a simple version of the `apply` function with only
    one argument:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Swift 并没有在 `Arrays` 上提供任何 `apply` 方法。为了能够实现 Applicative Functors，我们需要开发
    `apply` 函数。以下代码展示了 `apply` 函数的一个简单版本，它只有一个参数：
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `apply` function takes a function and an array of any type and applies
    the function to the first element of the array. Let''s test this function as the
    following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply` 函数接受一个函数和一个任意类型的数组，并将该函数应用于数组的第一个元素。让我们测试这个函数如下：'
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Join
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Join
- en: 'The `join` function takes an array of objects and joins them with a provided
    separator. The following example presents a simple version of join:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`join` 函数接受一个对象数组，并用提供的分隔符将它们连接起来。以下示例展示了 `join` 的一个简单版本：'
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This function takes an array with a separator, joins elements in `Array`, and
    provides a single `String`. We can test it as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受一个带有分隔符的数组，将 `Array` 中的元素连接起来，并提供一个单一的 `String`。我们可以如下测试它：
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The result will be `"First, Second, Third"`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是 `"First, Second, Third"`。
- en: Chaining higher-order functions
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链式调用高阶函数
- en: So far, we learned different functions with some examples for each. Let's see
    if we can combine them to solve problems that we may encounter in our day-to-day
    application development.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们学习了不同的函数，并为每个函数提供了一些示例。让我们看看我们是否可以将它们结合起来解决我们在日常应用开发中可能遇到的问题。
- en: 'Let''s assume that we need to receive an object from a backend system as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要从后端系统接收一个对象，如下所示：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then we need to calculate the total of ages in the `users` array. We can use
    a combination of the `map` and `reduce` functions to calculate `totalAge` as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要计算 `users` 数组中年龄的总和。我们可以使用 `map` 和 `reduce` 函数的组合来计算 `totalAge`，如下所示：
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We were able to chain the map and reduce methods to achieve this.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够通过链式调用 `map` 和 `reduce` 方法来实现这一点。
- en: Zip
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Zip
- en: The `zip` function is provided by the Swift standard library and creates a sequence
    of pairs built out of two underlying sequences, where the elements of the *i^(th)*
    pair are the *i^(th)* elements of each underlying sequence.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip` 函数是由 Swift 标准库提供的，它创建了一个由两个底层序列组成的序列对，其中第 *i^(th)* 对的元素是每个底层序列的第 *i^(th)*
    个元素。'
- en: 'For instance, in the following example, `zip` takes two `Arrays` and creates
    a pair of these two arrays:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在以下示例中，`zip` 接受两个 `Arrays` 并创建这两个数组的配对：
- en: '[PRE34]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The value for `zipped` will be `[("Three", 3), ("Five", 5), ("Nine", 9), ("Ten",
    10)]`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`zipped` 的值将是 `[("Three", 3), ("Five", 5), ("Nine", 9), ("Ten", 10)]`。'
- en: Practical examples
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实际例子
- en: Let's explore some practical examples of higher-order functions.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一些高阶函数的实际例子。
- en: Sum of an array
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组的和
- en: 'We can use `reduce` to calculate the sum of a list of numbers as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `reduce` 来计算数字列表的总和，如下所示：
- en: '[PRE35]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The result will be `55`, as expected.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 预期结果是 `55`。
- en: Product of an array
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组的乘积
- en: 'We can use `reduce` to calculate the product of array values as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `reduce` 来计算数组值的乘积，如下所示：
- en: '[PRE36]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The result will be `3628800`, as expected.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 预期结果是 `3628800`。
- en: Removing nil values from an array
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从数组中移除 `nil` 值
- en: 'We can use `flatMap` to get values out of optional arrays and remove `nil`
    values:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `flatMap` 从可选数组中获取值并移除 `nil` 值：
- en: '[PRE37]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The result will be `["First", "Second", "Fourth"]`, as expected.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 预期结果是 `["First", "Second", "Fourth"]`。
- en: Removing duplicates in an array
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组中的重复项移除
- en: 'We can use `reduce` to remove duplicate elements in an array as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `reduce` 来从数组中移除重复元素，如下所示：
- en: '[PRE38]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The result will be `[1, 2, 3, 4, 5, 6, 7]` as expected.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 预期结果是 `[1, 2, 3, 4, 5, 6, 7]`。
- en: Partitioning an array
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分区数组
- en: 'We can use `reduce` to partition an array with a specific criterion. For instance,
    in the following example, we partition `numbersToPartition` `Array` into two partitions,
    keeping all even numbers in the left partition:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `reduce` 来根据特定标准对数组进行分区。例如，在以下示例中，我们将 `numbersToPartition` 数组分为两个部分，将所有偶数保留在左侧部分：
- en: '[PRE39]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can make this function generic as the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将此函数泛化如下：
- en: '[PRE40]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Summary
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started with the category theory concepts such as Functor,
    Applicative Functor, and Monad and explored higher-order functions such as `map`,
    `filter`, `flatMap`, `flatten`, and `reduce`. Then, we examined Swift-provided
    versions of higher-order functions and implemented a simple version ourselves.
    Also, we developed `map`, `filter`, `flatMap`, and `flatten` functions in terms
    of the `reduce` function.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从范畴论概念如函子（Functor）、应用函子（Applicative Functor）和单子（Monad）开始，探讨了高阶函数如 `map`、`filter`、`flatMap`、`flatten`
    和 `reduce`。然后，我们检查了 Swift 提供的高阶函数版本，并实现了自己的简单版本。此外，我们还根据 `reduce` 函数开发了 `map`、`filter`、`flatMap`
    和 `flatten` 函数。
- en: Then, we continued with the `apply`, `join`, and `zip` functions and were introduced
    to chaining higher-order functions.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们继续使用 `apply`、`join` 和 `zip` 函数，并介绍了高阶函数的链式调用。
- en: Finally, we explored some practical examples of higher-order functions such
    as removing `nil` values from an array, removing duplicates, and partitioning
    arrays.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了高阶函数的一些实际例子，例如从数组中移除 `nil` 值、移除重复项和分区数组。
- en: These functions are going to be great tools in our day-to-day development toolkit
    to use and solve a lot of different kinds of problems.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数将成为我们日常开发工具箱中的优秀工具，用于解决各种不同类型的问题。
- en: In the following chapter, we will get familiar with optional types and discuss
    non-functional and functional ways to deal with them.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将熟悉可选类型，并讨论处理它们的非函数式和函数式方法。
