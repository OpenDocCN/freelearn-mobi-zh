- en: Chapter 5. Beautifying Our Game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章. 美化我们的游戏
- en: '*In the previous chapter, we learned about cross-device compatibility and what
    we need to do if we want to target iPhones and iPads simultaneously. We then set
    up the base for our game. In this chapter, we will begin to add animations to
    our game.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*在上一章中，我们学习了跨设备兼容性以及如果我们想要同时针对 iPhone 和 iPad，我们需要做什么。然后我们为我们的游戏设置了基础。在本章中，我们将开始为我们的游戏添加动画。*'
- en: Working with tweens
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用缓动动画
- en: 'Let''s say we want to move our ship to an edge of the screen. How would we
    go about achieving this? The following are two options to achieve this:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要将我们的船只移动到屏幕的边缘。我们该如何实现这一点？以下是有两种实现这一点的选项：
- en: Move the ship each frame in the direction we want it to move
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将船只移动到我们想要其移动的方向的每一帧
- en: Define two states for our ship and let the processor calculate all the required
    steps for animation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的船只定义两个状态，并让处理器计算动画所需的全部步骤
- en: At first glance, the second option seems to be more attractive. We first need
    to know the initial position of the ship and the position where the ship should
    be after the animation is complete. Sparrow provides the `SPTween` class, which
    does exactly this.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，第二个选项似乎更有吸引力。我们首先需要知道船只的初始位置以及动画完成后船只应处的位置。Sparrow 提供了 `SPTween` 类，它正好能完成这个任务。
- en: We take two values, also called key frames, and interpolate all values in between.
    The name "tween" comes from its in-between states.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们取两个值，也称为关键帧，并插值所有中间值。名称 "tween" 来自其中间状态。
- en: While in this example, we are talking about moving a position explicitly, in
    general, a tween is not confined to animating the position of an entity, but could
    be used to animate its color or any of its other properties.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在讨论显式移动位置，但在一般情况下，缓动动画并不仅限于动画化实体的位置，还可以用来动画化其颜色或其他任何属性。
- en: In Sparrow, specifically, any numeric property of an object can be animated.
    So every property that is available on an `SPDisplayObject` is available for the
    `SPTween` class and its animation abilities.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Sparrow 中，特别是对象的任何数值属性都可以进行动画化。因此，所有在 `SPDisplayObject` 上可用的属性都可用于 `SPTween`
    类及其动画能力。
- en: If we want to implement a fade-out or fade-in effect, all we need to do is to
    animate the `alpha` property of a display object from its maximum to its minimum
    value or vice versa.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要实现淡出或淡入效果，我们只需要对显示对象的 `alpha` 属性进行动画化，从其最大值到最小值或反之。
- en: Let's try this by actually moving the pirate ship.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过实际移动海盗船来尝试一下。
- en: Time for action – moving the pirate ship
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 移动海盗船
- en: 'Let''s follow these steps to move the ship:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤移动船只：
- en: Open our game project file if it's not already open.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果游戏项目文件尚未打开，请打开我们的游戏项目文件。
- en: 'Add an instance variable called `_pirateShip` of the type `SPImage`, as shown
    in following line of code:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `_pirateShip` 的实例变量，类型为 `SPImage`，如下面的代码行所示：
- en: '[PRE0]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Update the references from `pirateShip` to `_pirateShip` in `Battlefield.m`:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Battlefield.m` 中将 `pirateShip` 的引用更新为 `_pirateShip`：
- en: '[PRE1]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add a method called `onBackgroundTouch` in the `Battlefield.m` file, as shown
    in the following line of code:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Battlefield.m` 文件中添加一个名为 `onBackgroundTouch` 的方法，如下面的代码行所示：
- en: '[PRE2]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Within this method, get the touch itself:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此方法中，获取触摸本身：
- en: '[PRE3]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Complete the `onBackgroundTouch` method with the following piece of code:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码片段完成 `onBackgroundTouch` 方法：
- en: '[PRE4]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Register the event listener to the background image as shown in the following
    line of code:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将事件监听器注册到背景图像，如下面的代码行所示：
- en: '[PRE5]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Switch to the `Game.m` file.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到 `Game.m` 文件。
- en: Update the scene director to show the battlefield scene.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新场景导演以显示战场场景。
- en: Run the example and you will get the following output:![Time for action – moving
    the pirate ship](img/1509OS_05_01.jpg)
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例，你将得到以下输出：![行动时间 - 移动海盗船](img/1509OS_05_01.jpg)
- en: '*What just happened?*'
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: In step 1, we opened our Xcode template from where we left off in the previous
    chapter. In order to use a pirate ship in the entirety of our battlefield source
    file, we should move it into an instance variable for the `Battlefield` class,
    which is what we did in step 2.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 1 步中，我们从上一章结束的地方打开了我们的 Xcode 模板。为了在整个战场源文件中使用海盗船，我们应该将其移动到 `Battlefield`
    类的实例变量中，这就是我们在第 2 步中做的。
- en: Now, we need to update the references to the pirate ship which was the task
    for step 3.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要更新对海盗船的引用，这是第 3 步的任务。
- en: After this, we defined the method where we declared what happens if we were
    to touch the background (in our case, the water on the screen). In step 5, we
    got the current touch.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们定义了方法，声明了如果我们触摸背景（在我们的例子中，是屏幕上的水）会发生什么。在第 5 步中，我们获取了当前的触摸。
- en: In step 6, we implemented the actual tween. As soon as we were sure that we
    have the current touch object (as in not a false value such as `nil`), we began
    to animate the pirate ship.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 6 步中，我们实现了实际的补间动画。一旦我们确定我们有了当前的触摸对象（例如，不是像 `nil` 这样的假值），我们就开始动画化海盗船。
- en: 'We created two tweens: the first for the `x` position of the pirate ship and
    the second one for its `y` position. As long as the target and the duration of
    tween are the same, we could actually use a single tween, as shown in the following
    code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个补间动画：第一个用于海盗船的 `x` 位置，第二个用于其 `y` 位置。只要目标和补间动画的持续时间相同，我们实际上可以使用一个单一的补间动画，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Since we are going to change these properties in a bit, we better leave it at
    being two separate tweens.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们稍后将要更改这些属性，我们最好将其留为两个独立的补间动画。
- en: A tween always needs a target which we are setting to the `_pirateShip` instance
    variable. Another value we must specify is how long the tween will animate, which
    is set by the `time` parameter. The amount of time the tween takes is available
    as a property on an instance of `SPTween`. The `time` parameter is of the type
    `double` and is measured in seconds.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一个补间动画始终需要一个目标，我们将它设置为 `_pirateShip` 实例变量。我们必须指定的另一个值是补间动画将持续多长时间，这由 `time`
    参数设置。补间动画所需的时间作为 `SPTween` 实例上的一个属性可用。`time` 参数是 `double` 类型，以秒为单位。
- en: The `tweenX` instance is being bound to the `x` property. We need to access
    the property through its `NSString` identifier. So, if we want to animate the
    `alpha` property, we would need to access it through `@"alpha"`. Internally, Sparrow
    uses the runtime type information (also referred to as reflection) to change properties
    at runtime.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`tweenX` 实例正在绑定到 `x` 属性。我们需要通过其 `NSString` 标识符来访问该属性。因此，如果我们想动画化 `alpha` 属性，我们需要通过
    `@"alpha"` 来访问它。内部，Sparrow 使用运行时类型信息（也称为反射）来在运行时更改属性。'
- en: We set the target value to the current touch position, the x coordinate of that
    touch to be precise. Now, if we touch the background, the ship's top-left corner
    would be at the touch position. To feel more natural, we should change it so that
    the ship is at the center of the touch. This is why we subtracted half of the
    ship's width from the touch position.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将目标值设置为当前的触摸位置，即触摸的 x 坐标。现在，如果我们触摸背景，船的左上角将位于触摸位置。为了感觉更自然，我们应该将其改为船位于触摸的中心。这就是为什么我们从触摸位置减去船宽度的一半。
- en: Implicitly, the initial value is automatically set to the current value of the
    property, which is to be animated.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式地，初始值自动设置为要动画化的属性的当前值。
- en: Then, we did the same for `tweenY` and the y positions, respectively.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们分别对 `tweenY` 和 y 位置做了同样的操作。
- en: To actually animate the properties, we added the tweens to an object called
    the juggler, which is available through `Sparrow.juggler`. We will take a look
    at how jugglers work later in the chapter.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实际动画化属性，我们将补间动画添加到一个名为 juggler 的对象中，该对象通过 `Sparrow.juggler` 可用。我们将在本章后面部分看看
    juggler 的工作原理。
- en: For the touch event to fire, we registered the `onBackgroundTouch` method with
    the background image.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使触摸事件触发，我们将 `onBackgroundTouch` 方法与背景图像注册。
- en: In step 8, we opened the `Game.m` file and updated the `show` call to use the
    battlefield scene instead of the pirate cove scene that happens in step 9.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 8 步中，我们打开了 `Game.m` 文件，并将 `show` 调用更新为使用战场场景而不是第 9 步中发生的海盗湾场景。
- en: Then, we ran the example. If we touch anywhere on the screen, the ship will
    move to the position we just touched.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们运行了示例。如果我们触摸屏幕上的任何地方，船将移动到我们刚刚触摸的位置。
- en: Let's take a look at our source files.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的源文件。
- en: 'The following is the code for the `Battlefield.h` file:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码是 `Battlefield.h` 文件中的代码：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here''s the corresponding `Battlefield.m` file:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是相应的 `Battlefield.m` 文件：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Understanding transitions
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解过渡
- en: Let's take a closer look at the animation we just implemented. When we moved
    our pirate ship, it moves at a constant speed. This is a linear transition, which
    is the default behavior for each newly created `SPTween` instance if the transition
    value is not explicitly set when creating the instance.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看我们刚刚实现的动画。当我们移动我们的海盗船时，它以恒定的速度移动。这是一个线性过渡，这是每个新创建的 `SPTween` 实例的默认行为，如果创建实例时没有明确设置过渡值。
- en: 'The standard way to create a tween with the default transition is as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 创建具有默认过渡的补间的标准方法如下：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To use a tween with a nonlinear transition, just specify it as a parameter:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用具有非线性过渡的补间，只需将其指定为参数：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this piece of code, we are using a transition behavior called "ease-in-out",
    in which case the ship wouldn't move right away but would take its time to start,
    and shortly before the animation is over, it slows down a bit.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们使用了一个名为“ease-in-out”的过渡行为，在这种情况下，飞船不会立即移动，而是会花时间开始，在动画即将结束时，它会稍微慢下来一点。
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For a complete list of all available transitions and their graphical representations,
    take a look at the Sparrow manual at [http://wiki.sparrow-framework.org/_detail/manual/transitions.png?id=manual%3Aanimation](http://wiki.sparrow-framework.org/_detail/manual/transitions.png?id=manual%3Aanimation).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看所有可用过渡及其图形表示的完整列表，请查看 Sparrow 手册中的[http://wiki.sparrow-framework.org/_detail/manual/transitions.png?id=manual%3Aanimation](http://wiki.sparrow-framework.org/_detail/manual/transitions.png?id=manual%3Aanimation)。
- en: Explaining jugglers
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释杂技演员
- en: The purpose of a **juggler** is to animate other objects. It does this by holding
    them in a list, and calling an update method every frame. The update method (`advanceTime`)
    passes through the number of milliseconds that have been passed since the last
    frame. Every object we want to animate needs to be added to an instance of `SPJuggler`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**杂技演员**的目的是动画化其他对象。它是通过将它们保存在一个列表中，并在每一帧调用一个更新方法来实现的。更新方法（`advanceTime`）传递自上一帧以来经过的毫秒数。我们想要动画化的每个对象都需要添加到
    `SPJuggler` 的一个实例中。'
- en: The default juggler can be accessed through `Sparrow.juggler` and is the easiest
    way to animate objects on the screen.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 默认杂技演员可以通过 `Sparrow.juggler` 访问，这是在屏幕上动画化对象的简单方法。
- en: As `Sparrow.juggler` is just an instance of `SPJuggler`, it is also possible
    to separate jugglers for each of the main components of our game. For now, using
    the default juggler is enough for our needs.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Sparrow.juggler` 只是 `SPJuggler` 的一个实例，因此我们也可以为游戏的主要每个组件分别分离杂技演员。目前，使用默认的杂技演员就足够满足我们的需求了。
- en: Updating the movement and canceling tweens
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新移动和取消补间
- en: It's time for our first gameplay decisions. Right now, the pirate ship's animation
    is always 2 seconds long which would provide a serious advantage if the player
    touched one of the edges of the screen instead of just moving a few points on
    the screen.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候做出我们的第一个游戏决策了。目前，海盗飞船的动画总是2秒长，如果玩家触摸屏幕的边缘而不是仅仅在屏幕上移动几个点，这将提供严重的优势。
- en: What we need to introduce is some kind of penalty if we move to an edge of the
    screen, like taking more time for the ship to advance.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要引入的是，如果我们移动到屏幕边缘，则可能需要更多时间来推进飞船的某种形式的惩罚。
- en: It's also a good idea to add the possibility of canceling the animation when
    the ship is currently moving. So when things get heated, we have a option to retreat
    from the current battle.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 也是一个好主意，当飞船正在移动时，添加取消动画的可能性。这样，当事情变得紧张时，我们就有了一个从当前战斗中撤退的选项。
- en: 'Now, how would we go about implementing the cancelation of the current animation?
    Let''s see the following options for doing so:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们如何实现当前动画的取消呢？让我们看看以下选项：
- en: By adding a button on the screen
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在屏幕上添加按钮
- en: By touching the ship itself
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过触摸飞船本身
- en: We should try to avoid onscreen controls as long as we can, so let's add this
    functionality to the touch event (when we touch the pirate ship).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该尽可能地避免屏幕上的控制，因此让我们将此功能添加到触摸事件（当我们触摸海盗飞船时）。
- en: Time for action – updating the movement
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 更新移动
- en: 'To update the movement of our ship, follow these steps:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新我们飞船的移动，请按照以下步骤操作：
- en: 'Inside the initializer, add a tween for the enemy ship. We want the enemy ship
    to move on its own. We should also rename the ship instance to `enemyShip`:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在初始化器内部，为敌对飞船添加一个补间。我们希望敌对飞船能够自行移动。我们还应该将飞船实例重命名为 `enemyShip`：
- en: '[PRE11]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Update the `onBackgroundTouch` method to resemble the following piece of code:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `onBackgroundTouch` 方法，使其类似于以下代码片段：
- en: '[PRE12]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add a new method called `onShipStop` as shown in the following line of code:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `onShipStop` 的新方法，如下面的代码行所示：
- en: '[PRE13]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Implement this method with all of the touch boilerplate code and stop all animations:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用所有触摸样板代码实现此方法并停止所有动画：
- en: '[PRE14]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Register the `onShipStop` selector to the pirate ship:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `onShipStop` 选择器注册到海盗飞船上：
- en: '[PRE15]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When we add the ships to the battlefield scene, switch the enemy ship with the
    pirate ship.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们将飞船添加到战场场景中时，将敌对飞船与海盗飞船交换。
- en: Run the example and you'll see the following result:![Time for action – updating
    the movement](img/1509OS_05_02.jpg)
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例，你会看到以下结果：![行动时间 - 更新移动](img/1509OS_05_02.jpg)
- en: '*What just happened?*'
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: In step 1, we added a tween for the enemy ship right below the code where we
    load its image.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤1中，我们在加载敌舰图像的代码下方添加了一个敌舰补间动画。
- en: When creating the instance, we set the time the animation should take to 4 seconds
    and we used the ease-in-out transition to see the difference when we directly
    compare it with the default linear transition.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建实例时，我们将动画所需的时间设置为4秒，并使用ease-in-out过渡来查看与默认线性过渡直接比较时的差异。
- en: This tween will move the enemy ship by its `y` property/position. We set the
    target value to `250`, which is more or less the bottom of the screen.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个补间将通过其`y`属性/位置移动敌舰。我们将目标值设置为`250`，这大致是屏幕的底部。
- en: When setting the `repeatCount` property—which takes an `int` as its value—we
    want to repeat the animation for exactly as many times as we set the property
    to.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当设置`repeatCount`属性——它接受一个`int`类型的值时——我们希望动画重复的次数正好与我们设置的属性值相同。
- en: Tweens can be reversed by setting the reverse property to `YES` or `NO`, as
    it takes a `BOOL` value. If we had not set the `reverse` property in this example,
    the tween would start at its initial value when repeating the animation. When
    set to `YES`, the animation alternates between its initial and target values.
    We should keep in mind that a reverse animation counts as an animation cycle.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`reverse`属性设置为`YES`或`NO`，可以反转补间动画，因为它接受一个`BOOL`类型的值。如果我们没有在这个示例中设置`reverse`属性，当重复动画时，补间动画将从其初始值开始。当设置为`YES`时，动画将在初始值和目标值之间交替。我们应该记住，反转动画算作一个动画周期。
- en: Tweens can be delayed by using their `delay` property. This property needs a
    `double` type as well and is measured in seconds just like the `time` property.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用它们的`delay`属性来延迟补间动画。这个属性也需要一个`double`类型的值，并且像`time`属性一样以秒为单位来衡量。
- en: Now, we need to add the animation to the default juggler.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将动画添加到默认的杂技演员中。
- en: In step 2, we updated the touch event and the animation. First of all, we removed
    the `andPhase` parameter. Previously, we could only move the ship by tapping on
    the screen. Now, we can either tap the screen or touch-and-drag on the screen
    to move the ship around.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤2中，我们更新了触摸事件和动画。首先，我们移除了`andPhase`参数。之前，我们只能通过在屏幕上轻触来移动船。现在，我们可以通过轻触屏幕或触摸并拖动屏幕来移动船。
- en: After we know that a touch was made, we removed all the previously bound tweens
    from the juggler. Here, we are just making sure that we always have a fresh tween
    and the pirate ship animation might produce any random side effects such as multiple
    tweens setting different target values at the same time.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们知道触摸已经发生之后，我们从杂技演员中移除了之前绑定的所有补间动画。在这里，我们只是确保我们始终有一个新的补间，海盗船动画可能会产生任何随机的副作用，例如同时设置多个补间动画的不同目标值。
- en: In the next line, we declared and assigned variables for the new position our
    ship should move to. Then, we got the absolute values between the ship's position
    and the position of our touch.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行中，我们声明并分配了新位置的变量，然后我们得到了船的位置和触摸位置之间的绝对值。
- en: The penalty is calculated by the sum of the distances divided by 80, which is
    conveniently the size of our ship in points. So, the closer the touch is to the
    ship, the lower this value is, and the further away the touch is from the ship,
    the higher this value will be.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 惩罚是通过距离的总和除以80来计算的，这恰好是我们船的点大小。因此，触摸越接近船，这个值就越低，触摸离船越远，这个值就越高。
- en: The speed of the ship, that is, the duration of the animation, is calculated
    by the relative distance with regard to the screen size multiplied by the square
    penalty. We also have an initial value of 250 milliseconds, which is the shortest
    amount the animation could be.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 船的速度，即动画的持续时间，是通过相对于屏幕大小的相对距离乘以平方惩罚来计算的。我们还有一个初始值250毫秒，这是动画可能的最短时间。
- en: Instead of the `animateProperty` method, we can also use the shorthand method
    `moveToX:y:` which does the same as calling `animateProperty` on the `x` and `y`
    properties.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`animateProperty`方法之外，我们还可以使用简写方法`moveToX:y:`，它与在`x`和`y`属性上调用`animateProperty`相同。
- en: In step 3, we added the `onShipStop` method to the source file, which we implemented
    in the next step. We also removed all tweens with the `_pirateShip` target. So,
    if currently a tween is being executed, it will be removed.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3步中，我们将`onShipStop`方法添加到了源文件中，并在接下来的步骤中实现了它。我们还移除了所有带有`_pirateShip`目标的所有补间动画。因此，如果当前有一个补间动画正在执行，它将被移除。
- en: In step 5, we registered the `onShipStop` event to the pirate ship.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5步中，我们将`onShipStop`事件注册到了海盗船。
- en: Currently, if we were to move over the enemy ship, the enemy ship would be displayed
    on the top of our ship. For our ship to be displayed on top of the enemy ship,
    we need to switch the two around when we add them to the display tree.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，如果我们移动到敌舰，敌舰将显示在我们的船的上方。为了使我们的船显示在敌舰上方，我们需要在将它们添加到显示树时交换这两个对象的顺序。
- en: 'After this example, our `Battlefield.m` file should look like the following
    code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例之后，我们的`Battlefield.m`文件应该看起来像以下代码：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Working with sprite sheets
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与精灵图集一起工作
- en: So far, we loaded every image on its own and displayed them on the screen. Sprite
    sheets are a way to combine all of these smaller images into one big image. When
    we load the image, we are able to use the textures in the same way that we are
    used to.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已单独加载了每个图像并在屏幕上显示它们。精灵图集是将所有这些较小的图像组合成一个大图像的方法。当我们加载图像时，我们可以使用纹理的方式，就像我们习惯的那样。
- en: When using multiple images, something called a "texture switch" happens every
    time the current active texture is being swapped out by a different one. This
    operation is quite heavy on performance, so it should be avoided where possible.
    Sprite sheets allow us to achieve this by using the same image asset for numerous
    different images, thus avoiding the texture switch and keeping the number of draw
    calls to a minimum.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用多个图像时，每当当前活动的纹理被另一个不同的纹理替换时，就会发生所谓的“纹理切换”。这种操作对性能影响很大，因此应尽可能避免。精灵图集允许我们通过使用相同的图像资产来表示多个不同的图像，从而避免纹理切换，并将绘制调用次数保持在最低。
- en: Sprite sheets can also be used for sprite animation, in which a series of images
    is displayed sequentially one frame after another, which creates the illusion
    of animation to the human eye—just like a flip book.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵图集也可以用于精灵动画，其中一系列图像按顺序逐帧显示，这给人类眼睛造成了动画的错觉——就像翻书一样。
- en: A texture atlas is a specialization of sprite sheets with regard to containing
    smaller images, but it also provides a file of metadata which contains the information
    of where exactly its subimages are. In practice though, "texture atlas" and "sprite
    sheet" are used as synonyms.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理图集是精灵图集的一种特殊化，它包含较小的图像，但它还提供了一个包含其子图像确切位置信息的元数据文件。在实践中，"纹理图集"和"精灵图集"通常被用作同义词。
- en: Note
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Before we get started, let's download all the necessary graphics for this chapter
    at [https://github.com/freezedev/pirategame-assets/releases/download/0.5/Graphics_05.zip](https://github.com/freezedev/pirategame-assets/releases/download/0.5/Graphics_05.zip).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，请下载本章所需的全部图形资源，链接为[https://github.com/freezedev/pirategame-assets/releases/download/0.5/Graphics_05.zip](https://github.com/freezedev/pirategame-assets/releases/download/0.5/Graphics_05.zip)。
- en: Learning about texture formats
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习纹理格式
- en: 'So far, we only used PNG images. However, let''s see if there are any other
    texture formats in iOS that would better fit our purpose. Spoiler: there are.
    Leaving the brash remark aside, we are going to analyze which texture formats
    fits our purpose best.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只使用了PNG图像。然而，让我们看看iOS中是否有其他纹理格式更适合我们的目的。剧透：有的。不谈那些冒失的话，我们将分析哪种纹理格式最适合我们的目的。
- en: 'The following table shows the pirate ship image in different file formats.
    Let''s compare its file sizes:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了不同文件格式下的海盗船图像。让我们比较一下它们的文件大小：
- en: '| Compression | File format | File size |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 压缩 | 文件格式 | 文件大小 |'
- en: '| --- | --- | --- |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| None | BMP | 257 KB |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 无 | BMP | 257 KB |'
- en: '| Lossless | PNG | 36.6 KB |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 无损 | PNG | 36.6 KB |'
- en: '| Depends | PVR(In this case RGBA8888) | 257 KB |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 依赖 | PVR（在这种情况下为RGBA8888） | 257 KB |'
- en: When we load a PNG file, what happens internally? The image gets decompressed
    when it's being loaded—at the expense of the CPU. The same goes for other conventional
    image formats such as JPEG. Once the image is decompressed, it becomes a texture.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们加载PNG文件时，内部会发生什么？图像在加载时被解压缩——这会消耗CPU资源。对于其他传统图像格式，如JPEG，也是如此。一旦图像被解压缩，它就变成了纹理。
- en: PVR is a texture format specifically optimized for iOS devices or for PowerVR
    GPUs used on all iOS devices, to be more precise. When loading a PVR image, for
    example, it will decode the image directly on the GPU instead of the CPU.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: PVR 是一种针对 iOS 设备或所有 iOS 设备上使用的 PowerVR GPU 专门优化的纹理格式。例如，在加载 PVR 图像时，它将直接在 GPU
    上解码图像，而不是 CPU。
- en: PVR includes a lot of different image formats. If we are going for lossless
    quality including alpha channels, we should opt for the RGBA8888 format. If we
    don't need the alpha channel, we should use an image format without one. The RGBA8888
    image format is not compressed. So, in order to keep the application size at a
    minimum, we should use the `pvr.gz` format, which is a PVR file compressed using
    GZIP.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: PVR 包含许多不同的图像格式。如果我们追求包括 alpha 通道的无损质量，我们应该选择 RGBA8888 格式。如果我们不需要 alpha 通道，我们应该使用不带
    alpha 通道的图像格式。RGBA8888 图像格式未压缩。因此，为了将应用程序大小保持在最小，我们应该使用 `pvr.gz` 格式，这是一种使用 GZIP
    压缩的 PVR 文件。
- en: Using TexturePacker to create sprite sheets
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 TexturePacker 创建精灵表
- en: '**TexturePacker** is a commercial application to create sprite sheets and texture
    atlases and is available at [http://www.codeandweb.com/texturepacker](http://www.codeandweb.com/texturepacker)
    for around 30 dollars. To be able to create our very own sprite sheets, we either
    need the pro or the trial version of TexturePacker. The TexturePacker download
    window looks as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '** TexturePacker ** 是一个用于创建精灵表和纹理图集的商业应用程序，可在 [http://www.codeandweb.com/texturepacker](http://www.codeandweb.com/texturepacker)
    以约 30 美元的价格获得。为了能够创建我们自己的精灵表，我们需要 TexturePacker 的专业版或试用版。TexturePacker 下载窗口如下所示：'
- en: '![Using TexturePacker to create sprite sheets](img/1509OS_05_03.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![Using TexturePacker to create sprite sheets](img/1509OS_05_03.jpg)'
- en: 'While the workflow is pretty self-explanatory, let''s go through a few steps
    to create our own texture atlas:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然工作流程相当直观，但让我们通过几个步骤来创建我们自己的纹理图集：
- en: Drag-and-drop the images `0001.png` to `0032.png` into the **Sprites** section
    of the application.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图像 `0001.png` 到 `0032.png` 拖放到应用程序的 ** Sprites ** 部分中。
- en: Select **Sparrow/Starling** as the **Data Format**.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 ** Sparrow/Starling ** 作为 ** 数据格式 **。
- en: Select **GZIP compr. PVR** as the **Texture Format**.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 ** GZIP compr. PVR ** 作为 ** 纹理格式 **。
- en: Select **RGBA8888** as the **Image Format**.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 ** RGBA8888 ** 作为 ** 图像格式 **。
- en: Hit the **AutoSD** button and select **corona @4x/@2x** from the presets.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 ** AutoSD ** 按钮，并从预设中选择 ** corona @4x/@2x **。
- en: Set the filenames to `ship_pirate_small_cannon{v}.xml` for the data file and
    `ship_pirate_small_cannon{v}.pvr.gz` for the texture file.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据文件和纹理文件的文件名设置为 `ship_pirate_small_cannon{v}.xml` 和 `ship_pirate_small_cannon{v}.pvr.gz`。
- en: Click on the **Publish** button.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 ** 发布 ** 按钮。
- en: 'Now our texture atlas is generated for each of our resolution we are supporting.
    Let''s take a look at the result. The output of one of the generated images would
    look like the following screenshot:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的纹理图集已经为我们的每个支持分辨率生成。让我们看看结果。生成的图像之一输出如下截图：
- en: '![Using TexturePacker to create sprite sheets](img/1509OS_05_04.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![Using TexturePacker to create sprite sheets](img/1509OS_05_04.jpg)'
- en: 'Here''s a snippet from the corresponding XML file:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是相应的 XML 文件的一个片段：
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: From this snippet, we can see the reference to the original image and its subtextures.
    Each subtexture has a name, its location inside the bigger image, and its dimensions.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个片段中，我们可以看到对原始图像及其子纹理的引用。每个子纹理都有一个名称，它在较大图像中的位置以及其尺寸。
- en: Loading our first texture atlas
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Loading our first texture atlas
- en: Now that we have our texture atlas, let's load and display it with Sparrow.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了纹理图集，让我们使用 Sparrow 加载并显示它。
- en: Time for action – loading our first texture atlas
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Time for action – loading our first texture atlas
- en: 'To load our first texture atlas, we need to follow these steps:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载我们的第一个纹理图集，我们需要遵循以下步骤：
- en: Copy the necessary files (`ship_pirate_small_cannon*`) into the project.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将必要的文件 (`ship_pirate_small_cannon*`) 复制到项目中。
- en: 'Load the texture atlas with the following line of code:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码行加载纹理图集：
- en: '[PRE18]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create an array out of all textures starting with `00`:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从所有以 `00` 开头的纹理中创建一个数组：
- en: '[PRE19]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create a movie clip object and position it just above the original pirate ship,
    as shown in the following code:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个电影剪辑对象，并将其放置在原始海盗船的上方，如下面的代码所示：
- en: '[PRE20]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Play the animation with the following piece of code:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码片段播放动画：
- en: '[PRE21]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add the animated pirate ship to the display tree as follows:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按以下方式将动画海盗船添加到显示树中：
- en: '[PRE22]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Run the example to see the following result:![Time for action – loading our
    first texture atlas](img/1509OS_05_05.jpg)
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例以查看以下结果：![Time for action – loading our first texture atlas](img/1509OS_05_05.jpg)
- en: '*What just happened?*'
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: To use the texture atlas, we first copied all related files into the project.
    Using the `SPTextureAtlas` class, we then loaded the XML file.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用纹理图集，我们首先将所有相关文件复制到项目中。然后，使用`SPTextureAtlas`类，我们加载了XML文件。
- en: In step 3, we needed to get an array (or an `NSArray` to be exact) out of the
    texture atlas with all of the images starting with `00`, which in our case means
    that every image in this sprite sheet will be used for the animation.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3步中，我们需要从纹理图集中获取一个数组（或确切地说是一个`NSArray`），其中包含所有以`00`开头的图像，在我们的例子中这意味着这个精灵表中的每个图像都将用于动画。
- en: An `SPMovieClip` class is derived from `SPDisplayObject` and can be added to
    the display tree as well. It can play the animation from the array we made in
    step 3\. The `fps` parameter is necessary as it sets the speed of the animation.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`SPMovieClip`类是从`SPDisplayObject`派生出来的，也可以添加到显示树中。它可以播放我们在第3步中制作的数组中的动画。`fps`参数是必要的，因为它设置了动画的速度。'
- en: 'To play the animation itself, two things need to be done: first, we need to
    call the `play` method from the movie clip and second, we need to add the movie
    clip to the juggler. This is exactly what we did in step 5.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要播放动画本身，需要做两件事：首先，我们需要从电影剪辑中调用`play`方法；其次，我们需要将电影剪辑添加到表演者中。这正是我们在第5步中做的事情。
- en: In the next step, we added the movie clip to the display tree and when we ran
    the example, we had our pirate ship, the enemy ship which moves up and down and
    now the second pirate ship which has the cannon firing animation.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们将电影剪辑添加到显示树中，当我们运行示例时，我们有了我们的海盗船，上下移动的敌舰，现在还有第二艘海盗船，它有开火动画。
- en: If you want to take a look at the complete source file for this example, it
    is available at [https://github.com/freezedev/pirategame/blob/71f42ded614c4917802dcba46a190476ff7b88c4/Classes/Battlefield.m](https://github.com/freezedev/pirategame/blob/71f42ded614c4917802dcba46a190476ff7b88c4/Classes/Battlefield.m).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看这个示例的完整源文件，它可以在[https://github.com/freezedev/pirategame/blob/71f42ded614c4917802dcba46a190476ff7b88c4/Classes/Battlefield.m](https://github.com/freezedev/pirategame/blob/71f42ded614c4917802dcba46a190476ff7b88c4/Classes/Battlefield.m)找到。
- en: Pop quiz
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 突击测验
- en: Q1\. What are tweens?
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Q1\. 什么是补间动画？
- en: A way to define animation by setting two key frames
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过设置两个关键帧来定义动画的方法
- en: Animations consisting of multiple sprites
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由多个精灵组成的动画
- en: A way to optimize multiple display objects on the screen
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一种优化屏幕上多个显示对象的方法
- en: Q2\. What are sprite sheets?
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Q2\. 什么是精灵表？
- en: Sketches on a sheet of paper
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 纸张上的草图
- en: An image containing several smaller ones
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含几个较小图像的图像
- en: A Sparrow extension to use sprites
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Sparrow扩展以使用精灵
- en: Q3\. Transitions are used to modify the rate of animation over time.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Q3\. 过渡用于修改动画随时间的变化率。
- en: 'True'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we learned about tweens and sprite sheets.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了补间动画和精灵表。
- en: Specifically, we covered how to animate display objects with tweens, create
    our own sprite sheets, and how to animate these sprite sheets.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们介绍了如何使用补间动画来动画化显示对象，创建我们自己的精灵表，以及如何动画化这些精灵表。
- en: We also touched upon texture formats, jugglers, and transitions.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还提到了纹理格式、表演者和过渡效果。
- en: Now that we have animations and our ship is moving around, let's add some game
    logic—which is the topic of the next chapter.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了动画，我们的船在移动，让我们添加一些游戏逻辑——这是下一章的主题。
