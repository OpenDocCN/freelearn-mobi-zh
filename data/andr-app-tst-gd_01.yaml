- en: Chapter 1. Getting Started with Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章 开始测试
- en: This chapter introduces the different types of testing and their applicability
    to software development projects in general and to **Android** in particular.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了不同类型的测试及其在软件开发项目中的适用性，特别是针对**Android**的适用性。
- en: We will avoid introductions to Android and the **Open Handset Alliance** ([http://www.openhandsetalliance.com](http://www.openhandsetalliance.com))
    as they are covered in many books already and I am inclined to believe that if
    you are reading a book covering this more advanced topic you will have started
    with Android development before.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将避免介绍Android和**开放手机联盟**（[http://www.openhandsetalliance.com](http://www.openhandsetalliance.com)），因为它们已经在许多书中有所介绍，而且我倾向于相信，如果您正在阅读一本涵盖这个更高级主题的书，那么您在开始阅读之前就已经开始了Android开发。
- en: However, we will be reviewing the main concepts behind testing and the techniques,
    frameworks, and tools available to deploy your testing strategy on Android.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们将回顾测试背后的主要概念和技术、框架和工具，以便在Android上部署您的测试策略。
- en: Brief history
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简要历史
- en: Initially, when Android was introduced by the end of 2007, there was very little
    support for testing on the platform, and for some of us very accustomed to using
    testing as a component intimately coupled with the development process, it was
    time to start developing some frameworks and tools to permit this approach.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，当Android在2007年底推出时，该平台对测试的支持非常有限，对于我们这些习惯于将测试作为与开发过程紧密耦合的组件的人来说，是时候开始开发一些框架和工具来允许这种做法了。
- en: By that time Android had some rudimentary support for unit testing using JUnit
    ([http://www.JUnit.org](http://www.JUnit.org)), but it was not fully supported
    and even less documented.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到那时，Android已经对使用JUnit（[http://www.JUnit.org](http://www.JUnit.org)）进行单元测试提供了一些基本支持，但它并没有得到完全支持，甚至文档也很少。
- en: In the process of writing my own library and tools, I discovered Phil Smith's
    **Positron** (originally at [http://code.google.com/p/android-positron](http://code.google.com/p/android-positron)
    and now renamed and moved to [http://code.google.com/p/autoandroid)](http://code.google.com/p/autoandroid)),
    an Open Source library and a very suitable alternative to support testing on Android,
    so I decided to extend his excellent work and bring some new and missing pieces
    to the table.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写自己的库和工具的过程中，我发现Phil Smith的**Positron**（最初位于[http://code.google.com/p/android-positron](http://code.google.com/p/android-positron)并现在更名为并迁移到[http://code.google.com/p/autoandroid](http://code.google.com/p/autoandroid)）是一个开源库，非常适合支持Android上的测试，因此我决定扩展他的优秀工作，并带来一些新的和缺失的部分。
- en: Some aspects of test automation were not included and I started a complementary
    project to fill that gap, it was consequently named **Electron**. And although
    positron is the anti-particle of the electron, and they annihilate if they collide,
    take for granted that that was not the idea, but more the conservation of energy
    and the generation of some visible light and waves.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 测试自动化的某些方面没有被包括在内，我开始了一个补充项目来填补这个空白，因此它被命名为**Electron**。尽管正电子是电子的反粒子，并且它们在碰撞时会湮灭，但请相信这并不是初衷，而是更多地考虑到了能量的守恒以及一些可见光和波的产生。
- en: Later on, Electron entered the first **Android Development Challenge** (**ADC1**)
    in early 2008 and though it obtained a rather good score in some categories, frameworks
    had no place in that competition. Should you be interested in the origin of testing
    on Android, please find some articles and videos that were published in my personal
    blog ([http://dtmilano.blogspot.com/search/label/electron](http://dtmilano.blogspot.com/search/label/electron)).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 后来，Electron于2008年初参加了第一次**Android开发挑战赛**（**ADC1**），尽管它在某些类别中获得了相当不错的分数，但在那次比赛中框架并没有得到应有的位置。如果您对Android测试的起源感兴趣，请在我的个人博客中查找一些已发布的文章和视频（[http://dtmilano.blogspot.com/search/label/electron](http://dtmilano.blogspot.com/search/label/electron)）。
- en: By that time Unit Tests could be run on Eclipse. However, testing was not done
    on the real target but on a JVM on the local development computer.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到那时，单元测试可以在Eclipse上运行。然而，测试并不是在真实的目标设备上进行的，而是在本地开发计算机上的JVM上进行的。
- en: Google also provided application instrumentation code through the `Instrumentation`
    class. When running an application with instrumentation turned on, this class
    is instantiated for you before any of the application code, allowing you to monitor
    all of the interaction the system has with the application. An Instrumentation
    implementation is described to the system through an `AndroidManifest.xml` file.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Google还通过`Instrumentation`类提供了应用程序的测试代码。当运行一个启用测试的应用程序时，这个类在你任何应用程序代码之前被实例化，让你能够监控系统与应用程序之间的所有交互。一个`Instrumentation`实现通过`AndroidManifest.xml`文件描述给系统。
- en: During those early stages in the Android development evolution, I started writing
    some articles in my blog filling the gaps on testing. This book is the evolution
    and completion of that work in an orderly and understandable manner to paradoxically
    let you be bitten by the Android testing bug.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android开发演变的早期阶段，我开始在我的博客中撰写一些文章，填补测试的空白。这本书是对那项工作的有序和可理解方式的演变和完成，以悖论的方式让你被Android测试的bug所咬。
- en: Software bugs
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件bug
- en: It doesn't matter how hard you try and how much time you invest in design and
    even how careful you are when programming, mistakes are inevitable and bugs will
    appear.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你多么努力，投入多少时间在设计上，甚至编程时多么小心，错误是不可避免的，bug总会出现。
- en: 'Bugs and software development are intimately related. However, the term **bugs**
    to describe flaws, mistakes, or errors has been used in hardware engineering many
    decades before even computers were invented. Notwithstanding the story about the
    term ''bug'' coined by Mark II operators at Harvard University, Thomas Edison
    wrote this in 1878 in a letter to Puskás Tivadar showing the early adoption of
    the term:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Bug和软件开发密切相关。然而，用来描述缺陷、错误或错误的术语**bug**在计算机发明之前几十年就已经在硬件工程中使用了。尽管有关于哈佛大学Mark
    II操作员创造“bug”一词的故事，托马斯·爱迪生在1878年给Puskás Tivadar的信中写道，这表明了术语的早期采用：
- en: '"It has been just so in all of my inventions. The first step is an intuition,
    and comes with a burst, then difficulties arise—this thing gives out and [it is]
    then that ''Bugs''—as such little faults and difficulties are called—show themselves
    and months of intense watching, study and labor are requisite before commercial
    success or failure is certainly reached."'
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “在我的所有发明中，第一步是直觉，然后是一阵爆发，接着困难出现——这个玩意儿开始出问题，然后就是所谓的‘bug’——就像这样的小错误和困难——就会显现出来，在达到商业成功或失败之前，需要数月的紧张观察、研究和劳动。”
- en: How bugs severely affect your projects
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bug如何严重影响你的项目
- en: Bugs affect many aspects of your software development project and it is clearly
    understood that the sooner in the process you find and *squash* them, the better.
    It doesn't matter if you are developing a simple application to publish on the
    Android Market, re-branding the Android experience for an operator, or creating
    a customized version of Android for a device manufacturer, bugs will delay your
    shipment and will cost you money.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Bug会影响你的软件开发项目的许多方面，而且很明显，你越早在这个过程中找到并*消除*它们，情况就越好。无论是你开发一个简单的应用发布到Android市场，为运营商重新设计Android体验，还是为设备制造商创建一个定制的Android版本，bug都会延误你的发货，并让你付出代价。
- en: From all of the software development methodologies and techniques, **Test Driven
    Development**, an agile component of the software development process, is likely
    the one that forces you to face your bugs earlier in the development process and
    thus it is also likely that you will solve more problems up front.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有软件开发方法和技巧中，**测试驱动开发**（Test Driven Development，TDD）作为软件开发过程中的一个敏捷组件，很可能是那个迫使你在开发早期就面对你的bug的方法，因此你也很可能会在早期解决更多的问题。
- en: Furthermore, the increase in productivity can be clearly appreciated in a project
    where a software development team uses this technique versus one that is, in the
    best of cases, writing tests at the end of the development cycle. If you have
    been involved in software development for the mobile industry, you will have reasons
    to believe that with all the rush this stage never occurs. It's funny because,
    usually, this rush is to solve problems that could have been avoided.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，与那些在开发周期结束时才编写测试的最佳情况相比，在项目中使用这种技术可以明显提高生产力。如果你参与过移动行业的软件开发，你会有理由相信，在这个阶段，所有的匆忙都不会发生。这很有趣，因为通常，这种匆忙是为了解决本可以避免的问题。
- en: In a study conducted by the **National Institute of Standards and Technology**
    (**USA**) in 2002, it was reported that software bugs cost the economy $59.5 billion
    annually. More than a third of this cost could be avoided if better software testing
    was performed.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在美国国家标准与技术研究院（**美国**）于 2002 年进行的一项研究中，报告称软件错误每年给经济造成 595 亿美元。如果进行更好的软件测试，其中超过三分之一的成本可以避免。
- en: But please, don't misunderstand this message. There are no *silver bullets*
    in software development and what will lead you to an increase in productivity
    and manageability of your project is discipline in applying these methodologies
    and techniques to stay in control.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 但请，不要误解这个信息。软件开发中没有“银弹”，将使您提高项目生产力和可管理性的因素是应用这些方法和技术的纪律，以保持控制。
- en: Why, what, how, and when to test
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么、什么、如何以及何时进行测试
- en: You should understand that early bug detection saves a huge amount of project
    resources and reduces software maintenance costs. This is the best known reason
    to write software tests for your development project. Increased productivity will
    soon be evident.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该明白，早期发现错误可以节省大量的项目资源并降低软件维护成本。这是为您的开发项目编写软件测试的最佳理由。生产力的提升将很快显现。
- en: Additionally, writing the tests will give you a deeper understanding of the
    requirements and the problem to be solved. You will not be able to write tests
    for a piece of software you don't understand.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，编写测试将使您对需求和要解决的问题有更深入的理解。如果您不理解某个软件，将无法为其编写测试。
- en: This is also the reason behind the approach of writing tests to clearly understand
    legacy or third party code and having the ability to confidently change or update
    it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是编写测试以清楚地理解遗留或第三方代码，并能够自信地更改或更新它的原因。
- en: The more the code covered by your tests, the higher would be your expectations
    of discovering the hidden bugs.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您的测试覆盖的代码越多，您对发现隐藏错误的期望就越高。
- en: If during this coverage analysis you find that some areas of your code are not
    exercised, additional tests should be added to cover this code as well.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在这次覆盖率分析中您发现代码的某些区域没有被测试到，应该添加额外的测试来覆盖这些代码。
- en: This technique requires a special instrumented Android build to collect probe
    data and must be disabled for any release code because the impact on performance
    could severely affect application behavior.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术需要特殊的仪器 Android 构建来收集探针数据，并且必须禁用于任何发布代码，因为对性能的影响可能会严重影响应用程序的行为。
- en: 'To fill this gap, enter EMMA ([http://emma.sourceforge.net/](http://emma.sourceforge.net/)),
    an open-source toolkit for measuring and reporting Java code coverage, that can
    offline instrument classes for coverage. It supports various coverage types:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了填补这一空白，请访问 EMMA ([http://emma.sourceforge.net/](http://emma.sourceforge.net/))，这是一个开源的工具包，用于测量和报告
    Java 代码覆盖率，并且可以离线对类进行覆盖率测试。它支持各种覆盖率类型：
- en: class
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类
- en: method
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法
- en: line
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行
- en: basic block
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本块
- en: Coverage reports can also be obtained in different output formats. EMMA is supported
    to some degree by the Android framework and it is possible to build an EMMA instrumented
    version of Android.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖率报告也可以以不同的输出格式获得。EMMA 在一定程度上受到 Android 框架的支持，并且可以构建 Android 的 EMMA 仪器版本。
- en: We will be analyzing the use of EMMA on Android to guide us to full test coverage
    of our code in [Chapter 10](ch10.html "Chapter 10. Alternative Testing Tactics"),
    *Alternative Testing Tactics.*
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 10 章 [“替代测试策略”](ch10.html "第 10 章。替代测试策略")中分析 EMMA 在 Android 上的使用，以指导我们实现代码的全面测试覆盖。
- en: This screenshot shows how an EMMA code coverage report is displayed in the Eclipse
    editor, showing green lines where the code has been tested, provided the corresponding
    plugin is installed.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这张截图显示了 EMMA 代码覆盖率报告在 Eclipse 编辑器中的显示方式，显示了代码已被测试的绿色线条，前提是已安装相应的插件。
- en: '![Why, what, how, and when to test](img/3500_01_01.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![为什么、什么、如何以及何时进行测试](img/3500_01_01.jpg)'
- en: Unfortunately, the plugin doesn't support Android tests yet, so right now you
    can only use it for your JUnit tests. An Android coverage analysis report is only
    available through HTML.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，该插件目前还不支持 Android 测试，因此现在您只能用它来运行 JUnit 测试。Android 覆盖率分析报告仅通过 HTML 提供。
- en: Tests should be automated, and you should run some or all of them every time
    you introduce a change or addition to your code, in order to ensure that all the
    previous conditions are still met and that the new code still satisfies the tests
    as expected.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应该自动化，并且每次你对代码进行更改或添加时，都应该运行一些或所有测试，以确保所有先前条件仍然满足，并且新代码仍然满足预期的测试。
- en: This leads us to the introduction of **Continuous Integration**, which will
    be discussed in detail in [Chapter 8](ch08.html "Chapter 8. Continuous Integration"),
    *Continuous Integration*. This relies on the automation of tests and building
    processes.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这就引出了**持续集成**的介绍，它将在第 8 章[持续集成](ch08.html "第 8 章。持续集成")中详细讨论。这依赖于测试和构建过程的自动化。
- en: If you don't use automated testing, it is practically impossible to adopt Continuous
    Integration as part of the development process and it is very difficult to ensure
    that changes do not break existing code.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有使用自动化测试，实际上不可能将持续集成作为开发过程的一部分，并且很难确保更改不会破坏现有代码。
- en: What to test
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需要测试的内容
- en: Strictly speaking you should test every statement in your code but this also
    depends on different criteria and can be reduced to test the path of execution
    or just some methods. Usually there is no need to test something that can't be
    broken, for example it usually makes no sense to test getters and setters as you
    probably won't be testing the Java compiler on your own code and the compiler
    would have already performed its own tests.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，你应该测试你代码中的每一个语句，但这也取决于不同的标准，可以简化为测试执行路径或只是某些方法。通常，没有必要测试那些无法破坏的内容，例如，通常没有必要测试获取器和设置器，因为你可能不会在自己的代码上测试
    Java 编译器，编译器已经执行了自己的测试。
- en: In addition to the functional areas you should test, there are some specific
    areas of Android applications that you should consider. We will be looking at
    these in the following sections.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 除了你应该测试的功能区域之外，还有一些特定的 Android 应用程序区域你应该考虑。我们将在以下章节中探讨这些内容。
- en: Activity lifecycle events
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动生命周期事件
- en: You should test that your activities handle lifecycle events correctly.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该测试你的活动是否正确处理生命周期事件。
- en: If your activity should save its state during `onPause()` or `onDestroy()` events
    and later restore it in `onCreate(Bundle savedInstanceState)`, you should be able
    to reproduce and test these conditions and verify that the state was correctly
    saved and restored.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的活动应该在 `onPause()` 或 `onDestroy()` 事件期间保存其状态，并在稍后通过 `onCreate(Bundle savedInstanceState)`
    恢复它，你应该能够重现和测试这些条件，并验证状态是否已正确保存和恢复。
- en: Configuration-changed events should also be tested as some of these events cause
    the current Activity to be recreated, and you should test for correct handling
    of the event and that the newly created Activity preserves the previous state.
    Configuration changes are triggered even by rotation events, so you should test
    your application's ability to handle these situations.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 配置更改事件也应该进行测试，因为这些事件中的一些会导致当前 Activity 重新创建，你应该测试正确处理事件以及新创建的 Activity 是否保留了先前状态。配置更改甚至由旋转事件触发，因此你应该测试你的应用程序处理这些情况的能力。
- en: Database and filesystem operations
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据库和文件系统操作
- en: Database and filesystem operations should be tested to ensure that they are
    handled correctly. These operations should be tested in isolation at the lower
    system level, at a higher level through `ContentProviders`, and from the application
    itself.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 应该测试数据库和文件系统操作是否得到正确处理。这些操作应该在较低的系统级别单独测试，在较高级别通过 `ContentProviders` 测试，以及从应用程序本身进行测试。
- en: To test these components in isolation, Android provides some mock objects in
    the `android.test.mock` package.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了单独测试这些组件，Android 在 `android.test.mock` 包中提供了一些模拟对象。
- en: Physical characteristics of the device
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设备的物理特性
- en: Well before delivering your application you should be sure that all of the different
    devices it can be run on are supported or at the least you should detect the situation
    and take appropriate measures.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在交付你的应用程序之前，你应该确保所有可以运行该应用程序的不同设备都得到支持，或者至少你应该检测这种情况并采取适当的措施。
- en: 'Among other characteristics of the devices, you may find that you should test:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在设备的其他特性中，你可能还会发现你应该测试：
- en: Network capabilities
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络能力
- en: Screen densities
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 屏幕密度
- en: Screen resolutions
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 屏幕分辨率
- en: Screen sizes
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 屏幕尺寸
- en: Availability of sensors
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传感器的可用性
- en: Keyboard and other input devices
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键盘和其他输入设备
- en: GPS
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GPS
- en: External storage
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部存储
- en: In this respect Android Virtual Devices play an important role because it is
    practically impossible to have access to all possible devices with all of the
    possible combinations of features but you can configure AVD for almost every situation.
    However, as was mentioned before, save your final testing for actual devices where
    real users will run the application to understand its behavior.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这方面，Android虚拟设备扮演着重要的角色，因为实际上不可能访问所有可能的设备及其所有可能的功能组合，但您可以为几乎所有情况配置AVD。然而，如前所述，请将您的最终测试保留在实际设备上，以便真实用户运行应用程序以了解其行为。
- en: Types of tests
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试类型
- en: Testing can be implemented at any time in the development process, depending
    on the method employed. However, we will be promoting testing at an early stage
    of the development effort, even before the full set of requirements have been
    defined and the coding process has been started.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 测试可以在开发过程的任何时间点实现，具体取决于采用的方法。然而，我们将促进在开发努力的早期阶段进行测试，甚至在定义完整的需求和开始编码过程之前。
- en: There are several types of test available depending on the object being tested.
    Regardless of its type, a test should verify a condition and return the result
    of this evaluation as a single Boolean value indicating success or failure.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 根据被测试的对象类型，有多种测试类型可供选择。无论其类型如何，测试都应该验证一个条件，并将此评估的结果作为一个单一的布尔值返回，以指示成功或失败。
- en: Unit tests
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: Unit tests are software tests written by programmers for programmers in a programming
    language and they should isolate the component under test and be able to test
    it in a repeatable way. That's why unit tests and mock objects are usually placed
    together. You use mock objects to isolate the unit from its dependencies, to monitor
    interactions, and also to be able to repeat the test any number of times. For
    example, if your test deletes some data from a database you probably don't want
    the data to be actually deleted and not found the next time the test is run.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是由程序员为程序员编写的软件测试，它们应该隔离被测试的组件，并且能够以可重复的方式进行测试。这就是为什么单元测试和模拟对象通常放在一起。您使用模拟对象来隔离单元与其依赖项，以监控交互，并且能够重复测试任意次数。例如，如果您的测试从数据库中删除了一些数据，您可能不希望数据实际上被删除，并且在下次运行测试时找不到。
- en: JUnit is the de-facto standard for unit tests on Android. It's a simple open
    source framework for automating unit testing, originally written by Erich Gamma
    and Kent Beck.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit是Android上单元测试的事实标准。它是一个简单的开源框架，用于自动化单元测试，最初由Erich Gamma和Kent Beck编写。
- en: Android (up to Android 2.3 Gingerbread) uses JUnit 3\. This version doesn't
    use annotations and uses introspection to detect the tests.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Android（直到Android 2.3 Gingerbread）使用JUnit 3。这个版本不使用注解，并使用反射来检测测试。
- en: 'A typical JUnit test would look something like this (the actual tests are highlighted):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的JUnit测试看起来可能像这样（实际的测试被突出显示）：
- en: '[PRE0]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.PacktPub.com](http://www.PacktPub.com). If you
    purchased this book elsewhere, you can visit [http://www.PacktPub.com/support](http://www.PacktPub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.PacktPub.com](http://www.PacktPub.com)的账户中下载您购买的所有Packt书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.PacktPub.com/support](http://www.PacktPub.com/support)并注册，以便将文件直接通过电子邮件发送给您。
- en: The following sections explain in detail the components that build up our test
    case.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节将详细解释构建我们的测试用例的组件。
- en: The test fixture
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试用例
- en: A test fixture is the well known state defined as a baseline to run the tests
    and is shared by all the test cases, and thus plays a fundamental role in the
    design of the tests.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 测试用例是众所周知的基线状态，用于运行测试，并由所有测试用例共享，因此在测试设计中起着基本的作用。
- en: Generally it is implemented as a set of member variables and, following Android
    conventions, they will have names starting with `m`, for example `mActivity`.
    However, it can also contain external data, as specific entries in a database
    or files present in the filesystem.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通常它被实现为一组成员变量，并且遵循Android约定，它们的名称将以 `m` 开头，例如 `mActivity`。然而，它也可以包含外部数据，例如数据库中的特定条目或文件系统中的文件。
- en: The setUp() method
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: setUp() 方法
- en: This method is called to initialize the fixture.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法用于初始化测试用例。
- en: Overriding it you have the opportunity to create objects and initialize fields
    that will be used by tests. It's worth noting that this setup occurs *before*
    every test.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖它，你有机会创建将被测试使用的对象和初始化字段。值得注意的是，这种设置是在每次测试之前发生的。
- en: The tearDown() method
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`tearDown()` 方法'
- en: This method is called to finalize the fixture.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法用于最终确定测试环境。
- en: Overriding it you can release resources used by the initialization or tests.
    Again, this method is invoked *after* every test.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖它，你可以释放初始化或测试中使用的资源。再次强调，此方法是在每次测试之后调用的。
- en: For example, you can release a database or a network connection here.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以在这里释放数据库或网络连接。
- en: JUnit is designed in such a way that the entire tree of test instances is built
    in one pass, and then the tests are executed in a second pass. Therefore, the
    test runner holds strong references to all Test instances for the duration of
    the test execution. This means that for very large and very long test runs with
    many Test instances, none of the tests may be garbage collected until the end
    of the entire test run. This is particularly important in Android and when testing
    on limited devices as some tests may fail not because of an intrinsic problem
    but because of the amount of memory needed to run the application plus its tests
    exceeding the device limits.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 是这样设计的，即整个测试实例树在一次遍历中构建，然后在第二次遍历中执行测试。因此，测试运行器在整个测试执行期间都持有对所有 Test 实例的强引用。这意味着对于非常庞大且非常长的测试运行，其中包含许多
    Test 实例，在整个测试运行结束之前，可能没有任何测试被垃圾回收。这在 Android 和在有限设备上进行测试时尤为重要，因为某些测试可能不是由于固有的问题，而是因为运行应用程序及其测试所需的内存超过了设备的限制。
- en: Therefore, if you allocate external or limited resources in a test, such as
    `Services` or `ContentProviders`, you are responsible for freeing those resources.
    Explicitly setting an object to null in the `tearDown()` method, for example,
    allows it to be garbage collected before the end of the entire test run.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你在测试中分配外部或有限的资源，例如 `Services` 或 `ContentProviders`，你负责释放这些资源。例如，在 `tearDown()`
    方法中显式地将对象设置为 null，允许它在整个测试运行结束之前被垃圾回收。
- en: Test preconditions
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试前提条件
- en: Usually there is no way to test for preconditions as the tests are discovered
    using introspection and their order could vary. So it's customary to create a
    `testPreconditions()` method to test for preconditions. Though there is no assurance
    that this test will be called in any specific order, it is good practice to keep
    this and the preconditions together for organizational purposes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通常没有方法可以测试前提条件，因为测试是通过反射发现的，它们的顺序可能会变化。因此，通常的做法是创建一个 `testPreconditions()` 方法来测试前提条件。尽管不能保证这个测试将以任何特定的顺序被调用，但为了组织上的目的，将这个测试和前提条件放在一起是一个好的做法。
- en: The actual tests
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实际测试
- en: All `public void` methods whose names start with `test` will be considered as
    a test. JUnit 3, as opposed to JUnit 4, doesn't use annotations to discover the
    tests but introspection to find their names. There are some annotations available
    on the Android test framework such as `@SmallTest, @MediumTest`, and `@LargeTest`,
    but they don't turn a simple method into a test. Instead they organize them in
    different categories. Ultimately you will have the ability to run tests for a
    single category using the test runner.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 所有以 `test` 开头且名称为 `public void` 的方法都将被视为测试。与 JUnit 4 不同，JUnit 3 不使用注解来发现测试，而是使用反射来查找它们的名称。Android
    测试框架上提供了一些注解，如 `@SmallTest, @MediumTest` 和 `@LargeTest`，但它们并不能将简单的方法转换为测试。相反，它们将它们组织成不同的类别。最终，你将能够使用测试运行器运行单个类别的测试。
- en: As a rule of thumb, name your tests in a descriptive way using nouns and the
    condition being tested.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，使用名词和正在测试的条件来描述性地命名测试。
- en: 'For example: `testValues(), testConversionError(), testConversionToString()`
    are all valid test names.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：`testValues(), testConversionError(), testConversionToString()` 都是有效的测试名称。
- en: Test for exceptions and wrong values instead of just testing for positive cases.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 测试异常和错误值，而不仅仅是测试正面案例。
- en: During the execution of the test some conditions, side effects, or method returns
    should be compared against the expectations. To ease these operations, JUnit provides
    a full set of `assert*` methods to compare the expected results from the test
    to the actual results after running with them throwing exceptions if conditions
    are not met. Then the test runner handles these exceptions and presents the results.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试执行过程中，某些条件、副作用或方法返回值应与预期进行比较。为了简化这些操作，JUnit 提供了一套完整的 `assert*` 方法，用于比较测试的预期结果与运行后的实际结果。如果条件不满足，则它们会抛出异常。然后测试运行器处理这些异常并显示结果。
- en: 'These methods, which are overloaded to support different arguments, include:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法支持不同的参数，包括：
- en: '`assertEquals()`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertEquals()`'
- en: '`assertFalse()`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertFalse()`'
- en: '`assertNotNull()`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertNotNull()`'
- en: '`assertNotSame()`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertNotSame()`'
- en: '`assertNull()`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertNull()`'
- en: '`assertSame()`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertSame()`'
- en: '`assertTrue()`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertTrue()`'
- en: '`fail()`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fail()`'
- en: 'In addition to these JUnit assert methods, Android extends Assert in two specialized
    classes providing additional tests:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些 JUnit 断言方法之外，Android 还通过两个专用类扩展了 Assert，提供了额外的测试：
- en: '`MoreAsserts`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MoreAsserts`'
- en: '`ViewAsserts`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewAsserts`'
- en: Mock objects
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模拟对象
- en: Mock objects are mimic objects used instead of calling the real domain objects
    to enable testing units in isolation.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟对象是代替调用真实领域对象使用的模仿对象，以便在隔离状态下测试单元。
- en: Generally, this is done to ensure that correct methods are called but they can
    also be of help, as mentioned, to isolate your tests from the surrounding universe
    and enable you to run them independently and repeatably.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这样做是为了确保调用正确的方法，但正如提到的，这也有助于将测试与周围环境隔离开来，并使您能够独立且可重复地运行它们。
- en: The Android testing framework supports several mock objects that you will find
    very useful when writing your tests but you will need to provide some dependencies
    to be able to compile the tests.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Android 测试框架支持几个模拟对象，当您编写测试时，您会发现它们非常有用，但您需要提供一些依赖项才能编译测试。
- en: 'Several classes are provided by the Android testing framework in the `android.test.mock`
    package:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Android 测试框架在 `android.test.mock` 包中提供了几个类：
- en: '`MockApplication`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MockApplication`'
- en: '`MockContentProvider`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MockContentProvider`'
- en: '`MockContentResolver`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MockContentResolver`'
- en: '`MockContext`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MockContext`'
- en: '`MockCursor`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MockCursor`'
- en: '`MockDialogInterface`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MockDialogInterface`'
- en: '`MockPackageManager`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MockPackageManager`'
- en: '`MockResources`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MockResources`'
- en: Almost any component of the platform that could interact with your Activity
    can be created by instantiating one of these classes.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎可以创建与您的 Activity 交互的任何平台组件，通过实例化这些类之一。
- en: However, they are not real implementations but stubs where every method generates
    an `UnsupportedOperationException` and that you can extend to create real mock
    objects.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它们并不是真正的实现，而是存根，其中每个方法都会生成一个 `UnsupportedOperationException`，您可以扩展它们来创建真正的模拟对象。
- en: UI tests
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: UI 测试
- en: Finally, special consideration should be taken if your tests involve UI components.
    As you may have already known, only the main thread is allowed to alter the UI
    in Android. Thus a special annotation `@UIThreadTest` is used to indicate that
    a particular test should be run on that thread and would have the ability to alter
    the UI. On the other hand, if you only want to run parts of your test on the UI
    thread, you may use the `Activity.runOnUiThread(Runnable r)` method providing
    the corresponding `Runnable` containing testing instructions.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果您的测试涉及 UI 组件，应特别考虑。如您所知，在 Android 中，只有主线程允许更改 UI。因此，使用特殊注解 `@UIThreadTest`
    来指示特定测试应在该线程上运行，并且将具有更改 UI 的能力。另一方面，如果您只想在 UI 线程上运行测试的一部分，您可以使用 `Activity.runOnUiThread(Runnable
    r)` 方法，提供包含测试指令的相应 `Runnable`。
- en: 'A helper class `TouchUtils` is also provided to aid in the UI test creation
    allowing the generation of events to send to the Views, such as:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 还提供了一个辅助类 `TouchUtils`，以帮助创建 UI 测试，允许生成发送到视图的事件，例如：
- en: click
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: click
- en: drag
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: drag
- en: long click
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: long click
- en: scroll
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: scroll
- en: tap
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: tap
- en: touch
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: touch
- en: By these means you can actually remote control you application from the tests.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些方法，您实际上可以从测试中远程控制您的应用程序。
- en: Eclipse and other IDE support
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Eclipse 和其他 IDE 支持
- en: JUnit is fully supported by Eclipse and the Android ADT plugin lets you create
    Android testing projects. Furthermore, you can run the tests and analyze the results
    without leaving the IDE.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 完全由 Eclipse 支持，Android ADT 插件允许您创建 Android 测试项目。此外，您可以在不离开 IDE 的情况下运行测试并分析结果。
- en: This also provides a more subtle advantage; being able to run the tests from
    Eclipse allows you to debug the tests that are not behaving correctly.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这也提供了一种更微妙的优势；能够从 Eclipse 运行测试允许您调试表现不正确的测试。
- en: In the screenshot, we can see how Eclipse runs **18 tests** taking 20.008 seconds,
    where **0 Errors** and **0 Failures** were detected. The name of each test and
    its duration is also displayed. If there was a failure, the **Failure Trace**
    would show the related information.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕截图中，我们可以看到 Eclipse 以 20.008 秒的时间运行了 **18 个测试**，其中检测到 **0 个错误** 和 **0 个失败**。每个测试的名称及其持续时间也显示出来。如果有失败，**失败跟踪**将显示相关信息。
- en: '![Eclipse and other IDE support](img/3500_01_02.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![Eclipse 和其他 IDE 支持](img/3500_01_02.jpg)'
- en: Other IDEs like ItelliJ and Netbeans have plugins integrating Android development
    to some degree but they are not officially supported.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 其他 IDE，如 ItelliJ 和 Netbeans，在某种程度上集成了 Android 开发，但它们并未官方支持。
- en: 'Even if you are not developing in an IDE, you can find support to run the tests
    with **ant** (check [http://ant.apache.org](http://ant.apache.org) if you are
    not familiar with this tool). This setup is done by the `android` command using
    the subcommand `create test-project` as described by this help text:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您不在 IDE 中开发，您也可以找到使用 **ant** 运行测试的支持（如果您不熟悉这个工具，请检查 [http://ant.apache.org](http://ant.apache.org)）。此设置是通过
    `android` 命令使用子命令 `create test-project` 完成的，如帮助文本所述：
- en: '[PRE1]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As indicated by the help you should provide at least the path to the project
    (--path) and the path to the main project or the project under test (--main).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 根据帮助信息，您至少应提供项目路径 (--path) 和主项目或测试项目的路径 (--main)。
- en: Integration tests
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成测试
- en: Integration tests are designed to test the way individual components work jointly.
    Modules that have been unit tested independently are now combined together to
    test the integration.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试旨在测试各个组件协同工作的方式。那些已经独立进行单元测试的模块现在被组合在一起以测试集成。
- en: Usually Android Activities require some integration with the system infrastructure
    to be able to run. They need the Activity lifecycle provided by the `ActivityManager`,
    and access to resources, filesystem, and databases.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Android 活动（Activities）需要与系统基础设施集成，以便能够运行。它们需要 `ActivityManager` 提供的活动生命周期，以及访问资源、文件系统数据库。
- en: The same criteria apply to other Android components like `Services` or `ContentProviders`
    that need to interact with other parts of the system to achieve their function.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的标准适用于需要与其他系统部分交互以实现其功能的其他 Android 组件，如 `Services` 或 `ContentProviders`。
- en: In all these cases there are specialized tests provided by the Android testing
    framework that facilitate the creation of tests for these components.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些情况下，Android 测试框架都提供了专门的测试，以简化这些组件的测试创建。
- en: Functional or acceptance tests
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能或验收测试
- en: In agile software development, functional or acceptance tests are usually created
    by business and Quality Assurance (QA) people and expressed in a business domain
    language. These are high level tests to test the completeness and correctness
    of a user requirement or feature. They are created ideally through collaboration
    between business customers, business analysts, QA, testers, and developers. However
    the business customers (product owners) are the primary owners of these tests.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在敏捷软件开发中，功能或验收测试通常由业务和质量管理（QA）人员创建，并使用业务领域语言表达。这些是高级测试，用于测试用户需求或功能的完整性和正确性。它们最好通过业务客户、业务分析师、QA、测试人员和开发人员之间的协作来创建。然而，业务客户（产品所有者）是这些测试的主要所有者。
- en: Some frameworks and tools can help in this field, most notably FitNesse ([http://www.fitnesse.org](http://www.fitnesse.org)),
    which can be easily integrated, up to a point, into the Android development process
    and will let you create acceptance tests and check their results.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一些框架和工具可以帮助在这个领域，最著名的是 FitNesse ([http://www.fitnesse.org](http://www.fitnesse.org))，它可以很容易地集成到
    Android 开发过程中，并允许您创建验收测试并检查其结果。
- en: Note
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Also check Fit, [http://fit.c2.com](http://fit.c2.com) and Slim (Simple List
    Invocation Method), [http://fitnesse.org/FitNesse.UserGuide.SliM](http://fitnesse.org/FitNesse.UserGuide.SliM),
    as an alternative to Fit.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 还请检查 Fit，[http://fit.c2.com](http://fit.c2.com) 和 Slim (Simple List Invocation
    Method)，[http://fitnesse.org/FitNesse.UserGuide.SliM](http://fitnesse.org/FitNesse.UserGuide.SliM)，作为
    Fit 的替代方案。
- en: '![Functional or acceptance tests](img/3500_01_03.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![功能或验收测试](img/3500_01_03.jpg)'
- en: Lately, a new trend named **Behavior Driven Development** has gained some popularity
    and in a very brief description can be understood as the evolution of Test Driven
    Development. It aims to provide a common vocabulary between business and technology
    people in order to increase mutual understanding.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，一种名为 **行为驱动开发** 的新趋势已经获得了一些人气，并且可以用非常简短的方式来理解，即测试驱动开发的演变。它的目的是为了在业务和技术人员之间提供一种共同的语言，以便增加相互理解。
- en: Behavior Driven Development can be expressed as a framework of activities based
    on three principles (more information can be found at [http://behaviour-driven.org):](http://behaviour-driven.org))
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 行为驱动开发可以表达为一个基于三个原则的活动框架（更多信息可以在[http://behaviour-driven.org]找到）：](http://behaviour-driven.org))
- en: Business and technology should refer to the same system in the same way
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务和技术应该以相同的方式引用相同的系统。
- en: Any system should have an identified, verifiable value to the business
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何系统都应该有一个对业务有可识别、可验证的价值。
- en: Upfront analysis, design, and planning all have a diminishing return
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前期的分析、设计和规划都有递减的回报。
- en: To apply these principles, business people are usually involved in writing test
    case scenarios in a high level language and use some tool, such as **jbehave**
    ([http://jbehave.org](http://jbehave.org)). In the following example, these scenarios
    are translated into code that expresses the same test scenario in a programming
    language.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应用这些原则，业务人员通常参与以高级语言编写测试用例场景，并使用一些工具，例如 **jbehave** ([http://jbehave.org](http://jbehave.org))。在以下示例中，这些场景被转换为代码，以编程语言表达相同的测试场景。
- en: Test case scenario
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试用例场景
- en: As an illustration of this technique here is an oversimplified example.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这种技术的示例，这里有一个过于简化的例子。
- en: 'This scenario is:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个场景是：
- en: '[PRE2]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It would be translated into something similar to:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 它将被翻译成类似的东西：
- en: '[PRE3]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Performance tests
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能测试
- en: Performance tests measure performance characteristics of the components in a
    repeatable way. If performance improvements are required by some part of the application,
    the best approach is to measure performance before and after some change is introduced.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 性能测试以可重复的方式衡量组件的性能特征。如果应用程序的某个部分需要性能改进，最佳方法是引入更改前后测量性能。
- en: As is widely known, premature optimization does more harm than good, so it is
    better to clearly understand the impact of your changes on the overall performance.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如众所周知，过早的优化弊大于利，因此最好清楚地了解您的更改对整体性能的影响。
- en: The introduction of the **Dalvik JIT** compiler in Android 2.2 changed some
    optimization patterns that were widely used in Android development. Nowadays,
    every recommendation about performance improvements on the Android developer's
    site is backed up by performance tests.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 2.2 中引入的 **Dalvik JIT** 编译器改变了在 Android 开发中广泛使用的某些优化模式。如今，Android
    开发者网站上关于性能改进的任何建议都有性能测试的支持。
- en: System tests
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统测试
- en: 'The system is tested as a whole and the interaction between the components,
    software and hardware, is exercised. Normally, system tests include additional
    classes of tests like:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 系统作为一个整体进行测试，并锻炼组件、软件和硬件之间的交互。通常，系统测试包括额外的测试类别，如：
- en: GUI tests
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GUI 测试
- en: Smoke tests
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 烟雾测试
- en: Performance tests
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能测试
- en: Installation tests
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装测试
- en: Android testing framework
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android 测试框架
- en: Android provides a very advanced testing framework extending the industry standard
    JUnit with specific features suitable for implementing all of the testing strategies
    and types we mentioned before. In some cases, additional tools are needed but
    the integration of these tools is in most cases simple and straightforward.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Android 提供了一个非常先进的测试框架，它扩展了行业标准 JUnit，并增加了适合实现我们之前提到的所有测试策略和类型的特定功能。在某些情况下，需要额外的工具，但这些工具的集成在大多数情况下都是简单直接的。
- en: 'The key features of the Android testing environment include:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Android 测试环境的关键特性包括：
- en: Android extensions to the JUnit framework that provide access to Android system
    objects.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android 对 JUnit 框架的扩展，提供了访问 Android 系统对象的功能。
- en: An instrumentation framework that lets tests control and examine the application.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个仪器化框架，允许测试控制和检查应用程序。
- en: Mock versions of commonly used Android system objects.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常用 Android 系统对象的模拟版本。
- en: Tools for running single tests or test suites, with or without instrumentation.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行单个测试或测试套件的工具，带或不带仪器。
- en: Support for managing tests and test projects in the ADT Plugin for Eclipse and
    at the command line.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持在 Eclipse 的 ADT 插件和命令行中管理测试和测试项目。
- en: Instrumentation
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仪器化
- en: The instrumentation framework is the foundation of the testing framework. Instrumentation
    controls the application under test and permits the injection of mock components
    required by the application to run. For example, you can create mock Contexts
    before the application starts and let the application use them.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: instrumentation 框架是测试框架的基础。Instrumentation 控制被测试的应用程序，并允许注入应用程序运行所需的模拟组件。例如，你可以在应用程序启动之前创建模拟的
    Context，并让应用程序使用它们。
- en: All interaction of the application with the surrounding environment can be controlled
    using this approach. You can also isolate your application in a restricted environment
    to be able to predict the results, forcing the values returned by some methods
    or mocking persistent and unchanged data for `ContentProvider`, databases, or
    even the filesystem content.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，可以控制应用程序与周围环境的所有交互。你还可以在受限环境中隔离你的应用程序，以便能够预测结果，强制某些方法返回的值，或者对 `ContentProvider`、数据库或甚至文件系统内容进行模拟。
- en: A standard Android project has its tests in a correlated project that usually
    has the same project name but ends with **Test**. Inside this Test project, the
    `AndroidManifest.xml` declares the Instrumentation.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一个标准的 Android 项目，其测试在一个相关项目中，通常具有相同的项目名称，但以 **Test** 结尾。在这个 Test 项目内部，`AndroidManifest.xml`
    声明了 Instrumentation。
- en: 'As an illustrative example, assume your project has a manifest like this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个示例，假设你的项目有一个如下所示的清单：
- en: '[PRE4]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this case, the correlated Test project will have the following `AndroidManifest.xml:`
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，相关 Test 项目将具有以下 `AndroidManifest.xml`：
- en: '[PRE5]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here the Instrumentation package is the same package as the main application
    with the `.test` suffix added.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Instrumentation 包与主应用程序相同，只是添加了 `.test` 后缀。
- en: Then the Instrumentation is declared specifying the target package and the test
    runner, in this case the default custom runner `android.test.InstrumentationTestRunner`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，声明 Instrumentation，指定目标包和测试运行器，在这种情况下是默认的自定义运行器 `android.test.InstrumentationTestRunner`。
- en: Also notice that both, the application under test and the tests are Android
    applications with their corresponding APKs installed. Internally, they will be
    sharing the same process and thus have access to the same set of features.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，被测试的应用程序和测试都是 Android 应用程序，它们安装了相应的 APK。内部，它们将共享同一个进程，因此可以访问相同的功能集。
- en: When you run a test application, the **Activity Manager** ([http://developer.android.com/intl/de/reference/android/app/ActivityManager.html](http://developer.android.com/intl/de/reference/android/app/ActivityManager.html))
    uses the instrumentation framework to start and control the test runner, which
    in turn uses instrumentation to shut down any running instances of the main application,
    starts the test application, and then starts the main application in the same
    process. This allows various aspects of the test application to work directly
    with the main application.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行测试应用程序时，**活动管理器** ([http://developer.android.com/intl/de/reference/android/app/ActivityManager.html](http://developer.android.com/intl/de/reference/android/app/ActivityManager.html))
    使用 instrumentation 框架来启动和控制测试运行器，该运行器反过来使用 instrumentation 来关闭主应用程序的任何运行实例，然后启动测试应用程序，并在同一个进程中启动主应用程序。这允许测试应用程序的各个方面直接与主应用程序协同工作。
- en: Test targets
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试目标
- en: During the evolution of your development project your tests would be targeted
    to different devices. From the simplicity, flexibility, and speed of testing on
    an emulator to the unavoidable final testing on the specific devices you intend
    your application to be run on, you should be able to run on all of them.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的开发项目演变过程中，你的测试会针对不同的设备。从在模拟器上测试的简单性、灵活性和速度，到不可避免地在特定设备上进行的最终测试，你应该能够在所有这些设备上运行。
- en: There are also some intermediate cases like running your tests on a local **JVM**
    virtual machine on the development computer or on a **Dalvik** virtual machine
    or `Activity`, depending on the case.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一些中间情况，比如在开发计算机上的本地 **JVM** 虚拟机上运行测试，或者在 **Dalvik** 虚拟机或 `Activity` 上，具体取决于情况。
- en: Every case has its pros and cons, but the good news is that you have all of
    these alternatives available to run your tests.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 每种情况都有其优缺点，但好消息是，你可以使用所有这些替代方案来运行你的测试。
- en: The emulator is probably the most powerful target as you can modify almost every
    parameter from its configuration to simulate different conditions for your tests.
    Ultimately, your application should be able to handle all of these situations,
    so it is much better to discover the problems upfront than when the application
    has been delivered.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟器可能是最强大的目标，因为你可以从其配置中修改几乎每一个参数来模拟不同的测试条件。最终，你的应用程序应该能够处理所有这些情况，因此提前发现问题比应用程序交付后发现问题要好得多。
- en: The real devices are a requirement for performance tests, as it is somewhat
    difficult to extrapolate performance measurements from a simulated device. You
    will discover the real user experience only when using the real device. Rendering,
    scrolling, flinging, and other cases should be tested before delivering the application.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 真实设备对于性能测试是必需的，因为从模拟设备中推断性能测量值有些困难。你只有在使用真实设备时才能发现真实用户体验。在交付应用程序之前，应该测试渲染、滚动、抛掷和其他情况。
- en: Summary
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have reviewed the main concepts behind testing in general and Android in
    particular. Having acquired this knowledge will let us start our journey and start
    exploiting the benefits of testing in our software development projects.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回顾了测试的一般概念，特别是Android的测试。掌握这些知识将使我们开始我们的旅程，并开始在我们软件开发项目中利用测试的好处。
- en: 'So far, we have visited the following subjects:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经访问了以下主题：
- en: We reviewed the early stages of testing on Android and mentioned some of the
    frameworks that created the current alternatives.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们回顾了Android测试的早期阶段，并提到了一些创建了当前替代方案的框架。
- en: We briefly analyzed the reasons behind testing and the whys, whats, hows, and
    whens of it. Furthermore, from now on we will concentrate on exploring the hows,
    as we can assume that you are convinced by the arguments presented.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们简要分析了测试背后的原因以及为什么、是什么、如何和何时进行测试。此外，从现在开始，我们将专注于探索如何进行测试，因为我们假设你已经被提出的论点所说服。
- en: We enumerated the different and most common types of tests you would need in
    your projects, described some of the tools we can count on our testing toolbox,
    and provided an introductory example of a JUnit unit test to better understand
    what we are discussing.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们列举了你在项目中可能需要的不同和最常见的测试类型，描述了一些我们可以依赖的测试工具，并提供了一个JUnit单元测试的入门示例，以便更好地理解我们在讨论的内容。
- en: We also analyzed these techniques from the Android perspective and mentioned
    the use of Instrumentation to run our Android tests.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还从Android的角度分析了这些技术，并提到了使用Instrumentation来运行我们的Android测试。
- en: Now we will start analyzing the mentioned techniques, frameworks, and tools
    in detail, along with examples of their usage.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将开始详细分析所提到的技术、框架和工具，以及它们的使用示例。
