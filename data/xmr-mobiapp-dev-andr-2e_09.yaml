- en: Chapter 9. Making POIApp Location Aware
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章：使POIApp具备位置感知功能
- en: 'One of the most interesting aspects of mobile development is interacting with
    device capabilities such as motion sensors, cameras, and location sensors. Such
    features are contextual for most applications and carry a great deal of value
    to the users. In this chapter, we will walk you through adding location awareness
    to POIApp. We will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 移动开发中最有趣的一个方面是与设备功能交互，例如运动传感器、摄像头和位置传感器。这些功能对于大多数应用来说是上下文相关的，并且对用户具有很高的价值。在本章中，我们将向您展示如何将位置感知添加到POIApp中。我们将涵盖以下主题：
- en: Setting application permissions
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置应用程序权限
- en: Obtaining the current longitude and latitude
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取当前经纬度
- en: Obtaining the address for a longitude and latitude
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取经纬度的地址
- en: Calculating the distance between two geo points
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算两个地理点之间的距离
- en: Displaying a POI within the map app
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在地图应用中显示POI
- en: Working with location services
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用位置服务工作
- en: Integrating the location service in the Android platform is more complicated
    than it looks.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android平台上集成位置服务比看起来要复杂。
- en: You need to consider different location providers, location accuracy, user movements,
    and most importantly the nominal device battery power consumption. While working
    with location services on the Android platform, you will primarily work with an
    instance of `LocationManager`. The `LocationManager` class provides you with the
    ability to obtain periodic updates of the device geo location or fires an event
    when the device enters the proximity of a given geographical location.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要考虑不同的位置提供者、位置精度、用户移动，以及最重要的是设备的额定电池功耗。在Android平台上使用位置服务时，您将主要与`LocationManager`的一个实例一起工作。`LocationManager`类为您提供了获取设备地理位置周期性更新的能力，或者当设备进入特定地理位置的邻近区域时触发事件。
- en: 'Android devices generally provide two different means of determining a location:
    **GPS** and **Network**. When requesting location change notifications, you may
    specify the provider you wish to receive updates from. The Android platform defines
    a set of string constants for the following providers:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Android设备通常提供两种不同的确定位置的方法：**GPS**和**网络**。在请求位置变化通知时，您可以指定希望接收更新的提供者。Android平台定义了一组字符串常量，用于以下提供者：
- en: Provider name
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 提供者名称
- en: Description
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 描述
- en: '`GPS_PROVIDER` (GPS)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`GPS_PROVIDER`（GPS）'
- en: This provider determines a location using satellites. Depending on conditions,
    this provider may take a while to return a location fix. This requires the `ACCESS_FINE_LOCATION`
    permission.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此提供者使用卫星确定位置。根据条件，此提供者可能需要一段时间才能返回位置修正。这需要`ACCESS_FINE_LOCATION`权限。
- en: '`NETWORK_PROVIDER` (network)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`NETWORK_PROVIDER`（网络）'
- en: This provider determines a location based on the availability of a cell tower
    and Wi-Fi access points. Its results are retrieved by means of a network lookup.
    This requires the `ACCESS_COARSE_LOCATION` permission.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此提供者根据蜂窝塔和Wi-Fi接入点的可用性确定位置。其结果通过网络查找获取。这需要`ACCESS_COARSE_LOCATION`权限。
- en: '`PASSIVE_PROVIDER` (passive)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`PASSIVE_PROVIDER`（被动）'
- en: This provider can be used to passively receive location updates when other applications
    or services request them without actually having to request for the locations
    yourself. It requires the `ACCESS_FINE_LOCATION` permission. If the GPS is not
    enabled, this provider might only return coarse fixes.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此提供者可以在其他应用程序或服务请求位置更新时被动接收位置更新，而无需您自己实际请求位置。它需要`ACCESS_FINE_LOCATION`权限。如果GPS未启用，此提供者可能只能返回粗略的位置。
- en: 'The process of integrating the location service to an Android application includes
    the following steps:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 将位置服务集成到Android应用程序中的过程包括以下步骤：
- en: Obtain a reference to an instance of `LocationManager`.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取`LocationManager`实例的引用。
- en: Use the instance of `LocationManager` to request location change notifications,
    either ongoing or a single notification.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`LocationManager`实例来请求位置变化通知，无论是持续通知还是单个通知。
- en: Process the `LocationListener` callback methods. These methods will be fired
    only if the location is requested with the `RequestLocationUpdates(string, long,
    float, ILocationListener)` method.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理`LocationListener`回调方法。这些方法仅在通过`RequestLocationUpdates(string, long, float,
    ILocationListener)`方法请求位置时才会触发。
- en: Accessing the location service in Android applications requires specific permissions
    to be added, depending on the provider you want to use.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 访问Android应用程序中的位置服务需要添加特定的权限，具体取决于您想使用的提供者。
- en: Setting the app permissions
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置应用权限
- en: 'To access location services in Android, you must provide permissions to the
    application `AndroidManifest.xml` file. Android applications use two permissions
    to access the location API: `ACCESS_COARSE_LOCATION` and `ACCESS_FINE_LOCATION`.
    The `ACCESS_FINE_LOCATION` includes the permission for both the `GPS_PROVIDER`
    and `NETWORK_PROVIDER` providers. The `ACCESS_COARSE_LOCATION` permission includes
    permission only for `NETWORK_PROVIDER`.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Android中访问位置服务，您必须向`AndroidManifest.xml`文件提供权限。Android应用程序使用两个权限来访问位置API：`ACCESS_COARSE_LOCATION`和`ACCESS_FINE_LOCATION`。`ACCESS_FINE_LOCATION`包括对`GPS_PROVIDER`和`NETWORK_PROVIDER`提供者的权限。`ACCESS_COARSE_LOCATION`权限仅包括对`NETWORK_PROVIDER`的权限。
- en: 'To add the appropriate permissions to your application descriptor, perform
    the following steps:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要将适当的权限添加到您的应用程序描述符中，请执行以下步骤：
- en: Double-click on `Properties`/`AndroidManifest.xml` in the **Solution** pad.
    The file will be opened in the manifest editor. There are two tabs at the bottom
    of the screen, **Application** and **Source**, which can be used to toggle between
    viewing a form for editing the file or the raw XML.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击**属性**/`AndroidManifest.xml`在**解决方案**面板中。文件将在清单编辑器中打开。屏幕底部有两个标签页，**应用程序**和**源**，可以用来在查看用于编辑文件的表单或原始XML之间切换。
- en: In the **Required permissions** list, check **AccessCoarseLocation**, **AccessFineLocation**,
    and **Internet**. Navigate to **File** | **Save**:![](img/XhBPQB1a.jpg)
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**所需权限**列表中，勾选**AccessCoarseLocation**、**AccessFineLocation**和**Internet**。导航到**文件**
    | **保存**：![](img/XhBPQB1a.jpg)
- en: Switch to the **Source** view to view the XML as follows:![](img/r8qghy6E.jpg)
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到**源**视图以查看以下内容：![](img/r8qghy6E.jpg)
- en: Configuring the emulator
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置模拟器
- en: To use an **emulator** for development, this chapter will require the emulator
    to be configured with Google APIs so that the address lookup and navigation to
    map the app works.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用**模拟器**进行开发，本章将需要配置模拟器以使用Google APIs，以便地址查找和将应用映射到地图上。
- en: 'To install and configure **Google APIs**, perform the following steps:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装和配置**Google APIs**，请执行以下步骤：
- en: From the main menu, navigate to **Tools** and open **Android SDK Manager**.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从主菜单导航到**工具**并打开**Android SDK Manager**。
- en: Select the platform version you are using, check **Google APIs**, and click
    on **Install 1 package...**, as shown in the following screenshot:![](img/dsor4qaj.jpg)
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择您正在使用的平台版本，勾选**Google APIs**，然后单击**安装 1 个包...**，如图所示：![](img/dsor4qaj.jpg)
- en: After the installation is complete, close the Android SDK Manager, and from
    the main menu, navigate to **Tools** | Open **Android Emulator Manager**.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，关闭Android SDK Manager，然后从主菜单导航到**工具** | 打开**Android 模拟器管理器**。
- en: Select the emulator you want to configure and click on **Edit**.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择您想要配置的模拟器并单击**编辑**。
- en: In **Target**, select the **Google APIs** entry for the API level you want to
    work with.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**目标**中，选择您想要工作的API级别的**Google APIs**条目。
- en: Click on **OK** to save.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**以保存。
- en: Obtaining an instance of LocationManager
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取`LocationManager`实例
- en: 'The `LocationManager` class is a system service that provides access to the
    location and bearing of a device, if the device supports these services. You do
    not explicitly create an instance of `LocationManager`; instead, you request an
    instance from a `Context` object using the `GetSystemService()` method. In most
    cases, the `Context` object is a subtype of activity. The following code depicts
    declaring a reference of a `LocationManager` class and requesting an instance:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`LocationManager`类是一个系统服务，它提供对设备位置和方位的访问，如果设备支持这些服务。您不需要显式创建`LocationManager`实例；相反，您可以使用`GetSystemService()`方法从一个`Context`对象请求一个实例。在大多数情况下，`Context`对象是activity的子类型。以下代码展示了声明一个`LocationManager`类的引用并请求一个实例：'
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Requesting location change notifications
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求位置变更通知
- en: The `LocationManager` class provides a series of overloaded methods that can
    be used to request location update notifications. If you simply need a single
    update, you can call `RequestSingleUpdate()`; to receive ongoing updates, call
    `RequestLocationUpdate()`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`LocationManager`类提供了一系列重载方法，可用于请求位置更新通知。如果您只需要单个更新，可以调用`RequestSingleUpdate()`；要接收持续更新，请调用`RequestLocationUpdate()`。'
- en: 'Prior to requesting location updates, you must identify the location provider
    that should be used. In our case, we simply want to use the most accurate provider
    available at the time. This can be accomplished by specifying the criteria for
    the desired provider using an instance of `Android.Location.Criteria`. The following
    code example shows how to specify the minimum criteria:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在请求位置更新之前，您必须确定应使用的位置提供者。在我们的例子中，我们只想使用当时可用的最精确的提供者。这可以通过使用`Android.Location.Criteria`实例指定所需提供者的标准来实现。以下代码示例显示了如何指定最小标准：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now that we have the criteria, we are ready to request updates as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了标准，我们准备按照以下方式请求更新：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Implementing ILocationListener
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现`ILocationListener`
- en: 'You will notice that the second parameter to `RequestSingleUpdate()` must be
    an object that implements `ILocationListener`, which defines the following methods:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到`RequestSingleUpdate()`的第二个参数必须是一个实现`ILocationListener`的对象，该对象定义了以下方法：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For the most part, we will create blank stubs for all of the methods except
    `OnLocationChanged()`. While writing more sophisticated applications, it will
    be useful to provide implementations for some of the other methods. For example,
    you might call `RequestLocationUpdate()` to begin receiving updates and then receive
    a notification via `OnProviderEnabled()` that a preferred provider is now available,
    in which case you would want to stop the updates and start them again using the
    preferred provider.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我们将为所有方法创建空白存根，除了`OnLocationChanged()`。在编写更复杂的应用程序时，为其他一些方法提供实现将很有用。例如，您可能调用`RequestLocationUpdate()`以开始接收更新，然后通过`OnProviderEnabled()`接收通知，表明首选提供者现在可用，在这种情况下，您可能想要停止更新并再次使用首选提供者启动它们。
- en: Adding location services to POIApp
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将位置服务添加到POIApp
- en: 'In `POIApp`, we have the following two different scenarios for requesting location
    updates:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在`POIApp`中，我们有两个不同的场景用于请求位置更新：
- en: In the POI list, we need to calculate the distance of each of the listed POIs.
    In this scenario, we want to request location change notifications on an ongoing
    basis and use the most current location to calculate the distance.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在POI列表中，我们需要计算每个列表中POI的距离。在这种情况下，我们希望持续请求位置变化通知，并使用最新的位置来计算距离。
- en: In `POIDetailFragment`, we would like to request the current location when adding
    a new POI. In this scenario, we would want to request a single location change
    notification.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`POIDetailFragment`中，我们希望在添加新的POI时请求当前位置。在这种情况下，我们希望请求一个单一的位置变化通知。
- en: Adding location services to the POI list
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将位置服务添加到POI列表
- en: 'Now that we have some idea of how to add location services to an app, let''s
    add location services to `POIListFragment` as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何向应用程序添加位置服务，让我们按照以下方式将位置服务添加到`POIListFragment`：
- en: 'Declare a private instance of `LocationManager` and obtain a reference in the
    `OnCreateView()` method as follows:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`OnCreateView()`方法中声明`LocationManager`的私有实例并获取引用，如下所示：
- en: '[PRE4]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Include the `Android.Locations` namespace in `POIListFragment` and implement
    the `ILocationListener` interface:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`POIListFragment`中包含`Android.Locations`命名空间并实现`ILocationListener`接口：
- en: '[PRE5]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: From the code editor right-click on `ILocationListenerinterface`, select **Refactor**
    | **Implement interface** to implement the stub methods. Remove any code placed
    by default in the stub methods; we will provide logic for `OnLocationChange()`
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码编辑器中，右键单击`ILocationListener`接口，选择**重构** | **实现接口**以实现存根方法。删除任何默认放置在存根方法中的代码；我们将提供`OnLocationChange()`的逻辑。
- en: 'In `OnResume()`, obtain the best location provider and call `RequestLocationUpdates()`
    to start receiving updates as follows:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`OnResume()`中，获取最佳位置提供者并调用`RequestLocationUpdates()`以开始接收更新，如下所示：
- en: '[PRE6]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Override the `OnPause()` method on the `POIListFragment` class and add a call
    to `RemoveUpdates()`. This eliminates unnecessary processing of location changes
    when the `POIListFragment` class is not visible, as shown in the following code:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`POIListFragment`类中重写`OnPause()`方法并添加对`RemoveUpdates()`的调用。这样，当`POIListFragment`类不可见时，可以消除对位置变化的不必要处理，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add a `CurrentLocation` property to `POIListViewAdapter`. The `POIListFragment`
    class will use this property to communicate location changes to the adapter:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`CurrentLocation`属性添加到`POIListViewAdapter`中。`POIListFragment`类将使用此属性将位置变化通知适配器：
- en: '[PRE8]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add a logic to `OnLocationChanged()` to set `CurrentLocation` on `POIListViewAdapter`
    when a location change is received and call `NotifyDataSetChange()` to cause the
    `ListView` to be refreshed as follows:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `OnLocationChanged()` 中添加逻辑，当接收到位置变化时在 `POIListViewAdapter` 上设置 `CurrentLocation`，并调用
    `NotifyDataSetChange()` 以使 `ListView` 刷新，如下所示：
- en: '[PRE9]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add a logic to the `GetView()` method on `POIListViewAdapter` to calculate
    the distance between the `CurrentLocation` and a POI''s location properties and
    update `distanceTextView` with the results. The calculation should only be done
    if `CurrentLocation` is not `null`, and the `Latitude` and `Longitude` properties
    for the POI being added to the `ListView` are not null. If any of these values
    are `null`, simply place `??` in the distance field to indicate that it cannot
    be calculated at this time as follows:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `POIListViewAdapter` 的 `GetView()` 方法中添加逻辑，以计算 `CurrentLocation` 和 POI 的位置属性之间的距离，并将结果更新到
    `distanceTextView`。只有在 `CurrentLocation` 不是 `null`，并且要添加到 `ListView` 的 POI 的 `Latitude`
    和 `Longitude` 属性不是 `null` 时，才进行计算。如果这些值中的任何一个为 `null`，则在距离字段中简单地放置 `??` 以指示此时无法计算，如下所示：
- en: '[PRE10]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, run `POIApp` and view the results in `POIListView`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行 `POIApp` 并在 `POIListView` 中查看结果。
- en: Adding location services to POI details
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将位置服务添加到 POI 详细信息
- en: The steps for adding location services to `POIDetailFragment` will be very similar
    to the previous section, but will be slightly simpler.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 将位置服务添加到 `POIDetailFragment` 的步骤将与上一节非常相似，但会稍微简单一些。
- en: Updating the user interface
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新用户界面
- en: 'Prior to adding the logic, we need to add a few buttons to our app; one to
    get our location and one to navigate to the map, which we will cover later in
    this chapter. We can add these as a row of buttons at the bottom of `POIDetailFragment.axml`,
    as shown in the following screenshot:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加逻辑之前，我们需要在我们的应用程序中添加几个按钮；一个用于获取我们的位置，一个用于导航到地图，我们将在本章后面介绍。我们可以将这些按钮作为 `POIDetailFragment.axml`
    底部的一行添加，如下面的截图所示：
- en: '![](img/vIgVMhdy.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/vIgVMhdy.jpg)'
- en: 'Using `ImageButton` allows a `drawable` class to be specified. To add the `ImageButton`
    widgets, perform the following steps:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ImageButton` 允许指定 `drawable` 类。要添加 `ImageButton` 小部件，请执行以下步骤：
- en: Add a `LinearLayout` instance to the bottom of `POIDetailFragment.axml` just
    below the `TableLayout` used to arrange the latitude and longitude content. The
    orientation should be `horizontal`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `POIDetailFragment.axml` 的底部添加一个 `LinearLayout` 实例，位于用于排列纬度和经度内容的 `TableLayout`
    下方。方向应该是 `horizontal`。
- en: On the `LinearLayout` instance, the orientation should be `horizontal`, the
    content should be wrapped (both height and width), and it should be centered horizontally
    in the parent. The layout gravity can be used to center the content horizontally
    within its parent. The top and bottom padding of `10dp` will provide a good spacing
    for the buttons.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `LinearLayout` 实例上，方向应该是 `horizontal`，内容应该被包裹（高度和宽度），并且它应该在父元素中水平居中。可以使用布局重力在父元素内水平居中内容。`10dp`
    的顶部和底部填充将为按钮提供良好的间距。
- en: 'Add the two `ImageButton` widgets: `locationImageButton` and `mapImageButton`,
    in the `LinearLayout` instance. Images for these buttons can be found in the `drawable`
    folder in the `assets` location.'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `LinearLayout` 实例中添加两个 `ImageButton` 小部件：`locationImageButton` 和 `mapImageButton`。这些按钮的图片可以在
    `assets` 位置的 `drawable` 文件夹中找到。
- en: 'The following XML code shows the result:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下 XML 代码显示了结果：
- en: '[PRE11]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Adding the code
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加代码
- en: 'Now that we have buttons on the UI, we can add the code to obtain the location
    as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在 UI 上有了按钮，我们可以添加以下代码来获取位置：
- en: 'Declare a private instance of `LocationManager` and obtain a reference in `OnCreate()`
    in the same way we did for `POIListView` in the previous section:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个 `LocationManager` 的私有实例，并在 `OnCreate()` 中以与上一节中 `POIListView` 相同的方式获取引用：
- en: '[PRE12]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add a `GetLocationClicked` event handler and hook it up to the `ImageButton`
    as follows:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `GetLocationClicked` 事件处理程序并将其连接到 `ImageButton`，如下所示：
- en: '[PRE13]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add a call to `RequestSingleUpdate()` in `GetLocationClicked()`. The `RequestSingleUpdate()`
    method allows a `Criteria` object to be passed in so that we do not need a separate
    call to `GetBestProvider()` as follows:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `GetLocationClicked()` 中添加对 `RequestSingleUpdate()` 的调用。`RequestSingleUpdate()`
    方法允许传入一个 `Criteria` 对象，这样我们就不需要单独调用 `GetBestProvider()`，如下所示：
- en: '[PRE14]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Specify that `POIDetailFragment` implements `Android.Locations`. The `ILocationListener`
    implements stub methods using the Refactor | Implement interface. Remove any code
    placed in the stub methods; we will provide a logic for `OnLocationChange()`.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定 `POIDetailFragment` 实现 `Android.Locations`。使用 Refactor | Implement 接口实现 `ILocationListener`
    的存根方法。删除存根方法中放置的任何代码；我们将提供 `OnLocationChange()` 的逻辑。
- en: 'Add a logic to `OnLocationChange()` to update the location fields as follows:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `OnLocationChange()` 中添加逻辑以更新位置字段，如下所示：
- en: '[PRE15]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Mocking location data for testing
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟位置数据以进行测试
- en: Run `POIApp` and try adding a new POI and getting the location. While running
    the app in the emulator, you will notice that apparently nothing happens when
    you click on the location button. The app is actually waiting for a callback to
    `OnLocationChanged()` from the location manager. To trigger this callback, you
    must use the **Android Device Monitor** (**ADM**) to mock the location data.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `POIApp` 并尝试添加一个新的 POI 并获取位置。在模拟器中运行应用时，您会注意到当您点击位置按钮时似乎没有任何反应。实际上，应用正在等待从位置管理器来的
    `OnLocationChanged()` 回调。要触发此回调，您必须使用 **Android Device Monitor** （**ADM**）来模拟位置数据。
- en: 'To trigger `OnLocationChanged()`, perform the following steps:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要触发 `OnLocationChanged()`，执行以下步骤：
- en: Start ADM and select the emulator instance on the left-hand side of the screen.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 ADM 并选择屏幕左侧的模拟器实例。
- en: Click on the **Emulator Control** tab on the right-hand side of the screen.
    If the **Emulator Control** tab is not present, navigate to **Window** | **Show
    View** to display the tab. Notice that, at the bottom of the panel, there is a
    nested tab titled **Location Controls**, as shown in the following screenshot:![](img/LFvh8keh.jpg)
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击屏幕右侧的 **Emulator Control** 标签。如果 **Emulator Control** 标签不存在，导航到 **Window**
    | **Show View** 来显示该标签。注意，在面板底部有一个嵌套的标签，标题为 **Location Controls**，如下截图所示：![](img/LFvh8keh.jpg)
- en: Select the **Manual** tab, adjust **Longitude** and **Latitude**, if desired,
    and click on **Send**. This will cause the `OnLocationChanged()` method to be
    fired on `POIDetailFragment`.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **Manual** 标签，根据需要调整 **经度** 和 **纬度**，然后点击 **Send**。这将导致在 `POIDetailFragment`
    上触发 `OnLocationChanged()` 方法。
- en: 'Note the other two tabs under **Location Controls**: **GPX** and **KML**. These
    tabs can be used to load a series of location updates from a file and play them
    back to your app to test more sophisticated scenarios.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 **Location Controls** 下的其他两个标签：**GPX** 和 **KML**。这些标签可以用来从文件中加载一系列位置更新并回放到您的应用中，以测试更复杂的场景。
- en: Getting an address for a location
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取位置的地址
- en: Another useful feature provided by the Android platform is called **Geocoding**.
    This is the process of obtaining the location in terms of latitude and longitude
    from a known address. Android also supports reverse geocoding, which is what you
    would expect from the name, obtaining an address from a known location.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Android 平台提供的另一个有用功能称为 **地理编码**。这是从已知地址以纬度和经度表示位置的过程。Android 还支持反向地理编码，正如其名称所暗示的，从已知位置获取地址。
- en: 'The `Android.Locations.Geocoder` class is the class used to perform geocoding
    and reverse geocoding. It''s a very straightforward process to use, as shown in
    the following steps:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`Android.Locations.Geocoder` 类是用来执行地理编码和反向地理编码的类。使用它非常简单，如下步骤所示：'
- en: Create an instance of `Android.Locations.Geocoder`.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `Android.Locations.Geocoder` 的实例。
- en: Call `GetFromLocation()` by passing in the location you would like to find the
    address for.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过传递您想要查找地址的位置来调用 `GetFromLocation()`。
- en: 'Process the `IList&lt;Address&gt;` collection returned. The collection of addresses
    returned from `GetFromLocation()` vary in specifics, which means that some are
    specific street addresses, some specify a city, country, and so on. The first
    address is always the most specific, so we will automatically choose it using
    the following code:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理返回的 `IList<Address>` 集合。从 `GetFromLocation()` 返回的地址集合在具体细节上有所不同，这意味着一些是具体的街道地址，一些指定了城市、国家等。第一个地址总是最具体的，因此我们将使用以下代码自动选择它：
- en: '[PRE16]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice that the number `5` parameter in the `GetFromLocation()` method call
    represents the maximum number of results that are known to describe the area,
    surrounding the latitude and longitude.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 `GetFromLocation()` 方法调用中的数字 `5` 参数表示已知可以描述围绕纬度和经度的区域的最多结果数量。
- en: 'You can see that we chose to call a method to format the address information.
    The `FeatureName` property may contain a title such as *Golden Gate Bridge* or
    *Empire State Building*. More times than not, `FeatureName` will simply contain
    the street number. The address contains a list of address lines, which we combine
    and place in `_addrEditText` as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们选择调用一个方法来格式化地址信息。`FeatureName`属性可能包含一个标题，例如*金门大桥*或*帝国大厦*。很多时候，`FeatureName`将简单地包含街道号码。地址包含一系列地址行，我们将它们组合并放置在`_addrEditText`中，如下所示：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, run `POIApp` and try adding a new POI and getting the address for a location.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行`POIApp`并尝试添加一个新的POI和获取位置的地址。
- en: Keeping the user informed
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持用户知情
- en: After using the get location button, you will notice that requests for location
    information take some amount of time to process; generally, a few seconds or more.
    It would be best to keep users informed that processing is taking place so that
    they don't continually click on the button.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用获取位置按钮后，你会注意到请求位置信息需要一些时间来处理；通常，几秒钟或更长时间。最好让用户知道正在处理，这样他们就不会不断地点击按钮。
- en: This can be achieved in two ways. You can either attach a `ProgressBar` directly
    to the details fragment layout as we did for `POIListFragment`, or we can use
    a `ProgressDialog` class. The `ProgressDialog` class provides a simple means of
    displaying a dialog with a spinning progress widget and text description of what
    process is taking place. Ever since the `DialogFragment` class is added to Android,
    Google recommends that you use the `DialogFragment` class instead of `ProgressDialog`.
    Here, in this example, we will create a `DialogFragment` class that displays the
    loading progress that is similar to the `DeleteDialogFragment` class.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过两种方式实现。你可以直接将`ProgressBar`附加到详情片段布局中，就像我们在`POIListFragment`中所做的那样，或者我们可以使用`ProgressDialog`类。`ProgressDialog`类提供了一个简单的方法来显示一个带有旋转进度小部件和描述正在进行的进程的文本描述的对话框。自从`DialogFragment`类被添加到Android以来，谷歌推荐使用`DialogFragment`类而不是`ProgressDialog`。在这里，在这个例子中，我们将创建一个`DialogFragment`类，它显示的加载进度与`DeleteDialogFragment`类类似。
- en: 'The following steps will guide you to add a dialog fragment to display the
    loading progress:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将指导你添加一个对话框片段以显示加载进度：
- en: Let's add a new fragment named `ProgressDialogFragment` and extend it from the
    `DialogFragment` class.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一个名为`ProgressDialogFragment`的新片段，并从`DialogFragment`类扩展它。
- en: 'Override the `OnCreateDialog()` method and add the following code blocks:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`OnCreateDialog()`方法并添加以下代码块：
- en: '[PRE18]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We are not ready with the `ProgressDialogFragment` fragment. Let''s add the
    following code snippets to the `GetLocationClicked()` method to display the loading
    progress when a user clicks on the location button from `POIDetailFragment`:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还没有准备好`ProgressDialogFragment`片段。让我们将以下代码片段添加到`GetLocationClicked()`方法中，以便在用户从`POIDetailFragment`点击位置按钮时显示加载进度：
- en: '[PRE19]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now we need to remove the loading progress dialog once the location is retrieved
    from the location manager. Add the following code snippets to the `OnLocationChanged()`
    callback to remove the progress dialog:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要从位置管理器检索到位置后，移除加载进度对话框。将以下代码片段添加到`OnLocationChanged()`回调中，以移除进度对话框：
- en: '[PRE20]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, run `POIApp` and check the new progress dialog, as shown in the following
    screenshot:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行`POIApp`并检查新的进度对话框，如图所示：
- en: '![](img/P6XvjrOb.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/P6XvjrOb.jpg)'
- en: Adding map integration
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加地图集成
- en: Maps are another truly cool part of mobile computing. They provide a means of
    navigation, finding points of interest in an area, as well as supporting many
    other useful scenarios.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 地图是移动计算中真正酷的一部分。它们提供了一种导航方式，在区域内查找兴趣点，以及支持许多其他有用的场景。
- en: 'There are two basic approaches to interfacing with maps from an app as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 从应用程序与地图交互有两种基本方法如下：
- en: Navigate to the existing Android map app installed on the device to display
    a point of interest. Most recent Android devices are preinstalled with the Google
    Map application. However, it is not guaranteed.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航到设备上已安装的现有Android地图应用程序以显示兴趣点。大多数最新的Android设备都预装了Google地图应用程序。但是，这并不保证。
- en: Integrate with the Google Maps API. This approach integrates the map view directly
    to your application using Google Play services. You must create an application
    in the Google Developer Console and obtain a copy of the API key for your app.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成Google Maps API。这种方法直接使用Google Play服务将地图视图集成到你的应用程序中。你必须在Google开发者控制台中创建一个应用程序，并获取你应用的API密钥副本。
- en: 'The first option is much easier to implement, whereas the second option allows
    tighter integration and control of the maps at the cost of more code and complexity.
    The second option requires very specific versions of the Xamarin.Android binding
    libraries corresponding to Google Play libraries. We chose to go with the first
    option for the `POIApp` example for the following reasons:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项更容易实现，而第二个选项允许更紧密的集成和控制地图，但代价是更多的代码和复杂性。第二个选项需要与Google Play库对应的非常具体的Xamarin.Android绑定库版本。我们选择第一个选项在`POIApp`示例中，以下是一些原因：
- en: It is very difficult to get the second option working inside an emulator, which
    means that you would have to test and view the results of the code on an actual
    device, which may not be an option for all readers
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模拟器中实现第二个选项非常困难，这意味着您可能需要在实际设备上测试和查看代码的结果，这可能不是所有读者都有的选择
- en: We would need to dedicate more time than we have available in this chapter to
    get the second option up and running
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要比本章中可用的更多时间来设置第二个选项
- en: Xamarin's official website contains articles with all the details required to
    get the second option working.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin的官方网站包含所有必要的详细信息，以实现第二个选项。
- en: Navigating to the Map app
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导航到地图应用程序
- en: To navigate to the Map app, we will rely on the `Intent` class we used earlier
    in the book; however, rather than specifying the `Activity` class we want to start,
    we will specify the type of information we would like to view using a URI. Android
    contains a registry of apps that can display different types of information and
    will launch the most appropriate app.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要导航到地图应用程序，我们将依赖本书前面使用过的`Intent`类；然而，我们不会指定我们想要启动的`Activity`类，而是将指定我们想要通过URI查看的信息类型。Android包含一个可以显示不同类型信息的应用程序注册表，并将启动最合适的应用程序。
- en: 'The Android platform defines a set of `Intent` classes that can be used to
    launch Google apps on Android devices. The following table summarizes the `Intent`
    classes related to locations:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Android平台定义了一系列可以用于在Android设备上启动Google应用程序的`Intent`类。以下表格总结了与位置相关的`Intent`类：
- en: URI
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: URI
- en: Action
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 动作
- en: '`geo:latitude,longitude`'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`geo:latitude,longitude`'
- en: This action opens the Map application centered at a latitude or longitude
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作将在指定的纬度或经度上打开地图应用程序
- en: '`geo:latitude,longitude?z=zoom`'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`geo:latitude,longitude?z=zoom`'
- en: This action opens the Map application centered at a latitude or longitude and
    zoomed to the specified level
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作将在指定的纬度或经度上打开地图应用程序，并放大到指定级别
- en: '`geo:0,0?q=my+street+address`'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`geo:0,0?q=my+street+address`'
- en: This action opens the Map application to the location of a street address
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作将在地图应用程序中打开街道地址的位置
- en: '`geo:0,0?q=business+near+city`'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`geo:0,0?q=business+near+city`'
- en: This action opens the Map application and displays the annotated search results
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作将在地图应用程序中打开并显示标注的搜索结果
- en: 'In our case, we have a street address, latitude and longitude, or both. If
    the street address is present, we should build the `Intent` class with it because
    this will cause the street address to appear in the Map app, making it more user
    friendly. If the street address is not present, we will build the `Intent` class
    using latitude and longitude. The following code shows the logic for building
    the `Intent` class:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们有一个街道地址、纬度和经度，或者两者都有。如果存在街道地址，我们应该使用它构建`Intent`类，因为这会使街道地址在地图应用程序中显示，使其更用户友好。如果不存在街道地址，我们将使用纬度和经度构建`Intent`类。以下代码显示了构建`Intent`类的逻辑：
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Prior to launching the `Intent` class, we need to be sure there is an app that
    can handle the `Intent` class; otherwise, we might end up with an unhandled exception
    from `StartActivity()`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动`Intent`类之前，我们需要确保有一个可以处理`Intent`类的应用程序；否则，我们可能会在`StartActivity()`中遇到未处理的异常。
- en: Checking for registered map apps
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查已注册的地图应用程序
- en: 'Apps provide information about any capabilities they provide (the `Intent`
    classes) in their manifest files as an `&lt;intent-filter/&gt;` element. Since
    we are relying on an external map app to display our location for us, we should
    check whether such an app exists on the device we are running on. We can accomplish
    this with a few calls to the `PackageManager` class. The `PackageManager` class
    allows you to retrieve various types of information about the application packages
    installed on a device. The `QueryIntentActivities()` method allows you to check
    whether there are any apps available to handle a specific `Intent` class. The
    following code demonstrates the use of `QueryIntentActivities()`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序在其清单文件中通过 `<intent-filter/>` 元素提供有关它们提供的任何功能（`Intent` 类）的信息。由于我们依赖于外部地图应用来显示我们的位置，因此我们应该检查我们正在运行的设备上是否存在此类应用。我们可以通过调用
    `PackageManager` 类的几个方法来完成此操作。`PackageManager` 类允许您检索有关设备上安装的应用程序包的各种类型的信息。`QueryIntentActivities()`
    方法允许您检查是否有任何应用程序可以处理特定的 `Intent` 类。以下代码演示了 `QueryIntentActivities()` 的使用：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create a `MapClicked()` event handler and attach it to the `_mapImageButton`.
    The following code snippet represents the complete `MapClicked()` code that is
    used to open a Map application:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 `MapClicked()` 事件处理程序并将其附加到 `_mapImageButton`。以下代码片段表示用于打开地图应用的完整 `MapClicked()`
    代码：
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Run `POIApp` and click on the **Map** button from the POI details page. You
    will notice that the Map app will be opened with the POI location. You have the
    option of choosing to navigate to it from your current location.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `POIApp` 并从 POI 详细页面点击 **地图** 按钮。你会注意到地图应用会以 POI 位置打开。你可以选择从当前位置导航到那里。
- en: Summary
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how to use device location services to find the current
    position. We also integrated `POIApp` with the native device map to position the
    POI on the map. In the next chapter, we will continue integrating with device
    capabilities by adding integration with the camera.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何使用设备位置服务来查找当前位置。我们还集成了 `POIApp` 与原生设备地图，以便在地图上定位 POI。在下一章中，我们将继续通过添加与摄像头的集成来扩展设备功能。
