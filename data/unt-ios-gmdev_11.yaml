- en: Chapter 11. Debugging and Optimization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。调试和优化
- en: Now that we have a nearly completed project it's time to start working on getting
    as much performance out of the system as possible. While we would normally address
    performance throughout the development process, I felt it was important to look
    at the project further along, so that we could see how to reengineer the product
    based on some questionable decisions we might have made earlier in the project.
    By doing it this way it will be possible to see these decisions within the context
    of how we might normally build an application.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在我们几乎完成了项目，是时候开始努力让系统尽可能高效地运行了。虽然我们通常会在整个开发过程中关注性能，但我认为在项目进行到更深入的阶段时再考虑这一点很重要，这样我们就可以看到如何根据我们在项目早期可能做出的某些有疑问的决定来重新设计产品。通过这种方式，我们将能够在通常构建应用程序的上下文中看到这些决定。
- en: 'In this chapter we shall:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Learn about debugging options in Unity
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Unity中的调试选项
- en: Learn how to profile a mobile application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何分析移动应用程序
- en: Learn about object pooling and why it's crucial on mobile devices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解对象池及其在移动设备上的重要性
- en: Learn how to optimize lighting with Beast Lighting
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用Beast Lighting优化光照
- en: This chapter is where we will highlight some of the key differences between
    making a game for Unity and making one for Unity on a mobile device. This chapter
    will make the biggest difference between our application being a hit and it just
    bring a pretty showpiece that people uninstall a few hours after launching it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将突出Unity游戏和移动设备上Unity游戏制作的一些关键区别。这一章将使我们的应用程序成为热门产品，而不仅仅是人们启动后几小时就会卸载的漂亮展示品。
- en: Debugging
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试
- en: Unity possesses a debugger that is a first-class citizen with the rest of the
    Unity platform. The debugger will allow you to put breakpoints directly in your
    Unity scripts, and while the game is running on the target device, allow you to
    pause the game's execution to enable observation or tweaking of variables. This
    is a very powerful approach that is often times missing when developing for a
    device. In the past, the best one could do is emit sounds or change screen colors
    when certain conditions were met. Today you can watch the values of variables
    change, make modifications to scripts that are executing on the device, and change
    the flow of execution of the game dynamically without much impact to the game's
    frame rate. So let's take a look at how we make this magic happen.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Unity拥有一个与其他Unity平台同等重要的调试器。调试器将允许你在Unity脚本中直接设置断点，当游戏在目标设备上运行时，允许你暂停游戏的执行，以便观察或调整变量。这是一种非常强大的方法，在为设备开发时往往缺失。在过去，最好的办法是在满足某些条件时发出声音或改变屏幕颜色。今天，你可以观察变量值的变化，修改在设备上运行的脚本，并动态地改变游戏的执行流程，而对游戏的帧率影响不大。所以，让我们看看如何实现这一魔法。
- en: Debugging a running application on real hardware is something that you need
    to be very comfortable with. While Unity can do an admirable job of helping you
    simulate your content on your Mac, there is nothing that beats knowing how your
    application will perform in the wild.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在真实硬件上调试运行中的应用程序是你需要非常熟悉的事情。虽然Unity可以很好地帮助你模拟内容在你的Mac上，但没有任何东西能比知道你的应用程序在野外如何表现更胜一筹。
- en: A breakpoint is a place in your game where you want to pause the execution of
    the application for debugging purposes. As the Unity scripting environment, MonoDevelop,
    is integrated with the Unity IDE, and consequently the runtime, we can insert
    breakpoints in our scripts, which will trigger the pause in execution.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 断点是在游戏中你希望为了调试目的暂停应用程序执行的地方。由于Unity脚本环境MonoDevelop与Unity IDE以及运行时集成，我们可以在脚本中插入断点，这将触发执行暂停。
- en: Time for action — Using breakpoints
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 — 使用断点
- en: Position the carat on the line that you want to pause execution on and use the
    hotkey combination **Apple-\** to create the breakpoint. For many keyboard-centric
    developers this is the preferred way of doing things.![Time for action — Using
    breakpoints](img/0409_11_01.jpg)
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将光标定位在你想暂停执行的那一行，并使用快捷键组合**Apple-\**来创建断点。对于许多以键盘为中心的开发者来说，这是做事的首选方式。![行动时间
    — 使用断点](img/0409_11_01.jpg)
- en: The other method is to click on the spine area to the left of the code and line
    numbers. If you are more a mouse-centric developer, you will find this to be the
    more natural way for setting breakpoints.
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一种方法是点击代码和行号左侧的脊柱区域。如果你是一个更倾向于使用鼠标的程序员，你会发现这是一种更自然地设置断点的方式。
- en: '![Time for action — Using breakpoints](img/0409_11_02.jpg)'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 — 使用断点](img/0409_11_02.jpg)'
- en: Observe that the line that you created the breakpoint on is highlighted with
    a red circle in the spine next to the code. This represents an active breakpoint.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，你创建断点的行在代码旁边的脊柱上用红色圆圈突出显示。这代表了一个活动断点。
- en: To deactivate a breakpoint, simply click on the red circle or press **Apple-\**
    again and the breakpoint will be removed.
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要禁用断点，只需点击红色圆圈或再次按**Apple-\**，断点将被移除。
- en: It should be noted that if you create a breakpoint on a line that contains no
    actual code, the break point would actually execute on the next line of executable
    code.
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应该注意的是，如果你在不含实际代码的行上创建断点，断点实际上会在下一行可执行代码上执行。
- en: Run the application.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序。
- en: '![Time for action — Using breakpoints](img/0409_11_03.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 — 使用断点](img/0409_11_03.jpg)'
- en: We can now observe that the application stops on the line where the breakpoint
    was located. This gives us an opportunity to observe the state of the application
    at the time when the breakpoint is reached. Many times it is useful to put a breakpoint
    inside of some control structure, such as an `if` statement, to see if the conditions
    which should trigger it are ever met.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以观察到应用程序停止在断点所在的行。这给了我们观察断点达到时应用程序状态的机会。很多时候，在某种控制结构（如`if`语句）内部放置断点是有用的，以查看是否满足触发它的条件。
- en: What just happened?
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发生了什么？
- en: You have just created a breakpoint within your application and had your app
    stop on the line specified. When the application is in this state it is paused
    so that you can examine and/or change the state of any variables of the application.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在你的应用程序中创建了一个断点，并且你的应用程序停止在指定的行上。当应用程序处于这种状态时，它会暂停，这样你就可以检查和/或更改应用程序中任何变量的状态。
- en: Time for action — Debugging the application
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 — 调试应用程序
- en: The process of getting the debugger to communicate with the running application
    and provide data to the user is known as attaching the debugger to the process.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 将调试器附加到正在运行的应用程序的过程，以便与运行的应用程序通信并提供数据给用户，被称为将调试器附加到进程。
- en: Deploy and run your game on your iOS device. Make sure that the device is on
    the same WiFi network as the machine that will be doing the debugging and then
    select the iOS device that you want to attach to.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的iOS设备上部署并运行你的游戏。确保设备与将要进行调试的机器处于同一WiFi网络上，然后选择你想要连接的iOS设备。
- en: Select the **Debug** button in the toolbar:![Time for action — Debugging the
    application](img/0409_11_04.jpg)
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在工具栏中选择**调试**按钮：![行动时间 — 调试应用程序](img/0409_11_04.jpg)
- en: 'MonoDevelop will then launch the Unity editor and after some time start the
    execution of your application. Your application will begin running in the player
    and stop when the first breakpoint in your code is encountered:'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: MonoDevelop将启动Unity编辑器，经过一段时间后开始执行你的应用程序。你的应用程序将在玩家中开始运行，并在遇到代码中的第一个断点时停止：
- en: '![Time for action — Debugging the application](img/0409_11_05.jpg)'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 — 调试应用程序](img/0409_11_05.jpg)'
- en: Select the game that you want the Unity debugger to attach itself to. In this
    image we see the Unity Editor as one process we can attach to and another referred
    to as "null (mono)." This is your game running on your iOS device. Select this
    instance of your game.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你想让Unity调试器附加到的游戏。在这张图片中，我们看到Unity编辑器作为一个可以附加到的进程，另一个被称为“null (mono)”。这是在你的iOS设备上运行的游戏。选择这个游戏实例。
- en: What just happened?
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发生了什么？
- en: We have just attached our debugger to an instance of our game that is running
    on our iOS device. This is very useful as we can get real debugging information
    from our actual device. When testing an application it is important to do this,
    as there will be times when an application will run fine within Unity on the PC,
    yet fail on an actual device.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将调试器附加到了在我们iOS设备上运行的游戏实例。这非常有用，因为我们可以从实际设备获取真实的调试信息。在测试应用程序时，这样做很重要，因为有时应用程序在PC上的Unity中运行良好，但在实际设备上却失败。
- en: Time for action — Stepping through the game
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 — 游戏单步执行
- en: 'Once you have reached a breakpoint and examined variable values at that point,
    the next thing you will want to do is step forward in the application so you can
    watch the application change over time. There are several options available to
    you for stepping forward through the application depending on what your intentions
    are. The following screenshot shows these options: **Step Over, Step Into, Step
    Out, Pause**, and **Detach Debugger:**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你达到了断点并检查了该点的变量值，接下来你想做的事情就是向前执行应用程序，以便你可以观察应用程序随时间的变化。根据你的意图，有几种选项可供你在应用程序中向前执行。下面的截图显示了这些选项：**Step
    Over, Step Into, Step Out, Pause**和**Detach Debugger**：
- en: '![Time for action — Stepping through the game](img/0409_11_06.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 — 游戏步骤](img/0409_11_06.jpg)'
- en: Press the Step into icon so that the application will start.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下**Step Into**图标，使应用程序开始运行。
- en: As you can see below, the application is paused at the breakpoint. The current
    line of execution is highlighted in yellow:![Time for action — Stepping through
    the game](img/0409_11_07.jpg)
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下图所示，应用程序在断点处暂停。当前执行的行以黄色突出显示：![行动时间 — 游戏步骤](img/0409_11_07.jpg)
- en: As mentioned earlier, when the debugger is attached, you can get the value of
    any variable in your game. However, it would be cumbersome to have to constantly
    look for each individual variable, especially if there is a variable that we want
    to examine over time. You can accomplish this by setting up a watch for a variable
    of interest and observe its value as it changes.
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前所述，当调试器附加时，你可以获取游戏中任何变量的值。然而，如果需要不断查找每个单独的变量，尤其是当我们想要观察随时间变化的变量时，这会变得很繁琐。你可以通过为感兴趣的变量设置监视来观察其值的变化。
- en: Create a new watch by selecting the **Watch** tab in MonoDevelop. Enter the
    word **Screen** into the **Watch** tab to have MonoDevelop open an autocomplete
    dialog showing all of the attributes of the **Screen** object:![Time for action
    — Stepping through the game](img/0409_11_08.jpg)
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 MonoDevelop 中选择**监视**选项卡创建一个新的监视。在**监视**选项卡中输入单词**Screen**，MonoDevelop 将打开一个自动完成对话框，显示
    **Screen** 对象的所有属性：![行动时间 — 游戏步骤](img/0409_11_08.jpg)
- en: We can see here that **Screen** has a **currentResolution** attribute attached
    to it.
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以看到，**Screen** 有一个附加的 **currentResolution** 属性。
- en: 'Select **currentResolution** so that a watch is created for this variable.
    If the variable you''ve selected is an object, you will see a triangle to the
    left of it. Clicking on this triangle will display any attributes of the object
    as shown in the following screenshot:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**currentResolution**以创建此变量的监视。如果你选择的变量是一个对象，你将在其左侧看到一个三角形。点击此三角形将显示对象的所有属性，如下面的截图所示：
- en: '![Time for action — Stepping through the game](img/0409_11_09.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 — 游戏步骤](img/0409_11_09.jpg)'
- en: Here we are able to see all of the attributes of the **Screen.currentResolution**
    object.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到 **Screen.currentResolution** 对象的所有属性。
- en: What just happened?
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We have just stepped through our application using the attached debugger and
    added a watch so that we can observe a variable as it changes over time. Adding
    watches is a common way to examine variables as they change during the execution
    of the game. As you begin writing complex scripts, creating watches will help
    you determine whether or not the correct behaviors are happening at runtime.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚使用附加的调试器遍历了我们的应用程序，并添加了一个监视，以便我们可以观察变量随时间的变化。添加监视是检查游戏执行过程中变量变化的一种常见方式。当你开始编写复杂的脚本时，创建监视将帮助你确定在运行时是否发生了正确的行为。
- en: Profiling
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能分析
- en: We've been going along building our game and running it for sometime and it
    appears to be performing okay, but to really determine how our game is performing,
    we are going to have to profile. Profiling is the act of gathering information
    about how each part of our game is performing so that we can optimize the code
    or assets that are causing performance bottlenecks.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在构建我们的游戏并运行了一段时间，看起来表现良好，但为了真正确定我们的游戏表现如何，我们必须要进行性能分析。性能分析是收集有关游戏每个部分如何表现的信息的行为，以便我们可以优化导致性能瓶颈的代码或资源。
- en: We could make some assumptions about how the game is running and start blindly
    optimizing code because it should be faster to do it a certain way, but in reality,
    the biggest performance wins won't be obvious until you see what the profiler
    is telling you about the game. To successfully profile an application one has
    to really look at the data objectively as poor performance could result from texture
    sizes, shaders, scripts, physics, draw calls, or even something as simple as adding
    fog.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对游戏的运行方式做出一些假设，并盲目地优化代码，因为按照某种方式做应该会更快，但现实中，最大的性能提升直到您看到分析器告诉您的游戏信息时才会变得明显。要成功分析一个应用程序，必须真正客观地查看数据，因为性能不佳可能是由纹理大小、着色器、脚本、物理、绘制调用，甚至是添加雾气这样简单的事情引起的。
- en: So let's go through our current application and walk through the process of
    profiling it.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们遍历我们的当前应用程序，并了解分析它的过程。
- en: Time for action — Fine tuning the application (Pro Versions)
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作时间——微调应用程序（专业版本）
- en: Now we're going to take our application and tune it so that it performs well,
    and has consistent behavior, regardless of where we are in the environment.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将对我们的应用程序进行调整，以确保它在任何环境中都能良好运行，并保持一致的行为。
- en: Start the Profiler by selecting it from the **Window** menu **(Window | Profiler):**![Time
    for action — Fine tuning the application (Pro Versions)](img/0409_11_10.jpg)
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择**窗口**菜单中的**分析器**来启动分析器：![操作时间——微调应用程序（专业版本）](img/0409_11_10.jpg)
- en: 'The profiler will start and display the profiling interface for Unity. If you
    are familiar with the XCode tool Instruments you will find many of the same design
    and interface concepts in the Unity profiler:'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析器将启动并显示Unity的分析接口。如果您熟悉XCode工具的Instruments，您将在Unity分析器中找到许多相同的设计和界面概念：
- en: '![Time for action — Fine tuning the application (Pro Versions)](img/0409_11_11.jpg)'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![操作时间——微调应用程序（专业版本）](img/0409_11_11.jpg)'
- en: 'The **Profiler** will display metrics across a range of different settings:
    **CPU Usage, Rendering, Memory, Audio**, and **Physics**. You can remove profilers
    by clicking on the X in the upper-left corner of the **Profiler.**'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分析器**将显示一系列不同设置下的指标：**CPU 使用率、渲染、内存、音频**和**物理**。您可以通过点击**分析器**左上角的X来移除分析器。'
- en: Remove the **Audio** profiler by clicking on the X in the upper-left corner
    of the **Profiler:**![Time for action — Fine tuning the application (Pro Versions)](img/0409_11_12.jpg)
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**分析器**左上角的X来移除**音频**分析器：![操作时间——微调应用程序（专业版本）](img/0409_11_12.jpg)
- en: Add the **Audio** profiler back by clicking on the **Add Profiler** drop-down
    and selecting the **Audio** profiler:![Time for action — Fine tuning the application
    (Pro Versions)](img/0409_11_13.jpg)
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**添加分析器**下拉菜单并选择**音频**分析器来将**音频**分析器添加回来：![操作时间——微调应用程序（专业版本）](img/0409_11_13.jpg)
- en: The profilers that are already added will be greyed out. In this example both
    **Audio** and **Physics** can be added to the **Profiler.**
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已经添加的分析器将会变灰。在这个例子中，**音频**和**物理**都可以添加到**分析器**中。
- en: 'Start the game by pressing the **Play** button. Immediately you will see the
    profiler fill with data from the profiling session:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按下**播放**按钮开始游戏。立即您会看到分析器填充了来自分析会话的数据：
- en: '![Time for action — Fine tuning the application (Pro Versions)](img/0409_11_14.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![操作时间——微调应用程序（专业版本）](img/0409_11_14.jpg)'
- en: What just happened?
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We have used the build in Unity profiler to examine the performance of our application
    and explore the different metrics that it is returning so that we can gain some
    insight to the bottlenecks in our application. Now that we've done this we can
    identify some hot spots and look at a few ways to fix the issues that we uncover.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用内置的Unity分析器来检查我们应用程序的性能，并探索它返回的不同指标，以便我们可以对应用程序中的瓶颈有所了解。现在我们已经做了这件事，我们可以识别一些热点，并查看一些修复我们发现的问题的方法。
- en: Object pooling — Into the pool
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象池化——进入池中
- en: As we have learned from our profiling session, one of the largest performance
    detriments on the mobile platforms is the constant creation and destruction of
    GameObjects. As you probably noticed earlier when we were testing out firing our
    weapons, there were noticeable pauses in the game every so often. Let's examine
    why this happens.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的分析会话中我们了解到，在移动平台上最大的性能损失之一是GameObject的持续创建和销毁。正如您可能之前在测试我们发射武器时注意到的，游戏中的暂停现象时有发生。让我们来看看为什么会这样发生。
- en: When an instance of the class `GameObject` is created in Unity on a mobile device,
    the device must allocate memory for this new instance of `GameObject` and potentially
    clear out memory that is used by some other object that may not be visible. This
    process, known as garbage collection, takes just enough time that it causes the
    pauses that you experience in the game. The reason this happens is due to the
    limited amount of memory available on the target devices and the time it takes
    to collect the old object. Java developers, particularly those that were brave
    enough to write games for the platform, are very familiar with the issues associated
    with garbage collection.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当在移动设备上的Unity中创建`GameObject`类的实例时，设备必须为这个新的`GameObject`实例分配内存，并可能清除由某些可能不可见对象使用的内存。这个过程，称为垃圾回收，所需的时间足以导致你在游戏中体验到的暂停。这种情况发生的原因是由于目标设备上可用的内存有限以及收集旧对象所需的时间。Java开发者，尤其是那些勇敢地编写平台游戏的开发者，非常熟悉与垃圾回收相关的问题。
- en: Typically, one will resolve some of the issues associated with garbage collection
    through the use of an object pool. An object pool allows one to allocate a number
    of objects up front and cycle through them such that new objects are never created.
    In the case of our weapon example we would allocate a number of objects in our
    game object pool that represent the max number of projectiles we want to be able
    to display at one time. As projectiles reach a certain distance from the player,
    we can remove them and free up a new object in the object pool for objects that
    are going to be visible next.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，人们会通过使用对象池来解决与垃圾回收相关的一些问题。对象池允许你预先分配一定数量的对象，并通过它们循环使用，这样就不会创建新的对象。在我们的武器示例中，我们会在游戏对象池中分配一定数量的对象，这些对象代表我们希望一次显示的最大子弹数量。当子弹达到玩家一定距离时，我们可以移除它们，并在对象池中为新对象腾出空间，以便显示下一个可见对象。
- en: This particular implementation of an object pool was created by the Unity3D
    forum member and has an extension for particle systems as well as audio.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这种对象池的实现是由Unity3D论坛成员创建的，并且还扩展了粒子系统和音频。
- en: '[PRE0]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `ObjectPool` code is very straight-forward. It exposes several public variables
    so that you can configure it from the Unity IDE itself. The `ObjectPool` implemented
    here is designed to pool a variety of classes of objects at once. You don't need
    an implementation for each type of `GameObject` you want to pool. The **ObjectPool**
    stores each of the object types you want to pool in the `ObjectPrefabs` array.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`ObjectPool`代码非常直观。它公开了一些变量，以便你可以在Unity IDE中直接配置它。这里实现的`ObjectPool`旨在同时池化多种类的对象。你不需要为每个想要池化的`GameObject`类型实现一个实现。**ObjectPool**将你想要池化的每种对象类型存储在`ObjectPrefabs`数组中。'
- en: '![Object pooling — Into the pool](img/0409_11_15.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![对象池 — 进入池中](img/0409_11_15.jpg)'
- en: By default the pool will create a maximum of three objects of each type. If
    you want to configure the amount of objects that an individual object can have,
    expand the **Amount To Buffer** element and set that size.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，池将创建每种类型最多三个对象。如果你想配置单个对象可以拥有的对象数量，展开**Amount To Buffer**元素并设置该大小。
- en: Time for action — Optimizing with the object pool
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 — 使用对象池进行优化
- en: Now that we have a game object pool and the ability to profile our application
    we can look at how this optimization improves our application's performance. We
    will do this by replacing the `GameObject` instantiation approach that we took
    to creating projectiles when the player fires his weapon.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了游戏对象池和性能分析的能力，我们可以看看这种优化是如何提高我们的应用程序性能的。我们将通过替换玩家开火时创建子弹所采用的`GameObject`实例化方法来实现这一点。
- en: Connect the game to the profiler following the previous *Time for action —*
    and run it, firing a large number of projectiles:![Time for action — Optimizing
    with the object pool](img/0409_11_16.jpg)
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照之前的*行动时间 —*连接游戏到性能分析器，并运行它，发射大量子弹：![行动时间 — 使用对象池进行优化](img/0409_11_16.jpg)
- en: What we can see from this object profile is that performance dips considerably
    when the weapon is fired. The reason for this is because we are creating GameObjects
    on the fly. We can see here that when these objects are removed from view and
    collected, the performance of the application becomes more consistent. Things
    like this are a smoking gun and we have an optimization that can be made to improve
    performance of the game.
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从这个对象配置文件中我们可以看到，当武器发射时，性能会显著下降。原因是我们在实时创建GameObject。我们可以看到，当这些对象从视图中移除并被收集时，应用程序的性能变得更加一致。这类问题是明显的性能瓶颈，我们可以通过优化来提高游戏性能。
- en: Create a **GameObject** called **PoolManager:**![Time for action — Optimizing
    with the object pool](img/0409_11_17.jpg)
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为**PoolManager**的**GameObject**：![执行动作 — 使用对象池进行优化](img/0409_11_17.jpg)
- en: Add the **ObjectPool** script to the **PoolManager:**![Time for action — Optimizing
    with the object pool](img/0409_11_18.jpg)
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**ObjectPool**脚本添加到**PoolManager**：![执行动作 — 使用对象池进行优化](img/0409_11_18.jpg)
- en: Add the prefabs that you want to pool to the **Object Prefabs** array. You can
    accomplish this by dragging a prefab from the **Hierarchy** view onto the **Object
    Prefabs** array:![Time for action — Optimizing with the object pool](img/0409_11_19.jpg)
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你想要池化的预制体添加到**Object Prefabs**数组中。你可以通过将预制体从**Hierarchy**视图拖动到**Object Prefabs**数组中完成此操作：![执行动作
    — 使用对象池进行优化](img/0409_11_19.jpg)
- en: Replace the existing `fireWeapon` script with the optimized `fireWeapon` script
    that uses the **Object Pool:**
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用使用**Object Pool**的优化版`fireWeapon`脚本替换现有的`fireWeapon`脚本：
- en: '[PRE1]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: What we have done here is replace the `GameObject.Instantiate()` method that
    we were originally using for creating new bullets from our weapon.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在这里所做的是替换了原本用于从武器中创建新子弹的`GameObject.Instantiate()`方法。
- en: Start the game again and look at the **Profiler** profile. Fire a lot of projectiles
    and examine the performance.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次启动游戏并查看**Profiler**配置文件。发射大量投射物并检查性能。
- en: What just happened?
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We have just improved the performance of our application using object pooling.
    As you can see, the performance of the application is consistent now. This is
    what we are aiming for a consistent frame rate.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚通过对象池提高了应用程序的性能。正如你所见，应用程序的性能现在是一致的。这正是我们追求的稳定帧率。
- en: Instead of paying the penalty for creating and deleting large numbers of `GameObject`
    instances, we are instead creating a pool of those objects and simply changing
    their position, rotation, state, and visibility. This is an old trick that was
    frequently employed in gaming that was lost in the age of modern computers and
    graphics capabilities, but is just what we need on mobile devices to ensure optimal
    performance.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是为创建和删除大量`GameObject`实例而支付惩罚，而是创建一个这些对象的池，并简单地改变它们的位置、旋转、状态和可见性。这是一个在游戏开发中经常使用的老技巧，但随着现代计算机和图形能力的兴起而失传，但正是我们在移动设备上确保最佳性能所需要的。
- en: Unleash the beast
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 放出野兽
- en: So often when you're trying to improve the performance of your application you
    will have to make trade-offs between the visual presentation of your application
    and its performance. This time we will perform optimizations that will enhance
    both the performance and visual quality of our application is by using the integrated
    Beast lightmapping system from Illuminate Labs.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当你试图提高应用程序的性能时，你经常需要在应用程序的视觉表现和性能之间做出权衡。这次，我们将通过使用Illuminate Labs的集成Beast光照贴图系统来执行优化，这将提高我们应用程序的性能和视觉质量。
- en: The goal of lighting in our game is to provide a realistic depiction of our
    world. Normally the objects in the world would have some base material or texture
    that describes their natural surface. The lighting algorithms used by the engine
    would then compute the effects of the lights on the pixels or texels of the object's
    surface when it is rendered.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中照明的目标是提供我们世界的真实描绘。通常，世界中的物体会有一些基础材质或纹理来描述它们的自然表面。引擎使用的照明算法随后会计算当物体渲染时，光线对其表面像素或texels的影响。
- en: Lightmapping, as its name implies, is the process of utilizing lighting data
    (emissive properties, real lights, and so on) and casting rays from these lights
    as if they were active in the scene. The engine will then take the actual effect
    of these lights and store it in texture maps that will be mapped onto textures
    at run time (Unity refers to this process as baking the lights). As a result you
    can have a very complex lighting environment based upon a computationally intensive
    number of lights. You can also have all of this information baked into the texture
    maps of the scene, resulting in increased visual quality without the expense of
    having lights within your scene.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，光照贴图是利用光照数据（发射属性、真实光源等）并从这些光源发射光线的过程，就像它们在场景中活跃一样。然后，引擎将存储这些光源的实际效果，并将其存储在将在运行时映射到纹理上的纹理图中（Unity
    将此过程称为烘焙光照）。因此，你可以基于大量计算密集型光源创建一个非常复杂的光照环境。你还可以将所有这些信息烘焙到场景的纹理图中，从而在不增加场景中光源成本的情况下提高视觉效果。
- en: As lighting is one of the more expensive operations you can perform on mobile
    devices, using lightmaps represents a major performance win. While lightmapping
    will eventually be replaced with per pixel lighting in shaders, today's mobile
    hardware isn't quite up to the task.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于光照是你在移动设备上可以执行的成本较高的操作之一，因此使用光照贴图代表了一次重大的性能提升。虽然光照贴图最终将被着色器中的逐像素光照所取代，但今天的移动硬件还不足以完成这项任务。
- en: So let's look at how we can make this work for our application.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们看看我们如何使我们的应用程序实现这一点。
- en: Time for action — Generating Beast lightmaps
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手实践 — 生成 Beast 光照贴图
- en: To illustrate how lightmapping can improve our application we're going to take
    our City level scene and add Beast lightmapping to it.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明光照贴图如何改进我们的应用程序，我们将使用我们的城市级别场景并为其添加 Beast 光照贴图。
- en: The first step in preparing our scene for lightmapping is to ensure that any
    object that we want to have lightmaps generated for is declared static. Unity
    uses this declaration to make assumptions that the object won't move, scale, or
    change in any way during the scene. Remember, we only want to bake lightmaps on
    static geometry, as we're generating lighting based on the location of lights
    in the scene at a given time. If we tried to use this approach on objects that
    moved, for example, you'd find that even though an object changes its orientation
    with respect to a light, the lighting and shadow calculations would look as if
    the object were in a different place:![Time for action — Generating Beast lightmaps](img/0409_11_20.jpg)
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备场景进行光照贴图的第一步是确保我们想要为光照贴图生成的任何对象都被声明为静态。Unity 使用这个声明来做出假设，即对象在场景中不会移动、缩放或以任何方式改变。记住，我们只想在静态几何体上烘焙光照贴图，因为我们正在根据场景中给定时间的光源位置生成光照。如果我们尝试在移动的对象上使用这种方法，例如，你会发现即使对象相对于光源改变了方向，光照和阴影的计算看起来就像对象在另一个地方一样：![动手实践
    — 生成 Beast 光照贴图](img/0409_11_20.jpg)
- en: Here we have specified that one of our birch tree prefabs is **Static**. Similarly
    we can add the same settings to the terrain.
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这里，我们指定了我们的白桦树预制件之一是**静态**的。同样，我们也可以将这些相同的设置添加到地形中。
- en: Add a light to the scene using **Game Object | Create Other | Point Light**.
    Position this light in our scene. This is the light whose lighting effects we
    want to bake into our scene. Now that our objects are defined as being static,
    let's add a light to the scene that we want to bake to our objects:![Time for
    action — Generating Beast lightmaps](img/0409_11_21.jpg)
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**游戏对象 | 创建其他 | 点光源**在场景中添加一个光源。将此光源放置在我们的场景中。这是我们想要将光照效果烘焙到场景中的光源。现在，由于我们的对象被定义为静态的，让我们添加一个我们想要烘焙到对象中的光源：![动手实践
    — 生成 Beast 光照贴图](img/0409_11_21.jpg)
- en: Observe the scene to see what everything looks like when the lighting is rendering
    normally. This will give us an idea of what the lightmapped scene should look
    like if we perform the operation properly:![Time for action — Generating Beast
    lightmaps](img/0409_11_22.jpg)
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察场景，看看在光照正常渲染时一切看起来是什么样子。这将给我们一个概念，如果我们正确执行操作，光照贴图场景应该是什么样子：![动手实践 — 生成 Beast
    光照贴图](img/0409_11_22.jpg)
- en: Now that we've provided some lighting data for the lightmapper to work with,
    we can start the baking process.
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们已经为光照贴图提供了一些光照数据，我们可以开始烘焙过程。
- en: In the **Window** menu select the **Lightmapping** option to bring up the Beast
    lightmapping interface:![Time for action — Generating Beast lightmaps](img/0409_11_23.jpg)
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**窗口**菜单中选择**光照贴图**选项，以打开 Beast 光照贴图界面：![动手实践 — 生成 Beast 光照贴图](img/0409_11_23.jpg)
- en: 'This will open the Unity Lightmapping interface which allows us to configure
    the Beast lightmapping session:'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这将打开Unity光照贴图界面，允许我们配置Beast光照贴图会话：
- en: '![Time for action — Generating Beast lightmaps](img/0409_11_24.jpg)'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![动手实践——生成Beast光照贴图](img/0409_11_24.jpg)'
- en: With the interface is open, select the **Point light** we added to the scene
    and click on the **Bake** tab:![Time for action — Generating Beast lightmaps](img/0409_11_25.jpg)
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当界面打开时，选择场景中添加的**点光源**，然后点击**烘焙**标签：![动手实践——生成Beast光照贴图](img/0409_11_25.jpg)
- en: We can take our simple light and have it baked into the lightmaps of the scene.
    Press the **Bake** button and observe the debug output window:![Time for action
    — Generating Beast lightmaps](img/0409_11_26.jpg)
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以将我们的简单灯光烘焙到场景的光照贴图中。按下**烘焙**按钮，并观察调试输出窗口：![动手实践——生成Beast光照贴图](img/0409_11_26.jpg)
- en: The output window is telling us that it is unable to bake the lights because
    there is no UV data for the geometry in our scene. Remember that our lightmaps
    are texture maps that are being added as a texture map and, as such, if the geometry
    does not have UVs generated properly it cannot generate the lightmaps.
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出窗口告诉我们，它无法烘焙灯光，因为场景中的几何形状没有UV数据。记住，我们的光照贴图是作为纹理贴图添加的，因此，如果几何形状没有正确生成UV，则无法生成光照贴图。
- en: Select the geometry that Unity is reporting does not have UV data and select
    its **FBXImporter**. Click on the **Generate Lightmap UVs** button to ensure that
    Unity generates the UV information for this piece of geometry:![Time for action
    — Generating Beast lightmaps](img/0409_11_27.jpg)
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择Unity报告没有UV数据的几何形状，并选择其**FBX导入器**。点击**生成光照贴图UV**按钮，以确保Unity为这块几何形状生成UV信息：![动手实践——生成Beast光照贴图](img/0409_11_27.jpg)
- en: Now when you bake the scene, Unity will be able to generate a properly lightmapped
    scene.
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在当你烘焙场景时，Unity将能够生成一个正确光照贴图化的场景。
- en: Select the **Point light** in the **Hierarchy** view and delete it from the
    scene. When you run the game you will note that the game looks exactly the same
    as it did before but it is now running without the performance overhead of the
    lights in the scene.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**视图中选择**点光源**，并将其从场景中删除。当你运行游戏时，你会注意到游戏看起来与之前完全一样，但现在它正在运行，没有场景中灯光的性能开销。
- en: What just happened?
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: What Unity is doing behind the scenes is taking all of the assets and scripts
    from the Unity IDE and putting together a player that will be able to playback
    the content and all of its scenarios based on input from the user. This is a very
    important concept to understand as the content within the Unity IDE is largely
    platform agnostic and can be readily redeployed after a simple recompile within
    the Unity environment. This player is the the actual application that is deployed
    to the iOS device.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Unity在幕后所做的是，从Unity IDE中提取所有资源和脚本，并组合成一个玩家，该玩家能够根据用户的输入回放内容及其所有场景。这是一个非常重要的概念，因为Unity
    IDE中的内容在很大程度上是平台无关的，并且可以在Unity环境中简单重新编译后轻松重新部署。这个玩家是实际部署到iOS设备上的应用程序。
- en: Summary
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we learned a little bit about the topic of debugging, profiling
    and optimizing Unity projects. We've really only just scratched the surface on
    the subject, however, as game optimization can fill a book in its own right and
    much of it is related to the design of a particular application.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们简要地学习了调试、性能分析和优化Unity项目的主题。然而，关于游戏优化，它本身就可以写成一本书，而且其中很多内容与特定应用程序的设计有关。
- en: 'Specifically, we covered:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们涵盖了：
- en: How to attach the Unity debugger to a running application
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将Unity调试器附加到运行中的应用程序
- en: How to profile a Unity application
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何分析Unity应用程序
- en: Using object pooling to improve mobile application performance
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用对象池提高移动应用程序性能
- en: Using Beast lightmapping to improve performance and visual quality
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Beast光照贴图提高性能和视觉效果
- en: Now that we've profiled our application and worked specifically to improve its
    performance it's time to investigate monetization of our game and publish it on
    the AppStore.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经分析了我们的应用程序，并专门工作以提高其性能，现在是时候调查我们游戏的货币化和在AppStore上发布它了。
