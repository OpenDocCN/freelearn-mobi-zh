- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Building User Screen Flows
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建用户屏幕流程
- en: This chapter covers the Android activity lifecycle and explains how the Android
    system interacts with your app. By the end of this chapter, you’ll have learned
    how to build user journeys through different screens. You’ll also be able to use
    activity tasks and launch modes, save and restore the state of your activity,
    use logs to report on your application, and share data between screens.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了Android活动生命周期，并解释了Android系统如何与您的应用交互。在本章结束时，您将学会如何通过不同的屏幕构建用户旅程。您还将能够使用活动任务和启动模式，保存和恢复活动状态，使用日志报告您的应用程序，以及在不同屏幕之间共享数据。
- en: The previous chapter introduced you to the core elements of Android development,
    from configuring your app using the `AndroidManifest.xml` file, working with simple
    activities, and the Android resource structure to building an app with `gradle`
    and running an app on a virtual device.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章向您介绍了Android开发的核心理念，从使用`AndroidManifest.xml`文件配置您的应用，处理简单的活动，以及Android资源结构，到使用`gradle`构建应用和在虚拟设备上运行应用。
- en: In this chapter, you’ll go further and learn how the Android system interacts
    with your app through the Android lifecycle, how you are notified of changes to
    your app’s state, and how you can use the Android lifecycle to respond to these
    changes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将进一步学习Android系统如何通过Android生命周期与您的应用交互，您如何被通知应用状态的变化，以及您如何使用Android生命周期来响应这些变化。
- en: You’ll then progress to learning how to create user journeys through your app
    and how to share data between screens. You’ll be introduced to different techniques
    to achieve these goals so that you’ll be able to use them in your own apps and
    recognize them when you see them used in other apps.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将学习如何通过您的应用创建用户旅程以及如何在屏幕之间共享数据。您将介绍不同的技术来实现这些目标，以便您可以在自己的应用中使用它们，并在看到其他应用中使用它们时能够识别它们。
- en: 'We will cover the following topics in the chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: The Activity lifecycle
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 活动生命周期
- en: Saving and restoring the Activity state
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存和恢复活动状态
- en: Activity interaction with Intents
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 活动与意图的交互
- en: Intents, Tasks, and Launch Modes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 意图、任务和启动模式
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The complete code for all the exercises and the activity in this chapter is
    available on GitHub at [https://packt.link/PmKJ6](https://packt.link/PmKJ6)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章所有练习和活动的完整代码可在GitHub上找到，链接为[https://packt.link/PmKJ6](https://packt.link/PmKJ6)
- en: The Activity lifecycle
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动生命周期
- en: 'In the previous chapter, we used the `onCreate(saveInstanceState: Bundle?)`
    method to display a layout in the UI of our screen. Now, we’ll explore in more
    detail how the Android system interacts with your application to make this happen.
    As soon as an Activity is launched, it goes through a series of steps to take
    it through initialization, from preparing to be displayed to being partially displayed
    and then fully displayed.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '在上一章中，我们使用了`onCreate(saveInstanceState: Bundle?)`方法在屏幕的UI中显示布局。现在，我们将更详细地探讨Android系统如何与您的应用交互以实现这一点。一旦活动启动，它将经历一系列步骤，从准备显示到部分显示，然后完全显示。'
- en: There are also steps that correspond with your application being hidden, backgrounded,
    and then destroyed. This process is called the **Activity lifecycle**. For every
    one of these steps, there is a **callback** that your Activity can use to perform
    actions such as creating and changing the display and saving data when your app
    has been put into the background and then restoring that data after your app comes
    back into the foreground.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有与您的应用被隐藏、后台运行然后销毁相对应的步骤。这个过程被称为**活动生命周期**。对于这些步骤中的每一个，都有一个**回调**，您的活动可以使用它来执行在应用被置于后台时创建和更改显示以及保存数据，当应用回到前台后恢复这些数据的操作。
- en: These callbacks are made on your Activity’s parent, and it’s up to you to decide
    whether you need to implement them in your own Activity to take any corresponding
    action. Each of these callback functions has the `override` keyword. The `override`
    keyword in Kotlin means that either this function is providing an implementation
    of an interface or an abstract method, or, in the case of your Activity here,
    which is a subclass, it is providing the implementation that will override its
    parent.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这些回调是在您的活动父级上进行的，您需要决定是否需要在您的活动中实现它们以执行任何相应的操作。每个这些回调函数都有`override`关键字。在Kotlin中，`override`关键字意味着这个函数要么提供了一个接口或抽象方法的实现，要么，在您当前的活动这里，作为一个子类，它提供了一个将覆盖其父类的实现。
- en: 'Now that you know how the Activity lifecycle works in general, let’s go into
    more detail about the principal callbacks you will work with in order, from creating
    an Activity to the Activity being destroyed:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了Activity生命周期的一般工作原理，让我们更详细地探讨您将按顺序工作的主要回调，从创建Activity到Activity被销毁：
- en: '`override fun onCreate(savedInstanceState: Bundle?)`: This is the callback
    that you will use the most for activities that draw a full-sized screen. It’s
    here where you prepare your Activity layout to be displayed. At this stage, after
    the method has completed, it is still not displayed to the user, although it will
    appear that way if you don’t implement any other callbacks. You usually set up
    the UI of your Activity here by calling the `setContentView(R.layout.activity_main)`
    method and carrying out any initialization that is required.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`override fun onCreate(savedInstanceState: Bundle?)`: 这是您将最常用于绘制全屏活动的回调。在这里，您准备Activity布局以供显示。在这个阶段，方法完成后，它仍然没有显示给用户，尽管如果您没有实现任何其他回调，它看起来会是这样。您通常在这里通过调用`setContentView(R.layout.activity_main)`方法来设置Activity的UI，并执行任何所需的初始化。'
- en: This method is only called once in its lifecycle unless the Activity is created
    again. This happens by default for some actions (such as rotating the phone from
    portrait to landscape orientation). The `savedInstanceState` parameter of the
    `Bundle?` type (`?` means the type can be null) in its simplest form is a map
    of key-value pairs optimized to save and restore data.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在其生命周期中，此方法只会被调用一次，除非Activity再次被创建。对于某些操作（如将手机从纵向旋转到横向）默认情况下会发生这种情况。`Bundle?`类型的`savedInstanceState`参数（`?`表示该类型可以为null）在最简单的形式中是一个优化了保存和恢复数据的键值对映射。
- en: It will be null if this is the first time that the Activity has been run after
    the app has started, if the Activity is being created for the first time, or if
    the Activity is being recreated without any states being saved.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是应用程序启动后第一次运行Activity，或者Activity是第一次被创建，或者Activity在没有保存任何状态的情况下被重新创建，那么它将是空的。
- en: '`override fun onRestart()`: When the Activity restarts, this is called immediately
    before `onStart()`. It is important to be clear about the difference between restarting
    an Activity and recreating an activity. When the Activity is backgrounded by pressing
    the home button, when it comes back into the foreground again `onRestart()` will
    be called. Recreating an Activity is what happens when a configuration change
    happens, such as the device being rotated. The Activity is finished and then created
    again, in which case `onRestart()` will not be called.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`override fun onRestart()`: 当Activity重新启动时，这个方法会在`onStart()`之前立即被调用。了解重启Activity和重新创建Activity之间的区别很重要。当Activity被按下主页按钮置于后台，然后再次进入前台时，`onRestart()`会被调用。重新创建Activity发生在配置更改时，例如设备旋转。Activity结束时会被重新创建，在这种情况下，`onRestart()`不会被调用。'
- en: '`override fun onStart()`: This is the first callback made when the Activity
    is brought from the background to the foreground.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`override fun onStart()`: 这是当Activity从后台被带到前台时第一次被调用的回调。'
- en: '`override fun onRestoreInstanceState(savedInstanceState: Bundle?)`: If the
    state has been saved using `onSaveInstanceState(outState: Bundle?)`, this is the
    method that the system calls after `onStart()` where you can retrieve the `Bundle`
    state instead of restoring the state using `onCreate(savedInstanceState: Bundle?)`.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`override fun onRestoreInstanceState(savedInstanceState: Bundle?)`: 如果已经使用`onSaveInstanceState(outState:
    Bundle?)`保存了状态，那么在`onStart()`之后，系统会调用此方法，您可以在其中检索`Bundle`状态，而不是使用`onCreate(savedInstanceState:
    Bundle?)`恢复状态。'
- en: '`override fun onResume()`: This callback is run as the final stage of creating
    an Activity for the first time, and also when the app has been backgrounded and
    then is brought into the foreground. Upon the completion of this callback, the
    screen/activity is ready to be used, receive user events, and be responsive.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`override fun onResume()`: 这个回调是在第一次创建Activity的最后阶段运行的，也是当应用从后台被带到前台时。完成此回调后，屏幕/活动就准备好被使用，接收用户事件，并做出响应。'
- en: '`override fun onSaveInstanceState(outState: Bundle?)`: If you want to save
    the state of the activity, this function can do so. You add key-value pairs using
    one of the convenience functions depending on the data type. The data will then
    be available if your Activity is recreated in `onCreate(saveInstanceState: Bundle?)`
    and `onRestoreInstanceState(savedInstanceState: Bundle?)`.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`override fun onSaveInstanceState(outState: Bundle?)`: 如果你想保存Activity的状态，这个函数可以做到。你可以使用一个方便的函数来添加键值对，具体取决于数据类型。如果Activity在`onCreate(saveInstanceState:
    Bundle?)`和`onRestoreInstanceState(savedInstanceState: Bundle?)`中被重新创建，数据将可用。'
- en: '`override fun onPause()`: This function is called when the Activity starts
    to be backgrounded or another dialog or Activity comes into the foreground.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`override fun onPause()`: 当Activity开始变为后台或者另一个对话框或Activity进入前台时，会调用此函数。'
- en: '`override fun onStop()`: This function is called when the Activity is hidden,
    either because it is being backgrounded or another Activity is being launched
    on top of it.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`override fun onStop()`: 当Activity被隐藏时，无论是由于它正在变为后台还是另一个Activity在它之上启动，都会调用此函数。'
- en: '`override fun onDestroy()`: This is called by the system to kill the Activity
    when system resources are low, when `finish()` is called explicitly on the Activity,
    or, more commonly, when the Activity is killed by the user closing the app from
    the recents/overview button.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`override fun onDestroy()`: 当系统资源低时，系统会调用此方法来结束Activity，当Activity被显式调用`finish()`方法，或者更常见的是，当用户通过关闭应用从最近/概览按钮关闭应用时，Activity会被杀死。'
- en: 'The flow of callbacks/events is illustrated in the following diagram:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 回调/事件的流程在以下图中展示：
- en: '![Figure 2.1 – Activity lifecycle](img/B19411_02_01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – Activity生命周期](img/B19411_02_01.jpg)'
- en: Figure 2.1 – Activity lifecycle
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – Activity生命周期
- en: Now that you understand what these common lifecycle callbacks do, let’s implement
    them to see when they are called.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了这些常见的生命周期回调的作用，让我们实现它们来看看它们何时被调用。
- en: Exercise 2.01 – logging the Activity Callbacks
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.01 – 记录Activity回调
- en: 'Create an application called `Activity Callbacks` with an empty Activity. The
    aim of this exercise is to log the Activity callbacks and the order that they
    occur for common operations:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`Activity Callbacks`的应用程序，其中包含一个空的Activity。这个练习的目的是记录Activity回调以及它们发生的顺序：
- en: In order to verify the order of the callbacks, let’s add a log statement at
    the end of each callback. Open up `MainActivity` and prepare the Activity for
    logging by adding `import android.util.Log` to the `import` statements. Then,
    add a constant to the class to identify your Activity. Constants in Kotlin are
    identified by the `const` keyword and can be declared at the top level (outside
    the class) or in an object within the class.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了验证回调的顺序，让我们在每个回调的末尾添加一个日志语句。打开`MainActivity`，通过添加`import android.util.Log`到`import`语句中来准备Activity的日志记录。然后，在类中添加一个常量来标识你的Activity。Kotlin中的常量通过`const`关键字标识，可以在类的顶部级别（类外）或类内的对象中声明。
- en: 'Top-level constants are generally used if they are required to be public. For
    private constants, Kotlin provides a convenient way to add static functionality
    to classes by declaring a companion object. Add the following at the bottom of
    the class below `onCreate(savedInstanceState: Bundle?)`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '如果需要将常量设置为公开的，通常使用顶级常量。对于私有常量，Kotlin提供了一种方便的方法，通过声明一个伴生对象来为类添加静态功能。在`onCreate(savedInstanceState:
    Bundle?)`下方添加以下内容：'
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, add a log statement at the end of `onCreate(savedInstanceState: Bundle?)`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '然后，在`onCreate(savedInstanceState: Bundle?)`的末尾添加一个日志语句：'
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Our Activity should now have the following code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的活动现在应该有以下的代码：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`d` in the preceding log statement refers to *debug*. There are six different
    log levels that can be used to output message information from the least to most
    important – `v` for *verbose*, `d` for *debug*, `i` for *info*, `w` for *warn*,
    `e` for *error*, and `wtf` for *what a terrible failure* (this last log level
    highlights an exception that should never occur):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的日志语句中的`d`代表*调试*。有六个不同的日志级别可以用来输出从最不重要到最重要的消息信息 – `v`代表*详细*，`d`代表*调试*，`i`代表*信息*，`w`代表*警告*，`e`代表*错误*，`wtf`代表*多么糟糕的失败*（这个最后的日志级别强调了不应该发生的异常）：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, let’s see how the logs are displayed in Android Studio. Open the **Logcat**
    window. It can be accessed by clicking on the **Logcat** tab at the bottom of
    the screen and also from the toolbar by going to **View** | **Tool Windows** |
    **Logcat**.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看在Android Studio中日志是如何显示的。打开**Logcat**窗口。可以通过点击屏幕底部的**Logcat**标签或通过工具栏中的**视图**
    | **工具窗口** | **Logcat**来访问。
- en: Run the app on the virtual device and examine the **Logcat** window output.
    You should see the log statement you have added formatted like the following line
    in *Figure 2**.2*. If the **Logcat** window looks different, you might have to
    enable the newest version of **Logcat** by going to **Android Studio** | **Settings**
    | **Experimental** and checking the box that says **Enable New Logcat** **Tool
    Window**.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在虚拟设备上运行应用并检查 **Logcat** 窗口的输出。你应该看到像 *图 2**.2* 中的以下行格式化的日志语句。如果 **Logcat**
    窗口看起来不同，你可能需要通过转到 **Android Studio** | **设置** | **实验性** 并勾选说 **启用新 Logcat** **工具窗口**
    的复选框来启用 **Logcat** 的新版本。
- en: '![Figure 2.2 – Log output in Logcat](img/B19411_02_02.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – Logcat 中的日志输出](img/B19411_02_02.jpg)'
- en: Figure 2.2 – Log output in Logcat
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – Logcat 中的日志输出
- en: 'Log statements can be quite difficult to interpret at first glance, so let’s
    break down the following statement into its separate parts:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 日志语句一开始可能很难理解，所以让我们将以下语句分解为其独立的各个部分：
- en: '[PRE4]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let’s examine the elements of the log statement in detail:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细检查日志语句的元素：
- en: '| **Fields** | **Values** |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| **字段** | **值** |'
- en: '| **Date** | `2023-01-14` |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| **日期** | `2023-01-14` |'
- en: '| **Time** | `16:47:12.330` |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| **时间** | `16:47:12.330` |'
- en: '| **Process identifier and thread identifier (your app process ID and current**
    **thread ID)** | `26715-26715` |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| **进程标识符和线程标识符（你的应用进程 ID 和当前线程 ID）** | `26715-26715` |'
- en: '| **Class name** | `MainActivity` |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| **类名** | `MainActivity` |'
- en: '| **Package name** | `com.example.activitycallbacks` |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| **包名** | `com.example.activitycallbacks` |'
- en: '| **Log level** | `D (``for Debug)` |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| **日志级别** | `D (用于调试)` |'
- en: '| **Log message** | `onCreate` |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| **日志消息** | `onCreate` |'
- en: Figure 2.3 – Table explaining a log statement
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 解释日志语句的表格
- en: By default, in the log filter (the text box above the log window), it says `package:mine`,
    which is your app logs. You can examine the output of the different log levels
    of all the processes on the device by changing the log filter from `level:debug`
    to other options in the drop-down menu. If you select `level:verbose`, as the
    name implies, you will see a lot of output.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，在日志过滤器（日志窗口上方的文本框中），显示 `package:mine`，这是你的应用日志。你可以通过更改日志过滤器从 `level:debug`
    到下拉菜单中的其他选项来检查设备上所有进程的不同日志级别的输出。如果你选择 `level:verbose`，正如其名所示，你会看到大量的输出。
- en: '5. What’s great about the `tag` option of the log statement is that it enables
    you to filter the log statements that are reported in the `tag` followed by the
    text of the tag, `tag:MainActivity`, as shown in *Figure 2**.4*:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 日志语句的 `tag` 选项很棒的地方在于，它允许你过滤出在 `tag` 后跟的文本标签中报告的日志语句，如 *图 2**.4* 所示：
- en: '![Figure 2.4 – Filtering log statements by the tag name](img/B19411_02_03.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.4 – 通过标签名过滤日志语句](img/B19411_02_03.jpg)'
- en: Figure 2.4 – Filtering log statements by the tag name
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – 通过标签名过滤日志语句
- en: So, if you are debugging an issue in your Activity, you can type in the tag
    name and add logs to your Activity to see the sequence of log statements. This
    is what you are going to do next by implementing the principal Activity callbacks
    and adding a log statement to each one to see when they are run.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你正在调试 Activity 中的问题，你可以输入标签名并在你的 Activity 中添加日志以查看日志语句的顺序。这就是你接下来将要通过实现主要
    Activity 回调并在每个回调中添加日志语句来查看它们何时运行要做的。
- en: '6. Place your cursor on a new line after the closing brace of the `onCreate(savedInstanceState:
    Bundle?)` function and then add the `onRestart()` callback with a log statement.
    Make sure you call through to `super.onRestart()` so that the existing functionality
    of the Activity callback works as expected:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '6. 在 `onCreate(savedInstanceState: Bundle?)` 函数的闭合花括号后的一行放置你的光标，然后添加带有日志语句的
    `onRestart()` 回调。确保调用 `super.onRestart()` 以确保 Activity 回调的现有功能按预期工作：'
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In Android Studio, you can start typing the name of a function and autocomplete
    options will pop up with suggestions for functions to override. Alternatively,
    if you go to the top menu and then **Code** | **Generate** | **Override methods**,
    you can select the methods to override.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中，你可以开始输入函数的名称，并会弹出自动完成选项，提供要覆盖的函数的建议。或者，如果你转到顶部菜单，然后选择 **代码**
    | **生成** | **覆盖方法**，你可以选择要覆盖的方法。
- en: 'Do this for all of the following callback functions:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对以下所有回调函数都这样做：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '7. The completed activity will now override the callbacks with your implementation,
    which adds a log message. The following truncated code snippet shows a log statement
    in `onCreate(savedInstanceState: Bundle?)`. The complete class is available at
    [https://packt.link/Lj2GT](https://packt.link/Lj2GT):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '7. 完成后的活动将用你的实现覆盖回调，并添加日志消息。以下截断的代码片段显示了`onCreate(savedInstanceState: Bundle?)`中的日志语句。完整的类可在[https://packt.link/Lj2GT](https://packt.link/Lj2GT)找到：'
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '8. Run the app, and then once it has loaded, as in *Figure 2**.5*, look at
    the **Logcat** output; you should see the following log statements (this is a
    shortened version):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 8. 运行应用，然后一旦加载，如*图2.5*所示，查看**Logcat**输出；你应该看到以下日志语句（这是一个简化的版本）：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The Activity has been created, started, and then prepared for the user to interact
    with:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 活动已经创建、启动，并准备让用户与之交互：
- en: '![Figure 2.5 – The app loaded and displaying MainActivity](img/B19411_02_04.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5 – 应用已加载并显示MainActivity](img/B19411_02_04.jpg)'
- en: Figure 2.5 – The app loaded and displaying MainActivity
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 – 应用已加载并显示MainActivity
- en: '9. Press the round home button in the center of the navigation controls in
    the emulator window above the virtual device and background the app. Not all devices
    use the same three-button navigation of *back* (triangle icon), *home* (circle
    icon), and *recents/overview* (square icon). Gesture navigation can also be enabled
    so all these actions can be achieved by swiping and optionally holding. You should
    now see the following **Logcat** output:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟器窗口中虚拟设备上方的导航控制中心的圆形主页按钮上按下，并将应用置于后台。并非所有设备都使用相同的三个按钮导航，即*后退*（三角形图标）、*主页*（圆形图标）和*最近的应用/概览*（方形图标）。也可以启用手势导航，这样所有这些操作都可以通过滑动和可选地按住来实现。你现在应该能看到以下**Logcat**输出：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For apps that target versions below Android Pie (API 28), `onSaveInstanceState(outState:
    Bundle)` may also be called before `onPause()` or `onStop()`.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '对于针对Android Pie（API 28）以下版本的应用，`onSaveInstanceState(outState: Bundle)`也可能在`onPause()`或`onStop()`之前被调用。'
- en: '10. Now, bring the app back into the foreground by pressing the recents/overview
    square button in the emulator controls and selecting the app. You should now see
    the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 10. 现在，通过按下模拟器控制中的最近的应用/概览方形按钮并选择应用，将应用恢复到前台。你现在应该看到以下内容：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The Activity has been restarted. You might have noticed that the `onRestoreInstance`
    **State(savedInstanceState: Bundle)** function was not called. This is because
    the Activity was not destroyed and recreated.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '活动已经重新启动。你可能已经注意到`onRestoreInstanceState(savedInstanceState: Bundle)`函数没有被调用。这是因为活动没有被销毁和重新创建。'
- en: '11. Press the recents/overview square button again and then swipe the app image
    upward to kill the activity. This is the output:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 11. 再次按下最近的应用/概览方形按钮，然后向上滑动应用图像以结束活动。这是输出：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 12. Launch your app again and then rotate the phone. You might find that the
    phone does not rotate, and the display is sideways. If this happens, drag down
    the status bar at the very top of the virtual device, look for a button with a
    rectangular icon with arrows called **Auto-rotate**, and select it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 12. 再次启动你的应用，然后旋转手机。你可能发现手机没有旋转，显示是侧置的。如果发生这种情况，向下拖动虚拟设备顶部的状态栏，寻找一个带有矩形图标和箭头的按钮，称为**自动旋转**，并选择它。
- en: '![Figure 2.6 – Quick settings bar with Wi-Fi and Auto-rotate button selected](img/B19411_02_05.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图2.6 – 已选择Wi-Fi和自动旋转按钮的快速设置栏](img/B19411_02_05.jpg)'
- en: Figure 2.6 – Quick settings bar with Wi-Fi and Auto-rotate button selected
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 – 已选择Wi-Fi和自动旋转按钮的快速设置栏
- en: 'You should see the following callbacks:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下回调：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Please note that as stated in step 9, the order of the `onSaveInstanceState(outState:
    Bundle)` callback may vary.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，如第9步所述，`onSaveInstanceState(outState: Bundle)`回调的顺序可能不同。'
- en: Configuration changes, such as rotating the phone, by default recreate the activity.
    You can choose not to handle certain configuration changes in the app, which will
    then not recreate the activity.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 配置更改，如旋转手机，默认会重新创建活动。你可以选择不在应用中处理某些配置更改，这样活动就不会重新创建。
- en: '13. To not recreate the activity for rotation, add `android:configChanges=`
    **"orientation|screenSize|screenLayout"** to `MainActivity` in the `AndroidManifest.xml`
    file. Launch the app and then rotate the phone, and these are the only callbacks
    that you have added to `MainActivity` that you will see:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 13. 要在旋转时不重新创建活动，将`android:configChanges="orientation|screenSize|screenLayout"`添加到`AndroidManifest.xml`文件中的`MainActivity`。启动应用，然后旋转手机，你将看到的只有添加到`MainActivity`的这些回调：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `orientation` and `screenSize` values have the same function for different
    Android API levels for detecting screen orientation changes. The `screenLayout`
    value detects other layout changes that might occur on foldable phones.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`orientation` 和 `screenSize` 值在不同的 Android API 级别上检测屏幕方向变化的功能相同。`screenLayout`
    值检测可能在可折叠手机上发生的其他布局更改。'
- en: 'These are some of the config changes you can choose to handle yourself (another
    common one is `keyboardHidden` to react to changes in accessing the keyboard).
    The app will still be notified by the system of these changes through the following
    callback:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是你可以选择自己处理的一些配置更改（另一个常见的是 `keyboardHidden` 以响应键盘访问的变化）。应用将通过以下回调由系统通知这些更改：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you add this callback function to `MainActivity`, and you have added `android:`
    **configChanges="orientation|screenSize|screenLayout"** to `Main` **Activity**
    in the manifest, you will see it called on rotation.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这个回调函数添加到 `MainActivity`，并且你在清单文件中的 `Main` **Activity** 上添加了 `android:`
    **configChanges="orientation|screenSize|screenLayout"`，你将看到它在旋转时被调用。
- en: This approach of not restarting the activity is not recommended as the system
    will not apply alternative resources automatically. So, rotating a device from
    portrait to landscape won’t apply a suitable landscape layout.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这种不重新启动活动的方法不建议使用，因为系统不会自动应用替代资源。因此，从纵向旋转到横向不会应用合适的横向布局。
- en: In this exercise, you have learned about the principal Activity callbacks and
    how they run when a user carries out common operations with your app through the
    system’s interaction with `MainActivity`. In the next section, we will cover saving
    the state and restoring it, as well as see more examples of how the Activity lifecycle
    works.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你了解了主要的 Activity 回调以及当用户通过系统与 `MainActivity` 的交互执行常见操作时它们是如何运行的。在下一节中，我们将介绍保存状态和恢复状态，以及查看更多
    Activity 生命周期的工作示例。
- en: Saving and restoring the Activity state
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存和恢复 Activity 状态
- en: In this section, you’ll explore how your Activity saves and restores the state.
    As you’ve learned in the previous section, configuration changes, such as rotating
    the phone, cause the Activity to be recreated. This can also happen if the system
    has to kill your app in order to free up memory.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将探索你的 Activity 如何保存和恢复状态。正如你在上一节中学到的，配置更改，如旋转手机，会导致 Activity 被重新创建。这也可能发生在系统需要杀死你的应用以释放内存的情况下。
- en: In these scenarios, it is important to preserve the state of the Activity and
    then restore it. In the next two exercises, you’ll work through an example ensuring
    that the user’s data is restored when `TextView` is created and populated from
    a user’s data after filling in a form.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，保留 Activity 的状态然后恢复它非常重要。在接下来的两个练习中，你将通过一个示例来确保当 `TextView` 创建并从用户填写表单后的数据中填充时，用户的数据被恢复。
- en: Exercise 2.02 – saving and restoring the state in layouts
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2.02 – 在布局中保存和恢复状态
- en: 'In this exercise, firstly create an application called `Save and Restore` with
    an empty activity. The app you are going to create will have a simple form that
    offers a discount code for a user’s favorite restaurant if they enter some personal
    details (no actual information will be sent anywhere, so your data is safe):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，首先创建一个名为 `Save and Restore` 的应用程序，并包含一个空活动。你将要创建的应用程序将包含一个简单的表单，如果用户输入一些个人信息（实际上不会将任何信息发送到任何地方，所以你的数据是安全的），将提供用户的喜爱餐厅的折扣代码：
- en: 'Open up the `strings.xml` file (located in `app` | `src` | `main` | `res` |
    `values` | `strings.xml`) and add the following strings that you’ll need for your
    app:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `strings.xml` 文件（位于 `app` | `src` | `main` | `res` | `values` | `strings.xml`），并添加以下字符串，这些字符串是你应用所需的：
- en: '[PRE15]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In `R.layout.activity_main`, replace the contents with the following XML that
    creates a containing layout file and adds a `TextView` header with the text `Enter
    your name and email for a discount code at Your Favorite Restaurant!` This is
    done by adding the `android:text` attribute with the `@``string/header_text` value:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `R.layout.activity_main` 中，将内容替换为以下 XML，它创建一个包含布局文件并添加一个带有文本 `Enter your name
    and email for a discount code at Your Favorite Restaurant!` 的 `TextView` 标题。这是通过添加
    `android:text` 属性并使用 `@``string/header_text` 值来完成的：
- en: '[PRE16]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You will see here that `android:textSize` is specified in `sp` which stands
    for Scale-independent pixels. This unit type represents the same values as density-independent
    pixels, which define the size measurement according to the density of the device
    that your app is being run on, and also change the text size according to the
    user’s preference, defined in **Settings** | **Display** | **Font style** (this
    might be **Font size and style** or something similar, depending on the exact
    device you are using).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到这里 `android:textSize` 是以 `sp` 指定的，它代表无缩放像素。这种单位类型表示与密度无关像素相同的值，它根据运行应用程序的设备的密度定义大小测量，并根据用户在
    **设置** | **显示** | **字体样式**（这可能是 **字体大小和样式** 或类似的内容，具体取决于你使用的确切设备）中定义的首选项更改文本大小。
- en: Other attributes in the layout affect positioning. The most common ones are
    padding and margin. Padding is applied on the inside of Views and is the space
    between the text and the border. Margins are specified on the outside of Views
    and are the space from the outer edges of Views. For example, `android:padding`
    sets the padding for the View with the specified value on all sides. Alternatively,
    you can specify the padding for one of the four sides of a View with `android:paddingTop`,
    `android:paddingBottom`, `android:paddingStart`, and `android:paddingEnd`. This
    pattern also exists to specify margins, so `android:layout_margin` specifies the
    margin value for all four sides of a View, and `android:layout_marginTop`, `android:layout_marginBottom`,
    `android:layout_marginStart`, and `android:layout_marginEnd` allow setting the
    margin for individual sides.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 布局中的其他属性会影响定位。最常见的是填充和边距。填充应用于视图的内部，是文本和边框之间的空间。边距在视图的外部指定，是视图外边缘的空间。例如，`android:padding`
    使用指定的值在所有边上设置视图的填充。或者，你可以使用 `android:paddingTop`、`android:paddingBottom`、`android:paddingStart`
    和 `android:paddingEnd` 指定视图四边之一的填充。这种模式也存在于指定边距，因此 `android:layout_margin` 为视图的所有四边指定边距值，而
    `android:layout_marginTop`、`android:layout_marginBottom`、`android:layout_marginStart`
    和 `android:layout_marginEnd` 允许为单个边设置边距。
- en: 'In order to have consistency and uniformity throughout the app with these positioning
    values, you can define the margin and padding values as dimensions contained within
    a `dimens.xml` file so they can be used in multiple layouts. A dimension value
    of `<dimen name="grid_4">4dp</dimen>` can then be used as a View attribute like
    this: `android:paddingStart="@dimen/grid_4"`. To position the content within a
    View, you can specify `android:gravity`. The `center` value constrains the content
    both vertically and horizontally within the View.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在整个应用程序中使用这些定位值保持一致性和统一性，你可以将边距和填充值定义为包含在 `dimens.xml` 文件中的尺寸，这样它们就可以在多个布局中使用。例如，`<dimen
    name="grid_4">4dp</dimen>` 可以用作视图属性，如下所示：`android:paddingStart="@dimen/grid_4"`。为了在视图内定位内容，你可以指定
    `android:gravity`。`center` 值在视图内垂直和水平方向上约束内容。
- en: 'Next, add three `EditText` views below `header_text` for the user to add their
    first name, last name, and email:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在 `header_text` 下方添加三个 `EditText` 视图，供用户添加他们的名字、姓氏和电子邮件地址：
- en: '[PRE17]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `EditText` fields have an `inputType` attribute to specify the type of input
    that can be entered into the form field. Some values, such as `number` on `EditText`,
    restrict the input that can be entered into the field, and on selecting the field,
    suggest how the keyboard is displayed. Others, such as `android:inputType="textEmailAddress"`,
    will not enforce an `@` symbol being added to the form field, but will give a
    hint to the keyboard to display it.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`EditText` 字段有一个 `inputType` 属性来指定可以输入到表单字段的输入类型。一些值，例如 `EditText` 上的 `number`，会限制可以输入到字段中的输入，并在选择字段时建议如何显示键盘。其他值，如
    `android:inputType="textEmailAddress"`，不会强制在表单字段中添加 `@` 符号，但会向键盘提供提示以显示它。'
- en: 'Finally, add a button for the user to press to generate a discount code, a
    `TextView` to display the discount code, and a `TextView` for the confirmation
    message:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加一个按钮供用户按下以生成折扣代码，一个 `TextView` 用于显示折扣代码，以及一个 `TextView` 用于显示确认消息：
- en: '[PRE18]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There are also some attributes that you haven’t seen before. The `xmlns:tools="http://schemas.android.com/tools"`
    tools namespace, which was specified at the top of the XML layout file, enables
    certain features that can be used when creating your app to assist with configuration
    and design.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些你之前没有见过的属性。在 XML 布局文件顶部指定的 `xmlns:tools="http://schemas.android.com/tools"`
    工具命名空间，可以启用某些功能，这些功能可以在创建你的应用程序时用于辅助配置和设计。
- en: The attributes are removed when you build your app, so they don’t contribute
    to the overall size of the app. You are using the `tools:text` attribute to show
    the text that will typically be displayed in the form fields. This helps when
    you switch to the `Design` view from viewing the XML in the `Code` view in Android
    Studio as you can see an approximation of how your layout displays on a device.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当你构建应用时，这些属性会被移除，因此它们不会对应用的整体大小产生影响。你正在使用`tools:text`属性来显示通常会在表单字段中显示的文本。这有助于你在Android
    Studio中从查看`Code`视图中的XML切换到`Design`视图时，可以看到布局在设备上的近似显示效果。
- en: Run the app and you should see the output displayed in *Figure 2**.7*. The **GET
    DISCOUNT** button has not been enabled and so currently will not do anything.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用，你应该会看到*图2.7*中显示的输出。**GET DISCOUNT**按钮尚未启用，因此目前不会执行任何操作。
- en: '![Figure 2.7 – The Activity screen on the first launch](img/B19411_02_06.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图2.7 – 首次启动的活动屏幕](img/B19411_02_06.jpg)'
- en: Figure 2.7 – The Activity screen on the first launch
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 – 首次启动的活动屏幕
- en: 'Enter some text into each of the form fields:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个表单字段中输入一些文本：
- en: '![Figure 2.8 – The EditText fields filled in](img/B19411_02_07.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图2.8 – 填写好的EditText字段](img/B19411_02_07.jpg)'
- en: Figure 2.8 – The EditText fields filled in
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 – 填写好的EditText字段
- en: 'Now, use the second rotate button in the virtual device controls (![](img/B19411_02_08.png))
    to rotate the phone 90 degrees to the right:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用虚拟设备控制中的第二个旋转按钮(![](img/B19411_02_08.png))将手机向右旋转90度：
- en: '![Figure 2.9 – The virtual device turned to landscape orientation](img/B19411_02_09.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图2.9 – 虚拟设备切换到横屏方向](img/B19411_02_09.jpg)'
- en: Figure 2.9 – The virtual device turned to landscape orientation
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 – 虚拟设备切换到横屏方向
- en: Can you spot what has happened? The `EditText` fields, the Android framework
    will preserve the state of the fields if they have an ID set on them.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你能发现发生了什么吗？`EditText`字段，如果它们设置了ID，Android框架将保留字段的当前状态。
- en: 'Go back to the `activity_main.xml` layout file and add an ID to the `Last Name`
    `EditText` which appears below the `First` `Name` `EditText`:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到`activity_main.xml`布局文件，并为位于`First Name` `EditText`下方出现的`Last Name` `EditText`添加一个ID：
- en: '[PRE19]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When you run up the app again and rotate the device, it will preserve the value
    you have entered. You’ve now seen that you need to set an ID on the `EditText`
    fields to preserve the state. For the `EditText` fields, it’s common to retain
    the state on a configuration change when the user is entering details into a form
    so that it is the default behavior if the field has an ID.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当你再次运行应用并旋转设备时，它将保留你输入的值。你现在已经看到，你需要为`EditText`字段设置ID以保留状态。对于`EditText`字段，当用户在表单中输入详细信息时，在配置更改时保留状态是常见的，这样如果字段有ID，它就是默认行为。
- en: Obviously, you want to get the details of the `EditText` field once the user
    has entered some text, which is why you set an ID, but setting an ID for other
    field types, such as `TextView`, does not retain the state if you update them
    and you need to save the state yourself. Setting IDs for Views that enable scrolling,
    such as `RecyclerView`, is also important as it enables the scroll position to
    be maintained when the Activity is recreated.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你希望在用户输入一些文本后获取`EditText`字段的详细信息，这就是为什么你设置了ID，但为其他字段类型，如`TextView`设置ID，如果你更新它们并且需要自己保存状态，则不会保留状态。为允许滚动的视图设置ID，如`RecyclerView`，也很重要，因为它可以在Activity重新创建时保持滚动位置。
- en: Now, you have defined the layout for the screen, but you have not added any
    logic for creating and displaying the discount code. In the next exercise, we
    will work through this.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经定义了屏幕的布局，但你还没有添加创建和显示折扣代码的逻辑。在下一个练习中，我们将处理这个问题。
- en: The layout created in this exercise is available at [https://packt.link/ZJleK](https://packt.link/ZJleK).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习中创建的布局可在[https://packt.link/ZJleK](https://packt.link/ZJleK)找到。
- en: You can find the code for the entire exercise at [https://packt.link/Kh0kR](https://packt.link/Kh0kR).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/Kh0kR](https://packt.link/Kh0kR)找到整个练习的代码。
- en: Exercise 2.03 – saving and restoring the state with Callbacks
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.03 – 使用回调保存和恢复状态
- en: 'The aim of this exercise is to bring all the UI elements in the layout together
    to generate a discount code after the user has entered their data. In order to
    do this, you will have to add logic to the button to retrieve all the `EditText`
    fields and then display a confirmation to the user, as well as generate a discount
    code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的目的是在用户输入数据后，将布局中的所有 UI 元素组合起来生成折扣代码。为了做到这一点，您必须在按钮中添加逻辑以检索所有 `EditText`
    字段，并向用户显示确认信息，以及生成折扣代码：
- en: 'Open up `MainActivity.kt` and replace the contents with the following:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainActivity.kt` 并将其内容替换为以下内容：
- en: '[PRE20]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`get() = …` is a custom accessor for a property.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`get() = …` 是一个属性的定制访问器。'
- en: 'Upon clicking the discount button, you retrieve the values from the `first_name`
    and `last_name` fields, concatenate them with a space, and then use a string resource
    to format the discount code confirmation text. The string you reference in the
    `strings.xml` file is as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 点击折扣按钮后，您从 `first_name` 和 `last_name` 字段中检索值，将它们与空格连接，然后使用字符串资源格式化折扣代码确认文本。在
    `strings.xml` 文件中引用的字符串如下：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `%s` value specifies a string value to be replaced when the string resource
    is retrieved. This is done by passing in the full name when getting the string:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`%s` 值指定在检索字符串资源时要替换的字符串值。这是通过在获取字符串时传递全名来完成的：'
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The code is generated by using the `java.util` package. This creates a unique
    ID, and then the `take()` Kotlin function is used to get the first eight characters
    before setting these to uppercase. Finally, `discountCode` is set in the view,
    the keyboard is hidden, and all the form fields are set back to their initial
    values.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 代码是通过使用 `java.util` 包生成的。这创建了一个唯一的 ID，然后使用 `take()` Kotlin 函数获取前八个字符，在将它们设置为
    uppercase 之前。最后，在视图中设置 `discountCode`，隐藏键盘，并将所有表单字段重置为其初始值。
- en: 'Run the app and enter some text into the name and email fields, and then click
    on `GET DISCOUNT`:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用并在姓名和电子邮件字段中输入一些文本，然后点击 `GET DISCOUNT`：
- en: '![Figure 2.10 – Screen displayed after the user has generated a discount code](img/B19411_02_10.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.10 – 用户生成折扣代码后显示的屏幕](img/B19411_02_10.jpg)'
- en: Figure 2.10 – Screen displayed after the user has generated a discount code
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10 – 用户生成折扣代码后显示的屏幕
- en: The app behaves as expected, showing the confirmation.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序按预期运行，显示确认信息。
- en: 'Now, rotate the phone by pressing the second rotate button (![](img/B19411_02_081.png))
    in the emulator controls and observe the result:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过在模拟器控制中按第二个旋转按钮 (![](img/B19411_02_081.png)) 来旋转手机，并观察结果：
- en: '![Figure 2.11 – Discount code no longer displaying on the screen](img/B19411_02_11.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.11 – 折扣代码不再显示在屏幕上](img/B19411_02_11.jpg)'
- en: Figure 2.11 – Discount code no longer displaying on the screen
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.11 – 折扣代码不再显示在屏幕上
- en: Oh, no! The discount code has gone. The `TextView` fields do not retain the
    state, so you will have to save the state yourself.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，不！折扣代码不见了。`TextView` 字段不会保留状态，因此您必须自己保存状态。
- en: 'Go back into `MainActivity.kt` and add the following Activity callbacks:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 `MainActivity.kt` 并添加以下 Activity 回调：
- en: '[PRE23]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'These callbacks, as the names declare, enable you to save and restore the instance
    state. `on` **SaveInstanceState(outState: Bundle)** allows you to add key-value
    pairs from your Activity when it is being backgrounded or destroyed, which you
    can retrieve in either `onCreate(savedInstanceState: Bundle?)` or `onRestoreInstanceState`
    **(**`savedInstanceState: Bundle)`.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '这些回调，正如其名称所表明的，使您能够保存和恢复实例状态。`on` **SaveInstanceState(outState: Bundle)** 允许您在
    Activity 被置于后台或销毁时添加键值对，您可以在 `onCreate(savedInstanceState: Bundle?)` 或 `onRestoreInstanceState`
    **(**`savedInstanceState: Bundle)` 中检索这些键值对。'
- en: 'So, you have two callbacks to retrieve the state once it has been set. If you
    are doing a lot of initialization in `onCreate(savedInstanceState: Bundle)`, it
    might be better to use `onRestoreInstanceState(savedInstanceState: Bundle)` to
    retrieve this instance state when your Activity is being recreated. In this way,
    it’s clear which state is being recreated. However, you might prefer to use `onCreate(savedInstanceState:
    Bundle)` if there is minimal setup required.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '因此，您有两个回调来检索已设置的状态。如果您在 `onCreate(savedInstanceState: Bundle)` 中进行了大量的初始化，那么在
    Activity 被重新创建时使用 `onRestoreInstanceState(savedInstanceState: Bundle)` 来检索这个实例状态可能更好。这样，可以清楚地知道哪个状态正在被重新创建。然而，如果您需要的设置很少，您可能更喜欢使用
    `onCreate(savedInstanceState: Bundle)`。'
- en: 'Whichever of the two callbacks you decide to use, you will have to get the
    state you set in the `onSaveInstanceState(outState: Bundle)` call. For the next
    step in the exercise, you will use `onRestoreInstanceState(savedInstanceState:
    Bundle)`.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '无论你决定使用哪一个回调，你都将不得不获取在`onSaveInstanceState(outState: Bundle)`调用中设置的状态。对于练习的下一步，你将使用`onRestoreInstanceState(savedInstanceState:
    Bundle)`。'
- en: 'Add two constants to the `MainActivity` companion object, which is at the bottom
    of `MainActivity`:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainActivity`的伴生对象中添加两个常量，该对象位于`MainActivity`的底部：
- en: '[PRE24]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, add these constants as keys for the values you want to save and retrieve
    and make the following changes to the Activity in the `onSaveInstanceState(outState:
    Bundle)` and `onRestoreInstanceState(savedInstanceState:` `Bundle)` functions.'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在，将这些常量作为要保存和检索的值的键，并在`onSaveInstanceState(outState: Bundle)`和`onRestoreInstanceState(savedInstanceState:
    Bundle)`函数中对Activity进行以下更改。'
- en: '[PRE25]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Run the app, enter the values into the `EditText` fields, and then generate
    a discount code. Then, rotate the device and you will see that the discount code
    is restored in *Figure 2**.12*:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用，将值输入到`EditText`字段中，然后生成一个折扣码。然后旋转设备，你将看到折扣码在**图 2**.12*中恢复显示：
- en: '![Figure 2.12 – Discount code continues to be displayed on the screen](img/B19411_02_12.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![**图 2.12 – 折扣码继续在屏幕上显示**](img/B19411_02_12.jpg)'
- en: Figure 2.12 – Discount code continues to be displayed on the screen
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 2.12 – 折扣码继续在屏幕上显示**'
- en: 'In this exercise, you first saw how the state of the `EditText` fields is maintained
    on configuration changes. You also saved and restored the instance state using
    the Activity lifecycle `onSaveInstanceState(outState: Bundle)` and `onCreate(savedInstanceState:
    Bundle?)`/`onRestoreInstanceState(savedInstanceState: Bundle)` functions. These
    functions provide a way to save and restore simple data. The Android framework
    also provides `ViewModel`, an Android architecture component that is lifecycle-aware.
    The mechanisms of how to save and restore this state (with `ViewModel`) are managed
    by the framework, so you don’t have to explicitly manage it as you have done in
    the preceding example. You will learn how to use this component in [*Chapter 11*](B19411_11.xhtml#_idTextAnchor582),
    *Android* *Architecture Components*.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个练习中，你首先看到了在配置更改时如何维护`EditText`字段的状态。你还使用了活动生命周期函数`onSaveInstanceState(outState:
    Bundle)`和`onCreate(savedInstanceState: Bundle?)`/`onRestoreInstanceState(savedInstanceState:
    Bundle)`来保存和恢复实例状态。这些函数提供了一种保存和恢复简单数据的方式。Android框架还提供了`ViewModel`，这是一个生命周期感知的Android架构组件。如何保存和恢复此状态（使用`ViewModel`）的机制由框架管理，因此你不需要像前面示例中那样显式管理它。你将在[*第11章*](B19411_11.xhtml#_idTextAnchor582)，*Android*
    *架构组件*中学习如何使用此组件。'
- en: 'The complete code for this exercise can be found here: [https://packt.link/zsGW3](https://packt.link/zsGW3).'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的完整代码可以在以下链接找到：[https://packt.link/zsGW3](https://packt.link/zsGW3)。
- en: In the next section, you will add another Activity to an app and navigate between
    the activities.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将为应用添加另一个Activity并在活动之间进行导航。
- en: Activity interaction with Intents
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Activity与Intents的交互
- en: 'An intent in Android is a communication mechanism between components. Within
    your own app, a lot of the time, you will want another specific Activity to start
    when some action happens in the current activity. Specifying exactly which Activity
    will start is called an `AndroidManifest.xml` file from the previous exercise
    and you will see an example of two intent filters set within the `<intent-filter>`
    XML element of the `MainActivity`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Android中的intent是一种组件间的通信机制。在你的应用内部，很多时候，当当前活动发生某些操作时，你将希望启动另一个特定的Activity。指定确切哪个Activity将启动被称为从上一个练习中的`AndroidManifest.xml`文件，你将看到在`MainActivity`的`<intent-filter>`
    XML元素中设置了两个intent过滤器示例：
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The one specified with `<action android:name="android.intent.action.MAIN" />`
    means that this is the main entry point into the app. Depending on which category
    is set, it governs which Activity first starts when the app is started. The other
    intent filter that is specified is `<category android:name="android.intent.category.LAUNCHER"
    />`, which defines that the app should appear in the launcher. When combined,
    the two intent filters define that when the app is started from the launcher,
    `MainActivity` should be started. Removing the `<action android:name="android.intent.action.MAIN"
    />` intent filter results in the `"Error running ''app'': Default Activity not
    found"` message. As the app has not got a main entry point, it can’t be launched.
    If you remove `<category android:name="android.intent.category.LAUNCHER" />` then
    there is nowhere that it can be launched from.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '其中指定为 `<action android:name="android.intent.action.MAIN" />` 的意味着这是进入应用的主要入口点。根据设置的哪个类别，它控制当应用启动时哪个
    Activity 首先启动。另一个指定的 intent 过滤器是 `<category android:name="android.intent.category.LAUNCHER"
    />`，它定义了应用应该出现在启动器中。当结合使用时，这两个 intent 过滤器定义了当从启动器启动应用时，`MainActivity` 应该启动。移除
    `<action android:name="android.intent.action.MAIN" />` intent 过滤器会导致出现 `"Error
    running ''app'': Default Activity not found"` 信息。由于应用没有主入口点，因此无法启动。如果您移除 `<category
    android:name="android.intent.category.LAUNCHER" />`，则没有地方可以从中启动。'
- en: For the next exercise, you will see how intents work to navigate around your
    app.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，您将看到 intents 如何在您的应用中导航工作。
- en: Exercise 2.04 – an introduction to Intents
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2.04 – Intent 简介
- en: 'The goal of this exercise is to create a simple app that uses intents to display
    text to the user based on their input:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的目标是创建一个简单的应用，使用 intents 根据用户的输入向用户显示文本：
- en: Create a new project in Android Studio called `Intents Introduction` and select
    an empty Activity. Once you have set up the project, go to the toolbar and select
    `File` | `New` | `Activity` | `Empty` `Activity`. Call it `WelcomeActivity` and
    leave all the other defaults as they are. It will be added to the `AndroidManifest.xml`
    file, ready to use. The issue you have now that you’ve added `WelcomeActivity`
    is knowing how to do anything with it. `MainActivity` starts when you launch the
    app, but you need a way to launch `WelcomeActivity` and then, optionally, pass
    data to it, which is when you use intents.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建一个新的项目，命名为 `Intents Introduction` 并选择一个空 Activity。一旦设置好项目，转到工具栏并选择
    `File` | `New` | `Activity` | `Empty` `Activity`。将其命名为 `WelcomeActivity` 并保留所有其他默认设置。它将被添加到
    `AndroidManifest.xml` 文件中，以便使用。您现在添加了 `WelcomeActivity` 后遇到的问题是不知道如何使用它。`MainActivity`
    在您启动应用时启动，但您需要一种方法来启动 `WelcomeActivity`，并且可选地传递数据给它，这就是您使用 intent 的时候。
- en: In order to work through this example, add the following strings to the `strings.xml`
    file.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成此示例，请将以下字符串添加到 `strings.xml` 文件中。
- en: '[PRE27]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, change the `MainActivity` layout in `activity_main.xml` and replace the
    content with the following code to add an `EditText` and a `Button`:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在 `activity_main.xml` 中更改 `MainActivity` 布局，并用以下代码替换内容以添加一个 `EditText` 和一个
    `Button`：
- en: '[PRE28]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The app, when run, looks as in *Figure 2**.13*:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序运行时看起来如 *图 2.13* 所示：
- en: '![Figure 2.13 – The app display after adding the EditText full name field and
    SUBMIT button](img/B19411_02_13.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.13 – 添加了EditText全名字段和提交按钮后的应用显示](img/B19411_02_13.jpg)'
- en: Figure 2.13 – The app display after adding the EditText full name field and
    SUBMIT button
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.13 – 添加了EditText全名字段和提交按钮后的应用显示
- en: You now need to configure the button so that when it’s clicked, it retrieves
    the user’s full name from the `EditText` field and then sends it in an intent,
    which starts `WelcomeActivity`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在需要配置按钮，以便当它被点击时，从 `EditText` 字段中检索用户的全名，并将其通过 intent 发送，从而启动 `WelcomeActivity`。
- en: 'Update the `activity_welcome.xml` layout file to prepare to do this:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `activity_welcome.xml` 布局文件以准备进行此操作：
- en: '[PRE29]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You are adding a `TextView` field to display the full name of the user with
    a welcome message. The logic to create the full name and welcome message will
    be shown in the next step.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 您正在添加一个 `TextView` 字段来显示用户的全名，并带有欢迎信息。创建全名和欢迎信息的逻辑将在下一步展示。
- en: 'Now, open `MainActivity` and add a constant value above the class header and
    update the imports:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开 `MainActivity` 并在类头之上添加一个常量值并更新导入：
- en: '[PRE30]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You will use the constant to set the key to hold the full name of the user by
    setting it in the intent.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用该常量来设置在 intent 中保存用户全名的键。
- en: 'Then, add the following code to the bottom of `onCreate(savedInstanceState:
    Bundle?)`:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '然后，将以下代码添加到 `onCreate(savedInstanceState: Bundle?)` 的底部：'
- en: '[PRE31]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: There is logic to retrieve the value of the full name and verify that the user
    has filled this in; otherwise, a pop-up toast message will be shown if it’s blank.
    The main logic, however, takes the `fullName` value of the `EditText` field and
    creates an explicit intent to start `WelcomeActivity`, and then puts an `Extra`
    key with a value into the Intent. The last step is to use the intent to start
    `WelcomeActivity`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 有逻辑可以检索全名值并验证用户是否已填写此信息；如果没有填写，将显示一个弹出提示消息。然而，主要逻辑是获取 `EditText` 字段的 `fullName`
    值，创建一个显式意图以启动 `WelcomeActivity`，然后将一个 `Extra` 键及其值放入 Intent 中。最后一步是使用该意图启动 `WelcomeActivity`。
- en: 'Now, run the app, enter your name, and press **SUBMIT**, as shown in *Figure
    2**.14*:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行应用，输入你的名字，然后按 **提交**，如图 *图 2.14* 所示：
- en: '![Figure 2.14 – The default screen displayed when the intent extras data is
    not processed](img/B19411_02_14.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.14 – 当未处理意图额外数据时显示的默认屏幕](img/B19411_02_14.jpg)'
- en: Figure 2.14 – The default screen displayed when the intent extras data is not
    processed
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.14 – 当未处理意图额外数据时显示的默认屏幕
- en: Well, that’s not very impressive. You’ve added the logic to send the user’s
    name, but not to display it.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这并不太令人印象深刻。你已经添加了发送用户名的逻辑，但没有显示它。
- en: 'To enable this, please open `WelcomeActivity` and add the import `import android.widget.TextView`
    to the imports list and add the following to the bottom of `onCreate(savedInstanceState:
    Bundle?)`:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '要启用此功能，请打开 `WelcomeActivity` 并将导入 `import android.widget.TextView` 添加到导入列表中，并在
    `onCreate(savedInstanceState: Bundle?)` 的底部添加以下内容：'
- en: '[PRE32]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We check that the intent that started the Activity is not null and then retrieve
    the string value that was passed from the `MainActivity` intent by getting the
    string `FULL_NAME_KEY` extra key. We then format the `<string name="welcome_text">Hello
    %s, we hope you enjoy using the app!</string>` resource string by getting the
    string from the resources and passing in the `fullname` value retrieved from the
    intent. Finally, this is set as the text of `TextView`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查启动 Activity 的意图是否不为空，然后通过获取字符串 `FULL_NAME_KEY` 额外键从 `MainActivity` 意图中检索字符串值。然后，我们通过从资源中获取字符串并将从意图中检索到的
    `fullname` 值传递进去来格式化 `<string name="welcome_text">Hello %s, we hope you enjoy
    using the app!</string>` 资源字符串。最后，将此设置为 `TextView` 的文本。
- en: 'Run the app again, and a simple greeting will be displayed, as in *Figure 2**.15*:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行应用，将显示一个简单的问候语，如图 *图 2.15* 所示：
- en: '![Figure 2.15 – User welcome message displayed](img/B19411_02_15.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.15 – 用户欢迎信息显示](img/B19411_02_15.jpg)'
- en: Figure 2.15 – User welcome message displayed
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.15 – 用户欢迎信息显示
- en: This exercise, although very simple in terms of layouts and user interaction,
    allows the demonstration of some core principles of intents. You will use them
    to add navigation and create user flows from one section of your app to another.
    In the next section, you will see how you can use intents to launch an Activity
    and receive a result back from it.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个练习在布局和用户交互方面非常简单，但它允许展示意图的一些核心原则。你将使用它们来添加导航并从你的应用的一个部分创建到另一个部分的用户流程。在下一节中，你将看到如何使用意图启动
    Activity 并从其中获取结果。
- en: Exercise 2.05 – retrieving a result from an Activity
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2.05 – 从 Activity 中检索结果
- en: 'For some user flows, you will only launch an Activity for the sole purpose
    of retrieving a result back from it. This pattern is often used to ask permission
    to use a particular feature, popping up a dialog with a question about whether
    the user gives their permission to access contacts, the calendar, and so on, and
    then reporting the result of yes or no back to the calling Activity. In this exercise,
    you will ask the user to pick their favorite color of the rainbow, and then once
    that is chosen, display the result in the calling activity:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些用户流程，你将只为从 Activity 中获取结果而启动 Activity。这种模式通常用于请求使用特定功能，弹出对话框询问用户是否允许访问联系人、日历等，然后向调用
    Activity 报告是或否的结果。在这个练习中，你将要求用户选择彩虹的最喜欢的颜色，一旦选择，就在调用 Activity 中显示结果：
- en: 'Create a new project named `Activity Results` with an empty activity and add
    the following strings to the `strings.xml` file:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Activity Results` 的新项目，包含一个空 Activity，并将以下字符串添加到 `strings.xml` 文件中：
- en: '[PRE33]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add the following colors to `colors.xml`:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下颜色添加到 `colors.xml`：
- en: '[PRE34]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, you have to set up the Activity that will set the result you receive in
    `MainActivity`. Go to `RainbowColorPickerActivity`.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你必须设置将在 `MainActivity` 中设置结果的 Activity。转到 `RainbowColorPickerActivity`。
- en: 'Update the `activity_main.xml` layout file to display a header, a button, and
    then a hidden `android:visibility="gone"` View, which will be made visible and
    set with the user’s favorite color of the rainbow when the result is reported:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `activity_main.xml` 布局文件以显示标题、按钮，然后是一个隐藏的 `android:visibility="gone"` 视图，当结果报告时，该视图将被设置为用户彩虹色最喜欢的颜色：
- en: '[PRE35]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You’ll be using the `registerForActivityResult(ActivityResultContracts.StartActivityForResult())`
    function to get a result back from the Activity you launch. Add two constant keys
    for the values we want to use in the intent, as well as a default color constant
    above the class header in `MainActivity`, and update the imports so it is displayed
    as follows with the package name and imports:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将使用 `registerForActivityResult(ActivityResultContracts.StartActivityForResult())`
    函数从你启动的活动获取结果。为我们在 intent 中想要使用的值添加两个常量键，并在 `MainActivity` 的类标题上方添加一个默认颜色常量，并更新导入，使其显示如下，包括包名和导入：
- en: '[PRE36]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, create a property below the class header that is used to both launch
    the new activity and return a result from it:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在类标题下方创建一个属性，用于启动新活动并从中返回结果：
- en: '[PRE37]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Once the result is returned, you can proceed to query the intent data for the
    values you are expecting. For this exercise, we want to get the background color
    name (`colorName`) and the hexadecimal value of the color (`backgroundColor`)
    so that we can display it. The `?` operator checks whether the value is null (that
    is, not set in the intent), and if so, the Elvis operator (`?:`) sets the default
    value. The color message uses string formatting to set a message, replacing the
    placeholder in the resource value with the color name. Now that you’ve got the
    colors, you can make the `rainbow_color` `TextView` field visible and set the
    background color of the View to `backgroundColor` and add text displaying the
    name of the user’s favorite color of the rainbow.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦返回结果，你可以继续查询期望的 intent 数据。对于这个练习，我们想要获取背景颜色名称（`colorName`）和颜色的十六进制值（`backgroundColor`），以便我们可以显示它。`?`
    操作符检查值是否为 null（即在 intent 中未设置），如果是，则 Elvis 操作符（`?:`）设置默认值。颜色消息使用字符串格式化来设置消息，将资源值中的占位符替换为颜色名称。现在你已经得到了颜色，你可以使
    `rainbow_color` `TextView` 字段可见，并将视图的背景颜色设置为 `backgroundColor`，并添加显示用户彩虹色最喜欢的颜色名称的文本。
- en: 'First, add the logic to launch the Activity from the property defined previously
    by adding the following to the bottom of `onCreate(savedInstanceState: Bundle?)`::'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '首先，将启动 Activity 的逻辑添加到之前定义的属性中，方法是在 `onCreate(savedInstanceState: Bundle?)`
    的底部添加以下代码：'
- en: '[PRE38]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This creates an Intent that is launched for its result: `Intent(this`, `RainbowColor``PickerActivity::class.java)`.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个用于返回结果的 Intent：`Intent(this, RainbowColorPickerActivity::class.java)`。
- en: 'For the layout of the `RainbowColorPickerActivity` activity, you are going
    to display a button with a background color and color name for each of the seven
    colors of the rainbow: `RED`, `ORANGE`, `YELLOW`, `GREEN`, `BLUE`, `INDIGO`, and
    `VIOLET`. These will be displayed in a `LinearLayout` vertical list. For most
    of the layout files in the book, you will be using `ConstraintLayout`, as it provides
    fine-grained positioning of individual Views. For situations where you need to
    display a vertical or horizontal list of a small number of items, `LinearLayout`
    is also a good choice. If you need to display a large number of items, then `RecyclerView`
    is a better option as it can cache layouts for individual rows and recycle views
    that are no longer displayed on the screen. You will learn about `RecyclerView`
    in [*Chapter* *6*](B19411_06.xhtml#_idTextAnchor353), *RecyclerView*.'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 `RainbowColorPickerActivity` 活动的布局，你将显示一个带有背景颜色和颜色名称的按钮，每个彩虹的七种颜色：`RED`、`ORANGE`、`YELLOW`、`GREEN`、`BLUE`、`INDIGO`
    和 `VIOLET`。这些将在一个 `LinearLayout` 垂直列表中显示。对于本书中的大多数布局文件，你将使用 `ConstraintLayout`，因为它提供了对单个视图的精细定位。对于需要显示少量垂直或水平列表的情况，`LinearLayout`
    也是一个不错的选择。如果你需要显示大量项目，那么 `RecyclerView` 是更好的选择，因为它可以缓存单个行的布局并回收屏幕上不再显示的视图。你将在
    [*第 6 章*](B19411_06.xhtml#_idTextAnchor353)，*RecyclerView* 中了解 `RecyclerView`。
- en: The first thing you need to do in `RainbowColorPickerActivity` is create the
    layout. This will be where you present the user with the option to choose their
    favorite color of the rainbow.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `RainbowColorPickerActivity` 中，你需要做的第一件事是创建布局。这将是你向用户展示选择他们彩虹色最喜欢的颜色的选项的地方。
- en: 'Open `activity_rainbow_color_picker.xml` and replace the layout, inserting
    the following:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `activity_rainbow_color_picker.xml` 并替换布局，插入以下内容：
- en: '[PRE39]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We are adding `ScrollView` to allow the contents to scroll if the screen height
    cannot display all of the items. `ScrollView` can only take one child View, which
    is the layout to scroll.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加`ScrollView`以允许内容在屏幕高度无法显示所有项目时滚动。`ScrollView`只能接受一个子视图，即要滚动的布局。
- en: 'Next, add `LinearLayout` within `ScrollView` to display the contained views
    in the order that they are added with a header and a footer. The first child View
    is a header with the title of the page and the last View that is added is a footer
    with instructions for the user to pick their favorite color:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`ScrollView`内添加`LinearLayout`以按添加顺序显示包含的视图，包括页眉和页脚。第一个子视图是一个带有页面标题的页眉，最后添加的视图是一个带有用户选择颜色说明的页脚：
- en: '[PRE40]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The layout should now look as in *Figure 2**.16* in the app:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 布局现在应该看起来与应用中的*图2.16*一样：
- en: '![Figure 2.16 – Rainbow colors screen with a header and footer](img/B19411_02_16.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图2.16 – 带有页眉和页脚的彩虹颜色屏幕](img/B19411_02_16.jpg)'
- en: Figure 2.16 – Rainbow colors screen with a header and footer
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.16 – 带有页眉和页脚的彩虹颜色屏幕
- en: 'Now, finally, add the button views between the header and the footer to select
    a color of the rainbow, and then run the app (the following code only displays
    the first button ). The full layout is available at [https://packt.link/ZgdHX](https://packt.link/ZgdHX):'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，最后，在页眉和页脚之间添加按钮视图以选择彩虹颜色，然后运行应用（以下代码仅显示第一个按钮）。完整的布局可在[https://packt.link/ZgdHX](https://packt.link/ZgdHX)找到：
- en: '[PRE41]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: These buttons are displayed in the order of the colors of the rainbow with the
    color text and background. The XML `id` attribute is what you will use in the
    Activity to prepare the result of what is returned to the calling activity.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这些按钮按照彩虹的颜色顺序显示，带有颜色文本和背景。XML中的`id`属性是你在Activity中准备返回给调用Activity的结果。
- en: 'Now, open `RainbowColorPickerActivity` and replace the content with the following:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`RainbowColorPickerActivity`并将内容替换为以下内容：
- en: '[PRE42]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `setRainbowColor` function creates an intent and adds the rainbow color
    name and the rainbow color `hex` value as String extras. The result is then returned
    to the calling Activity, and as you have no further use for this Activity, you
    call `finish()` so that the calling Activity is displayed. The way that you retrieve
    the rainbow color that the user has chosen is by adding a listener for all the
    buttons in the layout.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`setRainbowColor`函数创建一个意图，并将彩虹颜色名称和彩虹颜色的`hex`值作为字符串附加信息添加。然后结果返回给调用Activity，由于你不再使用此Activity，你调用`finish()`以便显示调用Activity。检索用户选择的彩虹颜色的方式是在布局中的所有按钮上添加监听器。'
- en: 'Now, add the following to the bottom of `onCreate(savedInstanceState: Bundle?)`:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在，将以下内容添加到`onCreate(savedInstanceState: Bundle?)`的底部：'
- en: '[PRE43]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `colorPickerClickListener` added in the preceding code determines which
    colors to set for the `setRainbowColor(colorName: String, color: Int)` function
    by using a `when` statement. The `when` statement is the equivalent of the `switch`
    statement in Java and languages based on C. It allows multiple conditions to be
    satisfied with one branch and is more concise. In the preceding example, `view.id`
    is matched against the IDs of the rainbow layout buttons and, when found, executes
    the branch, setting the color name and hex value from the string resources to
    pass into `setRainbowColor(colorName: String,` `color: Int)`.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的代码中添加的`colorPickerClickListener`通过使用`when`语句确定`setRainbowColor(colorName:
    String, color: Int)`函数要设置的颜色。`when`语句相当于Java和基于C的语言中的`switch`语句。它允许一个分支满足多个条件，并且更简洁。在前面的示例中，`view.id`与彩虹布局按钮的ID匹配，当找到时，执行分支，从字符串资源设置颜色名称和十六进制值以传递给`setRainbowColor(colorName:
    String, color: Int)`。'
- en: 'Now, add this click listener to the buttons from the layout below the preceding
    code:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将此点击监听器添加到前面的代码下面的布局中的按钮：
- en: '[PRE44]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Every button has a `ClickListener` interface attached, and as the operation
    is the same, they have the same `ClickListener` interface attached. Then, when
    the button is pressed, it sets the result of the color that the user has chosen
    and returns it to the calling activity.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 每个按钮都附加了一个`ClickListener`接口，由于操作相同，它们附加了相同的`ClickListener`接口。然后，当按钮被按下时，它设置用户选择的颜色结果并将其返回给调用Activity。
- en: 'Now, run the app and press the `CHOOSE COLOR` button, as shown in *Figure 2**.17*:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行应用并按下*图2.17*中显示的`选择颜色`按钮：
- en: "![Figure 2.17 – The rainbow colors app start s\uFEFFcreen](img/B19411_02_17.jpg)"
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图2.17 – 彩虹颜色应用启动屏幕](img/B19411_02_17.jpg)'
- en: Figure 2.17 – The rainbow colors app start screen
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.17 – 彩虹颜色应用启动屏幕
- en: 'Now, select your favorite color of the rainbow:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，选择您最喜欢的彩虹颜色：
- en: '![Figure 2.18 – The rainbow colors selection screen](img/B19411_02_18.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![图2.18 – 彩虹颜色选择屏幕](img/B19411_02_18.jpg)'
- en: Figure 2.18 – The rainbow colors selection screen
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.18 – 彩虹颜色选择屏幕
- en: 'Once you’ve chosen your favorite color, a screen with your favorite color will
    be displayed, as shown in *Figure 2**.19*:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您选择了您最喜欢的颜色，就会显示一个带有您最喜欢的颜色的屏幕，如图 *图2.19* 所示：
- en: '![Figure 2.19 – The app displaying the selected color](img/B19411_02_19.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图2.19 – 显示所选颜色的应用](img/B19411_02_19.jpg)'
- en: Figure 2.19 – The app displaying the selected color
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.19 – 显示所选颜色的应用
- en: As you can see, the app displays the color that you’ve selected as your favorite
    color in *Figure 2**.19*.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，应用在 *图2.19* 中显示了您选定的作为您最喜欢的颜色。
- en: This exercise introduced you to another way of creating user flows using `registerFor`
    **ActivityResult**. This can be very useful for carrying out a dedicated Task
    where you need a result before proceeding with the user’s flow through the app.
    Next, you will explore launch modes and how they impact the flow of user journeys
    when building apps.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习向您介绍了使用 `registerFor` **ActivityResult** 创建用户流程的另一种方法。这在执行需要在使用者通过应用流程之前获取结果的专用任务时非常有用。接下来，您将探索启动模式以及它们在构建应用时对用户旅程流程的影响。
- en: Intents, Tasks, and Launch Modes
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Intents、Tasks和启动模式
- en: Up until now, you have been using the standard behavior for creating Activities
    and moving from one Activity to the next. When you open the app from the launcher
    with the default behavior, it creates its own Task, and each Activity you create
    is added to a back stack, so when you open three Activities one after the other
    as part of your user’s journey, pressing the back button three times will move
    the user back through the previous screens/Activities and then go back to the
    device’s home screen, while still keeping the app open.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您一直在使用创建 Activity 和从一个 Activity 转移到下一个 Activity 的标准行为。当您以默认行为从启动器打开应用时，它会创建自己的
    Task，并且您创建的每个 Activity 都会被添加到一个回退栈中，因此当您作为用户旅程的一部分连续打开三个 Activity 时，按三次返回按钮会将用户带回到之前的屏幕/Activity，然后返回到设备的首页，同时仍然保持应用打开。
- en: The launch mode for this type of Activity is called `Standard`; it is the default
    and doesn’t need specifying in the Activity element of `AndroidManifest.xml`.
    Even if you launch the same Activity three times, one after the other, there will
    be three instances of the same activity that exhibit the behavior described previously.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的 Activity 的启动模式称为 `Standard`；它是默认的，不需要在 `AndroidManifest.xml` 的 Activity
    元素中指定。即使您连续三次启动相同的 Activity，也会有三个相同的行为实例。
- en: For some apps, you may want to change this behavior so the same instance is
    used. The launch mode that can help here is called `singleTop`. If a `singleTop`
    Activity isthe most recently added, when the same `singleTop` Activity is launched
    again, then instead of creating a new Activity, it uses the same Activity and
    runs the `onNewIntent` callback. In this callback, you receive an intent, and
    you can then process this intent as you have done previously in `onCreate`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些应用，您可能希望更改此行为，以便使用相同的实例。可以在这里帮助的启动模式称为 `singleTop`。如果一个 `singleTop` Activity
    是最近添加的，当再次启动相同的 `singleTop` Activity 时，则不会创建新的 Activity，而是使用相同的 Activity 并运行 `onNewIntent`
    回调。在这个回调中，您会收到一个意图，然后您可以像之前在 `onCreate` 中所做的那样处理这个意图。
- en: 'There are three other launch modes to be aware of called `singleTask`, `singleInstance`
    and `singleInstancePerTask`. These are not for general use and are only used for
    special scenarios. Detailed documentation of all launch modes can be viewed here:
    [https://developer.android.com/guide/topics/manifest/activity-element#lmode](https://developer.android.com/guide/topics/manifest/activity-element#lmode).'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种其他启动模式需要了解，称为 `singleTask`、`singleInstance` 和 `singleInstancePerTask`。这些不是通用用途，仅用于特殊场景。所有启动模式的详细文档可以在此查看：[https://developer.android.com/guide/topics/manifest/activity-element#lmode](https://developer.android.com/guide/topics/manifest/activity-element#lmode)。
- en: You’ll explore the differences in behavior of the `Standard` and `singleTop`
    launch modes in the next exercise.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，您将探索 `Standard` 和 `singleTop` 启动模式的行为差异。
- en: Exercise 2.06 – setting the Launch Mode of an Activity
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.06 – 设置Activity的启动模式
- en: 'This exercise has many different layout files and Activities to illustrate
    the two most commonly used launch modes. Please download the code from [https://packt.link/DQrGI](https://packt.link/DQrGI):'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习包含了许多不同的布局文件和活动，以说明两种最常用的启动模式。请从[https://packt.link/DQrGI](https://packt.link/DQrGI)下载代码：
- en: Open up the `activity_main.xml` file and examine it.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`activity_main.xml`文件并检查它。
- en: 'This illustrates a new concept when using layout files. If you have a layout
    file and you would like to include it in another layout, you can use the `<include>`
    XML element (have a look at the following snippet of the layout file):'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这在使用布局文件时说明了新概念。如果你有一个布局文件，并且想要将其包含在另一个布局中，你可以使用`<include>` XML元素（查看以下布局文件的片段）：
- en: '[PRE45]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The preceding layout uses the `include` XML element to include the two layout
    files: `letters.xml` and `numbers.xml`.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的布局使用`include` XML元素包含了两个布局文件：`letters.xml`和`numbers.xml`。
- en: Open up and inspect the `letters.xml` and `numbers.xml` files found in the `res`
    | `layout` folder. These are very similar and are only differentiated from the
    buttons they contain by the ID of the buttons themselves and the text label they
    display.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开并检查位于`res` | `layout`文件夹中的`letters.xml`和`numbers.xml`文件。这两个文件非常相似，它们之间的区别仅在于包含的按钮的ID以及显示的文本标签。
- en: 'Run the app and you will see the following screen:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用，你会看到以下屏幕：
- en: '![Figure 2.20 – App displaying both the standard and single top modes](img/B19411_02_20.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![图2.20 – 显示标准模式和单顶模式的App](img/B19411_02_20.jpg)'
- en: Figure 2.20 – App displaying both the standard and single top modes
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.20 – 显示标准模式和单顶模式的App
- en: In order to demonstrate/illustrate the difference between the `standard` and
    `singleTop` activity launch modes, you have to launch two or three activities
    one after the other.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示/说明`standard`和`singleTop`活动启动模式之间的区别，你必须依次启动两个或三个活动。
- en: 'Open up `MainActivity` and examine the contents of the code block (truncated)
    in `onCreate(savedInstanceState: Bundle?)`:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '打开`MainActivity`并检查`onCreate(savedInstanceState: Bundle?)`中的代码块内容（已截断）：'
- en: '[PRE46]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The logic contained in the main Activity and the other activities is basically
    the same. It displays an Activity and allows the user to press a button to launch
    another Activity using the same logic of creating a `ClickListener` and setting
    it on the button you saw in *Exercise 2.05*, *Retrieving a result from* *an Activity*.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 主活动和其他活动包含的逻辑基本上是相同的。它显示一个活动，并允许用户按下按钮以相同的逻辑启动另一个活动，即创建一个`ClickListener`并将其设置在你在*练习2.05*，*从*
    *活动* *获取结果*中看到的按钮上。
- en: 'Open the `AndroidManifest.xml` file and you will see the following activities
    displayed:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`AndroidManifest.xml`文件，你会看到以下活动显示：
- en: '[PRE47]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: You launch an Activity based on a button pressed on the main screen, but the
    letter and number activities have a different launch mode, which you can see specified
    in the `AndroidManifest.xml` file.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 你根据主屏幕上的按钮点击来启动一个活动，但字母和数字活动有不同的启动模式，这可以在`AndroidManifest.xml`文件中看到。
- en: The `standard` launch mode is specified here to illustrate the difference between
    `standard` and `singleTop`, but `standard` is the default and would be how the
    Activity is launched if the `android:launchMode` XML attribute was not present.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这里指定了`standard`启动模式，以说明`standard`和`singleTop`之间的区别，但`standard`是默认的，如果没有`android:launchMode`
    XML属性，活动将以这种方式启动。
- en: 'Press one of the letters under the `Standard` heading and you will see the
    following screen (with **A**, **B**, or **C**):'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`标准`标题下的任意字母，你会看到以下屏幕（带有**A**、**B**或**C**）：
- en: '![Figure 2.21 – The app displaying standard activity](img/B19411_02_21.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图2.21 – 显示标准活动的App](img/B19411_02_21.jpg)'
- en: Figure 2.21 – The app displaying standard activity
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.21 – 显示标准活动的App
- en: 'Keep on pressing any of the letter buttons, which will launch another Activity.
    Logs have been added to show this sequence of launching activities. Here is the
    log after pressing 10 letter Activities randomly:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 持续按下任意字母按钮，这将启动另一个活动。日志已添加以显示此启动活动的序列。以下是随机按下10个字母活动后的日志：
- en: '[PRE48]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If you observe the preceding log, every time the user presses a character button
    in launch mode, a new instance of the character Activity is launched and added
    to the back stack.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你观察前面的日志，每次用户在启动模式下按下字符按钮时，都会启动一个新的字符活动实例并将其添加到返回栈中。
- en: 'Close the app, making sure it is not backgrounded (or in the recents/overview
    menu) but is actually closed, and then open the app again and press one of the
    number buttons under the **Single** **Top** heading:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭应用，确保它不是后台运行（或在最近/概览菜单中），而是真正关闭，然后再次打开应用并按下 **Single** **Top** 标题下的一个数字按钮：
- en: '![Figure 2.22 – The app displaying the Single Top activity](img/B19411_02_22.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![图2.22 – 显示Single Top活动的应用](img/B19411_02_22.jpg)'
- en: Figure 2.22 – The app displaying the Single Top activity
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.22 – 显示Single Top活动的应用
- en: Press the number buttons 10 times, but make sure you press the same number button
    at least twice sequentially before pressing another number button.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下数字按钮10次，但确保在按下另一个数字按钮之前至少连续两次按下相同的数字按钮。
- en: 'The logs you should see in the **Logcat** window (**View** | **Tool Windows**
    | **Logcat**) should be similar to the following:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在 **Logcat** 窗口中看到的日志应该类似于以下内容：
- en: '[PRE49]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: You’ll notice that instead of calling `onCreate` when you pressed the same button
    again at least twice sequentially, the Activity is not created, but a call is
    made to `onNewIntent`. If you press the back button, you’ll notice that it will
    take you less than 10 clicks to back out of the app and return to the home screen,
    reflecting the fact that 10 activities have not been created.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，当你连续至少两次按下相同的按钮时，不会调用 `onCreate`，而是调用 `onNewIntent`。如果你按下返回按钮，你会注意到，你只需点击不到10次就能退出应用并返回主屏幕，这反映了实际上没有创建10个活动。
- en: Activity 2.01 – creating a login form
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动二.01 – 创建登录表单
- en: 'The aim of this activity is to create a login form with username and password
    fields. Once the values in these fields are submitted, check these entered values
    against the hardcoded values and display a welcome message if they match, or an
    error message if they don’t, and return the user to the login form. The steps
    needed to achieve this are the following:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的目的是创建一个带有用户名和密码字段的登录表单。一旦这些字段中的值被提交，将这些输入的值与硬编码的值进行比较，如果匹配，则显示欢迎消息，如果不匹配，则显示错误消息，并将用户返回到登录表单。实现这一目标所需的步骤如下：
- en: Create a form with username and password `EditText` Views and a `LOGIN` button.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含用户名和密码 `EditText` 视图以及 `LOGIN` 按钮的表单。
- en: Add a `ClickListener` interface to the button to react to a button press event.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `ClickListener` 接口添加到按钮上，以响应按钮点击事件。
- en: Validate that the form fields are filled in.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证表单字段是否已填写。
- en: Check the submitted username and password fields against the hardcoded values.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将提交的用户名和密码字段与硬编码的值进行比较。
- en: Display a welcome message with the username if successful and hide the form.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果成功，显示带有用户名的欢迎消息并隐藏表单。
- en: Display an error message if not successful and redirect the user back to the
    form.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果不成功，显示错误消息并将用户重定向回表单。
- en: 'There are a few possible ways that you could go about trying to complete this
    activity. Here are three ideas for approaches you could adopt:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试完成这个活动的一些方法。以下是你可以采用的三种方法的想法：
- en: Use a `singleTop` Activity and send an intent to route to the same Activity
    to validate the credentials
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `singleTop` 活动并发送一个意图路由到相同的活动以验证凭据
- en: Use a `standard` Activity to pass a username and password to another Activity
    and validate the credentials
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `standard` 活动将用户名和密码传递给另一个活动并验证凭据
- en: Use `registerForActivityResult` to carry out the validation in another Activity
    and then return the result
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `registerForActivityResult` 在另一个活动中执行验证，然后返回结果
- en: 'The completed app, upon its first loading, should look as in *Figure 2**.23*:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的应用在首次加载时应该看起来像 *图2.23*：
- en: '![Figure 2.23 – The app display when first loaded](img/B19411_02_23.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![图2.23 – 应用首次加载时的显示](img/B19411_02_23.jpg)'
- en: Figure 2.23 – The app display when first loaded
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.23 – 应用首次加载时的显示
- en: Note
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found at [https://packt.link/PmKJ6](https://packt.link/PmKJ6).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在 [https://packt.link/PmKJ6](https://packt.link/PmKJ6) 找到。
- en: Summary
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have covered a lot of the groundwork of how your application
    interacts with the Android framework, from the Activity lifecycle callbacks to
    retaining the state in your activities, navigating from one screen to another,
    and how intents and launch modes make this happen. These are core concepts that
    you need to understand in order to move on to more advanced topics.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经涵盖了您应用程序与Android框架交互的基础知识，从Activity生命周期回调到在活动中保留状态，从一屏幕导航到另一屏幕，以及意图和启动模式如何实现这一切。这些是您为了进入更高级主题所必须理解的核心概念。
- en: In the next chapter, you will be introduced to fragments and how they fit into
    the architecture of your application, as well as exploring more of the Android
    resources framework.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将了解到片段以及它们如何融入您应用程序的架构，同时还将探索更多关于Android资源框架的内容。
