- en: Chapter 2. Looking Good – Graphical Interface
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章. 看起来不错 – 图形界面
- en: '*In the previous chapter, we covered the features of Unity and Android. We
    also discussed the benefits of using them together. After we finished installing
    a bunch of software and setting up our devices, we created a simple Hello World
    application to confirm that everything was connected correctly.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*在前一章中，我们介绍了Unity和Android的功能。我们还讨论了将它们结合使用的优点。在安装了大量软件并设置好我们的设备后，我们创建了一个简单的Hello
    World应用程序来确认一切连接正确。*'
- en: '*This chapter is all about **Graphical User Interface** (**GUI**). We will
    start by creating a simple Tic-tac-toe game, using the basic pieces of GUI that
    Unity provides. Following that we will discuss Unity''s GUI Styles and GUI Skins.
    Using what we learned, we will improve the look of our game. Also, we will explore
    some tips and tricks for handling many different screen sizes of Android devices.
    Finally, we will learn about a much quicker way to put our games on the device,
    which was covered in the previous chapter. With all that said, let''s jump in.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章全部关于**图形用户界面**（**GUI**）。我们将从创建一个简单的井字棋游戏开始，使用Unity提供的GUI基本组件。之后，我们将讨论Unity的GUI样式和GUI皮肤。利用我们所学，我们将改善游戏的外观。此外，我们将探索处理不同屏幕尺寸的Android设备的技巧和窍门。最后，我们将了解一种更快地将游戏上传到设备的方法，这在上一章中已经介绍过。话虽如此，让我们开始吧。*'
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: User preferences
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户偏好
- en: Buttons and labels
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮和标签
- en: GUI Skins and GUI Styles
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GUI皮肤和GUI样式
- en: Dynamic GUI positioning
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态GUI定位
- en: Build and run
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和运行
- en: In this chapter, we will be creating a new project in Unity. The first section
    here will walk you through its creation and setup.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将在Unity中创建一个新的项目。本节将指导你完成其创建和设置。
- en: Creating a Tic-tac-toe game
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建井字棋游戏
- en: The project for this chapter is a simple Tic-tac-toe-style game, similar to
    what any of us might play on paper. As with anything else, there are several ways
    you could make this game. We are going to use Unity's GUI system, in order to
    better understand how to create a GUI for any of our other games.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的项目是一个简单的井字棋风格游戏，类似于我们中任何一个人可能在纸上玩的游戏。与其他任何事物一样，你可以用几种不同的方式制作这个游戏。我们将使用Unity的GUI系统，以便更好地了解如何为我们的其他游戏创建GUI。
- en: Time for action – creating Tic-tac-toe
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 创建井字棋
- en: 'The basic Tic-tac-toe game involves two players and a 3 x 3 grid. The players
    take turns filling X''s and O''s. The player who first fills a line of three squares
    with his/her letter wins the game. If all squares are filled without a player
    achieving a line of three, the game is a tie. Let''s perform the following steps
    to create our game:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的井字棋游戏涉及两名玩家和一个3 x 3的网格。玩家轮流填写X和O。首先填满一行三个方格的玩家获胜。如果所有方格都填满，但没有玩家填满一行三个，则游戏平局。让我们按照以下步骤创建我们的游戏：
- en: The first thing to do is to create a project for this chapter. So, start up
    Unity and we will do just that.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先要做的事情是为本章创建一个项目。因此，启动Unity，我们将这样做。
- en: 'If you have been following along so far, Unity should boot up into the last
    project that was open. This isn''t a bad feature, but it can become extremely
    annoying. Think of it like this: you have been working on a project for a while
    and it has grown large. Now you need to quickly open something else, but Unity
    defaults to your huge project. If you wait for it to open before you can work
    on anything else, it can consume a lot of time. To change this feature, go to
    the top of the Unity window and click on **Edit** followed by **Preferences**.
    This is the same place where we changed our script editor''s preferences. This
    time, though, we are going to change settings in the **General** tab. The following
    screenshot shows the options present under the **General** tab:![Time for action
    – creating Tic-tac-toe](img/2014OT_02_01.png.jpg)'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你一直跟随着，Unity应该会启动到最后一个打开的项目。这不是一个坏特性，但它可能会变得非常令人烦恼。想想看：你已经在一项项目中工作了一段时间，它已经变得很大。现在你需要快速打开其他东西，但Unity默认打开你的大型项目。如果你在开始工作之前等待它打开，可能会浪费很多时间。要更改此功能，请转到Unity窗口的顶部，点击**编辑**然后点击**首选项**。这是我们更改脚本编辑器首选项的地方。不过，这次我们将更改**常规**选项卡中的设置。以下截图显示了**常规**选项卡下的选项：![行动时间
    – 创建井字棋](img/2014OT_02_01.png.jpg)
- en: 'At this moment, the primary concern is the **Always Show Project Wizard** option;
    however, we will still cover all of the options in turn. All the options under
    the **General** tab are explained in detail as follows:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，主要关注的是**始终显示项目向导**选项；然而，我们仍将逐一介绍所有选项。以下是对**常规**选项卡下所有选项的详细解释：
- en: '**Auto Refresh**: This is one of the best features of Unity. As assets are
    changed outside of Unity, this option lets Unity automatically detect the change
    and refresh the asset inside your project.'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动刷新**：这是Unity的最好特性之一。当资产在Unity外部被更改时，此选项允许Unity自动检测更改并刷新项目中的资产。'
- en: '**Always Show Project Wizard**: This is a great first option to go check whenever
    installing Unity. Instead of opening the last project, Unity opens **Project Wizard**.
    From there, you can open any project of your choice or create a new one. This
    is always a good one to turn on.'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**始终显示项目向导**：这是安装Unity时每次都应检查的绝佳首选选项。Unity不会打开最后一个项目，而是打开**项目向导**。从那里，你可以打开任何你选择的项目或创建一个新的项目。这是一个始终开启的好选项。'
- en: '**Compress Assets on Import**: This is the checkbox for automatically compressing
    your game assets when they are first imported to Unity.'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导入时压缩资产**：这是一个复选框，用于在首次将游戏资产导入Unity时自动压缩它们。'
- en: '**Editor Analytics**: This is the checkbox for Unity''s anonymous usage statistics.
    Leave it checked and the Unity Editor sends info occasionally to the Unity source.
    It doesn''t hurt anything to leave it on, and helps the Unity team make the Unity
    Editor better. But it comes down to personal preference.'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编辑器分析**：这是Unity匿名使用统计信息的复选框。保持勾选状态，Unity编辑器会偶尔向Unity源发送信息。保持开启不会影响任何东西，并有助于Unity团队使Unity编辑器变得更好。但这最终还是取决于个人喜好。'
- en: '**Show Asset Store search hits**: This setting is only relevant if you are
    planning to use the Asset Store. The Asset Store can be a great source of assets
    and tools for any game; however, since we are not going to use it, the relevance
    to this book is rather limited. It does what the name suggests. When you search
    the Asset Store for something from within the Unity Editor, the number of results
    is displayed based on this checkbox.'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显示资产商店搜索结果**：此设置仅在计划使用资产商店时相关。资产商店可以为任何游戏提供资产和工具的绝佳来源；然而，由于我们不会使用它，此书的相关性相当有限。它做的是名字所暗示的事情。当你从Unity编辑器内部搜索资产商店中的内容时，结果的数量会根据此复选框显示。'
- en: '**Verify Saving Assets**: This is a good one to be left off. If this is on,
    every time you click on **Save** in Unity. A dialog box will pop up so that you
    can make sure you save any and all of the assets that have changed since your
    last save. It is not so much about your models and textures, but concerned with
    Unity''s internal files, the materials, and prefabs. Best to leave it off for
    now.'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验证保存资产**：这是一个很好的选项，可以不开启。如果开启此选项，每次你在Unity中点击**保存**时，都会弹出一个对话框，以便你可以确保保存自上次保存以来更改的任何资产。这不仅仅关乎你的模型和纹理，还涉及到Unity的内部文件、材质和预制体。目前最好将其关闭。'
- en: '**Skin (Pro Only)**: This option only applies to Unity''s pro users. It gives
    the option to switch between the light and dark versions of the Unity Editor.
    It is purely cosmetic, so go with your gut for this one.'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**皮肤（仅限专业版）**：此选项仅适用于Unity的专业用户。它提供了在Unity编辑器的浅色和深色版本之间切换的选项。这完全是外观上的，所以根据你的直觉来选择。'
- en: With your preferences set, now go up to **File** and follow it with selecting
    **Open Project**.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置好你的偏好后，现在转到**文件**菜单，然后选择**打开项目**。
- en: Select the **Create New Project** tab, followed by the **Browse...** button
    to pick a location and name for the new project.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**创建新项目**选项卡，然后点击**浏览...**按钮来选择新项目的位置和名称。
- en: We will not be using any of the included packages, so click on **Create** and
    we can get on with it.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将不会使用任何包含的包，因此点击**创建**，我们可以继续进行。
- en: Once Unity finishes initializing the new project, create two new scripts in
    the **Project** panel, just as we did for the *Hello World* project in the previous
    chapter. Name the new scripts as `TicTacToeControl` and `SquareState`. Open them
    and clear out the default functions; again, just as we did in [Chapter 1](ch01.html
    "Chapter 1. Saying Hello to Unity and Android"), *Saying Hello to Unity and Android*.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦Unity完成新项目的初始化，在**项目**面板中创建两个新的脚本，就像我们在上一章的*Hello World*项目中做的那样。将新脚本命名为`TicTacToeControl`和`SquareState`。打开它们并清除默认函数；再次，就像我们在[第1章](ch01.html
    "第1章。向Unity和Android问好")中做的那样，*向Unity和Android问好*。
- en: The `SquareState` script will hold the possible states of each square of our
    game board. To do that, clear everything out of the script and replace it with
    a simple enumeration. An enumeration is just a list of potential values. This
    one is concerned with the player who controls the square. Do X's control it, O's
    control it, or is it clear because the game board is traditionally clear by default.
    `Clear` becomes the first and therefore the default state.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SquareState` 脚本将保存我们游戏板每个方块的可能的州。为此，清空脚本中的所有内容，并用一个简单的枚举来替换。枚举只是潜在值的列表。这个枚举关注的是控制该方块的玩家。是
    X 控制它，O 控制它，还是因为它默认情况下是清晰的（游戏板传统上是默认清晰的）。`Clear` 成为第一个，因此是默认状态。'
- en: '[PRE0]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In our other script, `TicTacToeControl`, we start with two variables that will
    largely control the flow of the game. The first defines our game board. Traditionally
    the game is played on a 3 x 3 grid, therefore nine squares. The second line dictates
    whose turn it is. How it is going to change will be made clear in a little bit,
    but for now suffice it to say that if it is X's turn, the value will be true.
    If it is not X's turn, the value will be false.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的另一个脚本 `TicTacToeControl` 中，我们开始于两个将很大程度上控制游戏流程的变量。第一个定义了我们的游戏板。传统上游戏是在一个
    3x3 的网格上进行的，因此有九个方块。第二行指定了轮到谁。它将如何改变将在稍后变得清楚，但就现在而言，如果轮到 X，值将是 true。如果不是 X 的回合，值将是
    false。
- en: '[PRE1]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In Unity, every script by default inherits from the `MonoBehaviour` class. This
    gives our scripts two primary benefits.
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 Unity 中，每个脚本默认继承自 `MonoBehaviour` 类。这给我们的脚本带来了两个主要好处。
- en: First, it allows us to add our scripts to objects as components. The filename
    of the script also needs to be the exact same as the class name within the script,
    if you plan on adding the script to an object.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，它允许我们将脚本作为组件添加到对象中。如果计划将脚本添加到对象中，脚本文件的名称也需要与脚本内部的类名完全相同。
- en: The second benefit of the `MonoBehaviour` class is the variety of variables
    and functions that come with it. The variables give us access to all the parts
    that make up objects in Unity. The functions provide a number of automatic features
    and access to the game initialization and loop. This is what we are most interested
    in at this particular moment.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`MonoBehaviour` 类的第二个好处是它附带的各种变量和函数。变量让我们可以访问组成 Unity 中对象的各个部分。函数提供了一系列自动功能和访问游戏初始化和循环的能力。这正是我们在这个特定时刻最感兴趣的。'
- en: In order to draw anything in each GUI frame, one needs to utilize the `OnGUI`
    function provided by the `MonoBehaviour` class. That is where we will draw our
    game board. The `OnGUI` function lets us draw our interface every frame. Inside
    it, we will first define the width and height of our board squares.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在每一帧的 GUI 中绘制任何内容，需要利用 `MonoBehaviour` 类提供的 `OnGUI` 函数。这就是我们将绘制游戏板的地方。`OnGUI`
    函数让我们在每一帧绘制我们的界面。在它内部，我们首先定义我们板方块的宽度和高度。
- en: '[PRE2]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Following that is a pair of for-loops. Because our board is a 3 x 3 grid, we
    need the loops to count three rows of three squares.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是一对 for 循环。因为我们的板是一个 3x3 的网格，我们需要循环来计数三行三列的方块。
- en: '[PRE3]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Inside the loops we must first figure out which square we are currently drawing.
    It becomes hard to play a game, if you don't know which square was touched.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环内部，我们首先必须弄清楚我们目前正在绘制哪个方块。如果你不知道哪个方块被触摸，玩游戏会变得很困难。
- en: '[PRE4]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The next line of code defines whether the square is going to be drawn as a `Rect`
    class. A `Rect` class is defined in GUI space as x position, y position, width,
    and height. In Unity, GUI space is defined as the top-left corner being (0,0)
    and the bottom-right is `Screen.width`, `Screen.height`. The width and height
    of the screen are the number of pixels.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一行代码定义了方块是否将以 `Rect` 类的形式绘制。`Rect` 类在 GUI 空间中定义为 x 位置、y 位置、宽度和高度。在 Unity 中，GUI
    空间定义为左上角为 (0,0)，右下角为 `Screen.width`、`Screen.height`。屏幕的宽度和高度是像素数。
- en: '[PRE5]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We then figure out who controls the square. The following line of code is a
    little complicated, but it is really just a compressed `if` statement. Basically,
    it works like this: first check a condition and if it is true return the first
    value, whatever is between the question mark and the colon. If the condition is
    false, return the value after the colon. Two of these compressed `if` statements
    were combined here; if the square is owned by X, set our owner to X. Otherwise,
    if it is owned by O, set the owner to O. If neither of the conditions is true,
    nobody owns the square and we set our owner to an empty string.'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们确定谁控制着这个方块。以下代码行有点复杂，但它实际上只是一个压缩的`if`语句。基本上，它的工作方式是这样的：首先检查一个条件，如果它是真的，返回第一个值，即问号和冒号之间的值。如果条件是假的，返回冒号后面的值。这里结合了两个这样的压缩`if`语句；如果方块被X拥有，将我们的所有者设置为X。否则，如果它被O拥有，将所有者设置为O。如果两个条件都不成立，则没有人拥有这个方块，我们将所有者设置为空字符串。
- en: '[PRE6]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now that all the hard work of figuring out where we are is done, we actually
    draw our game board square. This is done through the use of a wonderful little
    function provided by Unity, `GUI.Button`. To use this function in its basic form,
    we must tell the function where the button should be drawn and what text to display,
    hence rect and string. We give it our square and owner variables, it does all
    the hard work of actually drawing on screen, and we are given back a Boolean result,
    whether or not the button was pressed. Therefore, we check it with an `if` statement
    and if true, we send to a new function which square was pressed, letting it handle
    setting the owner. Also, don't forget the extra curly braces to close up the loops
    and the function.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经完成了确定我们位置的所有艰苦工作，我们实际上绘制我们的游戏棋盘方块。这是通过使用Unity提供的一个奇妙的小函数`GUI.Button`来完成的。要使用这个函数的基本形式，我们必须告诉函数按钮应该绘制在哪里以及显示什么文本，因此是rect和string。我们给它我们的方块和所有者变量，它完成所有在屏幕上绘制的实际工作，并返回一个布尔结果，表示按钮是否被按下。因此，我们用`if`语句检查它，如果为真，我们发送到一个新函数，告诉它哪个方块被按下，让它处理设置所有者的操作。另外，别忘了额外的花括号来关闭循环和函数。
- en: '[PRE7]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `SetControl` function is pretty short; it simply sets the owner for whichever
    square is passed to it. It first makes sure that the index given is actually within
    the range for our board. If it is not, we'll exit the function early. The next
    line of code sets control of the board square based on whose turn it is. If it
    is X's turn, set the square to `XControl`; otherwise set control to `OControl`.
    Finally we change whose turn it is. This is done by simply setting our `xTurn`
    Boolean to the opposite of itself, indicating that it is the other person's turn.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SetControl`函数相当简短；它只是为传递给它的任何方块设置所有者。它首先确保给定的索引确实在我们棋盘的范围内。如果不是，我们将提前退出函数。下一行代码根据轮到谁来设置棋盘方块的控件。如果是X的回合，将方块设置为`XControl`；否则将控件设置为`OControl`。最后我们改变轮到谁。这是通过简单地设置我们的`xTurn`布尔值为其相反的值来完成的，表示现在是另一人的回合。'
- en: '[PRE8]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We are just about ready to play our game. We just need to set up the scene.
    To do this, start by dragging our `TicTacToeControl` script from the **Project**
    pane of the Unity Editor to the **Main Camera** object in the **Hierarchy** pane
    of the Unity Editor.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们差不多准备好玩游戏了。我们只需要设置场景。为此，首先将我们的`TicTacToeControl`脚本从Unity编辑器的**项目**面板拖动到**场景**面板中的**主摄像机**对象。
- en: Now save the scene, just as we did in [Chapter 1](ch01.html "Chapter 1. Saying
    Hello to Unity and Android"), *Saying Hello to Unity and Android*, as `TicTacToe`.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在保存场景，就像我们在[第1章](ch01.html "第1章。向Unity和Android问好")中做的那样，*向Unity和Android问好*，命名为`TicTacToe`。
- en: It is possible to play the game at this point. It is also possible to do so
    on a device; just follow the same steps as in [Chapter 1](ch01.html "Chapter 1. Saying
    Hello to Unity and Android"), *Saying Hello to Unity and Android*, but for now
    just perform testing in the Unity Editor. Later in this chapter we will cover
    a much easier way to build to our devices.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个阶段可以玩游戏。也可以在设备上玩游戏；只需遵循[第1章](ch01.html "第1章。向Unity和Android问好")中的相同步骤，*向Unity和Android问好*，但现在只需在Unity编辑器中进行测试。在本章的后面，我们将介绍一种更简单的方法来构建到我们的设备上。
- en: Tip
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以从你购买的所有Packt书籍的账户中下载示例代码文件。[http://www.packtpub.com](http://www.packtpub.com)。如果你在其他地方购买了这本书，你可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给你。
- en: '*What just happened?*'
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We created the very base of what we need to play Tic-tac-toe. We did this with
    two short and simple scripts. However, while playing the game now, you probably
    noticed a few things about it. For starters, it doesn't look particularly fantastic.
    That is extremely odd, considering it is the point of this chapter, but we will
    address that soon enough. Second, there are no checks to determine whether or
    not somebody already controls a square.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了玩井字棋所需的基础。我们用两个简短的脚本完成了这个任务。然而，现在你在玩游戏时，可能注意到了一些关于它的细节。首先，它看起来并不特别出色。考虑到这是本章的重点，这非常奇怪，但我们很快就会解决这个问题。其次，没有检查来确定是否有人已经控制了一个方格。
- en: Also, there are no checks to see if anybody won the game. Finally, if you decided
    to build to device, you might have noticed one of the great things about Unity's
    GUI functions. There is no special programming needed to make any of the GUI functions
    work with touch inputs rather than the mouse. A lot of time is saved when you
    don't have to worry about special inputs, especially if you plan on multiplatform
    targeting.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，没有检查来确定是否有人赢得了游戏。最后，如果你决定构建到设备，你可能已经注意到了Unity的GUI函数的一个优点。不需要特殊的编程就可以使任何GUI函数与触摸输入而不是鼠标一起工作。当你不必担心特殊输入时，可以节省很多时间，尤其是如果你计划多平台定位。
- en: Finishing the game
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成游戏
- en: If you didn't want to go through the process of building the application and
    putting it on your device, it is still possible for you to try out interacting
    with the buttons, and touching them with your fingers. In [Chapter 1](ch01.html
    "Chapter 1. Saying Hello to Unity and Android"), *Saying Hello to Unity and Android*,
    we installed the application, Unity Remote. Plug the device into your computer
    and start it up; when you click on **Play** in the Unity Editor, you should see
    the game running on your device. If you can see the game playing in the Unity
    Editor but not on the device, just restart Unity. Make sure to save it; it would
    be awful to lose all of your hard work.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想经历构建应用程序并将其放在设备上的过程，你仍然可以尝试与按钮进行交互，用手指触摸它们。在[第1章](ch01.html "第1章。向Unity和Android问好")“向Unity和Android问好”中，我们安装了应用程序，Unity
    Remote。将设备连接到您的计算机并启动它；当你在Unity编辑器中点击**播放**时，你应该能在你的设备上看到游戏正在运行。如果你在Unity编辑器中看到游戏正在播放，但在设备上没有看到，只需重新启动Unity。确保保存它；丢失所有辛勤工作将是可怕的。
- en: 'Undoubtedly the first thing you will notice when using Unity Remote is that
    the game doesn''t look good. It is almost certainly stretched and pixelated. If
    it doesn''t concern you now, don''t worry, it gets worse when the project becomes
    more complicated. Now, before you start freaking out, grumbling about why you
    had to install such a useless program, you must understand the point of Unity
    Remote. We went over it sometime back, but we will dig a little deeper. Unity
    Remote is for testing device inputs: touch screen, tilt, and so on. What it looks
    like is a result of freeing up bandwidth so that the frame rate is the same as
    it is in the Unity Editor.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，当你使用Unity Remote时，你首先会注意到游戏看起来并不好。它几乎肯定会被拉伸和像素化。如果你现在并不在意，不用担心，当项目变得更加复杂时，情况会更糟。现在，在你开始恐慌，抱怨为什么你必须安装这样一个无用的程序之前，你必须理解Unity
    Remote的目的。我们之前已经讨论过这个问题，但我们将进一步深入探讨。Unity Remote用于测试设备输入：触摸屏、倾斜等。它的外观是释放带宽的结果，以便帧率与Unity编辑器中的帧率相同。
- en: There is something you can and should do about the stretching. At the top-left
    corner of the **Game** window of the Unity Editor is a drop-down list. By default
    it is set to **Free Aspect**, which means the window will fill all the space available.
    If you click on it, a variety of aspect ratio options will be presented. Clicking
    through these options, you will see black bars in the **Game** window. This is
    Unity resizing the **Game** window and blacking out the unused space. The options
    change based on what the build target is. In the **Build Settings** window, change
    your platform to Android. In the **Game** window's drop-down menu, find an aspect
    ratio that matches your device. With that selected, your game will no longer appear
    stretched when using Unity Remote.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 关于拉伸问题，你可以做并且应该做的是。在Unity编辑器的**游戏**窗口的左上角有一个下拉列表。默认情况下，它设置为**自由比例**，这意味着窗口将填充所有可用空间。如果你点击它，会显示一系列的纵横比选项。点击这些选项，你会在**游戏**窗口中看到黑色条带。这是Unity正在调整**游戏**窗口并屏蔽未使用的空间。选项会根据构建目标而变化。在**构建设置**窗口中，将你的平台更改为Android。在**游戏**窗口的下拉菜单中，找到一个与你的设备匹配的纵横比。选择该选项后，使用Unity
    Remote时你的游戏将不再出现拉伸。
- en: Time for action – finish creating the game
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 完成游戏的创建
- en: Let us finish the creation of our game by creating an opening screen. We will
    then add some checks to stop players from selecting squares more than once. Follow
    that with a check to see if anyone won and finally display a game over screen.
    With that, the game will be ready for us to make it look great.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个开场屏幕来完成我们游戏的创建。然后，添加一些检查以防止玩家多次选择方格。接着检查是否有人获胜，并最终显示游戏结束屏幕。这样，游戏就准备好让我们让它看起来很棒了。
- en: 'Let''s perform the following steps for finishing our game:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行以下步骤来完成我们的游戏：
- en: 'We will do all this by first creating another script like our `SquareState`
    script. Create the new `GameState` script and clear out the default contents.
    Add the following code snippet and we will have the values needed to track the
    current state of our game:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将通过首先创建另一个类似于我们的`SquareState`脚本来完成所有这些。创建新的`GameState`脚本并清除默认内容。添加以下代码片段，我们将得到跟踪我们游戏当前状态的所需值：
- en: '[PRE9]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We now need to update our `TicTacToeControl` script. For starters, because we
    want to be able to play multiple games, add the `NewGame` function to the script.
    This function initializes our control variables so that we can start a fresh game
    with a clear board. It will not do very well for players to start a new game and
    have the board already filled in. This function will be used by our main menu,
    which we will be writing shortly.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要更新我们的`TicTacToeControl`脚本。首先，因为我们想能够玩多个游戏，所以将`NewGame`函数添加到脚本中。这个函数初始化我们的控制变量，以便我们可以从一张干净的棋盘开始新游戏。如果玩家开始新游戏时棋盘已经填满，这对玩家来说效果不会很好。这个函数将由我们即将编写的菜单主界面使用。
- en: '[PRE10]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: But first, we need to update our `OnGUI` function. To do that, start by moving
    all of the current contents of `OnGUI` to a new function called `DrawGameBoard`.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 但首先，我们需要更新我们的`OnGUI`函数。为此，首先将`OnGUI`中的所有当前内容移动到一个名为`DrawGameBoard`的新函数中。
- en: Now, we need to change our cleared `OnGUI` function to the following code snippet
    in order to allow it to check and draw the proper screen based on the current
    game state. A `switch` statement works the same as a bunch of `if` and `else if`
    statements. In our case, we check the game state and call a different function
    based on what it is. For example, if the game state is equal to `GameState.MultiPlayer`,
    we will call the `DrawGameBoard` function, which should now contain what used
    to be in the `OnGUI` function.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要将我们的已清除的`OnGUI`函数更改为以下代码片段，以便它能够根据当前游戏状态检查并绘制适当的屏幕。`switch`语句与一系列的`if`和`else
    if`语句的工作方式相同。在我们的情况下，我们检查游戏状态，并根据它是调用不同的函数。例如，如果游戏状态等于`GameState.MultiPlayer`，我们将调用`DrawGameBoard`函数，该函数现在应包含之前在`OnGUI`函数中的内容。
- en: '[PRE11]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'By this point you are probably wondering where that game state variable is
    coming from. If you guessed that it was automatically provided by Unity, you are
    wrong. We have to track our own game state. That is why we created the `GameState`
    script earlier. Add the following line of code to the top of our `TicTacToeControl`
    class, right above where we defined our game board:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，你可能想知道那个游戏状态变量是从哪里来的。如果你猜它是Unity自动提供的，那你就错了。我们必须跟踪我们自己的游戏状态。这就是为什么我们之前创建了`GameState`脚本。将以下代码行添加到我们的`TicTacToeControl`类顶部，就在我们定义游戏板的地方上方：
- en: '[PRE12]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Next, we need to create the other two game state screens. Let us start with
    the opening screen. When we draw our opening screen, we start by defining the
    `Rect` class used by our title. We follow that with a quick call to `GUI.Label`.
    By passing it a `Rect` class to position itself by and some text, the text is
    simply drawn on screen. This function is the best way to draw a section of text
    on the screen.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建另外两个游戏状态屏幕。让我们从开场屏幕开始。当我们绘制开场屏幕时，我们首先定义用于标题的`Rect`类。然后，我们快速调用`GUI.Label`。通过传递一个`Rect`类来定位文本，以及一些文本，文本就被简单地绘制在屏幕上。这个函数是绘制屏幕上文本段落的最佳方式。
- en: '[PRE13]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The following line of code defines the `Rect` class used by our `New Game` button.
    We want to be sure that it was right under the title, so it starts with the title's
    x position. We then combine the title's y position with its height to find the
    position right underneath it. Next, we used the width from the title so that our
    button will cover the entire position under it. Finally, the height is set to
    `75` because it is a good size for fingers and we don't want it to change based
    on the title. We could have just as easily used all the values from the title
    or just put in the numbers but our title will change later when we start styling
    everything.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码行定义了用于我们的`New Game`按钮的`Rect`类。我们想确保它位于标题下方，所以它从标题的x位置开始。然后，我们将标题的y位置与其高度相加，以找到位于其下方的位置。接下来，我们使用标题的宽度，以便我们的按钮覆盖其下的整个位置。最后，高度设置为`75`，因为这是一个适合手指的好尺寸，我们不想让它根据标题改变。我们同样可以使用标题的所有值，或者只输入数字，但我们的标题将在我们开始设计样式时改变。
- en: '[PRE14]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Finally, we make a call that will draw our button. You may remember our use
    of the `GUI.Button` function from when we drew the game board. If the button is
    pressed, the game state is set to `MultiPlayer` that will start our game. The
    `NewGame` function is also called, which will reset our game board. And of course,
    there is an extra curly brace to finish off the function.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们调用一个将绘制我们的按钮的函数。你可能还记得我们绘制游戏板时使用的`GUI.Button`函数。如果按钮被按下，游戏状态将被设置为`MultiPlayer`，这将开始我们的游戏。同时也会调用`NewGame`函数，这将重置我们的游戏板。当然，还有一个额外的花括号来结束函数。
- en: '[PRE15]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We have one screen left to draw, the game over screen. To do this, we will create
    the function referenced by our `OnGUI` function. However, in order for a game
    to end, there must be a winner, so add the following line of code right under
    our game state variable. We are making extended use of the `SquareState` enumeration.
    If the winner variable is equal to `Clear`, nobody won the game. If it is equal
    to `XControl` or `OControl`, the relevant player has won. Don't worry, it will
    make more sense when we create the game over screen next and the winner check
    system in a little bit.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还剩下最后一个屏幕需要绘制，那就是游戏结束屏幕。为了实现这个功能，我们将创建一个由我们的`OnGUI`函数引用的函数。然而，为了让一个游戏结束，必须有胜者，所以在我们游戏状态变量下面添加以下代码行。我们正在扩展使用`SquareState`枚举。如果胜者变量等于`Clear`，则没有人赢得游戏。如果它等于`XControl`或`OControl`，则相关玩家获胜。不用担心，当我们创建下一个游戏结束屏幕和稍后赢家检查系统时，这会更有意义。
- en: '[PRE16]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There is nothing particularly new in the `DrawGameOver` function. First, we'll
    define where we are going to write who won the game. We'll then figure out who
    won, using our winner variable. After drawing the winner title, the `Rect` class
    used is shifted down by its height so it can be reused. Finally, we'll draw a
    button that changes our game state back to `Opening`, which is of course our main
    menu.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DrawGameOver`函数中没有什么特别新的内容。首先，我们将定义我们将要写谁赢了游戏的位置。然后，我们将使用我们的胜者变量来确定谁赢了。在绘制胜者标题后，我们使用的`Rect`类将根据其高度向下移动，以便可以重复使用。最后，我们将绘制一个按钮，将我们的游戏状态改回`Opening`，这当然是我们的主菜单。
- en: '[PRE17]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: To make sure we are not overwriting squares that somebody already controls,
    we need to make a few changes to our `DrawGameBoard` function. First, it would
    be helpful if the players could easily tell whose turn it is. To do this, we'll
    add the following code snippet to the end of the function. This should start to
    become familiar. We'll first define where we want to draw. Then, we'll use our
    `xTurn` Boolean to determine what to write about whose turn it is. Finally, it
    is the `GUI.Label` function to draw it on screen.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保我们不覆盖别人已经控制的方块，我们需要对我们的`DrawGameBoard`函数做一些修改。首先，如果玩家可以轻松地知道谁的回合，那将很有帮助。为此，我们将在函数的末尾添加以下代码片段。这应该开始变得熟悉。我们首先定义我们想要绘制的位置。然后，我们将使用我们的`xTurn`布尔值来确定要写关于谁的回合。最后，我们使用`GUI.Label`函数在屏幕上绘制它。
- en: '[PRE18]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We now need to change the bit where we draw the board square, the `GUI.Button`
    function. We need to only draw that button if the square is clear. The following
    code snippet will do just that by moving the button inside of a new `if` statement.
    It checks whether the board square is clear. If it is, we draw the button. Otherwise,
    we use a label to write the owner to the button's location.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在需要更改绘制棋盘方格的部分，即`GUI.Button`函数。我们需要只在方格为空时绘制该按钮。下面的代码片段将通过将按钮移动到新的`if`语句中来完成这一任务。它检查棋盘方格是否为空。如果是，我们绘制按钮。否则，我们使用标签将所有者信息写入按钮的位置。
- en: '[PRE19]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The last thing we need to do is make a system that checks for a winner. We will
    do this in another function provided by the `MonoBehaviour` class. `LateUpdate`
    is called at the end of every frame, just before things are drawn on the screen.
    You might be wondering to yourself, why don't we just create a function that is
    called at the end of `OnGUI`, which is already called every frame? The reason
    is that the `OnGUI` function gets a little weird when drawing some of the GUI
    elements. It will sometimes be called more than once so that it can draw everything.
    So, for the most part, the functionality should never be controlled by `OnGUI`.
    That is what `Update` and `LateUpdate` are for. `Update` is the normal game loop
    where most of a game's functionality is called from. `LateUpdate` is for things
    that need to happen after the objects' update, such as our check for a game over.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们最后需要做的是创建一个检查胜者的系统。我们将在`MonoBehaviour`类提供的另一个函数中完成这项工作。`LateUpdate`在每个帧的末尾被调用，就在屏幕上绘制事物之前。你可能自己会想，为什么我们不创建一个在`OnGUI`末尾被调用的函数，因为`OnGUI`已经每帧被调用？原因是当绘制一些GUI元素时，`OnGUI`函数会变得有些奇怪。它有时会被调用多次，以便绘制所有内容。所以，大部分功能不应该由`OnGUI`控制。这就是`Update`和`LateUpdate`的作用。`Update`是正常的游戏循环，大多数游戏功能都是从这里调用的。`LateUpdate`用于需要在对象更新之后发生的事情，比如我们的游戏结束检查。
- en: Add the following `LateUpdate` function to our `TicTacToeControl` class. We'll
    start with a check to make sure we should even be checking for a winner. If the
    game isn't in a state where we are playing, in this case `MultiPlayer`, exit here
    and go no further.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`LateUpdate`函数添加到我们的`TicTacToeControl`类中。我们将从一个检查开始，确保我们甚至应该检查胜者。如果游戏不在我们正在玩的状态，在这个例子中是`MultiPlayer`，在这里退出并不再继续。
- en: '[PRE20]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Follow that with a short `for` loop. A victory in this game is a run of three
    matching squares. We start by checking the column that is marked by our loop.
    If the first square is not `Clear`, compare it to the square below; if they match,
    check it against the square below that. Our board is stored as a list but drawn
    as a grid, so we have to add three to go down a square. The `else if` statement
    follows checks of each row. By multiplying our loop value by three, we will skip
    down a row of each loop. We'll again compare the square to `SquareState.Clear`,
    then to the square one to its right, and finally two to the right. If either set
    of conditions is correct, we'll send the first square in the set out to another
    function to change our game state.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接着是一个简短的`for`循环。在这个游戏中，胜利意味着连续三个匹配的方格。我们首先检查由循环标记的列。如果第一个方格不是`Clear`，则将其与下面的方格进行比较；如果它们匹配，则将其与下面的方格进行比较。我们的棋盘存储为一个列表，但以网格的形式绘制，因此我们需要加三才能向下移动一个方格。`else
    if`语句随后检查每一行。通过将循环值乘以三，我们将跳过每一循环的一行。我们再次将方格与`SquareState.Clear`进行比较，然后与它右侧的方格比较，最后与两个方格右侧的方格比较。如果任一条件组成立，我们将该组中的第一个方格发送到另一个函数以更改我们的游戏状态。
- en: '[PRE21]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The following code snippet is largely the same as the `if` statements we just
    wrote previously. However, these lines of code check the diagonals. If the conditions
    are true, again send out to the other function to change game states. You have
    probably also noticed the returns after the function calls. If we have found a
    winner at any point, there is no need to check any more of the board. So, we'll
    exit the `LateUpdate` function early.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面的代码片段与之前我们编写的`if`语句大致相同。然而，这些代码行检查的是对角线。如果条件成立，再次调用其他函数以更改游戏状态。你可能也注意到了函数调用后的返回值。如果在任何时刻找到了胜者，就没有必要再检查棋盘上的其他位置。因此，我们将提前退出`LateUpdate`函数。
- en: '[PRE22]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is the last little bit for our `LateUpdate` function. If no one has won
    the game, as determined by the previous parts of this function, we have to check
    for a tie. This is done by checking all of the squares of the game board. If any
    one of them is `Clear`, the game has yet to finish and we exit the function. But,
    if we make it through the entire loop without finding a `Clear` square, we go
    set the winner but declare a tie.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是我们的`LateUpdate`函数的最后一点。如果没有玩家获胜，如该函数的前一部分所确定的，我们必须检查是否有平局。这是通过检查游戏板上的所有方格来完成的。如果任何一个方格是`Clear`，则游戏尚未结束，我们退出函数。但是，如果我们整个循环中没有找到`Clear`方格，我们就设置赢家并宣布平局。
- en: '[PRE23]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Tip
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Do remember to close the last curly brace. It is needed to close off the `LateUpdate`
    function. If you forget it, some annoying errors will come your way.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请务必记得关闭最后一个花括号。这是关闭`LateUpdate`函数所必需的。如果你忘记了，一些令人烦恼的错误将会出现。
- en: Finally, we'll create the `SetWinner` function that is called repeatedly in
    our `LateUpdate` function. Short and sweet, we'll pass to this function that is
    going to win. It sets our winner variable and changes our game state to `GameOver`.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将创建一个`SetWinner`函数，这个函数将在我们的`LateUpdate`函数中被反复调用。简短而直接，我们将传递给这个函数，它将决定赢家。它设置我们的赢家变量并将游戏状态改为`GameOver`。
- en: '[PRE24]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![Time for action – finish creating the game](img/2014OT_02_02.png.jpg)'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 - 完成创建游戏](img/2014OT_02_02.png.jpg)'
- en: '*What just happened?*'
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: That is it. Congratulations! We now have a fully functioning Tic-tac-toe game
    and you survived the process. In the next sections, we will finally get to make
    it all look pretty. That is a good thing because, as the screenshot shows, the
    game does not look great right now.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。恭喜！我们现在有一个完全功能正常的井字棋游戏，并且你成功完成了这个过程。在接下来的章节中，我们终于可以把它做得更漂亮了。这是一件好事，因为，如截图所示，游戏现在看起来并不好看。
- en: GUI Skins and GUI Styles
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GUI 皮肤和 GUI 风格
- en: GUI Styles are how we change the look and feel of GUI elements, buttons, and
    labels in Unity. A GUI Skin contains several GUI Styles and allows us to change
    the look of the entire GUI without explicitly defining GUI Styles for each element.
    To create a GUI Skin, right-click in the **Project** window of the Unity Editor,
    just as with creating a new script. Go to **Create** but, instead of selecting
    **Script**, go to the bottom and select **GUI skin**. Selecting this option will
    create the new GUI Skin and let us name it to `GameSkin`. By looking at our `GameSkin`
    in the **Inspector** window, you can see what we have to work with.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: GUI 风格是我们改变 Unity 中 GUI 元素、按钮和标签的外观和感觉的方式。GUI 皮肤包含多个 GUI 风格，并允许我们改变整个 GUI 的外观，而无需为每个元素显式定义
    GUI 风格。要创建一个 GUI 皮肤，在 Unity 编辑器的**项目**窗口中右键单击，就像创建一个新的脚本一样。转到**创建**，但不是选择**脚本**，而是到底部选择**GUI
    皮肤**。选择此选项将创建新的 GUI 皮肤，并允许我们将其命名为`GameSkin`。通过在**检查器**窗口中查看我们的`GameSkin`，你可以看到我们可以使用什么。
- en: '![GUI Skins and GUI Styles](img/2014OT_02_03.png.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![GUI 皮肤和 GUI 风格](img/2014OT_02_03.png.jpg)'
- en: At the top is a **Font** attribute. By importing font files to your project
    and placing one here, you can change the default font used by text in the whole
    game.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在顶部是一个**字体**属性。通过将字体文件导入到你的项目中并放置在这里，你可以改变整个游戏中文本使用的默认字体。
- en: Under that is a long list of GUI elements, including our good friends **Button**
    and **Label**. These are all GUI Styles and coincide with the GUI functions that
    we use to draw things on screen. For example, unless otherwise specified, when
    we use the `Button` function, it will draw using the **Button** GUI Style.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在下面是一个长的 GUI 元素列表，包括我们的好朋友**按钮**和**标签**。这些都是 GUI 风格，与我们在屏幕上绘制东西所使用的 GUI 函数相对应。例如，除非有其他指定，当我们使用`Button`函数时，它将使用**按钮**GUI
    风格来绘制。
- en: Following the list of GUI elements is a **Custom Styles** attribute. This is
    where we can put any extra styles that we want to use. Of our dozen buttons, perhaps
    we want one to have red text. That GUI Style would go here.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 GUI 元素列表之后是一个**自定义风格**属性。这就是我们可以放置任何我们想要使用的额外风格的地方。在我们的十二个按钮中，也许我们想要一个按钮显示红色文字。这种
    GUI 风格就会放在这里。
- en: At the bottom is a **Settings** attribute. By expanding it, we can see it is
    fairly short. It includes options for whether or not multiclicks can be used for
    selection, what color of cursor and how fast it should flash when in a text field,
    and what color the highlight on selected words should be. The defaults here are
    just fine. Unless there is a very specific look or need, these values can be ignored.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在底部是一个**设置**属性。通过展开它，我们可以看到它相当简短。它包括是否可以使用多击进行选择、光标的颜色以及它在文本字段中闪烁的速度，以及所选单词的高亮颜色。这里的默认值已经很好了。除非有非常具体的外观或需求，否则可以忽略这些值。
- en: Now, let us go over what it takes to be a GUI Style. Expand the **Button** GUI
    Style from our `GameSkin` example. No matter what the GUI Style is used for, they
    all are made up the same. It may look like there are many attributes that make
    up a GUI Style, but most of them are nearly identical, making it much simpler.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看成为GUI样式所需具备的条件。从我们的`GameSkin`示例中扩展**按钮**GUI样式。无论GUI样式用于什么，它们都是由相同的元素组成的。它看起来像有很多属性组成GUI样式，但其中大多数几乎是相同的，这使得它变得简单得多。
- en: '![GUI Skins and GUI Styles](img/2014OT_02_04.png.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![GUI皮肤和GUI样式](img/2014OT_02_04.png.jpg)'
- en: The first attribute is fairly straightforward, but perhaps the most important.
    **Name** is what Unity uses to find GUI Styles and apply them to GUI elements.
    It lets us know what the style is supposed to be; however, if there is a typo
    between it and the code, you will never see your style in the game.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个属性相当直接，但也许是最重要的。**名称**是Unity用来查找GUI样式并将其应用于GUI元素的方式。它让我们知道样式应该是什么；然而，如果名称和代码之间存在拼写错误，你将永远看不到你的样式在游戏中。
- en: 'The next several groups of values describe how the GUI element should look
    when in a particular state. This is where the bulk of your styling will go. The
    primary states of any element are **Normal**, **Hover**, **Active**, and **Focused**.
    Secondary to these are **On Normal**, **On Hover**, **On Active**, and **On Focused**.
    These secondary states only occur as the GUI element transfers into the corresponding
    primary state. Not every GUI element makes use of every state, and you have the
    ability to control which states an element can go into, but we will discuss that
    a little later. Let''s see in detail how these states work:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的几组值描述了GUI元素在特定状态下应该看起来如何。这是你将放置大部分样式的位置。任何元素的初级状态主要是**正常**、**悬停**、**激活**和**聚焦**。次要状态是**正常时**、**悬停时**、**激活时**和**聚焦时**。这些次要状态仅在GUI元素转移到相应的初级状态时发生。并非每个GUI元素都使用每个状态，并且你可以控制元素可以进入哪些状态，但我们将稍后讨论这一点。让我们详细看看这些状态是如何工作的：
- en: '**Normal**: This is the default state of any GUI element. It is always used
    and occurs any time the element is not being interacted with.'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正常状态**：这是任何GUI元素的默认状态。它始终被使用，并且当元素没有被交互时发生。'
- en: '**Hover**: This state is used primarily by buttons and other clickable elements.
    When your mouse is on top of a GUI element, it will enter this state, if it can.
    However, since the focus of this book is touch screens, we do not have a mouse
    to really concern ourselves with. So, we will not be using this state.'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**悬停状态**：这个状态主要用于按钮和其他可点击元素。当你的鼠标位于GUI元素上方时，如果可能，它将进入这个状态。然而，由于本书的重点是触摸屏，我们没有鼠标真正需要关心。因此，我们不会使用这个状态。'
- en: '**Active**: This has to be the second most important state. An element enters
    this state when it is activated. For example, when one presses a button, it is
    active. By clicking on or touching a button, it enters the **Active** state. All
    of the GUI elements that can be interacted with use this state.'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**激活状态**：这可能是第二重要的状态。当元素被激活时，它会进入这个状态。例如，当按下按钮时，它就是激活状态。通过点击或触摸按钮，它进入**激活**状态。所有可以交互的GUI元素都使用这个状态。'
- en: '**Focused**: This is a rarely used state. In terms of Unity''s GUI, focused
    means having keyboard control. The only element that uses it by default is the
    **Text Field**.'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚焦状态**：这是一个很少使用的状态。在Unity的GUI中，聚焦意味着拥有键盘控制。默认使用它的唯一元素是**文本字段**。'
- en: If you were to expand any of the states, you would see that it has two attributes,
    **Background** and **Text Color**. The **Background** attribute is a texture.
    It can be any texture in your game. The **Text Color** attribute is simply the
    color of any text that appears in the GUI element. Except for the **Normal** state,
    if a state does not have a background texture, it will not be used. This can be
    both good and annoying. If we do not want our buttons to show that they have been
    hovered over, simply remove the texture from the Hover state's **Background**
    attribute. It becomes annoying when we want a GUI element that does not have a
    background image of its own, but we do want the text to change color between states.
    How do we make use of the active state, but not use a texture for the background?
    The answer is that we create a blank image, but it is not quite as simple as saving
    off a 100 percent transparent PNG and using that. The GUI Style is too smart for
    that. It detects that the image is completely blank, making it no different than
    if there was no image. And so, the state still is not used. To get around this,
    create a small, blank PNG image, but take a single pixel and make it 90 percent
    transparent white. This might seem like a hack solution, but it is, unfortunately,
    the only way. At such a low transparency, we can't detect the pixel; though it
    is not actually clear. However, Unity sees that there is a slightly white pixel
    that must be drawn and does so.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你展开任何状态，你会看到它有两个属性，**背景** 和 **文字颜色**。**背景** 属性是一个纹理。它可以是你游戏中任何纹理。**文字颜色**
    属性是GUI元素中出现的任何文字的颜色。除了 **正常** 状态外，如果一个状态没有背景纹理，则不会使用它。这既有好的一面也有不好的一面。如果我们不希望我们的按钮显示它们已被悬停，只需从悬停状态的
    **背景** 属性中移除纹理即可。当我们想要一个没有自己背景图像的GUI元素，但同时又想在不同状态下改变文字颜色时，这会变得很烦人。我们如何使用活动状态，但不使用背景纹理呢？答案是，我们创建一个空白图像，但这并不像保存一个100%透明的PNG文件并使用它那样简单。GUI样式太智能了。它会检测到图像是完全空白的，这使得它与没有图像没有区别。因此，该状态仍然没有被使用。为了解决这个问题，创建一个小的空白PNG图像，但取一个像素并使其90%透明白色。这看起来可能像是一种黑客解决方案，但不幸的是，这是唯一的方法。在如此低的透明度下，我们无法检测到像素；尽管它实际上并不透明。然而，Unity会看到有一个稍微白色的像素必须被绘制，并这样做。
- en: Now, you might be thinking, that's stupid. I'm just going to create images of
    all of my buttons and not worry about the text. It is indeed stupid but the response
    to that is, what if you need to slightly change the text of a button? Or perhaps
    the text on the button is dynamic based on the player's name. In nearly every
    project I have been a part of there has been a need to create the not quite blank
    image.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，你可能会想，这很愚蠢。我只是要创建所有按钮的图像，而不必担心文字。这确实很愚蠢，但对此的回应是，如果你需要稍微改变按钮的文字怎么办？或者按钮上的文字可能是基于玩家名字的动态文本。在参与的几乎所有项目中，都有创建这种不完全空白图像的需求。
- en: 'Below the GUI element''s states are **Border**, **Margin**, **Padding**, and
    **Overflow**. These attributes control how an element interacts with its background
    images and contained text. Inside each you will find **Left**, **Right**, **Top**,
    and **Bottom** values. Since every element is drawn as a rectangle, these correspond
    to each side of the said rectangle. They are defined in pixels, just like our
    GUI space. Let''s see all these attributes in detail as follows:'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在GUI元素的各个状态下面是 **边界**, **边距**, **填充**, 和 **溢出**。这些属性控制元素如何与它的背景图像和包含的文本交互。在每个属性中，你将找到
    **左**, **右**, **上**, 和 **下** 的值。由于每个元素都被绘制为一个矩形，这些对应于该矩形的每一侧。它们是以像素为单位的，就像我们的GUI空间一样。让我们详细看看所有这些属性，如下所示：
- en: '**Border**: This lets us define how many pixels from each side should not be
    stretched. When defining a GUI element, the background is normally stretched evenly
    across the space occupied. If you were to create a blue box with red edging and
    rounded corners, these values would keep your edges and corners regular while
    still stretching the blue on the inside.'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边界**: 这允许我们定义每个边应该有多少像素不应被拉伸。在定义GUI元素时，背景通常均匀地拉伸到占据的空间。如果你要创建一个带有红色边缘和圆角蓝色的框，这些值将保持你的边缘和角落规则，同时仍然拉伸内部的蓝色。'
- en: '**Margin**: This is only used by Unity''s automatic GUI layout system named
    GUILayout. It is how much extra space should be around the outside of the element.'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边距**: 这仅由Unity的自动GUI布局系统GUILayout使用。它表示元素外部应该有多少额外的空间。'
- en: '**Padding**: This is the space between the borders of an element and the text
    that it contains. If you want the text of a button left-justified but in slightly,
    you should use **Padding**.'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**填充**是元素边框和包含的文本之间的空间。如果你想将按钮的文本左对齐但稍微向右偏移，你应该使用**填充**。'
- en: '**Overflow**: This defines an extra space for your background image. When creating
    our buttons, we defined a `Rect` class for how much space the button takes up.
    If we are to use `Overflow`, the button itself would be where the `Rect` class
    is, but the background would extend beyond each edge as dictated by the values.
    This would be useful for buttons with a shadow or glow around them.'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**溢出**定义了背景图像的额外空间。在创建我们的按钮时，我们定义了一个`Rect`类来表示按钮占据的空间。如果我们使用`Overflow`，按钮本身将是`Rect`类所在的位置，但背景将根据值延伸到每个边缘。这对于周围有阴影或发光效果的按钮很有用。'
- en: The next several values have to do with the text in an element. The **Font**
    attribute is a font that is used specifically by this style. If this value is
    left empty, the font from the GUI Skin is used. **Font Size** is how big the letters
    of the text should be. This works just like your favorite word processor, except
    that a value of zero means to use the default font size defined in the font object.
    **Font Style** also works like your word processor. It lets you choose between
    **Normal**, **Bold**, and **Italic** text. This only makes a difference if it
    is supported by your chosen font.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的几个值与元素中的文本有关。**字体**属性是专门由这种样式使用的字体。如果这个值留空，则使用GUI皮肤中的字体。**字体大小**决定了文本字母的大小。这就像你的最喜欢的文字处理器一样工作，除了零值表示使用字体对象中定义的默认字体大小。**字体样式**也像你的文字处理器一样工作。它让你可以选择**正常**、**加粗**和**斜体**文本。这只有在你的选择字体支持的情况下才有区别。
- en: '**Alignment** defines where to justify the text in the GUI element. Imagine
    splitting your element into a 3 x 3 grid. **Alignment** is the same as the position
    of the grid.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对齐**定义了在GUI元素中放置文本的位置。想象一下将你的元素分成一个3x3的网格。**对齐**与网格的位置相同。'
- en: '**Word Wrap** defines whether or not text should split into multiple lines
    if it is too long. It again works on the same principle as your word processor.
    If checked and the line of text would extend beyond the sides of the GUI element,
    the text is split into as many lines as necessary to keep it within the bounds.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动换行**定义了文本是否应该分成多行，如果它太长。它再次遵循与你的文字处理器相同的原理。如果选中，并且文本行会超出GUI元素的边缘，文本将分成必要的行数以保持在其范围内。'
- en: '**Rich Text** is a fairly new and interesting feature of GUI Styles. It allows
    us to use HTML style markup to control text. You could put the tags `<b>` and
    `</b>` around a word in your Label''s text, and instead of writing those tags,
    Unity will make the words in between bold. We can make use of the bold, italics,
    size, and color tags. This allows for selectively making parts of our text bold
    or italics. We can make certain words larger or smaller. And, the color of any
    part of the text can be altered using hexadecimal values.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**富文本**是GUI样式的相对较新且有趣的功能。它允许我们使用HTML样式标记来控制文本。你可以在标签的文本中围绕一个单词放置`<b>`和`</b>`标签，而不是编写这些标签，Unity将使标签之间的单词加粗。我们可以使用加粗、斜体、大小和颜色标签。这允许我们选择性地使文本的某些部分加粗或斜体。我们可以使某些单词更大或更小。此外，可以使用十六进制值更改文本任何部分的颜色。'
- en: '**Text Clipping** became weird in the recent updates. It used to be a nice
    drop-down list of values, but now it is an integer field. Either way, it still
    serves its function. If the text extends beyond the edges of the GUI element,
    this attribute dictates what to do. A value of zero means don''t clip the text,
    let it extend beyond the edges. Any value that is not zero will cause the text
    to be clipped. Any text that extends beyond the borders will simply not be drawn.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本裁剪**在最近更新中变得有些奇怪。它曾经是一个很好的值下拉列表，但现在它是一个整数字段。无论如何，它仍然履行其功能。如果文本超出GUI元素的边缘，这个属性决定了要做什么。零值表示不裁剪文本，让它超出边缘。任何非零值都会导致文本被裁剪。任何超出边界的文本将简单地不会被绘制。'
- en: '**Image Position** is used in conjunction with GUIContent. GUIContent is a
    way of passing GUI elements the text, an icon image, and a tool tip. **Image Position**
    describes how the image and text interact. The image can either go to the left
    of the text or above. Or, we can choose to only use either the image or the text.
    Since tool tips aren''t really useful in a touch environment, GUIContent is of
    limited use to us. For that reason, we will not be using it extensively, if at
    all.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图像位置**与GUIContent一起使用。GUIContent是一种将文本、图标图像和工具提示传递给GUI元素的方式。**图像位置**描述了图像和文本的交互方式。图像可以位于文本的左侧或上方。或者，我们可以选择只使用图像或文本。由于在触摸环境中工具提示并不真正有用，所以GUIContent对我们来说用途有限。因此，我们将不会广泛使用它，如果使用的话。'
- en: '**Content Offset** adjusts anything contained inside the GUI element by the
    values provided. If all of your text is normally centered in your button, this
    will allow you to move it slightly to the right and up. It is an aesthetic thing,
    for when you need a very specific look.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内容偏移**通过提供的值调整GUI元素内部包含的任何内容。如果你的所有文本通常在按钮中居中，这将允许你将其稍微向右和向上移动。这是一个美学问题，当你需要一个非常具体的视觉效果时。'
- en: '**Fixed Width** and **Fixed Height** provides approximately the same function.
    If any value other than zero is provided for these attributes, they will override
    the corresponding values in the `Rect` class used for the GUI element. So, if
    you wanted buttons to always be one hundred pixels wide, no matter where they
    are in the game, you could set **Fixed Width** to one hundred and they will do
    just that.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**固定宽度**和**固定高度**提供大约相同的功能。如果为这些属性提供了除零以外的任何值，它们将覆盖用于GUI元素的`Rect`类中对应的值。因此，如果你想让按钮始终宽一百像素，无论它们在游戏中的位置如何，你可以将**固定宽度**设置为100，它们就会这样做。'
- en: '**Stretch Width** and **Stretch Height** also serves about the same function.
    They are used by GUILayout for automatic placement of GUI elements. It pretty
    much gives the system permission to make elements wider/skinnier and taller/shorter,
    respectively, in order to satisfy its conditions for a better layout. The way
    GUILayout arranges elements is not always the best. It is good, if you need something
    up quick. But it gets complicated if you want any sort of deeper control.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拉伸宽度**和**拉伸高度**也起到类似的作用。它们被GUILayout用于GUI元素的自动放置。它基本上给系统授权，使其元素可以更宽/更瘦和更高/更短，以满足其更好的布局条件。GUILayout排列元素的方式并不总是最好的。如果你需要快速完成某事，它很好。但如果你想要更深入的控制，就会变得复杂。'
- en: A prettier form of Tic-tac-toe
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更美观的井字棋
- en: Finally, we get to put what we learned about GUI Skins and GUI Styles into action
    and make our game look better. Or, at least make the game look like it isn't using
    default assets. Whatever your artistic talents, you will need to find or create
    a few images to continue following along.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以将关于GUI皮肤和GUI样式的知识应用到实际中，使我们的游戏看起来更好。或者，至少让游戏看起来没有使用默认资源。无论你的艺术才能如何，你都需要找到或创建一些图像，以便继续学习。
- en: Time for action – styling the game
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候为游戏添加样式了
- en: If you do not want to look far, the assets used for this chapter are found along
    with the resources for the book. All of the needed images are available, and they
    will work just well, until you have an opportunity to create some of your own.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想找得太远，本章使用的资源可以在与书籍资源一起找到。所有需要的图像都可用，并且它们将工作得很好，直到你有机会创建一些自己的。
- en: 'First, we need five small textures: `ButtonActive`, `ButtonNormal`, `ONormal`,
    `XNormal`, and `Title`. To create these, you will have to use a separate photo-editing
    program or use the ones supplied with the included projects.'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要五个小纹理：`ButtonActive`、`ButtonNormal`、`ONormal`、`XNormal`和`Title`。为了创建这些，你将不得不使用一个单独的图片编辑程序或使用包含在项目中的那些。
- en: The easiest way to get the images into your Unity project is to simply save
    them into the `Assets` folder that is created when you create a new project. Alternatively,
    you can go up to the top and click on **Assets** followed by **Import New Asset**.
    This will open a file browser and let you navigate to the asset you want. When
    you have found the asset you desire to import and have clicked on the **Import**
    button, a copy of the asset is put in your project. Unity will not move or remove
    files that exist outside of the current project.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图像放入你的Unity项目中最简单的方法是将它们保存到创建新项目时创建的`Assets`文件夹中。或者，你可以点击顶部并选择**资产**，然后选择**导入新资产**。这将打开一个文件浏览器，让你导航到想要导入的资源。当你找到你想要导入的资源并点击**导入**按钮时，该资源的副本将被放入你的项目中。Unity不会移动或删除当前项目之外的文件。
- en: And now a note about import settings for textures. By default, Unity assumes
    any image files imported to your project are going to be used as game model textures.
    Because of that, Unity compresses them and adjusts them to fit a power of two.
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在关于纹理的导入设置有一个说明。默认情况下，Unity假设导入到项目中的任何图像文件都将用作游戏模型纹理。因此，Unity会压缩它们，并将它们调整为适合2的幂。
- en: Tip
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In case you didn't know, in computer graphics it is much faster to render images
    that can be divided in half evenly, down to a single unit. There are deeper reasons,
    but suffice it to say that it is because of the binary switches that actually
    make up a computer.
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你不知道，在计算机图形学中，渲染可以均匀分成一半的图像要快得多，直到单个单位。有更深层的原因，但简单来说，这是因为构成计算机的实际上是二进制开关。
- en: '![Time for action – styling the game](img/2014OT_02_05.png.jpg)'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 - 游戏样式](img/2014OT_02_05.png.jpg)'
- en: Making our images recognized as being for the GUI is quite simple. To the right
    of **Texture Type**, click on **Texture** and select **GUI** from the drop-down
    menu.
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们的图像被识别为GUI的图像非常简单。在**纹理类型**的右侧，点击**纹理**并从下拉菜单中选择**GUI**。
- en: You will notice that we were given a new **Filter Mode** drop-down menu. This
    is essentially how much effort Unity will put into making the image look nice
    as it is resized for the various GUI elements. **Trilinear** is the best, **Point**
    is the fastest, and **Bilinear** is in the middle.
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你会注意到我们得到了一个新的**过滤器模式**下拉菜单。这基本上是Unity在调整图像大小以适应各种GUI元素时将投入多少努力。**三线性**是最好的，**点**是最快的，**双线性**位于中间。
- en: Once the import settings have been changed, be sure to click on **Apply**, or
    Unity will complain when you try to do anything else. If you do not want to commit
    the changes, clicking on **Revert** will discard any changes just made and set
    back the **Import Settings** window to the last configuration that was used.
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦更改了导入设置，请务必点击**应用**，否则当你尝试做其他任何事情时，Unity都会抱怨。如果你不想提交更改，点击**还原**将丢弃刚刚所做的任何更改，并将**导入设置**窗口恢复到最后一次使用的配置。
- en: So, set all of **Texture Types** for your images to GUI and we will get on with
    it.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，将所有图像的**纹理类型**设置为GUI，我们就可以继续了。
- en: 'Let us start with the beginning of the game. Open your `TicTacToeControl` script
    and add the following lines of code at the beginning. These allow us to attach
    references to other assets inside of the Unity Editor. The first will hold our
    `GameSkin`, so we can style all of our GUI elements. The second, as you can see
    in the following lines of code, will hold our fancy title image:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从游戏开始的地方开始。打开你的`TicTacToeControl`脚本，并在开头添加以下代码行。这些代码允许我们在Unity编辑器内部附加对其他资源的引用。第一个将保存我们的`GameSkin`，这样我们就可以为所有的GUI元素设置样式。第二个，正如你在下面的代码行中可以看到的，将保存我们的精美标题图像：
- en: '[PRE25]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now go to the Unity Editor and select **Main Camera** from the **Hierarchy**
    window.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在转到Unity编辑器，并从**层次结构**窗口中选择**主摄像机**。
- en: Every object that you see listed in the **Hierarchy** window is a `GameObject`.
    A `GameObject` is given a purpose and a meaning by the various components that
    are attached to it, for example, our `TicTacToeControl` script.
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你在**层次结构**窗口中看到的每一个列表对象都是一个`GameObject`。通过附加到它上的各种组件，`GameObject`被赋予了目的和意义，例如我们的`TicTacToeControl`脚本。
- en: An empty `GameObject` is just a point in space, as defined by the `Transform`
    component that is always the first component on any `GameObject`.
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个空的`GameObject`只是一个由`Transform`组件定义的空间点，该组件是任何`GameObject`上的第一个组件。
- en: You can see in the **Inspector** window, the **Main Camera** object has a **Camera**
    component. It gives a purpose to the `GameObject` and controls how the **Camera**
    component functions, just as our `TicTacToeControl` component at the bottom lets
    it control our Tic-tac-toe game.
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在**检查器**窗口中看到，**主摄像机**对象有一个**摄像机**组件。它为`GameObject`赋予目的，并控制**摄像机**组件的功能，就像我们底部的`TicTacToeControl`组件让我们控制我们的井字棋游戏一样。
- en: The **Inspector** window also lets us see all of the public variables that can
    be changed in the Unity Editor. If they are changed, those values are saved and
    used when the game is played. So, by creating a variable in our script, we can
    add the reference to our `GameSkin` and it will be used in the game. To add the
    reference, simply click-and-drag the object to the desired variable on the component
    in the **Inspector** window.
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检查器**窗口还让我们能够看到在Unity编辑器中可以更改的所有公共变量。如果它们被更改，这些值将在游戏播放时保存并使用。因此，通过在我们的脚本中创建一个变量，我们可以将`GameSkin`的引用添加到其中，它将在游戏中使用。要添加引用，只需将对象拖放到**检查器**窗口中所需的变量上即可。'
- en: Drag `GameSkin` to the **GUI Skin** slot and our title image to the **Title
    Image** slot.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`GameSkin`拖到**GUI皮肤**槽位，并将我们的标题图像拖到**标题图像**槽位。
- en: Tip
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Be sure to save. Saving regularly is the only thing that stands between you
    and premature baldness, the next time your computer decides to die.
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一定要保存。定期保存是您和过早脱发之间唯一的障碍，下次您的电脑决定死亡时。
- en: Inside of our `TicTacToeControl` script, add the following line of code at the
    beginning of the `OnGUI` function. It first checks to make sure there is a GUI
    Skin available. If it is, it is set into the `GUI.skin` variable. This variable
    controls the GUI Skin that is used in the game. Once set, any GUI elements drawn
    after that will use the new GUI Skin. This could allow you to set one GUI Skin
    and draw half of the GUI, then set a different GUI Skin and draw the other half
    in a completely different style.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`TicTacToeControl`脚本中，在`OnGUI`函数的开始处添加以下代码行。它首先检查是否有可用的GUI皮肤。如果有，它将设置到`GUI.skin`变量中。这个变量控制游戏中使用的GUI皮肤。一旦设置，之后绘制的任何GUI元素都将使用新的GUI皮肤。这可以允许您设置一个GUI皮肤并绘制一半的GUI，然后设置不同的GUI皮肤并在完全不同的风格中绘制另一半。
- en: '[PRE26]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If you play your game now, it won't look like much. The defaults of a new GUI
    Skin are the exact same as the default GUI Skin that Unity uses. Let us change
    that by selecting our `GameSkin` and expanding **Button** and **Label** in the
    **Inspector** window.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您现在玩游戏，它看起来不会太多。新的GUI皮肤默认值与Unity使用的默认GUI皮肤完全相同。让我们通过选择我们的`GameSkin`并在**检查器**窗口中展开**按钮**和**标签**来改变它。
- en: For **Button** we created a **ButtonNormal** and **ButtonActive** image. By
    dragging those to the **Background** properties of the respective states, the
    look of the buttons will change.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于**按钮**，我们创建了**按钮正常**和**按钮活动**图像。通过将它们拖到相应状态的**背景**属性中，按钮的外观将发生变化。
- en: The supplied button images have a yellow background, which will make the white
    text hard to read. So, by clicking on the color next to the **Text Color** property,
    the **Color Picker** window will open and we can select a new color. A navy blue
    for the **Normal** state and a faded blue for the **Active** state works well.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 供应的按钮图像有黄色背景，这将使白色文字难以阅读。因此，通过点击**文本颜色**属性旁边的颜色，将打开**颜色选择器**窗口，我们可以选择新的颜色。对于**正常**状态，海军蓝效果很好；对于**活动**状态，淡蓝色效果很好。
- en: Also, to keep it from looking weird in the Unity Editor, remove the **Hover**
    state. With a touch interface, there is no cursor to hover over buttons; therefore,
    there is no need for a hover state. To remove it, first click on the little circle
    to the right of the **Background** image.![Time for action – styling the game](img/2014OT_02_06.png.jpg)
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，为了防止在Unity编辑器中看起来奇怪，请移除**悬停**状态。在触摸界面上，没有光标可以悬停在按钮上；因此，不需要悬停状态。要移除它，首先点击**背景**图像右侧的小圆圈。![操作时间
    - 设置游戏样式](img/2014OT_02_06.png.jpg)
- en: The new window that pops up allows us to select any image that is currently
    in our project. However, since we want nothing to be in there select **None**,
    the first option in the list.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 弹出的新窗口允许我们选择项目中当前任何图像。然而，由于我们希望那里没有任何内容，请选择列表中的第一个选项**无**。
- en: The borders on the button images are much larger than those of the default buttons.
    So, we need to adjust the **Border** attribute to accommodate them. Values of
    15 for each side works well.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按钮图像的边框比默认按钮的边框大得多。因此，我们需要调整**边框**属性来适应它们。每边15的值效果很好。
- en: The text is also too small, so for the **Font Size** attribute choose a value
    of 40\. This will give us a large and easily readable text.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文本也太小，因此对于**字体大小**属性，选择一个值为40的值。这将给我们一个字体大且易于阅读的文本。
- en: For the **Label** element, we are only going to make two changes. First, the
    text is too small. So, it will also get a value of 40 for its font size. Second,
    we want the text to be centered in the GUI elements. That requires setting the
    alignment to middle center.![Time for action – styling the game](img/2014OT_02_07.png.jpg)
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于**标签**元素，我们只会进行两项更改。首先，文本太小。因此，它的字体大小也将设置为40。其次，我们希望文本在GUI元素中居中。这需要将对齐设置为中间中心。![操作时间
    - 为游戏添加样式](img/2014OT_02_07.png.jpg)
- en: Play the game now. It is already looking better or at least different. However,
    it is a little difficult to tell at a glance who controls which square. To fix
    this we are going to create two custom GUI Styles. To do this, expand the **Custom
    Styles** attribute of our `GameSkin` in the **Inspector** window. By default,
    one blank style is already in there. We are going to need two, but don't change
    the quantity just yet.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在就玩游戏吧。它看起来已经更好或者至少不同了。然而，一眼看去很难判断谁控制着哪个方块。为了解决这个问题，我们将创建两种自定义GUI样式。要做到这一点，请在我们**检查器**窗口中展开`GameSkin`的**自定义样式**属性。默认情况下，已经有一个空白样式在那里。我们需要两个，但暂时不要改变数量。
- en: Expand the custom GUI Style, by default called `Element 0`.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过默认名为`Element 0`的扩展自定义GUI样式。
- en: On clicking to the right of the **Name** attribute, more or less in the middle
    of the **Inspector** window, will allow us to rename the style. The name is very
    important. Whatever we call it here we need to call it exactly the same in code
    or it won't be used. Give it the name `XSquare` because it will be used to mark
    which squares are controlled by the X player.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**名称**属性右侧点击，大约在**检查器**窗口的中间位置，将允许我们重命名样式。名称非常重要。无论我们在这里叫什么，都需要在代码中完全相同地调用它，否则它将不会被使用。给它命名为`XSquare`，因为它将被用来标记由X玩家控制的方块。
- en: Inside of the **Normal** state, add the **XNormal** image to the **Background**
    attribute. The **Text Color** attribute can be left as black. We also need to
    adjust the font size and alignment properties to the same as we did for the **Label**
    element. So, set them to **40** and **MiddleCenter** respectively.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**正常**状态下，将**XNormal**图像添加到**背景**属性。**文本颜色**属性可以保持为黑色。我们还需要调整字体大小和对齐属性，使其与**标签**元素相同。因此，将它们设置为**40**和**MiddleCenter**。
- en: Now that we have created the first style, creating the second becomes fast and
    easy. Collapse the **XSquare** style.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经创建了第一个样式，创建第二个样式就变得快速且简单。折叠**XSquare**样式。
- en: Set the size of the **Custom Styles** attribute to **2**. When increasing the
    size of arrays in the Unity Editor, Unity duplicates whatever was the last item
    in the array to each of the new slots. So, we should now have two `XSquare` GUI
    Styles.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**自定义样式**属性的大小设置为**2**。在Unity编辑器中增加数组大小时，Unity会将数组中最后一个项目复制到每个新的槽位。因此，我们现在应该有两个`XSquare`
    GUI样式。
- en: Expand the second GUI Style and change its name to `Osquare`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展第二个GUI样式，并将其名称更改为`Osquare`。
- en: Also, replace the `XNormal` **Background** image with the `ONormal` image.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要将`XNormal`的**背景**图像替换为`ONormal`图像。
- en: Tip
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you are having trouble in dragging-and-dropping in the **Inspector** window,
    the `GameSkin` keeps losing focus perhaps; there is a lock at the top of the **Inspector**
    window. Clicking on that will stop the window from changing to anything else when
    a new object is selected. Clicking it again will toggle off this feature.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你发现在**检查器**窗口中拖放有困难，可能是`GameSkin`一直在失去焦点；在**检查器**窗口的顶部有一个锁定按钮。点击它将阻止窗口在选中新对象时切换到其他任何内容。再次点击它将关闭此功能。
- en: Just because we have our spiffy new custom GUI Styles, doesn't mean they will
    work automatically. But, just a little bit of coding will make them work. Inside
    our `DrawGameBoard` function of the `TicTacToeControl` script, we need to change
    the line that draws our label by adding a little bit to the end of it. The addition
    of a second string will tell the GUI system to look for a specific GUI Style.
    A little bit earlier in the function, we figure out who owns the square, is it
    X or O. By adding this to `Square` we create the names of our two custom GUI Styles,
    `XSquare` and `OSquare`.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然我们有了我们炫酷的新自定义GUI样式，但这并不意味着它们会自动工作。但是，只需一点点的编码就能让它们工作。在我们的`TicTacToeControl`脚本的`DrawGameBoard`函数内部，我们需要更改绘制标签的行，并在其末尾添加一些内容。添加第二个字符串将告诉GUI系统查找特定的GUI样式。在函数中更早的地方，我们确定谁拥有这个方块，是X还是O。通过添加到`Square`中，我们创建了我们的两个自定义GUI样式的名称，`XSquare`和`OSquare`。
- en: '[PRE27]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If you play the game now, you will see that when a player claims control of
    a square, our custom styles appear.![Time for action – styling the game](img/2014OT_02_08.png.jpg)
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在玩游戏，你会看到当玩家声称控制一个方块时，我们的自定义样式就会出现。![行动时间 - 设置游戏样式](img/2014OT_02_08.png.jpg)
- en: There is one more thing to do to change the look of our Tic-tac-toe game. Do
    you remember the title image that was created and for which we added a variable?
    Now is the time to place that. Inside of `TicTacToeControl` go to the `DrawOpening`
    function. To draw our image, we need to replace the call to `GUI.Label` with a
    call to `GUI.DrawTexture`. Instead of using GUI Styles, this function simply draws
    an image to the screen. It uses a `Rect` class, just as with all of our **Buttons**
    and **Labels**, to define a size and position. The image is, by default, stretched
    to fill the whole `Rect` class. For now, this suits us just fine.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要改变井字棋游戏的外观，还有一件事要做。你还记得创建的标题图像以及我们为其添加的变量吗？现在就是放置它的时刻。在`TicTacToeControl`中进入`DrawOpening`函数。为了绘制我们的图像，我们需要用`GUI.DrawTexture`的调用替换`GUI.Label`的调用。这个函数不是使用GUI样式，而是简单地将在屏幕上绘制一个图像。它使用`Rect`类，就像我们所有的**按钮**和**标签**一样，来定义大小和位置。默认情况下，图像会被拉伸以填充整个`Rect`类。目前，这非常适合我们。
- en: '[PRE28]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We can fix the stretching by updating the previous line of code, where we defined
    the `Rect` class for our title to accommodate. As you can see by the following
    code snippet, we use the width and height of `titleImage` to determine the width
    and height of `titleRect`. The `Rect` class now automatically determines how large
    it should be based on the size of our title image. If the `Rect` class is of the
    same size and shape as the image, it won't be stretched. In addition to that,
    because of the way we defined the `Rect` class for our **New Game** button, it
    will still be directly under and just as wide as our title image.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过更新定义标题`Rect`类的上一行代码来修复拉伸。正如以下代码片段所示，我们使用`titleImage`的宽度和高度来确定`titleRect`的宽度和高度。现在`Rect`类会根据标题图像的大小自动确定它应该有多大。如果`Rect`类与图像具有相同的大小和形状，它就不会被拉伸。此外，由于我们为**新游戏**按钮定义了`Rect`类，它仍然直接位于标题图像下方，并且与标题图像一样宽。
- en: '[PRE29]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: That is all there for styling our Tic-tac-toe game. Click on the **Play** button
    and take a look at all your hard work.![Time for action – styling the game](img/2014OT_02_09.png.jpg)
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是为井字棋游戏设置样式的全部内容。点击**播放**按钮，看看你所有的辛勤工作。![行动时间 - 设置游戏样式](img/2014OT_02_09.png.jpg)
- en: '*What just happened?*'
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We made our Tic-tac-toe game look great, or at least not like the defaults.
    We achieved this through the use of a handful of images and some custom GUI Skins
    and GUI Styles. With the addition of a special function for drawing textures on
    screen, we also add a unique title image to our opening screen.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们让我们的井字棋游戏看起来很棒，至少不像默认的。我们通过使用一些图像和一些自定义GUI皮肤和GUI样式实现了这一点。通过添加一个用于在屏幕上绘制纹理的特殊函数，我们还添加了一个独特的标题图像到我们的开场屏幕。
- en: Have a go hero – backgrounds
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄 - 背景
- en: Your challenge here is to make a background image and draw it behind the game.
    It also has to cover the whole of the screen. The default blue is great, but we
    could do so much better. As a note, whichever GUI element was drawn last is drawn
    on top, so think carefully about where to call the function to have the image
    drawn in the background. Also, since stretching is only good for exercising and
    rubber bands, take a look at also passing the function a `ScaleMode`, which is
    a special value type that Unity uses to determine how images should stretch. Look
    in the scripting reference or search online to find more information about it.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你的挑战是在游戏后面绘制一个背景图像，并且它必须覆盖整个屏幕。默认的蓝色很好，但我们可以做得更好。作为备注，无论哪个GUI元素是最后绘制的，它都会在最上面，所以仔细考虑在哪里调用函数以在背景中绘制图像。此外，由于拉伸只适用于锻炼和橡皮筋，请查看是否也传递一个`ScaleMode`函数，这是一个Unity使用的特殊值类型，用于确定图像应该如何拉伸。查看脚本参考或在网上搜索以获取更多信息。
- en: Dynamic positioning
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态定位
- en: You are probably thinking that it is all well and good that the game is all
    styled now, but everything is still sitting in the top-left corner of the screen.
    Well then, you are in luck. That is exactly the topic of this section. It is not
    enough to simply adjust the numbers in our `Rects` until our GUI is centered.
    While working with the Android platform and other mobile devices, we have to be
    prepared for a large variety of possibilities. Not every device that our games
    will be played on will have the same screen size. So, you may position your GUI
    to be centered on your tablet, but it will be far off screen on a phone.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为游戏现在样式齐全，但所有内容仍然都位于屏幕的左上角。那么，你很幸运。这正是本节的主题。仅仅调整我们`Rects`中的数字，直到我们的GUI居中是不够的。在处理Android平台和其他移动设备时，我们必须准备好应对各种可能性。不是我们游戏将在其上运行的所有设备都具有相同的屏幕尺寸。因此，你可能将GUI定位在平板电脑上居中，但在手机上它将远离屏幕。
- en: Time for action – the dynamic GUI
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 动态GUI
- en: We will be covering two excellent ways of dynamically adjusting our GUI to meet
    any screen requirements. The opening screen and the game over screen will both
    be centered. We will stretch the game board to fill the available space. The turn
    indicator text will also be set up to automatically change position based on the
    screen orientation.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍两种动态调整GUI以适应任何屏幕要求的方法。开场屏幕和游戏结束屏幕都将居中。我们将拉伸游戏板以填充可用空间。回合指示文本也将根据屏幕方向自动更改位置。
- en: Again, let's start with our main menu. Open up the `TicTacToeControl` script
    and go to the `DrawOpening` function.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，让我们从主菜单开始。打开`TicTacToeControl`脚本并转到`DrawOpening`函数。
- en: To center the menu, we will wrap up the contents as a GUI group by adding the
    following line of code at the beginning of the `DrawOpening` function. Think of
    GUI's grouping as **picture-in-picture** (**PIP**) that some televisions can do.
    Pick a rectangle section on screen and draw some other channel in it. So, first
    we are deciding where to draw our group. We do this by finding the center of the
    screen, `Screen.width` and `Screen.height` is divided by two. But, because GUI
    content is positioned at the top-left corner, we must subtract half our content's
    size to find that corner. For the width, that is simply the width of our title
    image. But the height is a combination of the image and the button below.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使菜单居中，我们将在`DrawOpening`函数的开始处添加以下代码行，将内容包装为GUI组。将GUI的分组想象成某些电视可以做的**画中画**（**PIP**）。在屏幕上选择一个矩形区域，并在其中绘制另一个频道。所以，首先我们决定在哪里绘制我们的组。我们通过找到屏幕的中心，将`Screen.width`和`Screen.height`除以二来实现这一点。但是，由于GUI内容定位在左上角，我们必须减去我们内容大小的一半以找到那个角落。对于宽度，那只是我们的标题图像的宽度。但高度是图像和下面的按钮的组合。
- en: '[PRE30]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `BeginGroup` function of the GUI is what gives us the PIP effect. Any GUI
    elements that are drawn after a call to this function are confined to the `Rect`
    class that was passed to the function. Instead of positions starting from the
    top-left corner of the screen, elements within the group will start at the top-left
    corner of the group `Rect`. Anything that extends beyond the edges of the group
    is also not drawn, just as if it extended beyond the edges of the screen.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GUI的`BeginGroup`函数为我们提供了画中画效果。在调用此函数之后绘制的任何GUI元素都将限制在传递给函数的`Rect`类中。与从屏幕左上角开始的位置不同，组内的元素将从组的左上角`Rect`开始。任何超出组边缘的内容也不会绘制，就像它超出了屏幕边缘一样。
- en: '[PRE31]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Before we can see the group in action, we must add a line to the end of our
    `DrawOpening` function. `EndGroup` is the direct counterpart to `BeginGroup`.
    If ever you use `BeginGroup`, there must be a corresponding call to `EndGroup`.
    Should you fail to pair up the function calls, Unity will make no end of complaints
    until the problem is fixed. It is really quite annoying.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们能够看到组的作用之前，我们必须在 `DrawOpening` 函数的末尾添加一行。`EndGroup` 是 `BeginGroup` 的直接对应物。如果你使用了
    `BeginGroup`，那么必须有相应的 `EndGroup` 调用。如果你没有配对函数调用，Unity 会一直抱怨，直到问题得到解决。这真的很烦人。
- en: '[PRE32]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With that line added, play the game. The main menu will now center itself. It
    will do this no matter the screen size. Also, it will do this whether the screen
    is in landscape or in portrait mode. In this case, the trick to keeping everything
    on screen is to plan for the smallest screen size and make images and GUI elements
    that fit accordingly.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加了这一行后，开始玩游戏。主菜单现在将自动居中。无论屏幕大小如何，它都会这样做。此外，无论屏幕是横屏还是竖屏模式，它都会这样做。在这种情况下，保持所有内容都在屏幕上的技巧是计划最小的屏幕尺寸，并制作相应大小的图像和
    GUI 元素。
- en: Skipping ahead a little, we can use a similar method for centering the game
    over screen. Add the following line of code to the beginning of the `DrawGameOver`
    function. You can see that we are doing the same thing we did a moment ago. Figure
    out where the center of the screen is and subtract half of the total size of our
    content. In this case we supplied solid numbers instead of keying off the size
    of an image. Also, because the math is easy, we already did the divisions to come
    up with `150` and `75`.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 快进一点，我们可以使用类似的方法来居中游戏屏幕。在 `DrawGameOver` 函数的开头添加以下代码行。你可以看到我们正在做刚才做过的事情。确定屏幕的中心，并减去内容总大小的一半。在这种情况下，我们提供了具体的数字而不是根据图像的大小来设置。此外，因为数学很简单，我们已经在计算中完成了除法，得出了
    `150` 和 `75`。
- en: '[PRE33]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Be sure to add your `EndGroup` function call to the end of the `DrawGameOver`
    function.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一定要在 `DrawGameOver` 函数的末尾添加你的 `EndGroup` 函数调用。
- en: '[PRE34]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: After that, find the line where we define the `winnerRect variable` class. We
    need to change it so it is easier to adjust the size and fit the contents, should
    we want to. Because of the way we set up the **winner** label and **main menu**
    button, this will cause each to take up the whole width of the group. They will
    also split the available height evenly; hence the division is by two.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，找到定义 `winnerRect` 变量类的行。我们需要修改它，使其更容易调整大小并适应内容，如果我们想要的话。由于我们设置了 **winner**
    标签和 **主菜单** 按钮，这会导致每个都占用整个组的宽度。它们还会平均分割可用的高度；因此，除以二。
- en: '[PRE35]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now we have the tricky part to do. For the game board, we want it to expand
    evenly so that it fills whichever direction is shortest. The turn indicator should
    be centered in the remaining space. Because the board needs to dynamically expand
    and the turn indicator needs to be either in the right or bottom of the screen,
    based on orientation, we can't get away with using our GUI group functions. Instead,
    we first need to figure out which side of our screen is smaller, the width or
    the height. This is fairly simple with the following lines of code added to the
    beginning of the `DrawGameBoard` function. Recognize the conditional statement,
    our good old friend? First, we create a variable to hold the result of comparing
    the width and height of the screen; we will be using it again later. If the width
    is smaller, obviously the small side is the width; otherwise it is the height.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们来到了一个棘手的部分。对于游戏板，我们希望它均匀扩展，以便填充最短的方向。回合指示器应该位于剩余空间的中心。因为游戏板需要动态扩展，而回合指示器需要根据方向在屏幕的右侧或底部，所以我们不能仅仅使用我们的
    GUI 组函数。相反，我们首先需要确定屏幕的哪一侧更小，是宽度还是高度。这通过在 `DrawGameBoard` 函数开头添加以下几行代码来实现。你能认出这个条件语句，我们那位老朋友吗？首先，我们创建一个变量来保存屏幕宽度和高度的比较结果；我们稍后会再次使用它。如果宽度更小，显然短边是宽度；否则就是高度。
- en: '[PRE36]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Next we change our width and height definitions. Because the game board is a
    3 x 3 grid, once we have the small side it is a simple matter to figure out how
    big the squares should be to fill the space. The change to the height is to keep
    the board squares actually square. Perhaps you remember from your first geometry
    lessons? The width and height of the sides of a square are equal.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们更改宽度和高度的定义。因为游戏板是一个 3 x 3 的网格，一旦我们有了短边，就可以简单地计算出应该有多大才能填满空间。对高度的改变是为了保持游戏板的方块实际上是正方形。也许你还记得你的第一次几何课程？正方形的边长是相等的。
- en: '[PRE37]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Playing the game at this point, we will be able to experience a game board that
    scales with our game screen. Try it out!![Time for action – the dynamic GUI](img/2014OT_02_10.png.jpg)
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个阶段玩游戏，我们将能够体验到一个与游戏屏幕一起缩放的棋盘。试试看吧！！[行动时间 – 动态GUI](img/2014OT_02_10.png.jpg)
- en: Remember when we were connecting Unity Remote? Use the drop-down menu in the
    top-left corner of the **Game** window to select different screen sizes and orientations.
    This does, however, reveal another small error. The turn indicator text sometimes
    appears over the top of our game board. Other times it may be beyond the edges
    of the screen. Or, perhaps you already noticed that one? Either way, to make it
    better we need to find the `Rect` class that will cover the remaining negative
    space.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记得我们连接Unity Remote的时候吗？使用**游戏**窗口左上角的下拉菜单选择不同的屏幕尺寸和方向。然而，这却揭示了一个小错误。回合指示器的文本有时会出现在我们的游戏板上方。有时它可能超出了屏幕的边缘。或者，也许你已经注意到了这一点？无论如何，为了使其更好，我们需要找到将覆盖剩余负空间的`Rect`类。
- en: After the initial definition of our `turnRect`, add the following code snippet.
    Using our conditional friends, we figured out all we need to place the `Rect`
    class in the negative space. If the width is smaller in portrait mode, the negative
    space starts at the left side of the screen, zero. The y position of the space
    begins where the board ends, the equivalent of the width; it is a square board,
    after all. The total width of the negative space is also equivalent to the width
    of the screen. The height becomes whatever is left over from the difference between
    the height and the width. If we are in landscape mode instead, the height being
    smaller than the width, the positioning is largely determined in the same way.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们定义`turnRect`的初始定义之后，添加以下代码片段。使用我们的条件朋友，我们计算出所有需要将`Rect`类放置在负空间中的内容。如果在纵向模式下宽度较小，负空间从屏幕的左侧开始，即零。空间的位置从游戏板的结束处开始，相当于宽度；毕竟，它是一个正方形板。负空间的总宽度也相当于屏幕的宽度。高度成为高度和宽度之间差异的剩余部分。如果我们处于横向模式，高度小于宽度，定位方式大致相同。
- en: '[PRE38]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This is all well and good. Looks pretty good with the turn text actually positioned
    where it can easily be seen and read. But, in some of those screen sizes there
    is an awful lot of empty space. If only there was some way we could scale the
    text to better fit the space. It just so happens that there is a good way to do
    just that. After we are done messing with the turn indicator's `Rect`, we can
    add the following line of code. This touch of code gets the label GUI Style from
    the current GUI Skin and creates a duplicate. In code, if we ever create a new
    GUI Style and pass another one as the argument, all of the values are copied into
    the new GUI Style. This allows us to cause temporary and dynamic changes without
    ruining the whole GUI Skin being used.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这一切都很不错。当回合文本实际放置在易于看到和阅读的位置时，看起来相当不错。但是，在某些屏幕尺寸下，有大量的空白空间。如果有一种方法可以调整文本以更好地适应空间就好了。恰好有一种很好的方法可以做到这一点。在我们完成对回合指示器的`Rect`的修改后，我们可以添加以下一行代码。这段代码从当前的GUI皮肤中获取标签GUI样式并创建一个副本。在代码中，如果我们创建一个新的GUI样式并将另一个样式作为参数传递，所有值都会复制到新的GUI样式中。这允许我们进行临时和动态的更改，而不会破坏正在使用的整个GUI皮肤。
- en: '[PRE39]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the next line of code we'll adjust the font size. To do this we have to figure
    out how much space is left on the long side of the screen after the game board
    is scaled up. Adding the width and height of the screen results in the total amount
    of screen distance available. By subtracting the smaller of the two sides, the
    distance that the game board covers multiplied by two, we are left with the excess
    negative space. Dividing all of that by one hundred, the amount of space that
    we had previously used for our turn indicator, will scale the font size to proportionately
    fit the change in space. It is finally wrapped in an explicit conversion to the
    integer type because the font size value must be defined as an integer.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一行代码中，我们将调整字体大小。为了做到这一点，我们必须计算出在游戏板放大后屏幕长边剩余的空间量。将屏幕的宽度和高度相加得到可用的总屏幕距离。通过减去两个边中较小的一边，即游戏板覆盖的距离乘以二，我们得到多余的负空间。将所有这些除以一百，即我们之前用于我们的回合指示器的空间量，将字体大小按比例调整以适应空间的变化。最后，通过显式转换为整数类型，因为字体大小值必须定义为整数。
- en: '[PRE40]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: To actually see this dynamic font size in action, we need to make a change to
    the line that draws the turn indicator. We change the call to the `Label` function
    to use the temporary style. Instead of providing the name of the GUI Style to
    GUI functions, we can provide a specific GUI Style. The function will then use
    this style to draw the GUI element.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要真正看到这个动态字体大小在行动中的效果，我们需要更改绘制回合指示器的行。我们将对`Label`函数的调用更改为使用临时样式。我们不再向GUI函数提供GUI样式的名称，而是可以提供一个特定的GUI样式。然后，该函数将使用此样式来绘制GUI元素。
- en: '[PRE41]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Try it out. By clicking on the **Game window** tab and dragging it into the
    **Game** window, you can undock the window and make it free floating. Changing
    the aspect ratio, that drop-down menu in the top-right corner of the **Game**
    window, to **Free Aspect** allows us to freely re-size the window and witness
    our great work in action.![Time for action – the dynamic GUI](img/2014OT_02_11.png.jpg)
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试一下。通过点击**游戏窗口**选项卡并将其拖入**游戏**窗口，你可以取消停靠窗口并使其自由浮动。将**游戏**窗口右上角的下拉菜单（**纵横比**）更改为**自由纵横比**，我们可以自由调整窗口大小并见证我们的伟大作品在行动中的效果。![行动时间
    – 动态GUI](img/2014OT_02_11.png.jpg)
- en: '*What just happened?*'
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We made our game change dynamically based on the screen of our devices. Both
    of the menu screens will center themselves. We also caused our game board to grow
    and shrink until it fills as much of the screen as it can. We then used a carefully
    applied bit of code magic to make the turn indicator automatically position itself
    and change font size to fill the remaining space.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们让我们的游戏根据我们的设备屏幕动态变化。两个菜单屏幕都会居中。我们还让我们的游戏板根据屏幕大小增长和缩小，直到尽可能填满屏幕。然后，我们使用一点精心应用的代码魔法，使回合指示器自动定位并更改字体大小以填充剩余的空间。
- en: Have a go hero – scaling menus
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄 – 缩放菜单
- en: The second challenge is a little tougher. Continue to use the GUI groups, but
    make the opening screen and the game over screen scale with the screen size. If
    you want a subchallenge with this one, see what you can do about scaling the text
    with it as well. And, don't forget about the text used to indicate control of
    the game board squares.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个挑战稍微有点困难。继续使用GUI组，但让开场屏幕和游戏结束屏幕根据屏幕大小缩放。如果你想对这个挑战进行子挑战，看看你能否同时缩放文本。此外，别忘了用于指示游戏板方格控制的文本。
- en: If you want to prepare for even more devices, change the Rects that we use throughout
    the section. Wherever we used specific numbers for position or size on screen,
    change them to percent. You will have to calculate the pixel size using percent
    and the size of the screen. That calculated amount can then be passed to and used
    in our Rects.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想为更多设备做准备，请更改本节中我们使用的矩形（Rects）。无论我们在屏幕上使用特定数字来表示位置或大小，都要将它们改为百分比。你将需要使用百分比和屏幕大小来计算像素大小。然后，可以将计算出的数值传递给我们的矩形并使用它。
- en: A better way to build to device
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更好地构建到设备的方法
- en: Now for the part of the build process that everyone itches to learn. There is
    a quicker and easier way to have your game built and playing on your Android device.
    The long and complicated way is still very good to know. Should this shorter method
    fail, and it will at some point, it is helpful to know the long method so you
    can debug any errors. Also, the short path is only good for building to a single
    device. If you have multiple devices and a large project, it will take significantly
    more time to load them all with the short path.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是构建过程中每个人都很想学习的一部分。有一个更快更简单的方法可以让你的游戏在Android设备上构建并运行。虽然长而复杂的方法仍然很好，但如果你使用这个较短的路径失败，并且它最终会失败，了解长方法将有助于调试任何错误。此外，短路径仅适用于构建到单个设备。如果你有多个设备和大项目，使用短路径将需要更多的时间来加载它们。
- en: Time for action – build and run
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 构建并运行
- en: 'With this alternate build method, we can quickly and easily test games on our
    devices as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种替代构建方法，我们可以快速轻松地在我们的设备上测试游戏，如下所示：
- en: Start by opening the **Build Settings** window. Remember, it can be found under
    **File** at the top of the Unity Editor.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开**构建设置**窗口。记住，它可以在Unity编辑器的**文件**菜单中找到。
- en: Click on the **Add Current** button to add our current scene, also the only
    scene, to the list of **Scenes In Build**. If this list is empty, there is no
    game.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加当前**按钮，将我们的当前场景（也是唯一场景）添加到**构建中的场景**列表中。如果这个列表为空，则没有游戏。
- en: Be sure to change your **Platform** to **Android**, if you haven't already done
    so. It is after all still the point of this book.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保将你的**平台**更改为**Android**，如果你还没有这样做的话。毕竟，这本书的重点就是这一点。
- en: Do not forget to set the **Player Settings**. Click on the **Player Settings**
    button to open them up in the **Inspector** window. Do you remember this from
    [Chapter 1](ch01.html "Chapter 1. Saying Hello to Unity and Android"), *Saying
    Hello to Unity and Android*.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要忘记设置**玩家设置**。点击**玩家设置**按钮，在**检查器**窗口中打开它们。你还记得[第1章](ch01.html "第1章。向Unity和Android问好")中的内容吗，*向Unity和Android问好*。
- en: At the top, set the **Company Name** and **Product Name** fields. Values of
    `TomPacktAndBegin` and `Ch2 TicTacToe` respectively will match the included completed
    project. Remember, these are seen by the people playing your game.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶部，设置**公司名称**和**产品名称**字段。`TomPacktAndBegin`和`Ch2 TicTacToe`的值将匹配包含的完成项目。记住，这些值会被玩游戏的人看到。
- en: The **Bundle Identifier** field under **Other Settings** needs to be set as
    well. The format is still `com.CompanyName.ProductName`, so `com.TomPactAndBegin.Ch2.TicTacToe`
    will work well.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**其他设置**下的**包标识符**字段也需要设置。格式仍然是`com.CompanyName.ProductName`，所以`com.TomPactAndBegin.Ch2.TicTacToe`将很好地工作。
- en: So that we can see our cool dynamic GUI in action on a device, there is one
    other setting that should be changed. Click on **Resolution** and **Presentation**
    to expand the options.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让我们能在设备上看到我们酷炫的动态GUI的实际效果，还有一个其他设置需要更改。点击**分辨率**和**演示**以展开选项。
- en: We are interested in **Default Orientation**. The default is **Portrait**, but
    this option means the game will be fixed in the portrait display mode. Click on
    the drop-down menu and select **Auto Rotation**. This option tells Unity to automatically
    adjust the game to be upright in whichever orientation the device is being held.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们对**默认方向**感兴趣。默认是**纵向**，但这意味着游戏将固定在纵向显示模式。点击下拉菜单并选择**自动旋转**。此选项告诉Unity自动调整游戏，使其在设备被持握的任何方向上都是竖直的。
- en: The new set of options that popped up when **Auto Rotation** was selected allow
    for the limiting of the orientations that are supported. Perhaps you are making
    a game that needs to be wider and held in landscape orientation. By unchecking
    **Portrait** and **Portrait Upside Down**, Unity will still adjust (but only for
    the remaining orientations). On your Android device, along one of the shorter
    sides, are the controls of some sort usually a home, menu, back, and search set
    of buttons. This side is generally recognized as the bottom of the device and
    it is the position of these buttons that dictates what each orientation is. **Portrait**
    is when those buttons are down relative to the screen. **Landscape Right** is
    when they are to the right. The pattern begins to come clear, does it not?
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当选择**自动旋转**时出现的新的选项集允许限制支持的旋转方向。也许你正在制作一个需要更宽屏幕并横屏持握的游戏。通过取消勾选**纵向**和**纵向颠倒**，Unity仍然会调整（但仅限于剩余的旋转方向）。在你的Android设备上，沿着较短的边，通常有一些控制按钮，通常是一个主页、菜单、返回和搜索按钮组。这一侧通常被认为是设备的底部，这些按钮的位置决定了每个方向。**纵向**是指这些按钮相对于屏幕向下。**横向右**是指它们在右侧。模式开始变得清晰，不是吗？
- en: For now, leave all of the orientation options checked and we will go back to
    **Build Settings**.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，保留所有方向选项的勾选，我们将返回到**构建设置**。
- en: The next step (and this is very important) is to connect your device to your
    computer and give it a moment to be recognized. If your device is not first connected
    to your computer, this shorter build path will fail.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步（这一点非常重要）是将你的设备连接到你的电脑，并给它一点时间来被识别。如果你的设备不是首先连接到电脑，这个较短的构建路径将会失败。
- en: In the bottom-right corner of the **Build Settings** window, click on the **Build
    And Run** button. You will be asked to give the application file, the APK, a relevant
    name and save it to an appropriate location. A name `Ch2_TicTacToe.apk` will be
    fine and it is suitable enough to save the file to the desktop.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**构建设置**窗口的右下角，点击**构建并运行**按钮。你将被要求为应用程序文件、APK文件提供一个相关名称并将其保存到适当的位置。名称`Ch2_TicTacToe.apk`将很好，并且足够适合将其保存到桌面。
- en: Click on **Save** and sit back to watch the wonderful loading bar that is provided.
    If you paid attention to the loading bar when we built the *Hello World* project
    in [Chapter 1](ch01.html "Chapter 1. Saying Hello to Unity and Android"), *Saying
    Hello to Unity and Android*, you will notice that there is an extra step taken
    this time around. After the application is built, there is a pushing to device
    step. This means the build was successful and Unity is now putting the application
    on your device and installing it. Once done, the game will be started on the device
    and the loading bar will be finished.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**保存**并坐下来观看提供的精彩加载进度条。如果你在[第1章](ch01.html "第1章. 与Unity和Android打招呼")中构建*Hello
    World*项目时注意到了加载进度条，*与Unity和Android打招呼*，你会注意到这次多了一个步骤。在应用程序构建完成后，会有一个推送到设备步骤。这意味着构建成功，Unity现在正在将应用程序放到你的设备上并安装它。一旦完成，游戏将在设备上启动，加载进度条将结束。
- en: '*What just happened?*'
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We just learned about the **Build And Run** button provided by the **Build Settings**
    window. Quick, easy, and free from command prompt pain; isn't the short build
    path wonderful? But if the build process fails for any reason including being
    unable to find the device, the application file will not be saved. You will have
    to sit through the entire build process again, if you want to try installing again.
    This isn't so bad for our simple Tic-tac-toe game, but might consume a lot of
    time for a larger project. Also, you can only have one Android device connected
    to your computer while building. Any more and the build process is a guaranteed
    failure. Unity also doesn't check for multiple devices until after it has gone
    through the rest of the potentially long build process.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚学习了**构建和运行**按钮，它是由**构建设置**窗口提供的。快速、简单，且免受命令提示符的痛苦；短构建路径不是很好吗？但如果构建过程因任何原因失败，包括无法找到设备，应用程序文件将不会保存。如果你想再次尝试安装，你必须再次经历整个构建过程。这对我们简单的井字游戏来说不是什么大问题，但对于更大的项目可能会消耗很多时间。此外，在构建过程中，你只能将一台Android设备连接到你的电脑。如果连接更多，构建过程将肯定失败。Unity在完成其余可能很长的构建过程之前，也不会检查多个设备。
- en: Other than those words of caution, the **Build And Run** option is really quite
    nice. Let Unity handle the hard part of getting the game to your device. This
    gives us much more time to focus on testing and making a great game.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些警告之外，**构建和运行**选项实际上非常好。让Unity处理将游戏传送到设备上的困难部分。这让我们有更多时间专注于测试和制作一款优秀的游戏。
- en: Have a go hero – single player mode
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试英雄 – 单人模式
- en: This is a tough one. Create a single player mode. You will have to start by
    adding an extra game state. Is the choice of `MultiPlayer` for a game state starting
    to make sense? The opening screen is going to need an extra button for selecting
    the second game mode. Also, any logic for the computer player should go in the
    `Update` function that is provided by the `MonoBehaviour` class. The computer
    needs to take its turn before we check for victory in `LateUpdate`. The `Update`
    function is just the place to do it. Also, take a look at `Random.Range` for randomly
    selecting a square to take control of. Or, you could do a little more work and
    make the computer search for a square where it can win or create a line of two
    matches.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个难题。创建一个单人模式。你将不得不先添加一个额外的游戏状态。对于游戏状态选择`多人`是否开始有意义？开屏将需要一个额外的按钮来选择第二种游戏模式。此外，任何关于电脑玩家的逻辑都应该放在由`MonoBehaviour`类提供的`Update`函数中。电脑需要在我们在`LateUpdate`中检查胜利之前走它的回合。`Update`函数正是做这件事的地方。此外，看看`Random.Range`用于随机选择一个方块来控制。或者，你可以做更多的工作，让电脑搜索一个可以获胜的方块或创建一条两连胜的线路。
- en: Summary
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: At this point, you should be familiar with Unity's GUI system including GUI
    Skins, GUI Styles, and a variety of GUI functions.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该已经熟悉了Unity的GUI系统，包括GUI皮肤、GUI样式以及各种GUI功能。
- en: In this chapter, we learned all about the GUI by creating a Tic-tac-toe game.
    We first became familiar with drawing buttons and the like to the GUI. After delving
    into the depths and gaining understanding of GUI Styles and GUI Skins, we applied
    the knowledge to make our game look even better. The game continued to improve
    when we added some dynamic positioning to our GUI elements. The opening and closing
    screens became centered, while the game board dynamically scaled to fill the screen.
    Finally, we explored an alternative build method for putting our game onto devices.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过创建井字棋游戏学习了所有关于GUI（图形用户界面）的知识。我们首先熟悉了在GUI上绘制按钮等元素。在深入研究并理解了GUI样式和GUI皮肤之后，我们将这些知识应用到我们的游戏中，使其外观更加出色。当我们为GUI元素添加一些动态定位后，游戏继续改进。开场和结束屏幕居中，而游戏板动态缩放以填充屏幕。最后，我们探索了将我们的游戏上传到设备上的另一种构建方法。
- en: 'In the next chapter, we will be starting a new and more complex game. The Tank
    Battle game that we will be creating will be used to gain understanding with the
    basic building blocks of any game: meshes, materials, and animations. When all
    is done, we will be able to drive a tank around a colorful city and shoot animated
    targets.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始一个新的、更复杂的游戏。我们将创建的坦克大战游戏将用于理解任何游戏的基本构建块：网格、材质和动画。当一切完成时，我们将能够驾驶坦克在五彩斑斓的城市中穿梭，并射击动画目标。
