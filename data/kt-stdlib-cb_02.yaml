- en: Expressive Functions and Adjustable Interfaces
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式函数和可调整接口
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下菜谱：
- en: Declaring adjustable functions with default parameters
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明具有默认参数的可调整函数
- en: Declaring interfaces containing default implementations
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明包含默认实现的接口
- en: Extending functionalities of classes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展类的功能
- en: Destructuring types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解构类型
- en: Returning multiple data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回多个数据
- en: Inlining parameters of closure type
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内联闭包类型的参数
- en: Infix notations for functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的内联表示法
- en: Smart types checking with generic reified parameters
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用泛型重载参数的智能类型检查
- en: Overloading operators
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重载运算符
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter will focus on exploring a number of Kotlin features that can help
    to write functions and interfaces that are robust, flexible, and clean. After
    reading the following recipes, you will understand the language-specific support
    and approach for boilerplate code reduction and runtime performance improvements.
    You will also understand the way functions of the standard library are implemented
    under the hood and how to work with them effectively.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点探讨一些 Kotlin 特性，这些特性可以帮助编写健壮、灵活且干净的函数和接口。阅读以下菜谱后，您将了解语言特定的支持和方法，用于减少样板代码和运行时性能改进。您还将了解标准库函数在底层是如何实现的，以及如何有效地与它们一起工作。
- en: Declaring adjustable functions with default parameters
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明具有默认参数的可调整函数
- en: 'When creating new functions, we often need to allow some of their parameters
    to be optional. This forces us to use method overloading to create multiple function
    declarations with the same name but different sets of arguments related to different
    use cases and scenarios. Usually, under the hood, each variant of the function
    is calling the base function with the default implementation. Let''s consider
    a simple example of a function that calculates a displacement of an object moving
    with a constant acceleration rate:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建新函数时，我们经常需要允许一些参数是可选的。这迫使我们使用方法重载来创建具有相同名称但与不同用例和场景相关的不同参数集的多个函数声明。通常，在底层，每个函数变体都会调用具有默认实现的基本函数。让我们考虑一个简单的函数示例，该函数计算以恒定加速度率移动的物体的位移：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We might also need to provide a displacement calculation for the scenario where
    the initial speed of the object is always equal to zero. In such a case, we would
    end up with overloading the basic function in the following manner:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能还需要为对象初始速度始终等于零的情况提供一个位移计算。在这种情况下，我们最终会以以下方式对基本函数进行重载：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'However, Kotlin allows you to reduce multiple declarations and to handle a
    number of different use cases with a single function having optional parameters.
    In this recipe, we are going to design an adjustable version of the `calculateDisplacement()`function
    with an optional `initialSpeed: Float`parameter.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，Kotlin 允许您通过单个具有可选参数的函数来减少多个声明，并处理多种不同的用例。在本菜谱中，我们将设计一个具有可选 `initialSpeed:
    Float` 参数的可调整版本的 `calculateDisplacement()` 函数。'
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s declare the basic implementation for the function:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为该函数声明基本实现：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let's declare a default value for the `initialSpeed` parameter*:*
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为 `initialSpeed` 参数声明一个默认值：*
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We''ve declared a default value for the `initialSpeed`parameter, equal to `0`.
    Once we have a default value assigned, the `initialSpeed`parameter becomes an
    optional one. We can now omit it while invoking the function, as shown in the
    following example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为 `initialSpeed` 参数声明了一个默认值，等于 `0`。一旦我们分配了默认值，`initialSpeed` 参数就变成了可选的。现在，我们可以在调用函数时省略它，如下面的示例所示：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Note that, if we are omitting some of the parameters and using their default
    values, we have to specify the values of the other parameters together with their
    names explicitly. This allows the compiler to map the values to the specific parameters.
    Of course, we are able to override the default value using the standard way:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果我们省略了一些参数并使用它们的默认值，我们必须明确指定其他参数的值及其名称。这允许编译器将值映射到特定的参数。当然，我们能够使用标准方式覆盖默认值：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: See also
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Kotlin makes it possible to declare interfaces containing default function implementations.
    You can learn more about this feature in the *Declaring interfaces containing
    default implementations* recipe.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin 使得声明包含默认函数实现的接口成为可能。您可以在 *声明包含默认实现的接口* 菜谱中了解更多关于此功能的信息。
- en: Declaring interfaces containing default implementations
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明包含默认实现的接口
- en: Kotlin makes the interface a powerful language element by offering the possibility
    to declare default implementations for its functions and to define default values
    of its properties. Those features bring the interface to a whole new level, allowing
    you to use it for more advanced applications than simple contract declarations.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 通过提供为其函数声明默认实现和定义其属性默认值的能力，使接口成为一个强大的语言元素。这些功能将接口提升到了一个新的水平，允许你将其用于比简单合同声明更高级的应用程序。
- en: In this recipe, we are going to define a reusable interface responsible for
    validating email address values entered by a user into the input field in an abstract
    registration form. The interface will provide two functions. The first one is
    responsible for parsing the email address and deciding if the given value is a
    valid email address, and the second one responsible for extracting a user's login
    from the email text entered into the form.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将定义一个可重用的接口，用于验证用户在抽象注册表单的输入字段中输入的电子邮件地址值。该接口将提供两个函数。第一个函数负责解析电子邮件地址并决定给定的值是否为有效的电子邮件地址，第二个函数负责从表单中输入的电子邮件文本中提取用户的登录名。
- en: Getting ready
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The declaration of an interface with a default function implementation is easy.
    Instead of declaring the function header, we need to include its body too:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 声明具有默认函数实现的接口很简单。我们不需要声明函数头，还需要包括其体：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How to do it...
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Declare a new interface called `EmailValidator`:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个新的接口，称为 `EmailValidator`：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add a string property responsible for holding the current text input:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个字符串属性，用于存储当前文本输入：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add the `isEmailValid()` function to the interface:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `isEmailValid()` 函数添加到接口中：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the `getUserLogin()` function:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `getUserLogin()` 函数：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Now, let''s give it a try and take a look at how we can use the `EmailValidator`
    interface in action. Let''s assume we have a `RegistrationForm` class containing
    a hook method that is invoked every time the input text is modified:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们试一试，看看我们如何在实际操作中使用 `EmailValidator` 接口。假设我们有一个 `RegistrationForm` 类，它包含一个钩子方法，每次输入文本被修改时都会被调用：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To make use of our `EmailValidator` interface, we need to declare a class that
    is implementing it. We can modify the `RegistrationForm` class to implement the `EmailValidator` interface:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用我们的 `EmailValidator` 接口，我们需要声明一个实现该接口的类。我们可以修改 `RegistrationForm` 类以实现 `EmailValidator`
    接口：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Every time the `onInputUpdated()` function is invoked, we are updating the
    `input: String` property declared in the `EmailValidator` interface. Once it is
    up to date, we are using the `EmailValidator` interface functions `isEmailValid()`
    and `getUserLogin()` values. Extracting the function implementations to the interface
    makes it possible to reuse them and integrate them easily in a number of classes.
    The only part that needs an actual implementation is the `input` property of the
    `EmailValidator` interface, which holds the current state of the text inserted
    by the user. The smooth way of integrating the `EmailValidator` interface makes
    it great when it comes to reusability and versatility of the application in different
    scenarios.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '每次调用 `onInputUpdated()` 函数时，我们都会更新在 `EmailValidator` 接口中声明的 `input: String`
    属性。一旦更新完成，我们就使用 `EmailValidator` 接口的 `isEmailValid()` 和 `getUserLogin()` 函数值。将函数实现提取到接口中使得它们可以被重用，并轻松地集成到多个类中。唯一需要实际实现的部分是
    `EmailValidator` 接口的 `input` 属性，它存储用户插入的文本的当前状态。以平滑的方式集成 `EmailValidator` 接口使其在可重用性和适应不同场景的应用程序中表现出色。'
- en: There's more...
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: It's important to keep in mind that, although we can define a default function
    implementation in the interface, we are not able to instantiate default values
    for interface properties. Unlike the class properties, properties of an interface
    are abstract. They don't have backing fields that could hold a current value (state).
    If we declare a property inside an interface, we need to implement it in the class
    or object that implements this interface. This is the main difference between
    interfaces and abstract classes. Abstract classes can have constructors and can
    store properties along with their implementations.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，尽管我们可以在接口中定义默认函数实现，但我们无法为接口属性实例化默认值。与类属性不同，接口属性是抽象的。它们没有可以存储当前值（状态）的后备字段。如果我们在一个接口中声明一个属性，我们需要在实现该接口的类或对象中实现它。这是接口和抽象类之间的主要区别。抽象类可以有构造函数，可以存储属性及其实现。
- en: 'As with Java, we can''t extend multiple classes; however, we can implement
    multiple interfaces. When we have a class implementing multiple interfaces containing
    default implementations, we are at risk of dealing with conflicts caused by functions
    having the same signatures:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 与Java一样，我们不能扩展多个类；然而，我们可以实现多个接口。当我们有一个类实现了包含默认实现的多个接口时，我们可能会遇到由具有相同签名的函数引起的冲突：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this case, we need to override the `foo()` function explicitly to resolve
    the conflict:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们需要显式重写`foo()`函数以解决冲突：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Otherwise, we would get the following error:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们会得到以下错误：
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: See also
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: A similar feature of Kotlin is the ability to declare default values of functions'
    parameters. You can learn more about it in the *Declaring adjustable functions
    with default parameters *recipe.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin的一个类似特性是能够声明函数参数的默认值。您可以在*使用默认参数声明可调整函数*菜谱中了解更多信息。
- en: Extending functionalities of classes
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展类的功能
- en: While working on implementing new features or refactoring of existing code,
    we often end up extracting some part of the code to functions in order to reuse
    them in different places. If the extracted function is atomic enough, we often
    end up exporting it to external utility classes whose primary purpose is to extend
    functionalities of existing classes. Kotlin provides an interesting alternative
    to the utility classes. It offers a built-in feature allowing us to extend functionalities
    of other classes with *extension functions* and *extension properties*.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现新功能或重构现有代码时，我们经常将代码的一部分提取到函数中，以便在不同的地方重用。如果提取的函数足够原子化，我们通常会将它导出到外部实用工具类中，这些类的首要目的是扩展现有类的功能。Kotlin提供了一个有趣的替代方案。它提供了一个内置功能，允许我们使用*扩展函数*和*扩展属性*来扩展其他类的功能。
- en: 'In this recipe, we are going to extend the functionality of the `Array<T>`
    classand add a `swap(a:T, b: T)`extension function to it, which is responsible
    for changing places of a two given elements of the array.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个菜谱中，我们将扩展`Array<T>`类的功能，并向其添加一个`swap(a:T, b: T)`扩展函数，该函数负责交换数组中两个给定元素的位置。'
- en: Getting ready
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We can declare extension functions and extension properties inside any file
    in the project. However, to keep them well organized, it's better to put them
    in dedicated files.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在项目的任何文件中声明扩展函数和扩展属性。然而，为了保持良好的组织结构，最好将它们放在专门的文件中。
- en: 'The syntax for extension functions is very similar to the one of the standard
    function. We just need to add information about the type that is being extended
    with the new function, as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展函数的语法与标准函数的语法非常相似。我们只需要添加有关新函数扩展的类型信息，如下所示：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How to do it...
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Create a new file, `Extensions.kt`, to store the extension function definition.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件，名为`Extensions.kt`，用于存储扩展函数的定义。
- en: 'Implement the `swap()` function inside:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中实现`swap()`函数：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As a result, we are able to call the `swap` function on any instance of the
    `Array` class. Let''s consider the following example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们能够对`Array`类的任何实例调用`swap`函数。让我们考虑以下示例：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This results in printing the following output to the console:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在控制台输出以下内容：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, we can access the current instance of the class inside the extension
    function using the `this` keyword.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们可以在扩展函数中使用`this`关键字来访问类的当前实例。
- en: There's more...
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Apart from extension functions, Kotlin also offers an extension properties
    feature. For example, we can declare a property for the `List<T>` class that will
    hold information about the last element index value:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 除了扩展函数之外，Kotlin还提供了扩展属性功能。例如，我们可以为`List<T>`类声明一个属性，该属性将保存有关最后一个元素索引值的详细信息：
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Extensions are a widely used pattern across Kotlin standard library classes.
    They work seamlessly with Java, Kotlin, JavaScript, and native classes defined
    within the project and in external dependencies as well.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展函数在Kotlin标准库的类中是一个广泛使用的模式。它们与Java、Kotlin、JavaScript以及项目内部和外部依赖中定义的本地类无缝工作。
- en: Destructuring types
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解构类型
- en: 'It is often practical to convert a single object of a complex type into a number
    of variables. This allows you to provide proper naming for the variables and simplifies
    the code. Kotlin provides an easy, built-in way to achieve this with a feature
    called *destructuring*:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，将复杂类型的一个对象转换为多个变量是非常实用的。这允许你为变量提供适当的命名，并简化代码。Kotlin提供了一个简单内置的功能来实现这一点，称为*解构*：
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As a result, this piece of code would print the following message to the console:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这段代码会在控制台打印以下信息：
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Pretty awesome! Destructuring is available for data classes out of the box.
    The Kotlin standard library provides this feature for many common types as well.
    However, destructuring is not available explicitly whenever we are dealing with
    custom, non-data classes. Especially, while working with classes from external
    libraries written in other languages such as Java, we need to define the destructuring
    mechanism manually. In this recipe, we are going to implement destructuring for
    a Java class defined as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 非常棒！解构对于数据类是开箱即用的。Kotlin标准库还为许多常见类型提供了这个功能。然而，当我们处理自定义的非数据类时，解构并不是明确可用的。特别是，当我们与其他语言（如Java）编写的类库中的类一起工作时，我们需要手动定义解构机制。在这个菜谱中，我们将为以下定义的Java类实现解构：
- en: '[PRE24]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Getting ready
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Destructuring declarations in Kotlin are position-based, opposed to property
    name-based declarations available in other languages. This means the Kotlin compiler
    decides which class property is linked to which variable based on the order of
    the properties. In order to allow custom class destructuring, we need to add implementations
    of the functions called `componentN`*, *where *N* refers to the component number marked
    with the `operator` keyword to allow using them in a destructuring declaration.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin中的解构声明是位置相关的，与在其他语言中可用的基于属性名称的声明相反。这意味着Kotlin编译器根据属性的顺序决定哪个类属性与哪个变量相关联。为了允许自定义类的解构，我们需要添加名为`componentN`的函数的实现，其中*N*代表带有`operator`关键字的标记的组件编号，以便在解构声明中使用它们。
- en: How to do it...
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Declare an extension function returning the `id` property of the `LightBulb`
    class:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个扩展函数，返回`LightBulb`类的`id`属性：
- en: '[PRE25]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add another extension `componentN` function responsible for returning the `turnedOn`
    property:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加另一个扩展`componentN`函数，用于返回`turnedOn`属性：
- en: '[PRE26]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How it works...
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Once we declare proper `componentN`functions, we can benefit from destructuring
    of the `LightBulb` type objects:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们声明了适当的`componentN`函数，我们就可以从`LightBulb`类型对象的解构中受益：
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This code would print the following output to the console:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码会在控制台打印以下输出：
- en: '[PRE28]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, the `component1()` function was assigned to the first variable
    of the destructured declaration—`id`. Similarly, the second `turnedOn` variable
    was assigned with the result of the `component2()` function.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`component1()`函数被分配给解构声明的第一个变量——`id`。同样，第二个`turnedOn`变量被分配给`component2()`函数的结果。
- en: There's more...
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Because of the fact that properties in destructured object assignments are
    position-based, sometimes we are forced to declare more variables than we want
    to use. We can use an underscore if we don''t need to use a certain value, avoiding
    the compiler hint indicating an unused variable and simplifying the code a bit:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于解构对象赋值中的属性是位置相关的，有时我们被迫声明比我们想要使用的变量更多的变量。如果我们不需要使用某个值，我们可以使用下划线，以避免编译器提示未使用的变量，并稍微简化代码：
- en: '[PRE29]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Destructuring is also available for function return values:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 解构也适用于函数返回值：
- en: '[PRE30]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The preceding code is going to return the following output:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将返回以下输出：
- en: '[PRE31]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can also use destructured declarations with lambda expressions:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在lambda表达式中使用解构声明：
- en: '[PRE32]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Another useful application of destructured declarations is an iteration. For
    example, we can use this feature to traverse through map entries:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 解构声明的一个有用应用是迭代。例如，我们可以使用此功能遍历映射条目：
- en: '[PRE33]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Returning multiple data
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回多个数据
- en: Although Kotlin doesn't provide a multiple return feature, thanks to data classes
    and destructuring declarations, it is quite convenient to write functions that
    return a number of values of different types. In this recipe, we are going to
    implement a function returning the result of dividing two numbers. The result
    is going to contain the quotient and remainder values.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Kotlin没有提供多返回功能，但由于数据类和解构声明，编写返回多个不同类型值的函数相当方便。在这个菜谱中，我们将实现一个返回两个数字除法结果的函数。结果将包含商和余数值。
- en: How to do it...
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s start with declaring a data class for the return type:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从声明一个用于返回类型的数据类开始：
- en: '[PRE34]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let''s implement the `divide()` function:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们实现`divide()`函数：
- en: '[PRE35]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How it works...
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We can see the `divide()` function in action:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`divide()`函数的作用：
- en: '[PRE36]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The preceding code is going to print the following output:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将打印以下输出：
- en: '[PRE37]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Thanks to the fact that we are returning a data class instance, the `DivisionResult` class,
    we can benefit from the destructuring feature and assign the result to a set of
    separate variables.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们返回的是数据类实例，即`DivisionResult`类，我们可以利用解构特性并将结果分配给一组单独的变量。
- en: There's more...
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The Kotlin standard library provides ready to use `Pair` and `Triple` classes.
    We can use them to return two and three values of any type. This eliminates the
    need to create a dedicated data classes for the return type. On the other hand,
    using data classes gives us the ability to operate on more meaningful names, which
    adds more clarity to the code.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin标准库提供了现成的`Pair`和`Triple`类。我们可以使用它们来返回任意类型的两个和三个值。这消除了为返回类型创建专用数据类的需求。另一方面，使用数据类使我们能够使用更有意义的名称，这增加了代码的清晰度。
- en: 'The following example demonstrates using the `Pair` class to return two objects
    at the same time:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了使用`Pair`类同时返回两个对象：
- en: '[PRE38]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: See also
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: If you'd like to get more familiar with destructuring declarations, you can
    take a look at the *Destructuring types *recipe
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要更熟悉解构声明，可以查看**解构类型**菜谱。
- en: Inlining parameters of closure type
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内联闭包类型的参数
- en: Usage of higher-order functions can lead to a decrease of runtime performance.
    Memory allocations of the functions passed as lambda arguments and their virtual
    calls in a function body lead to runtime overhead. However, in many cases, we
    can eliminate this type of overhead by inlining the lambda expression parameters.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用高阶函数可能会导致运行时性能下降。将函数作为lambda参数传递以及它们在函数体内的虚拟调用会导致运行时开销。然而，在许多情况下，我们可以通过内联lambda表达式参数来消除这种开销。
- en: In this recipe, we are going to implement the `lock()` function that will automate
    work with the Java `java.util.concurrent.locks.Lock` interface. The function will
    take two arguments—an instance of the `Lock` interface and the function that should
    be invoked after the lock is acquired. Finally, our `lock()` function should release
    the lock. We also want to allow making the function parameter inlined.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将实现`lock()`函数，该函数将自动化与Java `java.util.concurrent.locks.Lock`接口的工作。该函数将接受两个参数——`Lock`接口的一个实例以及在获取锁后应调用的函数。最后，我们的`lock()`函数应释放锁。我们还希望允许内联函数参数。
- en: Getting ready
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To declare an inline function, we simply need to add the `inline` modifier in
    front of the function header.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明内联函数，我们只需在函数头部之前添加`inline`修饰符。
- en: How to do it...
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s declare a `lock()` function with two arguments—an instance of the `Lock`
    interface and the function to be invoked after the lock is acquired:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们声明一个带有两个参数的`lock()`函数——`Lock`接口的一个实例以及获取锁后要调用的函数：
- en: '[PRE39]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How it works...
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `performHavingLock()` function allows us to provide synchronization for
    the function passed to it as the `task` parameter:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`performHavingLock()`函数允许我们为其`task`参数提供的函数提供同步。'
- en: '[PRE40]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'As a result, the `performHavingLock()` function is going to print the following
    output to the console:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`performHavingLock()`函数将打印以下输出到控制台：
- en: '[PRE41]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Under the hood, the inline modifier affects both the function itself and the
    lambda expressions passed to it. They are all going to be inlined in the underlying
    generated bytecode:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，`inline`修饰符会影响函数本身以及传递给它的lambda表达式。它们都将内联到生成的字节码中：
- en: '[PRE42]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If we did not use the `inline` modifier, the compiler would create a separate
    instance of the `Function0` type in order to pass the lambda argument to the `performHavingLock()`
    function. Inlining lambdas may cause the generated code to grow. However, if we
    do it in a reasonable way (that is, avoiding inlining large functions), it will
    pay off in performance.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有使用`inline`修饰符，编译器将创建一个`Function0`类型的单独实例，以便将lambda参数传递给`performHavingLock()`函数。内联lambda可能会导致生成的代码增长。然而，如果我们以合理的方式（即避免内联大型函数）进行内联，这将有助于性能。
- en: There's more...
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If you want only some of the lambdas passed to the function to be inlined,
    you can mark some of the function parameters with the `noinline` modifier:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想将函数传递的一些lambda表达式内联，你可以使用`noinline`修饰符标记一些函数参数：
- en: '[PRE43]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Kotlin also allows declaring inline class properties. The `inline` modifier
    can be used with getter and setter methods of properties that don''t have a backing
    field. For example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin还允许声明内联类属性。`inline`修饰符可以与没有后置字段的属性的getter和setter方法一起使用。例如：
- en: '[PRE44]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We can also annotate an entire property:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以注释整个属性：
- en: '[PRE45]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As a result, the inlined getters and setters are going to be represented in
    the same way as the regular inline functions.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，内联的getter和setter将与常规的内联函数以相同的方式进行表示。
- en: Infix notations for functions
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数的中缀表示法
- en: To bring our code closer to the natural language, Kotlin provides infix notations
    for the functions containing a single parameter. This way, we can invoke the function
    without using brackets. In this recipe, we are going to learn how to design an
    infix extension function for the `String` type, named `concat()`, which is responsible
    for the concatenation of two string values.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的代码更接近自然语言，Kotlin为包含单个参数的函数提供了中缀表示法。这样，我们可以不使用括号来调用函数。在本菜谱中，我们将学习如何为`String`类型设计一个名为`concat()`的中缀扩展函数，该函数负责连接两个字符串值。
- en: Getting ready
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: In order to enable an infix notation for the function, we simply need to add
    the `infix` keyword before the function header.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用函数的中缀表示法，我们只需在函数标题之前添加`infix`关键字。
- en: How to do it...
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Declare the `concat()` extension function and implement its body:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 声明`concat()`扩展函数并实现其主体：
- en: '[PRE46]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How it works...
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s test the `concat()` function by running the following code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过运行以下代码来测试`concat()`函数：
- en: '[PRE47]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Great! We have just printed out the following text to the console:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们刚刚将以下文本打印到控制台：
- en: '[PRE48]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: There's more...
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The Kotlin standard library uses the infix notation extensively. You can benefit
    from infix functions to shape your code the clean way. One infix function worth
    noting is the `to()` extension function provided for the `Map.Entry<K, V>` class,
    which allows you to declare map entries in a minimalistic way:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin标准库广泛使用中缀表示法。你可以利用中缀函数以整洁的方式塑造你的代码。一个值得注意的中缀函数是`Map.Entry<K, V>`类提供的`to()`扩展函数，它允许你以极简的方式声明映射条目：
- en: '[PRE49]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `to()` extension function is declared for a generic type `A` and generic
    argument of type `B`, which returns an instance of a `Pair<A, B>` class.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`to()`扩展函数是为泛型类型`A`和泛型参数类型`B`声明的，它返回一个`Pair<A, B>`类的实例。'
- en: There are plenty of other functions supporting infix notations available in
    the standard library. If you check the implementation of the ones you are using
    on a daily basis, it may turn out they are available in the infix form too.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中提供了许多支持中缀表示法的其他函数。如果你检查你每天使用的函数的实现，可能会发现它们也有中缀形式。
- en: See also
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: You can learn about another cool feature that helps to shape the code to be
    more natural to read in the *Overloading operators *recipe
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在*重载运算符*菜谱中了解另一个有助于使代码更易于阅读的酷特性。
- en: Smart types checking with generic reified parameters
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用泛型重载参数的智能类型检查
- en: 'While implementing functions that support generic type arguments, we often
    deal with the need to provide additional information about object types at runtime.
    On the JVM platform, types have their representations in the `Class<T>` class
    instances. For example, we can face such a need while parsing JSON formatted data
    to the Kotlin class instances using the `Gson` library:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现支持泛型类型参数的函数时，我们经常需要提供有关对象类型在运行时的额外信息。在JVM平台上，类型在`Class<T>`类实例中有它们的表示。例如，当我们使用`Gson`库将JSON格式的数据解析到Kotlin类实例时，我们可能会遇到这样的需求：
- en: '[PRE50]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Normally, we can''t access the generic type argument at runtime because of
    a JVM types erasure. However, Kotlin allows you to overcome this limitation because it
    preserves the type argument at runtime. In this recipe, we are going to tune up
    Gson''s `fromJson(json: String, Class<T>)` function to get rid of the additional
    type argument.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '通常，由于JVM类型擦除，我们无法在运行时访问泛型类型参数。然而，Kotlin允许你克服这一限制，因为它在运行时保留了类型参数。在这个示例中，我们将调整Gson的`fromJson(json:
    String, Class<T>)`函数，以消除额外的类型参数。'
- en: Getting ready
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Make sure you have the Gson dependency included in your project ([https://github.com/google/gson](https://github.com/google/gson)).
    If you are using Gradle, build script that you can fetch it with the following
    declaration:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的项目中包含了Gson依赖项（[https://github.com/google/gson](https://github.com/google/gson)）。如果你使用Gradle，可以在构建脚本中使用以下声明来获取它：
- en: '[PRE51]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In order to make a type argument accessible at runtime, we need to mark it with
    the `reified` modifier and mark the function as `inline`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在运行时使类型参数可访问，我们需要用`reified`修饰符标记它，并将函数标记为`inline`。
- en: How to do it...
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Create a new file where we will put an extension function implementation (for
    example, `GsonExtensions.kt`)
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件，我们将在这里放置扩展函数的实现（例如，`GsonExtensions.kt`）
- en: 'Inside the file, declare an extension function for the `Gson` class:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件内部，声明一个`Gson`类的扩展函数：
- en: '[PRE52]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: How it works...
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We have implemented an extension function for the `Gson` type. Thanks to adding
    the `reified` modifier, we can access the generic type argument at runtime and
    pass it to the original `fromGson()` function.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为`Gson`类型实现了一个扩展函数。由于添加了`reified`修饰符，我们可以在运行时访问泛型类型参数并将其传递给原始的`fromGson()`函数。
- en: 'As a result, we are able to use the more elegant version of the `fromGson()`
    function in our code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，我们能够在代码中使用更优雅版本的`fromGson()`函数：
- en: '[PRE53]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We could also benefit from Kotlin smart casting and omit the explicit type
    declaration from the function call:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以利用Kotlin智能转换并从函数调用中省略显式的类型声明：
- en: '[PRE54]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Overloading operators
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重载运算符
- en: The Kotlin language provides a set of operators which have their own symbol (for
    example, `+`, `-`, `*`,  or `/`) and a priority defined. At the time of compilation,
    the Kotlin compiler transforms them into associated function calls or even more
    complex statements. We are also able to override an operator and declare its custom
    underlying implementation for a specified type. This implementation would be applied
    to the instances of the specified type the operator was used with.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin语言提供了一套具有自己符号（例如，`+`、`-`、`*`或`/`）和优先级的运算符。在编译时，Kotlin编译器将它们转换为关联函数调用或更复杂的语句。我们还可以重载运算符并为其指定的类型声明自定义底层实现。此实现将应用于使用运算符的指定类型的实例。
- en: In this recipe, we are going to define a class called `Position`, representing
    the current coordinates of the point in a three-dimensional space. Then, we are
    going to implement custom `plus` and `minus` operators for our class to provide
    a simple way of applying a geometric transformation to its instances. As a result,
    we want to be able to update the coordinates of the point represented by the `Position` class
    using the `+` and `-` operator symbols.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将定义一个名为`Position`的类，表示三维空间中点的当前坐标。然后，我们将为我们的类实现自定义的`plus`和`minus`运算符，以便提供一种简单的方式来对其实例应用几何变换。结果，我们希望能够使用`+`和`-`运算符符号更新由`Position`类表示的点的坐标。
- en: Getting ready
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In order to overload the operator for the specific type, we need to provide
    a member function or an extension function with a fixed name corresponding to
    the operator. Additionally, functions that overload operators need to be marked
    with the `operator` keyword.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为特定类型重载运算符，我们需要提供一个具有与运算符对应的固定名称的成员函数或扩展函数。此外，重载运算符的函数需要用`operator`关键字标记。
- en: 'In the following tables, you can find grouped sets of operators available in
    the language with their corresponding expressions to which they are translated
    to:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下表中，您可以找到语言中可用的操作符分组及其对应的表达式，它们被转换成：
- en: '**Unary prefix**'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**一元前缀**'
- en: '| **Operator** | **Expression** |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| **操作符** | **表达式** |'
- en: '| `+a` | `a.unaryPlus()` |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `+a` | `a.unaryPlus()` |'
- en: '| `-a` | `a.unaryMinus()` |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `-a` | `a.unaryMinus()` |'
- en: '| `!a` | `a.not()` |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `!a` | `a.not()` |'
- en: '**Incrementation and decrementation**'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**增量与减量**'
- en: '| **Operator** | **Expression** |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| **操作符** | **表达式** |'
- en: '| `a++` | `a.inc()` |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `a++` | `a.inc()` |'
- en: '| `a--` | `a.dec()` |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `a--` | `a.dec()` |'
- en: '**Arithmetic**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**算术**'
- en: '| **Operator** | **Expression** |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| **操作符** | **表达式** |'
- en: '| `a` `+` `b` | `a.plus(b)` |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `a + b` | `a.plus(b)` |'
- en: '| `a` `-` `b` | `a.minus(b)` |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `a - b` | `a.minus(b)` |'
- en: '| `a` `*` `b`  | `a.times(b)` |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `a * b` | `a.times(b)` |'
- en: '| `a` `/` `b` | `a.div(b)` |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `a / b` | `a.div(b)` |'
- en: '| `a` `%` `b` | `a.rem(b)` |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `a % b` | `a.rem(b)` |'
- en: '| `a..b` | `a.rangeTo(b)` |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `a..b` | `a.rangeTo(b)` |'
- en: '**Inoperator**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**内联操作符**'
- en: '| **Operator** | **Expression** |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| **操作符** | **表达式** |'
- en: '| `a` `in` `b` | `b.contains(a)` |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| `a in b` | `b.contains(a)` |'
- en: '| `a` `!in` `b` | `!b.contains(a)` |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| `a !in b` | `!b.contains(a)` |'
- en: '**Indexed access**'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**索引访问**'
- en: '| **Operator** | **Expression** |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| **操作符** | **表达式** |'
- en: '| `a[i]` | `a.get(i)` |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| `a[i]` | `a.get(i)` |'
- en: '| `a[i, j]` | `a.get(i, j)` |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| `a[i, j]` | `a.get(i, j)` |'
- en: '| `a[i_1, ..., i_n]` | `a.get(i_1, ..., i_n)` |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| `a[i_1, ..., i_n]` | `a.get(i_1, ..., i_n)` |'
- en: '| `a[i] = b` | `a.set(i, b)` |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| `a[i] = b` | `a.set(i, b)` |'
- en: '| `a[i, j] = b` | `a.set(i, j, b)` |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| `a[i, j] = b` | `a.set(i, j, b)` |'
- en: '| `a[i_1, ..., i_n] = b` | `a.set(i_1, ..., i_n, b)` |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| `a[i_1, ..., i_n] = b` | `a.set(i_1, ..., i_n, b)` |'
- en: '**Invoke operator**'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**调用操作符**'
- en: '| **Operator** | **Expression** |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| **操作符** | **表达式** |'
- en: '| `a()` | `a.invoke()` |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| `a()` | `a.invoke()` |'
- en: '| `a(i)` | `a.invoke(i)` |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| `a(i)` | `a.invoke(i)` |'
- en: '| `a(i, j)` | `a.invoke(i, j)` |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| `a(i, j)` | `a.invoke(i, j)` |'
- en: '| `a(i_1, ..., i_n)` | `a.invoke(i_1, ..., i_n)` |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| `a(i_1, ..., i_n)` | `a.invoke(i_1, ..., i_n)` |'
- en: '**Augmented assignment**'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**增强赋值**'
- en: '| **Operator** | **Expression** |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| **操作符** | **表达式** |'
- en: '| `a += b` | `a.plusAssign(b)` |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| `a += b` | `a.plusAssign(b)` |'
- en: '| `a -= b ` | `a.minusAssign(b)` |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| `a -= b` | `a.minusAssign(b)` |'
- en: '| `a *= b` | `a.timesAssign(b)` |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| `a *= b` | `a.timesAssign(b)` |'
- en: '| `a /= b` | `a.divAssign(b)` |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| `a /= b` | `a.divAssign(b)` |'
- en: '| `a %= b` | `a.remAssign(b)` |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| `a %= b` | `a.remAssign(b)` |'
- en: '**Equality and comparison**'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**等式和比较**'
- en: '| **Operator** | **Expression** |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| **操作符** | **表达式** |'
- en: '| `a == b` | `a?.equals(b) ?: (b === null)` |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| `a == b` | `a?.equals(b) ?: (b === null)` |'
- en: '| `a != b` | `!(a?.equals(b) ?: (b === null))` |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `a != b` | `!(a?.equals(b) ?: (b === null))` |'
- en: '| `a > b` | `a.comareTo(b) > 0` |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| `a > b` | `a.comareTo(b) > 0` |'
- en: '| `a < b` | `a.compareTo(b) < 0` |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `a < b` | `a.compareTo(b) < 0` |'
- en: '| `a >= b` | `a.compareTo(b) >= 0` |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| `a >= b` | `a.compareTo(b) >= 0` |'
- en: '| `a <= b` | `a.compareTo(b) <= 0` |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| `a <= b` | `a.compareTo(b) <= 0` |'
- en: How to do it...
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Declare the `Position` data class with `x`, `y`, `z`  properties related to
    the current position in the Cartesian coordinates system:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`x`、`y`、`z`属性声明与笛卡尔坐标系中当前位置相关的`Position`数据类：
- en: '[PRE55]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Add a `plus` operator implementation for the `Position` class:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`Position`类添加一个`plus`操作符实现：
- en: '[PRE56]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Overload the `minus` operator:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖`minus`操作符：
- en: '[PRE57]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: How it works...
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Now we can use the `Position` class together with `plus` and `minus` operators.
    Let''s try using the minus operator:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`Position`类以及`plus`和`minus`操作符。让我们尝试使用减号操作符：
- en: '[PRE58]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'That''s it. The preceding code is going to print the following result to the
    console:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。前面的代码将打印以下结果到控制台：
- en: '[PRE59]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: There's more...
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Some of the operators have their corresponding compound *assign *operators
    defined. Once we have overloaded the `plus` and `minus`operators, we can use the `plusAssign
    (+=)` and `minusAssign (-=)`operators automatically. For example, we can use the `plusAssign`operator
    to update the `Position`instance state as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 一些操作符有它们对应的复合*赋值*操作符定义。一旦我们覆盖了`plus`和`minus`操作符，我们就可以自动使用`plusAssign (+=)`和`minusAssign
    (-=)`操作符。例如，我们可以使用`plusAssign`操作符来更新`Position`实例状态如下：
- en: '[PRE60]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'As a result, we will get the `position`variable with the following state:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将得到以下状态的`position`变量：
- en: '[PRE61]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: It is important to note that the *assign *operator returns the `Unit`*.* This
    makes it a better choice than an original basic operator (for example, `plus`or `minus`)
    in terms of memory allocations efficiency when updating an instance. In contrast,
    the base operators are returning new instances every time.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，*赋值*操作符返回`Unit`*.*这使得它在更新实例时，在内存分配效率方面比原始基本操作符（例如，`plus`或`minus`）是一个更好的选择。相比之下，基本操作符每次都会返回新的实例。
- en: 'It is good to know that Kotlin offers operators overloading for Java classes
    as well. To overload the operator, we just need to add a proper method to the
    class that has the name of the operator and the `public` visibility modifier.
    Here is what the Java version of the `Position` class with the overloaded `plus`operator
    would look like:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，Kotlin还提供了对Java类的运算符重载。要重载运算符，我们只需向具有运算符名称和`public`可见性修饰符的类中添加一个适当的方法。以下是具有重载`plus`运算符的`Position`类的Java版本：
- en: '[PRE62]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'And here is how it could be used in Kotlin code:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin代码中，可以这样使用它：
- en: '[PRE64]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The Kotlin standard library also contains predefined implementations of different
    operators. One that you should use on a daily basis is the `plus` operator for
    a `MutableCollection` type. This allows for adding new elements to the collection
    in the following way:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin标准库还包含不同运算符的预定义实现。你应每天使用的运算符之一是`MutableCollection`类型的`plus`运算符。这允许以下方式向集合中添加新元素：
- en: '[PRE65]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'As a result, the preceding code will print the following output to the console:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，前面的代码将在控制台打印以下输出：
- en: '[PRE66]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
