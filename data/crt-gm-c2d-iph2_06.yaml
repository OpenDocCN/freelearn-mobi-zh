- en: Chapter 6. Cycles of Light
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章。光之周期
- en: In this chapter, we will be shifting gears and developing a multiplayer iPad
    game. This game will include both two players on the same iPad as well as using
    Bluetooth connectivity with GameKit for a real head-to-head battle.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将转换方向，开发一个多人 iPad 游戏。这个游戏将包括在同一 iPad 上的两位玩家，以及使用 GameKit 的蓝牙连接进行真正的面对面战斗。
- en: 'In this chapter, we cover the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: CCSprite movement without using actions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不使用动作的 CCSprite 移动
- en: Dynamic sprite stretching
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态精灵拉伸
- en: Efficient reuse of images
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像的高效重用
- en: Drawing with CCRenderTexture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 CCRenderTexture 绘制
- en: Using glScissor to clip drawing areas
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 glScissor 来裁剪绘制区域
- en: GameKit PeerPicker
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GameKit PeerPicker
- en: Bluetooth connectivity
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝牙连接
- en: Sending and Receiving data
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送和接收数据
- en: The game is…
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏是…
- en: In this chapter, we will be making a tribute to the "Light Cycles of TRON" game
    from the golden era of arcades. Each player has a bike driven in an enclosed game
    field. The bike has a fixed speed, and can only turn at right angles. The bike
    leaves a wall as a trail behind it. It is fatal to run into the walls created
    by the bikes. It is also fatal to run into the outside walls. To put our own spin
    on the game, our "bikes" will be light bulbs, each with their own "glow" of the
    appropriate color.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向电子游戏黄金时代的“光之周期”游戏（TRON）致敬。每位玩家都有一辆在封闭游戏场地中驾驶的自行车。自行车具有固定的速度，并且只能以直角转弯。自行车在其后面留下墙壁作为痕迹。撞上自行车创建的墙壁是致命的。撞上外部墙壁也是致命的。为了给游戏增添自己的特色，我们的“自行车”将是灯泡，每个灯泡都有其适当的颜色“发光”。
- en: This is a two-player only game. Two players can play on the same iPad (positioned
    at opposite ends), or via a Bluetooth connection between two iPads. The game will
    be fully playable between Retina and non-Retina iPads at the same time.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个仅限两人游玩的游戏。两位玩家可以在同一 iPad 上（位于相反两端）游玩，或者通过两个 iPad 之间的蓝牙连接进行游玩。游戏将在 Retina
    和非 Retina iPad 之间同时完全可玩。
- en: 'Our finished game will look like the following screenshot:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成的游戏将看起来像以下截图：
- en: '![The game is…](img/9007_06_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![游戏是…](img/9007_06_01.jpg)'
- en: Design review
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计评审
- en: 'We will begin by discussing the approach that we will use for the design. One
    of our core design decisions for this game is to use as few graphic files as possible,
    without sacrificing the look and feel of the game. If you look at the source graphics,
    we only have four images: a white button with a right arrow on it, a light bulb,
    a white "bulb glow" image, and a white square image 1 x 1 point in size. From
    those images, we will drive the entire game.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先讨论我们将用于设计的方案。我们为这款游戏的核心设计决策之一是尽可能少地使用图形文件，同时不牺牲游戏的外观和感觉。如果您查看源图形，我们只有四张图片：一个带有右箭头的白色按钮，一个灯泡，一个白色的“灯泡发光”图像，以及一个
    1 x 1 点大小的白色方形图像。从这些图像中，我们将驱动整个游戏。
- en: Structurally, we want separate classes for the bike and the button. The bike
    will handle all of its own movement, and the button class will send messages directly
    to the bike it is controlling, so there is very little direct interaction with
    the game layer itself. The walls will be generated from the white square graphic,
    using on-the-fly scaling to stretch the walls behind the bike. All walls will
    be stored inside the game layer, since there is substantial need to share the
    walls between the bikes.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 结构上，我们希望为自行车和按钮分别创建单独的类。自行车将处理它自己的所有移动，按钮类将直接向它所控制的自行车发送消息，因此与游戏层的直接交互非常少。墙壁将从白色方形图形生成，使用即时缩放拉伸自行车后面的墙壁。所有墙壁都将存储在游戏层内部，因为需要在自行车之间共享墙壁。
- en: We will also use a separate layer for the "grid" graphics behind the playfield,
    because it truly is visual "fluff" with no interaction with the actual game field.
    This grid will have some visual effects, so it will never be static. This grid
    will be generated completely by the code, using the `CCRenderTexture` class to
    draw it when the game initializes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将为游戏场地后面的“网格”图形使用一个单独的层，因为它确实是视觉上的“填充物”，与实际游戏场地没有任何交互。这个网格将有一些视觉效果，因此它永远不会是静态的。这个网格将完全由代码生成，使用
    `CCRenderTexture` 类在游戏初始化时绘制它。
- en: Let's build a bike
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们构建一辆自行车
- en: We want to start with the basic element of the game, the `CLBike` class . We
    will look at this class in detail here, but first we want to see the `CLDefinitions.h`
    file.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望从游戏的基本元素开始，即 `CLBike` 类。我们将在这里详细查看这个类，但首先我们想看看 `CLDefinitions.h` 文件。
- en: '**Filename**: `CLDefinitions.h`'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`CLDefinitions.h`'
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here we have a few definition for our graphic and sound assets. Centralizing
    the definitions makes it much easier to change your filenames in one place, rather
    than hunting through your code for all references.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们对我们的图形和声音资源进行了一些定义。集中定义使得更改文件名变得更加容易，而不是在代码中搜索所有引用。
- en: We also create two `typedef` `enum` definitions. The `PlayerID` holds a value
    to make it easier to determine which player is being addressed. Likewise, we define
    `Direction` so we can use our directions without needing to keep notes to identify
    which number represents which direction. As we have mentioned before, these `typedef`
    `enum` are "integers in disguise", so we can pass these in as an integer if we
    ever need to (and we will later).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了两个`typedef` `enum`定义。`PlayerID`包含一个值，这使得确定哪个玩家被引用变得更容易。同样，我们定义了`Direction`，这样我们就可以使用方向而无需记录哪个数字代表哪个方向。正如我们之前提到的，这些`typedef`
    `enum`是“伪装成整数的整数”，因此如果我们需要（我们将会这样做），我们可以将这些作为整数传递。
- en: CLBike header
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CLBike头文件
- en: Now, we will look at the complete header for the `CLBike` class .
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将查看`CLBike`类的完整头文件。
- en: '**Filename**: `CLBike.h`'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`CLBike.h`'
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Most of these variables will be discussed during the explanation of the `CLBike.m`
    file, but there are a few items to touch on here. We keep a variable for `myPlayfield`,
    so the bike will be able to call methods from the main `CLPlayfieldLayer` class.
    You will notice that we do not `#import` that class, but instead use an `@class`
    line. As you may recall from [Chapter 3](ch03.html "Chapter 3. Thumping Moles
    for Fun"), *Thumping Moles for Fun* and [Chapter 4](ch04.html "Chapter 4. Give
    a Snake a Snack…"), *Give a Snake a Snack...*, this is a forward-declaration.
    It identifies that there will be a class by that name, but it doesn't know anything
    else about it in the header. The reason we use this is because the `CLPlayfieldLayer.m`
    file will import the `CLBike.h` header, so we would be stuck in a loop as the
    two classes try to import each other.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量中的大多数将在解释`CLBike.m`文件时进行讨论，但这里有一些事项需要提及。我们保留了一个`myPlayfield`变量，这样自行车就能调用主`CLPlayfieldLayer`类的函数。你会注意到我们没有`#import`那个类，而是使用了一个`@class`行。如你从[第3章](ch03.html
    "第3章。为了乐趣而敲打土拨鼠")，*为了乐趣而敲打土拨鼠*和[第4章](ch04.html "第4章。给蛇喂食……")，*给蛇喂食……*中回忆起来，这是一个前置声明。它标识了一个名为该名称的类，但在头文件中并不知道其他信息。我们使用这种方法的原因是`CLPlayfieldLayer.m`文件将导入`CLBike.h`头文件，因此当两个类尝试互相导入时，我们会陷入循环。
- en: 'We also have a class "convenience" method here:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里还有一个名为“便捷”的方法类：
- en: '**Filename**: `FileCLBike.h`'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`FileCLBike.h`'
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Even though the `CLBike` class is a subclass of `CCSprite`, we have several
    other details of the class that we need to set up, so we have opted for this convenience
    method. We need to know the `playerID` (`kRedPlayer` or `kBluePlayer`), and the
    `playerNo` variable, which defines which "control position" the player is in.
    Player no. 1 is on the "home button" end of the iPad, and player no. 2 will play
    from the "top" of the iPad. We also pass the parent layer to the bike. The final
    argument is the Boolean variable `isRemote`, which identifies whether or not this
    bike will be controlled by someone who is not "local" to this iPad (that is during
    a Bluetooth game).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`CLBike`类是`CCSprite`的子类，但我们还需要设置该类的几个其他细节，因此我们选择了这个便捷方法。我们需要知道`playerID`（`kRedPlayer`或`kBluePlayer`）和`playerNo`变量，它定义了玩家处于哪个“控制位置”。玩家编号1位于iPad的“主页按钮”端，玩家编号2将在iPad的“顶部”进行游戏。我们还向自行车传递了父层。最后一个参数是布尔变量`isRemote`，它标识了这辆自行车是否将由不是“本地”于这个iPad的人控制（即在蓝牙游戏中）。
- en: We also expose many variables and methods as properties in this class. This
    is because we want the other classes to be able to "ask" the bike for a lot of
    information. We also need to be able to completely control the bike from outside
    the class. If you recall from our design discussion, we want the control buttons
    to send messages directly to the bike, so we have to expose all of the control
    methods.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在这个类中公开了许多变量和方法作为属性。这是因为我们希望其他类能够“询问”自行车很多信息。我们还需要能够完全从类外部控制自行车。如果你还记得我们的设计讨论，我们希望控制按钮能够直接向自行车发送消息，因此我们必须公开所有的控制方法。
- en: CLBike implementation
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CLBike实现
- en: Now that we have a flavor for the `CLBike` header, we will move on to the implementation
    file. We will step through the core of the class here, and will revisit it later
    when we discuss playing over Bluetooth.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了`CLBike`头文件，我们将继续到实现文件。在这里，我们将逐步通过类的核心，稍后当我们讨论通过蓝牙进行游戏时，我们将再次访问它。
- en: '**Filename**: `CLBike.m`'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`CLBike.m`'
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It is worth pointing out that we do have the `#import "CLPlayfieldLayer.h"`
    statement at the top of this file. This is the "pair" to the `@class` forward-declaration
    statement we used in the header. We need to use the `#import` line here because
    we will need the `CLBike` class to have access to the methods of the `CLPlayfieldLayer`
    class.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，我们确实在文件顶部有`#import "CLPlayfieldLayer.h"`这一语句。这是我们在头文件中使用的`@class`前向声明语句的“配对”。我们需要在这里使用`#import`行，因为我们将会需要`CLBike`类来访问`CLPlayfieldLayer`类的成员方法。
- en: As we said earlier, we built a convenience method for creating a new bike. To
    adhere to the definition of a convenience method, we perform an `alloc`, an `init`,
    and mark the instantiated object as an `autorelease` object.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说的，我们创建了一个用于创建新自行车的便利方法。为了符合便利方法的定义，我们执行了一个`alloc`，一个`init`，并将实例化的对象标记为`autorelease`对象。
- en: '**Filename**: `CLBike.m` (`initForPlayer`, part 1)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`CLBike.m`（`initForPlayer`，第一部分）'
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here we begin the `initForPlayer:` method. The "super" class of `CLBike` is
    `CCSprite`, so we can call `initWithSpriteFrameName:` from the super class. This
    takes care of the initialization of the standard `CCSprite` aspects of our class.
    We only need to concern ourselves with the specialized `CLBike` initialization.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们开始`initForPlayer:`方法的实现。`CLBike`的“超类”是`CCSprite`，因此我们可以从超类中调用`initWithSpriteFrameName:`。这处理了我们类中标准的`CCSprite`方面的初始化。我们只需要关注我们类特有的`CLBike`初始化。
- en: We keep the reference to the layer passed (in `myPlayfield`), the `playerID`
    (in `self.thisPlayerID`), and the Boolean value of the `remotePlayer` variable
    (in `isRemotePlayer`). The `playerNo` value is not stored in a variable, as it
    will only be used while building the player's bike.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们保留了传入的层引用（在`myPlayfield`中），`playerID`（在`self.thisPlayerID`中），以及`remotePlayer`变量的布尔值（在`isRemotePlayer`中）。`playerNo`值没有存储在变量中，因为它只会在构建玩家自行车时使用。
- en: We set the default values for the bike to be facing up (`kUp`) with a `bikeSpeed`
    of `3.0`, and a `scale` of `0.25`. We also set the `anchorPoint` to `ccp(0.5,
    0)` which is a point which is centered on the rear end of the bike.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为自行车设置了默认值，使其面向上方（`kUp`），`bikeSpeed`为`3.0`，`scale`为`0.25`。我们还设置了`anchorPoint`为`ccp(0.5,
    0)`，这是一个位于自行车后端的中心点。
- en: Because we want to optimize our graphics, we will need to know what the player's
    color is. We don't want to set the sprite's color at all, because it would make
    the sprite look like a colored blob instead of a light bulb. Instead, we use `ccc3(r,g,b)`
    to build the colors we want, which are tinted slightly off pure red and pure blue,
    and then store them in the property `wallColor`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要优化我们的图形，我们需要知道玩家的颜色。我们根本不想设置精灵的颜色，因为这会使精灵看起来像是一个彩色的块，而不是一个灯泡。相反，我们使用`ccc3(r,g,b)`来构建我们想要的颜色，这些颜色略带纯红色和纯蓝色，然后将其存储在`wallColor`属性中。
- en: '**Filename**: `CLBike.m` (`initForPlayer`, part 2)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`CLBike.m`（`initForPlayer`，第二部分）'
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here we see the only code in the `CLBike` class that uses the `playerNo` value.
    If this is player 1, then the bike's starting position is centered toward the
    bottom of the screen. Player 2 is centered near the top of the screen, and their
    direction is changed to `kDown`. Once we have changed the bike's direction, we
    call the `rotateBike` method, which will correctly rotate the bike graphic (more
    on that method shortly).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到`CLBike`类中唯一使用`playerNo`值的代码。如果是玩家1，那么自行车的起始位置将位于屏幕底部中央。玩家2将位于屏幕顶部中央，并且他们的方向将改为`kDown`。一旦我们改变了自行车的方向，我们就调用`rotateBike`方法，该方法将正确地旋转自行车图形（关于这个方法将在稍后讨论）。
- en: We then add our "glow" graphic. This uses the solid white glow image, which
    we set to the color stored as the player's `wallColor`. We set the position as
    a little offset from the bike's position, to account for differences in the source
    image dimensions. We set the anchor point using the same `anchorPoint` value as
    the bike itself, and then we add the glow as a child of the bike (`self` in this
    class refers to the `CLBike` object), with a Z value of `-1`. This puts the glow
    behind the light bulb sprite. This lets us see the detail of the bulb, but also
    have the glowing effect visible through the transparent parts of the light bulb
    graphic.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们添加了我们的“发光”图形。这使用了纯白色的发光图像，我们将其设置为存储为玩家`wallColor`的颜色。我们将位置设置为略偏离自行车的位置，以考虑到源图像尺寸的差异。我们使用与自行车相同的`anchorPoint`值来设置锚点，然后将发光作为自行车的子节点添加（在这个类中`self`指的是`CLBike`对象），Z值为`-1`。这使发光位于灯泡精灵的后面。这让我们可以看到灯泡的细节，同时发光效果也可以通过灯泡图形的透明部分看到。
- en: 'The following screenshot shows the red bike, before and after we add the glow:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了添加发光效果前后的红色自行车：
- en: '![CLBike implementation](img/9007_06_02.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![CLBike实现](img/9007_06_02.jpg)'
- en: We will add some code to the end of this method later, but this will suffice
    for now.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后将在该方法末尾添加一些代码，但这对现在来说已经足够了。
- en: Bike rotation
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自行车旋转
- en: We have seen one method in this class that we haven't addressed yet, and it
    is simple enough to address now. After we position the bike, we call the `rotateBike`
    method.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个类中看到了一个尚未处理的方法，它足够简单，现在可以处理。在我们定位自行车后，我们调用`rotateBike`方法。
- en: '**Filename**: `CLBike.m`'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `CLBike.m`'
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We use a `switch` clause on the `self.bikeDirection` property. We then check
    which direction the bike is facing. Depending on the direction, we set the rotation
    for the sprite. The values chosen are simple right angles. So if the bike is facing
    in direction `kRight`, for example, we rotate the sprite to 90 degrees. If the
    bike is facing left, we rotate to -90 degrees. The movement will be controlled
    separately, so this graphic rotation is purely cosmetic. If we had chosen a symmetrical
    player graphic, we may not need to rotate at all.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`self.bikeDirection`属性上使用了一个`switch`子句。然后我们检查自行车面向哪个方向。根据方向，我们为精灵设置旋转。选择的是简单的直角。所以如果自行车面向`kRight`方向，例如，我们将精灵旋转到90度。如果自行车面向左边，我们旋转到-90度。移动将单独控制，所以这种图形旋转完全是装饰性的。如果我们选择了一个对称的玩家图形，我们可能根本不需要旋转。
- en: Turning the bike
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转动自行车
- en: 'Rotating the bike graphics is all well and good, but we need to be able to
    change the actual direction in which the bike is travelling. We build two methods
    to control this: `turnLeft` and `turnRight`. We will look at the `turnRight` method
    here.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 自行车图形的旋转很好，但我们还需要能够改变自行车实际行驶的方向。我们构建了两个方法来控制这一点：`turnLeft`和`turnRight`。我们将在这里查看`turnRight`方法。
- en: '**Filename**: `CLBike.m`'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `CLBike.m`'
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When we call the `turnRight` method, we use a switch statement to determine
    the current `bikeDirection`. We then set the new `bikeDirection` that is appropriate
    for this turn. So, if you were going in the `kUp` direction and turned right,
    your new direction is `kRight`. If you were going `kRight`, the new direction
    is `kDown`. After the new direction has been set, we call to the `rotateBike`
    method we just discussed. We play a simple sound effect for the turn, and that's
    all we need to do at this point. We have placeholders for two additional pieces
    of code that we will add later (wall assignments and remote game).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`turnRight`方法时，我们使用`switch`语句来确定当前的`bikeDirection`。然后我们设置适合这个转弯的新`bikeDirection`。所以，如果你正在`kUp`方向上行驶并转向右边，你的新方向是`kRight`。如果你正在`kRight`方向上行驶，新方向是`kDown`。设置新方向后，我们调用我们刚才讨论的`rotateBike`方法。我们播放一个简单的转弯音效，这就是我们现在需要做的所有事情。我们为稍后添加的两个额外的代码片段留有占位符（墙壁分配和远程游戏）。
- en: The `turnLeft` method is nearly identical, except we obviously use a different
    set of new directions in the `switch` statement, so the bike will correctly turn
    to the left. There will be a slight difference in the remote game section that
    we will add later.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`turnLeft`方法几乎相同，除了我们在`switch`语句中使用显然是不同的一组新方向，所以自行车可以正确地转向左边。稍后添加的远程游戏部分将有一些细微的差异。'
- en: We could have compressed these two methods into one, with a conditional *if*
    statement for the parts of the code that differ. We have opted for reading clarity
    in this case, as the repeated code is really not that difficult to debug.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这两个方法压缩成一个，使用一个条件`if`语句来处理代码中不同的部分。在这种情况下，我们选择了可读性，因为重复的代码实际上并不难调试。
- en: Building walls
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建造墙壁
- en: 'Next, we will turn our attention to the creation of the game walls. There are
    two types of walls we need to address: walls created by a player''s bike and the
    border walls around the playing grid. We will start by looking at how we can build
    our boundary walls.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将关注游戏墙壁的创建。我们需要处理两种类型的墙壁：由玩家自行车创建的墙壁和游戏网格周围的边界墙壁。我们将首先看看我们如何构建我们的边界墙壁。
- en: Boundary walls
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 边界墙壁
- en: Before we look at the code, it is important to know two items that are set up
    in our `init` method of the `CLPlayfieldLayer` class. First, our `CCSpriteBatchNode`
    is in the variable `cyclesheet`. The second is that we have created an `NSMutableArray`
    called `bikeWalls` that will hold the `CCSprite` objects for all created walls
    (we will see this later, when we look at the `init` method in the `CLPlayfieldLayer`
    class). This array will be used in our collision detection, so we need to have
    our outer walls included in it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看代码之前，了解在`CLPlayfieldLayer`类的`init`方法中设置的两个项目是很重要的。首先，我们的`CCSpriteBatchNode`存储在变量`cyclesheet`中。其次，我们创建了一个名为`bikeWalls`的`NSMutableArray`，它将保存所有创建的墙壁的`CCSprite`对象（我们将在查看`CLPlayfieldLayer`类的`init`方法时看到这一点）。这个数组将用于我们的碰撞检测，因此我们需要将外侧墙壁包含在内。
- en: '**Filename**: `CLPlayfieldLayer.m`'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`CLPlayfieldLayer.m`'
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first method we need is the ability to create a wall between two specified
    points, `orig` and `dest`, passed to it. If you recall from the beginning of the
    chapter, we said one of our goals with this game was to optimize the use of graphics.
    Here we see the first "real" use of that idea. We are using the image defined
    as `IMG_SPECK`, which is the file `whitespeck.png` in the sprite sheet. This is
    a 1 x 1 point white square image. We use this tiny image to create the wall sprite.
    We set the color to yellow, which works really well on a white sprite. Using `setColor`
    works in the opposite way to what most people expect. Instead of adding color
    to the sprite, it actually reduces the appropriate color registers to give the
    desired effect.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的第一个方法是能够在两个指定点之间创建一个墙壁，这两个点`orig`和`dest`被传递给它。如果你还记得章节的开头，我们说我们的一个目标是优化图形的使用。在这里，我们看到这个想法的第一个“真正”的使用。我们使用定义为`IMG_SPECK`的图像，这是精灵表中`whitespeck.png`文件。这是一个1
    x 1点的白色方形图像。我们使用这个微小的图像来创建墙壁精灵。我们将颜色设置为黄色，这在白色精灵上效果非常好。使用`setColor`的方式与大多数人预期的相反。它不是向精灵添加颜色，而是实际上减少适当的颜色寄存器以产生期望的效果。
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Setting a sprite to white (`ccWHITE`) actually sets the color to the original
    color. This dynamic is important to know if you are doing anything interesting
    with sprite colors. For example, if you set a sprite's color to blue and there
    is nothing in the blue register, the sprite could turn black. It is these unintended
    consequences that make it very appealing to use white sprites if your intention
    is to colorize them in-game.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 将精灵设置为白色（`ccWHITE`）实际上是将颜色设置为原始颜色。如果你在使用精灵颜色做任何有趣的事情，了解这种动态是很重要的。例如，如果你将精灵的颜色设置为蓝色，而蓝色寄存器中没有其他内容，精灵可能会变成黑色。正是这些意外的后果使得在游戏中想要着色精灵时使用白色精灵非常吸引人。
- en: 'Back to the code. We set the position of the sprite to the `orig` value we
    were passed, and we set the anchor point to the bottom-left corner. We do this
    to keep in check with the background we will be adding later. We then have a couple
    of odd lines for the `setScaleX` and `setScaleY`. Because we want to use this
    routine to draw all four walls, we won''t know in which direction we are drawing.
    The formula in each of these lines does the same thing: Subtract the x (or y)
    values from each other. Take the absolute value (`ABS`) of the result. This will
    turn the negatives into positives. We then add 3 points, so we end up with a thick
    line (and avoid zero scale in the "thin" direction). This will take that simple
    1 x 1 point graphic and stretch it out into a line the full length we requested,
    with a thickness of 3 points. This approach works well for horizontal or vertical
    lines, but will make a big rectangle if you use coordinates that are not straight
    lines. Our game uses only straight lines, so this will suit our needs perfectly.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 回到代码。我们将精灵的位置设置为传递给我们的`orig`值，并将锚点设置为左下角。我们这样做是为了与我们将要添加的背景保持一致。然后我们有几行奇怪的代码用于`setScaleX`和`setScaleY`。因为我们想使用这个例程绘制四面墙，我们不知道我们将朝哪个方向绘制。每一行中的公式都做同样的事情：从每个值中减去x（或y）值。取结果的绝对值（`ABS`）。这将把负值变成正值。然后我们添加3个点，所以我们最终得到一条粗线（并避免了“细”方向中的零缩放）。这将把简单的1
    x 1点图形拉伸成我们请求的全长线条，厚度为3点。这种方法对于水平或垂直线条效果很好，但如果你使用的是非直线坐标，它将创建一个大矩形。我们的游戏只使用直线，所以这将完全符合我们的需求。
- en: We wrap up this method by adding the wall as a child of `cyclesheet`, and adding
    the created wall to the `bikeWalls` array. Now we have seen how to build a wall,
    we need another method to pass all of the coordinates we need to build the outer
    walls.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将墙壁作为`cyclesheet`的子项来封装这个方法，并将创建的墙壁添加到`bikeWalls`数组中。现在我们已经看到了如何构建墙壁，我们需要另一个方法来传递我们构建外墙壁所需的所有坐标。
- en: '**Filename**: `CLPlayfieldLayer.m`'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`CLPlayfieldLayer.m`'
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We have decided that the desired offset from the left and right edges is 59
    points. The offset from the top and bottom is 62 points. We call the `createWallFrom`
    method for each of the four boundary walls, and our work is done here.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定从左侧和右侧边缘的偏移量是59点。从顶部和底部的偏移量是62点。我们为四个边界墙壁中的每一个调用`createWallFrom`方法，我们的工作就完成了。
- en: Bike walls
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自行车墙壁
- en: 'Now we get to the real core of the cycles of light experience: the bike walls.
    Each bike will begin with a wall created behind it, and the walls will stretch
    until the bike turns. We start a new wall from that point.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来到了光循环体验的核心：自行车墙壁。每辆自行车都将从它后面的墙壁开始创建，墙壁会延伸直到自行车转弯。我们从那个点开始一个新的墙壁。
- en: '**Filename**: `CLPlayfieldLayer.m`'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`CLPlayfieldLayer.m`'
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code is very similar to what we used for building the outer walls, with
    a few notable exceptions. When this method is called, the `CLBike` instance of
    the player's bike will be passed to it. We use this to get most of the parameters
    we need for the wall. We set the wall's color to the `wallColor` of the bike.
    We set the wall's position to the same position occupied by the bike. We also
    set the `anchorPoint` using a method called `wallAnchorPoint` that is part of
    the `CLBike` class (we'll look at that in just a moment).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与我们用于构建外墙壁的代码非常相似，但有几点值得注意。当调用此方法时，玩家的自行车`CLBike`实例将被传递给它。我们使用这个实例来获取构建墙壁所需的大部分参数。我们将墙壁的颜色设置为自行车的`wallColor`。我们将墙壁的位置设置为自行车占据的相同位置。我们还使用`CLBike`类中的`wallAnchorPoint`方法设置`anchorPoint`（我们稍后会看到它）。
- en: We do not scale the wall sprite when it is created, so it is a single dot under
    the bike. We will handle the scaling of these walls from within the bike's movement
    code.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在创建墙壁精灵时不会对其进行缩放，所以它是在自行车下方的单个点。我们将从自行车的移动代码中处理这些墙壁的缩放。
- en: Like the other method, we still add the wall to the `cyclesheet` and to the
    `bikeWalls` array. However, we also return the wall to the caller. This is because
    the bike will need to know what wall is being created. Let's hop over to the `CLBike`
    class to see what's going on there.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 和其他方法一样，我们仍然将墙壁添加到`cyclesheet`和`bikeWalls`数组中。然而，我们还返回墙壁给调用者。这是因为自行车需要知道正在创建哪个墙壁。让我们跳转到`CLBike`类来看看那里发生了什么。
- en: '**Filename**: `CLBike.m`'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`CLBike.m`'
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here we have another method that uses the `bikeDirection` in a `switch` statement
    to determine a course of action. We set the anchor point to be at the center rear
    of the bike. So if the bike is currently going in direction `kRight`, then the
    anchor point should be set so `x` is equal to `0` (left edge) and `y` is equal
    to `0.5` (centered). We return the anchor point as a `ccp()` for all possible
    values of `bikeDirection`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们有一个使用`bikeDirection`在`switch`语句中确定操作过程的方法。我们将锚点设置在自行车的中心后部。所以如果自行车当前正在向`kRight`方向行驶，那么锚点应该设置为`x`等于`0`（左侧边缘）和`y`等于`0.5`（居中）。我们返回一个`ccp()`作为所有可能的`bikeDirection`值的锚点。
- en: 'You will also notice that we return the value directly to the calling method.
    The only place where this method is called is from the `createWallFromBike` method
    we just reviewed. The reason we use the bike to determine the anchor point is
    that we want the wall to be attached to the rear end of the bike, no matter what
    direction it is heading. In this way, each time we create a bike, the wall is
    anchored correctly. If you''re curious what it looks like when you incorrectly
    anchor a wall in the game, consider the following screenshot:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会注意到我们直接将值返回给调用方法。这个方法只从我们刚刚审查的`createWallFromBike`方法中被调用。我们使用自行车来确定锚点的理由是我们希望墙壁无论朝哪个方向行驶都能附着在自行车的后端。这样，每次我们创建一辆自行车，墙壁都会正确锚定。如果你对游戏中错误锚定墙壁时的样子感到好奇，可以考虑以下截图：
- en: '![Bike walls](img/9007_06_03.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![自行车墙壁](img/9007_06_03.jpg)'
- en: The same code was used in both of these images, except the `wallAnchorPoint`
    method was not used in the "Bad Anchor Points" example.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个图像都使用了相同的代码，除了在“不良锚点”示例中没有使用`wallAnchorPoint`方法。
- en: Bike integration
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自行车集成
- en: Now let's look at the code changes needed to integrate the walls into `CLBike`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看将墙壁集成到`CLBike`中所需的代码更改。
- en: 'Filename: `CLBike.m` (`initForPlayer` end of method)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 文件名：`CLBike.m`（方法`initForPlayer`的末尾）
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here we set a `wallWidth` to `5`, and we set the `priorWall` to `nil`. Then
    we store the returned value of the `createWallFromBike` in the `self.currentWall`
    property. To avoid colliding with the prior wall when you turn, we need to be
    able to hold references to both the current wall and the wall just before it.
    Of course, here we are simply initializing the `priorWall` as `nil` for good measure.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`wallWidth`设置为`5`，并将`priorWall`设置为`nil`。然后我们将`createWallFromBike`返回的值存储在`self.currentWall`属性中。为了避免在转向时与之前的墙壁相撞，我们需要能够同时保留对当前墙壁和之前墙壁的引用。当然，在这里我们只是为了保险起见，将`priorWall`初始化为`nil`。
- en: We also need to insert identical code in both the `turnRight` and `turnLeft`
    methods of the `CLBike`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在`CLBike`的`turnRight`和`turnLeft`方法中插入相同的代码。
- en: '**Filename**: `CLBike.m` (inside `turnRight` method)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`CLBike.m`（`turnRight`方法内部）'
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Both turn methods get identical "wall" code. This is the same as in the original
    `init` method, except here we first point the `priorWall` to the `currentWall`
    before we generate a new wall into the `currentWall` property. Because the `currentWall`
    property will first release the reference to the old wall before it creates a
    new one, this leaves the `priorWall` variable pointing to the previous wall, and
    the `currentWall` is now connected to the newly instantiated wall.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 两个转向方法都获得相同的“墙壁”代码。这与原始的`init`方法相同，只不过在这里我们首先将`priorWall`指向`currentWall`，然后再向`currentWall`属性生成一个新的墙壁。因为`currentWall`属性将在创建新墙壁之前先释放对旧墙壁的引用，这会使`priorWall`变量指向之前的墙壁，而`currentWall`现在连接到新实例化的墙壁。
- en: Bike movement
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自行车移动
- en: We will now move on to examine how we move the bike. Because the walls are central
    to the bike movement code, we left the movement until we understood the walls.
    The movement is broken down into two methods.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将继续检查如何移动自行车。因为墙壁是自行车移动代码的核心，所以我们直到理解了墙壁后才进行移动。移动被分解为两个方法。
- en: '**Filename**: `CLBike.m`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`CLBike.m`'
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is the easy method. This looks a little silly now, but it will make more
    sense once we add the "remote game" functionality later. For now, this is just
    a pass-through to the `moveForDistance` method, passing the `bikeSpeed` parameter.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是简单的方法。现在看起来有点傻，但一旦我们稍后添加了“远程游戏”功能，它就会更有意义。目前，这只是一个将`bikeSpeed`参数传递给`moveForDistance`方法的中间过程。
- en: '**Filename**: `CLBike.m`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`CLBike.m`'
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We again use the common `switch` statement on the `bikeDirection`. For each
    direction the bike is travelling, we first set the new position for the bike.
    This position is adding (or subtracting) the value of `dist` (the `bikeSpeed`
    we passed in) to the appropriate x or y position. For example, if the bike is
    moving in the `kUp` direction, we add `dist` to the `y` position. To move down,
    we subtract `dist` from the `y` value.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次在`bikeDirection`上使用常见的`switch`语句。对于自行车行驶的每个方向，我们首先设置自行车的新位置。这个位置是将`dist`（我们传递的`bikeSpeed`）的值添加（或减去）到适当的x或y位置。例如，如果自行车在`kUp`方向上移动，我们将`dist`添加到`y`位置。要向下移动，我们从`y`值中减去`dist`。
- en: The next two lines of code in each case are adjusting the `scaleX` and `scaleY`
    of the `currentWall`. If the bike is travelling in a y direction (up or down),
    we set the `scaleX` to the value of `wallWidth`. If the bike is travelling in
    an x direction (left or right), we set the `scaleY` to the value of `wallWidth`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下接下来的两行代码都在调整`currentWall`的`scaleX`和`scaleY`。如果自行车在y方向（向上或向下）行驶，我们将`scaleX`设置为`wallWidth`的值。如果自行车在x方向（向左或向右）行驶，我们将`scaleY`设置为`wallWidth`的值。
- en: For the scale in the direction the bike is travelling, we take the absolute
    value (`ABS`) of the `currentWall` position minus the bike's current position.
    This will effectively stretch the wall from its origin to the bike with every
    move. This is exactly the same type of wall stretching we used when we created
    the outer walls, except this is dynamically resizing the wall every time the bike
    moves.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于自行车行驶方向的尺度，我们取`currentWall`位置与自行车当前位置的绝对值（`ABS`），这将有效地在每次移动中将墙壁从其原点拉伸到自行车。这正是我们在创建外墙壁时使用的墙壁拉伸类型，只不过这次是动态调整墙壁大小。
- en: That's all it takes to make the bike move, and for the walls to grow appropriately.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要使自行车移动，并使墙壁适当地增长，只需这样做即可。
- en: Control buttons
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制按钮
- en: Now that the bike and walls are fleshed out, we turn our attention to the control
    buttons. As we have mentioned before, we are optimizing our graphics, so we actually
    only have a single black and white button to use for all the control buttons.
    Let's look at the class header first.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在自行车和墙壁都已经完善，我们将注意力转向控制按钮。正如我们之前提到的，我们正在优化我们的图形，所以我们实际上只有一个单色按钮用于所有控制按钮。让我们首先看看类头。
- en: '**Filename**: `CLButton.h`'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`CLButton.h`'
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here we have kept references to both `myPlayfield` and the `parentBike`. The
    variable `myPlayfield` references the main playfield layer of our game. The `parentBike`
    is the bike that will be controlled by this button. The Boolean variable `isLeft`
    is used to determine if this is a left turn button. If this is set to `NO`, it
    is a right turn button.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们保留了`myPlayfield`和`parentBike`的引用。变量`myPlayfield`引用了我们游戏的主要游戏区域层。`parentBike`是将被此按钮控制的自行车。布尔变量`isLeft`用于确定这是否是左转按钮。如果设置为`NO`，则它是右转按钮。
- en: We also have a convenience method to establish the class, which accepts values
    on behalf of these three variables, as well as a `playerNo` variable. The buttons
    need to know this for the same reason that we used it in the `CLBike` class; the
    buttons need to know on which end of the iPad they should be drawn.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个便利方法来建立类，它接受这三个变量的值，以及一个`playerNo`变量。按钮需要知道这一点，原因和我们在`CLBike`类中使用它的原因相同；按钮需要知道它们应该在iPad的哪一端绘制。
- en: '**Filename**: `CLButton.m`'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`CLButton.m`'
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here we see the beginning of the implementation. We flesh out the class method,
    which follows the convenience method of building an autoreleased object.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到了实现的开始。我们完善了类方法，它遵循构建自动释放对象的便利方法。
- en: '**Filename**: `CLButton.m`'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`CLButton.m`'
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the `initForBike` method, we begin by setting the three variables we saw
    in the header to their passed values. We then call `setColor` and tint the (formerly
    white) button to the `wallColor` of the `parentBike`. So now we will have a red
    or blue button, reflecting the player it controls.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在`initForBike`方法中，我们首先将标题中看到的三个变量设置为它们的传递值。然后我们调用`setColor`并将（以前是白色的）按钮着色为`parentBike`的`wallColor`。因此，现在我们将有一个红色或蓝色的按钮，反映出它控制的玩家。
- en: We set "base" values of the `newX` to be ¼ of the screen width, and `newY` to
    be 30\. We then have a switch statement using the `playerNo` variable to handle
    the placement of the buttons. For player 1, we check if this is the left button
    (the `isLeft` Boolean). If it is, we flip the button on its X axis. This is because
    our source graphic has the arrow pointing to the right. If it is the right button,
    we multiply the `newX` value by 3, so we are ¾ of the way across the screen.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`newX`的“基础”值设置为屏幕宽度的1/4，将`newY`设置为30。然后我们有一个使用`playerNo`变量的switch语句来处理按钮的位置。对于玩家1，我们检查这是否是左按钮（`isLeft`布尔值）。如果是，我们在X轴上翻转按钮。这是因为我们的源图形中箭头指向右边。如果是右按钮，我们将`newX`值乘以3，这样我们就处于屏幕的3/4处。
- en: For player 2, the logic is a little different, because we need to create the
    buttons at the top of the iPad, and completely backwards, compared to player 1\.
    We reset the `newY` value to 994 (1024 – 30). We also flip the buttons on the
    Y axis, so they will be facing the player. If the button is the left button, we
    need multiply the `newX` by 3 to move it to ¾ of the way across the screen. This
    will put it on the left, relative to the player. If it is the right button, we
    flip it on the X axis. Notice the `flipX` and `newX` are exactly opposite to the
    way we handled player 1\. Finally, we set the position to `newX`, `newY`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于玩家2，逻辑稍微有些不同，因为我们需要在iPad顶部创建按钮，与玩家1相比，方向完全相反。我们将`newY`值重置为994（1024 - 30）。我们还沿Y轴翻转按钮，使它们面向玩家。如果按钮是左按钮，我们需要将`newX`乘以3，将其移动到屏幕的3/4处。这将使其相对于玩家位于左侧。如果是右按钮，我们在X轴上翻转它。注意`flipX`和`newX`与我们处理玩家1的方式正好相反。最后，我们将位置设置为`newX`，`newY`。
- en: Touching buttons
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按钮触摸
- en: As you might imagine, we need a touch handler for the buttons.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，我们需要为按钮提供一个触摸处理程序。
- en: '**Filename**: `CLButton.m`'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`CLButton.m`'
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We begin by making sure that `myPlayfield` does not have the `isTouchBlocked`
    Boolean set to `YES`. This is used during the game over routine to prevent rapid
    touching of the screen from exiting the game screen too fast. Here, we don't want
    to accept any touches on the buttons if the game is in this state.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先确保`myPlayfield`没有将`isTouchBlocked`布尔值设置为`YES`。这在游戏结束例程中用于防止快速触摸屏幕导致游戏屏幕退出得太快。在这里，我们不想接受任何按钮上的触摸，如果游戏处于这种状态。
- en: 'We then convert the touch to OpenGL coordinates so we can determine what we
    touched. Now we define the `hitRect`, using something called `CGRectInset`. `CGRectInset`
    is used for transforming a `CGRect`. In this case, we are altering the bounding
    box for our evaluation. `CGRectInset` takes three arguments: a `CGRect`, the x
    inset, and the y inset. Using positive values will shrink the `CGRect`. Negative
    values will expand the `CGRect`. In our case, we are expanding the y value to
    effectively double the hit zone for the button. We do this because during testing,
    we determined that the button graphics, while visually satisfying, were a little
    too small to hit effectively during an exciting game. Rather than make huge buttons,
    we opted to simply expand the hit box.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将触摸转换为OpenGL坐标，以便确定我们触摸了什么。现在我们定义`hitRect`，使用`CGRectInset`。`CGRectInset`用于转换`CGRect`。在这种情况下，我们正在改变评估的边界框。`CGRectInset`接受三个参数：一个`CGRect`，x方向的缩进和y方向的缩进。使用正值将缩小`CGRect`。负值将扩展`CGRect`。在我们的例子中，我们扩展了y值，有效地将按钮的击中区域加倍。我们这样做是因为在测试中，我们发现按钮图形虽然视觉上令人满意，但在激动人心的游戏中击中效果略小。我们宁愿制作大按钮，也不愿简单地扩展击中区域。
- en: We then check to see if the `hitRect` contains the touched location. If it does,
    we then send either the `turnLeft` or `turnRight` message to the `parentBike`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们检查`hitRect`是否包含触摸位置。如果是，我们就向`parentBike`发送`turnLeft`或`turnRight`消息。
- en: Flashing with blocks
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用块进行闪烁
- en: We also call to `flashButton` to give visual feedback to the users.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还调用`flashButton`来给用户视觉反馈。
- en: '**Filename**: `CLButton.m`'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`CLButton.m`'
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here is the code for the `flashButton` method. We use the `CCTintTo` action
    to set the button to its original white color, and immediately set it back, using
    a `CCCallBlock` action. As we haven't really talked about blocks before, now is
    a good time.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`flashButton`方法的代码。我们使用`CCTintTo`动作将按钮设置为原始的白色颜色，然后立即使用`CCCallBlock`动作将其设置回原样。因为我们之前没有真正讨论过块，现在是讨论的好时机。
- en: 'A block is a self-contained chunk of code that can save a lot of "extra" code,
    and can use variables internally. Our example here is extremely simple, but the
    syntax might seem foreign. A block is wrapped in a structure like the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 块是一个自包含的代码块，可以节省大量的“额外”代码，并且可以在内部使用变量。我们这里的例子非常简单，但语法可能看起来很陌生。块被包裹在以下这样的结构中：
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There's a lot that can be done with blocks, but here it really saves us from
    building another method simply to make one call to `setColor`. (We could have
    built a separate method, and called it with `CCCallFunc` if we didn't want to
    use a block).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 块有很多用途，但在这里它确实让我们免于构建另一个方法来简单地调用一次`setColor`。（如果我们不想使用块，我们可以构建一个单独的方法，并用`CCCallFunc`调用它）。
- en: 'It is worth noting that blocks are only available in iOS 4.0 or higher, so
    code meant for older devices cannot use them. To learn about using blocks, we
    suggest consulting Apple''s documentation on the topic at: [http://developer.apple.com/library/ios/#documentation/cocoa/Conceptual/Blocks/Articles/00_Introduction.html](http://developer.apple.com/library/ios/#documentation/cocoa/Conceptual/Blocks/Articles/00_Introduction.html)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，块仅在iOS 4.0或更高版本中可用，因此针对旧设备的代码不能使用它们。要了解如何使用块，我们建议查阅苹果关于该主题的文档，请参阅：[http://developer.apple.com/library/ios/#documentation/cocoa/Conceptual/Blocks/Articles/00_Introduction.html](http://developer.apple.com/library/ios/#documentation/cocoa/Conceptual/Blocks/Articles/00_Introduction.html)
- en: Finishing the buttons
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成按钮
- en: We would be remiss if we didn't also include the `onEnter` and `onExit` methods
    for the `CLButton` class.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不包括`CLButton`类的`onEnter`和`onExit`方法，那将是我们的疏忽。
- en: '**Filename**: `CLButton.m`'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`CLButton.m`'
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We register a delegate with the touch dispatcher in the `onEnter` method, and
    we remove that delegate in the `onExit` method. We also set both the `parentBike`
    and `myPlayfield` to `nil`. It is always important to clean up after yourself.
    If we had failed to remove the delegate, this object would never be deallocated,
    and would leak.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`onEnter`方法中将一个代理注册到触摸分发器中，并在`onExit`方法中移除该代理。我们还把`parentBike`和`myPlayfield`都设置为`nil`。自己清理是很重要的。如果我们没有移除代理，这个对象将永远不会被释放，从而导致内存泄漏。
- en: Building the background grid
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建背景网格
- en: If we were to leave the background as it is, the game would look rather dull,
    with a black background. One option would be to simply drop in a background graphic
    to enhance the look. That would work, but we want to do something more dynamic
    to give the game some life. We will begin by using `CCRenderTexture` to build
    a sprite with a grid pattern on it.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们保持背景不变，游戏看起来会相当单调，背景是黑色的。一个选项是简单地插入一个背景图形来增强外观。这会有效，但我们想做一些更动态的事情来给游戏增添活力。我们将从使用`CCRenderTexture`构建一个带有网格图案的精灵开始。
- en: A `CCRenderTexture` can be thought of as a second "blank sheet of paper" on
    which we can draw primitive shapes (like lines), draw sprites upon, and generally
    do anything visual on it. The power of the `CCRenderTexture` is that you can then
    use the resulting image as a sprite. One of the primary benefits for our project
    is that we can draw our grid on it once, and use it. If we were to put the `ccDrawLine`
    calls into our main layer's `draw` method, it would be drawing them from scratch
    with every refresh. In our case, we are drawing the lines once, and then using
    the resulting textured sprite without the additional overhead of redrawing the
    lines.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将`CCRenderTexture`想象成第二张“空白纸”，我们可以在上面绘制原始形状（如线条），在上面绘制精灵，并在上面进行任何视觉操作。`CCRenderTexture`的强大之处在于你可以使用生成的图像作为精灵。对我们项目的一个主要好处是我们可以一次性在它上面绘制网格，并使用它。如果我们把`ccDrawLine`调用放入主层的`draw`方法中，它将每次刷新时从头开始绘制。在我们的情况下，我们只绘制一次线条，然后使用生成的纹理精灵，而不需要重新绘制线条的额外开销。
- en: Let's look at the `init` method first.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看`init`方法。
- en: '**Filename**: `CLRenderGrid.m`'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `CLRenderGrid.m`'
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We begin by creating `firstGrid` as a `CCRenderTexture` with the dimensions
    700 x 950\. This is slightly larger than will be visible, but we want to be able
    to move it around later without seeing the edges. We will skip the `drawGrid`
    method call for now. We set the anchor point to the center and position the `firstGrid`
    sprite in the center of the layer. It is important to note that to access the
    sprite properties of the `CCRenderTexture`, you must specify `[firstGrid sprite]`
    to get to them. The `CCRenderTexture` itself does not have these properties. We
    also set our opacity to `50`, so the resulting sprite will be semi-transparent.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个`firstGrid`作为`CCRenderTexture`，其尺寸为700 x 950。这比可见区域稍大，但我们希望能够在之后移动它时不会看到边缘。我们现在暂时跳过`drawGrid`方法的调用。我们将锚点设置为中心，并将`firstGrid`精灵放置在层的中心。需要注意的是，要访问`CCRenderTexture`的精灵属性，你必须指定`[firstGrid
    sprite]`来获取它们。`CCRenderTexture`本身并没有这些属性。我们还设置了不透明度为`50`，因此生成的精灵将是半透明的。
- en: 'The next call, `setBlendFunc`, is not often seen in tutorials or code samples.
    The values set here force the sprite to use the "normal" sprite blending function.
    By default, a `CCRenderTexture` uses the blend function `GL_ONE, GL_ONE_MINUS_SRC_ALPHA`,
    which effectively negates any opacity settings used. A tutorial on OpenGL blending
    functions is beyond the scope of this discussion. For further reading on the topic,
    a good starting point is: [http://www.khronos.org/opengles/sdk/docs/man/xhtml/glBlendFunc.xml](http://www.khronos.org/opengles/sdk/docs/man/xhtml/glBlendFunc.xml)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个调用`setBlendFunc`在教程或代码示例中不常见。这里设置的值强制精灵使用“正常”的精灵混合函数。默认情况下，`CCRenderTexture`使用混合函数`GL_ONE,
    GL_ONE_MINUS_SRC_ALPHA`，这实际上抵消了任何使用的透明度设置。OpenGL混合函数的教程超出了本次讨论的范围。关于这个主题的进一步阅读，一个好的起点是：[http://www.khronos.org/opengles/sdk/docs/man/xhtml/glBlendFunc.xml](http://www.khronos.org/opengles/sdk/docs/man/xhtml/glBlendFunc.xml)
- en: We wrap this up by adding the `firstGrid` to the layer. We have two placeholders
    for code we will add later.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将`firstGrid`添加到层中来结束这个过程。我们有两个占位符，稍后我们将添加代码。
- en: Drawing the grid
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制网格
- en: Now we will see how we draw to the render texture.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看到如何将内容绘制到渲染纹理上。
- en: '**Filename**: `CLRenderGrid.m`'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `CLRenderGrid.m`'
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To begin drawing on the render texture, we make the call to `begin`. To stop
    drawing, we call `end`. Everything in the middle is direct OpenGL drawing commands.
    We set the `glLineWidth` parameter to set the drawing pen size to 3 points wide.
    Whenever you are diving into drawing with OpenGL, you must keep in mind it does
    not have any direct knowledge of the points versus pixels scaling that cocos2d
    converts for you. Everything is in pixels only. So, to draw a line 3 points wide,
    we multiply the desired point size by the `CC_CONTENT_SCALE_FACTOR()`, which will
    be 1 for non-Retina devices, and 2 for Retina devices. This will give us the desired
    effect of a 3 point wide line, regardless of the display capabilities of the device.
    By using this scale factor "helper", it also means the code will not fail if we
    find ourselves using a device with a scale factor of 3 (though it doesn't exist,
    yet). We then set the drawing color using `ccDrawColor4F()`. The values of 1,1,1,
    and 1 translate to r, g, b, and a values, with all fully "on". This is an opaque
    white color.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始在渲染纹理上绘制，我们调用`begin`。要停止绘制，我们调用`end`。中间的所有内容都是直接的OpenGL绘制命令。我们设置`glLineWidth`参数来设置绘制笔的宽度为3点。每次你使用OpenGL进行绘制时，你必须记住它没有直接了解点与像素缩放的知识，这是cocos2d为你转换的。一切都是以像素为单位。因此，为了绘制一个3点宽的线，我们需要将期望的点大小乘以`CC_CONTENT_SCALE_FACTOR()`，对于非Retina设备将是1，对于Retina设备将是2。这将给我们一个3点宽线的期望效果，无论设备的显示能力如何。通过使用这个比例因子“辅助工具”，这也意味着如果我们的设备具有3的比例因子（尽管它目前还不存在），代码也不会失败。然后我们使用`ccDrawColor4F()`设置绘制颜色。1,1,1和1的值分别对应于r,
    g, b和a值，所有都是完全“开启”的。这是一种不透明的白色颜色。
- en: We set floats to help us keep our code readable. We set the left and bottom
    to `0`, since we want to fill the render texture's space with our drawing. Likewise,
    we set the right and top to the total width and height (respectively) of the render
    texture's canvas. By "asking" the `firstGrid.sprite` for the size of the texture,
    it means we can change the size of the render texture in the `init` method without
    adjusting this code at all. We also set the grid size to `40` pixels wide. This
    is a fairly arbitrary number. Smaller numbers create a tighter grid, larger numbers
    have more open space.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置浮点数以帮助我们的代码可读。我们将左和底设置为`0`，因为我们想用我们的绘制填充渲染纹理的空间。同样，我们将右和顶设置为渲染纹理画布的总宽度和高度（分别）。通过“询问”`firstGrid.sprite`纹理的大小，这意味着我们可以在`init`方法中更改渲染纹理的大小，而无需调整此代码。我们还设置了网格大小为`40`像素宽。这是一个相当随意的数字。较小的数字创建了一个更紧密的网格，较大的数字有更多的开放空间。
- en: We then use a `for` statement to draw the vertical lines. We loop through the
    `x` values from left to right, based on the floats we set earlier. One callout
    here is that we are not using the typical `x++` as the incrementor. Instead, we
    are using `x+=gridSize` as the incrementor. This controls the size of the "step"
    between the iterations. Using this means that the first iteration will use a value
    of 0, the second will be 40, then 80, and so forth. This will be perfectly placed
    for each line. We use the `ccDrawLine` function to draw a line from the bottom
    of the screen to the top with a constant value of x. This line is drawn every
    step of the loop, so it will fill the render texture with the vertical lines we
    need, at a 40 pixel spacing.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后使用一个`for`循环来绘制垂直线。我们根据之前设置的浮点数从左到右遍历`x`值。这里的一个说明是，我们不是使用典型的`x++`作为增量器。相反，我们使用`x+=gridSize`作为增量器。这控制了迭代之间的“步长”大小。使用这种方式意味着第一次迭代将使用0的值，第二次将是40，然后是80，以此类推。这将完美地放置每条线。我们使用`ccDrawLine`函数从屏幕底部绘制到顶部，x值保持恒定。这条线在循环的每一步都会绘制，因此它将以40像素的间隔填充我们需要的垂直线。
- en: We then do exactly the same thing for the horizontal lines. This time we iterate
    through values of y, and draw from the left to the right at a constant y value.
    By the end, we have a perfectly drawn square grid.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后对水平线做完全相同的事情。这次我们遍历`y`值，并在恒定的y值从左到右绘制。到结束时，我们有一个完美绘制的正方形网格。
- en: In the interest of good memory management, we must remember that we have alloc'd
    the `firstGrid`, so we need to dealloc it appropriately.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了良好的内存管理，我们必须记住我们已经分配了`firstGrid`，因此我们需要适当地释放它。
- en: '**Filename**: `CLRenderGrid.m`'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`CLRenderGrid.m`'
- en: '[PRE25]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It is important to always release whatever you have retained.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 总是释放你所保留的东西是很重要的。
- en: The second grid
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二个网格
- en: We actually want to have two grids to give more visual fluff. We could draw
    the grid onto another render texture, but that seems a bit silly, since we already
    have drawn it the way we want it. Instead, we will clone the texture into a new
    sprite. Insert the following code at the "second grid" placeholder.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上想要有两个网格以提供更多的视觉效果。我们可以在另一个渲染纹理上绘制网格，但这似乎有点愚蠢，因为我们已经按照我们想要的方式绘制了它。相反，我们将纹理克隆到一个新的精灵中。在“第二个网格”占位符处插入以下代码。
- en: '**Filename**: `CLRenderTexture.m` (inside `init` method)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`CLRenderTexture.m`（在`init`方法内）'
- en: '[PRE26]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This is very similar to the settings we used for the `firstGrid`, except when
    we instantiate the sprite, we use `spriteWithTexture`, and pass it the texture
    of the sprite contained in the `firstGrid` object. This allows us to have a second
    sprite exactly like the render texture's sprite, but it will only behave as a
    sprite. This means we will not be able to draw more on the `secondGrid` (sprite
    only), but we could draw more on the `firstGrid` (`CCRenderTexture`).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`firstGrid`的设置非常相似，只是在实例化精灵时，我们使用`spriteWithTexture`，并传递`firstGrid`对象中包含的精灵纹理。这允许我们有一个与渲染纹理的精灵完全相同的第二个精灵，但它只会作为精灵行为。这意味着我们无法在`secondGrid`（精灵）上绘制更多内容，但可以在`firstGrid`（`CCRenderTexture`）上绘制更多内容。
- en: Moving grids
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动网格
- en: Now we have two identical grids on top of each other. What we want is to set
    them both into continuous motion, preferably something we can start and forget
    about. We will be using `CCRepeatForever` actions to make it happen.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个重叠的相同网格。我们想要的是让它们都进入连续运动，最好是那种我们可以启动后就可以忘记的事情。我们将使用`CCRepeatForever`动作来实现这一点。
- en: '**Filename**: `CLRenderGrid.m`'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`CLRenderGrid.m`'
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here we set up two "sets" of actions. The first set moves the grid around in
    a perfectly repeating pattern (after all three actions are run, the coordinates
    are back to where you started). The second set of actions uses the `TintBy` action
    to alter the colors in a slow fading pattern. Looking at the durations, it is
    a full 12 seconds for a complete cycle of this set of tints. We then wrap both
    of these sets of actions into a `CCSequence` inside a `CCRepeatForever` action.
    Because the two sets of actions affect different aspects of the sprite, they can
    be run simultaneously. We run these both on the `firstGrid` sprite.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置了两组动作。第一组动作使网格在一个完美的重复模式中移动（在运行完三个动作后，坐标回到起点）。第二组动作使用`TintBy`动作以缓慢渐变的方式改变颜色。从持续时间来看，这一组颜色的完整周期需要12秒。然后我们将这两组动作都包裹在一个`CCSequence`中，并在一个`CCRepeatForever`动作内。因为这两组动作影响精灵的不同方面，它们可以同时运行。我们在`firstGrid`精灵上运行这两个动作。
- en: We do nearly the same thing on the second grid, although we move the grid in
    the other diagonal direction, and we tint from black to white, in an 11 second
    cycle. We run this on the `secondGrid`. (Consult the code bundle for this book
    to see the movement code for the `secondGrid` sprite.)
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个网格上，我们几乎做了同样的事情，尽管我们以其他对角方向移动网格，并且从黑色渐变到白色，在一个11秒的周期内。我们在`secondGrid`上运行这个动作。（请参阅本书的代码包，以查看`secondGrid`精灵的运动代码。）
- en: To tie it all together, we insert the following lines into the `init` method
    at the "start grids moving" placeholder.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这些内容串联起来，我们在“开始移动网格”占位符处将以下行插入到`init`方法中。
- en: '**Filename**: `CLRenderGrid.m` (inside `init` method)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`CLRenderGrid.m`（在`init`方法内）'
- en: '[PRE28]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The glScissor
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: The glScissor
- en: We have one problem remaining. The grid is larger than the part of the screen
    we want to draw it in. Ideally, we want the grid to move around, but only be visible
    inside the yellow outer walls. Using the OpenGL `glScissor` is exactly what we
    need. Like its name suggests, the `glScissor` is used to clip an image from being
    visible. Here, we want to trim the visible graphics for this entire layer at the
    yellow line.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个问题尚未解决。网格的大小大于我们想要在其中绘制的屏幕部分。理想情况下，我们希望网格可以移动，但只显示在黄色的外墙上。使用OpenGL的`glScissor`正是我们所需要的。正如其名称所暗示的，`glScissor`用于裁剪图像的可见性。在这里，我们想要修剪整个层的可见图形，直到黄色线。
- en: 'The following screenshot shows a before and after comparison:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了前后对比：
- en: '![The glScissor](img/9007_06_04.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![The glScissor](img/9007_06_04.jpg)'
- en: As you may have noticed, the `CLRenderGrid` is a subclass of `CCLayer`, so we
    have the same coordinate space for the layer that we do for the main grid. We
    can easily use `glScissor` to fix the problem.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经注意到的，`CLRenderGrid`是`CCLayer`的子类，因此我们对于层和主网格有相同的坐标空间。我们可以轻松地使用`glScissor`来解决这个问题。
- en: '**Filename**: `CLRenderGrid.m`'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`CLRenderGrid.m`'
- en: '[PRE29]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here we use the same coordinates we used for drawing the outer walls in the
    main playfield layer. As we said earlier, OpenGL is not aware of the scale of
    the device, so we multiply each value by the `CC_CONTENT_SCALE_FACTOR()`. This
    will give the same clipping boundaries in Retina and non-Retina devices.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用与在主游戏场层绘制外墙时相同的坐标。正如我们之前所说的，OpenGL 并不知道设备的比例，所以我们通过乘以 `CC_CONTENT_SCALE_FACTOR()`
    来调整每个值。这将使得在 Retina 和非 Retina 设备上具有相同的裁剪边界。
- en: The playfield
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏场
- en: We have assembled most of the "external" components, so it is time to turn our
    attention to the `CLPlayfieldLayer` class itself. Let's dive into the class instantiation
    and `init` methods first.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经组装了大部分“外部”组件，因此现在是时候将注意力转向 `CLPlayfieldLayer` 类本身了。让我们首先深入了解类的实例化和 `init`
    方法。
- en: '**Filename**: `CLPlayfieldLayer.m`'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`CLPlayfieldLayer.m`'
- en: '[PRE30]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We use another convenience method here, this time only accepting one parameter,
    `isRemoteGame`. For a local only game this will be `NO`, and `YES` if it is a
    Bluetooth game.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了一个便利的方法，这次只接受一个参数，`isRemoteGame`。对于仅本地游戏，这将设置为 `NO`，如果是蓝牙游戏，则设置为 `YES`。
- en: The `initWithRemoteGame` method is fairly basic. We set up our `cyclesheet`
    batch node, establish the `bikeWalls` array, and set a few Boolean values. We
    also add our `CLRenderGrid` as a child with a Z order of `-1`, to keep it behind
    the rest of the game. Then we add our outer walls, and that's it.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`initWithRemoteGame` 方法相当基础。我们设置了我们的 `cyclesheet` 批处理节点，建立了 `bikeWalls` 数组，并设置了一些布尔值。我们还添加了我们的
    `CLRenderGrid` 作为子节点，Z 轴顺序为 `-1`，以保持它在游戏其他部分之后。然后我们添加了外墙，这就完成了。'
- en: We put the actual bike building calls in the `onEnterTransitionDidFinish` method.
    We do this because if we choose to use a transition to enter the scene, we don't
    want the game starting up before the transition is complete.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实际的自行车构建调用放在 `onEnterTransitionDidFinish` 方法中。我们这样做是因为如果我们选择使用过渡来进入场景，我们不希望在过渡完成之前游戏就开始启动。
- en: '**Filename**: `CLPlayfieldLayer.m`'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`CLPlayfieldLayer.m`'
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We have left a small piece of the remote game code here, so you can see the
    difference in how we set up the start of the game. For a local game only, we set
    up both players, and schedule the update. We will look at the "generate" methods
    next.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里留下了一小段远程游戏代码，这样你可以看到我们如何设置游戏开始的方式。对于仅本地游戏，我们设置了两个玩家，并安排了更新。接下来我们将查看“生成”方法。
- en: Generating the bikes
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成自行车
- en: Adding the player bikes and buttons to the playfield is trivial here, since
    we have done most of the work in the `CLBike` and `CLButton` classes. We use nearly
    identical methods for the red and blue bikes, so we will only include one here.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，将玩家自行车和按钮添加到游戏场是微不足道的，因为我们已经在 `CLBike` 和 `CLButton` 类中做了大部分工作。我们对红色和蓝色自行车使用几乎相同的方法，所以我们这里只包括一个。
- en: '**Filename**: `CLPlayfieldLayer.m`'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`CLPlayfieldLayer.m`'
- en: '[PRE32]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here we instantiate a new `redBike`, specifying that it belongs to `kRedPlayer`,
    and we add it to the sheet. We then check if this is a `remotePlayer`. If it is
    not, then we also build the right and left buttons for the player. (Remote players
    do not need to have buttons drawn for this device). You will notice that we do
    not retain a reference to the buttons we create. The buttons need to know about
    the layer (as we saw earlier), and they need to know about the bike they are controlling,
    but the layer doesn't need to do anything special with the buttons except to add
    them as children of the layer. They are self-sufficient, so we can build them
    and ignore them here.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们实例化了一个新的 `redBike`，指定它属于 `kRedPlayer`，并将其添加到表中。然后我们检查这是否是一个 `remotePlayer`。如果不是，那么我们还会为玩家构建左右按钮。（远程玩家不需要为这个设备绘制按钮）。你会注意到我们没有保留我们创建的按钮的引用。按钮需要了解层（正如我们之前看到的），并且需要了解它们控制的自行车，但层除了将按钮作为层的子节点添加之外，不需要对按钮做任何特殊处理。它们是自给自足的，因此我们可以构建它们并在这里忽略它们。
- en: The `generateBlueAsPlayerNo:isRemote:` method is nearly identical, except the
    initial bike creation is instantiated as `blueBike`, with `kBluePlayer` as the
    parameter. As we discussed in the `CLBike` class earlier, we could probably collapse
    this into a single method, but separate methods like this are easier to follow.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`generateBlueAsPlayerNo:isRemote:` 方法几乎相同，除了初始自行车创建实例化为 `blueBike`，参数为 `kBluePlayer`。正如我们在之前的
    `CLBike` 类中讨论的，我们可能可以将这些合并为单个方法，但像这样的单独方法是更容易理解的。'
- en: Collision handling
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 碰撞处理
- en: When it comes to collision handling, we have already put all of the pieces into
    place to make collisions easy to check for. We have all walls in the game stored
    in the `bikeWalls` array. Each bike keeps track of both the `currentWall` and
    `priorWall` objects created by that bike. This is all we need to do to check for
    all possible collisions.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在碰撞处理方面，我们已经在游戏中放置了所有必要的组件，以便于检查碰撞。我们将所有墙壁存储在`bikeWalls`数组中。每辆自行车都跟踪由该自行车创建的`currentWall`和`priorWall`对象。这就是我们检查所有可能的碰撞所需做的所有事情。
- en: '**Filename**: `CLPlayfieldLayer.m`'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `CLPlayfieldLayer.m`'
- en: '[PRE33]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When we check for collisions, we iterate through all the wall sprites in the
    `bikeWalls` array. We first check for the `blueBike`. If its `boundingBox` intersects
    with the wall and the wall is not the `currentWall` or `priorWall` of the `blueBike`,
    then that bike crashed. We do the same check for the `redBike`, this time making
    sure it is not the `currentWall` or `priorWall` of the `redBike`. The question
    is probably coming to mind: why two walls for each bike? Isn''t tracking the `currentWall`
    object enough?'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们检查碰撞时，我们会遍历`bikeWalls`数组中的所有墙壁精灵。我们首先检查`blueBike`。如果它的`boundingBox`与墙壁相交，并且墙壁不是`blueBike`的`currentWall`或`priorWall`，那么这辆自行车发生了碰撞。我们对`redBike`也进行同样的检查，这次确保它不是`redBike`的`currentWall`或`priorWall`。可能你正在想这个问题：为什么每辆自行车有两个墙壁？跟踪`currentWall`对象不是足够了吗？
- en: When a bike turns, it turns at an abrupt right angle. The ending of the `priorWall`
    is at exactly the same point as the origin of the new `currentWall`. For a single
    update cycle, the bike is on this exact point. If we don't track the `priorWall`,
    then the bike will crash on that point. As there is no way the bike can correctly
    crash into the `priorWall`, we can safely ignore any collisions with it.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当自行车转弯时，它会以一个突然的直角转弯。`priorWall`的结束点正好与新的`currentWall`的起点相同。在一个更新周期内，自行车就位于这个确切点上。如果我们不跟踪`priorWall`，那么自行车就会在那个点上发生碰撞。由于自行车不可能正确地撞到`priorWall`，我们可以安全地忽略与它的任何碰撞。
- en: Making it move
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使其移动
- en: We use a very simple `update` method, which actually passes most of the control
    to the bikes themselves.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个非常简单的`update`方法，实际上是将大部分控制权交给了自行车本身。
- en: '**Filename**: `CLPlayfieldLayer.m`'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `CLPlayfieldLayer.m`'
- en: '[PRE34]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If the player is not a remote player, we tell the bike to move, using the `move`
    method we saw earlier. (In case you're wondering, we will handle the remote player's
    moves more explicitly). We then check for collisions after every move.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家不是远程玩家，我们告诉自行车移动，使用我们之前看到的`move`方法。（如果你想知道，我们将更明确地处理远程玩家的移动）。然后我们在每次移动后检查碰撞。
- en: Crashing bikes
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自行车碰撞
- en: Now we will look at what happens when a bike crashes. We want a little visual
    flair, so we will put the actual "crash" code in the `CLBike` class, but the core
    handler is in the `CLPlayfieldLayer` class, because the entire game needs to know
    about the crash, not just the bike.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将观察当自行车发生碰撞时会发生什么。我们希望有一些视觉上的亮点，所以我们将实际的“碰撞”代码放在`CLBike`类中，但核心处理程序在`CLPlayfieldLayer`类中，因为整个游戏都需要知道关于碰撞的信息，而不仅仅是自行车。
- en: '**Filename:** `CLPlayfieldLayer.m`'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `CLPlayfieldLayer.m`'
- en: '[PRE35]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We unscheduled the `update` method, told the bike that it crashed, and set a
    couple ofBoolean values. We used the `isTouchesBlocked` variable to prevent the
    player from rapidly mashing buttons and exiting the game without seeing the results.
    Players need a little time to enjoy their victory, or ponder their defeat. We
    will not cover the `displayGameOver` method in the book. Please consult the source
    code for that method. (It is a fairly basic "Red Player Wins!" label, not much
    more than that.)
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们取消了`update`方法的调度，告诉自行车它发生了碰撞，并设置了一些布尔值。我们使用了`isTouchesBlocked`变量来防止玩家快速按按钮，在没有看到结果的情况下退出游戏。玩家需要一点时间来享受他们的胜利，或者思考他们的失败。我们不会在书中介绍`displayGameOver`方法。请查阅该方法的源代码。（它是一个相当基本的“红玩家获胜！”标签，没有更多内容。）
- en: '**Filename**: `CLBike.m`'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `CLBike.m`'
- en: '[PRE36]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here we see the `crash` method. We remove the glow image, scale the sprite up
    to be really big, and then quickly fade it out. We also set the `isCrashed` variable
    to `YES`, which is used in the `displayGameOver` method to determine who won and
    who lost.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们看到`crash`方法。我们移除发光图像，将精灵放大到非常大，然后快速淡出。我们还设置了`isCrashed`变量为`YES`，这在`displayGameOver`方法中用来确定谁赢了谁输了。
- en: Bluetooth multiplayer
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蓝牙多人游戏
- en: 'We now have a complete two-player game on the same iPad. Now we will turn our
    attention to using GameKit to create a local Bluetooth game between two iPads.
    A word of caution to begin this discussion: this does not work correctly on the
    simulator, so you must have two iPads (any generation will do) in order to test
    this code.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个完整的双人对战游戏在同一 iPad 上。现在我们将注意力转向使用 GameKit 在两个 iPad 之间创建本地蓝牙游戏。在开始这个讨论之前，有一个警告：这在模拟器上不正确工作，所以您必须有两个
    iPad（任何一代都可以）来测试这段代码。
- en: To get the game prepared for using GameKit, we need to make sure the `GameKit.framework`
    is included in our project. You can check this by selecting your target project,
    and selecting the "Build Phases" heading. Then, expand the **Link Binary With
    Libraries** tab, and see if it is listed. If it is not, click on the **+** button
    at the bottom of the section, and select `GameKit.framework`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让游戏准备好使用 GameKit，我们需要确保 `GameKit.framework` 已包含在我们的项目中。您可以通过选择您的目标项目，并选择“构建阶段”标题来检查这一点。然后，展开
    **链接二进制与库** 选项卡，查看它是否列出。如果没有列出，请点击该部分底部的 **+** 按钮，并选择 `GameKit.framework`。
- en: 'In Xcode, it looks like the following screenshot:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xcode 中，它看起来如下截图所示：
- en: '![Bluetooth multiplayer](img/9007_06_05.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![蓝牙多人游戏](img/9007_06_05.jpg)'
- en: We also need to make a couple of additions to the `CLPlayfieldLayer.h` file
    to include the GameKit.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在 `CLPlayfieldLayer.h` 文件中添加一些内容以包含 GameKit。
- en: '**Filename**: `CLPlayfieldLayer.h` (partial)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`CLPlayfieldLayer.h`（部分）'
- en: '[PRE37]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As you can see, we have imported GameKit with the "framework style" angle brackets,
    and we have declared two delegate types for our `CLPlayfieldLayer` class. This
    will let us receive the callbacks from GameKit.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用“框架风格”的尖括号导入了 GameKit，并为我们的 `CLPlayfieldLayer` 类声明了两种代理类型。这将使我们能够接收来自
    GameKit 的回调。
- en: We also need a few specific variables in the header.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在头文件中添加一些特定的变量。
- en: '**Filename**: `CLPlayfieldLayer.h` (partial):'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`CLPlayfieldLayer.h`（部分）：'
- en: '[PRE38]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The first three are needed by GameKit itself, and the `playerNumber` is a variable
    that we will be using to handle the issue of which player gets which color bike.
    The `currentState` is our own variable that we will be using to handle refused
    connections.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个是 GameKit 本身需要的，`playerNumber` 是我们将用来处理哪个玩家得到哪种颜色自行车的变量。`currentState` 是我们自己的变量，我们将用它来处理拒绝的连接。
- en: Peer Picker
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Peer Picker
- en: We will be using the default Peer Picker that comes as part of GameKit. This
    is a full GUI interface for finding players and making the connection between
    the devices. This GUI is called the **Peer Picker**. There are quite a few callbacks
    that are needed, so don't be put off by the amount of code we are about to see.
    Most of it is boilerplate and can be re-used with little, if any, modifications
    in other projects.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 GameKit 随附的默认 Peer Picker。这是一个用于查找玩家和建立设备之间连接的全 GUI 界面。这个 GUI 被称为 **Peer
    Picker**。需要很多回调函数，所以不要因为即将看到的代码量而感到沮丧。其中大部分是样板代码，可以在其他项目中稍作修改后重复使用。
- en: '**Filename**: `CLPlayfieldLayer.m`'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`CLPlayfieldLayer.m`'
- en: '[PRE39]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We begin by creating the `GKPeerPickerController`, setting its delegate, and
    specifying the connection mask. The `connectionTypesMask` property controls what
    types of connections are considered when looking for a game. The value we have
    specified, `GKPeerPickerConnectionTypeNearby`, limits the Peer Picker to local
    Bluetooth connections only. We also set the starting `playerNumber` to be 1\.
    For the purposes of this game, player no. 1 is the red player, and player no.
    2 is the blue player.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建 `GKPeerPickerController`，设置其代理，并指定连接掩码。`connectionTypesMask` 属性控制查找游戏时考虑的连接类型。我们指定的值
    `GKPeerPickerConnectionTypeNearby` 将 Peer Picker 限制为仅本地蓝牙连接。我们还设置了起始的 `playerNumber`
    为 1。对于这个游戏来说，玩家 1 是红色玩家，玩家 2 是蓝色玩家。
- en: '**Filename**: `CLPlayfieldLayer.m`'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`CLPlayfieldLayer.m`'
- en: '[PRE40]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here we establish the `GKSession` for the connection. We limit the available
    connections even further by specifying the `SessionID`. In our case, it is `"Ch6_Cycles"`,
    which is the way our game identifies itself. This `SessionID` must match between
    the devices, or they will not be able to "see" each other. This does mean that
    both players must have the game running at the same time in order to attempt to
    connect with each other.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们建立了用于连接的 `GKSession`。通过指定 `SessionID` 进一步限制了可用的连接。在我们的例子中，它是 `"Ch6_Cycles"`，这是我们游戏识别自己的方式。这个
    `SessionID` 必须在设备之间匹配，否则它们将无法“看到”彼此。这也意味着两个玩家必须同时运行游戏才能尝试相互连接。
- en: 'We also set the `sessionMode` to be `GKSessionModePeer`. There are three types
    of sessions: client, server, and peer. A **peer** is essentially a client and
    server at the same time. This means it can initiate connections to a server (or
    another peer), or it can receive connections from a client (or another peer).
    In most cases, you would want to set this to peer, so you can send and receive
    connection requests.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将`sessionMode`设置为`GKSessionModePeer`。有三种类型的会话：客户端、服务器和对等。一个**对等**本质上既是客户端也是服务器。这意味着它可以向服务器（或另一个对等方）发起连接，或者它可以接收来自客户端（或另一个对等方）的连接。在大多数情况下，您希望将其设置为对等，这样您就可以发送和接收连接请求。
- en: '**Filename**: `CLPlayfieldLayer.m`'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`CLPlayfieldLayer.m`'
- en: '[PRE41]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This callback will be called when a connection to a peer is made. It will configure
    the `gkSession` that was created in the previous method to identify the receiver
    of the data (self, in our case). We also dismiss the `gkPicker`, since we are
    done picking our opponent. Finally, we store the `peerID` in the `gamePeerId`
    variable. This `peerID` is how the devices identify themselves. We store this
    because we will need it when we want to send messages to the other player.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当与对等方建立连接时，将调用此回调。它将配置在前面方法中创建的`gkSession`，以识别数据接收者（在我们的例子中是self）。我们还关闭了`gkPicker`，因为我们已经完成了对手的选择。最后，我们将`peerID`存储在`gamePeerId`变量中。这个`peerID`是设备识别自己的方式。我们存储它是因为当我们想要向另一名玩家发送消息时，我们需要它。
- en: '**Filename**: `CLPlayfieldLayer.m`'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`CLPlayfieldLayer.m`'
- en: '[PRE42]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The final callback we need for the Peer Picker is the `peerPickerControllerDidCancel`
    method. This is called if, at any point while the Peer Picker was active, the
    user clicked on **Cancel**. In this method, we release the delegate and invalidate
    (get rid of) the session that was created. The `invalidateSession` method will
    be covered shortly. We also added our own behavior, the call to the `returnToMainMenu`
    method.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Peer Picker，我们需要的最后一个回调方法是`peerPickerControllerDidCancel`。如果在Peer Picker活动期间，用户点击了**取消**，则会调用此方法。在这个方法中，我们释放代理并使会话无效（删除）创建的会话。`invalidateSession`方法将在稍后介绍。我们还添加了自己的行为，即调用`returnToMainMenu`方法。
- en: '**Filename**: `CLPlayfieldLayer.m`'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`CLPlayfieldLayer.m`'
- en: '[PRE43]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `returnToMainMenu` method checks to see if we have a `gkSession`, and will
    invalidate the session if needed. We then call the `replaceScene` method to go
    back to the menu scene.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`returnToMainMenu`方法检查我们是否有`gkSession`，并在需要时使会话无效。然后我们调用`replaceScene`方法回到菜单场景。'
- en: 'The following screenshot gives an example of what the Peer Picker GUI looks
    like:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了Peer Picker GUI的示例：
- en: '![Peer Picker](img/9007_06_06.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![Peer Picker](img/9007_06_06.jpg)'
- en: Session callbacks
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 会话回调
- en: Now we will look at the session delegate callback methods. These callbacks will
    be triggered based on the current state of the `gkSession` we created with the
    Peer Picker. There are a few smaller methods that we will examine first.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将查看会话代理回调方法。这些回调将基于我们使用Peer Picker创建的`gkSession`的当前状态触发。我们将首先检查几个较小的方法。
- en: '**Filename**: `CLPlayfieldLayer.m`'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`CLPlayfieldLayer.m`'
- en: '[PRE44]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This method is called when the game receives a connection request from a peer.
    This means that the other player is taking the role of client, and the current
    device is being asked to take the role of the server. We made the design decision
    that the client is always red, and the server is always blue. Since this request
    makes us the server, we change the `playerNumber` variable to 2 to identify this
    device as the blue player. Since this method will only be called by one of the
    two devices, we can be certain the other player is red.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏从对等方收到连接请求时，将调用此方法。这意味着另一名玩家正在扮演客户端的角色，当前设备被要求扮演服务器的角色。我们做出了设计决定，客户端始终是红色，服务器始终是蓝色。由于此请求使我们成为服务器，我们将`playerNumber`变量更改为2，以将此设备识别为蓝色玩家。由于此方法只由两个设备之一调用，我们可以确定另一名玩家是红色。
- en: '**Filename**: `CLPlayfieldLayer.m`'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`CLPlayfieldLayer.m`'
- en: '[PRE45]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: These two methods are called when there is a connection error. There's nothing
    we can do, so we have both methods dismiss the Peer Picker, and return the player
    to the main menu.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当出现连接错误时，将调用这两个方法。我们无法做任何事情，所以我们让两个方法关闭Peer Picker，并将玩家返回到主菜单。
- en: '**Filename**: `CLPlayfieldLayer.m`'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`CLPlayfieldLayer.m`'
- en: '[PRE46]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This method is called when we need to abandon the session. As we saw earlier,
    this will be called when the user cancels out of the Peer Picker. If the session
    exists, it disconnects from all peers, marks itself unavailable, removes all delegates,
    and gets rid of the session.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要放弃会话时，这个方法会被调用。如我们之前看到的，这将在用户取消 Peer Picker 时被调用。如果会话存在，它将断开与所有对等体的连接，标记自己不可用，移除所有代理，并消除会话。
- en: '**Filename**: `CLPlayfieldLayer.m`'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**：`CLPlayfieldLayer.m`'
- en: '[PRE47]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This method is called whenever the session''s state changes. We begin by checking
    for one specific condition. When PeerPicker receives a request, the device that
    would be the server will be presented with the option to accept or decline the
    connection. We need to identify if the user pressed the "Decline" button. We check
    to see if the `currentState` (which is set at the bottom of this method, now holding
    the value from the last call to this method) is `GKPeerStateConnecting`, and the
    new state (the state variable) is not `GKPeerStateConnected`, then we reset the
    `playerNumber`. Why do we do this? When the connection request is first received,
    the `session:didReceiveConnectionRequestFromPeer:` method was called. As we saw
    earlier, that sets the `playerNumber` to 2\. As there is no callback received
    when the "Decline" button is pressed in the PeerPicker, this is the only way we
    can trap this situation, so we can "undo" the `playerNumber` being set to 2\.
    Why do we care? If we do not have this trap in place, here is a scenario that
    can happen:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当会话状态改变时，这个方法会被调用。我们首先检查一个特定的条件。当 PeerPicker 收到请求时，将成为服务器的设备将面临接受或拒绝连接的选择。我们需要确定用户是否按下了“拒绝”按钮。我们检查
    `currentState`（该状态在此方法的底部设置，现在持有上次调用此方法的值）是否为 `GKPeerStateConnecting`，以及新的状态（状态变量）不是
    `GKPeerStateConnected`，然后重置 `playerNumber`。我们为什么要这样做？当连接请求首次收到时，调用了 `session:didReceiveConnectionRequestFromPeer:`
    方法。如我们之前看到的，这会将 `playerNumber` 设置为 2。因为没有在按下“拒绝”按钮时收到回调，这是我们唯一能够捕捉这种情况的方法，因此我们可以“撤销”将
    `playerNumber` 设置为 2。我们为什么要关心？如果我们没有设置这个陷阱，这里是一个可能发生的情况：
- en: Device 1 requests connection to Device 2\. (Device 2 is now PlayerNumber 2)
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备 1 请求连接到设备 2。（设备 2 现在是 PlayerNumber 2）
- en: Device 2 declines the connection.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备 2 拒绝了连接。
- en: Device 2 requests connection to Device 1\. (Device 1 is now PlayerNumber 2)
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备 2 请求连接到设备 1。（设备 1 现在是 PlayerNumber 2）
- en: Device 1 accepts the connection.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备 1 接受了连接。
- en: Game starts, and both players are BLUE, and think their opponent is RED.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏开始，两位玩家都是蓝色，并认为他们的对手是红色。
- en: By trapping the "Decline" condition, we can avoid this undesirable situation.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 通过捕捉“拒绝”条件，我们可以避免这种不希望的情况。
- en: 'There are two standard states we need to handle: `GKPeerStateConnected` and
    `GKPeerStateDisconnected`. If the game is connected, we check which `playerNumber`
    we are. If this is `playerNumber` 2 (server) we set up the bikes correctly for
    this side of the game. The remote player is red, starting at the top of the device
    (remember, that is what the `AsPlayerNo:2` represents), and we specify that this
    is a remote player, which means there will be no control buttons created. The
    local player is blue, in position 1 (bottom of iPad), with control buttons created.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要处理两种标准状态：`GKPeerStateConnected` 和 `GKPeerStateDisconnected`。如果游戏连接成功，我们会检查我们自己是哪个
    `playerNumber`。如果是 `playerNumber` 2（服务器），我们将为游戏这一侧正确设置自行车。远程玩家是红色，从设备的顶部开始（记住，这就是
    `AsPlayerNo:2` 所代表的），我们指定这是一个远程玩家，这意味着将不会创建控制按钮。本地玩家是蓝色，位于位置 1（iPad 的底部），并创建了控制按钮。
- en: If this is `playerNumber` 1 (client) then we do everything backwards. The local
    player is red with buttons, the remote player is blue, without buttons.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是 `playerNumber` 1（客户端）那么我们做相反的事情。本地玩家是红色带有按钮，远程玩家是蓝色，没有按钮。
- en: We then schedule the update method, and the game is on!
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们安排更新方法，游戏就开始了！
- en: If the state is changed to `GKPeerStateDisconnected`, we unschedule the update
    (in case the game was running when disconnected), and we create a `UIAlert` object
    to inform the player that they lost their connection.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果状态变为 `GKPeerStateDisconnected`，我们取消更新（以防游戏在断开连接时正在运行），并创建一个 `UIAlert` 对象来通知玩家他们失去了连接。
- en: Sending messages
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送消息
- en: 'So we have a connection. Now what? We need to be able to send messages to the
    remote device, and accept messages from the remote device. We have determined
    we only need to send two types of data: move distance and turn direction. We will
    never send "real" data for both at the same time, so we will need to parse out
    the messages and take appropriate action. Let''s look at the data sending method
    first.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经建立了连接。接下来是什么？我们需要能够向远程设备发送消息，并从远程设备接收消息。我们已经确定我们只需要发送两种类型的数据：移动距离和转向方向。我们永远不会同时发送“真实”数据，因此我们需要解析消息并采取适当的行动。让我们首先看看数据发送方法。
- en: '**Filename**: `CLPlayfieldLayer.m`'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `CLPlayfieldLayer.m`'
- en: '[PRE48]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Here we pass the turn direction, `dir`, and the distance travelled, `dist`.
    We create an `NSMutableData` object and wrap that in an `NSKeyedArchiver`. We
    encode both variables with explicitly named keys, and we send the data via the
    `gkSession`. In the `sendData` method, you see that we are using the `gamePeerId`
    we stored earlier, and we are also sending the data in a mode called `GKSendDataReliable`.
    When you send data, you can either send it reliably or unreliably. The difference
    is that reliable packets must arrive and be processed in order. Unreliable data
    gives no guarantee of when it will be delivered, nor in which order the messages
    will be received and processed. Since we definitely need our data to arrive in
    order, on time, we send this reliably.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们传递转向方向 `dir` 和行驶距离 `dist`。我们创建一个 `NSMutableData` 对象，并将其包装在一个 `NSKeyedArchiver`
    中。我们使用显式命名的键对两个变量进行编码，并通过 `gkSession` 发送数据。在 `sendData` 方法中，你可以看到我们正在使用之前存储的 `gamePeerId`，并且我们还在一个称为
    `GKSendDataReliable` 的模式下发送数据。当你发送数据时，你可以选择可靠地发送或不可靠地发送。区别在于可靠的数据包必须按顺序到达并被处理。不可靠的数据不保证何时交付，也不保证消息接收和处理的顺序。由于我们肯定需要我们的数据按顺序、准时到达，因此我们以可靠的方式发送。
- en: Receiving data
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接收数据
- en: Now let's see how to receive and process the data when we receive it.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看在接收到数据时如何接收和处理数据。
- en: '**Filename**: `CLPlayfieldLayer.m`'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `CLPlayfieldLayer.m`'
- en: '[PRE49]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: When we receive data, we create an `NSKeyedUnarchiver` to interface with the
    data received. We decode both variables, and store them in local variables `dir`
    and `dist` (we use the same names in both methods to avoid confusion). We then
    check to see which player is local to this device. If the local player is number
    1, then the messages we are receiving must be for the blue bike. Otherwise, they
    would be the red bike. We create `whichBike`, which will point to whichever bike
    we have determined should be moved. Then, we check to see if the direction is
    `kNoChange`. If it is, then this is a movement packet, so we call to the `moveForDistance`
    method for `whichBike`, and pass it the value of `dist`. This will explicitly
    move the remote player's bike on the local game. We then check to see if the direction
    was `kLeft` or `kRight`. For each, we call to the bike's `turnLeft` or `turnRight`
    method, as needed.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们接收到数据时，我们创建一个 `NSKeyedUnarchiver` 来与接收到的数据进行接口交互。我们解码两个变量，并将它们存储在局部变量 `dir`
    和 `dist` 中（我们在两种方法中都使用相同的名称以避免混淆）。然后，我们检查哪个玩家是本地设备上的。如果本地玩家是编号 1，那么我们接收到的消息必须是蓝色自行车的。否则，它们将是红色自行车。我们创建
    `whichBike`，它将指向我们确定应该移动的任何自行车。然后，我们检查方向是否为 `kNoChange`。如果是，那么这是一个移动数据包，因此我们调用
    `whichBike` 的 `moveForDistance` 方法，并传递 `dist` 的值。这将明确地在本地游戏中移动远程玩家的自行车。然后，我们检查方向是否为
    `kLeft` 或 `kRight`。对于每一个，根据需要调用自行车的 `turnLeft` 或 `turnRight` 方法。
- en: Upgrading our bikes
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 升级我们的自行车
- en: The `receiveData` method we just reviewed will handle everything we need in
    how to handle moving the remote bike on the local device. Now we need to upgrade
    our `CLBike` class to be able to send the appropriate messages to the remote device.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才审查的 `receiveData` 方法将处理我们在本地设备上移动远程自行车所需的所有内容。现在，我们需要升级我们的 `CLBike` 类，以便能够向远程设备发送适当的消息。
- en: '**Filename**: `CLBike.m`'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `CLBike.m`'
- en: '[PRE50]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In this method, we check to make sure we are playing a remote game, and that
    this bike does not belong to a remote player. If both of these conditions pass,
    we call to the `sendData` method in the `CLPlayfieldLayer`, and pass it the `distance`
    argument. We also pass the direction as `kNoChange`, so we know there is no turn
    included in this message. So what calls this method? In the `move` method of the
    `CLBike` class, we left a placeholder "remote game". Let's fill that in now.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在此方法中，我们检查确保我们正在玩远程游戏，并且这辆自行车不属于远程玩家。如果这两个条件都满足，我们将调用`CLPlayfieldLayer`中的`sendData`方法，并传递`distance`参数。我们还传递方向为`kNoChange`，这样我们就知道消息中不包含任何转向。那么谁调用这个方法呢？在`CLBike`类的`move`方法中，我们留下了一个“远程游戏”的占位符。现在让我们来填充它。
- en: '**Filename**: `CLBike.m`'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `CLBike.m`'
- en: '[PRE51]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: As you recall from the `update` method in the `CLPlayfieldLayer` class, we only
    call `move` if the bike is a local player. So the local player's bike will move
    itself (locally) and then send the message for the other device to move this bike
    on the other device. This is the reason we separated the `move` method from the
    `moveForDistance` method. The remote player's moves are processed directly through
    the `moveForDistance` method, so we will not re-send the remote player's moves
    back to this player's device.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从`CLPlayfieldLayer`类中的`update`方法回忆的那样，我们只有在自行车是本地玩家时才调用`move`。因此，本地玩家的自行车会自己（本地）移动，然后发送消息给其他设备，让其他设备上的自行车移动。这就是为什么我们将`move`方法从`moveForDistance`方法中分离出来的原因。远程玩家的移动将通过`moveForDistance`方法直接处理，因此我们不会将远程玩家的移动重新发送回此玩家的设备。
- en: We follow a similar approach for the turn commands. First we build a similar
    send method for turns.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 对于转向命令，我们采用类似的方法。首先，我们为转向构建一个类似的发送方法。
- en: '**Filename**: `CLBike.m`'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `CLBike.m`'
- en: '[PRE52]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Just as we did with the `sendPacketForMove` method earlier, we make sure this
    is a remote game and that the bike does not belong to a remote player. We then
    send the `turnDir` argument with a `distance` of `0`. As we saw with the `receiveData`
    method, the turns will be processed first, so it actually doesn't matter what
    value we send for distance, but it is a good idea to fill in default values to
    avoid unintended consequences of unexpected data.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前对`sendPacketForMove`方法所做的那样，我们确保这是一个远程游戏，并且自行车不属于远程玩家。然后我们发送`turnDir`参数，距离为`0`。正如我们在`receiveData`方法中看到的那样，转向将首先被处理，所以实际上我们发送的距离值并不重要，但填写默认值以避免意外数据带来的不良后果是一个好主意。
- en: To call this method, we insert code into the end of the `turnRight` and `turnLeft`
    methods we discussed earlier. In both methods, we insert the new code at the "Remote
    game" placeholder.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用此方法，我们需要将代码插入到之前讨论过的`turnRight`和`turnLeft`方法的末尾。在这两个方法中，我们在“远程游戏”占位符处插入新代码。
- en: '**Filename**: `CLBike.m` (`turnRight`)'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `CLBike.m` (`turnRight`)'
- en: '[PRE53]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '**Filename**: `CLBike.m` (`turnLeft`):'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名**: `CLBike.m` (`turnLeft`):'
- en: '[PRE54]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now, every time the player turns, we call to the `sendPacketForTurn` method,
    and if this is a local player, we will send the appropriate message to the remote
    device.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次玩家转向时，我们都调用`sendPacketForTurn`方法，如果是本地玩家，我们将向远程设备发送适当的消息。
- en: Why send moves?
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么发送移动？
- en: A natural question on a game like this is why do we send the move, if it is
    a predetermined, constant rate? The primary reason we do this is to avoid game
    glitches if a message was to get delayed.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这类游戏，一个自然的问题是我们为什么要发送移动，如果它是预定且恒定的速率呢？我们这样做的主要原因是为了避免如果消息延迟导致的游戏故障。
- en: Imagine a game where red is the local player, and blue is the remote player.
    We have implemented the game so we are only sending turns, not move forward messages.
    So on each update, the local device moves both players forward a distance of 5
    points. Blue turns, but the message is delayed slightly, so it is received two
    update cycles late. On the local (red player) game, blue has moved forward 10
    points, then turned. On the remote (blue player) game, the blue player has turned,
    then moved forward 10\. This means the two devices have a different image of the
    game board, and we cannot bring them back into sync. So blue might appear to crash
    into a wall on the red player's iPad, but is actually still alive and playing
    on their different version of the game board. The only way to avoid this sort
    of board mutation on this type of game is to do as we have and explicitly send
    every movement to the other player. This way we can guarantee that the game board
    as seen by either player is exactly the same.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个游戏，红色代表本地玩家，蓝色代表远程玩家。我们已经实现了这个游戏，所以我们只发送回合信息，而不是移动消息。因此，在每次更新时，本地设备将两个玩家向前移动5个点的距离。蓝色玩家轮到时，消息会有轻微的延迟，所以它会在两个更新周期后收到。在本地（红色玩家）的游戏中，蓝色玩家已经前进了10个点，然后转向。在远程（蓝色玩家）的游戏中，蓝色玩家已经转向，然后前进了10个点。这意味着两个设备对游戏板有不同的看法，我们无法将它们同步回来。所以蓝色玩家可能看起来在红色玩家的iPad上撞到了墙壁，但实际上他们还在他们不同的游戏版上玩游戏。避免这种游戏板突变的方法是像我们这样明确地发送每个动作给另一玩家。这样我们可以保证任何玩家看到的游戏板都是完全相同的。
- en: Summary
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we implemented our first iPad game, our first simultaneous
    two-player game, and our first two-player Bluetooth game. We spent some time learning
    about how we can optimize our images to make a lot out of very few graphic assets.
    We also saw how we can create a simple animated background using `CCRenderTexture`,
    and used `glScissor` to cut that moving image to fit a non-moving screen area.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们实现了我们的第一个iPad游戏，第一个同时双玩家游戏，以及第一个双玩家蓝牙游戏。我们花了一些时间学习如何优化我们的图像，以充分利用很少的图形资源。我们还看到了如何使用`CCRenderTexture`创建一个简单的动画背景，并使用`glScissor`将移动图像裁剪以适应非移动屏幕区域。
- en: We covered the basics of a GameKit two player game, and hopefully we had some
    fun along the way. There is a lot to learn about optimization for networked games,
    and we have so far only scratched the surface with what is possible. There is
    also a whole world of other connectivity and lag issues you will face when you
    branch out to include Internet-based multiplayer games. If you are interested
    in exploring that, I advise you to read up on Apple's documentation and use your
    favorite search engine to find other resources, as network communication code
    is a specialty unto itself.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了GameKit双玩家游戏的基础知识，并希望我们在过程中玩得开心。关于网络游戏的优化有很多东西要学习，而我们到目前为止只是触及了可能性的表面。当你扩展到包括基于互联网的多玩家游戏时，你还会面临整个其他连接和延迟问题。如果你对此感兴趣，我建议你阅读苹果的文档，并使用你喜欢的搜索引擎查找其他资源，因为网络通信代码本身就是一个专业领域。
- en: In the next chapter, we will revisit Box2D to build an old school top-down pool
    game. We will implement a rules system as well as experiment with different control
    mechanics. Rack 'em up, and let's start the next chapter!
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将重新审视Box2D来构建一个老式的俯视式台球游戏。我们将实现一个规则系统，并尝试不同的控制机制。摆好姿势，让我们开始下一章吧！
