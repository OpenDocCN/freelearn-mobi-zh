- en: Chapter 9. Autonomous Moving Agents
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章. 自主导航代理
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Introduction to steering behaviors
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航行为简介
- en: Implementing seek
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现寻找
- en: Implementing flee
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现逃离
- en: Implementing arrive
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现到达
- en: Implementing evade
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现规避
- en: Implementing wander
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现徘徊
- en: Implementing wall avoidance
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现避障
- en: Obstacle avoidance
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避障
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Games are interesting as they are challenging in each and every level. To make
    a game interesting, it's important to increase the difficulty of the game at each
    level. It's always interesting to defeat something in the game. In this chapter,
    we will learn about various ways to create the autonomous behavior for game objects.
    This chapter has a bunch of recipes to demonstrate the artificially intelligent
    game objects. To understand all the concepts in detail, it is recommended to read
    the previous chapter, which gives you a grip on mathematics and physics. Each
    recipe will allow you to understand and learn a specific autonomous behavior.
    By the end of this chapter, you will be able to understand and implement various
    autonomous game behaviors.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏很有趣，因为它们在每个级别都具有挑战性。为了使游戏有趣，重要的是在每个级别增加游戏的难度。在游戏中击败某物总是很有趣的。在本章中，我们将学习创建游戏对象自主导航行为的各种方法。本章包含一系列食谱来展示人工智能游戏对象。为了详细了解所有概念，建议阅读上一章，它为您提供了数学和物理的把握。每个食谱都将使您了解和学习特定的自主导航行为。到本章结束时，您将能够理解和实现各种自主导航游戏行为。
- en: Introduction to steering behaviors
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航行为简介
- en: AI characters are a type of autonomous agent that is intended to be used in
    computer games for showing virtual reality. These agents represent a character
    in a story or game and have some ability to follow some pre-set actions. Actions
    of these characters are directed in real time by a human player or participant.
    In games, autonomous characters are sometimes called non-player or artificially
    intelligent characters. An AI character always has some aspects of an autonomous
    robot with some predefined skills such as either they will be seeking some characters
    in the game or they will evade themselves from the playing character. All these
    behaviors are called steering behaviors.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: AI角色是一种旨在用于计算机游戏以展示虚拟现实的自主导航代理。这些代理代表故事或游戏中的角色，并具有执行一些预设动作的能力。这些角色的动作由人类玩家或参与者实时指导。在游戏中，自主导航角色有时被称为非玩家或人工智能角色。AI角色始终具有某些自主导航机器人的方面，并具有一些预定义的技能，例如他们可能会寻找游戏中的某些角色，或者他们可能会规避游戏中的角色。所有这些行为都被称为导航行为。
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'In this chapter, we will create a new game to demonstrate all the steering
    behaviors. To get started with the implementation, let us create a new project.
    Open Xcode and go to **File** | **New** | **Project**, and then select **iOS**
    | **Application** | **SpriteKit Game**. In the pop up provide the **Product Name**
    as `SteeringBehaviors`, select **Devices** | **iPhone**, and click on **Next**,
    as shown in the following screenshot:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个新的游戏来演示所有导航行为。为了开始实现，让我们创建一个新的项目。打开Xcode，转到**文件** | **新建** | **项目**，然后选择**iOS**
    | **应用程序** | **SpriteKit游戏**。在弹出的窗口中提供**产品名称**为`SteeringBehaviors`，选择**设备** |
    **iPhone**，然后点击**下一步**，如图所示：
- en: '![Getting ready](img/00136.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/00136.jpeg)'
- en: How to do it
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做
- en: 'Now we have our working sample project and we need to update the game template
    project to get started with code game logic. Perform the following steps to start
    working with the basic code flow for the game:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了我们的工作样本项目，我们需要更新游戏模板项目以开始编写游戏逻辑。执行以下步骤以开始使用游戏的基本代码流程：
- en: 'Open the `GameViewController.m` file and update the `viewDidLoad` method; remove
    all the code from this class and make it look something similar to the following
    lines of code:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`GameViewController.m`文件并更新`viewDidLoad`方法；从这个类中删除所有代码，使其看起来类似于以下代码行：
- en: '[PRE0]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Open the `GameScene.m` file; this class creates a scene, which will be plugged
    inside the game. Now, remove all the codes from this class and just add the following
    function:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`GameScene.m`文件；这个类创建一个场景，该场景将被插入到游戏中。现在，从这个类中删除所有代码，并添加以下函数：
- en: '[PRE1]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, compile and run the app; you should be able to see the background image
    correctly. This will look something similar to the following screenshot:![How
    to do it](img/00137.jpeg)
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编译并运行应用程序；您应该能够正确地看到背景图像。这看起来类似于以下截图：![如何做](img/00137.jpeg)
- en: Now we will need one AI character on which we will be implementing all our AI
    behaviors. So, we will create a new subclass of `SKSpriteNode` with the name `Player`.
    Go to **File** | **New** | **File**, then select **iOS** | **Source** | **Cocoa
    Touch Classes**, and click on **Next**. Now, change the **Subclass of** to **SKSpriteNode**,
    and **Class** name as `Player`. The final screen should look something similar
    to the following screenshot:![How to do it](img/00138.jpeg)
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要一个AI角色，我们将在这个角色上实现所有我们的AI行为。因此，我们将创建一个新的 `SKSpriteNode` 子类，命名为 `Player`。转到
    **文件** | **新建** | **文件**，然后选择 **iOS** | **源** | **Cocoa Touch Classes**，并点击 **下一步**。现在，将
    **子类为** 改为 **SKSpriteNode**，并将 **类名** 设置为 `Player`。最后的屏幕应该类似于以下截图：![如何操作](img/00138.jpeg)
- en: 'Now, open the `Player.m` file, and add the following code after `@implementation`:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开 `Player.m` 文件，并在 `@implementation` 之后添加以下代码：
- en: '[PRE2]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, add the declaration of both the methods in the `Player.h` file using the
    following code:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `Player.h` 文件中使用以下代码添加两个方法的声明：
- en: '[PRE3]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, open your `GameScene.m` file and add the following code right after your
    `initWithSize` method:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开你的 `GameScene.m` 文件，并在 `initWithSize` 方法之后添加以下代码：
- en: '[PRE4]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, add the `touchesBegan` method just after the `createPlayer` method. This
    method will give you all the touch events.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `createPlayer` 方法之后添加 `touchesBegan` 方法。此方法将提供所有触摸事件。
- en: 'So, nothing happened till now. Let''s make the game work for the first state.
    Now, add the following code:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，到目前为止还没有发生任何事情。让我们让游戏在第一个状态下工作。现在，添加以下代码：
- en: '[PRE5]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The final file should look something similar to the following screenshot:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的文件应该类似于以下截图：
- en: '![How to do it](img/00139.jpeg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作](img/00139.jpeg)'
- en: 'Now, compile and run the project. Touch on any location and you will see the
    square box is created on that location. Multiple sprites are added to the scene
    on the tap action. The output should look something similar to the following screenshot:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编译并运行项目。触摸任何位置，你将看到在触摸位置创建了一个方块。在点击动作中向场景中添加了多个精灵。输出应该类似于以下截图：
- en: '![How to do it](img/00140.jpeg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作](img/00140.jpeg)'
- en: Now we have a separate class for our player. This approach will help us to isolate
    all the features of the game character. Similarly, when we take the games to next
    levels, these are very useful as we can isolate the behaviors for various types
    of AI characters.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个单独的玩家类。这种方法将帮助我们隔离游戏角色的所有功能。同样，当我们将游戏提升到下一个级别时，这些方法非常有用，因为我们可以为各种类型的AI角色隔离行为。
- en: Implementing the seek
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现寻找
- en: To implement the seek behavior for our player, we will need a derive force that
    will redirect the agent toward a target position. In the seek behavior, our character
    will overshoot the target because the force applied on the player will be more,
    which will make the player overshoot the target and then return to the target.
    It will take a finite amount of time before coming to rest.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现玩家寻找行为，我们需要一个派生力，它将引导代理向目标位置移动。在寻找行为中，我们的角色会因为作用在玩家上的力更大而超过目标，这将使玩家超过目标然后返回目标。它将在一段时间后停止。
- en: Getting ready
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Seek behavior is something similar to the following screenshot:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找行为类似于以下截图：
- en: '![Getting ready](img/00141.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/00141.jpeg)'
- en: 'The preceding image explains the algorithm that will be used to implement the
    seek behavior. In our case, we will need to seek to the target and have to follow
    the following algorithm:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张图片解释了将要用于实现寻找行为的算法。在我们的情况下，我们需要寻找目标并遵循以下算法：
- en: '*Vector desiredVelocity = targetVector – player.locationVector;*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*Vector desiredVelocity = targetVector – player.locationVector;*'
- en: '*desiredVelocity.normalize;*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*desiredVelocity.normalize;*'
- en: '*desiredVelocity *= player.maxSpeed;*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*desiredVelocity *= player.maxSpeed;*'
- en: '*return (desiredVelocity – agent.locationVector);*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*return (desiredVelocity – agent.locationVector);*'
- en: How to do it
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Now we will start again on the project to implement the seek behaviors. Now,
    follow the steps below to implement the seek behavior:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将重新开始项目以实现寻找行为。现在，按照以下步骤实现寻找行为：
- en: 'Open the `Player.m` file and add the `enum` function on the top, after the
    import statements:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Player.m` 文件，并在导入语句之后添加 `enum` 函数：
- en: '[PRE6]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, add the following code after your interface:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在接口之后添加以下代码：
- en: '[PRE7]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `enum` holds the behavior we want to implement. Whenever we add any behavior,
    we will have to add it to this `enum`.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`enum` 包含我们要实现的行为。每次我们添加任何行为，我们都必须将其添加到这个 `enum` 中。'
- en: The target property will hold the location where we want the player to seek
    and `behaviourType` will tell us which behavior we want to implement.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 目标属性将保存我们希望玩家寻找的位置，而`behaviourType`将告诉我们要实现哪种行为。
- en: 'Now, to implement the seek, add the following function:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了实现寻找，添加以下函数：
- en: '[PRE8]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, add the following code in the update function:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在更新函数中添加以下代码：
- en: '[PRE9]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This function will be executed if the player behavior is set as seek.
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果玩家的行为设置为寻找，则将执行此函数。
- en: 'Now we are all set to test the function we have written in the previous few
    steps. So, open the `GameScene.m` file and create the instance of the `newPlayer`
    object at the top of the implementation file. The implementation code should look
    like the following:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好测试之前几步中编写的函数。因此，打开`GameScene.m`文件，并在实现文件顶部创建`newPlayer`对象的实例。实现代码应类似于以下截图：
- en: '[PRE10]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Also, add the following line of code in the `init` method we have written earlier:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还需要在之前编写的`init`方法中添加以下代码行：
- en: '[PRE11]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The final init function should look something similar to the following screenshot:'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最终的初始化函数应类似于以下截图：
- en: '![How to do it](img/00142.jpeg)'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做](img/00142.jpeg)'
- en: We have created a `newPlayer` object and have also associated the physics body
    with it.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经创建了一个`newPlayer`对象，并将其与物理体关联起来。
- en: 'Now we have our player ready to seek the target. Wherever we tap on the screen,
    the player will seek to that location. In the `touchesBegain:withEvent` method,
    add the following line of code:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们的玩家已经准备好寻找目标。无论我们在屏幕上点击哪里，玩家都会寻找那个位置。在`touchesBegain:withEvent`方法中，添加以下代码行：
- en: '[PRE12]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'So, now we are all set for the seek behavior. So, finally, we will call the
    player''s update method on every update of the scene, so that the player can seek
    to the location a user has tapped on. To perform this add the following code:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，现在我们已经准备好实现寻找行为。所以，最后，我们将在场景的每次更新时调用玩家的更新方法，以便玩家可以寻找用户点击屏幕上的位置。为此，请添加以下代码：
- en: '[PRE13]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the above line of code, we are calling the update function on each and every
    `newPlayer` object.
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在上述代码行中，我们正在对每个`newPlayer`对象调用更新函数。
- en: Now, compile and run the project; you will see the player in the center of the
    screen and it will seek the location that you will tap on the screen. The output
    should look something similar to the following screenshot:![How to do it](img/00143.jpeg)
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编译并运行项目；你将看到玩家位于屏幕中央，并且它会寻找你点击屏幕上的位置。输出应类似于以下截图：![如何做](img/00143.jpeg)
- en: This completes our seek behavior for the player object.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对玩家对象的寻找行为。
- en: There's more
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容
- en: You can read all these properties in more detail at Apple's developer documentation
    at [https://developer.apple.com/library/IOs/documentation/SpriteKit/Reference/SKPhysicsBody_Ref/index.html](https://developer.apple.com/library/IOs/documentation/SpriteKit/Reference/SKPhysicsBody_Ref/index.html).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在苹果开发者文档中详细了解所有这些属性：[https://developer.apple.com/library/IOs/documentation/SpriteKit/Reference/SKPhysicsBody_Ref/index.html](https://developer.apple.com/library/IOs/documentation/SpriteKit/Reference/SKPhysicsBody_Ref/index.html)。
- en: Implementing flee
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现逃避
- en: Flee is the opposite of the seek behavior, which steers the vehicle in the opposite
    direction from the target. Instead of producing the force toward target, we will
    push the player off to the target as the object has to flee from the target.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 逃避行为是寻找行为的相反，它将车辆引导到目标相反的方向。我们不会产生指向目标的力，而是将玩家推离目标，因为对象必须从目标处逃离。
- en: Getting ready
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To implement the flee behavior, we need to flee to the target and follow the
    following algorithm:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现逃避行为，我们需要逃离到目标，并遵循以下算法：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding algorithm, we are calculating the force that will be needed
    to flee the object off from the screen. First, we will calculate the direction
    vector to determine the direction opposite to the player, so that our object can
    flee from the target in that location. Now, in the second step, we normalize the
    vector and increase its magnitude to its max speed. Using this algorithm, we will
    implement the flee behavior for our object.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的算法中，我们正在计算将使对象从屏幕上逃离所需的力。首先，我们将计算方向向量以确定与玩家相反的方向，这样我们的对象就可以从目标处逃离。现在，在第二步中，我们将向量归一化并增加其大小到最大速度。使用此算法，我们将实现对象的逃避行为。
- en: How to do it
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做
- en: 'Perform the following steps to implement the flee behavior in the game:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以在游戏中实现逃避行为：
- en: 'Open the Player.m file and add the following line of code just after the seek
    function:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Player.m`文件，并在寻找函数之后添加以下代码行：
- en: '[PRE15]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, add the following code in the update function after the seek code:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在更新函数中seek代码之后添加以下代码：
- en: '[PRE16]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, our function is ready to flee the player. This function will accept a target
    from which it will flee. So, once again, we will be using the same approach, and
    when the user will tap on the screen, we will make the object flee from the tapped
    point. The final `Player.m` file should look something similar to the following
    screenshot:![How to do it](img/00144.jpeg)
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们的函数已经准备好让玩家逃离。这个函数将接受一个目标，从该目标逃离。所以，我们再次使用相同的方法，当用户点击屏幕时，我们将使对象从点击点逃离。最终的`Player.m`文件应类似于以下截图：![如何操作](img/00144.jpeg)
- en: 'Now our `Player.m` class is ready to execute the flee behavior. So, open the
    `GameScene.m` file and take the following line of code:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了`Player.m`类来执行逃离行为。所以，打开`GameScene.m`文件，并取以下代码行：
- en: '[PRE17]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, replace this with the following line of code:'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，将其替换为以下代码行：
- en: '[PRE18]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And also, add the following code:'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，还需要添加以下代码：
- en: '[PRE19]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, update the `if` condition from the above code to:'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，将上述代码中的`if`条件更新为：
- en: '[PRE20]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `init` function should look something similar to the following screenshot:![How
    to do it](img/00145.jpeg)
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`init`函数应类似于以下截图：![如何操作](img/00145.jpeg)'
- en: That's all. Now compile and run the project. You should be able to see the player
    and when you tap anywhere near to the player, you will see the player will flee
    from the tapped location.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 那就结束了。现在编译并运行项目。你应该能看到玩家，当你点击玩家附近的任何地方时，你会看到玩家会从点击的位置逃离。
- en: There's more
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多
- en: You can read all these properties in more detail at Apple's developer documentation
    at [https://developer.apple.com/library/IOs/documentation/SpriteKit/Reference/SKPhysicsBody_Ref/index.html](https://developer.apple.com/library/IOs/documentation/SpriteKit/Reference/SKPhysicsBody_Ref/index.html).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在苹果开发者文档中更详细地阅读所有这些属性，链接为[https://developer.apple.com/library/IOs/documentation/SpriteKit/Reference/SKPhysicsBody_Ref/index.html](https://developer.apple.com/library/IOs/documentation/SpriteKit/Reference/SKPhysicsBody_Ref/index.html)。
- en: Implementing arrive
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现到达
- en: Arrive is similar to seek. The only difference between seek and arrive is that
    in arrive the player will stop at the target location. However, in seek, it overshoots
    the target location and then seeks again.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 到达（Arrive）与寻找（Seek）类似。寻找（Seek）和到达（Arrive）之间的唯一区别在于，在到达（Arrive）中，玩家会在目标位置停止。然而，在寻找（Seek）中，它会超过目标位置，然后再寻找。
- en: Getting ready
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The technical definition of arrive is to reach the goal with zero velocity.
    The arrival behavior will remain the same as the seek behavior, the only difference
    is that it will not overshoot the target.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 到达（Arrive）的技术定义是以零速度到达目标。到达行为将与寻找行为保持一致，唯一的区别是它不会超过目标。
- en: In this approach, when the player is outside the stopping radius, it will follow
    the maximum speed toward the target, while as soon as the player is inside the
    stopping radius, the desired velocity of the player will be ramped down to zero.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，当玩家在停止半径之外时，它会以最大速度向目标移动，而一旦玩家进入停止半径，玩家的期望速度就会降至零。
- en: How to do it
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Perform the following steps to implement the arrive behavior:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以实现到达行为：
- en: 'Open the Player.m file, and add the following line of code in the end of the
    file:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Player.m`文件，并在文件末尾添加以下代码行：
- en: '[PRE21]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we have to call this function till our player is not in the stopping radius.
    So, we will create a box around our target point, and as soon as the player is
    inside this box, we will stop calling the arrive function. To implement this,
    add the following line of code in the update method:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须调用此函数，直到我们的玩家不在停止半径内。所以，我们将在目标点周围创建一个盒子，一旦玩家进入这个盒子，我们就停止调用到达函数。为了实现这一点，在更新方法中添加以下代码行：
- en: '[PRE22]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The final update function should look something similar to the following screenshot:'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最终的更新函数应类似于以下截图：
- en: '![How to do it](img/00146.jpeg)'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作](img/00146.jpeg)'
- en: 'Now, it''s time to check the arrive function we have written in the `Player.m`
    file. Open the `GameScene.m` file. Take the following line of code:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候检查我们在`Player.m`文件中编写的到达函数了。打开`GameScene.m`文件。取以下代码行：
- en: '[PRE23]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, replace this with the following line of code:'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，将其替换为以下代码行：
- en: '[PRE24]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now, compile and run the project; you should see our player in the center of
    the screen. Now, click anywhere on the screen to provide the target for the player.
    After you have tapped, the player will arrive at the target location you have
    tapped on with overshooting the target. The output should look something similar
    to the following screenshot:![How to do it](img/00147.jpeg)
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编译并运行项目；你应该能在屏幕中央看到我们的玩家。现在，点击屏幕上的任何位置为玩家提供目标。点击后，玩家将到达你点击的目标位置，并超过目标。输出应该类似于以下截图：![如何操作](img/00147.jpeg)
- en: The red pointer shows the target location where the player has to arrive.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 红色指针显示玩家必须到达的目标位置。
- en: There's more
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多
- en: You can read all these properties in more detail at Apple's developer documentation
    at [https://developer.apple.com/library/IOs/documentation/SpriteKit/Reference/SKPhysicsBody_Ref/index.html](https://developer.apple.com/library/IOs/documentation/SpriteKit/Reference/SKPhysicsBody_Ref/index.html).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在苹果开发者文档中更详细地了解所有这些属性：[https://developer.apple.com/library/IOs/documentation/SpriteKit/Reference/SKPhysicsBody_Ref/index.html](https://developer.apple.com/library/IOs/documentation/SpriteKit/Reference/SKPhysicsBody_Ref/index.html)。
- en: Implementing evade
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现规避
- en: Evade is similar to flee. The only difference between flee and evade is that
    in evade, the player will stop after fleeing to a safe location from the target
    location selected for evade. However, in flee, it just runs out of the screen
    from the target location and never comes back.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 规避类似于逃离。逃离和规避之间的唯一区别在于，在规避中，玩家将在从目标位置逃离到安全位置后停止，而在逃离中，它只是从目标位置跑出屏幕，永远不会回来。
- en: Getting ready
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Technically, evade is to flee from the target to the safe location. The evade
    behavior will remain the same as the flee behavior, the only difference is that
    it will not run away infinitely from the target.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，规避是从目标逃到安全位置。规避行为将与逃离行为相同，唯一的区别是它不会无限逃离目标。
- en: In this approach, when the target location is inside the safe range of the player,
    then the player will flee till the target location is not outside its safe range.
    So, in our case, we will make the player flee till the player is far from the
    target, and then its velocity will be ramped down to zero.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，当目标位置在玩家的安全范围内时，玩家将逃离，直到目标位置不再在其安全范围之外。因此，在我们的情况下，我们将使玩家逃离，直到远离目标，然后将其速度降至零。
- en: How to do it
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Perform the following steps to implement the evade behavior:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以实现规避行为：
- en: 'Open the `Player.m` file and add the following line of code in the end of the
    file:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Player.m`文件，并在文件末尾添加以下代码行：
- en: '[PRE25]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, add the following code in the `update` method:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`update`方法中添加以下代码：
- en: '[PRE26]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: After this, the update function should look something similar to the following
    screenshot:![How to do it](img/00148.jpeg)
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，更新函数应该看起来类似于以下截图：![如何操作](img/00148.jpeg)
- en: In the preceding function, we are drawing a rectangle on the target location
    vector. Whenever the player is inside this rectangle, it's not safe. So, it will
    flee to get the player outside into the safe location. So, we will execute our
    evade function till the player is in the rectangle.
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的函数中，我们在目标位置向量上绘制了一个矩形。每当玩家在这个矩形内时，就不安全。因此，它将逃离以将玩家移出矩形到安全位置。因此，我们将执行我们的规避函数，直到玩家在矩形内。
- en: 'Now, it''s time to test the evade function we have written in `Player.m`. So,
    open the `GameScene.m` file. Enter the following line of code:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候测试我们在`Player.m`中编写的规避函数了。所以，打开`GameScene.m`文件。输入以下代码行：
- en: '[PRE27]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, replace this with the following line of code:'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，将此替换为以下代码行：
- en: '[PRE28]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The final `init` method should look something similar to the following screenshot:![How
    to do it](img/00149.jpeg)
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终的`init`方法应该类似于以下截图：![如何操作](img/00149.jpeg)
- en: Now, compile and run the project to see the object player in action. Click anywhere
    near the player, and it will flee to maintain a certain distance from the location
    you have tapped, as shown in the following screenshot:![How to do it](img/00150.jpeg)
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编译并运行项目以查看对象玩家在动作中的表现。点击玩家附近的任何位置，它将逃离以保持与你点击的位置一定的距离，如图所示：![如何操作](img/00150.jpeg)
- en: There's more
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多
- en: You can read about all these properties in more detail at Apple's developer
    documentation at [https://developer.apple.com/library/IOs/documentation/SpriteKit/Reference/SKPhysicsBody_Ref/index.html](https://developer.apple.com/library/IOs/documentation/SpriteKit/Reference/SKPhysicsBody_Ref/index.html).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在苹果开发者文档中详细了解所有这些属性，网址为[https://developer.apple.com/library/IOs/documentation/SpriteKit/Reference/SKPhysicsBody_Ref/index.html](https://developer.apple.com/library/IOs/documentation/SpriteKit/Reference/SKPhysicsBody_Ref/index.html)。
- en: Implementing wander
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现游荡
- en: You might have observed very often in the game that few characters are just
    randomly moving around in their environment. These characters are waiting for
    some event to happen. For example, in any warfare game, the enemy soldiers are
    just wandering around in the castle to catch the player and they will keep on
    wandering till they find the player. Once the player is in the vicinity, then
    they will change their behavior to seek. So, the wandering ability of the characters
    makes them visually pleasant and realistic.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在游戏中经常观察到，一些角色只是随机地在他们的环境中移动。这些角色正在等待某个事件发生。例如，在任何战争游戏中，敌军士兵只是在城堡里四处游荡，试图捕捉玩家，他们会一直游荡，直到找到玩家。一旦玩家进入他们的附近，他们就会改变行为去寻找。因此，角色的游荡能力使它们看起来更加愉悦和逼真。
- en: Making a game object follow the path will make it unrealistic and will affect
    the overall game play by making it more predictive. So these wandering behaviors
    add much more fun and realistic behavior to the game.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使游戏对象遵循路径将使其显得不真实，并会影响整体游戏玩法，使其更具预测性。因此，这些游荡行为为游戏增添了更多的乐趣和逼真性。
- en: The wander steering behavior produces a realistic movement, which makes the
    players think that the character is just walking and to feel the whole environment
    more alive.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 游荡转向行为产生逼真的移动，使玩家感觉角色只是在行走，并使整个环境感觉更加生动。
- en: Getting ready
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'There are various ways to implement the wander behaviors. They are as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 实现游荡行为有多种方法。如下所示：
- en: Implementing wander using seek and randomness. In this approach, wander brings
    together two behaviors, seek and randomness. This means technically wander is
    just seeking to some random points and targets in the world.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用寻找和随机性来实现游荡。在这种方法中，游荡结合了两种行为，寻找和随机性。这意味着技术上，游荡只是在世界中的某些随机点和目标上寻找。
- en: The second way is to evaluate a virtual point in front of the character and
    draw a circle in front of it, and get point on it circumference. Now, make the
    object seek that location. The following image will explain the approach a little
    better:![Getting ready](img/00151.jpeg)
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种方法是在角色前方评估一个虚拟点，并在其前方画一个圆，然后获取圆周上的点。现在，让对象寻找该位置。以下图像将更好地解释这种方法：![准备工作](img/00151.jpeg)
- en: 'We will implement the first approach, so we will follow the following approach:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现第一种方法，因此我们将遵循以下方法：
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How to do it
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做
- en: 'Now we will implement the wander behavior and will take our project a little
    more further. Perform the following steps to implement the wander behavior:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将实现游荡行为，并将我们的项目推进得更远。按照以下步骤实现游荡行为：
- en: 'Open the `Player.m` file and add the following line of code in the end of the
    file:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Player.m`文件，并在文件末尾添加以下代码行：
- en: '[PRE30]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We have implemented the algorithm that we have seen in the start of this section.
    In this code, we are getting a random local point in front of the player, and
    then make the player to seek that location. This will make a wander behavior.
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经实现了本节开头看到的算法。在这段代码中，我们在玩家前方获取一个随机局部点，然后让玩家寻找该位置。这将产生游荡行为。
- en: 'Now, add the following line of code in the `update` method:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`update`方法中添加以下代码行：
- en: '[PRE31]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The final `update` function should look something similar to the following
    screenshot:'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最终的`update`函数应类似于以下截图：
- en: '![How to do it](img/00152.jpeg)'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做](img/00152.jpeg)'
- en: 'Now, it''s time to test the `evade` function we have written in `Player.m`.
    So, open the `GameScene.m` file and add the following line of code:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候测试我们在`Player.m`中编写的`evade`函数了。因此，打开`GameScene.m`文件，并添加以下代码行：
- en: '[PRE32]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, replace it with the following line of code:'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，将其替换为以下代码行：
- en: '[PRE33]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Also, add the following if condition right after the if we had for the seek
    and flee:'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 还在寻找和逃跑的if条件之后添加以下if条件：
- en: '[PRE34]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The final file should look something similar to the following screenshot:'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最终文件应类似于以下截图：
- en: '![How to do it](img/00153.jpeg)'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做](img/00153.jpeg)'
- en: Now, compile and run the project to see the object player in action. Click anywhere
    on the screen and the player will start wandering on the screen, as shown in the
    following screenshot:![How to do it](img/00154.jpeg)
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编译并运行项目以查看玩家对象的实际效果。点击屏幕上的任何位置，玩家将开始在屏幕上游荡，如下面的截图所示：![如何实现](img/00154.jpeg)
- en: There's more
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多
- en: You can read all these properties in more detail at Apple's developer documentation
    at [https://developer.apple.com/library/IOs/documentation/SpriteKit/Reference/SKPhysicsBody_Ref/index.html](https://developer.apple.com/library/IOs/documentation/SpriteKit/Reference/SKPhysicsBody_Ref/index.html).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在苹果开发者文档中更详细地阅读所有这些属性：[https://developer.apple.com/library/IOs/documentation/SpriteKit/Reference/SKPhysicsBody_Ref/index.html](https://developer.apple.com/library/IOs/documentation/SpriteKit/Reference/SKPhysicsBody_Ref/index.html)。
- en: Implementing wall avoidance
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现墙壁避障
- en: The AI characters will look a little odd if they collide with a wall while wandering.
    So, we have to make them even more intelligent so that they can seek the wall
    and can respond or change direction accordingly.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果AI角色在游荡时撞到墙壁，它们看起来会有些奇怪。因此，我们必须使它们更加智能，以便它们可以寻找墙壁并相应地做出反应或改变方向。
- en: The wander behavior returns a force that steers the AI away from the wall to
    avoid collision.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 游荡行为返回一个力，将AI从墙壁推开以避免碰撞。
- en: Getting ready
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'The following approach will be used to implement the wall avoidance behavior:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 将采用以下方法来实现墙壁避障行为：
- en: Create feelers to sense the wall
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建感知墙壁的触须
- en: We will use one feeler in front of the AI to sense the wall
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在AI前方使用一个触须来感知墙壁
- en: When wall is detected, apply the force at the reflected vector
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当检测到墙壁时，在反射向量上施加力
- en: How to do it
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现
- en: 'Follow the following algorithm to achieve the wall avoidance behavior in the
    project:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下算法在项目中实现墙壁避障行为：
- en: The visual explanation of the technique is shown in the following screenshot:![How
    to do it](img/00155.jpeg)
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该技术的视觉解释如下截图所示：![如何实现](img/00155.jpeg)
- en: 'Create feelers that will sense the wall:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建将感知墙壁的触须：
- en: '[PRE35]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This will project the feeler in front of the player.
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将在玩家前方投射触须。
- en: '[PRE36]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now we have got the `Front_Feeler` so let's apply the force in the same direction.
    This force will push the player away from the wall.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经得到了`Front_Feeler`，让我们在相同方向上施加力。这个力会将玩家推开墙壁。
- en: To fine-tune the behavior even more, you can additionally add two more feelers
    on the either side of the player. This will help player to take a more smooth
    turn and look realistic.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了进一步微调行为，你还可以在玩家两侧额外添加两个触须。这将帮助玩家进行更平滑的转弯并看起来更真实。
- en: Obstacle avoidance
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避障
- en: If the game objects are exhibiting the group behaviors, then it's really important
    to make them avoid collision with each other. Also, there can be multiple obstacles
    on the way, which the characters have to avoid intelligently.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果游戏对象表现出群体行为，那么避免彼此碰撞非常重要。此外，路径上可能有多个障碍物，角色必须智能地避开。
- en: Getting ready
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'The following approach will be used to implement the obstacle avoidance behavior:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 将采用以下方法来实现避障行为：
- en: Create three feelers in front of the player object
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在玩家对象前方创建三个触须
- en: Let all the three feelers sense the obstacles on the way
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让所有三个触须感知路径上的障碍物
- en: Redirect the player in the opposite direction if the feeler has sensed any obstacles
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果触须感知到任何障碍物，则将玩家重新定向到相反方向
- en: How to do it
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现
- en: Follow the following algorithm to achieve the obstacle avoidance behavior in
    the project.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下算法在项目中实现避障行为。
- en: The visual explanation of the technique is shown in the following screenshot:![How
    to do it](img/00156.jpeg)
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该技术的视觉解释如下截图所示：![如何实现](img/00156.jpeg)
- en: 'Create feelers that will sense the wall:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建将感知墙壁的触须：
- en: '[PRE37]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now we have left, right, and front feelers. So whenever these feelers will sense
    any object in their way, they will push the player away from the obstacle.
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们有了左、右和前触须。所以，当这些触须感知到它们路径上的任何物体时，它们会将玩家推开障碍物。
- en: There's more
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多
- en: 'There are a lot more steering behaviors that can make the games very interesting.
    There are various group behaviors as well, which can be explored after having
    a hands-on these behaviors. Few of the behaviors are as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多其他转向行为可以使游戏变得非常有趣。还有各种群体行为，在亲身体验这些行为之后可以进行探索。以下是一些行为：
- en: '**Flocking**: When the objects exhibit certain common behavior in groups, then
    that behavior is called flocking'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集群行为**：当物体以某种共同的行为在群体中表现时，这种行为被称为集群行为'
- en: '**Alignment**: When the objects exhibit some behavior that causes a particular
    character to line up with agents close by, then it''s called alignment'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对齐**：当物体表现出某种导致特定特征与附近的代理对齐的行为时，这被称为对齐'
- en: '**Cohesion**: In this behavior, the objects are steered toward the center of
    the mass of all the objects—that is, the average position of the agents within
    a certain radius'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**凝聚力**：在这种行为中，物体被引导向所有物体的质量中心——即，在一定半径内代理的平均位置'
- en: '**Separation**: In this behavior, the objects are steered away from all of
    their neighbors'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分离**：在这种行为中，物体被引导远离所有邻居'
- en: 'You can read more about these behaviors at:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接中了解更多关于这些行为的信息：
- en: '[http://gamedevelopment.tutsplus.com/tutorials/the-three-simple-rules-of-flocking-behaviors-alignment-cohesion-and-separation--gamedev-3444](http://gamedevelopment.tutsplus.com/tutorials/the-three-simple-rules-of-flocking-behaviors-alignment-cohesion-and-separation--gamedev-3444)'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://gamedevelopment.tutsplus.com/tutorials/the-three-simple-rules-of-flocking-behaviors-alignment-cohesion-and-separation--gamedev-3444](http://gamedevelopment.tutsplus.com/tutorials/the-three-simple-rules-of-flocking-behaviors-alignment-cohesion-and-separation--gamedev-3444)'
- en: '[http://www.red3d.com/cwr/steer/gdc99/](http://www.red3d.com/cwr/steer/gdc99/)'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.red3d.com/cwr/steer/gdc99/](http://www.red3d.com/cwr/steer/gdc99/)'
