- en: Adding Boundaries and Using Sprites to Create Explosions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加边界和使用精灵创建爆炸
- en: 'In our preceding chapter, we covered the part where we successfully detected
    collisions. Now that we have understood how to deal with collisions, we can play
    around with our knowledge and add some cool stuff to our game. This chapter will be
    pretty concise, and if you have understood the concept of collision detection
    properly, then this will be a breeze for you. Here''s what we will do in this
    chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们前面的章节中，我们介绍了成功检测碰撞的部分。现在我们已经了解了如何处理碰撞，我们可以利用我们的知识来为游戏添加一些酷炫的功能。本章将会非常简洁，如果你正确理解了碰撞检测的概念，那么对你来说这将是一个轻松的任务。以下是本章我们将要完成的内容：
- en: Add a ground for our player as a boundary
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为玩家添加一个作为边界的地面
- en: Detect a collision between our player and rocks
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测玩家与岩石之间的碰撞
- en: Spawn an explosion sprite on the point where a collision takes place
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在碰撞发生的位置生成一个爆炸精灵
- en: 'Observe that from the preceding tasks, we have already accomplished our second task,
    so we have to focus on the first and third tasks. Let''s dive into creating a
    ground for our player because right now our player is simply going down infinitely.
    We will also add an upper boundary in order to contain our player within the screen,
    otherwise, our player would go right outside the screen. Again, we will divide
    this chapter into two parts:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，从前面的任务中，我们已经完成了第二个任务，所以我们必须专注于第一个和第三个任务。让我们深入创建玩家的地面，因为现在玩家正在无限地下落。我们还将添加一个上边界，以将玩家限制在屏幕内，否则玩家会直接穿过屏幕。再次，我们将本章分为两部分：
- en: Adding boundaries to our game
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将边界添加到我们的游戏中
- en: Using sprites to create explosions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用精灵创建爆炸
- en: Let's get started!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Adding boundaries
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加边界
- en: 'As we are quite familiar with the process of creating a new class, we will
    simply create our two new classes for our upper and lower boundary and call them
    `UpperBoundary.java` and `LowerBoundary.java`, respectively. We have the following
    objectives for our boundaries:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们非常熟悉创建新类的流程，我们将简单地创建两个新类，分别用于上边界和下边界，并分别命名为 `UpperBoundary.java` 和 `LowerBoundary.java`。我们对边界有以下目标：
- en: Make them appear at the top and bottom of our game screen
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让它们出现在游戏屏幕的顶部和底部
- en: If a player collides with them, then reset the game
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果玩家与它们发生碰撞，则重置游戏
- en: With these objectives in mind, we will move ahead to create boundaries for our
    game.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些目标指导下，我们将继续创建游戏边界。
- en: Creating the classes for our boundaries
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建边界类
- en: 'Before actually creating our boundaries, we will need an image sprite in order
    to make them visible on the screen. For this purpose, we will take a simple sprite
    with a plain color. Here''s the sprite that we will be using for our game:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际创建边界之前，我们需要一个图像精灵，以便在屏幕上显示它们。为此，我们将使用一个简单的单色精灵。以下是我们将用于游戏的精灵：
- en: '![](img/B05066_07_01.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B05066_07_01.png)'
- en: Our ground.png file
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 ground.png 文件
- en: Also, we will place this file in our `res/drawable` folder as we did for our
    previous image files. Once you are done with this, move on to the next part.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将此文件放置在 `res/drawable` 文件夹中，就像我们之前处理图像文件一样。完成这些后，继续下一部分。
- en: 'So now, let''s create our `UpperBoundary.java` class. Go ahead, create a new
    class and write the following code in it:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在让我们创建 `UpperBoundary.java` 类。继续前进，创建一个新的类，并在其中写入以下代码：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this code, we are simply creating our boundary class with its constructor
    and `update()` and `draw()` functions. The constructor is pretty simple to understand
    here. Whenever we create an instance of our boundaries, we will pass in a sprite,
    the x y position, and the height. We will also set a speed in which the boundaries
    will move backward, giving an illusion that our player is moving forward.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们只是创建了一个边界类，包括其构造函数和 `update()` 以及 `draw()` 函数。这里的构造函数非常简单易懂。每次我们创建边界的一个实例时，我们将传递一个精灵、x
    y 位置和高度。我们还会设置一个速度，使边界向后移动，给人一种玩家正在向前移动的错觉。
- en: 'Like all our previous game objects, this class also extends our main `GameObj`
    class. In a similar way, we will also create our `LowerBoundary.java` class. The
    only change we will make is in our `height` and `width` variable and the rest
    of the entire code remains the same as that of the `UpperBoundary.java` file:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前所有的游戏对象一样，这个类也扩展了我们的主 `GameObj` 类。以类似的方式，我们也将创建 `LowerBoundary.java` 类。我们将做的唯一改变是在
    `height` 和 `width` 变量上，其余的整个代码与 `UpperBoundary.java` 文件相同：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note here that we are keeping the `height` constant since we want to spawn our
    bottom border as low as possible and thereby `200` is a safe limit for the same.
    You can experiment with these values as per your liking.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们保持`height`为常数，因为我们希望将底部边界生成得尽可能低，因此`200`是一个安全的限制。你可以根据自己的喜好实验这些值。
- en: Now that we have our classes ready, it is time for us to bring them into our
    game.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了我们的类，是时候将它们引入我们的游戏了。
- en: Creating boundaries in our game
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的游戏中创建边界
- en: We will go step by step here since this part may get a bit tricky. We will have
    to deal with a lot of math calculations for our boundaries as well as lots and
    lots of new variables. Let's start by declaring some variables in our `GameView.java`
    file.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一步一步地进行，因为这部分可能会有些棘手。我们还需要处理很多关于边界的数学计算，以及大量的新变量。让我们从在`GameView.java`文件中声明一些变量开始。
- en: Throughout this part, we will be working only in our `GameView.java` file.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，我们只会在我们的`GameView.java`文件中工作。
- en: Creating the variables required
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建所需的变量
- en: 'Here are the new variables that we will declare:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们将要声明的新的变量：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We create our `upperBoundary` and `lowerBoundary` variables as `ArrayList` to
    keep a track of our actual game object on the screen, then we also create two
    integer variables--`maxBoundaryHeight` and `minBoundaryHeight`--to keep a track
    of the maximum and minimum heights for our upper boundary. We also create two
    Boolean variables--`upBound` and `lowBound`--if our boundaries go out of our specified
    minimum or maximum height. The `progressDenom` variable is created as an integer
    in order to create a cool pattern for our ground rather than just being plane.
    Finally, we have a `newGameCreated` Boolean variable, which will reset our game
    automatically if our player crashes with any object.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建`upperBoundary`和`lowerBoundary`变量作为`ArrayList`，以跟踪屏幕上的实际游戏对象，然后我们还创建了两个整数变量`maxBoundaryHeight`和`minBoundaryHeight`，以跟踪上边界的最大和最小高度。我们还创建了两个布尔变量`upBound`和`lowBound`，如果我们的边界超出指定的最小或最大高度。`progressDenom`变量被创建为一个整数，以便为地面创建一个酷炫的模式，而不仅仅是平面。最后，我们有一个`newGameCreated`布尔变量，如果我们的玩家与任何对象相撞，它将自动重置游戏。
- en: We are set with our variables. We will now move on to referencing our boundaries
    when the game is started.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置了变量。现在，我们将继续在游戏开始时引用我们的边界。
- en: Referencing our boundaries
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用我们的边界
- en: 'Just as we assigned a value to our reference in our rocks, we will do the same for
    both our boundaries. We will do so in our `surfaceCreated()` method by adding
    the variables marked in bold:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在岩石中分配了一个值一样，我们也会为我们的边界做同样的事情。我们将在`surfaceCreated()`方法中这样做，通过添加以下标记的变量：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Looks neat! Now comes the tricky part. We will have to write the update logic
    for both our boundaries. Don't confuse this with the `update()` method in our
    individual boundaries. That update method will simply make our ground move backward.
    We will also need to actually write the logic to spawn them on screen. Let's see
    how to do that.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很整洁！现在到了棘手的部分。我们需要为我们的两个边界编写更新逻辑。不要将这个与我们的单个边界的`update()`方法混淆。那个更新方法将简单地使地面向后移动。我们还需要实际编写在屏幕上生成它们的逻辑。让我们看看如何做到这一点。
- en: Updating our boundaries
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新我们的边界
- en: 'We will be updating our upper boundaries on every 50th score and lower boundaries
    on every 40th score. Let''s write the code for our boundaries. This involves a
    lot of tricky mathematical calculations, so watch out. However, contradictory
    to that, every step is quite self-explanatory here. Here''s the base logic for
    our boundaries:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在每50分和每40分时更新我们的上边界和下边界。让我们为我们的边界编写代码。这涉及到很多复杂的数学计算，所以要注意。然而，与此相反，这里的每一步都很直观。以下是我们的边界的基本逻辑：
- en: Update on every 50th or 40th score
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每50分或40分更新一次
- en: Add our image onto the screen
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的图像添加到屏幕上
- en: After every frame, call the `update()` method in our boundary class
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每一帧之后，调用边界类中的`update()`方法
- en: If the boundary goes out of screen, then remove it
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果边界超出屏幕，则将其移除
- en: If either of the boundary exceeds its maximum or minimum value, then accordingly
    set its `upBound` or `lowBound` variable to either `true` or `false`, depending
    on its position
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果任何一个边界超过了其最大值或最小值，则相应地将其`upBound`或`lowBound`变量设置为`true`或`false`，具体取决于其位置
- en: 'This is the logic for our boundaries, and the same is repeated for both our
    upper and lower boundaries. This code block is written after our `draw()` method.
    We write the code for them as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的边界逻辑，并且对于我们的上边界和下边界都是重复的。这个代码块是在我们的 `draw()` 方法之后编写的。我们按照以下方式编写它们的代码：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, we have to actually draw our boundaries on our screen, so we will go to
    our `draw()` method to do so.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须实际上在我们的屏幕上绘制我们的边界，所以我们将进入我们的 `draw()` 方法来完成这个任务。
- en: Drawing our boundaries on the screen
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在屏幕上绘制我们的边界
- en: 'As with our previous images, we use the `draw()` method to write our code for
    displaying our ground on the screen:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前的图像一样，我们使用 `draw()` 方法来编写我们的代码，以便在屏幕上显示我们的地面：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Even this part is taken care of for now. Now, we have to look at the collision
    part of our ground. We need to detect a collision on our ground with the player.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这部分也已经处理好了。现在，我们必须查看我们地面的碰撞部分。我们需要检测玩家与地面之间的碰撞。
- en: Detecting a collision between the ground and player
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测地面和玩家之间的碰撞
- en: 'Since we have already created our collision method, we simply go ahead and
    use the function. We already have a clear understanding of how a collision works
    because of the previous chapter, so we write the following code in our `update()`
    method of our `GameView.java` file:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经有了一个碰撞方法，我们只需继续使用该函数。由于前一章，我们已经清楚地理解了碰撞是如何工作的，所以我们将在我们的 `GameView.java`
    文件的 `update()` 方法中编写以下代码：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Collision detection between the player and the ground is completed. Now, we
    also have to assign our maximum and minimum boundary heights as well as tweak
    them as per our `progressDenom`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家和地面之间的碰撞检测已完成。现在，我们还需要分配我们的最大和最小边界高度，并根据我们的 `progressDenom` 进行调整。
- en: Maximum and minimum boundary heights
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最大和最小边界高度
- en: 'In our `update()` method, we will assign these values based on the player score
    and `progressDenom`. We will also use this method to call our `updateUpperBound()`
    and `updateLowerBound()` methods that we created earlier in this chapter:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `update()` 方法中，我们将根据玩家得分和 `progressDenom` 分配这些值。我们还将使用此方法调用我们在此章中较早创建的
    `updateUpperBound()` 和 `updateLowerBound()` 方法：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We're almost there. Now, the only thing remaining to create is our `newGame()`
    function.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了。现在，唯一剩下要创建的是我们的 `newGame()` 函数。
- en: Creating a new game
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新的游戏
- en: 'We will create a `newGame()` function that will get called every time the player
    crashes with an object. We''re doing nothing, but just resetting our objects as
    they were initially when we started the game. So, here''s how we do it:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个 `newGame()` 函数，该函数将在玩家与对象碰撞时被调用。我们现在什么都没做，只是将对象重置为游戏开始时的初始状态。所以，我们这样做：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Also, we still have to call this function from somewhere. As per our objective,
    we need it to be called after our player crashes. So, we add an else block in
    our update function after our `if(playerCharacter.getPlaying())` condition, as
    follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们仍然需要在某个地方调用这个函数。根据我们的目标，我们需要它在玩家崩溃后调用。所以，我们在 `if(playerCharacter.getPlaying())`
    条件之后在我们的更新函数中添加一个 else 块，如下所示：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We''re ready with our code. Let''s review our code for changes marked in bold
    and check whether you missed any step:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码已经准备好了。让我们回顾一下代码中标记的变化，并检查你是否遗漏了任何步骤：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, build and run your game; we have our boundaries ready!:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，构建并运行你的游戏；我们已经准备好了边界！：
- en: '![](img/B05066_07_02.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B05066_07_02.png)'
- en: Our player won't fall down infinitely now
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家现在不会无限坠落
- en: We can now proceed to our next part of creating explosions on our screen.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续创建屏幕上的爆炸效果的下一部分。
- en: Creating explosions
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建爆炸效果
- en: 'We''re almost done with our game here, and only the following two parts are
    remaining:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里的游戏几乎完成了，只剩下以下两个部分：
- en: Adding particle effects of an explosion
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加爆炸效果的粒子效果
- en: Displaying our score on the screen
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在屏幕上显示我们的得分
- en: 'We will divide this part into two sections wherein we will finish half of our
    explosions in this chapter, and the further half will be completed along with
    the UI of our game that will then conclude this game. So, let''s get started with
    this now. For our explosion, we will be needing a sprite sheet. We will use the
    following sprite sheet for our game:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这部分分为两个部分，其中我们将完成本章的一半爆炸，另一半将与游戏的 UI 一起完成，从而结束这个游戏。所以，让我们现在开始。对于我们的爆炸效果，我们需要一个精灵图集。我们将使用以下精灵图集来制作我们的游戏：
- en: '![](img/B05066_07_03.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B05066_07_03.png)'
- en: Our explosion sprite sheet
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的爆炸精灵图集
- en: 'We will create a new class named `ExplosionEffect.java`. Note here that we
    will not be extending this file to our `GameObj` file since we don''t need any
    of the collision components of this image. We will simply spawn it on the screen
    and make it stay at the same place. So, open up your `ExplosionEffect.java` file
    and let''s define our variables first:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为`ExplosionEffect.java`的新类。请注意，我们不会将此文件扩展到`GameObj`文件中，因为我们不需要这个图像的任何碰撞组件。我们只需在屏幕上生成它并使其保持在同一位置。所以，打开你的`ExplosionEffect.java`文件，让我们首先定义我们的变量：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, we just need the `x`, `y` coordinates and the `height` and `width`
    as integer values. Also, observe here that we will be working with both rows and
    columns in this sprite sheet as opposed to our previous sprites where we just
    used a singular row or column and hence we will need an extra variable `row` to
    help us out with this problem. We need our `AnimationClass` variable in order
    to run our animation and, last but not the least, our `Bitmap spriteSheet` variable.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们只需要`x`、`y`坐标以及`height`和`width`作为整数值。此外，请注意，在这里我们将同时处理精灵图中的行和列，而之前的精灵我们只使用了一行或一列，因此我们需要一个额外的变量`row`来帮助我们解决这个问题。我们需要`AnimationClass`变量来运行我们的动画，最后但同样重要的是，我们的`Bitmap
    spriteSheet`变量。
- en: 'After this, we will define the constructor for our class as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将定义我们类的构造函数如下：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you observe this closely, you will see that we are simply repeating our steps
    that we did for our previous game objects, except that we have an extra `row`
    variable here that we defined earlier, and this will help us scan through the
    rows of our sprite sheet.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仔细观察，您会看到我们只是在重复之前为游戏对象所做的步骤，只是这里我们有一个之前定义的额外`row`变量，这将帮助我们扫描精灵图的行。
- en: 'Now, we are left with the `draw()` and `update()` methods for this class. We
    will also make a method to `getHeight()` of the sprite sheet in order for us to
    work on our calculations when we use this to actually spawn our explosion effects:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只剩下这个类的`draw()`和`update()`方法。我们还将创建一个用于精灵图`getHeight()`的方法，以便我们在使用这个方法实际生成爆炸效果时进行计算：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once you are done with these, ensure that your `ExplosionEffect.java` file
    looks like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，确保你的`ExplosionEffect.java`文件看起来像这样：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We are all set with our `ExplosionEffect.java` file; that's it for this chapter. We
    are ready with our class for our explosion, and we will start creating explosion
    effects on our screen after our rocks collide with our player in the next chapter.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好我们的`ExplosionEffect.java`文件；这就是本章的全部内容。我们已经准备好我们的爆炸类，在下一章中，我们将在岩石与玩家碰撞后开始在屏幕上创建爆炸效果。
- en: Summary
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We learned how to create boundaries for our game and also created our explosion
    effect file with the required components needed along with its constructor.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何为我们的游戏创建边界，并且创建了包含所需组件及其构造函数的爆炸效果文件。
- en: We now have a proper upper and lower boundary in our game and we also have created
    our foundation for adding explosions in our game after our player collides with
    rocks.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在游戏中有了适当的上下边界，并且我们在玩家与岩石碰撞后添加爆炸效果的基础已经建立。
- en: In the next chapter, we will spawn the explosion on the screen after our player
    collides with the rock and display our score on the screen as a User Interface
    component.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，当玩家与岩石碰撞后，我们将在屏幕上生成爆炸效果，并将分数作为用户界面组件显示在屏幕上。
