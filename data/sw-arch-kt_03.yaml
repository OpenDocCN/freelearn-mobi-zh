- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Polymorphism and Alternatives
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态性和替代方案
- en: In this chapter, we are going to take a real-life example and solve the problem
    by implementing various solutions using different approaches. We will use **polymorphism**
    as a baseline for the solution. Afterward, we will use other approaches that are
    powered by the Kotlin language. Finally, we will compare them and try to understand
    which one is suitable under which circumstances.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过实现各种不同的解决方案来解决一个真实生活中的例子问题。我们将使用**多态性**作为解决方案的基础。之后，我们将使用由Kotlin语言支持的其它方法。最后，我们将比较它们，并尝试理解在什么情况下哪种方法更合适。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Why Kotlin?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么选择Kotlin？
- en: Real-life example – revisited
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生活中的例子——重访
- en: Polymorphic solution
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态性解决方案
- en: Sealed class solution
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密封类解决方案
- en: Delegation solution
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 委派解决方案
- en: Functional solution
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式解决方案
- en: Comparison and summary
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较和总结
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find all the code files used in this chapter on GitHub: [https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-3](https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-3)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章使用的所有代码文件：[https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-3](https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-3)
- en: Why Kotlin?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择Kotlin？
- en: 'Kotlin is chosen to be the primary programming language for all the examples
    in this book. There are several reasons for this choice:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin被选为本书所有例子的主要编程语言。选择这个语言有几个原因：
- en: Kotlin has gained significant popularity since it was released in 2011
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自从2011年发布以来，Kotlin已经获得了显著的人气
- en: It can be used for both frontend and backend applications, which allows for
    a wide range of architecture topics to be illustrated with the same language
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以用于前端和后端应用程序，这使得可以使用相同的语言来展示广泛的架构主题
- en: It has a concise, readable, and expressive syntax that helps us understand the
    implementation without a deep understanding of the language
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有简洁、易读和表达性强的语法，这有助于我们理解实现，而无需深入了解语言
- en: It is interoperable with Java so code examples can leverage existing numerous
    libraries in both Java and Kotlin if applicable
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它与Java兼容，因此如果适用，代码示例可以利用Java和Kotlin中现有的众多库
- en: Real-life example – revisited
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生活中的例子——重访
- en: We are using the same real-life example as in *Chapters 1* and *2*. This example
    is as follows. In a village, households provide services to and receive services
    from other households. To provide clarity to the exchange of services among households,
    software was created to keep records of the contract for exchanged services (the
    “contract”).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用与*第1章*和*第2章*相同的真实生活例子。这个例子如下。在一个村庄里，家庭之间互相提供服务，并从其他家庭那里接受服务。为了使家庭之间服务交换的记录更加清晰，创建了一个软件来记录交换服务的合同（即“合同”）。
- en: 'After both households have agreed on the services to be exchanged in the contract,
    each household will need to perform the service. Here are a few examples:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在双方家庭在合同中同意交换的服务后，每个家庭都需要提供服务。以下是一些例子：
- en: Repairing a piece of furniture
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修理家具
- en: Making a dress
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作连衣裙
- en: Babysitting a toddler for *x* hours
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 照顾*x*小时的小孩
- en: Performing a trick at a party
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在聚会上表演魔术
- en: Donating a used piece of clothing
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捐赠一件二手衣物
- en: Providing food and drinks
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供食物和饮料
- en: Cleaning *n* rooms in the house
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理房屋中的*n*个房间
- en: 'We need to be able to capture the details of these services and to be able
    to verify that the service has been performed. Once both services in a contract
    have been performed, the contract is concluded and reaches its terminal state.
    Let us focus on one scenario, in which Household A performed a service for Household
    B and Household B confirmed that Household A performed the service as per the
    contract. The sequence of interactions can be briefly described in the following
    UML sequence diagram:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要能够捕捉这些服务的细节，并能够验证服务是否已经完成。一旦合同中的双方都完成了服务，合同就结束了，达到了其最终状态。让我们专注于一个场景，其中家庭A为家庭B提供服务，而家庭B确认家庭A按照合同完成了服务。交互的顺序可以简要描述如下UML序列图：
- en: '![Figure 3.1 – Revisiting the real-time example](img/B21737_03_1.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – 重访实时示例](img/B21737_03_1.jpg)'
- en: Figure 3.1 – Revisiting the real-time example
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 重访实时示例
- en: Inside the **Exchange Service**, we need to provide two functions. One function
    is provided for a household performing a service for the other household. Another
    function is provided for a household to confirm that the service was performed
    by the other household as per the contract. The problem is that distinct types
    of services would require different ways to claim and confirm completion.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在**交换服务**中，我们需要提供两个函数。一个函数是为一个家庭为另一个家庭提供服务而提供的。另一个函数是为一个家庭确认另一个家庭是否按照合同执行了服务。问题是，不同的服务类型需要不同的方式来声明和确认完成。
- en: For example, if the service is to repair an item, then it only takes the repairer
    household to acknowledge that the item has been repaired. The receiver household
    would confirm that the item was repaired. If the service is to babysit a toddler,
    then the babysitter household may instead log the hours spent babysitting to confirm
    that the service was performed. Sometimes, the service is an aggregation of multiple
    sub-services.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果服务是修理物品，那么只需要修理家庭确认物品已被修理。接收家庭会确认物品已被修理。如果服务是照看婴儿，那么保姆家庭可能会记录照看时间来确认服务已执行。有时，服务是多个子服务的组合。
- en: 'Minimally, there should be two functions to perform a service and to check
    whether a service was performed:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 至少应该有两个函数来执行服务并检查服务是否已执行：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For this exercise, let us assume that we need to support three types of services:
    plumbing, babysitting, and room cleaning:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个练习，让我们假设我们需要支持三种类型的服务：管道、保姆和房间清洁：
- en: The plumbing service requires the plumber household to report the service as
    started and completed; the other household then confirms this
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道服务需要管道家庭报告服务开始和完成；然后另一个家庭确认这一点
- en: The babysitting service requires the babysitter household to log the start of
    the session and track it until the other household picks up the toddler and logs
    the total duration of the service
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保姆服务需要保姆家庭记录会话的开始，并跟踪它，直到另一个家庭接走婴儿并记录服务的总时长
- en: The room cleaning service requires the cleaner household to log the start of
    the service and the rooms cleaned, then the other household to confirm that all
    rooms, as per the contract, have been cleaned
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 房间清洁服务需要清洁家庭记录服务的开始和清洁的房间，然后另一个家庭确认按照合同所有房间都已清洁
- en: Let us start by solving this exercise with a polymorphic approach.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先用多态方法解决这个问题。
- en: Polymorphic solution
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态解决方案
- en: In object-oriented programming, polymorphism provides a powerful way to abstract
    an interface of many forms. Polymorphism literally means *many forms* in Greek.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，多态提供了一种强大的方式来抽象多种形式的接口。多态在希腊语中字面意思是*多种形式*。
- en: 'The common interface of the households contains a function called `performService`
    to signal the start of the service, as well as a function called `wasServicePerformed`
    to return true if the service was performed as per the agreement:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 家庭的通用接口包含一个名为`performService`的函数，用于表示服务的开始，以及一个名为`wasServicePerformed`的函数，如果服务按照协议执行，则返回true：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This solution can be illustrated in the following UML class diagram:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案可以用以下UML类图来表示：
- en: '![Figure 3.2 – Polymorphic solution](img/B21737_03_2.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2 – 多态解决方案](img/B21737_03_2.jpg)'
- en: Figure 3.2 – Polymorphic solution
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 多态解决方案
- en: 'The `Plumbing` class is relatively simple. It provides a function for the household
    to start the service, a function to report the service completed, and a function
    for the other household to confirm that the service has been performed. Meanwhile,
    timestamps are recorded that indicate when the service was performed, completed,
    and confirmed:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`Plumbing`类相对简单。它提供了一个家庭开始服务的函数，一个报告服务完成的函数，以及一个供另一个家庭确认服务已执行的函数。同时，记录了服务执行、完成和确认的时间戳：'
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `Babysitting` class is different because the completion criterion is based
    on the duration of the service. The class’s constructor takes an agreed number
    of hours to determine whether the service has been completed. There is one function
    for the babysitter household to start the job and another for the other household
    to confirm the end of the job. If the duration is the same as or longer than the
    agreed hours, the service is considered performed:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`Babysitting`类不同，因为完成标准基于服务的持续时间。类的构造函数接受一个协议中约定的小时数来确定服务是否完成。有一个函数用于保姆家庭开始工作，另一个函数用于其他家庭确认工作的结束。如果持续时间与协议小时数相同或更长，则认为服务已完成：'
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `RoomCleaning` class has performed the service when all the rooms in agreement
    have been cleaned. The constructor takes a `Set` of room names, which is later
    used to check whether all of the rooms in the agreement have been cleaned. It
    has one function for the cleaner to start the job and another for the other household
    to confirm whether each room has been cleaned:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当协议中的所有房间都被清洁时，`RoomCleaning`类已执行了服务。构造函数接受一个房间名称的`Set`，稍后用于检查协议中的所有房间是否都已清洁。它有一个函数用于清洁工开始工作，另一个函数用于其他家庭确认每个房间是否已被清洁：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There is a `main` function to have all these households perform the service
    and the results are printed:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个`main`函数来让所有这些家庭执行服务，并将结果打印出来：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The program should print something like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 程序应打印出类似以下内容：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The plumbing service starts with a timestamp. Then it is completed with a timestamp
    after two hours. After three minutes, it is then confirmed as complete with a
    timestamp. Since all three timestamps exist, the service has been performed.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 水暖服务从时间戳开始。然后，在两小时后用时间戳完成。三分钟后，它被确认完成，并附有时间戳。由于存在所有三个时间戳，因此服务已经完成。
- en: The babysitting service has a duration of three hours in the agreement. It started
    with a timestamp and ended time with a timestamp three hours later. The duration
    is exactly three hours. This matches the agreed hours, so the service has been
    performed.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在协议中，保姆服务持续时间为三小时。它从时间戳开始，并在三小时后结束，附有时间戳。持续时间正好是三小时。这与协议中的小时数相匹配，因此服务已经完成。
- en: The room-cleaning service lists both the kitchen and the bathroom in the agreement.
    Only the kitchen was reported to be cleaned with a timestamp, so the service has
    not been performed yet.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 房间清洁服务在协议中列出了厨房和浴室。只有厨房被报告为已清洁，并附有时间戳，因此服务尚未完成。
- en: This approach results in a homogeneous yet polymorphic style and facilitates
    three different services that have certain shared behaviors.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法产生了一种既统一又多态的风格，并促进了三种具有某些共享行为的不同服务。
- en: Sealed class solution
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密封类解决方案
- en: The Kotlin language has a feature called **sealed class**, which restricts the
    class hierarchy and requires that all subclasses be defined at compile time. All
    subclasses need to be in the same package and module where the sealed class is
    defined. This also means that no third-party classes can be inherited from sealed
    classes.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin语言有一个名为**密封类**的功能，它限制了类层次结构，并要求在编译时定义所有子类。所有子类都需要在定义密封类的同一包和模块中。这也意味着不能从密封类继承第三方类。
- en: 'Here are a few observations from the polymorphic solution mentioned previously.
    Firstly, all subclasses have a `startedAt` field and an implementation of the
    `performService` function that sets the `startedAt` field. So, the sealed class
    solution can be modified from the polymorphic solution. The interface can be changed
    to a sealed class with the `startedAt` field and the `performService` function:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是之前提到的多态解决方案的一些观察结果。首先，所有子类都有一个`startedAt`字段和一个实现`performService`函数来设置`startedAt`字段的实现。因此，密封类解决方案可以从多态解决方案中修改。接口可以更改为具有`startedAt`字段和`performService`函数的密封类：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The subclasses can be simplified by using the sealed class implementation as
    follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下方式使用密封类实现来简化子类：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `performService` function has been implemented by the `Service` superclass,
    so there is no need to implement it in the subclasses:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`performService`函数已在`Service`超类中实现，因此无需在子类中实现它：'
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The same simplification applies to the `RoomCleaning` subclass:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的简化也适用于`RoomCleaning`子类：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The sealed `Service` class has the `startedAt` field and the `performService`
    function to facilitate the starting of the service, while the subclasses have
    their own variations to complete it.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 封闭的 `Service` 类具有 `startedAt` 字段和 `performService` 函数，以方便服务的启动，而子类有自己的变体来完成它。
- en: 'The power of the Kotlin sealed classes is not the restriction of having all
    subclasses known at compile time. The power lies in what the compiler does with
    the restriction. If we use the `when` construct together with sealed classes,
    we can reduce our program to be as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 封闭类的强大之处不在于在编译时对所有子类进行限制。其强大之处在于编译器如何处理这种限制。如果我们使用 `when` 构造与封闭类一起，我们可以将我们的程序简化如下：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As the `Service` class has the implementation of the `wasServicePerformed`
    function using the `when` construct, the subclasses do not need to implement this
    function at all:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Service` 类使用了 `when` 构造实现 `wasServicePerformed` 函数，子类根本不需要实现这个函数：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Like the `Plumbing` subclass, other subclasses will now only contain the body
    of functions related to completing the service in various forms:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 `Plumbing` 子类，其他子类现在将只包含以各种形式完成服务相关的函数体：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The compiler enforces that all subclasses are included in branches of the `when`
    construct. If they are not, it will not compile. In addition, the `this` instance
    is automatically cast (**smart cast**) to the specific subclass in each branch,
    so we can directly access the fields defined in the subclass.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器强制要求所有子类都包含在 `when` 构造的分支中。如果没有，则无法编译。此外，`this` 实例在每个分支中自动转换为特定的子类（**智能转换**），因此我们可以直接访问在子类中定义的字段。
- en: In this implementation, all variations of the check for services performed are
    grouped together in the `when` construct as branches. It is better than an `enum`
    implementation because you will not overlook a subclass, given that we do not
    use `else` as a branch.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，对执行服务的检查的所有变体都被组合在 `when` 构造中的分支。这比 `enum` 实现更好，因为我们不会忽略任何子类，因为我们没有使用
    `else` 作为分支。
- en: Also, as these are subclasses of a sealed class, all the subclasses are known
    and we can easily compare the variations in a single function.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于这些是封闭类的子类，所有子类都是已知的，我们可以轻松地在单个函数中比较这些变体。
- en: However, this pattern is useful only when there are a small number of subclasses
    and they have similar implementations. Also, this pattern does not support the
    extension of functionality outside the package.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种模式仅在存在少量子类且它们具有类似实现时才有用。此外，这种模式不支持在包外部扩展功能。
- en: Delegation solution
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理解决方案
- en: '**Delegation** is often considered an alternative to the polymorphic solution.
    In this approach, an extension of a function is implemented by delegating part
    of the responsibility to other classes and then extending its behaviors. As a
    result, there is no mandatory requirement to create a subclass. There are several
    reasons for that:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**代理**通常被认为是多态解决方案的替代方案。在这种方法中，通过将部分责任委托给其他类并扩展其行为来实现函数的扩展。因此，没有创建子类的强制性要求。这有几个原因：'
- en: Loose coupling and high cohesion
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 松散耦合与高度凝聚
- en: Separation of concerns
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关注点分离
- en: Easy substitution
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于替换
- en: Refactoring to the delegation solution
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构到代理解决方案
- en: Loose coupling and high cohesion
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 松散耦合与高度凝聚
- en: Using delegation, code can be reused and composed only for the parts that are
    needed. It is more flexible than inheriting a class that is likely to give the
    subclasses more than it needs. This results in looser coupling to the reused code
    while still maintaining high cohesion within the class.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用代理，代码可以仅针对需要的部分进行重用和组合。这比继承一个可能给子类提供过多功能的类更灵活。这导致与重用代码的耦合更松，同时在类内部保持高度的凝聚性。
- en: Separation of concerns
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关注点分离
- en: With the use of delegation, classes can be broken into small classes (sub-classes)
    that only have a single responsibility. These classes are only delegated on demand.
    As a result, each class has a clear focus and responsibility. Classes are therefore
    easier to maintain, test, and understand.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用代理，可以将类分解成只有单一职责的小类（子类）。这些类仅在需要时才进行代理。因此，每个类都有一个清晰的关注点和职责。因此，类更容易维护、测试和理解。
- en: We are also able to break away from any change of superclass in unrelated implementation
    that may cause unintended changes in behaviors. We simply separate unrelated implementations
    from what is really needed.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还能够摆脱任何与无关实现相关的超类变更，这可能会导致行为上的意外变化。我们只需将无关的实现与真正需要的东西分开。
- en: Easy substitution
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单替换
- en: If we need to have a different behavior, it is easier to swap the delegate object
    than to swap an inherited superclass. Not only are there fewer functions to implement
    in delegate objects than a different superclass but it is also possible to swap
    to delegate objects at runtime dynamically.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要有不同的行为，交换代理对象比交换继承的基类要容易。不仅代理对象中要实现的功能比不同的基类要少，而且还可以在运行时动态地交换代理对象。
- en: As long as the subclasses conform to the **Liskov Substitution Principle** (**LSP**),
    there is no behavioral change in substituting subclasses.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 只要子类符合**Liskov替换原则**（**LSP**），替换子类时不会有行为变化。
- en: Refactoring to the delegation solution
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构到代理解决方案
- en: 'To refactor to the delegation solution, we will break down responsibilities
    into smaller interfaces. We will have an interface that starts a service and another
    interface that checks whether a service was performed:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了重构到代理解决方案，我们将职责分解成更小的接口。我们将有一个启动服务的接口，另一个检查服务是否已执行的接口：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Plumbing, babysitting, and room cleaning are three services that are completed
    very differently.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 水暖、照看孩子和房间清洁是三种完成方式非常不同的服务。
- en: 'The plumbing service has three phases: *Started*, *Completed*, and *Confirmed*.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 水暖服务有三个阶段：*开始*、*完成*和*确认*。
- en: '![Figure 3.3 – A three-phase service](img/B21737_03_3.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3 – 三阶段服务](img/B21737_03_3.jpg)'
- en: Figure 3.3 – A three-phase service
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 三阶段服务
- en: 'It can be expressed as a `ThreePhaseService` that is also a `ServiceStarter`
    and `ServiceChecker`. However, we already have the concrete `Started` class as
    an implementation of `ServiceStarter`, so we can use the Kotlin delegation feature
    to specify that the implementation of `ServiceStarter` is realized by the `started`
    field provided in the constructor with a `Started` default value:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以表示为一个既是`ServiceStarter`又是`ServiceChecker`的`ThreePhaseService`。然而，我们已经有了一个作为`ServiceStarter`实现的`Started`具体类，因此我们可以使用Kotlin的代理功能来指定`ServiceStarter`的实现是通过构造函数中提供的具有`Started`默认值的`started`字段来实现的：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, `Plumbing` is merely a specialization of `ThreePhaseServiceImpl` that
    we can define as a one-liner by Kotlin delegation:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`Plumbing`仅仅是`ThreePhaseServiceImpl`的一个特化，我们可以通过Kotlin的代理定义为一个单行代码：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The babysitting service has only two phases: *Started* and *Ended*. The duration,
    or the amount of time between the start and end times, determines whether the
    service has been performed. Here is a simple UML state diagram to capture the
    phase transition.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 照看孩子的服务只有两个阶段：*开始*和*结束*。持续时间，即开始时间和结束时间之间的时间量，决定了服务是否已经执行。这里有一个简单的UML状态图来捕捉阶段转换。
- en: '![Figure 3.4 – Hourly service phase transition](img/B21737_03_4.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4 – 按小时服务阶段转换](img/B21737_03_4.jpg)'
- en: Figure 3.4 – Hourly service phase transition
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – 按小时服务阶段转换
- en: 'It can be expressed as an `HourlyService`. Again, we can make use of the Kotlin
    delegation to avoid code duplication:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以表示为一个`HourlyService`。同样，我们可以利用Kotlin的代理来避免代码重复：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After that, `Babysitting` is declared as a one-liner delegated class:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`Babysitting`被声明为一个单行代理类：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Lastly, the room cleaning service is repeated in a loop until all agreed items
    have been completed. Here is a simple UML state diagram to capture the phase transition.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，房间清洁服务会循环重复，直到所有约定的项目都已完成。这里有一个简单的UML状态图来捕捉阶段转换。
- en: '![Figure 3.5 – Itemized service phase transition](img/B21737_03_5.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图3.5 – 项目化服务阶段转换](img/B21737_03_5.jpg)'
- en: Figure 3.5 – Itemized service phase transition
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 – 项目化服务阶段转换
- en: 'We can treat each room as an item that is completed individually in the name
    of `ItemizedService`. We also use the generic `T` type to make it flexible:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将每个房间视为一个在`ItemizedService`的名义下单独完成的项目。我们还使用泛型`T`类型使其更灵活：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`RoomCleaning` can now be defined as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`RoomCleaning`现在可以定义如下：'
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This example of a delegation solution can be illustrated by the following UML
    class diagram:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代理解决方案的例子可以用以下UML类图来表示：
- en: '![Figure 3.6 – A delegation solution](img/B21737_03_6.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图3.6 – 代理解决方案](img/B21737_03_6.jpg)'
- en: Figure 3.6 – A delegation solution
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 – 代理解决方案
- en: 'Putting them all together, we need to modify a bit of the `main` function only
    because the function names are different. The program behaves in the same way:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 将它们全部放在一起，我们只需要修改一下 `main` 函数，因为函数名不同。程序的行为方式相同：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: From this example, we can see how easy it is to reuse the code. For example,
    if there is another service that needs to run for an agreed hour, we can reuse
    the `HourlyService` using delegation without the need to implement the same logic
    again. We also need not write the same test.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中，我们可以看到代码重用是多么容易。例如，如果有另一个服务需要运行约定的小时数，我们可以通过委托重用 `HourlyService`，而无需再次实现相同的逻辑。我们也不需要编写相同的测试。
- en: This pattern reduces duplicated code and testing. It also promotes each class
    to be more specific and focused on its responsibility. It makes any extension
    of existing features easier, since it does not impose inheriting a concrete superclass.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式减少了代码的重复和测试。它还促使每个类更加具体和专注于其职责。这使得对现有功能的任何扩展都变得更容易，因为它不强制继承一个具体的超类。
- en: Functional solution
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式解决方案
- en: '**Functional programming** uses a completely different mindset in approaching
    the problem. The fundamental elements can be categorized into **immutable data
    structures** and **pure functions**.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数式编程**在处理问题时采用了一种完全不同的思维方式。基本元素可以分为**不可变数据结构**和**纯函数**。'
- en: Immutable data structures
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变数据结构
- en: An immutable data structure cannot be changed once it has been created. If a
    new value is needed to capture a change, new data structure instances are created
    and usually transformed from the existing ones. This approach makes data reliable
    and thread-safe.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变数据结构一旦创建后就不能更改。如果需要新的值来捕捉变化，就需要创建新的数据结构实例，通常是从现有的实例转换而来。这种方法使得数据可靠且线程安全。
- en: Kotlin provides the `toString`, `hashcode`, and `equals` for free. Combined
    with the use of the `val` keyword and exclusive refereces to other immutable data,
    we can easily create an immutable data structure.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 免费提供了 `toString`、`hashCode` 和 `equals` 方法。结合使用 `val` 关键字和对其他不可变数据的独占引用，我们可以轻松创建不可变数据结构。
- en: 'Here are the equivalent data structures for the example:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是示例中等效的数据结构：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It is worth noting that all fields are declared with `val`, so the references
    cannot be changed. Also, the `Instant` class that is used in many fields is also
    immutable.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，所有字段都是用 `val` 声明的，因此引用不能更改。此外，在许多字段中使用的 `Instant` 类也是不可变的。
- en: The `Set` interface has no mutable functions declared. Although a mutable concrete
    implementation could be injected that makes the data class not strictly immutable,
    if we only use the functions declared in the interface and the concrete implementation
    conforms to the LSP, there should be no behavioral change.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`Set` 接口没有声明可变函数。尽管可以注入一个可变的具体实现，使得数据类不是严格不可变的，但如果只使用接口中声明的函数以及具体实现符合 LSP，则不应该有行为上的变化。'
- en: Also, the fields that may have a different value in another instance come with
    either a nullable declaration (?) or default values. Kotlin constructors can provide
    these values if they are not specified during invocation.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可能在不同实例中具有不同值的字段，要么带有可空声明（?），要么带有默认值。如果调用时未指定，Kotlin 构造函数可以提供这些值。
- en: 'Kotlin provides a `copy` function for data classes to be mutable as a separate
    instance. For example, a plumbing service can be started by the following code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 为数据类提供了一个 `copy` 函数，以便作为单独的实例进行可变操作。例如，可以通过以下代码启动管道服务：
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: However, merely using the `copy` function may seem too low-level and does not
    help communicate the intent of the code. It may be better to have a function with
    a better name such as `start` that invokes `copy` to make the intent obvious.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仅仅使用 `copy` 函数可能显得太低级，并且不能帮助传达代码的意图。可能更好的是有一个更好的名字的函数，例如 `start`，它调用 `copy`
    来使意图明显。
- en: Pure functions
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纯函数
- en: Functions are said to be pure if, when they are given the same input, they always
    produce the same output and have no side effects. To achieve this, the function
    does not mutate any external data or state. It does not use any randomization
    or system clock functions either. It does not invoke any function that creates
    side effects, such as making a database update or calling an external system remotely.
    It is deterministic, predictable, testable, and thread-safe.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数在给定相同输入时总是产生相同的输出并且没有副作用时，我们称这些函数为纯函数。为了实现这一点，函数不会修改任何外部数据或状态。它也不使用任何随机化或系统时钟函数。它不会调用任何创建副作用的功能，例如更新数据库或远程调用外部系统。它是确定性的、可预测的、可测试的和线程安全的。
- en: In the real-life example of the households used in this chapter, all three services
    need to start the service despite all of them having different forms. Also, we
    want to have a better function name to communicate intent. Kotlin supports `start`
    function can work with multiple types. In addition, we use **lambda expressions**
    so that each type can specify its own way to create a new instance of new values.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中使用的家庭实际例子中，尽管所有三种服务形式不同，但所有三种服务都需要启动服务。此外，我们希望有一个更好的函数名来传达意图。Kotlin支持的`start`函数可以与多种类型一起工作。此外，我们使用**lambda表达式**，以便每种类型都可以指定其创建新值实例的自己的方式。
- en: 'The `start` function looks something like the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`start`函数看起来可能如下所示：'
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It declares a generic `T` type as the function receiver so we can invoke the
    function in the style of `T.start` as an `T` type to create a new instance of
    `T` with the `startAt` time. This is an example of the invocation of the `start`
    function:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 它声明了一个通用的`T`类型作为函数接收者，因此我们可以以`T.start`的风格调用函数，作为`T`类型来创建一个具有`startAt`时间的`T`类型的新实例。这是`start`函数调用的一个示例：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`Plumbing()` creates a new instance of `Plumbing` without a `startAt` time.
    Then the `start` function is invoked by supplying an `Instant` object and a lambda
    expression specifying the creation of a new `Plumbing` instance with a `startedAt`
    field set using the `copy` function.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`Plumbing()`创建一个没有`startAt`时间的`Plumbing`新实例。然后通过提供一个`Instant`对象和一个lambda表达式来调用`start`函数，该lambda表达式指定使用`copy`函数设置`startedAt`字段以创建一个新的`Plumbing`实例。'
- en: The rest of the functions
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其余的函数
- en: 'Other functions that are specific to the types of services can be declared
    separately:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 可以单独声明针对服务类型特定的其他函数：
- en: '[PRE26]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that it is not mandatory to use extension functions for the preceding functions.
    They can be declared inside the body of their corresponding data classes. Declaring
    them as extension functions, however, does provide flexibility in that they can
    be in a different package than the data classes.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用扩展函数对于前面的函数不是强制的。它们可以声明在其对应的数据类体内。然而，将它们声明为扩展函数确实提供了灵活性，因为它们可以位于数据类不同的包中。
- en: The functions to determine whether the service was performed are also different
    for each type of service.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 确定服务是否已执行的功能对于每种类型的服务都是不同的。
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Lastly, the `main` function looks different from other solutions, mainly because
    every change in the service would end up in a new instance when using the main
    function:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`main`函数与其他解决方案看起来不同，主要是因为在使用`main`函数时，对服务的每次更改都会导致一个新的实例：
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Since every function uses the data class or the generic type as the receiver,
    the calls can be chained in the sense that the output of the current function
    is the input of the next.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个函数都使用数据类或通用类型作为接收者，因此调用可以在当前函数的输出是下一个函数的输入的意义上链式调用。
- en: 'The code could end up like the `Babysitting` object can be refactored to look
    like the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 代码最终可能像`Babysitting`对象可以被重构为如下所示：
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Comparing all the solutions
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较所有解决方案
- en: 'All these solutions are valid, though their styles vary a lot. It is important
    to understand the pros and cons of each approach so we can make an informed decision
    to apply the solution wherever appropriate:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些解决方案都是有效的，尽管它们的风格差异很大。了解每种方法的优缺点非常重要，这样我们就可以在适当的地方做出明智的决定来应用解决方案：
- en: '**Extensibility**:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：'
- en: '**Polymorphic**: Extensible outside package and module'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多态性**：可扩展到包和模块外部'
- en: '**Sealed classes**: Not extensible outside package or module'
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密封类**：不可扩展到包或模块外部'
- en: '**Delegation**: Extensible outside package and module'
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**委托**：可扩展到包和模块外部'
- en: '**Functional**: Extensible outside package and module'
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能性**：可扩展到包和模块外部'
- en: '**Readability and** **code cleanness**:'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可读性和** **代码整洁性**：'
- en: '**Polymorphic**: Subclasses may inherit unnecessary features from superclasses,
    creating noise while reading code; classes can be big'
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多态**：子类可能会从超类继承不必要的功能，在阅读代码时产生噪音；类可以很大'
- en: '**Sealed classes**: All subclasses are known at compile time; no missing branches;
    not suitable for too many subclasses'
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密封类**：所有子类在编译时都是已知的；没有缺失的分支；不适合太多子类'
- en: '**Delegation**: Small interfaces; multiple behavioral delegations can be complicated;
    promotes single responsibility per interface; only delegates behaviors on demand'
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**委托**：小接口；多个行为委托可能很复杂；促进每个接口的单个职责；仅在需要时委托行为'
- en: '**Functional**: Small classes and functions; easy to reason about immutable
    data and pure functions; not so easy readable when it uses recursion, monads,
    and higher-level abstractions'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数式**：小类和函数；易于推理不可变数据和纯函数；当使用递归、单子和高阶抽象时，可读性不是那么容易'
- en: '**Testability**:'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可测试性**：'
- en: '**Polymorphic**: Each subclass would require testing of all behaviors to ensure
    it behaves like its superclass, that is, that it conforms to the LSP; also, each
    subclass would require testing on subclass-specific logic'
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多态**：每个子类都需要测试所有行为以确保其行为与其超类一致，即它符合LSP；此外，每个子类都需要对其特定逻辑进行测试'
- en: '**Sealed classes**: Behaviors implemented in superclass only need to be tested
    once; any when clause and subclass-specific logic need to be tested'
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密封类**：在超类中实现的行为只需要测试一次；任何 `when` 子句和子类特定逻辑都需要测试'
- en: '**Delegation**: Each small behavioral unit can be tested individually and need
    not repeat in its delegation'
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**委托**：每个小行为单元都可以单独测试，在其委托中不需要重复'
- en: '**Functional**: All small classes and functions can be tested individually
    without the need for repetition; each test would only need to verify the output
    given the input'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数式**：所有小类和函数都可以单独测试，无需重复；每个测试只需验证给定的输入所给出的输出'
- en: '**Thread safety**:'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线程安全**：'
- en: '**Polymorphic**: Not thread-safe by nature'
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多态**：本质上不是线程安全的'
- en: '**Sealed classes**: Not thread-safe by nature'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密封类**：本质上不是线程安全的'
- en: '**Delegation**: Not thread-safe by nature'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**委托**：本质上不是线程安全的'
- en: '**Functional**: Thread-safe due to immutable data classes and pure functions'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数式**：由于不可变数据类和纯函数而线程安全'
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We used the example of three types of services (plumbing, babysitting, and room
    cleaning) that households can perform for each other, focusing on the start, completion,
    confirmation, and checks for whether the service was performed.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以家庭之间可以互相提供的三种类型的服务（管道、看护和房间清洁）为例，重点关注服务的开始、完成、确认以及是否执行了服务的检查。
- en: We presented a solution that uses traditional polymorphism in object-oriented
    programming. An interface was defined and implemented by three subclasses, one
    for each type of service. The `main` function uses these subclasses in a homogeneous
    yet polymorphic manner.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提出了一种使用面向对象编程中的传统多态的解决方案。定义了一个接口，并由三个子类实现，每个子类对应一种服务类型。`main` 函数以同质且多态的方式使用这些子类。
- en: We then used the Kotlin sealed class feature to restrict all subclasses to be
    known. A further variation was that the sealed class was used together with the
    `when` construct to handle all branches within the `when` block. It resulted in
    a function containing all variations of the service check behaviors suitable for
    a small and fixed number of subclasses in a package.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后使用了 Kotlin 的密封类特性来限制所有子类都必须是已知的。进一步的变体是，密封类与 `when` 构造一起使用来处理 `when` 块内的所有分支。这导致了一个包含适合包中少量且固定数量的子类的服务检查行为所有变体的函数。
- en: We presented an alternative solution that uses Kotlin delegation over polymorphism.
    We defined smaller interfaces for each responsibility and identified a service
    starter class. Then we created three classes that use the service starter class
    by delegation. Plumbing, babysitting, and room cleaning services were then declared
    as one-liners using delegation. This style allowed us to reuse code without inheriting
    a superclass that might have provided more than the subclasses needed.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提出了一种使用 Kotlin 委托而非多态的替代解决方案。我们为每个职责定义了更小的接口，并识别了一个服务启动类。然后我们创建了三个通过委托使用服务启动类的类。管道、看护和房间清洁服务随后被声明为单行代码，使用委托。这种风格允许我们重用代码，而无需继承可能提供比子类所需更多功能的超类。
- en: Then we used the functional approach to create immutable data classes for each
    type of service. We used parametric polymorphism and lambda expressions to create
    a `start` function for shared behavior among the three types of services. We declared
    several extension functions with the service as the receiver to enable chains
    of calls in the `main` function.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们采用函数式方法为每种服务类型创建了不可变的数据类。我们使用参数多态性和lambda表达式为三种服务类型之间的共享行为创建了一个`start`函数。我们声明了几个以服务作为接收者的扩展函数，以在`main`函数中启用调用链。
- en: Lastly, we compared all the solutions in terms of extensibility, code readability,
    testability, and thread safety. We also briefly mentioned when a particular solution
    is suitable and when it is not.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们从可扩展性、代码可读性、可测试性和线程安全性等方面比较了所有解决方案。我们还简要说明了何时使用特定的解决方案以及何时不适用。
- en: In the coming chapters, we will go through several architectural patterns commonly
    used in today’s industry. We will group similar patterns together and compare
    them so you will be able to customize them to solve real-life problems.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨当今行业中常用的几种架构模式。我们将把相似的模式分组在一起并进行比较，这样你就可以根据实际情况进行定制，以解决实际问题。
