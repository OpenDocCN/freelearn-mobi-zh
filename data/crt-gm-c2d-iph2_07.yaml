- en: Chapter 7. Playing Pool, Old School
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。老式台球
- en: In this chapter we will be developing another project using the Box2D physics
    engine. Our emphasis in this chapter will be on how to easily implement multiple
    control methods, as well as alternate rule sets.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 Box2D 物理引擎开发另一个项目。本章的重点将是如何轻松实现多种控制方法以及不同的规则集。
- en: 'In this chapter, we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Using sensors
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用传感器
- en: Implementing multiple control schemes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现多种控制方案
- en: Designing a rules engine
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计规则引擎
- en: The game is…
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏是…
- en: Our game in this chapter is an old-school, top-down pool game. While our goal
    is to have suitably realistic movements, our emphasis will be on a fun arcade-style
    game. The main reason for this is it is impossible to accurately simulate the
    physics of a physical pool table without using a full 3D environment. Since we
    are working in 2D, we will not have features such as backspin, putting "English"
    on the ball, and so forth. We will also be using "bar room" variations on the
    games we implement. We have made this choice because there are literally hundreds
    of variations of each established game, so we are opting for "more fun" rather
    than "official rules". The game will be a pass-and-play two player game.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的游戏是一个老式、俯视的台球游戏。虽然我们的目标是实现合适的真实感动作，但我们的重点将放在一个有趣的街机风格游戏上。主要原因是在不使用完整的3D环境的情况下，无法准确模拟物理台球的物理特性。由于我们是在2D环境中工作，我们将没有诸如反旋转、给球施加“英文”等特性。我们还将使用我们在实现的游戏中采用“酒吧室”变体。我们做出这个选择是因为每个已建立的游戏实际上有成百上千种变体，所以我们选择“更多乐趣”而不是“官方规则”。游戏将是一个传递和玩的双人游戏。
- en: Overall design
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整体设计
- en: To make a 2D pool game, there are really only a few objects we will need to
    render on the screen. The table will be made of the side rails and the pockets.
    The rest of the table, as far as we are concerned, is just graphic fluff. Of course,
    we will need to build the 15 numbered pool balls and the cue ball. We will also
    need a cue stick, which we will create as a sprite but it will not be a body in
    the Box2D physics simulation. Why not? If we were to create the pool cue as a
    physics-enabled body, then we would have to consider the "unintended hits" of
    the pool cue running into other (non-cue ball) balls on the table. While this
    might happen on a real table, it is generally undesirable. Instead, we will use
    the pool cue as a visual "marker" of the planned shot, with the distance from
    the ball acting as our measure of the strength of the shot. Most of the interactions
    on the pool table will be handled by the Box2D simulation itself, so that will
    be the easy part.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要制作一个2D台球游戏，实际上我们只需要在屏幕上渲染几个对象。台面将由边框和球洞组成。至于台面的其余部分，对我们来说，只是图形装饰。当然，我们需要构建15个编号的台球和母球。我们还需要一根球杆，我们将将其创建为一个精灵，但它不会是
    Box2D 物理模拟中的物体。为什么不是呢？如果我们把台球杆作为一个启用了物理的物体来创建，那么我们就必须考虑台球杆“意外击中”桌上的其他（非母球）球的情况。虽然这可能在现实桌球桌上发生，但通常是不受欢迎的。相反，我们将使用台球杆作为计划击球的视觉“标记”，球与球之间的距离将作为我们衡量击球强度的标准。大多数台球桌上的交互将由
    Box2D 模拟本身处理，所以这部分将是容易的。
- en: We will focus more on the control mechanisms and the rules engine in this chapter.
    We will adopt two different touch-based control mechanisms, and we will build
    a rules engine that can play "bar style" Eight Ball as well as Nine Ball. As we
    said in the introduction, we are using "bar rules" as a baseline approach. Feel
    free to extend the rules engine however you see fit to play pool your way.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更关注控制机制和规则引擎。我们将采用两种不同的基于触摸的控制机制，并构建一个可以玩“酒吧风格”八球和九球的规则引擎。正如我们在引言中所说，我们使用“酒吧规则”作为基线方法。请随意扩展规则引擎，以适应您玩台球的方式。
- en: Building the table
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建台面
- en: 'Our first task at hand is to build the pool table. We will start by looking
    at our definitions, because we will be using these extensively throughout this
    chapter:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的首要任务是构建台球桌。我们将从查看我们的定义开始，因为我们将在这章中广泛使用这些定义：
- en: '**Filename:** `OPDefinitions.h`'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `OPDefinitions.h`'
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You should be familiar with `typedef` `enum` statements by now. We create the
    `BallID` type to represent the numbered balls for simplicity. To be able to easily
    convert from `NSInteger` values to `BallID` values, we set the numbered balls
    to equal the number on the balls. The cue is zero, and we also keep a reference
    for `kBallNone` as `-1` so we can cover our bases (useful when detecting a table
    scratch). We define two types of `RackLayoutType`, diamond and triangle. We also
    set our `GameMode` to be stripes, solids, ordered, or stripes versus solids. We
    use this last value to identify the game before anyone has pocketed any stripes
    or solids (also known as the table being "open"). We also have the `#define` statement
    to define the `kPocket` as `500`. We will use this in our collision detection
    to determine when a ball hits a pocket. Finally, there is also the `PTM_RATIO`
    , which you should be familiar with from [Chapter 5](ch05.html "Chapter 5. Brick
    Breaking Balls with Box2D"), *Brick Breaking Balls with Box2D*, which defines
    the Points-To-Meters ratio.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该熟悉`typedef`和`enum`语句。我们创建`BallID`类型来表示编号球，以简化表示。为了能够轻松地将`NSInteger`值转换为`BallID`值，我们将编号球设置为与球上的数字相等。球杆的编号为0，我们还保留了对`kBallNone`的引用，即`-1`，这样我们就可以覆盖所有情况（当检测台面划痕时很有用）。我们定义了两种`RackLayoutType`类型，即菱形和三角形。我们还设置了`GameMode`为条纹、纯色、有序或条纹对纯色。我们使用最后一个值来识别在任何人
    pocket 任何条纹或纯色之前（也称为台面“开放”）的游戏。我们还有一个`#define`语句来定义`kPocket`为`500`。我们将在碰撞检测中使用这个值来确定球何时击中口袋。最后，还有`PTM_RATIO`，你应该在第5章中熟悉它，*使用Box2D的砖块击球*，它定义了点对米的比例。
- en: The Box2D world
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Box2D世界
- en: 'With any Box2D simulation, we need to define a world for the bodies to inhabit.
    (If you need to brush up on the Box2D world and the structures inside it, please
    go back and re-read the *Box2D: a primer* section in [Chapter 5](ch05.html "Chapter 5. Brick
    Breaking Balls with Box2D"), *Brick Breaking Balls with Box2D*.)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何Box2D模拟，我们需要为物体定义一个世界。如果你需要复习Box2D世界及其内部结构，请回到并重新阅读第5章中的*Box2D：入门*部分，*使用Box2D的砖块击球*。
- en: '**Filename:** `OPPlayfieldLayer.mm`'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `OPPlayfieldLayer.mm`'
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As we did in [Chapter 5](ch05.html "Chapter 5. Brick Breaking Balls with Box2D"),
    we define our world with zero gravity, since we do not want any downward force
    on our environment. We allow bodies to sleep, and we allow the continuous physics
    to run, which will increase the accuracy of the simulation. Finally, we establish
    a contact listener. For this game, we use a nearly identical contact listener
    to the one in [Chapter 5](ch05.html "Chapter 5. Brick Breaking Balls with Box2D"),
    *Brick Breaking Balls with Box2D*. The only difference is we have changed the
    naming convention from BR… to OP… for all the elements in it. We will not repeat
    the code here, so please feel free to refer to that chapter or to the source code
    bundle for this chapter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第5章](ch05.html "第5章。使用Box2D的砖块击球")中所做的那样，我们使用零重力来定义我们的世界，因为我们不希望环境有任何向下的力。我们允许物体进入睡眠状态，并允许连续的物理运算，这将提高模拟的准确性。最后，我们建立了一个接触监听器。对于这个游戏，我们使用了一个与第5章中几乎相同的接触监听器，即*使用Box2D的砖块击球*。唯一的区别是我们将其中所有元素的名字从BR…改为OP…。这里我们不会重复代码，所以请随意参考那一章或这一章的源代码包。
- en: Building the rails
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建轨道
- en: 'The rails are one of the most interacted elements on the pool table, so we
    will build them first. Since the physical properties of all six rails are the
    same, we will build a single method to create a rail and pass parameters to that
    method to create each rail. We''ll look at the "core code" first:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 轨道是台球桌上最常交互的元素之一，所以我们将首先构建它们。由于所有六个轨道的物理属性相同，我们将构建一个单独的方法来创建轨道，并通过传递参数到该方法来创建每个轨道。我们首先看看“核心代码”：
- en: '**Filename:** `OPPlayfieldLayer.mm`'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `OPPlayfieldLayer.mm`'
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This method takes three arguments: the name of the sprite image, the position
    for the sprite and body, and an array of `verts` to define the shape of the rail.
    The rails are defined using the `PhysicsSprite` class, which we also saw in [Chapter
    5](ch05.html "Chapter 5. Brick Breaking Balls with Box2D"), *Brick Breaking Balls
    with Box2D*. A `PhysicsSprite` object, as you may recall, is like a normal `CCSprite`,
    except it holds a reference to the body attached to it. Cocos2d will automatically
    keep the sprite''s position and rotation in sync with the underlying Box2D body.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接受三个参数：精灵图像的名称、精灵和身体的定位，以及定义轨道形状的`verts`数组。轨道使用`PhysicsSprite`类定义，我们也在[第5章](ch05.html
    "第5章。使用Box2D的砖块破碎球")，*使用Box2D的砖块破碎球*中看到过。如您所记得，`PhysicsSprite`对象就像一个普通的`CCSprite`，但它持有附加到其上的身体的引用。Cocos2d将自动保持精灵的位置和旋转与底层的Box2D身体同步。
- en: For the rails, we build the sprite using the passed image name, and then build
    the associated body. After the body is built, we attach the body to the sprite
    with the `setPhysicsBody` method. Next, we define the shape for the rail. Because
    the rails are very simple shapes, we know that we only need four `verts` to define
    each rail. When we define the fixture, we set a pretty high density of `50.0f`,
    a moderate friction of `0.3f`, and an in-the-middle value for restitution of `0.5f`.
    These have been tweaked during play testing to give a good "bounciness" to the
    rails that feels more like a real table.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于轨道，我们使用传递的图像名称构建精灵，然后构建相关的身体。在身体构建完成后，我们使用`setPhysicsBody`方法将身体附加到精灵上。接下来，我们定义轨道的形状。因为轨道形状非常简单，我们知道我们只需要四个`verts`来定义每条轨道。当我们定义固定装置时，我们设置相当高的密度`50.0f`，适中的摩擦`0.3f`，以及中间的恢复值`0.5f`。这些值在游戏测试中已经调整过，以给轨道带来良好的“弹性”，感觉更像真实的台面。
- en: 'Now we can look at how we call this method to define the six rails for the
    table:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看看我们如何调用此方法来定义桌子的六条轨道：
- en: '**Filename:** `OPPlayfieldLayer.mm`'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `OPPlayfieldLayer.mm`'
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This looks like a lot of code to begin with, but it is the same pattern repeated
    six times to accommodate each rail.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这似乎需要很多代码，但实际上是重复了六次相同的模式，以适应每条轨道。
- en: 'For each rail, we define the position based on the center point of the sprite,
    as we are using the default centered anchor point for the rails. We then define
    the array of four `verts` that define the four sides of each rail. You will notice
    that they are not square, as we need the tapered ends around the pockets to make
    a smoother "mouth" for each pocket. Finally, we call the `createRailWithImage`
    method we just reviewed. We now have our rails, which look like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每条轨道，我们根据精灵的中心点定义位置，因为我们正在使用轨道的默认居中锚点。然后我们定义定义每条轨道四边的四个`verts`数组。您会注意到它们不是正方形，因为我们需要在口袋周围有锥形端部，以使每个口袋的“口”更平滑。最后，我们调用我们刚刚审查的`createRailWithImage`方法。现在我们有了轨道，它们看起来是这样的：
- en: '![Building the rails](img/9007_07_01.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![构建轨道](img/9007_07_01.jpg)'
- en: Building pockets
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建口袋
- en: Now that we have our rails built, we need to add the only other "interactive"
    elements of the table itself, the pockets. We will also use a similar two-method
    approach to build them, as the only difference in the pockets is their location.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了轨道，我们需要添加桌子本身的唯一其他“交互”元素，即口袋。我们也将使用类似的两方法方法来构建它们，因为口袋的唯一区别是它们的位置。
- en: '**Filename:** `OPPlayfieldLayer.mm`'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `OPPlayfieldLayer.mm`'
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here we follow the same basic formula we used for the rails. We build a sprite,
    body, shape, and fixture. Even though we don't technically need a sprite for the
    pocket, we will use our trusty `whitespeck.png` that we used heavily in [Chapter
    6](ch06.html "Chapter 6. Cycles of Light"), *Cycles of Light*. In this case, we
    color it black, so that it disappears into the pocket. (For debugging, it is also
    helpful to change it to a brighter color, so that you can see where the pockets
    are.) So why use it at all? We like using a sprite here because it allows us to
    add a tag, `kPocket`, to the sprite. This makes the collisions a little simpler,
    as we will be able to use sprite tags for all objects whose collisions we care
    about (pockets and balls only).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们遵循与轨道相同的基公式。我们构建一个精灵、身体、形状和固定装置。尽管在技术上我们不需要精灵来放置口袋，但我们仍将使用我们信任的`whitespeck.png`，我们在[第6章](ch06.html
    "第6章。光周期")，*光周期*中大量使用过。在这种情况下，我们将它染成黑色，使其消失在口袋中。（对于调试，将其改为更亮的颜色也有助于看到口袋的位置。）那么为什么还要使用它呢？我们在这里使用精灵是因为它允许我们向精灵添加一个标签，`kPocket`。这使得碰撞变得稍微简单一些，因为我们将能够使用精灵标签来处理所有我们关心的碰撞对象（口袋和球）。
- en: You may notice that, unlike the rails, we don't need this to be "physics enabled",
    so the pocket sprites are using normal `CCSprite` classes instead of `PhysicsSprite`
    classes. When we define the shape for the pocket, we use a circle with a radius
    of `7.0`. This is because we need a larger target to detect a ball in pocket.
    We made these circles a little smaller than the actual physical size of the pockets
    on the table, because we want to allow balls to hang on the edge of the pocket,
    just as they do on a real table.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，与轨道不同，我们不需要这个是“物理启用”的，所以口袋精灵使用的是正常的 `CCSprite` 类而不是 `PhysicsSprite`
    类。当我们定义口袋的形状时，我们使用半径为 `7.0` 的圆形。这是因为我们需要一个更大的目标来检测口袋中的球。我们使这些圆圈比桌子上实际物理尺寸的口袋略小，因为我们希望允许球挂在口袋的边缘，就像在真实桌球桌上一样。
- en: Finally, when we define the `pocketFixtureDef`, you will notice we did not use
    any of the usual values such as `density`, `friction`, or `restitution`. This
    is because we do not want the pockets to participate in the "bouncing around"
    of the physics simulation. Instead, we simply set `isSensor` to `YES`. A sensor
    is a physics object that registers in the collision handler, but does not actually
    have any physical "presence" in the world. We will register a contact when something
    touches the sensor, but other objects will be able to pass through the sensor.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们定义 `pocketFixtureDef` 时，你会注意到我们没有使用任何通常的值，如 `density`、`friction` 或 `restitution`。这是因为我们不希望口袋参与物理模拟中的“反弹”。相反，我们只需将
    `isSensor` 设置为 `YES`。传感器是一个在碰撞处理程序中注册的物理对象，但实际上在世界上没有任何物理“存在”。当某物接触传感器时，我们将注册一个接触点，但其他对象将能够穿过传感器。
- en: 'Now we can look at the second method used to drive the creation of the pocket
    sensors:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看看用来驱动口袋传感器创建的第二个方法：
- en: '**Filename:** `OPPlayfieldLayer.mm`'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `OPPlayfieldLayer.mm`'
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Compared to the extra code we needed to build the rails in their second method,
    this one is really simple. We have six pockets, so we simply call the previous
    method and pass it the coordinates for the pocket, and we're done.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们构建轨道的第二种方法所需的额外代码相比，这个方法真的很简单。我们有六个口袋，所以我们只需调用前面的方法并传递口袋的坐标，就完成了。
- en: Creating the cue stick
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建球杆
- en: 'The cue stick is purely cosmetic. We will be controlling the "hitting" of the
    cue ball programmatically, and the cue stick is used as an aiming point of reference
    only. Nevertheless, without a cue stick, the game wouldn''t "feel" like pool.
    The cue stick will be on the screen only during aiming, and will be faded out
    when we make the shot. Because the cue stick is deeply connected with the way
    the controls are built, we will save the discussion on how the cue stick will
    be used for later in the chapter. For now, let''s take a look at how we build
    it:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 球杆纯粹是装饰性的。我们将通过编程控制“击打”球，球杆仅用作瞄准参考点。尽管如此，没有球杆，游戏就不会有“台球”的感觉。球杆仅在瞄准时出现在屏幕上，当我们击球时将淡出。因为球杆与控制构建方式紧密相连，所以我们将在本章后面讨论球杆的使用方法。现在，让我们看看我们是如何构建它的：
- en: '**Filename:** `OPPlayfieldLayer.mm`'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `OPPlayfieldLayer.mm`'
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As it is primarily cosmetic, we use a normal `CCSprite`. We set the `anchorPoint`
    property to the tip of the cue (centered at the top). As we rotate the cue stick,
    this will allow it to pivot on its tip. We also set the visible property to `NO`,
    because the stick will only be made visible when needed.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它主要是装饰性的，我们使用一个正常的 `CCSprite`。我们将 `anchorPoint` 属性设置为球杆的尖端（位于顶部中央）。当我们旋转球杆时，这将允许它在尖端旋转。我们还设置了可见属性为
    `NO`，因为球杆只有在需要时才会变得可见。
- en: Loading the rules
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载规则
- en: 'We won''t be able to progress much farther without discussing the rules engine.
    Some of the configuration of the game, including what type of rack we use for
    the balls, is controlled by the rules. We will be using a separate "rules" class,
    `OPRulesBase`. Let''s look at the complete header for this class first:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 不讨论规则引擎，我们无法取得更大的进展。游戏的一些配置，包括我们使用哪种球架来控制球，都是由规则控制的。我们将使用一个独立的“规则”类，`OPRulesBase`。让我们首先看看这个类的完整头文件：
- en: '**Filename:** `OPRulesBase.h`'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `OPRulesBase.h`'
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first five variables are all parameters we need to define the rules of the
    game. Because these will all be used from the `OPPlayfieldLayer` class, we must
    make them all properties as well. The other variables you see will be explained
    later in the discussion as we use them. The classes in this header give you a
    little bit of a "sneak preview" on how we will approach the full rules engine
    implementation later in the chapter. As you can see, most of the classes are "questioning"
    methods to "ask" the rules engine about the status of various conditions. These
    methods will vary based on the type of game, which is why these "question methods"
    are part of the rules engine.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 前五个变量都是我们需要定义游戏规则的参数。因为这些都将由 `OPPlayfieldLayer` 类使用，我们必须将它们全部定义为属性。其他变量将在我们使用它们时在讨论中解释。这个头文件中的类给你一点关于我们将在本章后面部分如何实现完整规则引擎的“预览”。正如你所见，大多数类都是“询问”方法，用来“询问”规则引擎关于各种条件的状态。这些方法将根据游戏类型而变化，这就是为什么这些“询问方法”是规则引擎的一部分。
- en: 'As we move to the implementation file, we will begin by looking at the custom
    `init` method we will use for the rules:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们转向实现文件时，我们将首先查看我们将用于规则的定制 `init` 方法：
- en: '**Filename:** `OPRulesBase.mm`'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `OPRulesBase.mm`'
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is a pretty simple `init` method that calls the `loadRulesWith:gameName`
    method, and sets a couple of starting values for the table variables (`isTableScratch`
    and `isBreak`). Before we get to the `loadRulesWith` method, there are other methods
    we need to review first:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当简单的 `init` 方法，它调用 `loadRulesWith:gameName` 方法，并为表格变量（`isTableScratch`
    和 `isBreak`）设置了一些起始值。在我们到达 `loadRulesWith` 方法之前，我们还需要回顾其他一些方法：
- en: '**Filename:** `OPRulesBase.mm`'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `OPRulesBase.mm`'
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `readPlist` and `getDictionaryFromPlist` methods we have seen before, also
    in the *Brick breaker* section in [Chapter 5](ch05.html "Chapter 5. Brick Breaking
    Balls with Box2D"), *Brick Breaking Balls with Box2D*. The `readPlist` method
    will load the named plist into memory, and return it as a general type `id`. The
    `getDictionaryFromPlist` method casts the result of `readPlist` as an `NSDictionary`,
    and returns it to the calling method. That's all it takes to get our plist into
    an `NSDictionary`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前见过的 `readPlist` 和 `getDictionaryFromPlist` 方法，也出现在[第5章](ch05.html "第5章.
    使用Box2D的砖块击球")的*砖块击球*部分，即*使用Box2D的砖块击球*。`readPlist` 方法会将命名的 plist 载入内存，并以通用类型
    `id` 返回。`getDictionaryFromPlist` 方法将 `readPlist` 的结果转换为 `NSDictionary`，并将其返回给调用方法。这就是将我们的
    plist 转换为 `NSDictionary` 所需的全部操作。
- en: Rules.plist
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rules.plist
- en: 'Before we go any further into the loader, we should see what the plist for
    our rules actually looks like. This is the plist itself:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进一步探讨加载器之前，我们应该看看我们的规则 plist 实际上看起来是什么样子。这就是 plist 本身：
- en: '![Rules.plist](img/9007_07_02.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![Rules.plist](img/9007_07_02.jpg)'
- en: As you can see from the plist, the first level in the structure is the named
    game (**Eight Ball**, **Nine Ball**), and inside those Dictionaries are a set
    of Strings and Booleans that define the details of the game. Because we have chosen
    to represent the `RackStyle` and `GameMode` elements as strings, we will need
    to convert those into something more usable by the engine.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，结构中的第一层是命名游戏（**八球**，**九球**），在这些字典中有一组字符串和布尔值，定义了游戏的细节。因为我们选择将 `RackStyle`
    和 `GameMode` 元素表示为字符串，所以我们需要将它们转换为引擎可以更方便使用的格式。
- en: Now we have the pieces together to understand the `loadRulesWith` method.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经把所有部件拼在一起，可以理解 `loadRulesWith` 方法了。
- en: '**Filename:** `OPRulesBase.mm`'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `OPRulesBase.mm`'
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We begin by loading in the `rules.plist` using the `getDictionaryFromPlist`
    method. We load the rules into the `ruleBook` dictionary, and then we create another
    dictionary, `theseRules`, which gets the named game dictionary from inside our
    `ruleBook` dictionary. From there, we begin populating our base rules properties
    from that "game level" dictionary. Because an `NSDictionary` stores objects only,
    we have to convert the values for several of the keys before we can insert them
    into the properties. For `LastBall`, we convert the object to the `integerValue`
    of the object (which is stored as an `NSNumber`). You will notice that we convert
    this to an integer, but then we cast it to a `BallID` type when we set the property's
    value. This is where the numeric representations we set in the `typedef` `enum`
    in the `OPDefinitions.h` file come in handy. Because, for example, `kBallNine`
    is internally represented as the integer `9`, we can freely bridge across these
    data types. Had we used other values for the `typedef` `enum`, we would have been
    forced to do some more complex conversions, probably with an extended `switch`
    statement. Similarly, we get the `boolValue` of both the `OrderedBalls` and `ReplaceBalls`
    keys, so they will "fit" into our Boolean properties.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用`getDictionaryFromPlist`方法加载`rules.plist`。我们将规则加载到`ruleBook`字典中，然后创建另一个字典`theseRules`，它从我们的`ruleBook`字典中获取命名游戏字典。从那里开始，我们开始从那个"游戏级别"字典中填充我们的基本规则属性。由于`NSDictionary`只存储对象，我们不得不在将值插入属性之前将几个键的值进行转换。对于`LastBall`，我们将对象转换为对象的`integerValue`（存储为`NSNumber`）。你会注意到我们将它转换为整数，但在设置属性值时将其转换为`BallID`类型。这就是我们在`OPDefinitions.h`文件中的`typedef`
    `enum`中设置的数值表示派上用场的地方。因为例如，`kBallNine`在内部表示为整数`9`，我们可以自由地在这些数据类型之间进行转换。如果我们为`typedef`
    `enum`使用了其他值，我们就不得不进行一些更复杂的转换，可能需要扩展的`switch`语句。同样，我们获取`OrderedBalls`和`ReplaceBalls`键的`boolValue`，因此它们将“适合”到我们的布尔属性中。
- en: 'The other two rule properties need special consideration. Because we have chosen
    to store those as strings in the `rules.plist`, we have to do string comparison
    to convert them into the values our game wants to use. Let''s look at the conversion
    methods now:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个规则属性需要特别考虑。因为我们选择将它们作为字符串存储在`rules.plist`中，我们必须进行字符串比较以将它们转换为游戏想要使用的值。现在让我们看看转换方法：
- en: '**Filename:** `OPRulesBase.mm`'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `OPRulesBase.mm`'
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For both of these methods, we pass it the string that comes from the dictionary,
    and compare the strings to our defined values. We can then return the `typedef`
    `enum` values that correspond to the chosen options. We could have avoided this
    by storing the rack types and game modes as numbers in the plist, but that makes
    the human reading (and writing) of the plist less easy to understand. Because
    we only perform these comparisons when loading the rules, there is no performance
    drawback on using this slower approach.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这两种方法，我们传递给它来自字典的字符串，并将字符串与我们的定义值进行比较。然后我们可以返回与所选选项对应的`typedef` `enum`值。我们本可以避免这样做，将托盘类型和游戏模式作为数字存储在plist中，但这会使人类阅读（和编写）plist变得不那么容易理解。因为我们只在加载规则时执行这些比较，所以使用这种较慢的方法不会对性能产生负面影响。
- en: In the final lines of the `loadRulesWith` method, we assign the current `gameMode`
    (that we just loaded) to the `player1Goal` and `player2Goal` properties. This
    identifies for the players what their goal in the game is going to be. Why is
    this at a player level? It really comes down to the inherent complexity in the
    game of Eight Ball, where one player will be shooting for stripes, and the other
    for solids. Before any balls are sunk, the table is "open", so all shots (except
    for the last ball) are legal. So, in this case, the starting game is "Stripes
    vs Solids" for both players, until the game progresses to the point where one
    is deemed to have a goal of "Stripes" and the other "Solids".
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在`loadRulesWith`方法的最后几行中，我们将当前加载的`gameMode`赋值给`player1Goal`和`player2Goal`属性。这为玩家确定了他们在游戏中的目标是什么。为什么是在玩家级别？这实际上归结于八球游戏固有的复杂性，其中一名玩家将瞄准条纹球，而另一名玩家将瞄准固体球。在任何一个球被击入之前，台面是“开放的”，因此所有射击（除了最后一球）都是合法的。所以在这种情况下，起始游戏是“条纹对固体”对两名玩家，直到游戏进展到某个点，其中一个被认为目标是“条纹”，而另一个是“固体”。
- en: We also check if the `gameMode` is `kOrdered`. This means that balls will be
    sunk in numeric order. If this is the case, the `nextOrderedBall` variable is
    set to `kBallOne`. If the game is anything else, `nextOrderedBall` will be ignored.
    Finally, `currentPlayer` always starts as player 1.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还检查`gameMode`是否为`kOrdered`。这意味着球将按数字顺序沉入。如果是这种情况，`nextOrderedBall`变量将被设置为`kBallOne`。如果游戏是其他任何东西，`nextOrderedBall`将被忽略。最后，`currentPlayer`始终从玩家1开始。
- en: Rack 'em up
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排列起来
- en: Now that we know what type of game we will be playing, we have enough information
    to build the rack on the table. First we need to know how to build the balls.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了将要玩的游戏类型，我们就有足够的信息在桌子上构建台子了。首先我们需要知道如何构建球。
- en: '**Filename:** `OPPlayfieldLayer.mm`'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `OPPlayfieldLayer.mm`'
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is similar to the builders we used to create the rails and pockets, with
    a few exceptions. We pass both the `BallID` and `startPos` variables to this method,
    so we know which ball to build, and where to build it. We use the class `OPBall`,
    which is a subclass of `PhysicsSprite`, to represent the balls. The `OPBall` class
    is a direct pass-through of the `PhysicsSprite`, with no added functionality.
    We do this because we gain the ability in the collision handler to use the `isMemberOfClass`
    method to determine if the object is a ball or not. If we designed the collision
    handler differently, we could have used `PhysicsSprite` for the balls instead.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这与用于创建轨道和袋子的构建器类似，但有几点例外。我们向这个方法传递了`BallID`和`startPos`变量，这样我们就能知道要构建哪个球，以及在哪里构建它。我们使用`OPBall`类，它是`PhysicsSprite`的子类，来表示球。`OPBall`类是`PhysicsSprite`的直接传递，没有添加任何功能。我们这样做是因为在碰撞处理程序中，我们可以使用`isMemberOfClass`方法来确定对象是否是球。如果我们设计不同的碰撞处理程序，我们可以用`PhysicsSprite`来代替球。
- en: For the rest of the ball instantiation, we follow the pattern of building a
    body, assigning it to the sprite, creating the fixture, and attaching it to the
    body. We use a `density` of `1.0f`, a `friction` of `0.5f`, and a `restitution`
    of `0.9f` to give a good "pool ball feel" to the fixtures. We then use a few additional
    members of the body object that we haven't really used before. We turn off `SetFixedRotation`,
    so the balls will be able to rotate, rather than remaining at their original rotation.
    We set the linear damping to `0.7f`, and the angular damping to `0.5f`. Together,
    these will help simulate the effect of the balls rolling on the table felt. This
    is the one place in this game where we are "faking" the physics world, because
    we are not actually creating a table top object. Linear damping will slow the
    ball's forward progress, and angular damping will help slow the ball's rotation.
    Together with the fixture's settings, these provide a fairly realistic feel for
    a pool table.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其余的球实例化，我们遵循构建身体、将其分配给精灵、创建固定装置并将其附加到身体上的模式。我们使用`密度`为`1.0f`、`摩擦`为`0.5f`和`恢复`为`0.9f`来给固定装置一个良好的“台球感觉”。然后我们使用一些之前没有真正使用过的身体对象的附加成员。我们关闭`SetFixedRotation`，这样球就能旋转，而不是保持原始旋转。我们将线性阻尼设置为`0.7f`，角阻尼设置为`0.5f`。这些共同将有助于模拟球在台布上滚动的效果。这是在这个游戏中我们“伪造”物理世界的一个地方，因为我们实际上并没有创建桌面对象。线性阻尼会减慢球的向前运动，角阻尼会帮助减慢球的旋转。与固定装置的设置一起，这些提供了对台球桌相当逼真的感觉。
- en: Building the rack
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建台子
- en: 'Now we can build the rack. Let''s look at the code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以构建台子了。让我们看看代码：
- en: '**Filename:** `OPPlayfieldLayer.mm`'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `OPPlayfieldLayer.mm`'
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this method, we first define the positions where the balls will be located.
    We use a shorthand notation for most of the `CGPoint` positions. The abbreviation
    means row and ball in row, so `r1b1` is the leftmost ball in the first row past
    the foot spot (the foot spot is the front "point" of the rack). We define all
    the positions first, and then check which rack we want. If we called for a triangle
    rack (as in Eight Ball), then we will fill in every position with a ball. If we
    need a triangle rack (used in Nine Ball), then we only use 9 of the 15 positions
    defined. The positions, you will notice, are actually a little too close together.
    This is intentional, because Box2D will nudge the balls a little bit so they all
    fit. The end result is that the balls are all touching, which is known as a "tight
    rack" in pool.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们首先定义球将位于的位置。我们使用简写符号来表示大多数的`CGPoint`位置。缩写表示行和行中的球，所以`r1b1`是脚位（脚位是台球架的前“点”）之后第一行的最左边的球。我们首先定义所有位置，然后检查我们想要哪个台球架。如果我们调用三角形台球架（如八球），那么我们将填充每个位置上的球。如果我们需要一个三角形台球架（用于九球），那么我们只使用定义的15个位置中的9个。你会注意到，这些位置实际上非常接近。这是故意的，因为Box2D会稍微推动球，使它们都适合。最终结果是球都相互接触，这在台球中被称为“紧密排列”。
- en: Player HUD
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩家HUD
- en: 'As we are building a two-player game, let''s take a quick look at how we build
    the Heads-Up Display to provide feedback to the players:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在构建一个双玩家游戏，让我们快速看看我们是如何构建抬头显示器（Heads-Up Display）来为玩家提供反馈的：
- en: '**Filename:** `OPPlayfieldLayer.mm`'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `OPPlayfieldLayer.mm`'
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We build simple labels to identify player 1 and player 2, and we also create
    target labels, which we will use to identify "stripes" or "solids" for the player.
    We use our `whitespeck.png` image again, this time to make a nice green line that
    will identify which player''s turn it is, using the `markPlayer` variable to hold
    that sprite. Finally, if we are playing a game with ordered balls, we also add
    the legend **Next Ball** at the top of the display. As we have discussed the goals
    a few times, let''s see how they are identified for the players:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建简单的标签来识别玩家1和玩家2，我们还创建了目标标签，我们将使用这些标签来识别玩家的“条纹”或“纯色”。我们再次使用我们的`whitespeck.png`图像，这次用来制作一条漂亮的绿色线，以标识哪个玩家的回合，使用`markPlayer`变量来保存这个精灵。最后，如果我们正在玩一个按顺序排列的球类游戏，我们还在显示的顶部添加了**下一球**的图例。因为我们已经讨论过目标几次，让我们看看它们是如何为玩家识别的：
- en: '**Filename:** `OPPlayfieldLayer.mm`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `OPPlayfieldLayer.mm`'
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Referring back to our discussion in the rules about player goals, here we simply
    check each player''s goal. Depending on if it has been set to stripes or solids,
    we update the appropriate target labels to display to the users what they are
    shooting for. Then we check if it is a game with ordered balls. If it is, we check
    with the rules engine to determine what the lowest numbered ball on the table
    is, and we add an image of that ball to the top of the display, next to the **Next
    Ball** label. You will notice we call the `ballSpritesOnTable` method, so we should
    go there now:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们在规则中关于玩家目标的讨论，这里我们简单地检查每个玩家的目标。根据它是否被设置为条纹或纯色，我们更新相应的目标标签以显示给用户他们要射击的目标。然后我们检查是否是按顺序排列的球类游戏。如果是，我们通过规则引擎检查桌面上最低编号的球是哪一个，并将该球的图片添加到显示的顶部，紧邻**下一球**标签。你会注意到我们调用了`ballSpritesOnTable`方法，所以现在我们应该去那里：
- en: '**Filename:** `OPPlayfieldLayer.mm`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `OPPlayfieldLayer.mm`'
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here we iterate through all the bodies in the Box2D world, and find those that
    have sprites attached. You will notice we check to make sure the `tag` is lower
    than `100`. This is because the pockets also have sprites attached, but we set
    the `#define` for `kPocket` to be `500`, so we don't accidentally add a pocket
    sprite to the array. With all balls accounted for, we return an `NSArray` to the
    calling method.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们遍历Box2D世界中的所有身体，并找到那些附加了精灵的身体。你会注意到我们检查确保`tag`小于`100`。这是因为口袋也有附加的精灵，但我们把`#define`的`kPocket`设置为`500`，所以我们不会意外地将口袋精灵添加到数组中。在所有球都被计算后，我们返回一个`NSArray`给调用方法。
- en: 'The only significant player method we have left is the active player change:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们剩下的唯一重要玩家方法是活动玩家更改：
- en: '**Filename:** `OPPlayfieldLayer.mm`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `OPPlayfieldLayer.mm`'
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is a short and sweet method. If it is currently player 1's turn, we change
    the `currentPlayer` to player 2, and vice versa. We move the `markPlayer` sprite
    to the appropriate side of the display (below the P1 or P2 labels), and we call
    the `displayMessage` method to give feedback to the players.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简短而直接的方法。如果现在是玩家1的回合，我们将`currentPlayer`改为玩家2，反之亦然。我们将`markPlayer`精灵移动到显示的适当一侧（在P1或P2标签下方），并调用`displayMessage`方法向玩家提供反馈。
- en: Displaying messages
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示消息
- en: Throughout the game, there are many times we need to present messages to the
    player. Rather than building the same basic message display repeatedly, we have
    consolidated that functionality in the `displayMessage` and `dismissMessage` methods.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个游戏中，有许多时候我们需要向玩家显示消息。而不是反复构建相同的基本消息显示，我们将该功能合并到`displayMessage`和`dismissMessage`方法中。
- en: '**Filename:** `OPPlayfieldLayer.mm`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `OPPlayfieldLayer.mm`'
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this method, we first check to make sure we are not already displaying a
    message. If we are (as indicated by the `isDisplayingMsg` Boolean variable), then
    we wait for `0.1` second and call it again with the same parameters. If there
    is no message displaying, we create a label with the requested message and display
    it on the screen. If the `userDismiss` is `NO`, then we set a 2 second timer and
    then call `dismissMessage`. If the `userDismiss` is `YES`, then the message will
    be displayed until the user touches the screen to dismiss it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们首先检查确保我们还没有显示消息。如果我们正在显示（如`isDisplayingMsg`布尔变量所示），那么我们将等待`0.1`秒，并使用相同的参数再次调用它。如果没有消息正在显示，我们创建一个带有请求消息的标签，并将其显示在屏幕上。如果`userDismiss`是`NO`，那么我们将设置一个2秒定时器，然后调用`dismissMessage`。如果`userDismiss`是`YES`，那么消息将一直显示，直到用户触摸屏幕以取消它。
- en: '**Filename:** `OPPlayfieldLayer.mm`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `OPPlayfieldLayer.mm`'
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `dismissMessage` method is simple. If we didn't need to have the user dismiss
    option, then we could have easily embedded this in a `CCCallBlock` action in the
    `displayMessage` method, but we wanted the extra flexibility here.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`dismissMessage`方法很简单。如果我们不需要用户取消选项，那么我们可以在`displayMessage`方法中轻松地将其嵌入`CCCallBlock`动作中，但在这里我们希望有更多的灵活性。'
- en: Collision handling
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞处理
- en: 'Before we get to the final stretch covering the controls and the rest of the
    rules engine, we now know enough about our game that we can implement the collision
    detection, which uses the same contact listener we used in [Chapter 5](ch05.html
    "Chapter 5. Brick Breaking Balls with Box2D"), *Brick Breaking Balls with Box2D*.
    We will look at the `update` method in pieces, so we can discuss it along the
    way:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入涵盖控制和规则引擎其余部分的最后阶段之前，我们现在对我们的游戏了解得足够多，可以实施碰撞检测，该检测使用的是我们在[第5章](ch05.html
    "第5章。使用Box2D的砖块破碎球")中使用的相同接触监听器，即*使用Box2D的砖块破碎球*。我们将分步骤查看`update`方法，以便在过程中讨论它：
- en: '**Filename:** `OPPlayfieldLayer.mm` (`update`, part 1)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `OPPlayfieldLayer.mm` (`update`, 第1部分)'
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The first important thing to see here is that we have really ramped up the number
    of iterations that the simulation uses in each step, to increase the accuracy
    of the simulation. As we only have a small number of bodies, it does not adversely
    affect performance.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里首先要注意的重要一点是，我们确实增加了模拟在每一步中使用的迭代次数，以提高模拟的准确性。由于我们只有少数几个物体，这并不会对性能产生不利影响。
- en: We step the world forward and then, using C++ vectors, we iterate through all
    the contacts that have been collected by the contact listener. For each contact,
    we get the bodies and their related sprites, which we store in `bodyA`, `bodyB`,
    `spriteA`, and `spriteB`. We hold the sprites as `CCSprite` objects, because we
    can't be sure which subclass of `CCSprite` the object will be.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将世界向前推进，然后使用C++向量遍历所有由接触监听器收集的接触。对于每个接触，我们获取相关的身体和它们的精灵，我们将它们存储在`bodyA`、`bodyB`、`spriteA`和`spriteB`中。我们保持精灵为`CCSprite`对象，因为我们无法确定该对象将是`CCSprite`的哪个子类。
- en: '**Filename:** `OPPlayfieldLayer.mm` (`update`, part 2)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `OPPlayfieldLayer.mm` (`update`, 第2部分)'
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this section, we compare `spriteA` and `spriteB` to see if one of them is
    an `OPBall` object, and the other has a tag of `kPocket`. If this is true, then
    a ball has landed in a pocket, so we add the ball to the `toDestroy` vector to
    deal with later. As you probably recall from [Chapter 5](ch05.html "Chapter 5. Brick
    Breaking Balls with Box2D"), *Brick Breaking Balls with Box2D*, we cannot guarantee
    in which order the bodies will be reported to us, so we have to check everything
    in both ways.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们比较`spriteA`和`spriteB`以确定其中之一是否是`OPBall`对象，而另一个具有`kPocket`标签。如果这是真的，那么一个球已经落入球洞，因此我们将球添加到`toDestroy`向量中以便稍后处理。你可能还记得[第5章](ch05.html
    "第5章。使用Box2D的砖块破碎球")中的“使用Box2D的砖块破碎球”，我们无法保证身体报告给我们的顺序，因此我们必须以两种方式检查一切。
- en: The next check is to determine if two balls collided with each other. If there
    are two balls, then we check to see if one of them is the cue ball. If it is,
    and this is the first contact of the cue ball with another ball since the cue
    ball was last hit, then we keep a reference to that tag in the variable `firstHit`.
    Why do we do this? Pool has a rule that requires you to hit your own ball first,
    before the cue ball touches any other balls. By storing the first ball touched
    in the `firstHit` variable, we will be able to properly track what the cue ball
    hit first. We will use this information later.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个检查是确定两个球是否相互碰撞。如果有两个球，那么我们检查其中一个是否是主球。如果是，并且这是主球自上次击打以来与另一个球接触的第一次接触，那么我们将对该标签的引用保存在变量`firstHit`中。我们为什么要这样做？台球有一个规则要求你在主球接触任何其他球之前先击打自己的球。通过在`firstHit`变量中存储第一个被接触的球，我们将能够正确跟踪主球首先击中了什么。我们将在稍后使用这个信息。
- en: '**Filename:** `OPPlayfieldLayer.mm` (`update`, part 3)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `OPPlayfieldLayer.mm` (`update`部分3)'
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this final section of the `update` method, we proceed to destroy any bodies
    (balls) that were added to the `toDestroy` vector, and we send the corresponding
    sprites to the `sinkBall` method.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在`update`方法的最后一个部分，我们继续销毁添加到`toDestroy`向量中的任何身体（球），并将相应的精灵发送到`sinkBall`方法。
- en: We then check if the table is moving, that is, are any balls still rolling.
    If there are, we block any user input (with the `isTouchBlocked` Boolean variable),
    and then we call the `checkTable` method to see what happened. We use the `pendingTable`
    variable to allow us to only check the status of the table when everything is
    at rest. We will set `pendingTable` to `YES` when we take a shot, and this section
    will wait until everything is settled, and then check the table once.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查桌子是否在移动，也就是说，是否有球仍在滚动。如果有，我们通过`isTouchBlocked`布尔变量阻止任何用户输入，然后调用`checkTable`方法查看发生了什么。我们使用`pendingTable`变量来允许我们仅在一切静止时检查桌子的状态。当我们击球时，我们将`pendingTable`设置为`YES`，本节将等待一切平静下来，然后检查桌子一次。
- en: 'We will get to the `checkTable` method later, but for now let''s look at the
    `sinkBall` and `isTableMoving` methods to see how they work:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后了解`checkTable`方法，但现在让我们看看`sinkBall`和`isTableMoving`方法是如何工作的：
- en: '**Filename:** `OPPlayfieldLayer.mm`'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `OPPlayfieldLayer.mm`'
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If we wanted to do something fancy with the balls that are sunk, this would
    be the place. For our game, we are quite content with simply having the balls
    added to the `ballsSunk` array and then remove the ball from the layer.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在沉没的球上做些花哨的事情，这里就是地方。对于我们的游戏，我们非常满足于简单地让球被添加到`ballsSunk`数组中，然后从层中移除球。
- en: '**Filename:** `OPPlayfieldLayer.mm`'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `OPPlayfieldLayer.mm`'
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To check if the table is moving, we could simply poll to see if all bodies are
    sleeping. The problem with this approach is that it takes a while for physics
    bodies to completely stop and go to sleep. Through testing, we determined that
    this was too long and boring. So instead, we check the velocity length of each
    body. If the value is greater than `0.005f`, then the ball is still noticeably
    moving. Below that speed, everything is crawling slowly enough for us to proceed
    with checking the table.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查桌子是否在移动，我们可以简单地轮询以查看所有身体是否都在睡眠状态。这种方法的问题在于物理身体完全停止并进入睡眠状态需要一段时间。通过测试，我们确定这太长也太无聊了。因此，我们检查每个身体的速率长度。如果值大于`0.005f`，则球仍在明显移动。低于该速度，一切都在缓慢爬行，足以让我们继续检查桌子。
- en: Building the control base
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建控制基础
- en: We are now to the point where we can build the controls for the player. As we
    said in the introduction, we will be building two control schemes. The first is
    what we call "one touch". This controller will track from the moment the touch
    is detected until it is released. While the touch is on the screen, we will update
    the cue stick to follow the touch, aiming at the cue ball. When the touch is ended
    (finger lifted) we will take the shot from the position of the cue stick, and
    the distance from the cue ball will determine the strength of the shot.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经到了可以构建玩家控制器的阶段。正如我们在介绍中所说，我们将构建两个控制方案。第一个是我们称之为“单触”的控制方案。这个控制器将从触摸被检测到的那一刻开始跟踪，直到它被释放。当触摸在屏幕上时，我们将更新球杆以跟随触摸，瞄准球杆。当触摸结束（手指抬起）时，我们将从球杆的位置进行射击，从球杆到球的位置将决定射击的强度。
- en: The second control scheme, which we call "two touch", will be similar in the
    way it tracks the shot, but it will not automatically take the shot when the touch
    is lifted. Instead, a button that says **Shoot!** will appear at the bottom of
    the screen, and touching that button will take the shot.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个控制方案，我们称之为“双触”，在跟踪射击的方式上将与前者相似，但它不会在触摸抬起时自动射击。相反，一个写着**射击！**的按钮将出现在屏幕底部，触摸该按钮将进行射击。
- en: 'Both control schemes share some code, so we have created the `OPControlBase`
    class, which we will then subclass with `OPControlOneTouch` and `OPControlTwoTouch`
    to handle the specifics of those two control schemes. We will start by looking
    at the `OPControlBase` class:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 两个控制方案共享一些代码，因此我们创建了`OPControlBase`类，然后我们将使用`OPControlOneTouch`和`OPControlTwoTouch`来创建这两个控制方案的子类，以处理这两个控制方案的具体细节。我们将首先查看`OPControlBase`类：
- en: '**Filename:** `OPControlBase.h`'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `OPControlBase.h`'
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the header we can see the variables we need to track for both control schemes.
    We will keep a reference to the main playfield layer, since we need to interact
    with it. We keep track of the `shotLength` variable (used as the strength), the
    `plannedHit` variable (the point we will hit from), and the `aimAtPoint` variable,
    which will be the cue ball's position. We also have the `cueBallInHand` sprite.
    This will be used when we are positioning the cue ball on the table, as we really
    don't need or want an actual physics object to ram into other balls as the player
    is moving the cue ball around.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在头文件中，我们可以看到我们需要跟踪的两个控制方案所需的变量。我们将保留对主游戏场层的引用，因为我们需要与之交互。我们跟踪`shotLength`变量（用作强度），`plannedHit`变量（我们将从该点击球），以及`aimAtPoint`变量，它将是球杆的位置。我们还有一个`cueBallInHand`精灵。当我们将球杆定位在桌面上时，我们将使用这个精灵，因为我们实际上不需要或想要一个实际的物理对象在玩家移动球杆时撞击其他球。
- en: '**Filename:** `OPControlBase.mm`'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `OPControlBase.mm`'
- en: '[PRE26]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This is the primary method that is shared between the two control schemes. The
    input parameter, `convLoc`, is the converted location from the touch handler,
    which we will pass here after the necessary conversions to OpenGL space. We determine
    the `offset` as a subtraction of the `aimAtPoint` position (the cue ball) from
    the `convLoc` position (touch location). We then use the `ccpNormalize` function
    to convert that `offset` into the smallest possible coordinates that still represent
    the angle desired. This will allow us to control the power of the hit ourselves,
    without having to compensate for the distance in our calculations.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是两个控制方案之间共享的主要方法。输入参数`convLoc`是从触摸处理程序转换的位置，我们将在将其转换为OpenGL空间后将其传递到这里。我们通过从`convLoc`位置（触摸位置）减去`aimAtPoint`位置（目标球）来确定`offset`。然后我们使用`ccpNormalize`函数将这个`offset`转换为表示所需角度的最小坐标。这将使我们能够自己控制击球的力量，而无需在计算中补偿距离。
- en: Using the `mp` variable as a reference to the main playfield layer, we proceed
    to move the pool cue to the correct location, and we use the `ccpToAngle` function
    to convert the `approach` variable to something more useful. This creates a value
    in radians. We use `CC_RADIANS_TO_DEGREES()` to convert this to a degree-based
    angle, and add it to `90` (which we need to accommodate the rotation of our graphic
    for the cue stick), and multiply the whole thing by `-1`. This gives us the correct
    angle we need to make the cue stick point at the cue ball from the point we are
    currently touching.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`mp`变量作为对主游戏层的一个引用，我们继续将球杆移动到正确的位置，并使用`ccpToAngle`函数将`approach`变量转换为更有用的东西。这会创建一个以弧度为单位的值。我们使用`CC_RADIANS_TO_DEGREES()`将其转换为基于度的角度，并将其加到`90`（我们需要为此调整球杆的图形旋转），然后将整个值乘以`-1`。这给了我们正确的角度，使我们能够从当前触摸点使球杆指向球。
- en: We then calculate the `shotLength` value using some simple geometry. If the
    length is less than `4` (too close to the ball) or greater than `75` (too far
    away to be sensible), we reject the hit and hide the cue stick. Otherwise, we
    calculate the `hitPower` (the `shotLength` divided by `6`, to make it a more sensible
    power level), and we use that to determine the planned hit. This method does not
    actually make the shot. Rather, it updates the visuals and generates all the calculations
    we need to be ready to make the shot. The astute reader will also notice that
    we are setting the `shootButton` sprite to be visible. This is only in existence
    in our two touch control class, so in the case of the one touch control, this
    call will send a message to a `nil` object, which is completely ignored.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用一些简单的几何计算`shotLength`值。如果长度小于`4`（太靠近球）或大于`75`（太远以至于不合理），我们拒绝击球并隐藏球杆。否则，我们计算`hitPower`（`shotLength`除以`6`，使其成为一个更合理的功率级别），并使用它来确定计划中的击球。此方法实际上并不进行击球。相反，它更新视觉效果并生成我们准备击球所需的所有计算。细心的读者也会注意到我们正在将`shootButton`精灵设置为可见。这仅存在于我们的双触控制类中，所以在单触控制的情况下，这个调用将向一个`nil`对象发送消息，这将被完全忽略。
- en: '**Filename:** `OPControlBase.mm`'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `OPControlBase.mm`'
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `hideCue` method takes away the cue stick and resets all variables to baseline
    values because we don't have any shot to make. This is important to do here, because
    this will be called not only after the shot is made, but also when the shot is
    invalidated (stick too far away, and so on). We are again adjusting the `shootButton`
    sprite's visibility, if the button's sprite exists. If it doesn't exist, then
    this line is ignored automatically.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`hideCue`方法移除球杆并将所有变量重置为基线值，因为我们没有要打的球。这里这样做很重要，因为这不仅会在打出球后调用，还会在球无效时调用（球杆太远等）。我们再次调整`shootButton`精灵的可见性，如果按钮的精灵存在的话。如果不存在，则自动忽略此行。'
- en: One-touch control
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单触控制
- en: We will look at the one touch control first. The class `OPControlOneTouch` is
    a subclass of `OPControlBase`, but does not have any additional variables needed.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先查看单触控制。类`OPControlOneTouch`是`OPControlBase`的子类，但没有需要添加的任何额外变量。
- en: '**Filename:** `OPControlOneTouch.mm`'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `OPControlOneTouch.mm`'
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We begin the `ccTouchBegan` method by checking for a couple of special cases.
    If `isTouchBlocked` is `YES` on the main playfield, then we reject the touch.
    We then check for any user-dismissed messages, to see if we need to clear those
    messages. If the main playfield has the `isGameOver` flag set, then the next touch
    will return to the main menu. We now convert the touch location to the `convLoc`
    variable using the standard coordinate transforms. If the player should have the
    cue ball in hand (after a scratch), then the touch will create a new `cueBallInHand`
    sprite. Finally, if the touch is inside the table, then we set the `aimAtPoint`
    position to be the cue ball's position, and we call the `updateCueAimFromLoc`
    method we discussed earlier.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从检查几个特殊情况开始`ccTouchBegan`方法。如果主游戏场上的`isTouchBlocked`是`YES`，则我们拒绝触摸。然后我们检查任何用户取消的消息，以查看是否需要清除这些消息。如果主游戏场设置了`isGameOver`标志，则下一次触摸将返回主菜单。我们现在使用标准坐标转换将触摸位置转换为`convLoc`变量。如果玩家应该在手中持有球（在擦球后），则触摸将创建一个新的`cueBallInHand`精灵。最后，如果触摸在桌子里，我们将`aimAtPoint`的位置设置为球的位置，并调用我们之前讨论过的`updateCueAimFromLoc`方法。
- en: '**Filename:** `OPPControlOneTouch.mm`'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `OPPControlOneTouch.mm`'
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `ccTouchMoved` method follows the same approach as the `ccTouchBegan` method.
    If the ball is in hand, then the touch movement will move the `cueBallInHand`
    sprite to the touched location, so the ball will follow the touch. If the ball
    is not in hand, then we again call `updateCueAimFromLoc` to update the cue stick.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`ccTouchMoved`方法遵循与`ccTouchBegan`方法相同的做法。如果球在手中，那么触摸移动将使`cueBallInHand`精灵移动到触摸位置，这样球就会跟随触摸。如果球不在手中，那么我们再次调用`updateCueAimFromLoc`来更新球杆。'
- en: '**Filename:** `OPControlTouchOne.mm`'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `OPControlTouchOne.mm`'
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The final method of our control is `ccTouchEnded`, which makes the shot when
    the touch is lifted. For this controller, we want this to cause the shot to be
    made. As in the previous two touch methods, we first check if the ball is in hand.
    If it is, then we call the main playfield to create a new "real" cue ball at that
    location, and discard the `CCSprite` we were using to represent it. Here we also
    check the `shotLength` value to make sure it is not too long, to avoid a shot
    being made with an invisible cue stick. (Without this check, the shot will still
    be made, whether you can see the stick or not!) Finally, we call to the main playfield
    to actually make the shot. Before we move on to see the two touch controls, let''s
    go back to the main playfield and see what the `makeTheShot` method does:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们控制方法的最后一种是`ccTouchEnded`，当触摸抬起时进行击球。对于这个控制器，我们希望这能导致击球发生。与前面两种触摸方法一样，我们首先检查球是否在手中。如果是，那么我们调用主游戏场来在那个位置创建一个新的“真实”球，并丢弃我们用来表示它的`CCSprite`。在这里，我们也检查`shotLength`值以确保它不是太长，以避免用不可见的球杆进行击球。（如果没有这个检查，无论你是否能看到球杆，击球仍然会发生！）最后，我们调用主游戏场来实际进行击球。在我们继续查看两次触摸控制之前，让我们回到主游戏场，看看`makeTheShot`方法做了什么：
- en: '**Filename:** `OPPlayfieldLayer.mm`'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `OPPlayfieldLayer.mm`'
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When we make the shot, we set our `aimPoint` to match the controller's `aimAtPoint`
    (that is, the cue ball). We create a sequence of actions to give the illusion
    of hitting the ball with the cue stick. First, we move the stick rapidly at the
    `aimPoint`, then we use a `CCCallBlock` action to apply a linear impulse on the
    ball, and then we fade the cue out. As we have seen before, the `CCCallBlock`
    action here is effectively used to avoid the need to build another method. Everything
    inside the `^{ }` will be executed when this block is called in the sequence.
    Here it simply sets the `pendingTable` variable to `YES`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进行击球时，我们将我们的`aimPoint`设置为与控制器的`aimAtPoint`（即球杆）相匹配。我们创建一系列动作来产生用球杆击球的错觉。首先，我们快速地将球杆移动到`aimPoint`，然后我们使用`CCCallBlock`动作对球施加线性冲量，然后逐渐消失球杆。正如我们之前所看到的，这里的`CCCallBlock`动作被有效地用来避免需要构建另一个方法。在序列中调用此块时，`^{
    }`内的所有内容都将被执行。在这里，它只是将`pendingTable`变量设置为`YES`。
- en: The linear impulse is set using the `plannedHit` variable from the control class,
    and it applies it directly at the center of the cue ball. (Yes, pool purists,
    we are aware of the effects of hitting the cue ball off-center. For this game,
    we have opted to not include any offset controls. It's arcade pool, not a true
    pool simulator, after all!) You will notice that we add an additional `CCDelayTime`
    action after we fade out the cue, and then set the `pendingTable` to `YES`. Why
    do we do this? We need the `pendingTable` variable set to `YES` so the `checkTable`
    in the `update` method will work correctly when the table comes to rest. However,
    if we set it as soon as this method is called, the table checking will happen
    before the shot is made, because the table will still technically be "at rest"
    for the first half second or so of the action. As we need the balls to be moving
    before we set this variable, embedding it into the action sequence seemed like
    a natural fit.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 线性冲量是通过控制类中的`plannedHit`变量设置的，并直接应用于球杆的中心。（是的，台球纯主义者，我们知道击中球杆非中心位置的影响。对于这款游戏，我们选择不包含任何偏移控制。毕竟，这是街机台球，而不是真正的台球模拟器！）你会注意到，我们在球杆消失后添加了一个额外的`CCDelayTime`动作，然后设置`pendingTable`为`YES`。我们为什么要这样做？我们需要将`pendingTable`变量设置为`YES`，以便在桌子静止时`update`方法中的`checkTable`能正常工作。然而，如果我们在这个方法被调用时立即设置它，因为桌子在动作的前半秒左右仍然是“静止”的，所以桌子检查将在击球之前发生。由于我们需要在设置此变量之前让球移动，将此嵌入到动作序列中似乎是顺理成章的。
- en: Two-touch control
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 双触控制
- en: 'Our second control method will use two touches, but much of the "plumbing"
    is very similar to the one touch controller. Let''s take a look and then discuss:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二种控制方法将使用两次触摸，但大部分的“管道”与单次触摸控制器非常相似。让我们看看然后讨论：
- en: '**Filename:** `OPControlTwoTouch.mm`'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `OPControlTwoTouch.mm`'
- en: '[PRE32]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The first difference is that we are using our own `init` method for the two
    touch control. This `init`, as you can see, simply creates the **Shoot!** button,
    and positions it at the bottom center of the screen, and sets its `visible` property
    to `NO`. We could recreate it each time we need it, but that seems wasteful, so
    we build it once, and toggle the visible property when we need it.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个不同之处在于我们为双触控制使用了自己的`init`方法。这个`init`，正如你所见，只是创建了一个**射击！**按钮，并将其放置在屏幕的底部中央，并将它的`visible`属性设置为`NO`。我们可以在需要时每次都重新创建它，但这样似乎很浪费，所以我们只创建一次，并在需要时切换可见属性。
- en: 'The two touch control scheme in action looks as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 实际操作中的双触控制方案如下：
- en: '![Two-touch control](img/9007_07_03.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![双触控制](img/9007_07_03.jpg)'
- en: '**Filename:** `OPControlTwoTouch.mm`'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `OPControlTwoTouch.mm`'
- en: '[PRE33]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In `ccTouchBegan`, we follow the same code structure up to and including the
    `isBallInHand` variable evaluation. It is after that point that we see the differences.
    We still set the `aimAtPoint` variable to the cue ball's position, but then we
    check to see if the shoot button was touched. If it was, then we call `makeTheShot`.
    If there was any other touch on the table, then we update the cue stick's position.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ccTouchBegan`中，我们遵循相同的代码结构，直到包括`isBallInHand`变量评估。在那之后，我们看到了差异。我们仍然将`aimAtPoint`变量设置为球的位置，但然后我们会检查是否触摸了射击按钮。如果是，那么我们调用`makeTheShot`。如果有任何其他触摸在桌子上，那么我们更新球杆的位置。
- en: '**Filename:** `OPControlTwoTouch.mm`'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `OPControlTwoTouch.mm`'
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This method is exactly the same as the one touch version of this method. It
    will track the touch, and keep updating the cue stick (and all the power and distance
    variables) as the touch moves.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法与单触版本的此方法完全相同。它将跟踪触摸，并在触摸移动时不断更新球杆（以及所有力量和距离变量）。
- en: '**Filename:** `OPControlTwoTouch.mm`'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `OPControlTwoTouch.mm`'
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Because we are not causing any automatic shot to happen when you release your
    touch, the only handling we need in the `ccTouchEnded` method is the handling
    for the `ballInHand` situation.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在你释放触摸时不会引发任何自动击球，因此在`ccTouchEnded`方法中我们需要的唯一处理就是处理`ballInHand`情况。
- en: That's all we need to do for both control schemes. Looking over the code, there
    are some similarities where it would be possible to refactor so that the two touch
    class is a subclass of the one touch class (or vice versa), but we wanted to keep
    the two separate to make it easier to add other control schemes later on without
    having too much tangled code.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这两种控制方案，我们只需要做这么多。查看代码，有一些相似之处，如果可能的话，可以重构，使得双触类成为单触类的子类（或反之亦然），但我们希望保持它们分开，以便在以后更容易添加其他控制方案，而不会使代码过于混乱。
- en: The rules engine
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则引擎
- en: 'We are nearing the end of our journey through the pool hall. There is still
    one gaping hole in our game: the logic of the rules engine and how we use it.
    Earlier, we saw how we load the rules into our `OPRulesBase` class, and we have
    done a little in the `OPPlayfieldLayer` class with using the player goals to update
    the player''s display. We will dig into the rules engine with the smaller, simpler
    methods first.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将结束在台球厅的旅程。在我们的游戏中，仍有一个明显的缺陷：规则引擎的逻辑以及我们如何使用它。之前，我们看到了如何将规则加载到我们的`OPRulesBase`类中，并在`OPPlayfieldLayer`类中做了一些使用玩家目标来更新玩家显示的工作。我们将首先从较小的、更简单的方法开始深入研究规则引擎。
- en: '**Filename:** `OPRulesBase.mm`'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `OPRulesBase.mm`'
- en: '[PRE36]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Because every rule in the game of pool will depend on which player is taking
    their turn (especially in the case of Eight Ball), this is our helper method to
    determine what the current player's goal really is. This will be used by several
    of the other methods in this class.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于台球游戏中每条规则都将取决于哪个玩家正在轮到他们（尤其是在八球的情况下），这是我们确定当前玩家真正目标的一个辅助方法。这将被本类中的其他几个方法使用。
- en: '**Filename:** `OPRulesBase.mm`'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `OPRulesBase.mm`'
- en: '[PRE37]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is the first of the "asking" methods we talked about earlier. We pass this
    method a `ballArray`, and "ask" if it contains the ball that was identified as
    the `lastBall` in the `rules.plist`. In Eight Ball, this is the ball numbered
    8\. In Nine Ball, this is the ball numbered 9\. In other games of your own making,
    it could be anything. You might ask, what exactly is in the `ballArray`? When
    we call this method during the `checkTable` method (we'll see this soon), we will
    be passing the `ballsSunk` array to this method, so it knows what balls were sunk
    during this turn only.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这是之前提到的“询问”方法中的第一个。我们向这个方法传递一个`ballArray`，并“询问”它是否包含在`rules.plist`中标识为`lastBall`的球。在八球中，这是编号为8的球。在九球中，这是编号为9的球。在你自己制作的其他游戏中，这可能是任何球。你可能会问，`ballArray`中具体是什么？当我们调用这个方法进行`checkTable`方法（我们很快就会看到）时，我们将传递`ballsSunk`数组给这个方法，这样它就知道在这个回合中击沉了哪些球。
- en: '**Filename:** `OPRulesBase.mm`'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `OPRulesBase.mm`'
- en: '[PRE38]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This is the same idea as the `didSinkLastBall` method, except this time we are
    strictly checking to see if the cue ball was sunk, which is a scratch. Now we
    can move on to the slightly larger, more complex methods.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`didSinkLastBall`方法的想法相同，只不过这次我们严格检查主球是否被击沉，这是一个擦球。现在我们可以继续到稍微复杂一些的方法。
- en: '**Filename:** `OPRulesBase.mm`'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `OPRulesBase.mm`'
- en: '[PRE39]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here we pass this method the `firstBall` variable, which is the ball identified
    as the first ball hit in the `update` method we saw earlier. This is the first
    ball that the cue ball impacted. If the `firstBall` variable is set to the default
    `kBallNone`, it means the cue ball didn't hit any other balls, so this is a table
    scratch. If it is, we store that in the `isTableScratch` variable so we can use
    it later.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们传递这个方法`firstBall`变量，这个变量是在我们之前看到的`update`方法中识别为第一次击打的球。这是第一个撞击主球的球。如果`firstBall`变量设置为默认的`kBallNone`，这意味着主球没有撞击其他球，所以这是一个台球擦球。如果是这样，我们将它存储在`isTableScratch`变量中，以便以后使用。
- en: We then run through a `switch` statement on the goal for the current player.
    If the game is still `kStripesVsSolids` (so the table is open), then any ball
    except the ball numbered 8 is legal. If the goal is stripes, the ball number must
    be above 8\. If the goal is solids, the ball number must be a lower number than
    the 8\. Finally, if the game is ordered, then the first ball must be the `nextOrderedBall`
    *or* `isBreak` must be true (that is, it is the break shot, so anything is legal
    to hit first).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着对当前玩家的目标进行`switch`语句处理。如果游戏仍然是`kStripesVsSolids`（即桌子是开放的），那么除了编号为8的球之外，任何球都是合法的。如果目标是条纹球，球号必须大于8。如果目标是实心球，球号必须小于8。最后，如果游戏是按顺序进行的，那么第一球必须是`nextOrderedBall`或者`isBreak`必须为真（即这是开球，所以可以合法地击打任何球）。
- en: '**Filename:** `OPRulesBase.mm`'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `OPRulesBase.mm`'
- en: '[PRE40]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `didSinkValidBall` method is used to parse out whether the player sank a
    ball that was valid for them. We again receive the `ballsSunk` array as a parameter
    and iterate through all balls in the array. We go through a `switch` statement
    to determine what their current goal is, and go through a similar check to see
    if the ball was valid. Since we are iterating through the entire array of sunk
    balls, at least one ball sunk must be valid for the player, in order to return
    a `YES` to the calling method. The one major difference is that here we are also
    checking to see if the ball sunk has the same value as the `lastBall` variable.
    Unless we are trying to sink the last ball, that is not a valid play, so it will
    return `NO`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`didSinkValidBall`方法用于解析玩家是否击沉了有效的球。我们再次接收`ballsSunk`数组作为参数，并遍历数组中的所有球。我们通过`switch`语句确定他们的当前目标，并执行类似的检查以查看球是否有效。由于我们正在遍历整个击沉球数组，至少必须有一个球对玩家来说是有效的，以便向调用方法返回`YES`。一个主要的不同之处在于，这里我们还检查击沉的球是否与`lastBall`变量具有相同的值。除非我们试图击沉最后一个球，否则这不是一个有效的玩法，所以它会返回`NO`。'
- en: '**Filename:** `OPRulesBase.mm`'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `OPRulesBase.mm`'
- en: '[PRE41]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The last major method in this class is `isValidLastBall:withBallsOnTable:`.
    This again follows a similar pattern to the other classes we have reviewed. In
    this case, we are looking through the balls that are still on the table, rather
    than the balls that were sunk. This will only be evaluated if the `lastBall` was
    sunk, so we are more concerned with what's left on the table. If we are playing
    Eight Ball, for example, and the current player is playing solids, then there
    must not be any ball numbered lower than the `lastBall` left on the table. If
    we are playing an ordered game, then all of the balls on the table must be sunk
    already.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类中的最后一个主要方法是`isValidLastBall:withBallsOnTable:`。这又遵循了我们已审查的其他类中类似的模式。在这种情况下，我们正在查看桌上仍然存在的球，而不是已经击落的球。这只有在`lastBall`被击落时才会评估，所以我们更关心桌上剩下的是什么。例如，如果我们正在玩八球，并且当前玩家正在玩固体球，那么桌上不能剩下任何编号低于`lastBall`的球。如果我们正在玩有序游戏，那么桌上所有的球都必须已经击落。
- en: 'There is only one small but very useful method left in the `OPRulesBase` class,
    so let''s look at it before we return to the playfield:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OPRulesBase`类中，只剩下一个非常小但非常有用的方法，在我们返回到playfield之前，让我们来看看它：
- en: '**Filename:** `OPRulesBase.mm`'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `OPRulesBase.mm`'
- en: '[PRE42]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: When you're playing an ordered ball game, like Nine Ball, the player must always
    aim at the lowest numbered ball. Since balls can be sunk out of order, we can
    not simply increment the ball number as the next ball. Instead, we look for each
    ball, starting at number 1 and continuing to 15, and checking the `tableBalls`
    array to see what the lowest numbered ball on the table really is. When we find
    a ball, we set that value to the `nextOrderedBall` variable, and return control
    to the calling method.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在玩有序的球类游戏，比如九球时，玩家必须始终瞄准编号最低的球。由于球可以按顺序击落，我们不能简单地按下一个球来递增球号。相反，我们从编号1开始，继续到15，检查`tableBalls`数组以确定桌上实际编号最低的球是什么。当我们找到一个球时，我们将该值设置为`nextOrderedBall`变量，并将控制权返回给调用方法。
- en: Putting balls back
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 放回球
- en: Before we move to the `checkTable` method to tie it all together, we have one
    more method in the playfield to see. As we have a rule defined as `ReplaceBalls`,
    we need a way to put illegally sunk balls back on the table. This is defined in
    the plist, so you can set this to your favorite rules. Playing "bar style", this
    is usually not an option, as coin-operated tables do not allow you to retrieve
    balls once they are sunk.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将`checkTable`方法整合在一起之前，我们在playfield中还有一个方法要查看。由于我们定义了一个名为`ReplaceBalls`的规则，我们需要一种方法将非法击落的球放回桌上。这定义在plist中，因此你可以将其设置为你的首选规则。玩“酒吧风格”，这通常不是一个选项，因为投币式桌球桌不允许你在球击落之后取回球。
- en: '**Filename:** `OPPlayfieldLayer.m`'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `OPPlayfieldLayer.m`'
- en: '[PRE43]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We receive the `sunkBalls` array as the parameter passed as `ballArray` to this
    method. If the rules specify `replaceBalls` = `YES`, then we first look through
    the balls to make sure the cue ball is not in the array. If it is, we delete it
    from the `ballArray`. We then iterate through all balls in the `ballArray`, and
    put them back on the table following the same positioning we used when we first
    built the rack. If they are too close to other balls on the table, they will be
    nudged out of the way by Box2D. We have made the decision that there is probably
    very little likelihood of there being six or more balls that need to be replaced
    at the same time, so we have capped this method to only replace the first six
    balls. Realistically, three is probably the highest number of balls we have ever
    seen that need to be replaced, and that is a rare occurrence.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`sunkBalls`数组作为参数传递给这个方法，参数名为`ballArray`。如果规则指定`replaceBalls` = `YES`，那么我们首先检查球以确保母球不在数组中。如果是，我们将其从`ballArray`中删除。然后我们遍历`ballArray`中的所有球，并按照我们最初构建球架时使用的相同定位将它们放回桌上。如果它们太靠近桌上其他球，它们将被Box2D推开。我们决定，同时需要替换六个或更多球的可能性非常小，所以我们把这个方法限制为只替换前六个球。实际上，我们见过的需要替换的球数最高是三个，这是一个罕见的情况。
- en: Checking the table
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查桌面
- en: We have finally reached the `checkTable` method. As you recall, this is called
    by the `update` method after the balls have come to rest after a shot. This is
    where the rest of the game interacts with the rules engine, so we will take this
    method in pieces.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于到达了`checkTable`方法。如您所回忆的，在球击中后静止后，这是由`update`方法调用的。这就是游戏的其他部分与规则引擎交互的地方，因此我们将分步骤来分析这个方法。
- en: '**Filename:** `OPPlayfieldLayer.m` (`checkTable`, part 1)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `OPPlayfieldLayer.m` (`checkTable`，第一部分)'
- en: '[PRE44]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We begin by setting up a lot of Boolean variables to hold the "answers" from
    the method calls to the rules engine. We then go through each of the conditions
    from the rules engine and populate the Boolean variables with the returned values
    from those methods.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先设置许多布尔变量来保存从规则引擎的方法调用中得到的“答案”。然后我们遍历规则引擎中的每个条件，并用那些方法返回的值填充布尔变量。
- en: '**Filename:** `OPPlayfieldLayer.mm` (`checkTable`, part 2)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `OPPlayfieldLayer.mm` (`checkTable`，第2部分)'
- en: '[PRE45]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The entirety of the `checkTable` method has to be specifically ordered to make
    sure that the highest priority events are handled first. The first check we make
    is to see if the `lastBall` was sunk. If it was, we then check `isValidLastBall`
    to see if this was a legal sinking of the `lastBall`. Then we further check to
    see if the player scratched at the same time. If it is a valid last ball and the
    player did not scratch, then the game is over – the current player wins. Otherwise,
    the player has sunk the `lastBall` too early in the game, and they have lost.
    If the player loses, we display a disparaging message, and end the game, declaring
    their opponent a winner.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkTable`方法的全部内容必须按照特定的顺序排列，以确保首先处理最高优先级的事件。我们首先检查是否发生了`lastBall`入袋。如果是，我们接着检查`isValidLastBall`以确定这是否是合法的`lastBall`入袋。然后我们进一步检查球员是否同时犯规。如果这是一个有效的`lastBall`且球员没有犯规，那么游戏结束——当前球员获胜。否则，球员在游戏中过早地击入了`lastBall`，他们已经输了。如果球员输了，我们显示一条贬低的消息，并结束游戏，宣布他们的对手为赢家。'
- en: '**Filename:** `OPPlayfieldLayer.mm` (`checkTable`, part 3)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `OPPlayfieldLayer.mm` (`checkTable`，第3部分)'
- en: '[PRE46]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If the player scratched (without the last ball being sunk), we let the player
    know they scratched, and the cue ball is now in hand for the other player. We
    also identify that we need to `replaceBalls` (if the option is set), and that
    we need to change players.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果球员犯规（最后球没有入袋），我们让球员知道他们犯规了，现在球杆球由另一名球员控制。我们还确定需要`replaceBalls`（如果选项已设置），并且需要更换球员。
- en: If the player did not scratch (cue ball in a pocket), but did table scratch
    (cue ball did not touch any other balls), then we simply change players. You will
    notice that this section is a chain of `if…else` statements, because these conditions
    are all mutually exclusive, and we don't need to check the remaining conditions
    if we have met an earlier one.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果球员没有发生犯规（球杆球入袋），但发生了台边犯规（球杆球没有触及任何其他球），那么我们只需更换球员。你会注意到这一部分是一个`if…else`语句的链，因为这些条件都是互斥的，如果我们已经满足了一个早期的条件，我们就不需要检查剩余的条件。
- en: Next we check to see if the player did not hit a valid first ball (they hit
    an opponent's ball first), then we call `replaceBalls`, display a message, and
    indicate a player change.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们检查球员是否没有击中有效的第一球（他们先击中了对手的球），然后我们调用`replaceBalls`，显示一条消息，并指示更换球员。
- en: '**Filename:** `OPPlayfieldLayer.mm` (`checkTable`, part 4)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `OPPlayfieldLayer.mm` (`checkTable`，第4部分)'
- en: '[PRE47]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In this final section of code, if `isValidSink` is `YES`, then we add the balls
    sunk by the player to their own `ballsSunk` array, and if their goal is still
    `kStripesVsSolids`, then we look at the first ball sunk, and that determines whether
    they are stripes or solids.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码的最后一部分，如果`isValidSink`是`YES`，那么我们将球员击入的球添加到他们自己的`ballsSunk`数组中，如果他们的目标是`kStripesVsSolids`，那么我们就查看第一个击入的球，这将决定他们是条纹球还是固体球。
- en: If nothing of interest happened, we simply change players.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有发生任何有趣的事情，我们只需更换球员。
- en: The remaining checks in this method are to handle the `isPlayerChange` and `replaceBalls`
    conditions we set earlier in the method, if needed. With that, the core gameplay
    is complete, and we're ready to play some pool!
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法中剩余的检查是为了处理我们在方法中之前设置的`isPlayerChange`和`replaceBalls`条件，如果需要的话。有了这些，核心游戏玩法就完成了，我们就可以开始玩一些台球了！
- en: The playfield init method
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放场初始化方法
- en: 'We have omitted some small areas of code, specifically those related to the
    main menu itself. We have built convenience methods to start the game with a specified
    rule set and a specified control scheme. (If you want to see these in detail,
    please refer to the code bundle for this chapter.) There''s really nothing that
    we haven''t done before in earlier chapters, but we will briefly go over the `initWithControl:andRules:`
    method of the `OPPlayfieldLayer` class, so you can see how we have structured
    the initialization of the game:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们省略了一些小的代码区域，特别是那些与主菜单本身相关的部分。我们构建了方便的方法，以便使用指定的规则集和指定的控制方案启动游戏。（如果您想详细了解这些，请参阅本章的代码包。）我们之前章节中已经做过的，这里真的没有太多，但我们将简要回顾`OPPlayfieldLayer`类的`initWithControl:andRules:`方法，这样您就可以看到我们是如何构建游戏的初始化的：
- en: '**Filename:** `OPPlayfieldLayer.mm`'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `OPPlayfieldLayer.mm`'
- en: '[PRE48]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As you can see, we call our custom `init` method with `NSString` representations
    of the control and rule names. We do this for clarity's sake more than for compact
    programming. As we discussed in the review of the `rules.plist` design, we sometimes
    need to sacrifice some small amount of optimizations in favor of readable code.
    Isn't it easier to know that the rule set we want is "Eight Ball" rather than
    game number 1? If these were checks that were happening repeatedly throughout
    the game, we would never make this performance trade-off. However, in all cases
    where we have used these strings, the code is run once per game, so the microseconds
    it takes does not impact performance at all.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用控制名称和规则名称的`NSString`表示调用我们的自定义`init`方法。我们这样做是为了清晰，而不是为了紧凑的编程。正如我们在`rules.plist`设计回顾中讨论的那样，我们有时需要为了可读的代码而牺牲一些小的优化。知道我们想要的规则集是“八球”而不是游戏编号1，不是更容易吗？如果这些检查在整个游戏中反复发生，我们永远不会做出这种性能权衡。然而，在所有使用这些字符串的情况下，代码在每场比赛中只运行一次，所以它所花费的微秒对性能没有任何影响。
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Well, we have covered a lot of code in this chapter. We have come back to Box2D
    after being away from it for a while, and we have built a pretty fun pool game.
    Along the way, we have explored alternate control schemes, how to make the same
    engine run with different game rules with a minimum of messy code in the core
    class, and hopefully learned a few new approaches to coding issues, too. Did we
    build a world-class pool simulator? Absolutely not. We built a fun game that you,
    the reader, can expand on and explore on your own. There are many ways you could
    expand on this game. Add new rules to play pool your way. We kept arrays of each
    player's sunken balls, but we never did anything interesting with them. (That
    was intentional.) Perhaps you could draw images of the balls from those arrays
    on the screen to show who sank which balls? The possibilities are there, and by
    now you should be ready to hack and slash at the code and make it your own.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，在这一章中，我们涵盖了大量的代码。我们离开Box2D一段时间后又回到了它，并构建了一个相当有趣的台球游戏。在这个过程中，我们探索了不同的控制方案，如何在核心类中用最少的混乱代码运行具有不同游戏规则的同一引擎，并且希望学习到一些新的编码方法。我们构建了一个世界级的台球模拟器吗？绝对不是。我们构建了一个有趣的游戏，您，读者，可以在此基础上扩展并自行探索。您有很多种扩展这个游戏的方法。添加新的规则来按您的方式玩台球。我们保留了每个玩家沉没的球数组，但我们从未对它们做任何有趣的事情。（这是故意的。）也许您可以在屏幕上绘制这些数组中的球图像，以显示谁沉没了哪些球？可能性是存在的，到现在您应该准备好对代码进行修改和定制，使其成为您自己的。
- en: In the next chapter we will be building a top-down shooter, using tile maps
    and onscreen joysticks. It also has a strange fruit versus vegetable theme, just
    for fun. See you there!
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将构建一个自上而下的射击游戏，使用瓦片地图和屏幕上的操纵杆。它还有一个奇怪的果实与蔬菜主题，只是为了好玩。那里见！
