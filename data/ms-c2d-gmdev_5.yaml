- en: Chapter 5. Creating Cool Content
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 创建酷炫内容
- en: In this chapter, you'll be learning how to implement the really complex, subtle
    game mechanics that not many developers do. This is what separates the good games
    from the great games. There will be many examples, tutorials, and code snippets
    in this chapter intended for adaption in your own projects, so feel free to come
    back at any time to look at something you may have either missed the first time,
    or are just curious to know about in general.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何实现真正复杂、微妙的游戏机制，这是许多开发者不会做的。这就是好游戏与伟大游戏之间的区别。本章将包含许多示例、教程和代码片段，旨在适应你自己的项目，所以随时欢迎回来查看你可能第一次错过或只是好奇的内容。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Adding a table for scores
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加分数表格
- en: Adding subtle sliding to the units
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为单位添加细微的滑动
- en: Creating movements on a Bézier curve instead of straight paths
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在贝塞尔曲线上创建运动而不是直线路径
- en: Depth perception via device tilting (and parallax scrolling)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过设备倾斜实现深度感知（以及视差滚动）
- en: Three ways to create unit streamers or ghosts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建单位流线或幽灵的三种方法
- en: Touchscreen controls versus D-pad adaptation (and why it matters so much to
    know this distinction)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触屏控制与D-pad适配（以及为什么了解这种区别如此重要）
- en: A common theme for this chapter will be to show you how to take what seem like
    complex things and turn them into easy-to-code and easy-to-modify segments that
    you can implement in your own project (or projects).
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的一个常见主题将向您展示如何将看似复杂的事物转化为易于编码和修改的段，您可以将它们实现到自己的项目中（或项目中）。
- en: Also, this chapter features things that won't go well with the book's project,
    and only the first two points in the preceding list are related to the game project,
    which has been slowly worked all this while. The rest are standalone sample projects
    with code designed in a modular fashion so that you can extract it for your own
    projects faster.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，本章介绍了一些与本书项目不兼容的内容，并且前述列表中的前两点与游戏项目相关，该项目一直缓慢地进行。其余的都是独立的示例项目，代码以模块化方式设计，以便你可以更快地将它们提取到自己的项目中。
- en: Tip
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It's strongly recommended to open the Chapter 5 code before working on the first
    two sections. A decent amount of code has been added and/or modified since the
    last chapter, and it was not talked about in this book. Therefore, you may get
    compilation errors should you try to follow along with the book without using
    the Chapter 5 project code. Thanks for understanding!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议在处理前两个部分之前打开第5章的代码。自上一章以来，已经添加和/或修改了大量代码，并且本书没有提及。因此，如果你不使用第5章的项目代码而跟随本书，可能会遇到编译错误。感谢您的理解！
- en: Adding a table for scores
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加分数表格
- en: Because we want a way to show the user their past high scores, in the `GameOver`
    scene, we're going to add a table that displays the most recent high scores that
    are saved. For this, we're going to use `CCTableView`. It's still relatively new,
    but it works for what we're going to use it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们要提供一个方式让用户看到他们的过去高分，在`GameOver`场景中，我们将添加一个表格来显示保存的最新高分。为此，我们将使用`CCTableView`。它仍然相对较新，但对我们将要使用它是适用的。
- en: CCTableView versus UITableView
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CCTableView与UITableView的比较
- en: Although `UITableView` might be known to some of you who've made non-Cocos2d
    apps before, you should be aware of its downfalls when it comes to using it within
    Cocos2d. For example, if you want a BMFont in your table, you can't add `LabelBMFont`
    (you could try to convert the BMFont into a TTF font and use that within the table,
    but that's outside the scope of this book).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对于之前制作过非Cocos2d应用的你们来说，`UITableView`可能已经熟知，但在Cocos2d中使用时，你应该意识到它的缺点。例如，如果你想在表格中使用BMFont，你不能添加`LabelBMFont`（你可以尝试将BMFont转换为TTF字体并在表格中使用，但这超出了本书的范围）。
- en: 'If you still wish to use a `UITableView` object (or any `UIKit` element for
    that matter), you can create the object like normal, and add it to the scene,
    like this (`tblScores` is the name of the `UITableView` object):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然希望使用`UITableView`对象（或任何`UIKit`元素），你可以像平常一样创建对象，并将其添加到场景中，如下所示（`tblScores`是`UITableView`对象的名称）：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Saving high scores (NSUserDefaults)
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存高分（NSUserDefaults）
- en: Before we display any high scores, we have to make sure we save them. The easiest
    way to do this is by making use of Apple's built-in data preservation tool—NSUserDefaults.
    If you've never used it before, let me tell you that it's basically a dictionary
    with "save" mechanics that stores the values in the device so that the next time
    the user loads the device, the values are available for the app.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们显示任何高分之前，我们必须确保保存它们。最简单的方法是利用苹果内置的数据保存工具—NSUserDefaults。如果你以前从未使用过它，让我告诉你，它基本上是一个具有“保存”机制的字典，它将值存储在设备上，以便下次用户加载设备时，这些值可用于应用程序。
- en: Also, because there are three different values we're tracking for each gameplay,
    let's only say a given game is better than another game when the total score is
    greater.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，因为我们正在跟踪每个游戏玩法中的三个不同值，所以我们只说一个游戏的总分高于另一个游戏时，总分更高。
- en: 'Therefore, let''s create a `saveHighScore` method that will go through all
    the total scores in our saved list and see whether the current total score is
    greater than any of the saved scores. If so, it will insert itself and bump the
    rest down. In `MainScene.m`, add the following method:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们创建一个`saveHighScore`方法，该方法将遍历我们保存列表中的所有总分，并查看当前的总分是否高于任何已保存的分数。如果是这样，它将插入自己并将其余的向下移动。在`MainScene.m`中添加以下方法：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Finally, call this method in the `endGame` method right before you transition
    to the next scene:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在过渡到下一个场景之前，在`endGame`方法中调用此方法：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now that we have our high scores being saved, let's create the table to display
    them.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经保存了高分，让我们创建一个表格来显示它们。
- en: Creating the table
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建表格
- en: It's really simple to set up a `CCTableView` object. All we need to do is modify
    the `contentSize` object, and then put in a few methods that handle the size and
    content of each cell.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`CCTableView`对象非常简单。我们只需要修改`contentSize`对象，然后添加一些处理每个单元格大小和内容的方法。
- en: 'So first, open the `GameOverScene.h` file and set the scene as a data source
    for the `CCTableView`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先打开`GameOverScene.h`文件，并将场景设置为`CCTableView`的数据源：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, in the `initWithScoreData` method, create the header labels as well as
    initialize the `CCTableView`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`initWithScoreData`方法中，创建标题标签以及初始化`CCTableView`：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With the `CCTableView` object's data source being set to `self` we can add the
    three methods that will determine exactly how our table looks and what data goes
    in each cell (that is, row).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当`CCTableView`对象的数据源设置为`self`时，我们可以添加三个方法，这些方法将确定我们的表格外观以及每个单元格（即行）中的数据。
- en: Note
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that if we don't set the data source, the table view's method will not
    be called; and if we set it to anything other than `self`, the methods will be
    called on that object/class instead.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果我们没有设置数据源，表格视图的方法将不会被调用；如果我们将其设置为除`self`之外的其他任何内容，方法将调用该对象/类。
- en: 'That being said, add these three methods:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，添加以下三个方法：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first method, `tableView:nodeForRowAtIndex:`, will format each cell based
    on which index it is. For now, we're going to color each cell in one of two different
    colors.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法，`tableView:nodeForRowAtIndex:`，将根据索引格式化每个单元格。目前，我们将用两种不同的颜色之一来着色每个单元格。
- en: The second method, `tableViewNumberOfRows:`, returns the number of rows, or
    cells, that will be in the table view. Since we know there are going to be 20,
    we can technically type 20, but what if we decide to change that number later?
    So, let's stick with using the count of the array.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个方法，`tableViewNumberOfRows:`，返回表格视图中将有的行数或单元格数。既然我们知道将有20个，我们可以技术上输入20，但如果我们决定稍后更改这个数字怎么办？所以，让我们继续使用数组的计数。
- en: The third method, `tableView:heightForRowAtIndex:`, is meant to return the height
    of the row, or cell, at the given index. Since we aren't doing anything different
    with any cell in particular, we can hardcode this value to a fairly reasonable
    height of 40.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种方法，`tableView:heightForRowAtIndex:`，是用来返回给定索引处的行或单元格的高度。由于我们对于任何特定的单元格都没有做任何不同的事情，我们可以将这个值硬编码为一个相当合理的40像素高度。
- en: At this point, you should be able to run the game, and when you lose, you'll
    be taken to the game over screen with the labels across the top as well as a table
    that scrolls on the right side of the screen.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该能够运行游戏，当你失败时，你会被带到游戏结束屏幕，顶部有标签，屏幕右侧有一个可以滚动的表格。
- en: Tip
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It's good practice when learning Cocos2d to just mess around with stuff to see
    what sort of effects you can make. For example, you could try using some ScaleTo
    actions to scale the text up from 0, or use a `MoveTo` action to slide it from
    the bottom or the side.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 学习Cocos2d时，一个好的实践就是随意尝试一些东西，看看你能创造出什么样的效果。例如，你可以尝试使用一些`ScaleTo`动作将文本从0缩放，或者使用`MoveTo`动作从底部或侧面滑动它。
- en: Feel free to see whether you can create a cool way to display the text right
    now.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 随意看看你现在是否能想出一个酷炫的方式来显示文本。
- en: Now that we have the table in place, let's get the data displayed, shall we?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有了表格，让我们来看看如何显示数据，好吗？
- en: Showing the scores
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示得分
- en: Now that we have our table created, it's a simple addition to our code to get
    the proper numbers to display correctly.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了表格，只需简单地将数据添加到我们的代码中，就可以正确地显示数字。
- en: 'In the `nodeForRowAtIndex` method, add the following block of code right after
    adding the background color to the cell:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在`nodeForRowAtIndex`方法中，在给单元格添加背景色之后，添加以下代码块：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: And that's it! When you play the game and end up at the game over screen, you'll
    see the high scores being displayed (even the scores from earlier attempts, because
    they were saved, remember?). Notice the high score that is yellow. It's an indication
    that the score you got in the game you just played is on the scoreboard, and shows
    you where it is.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！当你玩游戏并最终到达游戏结束屏幕时，你会看到高分正在显示（甚至包括之前的尝试得分，因为它们已经被保存了，记得吗？）。注意那个黄色的最高分。这是一个指示，表明你刚刚玩的游戏得分已经出现在排行榜上，并显示了它的位置。
- en: Although the `CCTableView` might feel a bit weird with things disappearing and
    reappearing as you scroll, we'll cover how to make that better in the next chapter
    on polishing our game. For now, let's get some *Threes!*—like sliding into our
    game.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然当滚动时`CCTableView`中东西消失和重新出现可能会感觉有点奇怪，但我们将在下一章中介绍如何使它变得更好。现在，让我们来一些*Threes!*——像滑动进入我们的游戏。
- en: Tip
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you're considering adding a `CCTableView` to your own project, the key takeaway
    here is to make sure you modify the `contentSize` and position properly. By default,
    the `contentSize` is a normalized `CGSize`, so from 0 to 1, and the anchor point
    is (0,0).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在考虑将`CCTableView`添加到自己的项目中，这里的关键要点是确保你正确地修改`contentSize`和位置。默认情况下，`contentSize`是一个归一化的`CGSize`，范围从0到1，锚点是（0,0）。
- en: 'Plus, make sure you perform these two steps:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，确保你执行以下两个步骤：
- en: Set the data source of the table view
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置表格视图的数据源
- en: Add the three table view methods
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加三个表格视图方法
- en: With all that in mind, it should be relatively easy to implement a `CCTableView`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些，实现`CCTableView`应该相对简单。
- en: Adding subtle sliding to the units
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为单元添加微妙的滑动效果
- en: If you've ever played *Threes!* (or if you haven't, check out the trailer at
    [http://asherv.com/threes/](http://asherv.com/threes/), and maybe even download
    the game on your phone), you would be aware of the sliding feature when a user
    begins to make their move but hasn't yet completed the move. At the speed of the
    dragging finger, the units slide in the direction they're going to move, showing
    the user where each unit will go and how each unit will combine with another.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经玩过*Threes!*（或者即使你没有，也可以看看[http://asherv.com/threes/](http://asherv.com/threes/)上的预告片，甚至可以在你的手机上下载游戏），你就会知道当用户开始移动但尚未完成移动时，会有滑动功能。随着拖动手指的速度，单元会向它们将要移动的方向滑动，向用户显示每个单元将去哪里以及每个单元将如何与其他单元结合。
- en: This is useful as it not only adds that extra layer of "cool factor" but also
    provides a preview of the future for the user if they want to revert their decision
    ahead of time and make a different, more calculated move.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有用，因为它不仅增加了额外的“酷炫因素”，还如果用户想在做出决定之前撤销并做出不同的、更谨慎的移动，它还提供了对未来的预览。
- en: Tip
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Here''s a side note: if you want your game to go really viral, you have to
    make the user believe it was their fault that they lost, and not your "stupid
    game mechanics" (as some players might say).'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个小贴士：如果你想让你的游戏真正流行起来，你必须让用户相信他们输是因为自己的错误，而不是你的“愚蠢的游戏机制”（正如一些玩家可能会说的）。
- en: 'Think *Angry Birds*, *Smash Hit*, *Crossy Road*, *Threes!*, *Tiny Wings*… the
    list goes on and on with more games that became popular, and all had one underlying
    theme: when the user loses, it was entirely in their control to win or lose, and
    they made the wrong move.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 想想*愤怒的小鸟*，*Smash Hit*，*Crossy Road*，*Threes!*，*Tiny Wings*…这个列表可以一直继续，更多流行的游戏都有一个共同的主题：当用户失败时，完全取决于他们自己决定赢或输，并且他们做出了错误的移动。
- en: This unseen mechanic pushes players to play again with a better strategy in
    mind. And this is exactly why we want our users to see their move before it gets
    made. It's a win-win situation for both the developers and the players.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这种看不见的机制促使玩家带着更好的策略再次玩游戏。这正是我们希望用户在做出动作之前看到他们的动作的原因。这对开发者和玩家来说都是双赢的局面。
- en: Sliding one unit
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 滑动一个单位
- en: If we can get one unit to slide, we can surely get the rest of the units to
    slide by simply looping through them, modularizing the code, or some other form
    of generalization.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以让一个单位滑动，那么我们当然可以通过简单地遍历它们、模块化代码或某种其他形式的泛化来让其他单位也滑动。
- en: 'That being said, we need to set up the `Unit` class so that it can detect how
    far the finger has dragged. Thus, we can determine how far to move the unit. So,
    open `Unit.h` and add the following variable. It will track the distance from
    the previous touch position:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们需要设置`Unit`类，使其能够检测手指拖动的距离。这样，我们可以确定单位移动的距离。所以，打开`Unit.h`并添加以下变量。它将跟踪从上一个触摸位置的距离：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, in the `touchMoved` method of `Unit.m`, add the following assignment
    to `previousTouchPos`. It sets the previous touch position to the touch-down position,
    but only after the distance is greater than 20 units:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`Unit.m`的`touchMoved`方法中，向`previousTouchPos`添加以下赋值。它将前一个触摸位置设置为触摸下落位置，但前提是距离大于20个单位：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once that''s in place, we can begin calculating the distance while the finger
    is being dragged. To do that, we''ll do a simple check. Add the following block
    of code at the end of `touchMoved`, after the end of the initial `if` block:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置好，我们就可以在手指拖动时开始计算距离。为此，我们将进行一个简单的检查。在`touchMoved`的末尾，在初始`if`块之后添加以下代码块：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The assignment of `previousTouchPos` at the end will ensure that while the unit
    is being dragged, we continue to update the touch position so that we can determine
    the distance. Plus, the distance is calculated in only the direction in which
    the unit is being dragged (up and down are denoted by Y, and left and right are
    denoted by X).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在末尾对`previousTouchPos`的赋值将确保，当单位被拖动时，我们继续更新触摸位置，以便我们可以确定距离。此外，距离仅在单位被拖动的方向上计算（上下用Y表示，左右用X表示）。
- en: 'Now that we have the distance between finger drags being calculated, let''s
    push this into a function that will move our unit based on which direction it''s
    being dragged in. So, right after you''ve calculated `dist` in the previous code
    block, call the following method to move our unit based on the amount dragged:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经计算了手指拖动的距离，让我们将其推入一个函数，该函数将根据单位被拖动的方向移动我们的单位。所以，在你计算出上一段代码块中的`dist`之后，调用以下方法来根据拖动的量移动我们的单位：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tip
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Dividing the distance by `2` is optional. You may think the squares are too
    small, and want the user to be able to see their square. So note that dividing
    by `2`, or a larger number, will mean that for every 1 point the finger moves,
    the unit will move by 1/2 (or less) points.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 将距离除以`2`是可选的。你可能认为方块太小，希望用户能看到他们的方块。所以请注意，除以`2`或更大的数字意味着，每当手指移动1点，单位就会移动1/2（或更少）点。
- en: 'With that method call being ready, we need to implement it, so add the following
    method body for now. Since this method is rather complicated, it''s going to be
    added in parts:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 那个方法调用准备好了，我们需要实现它，所以现在添加以下方法体。由于这个方法相当复杂，我们将分部分添加：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The first thing we need to do is set up a variable to calculate the new *x*
    and *y* positions of the unit. We''ll call these `newX` and `newY`, and set them
    to the unit''s current position:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是设置一个变量来计算单位的新的*x*和*y*位置。我们将称这些为`newX`和`newY`，并将它们设置为单位的当前位置：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, we want to grab the position that the unit starts at, that is, the position
    the unit would be at if it was positioned at its current grid coordinate. To do
    that, we''re going to call the `getPositionForGridCoordinate` method from `MainScene`,
    (since that''s where the positions are being calculated anyway, we might as well
    use that function):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要获取单位开始的位置，即单位如果位于其当前网格坐标的位置。为此，我们将从`MainScene`调用`getPositionForGridCoordinate`方法（因为位置计算已经在那里进行，我们不妨使用那个函数）：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we''re going to move the `newX` or `newY` based on the direction in which
    the unit is being dragged. For now, let''s just add the up direction:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将根据单位被拖动的方向移动`newX`或`newY`。现在，让我们先添加向上方向：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this if block, we're first going to add the distance to the `newY` variable
    (because we're going up, we're adding to Y instead of X). Then, we want to make
    sure the position is at most 1 square up. We're going to use the `gridWidth` (which
    is essentially the width of the square, assigned in the `initCommon` method).
    Also, we need to make sure that if they're bringing the square back to its original
    position, it doesn't go into the square beneath it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个if块中，我们首先将距离添加到`newY`变量中（因为我们向上移动，所以我们添加到Y而不是X）。然后，我们想确保位置最多向上移动1个方块。我们将使用`gridWidth`（这实际上是方块的宽度，在`initCommon`方法中分配）。此外，我们还需要确保如果他们把方块移回原始位置，它不会进入下面的方块。
- en: 'So let''s add the rest of the directions as else if statements:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们添加其余的方向作为else if语句：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we will set the position of the unit based on the newly calculated
    *x* and *y* positions:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将根据新计算出的*x*和*y*位置设置单元的位置：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Running the game at this point should cause the unit you drag to slide along
    with your finger. Nice, huh? Since we have a function that moves one unit, we
    can very easily alter it so that every unit can be moved like this.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段运行游戏应该会导致你拖动的单元随着你的手指滑动。不错，对吧？因为我们有一个移动一个单元的函数，我们可以很容易地修改它，以便每个单元都可以这样移动。
- en: But first, there's something you've probably noticed a while ago (or maybe just
    recently), and that's the unit movement being canceled only when you bring your
    finger back to the original touch down position. Because we're dragging the unit
    itself, we can "cancel" the move by dragging the unit back to where it started.
    However, the finger might be in a completely different position, so we need to
    modify how the cancelling gets determined.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，你可能已经注意到了一段时间前（或者可能只是最近），那就是单元移动只有在将手指移回原始触摸位置时才会取消。因为我们正在拖动单元本身，所以我们可以通过将单元拖回起始位置来“取消”移动。然而，手指可能处于完全不同的位置，所以我们需要修改确定取消移动的方式。
- en: 'To do that, in your `touchEnded` method of `Unit.m`, locate this if statement:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，请在`Unit.m`的`touchEnded`方法中找到这个if语句：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Change it to the following, which will determine the unit''s distance, and
    not the finger''s distance:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 将其更改为以下内容，这将确定单元的距离，而不是手指的距离：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Yes, this means you no longer need the `touchPos` variable in `touchEnded` if
    you're getting that warning and wish to get rid of it. But that's it for sliding
    1 unit. Now we're ready to slide all the units, so let's do it!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这意味着如果你收到那个警告并且希望消除它，你不再需要在`touchEnded`中需要`touchPos`变量。但对于滑动1个单元来说，这就足够了。现在我们准备好滑动所有单元，让我们开始吧！
- en: Sliding all units
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 滑动所有单元
- en: Now that we have the dragging unit being slid, let's continue and make all the
    units slide (even the enemy units so that we can better predict our troops' movement).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了正在滑动的拖动单元，让我们继续并使所有单元滑动（甚至包括敌方单元，这样我们可以更好地预测我军部队的移动）。
- en: First, we need a way to move all the units on the screen. However, since the
    Unit class only contains information about the individual unit (which is a good
    thing), we need to call a method in `MainScene`, since that's where the arrays
    of units are.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一种方法来移动屏幕上的所有单元。然而，由于单元类只包含有关单个单元的信息（这是好事），我们需要在`MainScene`中调用一个方法，因为那里有单元数组。
- en: Moreover, we cannot simply call `[MainScene method]`, since the arrays are instance
    variables, and instance variables must be accessed through an instance of the
    object itself.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们不能简单地调用`[MainScene method]`，因为数组是实例变量，而实例变量必须通过对象本身的实例来访问。
- en: 'That being said, because we know that our unit will be added to the scene as
    a child, we can use Cocos2d to our advantage, and call an instance method on the
    `MainScene` class via the parent parameter. So, in `touchMoved` of `Unit.m`, make
    the following change:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，因为我们知道我们的单元将作为子单元添加到场景中，所以我们可以利用Cocos2d的优势，并通过父参数在`MainScene`类上调用一个实例方法。因此，在`Unit.m`的`touchMoved`中，进行以下更改：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Basically we've commented out (or deleted) the old method call here, and instead
    called it on our parent object (which we cast as a `MainScene` so that we know
    which functions it has).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们已经注释掉了（或者删除了）这里的老方法调用，而是调用我们的父对象（我们将它转换为`MainScene`，这样我们知道它有哪些函数）。
- en: 'But we don''t have that method created yet, so in `MainScene.h`, add the following
    method declaration:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们还没有创建那个方法，所以请在`MainScene.h`中添加以下方法声明：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Tip
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Just in case you haven't noticed, the enum UnitDirection is declared in `Unit.h`,
    which is why `MainScene.h` imports `Unit.h`—so that we can make use of that enum
    in this class, and the function to be more specific.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，你可能没有注意到，枚举 `UnitDirection` 在 `Unit.h` 中声明，这就是为什么 `MainScene.h` 导入 `Unit.h`
    的原因——这样我们就可以在这个类中使用该枚举，并具体化该函数。
- en: 'Then in `MainScene.m`, we''re going to loop through both the friendly and enemy
    arrays, and call the `slideUnitWithDistance` function on each individual unit:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在 `MainScene.m` 中，我们将遍历友方和敌方数组，并对每个单独的单位调用 `slideUnitWithDistance` 函数：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'However, that still isn''t functional, as we haven''t declared that function
    in the header file for the `Unit` class. So go ahead and do that now. Declare
    the function header in `Unit.h`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这仍然不起作用，因为我们还没有在 `Unit` 类的头部文件中声明该函数。所以现在就去声明它。在 `Unit.h` 中声明函数头：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We're almost done.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了。
- en: We initially set up our `slideUnitWithDistance` method with a drag direction
    in mind. However, only the unit that's currently being dragged will have a drag
    direction. Every other unit will need to use the direction it's currently facing
    (that is, the direction in which it's already going).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初设置 `slideUnitWithDistance` 方法时考虑了拖动方向。然而，只有当前被拖动的单位会有拖动方向。其他所有单位都需要使用它们当前面对的方向（即它们已经移动的方向）。
- en: To do that, we just need to modify how the `slideUnitWithDistance` method does
    its checking to determine which direction to modify the distance by.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们只需要修改 `slideUnitWithDistance` 方法进行检查以确定如何修改距离的方向。
- en: But first, we need to handle the negatives. What does that mean? Well, if you're
    dragging a unit to the left and a unit being moved is supposed to be moving to
    the left, it will work properly, as x-10 (for example) will still be less than
    the grid's width. However, if you're dragging left and a unit being moved is supposed
    to be moving right, it won't be moving at all, as it tries to add a negative value
    x `-10`, but because it needs to be moving to the right, it'll encounter the left-bound
    right away (of less than the original position), and stay still.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，我们需要处理负值。这意味着什么？好吧，如果你正在将单位向左拖动，而要移动的单位应该向左移动，它将正常工作，因为 x-10（例如）仍然小于网格的宽度。然而，如果你向左拖动，而要移动的单位应该向右移动，它将根本不会移动，因为它试图添加一个负值
    x `-10`，但由于它需要向右移动，它将立即遇到左边界（小于原始位置），并保持静止。
- en: The following diagram should help explain what is meant by "handling negatives."
    As you can see, in the top section, when the non-dragged unit is supposed to be
    going left by `10` (in other words, negative 10 in the *x* direction), it works.
    But when the non-dragged unit is going the opposite sign (in other words, positive
    `10` in the *x* direction), it doesn't.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表应该有助于解释“处理负值”的含义。如图所示，在上部区域，当非拖动单位应该向左移动 `10`（换句话说，*x* 方向的负 10）时，它起作用。但当非拖动单位移动的方向相反（换句话说，*x*
    方向的正 `10`）时，它不起作用。
- en: '![Sliding all units](img/image00248.jpeg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![滑动所有单位](img/image00248.jpeg)'
- en: To handle this, we set up a pretty complicated if statement. It checks when
    the drag direction and the unit's own direction are opposite (positive versus
    negative), and multiplies the distance by `-1` (flips it).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这个问题，我们设置了一个相当复杂的 `if` 语句。它检查拖动方向和单位自己的方向是否相反（正与负），并将距离乘以 `-1`（翻转）。
- en: 'Add this to the top of the `slideUnitWithDistance` method, right after you
    grab the `newX` and the original position:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到 `slideUnitWithDistance` 方法的顶部，在你获取 `newX` 和原始位置之后：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The logic of this if statement works is as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `if` 语句的逻辑如下：
- en: Suppose the unit is not being dragged. Also suppose that either the direction
    is positive and the drag direction is negative, or the direction is negative and
    the drag direction is positive. Then multiply by `-1`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 假设单位没有被拖动。此外，假设方向是正的而阻力方向是负的，或者方向是负的而阻力方向是正的。然后乘以 `-1`。
- en: 'Finally, as mentioned earlier, we just need to handle the non-dragged units.
    So, in every `if` statement, add an "or" portion that will check for the same
    direction, but only if the unit is not currently being dragged. In other words,
    in the `slideUnitWithDistance` method, modify your if statements to look like
    this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如前所述，我们只需要处理非拖动单位。因此，在每一个 `if` 语句中，添加一个“或”部分，以检查相同方向，但只有当单位当前没有被拖动时。换句话说，在
    `slideUnitWithDistance` 方法中，修改你的 `if` 语句，使其看起来像这样：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Finally, we can run the game. Bam! All the units go gliding across the screen
    with our drag. Isn't it lovely? Now the player can better choose their move.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以运行游戏。砰！所有单位都随着我们的拖动在屏幕上滑行。这不是很棒吗？现在玩家可以更好地选择他们的移动。
- en: That's it for the sliding portion (as well as this project's portion of the
    chapter). The rest of this chapter is filled with some really amazing things,
    and you're encouraged to check them out, as they may be helpful to you in your
    current projects outside this book, or in a future project of your own.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是滑动部分（以及这个项目章节的部分）的全部内容。本章的其余部分充满了真正令人惊叹的东西，鼓励你查看它们，因为它们可能对你在这本书之外的项目或你自己的未来项目有所帮助。
- en: Tip
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The key to unit sliding is to loop through the arrays to ensure that all the
    units get moved by an equal amount, hence passing the distance to the `move` function.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 单位滑动的关键是循环遍历数组，以确保所有单位移动的距离相等，因此传递给 `move` 函数的距离。
- en: Creating movements on a Bézier curve
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在贝塞尔曲线上创建运动
- en: If you don't know what a Bézier curve is, it's basically a line that goes from
    point A to point B over a curve. Instead of being a straight line with two points,
    it uses a second set of points called control points that bend the line in a smooth
    way. When you want to apply movement with animations in Cocos2d, it's very tempting
    to queue up a bunch of `MoveTo` actions in a sequence. However, it's going to
    look a lot nicer ( in both the game and the code) if you use a smoother Bézier
    curve animation.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道贝塞尔曲线是什么，它基本上是一条从点A到点B经过曲线的线。它不是一条由两个点组成的直线，而是使用第二组点，即控制点，以平滑的方式弯曲线条。当你想在
    Cocos2d 中应用带有动画的运动时，按顺序排队一大堆 `MoveTo` 动作是非常诱人的。然而，如果你使用更平滑的贝塞尔曲线动画，游戏和代码看起来会更好。
- en: 'Here''s a good example of what a Bézier curve looks like:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个贝塞尔曲线的例子看起来是什么样子的：
- en: '![Creating movements on a Bézier curve](img/image00249.jpeg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![在贝塞尔曲线上创建运动](img/image00249.jpeg)'
- en: As you can see, the red line goes from point P0 to P3\. However, the line is
    influenced in the direction of the control points, P1 and P2.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，红线从点 P0 到 P3。然而，这条线受到控制点 P1 和 P2 方向的影响。
- en: Examples of using a Bézier curve
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用贝塞尔曲线的例子
- en: 'Let''s list a few examples where it would be a good choice to use a Bézier
    curve instead of just the regular `MoveTo` or `MoveBy` actions:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们列出一些使用贝塞尔曲线而不是常规的 `MoveTo` 或 `MoveBy` 动作的好例子：
- en: A character that will perform a jumping animation, for example, in *Super Mario
    Bros*
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个将执行跳跃动画的角色，例如，在 *超级马里奥兄弟* 中
- en: A boomerang as a weapon that the player throws
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家投掷的回旋镖作为武器
- en: Launching a missile or rocket and giving it a parabolic curve
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发射导弹或火箭并给它一个抛物线曲线
- en: A tutorial hand that indicates a curved path the user must make with their finger
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指示用户必须用手指绘制曲线路径的教程手
- en: A skateboarder on a half-pipe ramp (if not done with Chipmunk)
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在半管道坡道上的滑板运动员（如果不是用 Chipmunk 完成）
- en: There are obviously a lot of other examples that could use a Bézier curve for
    their movement. But let's actually code one, shall we?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，还有很多其他例子可以使用贝塞尔曲线来模拟它们的运动。但让我们实际编写一个，怎么样？
- en: Sample project – Bézier map route
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 样本项目 – 贝塞尔地图路线
- en: First, to make things go a lot faster—as this isn't going to be part of the
    book's project—simply download the project from the code repository or the website.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了使事情变得更快——因为这个不是本书项目的部分——只需从代码仓库或网站下载项目。
- en: If you open the project and run it on your device or a simulator, you will notice
    a blue screen and a square in the bottom-left corner. If you tap anywhere on the
    screen, you'll see the blue square make an **M** shape ending in the bottom-right
    corner. If you hold your finger, it will repeat. Tap again and the animation will
    reset.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开项目并在你的设备或模拟器上运行它，你会注意到一个蓝色屏幕和位于左下角的正方形。如果你在屏幕上的任何地方点击，你会看到蓝色的正方形形成一个 **M**
    形状，结束在右下角。如果你保持手指，它会重复。再次点击，动画将重置。
- en: Imagine the path this square takes is over a map, and indicates what route a
    player will travel with their character. This is a very choppy, very sharp path.
    Generally, paths are curved, so let's make one that is!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 想象这个正方形走过的路径是在地图上，并指示玩家将如何使用他们的角色进行路线。这是一条非常粗糙、非常尖锐的路径。通常，路径是弯曲的，所以让我们做一个弯曲的路径吧！
- en: Here's the end result (tracked using the `CCMotionStreak` method described in
    the *Three ways to make unit streamers or "ghosts"* section of this chapter).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最终结果（使用本章“三种制作单位流或‘幽灵’”部分中描述的 `CCMotionStreak` 方法跟踪）。
- en: 'Here is a screenshot that shows a very straight path of the blue square:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一张显示蓝色正方形非常直的路径的截图：
- en: '![Sample project – Bézier map route](img/image00250.jpeg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![示例项目 – 贝塞尔地图路线](img/image00250.jpeg)'
- en: 'The following screenshot shows the Bézier path of the yellow square:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了黄色正方形的贝塞尔路径：
- en: '![Sample project – Bézier map route](img/image00251.jpeg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![示例项目 – 贝塞尔地图路线](img/image00251.jpeg)'
- en: Curved M-shape
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 曲线 M 形状
- en: 'Open `MainScene.h` and add another `CCNodeColor` variable, named `unitBezier`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `MainScene.h` 并添加另一个 `CCNodeColor` 变量，命名为 `unitBezier`：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then open `MainScene.m` and add the following code to the init method so that
    your yellow block shows up on the screen:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后打开 `MainScene.m` 并在初始化方法中添加以下代码，以便你的黄色方块出现在屏幕上：
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, in the `sendFirstUnit` method, add the lines of code that will reset
    the yellow block''s position as well as queue up the method to move the yellow
    block:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `sendFirstUnit` 方法中，添加重置黄色方块位置的代码行，并将该方法排队以移动黄色方块：
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'After this, you''ll need to actually create the `sendSecondUnit` method, like
    this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，你需要实际创建 `sendSecondUnit` 方法，如下所示：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The preceding method creates three Bézier configurations and attaches them to
    a `MoveTo` command that takes a Bézier configuration. The reason for this is that
    each Bézier configuration can take only two control points. As you can see in
    this marked-up screenshot, where each white and red square represents a control
    point, you can make only a U-shaped parabola with a single Bézier configuration.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法创建了三个贝塞尔配置，并将它们附加到一个带有贝塞尔配置的 `MoveTo` 命令。这样做的原因是每个贝塞尔配置只能接受两个控制点。正如你在标记的截图中所见，每个白色和红色方块代表一个控制点，你只能使用单个贝塞尔配置制作
    U 形抛物线。
- en: Thus, to make three U-shapes, you need three Bézier configurations.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要制作三个 U 形，你需要三个贝塞尔配置。
- en: '![Curved M-shape](img/image00252.jpeg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![曲线 M 形状](img/image00252.jpeg)'
- en: 'Finally, make sure that in the `touchBegan` method, you make the `unitBezier`
    stop all its actions (that is, stop on reset):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，确保在 `touchBegan` 方法中，使 `unitBezier` 停止所有动作（即，在重置时停止）：
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: And that's it! When you run the project and tap on the screen (or tap and hold),
    you'll see the blue square M-shape its way across, followed by the yellow square
    in its squiggly M-shape.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！当你运行项目并点击屏幕（或点击并保持）时，你会看到蓝色正方形的 M 形状穿过，随后是黄色正方形的波浪形 M 形状。
- en: Tip
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you want to adapt the Bézier `MoveTo` or `MoveBy` actions for your own project,
    you should know that you can create only one U-shape with each Bézier configuration.
    They're fairly easy to implement and can quickly be copied and pasted, as shown
    in the `sendSecondUnit` function.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将贝塞尔 `MoveTo` 或 `MoveBy` 动作适应到你的项目中，你应该知道你可以使用每个贝塞尔配置创建一个 U 形。它们相当容易实现，并且可以快速复制粘贴，如
    `sendSecondUnit` 函数所示。
- en: Plus, as the control points and end position are just `CGPoint` values, they
    can be relative (that is, relative to the unit's current position, the world's
    position, or an enemy's position), and as a regular `CCAction`, they can be run
    with any `CCNode` object quite easily.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于控制点和终点位置只是 `CGPoint` 值，它们可以是相对的（即，相对于单元的当前位置、世界位置或敌人的位置），并且作为一个常规的 `CCAction`，它们可以很容易地与任何
    `CCNode` 对象一起运行。
- en: Depth perception via device tilting
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过设备倾斜实现深度感知
- en: Something that can increase the cool factor of your game without really changing
    the game is a depth-perception-like feel when the user tilts the device. This
    can be seen in games such as *Shadowmatic* and *Jump! Chump!*, the checklist *Wunderlist*,
    or a lock screen background image with **Perspective Zoom** set to **On**. Although
    it's subtle, it can make your game feel a lot more polished and increase user
    engagement, as it's just one more thing they'll find cool or interesting about
    the game.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可以在不真正改变游戏的情况下提高游戏酷炫程度的方法是，当用户倾斜设备时产生一种深度感知的感觉。这在 *Shadowmatic* 和 *Jump! Chump!*
    游戏中、*Wunderlist* 清单中，或者将 **Perspective Zoom** 设置为 **开启** 的锁屏背景图片中都可以看到。虽然这很微妙，但它可以使你的游戏感觉更加精致，并增加用户参与度，因为它只是他们发现游戏酷或有趣的一个额外因素。
- en: Tip
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: As a reminder, you cannot make use of device tilting/accelerometer in the simulator.
    It must be done on a physical device.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，你无法在模拟器中使用设备的倾斜/加速度计。这必须在物理设备上完成。
- en: Here is *Shadowmatic* game's tilt effect seen on the menu. As you can see, it's
    a three-dimensional object, and the camera rotates around the object, as well
    as the shadows.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是菜单上看到的 *Shadowmatic* 游戏倾斜效果。正如你所见，它是一个三维物体，相机围绕物体旋转，以及阴影。
- en: 'The first one is as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个如下所示：
- en: '![Depth perception via device tilting](img/image00253.jpeg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![通过设备倾斜实现深度感知](img/image00253.jpeg)'
- en: 'The second one is as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个如下所示：
- en: '![Depth perception via device tilting](img/image00254.jpeg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![通过设备倾斜实现深度感知](img/image00254.jpeg)'
- en: The following is *Jump! Chump!* game's tilt effect seen in the game, where you
    can see the shadows of the main characters and enemies being shifted.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 *Jump! Chump!* 游戏中看到的倾斜效果，你可以看到主要角色和敌人的影子被移动。
- en: 'The first one is as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个如下所示：
- en: '![Depth perception via device tilting](img/image00255.jpeg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![通过设备倾斜实现深度感知](img/image00255.jpeg)'
- en: 'The second one is as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个如下所示：
- en: '![Depth perception via device tilting](img/image00256.jpeg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![通过设备倾斜实现深度感知](img/image00256.jpeg)'
- en: Isn't this parallax scrolling?
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这不是视差滚动吗？
- en: This is similar, but slightly different from parallax scrolling. Parallax scrolling—if
    you're unfamiliar—is when there are multiple background layers and each moves
    across the screen at a different rate to create the feeling of a more realistic
    movement. Cocos2d even has something called `CCParallaxNode`, which basically
    allows different relative movement speeds among the node's children. As an example,
    suppose you add a background image, a middle-ground image, and a foreground image
    with different ratios. When you move the `CCParallaxNode` object, it will automatically
    move the children as per the ratio set by each individual child.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前类似，但略有不同。视差滚动——如果你不熟悉的话——是指有多个背景层，每个层以不同的速度在屏幕上移动，从而产生更真实运动的感觉。Cocos2d 还有一个叫做
    `CCParallaxNode` 的功能，它基本上允许节点子代之间有不同的相对移动速度。例如，假设你添加了一个背景图像、一个中间图像和一个前景图像，它们有不同的比例。当你移动
    `CCParallaxNode` 对象时，它将自动根据每个子代设置的比率移动子代。
- en: Parallax scrolling is similar because there will still be multiple layers moving
    around, and they will be moving slightly in one direction or another based on
    the tilt of the device. Thus, the user feels as if there are objects (buttons,
    for example) that are literally in front of others (the grass in the background,
    for example).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 视差滚动类似，因为仍然会有多个层在移动，并且它们将根据设备的倾斜在某个方向上稍微移动。因此，用户会感觉到有物体（例如按钮）实际上在其他物体（例如背景中的草地）之前。
- en: Let's begin implementing some simple depth perception effects.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始实现一些简单的深度感知效果。
- en: Sample project – depth
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例项目 – 深度
- en: Download the `Depth` sample project from the code repository and run the project.
    You'll notice there are some background mountains, grass, and a few buttons that
    don't go anywhere. We're going to change this so that the buttons move around
    the screen to give a bit of depth.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码仓库下载 `Depth` 示例项目并运行项目。你会注意到有一些背景山脉、草地和几个按钮，它们并没有指向任何地方。我们将改变这一点，让按钮在屏幕周围移动，以增加一些深度感。
- en: Creating the parallax node and adding the objects
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建视差节点并添加对象
- en: 'In `MainScene.h`, add the the variables listed here, as well as import the
    CoreMotion framework:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MainScene.h` 文件中，添加此处列出的变量，并导入 CoreMotion 框架：
- en: '[PRE30]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `CCParallaxNode` is obvious. The `motionManager` is meant for tracking the
    accelerometer data, and `xFiltered` and `yFiltered` are going to be used as filters
    for the accelerometer so that it doesn't become too jittery.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`CCParallaxNode` 很明显。`motionManager` 用于跟踪加速度计数据，而 `xFiltered` 和 `yFiltered`
    将用作加速度计的过滤器，以防止它变得过于抖动。'
- en: 'Now, in the init method of `MainScene.m`, comment out the line that adds the
    `layoutbox` to the scene. Add the code that initializes the parallax node, adds
    the `layoutbox` to it, and adds the parallax node to the scene:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `MainScene.m` 的 `init` 方法中，注释掉添加 `layoutbox` 到场景的行。添加初始化视差节点、将 `layoutbox`
    添加到其中以及将视差节点添加到场景中的代码：
- en: '[PRE31]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If you''re wondering what the ratio parameter is, it''s like what the comment
    says: for every one pixel that the parallax object is moved, it will move the
    child by that amount. For example, if the parallax node was moved 100 pixels to
    the left, and if the child has a ratio of 0.5, the child will move to the left
    by 50 pixels. Does this make sense? So, for our buttons, we want the ratio to
    be 1:1\. This means that, for every pixel the parallax node moves, the buttons
    will move by the same amount.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道比例参数是什么，它就像注释中说的那样：对于每个移动的视差对象像素，它将移动子代相同数量的像素。例如，如果视差节点向左移动了100像素，并且如果子代的比例为0.5，子代将向左移动50像素。这说得通吗？所以，对于我们的按钮，我们希望比例是1:1。这意味着，对于每个视差节点移动的像素，按钮将以相同的数量移动。
- en: Running the project now won't do anything, however, so let's get the accelerometer
    data going so that we can shift the menu buttons by tilting the device.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行项目并不会做任何事情，但是，让我们开始获取加速度计数据，这样我们就可以通过倾斜设备来切换菜单按钮。
- en: Visualizing the depth
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可视化深度
- en: 'In the init method of `MainScene.m`, add the following block of code, which
    will set up the motion manager so that it can start collecting accelerometer data:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainScene.m`的`init`方法中，添加以下代码块，这将设置运动管理器以便开始收集加速度计数据：
- en: '[PRE32]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'For the accelerometer to affect the parallax node''s position, we must create
    the `getAccelerometerData` method, and modify the position there:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让加速度计影响视差节点的位置，我们必须创建`getAccelerometerData`方法，并在那里修改位置：
- en: '[PRE33]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This method basically reads the accelerometer's data 60 times per second, sends
    it through a filter (if you want steadier movement, increase the K value, which
    we called `filterValue` in the preceding code, up to a maximum of 1), and assigns
    the parallax's position based on the filtered *x* and *y* values.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法基本上每秒读取60次加速度计数据，将其通过一个过滤器（如果你想更平稳的运动，增加K值，我们在前面的代码中将其称为`filterValue`，最大值为1），并根据过滤后的*x*和*y*值分配视差的位置。
- en: Tip
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If this is the entirety of the effect you want in your own project, feel free
    to stop here. The key thing to note if you're using this in your own project is
    the fact that the parallax node affects every child's position based on the ratio
    it was given. Plus, if you're using the tilt mechanic, make sure you put a filter
    on the accelerometer data, or else it will be very jittery and actually hurt your
    game instead of helping it.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是你自己在项目中想要实现的所有效果，那么请在这里停止。如果你在自己的项目中使用这个功能，需要注意的关键点是视差节点根据给定的比例影响每个子节点的位置。此外，如果你使用倾斜机制，确保对加速度计数据进行过滤，否则它将会非常抖动，实际上会损害你的游戏而不是帮助它。
- en: Next, we're going to equalize the parallax node so that the buttons aren't always
    being pushed up or off to the side.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将平衡视差节点，这样按钮就不会总是被推上去或偏到一边。
- en: Restoring equilibrium (calibrating to the new rotation)
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 恢复平衡（校准到新的旋转）
- en: After the user adjusts their phone to a new position, you would want to slowly
    bring their equilibrium to the way they're holding the device. For example, if
    they start with the device flat on a table, and then tilt it towards themselves
    by about 45 degrees, you will shift the items as necessary. You'll then need to
    slowly make the 45-degree position look the same as it did when it was flat.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户调整他们的手机到新的位置后，你希望慢慢地将他们的平衡调整到他们持握设备的方式。例如，如果他们开始时将设备平放在桌子上，然后倾斜它大约45度朝向自己，你需要相应地移动项目。然后你需要慢慢地使45度的位置看起来与它平放时一样。
- en: 'This is easy to do, as long as we have a variable to hold what the equilibrium
    is. To do so, open `MainScene.h` and add the following code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易做到，只要我们有一个变量来保存平衡值。要做到这一点，打开`MainScene.h`并添加以下代码：
- en: '[PRE34]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: These two values will store the average of the last 100 `xFiltered` and `yFiltered`
    values recorded.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个值将存储最后记录的100个`xFiltered`和`yFiltered`值的平均值。
- en: 'Then in `MainScene.m`, modify the three relevant lines in your `getAccelerometerData`
    method to look like what you see here:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在`MainScene.m`中，修改`getAccelerometerData`方法中的三个相关行，使其看起来像这里所示：
- en: '[PRE35]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: At first, the math probably makes no sense, so let's go over it.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，数学可能没有意义，让我们来了解一下。
- en: First, `avgXValue` and `avgYValue` calculate the average by slowly adding one
    point at a time to the average in an estimation sort of way. This is not 100 percent
    accurate in the true "average" sense, but it comes close enough. It's also slightly
    better to do it this way as it means less code, less memory, and faster execution.
    Since we're doing this 60 times per second, it's not entirely important to get
    an accurate average. Within a few seconds, you'll have hundreds of points that
    will get you close enough.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`avgXValue`和`avgYValue`通过逐个点缓慢地添加到平均值中，以估计的方式计算平均值。这并不是在真正的“平均值”意义上的100%准确，但它足够接近。这样做也稍微好一些，因为它意味着更少的代码、更少的内存和更快的执行速度。由于我们每秒做60次这样的操作，因此获得一个准确的平均值并不完全重要。几秒钟内，你将获得足够多的点，足以接近真实值。
- en: Second, the subtraction of `xFiltered`/`xFiltered` and `avgYValue`/`avgXValue`
    is done to slowly bring it back to the center. For example, if your `yFiltered`
    value is `-1`, and `avgYValue` is `0`, it will quickly jump down to its new position.
    But if the device is held at `-1` for long enough, `avgYValue` will come so close
    to `-1` that subtracting the two variables will yield a zeroed-out position, which
    is exactly what we want.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，`xFiltered`/`xFiltered`和`avgYValue`/`avgXValue`的减法是为了慢慢将其带回中心。例如，如果你的`yFiltered`值是`-1`，而`avgYValue`是`0`，它将迅速跳到新的位置。但如果设备在`-1`处保持足够长的时间，`avgYValue`将非常接近`-1`，减去这两个变量将得到一个归零的位置，这正是我们想要的。
- en: Tip
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The key thing to note here if you are implementing the calibration effect into
    your own project is to subtract the two values. Whether you use a single-value
    calibration or a pseudo-average value (like what was used here), if you don't
    subtract the filtered *x* and *y* values, you won't see any change.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在自己的项目中实现校准效果，这里需要注意的关键是减去两个值。无论你使用单值校准还是伪平均值（就像这里使用的），如果你不减去过滤后的*x*和*y*值，你将看不到任何变化。
- en: For slow calibration, the preceding method is the way to go. If you want instant
    calibration (for example, with a button that realigns when the user says so),
    simply store the single accelerometer value when the button is pressed rather
    than store the average value.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 对于慢速校准，前面提到的方法是可行的。如果你想实现即时校准（例如，当用户说的时候通过按钮重新对齐），只需在按钮按下时存储单个加速度计值，而不是存储平均值。
- en: A quick scrolling example
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个快速滚动的示例
- en: 'Since we''re covering the topic of parallax scrolling, let''s quickly go over
    a simple example of parallax scrolling as it was intended. In `MainScene.m` (or
    the header; it doesn''t really matter), import the `GameScene.h` file:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在讨论视差滚动，让我们快速回顾一下视差滚动的简单示例，正如它被设计的那样。在`MainScene.m`（或头文件；实际上并不重要），导入`GameScene.h`文件：
- en: '[PRE36]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, in the `buttonPressed` method, add the following line of code. It will
    go to the game scene:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`buttonPressed`方法中，添加以下代码行。它将进入游戏场景：
- en: '[PRE37]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now let''s add the `CCParallaxNode` to `GameScene.h`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将`CCParallaxNode`添加到`GameScene.h`中：
- en: '[PRE38]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, in the `GameScene.m` file''s `init` method, set up the parallax node
    and add a few sprites to the node:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`GameScene.m`文件的`init`方法中，设置视差节点并添加一些精灵到节点中：
- en: '[PRE39]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Just in case you're wondering what `positionOffset` does, it moves the node
    to the position given as a parameter before any parallax ratios get applied. This
    is useful when first setting up your scene (just as we're doing here).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在想`positionOffset`的作用，它会在应用任何视差比例之前将节点移动到作为参数给出的位置。这在首次设置场景时很有用（就像我们现在正在做的那样）。
- en: 'Then, we want to enable touching, so we add this line to the `init` method:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们想要启用触摸，所以我们向`init`方法中添加这一行：
- en: '[PRE40]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'But first, we need to create a variable to hold the previous position the finger
    was at so that we know how far to move the parallax node. Therefore, in `GameScene.h`,
    add the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，我们需要创建一个变量来保存手指之前的位置，这样我们才知道要移动视差节点多远。因此，在`GameScene.h`中添加以下内容：
- en: '[PRE41]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, add the `touchBegan` and `touchMoved` methods so that the parallax
    node moves according to the `touchMoved` distance, while also making sure that
    the scrolling never goes beyond the bounds:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加`touchBegan`和`touchMoved`方法，以便视差节点根据`touchMoved`的距离移动，同时确保滚动永远不会超出边界：
- en: '[PRE42]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: From here onwards, you can run the project, and when you click on **Play**,
    you'll be taken to the game scene, which now has a (rather crude) set of background,
    middle-ground, and foreground elements. When you drag your finger across the screen,
    you'll notice the grass scrolling at the same speed while the mountains, trees,
    and sun all scroll at different speeds.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，你可以运行项目，当你点击**播放**时，你将被带到游戏场景，现在它有一个（相当粗糙的）背景、中景和前景元素集合。当你用手指在屏幕上滑动时，你会注意到草地以相同的速度滚动，而山脉、树木和太阳则以不同的速度滚动。
- en: Tip
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you're implementing a parallax scrolling background in your own project,
    the key thing to note is the difference in ratios between the added objects. Once
    you have that squared away, all you have to do is move the parallax node with
    respect to a finger dragging, a character moving, or whatever.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在自己的项目中实现视差滚动背景，需要注意添加对象之间的比例差异。一旦这个问题解决，你只需要根据手指拖动、角色移动或其他操作移动视差节点。
- en: Three ways to make unit streamers or "ghosts"
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作单元流线或“幽灵”的三种方法
- en: If you've ever played games such as *Fruit Ninja*, *Blek*, *Jetpack Joyride*,
    or *Tiny Wings*, you've surely seen this effect. There's a position on the screen
    that generates something similar to stars, a slashing effect, smoke clouds, or
    a line following the finger.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经玩过像 *Fruit Ninja*、*Blek*、*Jetpack Joyride* 或 *Tiny Wings* 这样的游戏，你肯定见过这种效果。屏幕上有一个位置会生成类似星星、划痕效果、烟雾云或跟随手指的线条。
- en: Sample project – ghosts
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 样本项目 – 鬼魂
- en: Go to the code repository and open the `Ghosts` project under the `Sample Projects`
    folder. If you run it, you will see just three labels as buttons that lead to
    mostly blank screens that don't really do anything. That's where you come in.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 前往代码仓库，在 `Sample Projects` 文件夹下打开 `Ghosts` 项目。如果你运行它，你会看到只有三个作为按钮的标签，它们引导到主要是空白的屏幕，实际上并没有做什么。这就是你发挥作用的地方。
- en: Here, you're going to learn how to make the effects that you just read. There
    are three general ways to go about making something like this. Let's go over each
    method, starting with the easiest and ending with the hardest.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将学习如何制作你刚刚阅读的效果。制作类似效果通常有三种方法。让我们逐一介绍每种方法，从最简单的开始，到最复杂的结束。
- en: Method 1 – particle systems
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法 1 – 粒子系统
- en: Particle systems are basically sprites that are created en masse, such as a
    firework effect, a gushing water fountain, or a flickering candle. The difference
    between using a particle system and creating the sprites yourself is that particle
    systems generally allow only moving, scaling, rotation, and color changes. But
    for simple effects such as a smoke cloud, a particle system works just fine.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子系统基本上是大量创建的精灵，例如烟花效果、喷泉或闪烁的蜡烛。使用粒子系统与你自己创建精灵之间的区别在于，粒子系统通常只允许移动、缩放、旋转和颜色变化。但对于像烟雾云这样的简单效果，粒子系统就足够了。
- en: Tip
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you wish to create your own particles for this sample project or any project
    of your own, as mentioned in [Chapter 1](part0014.xhtml "Chapter 1. Refreshing
    Your Cocos2d Knowledge"), *Refreshing Your Cocos2d Knowledge*, Particle Designer
    is a great tool for this purpose. You can manually create them in the code, but
    it's a lot easier and more efficient to create them visually using an editor such
    as Particle Designer.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望为这个样例项目或你自己的任何项目创建自己的粒子，如[第1章](part0014.xhtml "第1章. 刷新你的 Cocos2d 知识")中提到的，*刷新你的
    Cocos2d 知识*，粒子设计师是这个目的的绝佳工具。你可以在代码中手动创建它们，但使用像粒子设计师这样的编辑器可视化创建它们要容易得多，也更高效。
- en: 'With the `Ghosts` project opened in Xcode, open the `ParticleExampleScene.h`
    file and add a `CCParticleSystem` variable to the list:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xcode 中打开 `Ghosts` 项目，打开 `ParticleExampleScene.h` 文件，并将 `CCParticleSystem`
    变量添加到列表中：
- en: '[PRE43]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then open `ParticleExampleScene.m` and add the particle system to the screen
    in the init method:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 然后打开 `ParticleExampleScene.m` 文件，并在 init 方法中将粒子系统添加到屏幕上：
- en: '[PRE44]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The particle system used in the preceding code was created using Particle Designer,
    as mentioned at the beginning of this book. It uses a simple cloud-shaped image
    and has certain properties set to create the effect of fading out.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码中使用的粒子系统是在本书开头提到的粒子设计师中创建的。它使用一个简单的云形状图像，并设置了某些属性以创建淡出效果。
- en: 'Finally, in the `updateParticleSource` method, set the particle system''s source
    position so that as you drag your finger around the screen, the smoke starts in
    a different position:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 `updateParticleSource` 方法中，设置粒子系统的源位置，这样当你用手指在屏幕上拖动时，烟雾会从不同的位置开始：
- en: '[PRE45]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If you run the project at this point, you'll see that the smoke is constantly
    being generated, even after you take your finger off the screen. Although this
    doesn't mean much for this sample project, imagine you want a particle being displayed
    only if a user is in midair, or while a combo move is being performed. That being
    said, we need a way to stop and start the particle streaming on demand (in this
    case, when the user places or removes their finger).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行项目，你会看到烟雾会不断生成，即使你移开了手指。虽然这对这个样例项目来说意义不大，但想象一下，你可能只想在用户处于空中或执行连击动作时显示粒子。换句话说，我们需要一种方法来根据需要停止和启动粒子流（在这种情况下，当用户放置或移除手指时）。
- en: 'Although Cocos2d does not have a method to begin a particle system, it''s very
    easy to add such a method. So, look up the project for `stopSystem`. In the `CCParticleSystemBase.h`
    file (which should be the first result in the search), add the following code
    above the `stopSystem` declaration:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Cocos2d没有开始粒子系统的方法，但添加这样的方法非常简单。所以，查找 `stopSystem` 的项目。在 `CCParticleSystemBase.h`
    文件（应该是搜索结果中的第一个）中，在 `stopSystem` 声明之上添加以下代码：
- en: '[PRE46]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then, in the `CCParticleSystemBase.m` file (the next result in the search),
    add this method so that you can start the particle system on demand:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `CCParticleSystemBase.m` 文件（搜索结果中的下一个）中添加此方法，以便你可以按需启动粒子系统：
- en: '[PRE47]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now go back to `ParticleExampleScene.m`, and in the `init` method, right after
    you''ve added the smoke particle to the scene, call the `stopSystem` method so
    that it''s not on the screen when the scene first starts:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到 `ParticleExampleScene.m` 文件，在 `init` 方法中，在你将烟雾粒子添加到场景之后，调用 `stopSystem`
    方法，这样当场景首次启动时，它就不会出现在屏幕上了：
- en: '[PRE48]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Add the `stopSystem` method to the `touchEnded` method so that the particle
    system stops spawning new particles and lets the old particles die out:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `stopSystem` 方法添加到 `touchEnded` 方法中，以便粒子系统停止产生新的粒子，并让旧的粒子消亡：
- en: '[PRE49]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, add a method call to the newly created `startSystem` method in the
    `touchBegan` method so that the particles begin streaming when a finger is on
    the screen:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 `touchBegan` 方法中调用新创建的 `startSystem` 方法，以便当手指在屏幕上时，粒子开始流动：
- en: '[PRE50]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Running the project at this point will allow you to see the starting and stopping
    of a particle system that has already been created.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段运行项目将允许你看到已经创建的粒子系统的启动和停止。
- en: Tip
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You may be wondering how to adapt this for your own project. Once you have the
    particle system added to the screen, it's basically just a matter of updating
    the particle system's source position with the "start position." For example,
    you could have a rocket flying across the screen, and the rocket's position could
    be the start position.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道如何将此代码适应到自己的项目中。一旦粒子系统被添加到屏幕上，基本上就是一个更新粒子系统源位置的问题，使用“起始位置”。例如，你可以有一个火箭在屏幕上飞行，火箭的位置就是起始位置。
- en: Now let's move on to a very similar-looking style that takes a little more code,
    but allows greater manipulation with the overall look of the game.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续到一个外观非常相似但需要更多代码的风格，这允许对游戏的整体外观进行更大的操作。
- en: Method 2 – sprites or nodes
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法 2 – 精灵或节点
- en: Although a particle system requires less code to get a similar effect, there
    are more things you can do when you create the sprite yourself and handle everything
    that happens to it. For example, you can make the sprite change color several
    times, set up crazy movement patterns, change images altogether, or apply other
    `CCAction` actions that the particle system can't do.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然创建粒子系统需要的代码较少，但当你自己创建精灵并处理其所有事件时，你可以做更多的事情。例如，你可以让精灵改变颜色几次，设置疯狂的运动模式，完全更换图像，或者应用粒子系统无法做到的其他
    `CCAction` 动作。
- en: Tip
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: One example of something that a particle system can't do is shake mechanics.
    A simple way you can do this is by queuing up a sequence of `CCMove` actions to
    go in the various directions you want (generally, no more than a few points in
    any direction), and using a variable for the duration so that you can increase
    or decrease the speed based on the situation.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子系统无法做到的一件事是震动机制。你可以通过排队一系列 `CCMove` 动作来实现这一点，这些动作将按照你想要的方向进行（通常，任何方向不超过几个点），并使用一个变量来设置持续时间，这样你就可以根据情况增加或减少速度。
- en: 'With the `Ghosts` project opened in Xcode, open the `SpriteExampleScene.m`
    file and add the following block of code to the `spawnStreamer` method:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xcode 中打开 `Ghosts` 项目后，打开 `SpriteExampleScene.m` 文件，并将以下代码块添加到 `spawnStreamer`
    方法中：
- en: '[PRE51]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This code will spawn a red heart (the image is white, but we've colored it red),
    shrink it down to a scale of `0` in half a second, and then remove it from the
    scene so that it doesn't create lag after running for a while.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将产生一个红色的心形（图像是白色的，但我们将其染成了红色），在半秒内将其缩小到 `0` 的比例，然后将其从场景中移除，这样在运行一段时间后就不会产生延迟。
- en: If you run the project and drag you finger around the screen, you'll see some
    beautiful hearts being created in a fluid manner. And that's it! The only reason
    it was mentioned that you'd probably have to use more code is that, the more you
    want to do with your streamer (ghost, phantom, or whatever), the more code it
    will take to get the effect you want.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行项目并在屏幕上拖动手指，你会看到一些美丽的心形以流畅的方式被创建出来。就这样！之所以提到你可能需要使用更多的代码，是因为你想要在流线（鬼魂、幻影或
    whatever）上做更多的事情，那么你需要更多的代码来实现你想要的效果。
- en: 'So say, for example, you want to make the sprites move along a Bézier curve,
    spin 360 degrees, and finally shrink down and disappear, while at the same time
    changing to a green heart. The code will look something like this:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想使精灵沿着贝塞尔曲线移动，旋转 360 度，然后缩小并消失，同时变成绿色心形。代码看起来可能像这样：
- en: '[PRE52]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Tip
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you wish to implement something like this within your own project, the key
    requirement is the `isStreaming` Boolean and the check within the update method.
    Everything else is straightforward and very similar to the particle method of
    changing the `startPosition`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望在项目中实现类似的功能，关键要求是 `isStreaming` 布尔值和在更新方法中的检查。其他一切都是直截了当且非常类似于改变 `startPosition`
    的粒子方法。
- en: Finally, let's tackle the most unique method of all—the constant line that both
    *Fruit Ninja* and *Blek* have implemented.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们来处理所有方法中最独特的方法——即 *Fruit Ninja* 和 *Blek* 都实现过的恒定线条。
- en: Method 3 – constant line
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法 3 – 恒定线条
- en: Constant line is the most advanced version of streamers. It's not really a particle,
    and therefore, it can't be made as a sprite creation either. Instead, we're going
    to use `CCMotionStreak` to create a slashing effect. `CCMotionStreak` is fairy
    simple to implement, as it only needs a position, an image, and a color.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 恒定线条是流线最先进的版本。它实际上不是一个粒子，因此不能作为精灵创建。相反，我们将使用 `CCMotionStreak` 来创建划痕效果。`CCMotionStreak`
    的实现非常简单，因为它只需要一个位置、一个图像和一个颜色。
- en: 'With the `Ghosts` project opened in Xcode, open `ConstantLineExampleScene.h`
    and add a `CCMotionStreak` object to the list:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xcode 中打开 `Ghosts` 项目，打开 `ConstantLineExampleScene.h` 并将一个 `CCMotionStreak`
    对象添加到列表中：
- en: '[PRE53]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then, in `ConstantLineExampleScene.m`, create the streak and add it to the
    scene in the `init` method:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `ConstantLineExampleScene.m` 中，创建轨迹并将其添加到场景的 `init` 方法中：
- en: '[PRE54]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Here we're using the yellow color and the file named `blade.png`. You can use
    whichever image you want, but since we want a blade slashing effect, we're going
    to use the image that is shaped like a diamond to give the beginning and end a
    pointed edge.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用黄色颜色和名为 `blade.png` 的文件。你可以使用任何你想要的图像，但因为我们想要一个刀片划痕效果，我们将使用形状像钻石的图像，以给开始和结束部分一个尖锐的边缘。
- en: 'Next, in the `touchBegan` method, set the `CCMotionStreak` object''s position,
    and reset it so that when the users touch down again, it doesn''t connect the
    two lines (unless that''s what you want; in that case, you should not reset it):'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `touchBegan` 方法中，设置 `CCMotionStreak` 对象的位置，并重置它，以便当用户再次触摸时，它不会连接两条线（除非你想要这样做；在这种情况下，你不应该重置它）：
- en: '[PRE55]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Finally, in the `touchMoved` method, set the position so that every time the
    finger is dragged, the motion streak glides to the next position:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 `touchMoved` 方法中，设置位置，以便每次手指拖动时，动作轨迹滑动到下一个位置：
- en: '[PRE56]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: And that's it! If you run the project, go to the line example, and drag a finger
    around, you'll see the nice slashing effect. If you want to make the line bigger
    (or smaller), simply adjust the width in the initialization of `CCMotionStreak`.
    The same applies to the color, image, or even duration. However, it's not recommended
    to set the duration too high, as the motion streak might be a bit delayed.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！如果你运行项目，转到示例行，并拖动手指，你会看到漂亮的划痕效果。如果你想使线条更大（或更小），只需调整 `CCMotionStreak` 初始化中的宽度。同样适用于颜色、图像，甚至是持续时间。然而，不建议将持续时间设置得太高，因为动作轨迹可能会有些延迟。
- en: Tip
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'The key point to remember if you want to implement this style of streamer/ghost
    in your project is that `CCMotionStreak` relies on a position of something. So,
    if you want a streak on a spaceship, you have to update the motion streak''s position
    in the update function, like this:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在你的项目中实现这种风格的流线/鬼魂，关键点是 `CCMotionStreak` 依赖于某个位置。因此，如果你想在一个太空船上有一个轨迹，你必须在更新函数中更新动作轨迹的位置，如下所示：
- en: '[PRE57]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Touchscreen controls versus D-pad adaptation (and why it matters so much to
    know this distinction)
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 触摸屏控制与 D-pad 适配（以及为什么了解这种区别如此重要）
- en: Because we're coding for iOS, it's important to note the uniqueness of the device
    we're creating games for, that is, the touchscreen itself versus a plastic controller
    with joysticks and triggers that the user has in their hands. When creating games
    for iOS (or any smartphone device with a touchscreen), you must create the controls
    such that they feel natural and fluid on the device, as if the game never existed
    on another console.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们是为iOS编码，因此需要注意我们为游戏创建的设备的独特性，即触摸屏本身与用户手中拥有的带有摇杆和扳机的塑料控制器之间的区别。当为iOS（或任何带有触摸屏的智能手机设备）创建游戏时，你必须创建的控制方式要使它们在设备上感觉自然流畅，就像游戏从未在其他游戏机上存在过一样。
- en: Granted, it's understandable that some games are better suited for D-pad-style
    movement. However, there's always the accelerometer, swipe controls, or the way
    that Infinity Blade does it (using small buttons on the screen to block or dodge,
    and also using swipes across the center of the screen to attack with your sword).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，可以理解有些游戏更适合D-pad风格的移动。然而，始终有加速度计、滑动控制，或者像《无尽之刃》那样（使用屏幕上的小按钮来阻挡或躲避，并使用屏幕中央的滑动来挥剑攻击）。
- en: Unfortunately, there's no "how to program" section for the best controls, as
    it's all based on your individual game. For example, in this book's game, we don't
    tap a unit and then use a D-pad to tell the game which direction to send the unit
    in. Instead, we make use of the touch-and-drag feature of iOS and integrate that
    as part of our controls.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，没有“如何编程”部分专门介绍最佳控制方式，因为一切都基于你自己的游戏。例如，在这本书的游戏中，我们不是点击一个单位然后使用D-pad告诉游戏将单位发送到哪个方向。相反，我们利用iOS的触摸和拖动功能，并将其集成到我们的控制方式中。
- en: There are more good examples of touch-integrated controls later in this chapter,
    but first, let's go over what not to do.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 本章后面还有更多关于触摸集成控制的优秀例子，但首先，让我们来看看哪些是不应该做的。
- en: Bad examples of iOS game controls
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: iOS游戏控制的不良示例
- en: The following are some examples of some games that just basically took the controls
    they had on their console or PC version of the game and dumped them into the touchscreen,
    hoping it would work out for them.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些游戏示例，它们只是简单地将它们在游戏机或PC版本上的控制方式直接应用到触摸屏上，希望这样能奏效。
- en: '*Game Dev Story*: Although this is not a bad game on its own, the controls
    are completely menu driven and don''t feel as if they were created with a mobile
    in mind.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '*《游戏开发故事》*：虽然这款游戏本身并不差，但控制方式完全是菜单驱动的，感觉就像它们不是为移动设备设计的。'
- en: '![Bad examples of iOS game controls](img/image00257.jpeg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![iOS游戏控制的不良示例](img/image00257.jpeg)'
- en: '*Tomb Raider I*: Just based on the screenshots, it''s easy to see how complex
    the controls are and how little time the developers put into innovating their
    control scheme for the mobile platform.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '*《古墓丽影 I》*：仅从截图来看，就能轻易看出控制方式的复杂性以及开发者投入在为移动平台创新控制方案上的时间之少。'
- en: '![Bad examples of iOS game controls](img/image00258.jpeg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![iOS游戏控制的不良示例](img/image00258.jpeg)'
- en: '*Duke Nukem 3D*: Again, just based on the following screenshot, you can understand
    what bad controls are being pointed out here:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '*《杜克·努克3D》*：同样，仅从下面的截图来看，你就能理解这里所指出的糟糕控制方式：'
- en: '![Bad examples of iOS game controls](img/image00259.jpeg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![iOS游戏控制的不良示例](img/image00259.jpeg)'
- en: '*Midway Arcade*: They could''ve done so much better when it comes to cycling
    through the mini-games and even the mini-games themselves. Some of the games feel
    mobile friendly, but the rest are just not pulling their weight.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '*《中土世界街机》*：在循环迷你游戏甚至迷你游戏本身方面，它们本可以做得更好。有些游戏感觉适合移动设备，但其余的则没有发挥出应有的作用。'
- en: '![Bad examples of iOS game controls](img/image00260.jpeg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![iOS游戏控制的不良示例](img/image00260.jpeg)'
- en: Great examples of touchscreen controls
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 触摸屏控制的好例子
- en: In this section, you'll find some games that, whether they started on console
    before or not, have some great controls on mobile. They exhibit everything beautiful
    about being able to code games for a handheld device with a touchscreen and an
    accelerometer.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你会发现一些游戏，无论它们是否在游戏机上开始，在移动设备上都有很好的控制方式。它们展示了为带有触摸屏和加速度计的手持设备编写游戏的所有美好之处。
- en: First up is *Shadowmatic*; you drag the screen to rotate the objects, and tilting
    the device moves the camera so slightly that you really get a three-dimension-like
    feeling in this game.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是 *Shadowmatic*；你拖动屏幕来旋转物体，倾斜设备会让摄像头轻微移动，让你在这款游戏中真正体验到三维的感觉。
- en: '![Great examples of touchscreen controls](img/image00261.jpeg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![触摸屏控制的好例子](img/image00261.jpeg)'
- en: Next is *Smash Hit*; not only does it spawn the metal balls where your finger
    touches but also the easy-to-press buttons cause no disruptions to the gameplay
    either.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是*Smash Hit*；它不仅会在你的手指触摸的地方产生金属球，而且易于按下的按钮也不会打断游戏进程。
- en: '![Great examples of touchscreen controls](img/image00262.jpeg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![出色的触摸屏控制示例](img/image00262.jpeg)'
- en: I can't forget *Angry Birds*, with its pinch-zoom, pullback mechanics, and easy-to-understand
    gameplay, all of which stem from great touchscreen controls.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我不能忘记*Angry Birds*，它具有缩放手势、拉回机制和易于理解的游戏玩法，所有这些都源于出色的触摸屏控制。
- en: '![Great examples of touchscreen controls](img/image00263.jpeg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![出色的触摸屏控制示例](img/image00263.jpeg)'
- en: There's also *Temple Run*, integrating the swiping mechanics in every direction,
    making the user feel as if they're actually pushing their character in the particular
    direction.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 还有*Temple Run*，它将滑动机制整合到每个方向，使用户感觉就像实际上在推动他们的角色向特定方向前进。
- en: '![Great examples of touchscreen controls](img/image00264.jpeg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![出色的触摸屏控制示例](img/image00264.jpeg)'
- en: Last but not least (as there are surely a lot more that also have great touchscreen
    controls) is *Blek*. I'm not even sure whether this game could exist outside a
    touchscreen environment because it's just so fluid!
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是（因为肯定还有更多拥有出色触摸屏控制功能的设备），是*Blek*。我甚至不确定这款游戏是否能在非触摸屏环境中存在，因为它真是太流畅了！
- en: '![Great examples of touchscreen controls](img/image00265.jpeg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![出色的触摸屏控制示例](img/image00265.jpeg)'
- en: Summary
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to do a variety of things, from making a score
    table and previewing the next move, to making use of Bézier curves and creating
    unit streamers.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了如何做各种事情，从制作得分表和预览下一步操作，到利用贝塞尔曲线和创建单位流线。
- en: Remember, if you ever need to come back to this chapter (or any other for that
    matter), don't hesitate to do so. The code was built with a copy-paste mindset,
    so it can be adapted for any project without much reworking (if it is required
    at all).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果你需要回到这一章节（或者任何其他章节），请不要犹豫。代码是按照复制粘贴的心态编写的，因此它可以适应任何项目，无需太多修改（如果真的需要的话）。
- en: In the next chapter, we will enhance this game, which used only programmer art
    until now, so that it looks like something a team of 20 people spent months developing.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将增强这款游戏，它至今只使用了程序员艺术，使其看起来像是一个20人团队花费数月时间开发出来的作品。
