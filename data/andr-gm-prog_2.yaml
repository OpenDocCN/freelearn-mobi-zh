- en: Part 2. Module 2
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分。模块 2
- en: '***Android Game Programming by Example***'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '***Android 游戏编程实例***'
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Harness the power of the Android SDK by building three immersive and captivating
    games*'
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*通过构建三个沉浸式和引人入胜的游戏来利用 Android SDK 的力量*'
- en: Chapter 1. Player 1 UP
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章。玩家 1 UP
- en: The terminology used by old arcade and pinball machines "1 UP" was a kind of
    notice to the players that they were playing (up) now. It was also used to indicate
    earning an extra life. Are you ready to build three great games?
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 旧式街机和弹球机使用的术语“1 UP”是对玩家的一种通知，告诉他们现在正在玩游戏（上升）。它也被用来表示获得额外生命。你准备好构建三个伟大的游戏了吗？
- en: We will build three cool games together. Every line of code for these three
    games is shown in this book; you will never have to refer to the code files to
    see what is going on. Also, the entire file set required to build all three games
    is included in the download bundle that can be obtained from the books page on
    the Packt website.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一起构建三个酷炫的游戏。这本书展示了这三个游戏的每一行代码；你永远不需要参考代码文件来了解发生了什么。此外，构建所有三个游戏所需的整个文件集包含在可以从
    Packt 网站书籍页面获取的下载捆绑包中。
- en: All the code, Android manifest files, and the graphical and audio assets are
    included in the download as well. The three cool games are progressively more
    challenging to implement.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 所有代码、Android 清单文件以及图形和音频资源都包含在下载中。这三个酷炫的游戏在实现上越来越具有挑战性。
- en: The first project uses a simple but functional game engine that clearly demonstrates
    the essentials of a main game loop. The game will be fully working with the home
    screen, high scores, sound, and animation. But by the end of the project, as we
    add features and try to balance the game play, we will soon see that we need more
    flexibility in order to add features.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个项目使用一个简单但功能齐全的游戏引擎，清楚地展示了主游戏循环的基本要素。游戏将具备主屏幕、高分、音效和动画等功能。但随着项目的进行，当我们添加功能和尝试平衡游戏玩法时，我们很快就会看到我们需要更多的灵活性来添加功能。
- en: In the second project, a hard retro platformer, we will see how we can use a
    simple and flexible design to build a relatively fast and very flexible game engine,
    which is extendable and reusable. This flexibility will allow us to make quite
    a complex and well-featured game. This game will have multiple levels, different
    environments, and more. This in turn will highlight the need for being able to
    draw graphics more quickly. That leads us on to the third project.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个项目中，一个硬核复古平台游戏，我们将看到如何使用简单灵活的设计来构建一个相对快速且非常灵活的游戏引擎，该引擎可扩展且可重用。这种灵活性将使我们能够制作一个相当复杂且功能齐全的游戏。这个游戏将有多级、不同环境和更多内容。这反过来又突显了能够更快地绘制图形的需求。这让我们进入了第三个项目。
- en: In the third project, we will build an Asteroids-like game called **Asteroids
    simulator**. Although the game won't have as many features as the previous project,
    it will feature the super-smooth drawing of hundreds of animated game objects
    running at over 60 frames per second. We will achieve this by learning about and
    using the **Open Graphics Library for Embedded Systems** (**OpenGL ES 2**).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三个项目中，我们将构建一个类似 Asteroids 的游戏，称为 **Asteroids 模拟器**。尽管这个游戏不会像前一个项目那样有那么多功能，但它将具有超过
    60 帧每秒的数百个动画游戏对象的超级平滑绘制。我们将通过了解和使用 **嵌入式系统开放图形库**（**OpenGL ES 2**）来实现这一点。
- en: By the end of this book, you will have a whole repertoire of design ideas, techniques,
    and code templates that you can use in your future games. By seeing the strengths
    and weaknesses of the different ways of making games on Android, you will be able
    to successfully design and build games in the most appropriate way for your next
    big game.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的结尾，你将拥有一整套设计理念、技术和代码模板，你可以在未来的游戏中使用。通过了解在 Android 上制作游戏的多种方式的优缺点，你将能够以最合适的方式成功设计和构建游戏。
- en: A closer look at the games
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解游戏
- en: Here is a quick glimpse at the three projects.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 快速浏览三个项目。
- en: Tappy Defender
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Tappy Defender
- en: 'Fly Flappy Bird-style with one finger to reach your home planet, while avoiding
    multiple enemies. Features include:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 用一根手指飞得像 Flappy Bird 一样，到达你的家园星球，同时避开多个敌人。特色功能包括：
- en: Basic animation
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本动画
- en: Home screen![Tappy Defender](img/B04322_01_01.jpg)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主屏幕![Tappy Defender](img/B04322_01_01.jpg)
- en: Collision detection
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞检测
- en: High scores
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高分
- en: Simple HUD
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的 HUD
- en: One-finger touch screen controls![Tappy Defender](img/B04322_01_01b.jpg)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一指触摸屏控制![Tappy Defender](img/B04322_01_01b.jpg)
- en: Tough retro platformer
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 艰难的复古平台游戏
- en: 'This is a genuinely tough-to-beat retro style platform game. We have to guide
    Bob from the underground fire caves through the city, forest, and finally to the
    mountains. It has four challenging levels. Features include:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一款真正难以击败的复古风格平台游戏。我们必须引导鲍勃从地下火洞穿过城市、森林，最终到达山区。它有四个挑战级别。特色功能包括：
- en: A more advanced, flexible game engine
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更高级、更灵活的游戏引擎
- en: More advanced "sprite sheet" character animation
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更高级的“精灵表”角色动画
- en: A level builder engine to design your levels in text format
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个关卡构建器引擎，用于以文本格式设计您的关卡
- en: Multiple scrolling parallax backgrounds
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多重滚动视差背景
- en: Transition between levels
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关卡之间的过渡
- en: A more advanced HUD![Tough retro platformer](img/B04322_01_02.jpg)
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更高级的HUD![艰难的复古平台游戏](img/B04322_01_02.jpg)
- en: Add loads of extra diverse levels
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加大量额外的多样化关卡
- en: Sound manager to easily manage sound FX
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声音管理器，轻松管理音效
- en: Pickups
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拾取物品
- en: An upgradeable gun
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可升级的枪械
- en: Seek-and-destroy enemy drones
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索并摧毁敌方无人机
- en: Simple AI scripting for patrolling enemy guards
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于巡逻敌方守卫的简单AI脚本
- en: Hazards such as fire pits
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如火山坑等危险
- en: Scenery objects to create atmosphere![Tough retro platformer](img/B04322_01_02b.jpg)
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于营造氛围的风景对象![艰难的复古平台游戏](img/B04322_01_02b.jpg)
- en: Asteroids simulator
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小行星模拟器
- en: 'This is a classic shooter with retro vector-graphics style visuals. It involves
    clearing waves of smoothly animated spinning asteroids with a rapid fire gun.
    Features include:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一款经典的射击游戏，具有复古矢量图形风格的视觉效果。它涉及使用快速射击枪清除平滑动画的旋转小行星的波浪。特色功能包括：
- en: 60 frames per second or better, even on old hardware
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每秒60帧或更好，即使在旧硬件上
- en: An introduction to OpenGL ES 2
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL ES 2简介
- en: Shooter with waves of progressive difficulty
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 难度递增的波浪射击游戏
- en: Advanced multiphase collision detection![Asteroids simulator](img/B04322_01_03.jpg)
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级多阶段碰撞检测![小行星模拟器](img/B04322_01_03.jpg)
- en: Setting up your development environment
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置您的开发环境
- en: All the code in this book and the download bundle will work in your favorite
    Android IDE. However, I found the latest version of Android Studio exceptionally
    friendly to use and the code was written and tested in it as well.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 本书和下载包中的所有代码都将在您喜欢的Android IDE中运行。然而，我发现最新的Android Studio特别易于使用，代码也是在此环境中编写和测试的。
- en: If you don't currently use Android Studio, I encourage you to give it a try.
    Here is a quick overview of how to get up and running quickly. This guide includes
    steps to install the Java JDK in case you are completely new to Android development.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您目前不使用Android Studio，我鼓励您尝试一下。以下是如何快速启动和运行的简要概述。本指南包括安装Java JDK的步骤，以防您是Android开发的初学者。
- en: Tip
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you already have your preferred development environment ready to go then
    jump straight to [Chapter 2](ch11.html "Chapter 2. Tappy Defender – First Step"),
    *Tappy Defender – First Step*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经准备好了您偏好的开发环境，那么请直接跳转到[第2章](ch11.html "第2章。Tappy Defender – 第一步"), *Tappy
    Defender – 第一步*。
- en: The first thing we need to do is prepare your PC to develop for Android using
    Java. Fortunately, this is made quite simple for us.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是为使用Java开发Android准备您的PC。幸运的是，这对我们来说变得相当简单。
- en: Tip
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you are learning on Mac or Linux everything in this book will still work.
    The next two tutorials have Windows-specific instructions and screenshots. However,
    it shouldn't be too difficult to vary the steps slightly to suit Mac or Linux.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Mac或Linux上学习，本书中的所有内容仍然适用。接下来的两个教程包含Windows特定的说明和截图。然而，根据Mac或Linux进行轻微的步骤调整应该不会太难。
- en: 'All we need to do is:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的只是：
- en: Install the **Java Development Kit** (**JDK**), which allows us to develop in
    Java.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装**Java开发工具包**（**JDK**），它允许我们使用Java进行开发。
- en: Then install Android Studio to make Android development fast and easy. Android
    Studio uses the JDK and some other Android-specific tools that get automatically
    installed when we install Android Studio.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后安装Android Studio，使Android开发变得快速且简单。Android Studio使用JDK和一些其他特定于Android的工具，这些工具在我们安装Android
    Studio时会自动安装。
- en: Installing the JDK
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装JDK
- en: 'The first thing we need to do is get the latest version of the JDK. To complete
    this guide, perform the following instructions:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是获取JDK的最新版本。为了完成本指南，请执行以下步骤：
- en: 'We need to be on the Java website, so visit: [http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html).'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要访问Java网站，因此请访问：[http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html)。
- en: Find the three buttons shown here and click on the one that says **JDK** that
    is highlighted in the following image. They are on the right-hand side of the
    web page. Then, click on the **Download** button under the **JDK** option:![Installing
    the JDK](img/B04322_01_04.jpg)
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到此处显示的三个按钮，并点击以下图像中突出显示的 **JDK** 按钮。它们位于网页的右侧。然后，点击 **JDK** 选项下的 **下载** 按钮：![安装
    JDK](img/B04322_01_04.jpg)
- en: You will be taken to a page that has multiple options to download the JDK. In
    the **Product/File Description** column, you need to click the option that matches
    your operating system. Windows, Mac, Linux, and some other less common options
    are all listed.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将被带到具有多个选项下载 JDK 的页面。在 **产品/文件描述** 列表中，您需要点击与您的操作系统匹配的选项。Windows、Mac、Linux
    以及一些其他不太常见的选项都列出了。
- en: A common question asked here is, do I have 32- or 64-bit windows? To find out,
    right-click on your **My Computer** icon (**This PC** on Windows 8), click on
    the **Properties** option, and look under the **System** heading at the **System
    type** entry:![Installing the JDK](img/B04322_01_05.jpg)
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里常问的一个问题是，我是否有 32 位或 64 位 Windows？要找出答案，请右键单击您的 **我的电脑** 图标（Windows 8 上的 **此电脑**），点击
    **属性** 选项，然后在 **系统** 标题下查看 **系统类型** 条目：![安装 JDK](img/B04322_01_05.jpg)
- en: Click on the somewhat hidden **Accept License Agreement** checkbox:![Installing
    the JDK](img/B04322_01_06.jpg)
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击稍显隐藏的 **接受许可协议** 复选框：![安装 JDK](img/B04322_01_06.jpg)
- en: Now, click on **download for your OS** and type as previously determined. Wait
    for the download to finish.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击 **为您的操作系统下载** 并输入之前确定的版本。等待下载完成。
- en: In your `downloads` folder, double-click on the file you just downloaded. The
    latest version at the time of writing for a 64-bit Windows PC was `jdk-8u5-windows-x64`.
    If you are using Mac/Linux or have a 32-bit OS, your filename will vary accordingly.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的 `下载` 文件夹中，双击您刚刚下载的文件。截至撰写本文时，64 位 Windows PC 的最新版本是 `jdk-8u5-windows-x64`。如果您使用
    Mac/Linux 或 32 位操作系统，您的文件名将相应变化。
- en: In the first of several install dialogs, click on the **Next** button and you
    will see the following dialog box:![Installing the JDK](img/B04322_01_07.jpg)
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在几个安装对话框中的第一个对话框中，点击 **下一步** 按钮，您将看到以下对话框：![安装 JDK](img/B04322_01_07.jpg)
- en: Accept the defaults shown in the previous image by clicking on **Next**. In
    the next dialog box, you can accept the default install location by clicking on
    **Next**.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击 **下一步** 接受前一个图像中显示的默认设置。在下一个对话框中，您可以通过点击 **下一步** 接受默认的安装位置。
- en: Next up is the last dialog of the Java installer; for this click on **Close**.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是 Java 安装程序的最后一个对话框；为此，点击 **关闭**。
- en: Note
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The JDK is now installed. Next, we will make sure that Android Studio is able
    to use the JDK.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: JDK 已安装。接下来，我们将确保 Android Studio 能够使用 JDK。
- en: Right-click on your **My Computer** icon (**This PC** on windows 8) and click
    on **Properties** | **Advanced system settings** | **Environment Variables...**
    | **New...** (under **System variables**, not under **User variables**). Now,
    you can see the **New System Variable** dialog box:![Installing the JDK](img/B04322_01_08.jpg)
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击您的 **我的电脑** 图标（Windows 8 上的 **此电脑**），然后点击 **属性** | **高级系统设置** | **环境变量...**
    | **新...**（在 **系统变量** 下，不在 **用户变量** 下）。现在，您可以看到 **新系统变量** 对话框：![安装 JDK](img/B04322_01_08.jpg)
- en: Type `JAVA_HOME` for **Variable name:** and enter `C:\Program Files\Java\jdk1.8.0_05`
    for the **Variable value:** field. If you installed the JDK somewhere else, then
    the file path you enter in the **Variable value:** field will need to point to
    wherever you put it. Your exact file path will likely have a different ending
    to match the latest version of Java at the time you downloaded it.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **变量名** 为 **JAVA_HOME** 的字段中输入，并在 **变量值** 字段中输入 `C:\Program Files\Java\jdk1.8.0_05`。如果您在其他位置安装了
    JDK，那么您在 **变量值** 字段中输入的文件路径需要指向您放置它的位置。您的确切文件路径可能以不同的结尾结束，以匹配您下载时的最新 Java 版本。
- en: Click on **OK** to save your new settings.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **确定** 保存您的新的设置。
- en: Now under **System variables**, click on **Path** and then click on the **Edit...**
    button. At the very end of the text in the **Variable value:** field, enter the
    following text to add our new variable to the file paths that Windows will use,
    `;JAVA_HOME`. Be sure not to miss the semicolon from the beginning.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在 **系统变量** 下，点击 **路径**，然后点击 **编辑...** 按钮。在 **变量值** 字段中的文本末尾，输入以下文本以将我们的新变量添加到
    Windows 将使用的文件路径中，`;JAVA_HOME`。务必不要遗漏开头的分号。
- en: Click on **OK** to save the updated **Path** variable.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **确定** 保存更新的 **路径** 变量。
- en: Now, click on **OK** again to clear the **Advanced system settings** dialog
    box.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，再次点击**确定**以清除**高级系统设置**对话框。
- en: The JDK is now installed on our PC.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: JDK现在已安装在我们的PC上。
- en: Installing Android Studio
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Android Studio
- en: 'Without delay, let''s get Android Studio installed, and then we can begin our
    first game project. Visit:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 不拖延，让我们立即安装Android Studio，然后我们可以开始我们的第一个游戏项目。访问：
- en: '[https://developer.android.com/sdk/index.html](https://developer.android.com/sdk/index.html)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.android.com/sdk/index.html](https://developer.android.com/sdk/index.html)'
- en: Click on the button labeled **DOWNLOAD ANDROID STUDIO FOR WINDOWS** to start
    the Android Studio download. This will take you to another web page with a very
    similar looking button to the one you just clicked on.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击标有**下载Android Studio for Windows**的按钮开始下载Android Studio。这将带您进入另一个网页，其中有一个与您刚才点击的按钮非常相似的按钮。
- en: Accept the license by checking the checkbox and commence the download by clicking
    the button labeled **DOWNLOAD ANDROID STUDIO FOR WINDOWS** and wait for the download
    to complete.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过勾选复选框接受许可协议，并通过点击标有**下载Android Studio for Windows**的按钮开始下载，等待下载完成。
- en: In the folder you just downloaded Android Studio to, right-click on the `android-studio-bundle-135.12465-windows.exe`
    file and click on **Run as administrator**. The end of your filename will vary
    depending on the version of Android Studio and your operating system.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您刚刚下载Android Studio的文件夹中，右键单击`android-studio-bundle-135.12465-windows.exe`文件，并点击**以管理员身份运行**。您的文件名末尾将根据Android
    Studio的版本和您的操作系统而有所不同。
- en: When asked if you want to allow the following program from an unknown publisher
    to make changes to your computer, click on **Yes**. On the next screen, click
    on **Next**.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当被问及是否允许来自未知发布者的以下程序更改您的计算机时，点击**是**。在下一屏幕上，点击**下一步**。
- en: On the screen pictured here, you can choose which users of your PC can use Android
    Studio. Choose which is right for you as all options will work, and then click
    on **Next**:![Installing Android Studio](img/B04322_01_09.jpg)
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此处显示的屏幕上，您可以选择哪些PC用户可以使用Android Studio。选择适合您的选项，因为所有选项都将正常工作，然后点击**下一步**：![安装Android
    Studio](img/B04322_01_09.jpg)
- en: In the next dialog, leave the default settings and then click on **Next**.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个对话框中，保留默认设置，然后点击**下一步**。
- en: On the **Choose start menu folder** dialog box leave the defaults and click
    on **Install**.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**选择开始菜单文件夹**对话框中，保留默认设置并点击**安装**。
- en: On the Installation complete dialog, click on **Finish** to run Android Studio
    for the first time.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在安装完成对话框中，点击**完成**以首次运行Android Studio。
- en: The next dialog is for users who have already used Android Studio, so assuming
    you are first-time user, select the **I do not have a previous version of Android
    Studio or I do not want to import my settings** checkbox. Then click on **OK**:![Installing
    Android Studio](img/B04322_01_10.jpg)
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个对话框是为已经使用过Android Studio的用户准备的，所以假设您是第一次用户，请选择**我没有先前的Android Studio版本或我不想导入我的设置**复选框。然后点击**确定**：![安装Android
    Studio](img/B04322_01_10.jpg)
- en: That was the last piece of software we needed. We will begin to use Android
    Studio straight away in the next chapter.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 那是我们需要的最后一款软件。我们将在下一章直接开始使用Android Studio。
- en: Summary
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was deliberately kept as short as possible, so we can get on with
    building some games. We will do this now.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 本章故意保持尽可能短，这样我们就可以开始构建一些游戏。我们现在就这样做。
- en: Chapter 2. Tappy Defender – First Step
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 Tappy Defender – 第一步
- en: Welcome to the first game, which we will learn about in three chapters. In this
    chapter, we will closely examine the goals for the finished product. It helps
    a lot when building a game, if we know exactly what we are trying to achieve.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到第一个游戏，我们将在接下来的三章中学习它。在本章中，我们将仔细检查最终产品的目标。如果我们确切地知道我们想要实现什么，这对构建游戏非常有帮助。
- en: We can then look at the structure of our code, including an approximate design
    pattern that we will be adhering to. Then, we will put together the code skeleton
    of our first game engine. Finally, to finish the chapter, we will draw our first
    real object from the game and animate it on the screen.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以查看我们代码的结构，包括我们将遵循的大致设计模式。然后，我们将组装我们第一个游戏引擎的代码框架。最后，为了完成本章，我们将从游戏中绘制第一个真实对象并在屏幕上对其进行动画处理。
- en: We will then be ready for [Chapter 3](ch12.html "Chapter 3. Tappy Defender –
    Taking Flight"), *Tappy Defender – Taking Flight*, where we can make really fast
    progress before completing our first game in [Chapter 4](ch13.html "Chapter 4. Tappy
    Defender – Going Home"), *Tappy Defender – Going Home*.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将准备好进入[第3章](ch12.html "第3章。Tappy Defender – Taking Flight")，*Tappy Defender
    – Taking Flight*，在那里我们可以在完成[第4章](ch13.html "第4章。Tappy Defender – Going Home")，*Tappy
    Defender – Going Home*中的第一个游戏之前取得真正的进展。
- en: Planning the first game
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规划第一个游戏
- en: In this section, we will flesh out exactly what our game will be. The backstory;
    who is our hero and what are they trying to achieve? The game mechanics; what
    will the player actually do? What buttons will he press and in what way is that
    a challenge or fun thing to do? Then, we will look at the rules. What constitutes
    victory, death, and progress? Finally, we will get technical and start to examine
    how we will actually build the game.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将详细说明我们的游戏将是什么样子。背景故事；我们的英雄是谁，他们试图实现什么？游戏机制；玩家实际上会做什么？他会按哪些按钮，以及这种方式是如何成为一种挑战或有趣的事情的？然后，我们将研究规则。胜利、死亡和进步由什么构成？最后，我们将变得技术性，开始研究我们实际上将如何构建游戏。
- en: Backstory
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背景
- en: Valerie has been defending the far outposts of humanity since the early '80s.
    Her brave exploits were originally immortalized in the 1981 arcade classic, Defender.
    However, after over 30 years on the front line, she is retiring and it is time
    to begin the journey home. Unfortunately, in a recent skirmish, her ship's engines
    and navigation systems were severely damaged. Therefore, now she must fly all
    the way home using only her boost thruster.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 瓦莱丽自20世纪80年代初以来一直在保卫人类的前哨阵地。她的勇敢事迹最初在1981年的街机经典游戏《Defender》中被永久记录。然而，在30多年的前线战斗后，她即将退休，是时候开始回家的旅程了。不幸的是，在最近的一次小冲突中，她的飞船引擎和导航系统严重受损。因此，现在她必须仅靠她的助推器飞回家。
- en: This means that she must fly her ship by simultaneously thrusting up and forward,
    kind of bouncing really, while avoiding enemies who try to crash into her. In
    a recent communication with Earth, Valerie was heard to claim that it was, "Like
    trying to fly a lame bird." This is some concept art of Valerie in her damaged
    ship because it helps to visualize our game as early as possible.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着她必须通过同时向上和向前推力来驾驶她的飞船，有点像弹跳，同时避开试图撞向她的敌人。在一次与地球的最近通信中，瓦莱丽声称这就像“试图驾驶一只跛脚的鸟”。这是瓦莱丽在她的受损飞船中的概念艺术，因为它有助于尽早可视化我们的游戏。
- en: '![Backstory](img/B04322_02_01.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![背景故事](img/B04322_02_01.jpg)'
- en: Now that we have learned a little bit about our hero and her predicament, we
    take a closer look at the mechanics of the game.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对我们的英雄和她所处的困境有了一些了解，我们更仔细地看看游戏的机制。
- en: The game mechanics
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏机制
- en: Mechanics are the key actions that a player must make and become good at, to
    be able to beat the game. When designing a game, you can rely on tried and tested
    ideas for mechanics or you can invent your own. In Tappy Defender, we will be
    using a mechanic where the player taps and holds the screen to boost the ship.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 机制是玩家必须执行并变得擅长以能够打败游戏的关键动作。在设计游戏时，你可以依赖经过验证和测试的机制想法，或者你可以发明自己的。在Tappy Defender中，我们将使用一种机制，即玩家轻触并保持屏幕以助推飞船。
- en: This boosting will raise the ship up the screen, but will also make the ship
    speed up and therefore be more vulnerable. When the player removes their finger,
    the boost engine will cut out and the ship will fall downward and decelerate,
    thus making the ship slightly less vulnerable. Therefore, a very fine and masterful
    balance of boosting and not boosting is required to survive.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这种助推将使飞船上升屏幕，但也会使飞船加速，因此更容易受到攻击。当玩家移开手指时，助推器将关闭，飞船将向下坠落并减速，从而使飞船稍微不那么容易受到攻击。因此，需要非常精细和精湛的助推与不助推之间的平衡，才能生存下来。
- en: Tappy Defender is of course heavily inspired by Flappy Bird and a multitude
    of similar games that followed its success.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Tappy Defender当然深受Flappy Bird及其众多类似游戏成功的影响。
- en: Instead of a how-far-can-I-get scoring system like Flappy Bird, Tappy Defender
    will have a goal of reaching "home". Then, the player can replay the game multiple
    times in order to try and beat their fastest time. Of course to go faster, the
    player must boost more frequently and put Valerie in greater peril.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 与Flappy Bird那样的得分系统不同，Tappy Defender的目标是到达“家”。然后，玩家可以多次重玩游戏，以尝试打破他们最快的记录。当然，为了更快，玩家必须更频繁地助推，并将瓦莱丽置于更大的危险之中。
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In the unlikely event you have never played or seen Flappy Bird, it is well
    worth spending 5 minutes having a play with this type of game now. You can download
    one of the many Flappy Bird inspired apps from the Google Play store:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在不太可能的情况下，如果你从未玩过或见过《Flappy Bird》，现在花5分钟玩这种类型的游戏是非常值得的。你可以从Google Play商店下载许多受《Flappy
    Bird》启发的应用程序：
- en: '[https://play.google.com/store/search?q=flappy%20bird&c=apps](https://play.google.com/store/search?q=flappy%20bird&c=apps)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://play.google.com/store/search?q=flappy%20bird&c=apps](https://play.google.com/store/search?q=flappy%20bird&c=apps)'
- en: Rules for the game
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏规则
- en: 'Here, we will define things which balance the game and make it fair and consistent
    for the player:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将定义一些平衡游戏并使其对玩家公平和一致的事物：
- en: The player's ship is much tougher than the enemy ships. This is because the
    player's ship has shields. Each time the player collides with an enemy, the enemy
    is instantly destroyed, but the player loses a shield. The player has three shields.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家的飞船比敌人的飞船更坚固。这是因为玩家的飞船有护盾。每次玩家与敌人碰撞时，敌人会立即被摧毁，但玩家会失去一个护盾。玩家有三个护盾。
- en: The player will need to fly a set number of kilometers to reach home.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家需要飞行一定数量的公里才能到达家中。
- en: Every time the player reaches home, they win the game. If their time was the
    fastest, they also get a new fastest time, like a high score.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当玩家到达家中，他们就会赢得游戏。如果他们的时间是最快的，他们也会获得一个新的最快时间，就像高分一样。
- en: Enemies will spawn at a random height on the far right of the screen and fly
    toward the player at a random speed.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 敌人将在屏幕最右侧的随机高度出现，并以随机速度向玩家飞来。
- en: The player is always positioned on the far left of the screen, but boosting
    will mean the enemies approach more quickly.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家始终位于屏幕的远左侧，但加速会使敌人更快接近。
- en: The design
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计
- en: We will use a loose design pattern, where we will separate our code based on
    a control part, model part, and view. This is how we will separate our code into
    three areas.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用宽松的设计模式，我们将根据控制部分、模型部分和视图来分离我们的代码。这就是我们将代码分成三个区域的方法。
- en: Control
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制
- en: This is the part of our code that will control all other parts. It will decide
    when to show the view, it will initialize all our game objects from the model,
    and it will prompt decisions based on the states of data to take place within
    the model.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是控制我们代码其他部分的代码部分。它将决定何时显示视图，它将从模型初始化所有我们的游戏对象，并且它将根据模型中的数据状态提示决策。
- en: Model
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模型
- en: The model is our game data and logic. What do the ships look like? Where on
    the screen are our ships? How fast are they going, and so on. Furthermore, the
    model part of our code is the intelligence system for each of our game objects.
    Although our enemies in this game don't have sophisticated AI, they will know
    and decide for themselves how fast they are going, when to respawn and more.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 模型是我们的游戏数据和逻辑。船看起来是什么样子？我们的船在屏幕上的位置在哪里？它们移动得多快，等等。此外，我们代码中的模型部分是每个游戏对象的智能系统。尽管我们游戏中的敌人没有复杂的AI，但它们会知道并自行决定移动的速度，何时重生等等。
- en: View
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 视图
- en: The view is exactly what it sounds like. It is the part of our code that will
    do the actual drawing based on the state of the models. It will draw when the
    control part of our code tells it. It will not have any influence over the game
    objects. For example, the view will not decide where an object is or even what
    it looks like. It just draws and then hands control back to the control code.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 视图正如其名。这是我们代码的一部分，将根据模型的状态进行实际绘制。当控制代码的一部分告诉它时，它将绘制。它不会对游戏对象有任何影响。例如，视图不会决定对象的位置或其外观。它只是绘制，然后把控制权交回控制代码。
- en: Design pattern reality check
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计模式现实检查
- en: In reality, the separation is not as clear as the discussion suggests. In fact,
    the code for drawing and control is within the same class. However, you will see
    that the logic of drawing and controlling is separate within that class.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这种分离并不像讨论中提到的那么清晰。实际上，绘制和控制代码位于同一个类中。然而，你将看到，绘制和控制的逻辑在那个类中是分开的。
- en: By separating our game into these three parts, we will see how we simplify the
    development and avoid getting tied up in messy code that constantly expands as
    we add new features to our game.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将我们的游戏分成这三个部分，我们将看到我们如何简化开发并避免陷入混乱的代码，这些代码随着我们向游戏中添加新功能而不断扩展。
- en: Let's look more closely at where this pattern fits in with our code.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这个模式在我们代码中的位置。
- en: The game code structure
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏代码结构
- en: First of all, we must take account of the system we are working within. In this
    case, it is the Android system. If you have been making Android apps for a while,
    you may be wondering where this pattern stuff fits in with the Android Activity
    lifecycle. If you are new to Android, you might ask what the Activity lifecycle
    is.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须考虑我们正在工作的系统。在这种情况下，是 Android 系统。如果您已经制作了一段时间的 Android 应用，您可能会想知道这种模式与
    Android Activity 生命周期有什么关系。如果您是 Android 新手，您可能会问 Activity 生命周期是什么。
- en: The Android Activity lifecycle
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Android Activity 生命周期
- en: The Android Activity lifecycle is the framework we must work within to make
    any type of Android app. There is a class called `Activity` that we must derive
    from and is an entry point to our app. In addition, we need to be aware that this
    class, that our game is an object of, also has some methods we can override. These
    methods control the lifecycle of our app.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Android Activity 生命周期是我们必须在其中工作的框架，以制作任何类型的 Android 应用。有一个名为 `Activity` 的类，我们必须从中派生出来，并且它是我们应用的入口点。此外，我们需要意识到这个类，即我们的游戏是一个对象，也有一些我们可以重写的方法。这些方法控制着我们的应用生命周期。
- en: When an app is started by the user, our `Activity` object is created and a number
    of the methods that we can override are called in sequence. This is what happens.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户启动应用时，我们的 `Activity` 对象被创建，并且会按顺序调用我们可以重写的一系列方法。这就是发生的事情。
- en: When the `Activity` object is created, three methods are called in sequence;
    `onCreate()`, `onStart()`, and `onResume()`. At this point, the app is now running.
    In addition, when the user quits an app or the app is interrupted, perhaps by
    a phone call, the `onPause` method is called. The user may decide, perhaps after
    completing their phone call, to return to the app. If this happens, the `onResume`
    method is called, following which the app is running again.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `Activity` 对象被创建时，会按顺序调用三个方法；`onCreate()`、`onStart()` 和 `onResume()`。此时，应用现在正在运行。此外，当用户退出应用或应用被中断，例如被电话呼叫，会调用
    `onPause` 方法。用户可能会决定，也许在完成电话通话后，返回到应用。如果发生这种情况，会调用 `onResume` 方法，随后应用再次运行。
- en: Should the user not return to the app or the Android system decides that it
    wants the system resources for something else, two further methods are called
    to clean up. First `onStop()`, and then `onDestroy()`. The app is now destroyed
    and any attempt to return to the game again will result in the Activity lifecycle
    starting from the beginning.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户没有返回到应用或 Android 系统决定它需要为其他事情使用系统资源，将调用两个进一步的方法来清理。首先 `onStop()`，然后 `onDestroy()`。现在应用已被销毁，任何尝试再次返回到游戏的行为都将导致
    Activity 生命周期从头开始。
- en: All we have to do as game programmers is be aware of this lifecycle and observe
    a few rules of good housekeeping. We will implement and explain the rules of good
    housekeeping as we proceed.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 作为游戏程序员，我们只需要意识到这个生命周期并遵守一些良好的管理规则。随着我们的进行，我们将实现并解释这些良好的管理规则。
- en: Note
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The Android Activity lifecycle is much more complex and far more nuanced than
    I have just explained it. However, we know everything we need to get programming
    our first game. If you want to know more please have a look at this article on
    the Android developer''s web site at:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Android Activity 生命周期比我刚才解释的要复杂得多，也更为微妙。然而，我们已经知道了一切，足以开始编写我们的第一个游戏。如果您想了解更多信息，请查看
    Android 开发者网站上的这篇文章：
- en: '[http://developer.android.com/reference/android/app/Activity.html](http://developer.android.com/reference/android/app/Activity.html)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://developer.android.com/reference/android/app/Activity.html](http://developer.android.com/reference/android/app/Activity.html)'
- en: 'Once we have catered for the Android Activity lifecycle, the core methods of
    our class representing the control part of the pattern will be as simple as this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们处理了 Android Activity 生命周期，我们代表模式控制部分的类的核心方法将像这样简单：
- en: Update the state of our game objects.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新我们游戏对象的状态。
- en: Draw the game objects based on their state.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据它们的状态绘制游戏对象。
- en: Pause to lock the frame rate.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 暂停以锁定帧率。
- en: Get player input. Actually because parts 1, 2, and 3 happen in a thread, this
    part can happen at any time.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取玩家输入。实际上，由于第 1、2 和 3 部分发生在线程中，这部分可以在任何时间发生。
- en: Repeat.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复。
- en: One last bit of preparation, before we start to build our game for real.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始真正构建游戏之前，还有一些最后的准备工作。
- en: The Android Studio file structure
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android Studio 文件结构
- en: The Android system is quite particular about where we put our class files, including
    `Activity` and where in the file hierarchy we place our assets like sound files
    and graphics.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Android 系统对我们放置类文件的位置非常讲究，包括 `Activity`，以及我们在文件层次结构中放置我们的资产（如声音文件和图形）的位置。
- en: Here is a really quick overview of where we will be putting everything. You
    don't need to memorize this, as we will remind ourselves of the correct folder
    while adding assets. We will step through the activity/class creation process
    the first few times we need to do it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个关于我们将要放置所有内容的快速概述。你不需要记住这些，因为当我们添加资源时会提醒你正确的文件夹。我们将在第一次需要创建活动/类的时候逐步进行。
- en: 'As a heads up, here is an annotated diagram of what your Android Studio project
    explorer will look like by the end of the Tappy Defender project:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 提前提醒，以下是 Tappy Defender 项目结束时你的 Android Studio 项目资源管理器将看起来像的标注图：
- en: '![The Android Studio file structure](img/B04322_02_02.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![Android Studio 文件结构](img/B04322_02_02.jpg)'
- en: Now, we can actually start building Tappy Defender.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以真正开始构建 Tappy Defender。
- en: Building the home screen
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建主页
- en: Since we have done all the planning and preparation, we can get started with
    the code.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经完成了所有的规划和准备，我们可以开始编写代码。
- en: Note
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To use the code files, you will still need to create an Android Studio project.
    In addition, you will need to change the package name in the very first line of
    code of each of the JAVA files. Change the package name to match the package name
    of the project you created. Finally, you will need to make sure that any assets
    such as images or sound files are placed into the appropriate folder in the project.
    All the required assets for each project are supplied in the download bundle.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用代码文件，你仍然需要创建一个 Android Studio 项目。此外，你还需要在每个 JAVA 文件的非常第一行代码中更改包名。将包名更改为与创建的项目包名匹配。最后，你需要确保任何如图片或声音文件等资源都放置在项目中的适当文件夹里。每个项目的所有必需资源都包含在下载包中。
- en: Creating the project
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建项目
- en: Fire up Android Studio and create a new project by following these steps. All
    the files to get the project to where we will be, by the end of this chapter,
    are in the download bundle in the `Chapter2` folder.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 Android Studio，按照以下步骤创建一个新项目。所有将在这个章节结束时用到的文件都包含在`Chapter2`文件夹中的下载包里。
- en: On the **Welcome to Android Studio** dialog, click on **Start a new Android
    Studio project**.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**欢迎使用 Android Studio**对话框中，点击**创建新的 Android Studio 项目**。
- en: In the **Create New Project** window shown next, we need to enter some basic
    information about our app. These bits of information will be used by Android Studio
    to determine the package name.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在接下来的**创建新项目**窗口中，我们需要输入一些关于我们应用的基本信息。这些信息将被 Android Studio 用于确定包名。
- en: Note
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the following image, you can see the **Edit** link where you can customize
    the package name if required.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下图片中，你可以看到**编辑**链接，你可以在此处自定义包名（如果需要的话）。
- en: If you will be copy/pasting the supplied code into your project, then use `C1
    Tappy Defender` for the **Application name** field and `gamecodeschool.com` in
    the **Company Domain** field as shown in the following screenshot:![Creating the
    project](img/B04322_02_03.jpg)
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你将复制粘贴提供的代码到你的项目中，那么在**应用程序名称**字段中输入`C1 Tappy Defender`，在**公司域名**字段中输入`gamecodeschool.com`，如以下截图所示：![创建项目](img/B04322_02_03.jpg)
- en: Click on the **Next** button when you're ready. When asked to select the form
    factors, your app will run on, we can accept the default settings (**Phone and
    Tablet**). So click on **Next** again.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备好时，点击**下一步**按钮。当被问及你的应用将运行在哪些设备形式上时，我们可以接受默认设置（**手机和平板**）。所以再次点击**下一步**。
- en: On the **Add an activity to mobile** dialog, just click on **Blank Activity**
    followed by the **Next** button.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**添加活动到移动设备**对话框中，只需点击**空白活动**，然后点击**下一步**按钮。
- en: On the **Customize the Activity** dialog, again we can accept the default settings
    because `MainActivity` seems like a good name for our main Activity. So click
    on the **Finish** button.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**自定义活动**对话框中，我们同样可以接受默认设置，因为`MainActivity`似乎是我们主要活动的合适名称。所以点击**完成**按钮。
- en: What we did
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们所做
- en: Android Studio has built the project and created a number of files, most of
    which we will see and edit during the course of building this game. As mentioned
    earlier, even if you are just copying and pasting the code, you need to go through
    this step because Android Studio is doing things behind the scenes to make our
    project work.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio 已经构建了项目并创建了许多文件，其中大部分我们将在构建这个游戏的过程中看到并编辑。如前所述，即使你只是在复制粘贴代码，你也必须完成这一步，因为
    Android Studio 在幕后做一些事情来使我们的项目工作。
- en: Building the home screen UI
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建主页 UI
- en: 'The first and simplest part of our Tappy Defender game is the home screen.
    All we need is a neat picture with a scene about the game, a high score, and a
    button to start the game. The finished home screen will look a bit like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们Tappy Defender游戏的第一部分和最简单部分是主屏幕。我们需要的只是一个关于游戏的场景整洁图片、一个最高分和一个开始游戏的按钮。完成后的主屏幕将看起来有点像这样：
- en: '![Building the home screen UI](img/B04322_02_04.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![构建主屏幕UI](img/B04322_02_04.jpg)'
- en: 'When we built the project, Android Studio opens up two files ready for us to
    edit. You can see them as tabs in the following Android Studio UI designer. The
    files (and tabs) are `MainActivity.java` and `activity_main.xml`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建项目时，Android Studio会为我们打开两个文件以便编辑。您可以在下面的Android Studio UI设计器中看到它们作为标签页。这些文件（和标签页）是`MainActivity.java`和`activity_main.xml`：
- en: '![Building the home screen UI](img/B04322_02_05.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![构建主屏幕UI](img/B04322_02_05.jpg)'
- en: The `MainActivity.java` file is the entry point to our game, and we will see
    this in more detail soon. The `activity_main.xml` file is the UI layout that our
    home screen will use. Now, we can go ahead and edit the `activity_main.xml` file,
    so it actually looks like our home screen should.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainActivity.java`文件是我们游戏的入口点，我们很快就会看到更多细节。`activity_main.xml`文件是我们主屏幕将使用的UI布局。现在，我们可以继续编辑`activity_main.xml`文件，使其看起来像我们的主屏幕应该的样子。'
- en: First of all, your game will be played with the Android device in landscape
    mode. If we change our UI preview window to landscape, we will see your progress
    more accurately. Look for the button shown in the next image. It is just preceding
    the UI preview:![Building the home screen UI](img/B04322_02_06.jpg)
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您的游戏将以Android设备的横屏模式运行。如果我们将我们的UI预览窗口更改为横屏，我们将更准确地看到您的进度。寻找下一张图片中显示的按钮。它就在UI预览之前：![构建主屏幕UI](img/B04322_02_06.jpg)
- en: Click on the button shown in the preceding screenshot, and your UI preview will
    switch to landscape like this:![Building the home screen UI](img/B04322_02_07.jpg)
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击前一张截图中的按钮，您的UI预览将切换到如下所示的横屏模式：![构建主屏幕UI](img/B04322_02_07.jpg)
- en: Make sure `activity_main.xml` is open by clicking on its tab.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保通过单击其标签打开`activity_main.xml`。
- en: Now, we will set in a background image. You can use your own or mine from `Chapter2/drawable/background.jpg`
    in the download bundle. Add your chosen image to the `drawable` folder of the
    project in Android Studio.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将设置一个背景图片。您可以使用自己的图片，或者从下载包中的`Chapter2/drawable/background.jpg`使用我的图片。将您选择的照片添加到Android
    Studio项目中`drawable`文件夹。
- en: In the **Properties** window of the UI designer, find and click on the **background**
    property as shown in the next image:![Building the home screen UI](img/B04322_02_08.jpg)
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在UI设计器的**属性**窗口中，找到并单击如图所示的**背景**属性：![构建主屏幕UI](img/B04322_02_08.jpg)
- en: Also, in the previous image the button labelled **...** is outlined. It is just
    to the right of the **background** property. Click on that **...** button and
    browse to and select the background image file that you will be using.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，在上一张图片中，标记为**...**的按钮被轮廓包围。它位于**背景**属性的正右方。点击那个**...**按钮，浏览并选择您将使用的背景图片文件。
- en: Next, we need a **TextView** widget that we will use to display the high score.
    Note that there is already a **TextView** widget on the layout. It says **Hello
    World**. You will modify this and use it for our high score. Left click on it
    and drag the **TextView** to where you want it. You can copy me if you intend
    using the supplied background or put it where it looks best with your background.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个用于显示最高分的**TextView**小部件。请注意，布局中已经有一个**TextView**小部件。它写着**Hello World**。您将修改它并用于我们的最高分。左键单击它并将其拖动到您想要的位置。如果您打算使用提供的背景，可以复制它，或者将其放置在背景看起来最好的位置。
- en: Next, in the **Properties** window, find and click on the **id** property. Enter
    `textHighScore`. Type it exactly as shown because when we write some Java code
    in a later tutorial, we will refer to this ID in order to manipulate it, to show
    the player's fastest time.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在**属性**窗口中，找到并单击**id**属性。输入`textHighScore`。请准确无误地输入，因为当我们稍后在教程中编写一些Java代码时，我们将引用此ID来操作它，以显示玩家的最快时间。
- en: 'You can also edit the **text** property to say `High Score: 99999` or similar
    so that the **TextView** looks the part. However, this isn''t necessary because
    your Java code will take care of this later.'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '您还可以编辑**文本**属性，将其设置为`High Score: 99999`或类似内容，以便**TextView**看起来更合适。然而，这并不是必需的，因为您的Java代码将在稍后处理这一点。'
- en: Now, we will drag a button from the widget palette as shown in the following
    screenshot:![Building the home screen UI](img/B04322_02_09.jpg)
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将从组件面板中拖动一个按钮，如下面的截图所示：![构建主页UI](img/B04322_02_09.jpg)
- en: Drag it to where it looks good on your background. You can copy me if using
    the supplied background or put it where it looks best with your background.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将它拖动到背景上看起来不错的地方。如果您使用提供的背景，可以复制我，或者将其放置在您背景上看起来最好的位置。
- en: Next, in the Properties window, find and click on the id property of the button.
    Enter buttonPlay. Type it exactly as shown because when we write some Java code
    in a later tutorial, we will refer to this ID in order to manipulate it. Also
    edit the text property to say Play.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在属性窗口中，找到并点击按钮的id属性。输入buttonPlay。请准确无误地输入，因为我们将在稍后的教程中编写一些Java代码时，将引用此ID来操作它。同时编辑文本属性，使其显示为“播放”。
- en: What we did
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们所做的是
- en: We now have a cool background with neatly arranged widgets (a **TextView** and
    a **Button**) for your home screen. We can add functionality via Java code to
    the **Button** widget next. Revisit the **TextView** for the player's high score
    in [Chapter 4](ch13.html "Chapter 4. Tappy Defender – Going Home"), *Tappy Defender
    – Going Home*. The important point is that both the widgets have been assigned
    a unique ID that we can use to reference and manipulate in your Java code.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个酷炫的背景，上面整齐地排列着小部件（一个**TextView**和一个**Button**），用于您的首页。我们可以通过Java代码向**Button**小部件添加功能。回顾[第4章](ch13.html
    "第4章。Tappy Defender – Going Home")中的**TextView**，*Tappy Defender – Going Home*。重要的是，这两个小部件都分配了一个唯一的ID，我们可以使用它来在Java代码中引用和操作。
- en: Coding the functionality
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码功能
- en: Now, we have a simple layout for our game home screen. Now, we need to add the
    functionality that will allow the player to click on the **Play** button to start
    the game.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们为游戏的主页有一个简单的布局。现在，我们需要添加允许玩家点击**播放**按钮开始游戏的功能。
- en: Click on the tab for the `MainActivity.java` file. The code that was automatically
    generated for us is not exactly what we need. Therefore, we will start again as
    it is simpler and quicker than tinkering with what is already there.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 点击`MainActivity.java`文件的标签。为我们自动生成的代码并不完全符合我们的需求。因此，我们将从头开始，因为这样做比修改现有的代码要简单快捷。
- en: Delete the entire contents of the `MainActivity.java` file except the package
    name and enter the following code in it. Of course, your package name may be different.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 删除`MainActivity.java`文件中的所有内容（除了包名），并在其中输入以下代码。当然，您的包名可能不同。
- en: '[PRE0]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The mentioned code is the current contents of our main `MainActivity` class
    and the entry point of our game, the `onCreate` method. The line of code that
    begins with `setContentView...` is the line that loads our UI layout from `activity_main.xml`
    to the players screen. We can run the game now and see our home screen, but let's
    make some more progress, following which we will look at how we run the game on
    a real device at the end of the chapter.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 提到的代码是我们当前主`MainActivity`类的当前内容，也是我们游戏的入口点，即`onCreate`方法。以`setContentView...`开头的代码行是将我们的UI布局从`activity_main.xml`加载到玩家屏幕上的代码行。我们现在可以运行游戏并看到我们的主页，但让我们再取得一些进展，然后我们将在本章末尾查看如何在真实设备上运行游戏。
- en: Now, let's handle the **Play** button on our home screen. Add the two highlighted
    lines of the following code into the `onCreate` method just after the call to
    `setContentView()`. The first new line creates a new `Button` object and gets
    a reference to `Button` in our UI layout. The second line is the code that listens
    for clicks on the button.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们处理我们的主页上的**播放**按钮。将以下代码中的两个高亮行添加到`onCreate`方法中，紧接在调用`setContentView()`之后。第一行新代码创建了一个新的`Button`对象，并获取了UI布局中`Button`的引用。第二行是监听按钮点击的代码。
- en: '[PRE1]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that we have a few errors in our code. We can resolve these errors by holding
    down the *Alt* keyboard key and then pressing *Enter*. This will add an import
    directive for the `Button` class.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的代码中存在一些错误。我们可以通过按住键盘上的*Alt*键然后按*Enter*键来解决这些错误。这将添加一个对`Button`类的导入指令。
- en: 'We still have one error. We need to implement an interface so that our code
    listens to the button clicks. Modify the `MainActivity` class declaration as highlighted:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然有一个错误。我们需要实现一个接口，以便我们的代码能够监听按钮点击。修改如高亮显示的`MainActivity`类声明：
- en: '[PRE2]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When we implement the `onClickListener` interface, we must also implement the
    `onClick` method. This is where we will handle what happens when a button is clicked.
    We can automatically generate the `onClick` method by right-clicking somewhere
    after the `onCreate` method, but within the `MainActivity` class, and navigating
    to **Generate** | **Implement methods** | **onClick(v:View):void. Or just add
    the given code.**
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实现 `onClickListener` 接口时，我们也必须实现 `onClick` 方法。这是我们处理按钮点击时发生的事情的地方。我们可以通过在
    `onCreate` 方法之后但仍在 `MainActivity` 类内部的位置右键单击，然后导航到 **生成** | **实现方法** | **onClick(v:View):void**
    来自动生成 `onClick` 方法。或者直接添加给定的代码。
- en: We also need to have Android Studio add another import directive for `Android.view.View`.
    Use the *Alt* | *Enter* keyboard combination again.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要让 Android Studio 添加另一个导入指令，用于 `Android.view.View`。再次使用 *Alt* | *Enter*
    键盘组合。
- en: 'We can now scroll to near the bottom of the `MainActivity` class and see that
    Android Studio has implemented an empty `onClick` method for us. We should have
    no errors in your code at this point. Here is the `onClick` method:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以滚动到 `MainActivity` 类的底部附近，看到 Android Studio 已经为我们实现了一个空的 `onClick` 方法。此时，你的代码应该没有错误。以下是
    `onClick` 方法：
- en: '[PRE3]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As we only have one `Button` object and one listener, we can safely assume that
    any clicks on our home screen are the player pressing our **Play** button.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只有一个 `Button` 对象和一个监听器，我们可以安全地假设在我们主屏幕上的任何点击都是玩家在按下我们的**播放**按钮。
- en: 'Android uses the `Intent` class to switch between activities. As we need to
    go to a new activity when the **Play** button is clicked, we will create a new
    `Intent` object and pass in the name of our future `Activity` class, `GameActivity`
    to its constructor. We can then use the `Intent` object to switch activities.
    Add the following code to the body of the `onClick` method:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Android 使用 `Intent` 类在活动之间切换。由于当点击**播放**按钮时我们需要转到新的活动，我们将创建一个新的 `Intent` 对象，并将我们未来的
    `Activity` 类 `GameActivity` 的名称传递给其构造函数。然后我们可以使用 `Intent` 对象来切换活动。将以下代码添加到 `onClick`
    方法的主体中：
- en: '[PRE4]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Once again, we have errors in our code because we need to generate a new import
    directive, this time for the `Intent` class so use the *Alt* | *Enter* keyboard
    combination again. We still have one error in our code. This is because our `GameActivity`
    class does not exist yet. We will now solve this problem.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们的代码中出现了错误，因为我们需要生成一个新的导入指令，这次是针对 `Intent` 类，所以再次使用 *Alt* | *Enter* 键盘组合。我们代码中仍然有一个错误。这是因为我们的
    `GameActivity` 类还不存在。我们现在将解决这个问题。
- en: Creating GameActivity
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 GameActivity
- en: We have seen that when the player clicks on the **Play** button, main activity
    will close and game activity will begin. Therefore, we need to create a new activity
    called `GameActivity` that will be were your game actually executes.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，当玩家点击**播放**按钮时，主活动将关闭，游戏活动将开始。因此，我们需要创建一个新的活动，名为 `GameActivity`，这将是我们游戏实际执行的地方。
- en: From the main menu, navigate to **File** | **New** | **Activity** | **Blank
    Activity**.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从主菜单导航到 **文件** | **新建** | **活动** | **空白活动**。
- en: In the **Customize the Activity** dialog, change the **Activity Name** field
    to `GameActivity`.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **自定义活动** 对话框中，将 **活动名称** 字段更改为 `GameActivity`。
- en: We can accept all the other default settings from this dialog, so click on **Finish**.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以接受此对话框中的所有其他默认设置，因此点击 **完成**。
- en: As we did with your `MainActivity` class, we will code this class from scratch.
    Therefore, delete the entire code content from `GameActivity.java`.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们在 `MainActivity` 类中所做的那样，我们将从头开始编写这个类。因此，从 `GameActivity.java` 中删除整个代码内容。
- en: What we did
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们所做的工作
- en: Android Studio has generated two more files for us and done some work behind
    the scenes that we will investigate soon. The new files are `GameActivity.java`
    and `activity_game.xml`. They are both automatically opened for us in two new
    tabs, in the same place as the other tabs above the UI designer.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio 已经为我们生成了两个新文件，并在幕后做了一些工作，我们很快将调查这些工作。新文件是 `GameActivity.java`
    和 `activity_game.xml`。它们都自动在我们打开的两个新标签页中打开，位于 UI 设计器上方的其他标签页相同的位置。
- en: We will never need `activity_game.xml` because we will build a dynamically generated
    game view, not a static UI. Feel free to close that now or just ignore it. We
    will come back to the `GameActivity.java` file, when we start to code our game
    for real, later in the chapter in the *Coding the game loop* section.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将永远不会需要 `activity_game.xml`，因为我们将会构建一个动态生成的游戏视图，而不是静态的用户界面。现在可以将其关闭或忽略。我们将在本章的
    *编写游戏循环* 部分开始编写游戏时回到 `GameActivity.java` 文件。
- en: Configuring the AndroidManifest.xml file
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 AndroidManifest.xml 文件
- en: We briefly mentioned that when we create a new project or a new activity, Android
    Studio does more than just creating two files for us. This is why we create new
    projects/activities the way we do.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要地提到，当我们创建一个新的项目或一个新的活动时，Android Studio为我们做的不仅仅是创建两个文件。这就是我们以这种方式创建新项目/活动的原因。
- en: One of the things going on behind the scenes is the creation and modification
    of the `AndroidManifest.xml` file in the `manifests` directory.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后发生的一件事是创建和修改`manifests`目录中的`AndroidManifest.xml`文件。
- en: This file is required for our app to work. Also, it needs to be edited to make
    our app work the way we want it to. Android Studio has automatically configured
    the basics for us, but we will now do two more things to this file.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件对于我们的应用程序正常工作是必需的。此外，它需要被编辑以使我们的应用程序以我们想要的方式工作。Android Studio已经为我们自动配置了基础知识，但现在我们将对此文件进行两项操作。
- en: 'By editing the `AndroidManifest.xml` file, we will force both of our activities
    to run with a full screen, and we will also lock them to a landscape layout. Let''s
    make these changes here:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编辑`AndroidManifest.xml`文件，我们将强制我们的两个活动以全屏运行，并且我们将锁定它们为横幅布局。让我们在这里进行这些更改：
- en: Open the `manifests` folder now, and double click on the `AndroidManifest.xml`
    file to open it in the code editor.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开`manifests`文件夹，双击`AndroidManifest.xml`文件以在代码编辑器中打开它。
- en: 'In the `AndroidManifest.xml` file, find the following line of code:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AndroidManifest.xml`文件中，找到以下代码行：
- en: '[PRE5]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Immediately following it, type or copy and paste these two lines to make `MainActivity`
    run full screen and lock it in the landscape orientation:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 紧接着，输入或复制粘贴以下两行代码，使`MainActivity`全屏运行并锁定在横幅方向：
- en: '[PRE6]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the `AndroidManifest.xml` file, find the following line of code:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AndroidManifest.xml`文件中，找到以下代码行：
- en: '[PRE7]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Immediately following it, type or copy and paste these two lines to make `GameActivity`
    run full screen and lock it in the landscape orientation:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 紧接着，输入或复制粘贴以下两行代码，使`GameActivity`全屏运行并锁定在横幅方向：
- en: '[PRE8]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: What we did
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们所做
- en: We have now configured both activities from our game to be full screen. This
    presents a much more pleasing appearance to our player. In addition, we have disabled
    the player's ability to affect our game by rotating their Android device.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已将我们的游戏中的两个活动配置为全屏。这对玩家来说呈现了一个更加令人愉悦的外观。此外，我们还禁用了玩家通过旋转他们的Android设备来影响我们的游戏的能力。
- en: Coding the game loop
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写游戏循环
- en: We said that we will not be using a UI layout for our game screen, but instead
    a dynamically drawn view. This is where the view of our pattern comes in. Let's
    create a new class to represent our view, then we will put in the fundamental
    building blocks of our Tappy Defender game.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到我们不会为我们的游戏屏幕使用UI布局，而是一个动态绘制的视图。这就是我们的图案视图发挥作用的地方。让我们创建一个新的类来表示我们的视图，然后我们将放入Tappy
    Defender游戏的根本构建块。
- en: Building the view
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建视图
- en: We will leave our two activity classes alone for a while so that we can take
    a look at our class that will represent the view of our game. As we discussed
    at the start of this chapter, the view and the controller aspects will be part
    of the same class.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将暂时不修改我们的两个活动类，以便我们可以查看代表我们游戏视图的类。正如我们在本章开头讨论的那样，视图和控制方面将是同一个类的部分。
- en: The Android API provides us with an ideal class for our requirements. The `android.view.SurfaceView`
    class not only provides us a view that is designed for drawing pixels, text, lines,
    and sprites onto, but also enables us to quickly handle player input as well.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Android API为我们提供了满足我们需求的理想类。`android.view.SurfaceView`类不仅为我们提供了一个用于绘制像素、文本、线条和精灵的视图，而且还使我们能够快速处理玩家输入。
- en: As if this wasn't useful enough, we can also spawn a thread by implementing
    the runnable interface allowing our main game loop to get player input and other
    system essentials at the same time. We will deal with the general structure of
    your new `SurfaceView` implementation now, so we can fill in the details as we
    progress with the project.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎这还不够有用，我们还可以通过实现可运行接口来创建一个线程，使我们的主游戏循环能够同时获取玩家输入和其他系统基本要素。现在，我们将处理您新`SurfaceView`实现的一般结构，以便我们可以在项目进展过程中填写细节。
- en: Creating a new class for the view
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为视图创建一个新类
- en: Without further delay, we can create a new class which extends `SurfaceView`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 不再拖延，我们可以创建一个新的类，该类扩展了`SurfaceView`。
- en: Right-click the folder containing our `.java` files and select **New** | **Java
    Class** then click on **OK**.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击包含我们的`.java`文件的文件夹，选择**新建** | **Java类**，然后点击**确定**。
- en: In the **Create New Class** dialog, name the new class `TDView,` (Tappy Defender
    view). Now, click on **OK** to have Android Studio autogenerate the class.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**创建新类**对话框中，将新类命名为`TDView,`（Tappy Defender视图）。现在，点击**确定**让Android Studio自动生成该类。
- en: 'The new class will open in the code editor. Amend the code to have it extend
    `SurfaceView` and implement `Runnable` as discussed in the previous section. Edit
    the highlighted parts of the code that follows:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新类将在代码编辑器中打开。修改代码，使其扩展`SurfaceView`并实现`Runnable`，如前一小节所述。编辑以下代码的高亮部分：
- en: '[PRE9]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Use the *Alt* | *Enter* combination to import the missing classes.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*Alt* | *Enter*组合来导入缺失的类。
- en: Note that we still have an error in our code. This is because we must provide
    a constructor for our `SurfaceView` implementation. Right-click just below the
    `TDView` class declaration and navigate to **Generate** | **Constructor** | **SurfaceView(Context:context)**.
    Or you can just type this in as shown in the next block of code. Now click on
    **OK**.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，我们代码中仍然存在错误。这是因为我们必须为我们的`SurfaceView`实现提供一个构造函数。在`TDView`类声明下方右键单击，然后导航到**生成**
    | **构造函数** | **SurfaceView(Context:context)**。或者，您也可以像下一个代码块中所示那样直接输入。现在点击**确定**。
- en: What we did
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们所做
- en: We now have a new class called `TDView`, which extends `SurfaceView` for our
    drawing requirements and implements `Runnable` for our threading needs. We have
    also generated a constructor, which we will use soon to initialize our new class.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个名为`TDView`的新类，它扩展了`SurfaceView`以满足我们的绘图需求，并实现了`Runnable`以满足我们的线程需求。我们还生成了一个构造函数，我们将很快使用它来初始化我们的新类。
- en: The `Context` parameter that is passed into our constructor is a reference to
    the current state of our application within the Android system that is held by
    our `GameActivity` class. This `Context` parameter is useful/essential for a number
    of things that we will be implementing throughout this project.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给我们的构造函数的`Context`参数是对Android系统中我们的`GameActivity`类持有的当前应用程序状态的引用。这个`Context`参数对于我们将在这个项目中实现的大量事情非常有用/必要。
- en: 'So far, our `TDView` class will look like this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的`TDView`类将看起来像这样：
- en: '[PRE10]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Structuring the class code
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结构化类代码
- en: Now that we have our `TDView` class extended from the `SurfaceView` class, we
    can start coding it. To control the game, we need to be able to update all the
    game data/objects. This implies an `update` method. In addition, we are obviously
    going to want to draw all our game data once every frame after they have been
    updated. Let's keep all of our drawing code together in a method called `draw`.
    Furthermore, we need to control the frequency with which this happens. Therefore,
    a `control` method seems like it should be part of the class as well.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将`TDView`类扩展为`SurfaceView`类，我们可以开始编写代码了。为了控制游戏，我们需要能够更新所有游戏数据/对象。这意味着需要一个`update`方法。此外，我们显然希望在更新后每帧都绘制所有游戏数据，因此我们将所有的绘图代码放在一个名为`draw`的方法中。此外，我们需要控制这个操作的频率。因此，一个`control`方法似乎也应该成为类的一部分。
- en: We also know that everything needs to happen in your thread; so to achieve this,
    we should wrap the code in the `run` method. Lastly, we need a way to control
    when the thread should and shouldn't do its work so we need an infinite loop controlled
    by a Boolean, perhaps, `playing`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还知道，所有事情都需要在您的线程中发生；因此，为了实现这一点，我们应该将代码包裹在`run`方法中。最后，我们需要一种方式来控制线程何时以及何时不应执行其工作，因此我们需要一个由布尔值控制的无限循环，例如`playing`。
- en: 'Copy the following code into the body of our `TDView` class to implement what
    we just discussed:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码复制到我们的`TDView`类体中，以实现我们刚刚讨论的内容：
- en: '[PRE11]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is the bare-bones of our game. The `run` method will execute in a thread,
    but it will only execute the game loop while the Boolean `playing` instance is
    true. Then, it will update all the game data, draw the screen based on that game
    data, and control how long it is until the `run` method is called again.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们游戏的基础框架。`run`方法将在一个线程中执行，但只有在布尔实例`playing`为真时才会执行游戏循环。然后，它将更新所有游戏数据，根据这些游戏数据绘制屏幕，并控制`run`方法再次被调用的时间。
- en: 'Now, we can quickly build on this code. First of all, we can implement the
    three methods that we call from the `run` method. Type the following code in the
    body of our `TDView` class after closing the curly brace of the `run` method:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以快速构建这段代码。首先，我们可以实现从`run`方法中调用的三个方法。在`run`方法的括号闭合后，在`TDView`类体中输入以下代码：
- en: '[PRE12]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We now need to declare our playing member variable. We can do this using the
    `volatile` keyword as it will be accessed from outside the thread and from within.
    Type this code just after the `TDView` class declaration:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要声明我们的`playing`成员变量。我们可以使用`volatile`关键字来完成，因为它将从线程外部和内部访问。在`TDView`类声明之后立即输入此代码：
- en: '[PRE13]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, we know that we can control the execution of code within the run method
    with the infinite loop and the `playing` variable. We also need to start and stop
    the actual thread itself. Not just when we decide, but when the player unexpectedly
    quits the game. What if he gets a phone call or just taps the home button on his
    device.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道我们可以通过无限循环和`playing`变量来控制`run`方法中的代码执行。我们还需要启动和停止实际的线程本身。不仅在我们决定的时候，而且在玩家意外退出游戏的时候。如果他接到电话或者只是在他的设备上轻触主页按钮会怎样。
- en: 'To handle these events, we need the `TDView` class and `GameActivity` to work
    together. Now, in the `TDView` class, we can implement a `pause` method and a
    `resume` method. Within them, we put the code to stop and start our thread. Implement
    these two methods within the body of the `TDView` class:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这些事件，我们需要`TDView`类和`GameActivity`协同工作。现在，在`TDView`类中，我们可以实现一个`pause`方法和一个`resume`方法。在它们内部，我们放置停止和启动我们的线程的代码。在`TDView`类的主体中实现这两个方法：
- en: '[PRE14]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we need an instance of a `Thread` class called `gameThread`. We can declare
    it as a member variable of `TDView` just after the class declaration, right after
    our Boolean `playing` parameter. Like this:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一个名为`gameThread`的`Thread`类实例。我们可以在类声明之后，紧随我们的布尔`playing`参数之后将其声明为`TDView`的成员变量。如下所示：
- en: '[PRE15]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that the `onPause` and `onResume` methods are public. We can now add code
    to our `GameActivity` class to call these methods at the appropriate time. Remember
    that `GameActivity` extends `Activity`. Therefore, use the overridden `Activity`
    lifecycle methods.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`onPause`和`onResume`方法是公开的。我们现在可以向我们的`GameActivity`类添加代码，在适当的时间调用这些方法。记住，`GameActivity`扩展了`Activity`。因此，使用重写的`Activity`生命周期方法。
- en: By overriding the `onPause` method, whenever the activity is paused, we can
    shut down the thread. This avoids potentially embarrassing the player and having
    to explain to his caller, why they can hear sound FX in the background.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重写`onPause`方法，每当活动暂停时，我们可以关闭线程。这可以避免玩家可能感到尴尬，并不得不向他的呼叫者解释为什么他们能在背景中听到音效。
- en: By overriding `onResume()`, we can have our thread start up in the last phase
    of the Android lifecycle before the app is actually running.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重写`onResume()`，我们可以在Android生命周期中实际运行之前启动线程的最后阶段。
- en: Note
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note the distinction between the `pause` and `resume` methods of the `TDView`
    class and the overridden `onPause` and `onResume` methods of the `GameActivity`
    class.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`TDView`类的`pause`方法和`resume`方法与`GameActivity`类的重写`onPause`和`onResume`方法之间的区别。
- en: The game activity
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏活动
- en: Before you implement/override this method, note that all they will do is call
    the parent version of their respective methods followed by the public methods
    in the `TDView` class to which they correspond.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现/覆盖此方法之前，请注意，它们所做的一切只是调用各自方法的父版本，然后调用它们对应的`TDView`类中的公共方法。
- en: 'You might remember back to the section when we created our new `GameActivity`
    class, we deleted the entire code contents? With that in mind, here is the outline
    of the code we will need in `GameActivity.java` including the implementation of
    the overridden methods within the body of the `GameActivity` class that we discussed
    in the previous section. Type this code in `GameActivity.java`:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得我们创建新的`GameActivity`类时删除了整个代码内容？考虑到这一点，以下是我们在`GameActivity.java`中需要的代码概要，包括在上一节中讨论的`GameActivity`类主体中重写的方法的实现。在`GameActivity.java`中输入此代码：
- en: '[PRE16]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, let''s go ahead and declare an object of the `TDView` class. Do this
    just after the `GameActivity` class declaration:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们继续并声明一个`TDView`类的对象。在`GameActivity`类声明之后立即这样做：
- en: '[PRE17]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, within the `onCreate` method, we need to instantiate your object, keeping
    in mind that your constructor in `TDView.java` takes a `Context` object as an
    argument. Then, we use the newly instantiated object in a call to `setContentView()`.
    Remember when we built our home screen, we called `setContentView()` and passed
    in our UI design. This time, we are setting the player''s view to be the object
    of our `TDView` class. Copy the following code into the `onCreate` method of the
    `GameActivity` class:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`onCreate`方法中，我们需要实例化你的对象，记住在`TDView.java`中的构造函数需要一个`Context`对象作为参数。然后，我们在`setContentView()`调用中使用新实例化的对象。记得当我们构建我们的主页时，我们调用了`setContentView()`并传递了我们的UI设计。这次，我们将玩家的视图设置为我们的`TDView`类的对象。将以下代码复制到`GameActivity`类的`onCreate`方法中：
- en: '[PRE18]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: At this point, we can actually run our game and click on the **Play** button
    to proceed to the `GameView` activity, which will use `TDView` as its view and
    start our thread. Obviously, there is nothing to see yet, so let's work on the
    model of our design pattern and build the basic outline of our first game object.
    At the end of the chapter, we will see how to run the game on an Android device.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们实际上可以运行我们的游戏并点击**播放**按钮来进入`GameView`活动，该活动将使用`TDView`作为其视图并启动我们的线程。显然，目前什么也看不到，所以让我们专注于设计模式的模型部分，并构建我们第一个游戏对象的基本轮廓。在本章结束时，我们将看到如何在Android设备上运行游戏。
- en: The PlayerShip object
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩家飞船对象
- en: We need to keep the model part of our code as separate as possible from the
    rest. We can do this by creating a class for our player's spaceship. Let's call
    our new class `PlayerShip`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要尽可能地将代码的模型部分与其他部分分开。我们可以通过创建一个用于玩家飞船的类来实现这一点。让我们将我们的新类命名为`PlayerShip`。
- en: Go ahead and add a new class to the project, and call it `PlayerShip`. Here
    are a few quick steps on how to do that. Now, right-click the folder with our
    `.java` files in it and navigate to **New** | **Java Class**, then enter `PlayerShip`
    as the name and click on **OK**.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在请向项目中添加一个新的类，并将其命名为`PlayerShip`。以下是完成此操作的几个快速步骤。现在，右键单击包含我们的`.java`文件的文件夹，导航到**新建**
    | **Java类**，然后输入`PlayerShip`作为名称，点击**确定**。
- en: 'What do we need our `PlayerShip` class to be able to know about itself? As
    a bare minimum it needs to:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要我们的`PlayerShip`类能够了解关于自己的什么？作为最低要求，它至少需要能够：
- en: Know where it is on the screen
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道它在屏幕上的位置
- en: What it looks like
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它看起来像什么
- en: How fast it is flying
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它飞行的速度有多快
- en: 'These requirements suggest a few member variables we can declare. Enter the
    code just after the class declaration that we generated:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这些要求表明我们可以声明几个成员变量。在我们生成的类声明之后输入代码：
- en: '[PRE19]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As usual, use the *Alt* | *Enter* keyboard combination to import any missing
    classes. In the previous block of code, we see that we have declared an object
    of type `Bitmap` that we will use to hold the graphic which represents our ship.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，使用*Alt* | *Enter*键盘组合导入任何缺少的类。在之前的代码块中，我们看到我们声明了一个类型为`Bitmap`的对象，我们将使用它来存储代表我们的船的图形。
- en: We have also declared three `int` type variables; `x` and `y` to hold the spaceship's
    screen coordinates and another `int` type variable, `speed` to hold a value for
    how fast our spaceship is traveling.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还声明了三个`int`类型的变量；`x`和`y`用于存储飞船的屏幕坐标，另一个`int`类型的变量`speed`用于存储飞船移动的速度值。
- en: 'Now, let''s consider what our `PlayerShip` class needs to do. Again as a bare
    minimum it needs to:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑我们的`PlayerShip`类需要做什么。再次作为最低要求，它至少需要做到：
- en: Prepare itself
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备自己
- en: Update itself
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新自己
- en: Share it's state with our view
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与我们的视图共享其状态
- en: A constructor seems to be the ideal place to prepare itself. We can initialize
    its `x` and `y` coordinate variables and set a starting speed with the `speed`
    variable.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数似乎是准备自己的理想位置。我们可以初始化其`x`和`y`坐标变量，并使用`speed`变量设置一个起始速度。
- en: The other thing the constructor will need to do is to load the bitmap graphic,
    which represents its appearance. To load bitmaps, we require an Android `Context`
    object. This implies that the constructor that we write will need to receive a
    `Context` object from our view.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数还需要做的一件事是加载表示其外观的位图图形。加载位图需要Android的`Context`对象。这意味着我们编写的构造函数将需要从我们的视图中接收一个`Context`对象。
- en: 'With all this in mind, here is our `PlayerShip` constructor to implement point
    one from our to-do list:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些，以下是我们的`PlayerShip`构造函数，以实现待办事项列表中的第一点：
- en: '[PRE20]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As usual, we need to import some new classes using the *Alt* | *Enter* combination.
    After importing all the new classes required by the line which initializes our
    bitmap object, we can see we still have an error; `Cannot resolve symbol ship`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常一样，我们需要使用 *Alt* | *Enter* 组合键导入一些新的类。在导入初始化我们的位图对象的行所需的所有新类之后，我们可以看到我们仍然有一个错误；`Cannot
    resolve symbol ship`。
- en: Let's dissect the line that loads the ship bitmap as we will be seeing this
    quite a lot throughout the book.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析加载飞船位图的行，因为我们将在整本书中多次看到它。
- en: The `BitmapFactory` class is using its static method `decodeResource()` to attempt
    to load our graphic of the player ship. It requires two parameters. The first
    is the `getResources` method supplied by the `Context` object that was passed
    from the view.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`BitmapFactory` 类正在使用其静态方法 `decodeResource()` 尝试加载我们的玩家飞船图形。它需要两个参数。第一个是来自传递给视图的
    `Context` 对象提供的 `getResources` 方法。'
- en: The second parameter `R.drawable.ship` is requesting a graphic called `ship`
    from the (R)esource folder named `drawable`. All we have to do to resolve this
    error is to copy our graphic, named `ship.png`, into the `drawable` folder of
    our project.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数 `R.drawable.ship` 是从名为 `drawable` 的（R）资源文件夹请求一个名为 `ship` 的图形。要解决这个错误，我们只需要将我们的图形
    `ship.png` 复制到项目的 `drawable` 文件夹中。
- en: 'Simply drag and drop/copy and paste the `ship.png` graphic contained in the
    `Chapter2/drawable` folder from the download bundle into the `res/drawable` folder
    in the Android Studio project explorer window. The following is a `ship.png` image:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地将 `Chapter2/drawable` 文件夹中包含的 `ship.png` 图形从下载包拖放到 Android Studio 项目资源管理器窗口中的
    `res/drawable` 文件夹。以下是一个 `ship.png` 图像：
- en: '![The PlayerShip object](img/B04322_02_10.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![玩家飞船对象](img/B04322_02_10.jpg)'
- en: 'Number two on our list of things that `PlayerShip` needs to do is, to update
    itself. Let''s implement a public `update` method that can be called from our
    `TDView` class. The method will simply increment the ship''s *x* value by 1 each
    time it is called. Clearly, we need to get more advanced than this. For now implement
    the method in the `PlayerShip` class like this:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们列表中 `PlayerShip` 需要做的第二件事是更新自己。让我们实现一个公共的 `update` 方法，可以从我们的 `TDView` 类中调用。每次调用该方法时，它将简单地增加飞船的
    *x* 值 1。显然，我们需要比这更高级。现在，在 `PlayerShip` 类中按如下方式实现该方法：
- en: '[PRE21]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Number three on the to-do list is to share its state with the view. We can
    do this by providing a bunch of getter methods like this:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 待办事项列表中的第三项是将其状态与视图共享。我们可以通过提供一些类似这样的获取器方法来实现：
- en: '[PRE22]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now your `TDView` class can be instantiated, and find out what it likes about
    any `PlayerShip` objects. However, only the `PlayerShip` class itself can decide
    how it should look, what properties it has, and how it behaves.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的 `TDView` 类可以被实例化，并找出它对任何 `PlayerShip` 对象的喜好。然而，只有 `PlayerShip` 类本身可以决定它应该看起来像什么，它有什么属性，以及它的行为方式。
- en: We can see how we will draw our player's ship to the screen and animate it as
    well.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们将如何将玩家的飞船绘制到屏幕上，并对其进行动画处理。
- en: Drawing the scene
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制场景
- en: As we will see, drawing a bitmap is really trivial. But the coordinate system
    that we use to draw our graphics onto needs a brief explanation.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将看到的，绘制位图实际上是非常简单的。但我们将用于在图形上绘制坐标系的系统需要简要说明。
- en: Plotting and drawing
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘图和绘制
- en: When we draw a `Bitmap` object to the screen, we pass in the coordinates we
    want to draw the object at. The available coordinates of a given Android device
    depend on the resolution of its screen.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将 `Bitmap` 对象绘制到屏幕上时，我们传递想要绘制对象的坐标。给定 Android 设备的可用坐标取决于其屏幕的分辨率。
- en: For example, the Samsung Galaxy S4 phone has a screen resolution of 1920 pixels
    (across) by 1080 pixels (down) when held in a landscape view.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当三星 Galaxy S4 手机以横向视图持有时，其屏幕分辨率为 1920 像素（宽）和 1080 像素（高）。
- en: The numbering system of these coordinates starts in the top-left hand corner
    at 0,0 and proceeds down and to the right until the bottom right corner is pixel
    1919, 1079\. The apparent 1 pixel disparity between 1920/ 1919 and 1080/ 1079
    is because the numbering starts at 0.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这些坐标的编号系统从左上角的 0,0 开始，向下和向右延伸，直到右下角是像素 1919, 1079。1920/ 1919 和 1080/ 1079 之间明显的
    1 像素差异是因为编号从 0 开始。
- en: Therefore, when we draw a bitmap or any other drawable to the screen, we must
    specify *x*, *y* coordinates.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们绘制位图或其他可绘制对象到屏幕上时，我们必须指定 *x*，*y* 坐标。
- en: Furthermore, a bitmap is, of course, comprised of many pixels. So which pixel
    of a given bitmap is drawn at the *x*, *y* screen coordinate that we will be specifying?
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，位图当然由许多像素组成。所以，给定位图的哪个像素将被绘制到我们将指定的*x*，*y*屏幕坐标上？
- en: The answer is the top-left pixel of the `Bitmap` object. Take a look at the
    next image, which should clarify the screen coordinates using the Samsung Galaxy
    S4 as an example.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是`Bitmap`对象的最左上角像素。看看下一张图，它应该会使用三星Galaxy S4作为示例来阐明屏幕坐标。
- en: '![Plotting and drawing](img/B04322_02_10b.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![绘图和绘制](img/B04322_02_10b.jpg)'
- en: For now, when drawing just a single ship at an arbitrary location, this information
    is of little consequence. It will become more important in the next chapter, when
    we start constraining our graphics to the visible screen and respawning them when
    they disappear.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，当我们只在任意位置绘制一艘船时，这些信息意义不大。在下一章，当我们开始将我们的图形限制在可见屏幕上，并在它们消失时重新生成它们时，它将变得更加重要。
- en: So let's just bare this in mind and get on with drawing our ship to the screen.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们记住这一点，继续将我们的船绘制到屏幕上。
- en: Drawing PlayerShip
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制玩家船
- en: 'Now that we know all this, we can add some code to our `TDView` class, so we
    can see our `PlayerShip` class in action. First, we need a new `PlayerShip` object
    with class scope. The following code is the `TDView` class declaration:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了所有这些，我们可以在`TDView`类中添加一些代码，这样我们就可以看到`PlayerShip`类的实际效果。首先，我们需要一个具有类作用域的新`PlayerShip`对象。以下代码是`TDView`类的声明：
- en: '[PRE23]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We also need a bunch of objects that we haven't seen yet to help us actually
    do some drawing. We need a canvas and some paint.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一些我们尚未见过的对象来帮助我们实际进行绘图。我们需要一个画布和一些画笔。
- en: The Canvas and Paint objects
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 画布和画笔对象
- en: The aptly named `Canvas` class provides just what you will expect—a virtual
    canvas to draw our graphics upon.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 命名恰当的`Canvas`类提供了你所期望的——一个虚拟画布，我们可以在此画布上绘制我们的图形。
- en: We can make a virtual canvas using the `Canvas` class and project it onto our
    `SurfaceView` object which is the view of your `GameActivity` class. We can actually
    add `Bitmap` objects and even manipulate individual pixels on our `Canvas` object
    using methods from our `Paint` object. In addition, we also need an object of
    the `SurfaceHolder` class. This allows us to lock your `Canvas` object while we
    are manipulating it and unlock it when we are ready to draw the frame.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Canvas`类创建一个虚拟画布，并将其投影到我们的`SurfaceView`对象上，这是你的`GameActivity`类的视图。我们实际上可以在我们的`Canvas`对象上添加`Bitmap`对象，甚至使用我们的`Paint`对象的方法来操纵单个像素。此外，我们还需要一个`SurfaceHolder`类的对象。这允许我们在操作`Canvas`对象时锁定它，并在我们准备好绘制帧时解锁它。
- en: 'We will see in more detail how these classes work as we proceed. Type this
    code immediately following the previous line of code we typed:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的过程中更详细地了解这些类是如何工作的。在输入上一行代码后立即输入以下代码：
- en: '[PRE24]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As usual, we need to use the *Alt | Enter* keyboard combination to import some
    new classes for the two lines of code that follow. From this point on, we will
    save digital link and just assume that you know to do this each time you add a
    new class.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我们需要使用*Alt | Enter*键盘组合来导入接下来的两行代码所需的一些新类。从这一点开始，我们将保存数字链接，并假设你知道每次添加新类时都要这样做。
- en: 'Next, we need to set up to prepare for drawing. The best place to do this is
    in the `TDView()`, constructor. Type the following code to prepare our `Paint`
    and `SurfaceHolder` objects for action:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置以准备绘图。最好的地方是在`TDView()`构造函数中这样做。输入以下代码以准备我们的`Paint`和`SurfaceHolder`对象以进行操作：
- en: '[PRE25]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Immediately after the previous line of code, we can at last call `new()` to
    initialize our `PlayerShip` object:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一行代码之后，我们最终可以调用`new()`来初始化我们的`PlayerShip`对象：
- en: '[PRE26]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, we can jump to our `TDView` class''s `update` method and do this:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以跳转到`TDView`类的`update`方法并执行以下操作：
- en: '[PRE27]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: That's it. The `PlayerShip` class (part of the model) knows what to do, and
    we can add all kinds of artificial intelligence into our `PlayerShip` class. The
    `TDView` class (the controller) just says when it is time to update. You can easily
    imagine that all we need to do is create lots of different game objects with different
    properties and behaviors and call their `update` methods once per frame.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。`PlayerShip`类（模型的一部分）知道该做什么，我们可以在`PlayerShip`类中添加各种人工智能。`TDView`类（控制器）只是说何时更新。你可以很容易地想象，我们所需做的就是创建具有不同属性和行为的大量不同游戏对象，并在每一帧调用它们的`update`方法。
- en: 'Now, jump to the `TDView` class''s `draw` method. Let''s draw our `player`
    object by performing the following:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，跳转到`TDView`类的`draw`方法。让我们通过以下操作来绘制我们的`player`对象：
- en: Check that our `SurfaceHolder` class is valid.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认我们的`SurfaceHolder`类是有效的。
- en: Lock the `Canvas` object.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 锁定`Canvas`对象。
- en: Clear the screen with a call to `drawColor()`.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用`drawColor()`清除屏幕。
- en: Splash some virtual paint on it by calling `drawBitmap()` and passing in the
    `PlayerShip` bitmap and an *x*, *y* coordinate.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用`drawBitmap()`并传入`PlayerShip`位图以及*x*，*y*坐标，在其上泼溅一些虚拟油漆。
- en: Finally, unlock the `Canvas` object and draw the scene.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，解锁`Canvas`对象并绘制场景。
- en: 'To achieve these things, type this code in the `draw` method:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这些，请在`draw`方法中输入以下代码：
- en: '[PRE28]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: At this point, we can actually run the game. If our eyesight is fast enough
    or our Android device slow enough, we will just about see our player spaceship
    fly across the screen with immense speed.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，我们实际上可以运行游戏。如果我们的视力足够快或者我们的Android设备足够慢，我们几乎可以看到我们的玩家宇宙飞船以极快的速度飞越屏幕。
- en: There is just one more thing to do before we deploy our game so far.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将游戏部署之前，还有一件事要做。
- en: Controlling the frame rate
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制帧率
- en: The reason we can barely see anything is that even though we only move our ship
    at one pixel per frame along the *x* axis (in the `PlayerShip` class's `update`
    method), our thread is calling the `run` method in an unrestricted manner. This
    is probably happening hundreds of times per second. What we need to do is control
    this rate.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎看不到任何东西的原因是，尽管我们只在每一帧沿着*x*轴（在`PlayerShip`类的`update`方法中）移动我们的船一个像素，但我们的线程以无限制的方式调用`run`方法。这可能在每秒发生数百次。我们需要做的是控制这个速率。
- en: 'Sixty frames per second (FPS) is a reasonable goal. This goal implies the need
    for timing. The Android system measures time in milliseconds (thousandths of a
    second). Therefore, we can add the following code to the `control` method:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 每秒60帧（FPS）是一个合理的目标。这个目标意味着需要计时。Android系统以毫秒（千分之一秒）为单位测量时间。因此，我们可以将以下代码添加到`control`方法中：
- en: '[PRE29]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding code, we paused the thread for 17 milliseconds (*1000(milliseconds)/60(FPS)*)
    by calling `gameThread.sleep` with `17` as the argument to the method. We wrap
    the code within a `try`/`catch` block.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们通过调用`gameThread.sleep`并将`17`作为方法参数，使线程暂停了17毫秒（*1000（毫秒）/60（FPS）*）。我们将代码包裹在一个`try`/`catch`块中。
- en: Deploying the game
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署游戏
- en: Now, we can run our game to see our spaceship floating through space (starting
    at 50 pixels on the *x* axis and 50 pixels on the *y* axis).
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行我们的游戏，看到我们的宇宙飞船在太空中漂浮（从*x*轴上的50像素和*y*轴上的50像素开始）。
- en: Android Studio enables us to fairly quickly create emulators, on which we can
    test our games on a development PC. However, even the most simple of games will
    not run well on an emulator. When we start testing things like player input, the
    experience is so awful that it is best to avoid using emulators completely.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio使我们能够相当快速地创建模拟器，在开发PC上测试我们的游戏。然而，即使是最简单的游戏在模拟器上运行也不会很好。当我们开始测试像玩家输入这样的东西时，体验如此糟糕，最好完全避免使用模拟器。
- en: The solution is to carry out debugging on a real Android device. It is very
    easy to prepare for this.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是在真实的Android设备上进行调试。为此做准备非常容易。
- en: Debugging on an Android device
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Android设备上调试
- en: The first thing to do is to visit your device manufacturer's website and obtain
    and install any drivers that are required for your device and operating system.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 首件事是访问您的设备制造商的网站，获取并安装您设备和操作系统所需的任何驱动程序。
- en: The next few steps will setup the Android device for debugging. Note that different
    manufacturers structure the menu options slightly differently than others. The
    following sequence is probably very close, if not exact to enable debugging on
    most devices.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几个步骤将为调试设置Android设备。请注意，不同制造商的菜单选项结构可能略有不同。以下序列可能非常接近，如果不是完全相同，以在大多数设备上启用调试。
- en: Tap the **Settings** menu option or the **Settings** app.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**设置**菜单选项或**设置**应用。
- en: Tap **Developer** options.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**开发者**选项。
- en: Tap the checkbox for **USB Debugging**.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**USB调试**的复选框。
- en: Connect your Android device to the USB port of your development system. The
    next image shows on the Android tab. At the bottom of the Android Studio UI, you
    can see that **Samsung GT-I9100 Android 4.1.2 (API 16)** has been detected:![Debugging
    on an Android device](img/B04322_02_11.jpg)
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的Android设备连接到开发系统的USB端口。下一张图片显示了Android选项卡。在Android Studio UI的底部，您可以看到已检测到**三星GT-I9100
    Android 4.1.2（API 16）**：![在Android设备上调试](img/B04322_02_11.jpg)
- en: Click on the **Play** icon from the Android Studio toolbar:![Debugging on an
    Android device](img/B04322_02_12.jpg)
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击Android Studio工具栏中的**播放**图标：![在Android设备上调试](img/B04322_02_12.jpg)
- en: When prompted, click on **OK** to run the game on your chosen device.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当提示时，点击**OK**以在所选设备上运行游戏。
- en: 'The game will now run on the device. Any output or errors can be seen in the
    **logcat** window, also on the **Android** tab:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏现在将在设备上运行。任何输出或错误都可以在**logcat**窗口中看到，也在**Android**标签页上：
- en: '![Debugging on an Android device](img/B04322_02_13.jpg)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![在Android设备上调试](img/B04322_02_13.jpg)'
- en: Watch with awe as our player's spaceship moves slowly from left to right.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 惊叹地看着我们的玩家飞船从左到右缓慢移动。
- en: Summary
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we spent a lot of time setting up the structure, game loop,
    and thread. We also spent time handling the Android Activity lifecycle.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们花费了大量时间设置结构、游戏循环和线程。我们还花费时间处理Android Activity生命周期。
- en: Now, we have all this in place, and we can easily start adding more game objects
    to make Tappy Defender quickly feel more like a real game in the next chapter.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经有了所有这些，我们可以轻松地开始添加更多游戏对象，使Tappy Defender在下一章中快速感觉更像一个真正的游戏。
- en: Chapter 3. Tappy Defender – Taking Flight
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。Tappy Defender –起飞
- en: We are now ready to quickly add a lot of new objects and some features as well.
    By the end of this chapter, we will be really close to a playable game. We will
    detect the player touching the screen, so he can control the spaceship. We will
    add virtual boosters to our `SpaceShip` class to move the ship up and down and
    increase the speed.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以快速添加许多新对象和一些功能。到本章结束时，我们将非常接近一个可玩的游戏。我们将检测玩家触摸屏幕，以便他可以控制飞船。我们将在`SpaceShip`类中添加虚拟加速器，以使飞船上下移动并增加速度。
- en: We will then detect the resolution of the Android device and use it to do things
    like prevent the player boosting off the screen, and to detect when our enemies
    need to respawn.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将检测Android设备的分辨率，并使用它来做诸如防止玩家从屏幕上加速，以及检测敌人何时需要重生的事情。
- en: We will create a new `EnemyShip` class, which will represent the suicidal enemies.
    We will also see how we can easily spawn and then control them without changing
    any of the logic from the control part of our code.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的`EnemyShip`类，它将代表自杀式敌人。我们还将看到我们如何可以轻松地生成并控制它们，而无需更改代码控制部分中的任何逻辑。
- en: We will add a scrolling effect by adding a `SpaceDust` class and spawning dozens
    of them to make it look like the player is whizzing through space.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过添加`SpaceDust`类并生成数十个来添加滚动效果，使其看起来像玩家正在飞快地穿过太空。
- en: Finally, we will learn about, and implement, collision detection so we know
    when our player has been hit by an enemy, as well as look at a graphical trick
    to help us with debugging our collision detection code.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将了解并实现碰撞检测，这样我们就知道玩家是否被敌人击中，以及查看一个图形技巧，帮助我们调试碰撞检测代码。
- en: Controlling the spaceship
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制飞船
- en: We have our player's spaceship floating aimlessly on the screen starting 50
    pixels from the left and 50 pixels from the top and drifting slowly to the right.
    Now, we can give the player the power to control the spaceship.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 我们玩家的飞船现在在屏幕上无目的地漂浮，从左边50像素和顶部50像素开始，缓慢向右漂移。现在，我们可以给玩家控制飞船的能力。
- en: Remember the design for the controls is a one finger tap and hold to boost,
    release to quit boosting and decelerate.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 记住控制的设计是一个手指轻触并保持以加速，释放以停止加速并减速。
- en: Detecting touches
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测触摸
- en: The `SurfaceView` class that we extended for our view is perfect for handling
    screen touches.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们扩展的`SurfaceView`类非常适合处理屏幕触摸。
- en: 'All we need to do is override the `onTouchEvent` method within our `TDView`
    class. Let''s see the code in full, and then we can examine it more closely to
    make sure we understand what is going on. Enter this method in the `TDView` class
    and import the necessary classes in the usual way. I have highlighted the parts
    of the code that we will be customizing later:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的就是在我们`TDView`类中重写`onTouchEvent`方法。让我们看看完整的代码，然后我们可以更仔细地检查它，以确保我们理解正在发生的事情。在`TDView`类中输入此方法，并按常规方式导入必要的类。我已经突出显示了我们将稍后自定义的代码部分：
- en: '[PRE30]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This is how the `onTouchEvent` method works so far. The player touches the screen;
    this can be any kind of contact at all. It could be a swipe, a pinch, multiple
    fingers, and so on. A detailed message is sent to the `onTouchEvent` method.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`onTouchEvent`方法目前的工作方式。玩家触摸屏幕；这可以是任何类型的接触。它可能是一划、一捏、多指等等。一个详细的消息被发送到`onTouchEvent`方法。
- en: The details of the event are contained in the `MotionEvent` class parameter,
    as we can see in our code. The `MotionEvent` class holds lots of data. It knows
    how many fingers were placed on the screen, the coordinates of each, and if any
    gestures were made as well.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 事件的详细信息包含在 `MotionEvent` 类参数中，正如我们在代码中所看到的。`MotionEvent` 类包含大量数据。它知道屏幕上有多少个手指，每个手指的坐标，以及是否进行了任何手势。
- en: As we are implementing a simple tap and hold to boost, release to stop boosting
    control scheme; we can simply switch using the `motionEvent.getAction() & MotionEvent.ACTION_MASK`
    condition and cater for just two of many possible different cases.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在实现一个简单的点击并保持以加速，释放以停止加速的控制方案；我们可以简单地使用 `motionEvent.getAction() & MotionEvent.ACTION_MASK`
    条件进行切换，并处理许多可能的不同情况中的两种。
- en: The case `MotionEvent.ACTION_UP:` will, as the name suggests, tell us when the
    player removes a finger from the screen. Then, perhaps unsurprisingly, case `MotionEvent.ACTION_DOWN:`
    tells us if the player places a finger on the screen.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家从屏幕上移除手指时，`MotionEvent.ACTION_UP:` 事件，正如其名称所暗示的，会告诉我们这一点。然后，也许不出所料，`MotionEvent.ACTION_DOWN:`
    事件会告诉我们玩家是否在屏幕上放置了手指。
- en: Note
  id: totrans-392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'What we can find out through the `MotionEvent` class is quite vast. Why not
    take a look at the full scope of its potential here: [http://developer.android.com/reference/android/view/MotionEvent.html](http://developer.android.com/reference/android/view/MotionEvent.html).
    We will also explore this class further in the next project that we start to build
    in [Chapter 5](ch14.html "Chapter 5. Platformer – Upgrading the Game Engine"),
    *Platformer – Upgrading the Game Engine*.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 `MotionEvent` 类得知的信息非常广泛。为什么不在这里看看其全部潜在范围：[http://developer.android.com/reference/android/view/MotionEvent.html](http://developer.android.com/reference/android/view/MotionEvent.html)。我们还会在下一章中进一步探讨这个类，我们将在
    [第 5 章](ch14.html "第 5 章。平台游戏 – 升级游戏引擎") 开始构建的项目中构建 *平台游戏 – 升级游戏引擎*。
- en: Adding boosters to the spaceship
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为飞船添加加速器
- en: 'Now, all we need to do is think about how we will use these events to control
    the spaceship. First of all, the spaceship needs to know if it is boosting or
    not boosting. This suggests a Boolean member variable. Add this code just after
    the class declaration in the `PlayerShip` class:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要考虑我们将如何使用这些事件来控制飞船。首先，飞船需要知道它是否在加速。这暗示了一个布尔成员变量。在 `PlayerShip` 类声明之后添加此代码：
- en: '[PRE31]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We then need to initialize it when a `PlayerShip` object is created. So add
    this to the `PlayerShip` constructor:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要在创建 `PlayerShip` 对象时对其进行初始化。因此，将以下代码添加到 `PlayerShip` 构造函数中：
- en: '[PRE32]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, we need to let the `onTouchEvent` method toggle `boosting` between true
    and false, boosting and not boosting. Add these methods to the `PlayerShip` class:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要让 `onTouchEvent` 方法在 `boosting` 之间切换为 true 和 false，即加速和不加速。将这些方法添加到 `PlayerShip`
    类中：
- en: '[PRE33]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, we can call these public methods from our `onTouchEvent` method to control
    the state of whether the spaceship is boosting or not. Add this new code in the
    `onTouchEvent` method:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以从 `onTouchEvent` 方法中调用这些公共方法来控制飞船是否在加速的状态。在 `onTouchEvent` 方法中添加以下新代码：
- en: '[PRE34]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, our view is talking to our model; all we need to do is make the boosting
    variable do something depending on which state it is in. The logical place for
    this code will be the `PlayerShip` class's `update` method.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的视图正在与我们的模型进行通信；我们只需要让加速变量根据其所在的状态做些事情。这段代码的逻辑位置将在 `PlayerShip` 类的 `update`
    方法中。
- en: 'We will change the `speed` variable of our spaceship based on whether the ship
    is currently boosting. At first this seems simple, but there are a few minor issues
    with just increasing the speed based on whether the ship is boosting:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将根据飞船是否正在加速来改变飞船的 `speed` 变量。起初这似乎很简单，但仅仅根据飞船是否加速来增加速度有几个小问题：
- en: One problem is that the `update` method is called 60 times every second. So,
    it wouldn't take much boosting to have the ship flying at ridiculous speeds. We
    need to constrain the ship's speed.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个问题是，`update` 方法每秒被调用 60 次。因此，要让飞船以荒谬的速度飞行，不需要太大的提升。我们需要限制飞船的速度。
- en: Another problem is that our spaceship will rise up the screen when boosting,
    and there is nothing to stop it whizzing straight off the top of the screen, never
    to be seen again. We need to constrain the ship's *x* and *y* coordinates within
    the screen.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个问题是我们的小飞船在加速时会上升屏幕，而且没有任何东西可以阻止它直接飞出屏幕顶部，从此消失。我们需要将飞船的 *x* 和 *y* 坐标限制在屏幕内。
- en: When the ship is not boosting and the speed steadily returns to zero, what will
    bring the ship back down again? We will need a simple gravity physics simulation.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当飞船不加速且速度稳步回到零时，什么会再次将飞船降下来？我们需要一个简单的重力物理模拟。
- en: To solve these three problems, we can add code to our `PlayerShip` class. However,
    before we do this, a quick word about gameplay balance. The code which we will
    see very soon uses different integer values, for example, we initialize `GRAVITY`
    to `-12` and `MAX_SPEED` to `20`. These numbers have no bearing in reality!
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这三个问题，我们可以在`PlayerShip`类中添加代码。然而，在我们这样做之前，我们先简单谈谈游戏平衡。我们很快就会看到的代码使用了不同的整数值，例如，我们将`GRAVITY`初始化为`-12`，将`MAX_SPEED`初始化为`20`。这些数字在现实中没有任何意义！
- en: They are simply the arbitrary numbers that make the gameplay balanced. Feel
    free to play with all these arbitrary figures to make the game harder, easier,
    or even impossible. At the end of [Chapter 4](ch13.html "Chapter 4. Tappy Defender
    – Going Home"), *Tappy Defender – Going Home*, we will look more closely at game
    iteration and look again at difficulty and balance.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是使游戏平衡的任意数字。您可以随意调整所有这些任意数字，使游戏更难、更容易，甚至不可能。在[第4章](ch13.html "第4章。Tappy Defender
    – Going Home")“Tappy Defender – Going Home”的结尾，我们将更仔细地研究游戏迭代，并再次看看难度和平衡。
- en: 'With three of our previously stated problems in mind, add the following member
    variables just after the class declaration in the `PlayerShip` class:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在心中牢记我们之前提到的三个问题，在`PlayerShip`类声明之后添加以下成员变量：
- en: '[PRE35]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, we made a start to solve our three problems, we can add code to our `PlayerShip`
    class''s `update` method. We will delete the one line of code, we put in there
    in the previous chapter. That was just there to take a quick look at our ship
    in action. Enter the new code of our `PlayerShip` class''s `update` method. We
    will take a closer look afterward:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经开始解决我们的三个问题，我们可以在`PlayerShip`类的`update`方法中添加代码。我们将删除上一章中添加的那一行代码。那只是为了快速查看我们的飞船在行动中的样子。接下来，我们将查看`PlayerShip`类的`update`方法的新代码。稍后我们会更详细地研究：
- en: '[PRE36]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In order from the top of the previous block of code, we are increasing and decreasing
    the speed variable by apparently arbitrary amounts, each frame of the game, based
    on if the ship is boosting or not.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一块代码的顶部开始，我们根据飞船是否加速，在每一帧游戏中以看似随意的数量增加和减少速度变量。
- en: We then constrain the speed of the ship to a maximum of 20 and a minimum of
    1, as specified by the variables we added earlier. With the line `y -= speed +
    GRAVITY`, we move the graphic on screen either up or down based on speed and gravity.
    The apparently arbitrary values for `GRAVITY` and `MAX_SPEED` work nicely to allow
    the player to awkwardly and precariously bounce along through space.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将飞船的速度限制在之前添加的变量指定的最大20和最小1之间。通过`y -= speed + GRAVITY`这一行代码，我们根据速度和重力将屏幕上的图形向上或向下移动。`GRAVITY`和`MAX_SPEED`的看似随意的值非常适合让玩家笨拙且危险地在太空中弹跳。
- en: Finally, we stop the ship from ever disappearing off the screen by making sure
    the ship graphic is never drawn beyond `maxY` and `minY`. You have probably noticed
    that, as of yet, we haven't initialized `maxY` and `minY`. Furthermore, what will
    we initialize them to anyway as many Android devices have vastly different screen
    resolutions?
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过确保飞船图形永远不会超出`maxY`和`minY`来阻止飞船从屏幕上消失。您可能已经注意到，到目前为止，我们还没有初始化`maxY`和`minY`。此外，我们到底要将它们初始化为多少，因为许多Android设备的屏幕分辨率差异很大？
- en: What we need to do is discover the resolution of the Android device at run time
    and use the information to initialize `MaxY` and `minY`.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的是在运行时发现Android设备的分辨率，并使用这些信息来初始化`MaxY`和`minY`。
- en: Detecting the screen resolution
  id: totrans-418
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测屏幕分辨率
- en: We know that we need the maximum *y* coordinate of the player's screen. Later
    in the project when we start adding backgrounds and enemy ships, we will realize
    that we also need the maximum *x* coordinate as well. With this in mind, let's
    see how we can get this information and make it available to the `PlayerShip`
    class.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们需要玩家屏幕的最大*y*坐标。在项目后期，当我们开始添加背景和敌舰时，我们会意识到我们还需要最大*x*坐标。考虑到这一点，让我们看看我们如何获取这些信息，并将其提供给`PlayerShip`类。
- en: 'The most expedient time to detect the screen resolution is as the app is starting,
    and before our view and the model have been instantiated. This implies that our
    `GameActivity` class is a good place to do it. We will now add code to the `onCreate`
    method of the `GameActivity` class. Add this new code to the `onCreate` class,
    before the call to `new...` that creates our `TDView` object:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 检测屏幕分辨率最方便的时间是在应用启动时，在我们视图和模型实例化之前。这意味着我们的 `GameActivity` 类是做这件事的好地方。我们现在将向
    `GameActivity` 类的 `onCreate` 方法中添加代码。将以下新代码添加到 `onCreate` 类中，在调用 `new...` 创建我们的
    `TDView` 对象之前：
- en: '[PRE37]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The previous code declares and initializes an object of the `Display` type using
    `getWindowManager().getDefaultDisplay();`. Then we create a new object of type
    `Point`. The `Point` object can hold two coordinates and we then pass it as an
    argument into the `getSize` method of our new `Display` object.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码使用 `getWindowManager().getDefaultDisplay();` 声明并初始化了一个 `Display` 类型的对象。然后我们创建了一个新的
    `Point` 类型的对象。`Point` 对象可以存储两个坐标，然后我们将它作为参数传递给我们的新 `Display` 对象的 `getSize` 方法。
- en: 'We now have the resolution of the Android device our game is running on, neatly
    stored in `size`. Now pass this on to the parts of our code which require it.
    First, we will change the arguments we pass in the call to `new`, which initializes
    our `TDView` object. Change the call to `new` as shown next to pass in the screen
    resolution to the `TDView` constructor:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将运行游戏的 Android 设备的分辨率整洁地存储在 `size` 中。现在将这个值传递到需要它的代码部分。首先，我们将更改传递给 `new`
    调用的参数，该调用初始化我们的 `TDView` 对象。按照下面的说明更改 `new` 调用来将屏幕分辨率传递给 `TDView` 构造函数：
- en: '[PRE38]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, of course, we need to update the `TDView` constructor itself. In the
    `TDView.java` file, amend the `TDView` constructor''s signature so that the declaration
    now looks like this:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当然，我们需要更新 `TDView` 构造函数本身。在 `TDView.java` 文件中，修改 `TDView` 构造函数的签名，使其现在看起来像这样：
- en: '[PRE39]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, still in the constructor, change the way we initialize the player of our
    `PlayerShip` object:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，仍然在构造函数中，改变我们初始化 `PlayerShip` 对象玩家的方式：
- en: '[PRE40]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Of course, we must now amend the constructor declaration within the `PlayerShip`
    class itself, to this:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们现在必须修改 `PlayerShip` 类本身的构造函数声明，如下所示：
- en: '[PRE41]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In addition, we can now initialize our `maxY` and `minY` variables within the
    `PlayerShip` constructor. Before we see the code, we need to consider exactly
    how this will work.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以在 `PlayerShip` 构造函数中初始化 `maxY` 和 `minY` 变量。在我们看到代码之前，我们需要考虑这究竟是如何工作的。
- en: 'The coordinates of the bitmap that holds our spaceship graphic is drawn with
    the top-left corner at the *x = 0* and *y = 0* coordinates passed in to `drawBitmap()`
    in the `TDView` class''s `draw` method. This means that there are pixels off to
    the right and after the coordinates at which we begin to draw the ship. Take a
    look at this next image to visualize this:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 包含我们的宇宙飞船图形的位图的坐标是在 `TDView` 类的 `draw` 方法中通过传递给 `drawBitmap()` 的 *x = 0* 和 *y
    = 0* 坐标绘制的。这意味着在开始绘制飞船的坐标之后，有一些像素偏右。看看下面的图片来可视化这一点：
- en: '![Detecting the screen resolution](img/B043422_03_01.jpg)'
  id: totrans-433
  prefs: []
  type: TYPE_IMG
  zh: '![检测屏幕分辨率](img/B043422_03_01.jpg)'
- en: Therefore, we must set our `minY` and `maxY` values with this in mind. As the
    image illustrates, the top pixel of the bitmap is indeed drawn exactly at the
    ships *y*. We can then be confident that `minY` should be zero.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须考虑到这一点来设置我们的 `minY` 和 `maxY` 值。如图所示，位图的顶部像素确实正好绘制在飞船的 *y* 上。然后我们可以确信
    `minY` 应该是零。
- en: The bottom of the ship, however, is drawn at *y + the height of the bitmap*.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，船的底部是在 *y + 位图的高度* 处绘制的。
- en: 'We can now add two lines of code to our constructor to initialize these variables:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在构造函数中添加两行代码来初始化这些变量：
- en: '[PRE42]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You can now run the game and test out your boosters!
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以运行游戏并测试你的助推器了！
- en: Building the enemies
  id: totrans-439
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建敌人
- en: Now that we have the tap controls implemented, it is time to add some enemies
    that the player can boost to avoid.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了水龙头控制，是时候添加一些玩家可以加速躲避的敌人了。
- en: This is going to be much easier than when we added our player's spaceship because
    most of what we need is in place already. All we have to do is code a class to
    represent our enemy, instantiate as many enemy objects as we need, call their
    `update` methods, and then draw them.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 这将比我们添加玩家的宇宙飞船要容易得多，因为我们需要的很多东西已经准备好了。我们只需要编写一个表示敌人的类，实例化我们需要的敌人对象，调用它们的 `update`
    方法，然后绘制它们。
- en: As we will see, the `update` method for our enemy will be quite different to
    that of `PlayerShip`. It will need to handle things like simple AI to fly toward
    the player. It will also need to handle respawning when it leaves the screen.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将看到的，我们的敌人`update`方法将与`PlayerShip`的方法相当不同。它需要处理像简单AI飞向玩家这样的东西。它还需要处理当它离开屏幕时的重生。
- en: Designing the enemy
  id: totrans-443
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计敌人
- en: 'To begin with, create a new Java class and call it `EnemyShip`. Add these member
    variables inside the class so your new class will look like this:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个新的Java类，并将其命名为`EnemyShip`。在类内部添加以下成员变量，以便您的新的类看起来像这样：
- en: '[PRE43]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, add some getter and setter methods so that the `draw` method can access
    what it needs to draw, and where it needs to draw it. There is nothing new or
    unusual here:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加一些getter和setter方法，以便`draw`方法可以访问它需要绘制的内容，以及它需要绘制的地方。这里没有什么新奇的或不同寻常的地方：
- en: '[PRE44]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Spawning the enemy
  id: totrans-448
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成敌人
- en: 'Let''s implement the `EnemyShip` constructor in full. Enter the code now, and
    we will then take a closer look:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来完整实现`EnemyShip`构造函数。现在输入代码，然后我们将更仔细地查看：
- en: '[PRE45]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The constructors' signature is exactly that of the `PlayerShip` class. A `Context`
    class for manipulating your `Bitmap` object and `screenX` and `screenY` that hold
    the resolution of the screen.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数的签名与`PlayerShip`类完全相同。一个用于操作您的`Bitmap`对象和`screenX`、`screenY`的`Context`类，它们持有屏幕的分辨率。
- en: 'Just as we did with the `PlayerShip` class, we load up an image into `Bitmap`.
    Of course, we once again need to add an image file named `enemy.png` to the `drawable`
    folder of our project. There is a neat enemy graphic in the `Chapter3/drawable`
    folder of the download bundle or you can design your own. Any size between roughly
    32 x 32 and 256 x 256 will suffice for the purposes of this game. Also, like those
    supplied, your graphics do not need to be square. We will see that our game engine
    is imperfect when it comes to how it looks on different screen sizes, and we will
    address this in the next project:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在`PlayerShip`类中所做的那样，我们将一个图像加载到`Bitmap`中。当然，我们还需要将一个名为`enemy.png`的图像文件添加到我们项目的`drawable`文件夹中。下载包的`Chapter3/drawable`文件夹中有一个整洁的敌人图形，或者您可以自己设计。对于这个游戏来说，任何大约32
    x 32到256 x 256大小的图形都足够了。同样，像提供的那些图形一样，您的图形不需要是正方形的。我们将看到，当它显示在不同屏幕尺寸上时，我们的游戏引擎在视觉上是不完美的，我们将在下一个项目中解决这个问题：
- en: '![Spawning the enemy](img/B043422_03_02.jpg)'
  id: totrans-453
  prefs: []
  type: TYPE_IMG
  zh: '![生成敌人](img/B043422_03_02.jpg)'
- en: Next, we initialize `maxX`, `maxY`, `minX`, and `minY`. Although the enemies
    only move horizontally, we need the `maxY` and `minY` coordinates to make sure
    that we spawn them at a sensible height. The `maxX` coordinate will enable us
    to spawn them just off-screen horizontally.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们初始化`maxX`、`maxY`、`minX`和`minY`。虽然敌人只水平移动，但我们需要`maxY`和`minY`坐标来确保我们在一个合理的身高处生成它们。`maxX`坐标将使我们能够在水平方向上刚好在屏幕外生成它们。
- en: We create a new object of type `Random` and generate a random number between
    the values of 10 and 15\. These are the maximum and minimum speeds our enemies
    can travel at. These values are fairly arbitrary, and we might adjust them when
    we do some play-testing in [Chapter 4](ch13.html "Chapter 4. Tappy Defender –
    Going Home"), *Tappy Defender – Going Home*.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个新的`Random`对象，并生成一个介于10和15之间的随机数。这些是我们敌人可以旅行的最大和最小速度。这些值相当任意，我们可能在[第4章](ch13.html
    "第4章。Tappy Defender – 回家") *Tappy Defender – 回家*进行一些游戏测试时调整它们。
- en: Note
  id: totrans-456
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are wondering how `generator.nextInt(6)+10;` comes up with a number between
    10 and 15, it is because the `6` argument causes `nextInt()` to return a number
    between 0 and 5.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想知道`generator.nextInt(6)+10;`是如何生成一个介于10到15之间的数字的，那是因为`6`参数导致`nextInt()`返回一个介于0到5之间的数字。
- en: We then set the enemy ship's *x* coordinate to screen, which spawns it on the
    far right of the screen. Actually, this spawns it off screen. However, that is
    fine because it will then emerge in to the player's view rather than just appearing
    all at once.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后将敌人船的*x*坐标设置为屏幕，这样它就会在屏幕的右侧生成。实际上，这是在屏幕外生成。然而，这是可以的，因为它将随后进入玩家的视野，而不是一次性出现。
- en: We now generate another random number based on `maxY`—the height of the enemy
    ship bitmap `(bitmap.getHeight())`—to create a random but sensible *y* coordinate
    for our enemy ship to spawn at.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们基于`maxY`——敌人的位图高度（`bitmap.getHeight()`）——生成另一个随机数，为我们的敌人船生成一个随机但合理的*y*坐标。
- en: What we need to do now is to give our enemies life by coding their update method.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要通过编写它们的更新方法来赋予我们的敌人生命。
- en: Making the enemy think
  id: totrans-461
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让敌人思考
- en: Now, we can handle the `EnemyShip` class's `update` method. For now, we just
    need to handle two things. First, fly the enemy toward the player's end of the
    screen. We need to take account of the enemy's speed and the player's speed to
    simulate this accurately. The reason we need to do this is because when the player
    boosts, he expects his speed to increase, and objects to rush toward him more
    quickly. However, the spaceship graphic is horizontally static.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以处理 `EnemyShip` 类的 `update` 方法。目前，我们只需要处理两件事。首先，让敌人飞向玩家的屏幕末端。我们需要考虑敌人的速度和玩家的速度来准确模拟这一点。我们需要这样做的原因是，当玩家加速时，他期望自己的速度会增加，物体会更快速地向他冲来。然而，飞船的图形在水平方向上是静态的。
- en: We can increase the rate of travel of an enemy in proportion to both the enemy's
    static and randomly generated speed at the same time as the player's dynamically
    set speed (through boosting). This will give the player a sense of speeding up
    even though the ship graphic never moves forward.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在玩家动态设置的速度（通过加速）的同时，按比例增加敌人的移动速度，这个速度既包括敌人的静态速度也包括随机生成的速度。这将给玩家一种加速的感觉，尽管船的图形从未向前移动。
- en: The other issue is that the enemy ship will eventually fly off the screen, on
    the left-hand side. We need to detect when this happens and respawn it on the
    right-hand side with a new random *y* coordinate and a new random speed. This
    is just like we did in the constructor.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是我们需要检测敌舰最终会飞离屏幕，在左侧。我们需要检测这种情况发生，并在右侧以新的随机 *y* 坐标和新的随机速度重新生成它。这与我们在构造函数中做的是一样的。
- en: Finally before we get to the actual code, let's consider something. If the enemy
    is going to take note of and use the player's speed, it will need to be able to
    get it. Note that in the next block of code, the `EnemyShip` class's `update`
    method declaration has a parameter to receive the player's speed.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们实际编写代码之前，让我们考虑一下。如果敌人要记录并使用玩家的速度，它将需要能够获取它。注意，在下一块代码中，`EnemyShip` 类的 `update`
    方法声明有一个参数来接收玩家的速度。
- en: 'We will see how this is passed in when we add code to the `TDView` class''s
    `update` method soon. Enter the following code for the `EnemyShip` class''s `update`
    method to implement what we have just discussed:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在不久后添加代码到 `TDView` 类的 `update` 方法中，看看这是如何传递的。为 `EnemyShip` 类的 `update` 方法输入以下代码以实现我们刚才讨论的内容：
- en: '[PRE46]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As you can see, we first decreased the enemy's *x* coordinate by the player's
    speed then by the enemy's speed. As the player boosts, the enemy will fly at the
    player faster. However, if the player is not boosting then the enemy will attack
    at the speed that was previously and randomly generated.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们首先将敌人的 *x* 坐标减少了玩家的速度，然后是敌人的速度。当玩家加速时，敌人会以更快的速度飞向玩家。然而，如果玩家没有加速，敌人将以之前和随机生成的速度攻击。
- en: '[PRE47]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: After this, we simply detected if the right-hand edge of the enemy bitmap has
    disappeared from the left-hand side of the screen. This is done by detecting if
    the `EnemyShip` class's *x* coordinate is the width of the bitmap off screen.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们简单地检测了敌人位图的右边缘是否已经从屏幕的左侧消失。这是通过检测 `EnemyShip` 类的 *x* 坐标是否是位图宽度之外的来实现。
- en: '[PRE48]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Then we respawn the very same object to come at the player again. This appears
    to the player as if it is an entirely new enemy.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们重新生成同一个对象再次攻击玩家。这对玩家来说看起来就像是一个全新的敌人。
- en: The last three things we must do are create a new object from `EnemyShip` by
    declaring and then initializing an object. Actually, let's make three.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须做的最后三件事是从 `EnemyShip` 创建一个新的对象，通过声明和初始化对象来实现。实际上，让我们创建三个。
- en: 'Here, were we declared our player''s ship in our `TDView.java` file, declare
    three enemy ships like this:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在 `TDView.java` 文件中声明了我们的玩家飞船，可以像这样声明三艘敌舰：
- en: '[PRE49]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, in the constructor of our `TDView` class, initialize our three new enemies:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的 `TDView` 类的构造函数中，初始化我们的三个新敌人：
- en: '[PRE51]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In the `update` method of our `TDView` class, we call each of the new object's
    `update` methods in turn. Here, we also see how we pass in the player's speed
    to each of our enemies so they can use it in their `update` methods to adjust
    speed accordingly.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `TDView` 类的 `update` 方法中，我们依次调用每个新对象的 `update` 方法。在这里，我们还可以看到我们如何将玩家的速度传递给每个敌人，以便他们可以在自己的
    `update` 方法中使用它来相应地调整速度。
- en: '[PRE52]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Finally, in the `TDView` class's `draw` method, we draw our new enemies to the
    screen.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 `TDView` 类的 `draw` 方法中，我们将我们的新敌人绘制到屏幕上。
- en: '[PRE53]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: You can run the game and give this a try now.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以运行游戏并尝试一下。
- en: The first and most obvious problem is that the player and the enemies fly right
    through each other. We will solve this problem later in this chapter, in the *Things
    that go bump – collision detection* section. But right now, we can make our player's
    sense of immersion better by drawing a star/space dust field as a background.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个也是最明显的问题是玩家和敌人可以直接穿过彼此。我们将在本章后面的*碰撞检测*部分解决这个问题。但此时，我们可以通过绘制一个星/太空尘埃场作为背景来提高玩家的沉浸感。
- en: The thrill of flight – scrolling the background
  id: totrans-485
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 飞行的刺激——滚动背景
- en: Implementing our space dust is going to be really quick and easy. All we will
    do is create a `SpaceDust` class with very similar properties to our other game
    objects. Spawn them into the game at a random location, move them toward the player
    at a random speed, and respawn them on the far right of the screen, again with
    a random speed and *y* coordinate.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 实现太空尘埃将会非常快且简单。我们只需创建一个具有与其他游戏对象非常相似属性的`SpaceDust`类。在随机位置将它们生成到游戏中，以随机速度向玩家移动，并在屏幕的远右侧以随机速度和`y`坐标重生它们。
- en: Then in our `TDView` class, we can declare a whole array of these objects, update,
    and draw them each frame.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在我们的`TDView`类中，我们可以声明一系列这些对象，每帧更新并绘制它们。
- en: 'Create a new class and call it `SpaceDust`. Now enter this code:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的类，命名为`SpaceDust`。现在输入以下代码：
- en: '[PRE54]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Here is what is happening in the `SpaceDust` class. At the top of the previous
    block of code, we declare our usual speed and maximum and minimum variables. They
    will allow us to detect when the `SpaceDust` object leaves the left of the screen
    and needs respawning on the right, and provide sensible bounds for the height
    at which we respawn the object.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`SpaceDust`类中发生的事情。在上一个代码块顶部，我们声明了我们常用的速度、最大和最小变量。它们将允许我们检测`SpaceDust`对象何时离开屏幕左侧并需要在右侧重生，并为重生对象的高度提供合理的边界。
- en: Then inside the `SpaceDust` constructor, we initialize the `speed`, `x`, and
    `y` variables with random values, but within the bounds set by the maximum and
    minimum variables we just initialized.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在`SpaceDust`构造函数内部，我们使用随机值初始化`speed`、`x`和`y`变量，但在这个我们刚刚初始化的最大和最小变量设定的范围内。
- en: Then we implement the `SpaceDust` class's `update` method, which moves the object
    to the left based on the speed of the object and the player, then checks if the
    object has flown of the left-hand edge of the screen and respawns it with random
    but appropriate values if it has.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们实现`SpaceDust`类的`update`方法，该方法根据对象的速度和玩家的速度将对象向左移动，然后检查对象是否已经飞出屏幕的左侧边缘，如果已经飞出，则使用随机但适当的值重生它。
- en: At the bottom, we provide two getter methods so that our `draw` method knows
    where to draw each speck of dust.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 在底部，我们提供了两个获取方法，以便我们的`draw`方法知道如何绘制每一粒尘埃。
- en: 'Now, we can create an `ArrayList` object to hold all our `SpaceDust` objects.
    Declare it just under the declaration of the other game objects near the top of
    the `TDView` class:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个`ArrayList`对象来存储所有的`SpaceDust`对象。在`TDView`类顶部附近其他游戏对象的声明下方声明它：
- en: '[PRE55]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In the `TDView` constructor, we can initialize a whole bunch of the `SpaceDust`
    objects using a `for` loop and then stash them into the `ArrayList` object:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 在`TDView`构造函数中，我们可以使用`for`循环初始化一系列的`SpaceDust`对象，然后将它们存储到`ArrayList`对象中：
- en: '[PRE56]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We create forty specks of dust in total. Each time through the loop, we create
    a new speck of dust and the `SpaceDust` constructor assigns it a random location
    and a random speed. We then put the `SpaceDust` object into our `ArrayList` object
    with `dustList.add(spec);`
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总共创建了四十粒尘埃。每次循环中，我们创建一个新的尘埃粒子，`SpaceDust`构造函数给它分配一个随机位置和速度。然后我们使用`dustList.add(spec);`将`SpaceDust`对象放入我们的`ArrayList`对象中。
- en: 'Next, we jump to our `TDView` class''s `update` method and use an enhanced
    `for` loop to call `update()` on each of our `SpaceDust` objects:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们跳转到`TDView`类的`update`方法，并使用增强型`for`循环对每个`SpaceDust`对象调用`update()`。
- en: '[PRE57]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Remember that we passed in the player speed so that the dust increases and decreases
    its speed relative to the player's speed.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我们传递了玩家速度，这样尘埃的速度会相对于玩家的速度增加或减少。
- en: Now to draw all our space dust, we loop through our `ArrayList` object and draw
    a speck at a time. Of course, we add the code to our `TDView` class's `draw` method,
    but we must make sure to draw the space dust first so it appears behind the other
    game objects. In addition, we have an extra line to switch pixel color to white
    before using the `drawPoint` method of our `Canvas` object to plot a single pixel
    for each `SpaceDust` object.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 现在要绘制所有我们的太空尘埃，我们遍历我们的 `ArrayList` 对象，一次绘制一个点。当然，我们将代码添加到 `TDView` 类的 `draw`
    方法中，但我们必须确保首先绘制太空尘埃，这样它就会出现在其他游戏对象之后。此外，我们在使用 `Canvas` 对象的 `drawPoint` 方法绘制每个
    `SpaceDust` 对象的单个像素之前，添加了一行额外的代码来切换像素颜色为白色。
- en: 'In the `draw` method of the `TDView` class, add this code to draw our dust:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `TDView` 类的 `draw` 方法中，添加以下代码来绘制我们的尘埃：
- en: '[PRE58]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The only new thing here is the `canvas.drawpoint...` line of code. Apart from
    drawing bitmaps to the screen, the `Canvas` class allows us to draw primitives,
    like points and lines, as well as things like text and shapes. We will use these
    features when drawing a HUD for our game in [Chapter 4](ch13.html "Chapter 4. Tappy
    Defender – Going Home"), *Tappy Defender – Going Home*.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一的新东西是 `canvas.drawpoint...` 这行代码。除了在屏幕上绘制位图之外，`Canvas` 类还允许我们绘制原语，如点和线，以及文本和形状等。我们将在第
    4 章 [Tappy Defender – Going Home](ch13.html "Chapter 4. Tappy Defender – Going
    Home") 中使用这些功能来绘制我们的游戏HUD。
- en: 'Why not run the app and check out how much neat stuff we have implemented?
    In this screenshot, I have temporarily increased the number of the `SpaceDust`
    objects to `200`, just for fun. You can also see that we have enemies drawn, attacking
    at a random *y* coordinate with random speed:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不运行应用程序并查看我们实现了多少有趣的功能？在这个屏幕截图中，我为了好玩，临时增加了 `SpaceDust` 对象的数量到 `200`。你还可以看到我们绘制了敌人，它们在随机的
    *y* 坐标上以随机速度攻击：
- en: '![The thrill of flight – scrolling the background](img/B043422_03_03.jpg)'
  id: totrans-507
  prefs: []
  type: TYPE_IMG
  zh: '![飞行的刺激 - 滚动背景](img/B043422_03_03.jpg)'
- en: Things that go bump – collision detection
  id: totrans-508
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发生碰撞的事物 - 碰撞检测
- en: Collision detection is quite a broad subject. Throughout the three projects
    in this book, we will use a whole range of different ways to detect when things
    collide.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 碰撞检测是一个相当广泛的主题。在这本书的三个项目中，我们将使用各种不同的方法来检测物体何时发生碰撞。
- en: So, here is a quick look at our options for collision detection, and in which
    circumstances different methods may be appropriate.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里快速看一下我们的碰撞检测选项，以及在什么情况下不同的方法可能是合适的。
- en: Essentially, we just need to know when certain objects from our game touch other
    objects. We can then respond to that event by exploding, reducing shields, playing
    a sound, or whatever is appropriate. We need a broad understanding of our different
    options so we can make the right decisions in any particular game.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们只需要知道我们游戏中的某些物体何时触摸其他物体。然后我们可以通过爆炸、减少护盾、播放声音或采取适当的行动来响应该事件。我们需要对不同的选项有一个广泛的理解，这样我们才能在任何特定的游戏中做出正确的决定。
- en: Collision detection options
  id: totrans-512
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 碰撞检测选项
- en: First of all, here are a few of the different mathematical calculations we can
    utilize and when they may be useful.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这里有一些我们可以利用的不同数学计算，以及它们可能何时有用。
- en: Rectangle intersection
  id: totrans-514
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 矩形交集
- en: 'This type of collision detection is really straightforward. We draw an imaginary
    rectangle; we can call it a hitbox or bounding rectangle, around the objects we
    want to test for collision. Then, test to see if they intersect. If they do, we
    have a collision:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 这种碰撞检测类型非常直接。我们画一个想象中的矩形；我们可以称之为击中框或边界矩形，围绕我们想要测试碰撞的物体。然后测试它们是否相交。如果相交，我们就有了碰撞：
- en: '![Rectangle intersection](img/B043422_03_04.jpg)'
  id: totrans-516
  prefs: []
  type: TYPE_IMG
  zh: '![矩形交集](img/B043422_03_04.jpg)'
- en: Where the hitboxes intersect, we have a collision. As we can see from the previous
    image, this is far from perfect. However, in some situations, it is sufficient.
    To implement this method, all we need to do is test for the intersection using
    the *x* and *y* coordinates of both objects.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 当击中框相交时，我们就有碰撞。从之前的图像中我们可以看到，这远非完美。然而，在某些情况下，这已经足够了。要实现这种方法，我们只需要测试两个物体的 *x*
    和 *y* 坐标是否相交。
- en: Don't use the following code. It is for demonstration purposes only.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用以下代码。它仅用于演示目的。
- en: '[PRE59]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The preceding code assumes we have a `getHitbox` method that returns the left
    and right *x* coordinates as well as the top and bottom *y* coordinates of the
    given object. In the aforementioned code, we first check to see if the *x* axes
    overlap. If they don't, then there is no point going any further. If they do,
    then check the *y* axes. If they don't, it could have been an enemy whizzing by
    above or below. If they overlap on the *y* axis as well, then we have a collision.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码假设我们有一个`getHitbox`方法，它可以返回给定对象的左和右 *x* 坐标以及上和下 *y* 坐标。在上面的代码中，我们首先检查 *x*
    轴是否重叠。如果没有重叠，那么就没有必要继续下去。如果重叠，然后检查 *y* 轴。如果没有重叠，那可能是一个在上方或下方的敌人快速掠过。如果它们在 *y*
    轴上也重叠，那么我们就有了碰撞。
- en: Note that we can check the *x* and *y* axis in either order as long as we check
    them both.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以以任何顺序检查 *x* 和 *y* 轴，只要我们检查它们两个。
- en: Radius overlapping
  id: totrans-522
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 半径重叠
- en: This method is also checking to see if two hitboxes intersect with each other,
    but as the title suggests, it does so using circles instead. There are obvious
    advantages and disadvantages. Mainly that this works well with shapes more circular
    in nature and less well with elongated shapes.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法也在检查两个碰撞框是否相互重叠，但正如标题所暗示的，它是通过圆形来实现的。这显然有明显的优点和缺点。主要是这种方法与更圆的形状配合得很好，而与细长的形状配合得不好。
- en: '![Radius overlapping](img/B043422_03_05.jpg)'
  id: totrans-524
  prefs: []
  type: TYPE_IMG
  zh: '![半径重叠](img/B043422_03_05.jpg)'
- en: From the previous image, it is easy to see how the radius overlapping method
    is inaccurate for these particular objects and not hard to imagine how for a circular
    object like a ball it would be perfect.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一张图中，很容易看出对于这些特定的对象，半径重叠方法是不准确的，而且不难想象对于一个像球这样的圆形物体，它将是完美的。
- en: Here is how we can implement this method.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们如何实现这个方法。
- en: Note
  id: totrans-527
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The following code is for demonstration purposes only.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码仅用于演示目的。
- en: '[PRE60]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The code again makes some assumptions. Like we have a `getHitBox` method that
    can return the radius as well as the center *x* and *y* coordinates. Furthermore,
    because the static `Math.sqrt` method takes and returns a variable of type `double`,
    we will need to start working with different types in our `SpaceShip` and `EnemyShip`
    classes.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 代码再次做出了一些假设。比如我们有一个`getHitBox`方法，它可以返回半径以及中心 *x* 和 *y* 坐标。此外，因为静态`Math.sqrt`方法接受并返回一个类型为`double`的变量，我们将在我们的`SpaceShip`和`EnemyShip`类中开始使用不同的类型。
- en: Note
  id: totrans-531
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If the way we initialize distance: `Math.sqrt(distanceX * distanceX + distanceY
    * distanceY);` looks a little confusing, it is simply using Pythagoras'' theorem
    to get the length of the hypotenuse of a triangle which is equal in length to
    a straight line drawn between the centers of the two circles. In the last line
    of our solution, we test if `distance < ship.getHitBox.radius + enemy.getHitBox.radius`,
    then we can be certain that we must have a collision. That is because if the center
    points of two circles are closer than the combined length of their radii, they
    must be overlapping.'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们初始化距离的方式`Math.sqrt(distanceX * distanceX + distanceY * distanceY);`看起来有点令人困惑，它只是在使用毕达哥拉斯定理来获取三角形的斜边长度，这个斜边长度等于两个圆心之间画出的直线长度。在我们的解决方案的最后一条线中，我们测试`distance
    < ship.getHitBox.radius + enemy.getHitBox.radius`，然后我们可以确定我们肯定有一个碰撞。这是因为如果两个圆的中心点比它们半径的总和还要近，它们必须重叠。
- en: The crossing number algorithm
  id: totrans-533
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跨越数算法
- en: 'This method is mathematically more complicated. However, as we will see in
    our third and final project, it is perfect for detecting when a point intersects
    a convex polygon:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在数学上更复杂。然而，正如我们将在我们的第三个和最后一个项目中看到的那样，它非常适合检测一个点是否与凸多边形相交：
- en: '![The crossing number algorithm](img/B043422_03_06.jpg)'
  id: totrans-535
  prefs: []
  type: TYPE_IMG
  zh: '![跨越数算法](img/B043422_03_06.jpg)'
- en: This is perfect for an Asteroids clone, and we will explore this method more
    as well as see it in action in our final project.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于制作小行星克隆游戏是完美的，我们将在我们的最终项目中更深入地探讨这种方法，并看到它在实际中的应用。
- en: Optimizations
  id: totrans-537
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化
- en: As we have seen, the different collision detection methods can have at least
    two problems depending on which method you use in which situation. The problems
    are lack of accuracy and drain on CPU cycles.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，不同的碰撞检测方法可能至少有两个问题，这取决于你在哪种情况下使用哪种方法。问题是缺乏准确性和对CPU周期的消耗。
- en: Multiple hitboxes
  id: totrans-539
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多个碰撞框
- en: The first problem, a lack of accuracy, can be solved by having multiple hitboxes
    per object.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题，缺乏准确性，可以通过每个对象有多个碰撞框来解决。
- en: We simply add the required number of hitboxes to our game object to most effectively
    *wrap* it, and then perform the same rectangle intersection code on each in turn.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需将所需数量的碰撞框添加到游戏对象中，以最有效地将其“包裹”，然后依次对每个对象执行相同的矩形交集代码。
- en: Neighbor checking
  id: totrans-542
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 邻居检查
- en: This method allows us to only check objects that are in the approximate same
    area as each other. It can be achieved by checking which neighborhood of our game
    a given two objects are in, and then only performing the more CPU intensive collision
    detection if there is a realistic chance that a collision could occur.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法允许我们只检查彼此大致位于同一区域的对象。这可以通过检查给定两个对象位于我们游戏中的哪个区域来实现，然后只有在有实际可能发生碰撞的情况下才执行更耗CPU的碰撞检测。
- en: Suppose we have 10 objects that each need to be checked against each other,
    then we need to perform 10 squared (100) collision checks. If we do neighbor checking
    first, we can significantly reduce this number. In the very hypothetical situation
    in the diagram, we would only need to do an absolute maximum of 11 collision checks,
    instead of 100, for our 10 objects, if we first check to see if objects share
    the same sector.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有10个对象需要相互检查，那么我们需要执行10的平方（100）次碰撞检测。如果我们首先进行邻居检查，可以显著减少这个数量。在非常假设的情况图中，如果我们首先检查对象是否共享同一个区域，那么对于我们的10个对象，我们只需要进行最多11次碰撞检测，而不是100次。
- en: '![Neighbor checking](img/B043422_03_07.jpg)'
  id: totrans-545
  prefs: []
  type: TYPE_IMG
  zh: '![邻居检查](img/B043422_03_07.jpg)'
- en: Implementing this in code can be as simple as having a sector member variable
    for each game object, then looping through the list of objects and just checking
    if they are in the same sector.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中实现这一点可能就像为每个游戏对象添加一个区域成员变量，然后遍历对象列表，检查它们是否位于同一个区域。
- en: Note
  id: totrans-547
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We will use all these options and optimizations over the course of our three
    game projects.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的三个游戏项目中，我们将使用所有这些选项和优化。
- en: Best options for Tappy Defender
  id: totrans-549
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Tappy Defender 的最佳选项
- en: Now that we know our collision detection options, we can decide the best course
    of action in our current game. All our ships are approximately rectangular (or
    square), there are few or no extremities on any of them, and we only have one
    object were we really care about a collision (with all the others).
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了我们的碰撞检测选项，我们可以在当前游戏中决定最佳的行动方案。我们的所有飞船都是近似矩形的（或正方形），它们上面几乎没有或没有极端部分，我们只关心一个对象的碰撞（与其他所有对象）。
- en: This tends to suggest that we can use a single rectangular hitbox for the player
    and the enemy and perform purely corner aligned, global collision detection. If
    you're disappointed that we are going for the easy option, then you will be pleased
    to hear we will be getting into all the fancier techniques over the next two projects.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常意味着我们可以为玩家和敌人使用单个矩形碰撞框，并执行纯角对齐的全局碰撞检测。如果你对我们选择简单方案感到失望，那么你将很高兴听到，在接下来的两个项目中，我们将涉及所有更复杂的技巧。
- en: To make life even easier, the Android API has a handy the `Rect` class that
    can not only represent our hitboxes, but also has a neat `intersects` method that
    basically does the same thing as rectangle intersection collision detection. Let's
    think about how to add collision detection to our game.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让生活更加便捷，Android API 提供了一个方便的 `Rect` 类，它不仅能表示我们的碰撞框，还包含一个整洁的 `intersects` 方法，基本上与矩形交集碰撞检测做的是同样的事情。让我们来思考如何将碰撞检测添加到我们的游戏中。
- en: 'First, all of our enemies and our player ship are going to need a hitbox. Add
    this code to declare a new `Rect` member called `hitbox`. Do this in both the
    `PlayerShip` and `EnemyShip` class:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们所有的敌人和我们的玩家飞船都需要一个碰撞框。将以下代码添加到声明新的 `Rect` 成员变量 `hitbox` 中。在 `PlayerShip`
    和 `EnemyShip` 类中执行此操作：
- en: '[PRE61]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Tip
  id: totrans-555
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Important!**'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要！**'
- en: Be sure to do the previous step and the next three blocks of code for both the
    `EnemyShip` class as well as the `PlayerShip` class. I will remind you each time
    but just thought it worth mentioning beforehand as well.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 确保为 `EnemyShip` 类和 `PlayerShip` 类执行之前的步骤以及接下来的三个代码块。我会每次提醒你，但认为提前提一下也很有必要。
- en: 'Now, we need to add a getter method to the `PlayerShip` class and the `EnemyShip`
    class. Add this code to both classes:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要为 `PlayerShip` 类和 `EnemyShip` 类添加一个获取器方法。将以下代码添加到这两个类中：
- en: '[PRE62]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'And next, we need to make sure we initialize our hitboxes in both constructors.
    Make sure to enter the code right at the end of the constructor:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要确保在两个构造函数中初始化我们的碰撞框。确保在构造函数的末尾输入代码：
- en: '[PRE63]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now we need to make sure the hitboxes are kept up-to-date with the coordinates
    of our enemies and our player. The best place to do this is the `update` method
    of the enemy/player ships. The next block of code will update the hitboxes with
    the ship''s current coordinates. Be sure to add this block of code at the very
    end of the `update`() methods so that the hitbox is updated with the coordinates
    after the `update` methods have done their adjustments. Again, add it to both
    `PlayerShip` and `EnemyShip`:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要确保击中区域与我们的敌人和玩家的坐标保持最新。做这件事的最佳地方是敌人和玩家飞船的`update`方法。接下来的代码块将使用飞船的当前坐标更新击中区域。确保在`update()`方法的末尾添加此代码块，以便在`update`方法完成调整后更新击中区域。再次提醒，将其添加到`PlayerShip`和`EnemyShip`中：
- en: '[PRE64]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Our hitboxes have the coordinates that represent the outline of our bitmaps.
    This situation is nearly perfect, apart from the transparent bits around the edges.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的击中区域坐标代表了我们位图的轮廓。这种情况几乎是完美的，除了边缘周围的透明部分。
- en: Now, we can use our hitboxes from the `TDView` class's `update` method to detect
    collisions. But first, we need to decide what we are going to do when a collision
    occurs.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`TDView`类的`update`方法中的击中区域来检测碰撞。但在做之前，我们需要决定当发生碰撞时我们将做什么。
- en: We need to refer to the rules of our game. We discussed them back at the beginning
    of [Chapter 2](ch11.html "Chapter 2. Tappy Defender – First Step"), *Tappy Defender
    – First Step*. We know that the player has three shields but an enemy blows up
    after one hit. It makes sense to leave things like shields to a later part of
    the chapter, but we need some way to see our collision detection in action and
    make sure it is working.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要参考我们游戏规则。我们之前在[第二章](ch11.html "第二章. Tappy Defender – 第一步")，*Tappy Defender
    – 第一步*中讨论过这些规则。我们知道玩家有三个护盾，但敌人被击中一次后就会爆炸。将像护盾这样的东西留到章节的后面部分是有道理的，但我们需要某种方式来查看我们的碰撞检测是否在起作用并确保它正常工作。
- en: Probably, the simplest way to acknowledge a collision at this stage, will be
    to make the enemy ship disappear and respawn as normal, as if it is a totally
    new enemy. We already have a mechanism in place for this. We know that when an
    enemy moves off the left of the screen it respawns as if it is a new enemy on
    the right. All we need to do is instantly transport the enemy to a location off
    of the left of the screen and the `EnemyShip` class will do the rest.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，承认碰撞的最简单方法可能是让敌舰消失并重新生成，就像它是一个全新的敌人一样。我们已经有了一个实现这个功能的机制。我们知道当敌人移动到屏幕的左侧时，它会像在右侧的新敌人一样重新生成。我们只需要将敌人瞬间传送到屏幕左侧之外的位置，`EnemyShip`类就会完成剩下的工作。
- en: 'We need to be able to change the `EnemyShip` object''s *x* coordinate. Let''s
    add a setter method to the `EnemyShip` class so we can manipulate the *x* coordinate
    of all our enemy spaceships. Like this:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要能够改变`EnemyShip`对象的*x*坐标。让我们在`EnemyShip`类中添加一个setter方法，这样我们就可以操作所有敌舰的*x*坐标。如下所示：
- en: '[PRE65]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now, we can carry out collision detection and respond when we get a hit. The
    next block of code uses the static method `Rect.intersects()` to detect a hit
    by comparing the player ship''s hitbox with each of the enemy hitboxes in turn.
    If a hit is detected, the appropriate enemy is moved off screen, ready to be respawned
    by its own `update` method in the next frame. Enter this code at the very top
    of the `TDView` class''s `update` method:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以执行碰撞检测，并在被击中时做出反应。接下来的代码块使用静态方法`Rect.intersects()`通过依次比较玩家飞船的击中区域和每个敌人击中区域来检测碰撞。如果检测到碰撞，适当的敌人将被移出屏幕，准备在下一帧由其自己的`update`方法重新生成。在`TDView`类的`update`方法的最顶部输入此代码：
- en: '[PRE66]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'That''s it, our collisions will now work. It may be nice to be able to really
    see what is going on. For the purposes of debugging, let''s draw a rectangle around
    all our spaceships, so we can see the hitboxes. We will use the `drawRect` method
    of the `Paint` class and pass the properties of our hitboxes in as arguments to
    define the area to draw. As you will expect, this code goes in the `draw` method.
    Note that it should go before the code that draws our ships so that the rectangles
    are drawn behind them, but after we clear the screen, as shown by the highlighted
    code:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们的碰撞检测现在将正常工作。能够真正看到正在发生的事情可能很好。为了调试的目的，让我们在所有的飞船周围画一个矩形，这样我们就可以看到击中区域。我们将使用`Paint`类的`drawRect`方法，并将我们的击中区域属性作为参数传递，以定义要绘制的区域。正如你所期望的，这段代码将放在`draw`方法中。注意，它应该在绘制我们飞船的代码之前，这样矩形就会在飞船后面绘制，但在清除屏幕之后，如高亮代码所示：
- en: '[PRE67]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We can now run Tappy Defender and see the game in action complete with debugging
    mode hitboxes enabled:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行Tappy Defender，并看到游戏在调试模式下的击中框完全启用的情况：
- en: '![Best options for Tappy Defender](img/B043422_03_08.jpg)'
  id: totrans-575
  prefs: []
  type: TYPE_IMG
  zh: '![Tappy Defender的最佳选项](img/B043422_03_08.jpg)'
- en: We can comment out this debugging code when we are done with it and then uncomment
    it should we need it again later.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成调试代码后，我们可以将其注释掉，然后在需要时再次取消注释。
- en: Summary
  id: totrans-577
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We now have all the game objects that we need for a complete game. They all
    think and represent themselves internally in the model part of our design pattern.
    Furthermore, our player can at last control his spaceship, and we can detect when
    he crashes.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们拥有了完成整个游戏所需的所有游戏对象。它们都在我们的设计模式的模型部分内部思考和代表自己。此外，我们的玩家现在终于可以控制他的宇宙飞船了，我们也可以检测到他何时撞毁。
- en: In the next chapter, we will put the finishing touches to our game including
    adding a HUD (Heads Up Display), implementing the game rules, adding some extra
    features, and play-testing our game to get everything in balance.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将为我们的游戏添加最后的修饰，包括添加HUD（抬头显示）、实现游戏规则、添加一些额外功能，并对游戏进行测试以平衡一切。
- en: Chapter 4. Tappy Defender – Going Home
  id: totrans-580
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 Tappy Defender – 回家
- en: We are on the home straight of our first game. In this chapter, we will draw
    a HUD to show the player in-game information, and implement the rules of the game
    so that the player can win, lose, and get fastest times.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经进入了第一款游戏的冲刺阶段。在本章中，我们将绘制一个HUD（头部显示单元）来显示玩家在游戏中的信息，并实现游戏规则，以便玩家可以赢、输和获得最快时间。
- en: After that, we will make a pause screen so the player can admire their achievements
    (or not) after they win or lose.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将制作一个暂停屏幕，让玩家在赢或输后可以欣赏他们的成就（或者不是）。
- en: In this chapter, we will also generate our own sound FX and then add them to
    the game. Following that, we will enable the player to save their fastest time,
    and finally we will add a whole bunch of minor improvements, including a bit of
    difficulty balancing based on the screen resolution of the player's Android device.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还将生成我们自己的音效，并将其添加到游戏中。之后，我们将允许玩家保存他们的最快时间，最后我们将添加一些小的改进，包括根据玩家安卓设备的屏幕分辨率进行的一点点难度平衡。
- en: Displaying a HUD
  id: totrans-584
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示HUD
- en: We need to start making our game a bit more rounded. Games have a score or,
    in our case, a time, and other rules as well. For the player to keep check on
    their progress we need to display the stats of the game.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要开始让我们的游戏更加完善。游戏有一个得分或者，在我们的情况下，是一个时间，以及其他规则。为了使玩家能够监控他们的进度，我们需要显示游戏的统计数据。
- en: Here, we will quickly set up a HUD that will show the player everything they
    need to know on screen while he is dodging enemies. We will also declare and initialize
    the variables required to supply data to the HUD. In the next section, *Implementing
    the rules*, we can begin to manipulate variables such as, shields, time, fastest
    time, and so on.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将快速设置一个HUD，它将在玩家躲避敌人时在屏幕上显示他们所需了解的一切。我们还将声明并初始化向HUD提供数据的变量。在下一节“实现规则”中，我们可以开始操作如护盾、时间、最快时间等变量。
- en: 'We can start by adding some member variables to the `TDView` class. We use
    a float value for the `distanceRemaining` variable because we will be using pseudo-kilometers
    and fractions of kilometers to represent the distance remaining until our hero
    makes it to her home planet. For the `timeTaken`, `timeStarted`, and `fastestTime`
    variables, we will use the **long** type because time is represented in milliseconds
    and the values get really big. Add this code after the `TDView` class declaration:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从向`TDView`类添加一些成员变量开始。我们使用浮点值来表示`distanceRemaining`变量，因为我们将会使用伪千米和千米分数来表示英雄到达她家园星球之前剩余的距离。对于`timeTaken`、`timeStarted`和`fastestTime`变量，我们将使用**长**类型，因为时间以毫秒表示，值会变得非常大。在`TDView`类声明之后添加此代码：
- en: '[PRE68]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: For now, we will just leave these variables with their default values and concentrate
    on displaying them in our HUD. We will make them useful and meaningful in the
    next section, *Implementing the rules*.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将只保留这些变量默认的值，并专注于在HUD中显示它们。在下一节“实现规则”中，我们将使它们变得有用和有意义。
- en: Now, we can go ahead and draw our HUD to display all the data the player may
    want to know while playing. As so often, we will be using our versatile `Paint`
    class object `paint` to do the bulk of the work. This time, we use the `drawText`
    method to add text to the screen, the `setTextAlign` method to justify our text,
    and `setTextSize` to scale the size of the text.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续绘制我们的HUD，以显示玩家在游戏过程中可能想要了解的所有数据。像往常一样，我们将使用我们多才多艺的`Paint`类对象`paint`来完成大部分工作。这次，我们使用`drawText`方法向屏幕添加文本，使用`setTextAlign`方法对齐文本，并使用`setTextSize`调整文本大小。
- en: 'We can now add this code to our `TDView` class''s `draw` method. Add it as
    the last thing to draw, just before the call to `unlockCanvasAndPost()`, as shown
    by the highlighted code:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将此代码添加到`TDView`类的`draw`方法中。将其添加为最后要绘制的内容，在调用`unlockCanvasAndPost()`之前，如高亮代码所示：
- en: '[PRE69]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: After entering this code, we have some errors and probably some questions.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 输入此代码后，我们有一些错误和一些疑问。
- en: First, we will deal with the questions. We will look more closely at what we
    are doing to `fastestTime`, `timeTaken`, `distanceRemaining`, and the value returned
    by `getSpeed` in the next section, *Implementing the rules*. Simply put, they
    are representations of distance and time that serve to give the player a sense
    of how they are doing. They are not real simulations of distance, although the
    time is accurate.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将处理疑问。在下一节“实现规则”中，我们将更仔细地查看我们对`fastestTime`、`timeTaken`、`distanceRemaining`以及`getSpeed`返回的值的操作。简而言之，它们是距离和时间的表示，旨在让玩家了解他们的表现。它们不是距离的真实模拟，尽管时间是准确的。
- en: 'The first error we will deal with is caused by a call to a nonexistent method
    `player.getShieldStrength`. Add a member variable `shieldStrength` to the `PlayerShip`
    class:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先处理由调用不存在的方法`player.getShieldStrength`引起的第一个错误。向`PlayerShip`类添加一个成员变量`shieldStrength`：
- en: '[PRE70]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Initialize it to `2` in the `PlayerShip` constructor:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PlayerShip`构造函数中将它初始化为`2`：
- en: '[PRE71]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Implement your missing getter method in the `PlayerShip` class:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PlayerShip`类中实现你缺失的getter方法：
- en: '[PRE72]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The final errors are caused by the undeclared variables `screenX` and `screenY`.
    It is now apparent that we need the screen resolution in this part of our code.
    The fastest way to deal with this is to make some new class variables called `screenX`
    and `screenY`. Declare these now just after the `TDView` class declaration:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的错误是由未声明的变量`screenX`和`screenY`引起的。现在很明显，我们需要在这个代码部分的屏幕分辨率。处理这个问题最快的方法是创建一些新的类变量`screenX`和`screenY`。现在就在`TDView`类声明之后声明这些变量：
- en: '[PRE73]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: As we will see, knowing the screen coordinates is useful in a number of places,
    so it makes sense to do this.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将看到的，知道屏幕坐标在许多地方都很有用，所以这样做是有意义的。
- en: 'Now, in the `TDView` constructor, initialize `screenX` and `screenY` with the
    resolution passed in by the `GameActivity` class. Do this at the start of the
    constructor:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`TDView`构造函数中，使用`GameActivity`类传入的分辨率初始化`screenX`和`screenY`。在构造函数的开始处执行此操作：
- en: '[PRE74]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We can now run the game and see our HUD. The only parts of our HUD with meaningful
    data are the **Shield** and **Speed** labels. The speed is a pseudo-measurement
    of MPS (meters per second). Of course it has no bearing on reality, but it is
    relative to the speed of the whizzing stars, approaching enemies and soon, to
    the decreasing distance from the player''s goal, home:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以运行游戏并查看我们的HUD。我们HUD中带有有意义数据的部分只有**护盾**和**速度**标签。速度是每秒米数（MPS）的伪测量值。当然，它与现实无关，但它与旋转的星星、接近的敌人以及玩家与家的距离减少有关：
- en: '![Displaying a HUD](img/B04322_04_01.jpg)'
  id: totrans-607
  prefs: []
  type: TYPE_IMG
  zh: '![显示HUD](img/B04322_04_01.jpg)'
- en: Implementing the rules
  id: totrans-608
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现规则
- en: Now, we should pause and think about what we need to do later in the project
    because it will affect what we do while implementing our rules. When the player's
    ship is destroyed or when player reaches their goal, the game will end. This implies
    that the game will need to be restarted. We don't want to quit back to the home
    screen each time, so we need a way to restart the game from within the `TDView`
    class.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该暂停并思考在项目后期需要做什么，因为它将影响我们在实现规则时的操作。当玩家的飞船被摧毁或玩家达到他们的目标时，游戏将结束。这意味着游戏需要重新启动。我们不希望每次都退出到主屏幕，因此我们需要一种从`TDView`类内部重新启动游戏的方法。
- en: To facilitate this, we are going to implement a `startGame` method in our `TDView`
    class. The constructor will be able to call it and our game loop will also be
    able to call it when necessary as well.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，我们将在`TDView`类中实现一个`startGame`方法。构造函数将能够调用它，并且我们的游戏循环在必要时也可以调用它。
- en: It will also be necessary to pass some of the tasks that the constructor currently
    performs onto the new `startGame` method so that it can properly do its job. Also,
    we will use `startGame` to initialize some of the variables that our game rules
    and HUD require.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要将构造函数当前执行的一些任务传递给新的 `startGame` 方法，以便它能够正确地完成其工作。此外，我们将使用 `startGame` 来初始化我们游戏规则和HUD所需的某些变量。
- en: 'In order to accomplish what we discussed, `startGame()` will need a copy of
    the application''s `Context` object. So, like we did with `startX` and `startY`,
    we will now make `context` a member of `TDView`. Declare it after the `TDView`
    class declaration:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们讨论的内容，`startGame()` 将需要一个应用 `Context` 对象的副本。所以，就像我们对 `startX` 和 `startY`
    所做的那样，我们现在将 `context` 作为 `TDView` 的成员。在 `TDView` 类声明之后声明它：
- en: '[PRE75]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Initialize it in the constructor right after the call to `super()`, like this:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `super()` 之后立即在构造函数中初始化它，如下所示：
- en: '[PRE76]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: We can now implement the new `startGame` method. Most of the code is just moved
    from the constructor. Note that the subtle but important differences, like using
    the class version of the screen coordinates `screenX` and `screenY` instead of
    the constructor parameters *x* and *y*. Also, we initialize `distanceRemaining`,
    `timeTaken`, and `timeStarted`.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以实施新的 `startGame` 方法。大部分代码只是从构造函数中移动过来。请注意这些微妙但重要的差异，例如使用类的屏幕坐标版本 `screenX`
    和 `screenY` 而不是构造函数参数 *x* 和 *y*。此外，我们还初始化了 `distanceRemaining`、`timeTaken` 和 `timeStarted`。
- en: '[PRE77]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Note
  id: totrans-618
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Are you are wondering what is going on with the `timeStarted` initialization?
    We initialized `startTime` using a method of the `System` class, `currentTimeMillis`.
    Now, `startTime` holds the number of milliseconds since January 1, 1970\. We will
    see how this is used in the upcoming section, *Ending the game*. The `System`
    class has many uses. Here, we use it to get the number of milliseconds since January
    1, 1970\. This is a common system for measuring time in a computer. It is called
    Unix time and the moment before the 1st millisecond of January 1, 1970 is known
    as the Unix Epoch.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 你想知道 `timeStarted` 初始化发生了什么吗？我们使用 `System` 类的方法 `currentTimeMillis` 来初始化 `startTime`。现在，`startTime`
    保存了自1970年1月1日以来的毫秒数。我们将在接下来的部分中看到它是如何被使用的，*结束游戏*。`System` 类有很多用途。在这里，我们使用它来获取自1970年1月1日以来的毫秒数。这是一个在计算机中测量时间的通用系统。它被称为Unix时间，而1970年1月1日第一毫秒之前被称为Unix纪元。
- en: 'Now, comment out or delete the now unnecessary code from the `TDView` constructor
    but add the call to `startGame()` in its place:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，注释掉或删除 `TDView` 构造函数中现在不再需要的代码，但用 `startGame()` 调用替换它：
- en: '[PRE78]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Next, we want to create a method to decrement the `PlayerShip` shield strength.
    This is so that when we detect a collision, we can reduce it by one each time.
    Add this simple method to the `PlayerShip` class:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要创建一个方法来减少 `PlayerShip` 的护盾强度。这样，当我们检测到碰撞时，我们可以每次减少一个。将此简单方法添加到 `PlayerShip`
    类中：
- en: '[PRE79]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Now, we can jump to the `TDView` class's `update` method and add code to implement
    our game rules a bit further. We will add a Boolean variable `hitDetected` just
    before we do all our collision detection. Inside each of the `if` blocks which
    detects a hit, we can set `hitDetected` to `true`.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以跳转到 `TDView` 类的 `update` 方法，并添加代码以进一步实现我们的游戏规则。我们将在进行所有碰撞检测之前添加一个布尔变量
    `hitDetected`。在每个检测到击中的 `if` 块内部，我们可以将 `hitDetected` 设置为 `true`。
- en: 'Then, after all the collision detection code, we can see if a hit has been
    detected and reduce the player''s shield strength accordingly. Here is the top
    part of the `TDView` class''s `update` method with the new lines of code highlighted:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在所有碰撞检测代码之后，我们可以检查是否检测到击中，并相应地减少玩家的护盾强度。以下是 `TDView` 类的 `update` 方法的顶部部分，其中新的代码行被突出显示：
- en: '[PRE80]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Note the nested if statement after the call to `player.reduceShieldStrength`.
    This detects when the player has lost all their shields and failed. We will deal
    with what happens here soon.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在调用 `player.reduceShieldStrength` 之后嵌套的 `if` 语句。这检测玩家是否已经失去了所有的护盾并失败了。我们将很快处理这里发生的事情。
- en: We are really close to finishing off our game rules. We just need to decrease
    the `distanceRemaining` relative to the player's speed. This is so that we know
    when the player has succeeded. We also need to update the `timeTaken` variable
    so that the HUD is updated each time our draw method is called. This may not seem
    important, but thinking ahead a little, we can foresee a time when the game has
    ended, either because the player has failed or because the player has won. Let's
    talk about the end of the game.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 我们离完成游戏规则已经非常接近了。我们只需要根据玩家的速度减少`distanceRemaining`的相对值。这样我们就可以知道玩家何时成功。我们还需要更新`timeTaken`变量，以便每次调用绘制方法时更新HUD。这看起来可能并不重要，但稍微提前思考一下，我们可以预见游戏结束的时间，无论是由于玩家失败还是获胜。让我们来谈谈游戏的结束。
- en: Ending the game
  id: totrans-629
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏结束
- en: 'If the game is not ended, the game is playing, and if the player has just died
    or won, the game is ended. We need to know when the game is ended and when it
    is playing. Let''s make a new member variable `gameEnded` and declare it after
    the `TDView` class declaration:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 如果游戏没有结束，游戏正在进行，如果玩家刚刚死亡或获胜，则游戏结束。我们需要知道游戏何时结束以及何时在进行。让我们创建一个新的成员变量`gameEnded`，并在`TDView`类声明之后声明它：
- en: '[PRE81]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Now, we can initialize `gameEnded` in the `startGame` method. Enter this code
    as the very last line in the method.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在`startGame`方法中初始化`gameEnded`。将此代码作为方法中的最后一行输入。
- en: '[PRE82]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now, we can finish the last few lines of our game rules logic, but wrap them
    in a test to see if the game has ended or not. Add the following code to conditionally
    update our game rules logic, right at the end of the `TDView` class''s `update`
    method:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以完成游戏规则逻辑的最后几行，但将它们包裹在一个测试中，以查看游戏是否已经结束。将以下代码添加到`TDView`类的`update`方法末尾，以条件性地更新我们的游戏规则逻辑：
- en: '[PRE83]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Our HUD will now have accurate data to keep the player informed of exactly
    how they are doing. We can also detect when the player arrives home and wins because
    `distanceRemaining` will pass zero. In addition, when distance remaining is less
    than zero, we can test to see if `timeTaken` is less than `fastestTime` and update
    `fastestTime` if it is. We can also set `gameEnded` to `true`. Add this code directly
    after the last block of code in the `TDView` class''s `update` method:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的HUD现在将具有准确的数据，以让玩家了解他们确切的情况。我们还可以检测玩家何时到达家并获胜，因为`distanceRemaining`将超过零。此外，当剩余距离小于零时，我们可以测试`timeTaken`是否小于`fastestTime`，并在必要时更新`fastestTime`。我们还可以将`gameEnded`设置为`true`。将此代码直接添加到`TDView`类`update`方法的最后一个代码块之后：
- en: '[PRE84]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'We ended the game when the player won; now, add this next line of code to end
    the game when the player loses all their shields. Update this code in the `TDView`
    class''s `update` method. The new line of code is highlighted:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家获胜时，我们结束了游戏；现在，在`TDView`类的`update`方法中添加此行代码以结束游戏，当玩家失去所有护盾时：
- en: '[PRE85]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Now, we just need to make something actually happen when `gameEnded` is set
    to true.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要在`gameEnded`设置为`true`时让一些事情真正发生。
- en: 'One way to do this is to alternate how we draw the HUD based on whether the
    `gameEnded` Boolean is true or false. Identify the HUD drawing code in the `draw`
    method, shown again here for easy reference:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事的一种方法是根据`gameEnded`布尔值是真是假来交替绘制HUD。在`draw`方法中识别HUD绘制代码，如下再次显示，以便于参考：
- en: '[PRE86]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'We want to wrap that code in an `if`-`else` block. If the game is not ended,
    draw the normal HUD else draw an alternative. Wrap the HUD drawing code like this:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将这段代码包裹在一个`if-else`块中。如果游戏没有结束，则绘制正常HUD，否则绘制替代HUD。将HUD绘制代码包裹如下：
- en: '[PRE87]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Now, let''s deal with the `else` block, which we will execute when the game
    is ended. What we will do is draw a big **Game Over**, and show the end game stats
    from the HUD. The thread continues on but the HUD stops updating. Enter this code
    in the `else` block:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们处理`else`块，我们将在这个块中执行游戏结束时的操作。我们将绘制一个大的**游戏结束**，并显示从HUD中获取的结束游戏统计数据。线程将继续，但HUD将停止更新。在`else`块中输入以下代码：
- en: '[PRE88]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Note that we switch text sizes using `setTextSize()`, and we align all the
    text in the center of the screen using `setTextAlign()`. This is what it looks
    like when you run the game. We just need a way to restart the game after it has
    ended:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用`setTextSize()`切换文本大小，并使用`setTextAlign()`将屏幕中心的所有文本对齐。这就是运行游戏时的样子。我们只需要在游戏结束后有一种方法可以重启游戏：
- en: '![Ending the game](img/B04322_04_02.jpg)'
  id: totrans-648
  prefs: []
  type: TYPE_IMG
  zh: '![游戏结束](img/B04322_04_02.jpg)'
- en: Restarting the game
  id: totrans-649
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重启游戏
- en: 'To allow the player to restart after the game has ended, we just need to listen
    for a touch and call `startGame()`. Lets edit our `onTouchListener()` code to
    achieve this. The case `MotionEvent.ACTION_DOWN:` is the case we are interested
    in amending. We can simply add conditions here that if the screen is touched while
    the game is ended, restart. The new code to add to case `MotionEvent.ACTION_DOWN:`
    is highlighted:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许玩家在游戏结束后重新开始，我们只需要监听触摸并调用`startGame()`。让我们编辑我们的`onTouchListener()`代码来实现这一点。我们感兴趣的修正案例是`MotionEvent.ACTION_DOWN:`。我们可以在其中添加条件，如果游戏结束时屏幕被触摸，则重新启动。要添加到`MotionEvent.ACTION_DOWN:`案例的新代码已突出显示：
- en: '[PRE89]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Try it out. You can now restart the game from the pause menu by tapping the
    screen. Is it just me or is it a bit quiet round here?
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下。你现在可以从暂停菜单通过点击屏幕来重新启动游戏。是不是只有我觉得这里有点安静？
- en: Adding sound FX
  id: totrans-653
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加声音效果
- en: Adding sound effects in Android is really straightforward. First, let's look
    at where we can get our sound FX from. If you just want to get on with the coding,
    you can use my sound FX in the `Chapter4/assets` folder.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 在安卓中添加声音效果非常简单。首先，让我们看看我们可以在哪里获取我们的声音效果。如果你只想继续编码，你可以使用我在`Chapter4/assets`文件夹中的声音效果。
- en: Generating the FX
  id: totrans-655
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成声音效果
- en: 'We require four sound FX for our Tappy Defender game:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为我们的Tappy Defender游戏准备四个声音效果：
- en: The sound for when our player crashes into an alien, which we will call `bump.ogg`.
  id: totrans-657
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们的玩家撞到外星人的声音，我们将称之为`bump.ogg`。
- en: The sound for when the player is destroyed, which we will call `destroyed.ogg`.
  id: totrans-658
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当玩家被摧毁时的声音，我们将称之为`destroyed.ogg`。
- en: A fun sound for when the game first begins, which we will call `start.ogg`.
  id: totrans-659
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当游戏刚开始时的一种有趣的声音，我们将称之为`start.ogg`。
- en: Finally, a victory whoop-type sound, which we will call `win.ogg`.
  id: totrans-660
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，一种胜利时的欢呼声类型的声音，我们将称之为`win.ogg`。
- en: Here is a very quick guide to make these sound FX using BFXR. Grab a free copy
    of BFXR from [www.bfxr.net](http://www.bfxr.net).
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用BFXR制作这些声音效果的快速指南。从[www.bfxr.net](http://www.bfxr.net)获取BFXR的免费副本。
- en: Follow the simple instructions on the website to set it up. Try out a few of
    these things to make our cool sound FX.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 按照网站上的简单说明来设置它。尝试一些这些操作来制作我们酷炫的声音效果。
- en: Note
  id: totrans-663
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is a very condensed tutorial. You can do so much with BFXR. To learn more
    read the tips on the website at the previous URL.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简化的教程。你可以用BFXR做很多事情。要了解更多，请阅读之前URL上的网站上的提示。
- en: Run `bfxr.exe`.![Generating the FX](img/B04322_04_03.jpg)
  id: totrans-665
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`bfxr.exe`。![生成声音效果](img/B04322_04_03.jpg)
- en: Try out all the preset types, which generate a random sound of the type you
    are working on. When you have a sound that is close to what you want, move to
    the next step:![Generating the FX](img/B04322_04_05.jpg)
  id: totrans-666
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试所有预设类型，这些类型会生成你正在工作的随机声音。当你得到一个接近你想要的声音时，移动到下一步：![生成声音效果](img/B04322_04_05.jpg)
- en: Use the sliders to fine-tune the pitch, duration, and other aspects of your
    new sound:![Generating the FX](img/B04322_04_04.jpg)
  id: totrans-667
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用滑块来微调你新声音的音高、时长和其他方面：![生成声音效果](img/B04322_04_04.jpg)
- en: Save your sound by clicking on the **Export Wav** button. Despite the name of
    this button, as we will see we can save in formats other than `.wav` too.![Generating
    the FX](img/B04322_04_06.jpg)
  id: totrans-668
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**导出Wav**按钮保存你的声音。尽管这个按钮的名称是`.wav`，但我们会看到我们还可以保存其他格式的文件。![生成声音效果](img/B04322_04_06.jpg)
- en: Android likes to work with sounds in the OGG format, so when asked to name your
    file use the `.ogg` extension at the end of the filename. Remember we need to
    create `bump.ogg`, `destroyed.ogg`, `start.ogg`, and `win.ogg`.
  id: totrans-669
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安卓喜欢使用OGG格式的声音，所以当被要求命名文件时，在文件名末尾使用`.ogg`扩展名。记住我们需要创建`bump.ogg`、`destroyed.ogg`、`start.ogg`和`win.ogg`。
- en: Repeat steps 2 to 5 and create the four sound FX that we discussed.
  id: totrans-670
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤2到5，创建我们讨论过的四个声音效果。
- en: Right-click the `app` folder in Android Studio. From the pop-up menu, navigate
    to **New** | **Android resource directory**.
  id: totrans-671
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击Android Studio中的`app`文件夹。从弹出菜单中，导航到**新建** | **Android资源目录**。
- en: In the **Directory name** field, type `assets`. Click on **OK** to create the
    `assets` folder.
  id: totrans-672
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**目录名称**字段中，输入`assets`。点击**确定**来创建`assets`文件夹。
- en: Use your operating system's file manager to add a folder called `assets` to
    the main folder of the project, then add the four sound files to the new assets
    folder in your project.
  id: totrans-673
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你的操作系统文件管理器将一个名为`assets`的文件夹添加到项目的根目录中，然后将四个声音文件添加到项目中的新`assets`文件夹。
- en: The SoundPool class
  id: totrans-674
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SoundPool类
- en: To play our sounds, we will use the `SoundPool` class. We are using the deprecated
    version of the `SoundPool` constructor because the new version needs API 21 or
    newer and it is likely that lots of readers will be using an earlier version of
    Android. We can dynamically get the Android version and provide a different version
    of the code for pre- and post-API level 21, but the older constructor meets our
    needs.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 要播放我们的声音，我们将使用`SoundPool`类。我们使用已弃用的`SoundPool`构造函数，因为新版本需要API 21或更高版本，而且很可能许多读者仍在使用Android的早期版本。我们可以动态获取Android版本，并为API级别21之前和之后提供不同的代码版本，但较旧的构造函数符合我们的需求。
- en: Coding the sound FX
  id: totrans-676
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写声音效果
- en: 'Declare a `SoundPool` object and some integers to represent the individual
    sounds. Add this code just after the `TDView` class declaration:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 声明一个`SoundPool`对象和一些整数来表示单个声音。在`TDView`类声明之后立即添加此代码：
- en: '[PRE90]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Next, we can initialize our `SoundPool` object and our integer sound IDs. We
    wrap the code in a `try`-`catch` block as required.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以初始化我们的`SoundPool`对象和整数声音ID。我们按照要求将代码包裹在`try`-`catch`块中。
- en: 'Note that the call to `load()` starts a process of converting our `.ogg` files
    to raw sound data. If the process is not finished when a call to `playSound()`
    is made, the sound won''t play. The calls to `load()` are in the likely order
    of them being used to minimize this possibility. Enter this code in the constructor
    of our `TDView` class as shown. The new code is highlighted:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，调用`load()`开始了一个将我们的`.ogg`文件转换为原始声音数据的过程。如果在调用`playSound()`时此过程尚未完成，则声音将无法播放。`load()`的调用顺序很可能是它们被使用的顺序，以最大限度地减少这种可能性。按照如下所示，将此代码放入我们的`TDView`类的构造函数中。新的代码已高亮显示：
- en: '[PRE91]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Add a call to `playSound()` using the appropriate reference at the points in
    our code which represent the appropriate event in our game. We have four sounds,
    so four calls to `playSound()` will be made.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中代表游戏中的适当事件的适当位置使用适当的引用调用`playSound()`。我们有四个声音，所以将调用四次`playSound()`。
- en: 'The first goes at the very end of the `startGame()` method:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个放在`startGame()`方法的最后：
- en: '[PRE92]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The next two are highlighted in the `if(hitDetected)` block:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 下两个在`if(hitDetected)`块中高亮显示：
- en: '[PRE93]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The last one is in the `if(distanceRemaining < 0)` block, as highlighted:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个在`if(distanceRemaining < 0)`块中，如下所示高亮显示：
- en: '[PRE94]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: It's time to run Tappy Defender now and hear the sound in action.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候运行Tappy Defender并听到实际操作的声音了。
- en: We will see how to save our player's high score by saving it to a file when
    they achieve it and loading it back up again when Tappy Defender starts.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何通过在玩家达到高分时将其保存到文件，并在Tappy Defender启动时再次加载，来保存玩家的最高分。
- en: Adding persistence
  id: totrans-691
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加持久性
- en: You may have noticed that the current fastest time is zero and can therefore
    never be beaten. The other problem is that every time the player quits the game
    the high score is lost. Now, we will load a default high score from a file. When
    a new high score is achieved, save it to the file. It doesn't matter if the player
    quits the game or even switches off their phone; their high score will remain.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到当前的最快时间是零，因此永远无法打破。另一个问题是，每次玩家退出游戏时，高分都会丢失。现在，我们将从文件中加载默认高分。当达到新的高分时，将其保存到文件中。无论玩家是否退出游戏，甚至关闭他们的手机，他们的高分都将保持不变。
- en: 'First we need two new objects. Declare them as members of the `TDView` class
    after the `TDView` class declaration. The first is a `SharedPreferences` object
    and the second is an `Editor` object, which actually writes to the file for us:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要两个新对象。在`TDView`类声明之后，将它们声明为`TDView`类的成员。第一个是一个`SharedPreferences`对象，第二个是一个`Editor`对象，它实际上为我们写入文件：
- en: '[PRE95]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'We use `prefs` first as we just want to attempt to load a high score if one
    exists. We will also initialize `editor` ready for when we save our high score.
    We do this in the `TDView` constructor:'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用`prefs`，因为我们只想尝试加载一个高分，如果有的话。我们还将初始化`editor`，以便在保存我们的高分时使用。我们在`TDView`构造函数中这样做：
- en: '[PRE96]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Let''s use our `Editor` object to write any new fastest times to the `HiScores`
    file when appropriate. Add the extra highlighted lines shown to add the proposed
    changes to our file, first into a buffer and then commit the changes:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用我们的`Editor`对象在适当的时候将任何新的最快时间写入`HiScores`文件。添加额外的显示行以将建议的更改添加到我们的文件中，首先放入缓冲区，然后提交更改：
- en: '[PRE97]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The last thing we need to do is get the home screen to load up the fastest time
    and display it to the player. We will load the fastest time in exactly the same
    way as we did in our `TDView` constructor. We will also get a reference to our
    `TextView` through its ID `textHighScore`, which we assigned way back at the beginning
    of [Chapter 2](ch11.html "Chapter 2. Tappy Defender – First Step"), *Tappy Defender
    – First Step*. We then use the `setText` method to display it to the player.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后需要做的是让主屏幕加载速度最快，并将其显示给玩家。我们将以与我们在 `TDView` 构造函数中相同的方式加载最快时间。我们还将通过其 ID `textHighScore`
    获取对 `TextView` 的引用，这是我们早在 [第 2 章](ch11.html "第 2 章。Tappy Defender – 第一步")，*Tappy
    Defender – 第一步* 中分配的。然后我们使用 `setText` 方法将其显示给玩家。
- en: 'Open up `MainActivity.java` and add the highlighted code to the `onCreate`
    method to achieve what we just discussed:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `MainActivity.java` 文件，并将高亮代码添加到 `onCreate` 方法中，以实现我们刚才讨论的内容：
- en: '[PRE98]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Now, we have a complete working game. However, it is not really finished yet.
    To make a game that is genuinely playable and fun, we have to improve, refine,
    test, and iterate.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个完整的可工作游戏。然而，它还没有真正完成。为了制作一个真正可玩且有趣的游戏，我们必须改进、精炼、测试和迭代。
- en: Iteration
  id: totrans-703
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代
- en: How can we make our game better and more playable? Let's look at a number of
    possibilities and then go ahead and implement them.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何使我们的游戏更好、更易玩？让我们看看一些可能性，然后继续实施它们。
- en: Multiple different enemy graphics
  id: totrans-705
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多种不同的敌人图形
- en: Let's make the enemies a bit more interesting by adding a few more graphics
    to the game. First, we need to add the extra graphics to the project. Copy and
    paste `enemy2.png` and `enemy3.png` from the `Chapter4/drawables` folder of the
    download bundle into the `drawables` folder in Android Studio.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在游戏中添加更多图形来使敌人更有趣。首先，我们需要将额外的图形添加到项目中。从下载包的 `Chapter4/drawables` 文件夹中复制并粘贴
    `enemy2.png` 和 `enemy3.png` 到 Android Studio 的 `drawables` 文件夹中。
- en: '![Multiple different enemy graphics](img/B04322_04_07.jpg)'
  id: totrans-707
  prefs: []
  type: TYPE_IMG
  zh: '![多种不同的敌人图形](img/B04322_04_07.jpg)'
- en: enemy2 and enemy3
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: enemy2 和 enemy3
- en: 'Now, we just need to amend the `EnemyShip` constructor. This code generates
    a random number between 0 and 2, and then switches to load a different enemy bitmap
    accordingly. Our completed constructor now looks like this:'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要修改 `EnemyShip` 构造函数。此代码生成一个介于 0 和 2 之间的随机数，然后根据该随机数加载不同的敌人位图。我们的完成后的构造函数现在看起来是这样的：
- en: '[PRE99]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Note that we just need to move the `Random generator = new Random();` line of
    code to the top of the constructor, so we can use it to choose a bitmap as well
    as generate a random height later in the constructor, as usual.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们只需要将 `Random generator = new Random();` 这行代码移动到构造函数的顶部，这样我们就可以使用它来选择位图，并在构造函数的后面生成随机高度，就像通常一样。
- en: An exercise in balance
  id: totrans-712
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平衡练习
- en: Probably the biggest playability issue in the game is the difference in difficulty
    when playing on a medium/high resolution screen as opposed to a low resolution
    screen. For example, one of my testing devices is a Samsung Galaxy S2\. It is
    a few years old now, and the screen resolution is 800 x 480 pixels when held in
    the landscape position. For comparison, I tested the game on a Samsung Galaxy
    S4 that has 1920 x 1080 pixels in landscape mode. This is more than double the
    resolution of the S2.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中可能最大的可玩性问题是在中等/高分辨率屏幕上玩游戏与在低分辨率屏幕上玩游戏时难度的差异。例如，我的一个测试设备是三星 Galaxy S2。现在它已经几年了，当以横屏位置持有时，屏幕分辨率为
    800 x 480 像素。为了比较，我在具有横屏模式下 1920 x 1080 像素的三星 Galaxy S4 上测试了游戏。这是 S2 分辨率的超过两倍。
- en: On the S4, the player seems to effortlessly glide in between the almost insignificant
    enemies, while on the S2, the player is faced with an almost impenetrable wall
    of alien steel.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 在 S4 设备上，玩家似乎可以毫不费力地在几乎微不足道的敌人之间滑行，而在 S2 设备上，玩家则面临几乎无法穿透的外星钢铁壁垒。
- en: The real solution to this problem is to draw game objects at pseudo-real-world
    coordinates, and then map these coordinates back to the device at the same scale,
    regardless of resolution. This way, the game will look and play the same on both
    an S2 and an S4\. In the next project, we will build a more advanced game engine
    that does this.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的真正方法是使用伪真实世界坐标绘制游戏对象，然后将这些坐标以相同的比例映射回设备，无论分辨率如何。这样，游戏在 S2 和 S4 设备上看起来和玩起来都一样。在下一个项目中，我们将构建一个更先进的游戏引擎来完成这项工作。
- en: Of course, we will still have the consideration of the actual physical screen
    size, making the player's experience varied, but this is a much more accepted
    situation by gamers.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们仍然需要考虑实际物理屏幕大小，使玩家的体验多样化，但这是游戏玩家更易于接受的情况。
- en: As a quick and dirty solution, we will vary the size of the ships and the number
    of enemies. So on lower resolutions, we will have three enemies, but we will shrink
    their size. On higher resolutions, we will increase the number of enemies gradually.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种快速且不完美的解决方案，我们将改变飞船的大小和敌人的数量。所以，在低分辨率下，我们将有三个敌人，但我们将缩小它们的大小。在高分辨率下，我们将逐渐增加敌人的数量。
- en: 'In the `EnemyShip` class, just after the `switch` block that loads our enemy
    graphics into our `Bitmap` object, add the line shown highlighted to call a new
    method that we will write soon, `scaleBitmap()`:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 在`EnemyShip`类中，在将敌人图形加载到我们的`Bitmap`对象中的`switch`块之后，添加一行突出显示的行以调用我们很快将要编写的新的方法`scaleBitmap()`：
- en: '[PRE100]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Now, we will write our new `scaleBitmap` method. This simple helper method
    takes a single argument, which as we have seen is the horizontal resolution of
    the screen. We then use the resolution and the static `createScaledBitmap` method
    to reduce our `Bitmap` objects on a scale of 2 or 3 depending on the resolution
    of the screen. Add the new `scaleBitmap` method to the `EnemyShip` class:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写我们的新`scaleBitmap`方法。这个简单的辅助方法接受一个参数，正如我们所看到的，它是屏幕的水平分辨率。然后我们使用分辨率和静态`createScaledBitmap`方法，根据屏幕的分辨率以2或3的比例减少我们的`Bitmap`对象。将新的`scaleBitmap`方法添加到`EnemyShip`类中：
- en: '[PRE101]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The enemies will be scaled down in size on lower resolution screens. Now, let's
    increase the number of enemies for the higher resolutions.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 在低分辨率屏幕上，敌人将被缩小。现在，让我们增加高分辨率屏幕上的敌人数量。
- en: For this, we will add code to the `TDView` class to add extra enemies to higher
    resolution screens.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个，我们将在`TDView`类中添加代码，以在更高分辨率的屏幕上添加额外的敌人。
- en: Note
  id: totrans-724
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Warning! This code sucks, but it works and it shows us where we can make improvements
    in our next project. When planning a game, there is always a trade-off between
    good design and simplicity. By keeping things organized from the start, we can
    get away with a bit of hacking near the end. Yes, we can redesign the way we spawn
    and store our game objects, and if Tappy Defender was an ongoing project then
    this would be worthwhile.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 警告！这段代码很糟糕，但它能工作，并且它展示了我们如何在下一个项目中改进。在规划游戏时，总是在良好的设计和简洁性之间进行权衡。通过从一开始就保持事物组织，我们可以在最后阶段进行一些黑客行为。是的，我们可以重新设计生成和存储游戏对象的方式，如果Tappy
    Defender是一个持续的项目，那么这将是有价值的。
- en: 'Add two more enemy ship objects after the first three, as shown:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 在前三个之后，添加两个更多的敌人飞船对象，如下所示：
- en: '[PRE102]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Now, add code to conditionally initialize these two new objects in the `startGame`
    method:'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`startGame`方法中添加代码，有条件地初始化这两个新对象：
- en: '[PRE103]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Add code in the `update` method to update our fourth and fifth enemies and
    check for collisions:'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 在`update`方法中添加代码以更新我们的第四和第五个敌人并检查碰撞：
- en: '[PRE104]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Finally, in the `draw` method, draw our extra enemies when appropriate:'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`draw`方法中，在适当的时候绘制额外的敌人：
- en: '[PRE105]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Of course, we now realize that we may like to scale the player as well. This
    makes it plain that perhaps we need a `Ship` class, from which we can derive `PlayerShip`
    and `EnemyShip`.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们现在意识到我们可能希望缩放玩家。这清楚地表明我们可能需要一个`Ship`类，我们可以从中派生出`PlayerShip`和`EnemyShip`。
- en: Add to this the cumbersome manner in which we added the extra enemies for higher
    resolution screens and a much more polymorphic solution is probably worthwhile.
    We will see how we can seriously improve this and virtually every other aspect
    of our game engine in the next project.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 将这添加到我们为更高分辨率屏幕添加额外敌人的繁琐方式中，并且可能一个更具有多态性的解决方案是值得的。我们将看到我们如何可以真正改进这个和游戏引擎的几乎每个其他方面，在下一个项目中。
- en: Format time
  id: totrans-736
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 格式化时间
- en: 'Look at how time is formatted in the player''s HUD:'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 看看玩家HUD中时间是如何格式化的：
- en: '![Format time](img/B04322_04_08.jpg)'
  id: totrans-738
  prefs: []
  type: TYPE_IMG
  zh: '![格式化时间](img/B04322_04_08.jpg)'
- en: Yuck! Let's write a simple helper method to make this look a whole lot nicer.
    We will add a new method to the `TDView` class called `formatTime()`. The method
    uses the number of elapsed milliseconds in this game (`timeTaken`) and reorganizes
    them into seconds and fractions of a second. It pads the fractions with zeros
    where appropriate and returns the result as a `String` ready to be drawn in the
    `TDView` class's `draw` method. The reason the method takes an argument rather
    than just using the member variable `timeTaken` is so we can reuse this code in
    a minute.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 不好！让我们编写一个简单的辅助方法，让它看起来好得多。我们将在`TDView`类中添加一个新的方法，称为`formatTime()`。该方法使用游戏中经过的毫秒数（`timeTaken`），并将它们重新组织成秒和秒的分数。在适当的地方用零填充分数，并将结果作为`String`返回，以便在`TDView`类的`draw`方法中绘制。这个方法接受一个参数而不是仅仅使用成员变量`timeTaken`的原因是我们可以在一分钟内重用这段代码。
- en: '[PRE106]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'We amend the line that draws the time in the player''s HUD. For context, in
    the next piece of code, I have commented out the entirety of the original line
    and provided the new line, which includes our call to `formatTime()`, and highlighted
    it:'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 我们修改了绘制玩家HUD中时间的行。为了说明，在下一段代码中，我已将原始行全部注释掉，并提供了新的行，其中包含了我们的`formatTime()`调用，并对其进行了突出显示：
- en: '[PRE107]'
  id: totrans-742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'In addition, with one minor change, we can use this formatting on the **Fastest:**
    label in the HUD as well. Again, the old line is commented out and the new one
    is highlighted. Find and amend the code in the `TDView` class''s `draw` method:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通过一个小的更改，我们可以在HUD中的**最快：**标签上使用这种格式化。同样，旧行已被注释，新行被突出显示。在`TDView`类的`draw`方法中找到并修改代码：
- en: '[PRE108]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'We should also update the time formatting on the pause screen. The lines to
    change are commented out and the new lines to add are highlighted:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该更新暂停屏幕上的时间格式。需要更改的行已被注释，新添加的行被突出显示：
- en: '[PRE109]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '**Fastest:** is now formatted in the same way as **Time:** on both the in-game
    HUD and the pause screen HUD. Take a look at our neatly formatted time now:'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: '**最快：**现在以与**时间：**相同的方式在游戏内HUD和暂停屏幕HUD中格式化。看看我们现在整洁的时间格式：'
- en: '![Format time](img/B04322_04_09.jpg)'
  id: totrans-748
  prefs: []
  type: TYPE_IMG
  zh: '![格式化时间](img/B04322_04_09.jpg)'
- en: Handle the back button
  id: totrans-749
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理返回按钮
- en: We will quickly add a small block of code to handle what happens when the player
    presses the back button on their Android device. Add this new method to both the
    `GameActivity` and `MainActivity` classes. We simply check if the back button
    was pressed, and if it was, call `finish()` to let the operating system know we
    are done with this activity.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将快速添加一小段代码来处理当玩家在他们的Android设备上按下返回按钮时会发生什么。将这个新方法添加到`GameActivity`和`MainActivity`类中。我们只需检查是否按下了返回按钮，如果是，就调用`finish()`来让操作系统知道我们已经完成了这个活动。
- en: '[PRE110]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The finished game
  id: totrans-752
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成的游戏
- en: 'Finally, in case you are following along for the theory and not the practical,
    here is the finished `GameActivity` on a high resolution screen with a few hundred
    extra stars and shields:'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你是跟随理论而不是实践，这里是一个在高清屏幕上完成的`GameActivity`，有几百个额外的星星和盾牌：
- en: '![The finished game](img/B04322_04_10.jpg)'
  id: totrans-754
  prefs: []
  type: TYPE_IMG
  zh: '![完成的游戏](img/B04322_04_10.jpg)'
- en: Summary
  id: totrans-755
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have implemented the component parts of a basic game engine. We can do so
    much more. Of course, a modern mobile game will have a lot more going on than
    in ours. How will we handle collisions when there are lots more game objects?
    Couldn't we tighten up our class hierarchy a bit, as there were lots of similarities
    between our `PlayerShip` and `EnemyShip` classes? How can we add complex internal
    character animations without confusing the structure of our code, and what if
    we want smart enemies, enemies who can actually think?
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了基本游戏引擎的各个组成部分。我们可以做更多的事情。当然，一个现代移动游戏将比我们的游戏有更多的事情发生。当有更多游戏对象时，我们如何处理碰撞？我们能不能把我们的类层次结构稍微整理一下，因为我们的`PlayerShip`和`EnemyShip`类之间有很多相似之处？我们如何添加复杂的内部角色动画，而不会使我们的代码结构混乱，如果我们想有智能敌人，敌人实际上能思考怎么办？
- en: We need realistic backgrounds, side objectives, power-ups, and pick-ups. We
    want a game world with real-world coordinates that map back accurately regardless
    of the resolution of the screen.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要逼真的背景、辅助目标、升级道具和拾取物品。我们希望游戏世界具有现实世界的坐标，无论屏幕分辨率如何，都能准确映射。
- en: We need a smarter game loop that runs the game at the same speed regardless
    of the CPU it is being processed on. Most of all, what we really need, more than
    any of these things, is a dirty big machine gun. Let's build a classic platform
    game.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个更智能的游戏循环，无论在哪个CPU上运行，都能以相同的速度运行游戏。最重要的是，我们真正需要的，比这些都要多的是一台非常大的机关枪。让我们打造一个经典平台游戏。
- en: Chapter 5. Platformer – Upgrading the Game Engine
  id: totrans-759
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。平台游戏 – 升级游戏引擎
- en: Welcome to the second project of this book. Here, we will build a really tough
    retro platform game. It is not tough to build, but tough to beat when you play
    it. At the end of the project, we will also discuss ways to make the game play
    a little less punishing should you wish.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到这本书的第二个项目。在这里，我们将打造一个真正的艰难复古平台游戏。虽然制作起来不难，但当你玩的时候却很难打败。在项目结束时，我们还将讨论如果你希望的话，如何让游戏玩起来不那么严厉。
- en: This chapter will focus entirely on our game engine and essentially lead to
    an upgraded version of the Tappy Defender code.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将完全专注于我们的游戏引擎，并本质上将导致Tappy Defender代码的升级版本。
- en: 'First, we will discuss what we want to achieve with this game: the backstory,
    game mechanics, and rules.'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将讨论我们希望通过这个游戏实现什么：背景故事、游戏机制和规则。
- en: Then, we will quickly create an activity that instantiates a view that will
    do all the work.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们将快速创建一个活动，实例化一个视图，该视图将完成所有工作。
- en: After that, we will flesh out the basic structure of our `PlatformView` class,
    which will have some subtle, but important differences to our `TDView` class.
    Most notably, `PlatformView` will have a simple but effective way of managing
    the timing of all the events of our game.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将完善我们的 `PlatformView` 类的基本结构，它与我们的 `TDView` 类有一些微妙但重要的区别。最值得注意的是，`PlatformView`
    将有一种简单但有效的方法来管理我们游戏中所有事件的时机。
- en: We will then start the iterative process of building our `GameObject` class,
    from which almost every entity of the game world will be derived.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将开始迭代构建我们的 `GameObject` 类，几乎游戏世界中的每个实体都将从这个类派生出来。
- en: Next, we will discuss the concept of a viewport through which the game world
    is viewed by the player. We will no longer be designing our game objects to operate
    at the level of the screen resolution, but they will now exist in a world with
    their own *x* and *y* coordinates that we can think of as virtual meters. There
    is also a simple system of depth on the *z* axis as well. This will be handled
    by our new `Viewport` class.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论视口的概念，通过视口玩家可以看到游戏世界。我们将不再设计我们的游戏对象以屏幕分辨率级别运行，但它们现在存在于一个有自己 *x* 和 *y*
    坐标的世界上，我们可以将其视为虚拟米。在 *z* 轴上还有一个简单的深度系统。这将由我们新的 `Viewport` 类处理。
- en: After this, we will look at how we design and layout the content of our game.
    This is done via a class that is used as a level designer and can be used in a
    nonprogrammatic way to map out the jumps, enemies, rewards, and goals that constitute
    the layout of a level.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将探讨如何设计和布局我们的游戏内容。这是通过一个用作关卡设计师的类来完成的，并且可以用非编程方式来绘制跳跃、敌人、奖励和目标，这些构成了关卡布局。
- en: To manage the level designs and load them into our game engine, we will need
    another class. We will call it `LevelManager`.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理关卡设计和将它们加载到我们的游戏引擎中，我们需要另一个类。我们将称之为 `LevelManager`。
- en: Finally in this chapter, we will look at our enhanced `update` and `draw` methods
    within the `PlatformView` class so that we can actually run our new game and see
    the first output on the screen.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 最后在本章中，我们将查看 `PlatformView` 类中增强的 `update` 和 `draw` 方法，这样我们就可以真正运行我们的新游戏，并在屏幕上看到第一个输出。
- en: With so much to do, we better get started.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 有这么多事情要做，我们最好开始行动了。
- en: The game
  id: totrans-771
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏
- en: The game we will build is based on the game play of some of the brutally hard
    platform games of the '80s, such as Bounty Bob Strikes Back and Impossible Mission.
    These games featured difficult jumps and required insanely precise timing at the
    same time as giving the player an unforgiving number of lives/chances. This style
    of game works well for us because we can actually build a multilevel playable
    game in just four chapters.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的游戏基于80年代一些残酷难度的平台游戏的游戏玩法，例如《鲍勃的复仇》和《不可能的任务》。这些游戏具有困难的跳跃和需要极端精确的时间控制，同时给玩家一个无法原谅的生命/机会数量。这种游戏风格对我们来说很适用，因为我们实际上可以在四个章节中仅用四个章节构建一个多级可玩游戏。
- en: The design of the classes will make it really easy for you to add your own extra
    features, and game objects or make it slightly less challenging to play should
    you want to.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 类的设计将使您轻松添加自己的额外功能，或者如果您想使游戏稍微容易一些，也可以做到。
- en: The backstory
  id: totrans-774
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背景故事
- en: Our hero Bob, having just returned from a secret mission to destroy an evil
    scientist at the center of the Earth, finds he is deep underground. Worse, it
    seems that although he has defeated the evil scientist, it was not in time to
    save the planet from the powerful guards and deadly flying robot drones that he
    unleashed.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的英雄鲍勃刚刚从秘密任务中返回，任务是摧毁位于地球中心的邪恶科学家，他发现自己深陷地下。更糟糕的是，尽管他击败了邪恶的科学家，但似乎已经来不及拯救地球，因为强大的守卫和致命的飞行机器人无人机已经被他释放出来。
- en: Bob must make his way from the deep underground fiery cave, through the heavily
    guarded city, and forest, high in the mountains, where he hopes to live, free
    from the terrifying new order that has taken over the planet.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 鲍勃必须从深埋地下的炽热洞穴中穿过，经过严密守卫的城市和森林，高耸入云的山脉，他希望在那里生活，摆脱恐怖的新秩序，这个新秩序已经占领了整个星球。
- en: On his journey through these four levels, he must avoid guards, destroy drones,
    collect lots of money, and upgrade his initially puny machine gun.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 在他的四个关卡之旅中，他必须避开守卫，摧毁无人机，收集大量金钱，并升级他最初微不足道的机关枪。
- en: The game mechanics
  id: totrans-778
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏机制
- en: The game will be about executing precise jumps, planning the best route through
    a level to collect the loot and escape. Bob will be able to stand precariously
    on ledges with whole pixels of his feet overhanging, to be able to make seemingly
    impossible jumps. Bob will be able to control the distance he travels while jumping,
    meaning that sometimes he will often need to make sure he doesn't over jump.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏将关于执行精确跳跃，规划通过关卡的最佳路线以收集战利品和逃脱。鲍勃将能够站在边缘上，他的整个脚趾悬空，进行看似不可能的跳跃。鲍勃将能够控制跳跃的距离，这意味着有时他需要确保自己不要跳得太远。
- en: Bob will need to collect machine gun upgrades before attempting to escape via
    heavily guarded areas.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 鲍勃在尝试通过重兵把守的区域逃脱之前，需要收集机枪升级。
- en: Bob will only have three lives, but may be able to find some more on his journey.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 鲍勃只有三条命，但在他的旅途中可能会找到更多。
- en: Rules for the game
  id: totrans-782
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏规则
- en: When Bob loses a life by being caught by a drone/guard, touching fire, or falling
    out of the game world, he will respawn at the start of the current level. Drones
    can fly, and will home in on Bob as soon as he comes into view. Bob will need
    to make sure he has enough firepower to handle the drones. Guards will patrol
    predetermined parts of the level, but they are tough and can only be knocked back
    by Bob's machine gun. Usually, Bob will need to execute a precisely timed jump
    to progress past a guard.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 当鲍勃被无人机/守卫抓住、触碰火焰或从游戏世界中掉落时，他将在当前关卡的开始处重生。无人机可以飞行，并且一旦鲍勃进入视野，就会立即锁定他。鲍勃需要确保他有足够的火力来对付无人机。守卫将在关卡预定的部分巡逻，但它们很坚固，只能被鲍勃的机枪击退。通常，鲍勃需要执行精确时间跳来通过守卫。
- en: The environment will also be tough. Bob will need to completely master each
    level, as one wrong jump will send him plummeting back to the start, straight
    into the clutches of an enemy or even to his fiery death.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 环境也将非常艰难。鲍勃需要完全掌握每个级别，因为一次错误的跳跃会让他直线下坠，回到起点，直接落入敌人的魔爪，甚至可能葬身火海。
- en: Upgrading the game engine
  id: totrans-785
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 升级游戏引擎
- en: All the talk of guards, drones, fire, collectibles, guns, and the implied much
    larger game world suggests a much more complex system to manage. One of the goals
    of our game engine will be to make this complexity easily manageable. The other
    goal will be to separate the level design from the coding. When our game is done,
    you will be able to sit back and design the most evil, yet rewarding levels, in
    multiple different environments without touching the code.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 所有关于守卫、无人机、火焰、可收集物品、枪支以及暗示的更大游戏世界的讨论，都表明需要一个更复杂的系统来管理。我们游戏引擎的一个目标将是使这种复杂性易于管理。另一个目标将是将关卡设计从编码中分离出来。当我们的游戏完成时，你将能够坐下来设计最邪恶、最有回报的关卡，在多个不同的环境中进行设计，而不必触碰代码。
- en: The platform activity
  id: totrans-787
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平台活动
- en: First we start off with our `Activity` class, which is the entry point into
    our game. There is not much new here, so let's go ahead and get it built quickly.
    Create a new project, and in the **Application Name** field, enter `C5 Platform
    Game`. Choose **Phones and tablets**, then **Blank Activity** when prompted. In
    the **Activity Name** field, type `PlatformActivity`.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从我们的`Activity`类开始，这是进入我们游戏的大门。这里没有太多新内容，所以我们快速构建它。创建一个新的项目，在**应用程序名称**字段中输入`C5
    平台游戏`。选择**手机和平板电脑**，然后当提示时选择**空白活动**。在**活动名称**字段中，键入`PlatformActivity`。
- en: Tip
  id: totrans-789
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Obviously you don't have to follow my exact naming choices, but just remember
    to make minor alterations in the code to reflect your own naming choices.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你不必完全遵循我的命名选择，但请记住在代码中进行一些小的修改，以反映你自己的命名选择。
- en: 'You can delete `activity_platform.xml` from the `layout` folder. You can also
    delete all the code within the `PlatformActivity.java` file. Just leave the package
    declaration. Now, we have an entirely blank canvas ready for us to start coding.
    Here is the entirety of our project so far:'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从`layout`文件夹中删除`activity_platform.xml`。你还可以删除`PlatformActivity.java`文件中的所有代码。只需留下包声明。现在，我们有一个完全空白的画布，可以开始编码。以下是到目前为止我们的整个项目：
- en: '[PRE111]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Let's start building our engine. Just like in our Tappy Defender project, we
    will build a class to handle the view aspect of our game. Perhaps unsurprisingly,
    we will call the class `PlatformView`. Therefore, our `PlatformActivity` class
    needs to instantiate a `PlatformView` object and set it as the main view of the
    app, just like in the previous project.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始构建我们的引擎。就像在我们的Tappy Defender项目中一样，我们将构建一个类来处理游戏视图方面。不出所料，我们将把这个类命名为`PlatformView`。因此，我们的`PlatformActivity`类需要实例化一个`PlatformView`对象，并将其设置为应用程序的主视图，就像在先前的项目中一样。
- en: We will be making some significant upgrades to our engine, but this will mainly
    happen in the view. In the code for the `PlatformActivity` class that we will
    look at next, we do much the same as in the previous project. First, declare the
    `PlatformView` object and set it as the main view in the overridden `onCreate`
    method; however, before we do this, we also capture and pass in the resolution
    of the device's screen.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对我们的引擎进行一些重大的升级，但这主要发生在视图方面。在接下来我们将查看的`PlatformActivity`类的代码中，我们与先前的项目做得很相似。首先，在重写的`onCreate`方法中声明`PlatformView`对象并将其设置为主要的视图；然而，在我们这样做之前，我们还会捕获并传递设备的屏幕分辨率。
- en: We do this using the `Display` class and chaining the `getWindowManager()` and
    `getDefaultDisplay()` methods to get the properties of the physical display hardware
    that our game will be running on. Then, we create an object of type `Point` called
    resolution and store the resolution of the display into our `Point` object by
    calling `display.getSize(size)`.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`Display`类，并通过链式调用`getWindowManager()`和`getDefaultDisplay()`方法来获取游戏将运行的物理显示硬件的属性。然后，我们创建一个名为`resolution`的`Point`类型对象，并通过调用`display.getSize(size)`将显示的分辨率存储到我们的`Point`对象中。
- en: This stores the horizontal and vertical number of pixels of the screen into
    `size.x` and `size.y`, respectively. We can then go ahead and instantiate a new
    `PlatformView` object by calling its constructor and passing in the values stored
    in `size.x` and `size.y`. As before, we also pass in the application, `Context`
    object (`this`) that like in the previous project, we will find many uses for.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 这将屏幕的水平和垂直像素数分别存储到`size.x`和`size.y`中。然后，我们可以通过调用其构造函数并传递存储在`size.x`和`size.y`中的值来实例化一个新的`PlatformView`对象。和之前一样，我们也会传递应用程序的`Context`对象（`this`），就像在先前的项目中一样，我们将发现它有很多用途。
- en: We can then set `platformView` as the view by calling `setContentView()` in
    the usual way. As earlier, we override the `Activity` class's lifecycle methods
    `onPause()` and `onResume()` to have them call their respective methods in our
    soon-to-be-written `PlatformView` class. These two methods can then start and
    stop our `Thread` class.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过调用`setContentView()`以通常的方式将`platformView`设置为视图。和之前一样，我们重写`Activity`类的生命周期方法`onPause()`和`onResume()`，使它们调用我们即将编写的`PlatformView`类中的相应方法。这两个方法然后可以启动和停止我们的`Thread`类。
- en: Here is the entirety of the code for the `PlatformActivity` class that we have
    just discussed, with no significant new aspects. Type or copy and paste the code
    into your project. The code for this chapter can be found within the download
    bundle from the book's page on the Packt Publishing website. All the code and
    assets from this chapter can be found in the `Chapter5` folder. This file is called
    `PlatformActivity.java`.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们刚刚讨论的`PlatformActivity`类的全部代码，没有显著的新方面。将代码输入或复制粘贴到您的项目中。本章的代码可以在Packt Publishing网站上的书籍页面的下载捆绑包中找到。本章的所有代码和资源都可以在`Chapter5`文件夹中找到。此文件名为`PlatformActivity.java`。
- en: Tip
  id: totrans-799
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Remember to import all the new classes when prompted to do so, or by pressing
    the *Alt* | *Enter* keyboard combination while hovering the cursor over the error
    when a missing class causes this error.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 当提示导入所有新类时，或者当鼠标悬停在错误上并出现缺失类导致的错误时，请按*Alt* | *Enter*键盘组合来导入所有新类。
- en: '[PRE112]'
  id: totrans-801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Note
  id: totrans-802
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Obviously, until we create our `PlatformView` class, there will be errors in
    our `PlatformActivity` class's code.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，直到我们创建我们的`PlatformView`类，我们的`PlatformActivity`类代码中都会有错误。
- en: Locking the layout to landscape
  id: totrans-804
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 锁定布局为横屏
- en: 'Just as we did for the last project, we will make sure the game runs in the
    landscape mode only. We will make our `AndroidManifest.xml` file force our `PlatformActivity`
    class to run with a full screen, and we will also lock it to a landscape layout.
    Let''s make these changes:'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在上一个项目中做的那样，我们将确保游戏仅在横屏模式下运行。我们将使我们的`AndroidManifest.xml`文件强制我们的`PlatformActivity`类以全屏方式运行，并且我们还将将其锁定为横屏布局。让我们进行以下更改：
- en: Open the `manifests` folder now and double-click the `AndroidManifest.xml` file
    to open it in the code editor.
  id: totrans-806
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开 `manifests` 文件夹，双击 `AndroidManifest.xml` 文件，在代码编辑器中打开它。
- en: 'In the `AndroidManifest.xml` file, find the following line of code:'
  id: totrans-807
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `AndroidManifest.xml` 文件中，找到以下代码行：
- en: '[PRE113]'
  id: totrans-808
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Immediately after it, type or copy and paste these two lines to make `PlatformActivity`
    run full screen and lock it in the landscape orientation.
  id: totrans-809
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 紧接着，输入或复制粘贴以下两行代码，使 `PlatformActivity` 运行全屏并锁定为横屏模式。
- en: '[PRE114]'
  id: totrans-810
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Now, we can move on to the real guts of our game and see how we can implement
    all these improvements we talked about.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续深入到我们游戏的核心部分，看看我们如何实现我们之前讨论的所有改进。
- en: The PlatformView class
  id: totrans-812
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`PlatformView` 类'
- en: This class, by the time it is completed, will be dependent on many other classes.
    I don't want to just present each class in turn, as this would be quite hard to
    follow and exactly what code implements which feature will become confusing. Instead,
    we will look at, and code, each feature in turn, as we require them, and then
    revisit many of the classes multiple times to add more features. This will keep
    the focus on the specific purpose of each part of the code.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 到完成时，这个类将依赖于许多其他类。我不想逐个展示每个类，因为这会相当难以跟踪，而且不清楚哪些代码实现了哪些功能会变得混乱。相反，我们将按需查看和编写每个功能，然后多次回顾许多类以添加更多功能。这将保持对代码每个部分的特定目的的关注。
- en: Having said this, great care has been taken so that although we will revisit
    many of these classes multiple times, we won't be constantly deleting code, just
    adding to it. When we add to it, the code will be presented in its proper context
    with the new parts highlighted among the existing code.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们已经非常小心地处理了这个问题，尽管我们将多次回顾这些类，但我们不会不断删除代码，而是会添加代码。当我们添加代码时，代码将在其适当的环境中呈现，新部分将在现有代码中突出显示。
- en: With regard to the structure of the classes, they are designed to be as minimal
    as possible, while at the same time, not restricting your potential to easily
    add features and extend the code.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 关于类的结构，它们被设计得尽可能简单，同时，又不会限制你轻松添加功能和扩展代码的潜力。
- en: This is not a lesson in game engine design, but more a lesson in seeing how
    many different features we can learn to implement and cram into four chapters,
    without the code becoming unmanageable.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是关于游戏引擎设计的课程，而更多的是关于展示我们可以学习到多少不同的功能，并将它们压缩到四个章节中，而不会使代码变得难以管理。
- en: If you plan to build very large-scale games, especially when working as a team,
    then a more robust design will be necessary. This more robust design will also
    mean a whole lot of extra classes, interfaces, packages, and so on.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划构建大规模的游戏，尤其是在团队合作的情况下，那么需要一个更健壮的设计。这种更健壮的设计也意味着将需要大量的额外类、接口、包等等。
- en: Tip
  id: totrans-818
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If this type of discussion interests you, I highly recommend the book, *Beginning
    Android Games* by Mario Zechner, published by APRESS. Mario is the founder/creator
    of the LibGDX cross-platform game library, and his book goes into great detail
    about the design patterns required to build a highly extensible and reusable code
    base for games. The only downside to the great design detail that this book has,
    is that it would take around 600 pages to build a simple retro Snake game.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这类讨论感兴趣，我强烈推荐 Mario Zechner 编写的书籍，书名为 *《Android 游戏入门》*，由 APRESS 出版。Mario
    是 LibGDX 跨平台游戏库的创始人/创建者，他的书详细介绍了构建高度可扩展和可重用代码库所需的设计模式。这本书的缺点是，要构建一个简单的复古蛇游戏，可能需要大约
    600 页。
- en: First, let's create the class. Right-click on the package name in the Android
    Studio project explorer and navigate to **New** | **Java Class**. Call the new
    class `PlatformView`. Delete the autogenerated contents of the class, as we will
    add our own code soon.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个类。在 Android Studio 项目资源管理器中，右键单击包名，然后导航到 **新建** | **Java 类**。将新类命名为
    `PlatformView`。删除类的自动生成内容，因为我们很快就会添加自己的代码。
- en: We will continue to add code to this class over the entirety of the project.
    The full extent of the code that we add to the class in this chapter can be found
    in the download bundle at `Chapter5/PlatformView.java`.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在整个项目过程中继续向这个类添加代码。本章添加到类中的全部代码可以在 `Chapter5/PlatformView.java` 的下载包中找到。
- en: We need a class that can manage our level. Let's call it `LevelManager`.
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个可以管理我们等级的类。让我们称它为 `LevelManager`。
- en: We also need a class that can hold the data for our level, as we can then extend
    it each time we create a new/different level design. Let's call the parent class
    `LevelData`, and our first real level for Bob to escape from, `LevelCave`.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个可以存储我们关卡数据的类，因为每次我们创建新的/不同的关卡设计时，我们都可以扩展它。让我们称这个父类为`LevelData`，以及鲍勃需要逃离的第一个真实关卡，`LevelCave`。
- en: Furthermore, as this game is going to have many enemies, props, and terrain
    types, we are going to need a cleaner system of managing them all. We need a fairly
    generic `GameObject` class, which all the different game objects can extend. We
    can then manage them really easily in our `update` and `draw` methods.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于这个游戏将有许多敌人、道具和地形类型，我们需要一个更干净的系统来管理它们。我们需要一个相当通用的`GameObject`类，所有不同的游戏对象都可以扩展它。然后我们可以在`update`和`draw`方法中非常容易地管理它们。
- en: We will also, as a matter of necessity, build a slightly more complicated method
    of detecting the players input. We will create an `InputController` class to delegate
    all of the code from `PlatformView`. However, the details of this class we will
    not see, until we have fully fleshed out our `Player` object to represent the
    player in the next chapter.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 由于必要性，我们还将构建一个稍微复杂的方法来检测玩家的输入。我们将创建一个`InputController`类来委托所有来自`PlatformView`的代码。然而，这个类的细节我们将在下一章完全实现我们的`Player`对象来表示玩家之前不会看到。
- en: We can quickly code our basic `PlatformView` class with very similar code to
    the first project, but with a few notable exceptions that we will discuss.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用与第一个项目非常相似但有一些显著不同的代码快速编写我们的基本`PlatformView`类，但我们将讨论这些不同之处。
- en: The basic structure of PlatformView
  id: totrans-827
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`PlatformView`的基本结构'
- en: Here are the necessary imports and our member variables to get us started. We
    will add to these a fair bit as the project continues.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们开始所需的必要导入和我们的成员变量。随着项目的继续，我们将添加很多内容。
- en: Note that we also declare three new object types, `lm` that will be our `LevelManager`
    class, `vp` that will be our `Viewport` class, and `ic` that is our `InputController`
    class. We will begin working on some of these in this chapter. These declarations
    will of course show an error until we implement their respective classes.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还声明了三种新的对象类型，`lm`将是我们`LevelManager`类，`vp`将是我们`Viewport`类，而`ic`是我们的`InputController`类。我们将从本章开始工作于其中的一些。当然，这些声明将在我们实现相应的类之前显示错误。
- en: '[PRE115]'
  id: totrans-830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Here, we have our `PlatformView` constructor. At this stage, it does nothing
    new, in fact, it has less code than our `TDView` constructor but it will soon
    be enhanced. For now, enter the code as shown:'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有我们的`PlatformView`构造函数。在这个阶段，它没有做任何新的事情，实际上，它的代码比我们的`TDView`构造函数要少，但它很快就会得到增强。现在，按照下面的代码输入：
- en: '[PRE116]'
  id: totrans-832
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Here is our thread''s `run` method. Note that before the call to `update()`,
    we get the current time in milliseconds and put it in the `startFrameTime` long
    variable. Then after `draw()` has completed, we make another call to get the system
    time and measure how many milliseconds have elapsed since the frame started. We
    then carry out the calculation `fps = 1000 / thisFrameTime`, which gives us the
    number of frames per second our game ran at, in that last frame. This value is
    stored in the `fps` variable. We will be using this all over the place as we proceed
    with the game. Code the `run` method that we have just discussed, like this:'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的线程的`run`方法。注意在调用`update()`之前，我们获取当前时间的毫秒数并将其放入`startFrameTime`长变量中。然后，在`draw()`完成后，我们再次调用系统时间并测量自帧开始以来经过的毫秒数。然后我们执行计算`fps
    = 1000 / thisFrameTime`，这给出了我们游戏在最后一帧中每秒运行的帧数。这个值存储在`fps`变量中。随着游戏的进行，我们将到处使用这个值。按照我们刚才讨论的，编写`run`方法，如下所示：
- en: '[PRE117]'
  id: totrans-834
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Later in the chapter, we will see how we manage the extra complexity of multiple
    object types and update them when necessary. For now, just add an empty `update`
    method to the `PlatformView` class like this:'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将看到我们如何管理多个对象类型带来的额外复杂性，并在必要时更新它们。现在，只需像这样给`PlatformView`类添加一个空的`update`方法：
- en: '[PRE118]'
  id: totrans-836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Here, we see the familiar parts of our `draw` method. Later in this chapter,
    we will see some of the new code. For now, add the basics of the `draw` method
    as shown next as this will remain unchanged:'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们看到我们`draw`方法中熟悉的部分。在本章的后面部分，我们将看到一些新的代码。现在，按照下面的代码添加`draw`方法的基本内容，因为这将保持不变：
- en: '[PRE119]'
  id: totrans-838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'The last parts of the first phase of putting together our view is the `pause`
    and `resume` methods, which are called by `PlatformActivity` when the corresponding
    Activity lifecycle methods are called by the operating system. They are unchanged
    from the previous project, but here they are again for the sake of completeness
    and being able to follow along easily. Add these methods to the `PlatformView`
    class:'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 组装视图的第一阶段最后的部分是`pause`和`resume`方法，当操作系统调用相应的Activity生命周期方法时，由`PlatformActivity`调用。它们与上一个项目中的内容没有变化，但在这里再次列出是为了完整性和便于跟踪。将这些方法添加到`PlatformView`类中：
- en: '[PRE120]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Now, we have the basic outline of our view coded and ready. Let's take our first
    look at the `GameObject` class.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经编写并准备好了我们的视图的基本轮廓。让我们首先看看`GameObject`类。
- en: The GameObject class
  id: totrans-842
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`GameObject`类'
- en: We know that we need a parent class to hold the vast majority of our game objects
    as we want to improve on the inflexibility and code duplication of the last project.
    From the previous project, we also know many of the properties and methods it
    will require.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们需要一个父类来包含我们游戏中的大多数对象，因为我们希望改进上一个项目的僵化和代码重复。从上一个项目中，我们也知道它将需要许多属性和方法。
- en: 'First, we need a simple class to represent the world location of all our future
    `GameObject` classes. This class will hold a detailed location on both the *x*
    and *y* axis. Note that these are totally independent to the coordinates of the
    pixels of the device on which our game will run. We can think of the *z* coordinate
    as a layer number. The lower numbers get drawn first. Therefore, create a new
    Java class, call it `Vector2Point5D`, and enter this code:'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个简单的类来表示我们所有未来`GameObject`类的世界位置。这个类将在*x*和*y*轴上持有详细的位置。请注意，这些与我们的游戏将在其上运行的设备的像素坐标完全独立。我们可以将*z*坐标视为层号。较低的数字先被绘制。因此，创建一个新的Java类，命名为`Vector2Point5D`，并输入以下代码：
- en: '[PRE121]'
  id: totrans-845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Now, let's have a look at, and code the basic working outline of, the `GameObject`
    class, and then throughout the project, we can come back and add extra features.
    Create a new Java class and call it `GameObject`. Let's look at the code we need
    to start to make this class useful. First, we import the classes we need.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看并编写`GameObject`类的基本工作轮廓，然后在整个项目中，我们可以回来添加额外的功能。创建一个新的Java类，命名为`GameObject`。让我们看看我们需要编写哪些代码来使这个类变得有用。首先，我们导入所需的类。
- en: '[PRE122]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: When we code `GameObject` itself, note that the class does not provide a constructor
    as this will be handled differently, depending on the specific `GameObject` that
    we are implementing.
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写`GameObject`本身时，请注意，该类不提供构造函数，因为这将根据我们正在实现的特定`GameObject`以不同的方式处理。
- en: The first variable you will notice in the code is `worldLocation`, which, as
    you may expect, is of type `Vector2Point5D`. We then have two float members, which
    will hold the width and height of the `GameObject` class. Next up, we have the
    Boolean variables `active` and `visible` which will be used, perhaps to label
    an object when it is active, visible, or otherwise. We will begin to see later
    in the chapter how this is of benefit.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中您首先会注意到的是`worldLocation`变量，正如您所期望的，它是`Vector2Point5D`类型。然后我们有两个浮点成员，它们将持有`GameObject`类的宽度和高度。接下来，我们有布尔变量`active`和`visible`，它们可能被用来标记一个对象当它处于活动状态、可见状态或其他状态时。我们将在本章的后面部分开始看到这如何有益。
- en: We will also need to know how many frames of internal animation any given object
    has. The default will be `1`, so `animFrameCount` is initialized accordingly.
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要知道任何给定对象有多少帧的内部动画。默认值将是`1`，因此`animFrameCount`将相应地初始化。
- en: 'We then have a `char` class called `type`. This `type` variable will determine
    exactly what any particular `GameObject` might be. It will be used extensively.
    The last member variable for now is `bitmapName`. We will see that it will become
    useful to know the name of the graphic, which represents the appearance of each
    of our individual objects. Add the member variables we have just discussed:'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为`type`的`char`类。这个`type`变量将决定任何特定的`GameObject`可能是什么。它将被广泛使用。目前最后一个成员变量是`bitmapName`。我们将看到知道图形的名称，即代表我们每个单独对象的外观，将变得很有用。添加我们刚刚讨论的成员变量：
- en: '[PRE123]'
  id: totrans-852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Now, we can look at the first part of the functionality of `GameObject`. We
    have the abstract method `update()`. The plan was that all objects will need to
    update themselves. Turns out that this was over ambitious in just four chapters,
    and some of our objects (mainly the platforms and scenery) will just provide an
    empty `update()` implementation. However, there is nothing to stop you making
    the scenery more interactive than we have time for now, or make the platforms
    more dynamic and adventurous once we see how things work. Add the abstract `update`
    method:'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看看`GameObject`功能的第一部分。我们有抽象方法`update()`。计划是所有对象都需要更新自己。结果证明，在仅仅四章中就过于雄心勃勃了，我们的一些对象（主要是平台和场景）将只提供一个空的`update()`实现。然而，没有任何东西阻止你使场景比我们现在有时间做的更互动，或者一旦我们看到事物是如何工作的，使平台更加动态和冒险。添加抽象的`update`方法：
- en: '[PRE124]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: We handle our methods that manage our graphics. We have a getter to retrieve
    `bitmapName`. Then, we have `prepareBitmap()`, which uses the string `bitmapName`
    to make an Android resource ID from a `.png` image file. This file must be present
    in the `drawable` folder of the project. A bitmap is created as we have seen before.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 我们处理管理我们图形的方法。我们有一个获取器来检索`bitmapName`。然后，我们有`prepareBitmap()`，它使用字符串`bitmapName`从`.png`图像文件创建一个Android资源ID。此文件必须位于项目的`drawable`文件夹中。正如我们之前所看到的，一个位图被创建。
- en: Now our `prepareBitmap` method does something new. It uses the `createScaledBitmap`
    method to change the size of the bitmap we just created. It not only uses the
    `animFrameCount`, which we already discussed, but also the `pixelsPerMetre` variable,
    which is a parameter of the method.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的`prepareBitmap`方法做了些新的事情。它使用`createScaledBitmap`方法来改变我们刚刚创建的位图的大小。它不仅使用了我们之前讨论过的`animFrameCount`，还使用了方法参数`pixelsPerMetre`变量。
- en: 'The idea being, that each device has a `pixelsPerMetre` value that is appropriate
    for the device, which will help us create an identical view of the game across
    devices with different resolutions. We will see exactly where we get this `pixelsPerMetre`
    value from, when we discuss the `Viewport` class. Enter the following methods
    in the `GameObject` class:'
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 想法是，每个设备都有一个`pixelsPerMetre`值，这个值适合该设备，这将帮助我们创建跨不同分辨率的设备上的相同游戏视图。当我们讨论`Viewport`类时，我们将看到这个`pixelsPerMetre`值是从哪里获得的。在`GameObject`类中输入以下方法：
- en: '[PRE125]'
  id: totrans-858
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: We also want to be able to know where in the world each `GameObject` is and,
    of course, to set where in the world it is. Here are a getter and a setter, which
    do just that.
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望能够知道每个`GameObject`在世界中的位置，当然，也要设置它在世界中的位置。这里有一个获取器和设置器，它们正是这样做的。
- en: '[PRE126]'
  id: totrans-860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: We also want to be able to both, get and set many of the member variables we
    have already discussed. These getters and setters will do that.
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望能够获取和设置我们之前讨论过的许多成员变量。这些获取器和设置器将做到这一点。
- en: '[PRE127]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Furthermore, we will want to check and change the status of our active and visible
    variables as well.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还想检查和更改我们的活动变量和可见变量的状态。
- en: '[PRE128]'
  id: totrans-864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Set and get `type` of each `GameObject`.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 设置和获取每个`GameObject`的`type`。
- en: '[PRE129]'
  id: totrans-866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Now, we will create our first of many child classes from `GameObject`. Right-click
    on the package name in the Android Studio explorer and create a class called `Grass`.
    This will be our first basic tile type that the player can walk about on.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将从`GameObject`创建我们的第一个许多子类。在Android Studio资源管理器中右键单击包名，创建一个名为`Grass`的类。这将是我们玩家可以行走的第一个基本瓦片类型。
- en: This straightforward code uses the constructor to initialize height, width,
    type, and its location in the game world. Note that all this information is passed
    in as parameters to the constructor. The only thing the `Grass` class "knows",
    and one of the few things that will differentiate it from some of the other simple
    `GameObject` child classes, is the value used for `bitmapName`, which in this
    case is `turf`.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 这段简单的代码使用构造函数来初始化高度、宽度、类型及其在游戏世界中的位置。请注意，所有这些信息都作为参数传递给构造函数。`Grass`类“知道”的唯一事情，以及与其他一些简单`GameObject`子类区分开来的少数几个因素之一，是用于`bitmapName`的值，在这个例子中是`turf`。
- en: 'As discussed previously, we also provide an empty implementation of the `update`
    method:'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们还提供了一个空的`update`方法实现：
- en: '[PRE130]'
  id: totrans-870
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Now, add the `turf.png` graphic from the `Chapter5/drawable` folder in the download
    bundle to the `drawable` folder in Android Studio.
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将下载包中的`Chapter5/drawable`文件夹中的`turf.png`图形添加到Android Studio的`drawable`文件夹中。
- en: Finally, we will do an absolute barebones implementation of our `Player` class
    that will also extend `GameObject`. We will not be putting any functionality into
    this class just an *x* and *y* world location. This is so that the `Viewport`
    class, which we will implement next, knows where to focus.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将实现一个绝对基础的`Player`类，它也将扩展`GameObject`。我们不会在这个类中放入任何功能，只提供一个*x*和*y*世界位置。这样，我们将实现的`Viewport`类就知道在哪里聚焦。
- en: Here is the `Player` class, which will represent Bob our hero. The class at
    this stage is as simple and straightforward as, and nearly identical to the `Grass`
    class. This will change and evolve substantially as we progress. Note that we
    set the type to `p`.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`Player`类，它将代表我们的英雄鲍勃。在这个阶段，这个类非常简单直接，几乎与`Grass`类完全相同。随着我们的进展，它将发生重大变化和演变。注意，我们将类型设置为`p`。
- en: '[PRE131]'
  id: totrans-874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Add the `player.png` graphic from the `drawable` folder in the download bundle
    to the `drawable` folder in Android Studio. The graphic is a multiframe sprite
    sheet, so it won't display nicely until we animate it in [Chapter 6](ch15.html
    "Chapter 6. Platformer – Bob, Beeps, and Bumps"), *Platformer – Bob, Beeps, and
    Bumps* , but it will serve its purpose as a placeholder for now.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 将下载包中的`drawable`文件夹中的`player.png`图形添加到Android Studio中的`drawable`文件夹。这个图形是一个多帧精灵表，所以在我们将其在[第6章](ch15.html
    "第6章。平台游戏 – 鲍勃、哔哔声和碰撞")中动画化之前，它不会很好地显示，*平台游戏 – 鲍勃、哔哔声和碰撞*，但作为现在的占位符它将发挥作用。
- en: As we will see next, the view of the game world that the player sees, will focus
    on Bob, as you will probably expect.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们接下来将要看到的，玩家看到的游戏世界视图将聚焦于鲍勃，正如你可能预期的那样。
- en: The view through a viewport
  id: totrans-877
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 视口视图
- en: A viewport can be thought of as the movie camera that follows the action of
    our game. It defines the area of the game world that is to be shown to the player.
    Typically, it will center on Bob.
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 视口可以被视为跟随我们游戏动作的电影摄像机。它定义了要向玩家展示的游戏世界区域。通常，它将集中在鲍勃身上。
- en: It also serves the combined function of making our draw method more efficient
    by determining which objects are inside and outside the player's field of vision.
    There is no point drawing or processing a bunch of enemies, if they are not relevant
    at any given moment.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 它还通过确定哪些对象在玩家的视野内和视野外，使我们的绘制方法更有效。如果敌人在任何给定时刻都不相关，就没有必要绘制或处理它们。
- en: This will significantly speed up tasks like collision detection by implementing
    a first phase of detection by removing objects off screen from the list of objects
    to check for collisions, and it is surprisingly simple to do.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显著加快诸如碰撞检测等任务，通过实施第一阶段检测，从要检查碰撞的对象列表中移除屏幕外的对象，这做起来出奇地简单。
- en: Furthermore, our `Viewport` class will have the task of translating game world
    coordinates into appropriate pixel coordinates for drawing on the screen. We will
    also see how this class calculates the `pixelsPerMetre` value that our `GameObject`
    class used in the `prepareBitmap` method.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们的`Viewport`类将负责将游戏世界坐标转换为屏幕上绘制适当的像素坐标。我们还将看到这个类是如何计算我们的`GameObject`类在`prepareBitmap`方法中使用的`pixelsPerMetre`值的。
- en: The `Viewport` class really is an all singing and dancing thing. So let's get
    coding.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: '`Viewport`类确实是一个全能的类。所以让我们开始编码。'
- en: First, we will declare a whole bunch of useful variables. We have another `Vector2Point5D`,
    which will just be used to represent whatever point in the world is currently
    the central focus in the viewport. Then, we have separate integer values for `pixelsPerMetreX`
    and `pixelsPerMetreY`.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将声明一大堆有用的变量。我们还有一个`Vector2Point5D`，它将仅用于表示当前在视口中是世界中央焦点的任何点。然后，我们有`pixelsPerMetreX`和`pixelsPerMetreY`的单独整数值。
- en: Note
  id: totrans-884
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Actually, in this implementation, there is no distinction between `pixelsPerMetrX`
    and `pixelsPerMetreY`. However, the `Viewport` class can be upgraded to take into
    account different ratios of width to height of the device, based on screen size,
    rather than just resolution. We don't do so in this implementation.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在这个实现中，`pixelsPerMetrX`和`pixelsPerMetreY`之间没有区别。然而，`Viewport`类可以被升级以考虑设备宽高比的不同，基于屏幕大小，而不仅仅是分辨率。在这个实现中我们没有这样做。
- en: 'Next, we simply have the resolution of the screen in both axes: `screenXResolution`
    and `screenYResolution`. We then have `screenCentreX` and `screenCentreY`, which
    are basically the two previous variables divided by two to find the middle.'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们简单地有屏幕在两个轴上的分辨率：`screenXResolution`和`screenYResolution`。然后我们有`screenCentreX`和`screenCentreY`，这两个变量基本上是前两个变量除以二得到的中间值。
- en: In our list of declared variables, we have `metresToShowX` and `metresToShowY`
    that will be the number of meters we will squash into our viewport. Changing these
    values will show more or less of the game world on screen.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们声明的变量列表中，我们有`metresToShowX`和`metresToShowY`，这将是我们将挤压到视口中的米数。更改这些值将在屏幕上显示更多或更少的游戏世界。
- en: The last member, we will declare at this point, is the `int numClipped`. This
    we will use to output debugging text to see what effect our `Viewport` class is
    having with regard to making drawing, updates, and multiphase collision detection,
    more efficient.
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个成员，我们将在这一点上声明，是`int numClipped`。我们将使用它来输出调试文本，以查看我们的`Viewport`类在使绘制、更新和多阶段碰撞检测更有效方面产生的影响。
- en: 'Create a new class called `Viewport` and declare the variables we have just
    discussed:'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`Viewport`的新类，并声明我们刚刚讨论的变量：
- en: '[PRE132]'
  id: totrans-890
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: Now, let's look at the constructor. The constructor just needs to know the resolution
    of the screen. This is obtained in parameters *x* and *y*, which, of course, we
    assign to `screenXResolution` and `screenYResolution`, respectively.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看构造函数。构造函数只需要知道屏幕的分辨率。这通过参数*x*和*y*获得，当然，我们将它们分别分配给`screenXResolution`和`screenYResolution`。
- en: Then, as previously suggested, we divide those two previous variables by two
    and assign the results to `screenCentreX` and `screenCentreY`, respectively.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如之前建议的那样，我们将这两个先前变量除以二，并将结果分别赋值给`screenCentreX`和`screenCentreY`。
- en: The `pixelsPerMetreX` and `pixelsPerMetreY` are calculated by dividing by 32
    and 18 (again, respectively), so a device with a resolution of 840 x 400 pixels
    will have pixels per meter *x/y* of 32/22\. Now, we have variables that refer
    to the number of pixels of screen real estate on the current device that represents
    a meter of our game world. We will see a number of times in our code, where this
    will be useful.
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: '`pixelsPerMetreX`和`pixelsPerMetreY`是通过除以32和18（再次分别）计算得出的，因此分辨率为840 x 400像素的设备将具有每米*x/y*像素为32/22。现在，我们有了变量，它们指的是当前设备上表示我们游戏世界一米的屏幕实际面积。我们将在代码中多次看到这一点，它将非常有用。'
- en: We will actually draw a slightly wider area than this, to make sure we don't
    have any unsightly gaps/lines around the edge of the screen and assign 34 to `metresToShowX`
    and 20 to `metresToShowY`. Now, we have variables that refer to the amount of
    our game world that we will draw each frame.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们将绘制一个比这稍宽的区域，以确保屏幕边缘没有难看的间隙/线条，并将34赋值给`metresToShowX`和20赋值给`metresToShowY`。现在，我们有了变量，它们指的是我们将在每一帧中绘制的游戏世界部分的数量。
- en: Tip
  id: totrans-895
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Once we have some screen output, you can experiment with these values to create
    a more or less zoomed-in or zoomed-out experience for the player.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有一些屏幕输出，您就可以通过调整这些值来为玩家创建更或更缩放或更缩小的体验。
- en: Nearing the end of the constructor, we create a new `Rect` object called `convertedRect`
    that we will see in action soon. We call `new()` on `currentViewportWorldCentre`,
    so it is ready for action shortly.
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数接近结束时，我们创建了一个名为`convertedRect`的新`Rect`对象，我们很快就会看到它的作用。我们在`currentViewportWorldCentre`上调用`new()`，因此它很快就可以投入使用。
- en: '[PRE133]'
  id: totrans-898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Note
  id: totrans-899
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If some of the screenshots throughout this project look slightly different to
    the results you get, it is because some images have been taken using different
    viewport settings to highlight different aspects of the game world.
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在这个项目中的某些截图看起来与您得到的结果略有不同，那是因为一些图像是使用不同的视口设置来突出游戏世界不同方面的。
- en: The first method we write for the `Viewport` class is `setWorldCentre()`. It
    receives an *x* and a *y* parameter, which is promptly assigned as the `currentWorldCentre`.
    We need this method because of course the player will be moving around in the
    world, and we need to let the `Viewport` class know where Bob is. Also, as we
    will see in [Chapter 8](ch17.html "Chapter 8. Platformer – Putting It All Together"),
    *Putting It All together*, we will also have a situation where we don't want Bob
    as the center of attention.
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`Viewport`类编写的第一个方法是`setWorldCentre()`。它接收一个*x*和*y*参数，这些参数立即被分配为`currentWorldCentre`。我们需要这个方法，因为当然玩家会在世界中移动，我们需要让`Viewport`类知道鲍勃的位置。此外，正如我们将在[第8章](ch17.html
    "第8章。平台游戏 – 整合所有元素")中看到的，*整合所有元素*，我们还将遇到一种我们不想让鲍勃成为关注中心的情况。
- en: '[PRE134]'
  id: totrans-902
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Now, a few simple getters and setters that will be useful to us as we progress.
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一些简单的方法，这些方法在我们前进的过程中将非常有用。
- en: '[PRE135]'
  id: totrans-904
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: We fulfil one of the primary roles of the `Viewport` class with the `worldToScreen()`
    method. As the name suggests, this is the method that converts the locations of
    all the objects currently in the visible viewport from world coordinates to pixel
    coordinates that can actually be drawn to the screen. It returns our previously
    prepared `rectToDraw` object as the result.
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过`worldToScreen()`方法履行`Viewport`类的一个主要角色。正如其名所示，这是将当前可见视口内所有对象的坐标从世界坐标转换为可以实际绘制到屏幕上的像素坐标的方法。它返回我们之前准备的`rectToDraw`对象作为结果。
- en: This is how `worldToScreen()` works. It receives the *x* and *y* world locations
    of an object along with that object's width and height. With these values, each
    in turn, subtracts the objects world coordinate multiplied by the pixels per meter
    for the current screen, from the appropriate current world viewport center (*x*
    or *y*). Then, for the left and top coordinates of the object, the result is subtracted
    from the pixel screen center value and for the bottom and right coordinates, it
    is added.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`worldToScreen()`函数的工作原理。它接收一个对象的*x*和*y*世界位置，以及该对象的宽度和高度。有了这些值，每个值依次从对象的坐标乘以当前屏幕每米的像素数中减去，然后从适当的世界视口中心（*x*或*y*）中减去。然后，对于对象的左上坐标，从像素屏幕中心值中减去，对于底部和右部坐标，则加上。
- en: 'These values are then packed into the left, top, right, and bottom values of
    `convertedRect` and returned to the `draw` method of `PlatformView`. Add the `worldToScreen`
    method to the `Viewport` class:'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值随后被打包到`convertedRect`的左、上、右和底部值中，并返回给`PlatformView`的`draw`方法。将`worldToScreen`方法添加到`Viewport`类中：
- en: '[PRE136]'
  id: totrans-908
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Now, we implement the second primary function of the `Viewport` class, removing
    objects that are currently of no interest to us. We call this clipping, and the
    method we will call; `clipObjects()`.
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们实现`Viewport`类的第二个主要功能，移除当前对我们没有兴趣的对象。我们称之为裁剪，我们将调用的方法是`clipObjects()`。
- en: Once again, we receive as parameters the `x`, `y`, `width`, and `height` of
    an object. The test starts by assuming that we want to clip the current object
    and we assign `true` to clipped.
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们接收对象的`x`、`y`、`width`和`height`作为参数。测试开始时，我们假设我们想要裁剪当前对象，并将`true`赋值给`clipped`。
- en: 'Then, the four nested `if` statements test whether each and every point of
    the object is within the bounds of the related side of the viewport. If it is,
    we set `clipped` to `false`. Some of the levels we will design have in excess
    of a thousand objects, but we will see that we rarely need to process (update,
    collision detection, and draw) more than a quarter of them in any given frame.
    Enter the code for the `clipObjects` method:'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，四个嵌套的`if`语句测试对象的每个点是否在视口相关边的范围内。如果是，我们将`clipped`设置为`false`。我们将设计的一些层级将超过一千个对象，但我们将看到，在任何给定帧中，我们很少需要处理（更新、碰撞检测和绘制）超过四分之一的对象。输入`clipObjects`方法的代码：
- en: '[PRE137]'
  id: totrans-912
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Now, we provide access to the `numClipped` variable so that it can be read and
    reset to zero each frame.
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们提供对`numClipped`变量的访问，以便它可以被读取并在每一帧重置为零。
- en: '[PRE138]'
  id: totrans-914
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Let''s declare and initialize our `Viewport` object. Add this code right after
    we initialize our `Paint` object in the `PlatformView` constructor. The new code
    is shown highlighted here:'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们声明并初始化我们的`Viewport`对象。在`PlatformView`构造函数中初始化我们的`Paint`对象后，添加此代码。新的代码在此处突出显示：
- en: '[PRE139]'
  id: totrans-916
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: We can now describe and position objects in our game world and focus on the
    precise parts of the world we are interested in. Let's see how we will actually
    get our objects into that world, so we can then update and draw them as we have
    done before. We will also look at the concept of a level.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在我们的游戏世界中描述和定位对象，并专注于我们感兴趣的世界精确部分。让我们看看我们实际上如何将对象放入这个世界，这样我们就可以像之前那样更新和绘制它们。我们还将探讨层级概念。
- en: Creating the levels
  id: totrans-918
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建层级
- en: Here, we will see how to build our `LevelManager`, `LevelData`, and our first
    real level, `LevelCave`.
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将看到如何构建我们的`LevelManager`、`LevelData`以及我们的第一个真实层级`LevelCave`。
- en: The `LevelManager` class will eventually need a copy of our `InputController`
    class. Therefore, in order to try and keep to our intentions of not having to
    delete any code, we will include a parameter for `InputController` in our `LevelManager`
    constructor.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: '`LevelManager`类最终需要我们`InputController`类的副本。因此，为了尽量保持我们的意图，即不删除任何代码，我们在`LevelManager`构造函数中包含一个`InputController`参数。'
- en: 'Let''s quickly create a blank template for our `InputController` class. Create
    a new class in the usual way and call it `InputController`. Add this code:'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速创建一个`InputController`类的空白模板。以通常的方式创建一个新的类，命名为`InputController`。添加以下代码：
- en: '[PRE140]'
  id: totrans-922
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Now, let's look at our, initially, very simple `LevelData` class. Create a new
    class, call it `LevelData`, and add this code. At this stage, it holds just an
    `ArrayList` object for `Strings`.
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们的，最初非常简单的`LevelData`类。创建一个新的类，命名为`LevelData`，并添加以下代码。在这个阶段，它只包含一个用于字符串的`ArrayList`对象。
- en: '[PRE141]'
  id: totrans-924
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Next, we can start on what will eventually become our first playable level.
    Create a new class, call it `LevelCave`, and add this code:'
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以开始制作最终将成为我们第一个可玩关卡的代码。创建一个新的类，命名为`LevelCave`，并添加以下代码：
- en: '[PRE142]'
  id: totrans-926
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Tip
  id: totrans-927
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The position of `p` for player in the `LevelCave` file is arbitrary. As long
    as it is on there, the `Player` object will be initialized. The actual spawn location
    of the player character is determined by the call to a `loadLevel` method, as
    we will soon see. I usually put the `p` for player as the first element on the
    first line of the map, then it is less likely to be forgotten.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 在`LevelCave`文件中，玩家`p`的位置是任意的。只要它在文件中，`Player`对象就会被初始化。玩家角色的实际出生位置是由调用`loadLevel`方法来确定的，正如我们很快就会看到的。我通常将玩家的`p`放在地图的第一行的第一个元素上，这样就不太容易被遗忘。
- en: Now, let's talk about how this level design is going to work. We will enter
    alpha-numeric characters in the `LevelCave` class within the `tiles.add("..."`
    parts of the code. We will enter a different alpha-numeric character depending
    on which `GameObject` we want to place into the level. At the moment, we just
    have `p` to represent the `Player` object, a `1` to represent a `Grass` object,
    and a period (`.`) to represent an empty space of one game world meter square.
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们谈谈这个关卡设计是如何工作的。我们将在`LevelCave`类的`tiles.add("..."`部分输入字母数字字符。我们将输入不同的字母数字字符，具体取决于我们想在关卡中放置哪种`GameObject`。目前，我们只有`p`来表示`Player`对象，`1`来表示`Grass`对象，以及点号（`.`）来表示一个游戏世界米平方的空地。
- en: Tip
  id: totrans-930
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: This implies that the positioning of the `Grass` objects with the `1` character
    in the previous block of code can be arranged exactly how you like. This is the
    case, and whenever we look at the code for our `LevelCave` class please feel free
    to improvise and experiment as you like.
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在上一块代码中用`1`字符定位`Grass`对象的方式可以完全按照你的喜好来安排。情况就是这样，每次我们查看我们的`LevelCave`类的代码时，请随意发挥和实验。
- en: As the project continues, we will add more than twenty different `GameObject`
    child classes. Some will be inanimate like `Grass`, others will be thinking, aggressive
    enemies. All will be placeable within our level design.
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 随着项目的进行，我们将添加超过二十个不同的`GameObject`子类。其中一些将是静止的，如`Grass`，其他将是思考型、侵略性的敌人。所有这些都可以放置在我们的关卡设计中。
- en: Now, we can implement the class to manage our levels. Create a new Java class
    and call it `LevelManager`. Enter the code for the `LevelManager` class as we
    go through, and discuss it a block at a time.
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以实现管理我们关卡类的代码。创建一个新的Java类，命名为`LevelManager`。随着我们逐步进行，输入`LevelManager`类的代码，并逐块讨论。
- en: First, a few import directives.
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，是一些导入指令。
- en: '[PRE143]'
  id: totrans-935
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Now, the constructor is where we have a `String` `level` to hold the name of
    the level, `mapWidth` and `mapHeight` to store the width and height in game world
    meters of the current level, a `Player` object because we know we will always
    have one of them, and an `int` type called `playerIndex`.
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，构造函数中有一个`String`类型的`level`来保存关卡名称，`mapWidth`和`mapHeight`来存储当前关卡在游戏世界米中的宽度和高度，一个`Player`对象，因为我们知道我们始终会有一个，以及一个名为`playerIndex`的整型。
- en: Soon, we will have an `ArrayList` object of many `GameObject` classes, and it
    will be handy to always have the index of the `Player` object.
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 很快，我们将有一个包含许多`GameObject`类的`ArrayList`对象，并且始终拥有`Player`对象的索引将很有用。
- en: Moving on, we have the Boolean `playing` because we will need to know when the
    game is being played or being paused and a float called `gravity`.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有布尔值`playing`，因为我们需要知道游戏何时在播放或暂停，以及一个名为`gravity`的浮点数。
- en: Tip
  id: totrans-939
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In the context of this project, gravity will not be used to its full potential,
    but it can easily be manipulated so that different levels have a different gravity.
    This is why it is in the `LevelManager` class.
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 在本项目的背景下，重力不会发挥其全部潜力，但它可以很容易地被操纵，以便不同的关卡有不同的重力。这就是为什么它位于`LevelManager`类中的原因。
- en: Finally, we declare an object of type `LevelData`, an `ArrayList` object to
    hold all our `GameObject` objects, an `ArrayList` object to hold representations
    of the players control buttons and a regular array to hold the majority of all
    the `Bitmap` objects we will need.
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们声明一个类型为`LevelData`的对象，一个用于存储所有`GameObject`对象的`ArrayList`对象，一个用于存储玩家控制按钮表示的`ArrayList`对象，以及一个用于存储我们将需要的绝大多数`Bitmap`对象的常规数组。
- en: '[PRE144]'
  id: totrans-942
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Then, in the constructor, we examine the signature and see that it receives
    a `Context` object, `pixelsPerMetre` that will have been determined when the `Viewport`
    class was constructed, `screenWidth` again direct from the `Viewport` class, a
    copy of our `InputController` class, and then the name of the level to load. The
    `int` parameters, `px` and `py`, are the starting coordinates for the player.
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在构造函数中，我们检查签名并看到它接收一个`Context`对象，`pixelsPerMetre`，这是在`Viewport`类构建时确定的，`screenWidth`直接来自`Viewport`类，我们`InputController`类的一个副本，以及要加载的关卡名称。`int`参数`px`和`py`是玩家的起始坐标。
- en: We assign the level parameter to our member level, then we switch to determine
    which class will be our current level. Of course, at the moment, we only have
    `LevelCave`.
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将关卡参数分配给我们的成员变量`level`，然后我们切换以确定我们的当前关卡将使用哪个类。当然，目前我们只有`LevelCave`。
- en: 'Then, we initialize our `gameObject ArrayList` and our `bitmapsArray`. We then
    call `loadMapData()`, which is a method we will write shortly. After this, we
    set `playing` to `true`, and finally we have a getter method to find out what
    the state of `playing` is. Enter the code we have just discussed in the `LevelManager`
    class:'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们初始化我们的`gameObject ArrayList`和`bitmapsArray`。接着，我们调用`loadMapData()`方法，这是我们很快将要编写的方法。在此之后，我们将`playing`设置为`true`，最后我们有一个获取`playing`状态的方法。在`LevelManager`类中输入我们刚刚讨论的代码：
- en: '[PRE145]'
  id: totrans-946
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Now, we have a really simple method which will enable us to get any `Bitmap`
    object based on the type of `GameObject` we are currently dealing with. This way,
    each `GameObject` does not have to hold its own `Bitmap` object. For example,
    we can design a level with hundreds of `Grass` objects. This can easily use up
    the memory of even a modern tablet.
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个非常简单的方法，它将使我们能够根据我们目前正在处理的`GameObject`的类型获取任何`Bitmap`对象。这样，每个`GameObject`就不必持有自己的`Bitmap`对象。例如，我们可以设计一个包含数百个`Grass`对象的关卡。这可能会轻易耗尽即使是现代平板电脑的内存。
- en: 'Our `getBitmap` method takes an `int` value as an index and returns a `Bitmap`
    object. We will see how we access the appropriate value for `index` in the next
    method:'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`getBitmap`方法接受一个`int`值作为索引，并返回一个`Bitmap`对象。我们将在下一个方法中看到如何访问`index`的适当值：
- en: '[PRE146]'
  id: totrans-949
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: This next method will enable us to get the `index` with which to call the `getBitmap`
    method. As long as the `char` cases correspond with the `type` values held by
    the various `GameObject` child classes we create, and the index returned by this
    method matches the index of the appropriate `Bitmap` held in the `bitmapsArray`,
    we will only ever need one copy of each `Bitmap` object.
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法将使我们能够获取调用`getBitmap`方法的`index`。只要`char`情况与我们所创建的各个`GameObject`子类持有的`type`值相对应，并且此方法返回的索引与`bitmapsArray`中保存的适当`Bitmap`的索引相匹配，我们只需每个`Bitmap`对象的一个副本即可。
- en: '[PRE147]'
  id: totrans-951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: Now, we do the real work with the `LevelManager` class, and load our level from
    our design. The method needs the `pixelsPerMetre` and the `Player` objects coordinates
    in order to do its work. As this is a large method, the explanations and the code
    have been split into a few sections.
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们使用`LevelManager`类进行实际的工作，并从我们的设计中加载我们的关卡。该方法需要`pixelsPerMetre`和`Player`对象的坐标来完成其工作。由于这是一个较大的方法，解释和代码已被分成几个部分。
- en: In this first part, we simply declare an `int` type called `index` and set it
    to `-1`. As we loop through our level design, it will help us keep track of where
    we are up to.
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一部分，我们简单地声明一个名为`index`的`int`类型并将其设置为`-1`。当我们遍历我们的关卡设计时，它将帮助我们跟踪我们的进度。
- en: Then, we calculate the height and width of the map using the size of `ArrayList`
    and the length of the first element of `ArrayList`, respectively.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`ArrayList`的大小和第一个元素的长度分别计算地图的高度和宽度。
- en: '[PRE148]'
  id: totrans-955
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: We enter a nested `for` loop starting with the first element of the first string
    in our `ArrayList` object. We work from left to right across the first string
    before moving on to the second string.
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进入一个嵌套的`for`循环，从我们的`ArrayList`对象中的第一个字符串的第一个元素开始。我们在处理第一个字符串之前，从左到右工作，然后转到第二个字符串。
- en: We check to see if an object other than an empty space (.) is present at the
    current location, and if it is, we enter a switch block to create the appropriate
    object at the designated location.
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查当前位置是否存在除空格（.）之外的对象，如果存在，则进入一个`switch`块以在指定位置创建适当的对象。
- en: If we encounter a `1`, then we add a new `Grass` object to `ArrayList`, and
    if we encounter a `p`, we initialize the `Player` object at the location passed
    in to the constructor of this `LevelManager` class. When a new `Player` object
    is created, we also initialize our `playerIndex` and `player` object ready for
    future use.
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们遇到`1`，则向`ArrayList`添加一个新的`Grass`对象，如果遇到`p`，则初始化在`LevelManager`类构造函数中传递的位置的`Player`对象。当创建一个新的`Player`对象时，我们也初始化我们的`playerIndex`和`player`对象，以便将来使用。
- en: '[PRE149]'
  id: totrans-959
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'If a new object has been added to `gameObjects ArrayList`, we need to check
    if the corresponding bitmap has been added to the `bitmapsArray`. If it hasn''t,
    we add one using the `prepareBitmap` method of the current `GameObject` class
    under consideration. Here is the code to perform this check and prepare the bitmap,
    if necessary:'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`gameObjects ArrayList`中已添加新对象，我们需要检查相应的位图是否已添加到`bitmapsArray`中。如果没有，我们使用当前考虑的`GameObject`类的`prepareBitmap`方法添加一个。以下是执行此检查和准备位图的代码（如果需要）：
- en: '[PRE150]'
  id: totrans-961
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Back in the `PlatformView` class, to put all our level objects to use, we call
    `loadLevel()` just after where we initialized our `Viewport` class in the `PlatformView`
    constructor. The new code has been highlighted, and the existing code is provided
    for context:'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`PlatformView`类，为了使用所有级别对象，我们在`PlatformView`构造函数中初始化我们的`Viewport`类之后立即调用`loadLevel()`。新代码已被突出显示，现有代码提供上下文：
- en: '[PRE151]'
  id: totrans-963
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Of course, now we need to implement the `loadLevel` method within the `PlatformView`
    class.
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，现在我们需要在`PlatformView`类中实现`loadLevel`方法。
- en: The `loadLevel` method needs to know which level to load, so the `switch` statement
    in the `LevelManager` constructor can do its work, and it also needs the coordinates
    to spawn our hero Bob.
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadLevel`方法需要知道要加载哪个级别，因此`LevelManager`构造函数中的`switch`语句可以执行其工作，并且它还需要坐标来生成我们的英雄Bob。'
- en: We initialize our `LevelManager` object by calling its constructor with the
    viewport data retrieved from `vp` and the level/player data we have just discussed.
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用其构造函数并使用从`vp`检索的视口数据和刚刚讨论的级别/玩家数据来初始化我们的`LevelManager`对象。
- en: We then create a new `InputController` class, again passing in some data from
    `vp`. We will see exactly what we do with this data when we build our `InputController`
    class in [Chapter 6](ch15.html "Chapter 6. Platformer – Bob, Beeps, and Bumps"),
    *Bob, Beeps, and Bumps*. Finally, we call `vp.setWorldCentre()` and pass it in
    the player's location as the coordinates. This centers the screen on Bob.
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个新的`InputController`类，再次从`vp`传递一些数据。当我们构建`InputController`类时，我们将在[第6章](ch15.html
    "第6章。平台游戏 – Bob，哔哔声和颠簸") *Bob，哔哔声和颠簸* 中看到我们如何使用这些数据。最后，我们调用`vp.setWorldCentre()`并将玩家的位置作为坐标传递给它。这样屏幕就定位在Bob上了。
- en: '[PRE152]'
  id: totrans-968
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: We can add some code to our `update` method that will be first to utilize a
    primary function of our new `Viewport` class.
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们的`update`方法中添加一些代码，使其首先利用我们新的`Viewport`类的主要功能。
- en: The enhanced update method
  id: totrans-970
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 增强的更新方法
- en: 'At last, we can use our handy `ArrayList` of game objects and our `Viewport`
    functionality to flesh out our enhanced `update` method. In the code that follows,
    we simply use an enhanced `for` loop to go through each `GameObject`. We check
    if it `isActive()`, and then send the object''s location and dimensions to `clipObjects()`
    wrapped in an `if` statement. If `clipObjects()` returns `false`, then the object
    is not clipped and the object is flagged as visible by calling `go.setVisible(true)`.
    Otherwise, it is flagged as not visible calling `go.setVisible(false)`. This is
    the only aspect of any object that is updated at the moment. We will see when
    we run the game, at the end of the chapter, that it is already useful. Enter the
    new code in the `update` method:'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用我们方便的`ArrayList`游戏对象和`Viewport`功能来完善我们的增强`update`方法。在接下来的代码中，我们简单地使用增强的`for`循环遍历每个`GameObject`。我们检查它是否`isActive()`，然后通过一个`if`语句将对象的定位和尺寸发送到`clipObjects()`。如果`clipObjects()`返回`false`，则对象没有被裁剪，并且通过调用`go.setVisible(true)`将对象标记为可见。否则，它被标记为不可见，通过调用`go.setVisible(false)`。这是目前任何对象更新的唯一方面。我们将在本章末尾运行游戏时看到它已经很有用了。在`update`方法中输入新代码：
- en: '[PRE153]'
  id: totrans-972
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: The enhanced draw method
  id: totrans-973
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 增强绘图方法
- en: Now, we can be more precise about which objects we need to draw. First, we declare
    and initialize a new `Rect` object called `toScreen2d`.
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以更精确地确定需要绘制哪些对象。首先，我们声明并初始化一个新的`Rect`对象，称为`toScreen2d`。
- en: Then, we loop through our `gameObjects ArrayList` once for each layer starting
    with the lowest layer. This isn't strictly necessary at this stage because all
    our objects are, by default, currently on layer zero. We will add objects on layer
    -1 and 1 before the end of the project, and we don't want to have to rewrite code
    if we can help it.
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们遍历`gameObjects ArrayList`，为每个层（从最低层开始）进行一次循环。在这个阶段，这并不是严格必要的，因为我们的所有对象默认都位于层零。我们将在项目结束前添加层-1和1的对象，我们不希望如果可能的话重写代码。
- en: 'Next, we check if the object is visible and on the current layer. If it is,
    we pass the current object''s location and dimensions to the `worldToScreen` method,
    which returns the result to our previously prepared `toScreen2d Rect` object.
    Then, we call `drawBitmap()` using our `bitmapArray` to provide the appropriate
    bitmap, and pass in the coordinates of `toScreen2d`. Update the `draw` method
    as highlighted:'
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查对象是否可见并且位于当前层。如果是的话，我们将当前对象的位置和尺寸传递给`worldToScreen`方法，该方法将结果返回到我们之前准备好的`toScreen2d
    Rect`对象。然后，我们使用`bitmapArray`调用`drawBitmap()`来提供适当的位图，并传入`toScreen2d`的坐标。更新后的`draw`方法如下所示：
- en: '[PRE154]'
  id: totrans-977
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: Now, still in the `draw` method, we print debugging info to the screen, including
    the size of our `gameObjects ArrayList` compared to the number of objects that
    were clipped this frame.
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，仍然在`draw`方法中，我们将调试信息打印到屏幕上，包括我们`gameObjects ArrayList`的大小与这一帧被裁剪的对象数量的比较。
- en: 'Then, we finish the `draw` method by the usual call to `unlockCanvasAndPost()`.
    Note that at the end of the `if(debugging)` block, we call `vp.resetNumClipped`
    to set the `numClipped` variable back to zero ready for the next frame. Add this
    code straight after the previous block of code in the `draw` method:'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过常规调用`unlockCanvasAndPost()`来完成`draw`方法。注意，在`if(debugging)`块的末尾，我们调用`vp.resetNumClipped`将`numClipped`变量重置为零，以便为下一帧做好准备。将此代码直接添加到`draw`方法中的上一段代码之后：
- en: '[PRE155]'
  id: totrans-980
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'For the first time in this project, we can actually run our game and see some
    results:'
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们第一次真正运行我们的游戏并看到一些结果：
- en: '![The enhanced draw method](img/B04322_05_03.jpg)'
  id: totrans-982
  prefs: []
  type: TYPE_IMG
  zh: '![增强的draw方法](img/B04322_05_03.jpg)'
- en: Note in the image the precise layout of the grass from our `LevelCave` design.
    You can also see our squashed Bob sprite sheet and the fact that there are 28
    objects, but 10 of them have been clipped. As our levels get bigger, the ratio
    of clipped to unclipped will dramatically increase in favor of the vast majority
    being clipped.
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 注意图像中`LevelCave`设计的草地精确布局。您还可以看到我们的压缩比伯精灵图集，以及有28个对象，但其中10个已经被裁剪。随着我们的关卡变得更大，裁剪与未裁剪的比例将显著增加，大多数对象将被裁剪。
- en: Summary
  id: totrans-984
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have covered a lot of ground in this chapter, and now have a well fleshed-out
    game engine.
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们覆盖了很多内容，现在我们有一个非常完善的游戏引擎。
- en: As we have done much of the setup work, from now on, most of the code we add
    will also have a visible (or audible) result and be much more satisfying, as we
    will be able to regularly run our game to see the improvements.
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经完成了大部分的设置工作，从现在开始，我们添加的大部分代码也将产生可见（或可听）的结果，并且会更有满足感，因为我们能够定期运行我们的游戏来查看改进。
- en: In the next chapter, we will add sound effects and input detection, thus bringing
    Bob to life. Then, we will see how dangerous his world can be, and will promptly
    add collision detection so that he can stand on a platform.
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将添加音效和输入检测，从而使比伯栩栩如生。然后，我们将看到他的世界有多么危险，并将立即添加碰撞检测，以便他能够站在平台上。
- en: Chapter 6. Platformer – Bob, Beeps, and Bumps
  id: totrans-988
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 平台游戏 – 比伯、哔哔声和颠簸
- en: Now that our basic game engine is set up, we can start making some fast progress.
    In this chapter, we will quickly add a `SoundManager` class that we will use to
    make a noise wherever and whenever we please. After that, we will put some meat
    on the bones of Bob and implement the core functionality we require in the `Player`
    class. Then, we can handle the second phase (after clipping) of our multiphase
    collision detection and give Bob the useful skill of being able to stand on a
    platform.
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了基本游戏引擎，我们可以开始取得一些快速进展。在本章中，我们将快速添加一个`SoundManager`类，我们将使用它来在任意位置和任意时间制造噪音。之后，我们将为比伯添加一些实质性的内容并实现`Player`类中所需的核心功能。然后，我们可以处理多阶段碰撞检测的第二阶段（裁剪之后），并让比伯获得站在平台上的有用技能。
- en: After we have achieved this significant feat, we will hand over control of Bob
    to the player by implementing the `InputController` class. Bob will at last be
    able to run around and jump. At the end of this chapter, we will animate Bob's
    sprite sheet so he actually appears to run, rather than slide everywhere.
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成这个显著的成就之后，我们将通过实现 `InputController` 类将鲍勃的控制权交给玩家。鲍勃最终将能够四处奔跑和跳跃。在本章结束时，我们将动画化鲍勃的精灵图集，让他看起来真的在跑，而不是到处滑动。
- en: The SoundManager class
  id: totrans-991
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`SoundManager` 类'
- en: Throughout the next few chapters, we will be adding sound effects for various
    events. Sometimes these sounds will be triggered directly in the main `PlatformView`
    class, but other times, they will need to be triggered in more remote corners
    of your code like the `InputController` class and even within the `GameObject`
    class themselves. We will quickly make a simple `SoundManager` class that can
    be passed around and used as needed when a beep is required.
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几章中，我们将为各种事件添加音效。有时这些声音将直接在主 `PlatformView` 类中触发，但有时它们需要在代码的更远端触发，比如在 `InputController`
    类中，甚至在 `GameObject` 类内部。我们将快速创建一个简单的 `SoundManager` 类，可以在需要哔哔声时传递和使用。
- en: 'Create a new Java class and call it `SoundManager`. This class has three main
    parts. In the first part, we simply declare a `SoundPool` object and a bunch of
    `int` variables to hold a reference to each sound effect. Enter the first part
    of the code, the declaration, and members:'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 Java 类，命名为 `SoundManager`。这个类有三个主要部分。在第一部分，我们简单地声明一个 `SoundPool` 对象和一些
    `int` 变量来保存每个音效的引用。进入代码的第一部分，声明和成员：
- en: '[PRE156]'
  id: totrans-994
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'The second part of the class is the `loadSound` method, which unsurprisingly
    loads all the sounds into memory ready for playing. We will call this once we
    have initialized a `SoundManager` object in the `PlatformView` constructor. Enter
    this code next:'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 类的第二部分是 `loadSound` 方法，它意外地加载所有声音到内存中，以便播放。我们将在 `PlatformView` 构造函数中初始化 `SoundManager`
    对象后调用它。接下来输入以下代码：
- en: '[PRE157]'
  id: totrans-996
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Finally for our `SoundManager` class, we need to be able to play any sound
    we like. This `playSound` method simply switches on a string passed in as a parameter.
    When we have a `SoundManager` object, we can just call `playSound()` with an appropriate
    string argument:'
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于我们的 `SoundManager` 类，我们需要能够播放任何我们喜欢的声音。这个 `playSound` 方法简单地切换传入的参数字符串。当我们有一个
    `SoundManager` 对象时，我们只需用适当的字符串参数调用 `playSound()`：
- en: '[PRE158]'
  id: totrans-998
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: Declare a new object of type `SoundManager` after the `PlatformView` class declaration
    after your new game engine classes from the previous chapter.
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的新游戏引擎类（上一章中）声明 `PlatformView` 类之后，声明一个新的 `SoundManager` 类对象。
- en: '[PRE159]'
  id: totrans-1000
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'Next, initialize the `SoundManager` object and call `loadSound()` in the `PlatformView`
    constructor as shown:'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `PlatformView` 构造函数中初始化 `SoundManager` 对象并调用 `loadSound()`，如下所示：
- en: '[PRE160]'
  id: totrans-1002
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: You can create all your own sounds using BFXR or just copy mine from the `Chapter6/assets`
    folder. Copy all the sounds to the `assets` folder in your Android Studio project.
    Create an `assets` folder in the `src/main` folder of your project in order to
    achieve this if the folder doesn't exist already.
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 BFXR 创建你自己的声音，或者只需从 `Chapter6/assets` 文件夹中复制我的声音。将所有声音复制到你的 Android Studio
    项目的 `assets` 文件夹中。如果你的项目中还没有 `assets` 文件夹，请在 `src/main` 文件夹中创建一个 `assets` 文件夹以实现这一点。
- en: Now, we can play sound effects wherever we like. It's time to bring our hero
    Bob to life.
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在任何我们想要的地方播放音效。是时候让我们的英雄鲍勃复活了。
- en: Introducing Bob
  id: totrans-1005
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍鲍勃
- en: Here, we can add the meat to the bones of your `Player` class. However, this
    section won't be the last time we revisit the `Player` class. Now, we will add
    the necessary functionality to allow Bob to move. Immediately after we have done
    this, we will add the code to allow the player to use the forthcoming collision
    detection code and the `Animation` class.
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以为 `Player` 类添加实质性的内容。然而，这不会是我们最后一次访问 `Player` 类。现在，我们将添加必要的功能，让鲍勃能够移动。在我们完成这个之后，我们将添加代码，让玩家可以使用即将到来的碰撞检测代码和
    `Animation` 类。
- en: First of all, we need to add some members to the `Player` class. The `Player`
    class will need to know how fast it can move, when the player is pressing the
    left or right controls, and if it is falling or jumping. In addition, the `Player`
    class needs to know how long it has been jumping and how long it should jump for.
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要向 `Player` 类添加一些成员。`Player` 类需要知道它能够移动多快，当玩家按下左右控制键时，以及它是否在坠落或跳跃。此外，`Player`
    类还需要知道它已经跳跃了多久以及它应该跳跃多久。
- en: The next block of code provides variables for us to monitor all these things.
    We will very soon see, how we use them to make Bob do what we want.
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码块为我们提供了监控所有这些内容的变量。我们很快就会看到，我们如何使用它们让鲍勃做我们想要的事情。
- en: 'Now, we know what the variables are for. We can add this code right after the
    class declaration as shown:'
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道这些变量的用途了。我们可以在类声明之后立即添加此代码：
- en: '[PRE161]'
  id: totrans-1010
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'Furthermore, there are some other movement-related conditions we will need
    to track, but they will be useful in other classes as well. Therefore, we will
    add them as members to the `GameObject` class. We will track the current horizontal
    and vertical speed, the direction the object is facing, and whether the object
    can move at all with the following variables. Add these to the `GameObject` class:'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些与运动相关的条件我们需要跟踪，但它们在其他类中也会很有用。因此，我们将它们作为成员添加到`GameObject`类中。我们将跟踪当前的水平速度和垂直速度，对象面对的方向，以及对象是否可以移动，以下是一些变量。将这些添加到`GameObject`类中：
- en: '[PRE162]'
  id: totrans-1012
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: Now, in the `GameObject` class, we will add a `move` method. This method simply
    checks that the velocity on either of the axes is not zero and if it is, it moves
    the object by changing its `worldLocation` object. This method uses the velocity
    (either `xVelocity` or `yVelocity`) divided by the current frames per second to
    calculate the distance to move each frame. This ensures that the movement will
    be exactly correct, regardless of the current frames per second. It doesn't matter
    if our game executes smoothly or fluctuates a bit, or how powerful or puny the
    CPU in the Android device is. We will very soon call this `move` method from within
    the `update` method of the `Player` class. Later in the project, we will call
    it from other classes as well.
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`GameObject`类中，我们将添加一个`move`方法。这个方法简单地检查任一轴上的速度是否为零，如果是，则通过改变其`worldLocation`对象来移动对象。此方法使用速度（`xVelocity`或`yVelocity`）除以当前每秒帧数来计算每帧要移动的距离。这确保了移动将完全正确，无论当前每秒帧数是多少。我们的游戏是否执行流畅，或者略有波动，或者Android设备中的CPU有多强大或多弱，这都不重要。我们很快就会在`Player`类的`update`方法中调用这个`move`方法。在项目的后期，我们也会在其他类中调用它。
- en: '[PRE163]'
  id: totrans-1014
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: Next, in the `GameObject` class, we have a bunch of getters and setters for
    the new variables we added previously. The only part to note is that the setters
    for the two velocity variables (`setxVelocity` and `setyVelocity`) check `if(moves)`
    before actually assigning a value. Add these new getters and setters to the `GameObject`
    class.
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`GameObject`类中，我们为之前添加的新变量提供了一组getter和setter。需要注意的是，两个速度变量的setter（`setxVelocity`和`setyVelocity`）在实际上传值之前会检查`if(moves)`。将这些新的getter和setter添加到`GameObject`类中。
- en: '[PRE164]'
  id: totrans-1016
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'Now, back in the `Player` class constructor, we can use some of these new methods
    to set up the object at creation time. Add the highlighted code to the `Player`
    constructor:'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到`Player`类的构造函数中，我们可以在创建对象时使用这些新方法来设置对象。将以下高亮代码添加到`Player`构造函数中：
- en: '[PRE165]'
  id: totrans-1018
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: At last, we can make practical use of all this new code in the `Player` class's
    `update` method.
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在`Player`类的`update`方法中实际使用所有这些新代码。
- en: First, we handle what happens when `isPressingRight` or `isPressingLeft` is
    true. Of course, we still need to be able to set these variables via touches on
    the screen. Very simply, this next code block sets the horizontal velocity to
    `MAX_X_VELOCITY` if `isPressingRight` is true or to `-MAX_X_VELOCITY` if `isPressingLeft`
    is true. If neither is true, it sets the horizontal velocity to zero, which is
    standing still.
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们处理当`isPressingRight`或`isPressingLeft`为真时会发生什么。当然，我们仍然需要能够通过屏幕触摸来设置这些变量。非常简单，接下来的代码块将水平速度设置为`MAX_X_VELOCITY`，如果`isPressingRight`为真，或者设置为`-MAX_X_VELOCITY`，如果`isPressingLeft`为真。如果两者都不为真，则将水平速度设置为零，即站立不动。
- en: '[PRE166]'
  id: totrans-1021
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: Next, we check which way the player is moving and call `setFacing()` with either
    `RIGHT` or `LEFT` as the argument.
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查玩家移动的方向，并使用`RIGHT`或`LEFT`作为参数调用`setFacing()`。
- en: '[PRE167]'
  id: totrans-1023
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: Now, we can handle jumping. When the player presses the jump button, if successful,
    `isJumping` will be set to true and `jumpTime` will be set to whatever the current
    system time is. So we can then enter the `if(isJumping)` block on each frame,
    test how long Bob has been jumping for, and if he has not exceeded `maxJumpTime`
    take one of two possible actions.
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以处理跳跃了。当玩家按下跳跃按钮时，如果成功，`isJumping`将被设置为真，`jumpTime`将被设置为当前系统时间。然后我们可以在每一帧进入`if(isJumping)`块中，测试鲍勃跳了多久，如果没有超过`maxJumpTime`，则采取两种可能的行为之一。
- en: Action one is; if we are less than half way through the jump, the *y* velocity
    is set to `-gravity` (going up). Action two is; if Bob is more than half way through
    the jump, his *y* velocity is set to `gravity` (going down).
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个动作是：如果我们还没有跳到一半，将*y*速度设置为`-gravity`（向上）。第二个动作是：如果鲍勃跳过一半以上，他的*y*速度设置为`gravity`（向下）。
- en: When `maxJumpTime` is exceeded, `isJumping` is set back to false until the next
    time the player taps the jump button. The final `else` clause in the following
    code executes whenever `isJumping` is false and sets the player's `y` velocity
    to `gravity`. Note that the additional line of code that sets `isFalling` to `true`.
    As we will see, this variable is used to control what happens when the player
    initially tries to jump and also in parts of our collision detection code. It
    basically stops the player from being able to jump in mid air.
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 当`maxJumpTime`超过时，`isJumping`被设置为`false`，直到玩家下一次点击跳跃按钮。以下代码中的最后一个`else`子句在`isJumping`为`false`时执行，并将玩家的`y`速度设置为`gravity`。注意，设置`isFalling`为`true`的附加代码行。正如我们将看到的，这个变量用于控制玩家最初尝试跳跃时发生的情况，以及在我们的碰撞检测代码的部分。它基本上阻止了玩家在空中跳跃的能力。
- en: '[PRE168]'
  id: totrans-1027
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: Immediately after we handle jumping, we call `move()` to update the *x* and
    *y* coordinates, if they have changed.
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理跳跃后立即，我们调用`move()`来更新*x*和*y*坐标，如果它们已经改变。
- en: '[PRE169]'
  id: totrans-1029
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: That was a bit of a mouthful, but apart from the actual controls, it is just
    about everything we need to allow the player to move. We just need to call the
    `update`() method from our `PlatformView` class's `update` method once each frame,
    and our player character will spring into action.
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 这段话有点长，但除了实际的控制之外，这几乎是我们允许玩家移动所需的一切。我们只需要在每个帧中从我们的`PlatformView`类的`update`方法中调用`update()`方法一次，我们的玩家角色就会立刻行动起来。
- en: 'In the `update` method of the `PlatformView` class, add the following code
    as shown highlighted:'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PlatformView`类的`update`方法中，添加以下代码，如下所示，高亮显示：
- en: '[PRE170]'
  id: totrans-1032
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'Next, we can see what is going on. Let''s add some more text output to the
    `if(debugging)` block in the `draw` method of `PlatformView`. Add the new highlighted
    code as shown here:'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以看到正在发生的事情。让我们在`PlatformView`类的`draw`方法中的`if(debugging)`块中添加一些更多的文本输出。添加新的高亮代码，如下所示：
- en: '[PRE171]'
  id: totrans-1034
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: Why not run the game now? You have probably noticed the next issue is that the
    player is gone.
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不现在运行游戏呢？你可能已经注意到下一个问题是玩家消失了。
- en: '![Introducing Bob](img/B04322_06_01.jpg)'
  id: totrans-1036
  prefs: []
  type: TYPE_IMG
  zh: '![介绍鲍勃](img/B04322_06_01.jpg)'
- en: This is because we now have gravity, and also the thread that calls `update()`
    runs immediately as the application starts, even before our level and the player
    character is finished being set up.
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们现在有了重力，而且调用`update()`的线程在应用程序启动时立即运行，甚至在我们的关卡和玩家角色设置完成之前。
- en: We need to do two things. First, we only want `update()` to run when the `LevelManager`
    class has finished its work. Secondly, we need to update the focus of the `Viewport`
    class in every frame so that even if the player is falling to his death (as he
    will frequently) the screen will be centered on him, so we can watch his demise.
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做两件事。首先，我们只希望当`LevelManager`类完成其工作后，`update()`方法才运行。其次，我们需要在每一帧更新`Viewport`类的焦点，以便即使玩家正在坠落（他经常会这样做），屏幕也会以他为中心，这样我们就可以观看他的死亡。
- en: 'Let''s start the game on paused mode so that the player isn''t missing. First,
    we will add a method to our `LevelManager` class that will switch the playing
    status between playing and not playing. A good name may be `switchPlayingStatus()`.
    Add the new method to `LevelManager` as shown follows:'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在暂停模式下开始游戏，这样玩家就不会错过了。首先，我们将在`LevelManager`类中添加一个方法，用于在播放和不播放之间切换播放状态。一个好的名字可能是`switchPlayingStatus()`。将新方法添加到`LevelManager`中，如下所示：
- en: '[PRE172]'
  id: totrans-1040
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'Now, just delete or comment out the line of code in the `LevelManager` constructor
    that sets `playing` to `true`. Soon, this will be handled by screen touches and
    the method we just wrote:'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只需删除或注释掉`LevelManager`构造函数中设置`playing`为`true`的那行代码。不久，这将由屏幕触摸和刚刚编写的该方法来处理：
- en: '[PRE173]'
  id: totrans-1042
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: We will write a tiny bit of temporary code, just a tiny bit. We already know
    that we will eventually be delegating responsibility to monitor player input to
    our new `InputController` class. This little bit of code in the overridden `onTouchEvent`
    method is well worth the effort because we will be able to use a pause feature
    right now.
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一小段临时代码，只是很小的一段。我们已经知道我们最终会将监控玩家输入的责任委托给我们的新`InputController`类。在重写的`onTouchEvent`方法中的这段小代码非常值得努力，因为我们现在就可以使用暂停功能。
- en: This code will toggle the playing status using the method we just wrote each
    time we touch the screen. Add the overridden method to the `PlatformView` class.
    We will eventually replace some of this code later in the chapter.
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将使用我们刚刚编写的方法在每次触摸屏幕时切换播放状态。将重写的方法添加到`PlatformView`类中。我们将在本章的后面部分替换一些代码。
- en: '[PRE174]'
  id: totrans-1045
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'You can set `isPressingRight` in the `Player` class to true, following which
    you can run the game and tap the screen. We will then see the player fall like
    a ghost off the bottom, while moving to the right of the screen:'
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`Player`类中将`isPressingRight`设置为true，然后运行游戏并轻触屏幕。然后我们会看到玩家像幽灵一样从屏幕底部坠落，同时向右移动：
- en: '![Introducing Bob](img/B04322_06_02.jpg)'
  id: totrans-1047
  prefs: []
  type: TYPE_IMG
  zh: '![介绍鲍勃](img/B04322_06_02.jpg)'
- en: 'Now, let''s update the viewport per frame to remain centered on the player.
    Add this highlighted code to the very end of the `update` method in the `PlatformView`
    class:'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们每帧更新视口，使其保持在玩家中心。将以下高亮代码添加到`PlatformView`类的`update`方法末尾：
- en: '[PRE175]'
  id: totrans-1049
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: If you run the game now, although the player still falls to his doom and to
    the right, at least the screen stays focused on him to watch it happen.
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行游戏，尽管玩家仍然会向右下落，但至少屏幕会聚焦在他身上，以便观看这一过程。
- en: We will deal with the perpetual falling problem.
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将处理永无止境的下落问题。
- en: Multiphase collision detection
  id: totrans-1052
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多阶段碰撞检测
- en: We have seen that our player character simply falls though the world and into
    oblivion. Of course we need the player to be able to stand on the platforms. Here
    is what we will do.
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到我们的玩家角色只是简单地穿过世界并坠入虚无。当然，我们需要玩家能够站在平台上。以下是我们将要做的。
- en: We will provide every object that matters with a hitbox as we can then provide
    methods in the `Player` class to test if a hitbox has made contact with the player.
    Once per frame, we will send all hitboxes that have not been clipped by the viewport
    to this new method where a collision can be tested for.
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为每个重要的对象提供一个碰撞盒，这样我们就可以在`Player`类中提供方法来测试碰撞盒是否与玩家接触。每帧一次，我们将所有未被视口裁剪的碰撞盒发送到这个新方法中进行碰撞测试。
- en: We do it like this for two main reasons. Firstly, by sending only unclipped
    hitboxes for collision testing, we drastically reduce the number of checks, as
    described in [Chapter 3](ch12.html "Chapter 3. Tappy Defender – Taking Flight"),
    *Tappy Defender – Taking Flight*, in the section *Things that go bump – collision
    detection*. Secondly, by handling the checks within the `Player` class, we can
    give the player multiple different hitboxes and respond slightly differently according
    to which one is hit.
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做主要有两个原因。首先，通过只发送未裁剪的碰撞盒进行碰撞测试，我们大大减少了检查的数量，如第3章[“Tappy Defender – Taking
    Flight”](ch12.html "Chapter 3. Tappy Defender – Taking Flight")中所述，在“碰撞检测”部分*Things
    that go bump*。其次，通过在`Player`类中处理检查，我们可以给玩家多个不同的碰撞盒，并根据被击中的碰撞盒做出不同的反应。
- en: Let's create our own class for a hitbox, so we can make it just how we want
    it. It needs to use float coordinates, it needs an `intersects` method and a bunch
    of getters and setters as well. Create a new class and call it `RectHitbox`.
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建自己的碰撞盒类，这样我们就可以按照自己的意愿来设计它。它需要使用浮点坐标，需要一个`intersects`方法以及一些getter和setter。创建一个新的类，命名为`RectHitbox`。
- en: 'Here, we see that `RectHitbox` simply has a bunch of self explanatory getters
    and setters. It also has the `intersects` method, which returns `true` if the
    `RectHitbox` passed into it intersects with itself. For an explanation of how
    the `intersects()` code works, see [Chapter 3](ch12.html "Chapter 3. Tappy Defender
    – Taking Flight"), *Tappy Defender – Taking Flight*. Enter the following code
    into the new class:'
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到`RectHitbox`只是一些简单的getter和setter方法。它还有一个`intersects`方法，如果传入的`RectHitbox`与其自身相交，则返回`true`。关于`intersects()`代码的工作原理的解释，请参阅第3章[“Tappy
    Defender – Taking Flight”](ch12.html "Chapter 3. Tappy Defender – Taking Flight")。将以下代码输入到新类中：
- en: '[PRE176]'
  id: totrans-1058
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: Now, we can add a `RectHitbox` class as a member of `GameObject`. Add it right
    after the class declaration.
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在`GameObject`中将`RectHitbox`类作为成员添加。在类声明之后添加它。
- en: '[PRE177]'
  id: totrans-1060
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'Then, we add a method to initialize the hitbox and a method so that we can
    grab a copy of it when needed. Add these two methods to `GameObject`:'
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加一个初始化碰撞盒的方法和一个方法，以便在需要时获取它的副本。将这些方法添加到`GameObject`中：
- en: '[PRE178]'
  id: totrans-1062
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: Now for our `Grass` object, we add a call to `setRectHitbox()` and then we can
    start bumping into it. Add this one line of highlighted code at the very end of
    the `Grass` class's constructor. It is important that the call to `setRectHitbox()`
    comes after the call to `setWorldLocation()` otherwise the hitbox won't be wrapped
    around the block of grass.
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们为`Grass`对象添加一个对`setRectHitbox()`的调用，然后我们可以开始与之碰撞。在`Grass`类的构造函数的末尾添加这一行高亮代码。重要的是，`setRectHitbox()`的调用必须在`setWorldLocation()`的调用之后，否则碰撞框将不会围绕草块包裹。
- en: '[PRE179]'
  id: totrans-1064
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'Before we can begin to comprehend the code that will do the collision checking,
    we need the `Player` class to have its own set of hitboxes. We need to know the
    following things about the player character:'
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始理解将要进行碰撞检测的代码之前，我们需要`Player`类有自己的碰撞框集合。我们需要了解有关玩家角色的以下信息：
- en: When the head bumps something above it
  id: totrans-1066
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当头部撞到它上面的东西时
- en: When the feet land on a platform below
  id: totrans-1067
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当脚部落在下面的平台上时
- en: When the player walks into something either side of it
  id: totrans-1068
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当玩家走进它两侧的东西时
- en: To achieve this, we will create four hitboxes; one for the head, one for the
    feet, and one for each of the left and right-hand sides. As they are unique to
    the player, we will create the hitboxes within the `Player` class.
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将创建四个碰撞框；一个用于头部，一个用于脚部，以及每个左右手边的碰撞框。由于它们是玩家独有的，我们将在`Player`类中创建碰撞框。
- en: 'Declare the four hitboxes as members just after the `Player` class declaration:'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Player`类声明之后立即声明四个碰撞框：
- en: '[PRE180]'
  id: totrans-1071
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'Now in the constructor, we call new `RectHitbox()` to prepare them. Note that
    we haven''t bothered assigning any values to the hitboxes. We will see how we
    do that soon. Add the four calls to `new()` at the end of the `Player` constructor
    like this:'
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在构造函数中，我们调用新的`RectHitbox()`来准备它们。请注意，我们没有费心为碰撞框分配任何值。我们很快就会看到如何做到这一点。像这样在`Player`构造函数的末尾添加四个`new()`调用：
- en: '[PRE181]'
  id: totrans-1073
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: We will see were we will initialize them properly. The hitbox values in the
    code that follows, have been manually estimated based on the space taken up by
    the actual shape of the character within the rectangle that represents each frame
    of the character. If you use a different character graphic, you will likely need
    to adjust the precise values you use.
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到我们将在哪里正确地初始化它们。接下来的代码中的碰撞框值是根据代表每个角色帧的矩形内实际形状所占用的空间手动估计的。如果你使用不同的角色图形，你可能需要调整你使用的精确值。
- en: The diagram shows an approximate graphical representation of the locations that
    each hitbox will be positioned at. The apparent lack of closeness for the left
    and right hitboxes is because different frames of the animation are slightly wider
    than this one. This is a compromise.
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 图表显示了每个碰撞框将定位的大致图形表示。左右碰撞框之间明显的距离不足是因为动画的不同帧比这个略宽。这是一个妥协。
- en: '![Multiphase collision detection](img/B04322_06_03_new.jpg)'
  id: totrans-1076
  prefs: []
  type: TYPE_IMG
  zh: '![多阶段碰撞检测](img/B04322_06_03_new.jpg)'
- en: The code must be placed after the call to `move()` within the `update` method
    in the `Player` class. This way, the hitboxes are updated each and every time
    the player position has changed. Add the highlighted code in exactly the position
    shown, and then we are one step closer to being able to start bumping in to stuff.
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: 代码必须放置在`Player`类`update`方法中`move()`调用之后。这样，每当玩家位置发生变化时，碰撞框都会更新。在所示位置添加高亮代码，然后我们就更接近能够开始与物体碰撞。
- en: '[PRE182]'
  id: totrans-1078
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: In the next stage, we can detect some collisions and react to them. Collisions
    which only concern the player, such as falling, bumping his head, or trying to
    walk through a wall are handled directly in this next method, within the `Player`
    class. Note that the method also returns an `int` value to represent if there
    was a collision and where on the player that collision occurred so that other
    collisions with things like pickups or pits of fire can be handled outside the
    class.
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个阶段，我们可以检测一些碰撞并对它们做出反应。仅涉及玩家的碰撞，例如坠落、撞头或试图穿过墙壁，将在`Player`类中的这个下一个方法中直接处理。请注意，该方法还返回一个`int`值来表示是否发生了碰撞以及碰撞发生在玩家身上的哪个位置，以便可以处理与拾取物或火坑等物品的其他碰撞。
- en: The new `checkCollisions` method receives a `RectHitbox` as a parameter. This
    will be the `RectHitbox` of whichever object we are currently checking against
    for collisions. Add the `checkCollisions` method to the `Player` class.
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`checkCollisions`方法接收一个`RectHitbox`作为参数。这将是我们当前正在检查碰撞的任何对象的`RectHitbox`。将`checkCollisions`方法添加到`Player`类中。
- en: '[PRE183]'
  id: totrans-1081
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'As the previous code implies, we need to add some setter methods to the `GameObject`
    class so that the *x* and *y* world coordinates can be changed when a collision
    is detected. Add the following two methods to the `GameObject` class:'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，我们需要向`GameObject`类添加一些setter方法，以便在检测到碰撞时可以更改*x*和*y*世界坐标。将以下两个方法添加到`GameObject`类中：
- en: '[PRE184]'
  id: totrans-1083
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'The final step is to select all relevant objects and test for collisions. We
    do this in the `update` method of the `PlatformView` class, following which we
    switch to take further actions based on which body part collides with what object
    type. Our switch block will only have a default case to begin with, since we have
    only one possible object type to collide with a grass platform. Note that when
    a collision with the feet is detected, we set our `isFalling` variable to `false`,
    enabling the player to jump. Enter the highlighted code where shown:'
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是选择所有相关对象并测试碰撞。我们在`PlatformView`类的`update`方法中这样做，之后根据哪个身体部位与哪种对象类型发生碰撞来采取进一步行动。我们的switch块最初将只有一个默认情况，因为我们只有一个可能的对象类型可以与草地平台发生碰撞。注意，当检测到脚部碰撞时，我们将`isFalling`变量设置为`false`，使玩家能够跳跃。在所示位置输入高亮代码：
- en: '[PRE185]'
  id: totrans-1085
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: Note
  id: totrans-1086
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We will make more use of the value that gets stored in `hit` for further collision-based
    decision making, as we progress with this project.
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们在这个项目中继续前进，我们将更多地使用存储在`hit`中的值来进行基于碰撞的进一步决策。
- en: Let's take control of the player for real.
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们真正控制玩家。
- en: Player input
  id: totrans-1089
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩家输入
- en: First, let's add some methods in the `Player` class that our input controller
    will be able to call, then manipulate the variables that the `Player` class's
    `update` method uses to move around.
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在`Player`类中添加一些方法，这样我们的输入控制器就能够调用它们，然后操作`Player`类`update`方法使用的变量来移动。
- en: We already played with the `isPressingRight` variable, and also have an `isPressingLeft`
    variable. Furthermore, we want to be able to jump. If you take a look at the `Player`
    class's `update` method, we already have the code to handle these situations.
    We just need the player to be able to initiate the movements via touches to the
    screen.
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经玩过了`isPressingRight`变量，并且还有一个`isPressingLeft`变量。此外，我们还想能够跳跃。如果你查看`Player`类的`update`方法，我们已经有处理这些情况的代码。我们只需要让玩家能够通过触摸屏幕来启动这些动作。
- en: Our previous button layout design and the code we have written so far, suggests
    a method for going left, a method for going right, and a method for jumping.
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的按钮布局设计和迄今为止编写的代码，表明有一个向左走的方法，一个向右走的方法，以及一个跳跃的方法。
- en: 'You will also note that we pass a copy of `SoundManager` into the `startJump`
    method, which allows us to play a neat retro jumping sound, if the jump attempt
    is successful. Add these three new methods to the `Player` class:'
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 你也会注意到，我们将一个`SoundManager`的副本传递给`startJump`方法，这使得我们能够在跳跃尝试成功时播放一个整洁的复古跳跃声音。将这三个新方法添加到`Player`类中：
- en: '[PRE186]'
  id: totrans-1094
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'Now, we can focus on the `InputController` class. Let''s pass control from
    the `onTouchEvent` method to our `InputController` class. Change the code in the
    `onTouchEvent` method to the following in the `PlatformView` class:'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以专注于`InputController`类。让我们将控制权从`onTouchEvent`方法传递到我们的`InputController`类。在`PlatformView`类中将`onTouchEvent`方法中的代码更改为以下内容：
- en: '[PRE187]'
  id: totrans-1096
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: We have an error in our new method. This is simply because we have called the
    `handleInput` method but not implemented it yet. We will do that now.
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新方法中有一个错误。这仅仅是因为我们调用了`handleInput`方法，但还没有实现它。我们现在将这样做。
- en: Note
  id: totrans-1098
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are wondering about the check for whether `lm != null`, that is because
    the `onTouchEvent` method is triggered from the Android UI thread and is not within
    our control. If we pass in `lm` and start trying to do things with it, when it
    is not initialized, the game will crash.
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道关于`lm != null`的检查，那是因为`onTouchEvent`方法是从Android UI线程触发的，并且不受我们的控制。如果我们传递`lm`并开始尝试使用它，当它未初始化时，游戏将会崩溃。
- en: We can now get everything that we need done within the `InputController` class.
    Open that class now, and we will plan what we are going to do.
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在`InputController`类中完成所有需要做的事情。现在打开这个类，我们将计划我们将要做什么。
- en: We need a button to go left, a button to go right, a button to jump, a button
    to toggle pause, and later we will also need a button to fire a machine gun. Therefore,
    we really need to highlight different areas of the screen to represent each of
    these tasks.
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个向左走的按钮，一个向右走的按钮，一个跳跃的按钮，一个切换暂停的按钮，稍后我们还需要一个开枪的按钮。因此，我们真的需要突出显示屏幕上的不同区域来代表每个任务。
- en: To do this, we will declare four `Rect` objects, one for each task. Then in
    the constructor, we will define the points of these four `Rect` objects by carrying
    out some simple calculations based on the players screen resolution.
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将声明四个 `Rect` 对象，每个任务一个。然后在构造函数中，我们将通过基于玩家屏幕分辨率进行一些简单计算来定义这四个 `Rect`
    对象的点。
- en: 'We define some handy variables, `buttonWidth`, `buttonHeight`, and `buttonPadding`,
    based on the device''s screen resolution to help us arrange our `Rect` coordinates
    neatly. Enter the following members and the `InputController` constructor as shown
    next:'
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一些方便的变量，`buttonWidth`、`buttonHeight` 和 `buttonPadding`，基于设备的屏幕分辨率来帮助我们整齐地安排我们的
    `Rect` 坐标。输入以下成员和 `InputController` 构造函数，如下所示：
- en: '[PRE188]'
  id: totrans-1104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'We will use the four `Rect` objects to draw buttons on the screen. The `draw`
    method is going to need a copy of them. Enter the code for the `getButtons` method
    to achieve this:'
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用四个 `Rect` 对象在屏幕上绘制按钮。`draw` 方法将需要一个它们的副本。输入 `getButtons` 方法的代码以实现这一点：
- en: '[PRE189]'
  id: totrans-1106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: We can now handle the actual player input. This project is different to the
    previous one because there are lots of different possible player actions that
    need to be monitored and responded to, sometimes simultaneously. As you expect,
    the Android API has the functionality to make this as easy as possible for us.
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以处理实际的玩家输入。这个项目与之前的有所不同，因为需要监控和响应许多不同的玩家动作，有时是同时进行的。正如你所期望的，Android API
    有功能使我们尽可能容易地做到这一点。
- en: The `MotionEvent` class has a lot more data tucked away in it than we have seen
    so far. Previously, we simply checked for the `ACTION_DOWN` and `ACTION_UP` events.
    Now, we need to dig a little deeper to grab more of the event data.
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: '`MotionEvent` 类中包含比我们迄今为止所看到更多的数据。之前，我们只是简单地检查了 `ACTION_DOWN` 和 `ACTION_UP`
    事件。现在，我们需要深入挖掘以获取更多的事件数据。'
- en: In order to record and pass on the details of multiple fingers, touching, leaving,
    and moving on the screen, the `MotionEvent` class stores them all in an array.
    When the first finger of the player touches the screen, the details, coordinates,
    and so on, are stored at position zero. Subsequent actions are then stored later
    in the array.
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了记录和传递多个手指触摸、离开和移动到屏幕上的详细信息，`MotionEvent` 类将它们全部存储在一个数组中。当玩家的第一个手指触摸屏幕时，详细信息、坐标等存储在位置零。然后后续动作随后存储在数组中的较后位置。
- en: The position in the array related to any such finger's activity is not consistent.
    In some situations, such as detecting specific gestures, this can be a problem
    and the programmer needs to capture, remember, and respond to the ID of a finger,
    also held in the `MotionEvent` class.
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何此类手指活动相关的数组中的位置并不一致。在某些情况下，例如检测特定手势，这可能会成为一个问题，程序员需要捕获、记住并响应 `MotionEvent`
    类中持有的手指 ID。
- en: Fortunately in this situation, we have our clearly defined areas of the screen
    that represent our buttons, and the most we will ever need to know is if the finger
    has pressed or released the screen within one of these predefined areas.
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在这种情况下，我们有明确定义的屏幕区域，代表我们的按钮，我们最需要知道的是手指是否在其中一个预定义区域内按下或释放屏幕。
- en: We just need to find out how many fingers have caused events and are therefore
    stored in the array by calling `motionEvent.getPointerCount()`. We then loop through
    each of these events while providing a `switch` block to handle them, whatever
    area of the screen, where `ACTION_DOWN` or `ACTION_UP` has occurred. It won't
    matter which position in the array our event is stored at, as long as we detect
    it and respond to it.
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要找出有多少手指导致了事件，并且因此存储在数组中，通过调用 `motionEvent.getPointerCount()`。然后我们遍历这些事件中的每一个，同时提供一个
    `switch` 块来处理它们，无论屏幕的哪个区域发生了 `ACTION_DOWN` 或 `ACTION_UP`。我们的事件存储在数组中的哪个位置并不重要，只要我们检测到它并对其做出响应。
- en: The only other thing we need to know, before we can code our solution, is that
    the subsequent actions in the array are stored as `ACTION_POINTER_DOWN` and `ACTION_POINTER_UP`;
    therefore, with each pass through the loop, that we will shortly code, we need
    to check and handle both `ACTION_DOWN` and `ACTION_POINTER_DOWN`.
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以编写解决方案之前，我们还需要知道的是，数组中的后续动作存储为 `ACTION_POINTER_DOWN` 和 `ACTION_POINTER_UP`；因此，在接下来的代码中，每次循环遍历时，我们需要检查和处理
    `ACTION_DOWN` 和 `ACTION_POINTER_DOWN`。
- en: 'After all this talk, here is our `handleInput` method that gets called every
    time the screen is touched or released:'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些讨论之后，这是我们的 `handleInput` 方法，每次屏幕被触摸或释放时都会被调用：
- en: '[PRE190]'
  id: totrans-1115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: Note
  id: totrans-1116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are wondering why we bothered to set up two sets of control code, one
    for playing and one for not playing, it is because in [Chapter 8](ch17.html "Chapter 8. Platformer
    – Putting It All Together"), *Putting It All Together*, we will add a cool new
    feature for the game while it is paused. Of course, the `togglePlayingStatus`
    method did not need to be done like this, and it would have worked fine without
    the test for the status of playing. It just saves us making minor intricate amendments
    to our code later on.
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道为什么我们费心设置了两组控制代码，一组用于播放，另一组用于不播放，那是因为在 [第8章](ch17.html "第8章。平台游戏 - 整合所有元素")
    *整合所有元素* 中，我们将在游戏暂停时添加一个酷炫的新功能。当然，`togglePlayingStatus` 方法不需要这样做，即使没有对播放状态的测试也能正常工作。它只是节省了我们以后对代码进行一些细微的修改。
- en: 'Now all we need to do is open up the `PlatformView` class, grab a copy of the
    array with all the control buttons in, and draw them to the screen. We use the
    `drawRoundRect` method to draw neat curved-corner rectangles to represent the
    areas of the screen that will respond to the player''s touches. Enter this code
    in the `draw` method right before the call to `unlockCanvasAndPost()`:'
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要做的就是打开 `PlatformView` 类，获取包含所有控制按钮的数组副本，并将它们绘制到屏幕上。我们使用 `drawRoundRect`
    方法绘制整洁的圆角矩形，以表示屏幕上将对玩家的触摸做出响应的区域。在调用 `unlockCanvasAndPost()` 之前，在 `draw` 方法中输入此代码：
- en: '[PRE191]'
  id: totrans-1119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: Also, right before we call `unlockCanvasAndPost()`, let's draw a simple pause
    screen so that we know when the game is paused or playing.
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在我们调用 `unlockCanvasAndPost()` 之前，让我们先画一个简单的暂停屏幕，这样我们就能知道游戏是暂停还是正在播放。
- en: '[PRE192]'
  id: totrans-1121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'You can now jump and walk all over the place and a nice retro jumping sound
    plays as well. Why not add some more grass to the scene by editing `LevelCave`
    and replacing a few period characters (`.`) with a few more `1` characters. The
    next screenshot shows that the player has been jumping around a bit as well as
    the buttons used for controls:'
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以跳来跳去，还可以听到一个不错的复古跳跃声音。为什么不通过编辑 `LevelCave` 并将几个句点字符 (`.`) 替换为几个更多的 `1`
    字符来在场景中添加更多草地呢。下一张截图显示了玩家跳来跳去以及用于控制的按钮：
- en: '![Player input](img/B04322_06_04.jpg)'
  id: totrans-1123
  prefs: []
  type: TYPE_IMG
  zh: '![玩家输入](img/B04322_06_04.jpg)'
- en: Note
  id: totrans-1124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We will design some real-playable levels, as well as link them together in [Chapter
    8](ch17.html "Chapter 8. Platformer – Putting It All Together"), *Putting It All
    Together*. For now, just do whatever seems like fun with `LevelCave`.
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设计一些可玩的真实关卡，并在 [第8章](ch17.html "第8章。平台游戏 - 整合所有元素") *整合所有元素* 中将它们连接起来。现在，只需用
    `LevelCave` 做任何看起来有趣的事情即可。
- en: Now, we can get rid of that ugly squashed player graphic and make a neat little
    animation out of it.
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以摆脱那个丑陋的挤压玩家图形，并从中制作一个整洁的小动画。
- en: Animating Bob
  id: totrans-1127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画鲍勃
- en: Sprite sheet animations work by quickly changing the image drawn to the screen.
    Exactly like a child may draw the phases of a stick-man moving on the corner of
    a book, and then quickly flicking through it to make it appear to move.
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵图集动画通过快速改变屏幕上绘制的图像来实现。就像一个孩子可能在书的角落画一个棍状人的各个阶段，然后快速翻动它，使其看起来在移动一样。
- en: The frames of Bob's animation are already contained within the `player.png`
    file we have been using to represent him.
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: 鲍勃的动画帧已经包含在我们用来代表他的 `player.png` 文件中。
- en: '![Animating Bob](img/B04322_06_05.jpg)'
  id: totrans-1130
  prefs: []
  type: TYPE_IMG
  zh: '![动画鲍勃](img/B04322_06_05.jpg)'
- en: All we need to do is loop through them one at a time when the player is moving.
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的只是当玩家移动时逐个遍历它们。
- en: This is quite straightforward to implement. We will make a simple animation
    class that handles the function of keeping time and returning the appropriate
    part of the sprite sheet when requested. We can then initialize a new animation
    object for any `GameObject` that needs to be animated. In addition, when they
    are being drawn in the `draw` method of `PlatformView`, if the object is animated,
    we will handle it slightly differently.
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当简单易行。我们将创建一个简单的动画类，它处理计时功能，并在请求时返回精灵图集的适当部分。然后我们可以为任何需要动画的 `GameObject` 初始化一个新的动画对象。此外，当它们在
    `PlatformView` 的 `draw` 方法中被绘制时，如果对象是动画的，我们将对其进行稍微不同的处理。
- en: In this section, we will also see how to use the facing variable that tracks
    which way the player is facing. It will enable us to reverse the sprite sheet
    depending on the way the player (or any future animated objects) is headed.
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们还将看到如何使用跟踪玩家朝向的面向变量。它将使我们能够根据玩家的朝向反转精灵图集。
- en: Let's start by making the animation class. Create a new Java class and call
    it `Animation`. The code that follows soon will declare variables that hold the
    bitmap to be manipulated, the name of the bitmap, and a `rect` parameter to define
    the area of the sprite sheet that is the coordinates of the currently relevant
    frame of animation.
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建动画类开始。创建一个新的Java类，命名为`Animation`。接下来的代码将声明变量，这些变量将保存要操作的位图、位图的名称，以及一个`rect`参数来定义精灵图集中的区域，这是当前相关动画帧的坐标。
- en: In addition, we have `frameCount`, `currentFrame`, `frameTicker`, and `framePeriod`
    that hold and control the number of available frames, the current frame number,
    and the timing of the change of the frames. As you would expect, we also need
    to know the width and height of a frame of animation, these are held by `frameWidth`
    and `frameHeight`.
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还有`frameCount`、`currentFrame`、`frameTicker`和`framePeriod`，它们保存和控制可用帧的数量、当前帧号和帧变化的时机。正如你所期望的，我们还需要知道动画帧的宽度和高度，这些由`frameWidth`和`frameHeight`保存。
- en: Furthermore, the `Animation` class will regularly refer to the number of pixels
    per meter; therefore, it makes sense to hold this value in a member variable.
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`Animation`类将经常引用每米像素数；因此，将这个值保存在成员变量中是有意义的。
- en: 'Enter these member variables that we discussed in the `Animation` class:'
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Animation`类中输入我们讨论过的这些成员变量：
- en: '[PRE193]'
  id: totrans-1138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: Next, we have the constructor that prepares our animation object for use. We
    will see exactly how we prepare for the actual animation soon. Note that there
    are a fair few parameters in the signature indicating that the animation is quite
    configurable. Just note that FPS in this context is not referring to the frame
    rate of the game but the frame rate of the animation.
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有构造函数，它为我们的动画对象准备使用。我们很快就会看到我们是如何为实际动画做准备的。注意，签名中有相当多的参数，表明动画是相当可配置的。只需注意，这里的FPS不是指游戏的帧率，而是指动画的帧率。
- en: '[PRE194]'
  id: totrans-1140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: We can deal with the real functionality of the class. The `getCurrentFrame`
    method first checks to see if the object is moving or if it is capable of moving.
    At this stage, this may seem a little odd as this method will only ever be called
    by a `GameObject` class that is animated. The odd looking check, therefore, is
    determining if a new frame is required at the moment.
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以处理类的实际功能。`getCurrentFrame`方法首先检查对象是否在移动或是否能够移动。在这个阶段，这看起来可能有点奇怪，因为这个方法将只由一个动画的`GameObject`类调用。因此，看起来奇怪的检查是在确定是否需要新的帧。
- en: If an object moves, (such as Bob), but is standing still, then we don't need
    to change the frame of animation. However, if the animated object has no velocity
    ever, like a roaring fire, then we need to animate it all the time. It will never
    have any velocity so the `moves` variable will be `false`, but the method will
    proceed.
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个对象移动（例如鲍勃），但处于静止状态，那么我们不需要改变动画帧。然而，如果一个动画对象从未有过速度，比如咆哮的火焰，那么我们需要一直给它动画。它将永远不会有任何速度，所以`moves`变量将是`false`，但方法将继续进行。
- en: The method then uses `time`, `frameTicker` and `framePeriod`, to determine if
    it is time to show the next frame of animation and if it increments the frame
    number to display. Then, if the animation is on the last frame, it goes back to
    the first frame.
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法使用`time`、`frameTicker`和`framePeriod`来确定是否是显示下一个动画帧的时候，并且是否增加帧数以显示。然后，如果动画处于最后一帧，它将回到第一帧。
- en: Finally, the precise left and right-hand positions that represent the portion
    of the sprite sheet that contains the needed frame, are calculated and returned
    to the calling code.
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，计算并返回代表包含所需帧的精灵图集部分的精确左右位置，这些位置被返回给调用代码。
- en: '[PRE195]'
  id: totrans-1145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: Next, we can add some members to the `GameObject` class.
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以向`GameObject`类添加一些成员。
- en: '[PRE196]'
  id: totrans-1147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: Some methods to interact with our `Animation` class, which set and get variables,
    make the animation work and inform the `draw` method if the object is animated
    or not.
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: 一些与我们的`Animation`类交互的方法，设置和获取变量，使动画工作，并通知`draw`方法对象是否是动画的。
- en: '[PRE197]'
  id: totrans-1149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: Lastly in `GameObject`, there is a method which the objects that require animating
    can use to set up their whole animation object. Note it is this `setAnimated`
    method that calls `new()` on a new animation object.
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`GameObject`中，有一个方法，需要动画的对象可以使用它来设置整个动画对象。注意，是这个`setAnimated`方法在新的动画对象上调用`new()`。
- en: '[PRE198]'
  id: totrans-1151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: The next method acts as a go between for the `draw` method of the `PlatformView`
    class and the `getRectToDraw` method of the `Animation` class.
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法充当`PlatformView`类的`draw`方法和`Animation`类的`getRectToDraw`方法之间的中间件。
- en: '[PRE199]'
  id: totrans-1153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: 'Then, we need to update the `Player` class in order to initialize its animation
    object according to its own specific required number of frames and frames per
    second. The new code in the `Player` class is highlighted:'
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要更新`Player`类，以便根据其所需的特定帧数和每秒帧数初始化其动画对象。`Player`类中的新代码如下所示：
- en: '[PRE200]'
  id: totrans-1155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: We can use all this new code from the `draw` method to implement our animations.
    The next block of code checks if the current `GameObject` being drawn `isAnimated()`.
    If it is, it gets the appropriate rectangle from the sprite sheet using the `getNextRect()`
    method via the `GameObject` class's `getRectToDraw` method.
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`draw`方法中的所有这些新代码来实现我们的动画。下一块代码检查当前正在绘制的`GameObject`是否`isAnimated()`。如果是，它通过`GameObject`类的`getRectToDraw`方法使用`getNextRect()`方法从精灵图中获取适当的矩形。
- en: Note that, the next code listing from the `draw` method that made the original
    call to `drawBitmap()`, is now wrapped in an `else` clause at the end of the new
    code. Basically, the logic is this. If animated, execute the new code, otherwise
    just do it the usual way.
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，下一段代码是从`draw`方法中提取的，它最初调用了`drawBitmap()`，现在被包裹在新代码的末尾的`else`子句中。基本的逻辑是这样的。如果动画正在播放，则执行新代码，否则按常规方式执行。
- en: In addition to the animation code we know about, we also check `if(go.getFacing()
    == 1)` and use the `Matrix` class to flip the bitmap when required by scaling
    it by -1 on the *x* axis.
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们知道的动画代码外，我们还检查`if(go.getFacing() == 1)`，并使用`Matrix`类在需要时通过在*x*轴上按-1的比例缩放位图来翻转位图。
- en: 'Here is all the new code, including the original `drawBitmap()` call wrapped
    in an `else` clause at the end:'
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是所有新代码，包括原始的`drawBitmap()`调用，它被包裹在新代码末尾的`else`子句中：
- en: '[PRE201]'
  id: totrans-1160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: 'Now, you can run the game and see Bob in all his animated glory. The screenshot
    can''t show his movements, but you can see he is now perfectly formed:'
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以运行游戏，看到Bob所有的动画辉煌。截图无法显示他的动作，但你可以看到他现在完美成型：
- en: '![Animating Bob](img/B04322_06_06.jpg)'
  id: totrans-1162
  prefs: []
  type: TYPE_IMG
  zh: '![动画中的Bob](img/B04322_06_06.jpg)'
- en: Summary
  id: totrans-1163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Our game is steadily coming together. At this stage, we can build a huge level
    design in `LevelCave` and go running and jumping all over the place. However,
    we will save to postpone trying to make the game playable until we have added
    a load more neat features.
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏正在稳步推进。在这个阶段，我们可以在`LevelCave`中构建一个巨大的关卡设计，到处奔跑和跳跃。然而，我们将保存以推迟尝试使游戏可玩，直到我们添加更多整洁的功能。
- en: These neat features will include a machine gun, which can be upgraded through
    collectible pickups and some enemies that Bob can shoot at. We will get going
    with that in the next chapter.
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 这些整洁的功能将包括一挺机枪，它可以通过可收集的拾取物和一些Bob可以射击的敌人进行升级。我们将在下一章开始介绍这些内容。
- en: Chapter 7. Platformer – Guns, Life, Money, and the Enemy
  id: totrans-1166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 平台游戏 - 枪支、生命、金钱和敌人
- en: In this chapter, we will do many things. First, we will build a machine gun
    with a variable rate of fire and have it shoot bullets. Then, we will introduce
    pickups or collectibles. These give the player something to scavenge for while
    trying to escape into the next level.
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将做很多事情。首先，我们将构建一个具有可变射速的机枪，并让它射击子弹。然后，我们将介绍拾取物或可收集物品。这些物品在玩家试图逃入下一级时提供了一些搜寻的东西。
- en: Then, just as Bob was beginning to think that his life was a blissful one of
    grass and collectibles, we will build two adversaries for him to outsmart or kill.
    A homing drone and a patrolling guard. We will easily be able to add all these
    things into our level designs.
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，就在Bob开始认为他的生活是幸福的一生的草地和可收集物品时，我们将为他构建两个对手，让他智胜或杀死。一个归巢无人机和一个巡逻守卫。我们将很容易将这些事物添加到我们的关卡设计中。
- en: Ready aim fire
  id: totrans-1169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备瞄准射击
- en: Now, we can give our hero a gun, and later, we can give him enemies to shoot
    at. We will create a `MachineGun` class to do all the work and a `Bullet` class
    to represent the projectiles that it fires. The `Player` class will control the
    `MachineGun` class, and the `MachineGun` class will control and keep track of
    all the `Bullet` objects that it fires.
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以给我们的英雄配备一把枪，稍后，我们可以给他一些敌人来射击。我们将创建一个`MachineGun`类来完成所有工作，并创建一个`Bullet`类来表示它发射的弹丸。`Player`类将控制`MachineGun`类，而`MachineGun`类将控制并跟踪它发射的所有`Bullet`对象。
- en: Create a new Java class and call it `Bullet`. Bullets are not complicated. Ours
    will need a *x* and *y* location, a horizontal velocity, and a direction to help
    calculate the velocity.
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的Java类，命名为`Bullet`。子弹并不复杂。我们的子弹将需要一个*x*和*y*位置、一个水平速度和一个方向来帮助计算速度。
- en: 'This implies the following simple class, constructor, and a bunch of getters
    and setters:'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着以下简单的类、构造函数以及一大堆getter和setter方法：
- en: '[PRE202]'
  id: totrans-1173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: Now let's implement the `MachineGun` class.
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们实现`MachineGun`类。
- en: Create a new Java class and call it `MachineGun`. First, we add some members.
    The `maxBullets` variable is not the amount of shots a player has, that is unlimited,
    it is the number of bullet objects the `MachineGun` class can have. Ten is sufficient
    for a very fast firing gun, as we will see. The members `numBullets` and `nextBullet`
    help the class to keep track of its 10 bullets. The `rateOfFire` variable controls
    how fast the player will be able to tap the fire button, and `lastShotTime` will
    help enforce the `rateOfFire` by keeping track of the system time that the last
    bullet was fired. It is the rate of fire that will be the upgradeable aspect of
    the weapon.
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的Java类，命名为`MachineGun`。首先，我们添加一些成员。`maxBullets`变量不是玩家拥有的射击次数，那是无限的，它是`MachineGun`类可以拥有的子弹对象的数量。10个对于一把非常快速的射击枪来说是足够的，就像我们将会看到的那样。`numBullets`和`nextBullet`成员帮助类跟踪其10个子弹。`rateOfFire`变量控制玩家能够多快地按下射击按钮，而`lastShotTime`将帮助通过跟踪上次发射子弹的系统时间来强制执行`rateOfFire`。这将成为武器的可升级方面。
- en: Enter the code that we discussed as follows.
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 输入我们讨论的代码如下。
- en: '[PRE203]'
  id: totrans-1177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: Note
  id: totrans-1178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For functional purposes, we can think of the `CopyOnWriteArrayList` `bullets`,
    which stores our bullets, as a plain old `ArrayList` object. We use this more
    complex and slightly slower class because it is thread safe and bullets can be
    accessed potentially simultaneously from the UI thread, when the player taps the
    fire button as well as from our own thread. This article explains `CopyOnWriteArrayList`,
    if you want to know more, visit:'
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了功能上的考虑，我们可以将存储我们的子弹的`CopyOnWriteArrayList` `bullets`视为一个普通的`ArrayList`对象。我们使用这个更复杂且稍微慢一点的类，因为它线程安全，子弹可以从UI线程访问，当玩家按下射击按钮时，以及从我们的线程中访问。这篇文章解释了`CopyOnWriteArrayList`，如果你想了解更多，请访问：
- en: '[http://examples.javacodegeeks.com/java-basics/exceptions/java-util-concurrentmodificationexception-how-to-handle-concurrent-modification-exception/](http://examples.javacodegeeks.com/java-basics/exceptions/java-util-concurrentmodificationexception-how-to-handle-concurrent-modification-exception/)'
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://examples.javacodegeeks.com/java-basics/exceptions/java-util-concurrentmodificationexception-how-to-handle-concurrent-modification-exception/](http://examples.javacodegeeks.com/java-basics/exceptions/java-util-concurrentmodificationexception-how-to-handle-concurrent-modification-exception/)'
- en: 'We have the constructor that just initializes bullets, `lastShotTime`, and
    `nextBullet`:'
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个只初始化子弹、`lastShotTime`和`nextBullet`的构造函数：
- en: '[PRE204]'
  id: totrans-1182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: Here, we update all the `Bullet` objects controlled by the gun by calling the
    `bullet.update` method for each bullet.
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过调用每个子弹的`bullet.update`方法来更新枪控制的所有的`Bullet`对象。
- en: '[PRE205]'
  id: totrans-1184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: Next, we have some getters that will let us find out things about our gun and
    its bullets, to do things like collision detection, and drawing bullets.
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一些getter方法，将允许我们了解我们的枪及其子弹的信息，以便进行碰撞检测和绘制子弹。
- en: '[PRE206]'
  id: totrans-1186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: We also have a quick helper method for when we want to stop drawing a bullet.
    We hide it away until it is ready to be reassigned in our `shoot` method shortly.
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个快速的帮助方法，用于当我们想要停止绘制子弹时。我们将它隐藏起来，直到它准备好在`shoot`方法中重新分配。`shoot`方法中。
- en: '[PRE207]'
  id: totrans-1188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'A getter that returns the direction of travel:'
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: 一个getter方法，返回移动的方向：
- en: '[PRE208]'
  id: totrans-1190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: Now, we add a more comprehensive method that actually shoots a bullet. The method
    compares the time of the last fired shot against the current `rateOfFire`. It
    then proceeds to increment `nextBullet` and create a new `Bullet` object if permitted.
    The bullet is sent speeding off in the same direction as Bob is facing. Note that
    the method returns `true` if a bullet was successfully fired. This is so that
    the `InputController` class can play a sound effect to correspond with the player's
    button press.
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们添加一个更全面的方法，实际上发射子弹。该方法比较上次发射的射击时间与当前的`rateOfFire`。然后继续增加`nextBullet`并创建一个新的`Bullet`对象（如果允许的话）。子弹以与鲍勃面对的方向相同的速度飞出。注意，如果成功发射了子弹，该方法返回`true`。这样，`InputController`类就可以播放一个与玩家按钮按压相对应的声音效果。
- en: '[PRE209]'
  id: totrans-1192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: Finally, we have a method to call when the player finds a machine gun upgrade
    pickup. We will see more of them later in the chapter. Here, we simply increase
    `rateOfFire`, which enables the player to tap the fire button more furiously and
    still get results.
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当玩家找到机枪升级拾取物时，我们有一个可以调用的方法。我们将在本章后面看到更多。在这里，我们简单地增加`rateOfFire`，这使得玩家可以更猛烈地按下射击按钮，同时仍然得到结果。
- en: '[PRE210]'
  id: totrans-1194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: Now, we will modify the `Player` class to carry a `MachineGun`. Give `Player`
    a member variable that is a `MachineGun`.
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将修改`Player`类以携带`MachineGun`。给`Player`一个成员变量，它是一个`MachineGun`。
- en: '[PRE211]'
  id: totrans-1196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: 'Next in the `Player` constructor, add a line of code to initialize our new
    `MachineGun` object:'
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Player`构造函数中，添加一行代码来初始化我们新的`MachineGun`对象：
- en: '[PRE212]'
  id: totrans-1198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: 'In the `Player` class''s `update` method, add a call to the `MachineGun` class''s
    `update` method just before we call `move()` for the player. As highlighted next:'
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Player`类的`update`方法中，在调用玩家的`move()`之前，添加对`MachineGun`类`update`方法的调用。如下所示：
- en: '[PRE213]'
  id: totrans-1200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: Add a method to the `Player` class, so our `InputController` can access the
    virtual trigger. As we saw, the method returns `true` if a shot was successful
    so that the `InputController` class knows whether to play a shot sound or not.
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Player`类中添加一个方法，以便我们的`InputController`可以访问虚拟扳机。正如我们所见，如果射击成功，该方法返回`true`，这样`InputController`类就知道是否播放射击声音。
- en: '[PRE214]'
  id: totrans-1202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: 'Now, we can make some minor additions to our `InputController` class so that
    the player can fire a shot. The code to add is shown highlighted amongst the existing
    code:'
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以对我们的`InputController`类做一些小的添加，以便玩家可以射击。要添加的代码如下所示，突出显示在现有代码中：
- en: '[PRE215]'
  id: totrans-1204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: 'Not forgetting the way that our new control system works, we also need to add
    the same piece of extra code further down the `InputController` class in the `MotionEvent.ACTION_POINTER_DOWN`
    case as well. As usual, here is the code highlighted and with plenty of context:'
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记我们新的控制系统是如何工作的，我们还需要在`InputController`类的`MotionEvent.ACTION_POINTER_DOWN`情况中添加相同的额外代码。像往常一样，以下是突出显示的代码和丰富的上下文：
- en: '[PRE216]'
  id: totrans-1206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: Now we have a gun, it's loaded, and we know how to pull the trigger. We just
    need to draw the bullets.
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了枪，它已经上膛，我们也知道如何拉动扳机。我们只需要绘制子弹。
- en: 'Add the new code in the `draw` method, just before we draw the debugging text,
    as shown:'
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: 在`draw`方法中添加新代码，就在我们绘制调试文本之前，如下所示：
- en: '[PRE217]'
  id: totrans-1209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: We will now fire some bullets. Note that the rate of fire is unsatisfying and
    slow. We will add some pickups, which the player can get to increase the rate
    of fire of his gun.
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将发射一些子弹。请注意，射速令人不满意且缓慢。我们将添加一些拾取物，玩家可以通过它们来增加枪的射速。
- en: Pickups
  id: totrans-1211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拾取物
- en: Pickups are game objects that can be collected by the player. They include things
    like upgrades, extra lives, money, and so on. We will now implement one of each
    of those collectibles. As our game engine is setup the way it is, this will be
    surprisingly easy.
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 拾取物是可以被玩家收集的游戏对象。它们包括升级、额外生命、金钱等等。我们现在将实现这些可收集物品中的每一个。由于我们的游戏引擎设置得如此，这将出人意料地简单。
- en: The first thing we will do is create a class to hold the state of the current
    player. We want to monitor the money collected, power of machine gun, and lives
    remaining. Let's call it `PlayerState`. Create a new Java class and name it `PlayerState`.
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是创建一个类来保存当前玩家的状态。我们想要监控收集到的金钱、机枪的威力以及剩余的生命值。让我们称它为`PlayerState`。创建一个新的Java类，并将其命名为`PlayerState`。
- en: 'In addition to the variables, we have just talked about, we also want the `PlayerState`
    class to remember an *x* and *y* location to respawn at, when the player loses
    a life. Enter these member variables and the simple constructor:'
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们刚才提到的变量之外，我们还想让`PlayerState`类记住一个*x*和*y*位置，当玩家失去生命时可以重生。输入这些成员变量和简单的构造函数：
- en: '[PRE218]'
  id: totrans-1215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: 'Now, we need a method that we can call to initialize the respawn location.
    We will use this later when we call this method. Also, we need a method to reload
    the location. These are our next two methods for the `PlayerState` class:'
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一个我们可以调用的方法来初始化重生位置。我们将在稍后调用此方法时使用它。此外，我们还需要一个方法来重新加载位置。这是`PlayerState`类的下两个方法：
- en: '[PRE219]'
  id: totrans-1217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: 'We just need a whole bunch of getters and setters to give us access to the
    members of this class:'
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要一整套getter和setter来让我们访问这个类的成员：
- en: '[PRE220]'
  id: totrans-1219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: 'Next, declare an object of the `PlayerState` type as a member of the `PlatformView`
    class:'
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，声明一个`PlayerState`类型的对象，作为`PlatformView`类的成员：
- en: '[PRE221]'
  id: totrans-1221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: 'Initialize it in the `PlatformView` constructor:'
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PlatformView`构造函数中初始化它：
- en: '[PRE222]'
  id: totrans-1223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: Now in the `loadLevel` method, create a `RectF` object, store the players starting
    location, and pass it in to the `PlayerState` object, `ps`, for safe keeping.
    Each time the player dies, he can be respawned using this location.
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`loadLevel`方法中，创建一个`RectF`对象，存储玩家的起始位置，并将其传递给`PlayerState`对象`ps`以安全保存。每次玩家死亡时，都可以使用此位置重新生成。
- en: '[PRE223]'
  id: totrans-1225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: 'Now we will create three classes, one for each of our pickups. These classes
    are very simple. They extend `GameObject`, set a bitmap, have a hitbox, and a
    location in the world. Also note that they all receive a type in the constructor
    and use `setType()` to store this value. We will soon see how to use their type
    to handle what happens when the player "picks them up". Create three new Java
    classes: `Coin`, `ExtraLife`, and `MachineGunUpgrade`. Note that the pickups are
    a little smaller than a platform, perhaps as we may expect. Enter the code for
    each of them in turn.'
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建三个类，每个类对应我们的一个拾取物。这些类非常简单。它们扩展了`GameObject`，设置一个位图，有一个碰撞框和一个世界中的位置。此外，请注意，它们都在构造函数中接收一个类型，并使用`setType()`来存储这个值。我们将很快看到如何使用它们的类型来处理玩家“拾取”它们时发生的情况。创建三个新的Java类：`Coin`、`ExtraLife`和`MachineGunUpgrade`。注意，拾取物比平台小一点，也许正如我们预期的那样。依次输入它们的代码。
- en: 'The following is the code for `Coin`:'
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`Coin`的代码：
- en: '[PRE224]'
  id: totrans-1228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: 'Now, for `ExtraLife`:'
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于`ExtraLife`：
- en: '[PRE225]'
  id: totrans-1230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: 'Finally, the `MachineGunUpgrade` class:'
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是`MachineGunUpgrade`类：
- en: '[PRE226]'
  id: totrans-1232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: 'Now, update the `LevelManager` class to expect these three new objects in our
    level designs and add them to `ArrayList` of `GameObjects`. To do this, we need
    to update the `LevelManager` class in three places: `getBitmap()`, `getBitmapIndex()`,
    and `loadMapData()`. Here are each of these minor updates, with the new code highlighted
    amongst the existing code.'
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，更新`LevelManager`类以期望我们在关卡设计中使用这三个新对象，并将它们添加到`GameObjects`的`ArrayList`中。为此，我们需要在三个地方更新`LevelManager`类：`getBitmap()`、`getBitmapIndex()`和`loadMapData()`。以下是每个这些小的更新，新代码在现有代码中突出显示。
- en: 'Make the following additions to `getBitmap()`:'
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: 在`getBitmap()`中添加以下内容：
- en: '[PRE227]'
  id: totrans-1235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: 'Make identical additions, but this time to `getBitmapIndex()`:'
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 添加相同的添加，但这次是到`getBitmapIndex()`：
- en: '[PRE228]'
  id: totrans-1237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: 'Make the final changes within `LevelManager` with the following additions to
    `loadMapData()`:'
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: 在`LevelManager`中做出最终更改，通过以下对`loadMapData()`的添加来实现：
- en: '[PRE229]'
  id: totrans-1239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: Now, we can add the three appropriately named graphics to the drawable folder
    and start adding them to our `LevelCave` design. Go ahead and copy `clip.png`,
    `coin.png`, and `life.png` from the `Chapter7/drawables` folder in the download
    bundle to the `drawable` folder of your Android Studio project.
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将三个适当命名的图形添加到drawable文件夹中，并开始将它们添加到我们的`LevelCave`设计中。请将`clip.png`、`coin.png`和`life.png`从下载包中的`Chapter7/drawables`文件夹复制到Android
    Studio项目的`drawable`文件夹中。
- en: 'Add a handy list of comments that identify all the types of game object. We
    will add these over the course of this project and the alpha-numeric code that
    will represent them on our level designs. Add the following comments to the `LevelData`
    class:'
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个方便的注释列表，标识所有游戏对象类型。我们将在整个项目中添加这些注释，以及将代表它们在我们关卡设计中的字母数字代码。将以下注释添加到`LevelData`类中：
- en: '[PRE230]'
  id: totrans-1242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: 'Before we enhance our `LevelCave` class to use our new objects, we want to
    detect when the player collects them or collides with them and take appropriate
    action. We will first add a quick helper method to the `Player` class. The reason
    for this is because when the player collides with another object, the default
    action in the `Player` class''s `checkCollisions` method is to stop the character
    moving. We don''t want this to happen for pickups because it will be irritating
    for the player. Therefore, we will quickly add a `restorePreviousVelocity` method
    to the `Player` class that we can call whenever we don''t want this default action
    to occur. Add this method to the `Player` class:'
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们增强`LevelCave`类以使用我们的新对象之前，我们希望检测玩家收集它们或与它们碰撞，并采取适当的行动。我们将首先向`Player`类添加一个快速的帮助方法。这样做的原因是因为当玩家与另一个对象碰撞时，`Player`类中的`checkCollisions`方法的默认操作是停止角色移动。我们不希望这种情况发生在拾取物上，因为这会对玩家造成困扰。因此，我们将快速向`Player`类添加一个`restorePreviousVelocity`方法，我们可以在不需要此默认操作时调用它。将此方法添加到`Player`类中：
- en: '[PRE231]'
  id: totrans-1244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: 'Now, we can handle the collisions for each of our pickups in turn. Add these
    cases to handle our three pickups within the switch block that handles our collisions
    in the `update` method of the `PlatformView` class:'
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以依次处理我们每个拾取物的碰撞。将这些情况添加到处理`PlatformView`类中的`update`方法碰撞的switch块中，以处理我们的三个拾取物：
- en: '[PRE232]'
  id: totrans-1246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: Finally, add the new objects to our `LevelCave` class.
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将新对象添加到我们的`LevelCave`类中。
- en: Tip
  id: totrans-1248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The following code snippet, I suggest, is for a simple new layout that demonstrates
    our new objects, but your layout can be as big or elaborate as you like. We will
    do something more elaborate in the next chapter when we design and link some levels.
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议以下代码片段是一个简单的布局，用于演示我们的新对象，但你的布局可以像你喜欢的任何大小或复杂程度。我们将在下一章设计并链接一些关卡时做些更复杂的事情。
- en: 'Enter the following code into `LevelCave` or elaborate with your own design:'
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码输入到`LevelCave`或使用你自己的设计进行扩展：
- en: '[PRE233]'
  id: totrans-1251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: 'This is what the simple layout will look like:'
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: 简单布局将看起来像这样：
- en: '![Pickups](img/B04322_07_01.jpg)'
  id: totrans-1253
  prefs: []
  type: TYPE_IMG
  zh: '![拾取物](img/B04322_07_01.jpg)'
- en: Try collecting the pickups, and you will hear the pleasing sound effects. In
    addition, each time we collect a pickup, the `PlayerState` class stores an update.
    This will be useful when we build a HUD in the next chapter. Most fun of all;
    if you collect the machine gun upgrades, then try shooting your gun, you will
    find it much more satisfying to wield.
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试收集拾取物，你会听到令人愉悦的声音效果。此外，每次我们收集一个拾取物，`PlayerState`类都会存储一个更新。这将在我们下一章构建HUD时很有用。最有趣的是；如果你收集了机枪升级，然后尝试射击你的枪，你会发现它更加令人满意。
- en: We better make those bullets do something. However, before we do that, let's
    give the player a bit more cannon fodder in the form of a couple of enemies.
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最好让那些子弹做些事情。然而，在我们这样做之前，让我们给玩家提供一些额外的炮弹作为几个敌人的形式。
- en: The drone
  id: totrans-1256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无人机
- en: The drone is a simple but evil enemy. It will detect the player when it is within
    the viewport and fly straight at him. If the drone touches the player, death is
    immediate.
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: 无人机是一个简单但邪恶的敌人。当它在视图中检测到玩家时，它会直飞向玩家。如果无人机接触到玩家，玩家将立即死亡。
- en: Let's build a `Drone` class. Create a new Java class and call it `Drone`. We
    need member variables to remember when we set the last waypoint. This will restrict
    the frequency with which the drone will get a navigation update of Bob's coordinates.
    This stops the drone from being too deadly accurate. It needs a waypoint/target
    coordinate and also needs to know the speed limit via `MAX_X_VELOCITY` and `MAX_Y_VELOCITY`.
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个`Drone`类。创建一个新的Java类，命名为`Drone`。我们需要成员变量来记住我们上次设置航点的时刻。这将限制无人机获取鲍勃坐标导航更新的频率。这将阻止无人机过于精确。它需要一个航点/目标坐标，并且还需要通过`MAX_X_VELOCITY`和`MAX_Y_VELOCITY`知道速度限制。
- en: '[PRE234]'
  id: totrans-1259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: Now in the `Drone` constructor, initialize the usual `GameObject` members and
    specifically, the `Drone` class ones such as `currentWaypoint`. Not forgetting,
    that if we are going to shoot the drone, it will need a hitbox and we call `setRectHitBox()`
    after we have called `setWorldLocation()`.
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`Drone`构造函数中，初始化通常的`GameObject`成员，特别是`Drone`类的一些成员，如`currentWaypoint`。不要忘记，如果我们打算射击无人机，它将需要一个碰撞框，我们在调用`setWorldLocation()`之后调用`setRectHitBox()`。
- en: '[PRE235]'
  id: totrans-1261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: Here is the implementation of the `update` method, which compares the drone's
    coordinates with its `currentWaypoint` variable and changes its velocity accordingly.
    Then, we end `update()` by calling `move()` then `setRectHitbox()`.
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`update`方法的实现，该方法比较无人机的坐标与其`currentWaypoint`变量，并相应地改变其速度。然后，我们通过调用`move()`然后`setRectHitbox()`来结束`update()`方法。
- en: '[PRE236]'
  id: totrans-1263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: In our last method for the `Drone` class, update the `currentWaypoint` variable
    by passing in Bob's coordinates as a parameter. Note that we check if enough time
    has elapsed for an update to make sure our drone is not too accurate.
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Drone`类的最后一个方法中，通过传递鲍勃的坐标作为参数来更新`currentWaypoint`变量。注意，我们检查是否已经过去了足够的时间以便进行更新，以确保我们的无人机不会过于精确。
- en: '[PRE237]'
  id: totrans-1265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: Add the drone graphic `drone.png` from `Chapter7/drawable` into the `drawable`
    folder of your project.
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Chapter7/drawable`中的无人机图形`drone.png`添加到你的项目中的`drawable`文件夹。
- en: We then need to add drones to our `LevelManager` class in the usual three places,
    just as we did for each of our pickups. Now, add code to `getBitmap()`, `getBitmapIndex()`,
    and `loadMapData()`. These are the three minor code additions in order.
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要在`LevelManager`类中的通常三个地方添加无人机，就像我们对每个拾取物所做的那样。现在，向`getBitmap()`、`getBitmapIndex()`和`loadMapData()`添加代码。这些是按照顺序的三个小的代码添加。
- en: 'Add the highlighted code in the `getBitmap` method:'
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: 在`getBitmap`方法中添加高亮代码：
- en: '[PRE238]'
  id: totrans-1269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: 'Add the highlighted code in the `getBitmapIndex` method:'
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: 在`getBitmapIndex`方法中添加高亮代码：
- en: '[PRE239]'
  id: totrans-1271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: 'Add the highlighted code in the `loadMapData` method:'
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: 在`loadMapData`方法中添加高亮代码：
- en: '[PRE240]'
  id: totrans-1273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: The burning question is; how does the drone know where to go? In each frame,
    if there is a drone within the viewport, we can send the coordinates of the player.
    Do what is shown in this next code block within the `update` method of the `PlatformView`
    class.
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: 燃烧的问题是如何让无人机知道去哪里？在每一帧，如果视图中有一个无人机，我们可以发送玩家的坐标。在`PlatformView`类的`update`方法中执行以下代码块中所示的操作。
- en: As usual, the new code is shown highlighted and in the context of the existing
    code. If you remember the `setWaypoint()` code from the `Drone` class, it only
    accepts updates every 2 seconds. This stops the drone from being too accurate.
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，新代码会以高亮和现有代码的上下文显示。如果你还记得`Drone`类中的`setWaypoint()`代码，它每2秒只接受更新。这阻止了无人机过于精确。
- en: '[PRE241]'
  id: totrans-1276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: 'Now, these evil drones can be strategically placed around the level, and they
    will home in on the player. The last thing we need to do to make the drones fully
    operational is to detect when they actually collide with the player. This is nice
    and easy. Just add a case for drones in our collision detection `switch` block
    in the `update` method of the `PlatformView` class:'
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这些邪恶的无人机可以被战略性地放置在关卡周围，它们会锁定玩家。为了让无人机完全投入使用，我们最后需要做的是检测它们实际撞击玩家的时刻。这很简单。只需在`PlatformView`类的`update`方法中为无人机添加一个`switch`块中的情况：
- en: '[PRE242]'
  id: totrans-1278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: Go ahead and add a whole bunch of drones to `LevelCave` and watch them fly at
    the player. Note that if a drone catches the player, he dies and respawns.
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: 将一大群无人机添加到`LevelCave`中，并观察它们飞向玩家。注意，如果无人机抓住玩家，玩家就会死亡并重生。
- en: '![The drone](img/B04322_07_02.jpg)'
  id: totrans-1280
  prefs: []
  type: TYPE_IMG
  zh: '![无人机](img/B04322_07_02.jpg)'
- en: Now, as if the world wasn't a dangerous enough place with all those enemy drones,
    let's add another type of enemy.
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，好像这个世界还不够危险，有那么多敌对无人机，让我们再添加一种敌人类型。
- en: The guard
  id: totrans-1282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 守卫
- en: The guard enemy will be an exercise in scripting. We will have our `LevelManager`
    class automatically generate a simple script, which generates a route for our
    guard to patrol.
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: 守卫敌人将是脚本练习的一部分。我们将让`LevelManager`类自动生成一个简单的脚本，为我们的守卫生成巡逻路线。
- en: The route will be the simplest one possible; it will be just two waypoints that
    the guard will walk between continuously. It will be much quicker and simpler
    to preprogram our guards with two predetermined waypoints. However, by taking
    the time to have it automatically generated, we can place guards wherever we like
    (within certain parameters) on any level we design, and the behavior will be taken
    care of for us.
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: 路线将是可能的最简单路线；它将只是守卫之间连续行走的两个航点。通过预先编程我们的守卫为两个预定的航点，这将更快、更简单。然而，通过花时间自动生成它，我们可以在我们设计的任何关卡中（在一定的参数内）放置守卫，并且行为将由我们处理。
- en: Our guard will be animated, so we will be using a sprite sheet and configuring
    the animation details in the constructor; just as we did for the `Player` class.
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的守卫将会动画化，所以我们将使用精灵图集，并在构造函数中配置动画细节；就像我们对`Player`类所做的那样。
- en: 'Create a new class and call it `Guard`. First, handle the member variables.
    Our `Guard` class will not only need two waypoints, but also a variable to indicate
    which one the current waypoint is. Like other moving objects, it will need velocity.
    Here is the class declaration and member variables to start coding your class:'
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的类，命名为`Guard`。首先，处理成员变量。我们的`Guard`类不仅需要两个航点，还需要一个变量来指示当前航点是哪一个。像其他移动对象一样，它还需要速度。以下是类声明和成员变量，以开始编写你的类：
- en: '[PRE243]'
  id: totrans-1287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: We need to set up our guards via the constructor. First, setup our animation
    variables, bitmap, and sizes. Then as usual, set the guard's position in the level,
    its hitbox, and the way that it is facing. However, in the last line of the constructor
    we set `currentWaypoint` to `1`; this is new. We will see how this informs our
    guard's behavior in this class's `update` method.
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要通过构造函数设置我们的守卫。首先，设置动画变量、位图和大小。然后，像往常一样，设置守卫在关卡中的位置、击中框和它面对的方式。然而，在构造函数的最后一行，我们将`currentWaypoint`设置为`1`；这是新的。我们将在本类的`update`方法中看到这是如何影响守卫行为的。
- en: '[PRE244]'
  id: totrans-1289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: 'Next, add a method that our `LevelManager` class will use to let the `Guard`
    class know what its two waypoints are:'
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加一个方法，我们的`LevelManager`类将使用它来让`Guard`类知道它的两个航点：
- en: '[PRE245]'
  id: totrans-1291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: Now, we will code the "brains" of our `Guard` class, that is, its `update` method.
    You can basically break this method into two main parts. First, `if(currentWaypoint
    == 1)` and secondly, `if(currentWaypoint == 2)`. Inside each of these `if` blocks,
    simply check if the guard has reached or passed the appropriate waypoint. If it
    has, switch waypoints, reverse the velocity, and make the guard face the other
    way.
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写`Guard`类的“大脑”，即其`update`方法。基本上，你可以把这个方法分成两个主要部分。首先，`if(currentWaypoint
    == 1)`，其次，`if(currentWaypoint == 2)`。在每个`if`块内部，简单地检查护甲是否到达或超过了适当的巡逻点。如果是，则切换巡逻点，反转速度，并让护甲朝相反方向前进。
- en: Finally, call `move()` then `setRectHitbox()` to update the hitbox to the new
    location of the guard. Add the code for the `update` method and then we will see
    how to put it to work.
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，调用`move()`然后`setRectHitbox()`来更新护甲到护甲的新位置。添加`update`方法的代码，然后我们将看到如何将其投入使用。
- en: '[PRE246]'
  id: totrans-1294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: Remember to add `guard.png` from the `Chapter7/drawables` folder of the download
    bundle to the `drawable` folder of the project.
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: 记得将下载包的`Chapter7/drawables`文件夹中的`guard.png`添加到项目的`drawable`文件夹中。
- en: Now, we can make the usual three additions to the `LevelManager` class to load
    any guards that may be found in our level designs.
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以向`LevelManager`类添加通常的三个新增功能，以加载我们可能在我们级别设计中找到的所有护甲。
- en: 'In `getBitmap()`, add the highlighted code:'
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: 在`getBitmap()`中，添加以下高亮代码：
- en: '[PRE247]'
  id: totrans-1298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: 'In `getBitmapIndex()`, add the highlighted code:'
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: 在`getBitmapIndex()`中，添加以下高亮代码：
- en: '[PRE248]'
  id: totrans-1300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: 'In `loadMapData()`, add the highlighted code:'
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: 在`loadMapData()`中，添加以下高亮代码：
- en: '[PRE249]'
  id: totrans-1302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: We will soon add something totally new to `LevelManager`. That is a method that
    will create the script (set two waypoints to patrol). For this new method to work,
    it needs to know if the tile is suitable for walking on. We will add a new property,
    a getter, and a setter to `GameObject` so that this is easily discoverable.
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快将为`LevelManager`添加一些全新的内容。这是一个创建脚本（设置两个巡逻点）的方法。为了使这个新方法能够工作，它需要知道这个地砖是否适合行走。我们将为`GameObject`添加一个新的属性、一个获取器和设置器，以便这个功能可以轻松被发现。
- en: 'Add this new member to the `GameObject` class right after the class declaration:'
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: 在类声明之后立即将这个新成员添加到`GameObject`类中：
- en: '[PRE250]'
  id: totrans-1305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: 'Add these two methods to the `GameObject` class to get and set this variable:'
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: 将这两个方法添加到`GameObject`类中，以获取和设置这个变量：
- en: '[PRE251]'
  id: totrans-1307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: 'Now in the `Grass` class constructor, add a call to `setTraversable()`. We
    must remember to do this for all future `GameObject` derived classes that we design,
    if we want our guards to be able to patrol on them. In `Grass`, add this line
    at the top of the constructor:'
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`Grass`类的构造函数中，添加对`setTraversable()`的调用。我们必须记住，如果我们想让我们的护甲能够在它们上面巡逻，我们必须为所有未来设计的`GameObject`派生类都这样做。在`Grass`中，在构造函数顶部添加此行：
- en: '[PRE252]'
  id: totrans-1309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: Next, we will look at the new `setWaypoints` method for our `LevelManager` class.
    It needs to examine the level design and calculate two waypoints for any `Guard`
    objects present in that level.
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看`LevelManager`类的新`setWaypoints`方法。它需要检查级别设计，并为该级别中存在的任何`Guard`对象计算两个巡逻点。
- en: We will break this method into a few parts, so we can see what's happening at
    each stage.
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个方法分成几个部分，这样我们就可以看到每个阶段的操作。
- en: First, we need to loop through all the `gameObjects` classes looking for the
    `Guard` objects.
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要遍历所有的`gameObjects`类，寻找`Guard`对象。
- en: '[PRE253]'
  id: totrans-1313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: If we reach this point in the code, it means we have found a guard who will
    need two waypoints to be set. First, we need to find the tile which the guard
    is "standing on". Then, we calculate the coordinate of the last traversable tile
    on either side, but with a maximum range of five tiles each way. These will be
    the two waypoints. Here, is the code to add to the `setWaypoints` method. It is
    heavily commented to make clear what is going on without interrupting the flow
    by stopping to talk about it.
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们到达代码的这个点，这意味着我们已经找到了一个需要设置两个巡逻点的护甲。首先，我们需要找到护甲“站立”的地砖。然后，我们计算两侧最后一个可穿越地砖的坐标，但每侧的最大范围是五个地砖。这些将是两个巡逻点。以下是添加到`setWaypoints`方法的代码。代码中包含大量注释，以在不打断流程的情况下清楚地说明正在发生的事情。
- en: '[PRE254]'
  id: totrans-1315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: 'Now, we can call our new `setWaypoints` method as the last thing to do in the
    `LevelManager` constructor. We need to call this method after the `GameObject`
    class''s `ArrayList` has been populated or there will be no guards in it. Add
    the call to `setWaypoints()` as highlighted:'
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在`LevelManager`构造函数的最后调用我们的新`setWaypoints`方法。我们需要在`GameObject`类的`ArrayList`被填充之后调用此方法，否则其中将没有护甲。添加对`setWaypoints()`的调用，如下所示：
- en: '[PRE255]'
  id: totrans-1317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: Next, add this code to the collision detection switch block in the `update`
    method of the `PlatformView` class, so we can bump into the guards.
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将此代码添加到`PlatformView`类的`update`方法中的碰撞检测开关块中，这样我们就可以撞到守卫了。
- en: '[PRE256]'
  id: totrans-1319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: 'Finally, add some `g` letters to the `LevelCave` class. Make sure to place
    them with one space above the platform, because they are 2 meters high as in this
    pseudo code:'
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，向`LevelCave`类添加一些`g`字母。确保将它们放置在平台上方一个空格处，因为它们的高度是2米，就像这个伪代码中一样：
- en: '[PRE257]'
  id: totrans-1321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '![The guard](img/B04322_07_03.jpg)'
  id: totrans-1322
  prefs: []
  type: TYPE_IMG
  zh: '![守卫](img/B04322_07_03.jpg)'
- en: Summary
  id: totrans-1323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: We implemented guns, pickups, drones, and guards. This means we now have plenty
    of dangers, but have a machine gun that can't do any damage. We will change that
    first thing in the next chapter, by implementing collision detection for our bullets.
    However, we will go slightly further than merely having them hit our enemies.
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了枪械、拾取物、无人机和守卫。这意味着我们现在有很多危险，但我们有一把不能造成任何伤害的机关枪。我们将在下一章首先改变这一点，通过实现子弹的碰撞检测。然而，我们将做得比仅仅让它们击中敌人更进一步。
- en: Chapter 8. Platformer – Putting It All Together
  id: totrans-1325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。平台游戏 – 整合一切
- en: Finally, we will make the bullets do some damage. The ricochet sound is very
    satisfying when the bullets energy is absorbed by a clump of grass. We will add
    an abundance of new platform types and inanimate scenery objects to make our levels
    more interesting. We will provide a real sense of motion and immersion by implementing
    multiple scrolling parallax backgrounds.
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将让子弹造成一些伤害。当子弹的能量被一团草吸收时，回弹声音非常令人满意。我们将添加大量新的平台类型和静态场景对象，使我们的关卡更有趣。我们将通过实现多个滚动透视背景来提供真实的运动和沉浸感。
- en: We will also add an animated fire tile for the player to avoid, and in addition,
    a special `Teleport` class to link levels together into one playable game. Then,
    we will use all of our game objects and backgrounds to create four, linked, and
    fully playable levels.
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将为玩家添加一个需要躲避的动画火焰砖块，以及一个特殊的`Teleport`类，用于将关卡链接成一个可玩的游戏。然后，我们将使用所有的游戏对象和背景来创建四个，链接的，并且完全可玩的游戏关卡。
- en: Then, we will add a HUD to keep track of pickups and lives. Finally, we will
    discuss some of the neat things that couldn't be fitted into this project in just
    four chapters.
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将添加一个HUD来跟踪拾取物和生命值。最后，我们将讨论一些在这个项目中仅用四章无法涵盖的有趣事物。
- en: Bullet collision detection
  id: totrans-1329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子弹碰撞检测
- en: Detecting bullet collisions is fairly straightforward. We loop through all the
    existing `Bullet` objects held by our `MachineGun` object. Next, we convert the
    points of each bullet into a `RectHitBox` object and test it using `intersects()`
    against each object in our viewport.
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: 检测子弹碰撞相当直接。我们遍历我们的`MachineGun`对象持有的所有现有`Bullet`对象。接下来，我们将每个子弹的点转换为`RectHitBox`对象，并使用`intersects()`方法与视口中的每个对象进行测试。
- en: If we get a hit, we check to see what type of object it has hit. We then switch
    to handle each type of object that we care about. If it is a `Guard` object, we
    knock it back a bit, if it is a `Drone` object, we destroy it, and if it is anything
    else, we just make the bullet disappear and play a kind of thudding/ricochet sound.
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们被击中，我们会检查它击中了什么类型的对象。然后，我们切换到处理我们关心的每种类型的对象。如果是`Guard`对象，我们会将其击退一点，如果是`Drone`对象，我们会将其摧毁，如果是其他任何东西，我们只需让子弹消失并播放一种沉闷/回弹声音。
- en: 'We simply place this logic we discussed after our `switch` block that handles
    collisions with the player, but before, we call `update()` on all our unclipped
    objects as shown next:'
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是将我们讨论的逻辑放置在我们处理玩家碰撞的`switch`块之后，但在那之前，我们会在所有未剪辑的对象上调用`update()`，如下所示：
- en: '[PRE258]'
  id: totrans-1333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: Try it out, it is really satisfying, especially with a high rate of fire.
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下，这真的很令人满意，尤其是在高射速的情况下。
- en: Adding some fire tiles
  id: totrans-1335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一些火焰砖块
- en: These new `GameObject` derived objects will mean instant death to Bob. They
    won't move, but they will be animated. We will see we can achieve this just by
    setting the already existing properties of `GameObject`.
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: 这些新的`GameObject`派生对象将意味着鲍勃会立即死亡。它们不会移动，但会进行动画。我们将看到我们只需设置`GameObject`已经存在的属性就能实现这一点。
- en: Adding this feature into our game is simple because we have already implemented
    all the features we need. We already have a way to locate and add new tiles, a
    way to detect and respond to a collision, sprite sheet animation, and so on. Let's
    do it step-by-step, then we can add these dangerous and life-threatening elements
    into our world.
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: 将此功能添加到我们的游戏中很简单，因为我们已经实现了我们需要的所有功能。我们已经有了一种定位和添加新砖块的方法，一种检测和响应碰撞的方法，精灵表动画，等等。让我们一步一步来做，然后我们可以将这些危险和生命威胁元素添加到我们的世界中。
- en: We can put the entire functionality of the class into its constructor. All we
    do is configure the object much like we did our `Grass` object, but in addition,
    we configure it with all the animation settings, like we did to the `Player` and
    `Guard` objects. The `fire.png` sprite sheet has three frames of animation that
    we want to play over the course of one second.
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将类的整个功能放入其构造函数中。我们所做的只是配置对象，就像我们配置我们的`Grass`对象一样，但除此之外，我们还要配置所有动画设置，就像我们对`Player`和`Guard`对象所做的那样。`fire.png`精灵图集有3帧动画，我们希望在一秒钟内播放。
- en: '![Adding some fire tiles](img/B04322_08_01.jpg)'
  id: totrans-1339
  prefs: []
  type: TYPE_IMG
  zh: '![添加一些火焰瓦片](img/B04322_08_01.jpg)'
- en: 'Create a new class, call it `Fire`, and add the following code to it:'
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的类，命名为`Fire`，并向其中添加以下代码：
- en: '[PRE259]'
  id: totrans-1341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: Now, of course, we need to add the `fire.png` sprite sheet from `Chapter8/drawable`
    in the download bundle to the `drawable` folder of the project.
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，现在我们需要将下载包中的`Chapter8/drawable`文件夹中的`fire.png`精灵图集添加到项目的`drawable`文件夹中。
- en: Then, we add to our `LevelManager` class, in the usual three ways that we have
    done for all our new `GameObject` derived classes.
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将向我们的`LevelManager`类添加内容，就像我们为所有新的`GameObject`派生类所做的那样，通常有三种方式。
- en: 'In the `getBitmap` method, add the highlighted code:'
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: 在`getBitmap`方法中，添加以下高亮代码：
- en: '[PRE260]'
  id: totrans-1345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: 'In the `getBitmapIndex` method:'
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: 在`getBitmapIndex`方法中：
- en: '[PRE261]'
  id: totrans-1347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: 'In the `loadMapData()` method:'
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: 在`loadMapData()`方法中：
- en: '[PRE262]'
  id: totrans-1349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: Finally, we add to our collision detection `switch` block to handle the consequences
    of touching this terrible tile.
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在碰撞检测的`switch`块中添加内容，以处理接触这个糟糕瓦片的后果。
- en: '[PRE263]'
  id: totrans-1351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: Why not add a few `f` tiles to `LevelCave` and experiment with what the player
    is able to jump over. It will help us design some challenging levels later in
    the chapter.
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不在`LevelCave`中添加几个`f`瓦片并实验玩家能够跳过的内容。这有助于我们在本章后面设计一些具有挑战性的关卡。
- en: '![Adding some fire tiles](img/B04322_08_02.jpg)'
  id: totrans-1353
  prefs: []
  type: TYPE_IMG
  zh: '![添加一些火焰瓦片](img/B04322_08_02.jpg)'
- en: We don't want our player to be walking on the grass the whole time, so let's
    add some more variety.
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望我们的玩家整段时间都在草地上行走，所以让我们添加一些更多的变化。
- en: Eye candy
  id: totrans-1355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 眼睛的甜点
- en: The next three sections in this chapter will be purely aesthetic. We will add
    a whole bunch of different tile graphics with matching classes so that we can
    use a whole lot more artistic license to make our levels more interesting. The
    difference between the tiles will be purely visual, but it will be fairly simple
    to make them more functional than that.
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: 本章接下来的三个部分将纯粹是美学上的。我们将添加一大堆不同的瓦片图形以及相应的类，这样我们就可以使用更多的艺术许可来使我们的关卡更有趣。瓦片之间的区别将是纯粹视觉上的，但将它们做得比这更有功能性将相对简单。
- en: For example, we can easily detect collision with a snow tile and have the player
    keep moving briefly after stopping to simulate skidding, or perhaps; the concrete
    tile can allow the player to move faster and therefore change the way we design
    big jumps and so on. The point is that you don't have to just copy paste the classes
    as they will be presented here.
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以轻松地检测与雪瓦片的碰撞，并在停止后让玩家短暂移动以模拟打滑，或者也许；混凝土瓦片可以让玩家移动得更快，从而改变我们设计大跳跃的方式等等。关键是，你不必像这里展示的那样直接复制粘贴类。
- en: 'We will also add some completely aesthetic props: mine carts, boulders, stalactites,
    and more. There will be no collision detection for these objects. They will allow
    the level designer to make the levels more visually interesting.'
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加一些完全具有美感的道具：矿车、巨石、钟乳石等等。这些物体将不会有碰撞检测。这将允许关卡设计师使关卡更加视觉上吸引人。
- en: Tip
  id: totrans-1359
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It would be simple to make these aesthetics more functional. Just add a hitbox
    and a case in the collision detection switch block to handle the consequences.
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这些美学元素更具有功能性，只需在碰撞检测的`switch`块中添加一个击中框和情况来处理后果。
- en: Probably, the most visually significant improvement we add, will be scrolling
    backgrounds. We will add some classes to allow the level designer to add multiple
    different scrolling backgrounds to a level design.
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: 可能，我们添加的最具视觉意义的改进将是滚动背景。我们将添加一些类，允许关卡设计师向关卡设计中添加多个不同的滚动背景。
- en: Tip
  id: totrans-1362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Why not add all the graphics from the `Chapter8/drawable` folder of the download
    bundle to the `drawable` folder of your project. Then, you will have all the graphics
    ready and in place, for this and the next two sections as well.
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不将下载包中`Chapter8/drawable`文件夹中的所有图形添加到项目的`drawable`文件夹中。这样，你将拥有所有准备好的图形，并可用于本节以及接下来的两节。
- en: The new platform tiles
  id: totrans-1364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新的平台瓦片
- en: 'Now, add all these classes with the filenames as shown. I have removed all
    comments from the code because they are all functionally the same as the `Grass`
    class. Create each of the following classes with the name shown and enter the
    code:'
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: 现在添加所有这些类，文件名如所示。我已经从代码中移除了所有注释，因为它们在功能上都与 `Grass` 类相同。按照所示名称创建以下每个类，并输入代码：
- en: 'Here is the code for the `Brick` class:'
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `Brick` 类的代码：
- en: '[PRE264]'
  id: totrans-1367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: 'This is the code for the `Coal` class:'
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `Coal` 类的代码：
- en: '[PRE265]'
  id: totrans-1369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: 'Here is the code for the `Concrete` class:'
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `Concrete` 类的代码：
- en: '[PRE266]'
  id: totrans-1371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: 'The following is the code for the `Scorched` class:'
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码是 `Scorched` 类的代码：
- en: '[PRE267]'
  id: totrans-1373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: 'This is the code for the `Snow` class:'
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `Snow` 类的代码：
- en: '[PRE268]'
  id: totrans-1375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: 'Here is the code for the `Stone` class:'
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `Stone` 类的代码：
- en: '[PRE269]'
  id: totrans-1377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: Now, as we are getting used to, we need to add them all into our `LevelManager`
    in the usual three places.
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如我们习惯的那样，我们需要将它们全部添加到我们的 `LevelManager` 中，通常在三个地方。
- en: In `getBitmap()`, we simply add them in as normal. Note that although the values
    are arbitrary, we will use numbers for the type 2,3,4, and so on. This makes it
    easy to remember, while designing levels, that all our actual platforms are numbers.
    The actual index numbers are unimportant to us, as long as they are the same as
    in the `getBitmapIndex` method. Also, remember that we have a list of types in
    our `LevelData` class's comments, for easy reference when designing levels.
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `getBitmap()` 中，我们简单地按正常方式添加它们。请注意，尽管值是任意的，但我们将使用数字 2、3、4 等来表示类型。这使得在设计关卡时更容易记住，所有我们的实际平台都是数字。实际的索引数字对我们来说并不重要，只要它们与
    `getBitmapIndex` 方法中的相同。此外，请记住，在我们的 `LevelData` 类的注释中有一个类型列表，便于设计关卡时参考。
- en: '[PRE270]'
  id: totrans-1380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: 'In `getBitmapIndex()`, we do the same thing:'
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `getBitmapIndex()` 中，我们做同样的事情：
- en: '[PRE271]'
  id: totrans-1382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: In `loadMapData()`, we just call `new()` on our new `GameObjects` to add them
    to our `gameObjects` list.
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `loadMapData()` 中，我们只需对新的 `GameObjects` 调用 `new()` 来将它们添加到我们的 `gameObjects`
    列表中。
- en: '[PRE272]'
  id: totrans-1384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: 'Now, go wild adding different terrains to the `LevelCave` class:'
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尽情地为 `LevelCave` 类添加不同的地形：
- en: '![The new platform tiles](img/B04322_08_03.jpg)'
  id: totrans-1386
  prefs: []
  type: TYPE_IMG
  zh: '![新的平台砖块](img/B04322_08_03.jpg)'
- en: Now, to add some scenery objects.
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: 现在添加一些景观对象。
- en: The new scenery objects
  id: totrans-1388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新的景观对象
- en: Here, we will add some objects that don't do anything but look pretty. We will
    let the game engine know by simply not adding a hitbox and setting them randomly
    to either z layer -1, or 1\. Then the player can appear either in front or behind
    them.
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将添加一些不做什么但看起来很漂亮的对象。我们将通过简单地不添加碰撞盒并将它们随机设置为 z 层 -1 或 1 来让游戏引擎知道。然后玩家可以出现在它们的前面或后面。
- en: 'We will first add all the classes, and then update `LevelManager` in the usual
    three places. Create each of the new classes as follows:'
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先添加所有类，然后像往常一样在三个地方更新 `LevelManager`。按照以下方式创建每个新类：
- en: 'Here is the `Boulders` class:'
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `Boulders` 类：
- en: '[PRE273]'
  id: totrans-1392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: From now on, I removed all the comments to save digital ink. The class functionality
    is the same as it is in `Boulders`, just the attributes vary a bit.
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我移除了所有的注释以节省数字墨水。类功能与 `Boulders` 中的相同，只是属性略有不同。
- en: 'Here is the `Cart` class:'
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `Cart` 类：
- en: '[PRE274]'
  id: totrans-1395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: 'This is the code for the `Lampost` class:'
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `Lampost` 类的代码：
- en: '[PRE275]'
  id: totrans-1397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: 'Here is the `Stalagmite` class:'
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `Stalagmite` 类：
- en: '[PRE276]'
  id: totrans-1399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: 'This is the `Stalactite` class:'
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `Stalactite` 类：
- en: '[PRE277]'
  id: totrans-1401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: 'Here is the `Tree` class:'
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `Tree` 类的代码：
- en: '[PRE278]'
  id: totrans-1403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: 'And this is the `Tree2` class:'
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 `Tree2` 类：
- en: '[PRE279]'
  id: totrans-1405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: That's all the new classes for the scenery objects. Now, we can update the `getBitmap`
    method with the seven new types in the `LevelManager` class.
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是所有新的景观对象类。现在，我们可以更新 `LevelManager` 类中的 `getBitmap` 方法，添加七个新类型。
- en: '[PRE280]'
  id: totrans-1407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: 'Update the `getBitmapIndex` method in the same way:'
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: 以同样的方式更新 `getBitmapIndex` 方法：
- en: '[PRE281]'
  id: totrans-1409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: 'Finally, make sure our new scenery items are added to our `gameObjects` array
    list:'
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，确保我们的新景观项目被添加到我们的 `gameObjects` 数组列表中：
- en: '[PRE282]'
  id: totrans-1411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: 'Now, we can design levels with scenery. Note the slight difference in appearance
    when an object is drawn on layer zero compared to layer one and how the player
    character passes either in front or behind:'
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用景观来设计关卡。注意当对象在零层绘制时与在第一层绘制时的外观略有不同，以及玩家角色是穿过前面还是后面：
- en: '![The new scenery objects](img/B04322_08_04.jpg)'
  id: totrans-1413
  prefs: []
  type: TYPE_IMG
  zh: '![新的景观对象](img/B04322_08_04.jpg)'
- en: Tip
  id: totrans-1414
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Of course, if you want to bump into lamposts, get skewered by stalagmites, or
    jump on top of mine carts, then just give them a hitbox.
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你想撞到路灯柱，被钟乳石刺穿，或者跳到矿车上，那么只需给它们一个碰撞盒。
- en: We have one more way to beautify our game world.
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有另一种美化游戏世界的方法。
- en: Scrolling parallax backgrounds
  id: totrans-1417
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 滚动透视背景
- en: Parallax backgrounds are scrolling backgrounds, where we scroll them slower
    the farther away they are. So, if we have a grass verge at the player's feet,
    we will scroll it quickly. However, if we have a mountain range in the distance,
    we will scroll it slowly. This effect can give the sense of motion to the player.
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直背景是滚动背景，我们越远地滚动它们就越慢。所以，如果我们在玩家的脚下有草地边缘，我们会快速滚动它。然而，如果我们在远处有山脉，我们会慢速滚动它。这种效果可以给玩家带来运动感。
- en: To implement them, we will first add a data structure to represent the parameters
    of a background. We will call this class `BackgroundData`, we will then implement
    a `Background` class, which has the functionality necessary to control the scrolling
    and then we will see how to position and define backgrounds in our level design.
    Finally, we will write a `drawBackground` method that we will call from our regular
    `draw` method.
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这些，我们首先将添加一个数据结构来表示背景的参数。我们将把这个类命名为 `BackgroundData`，然后实现一个 `Background`
    类，它具有控制滚动的功能，然后我们将看到如何在我们的关卡设计中定位和定义背景。最后，我们将编写一个 `drawBackground` 方法，我们将在常规的
    `draw` 方法中调用它。
- en: Make sure you added all the graphics from the `Chapter8/drawable` folder of
    the download bundle to the `drawable` folder of your project.
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已经将下载包中 `Chapter8/drawable` 文件夹中的所有图形添加到了你的项目中的 `drawable` 文件夹。
- en: First, let's build a simple class to hold the data structure which will define
    our backgrounds. As we can see in the next block of code, we have quite a large
    number of parameters and member variables. We will need to know which bitmap will
    represent a background, which layer on the *z* axis to draw it (in front on 1
    or behind on -1), where in the world on the *y* axis it starts and finishes, how
    fast the background will scroll, and how high the background will be.
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们构建一个简单的类来保存数据结构，这将定义我们的背景。正如我们可以在下一块代码中看到的那样，我们有很多参数和成员变量。我们需要知道哪个位图将代表一个背景，它在
    *z* 轴上的哪一层来绘制（在 1 前面或在 -1 后面），在 *y* 轴上它在世界中的起始和结束位置，背景将如何滚动，以及背景将有多高。
- en: The `isParallax` Boolean is intended to give the option to have a background
    which is static, but we will not be implementing this feature. When you see the
    code for the background class, you will see it is simple to add this functionality
    if you want to.
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: '`isParallax` 布尔值旨在提供选项来有一个静态的背景，但我们不会实现这个功能。当你看到背景类的代码时，你会看到如果你想要添加这个功能，它是很容易的。'
- en: 'Create a new class and call it `BackgroundData`, then implement it with the
    following code:'
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的类，命名为 `BackgroundData`，然后使用以下代码实现它：
- en: '[PRE283]'
  id: totrans-1424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: 'Now, we add an `ArrayList` of our new type to the `LevelData` class:'
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将我们的新类型 `ArrayList` 添加到 `LevelData` 类中：
- en: '[PRE284]'
  id: totrans-1426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: Next, let's create the `Background` class itself. Create a new class and name
    it `Background`. First, we set up a bunch of variables to hold a copy of the background
    image along with a reversed copy. We will make the backgrounds seem *endless*
    by putting the images back to back alternating between the regular image and a
    reversed image. We will see how to achieve this further on in the code.
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建 `Background` 类本身。创建一个新的类，命名为 `Background`。首先，我们设置一些变量来保存背景图像的一个副本以及一个反转的副本。我们将通过交替放置正图像和反转图像来使背景看起来是无限的。我们将在代码的后续部分看到如何实现这一点。
- en: We also have variables for the width and height of the image in pixels. The
    `reversedFirst` Boolean will determine which copy of the image is currently drawn
    on the left-hand side of the screen (first) and will change as the player moves
    and the image scrolls. The `xClip` variable will hold the precise pixel of the
    *x* axis (of the image), where we will cut the image and start to draw it from
    the left hand edge of the screen.
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有用于图像宽度和高度的像素变量。`reversedFirst` 布尔值将确定当前绘制在屏幕左侧（第一）的图像副本是哪个。当玩家移动和图像滚动时，它将改变。`xClip`
    变量将保存 *x* 轴（图像的）上的精确像素，我们将从屏幕的左侧边缘开始切割图像并绘制它。
- en: 'The `y`, `endY`, `z`, and `speed` member variables are to hold the related
    values passed in as parameters:'
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
  zh: '`y`、`endY`、`z` 和 `speed` 成员变量用于存储作为参数传入的相关值：'
- en: '[PRE285]'
  id: totrans-1430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: Now, in the constructor, we create an Android resource ID from the name of the
    graphic file passed in as a parameter. Then, create the actual bitmap by calling
    `BitmapFactory.decodeResource()`. We set `reversedFirst` to `false`, so we will
    start with the regular (non-reversed) copy of the image on the left-hand side
    of the screen. We initialize our member variables and then scale the bitmap we
    just created by calling `Bitmap.createScaledBitmap()` and passing in bitmap, the
    width of the screen and the height (in the game world) of our background multiplied
    by the `pixelsPerMetre`, making the bitmap exactly the right size for the current
    devices screen.
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在构造函数中，我们从一个作为参数传递的图形文件名称创建一个Android资源ID。然后，通过调用`BitmapFactory.decodeResource()`创建实际的位图。我们将`reversedFirst`设置为`false`，因此我们将从屏幕左侧的常规（非反转）图像副本开始。我们初始化我们的成员变量，然后通过调用`Bitmap.createScaledBitmap()`并传入位图、屏幕宽度和背景（在游戏世界中）的高度（乘以`pixelsPerMetre`）来缩放我们刚刚创建的位图，使位图正好适合当前设备的屏幕。
- en: Tip
  id: totrans-1432
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that we must choose appropriate heights for our background designs or they
    will appear stretched.
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们必须为我们的背景设计选择适当的高度，否则它们将看起来被拉伸。
- en: The last thing we do in the constructor is create a `Matrix` object and send
    it to the `createScaledBitmap` method along with the bitmap, so we now have a
    reversed copy of our background image stored in the `bitmapReversed Bitmap` object.
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中我们做的最后一件事是创建一个`Matrix`对象，并将其与位图一起发送到`createScaledBitmap`方法，因此我们现在在`bitmapReversed
    Bitmap`对象中存储了背景图像的反转副本。
- en: '[PRE286]'
  id: totrans-1435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: 'Now, we add two backgrounds to our level design. We fill out the required parameters
    that we have already discussed. Note that the "grass" background on layer 1 scrolls
    much faster than the "skyline" background on layer -1\. This will create the desired
    parallax effect. Add this code right at the end of the `LevelCave` constructor:'
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在关卡设计中添加两个背景。我们填写了已经讨论过的必需参数。注意，层1上的“草地”背景比层-1上的“天际线”背景滚动得快得多。这将创建所需的透视效果。在`LevelCave`构造函数的末尾添加此代码：
- en: '[PRE287]'
  id: totrans-1437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: Note
  id: totrans-1438
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is certainly true that most caves do not have grass and a skyline. This is
    just a demonstration and to get the code working. We will redesign `LevelCave`
    and design some more appropriate levels a little later in this chapter.
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，大多数洞穴没有草地和天际线。这只是一个演示，为了使代码工作。我们将在本章稍后重新设计`LevelCave`并设计一些更合适的关卡。
- en: Now, we load them with our `LevelManager` class by declaring a new `Arraylist`
    object as a member of our `LevelManager` class.
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们通过声明一个新`Arraylist`对象作为`LevelManager`类的一个成员，使用我们的`LevelManager`类来加载它们。
- en: '[PRE288]'
  id: totrans-1441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: 'Then, add a new method in `LevelManager` to load the background data:'
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`LevelManager`中添加一个新方法来加载背景数据：
- en: '[PRE289]'
  id: totrans-1443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: 'We call the new method in the `LevelManager` constructor:'
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`LevelManager`构造函数中调用新方法：
- en: '[PRE290]'
  id: totrans-1445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: And, not for the last time, we will upgrade our `Viewport` class to enable our
    `PlatformView` methods to get the information they need, to draw the parallax
    backgrounds.
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，这不是最后一次，我们将升级我们的`Viewport`类，以使我们的`PlatformView`方法能够获取它们所需的信息，以绘制透视背景。
- en: '[PRE291]'
  id: totrans-1447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: Then, we will add a method which actually does the drawing in the `PlatformView`
    class. We will call this method from `onDraw()`, in just the right places, next.
    Note that we are using the new methods that we just added to the `Viewport` class.
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将在`PlatformView`类中添加一个实际执行绘制的方法。我们将在接下来的`onDraw()`方法中，在正确的位置调用此方法。注意，我们正在使用我们刚刚添加到`Viewport`类中的新方法。
- en: First, we define four `Rect` objects that we will use to hold the start and
    end points of `bitmap` and `reversedBitmap`.
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义四个`Rect`对象，我们将使用它们来保存`bitmap`和`reversedBitmap`的起始和结束点。
- en: 'Implement the first part of the `drawBackground` method as shown:'
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式实现`drawBackground`方法的第一部分：
- en: '[PRE292]'
  id: totrans-1451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: Now, we simply loop through all our backgrounds using the `start` and `stop`
    parameters to decide which backgrounds have a *z* layer that we are currently
    interested in drawing.
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需使用`start`和`stop`参数遍历所有背景，以决定哪些背景具有我们目前感兴趣绘制的*z*层。
- en: '[PRE293]'
  id: totrans-1453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: Next, we send the world coordinates of the background to the `Viewport` class
    for clipping. If it isn't clipped (and should be drawn), we get the starting pixel
    coordinates, and ending pixel coordinates on the *y* axis with the help of the
    new methods we added to our `Viewport` class previously. Note that we cast the
    results to `int` variables ready to be drawn to the screen.
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将背景的世界坐标发送到`Viewport`类进行裁剪。如果没有裁剪（应该绘制），我们通过我们之前添加到`Viewport`类中的新方法获取起始像素坐标和结束像素坐标在*y*轴上。注意，我们将结果转换为`int`变量，以便绘制到屏幕上。
- en: '[PRE294]'
  id: totrans-1455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: 'This next block of code is where the real action takes place. We initialize
    the four `Rect` objects with the starting and ending coordinates of the first
    and second of our two `Bitmap` objects. Note that the point (or pixel) that is
    calculated, is determined by `xClip`, which is initially zero. So, to start with,
    we will simply see `background` (if it is not clipped) stretched across the width
    of the screen. Soon, we will see that we modify `xClip` based on Bob''s velocity
    and cause different regions from each bitmap to be shown:'
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的代码块是真正动作发生的地方。我们使用两个 `Bitmap` 对象的第一个和第二个的起始和结束坐标初始化四个 `Rect` 对象。请注意，计算出的点（或像素）是由
    `xClip` 决定的，它最初为零。因此，一开始，我们只会看到 `background`（如果它没有被裁剪）横跨屏幕的宽度。很快，我们将看到我们根据鲍勃的速度修改
    `xClip`，从而显示每个位图的不同区域：
- en: '[PRE295]'
  id: totrans-1457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: Now, we determine which background (regular or reversed) is currently being
    drawn first, and then draw that one first followed by the other.
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们确定当前正在绘制的背景（常规或反转）是哪一个，然后先绘制这个背景，然后绘制另一个。
- en: '[PRE296]'
  id: totrans-1459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: We can scroll along based on the speed and direction of Bob, `lv.player.getxVelocity()`
    and if `xClip` has reached the end of the current first background, `if (bg.xClip
    >= bg.width)`, simply set `xClip` to zero and change which bitmap we show first.
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据鲍勃的速度和方向进行滚动，`lv.player.getxVelocity()` 以及如果 `xClip` 达到了当前第一个背景的末尾，`if
    (bg.xClip >= bg.width)`，简单地将 `xClip` 设置为零，并更改我们首先显示的位图。
- en: '[PRE297]'
  id: totrans-1461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: Then, we add a call to `drawBackground()` just before our game objects for backgrounds
    with a *z* layer less than zero.
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在游戏对象之前添加对 `drawBackground()` 的调用，对于具有小于零的 *z* 层的背景。
- en: '[PRE298]'
  id: totrans-1463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: Just after the bullets are drawn, but before the debugging text for those backgrounds
    with a *z* order more than zero.
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
  zh: 在子弹被抽取后，但在那些具有超过零的 *z* 排序的背景的调试文本之前。
- en: '[PRE299]'
  id: totrans-1465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: Now, we can really start to get creative with our level designs.
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们真的可以开始在我们的等级设计中发挥创意了。
- en: '![Scrolling parallax backgrounds](img/B04322_08_05.jpg)'
  id: totrans-1467
  prefs: []
  type: TYPE_IMG
  zh: '![滚动视差背景](img/B04322_08_05.jpg)'
- en: Very soon, we will make some real playable levels that use all the features
    we have implemented over the last four chapters. Before we do that, let's have
    a bit of fun with the `Viewport` class.
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
  zh: 很快，我们将制作一些真正的可玩等级，这些等级使用了我们在过去四章中实现的所有功能。在我们这样做之前，让我们先在 `Viewport` 类上玩玩。
- en: It will be really useful for the player to scan around a level and plan a route.
    Equally, it will be helpful when designing levels, to zoom around the level to
    see how a particular part of the level looks without having to get the player
    character to that part in order to see it on the screen. So, let's make the pause
    screen into a moveable viewport.
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
  zh: 对于玩家来说，扫描整个等级并规划路线将非常有用。同样，在设计等级时，通过放大等级来查看特定部分的等级外观，而不必让玩家角色到达那个部分以便在屏幕上看到它，这也会很有帮助。所以，让我们将暂停屏幕变成一个可移动的视口。
- en: Pause menu with moveable viewport
  id: totrans-1470
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有可移动视口的暂停菜单
- en: This is nice and quick. We will just add a bunch of new methods to our `Viewport`
    class to change the center of focus. Then, we will call them from `InputController`.
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，也很快捷。我们只需向我们的 `Viewport` 类添加一些新方法来改变焦点中心。然后，我们将从 `InputController` 中调用它们。
- en: If you remember when we implemented the `InputController` class back in [Chapter
    6](ch15.html "Chapter 6. Platformer – Bob, Beeps, and Bumps"), *Platformer – Bob,
    Beeps and Bumps*, we wrapped all the control logic in an `if(playing)` test. We
    also implemented the pause button already in the `else` clause. All we will do
    is use the left, right, jump, and shoot buttons as left, right, up, and down,
    respectively, for moving the viewport.
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得我们在 [第 6 章](ch15.html "第 6 章。平台游戏 – 鲍勃、哔哔声和碰撞") 中实现 `InputController`
    类时，*平台游戏 – 鲍勃、哔哔声和碰撞*，我们将所有控制逻辑包裹在 `if(playing)` 测试中。我们已经在 `else` 子句中实现了暂停按钮。我们将会做的是将左、右、跳跃和射击按钮分别用作左、右、上和下，以移动视口。
- en: 'First, add these methods to the `Viewport` class:'
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将这些方法添加到 `Viewport` 类中：
- en: '[PRE300]'
  id: totrans-1474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: Now, add these calls to the methods from the `else` clause of the `if` condition
    in the `InputController` class that we were just discussing.
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将这些调用添加到我们刚才讨论的 `InputController` 类中 `if` 条件的 `else` 子句的方法中。
- en: '[PRE301]'
  id: totrans-1476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: On the pause screen, the player can look around and plan their route when they
    are on more complicated levels. They are probably going to need to.
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
  zh: 在暂停屏幕上，玩家可以四处张望并规划他们的路线，当他们处于更复杂的等级时。他们可能需要这样做。
- en: Levels and game rules
  id: totrans-1478
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 等级和游戏规则
- en: We have implemented so many features, but we still don't have a way to put them
    altogether into a playable game. We need to be able to travel between levels,
    and have the player state persist when we do.
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了许多功能，但我们仍然没有将这些功能全部整合成一个可玩游戏的方法。我们需要能够在关卡之间旅行，并且当这样做时，玩家状态能够持续。
- en: Traveling between levels
  id: totrans-1480
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在关卡之间旅行
- en: 'As we are going to design four levels, we want the player to be able to travel
    between them. First, let''s add code to the `switch` statement at the start of
    the `LevelManager` constructor to include all four levels that we are about to
    build:'
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将设计四个关卡，我们希望玩家能够在它们之间旅行。首先，让我们向`LevelManager`构造函数开始处的`switch`语句中添加我们即将构建的所有四个关卡：
- en: '[PRE302]'
  id: totrans-1482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: 'As we know, we start the game by calling `loadLevel()` from the `PlatformView`
    constructor. The arguments include the name of the level and the coordinates to
    spawn the player. If you are designing your own levels, then you need to decide
    which level and coordinates to start with. If you will be following along with
    the levels I have provided, set the call to `loadLevel()` in the constructor of
    `PlatformView` as follows:'
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，我们通过从`PlatformView`构造函数中调用`loadLevel()`来开始游戏。参数包括关卡名称和玩家出生的坐标。如果你正在设计自己的关卡，那么你需要决定从哪个关卡和坐标开始。如果你将跟随我提供的关卡进行，请将`PlatformView`构造函数中的`loadLevel()`调用设置如下：
- en: '[PRE303]'
  id: totrans-1484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: 'In the `if(lm.isPlaying())` block, in the `update` method, where we set the
    viewport to center on the player each frame; add the following code to detect
    (and brutally kill) the player if he falls out of the map as well as cause the
    game to restart with three lives, zero money, and no upgrades should he run out
    of lives:'
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
  zh: 在`if(lm.isPlaying())`块中，在`update`方法中，我们将视口设置为每帧都居中显示玩家；添加以下代码以检测（并残忍地杀死）玩家如果他从地图上掉落，以及如果玩家用尽生命，游戏将重新开始，拥有三条生命、零金钱和没有升级：
- en: '[PRE304]'
  id: totrans-1486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: Now, we can create a special `GameObject` class that when touched sends the
    player to a predetermined level and location. We can then strategically add these
    objects to our level designs, and they will act as the link between our levels.
    Create a new class and call it `Teleport`. If you haven't already done so, add
    the `door.png` file from `Chapter8/drawable` to the `drawable` folder of the project.
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个特殊的`GameObject`类，当被触摸时，它会将玩家发送到预定的关卡和位置。然后我们可以有策略地将这些对象添加到我们的关卡设计中，它们将作为我们关卡之间的链接。创建一个新的类，命名为`Teleport`。如果你还没有这样做，请将`Chapter8/drawable`中的`door.png`文件添加到项目的`drawable`文件夹中。
- en: 'This is how our `Teleport` object will appear in the game:'
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的`Teleport`对象在游戏中的外观：
- en: '![Traveling between levels](img/B04322_08_06.jpg)'
  id: totrans-1489
  prefs: []
  type: TYPE_IMG
  zh: '![在关卡之间旅行](img/B04322_08_06.jpg)'
- en: 'Let''s make a simple class to hold the data that each `Teleport` object will
    need. Create a new class called `Location` like this:'
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的类来保存每个`Teleport`对象所需的数据。创建一个新的类，命名为`Location`，如下所示：
- en: '[PRE305]'
  id: totrans-1491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: The actual `Teleport` class looks just like any other `GameObject` class, but
    note that it also has a member `Location` variable. We will see how the level
    design will hold the destination of the `Teleport`, the `LevelManager` class will
    initialize it, and then when the player collides with it, we can load the new
    location, sending the player off to his destination.
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的`Teleport`类看起来就像任何其他`GameObject`类一样，但请注意，它还有一个成员`Location`变量。我们将看到关卡设计将如何保存`Teleport`的目的地，`LevelManager`类将初始化它，然后当玩家与之碰撞时，我们可以加载新的位置，将玩家发送到他的目的地。
- en: '[PRE306]'
  id: totrans-1493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: 'To make our `Teleport` class work in a way that lets the level designer decide
    what it will do exactly, we need to add to our `LevelData` class like this:'
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的`Teleport`类能够以让关卡设计师决定它确切行为的方式工作，我们需要向我们的`LevelData`类添加如下内容：
- en: '[PRE307]'
  id: totrans-1495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: Then, we need to add a `t` to the level design wherever we want our teleport/door,
    and an entry like the next line of code, within the constructor of the class of
    the level we are designing.
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要在我们想要放置传送门/门的关卡设计中添加一个`t`，以及类似于下一行代码的条目，位于我们正在设计的关卡类构造函数中。
- en: 'Note that you can have as many `Teleport` objects as you like in a map, as
    long as the order they are defined in code matches the order they appear in the
    design. We will see exactly how this works when we look at our actual level designs
    in a minute, but the code will look like this:'
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你可以在地图中拥有任意多的`Teleport`对象，只要它们在代码中定义的顺序与在设计中出现的顺序相匹配。我们将在稍后查看我们的实际关卡设计时看到这是如何工作的，但代码看起来像这样：
- en: '[PRE308]'
  id: totrans-1498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: 'As usual, we need to update the `LevelManager` class to load and locate our
    teleport(s). Here is the new code for `getBitmap()`:'
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我们需要更新`LevelManager`类以加载和定位我们的传送点。以下是`getBitmap()`的新代码：
- en: '[PRE309]'
  id: totrans-1500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: 'New code for `getBitmapIndex()`:'
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
  zh: 为`getBitmapIndex()`编写的新的代码：
- en: '[PRE310]'
  id: totrans-1502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: 'We also need to keep track of our `Teleport` objects during the loading phase
    in case there is more than one. So, add a new local variable as shown in the `loadMapData`
    method:'
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在加载阶段跟踪我们的`Teleport`对象，以防有多个。所以，在`loadMapData`方法中添加一个新的局部变量，如下所示：
- en: '[PRE311]'
  id: totrans-1504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: Finally for the `LevelManager` class, we initialize all the teleport data from
    the level design, tuck it away in the object and add it to our `gameObject ArrayList`.
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于`LevelManager`类，我们从关卡设计中初始化所有传送数据，将其存放在对象中，并将其添加到我们的`gameObject ArrayList`中。
- en: '[PRE312]'
  id: totrans-1506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: 'We are really close to being able to teleport all over the place. We need to
    detect a collision with a teleport, and then load a new level with the player
    at the desired location. This code will go in our collision detection switch block
    in the `PlatformView` class like this:'
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真的非常接近能够在任何地方传送。我们需要检测与传送的碰撞，然后加载一个新关卡，玩家位于期望的位置。这段代码将放在`PlatformView`类的碰撞检测开关块中，如下所示：
- en: '[PRE313]'
  id: totrans-1508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: 'When a new level is loaded, the `Player`, `MachineGun`, and `Bullet` objects
    are all created from scratch. Therefore, we need to add a line to our `loadLevel`
    method to reload the current machine gun fire rate from the `PlayerState` class
    into the `MachineGun` class. Add the highlighted code:'
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
  zh: 当加载新关卡时，`Player`、`MachineGun`和`Bullet`对象都是从零开始创建的。因此，我们需要在我们的`loadLevel`方法中添加一行，将`PlayerState`类中的当前机枪射速重新加载到`MachineGun`类中。添加以下高亮代码：
- en: '[PRE314]'
  id: totrans-1510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: Now, we can work on the level designs for real.
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以真正开始设计关卡了。
- en: The level designs
  id: totrans-1512
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关卡设计
- en: You can just copy and paste four classes from the `Chapter8/java` folder into
    your project and start playing, or you can start from the beginning and design
    your own. The levels are quite large, intricate, and tough to beat. It is not
    physically possible to print the level designs in a book or e-book in any meaningful
    way, so you will need to open up the `LevelCave`, `LevelCity`, `LevelForest`,
    and `LevelMountain` design files in order to see the detail of the four levels.
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接从`Chapter8/java`文件夹复制粘贴四个类到你的项目中开始游戏，或者你可以从头开始并设计自己的关卡。这些关卡相当大，复杂，难以击败。在书中或电子书中以任何有意义的方式打印关卡设计都是不可能的，所以你需要打开`LevelCave`、`LevelCity`、`LevelForest`和`LevelMountain`设计文件，才能看到四个关卡的具体细节。
- en: However, a brief discussion of the levels, pictures, and some screenshots, but
    not actual code from the four designs follows.
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，以下是对关卡、图片和一些截图的简要讨论，但不是来自四个设计的实际代码。
- en: Note
  id: totrans-1515
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the following screenshots feature the new HUD that is the last thing
    we will cover in this chapter.
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，以下截图展示了新的HUD，这是我们将在本章最后讨论的最后一个内容。
- en: The cave
  id: totrans-1517
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 洞穴
- en: The cave level is where the whole thing starts. It not only features modestly
    frustrating jumps, but also plenty of fire making a fall potentially deadly.
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
  zh: 洞穴关卡是整个游戏开始的地方。它不仅包含适度令人沮丧的跳跃，还有大量的火焰，使得坠落可能致命。
- en: '![The cave](img/B04322_08_07.jpg)'
  id: totrans-1519
  prefs: []
  type: TYPE_IMG
  zh: '![洞穴](img/B04322_08_07.jpg)'
- en: As the player starts with a puny machine gun, only a few drones are present
    in the level. But there are two awkward guards that will require vaulting.
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
  zh: 作为玩家开始时只有一把微弱的机枪，这个关卡中只有几个无人机。但有两个笨拙的守卫需要翻越。
- en: '![The cave](img/B04322_08_08.jpg)'
  id: totrans-1521
  prefs: []
  type: TYPE_IMG
  zh: '![洞穴](img/B04322_08_08.jpg)'
- en: The city
  id: totrans-1522
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 城市
- en: The city holds vast rewards, especially in the bottom left-hand corner for coins
    and the top-left for machine gun upgrades.
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
  zh: 城市拥有巨大的奖励，特别是在左下角有硬币，在左上角有机枪升级。
- en: '![The city](img/B04322_08_09.jpg)'
  id: totrans-1524
  prefs: []
  type: TYPE_IMG
  zh: '![城市](img/B04322_08_09.jpg)'
- en: However, there is a very awkward-to-jump guard on the bottom level should the
    player want to get all those stray coins and not opt for leaving them behind.
    The near vertical ascent that must be traversed up the left-hand side is likely
    to frustrate and if the player opts not to go for the machine gun upgrades, he
    will probably struggle with the double-guard just outside the door to the next
    level.
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果玩家想要收集所有散落的硬币而不是选择留下它们，那么底层有一个非常难以跳跃的守卫。必须穿越几乎垂直的上升，沿着左手边向上爬，这可能会令人沮丧。如果玩家选择不升级机枪，他可能会在通往下一关的门外的双重守卫处遇到困难。
- en: '![The city](img/B04322_08_10.jpg)'
  id: totrans-1526
  prefs: []
  type: TYPE_IMG
  zh: '![城市](img/B04322_08_10.jpg)'
- en: The forest
  id: totrans-1527
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 森林
- en: The forest may be the overall toughest level of them all with a brutally long
    run of jumps, which are very easy to over or under jump.
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
  zh: 森林可能是所有关卡中最具挑战性的关卡，因为有一段非常长的跳跃，很容易跳过或跳得太低。
- en: '![The forest](img/B04322_08_11.jpg)'
  id: totrans-1529
  prefs: []
  type: TYPE_IMG
  zh: '![森林](img/B04322_08_11.jpg)'
- en: And with in excess of a dozen drones waiting to swoop on Bob, as his pixels
    hang precariously off a platform.
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
  zh: 并且有超过一打无人机等着扑向鲍勃，他的像素正悬挂在平台边缘，摇摇欲坠。
- en: '![The forest](img/B04322_08_12.jpg)'
  id: totrans-1531
  prefs: []
  type: TYPE_IMG
  zh: '![森林](img/B04322_08_12.jpg)'
- en: The mountains
  id: totrans-1532
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 山脉
- en: The fresh mountain air means Bob has almost made it. Not a guard or a drone
    in sight.
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
  zh: 新鲜的山间空气意味着鲍勃几乎已经成功了。没有守卫或无人机在视线范围内。
- en: '![The mountains](img/B04322_08_13.jpg)'
  id: totrans-1534
  prefs: []
  type: TYPE_IMG
  zh: '![山脉](img/B04322_08_13.jpg)'
- en: However, look at that winding path of jumps, most of which will see Bob thrown
    right back to the bottom if he puts a pixel out of place.
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，看看那些跳跃的蜿蜒路径，大多数情况下，如果鲍勃有一个像素放错位置，他就会被直接扔回底部。
- en: '![The mountains](img/B04322_08_14.jpg)'
  id: totrans-1536
  prefs: []
  type: TYPE_IMG
  zh: '![山脉](img/B04322_08_14.jpg)'
- en: Tip
  id: totrans-1537
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'If you want to try out each of the levels without completing the grueling level(s)
    that precede it, you can of course, just start at the level and location of your
    choice. To do this, just change the call to `loadLevel()` in the `PlatformView`
    constructor to one of the following:'
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想尝试每个关卡而不完成前面的艰难关卡，当然，你只需从你选择的关卡和位置开始即可。为此，只需将`PlatformView`构造函数中对`loadLevel()`的调用更改为以下之一：
- en: '[PRE315]'
  id: totrans-1539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: The HUD
  id: totrans-1540
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HUD
- en: The finishing touch is to add a HUD. This code in the `draw` method of `PlatformView`
    uses the graphics from some of the existing game objects.
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的修饰是添加一个HUD。这个代码位于`PlatformView`的`draw`方法中，使用了现有游戏对象中的一些图形。
- en: 'Add the code after the last call to `drawBackground()` and before the debugging
    text is drawn:'
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`drawBackground()`的最后和绘制调试文本之前添加代码：
- en: '[PRE316]'
  id: totrans-1543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: I think we are done!
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
  zh: 我想我们已经完成了！
- en: Summary
  id: totrans-1545
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We finished the platform game because that is all there is space for. Why not
    try to implement some or all of the following improvements and features?
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了平台游戏，因为那里已经没有空间了。为什么不尝试实现以下的一些或所有改进和功能呢？
- en: Change the code in the `Player` class to make Bob gradually accelerate and decelerate
    instead of always running at full speed. Simply increment the velocity for each
    frame that the player is holding down left or right, and decrement it for each
    frame they are not.
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`Player`类中的代码，使鲍勃逐渐加速和减速，而不是始终以全速奔跑。只需在玩家按住左右键的每一帧增加速度，在他们不按的每一帧减少速度。
- en: Once you have achieved this, add the preceding code to the collision detection
    `switch` block in the `update` method to make the player skid on snow, speed up
    on concrete, and have a different walking/landing sound effect for each tile type.
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你做到了这一点，就将前面的代码添加到`update`方法中的碰撞检测`switch`块中，使玩家在雪地上打滑，在混凝土上加速，并为每种地砖类型提供不同的行走/着陆音效。
- en: Draw a gun on Bob, and adjust the height that the `Bullet` object is spawned
    at to appear as if it is coming from the barrel of his machine gun.
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
  zh: 在鲍勃身上画一把枪，并调整`Bullet`对象生成的位置高度，使其看起来是从他的机枪枪管中发射出来的。
- en: Make some objects pushable. Add an `isPushable` member to `GameObject` and make
    the collision detection simply knock the object back a little. Perhaps, Bob could
    push mine carts into fire to jump over extra wide fire pits. Note that pushing
    objects that fall down to another level will be more complicated than pushing
    objects that remain at the same *y* coordinate.
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
  zh: 使一些物体可推动。给`GameObject`添加一个`isPushable`成员，并使碰撞检测简单地使物体稍微后退。也许，鲍勃可以推动矿车进入火中，以跳过更宽的火坑。请注意，推动掉落到另一个级别的物体将比推动保持在同一*y*坐标的物体更复杂。
- en: Destructible tiles sound like fun. Give them a strength variable that decrements
    when hit by a bullet and is removed from `gameObjects` when it reaches zero.
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
  zh: 可破坏的地砖听起来很有趣。给它们一个强度变量，当被子弹击中时减少，当达到零时从`gameObjects`中移除。
- en: Moving platforms are a staple of great platformers. Simply add waypoints to
    a tile object and add the move code to the `update` method. The challenge will
    be assigning the waypoints. You can either have them all move a set number of
    spaces left and right or up and down, or do some kind of `setTileWaypoint` method
    similar to how we scripted the `Guard` object.
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
  zh: 移动平台是优秀平台游戏的标准配置。只需将航点添加到地砖对象中，并将移动代码添加到`update`方法中。挑战将是分配航点。你可以让它们全部向左向右或向上向下移动一定距离，或者做一些类似于我们为`Guard`对象编写的`setTileWaypoint`方法。
- en: Make the game more persistent by saving the total number of coins collected
    ever, remembering which levels are unlocked, and offering access to replay any
    unlocked levels from the menu screen.
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
  zh: 通过保存收集到的总金币数、记住已解锁的关卡，并在菜单屏幕上提供重新播放任何解锁关卡的功能，使游戏更具持续性。
- en: Make the game easier with teleports used as waypoints. Adjust the viewport zoom
    for different screen sizes. The current zoom can be a little too low for some
    small phones.
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
  zh: 使用传送门作为航点使游戏更容易。调整视口缩放以适应不同的屏幕尺寸。当前的缩放对于一些小手机来说可能有点太低。
- en: Add timed runs for high scores, leaderboards, and achievements, and add more
    levels.
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
  zh: 添加计时赛跑以获得高分、排行榜和成就，并添加更多关卡。
- en: In the next chapter, we will look at a much smaller project, but still an interesting
    one, as we will be using OpenGL ES for super-fast, smooth drawing.
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将查看一个更小的项目，但仍然很有趣，因为我们将使用OpenGL ES进行超快、平滑的绘图。
- en: Chapter 9. Asteroids at 60 FPS with OpenGL ES 2
  id: totrans-1557
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章：使用OpenGL ES 2在60 FPS下玩《小行星》
- en: Welcome to the final project. Over the course of the next three chapters, we
    will build an Asteroids-like game using the OpenGL ES 2 graphics API. If you are
    wondering exactly what OpenGL ES 2 is, then we will discuss the details later
    in this chapter.
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到最终项目。在接下来的三个章节中，我们将使用OpenGL ES 2图形API构建一个类似《小行星》的游戏。如果你想知道OpenGL ES 2究竟是什么，那么我们将在本章后面讨论其细节。
- en: We will build a very simple but fun and challenging game, where we can draw
    and animate hundreds of objects at a time, even on quite old Android devices.
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个非常简单但有趣且具有挑战性的游戏，我们可以在一次绘制和动画化数百个对象，甚至在相当旧的Android设备上。
- en: With OpenGL, we will take our drawing efficiency to a much higher level, and
    with some not-too-tricky math, our movement and collision detection will be greatly
    enhanced compared to our previous projects.
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
  zh: 使用OpenGL，我们将把我们的绘图效率提升到一个更高的水平，并且通过一些不太复杂的数学计算，我们的移动和碰撞检测将比我们之前的项目有极大的提升。
- en: By the end of this chapter, we will have a basic working OpenGL ES 2 engine
    drawing our simple but temporarily static spaceship to the screen; at 60 FPS or
    higher.
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将拥有一个基本的OpenGL ES 2引擎，它将以60 FPS或更高的帧率将我们的简单但暂时静态的宇宙飞船绘制到屏幕上。
- en: Tip
  id: totrans-1562
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you have never seen or played the '80s arcade hit (released in November 1979)
    Asteroids, why not go and check out a clone of it or a video now?
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从未见过或玩过1980年代的街机游戏《小行星》（1979年11月发布），为什么不现在去看看它的克隆版或视频呢？
- en: Free web game at [http://www.freeasteroids.org/](http://www.freeasteroids.org/).
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
  zh: 免费网页游戏在[http://www.freeasteroids.org/](http://www.freeasteroids.org/)。
- en: On YouTube at [https://www.youtube.com/watch?v=WYSupJ5r2zo](https://www.youtube.com/watch?v=WYSupJ5r2zo).
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
  zh: 在YouTube上查看[https://www.youtube.com/watch?v=WYSupJ5r2zo](https://www.youtube.com/watch?v=WYSupJ5r2zo)。
- en: Let's discuss exactly what we intend to build.
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们具体讨论一下我们打算构建的内容。
- en: Asteroids simulator
  id: totrans-1567
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小行星模拟器
- en: Our game will be set in a four directional scrolling world that the player will
    be able to traverse while hunting for asteroids. The world will be enclosed in
    a rectangular border to keep the asteroids from drifting off too far, and the
    border will also serve as another hazard for the player to avoid.
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏将设定在一个四方向滚动的世界中，玩家可以在其中狩猎小行星时穿越世界。世界将被一个矩形边界包围，以防止小行星漂移得太远，边界也将作为玩家需要避免的另一个危险。
- en: The game controls
  id: totrans-1569
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏控制
- en: We will reuse our `InputController` class with a few simple modifications and
    can even keep the same button layout. As we will see, however, we will draw the
    buttons on screen in a very different manner to our retro platformer. Also, instead
    of walking left and right, the player will rotate the ship left and right through
    360 degrees. The jump button will become a thrust toggle switch to turn on and
    off forward motion, and the shoot button will remain just that. We will also have
    the pause button in the same place.
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用经过少量修改的`InputController`类，甚至可以保持相同的按钮布局。然而，正如我们将看到的，我们将以非常不同于我们的复古平台游戏的方式在屏幕上绘制按钮。此外，玩家将不会左右移动，而是通过360度旋转飞船左右移动。跳跃按钮将变成一个推力切换开关，用于打开和关闭前进运动，而射击按钮将保持原样。我们还将有一个暂停按钮放在相同的位置。
- en: Rules for the game
  id: totrans-1571
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏规则
- en: When an asteroid hits the border, it will bounce back into the game world. If
    the player hits the border, a life will be lost and the ship will respawn in the
    center of the screen. If an asteroid hits the ship this will be fatal too.
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
  zh: 当小行星撞击边界时，它将弹回游戏世界。如果玩家撞击边界，将损失一条生命，飞船将在屏幕中心重生。如果小行星撞击飞船，这也会是致命的。
- en: The player will start with three lives and must clear the asteroids simulator
    of all asteroids. The HUD will show a tally of the remaining asteroids and lives.
    If the player clears all the asteroids, then the next wave will start with more
    than the last. They will also move a little faster. Each wave cleared will be
    rewarded with an extra life.
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家开始时有三个生命值，必须清除所有的小行星模拟器中的小行星。HUD将显示剩余的小行星和生命值。如果玩家清除了所有的小行星，下一波将比上一波有更多的小行星。它们也会稍微快一点。每清除一波都会获得额外的生命值。
- en: We will implement these rules as we proceed through the project.
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在项目进行过程中实现这些规则。
- en: Introducing OpenGL ES 2
  id: totrans-1575
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍OpenGL ES 2
- en: OpenGL ES 2 is the second major version of the **Open Graphics Library** (**OpenGL**)
    for embedded systems. It is the mobile incarnation of OpenGL for desktop systems.
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL ES 2是嵌入式系统中的**开放图形库**（**OpenGL**）的第二大版本。它是桌面系统的OpenGL在移动设备上的实现。
- en: Why use it and how does it work?
  id: totrans-1577
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么使用它以及它是如何工作的？
- en: OpenGL runs as a native process, not on the Dalvik virtual machine like the
    rest of our Java. This is one of the reasons it is super fast. The OpenGL ES API
    takes away all of the complexity of interacting with native code, and OpenGL itself
    also provides very efficient and fast algorithms within its native code base.
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL作为一个本地进程运行，不像我们其余的Java那样在Dalvik虚拟机上运行。这是它超级快的原因之一。OpenGL ES API移除了与本地代码交互的所有复杂性，OpenGL本身也在其本地代码库中提供了非常高效和快速的算法。
- en: The first version of OpenGL was completed in 1992\. The point is that even back
    then OpenGL used arguably the most efficient code and algorithms to draw graphics.
    Now, more than 20 years on, it has been continually refined and improved as well
    as adapted to work with the latest graphics hardware, both mobile and desktop.
    All the mobile GPU manufacturers specifically design their hardware to be compatible
    with the latest version of OpenGL ES.
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL的第一个版本在1992年完成。重点是，即使在那时，OpenGL也使用了可能最有效的代码和算法来绘制图形。现在，超过20年后，它已经不断得到改进和优化，并且已经适应了与最新的图形硬件一起工作，无论是移动设备还是桌面设备。所有移动GPU制造商都专门设计他们的硬件以兼容最新的OpenGL
    ES版本。
- en: Trying to improve on OpenGL ES is, therefore, probably a fool's errand.
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，试图改进OpenGL ES可能是一个徒劳的任务。
- en: Tip
  id: totrans-1581
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: There is another viable Graphics API option when developing exclusively for
    Windows devices called DirectX.
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
  zh: 当专门为Windows设备开发时，还有一个可行的图形API选项，称为DirectX。
- en: What is neat about Version 2?
  id: totrans-1583
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二版有什么好处？
- en: The first version of OpenGL ES certainly impressed at the time. I remember almost
    falling off my chair when I first played a 3D shooter on a phone! Now this is
    of course commonplace. However, compared to the desktop version of OpenGL, OpenGL
    ES 1 had a major drawback.
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL ES 1的最初版本在当时确实给人留下了深刻印象。我记得当我第一次在手机上玩3D射击游戏时，差点从椅子上摔下来！现在这当然是家常便饭。然而，与桌面版本的OpenGL相比，OpenGL
    ES 1有一个主要的缺点。
- en: OpenGL ES 1 had, what is known as, a fixed function pipeline. The geometry to
    draw went into the GPU and it was drawn, but any further manipulation of individual
    pixels needed to take place before OpenGL ES took over the drawing of a frame
    of the game.
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL ES 1有一个被称为固定功能管道的东西。要绘制的几何形状进入GPU并绘制，但任何进一步操纵单个像素的操作都需要在OpenGL ES接管游戏帧的绘制之前进行。
- en: Now, with OpenGL ES 2, we have access to what is called a programmable pipeline.
    That is, we can send our graphics off to be drawn, but we can also write code
    that runs on the GPU that is capable of manipulating each and every pixel independently.
    This is a very powerful feature, although we will not get to explore it in much
    depth.
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有了OpenGL ES 2，我们可以访问所谓的可编程管道。也就是说，我们可以将我们的图形发送出去绘制，但我们还可以编写在GPU上运行的代码，这些代码能够独立操纵每个像素。这是一个非常强大的功能，尽管我们不会深入探索它。
- en: This extra code that runs on the GPU is called a **shader** program. We can
    write code to manipulate the geometry (position) of our graphics in what is called
    a **vertex shader**. We can also write code that manipulates the appearance of
    each and every pixel individually called a **fragment shader**.
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
  zh: 在GPU上运行的额外代码被称为**着色器**程序。我们可以在称为**顶点着色器**的地方编写代码来操纵我们图形的几何形状（位置）。我们还可以编写代码来单独操纵每个像素的外观，这被称为**片段着色器**。
- en: Note
  id: totrans-1588
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Actually, we can do better than even pixel manipulation. A fragment is not
    necessarily a pixel. It depends on the hardware and the specific nature of the
    graphics being processed. It can be more than one pixel or a sub-pixel: one light
    of several that makes up a pixel in the screen hardware.'
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们甚至可以做得比像素操作更好。片段不一定是像素。这取决于硬件和正在处理的图形的具体性质。它可能是一个以上的像素或亚像素：屏幕硬件中构成像素的几个光之一。
- en: The disadvantage of OpenGL ES 2 for simple games like this is that you must
    provide at least one vertex and one fragment shader, even if you are not going
    to do a whole lot with them. As we will see, however, this is not very difficult.
    Although we will not be exploring shaders in any depth, we will write some shader
    code using **GL Shader Language** (**GLSL**) and get a glimpse at the possibilities
    they offer.
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像这样的简单游戏，OpenGL ES 2的缺点是，即使你不会对它们做很多事情，也必须至少提供一个顶点着色器和一个片段着色器。然而，正如我们将看到的，这并不困难。尽管我们不会深入探讨着色器，但我们将编写一些着色器代码，使用**GL着色器语言**（**GLSL**），并一瞥它们提供的可能性。
- en: Tip
  id: totrans-1591
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If the power of programmable graphics pipelines and shaders is just too exciting
    to leave for another day, then I can highly recommend *GLSL Essentials* by Jacobo
    Rodríguez.
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可编程图形管道和着色器的力量太过激动人心，以至于无法留到另一天，那么我强烈推荐Jacobo Rodríguez的《GLSL Essentials》。
- en: '[https://www.packtpub.com/hardware-and-creative/glsl-essentials](https://www.packtpub.com/hardware-and-creative/glsl-essentials)'
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/hardware-and-creative/glsl-essentials](https://www.packtpub.com/hardware-and-creative/glsl-essentials)'
- en: The book explores OpenGL shaders on the desktop and is highly accessible to
    any reader with basic programming knowledge and a willingness to learn a different
    language (GLSL), yet one with some syntax similarities to Java.
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
  zh: 本书探讨了桌面上的OpenGL着色器，对任何具有基本编程知识并愿意学习不同语言（GLSL）的读者来说都易于理解，尽管它与Java有一些语法相似之处。
- en: How will we be using OpenGL ES 2?
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将如何使用OpenGL ES 2？
- en: How we will use OpenGL ES 2?
  id: totrans-1596
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们将如何使用OpenGL ES 2？
- en: In OpenGL, everything is a point, a line, or a triangle. In addition, we can
    attach colors and textures to this basic geometry and also combine these elements
    to make the complex graphics that we see in today's modern mobile games.
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenGL中，一切都是点、线或三角形。此外，我们还可以将颜色和纹理附加到这种基本几何形状，并将这些元素组合起来，以制作我们今天在现代移动游戏中看到的复杂图形。
- en: We will use some of each type of element (points, lines, and triangles) that
    are collectively referred to as primitives.
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用每种类型的一些元素（点、线和三角形），这些元素统称为原语。
- en: We will not be using textures on this project. Fortunately, the appearance of
    untextured primitives is appropriate for building our Asteroids-like game.
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们不会使用纹理。幸运的是，无纹理原语的外观非常适合构建类似Asteroids的游戏。
- en: In addition to primitives, Open GL uses matrices. **Matrices** are a method
    and structure for performing arithmetic. This arithmetic can range from extremely
    simple high-school level calculations to move (translate) a coordinate or it can
    be quite complex to perform more advanced mathematics to convert our game world
    coordinates into OpenGL screen coordinates that the GPU can use.
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
  zh: 除了原语之外，OpenGL还使用矩阵。**矩阵**是一种执行算术的方法和结构。这种算术可以从非常简单的中学水平计算（移动（平移）坐标）到执行更复杂的数学，将我们的游戏世界坐标转换为GPU可以使用的OpenGL屏幕坐标。
- en: The point is that both the matrices and methods to use them are entirely provided
    by the OpenGL API. This means that we just have to learn what methods do which
    graphical manipulation and do not have to concern ourselves with the potentially
    complex math that goes on behind the scenes (on the GPU).
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于OpenGL API完全提供了矩阵及其使用方法。这意味着我们只需要了解哪些方法执行哪些图形操作，而无需关心幕后（在GPU上）可能出现的复杂数学。
- en: The best way to learn about shaders, primitives, and matrices in OpenGL is to
    go ahead and start using them.
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenGL中了解着色器、原语和矩阵的最好方法就是直接开始使用它们。
- en: Preparing OpenGL ES 2
  id: totrans-1603
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备OpenGL ES 2
- en: First we start off with our `Activity` class, which as before is the entry point
    into our game. Create a new project and in the **Application Name** field enter
    `C9 Asteroids`. Choose **Phones and tablets**, then **Blank Activity** when prompted.
    In the **Activity Name** field type `AsteroidsActivity`.
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从`Activity`类开始，正如之前一样，它是我们游戏的入口点。创建一个新的项目，在**应用程序名称**字段中输入`C9 Asteroids`。选择**手机和平板电脑**，然后当提示时选择**空白活动**。在**活动名称**字段中输入`AsteroidsActivity`。
- en: Tip
  id: totrans-1605
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Obviously you don't have to follow my exact naming choices but just remember
    to make the minor alterations in code to reflect your own naming choices.
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你不必完全遵循我的命名选择，但请记住对代码进行一些小的修改，以反映你自己的命名选择。
- en: You can delete `activity_asteroids.xml` from the `layout` folder. You can also
    delete all the code within the `AsteroidsActivity.java` file. Just leave the package
    declaration.
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从`layout`文件夹中删除`activity_asteroids.xml`。你还可以从`AsteroidsActivity.java`文件中删除所有代码。只需留下包声明。
- en: Locking the layout to landscape
  id: totrans-1608
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 锁定布局为横屏
- en: 'Just as we did for the previous two projects, we will make sure the game runs
    in landscape mode only. We will make our `AndroidManifest.xml` file, force our
    `AsteroidsActivity` class to run with a full screen, and lock it to a landscape
    orientation. Let''s make these changes:'
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们为前两个项目所做的那样，我们将确保游戏只在横屏模式下运行。我们将修改我们的`AndroidManifest.xml`文件，强制我们的`AsteroidsActivity`类全屏运行，并将其锁定为横屏方向。让我们进行以下更改：
- en: Open the `manifests` folder now and double-click the `AndroidManifest.xml` file
    to open it in the code editor.
  id: totrans-1610
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开`manifests`文件夹，双击`AndroidManifest.xml`文件，在代码编辑器中打开它。
- en: 'In the `AndroidManifest.xml` file, find the following line of code:'
  id: totrans-1611
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AndroidManifest.xml`文件中，找到以下代码行：
- en: '[PRE317]'
  id: totrans-1612
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE317]'
- en: 'Immediately, type or copy and paste these two lines to make `PlatformActivity`
    run in full screen and lock it in the landscape orientation:'
  id: totrans-1613
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 立即输入或复制粘贴以下两行代码，使`PlatformActivity`全屏运行并锁定为横屏方向：
- en: '[PRE318]'
  id: totrans-1614
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE318]'
- en: Now we can move on to implementing our Asteroids simulator game with OpenGL.
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续用OpenGL实现我们的Asteroids模拟游戏了。
- en: Activity
  id: totrans-1616
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动
- en: 'First of all, we have our familiar `Activity` class. The only thing that is
    new here is the type of our view class. We declare a member called `asteroidsView`
    of type `GLSurfaceView`. This is the class that will provide us with easy access
    to OpenGL. We will see exactly how very soon. Note that all we do is initialize
    `GLSurfaceView` by passing in the `Activity` context and the screen resolution
    that we obtain in the usual manner. Implement the `AsteroidsActivity` class as
    shown:'
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有我们熟悉的`Activity`类。这里唯一的新事物是我们视图类的类型。我们声明了一个名为`asteroidsView`的成员，其类型为`GLSurfaceView`。这个类将为我们提供轻松访问OpenGL的途径。我们很快就会看到这一点。请注意，我们只是通过传递`Activity`上下文和以通常方式获得的屏幕分辨率来初始化`GLSurfaceView`。按以下方式实现`AsteroidsActivity`类：
- en: '[PRE319]'
  id: totrans-1618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: Next, we will get to see some OpenGL code.
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到一些OpenGL代码。
- en: The view
  id: totrans-1620
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图
- en: Here, we will implement the `GLSurfaceView` class. Actually, this isn't where
    the real action will take place but it does allow us to attach an OpenGL renderer.
    This is a class that implements the `Renderer` interface. As well as in this critical
    `Renderer`, the `GLSurfaceView` class enables us to override the `onTouchListener`
    method that will allow us to detect player input in the same way that `SurfaceView`
    did in the previous projects.
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将实现`GLSurfaceView`类。实际上，真正的动作不会在这里发生，但它确实允许我们附加一个OpenGL渲染器。这是一个实现了`Renderer`接口的类。同样，在这个关键的`Renderer`中，`GLSurfaceView`类使我们能够重写`onTouchListener`方法，这样我们就可以像在之前的项目中`SurfaceView`所做的那样检测玩家输入。
- en: Note
  id: totrans-1622
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Android Studio does not auto-import or even suggest all of the OpenGL imports
    required. Therefore, I included all of the imports for some classes in the code
    listings. In addition, you will note that sometimes we use static imports. This
    will make the code more readable too.
  id: totrans-1623
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio不会自动导入或甚至建议所有必需的OpenGL导入。因此，我在代码列表中包含了某些类的所有导入。此外，你还会注意到有时我们使用静态导入。这也会使代码更易于阅读。
- en: 'In the code that follows, we declare and initialize a new object of type `GameManager`
    that we will implement soon. We set the OpenGL version to two by calling `setEGLContextClientVersion(2)`,
    and we set our vital renderer object by calling `setRenderer()` and passing in
    our `GameManager` object. Create a new class called `AsteroidsView` and implement
    it as follows:'
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们声明并初始化了一个新的`GameManager`对象，我们将在不久后实现它。我们通过调用`setEGLContextClientVersion(2)`将OpenGL版本设置为2，并通过调用`setRenderer()`并传入我们的`GameManager`对象来设置我们的关键渲染器对象。创建一个名为`AsteroidsView`的新类，并按以下方式实现它：
- en: '[PRE320]'
  id: totrans-1625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: Now, we can take a look at what is involved in our `GameManager` class.
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看看我们的`GameManager`类涉及的内容。
- en: A class to manage our game
  id: totrans-1627
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理我们游戏的一个类
- en: This class will control things like the level the player is on, the number of
    lives, as well as things like the overall size of the game world. It will evolve
    a little as the project progresses, but it will remain quite simple in comparison
    to the combined depth of the LevelManager and PlayerState classes from the previous
    project, although it effectively replaces both.
  id: totrans-1628
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类将控制玩家所在的关卡、生命值以及游戏世界的整体大小等。随着项目的进展，它会有所发展，但与之前项目中`LevelManager`和`PlayerState`类的综合深度相比，它将保持相当简单，尽管它实际上取代了这两个类。
- en: In the code that follows, we declare `int` members to hold the width and height
    of the game world; we can make this much bigger or smaller as we see fit. We keep
    track of the games status with the Boolean `playing`.
  id: totrans-1629
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的代码中，我们声明`int`成员来保存游戏世界的宽度和高度；我们可以根据需要将其做得更大或更小。我们使用布尔值`playing`来跟踪游戏的状态。
- en: The `GameManager` class also needs to know the height and width of the screen
    in pixels, and this information is passed in to the constructor when the object
    is initialized back in the `AsteroidsView` class.
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameManager`类还需要知道屏幕的宽度和高度（以像素为单位），当对象在`AsteroidsView`类中初始化时，这个信息被传递给构造函数。'
- en: 'Note also the `metresToShowX` and `metresToShowY` member variables. These probably
    sound familiar from our `Viewport` class from the last project. These variables
    will be used for exactly the same thing: defining the current viewable area of
    the game world. This time, however, OpenGL will take care of what objects to clip
    before drawing (using a matrix). We will soon see where this happens.'
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意`metresToShowX`和`metresToShowY`成员变量。这些可能听起来与上一个项目中我们的`Viewport`类很熟悉。这些变量将被用于完全相同的目的：定义游戏世界的当前可视区域。然而，这一次，OpenGL将负责在绘制之前裁剪哪些对象（使用矩阵）。我们很快就会看到这是在哪里发生的。
- en: Note
  id: totrans-1632
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that although OpenGL takes care of clipping and scaling the area of the
    game world that we want to show, it doesn't have any effect on which objects are
    updated each frame. As we will see, however, this is just what we want for this
    game because we want all our objects to update themselves each frame, even when
    they are offscreen. Therefore, no `Viewport` class is necessary for this game.
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管OpenGL负责裁剪和缩放我们想要显示的游戏世界区域，但这不会影响每一帧更新哪些对象。然而，正如我们将看到的，这正是我们想要的游戏，因为我们希望所有对象在每一帧都更新自己，即使它们在屏幕之外。因此，这个游戏不需要`Viewport`类。
- en: 'Lastly, we want a convenient way to pause and unpause the game, and we provide
    this functionality with the `switchPlayingStatus` method. Create a new class called
    `GameManager` and implement it as shown:'
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们希望有一个方便的方法来暂停和恢复游戏，我们通过`switchPlayingStatus`方法提供这个功能。创建一个新的类，命名为`GameManager`，并按如下所示实现：
- en: '[PRE321]'
  id: totrans-1635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: We can now take our first look at these all powerful shaders and how we will
    manage them.
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以首次查看这些功能强大的着色器以及我们将如何管理它们。
- en: Managing simple shaders
  id: totrans-1637
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理简单的着色器
- en: An application can have many shaders. We can then attach different shaders to
    different game objects to create the desired effects.
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用程序可以有多个着色器。然后我们可以将不同的着色器附加到不同的游戏对象上，以创建所需的效果。
- en: We will only have one vertex and one fragment shader in this game. However,
    when you see how to attach a shader to primitives, it will be plain that it is
    simple to have more shaders.
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个游戏中，我们只会使用一个顶点着色器和一个片段着色器。然而，当你看到如何将着色器附加到原语时，你会明白拥有更多着色器是多么简单。
- en: First of all, we need the code for the shader that will be executed in the GPU.
  id: totrans-1640
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要在GPU上执行的着色器代码。
- en: Then we need to compile that code.
  id: totrans-1641
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们需要编译那段代码。
- en: Finally, we need to link together the two compiled shaders into a GL program.
  id: totrans-1642
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要将两个编译好的着色器链接成一个GL程序。
- en: As we implement this next simple class, we will see how we can bundle up this
    functionality into a single method call, which can be made by an object from our
    game and have the ready-to-run GL program returned to the game object. When we
    build our `GameObject` class later in the chapter, we will see how we use this
    GL program.
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现这个下一个简单的类时，我们将看到如何将这个功能捆绑成一个单独的方法调用，这个调用可以由我们的游戏对象执行，并将准备运行的GL程序返回给游戏对象。当我们在本章的后面构建`GameObject`类时，我们将看到如何使用这个GL程序。
- en: 'Let''s go ahead and implement the necessary three steps in a new class. Create
    a new class and call it `GLManager`. Add the static imports as shown here:'
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续在新的类中实现必要的三个步骤。创建一个新的类，并将其命名为`GLManager`。添加如下所示的静态导入：
- en: '[PRE322]'
  id: totrans-1645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: Next, we will add some public static final member variables that we can use
    in our `GameObject` class later in the chapter. Although we will see exactly how
    they work when we get around to using them, here is a quick preliminary explanation.
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一些可以在本章后面的 `GameObject` 类中使用的公共静态最终成员变量。虽然我们将在使用它们时看到它们的确切工作方式，但这里有一个快速的初步解释。
- en: '`COPONENTS_PER_VERTEX` is the number of values that will be used to represent
    a single vertex (point) in our primitives that will make up our game objects.
    As you can see, we initialize this to three coordinates: *x*, *y*, and *z*.'
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
  zh: '`COPONENTS_PER_VERTEX` 是将用于表示我们游戏对象中单个顶点（点）的值的数量。正如你所见，我们将其初始化为三个坐标：*x*、*y*
    和 *z*。'
- en: We also have `FLOAT_SIZE`, which is initialized to `4`. This is the number of
    bytes in a Java float. As we will see soon, OpenGL likes all its primitives passed
    into it in the form of a `ByteBuffer`. We need to make sure we are precise about
    where in the `ByteBuffer` each piece of information is.
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有 `FLOAT_SIZE`，其初始化为 `4`。这是 Java 中 `float` 类型的字节数。正如我们很快就会看到的，OpenGL 喜欢以
    `ByteBuffer` 的形式接收所有传入它的原型的数据。我们需要确保我们精确地知道 `ByteBuffer` 中每条信息的位置。
- en: 'Next, we declare `STRIDE` and initialize it to `COMPONENTS_PER_VERTEX * FLOAT_SIZE`.
    As OpenGL uses the float type to hold virtually all of the data it works with,
    `STRIDE` now equals the size in bytes of the data that represents a single vertex
    of an object. Go ahead and add these members at the top of the class:'
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明 `STRIDE` 并将其初始化为 `COMPONENTS_PER_VERTEX * FLOAT_SIZE`。由于 OpenGL 使用
    `float` 类型来存储它处理的所有数据，因此 `STRIDE` 现在等于表示单个顶点数据的字节数。请将这些成员添加到类的顶部：
- en: '[PRE323]'
  id: totrans-1650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: GLSL is a language in its own right and it also has its own types, and variables
    of those types can be utilized. Here, we declare and initialize some strings that
    we can use to refer to these variables more cleanly in our code.
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
  zh: GLSL 是一种独立的语言，它也有自己的类型，并且可以使用这些类型的变量。在这里，我们声明并初始化了一些字符串，我们可以在代码中更干净地引用这些变量。
- en: Discussion of these types is beyond the scope of this book, but simply explained
    they will represent a matrix (`u_matrix`), a location (`a_position`), and a color
    (`u_Color`). We will see examples of the actual GLSL types these variables are
    in our shader code very soon.
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的讨论超出了本书的范围，但简单来说，它们将代表一个矩阵（`u_matrix`）、一个位置（`a_position`）和一个颜色（`u_Color`）。我们很快将在着色器代码中看到这些变量实际是哪种
    GLSL 类型。
- en: After the strings, we declare three `int` types. These three public static (but
    not final) members will be used to store the location of there namesake types
    within our shaders. This allows us to manipulate the values within the shader
    program before we give OpenGL the final instruction to draw our primitives.
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
  zh: 在字符串之后，我们声明了三个 `int` 类型的变量。这三个公共静态（但不是最终）成员将用于存储我们着色器中同名类型的存储位置。这允许我们在将最终绘制原型的指令交给
    OpenGL 之前，在着色器程序中操作这些值。
- en: '[PRE324]'
  id: totrans-1654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: At last, we come to our GLSL code that is a vertex shader packed up in a string.
    Note that we declare a variable called `u_Matrix` of type uniform `mat4` and `a_Position`
    of type attribute `vec4`. We will see in our `GameObject` class later how to get
    the locations of these variables to enable us to pass in values for them from
    our Java code.
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到了我们的 GLSL 代码，它是一个打包在字符串中的顶点着色器。注意，我们声明了一个名为 `u_Matrix` 的变量，其类型为 `uniform
    mat4`，以及一个名为 `a_Position` 的变量，其类型为 `attribute vec4`。我们将在后面的 `GameObject` 类中看到如何获取这些变量的位置，以便我们能从
    Java 代码中传递它们的值。
- en: 'The line in the code that starts with `void main()` is were the actual shader
    code executes from. Note that `gl_position` is assigned the value of the product
    of the two variables we just declared. Also `gl_PointSize` is assigned the value
    of `3.0`. This will be the size we draw all our point primitives. Enter the code
    for the vertex shader right after the previous block of code:'
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中以 `void main()` 开头的行是实际着色器代码执行的地方。注意，`gl_position` 被分配了我们刚才声明的两个变量的乘积的值。同样，`gl_PointSize`
    被分配了 `3.0` 的值。这将是我们绘制所有点原型的尺寸。在上一段代码块之后直接输入顶点着色器的代码：
- en: '[PRE325]'
  id: totrans-1657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: Next, we will implement the fragment shader. A few things are happening here.
    First, the line precision `mediump` float tells OpenGL to draw with medium precision
    and therefore medium speed. Then we can see our variable `u_Color` being declared
    to type uniform `vec4`. We will see how we can pass a `color` value to this variable
    in the `GameObject` class soon.
  id: totrans-1658
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现片段着色器。这里发生了一些事情。首先，行精度 `mediump` float 告诉 OpenGL 以中等精度绘制，因此速度中等。然后我们可以看到我们的变量
    `u_Color` 被声明为类型 `uniform vec4`。我们将在后面的 `GameObject` 类中看到如何将 `color` 值传递给这个变量。
- en: When execution begins at `void main()`, we simply assign `u_Color` to `gl_FragColor`.
    So, whatever color is assigned to `u_Colour`, all the fragments will be that color.
    Just after the fragment shader, we declare an `int` called `program` that will
    act as a handle to our GL program.
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行从`void main()`开始时，我们只需将`u_Color`赋值给`gl_FragColor`。所以，无论分配给`u_Colour`的颜色是什么，所有片段都将具有该颜色。在片段着色器之后，我们声明一个名为`program`的`int`，它将作为我们的GL程序的句柄。
- en: 'Enter the code for the fragment shader right after the previous block of code:'
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一段代码块之后立即输入片段着色器的代码：
- en: '[PRE326]'
  id: totrans-1661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: 'This is a getter method that returns a handle to the GL program:'
  id: totrans-1662
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个获取方法，它返回GL程序的句柄：
- en: '[PRE327]'
  id: totrans-1663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: This next method may look complex, but all it does is return a compiled and
    linked program to the caller. It does so by calling the OpenGL's `linkProgram`
    method with `compileVertexShader()` and `compileFragmentShader()` as arguments.
    Next, we see these two new methods and that all they need to do is call our method
    `compileShader()` with the OpenGL constant representing the type of shader and
    the appropriate string that holds the matching shader GLSL code.
  id: totrans-1664
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法可能看起来很复杂，但它所做的只是返回一个编译和链接好的程序给调用者。它是通过调用OpenGL的`linkProgram`方法，并将`compileVertexShader()`和`compileFragmentShader()`作为参数来实现的。接下来，我们看到这两个新方法，它们只需要调用我们的`compileShader()`方法，并使用OpenGL常量表示着色器类型和适当的字符串，该字符串包含匹配的GLSL着色器代码。
- en: 'Enter the three methods that we have just discussed into the `GLManager` class:'
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们刚才讨论的三个方法放入`GLManager`类中：
- en: '[PRE328]'
  id: totrans-1666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: 'Now we see what happens when our methods called `compileShader()`. First, we
    create a handle to a shader based on the `type` parameter. Then, we pass in that
    handle and the code to `glShaderSource()`. Finally, we compile the shader with
    `glCompileShader()` and return a handle to the calling method:'
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看到当我们的方法`compileShader()`被调用时会发生什么。首先，我们根据`type`参数创建一个着色器的句柄。然后，我们将该句柄和代码传递给`glShaderSource()`。最后，我们使用`glCompileShader()`编译着色器，并返回一个调用方法的句柄：
- en: '[PRE329]'
  id: totrans-1668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: 'Now we can see the final step in the process. We create an empty program with
    `glCreateProgram()`. Then we attach each of the compiled shaders in turn with
    `glAttachShader()`, and finally link them into a program we can actually use with
    `glLinkProgram()`:'
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到这个过程中的最后一步。我们使用`glCreateProgram()`创建一个空的程序。然后我们依次使用`glAttachShader()`将编译好的着色器附加到程序上，最后使用`glLinkProgram()`将它们链接成一个我们可以实际使用的程序：
- en: '[PRE330]'
  id: totrans-1670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: Note that we created a program and we have access to it via its handle and the
    `getProgram` method. We also have access to all those public static members we
    created, so we will be able to tinker with the variables in the shader programs
    from our Java code.
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们创建了一个程序，并且我们可以通过其句柄和`getProgram`方法访问它。我们还可以访问我们创建的所有公共静态成员，因此我们将能够从我们的Java代码中调整着色器程序中的变量。
- en: The game's main loop – the renderer
  id: totrans-1672
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏的主循环——渲染器
- en: 'Now we will see where the real meat of our code will go. Create a new class
    and call it `AsteroidsRenderer`. This is the class that we attached as our renderer
    to the `GLSurfaceView`. Add the import statements as follows, noting that some
    of them are static:'
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看到我们的代码真正的主要内容所在。创建一个新的类，并将其命名为`AsteroidsRenderer`。这是我们附加到`GLSurfaceView`上的渲染器类。添加以下导入语句，注意其中一些是静态的：
- en: '[PRE331]'
  id: totrans-1674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: Now we will build the class. The first thing to note that we have mentioned
    before is that the class implements `Renderer`, so we need to override three methods.
    They are `onSurfaceCreated()`, `onSurfaceChanged()`, and `onDrawFrame()`. Also,
    into this class, we will initially add a constructor to get everything set up,
    a `createObjects` method where we will eventually initialize all our game objects,
    an `update` method were we will update all our objects each frame, and a `draw`
    method were we will draw all our objects each frame.
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将构建类。首先要注意的是，我们之前已经提到过，这个类实现了`Renderer`接口，因此我们需要重写三个方法。它们是`onSurfaceCreated()`、`onSurfaceChanged()`和`onDrawFrame()`。此外，我们还将在这个类中最初添加一个构造函数来设置一切，一个`createObjects`方法，我们将最终在其中初始化所有游戏对象，一个`update`方法，我们将每帧更新所有对象，以及一个`draw`方法，我们将每帧绘制所有对象。
- en: We will explore and explain each method as we implement it, and we will also
    see how our methods fit in to the OpenGL renderer system, which dictates the flow
    of this class.
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在实现每个方法时探索和解释它，我们还将看到我们的方法如何适应OpenGL渲染器系统，该系统决定了这个类的流程。
- en: To get started, we have some member variables that are worth looking at quite
    closely.
  id: totrans-1677
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们有一些成员变量值得仔细查看。
- en: The Boolean debugging will be used to toggle output to the console on and off.
    The `frameCounter`, `averageFPS`, and `fps` variables will not only be used for
    checking what frame rates we are reaching but also for passing to our game objects
    that will update themselves based on the elapsed time each frame.
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔调试将用于在控制台开启和关闭输出。`frameCounter`、`averageFPS` 和 `fps` 变量不仅用于检查我们达到的帧率，还将传递给我们的游戏对象，这些对象将根据每一帧的经过时间自行更新。
- en: Our first really interesting variable is the float array `viewportMatrix`. As
    the name suggests, it will hold a matrix that OpenGL can use to calculate the
    viewport into our game world.
  id: totrans-1679
  prefs: []
  type: TYPE_NORMAL
  zh: 我们第一个真正有趣的变量是浮点数组 `viewportMatrix`。正如其名所示，它将保存一个 OpenGL 可以用来计算游戏世界视口的矩阵。
- en: We have a `GameManager` to hold a reference to the `GameManager` object, that
    `AsteroidsView` passed into this class's constructor. Finally, we have two `PointF`
    objects.
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个 `GameManager` 来保存对 `GameManager` 对象的引用，这是 `AsteroidsView` 传递给这个类构造函数的。最后，我们有两个
    `PointF` 对象。
- en: We will initialize the `PointF` objects in the constructor and use them for
    a few different things to avoid dereferencing any objects in the main game loop.
    When the garbage collector starts cleaning up discarded objects, even OpenGL will
    slow down. Avoiding summoning the garbage collector will be a goal for the entire
    game.
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在构造函数中初始化 `PointF` 对象，并使用它们做几件不同的事情，以避免在主游戏循环中解引用任何对象。当垃圾收集器开始清理丢弃的对象时，即使是
    OpenGL 也会变慢。避免召唤垃圾收集器将是整个游戏的目标。
- en: 'Enter the member variables at the top of the `AsteroidsRenderer` class:'
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `AsteroidsRenderer` 类的顶部输入成员变量：
- en: '[PRE332]'
  id: totrans-1683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: 'Here is our constructor, where we initialize our `GameManager` reference from
    the parameter and create our two handy `PointF` objects ready for use:'
  id: totrans-1684
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的构造函数，其中我们从参数初始化我们的 `GameManager` 引用，并创建两个便于使用的 `PointF` 对象以供使用：
- en: '[PRE333]'
  id: totrans-1685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: This is the first overridden method. It is called every time a `GLSurfaceView`
    class with attached renderer is created. We call `glClearColor()` to set which
    color OpenGL will use each time it clears the screen. We then build our shader
    program using our `GLManager.buildProgram()` method and call our `createObjects`
    method that we will code soon.
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一个重写的方法。每次创建带有附加渲染器的 `GLSurfaceView` 类时都会调用它。我们调用 `glClearColor()` 来设置 OpenGL
    每次清除屏幕时将使用的颜色。然后我们使用我们的 `GLManager.buildProgram()` 方法构建着色器程序，并调用我们即将编写的 `createObjects`
    方法。
- en: '[PRE334]'
  id: totrans-1687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: This next overridden method is called once after `onSurfaceCreated()` and any
    time the screen orientation changes. Here, we call the `glViewport()` method to
    tell OpenGL the pixel coordinates to map the OpenGL coordinate system onto.
  id: totrans-1688
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个重写的方法是在 `onSurfaceCreated()` 之后一次调用，以及屏幕方向改变时。在这里，我们调用 `glViewport()` 方法告诉
    OpenGL 将像素坐标映射到 OpenGL 坐标系上。
- en: The OpenGL coordinate system is very different from the pixel coordinates we
    are used to deal with in the previous two projects. The center of the screen is
    0,0, the left and bottom are -1, and the top and right are 1.
  id: totrans-1689
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL 坐标系与我们之前在两个项目中习惯处理的像素坐标系非常不同。屏幕中心是 0,0，左侧和底部是 -1，顶部和右侧是 1。
- en: '![The game''s main loop – the renderer](img/B04322_09_01.jpg)'
  id: totrans-1690
  prefs: []
  type: TYPE_IMG
  zh: '![游戏的主循环 – 渲染器](img/B04322_09_01.jpg)'
- en: The preceding situation is further complicated by the fact that most screens
    are not square, yet the range -1 to 1 must represent both *x* and *y* axes. Fortunately,
    our `glViewport()` has dealt with this for us.
  id: totrans-1691
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的情况还进一步复杂化，因为大多数屏幕不是正方形，但范围 -1 到 1 必须代表 *x* 和 *y* 轴。幸运的是，我们的 `glViewport()`
    已经为我们处理了这个问题。
- en: The last thing we see in this method is calling the `orthoM` method with our
    `viewportMatrix` as the first parameter. OpenGL will now prepare `viewportMatrix`
    for use within OpenGL itself. The method `orthoM()` creates a matrix to convert
    coordinates into an orthographic view. If our coordinates are three-dimensional,
    it will have the effect of making all the objects appear the same distance away.
    As we are making a two-dimensional game, this is also suitable for us.
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中我们看到最后一件事情是调用 `orthoM` 方法，并将 `viewportMatrix` 作为第一个参数。OpenGL 现在将为 OpenGL
    本身准备 `viewportMatrix` 以供使用。`orthoM` 方法创建一个矩阵，将坐标转换为正交视图。如果我们的坐标是三维的，它将产生所有对象看起来距离相同的效果。由于我们正在制作一个二维游戏，这也适合我们。
- en: 'Enter the code for the `onSurfaceChanged` method:'
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 `onSurfaceChanged` 方法的代码：
- en: '[PRE335]'
  id: totrans-1694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: 'Here is our `createObjects` method and, as you can see, we create an object
    of type `SpaceShip` and pass in the map height and width to the constructor. We
    will build the `SpaceShip` class and its parent class `GameObject` later in this
    chapter. Enter the `createObjects` method:'
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的`createObjects`方法，如您所见，我们创建了一个类型为`SpaceShip`的对象，并将地图的高度和宽度传递给构造函数。我们将在本章后面构建`SpaceShip`类及其父类`GameObject`。输入`createObjects`方法：
- en: '[PRE336]'
  id: totrans-1696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: This is the overridden `onDrawFrame` method. It is called continuously by the
    system. We can control when this is called by setting a render mode when we attach
    the `AsteroidsRenderer` to the view but the default OpenGL controlled continuous
    calling is exactly what we need.
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
  zh: 这是重写的`onDrawFrame`方法。它被系统连续调用。当我们把`AsteroidsRenderer`附加到视图上时，我们可以控制这个方法的调用时间，但默认的OpenGL控制的连续调用正是我们所需要的。
- en: We set `startFrameTime` to whatever the current system time is. Then, if `isPlaying()`
    returns `true`, we call our soon-to-be-implemented `update` method. Then, we call
    `draw()`, which will tell all of our objects to draw themselves.
  id: totrans-1698
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`startFrameTime`设置为当前系统时间。然后，如果`isPlaying()`返回`true`，我们调用我们即将实现的`update`方法。然后，我们调用`draw()`，这将告诉所有我们的对象绘制自己。
- en: We then update `timeThisFrame` and `fps` optionally outputting the average frames
    per second, every 100 frames, if we are debugging.
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们更新`timeThisFrame`和`fps`，可选地输出每100帧的平均帧数，如果我们在调试的话。
- en: Now we know that OpenGL will call `onDrawFrame()` up to hundreds of times per
    second. We will conditionally call our `update` method each time as well as call
    our `draw` method. We have effectively implemented our game loop apart from the
    actual `draw` and update methods themselves.
  id: totrans-1700
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道OpenGL会每秒调用`onDrawFrame()`数百次。我们将有条件地每次调用我们的`update`方法以及调用我们的`draw`方法。我们实际上已经实现了游戏循环，除了实际的`draw`和`update`方法本身。
- en: 'Add the `onDrawFrame` method to the class:'
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
  zh: 将`onDrawFrame`方法添加到类中：
- en: '[PRE337]'
  id: totrans-1702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: 'Here is our `update` method, leave an empty body for now:'
  id: totrans-1703
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的`update`方法，目前先留一个空体：
- en: '[PRE338]'
  id: totrans-1704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: Now, we come to our `draw` method, which is called once per frame from the `onDrawFrame`
    method. Here, we load up the ships current location into one of our handy `PointF`
    objects. Clearly, as we haven't implemented our `SpaceShip` class yet, this method
    call will produce an error.
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来到我们的`draw`方法，它由`onDrawFrame`方法每帧调用一次。在这里，我们将飞船的当前位置加载到我们手头的`PointF`对象之一中。显然，因为我们还没有实现我们的`SpaceShip`类，这个方法调用将产生错误。
- en: The next thing we do in `draw()` is quite interesting. We modify our `viewportMatrix`
    based on the current location in the game world and the values assigned to `metresToShowX`
    and `metresToShowY`. Simply, we are centering on wherever the ship is and extending
    out by half the distance we wish to show in all four directions. Remember that,
    this happens in every frame, so our viewport will constantly follow the player
    ship.
  id: totrans-1706
  prefs: []
  type: TYPE_NORMAL
  zh: 在`draw()`方法中我们接下来要做的事情非常有趣。我们根据游戏世界中的当前位置和分配给`metresToShowX`和`metresToShowY`的值修改我们的`viewportMatrix`。简单来说，我们是在以飞船为中心，向所有四个方向延伸出我们希望显示距离的一半。记住，这发生在每一帧，所以我们的视口将始终跟随玩家飞船。
- en: Next, we call `glClear()` to clear the screen with the color we set in `onSurfaceCreated()`.
    The last thing we do in `draw()` is call a `draw` method on our `SpaceShip` object.
    This implies quite a fundamental design change from both of our previous games.
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用`glClear()`使用在`onSurfaceCreated()`中设置的颜色清除屏幕。在`draw()`方法中我们做的最后一件事是在我们的`SpaceShip`对象上调用一个`draw`方法。这暗示了与我们的前两个游戏相比，有一个相当基本的设计变化。
- en: 'We mentioned this already, but here we can see it in action: each object will
    draw itself. Also, notice that we pass in our newly configured `viewportMatrix`.'
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到过这一点，但在这里我们可以看到它是如何运作的：每个对象都会绘制自己。同时，请注意我们传递了新配置的`viewportMatrix`。
- en: 'Enter the code for the `draw` method:'
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`draw`方法的代码：
- en: '[PRE339]'
  id: totrans-1710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: Now, we can build our `GameObject` super class, closely followed by its first
    child, `SpaceShip`. We will see how these objects will manage to use OpenGL to
    draw themselves.
  id: totrans-1711
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以构建我们的`GameObject`超级类，紧接着是其第一个子类`SpaceShip`。我们将看到这些对象如何使用OpenGL来绘制自己。
- en: Building an OpenGL-friendly, GameObject super class
  id: totrans-1712
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个OpenGL友好的GameObject超级类
- en: Let's dive straight into the code. As we will see, this `GameObject` will have
    a lot in common with the `GameObject` class from the previous project. The most
    significant difference will be that this latest `GameObject` will of course draw
    itself using a handle to the GL program, primitive (vertex) data from a child
    class, and the viewport matrix contained in `viewportMatrix`.
  id: totrans-1713
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接进入代码。正如我们将看到的，这个 `GameObject` 将与上一个项目中的 `GameObject` 类有很多共同之处。最显著的区别是，这个最新的
    `GameObject` 将当然使用 GL 程序的句柄、子类中的原始（顶点）数据以及包含在 `viewportMatrix` 中的视口矩阵来自动绘制。
- en: 'Create a new class, call it `GameObject`, and enter these import statements,
    noting again that that some of them are static:'
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的类，命名为 `GameObject`，并输入以下导入语句，注意其中一些是静态的：
- en: '[PRE340]'
  id: totrans-1715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: There are lots of member variables, many are self-explanatory and commented
    just to refresh our memories, but there are some totally new ones as well.
  id: totrans-1716
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多成员变量，其中许多是自解释的，注释只是为了刷新我们的记忆，但也有一些是完全新的。
- en: For example, we have an `enum` to represent each type of `GameObject` we will
    create. The reason for this is we will draw some objects as points, some as lines,
    and one as a triangle. The way that we use OpenGL is consistent between different
    types of primitive; hence, it is why we have bundled the code into this parent
    class. However, the final call to draw the primitive varies dependent on the type
    of primitive. We can use the `type` variable in a `switch` statement to execute
    the correct type of a `draw` method.
  id: totrans-1717
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们有一个 `enum` 来表示我们将创建的每种 `GameObject` 类型。这样做的原因是我们将绘制一些对象为点，一些为线，一个为三角形。我们使用
    OpenGL 的方式在不同类型的原始数据之间是一致的；因此，这就是为什么我们将代码打包在这个父类中。然而，最终绘制原始数据的调用取决于原始数据的类型。我们可以使用
    `type` 变量在 `switch` 语句中执行正确的 `draw` 方法类型。
- en: We also have an `int numElements` and `numVertices` that holds the number of
    points that make up any given `GameObject`. These will be set from the child class
    as we will see soon.
  id: totrans-1718
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个 `int numElements` 和 `numVertices`，它们保存构成任何给定 `GameObject` 的点的数量。这些将在我们很快就会看到的子类中设置。
- en: We have another float array called `modelVertices`, which will hold all the
    vertices that make up a model.
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个名为 `modelVertices` 的浮点数组，它将保存构成模型的所有顶点。
- en: 'Enter the first batch of member variables in the `GameObject` class and take
    a look at the comments to refresh your memory or make clear what the various members
    will eventually be used for:'
  id: totrans-1720
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `GameObject` 类中输入第一组成员变量，并查看注释以刷新记忆或明确各种成员最终将用于什么：
- en: '[PRE341]'
  id: totrans-1721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: Next, we will add another batch of member variables. First, and most notably,
    we have a `FloatBuffer` called `vertices`. As we know, OpenGL executes in native
    code and `FloatBuffers` are how it likes to consume its data. We will see how
    we pack all our vertices into this `FloatBuffer`.
  id: totrans-1722
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加另一批成员变量。首先，也是最重要的，我们有一个名为 `vertices` 的 `FloatBuffer`。正如我们所知，OpenGL
    在本地代码中执行，`FloatBuffers` 是它喜欢消费数据的方式。我们将看到如何将所有顶点打包到这个 `FloatBuffer` 中。
- en: We will also use all the public static members from our `GLManager` class to
    help us get it right.
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用 `GLManager` 类中的所有公共静态成员来帮助我们正确实现。
- en: Probably the second most interesting new member where OpenGL is concerned is
    we have another three float arrays called `modelMatrix`, `viewportModelMatrix`,
    and `rotateViewportModelMatrix`. These will be instrumental in helping OpenGL
    to draw the `GameObject` class exactly as required. We will examine exactly how
    they are initialized and used when we get to the `draw` method of this class.
  id: totrans-1724
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OpenGL 方面，第二有趣的新成员可能是我们还有另外三个名为 `modelMatrix`、`viewportModelMatrix` 和 `rotateViewportModelMatrix`
    的浮点数组。这些将在帮助 OpenGL 准确绘制 `GameObject` 类时发挥关键作用。当我们到达这个类的 `draw` 方法时，我们将详细检查它们是如何初始化和使用的。
- en: 'We also have a bunch of members that hold different angles and rotation rates.
    How we use and update these in order to inform OpenGL of the orientation of our
    objects, we will see soon:'
  id: totrans-1725
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一些成员变量，用于保存不同的角度和旋转速率。我们将很快看到我们如何使用和更新这些变量，以便通知 OpenGL 我们对象的朝向：
- en: '[PRE342]'
  id: totrans-1726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: We now implement the constructor. First, we check if we have previously compiled
    the shaders, because we only need to do it once. If we haven't, this is what happens
    inside the `if(glProgarm == -1)` block.
  id: totrans-1727
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在实现构造函数。首先，我们检查是否已经编译了着色器，因为我们只需要做一次。如果没有，这就是 `if(glProgram == -1)` 块内的内容。
- en: We call `setGLProgram()` followed by `glUseProgram()` with `glProgram` as the
    argument. That is all we have to do, `GLManager` does the rest and our OpenGL
    program is ready to use.
  id: totrans-1728
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用 `setGLProgram()`，然后使用 `glUseProgram()` 并将 `glProgram` 作为参数。这就是我们必须要做的，`GLManager`
    会完成其余的工作，我们的 OpenGL 程序就准备好了。
- en: Before we go on, however, we save the locations of our key shader variables
    by calling the respective methods (`glGetUniformLocation()` and `glGetAttrtibuteLocation`)
    to get their locations within our GL program. We will see in the `draw` method
    of this class how we use those locations to manipulate values within the shaders.
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们通过调用相应的方法（`glGetUniformLocation()` 和 `glGetAttrtibuteLocation`）来保存我们的关键着色器变量的位置，以获取它们在
    GL 程序中的位置。我们将在该类的 `draw` 方法中看到我们如何使用这些位置来操作着色器中的值。
- en: 'Finally, we set `isActive` to `true`. Enter this method into the `GameObject`
    class:'
  id: totrans-1730
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将 `isActive` 设置为 `true`。将此方法输入到 `GameObject` 类中：
- en: '[PRE343]'
  id: totrans-1731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: Now we have a few getters and setters including `getWorldLocation()`, which
    we called from the `draw` method in `AsteroidsRenderer` and `setGLProgram()`.
    This uses the `GLManager` class's static method `getGLProgram()` to get the handle
    to our GL program.
  id: totrans-1732
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有几个获取器和设置器，包括 `getWorldLocation()`，我们在 `AsteroidsRenderer` 的 `draw` 方法中调用它，以及
    `setGLProgram()`。这使用了 `GLManager` 类的静态方法 `getGLProgram()` 来获取我们的 GL 程序句柄。
- en: 'Enter all these methods into the `GameObject` class:'
  id: totrans-1733
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些方法输入到 `GameObject` 类中：
- en: '[PRE344]'
  id: totrans-1734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: The next method, `setVertices()` is a vital step in preparing an object to be
    drawn by OpenGL. In each of our child classes, we will build an array of float
    types to represent the vertices that make up the shape of the game object. Each
    game object will obviously be different in shape, but the `setVertices` method
    does not need to appreciate the difference, it just needs the data.
  id: totrans-1735
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法 `setVertices()` 是准备对象以便 OpenGL 绘制的重要步骤。在我们的每个子类中，我们将构建一个浮点数数组来表示构成游戏对象形状的顶点。显然，每个游戏对象的形状都是不同的，但
    `setVertices` 方法不需要理解这种差异，它只需要数据。
- en: As we can see in the next block of code, the method receives a float array as
    a parameter. It then stores the number of elements that is equal to the length
    of the array in `numElements`. Note that the number of elements is different from
    the number of vertices the elements represent. It takes three elements (*x*, *y*,
    and *z*) to make one vertex. Therefore, we can store into `numVertices` the correct
    value by dividing `numElements` by `ELEMENTS_PER_VERTEX`.
  id: totrans-1736
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们可以在下一块代码中看到，该方法接收一个浮点数组作为参数。然后，它在 `numElements` 中存储与数组长度相等的元素数量。请注意，元素的数量与表示的顶点数量不同。需要一个
    (*x*，*y*，和 *z*) 元素来构成一个顶点。因此，我们可以通过将 `numElements` 除以 `ELEMENTS_PER_VERTEX` 来将正确的值存储到
    `numVertices` 中。
- en: Now we can actually initialize up our `ByteBuffer` by calling `allocateDirect()`
    and passing in our newly initialized variables along with `FLOAT_SIZE`. The `ByteOrder.nativeOrder`
    method simply detects if the particular system's endianness, and `asFloatBuffer()`
    tells `ByteBuffer` the type of data that will stored. We can now store our array
    of vertices into our vertices `ByteBuffer` by calling `vertices.put(modelVertices)`.
    This data is now ready to be passed to OpenGL.
  id: totrans-1737
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过调用 `allocateDirect()` 并传入我们新初始化的变量以及 `FLOAT_SIZE` 来实际初始化我们的 `ByteBuffer`。`ByteOrder.nativeOrder`
    方法简单地检测特定系统的端序，而 `asFloatBuffer()` 告诉 `ByteBuffer` 将存储的数据类型。现在，我们可以通过调用 `vertices.put(modelVertices)`
    将我们的顶点数组存储到顶点 `ByteBuffer` 中。这些数据现在已准备好传递给 OpenGL。
- en: Tip
  id: totrans-1738
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'If you want to learn more about endianness, take a look at this Wikipedia article:'
  id: totrans-1739
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于端序的信息，请查看这篇维基百科文章：
- en: '[http://en.wikipedia.org/wiki/Endianness](http://en.wikipedia.org/wiki/Endianness)'
  id: totrans-1740
  prefs: []
  type: TYPE_NORMAL
  zh: '[端序](http://en.wikipedia.org/wiki/Endianness)'
- en: 'Enter the `setVertices` method into the `GameObject` class:'
  id: totrans-1741
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `setVertices` 方法输入到 `GameObject` 类中：
- en: '[PRE345]'
  id: totrans-1742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: Now we get to see how we actually draw the contents of our `ByteBuffer`. At
    a glance, the following code may look complex, but when we discuss the nature
    of the data in our `ByteBuffer` and the steps that OpenGL goes through to draw
    this data, we will see that it is actually quite straightforward.
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到我们实际上是如何绘制 `ByteBuffer` 的内容的。乍一看，以下代码可能看起来很复杂，但当我们讨论 `ByteBuffer` 中数据的性质以及
    OpenGL 绘制这些数据所经过的步骤时，我们会发现它实际上非常直接。
- en: As we have not written the code for our first `GameObject` child class, there
    is one key thing to point out. The vertices that represent the shape of a game
    object are zero based on its own center.
  id: totrans-1744
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们尚未编写第一个 `GameObject` 子类的代码，有一件关键的事情要指出。表示游戏对象形状的顶点是以其自身的中心为零基准的。
- en: 'The OpenGL coordinate system has **0,0** as its center but, to make it clear,
    this is not related. This is called model space. The next image is a representation
    of our spaceship, in model space, that we will soon create:'
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL坐标系统的中心是**0,0**，但为了清楚起见，这与它无关。这被称为模型空间。下一张图是我们即将创建的宇宙飞船在模型空间中的表示：
- en: '![Building an OpenGL-friendly, GameObject super class](img/B04322_09_02.jpg)'
  id: totrans-1746
  prefs: []
  type: TYPE_IMG
  zh: '![构建一个OpenGL友好的GameObject超级类](img/B04322_09_02.jpg)'
- en: It is this data that is contained within our `ByteBuffer`. This data takes no
    account of orientation (is the ship or asteroid rotated), it takes no account
    of its position in the game world and, as a reminder, it is totally unrelated
    to the OpenGL coordinate system.
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们`ByteBuffer`中包含的数据。这些数据不考虑方向（飞船或小行星是否旋转），不考虑其在游戏世界中的位置，并且作为提醒，它与OpenGL坐标系统完全无关。
- en: Therefore, before we draw our `ByteBuffer`, we need to convert this data, or,
    more accurately, we need to prepare an appropriate matrix, which we will pass
    into OpenGL with the data so that OpenGL will know how to use or convert the data.
  id: totrans-1748
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们绘制`ByteBuffer`之前，我们需要转换这些数据，或者更准确地说，我们需要准备一个适当的矩阵，我们将这个矩阵与数据一起传递给OpenGL，这样OpenGL就会知道如何使用或转换这些数据。
- en: I have split the `draw` method up into six chunks to talk about how we do this.
    Note that our `viewPort` matrix is prepared in our `AsteroidsRenderer` class's
    `draw` method, which is centered upon the location of the ship and based around
    the proportion of game world we want to show and is passed in as a parameter.
  id: totrans-1749
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经将`draw`方法分成六个部分来讨论我们是如何做到这一点的。请注意，我们的`viewPort`矩阵是在`AsteroidsRenderer`类的`draw`方法中准备的，该方法以飞船的位置为中心，基于我们想要显示的游戏世界的比例，并作为参数传递。
- en: First, we call `glUseProgram()` and pass in the handle to our program. Then
    we set the internal pointer of our `ByteBuffer` to the start with `vertices.position(0)`.
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们调用`glUseProgram()`并传入我们程序的句柄。然后我们通过`vertices.position(0)`将我们的`ByteBuffer`的内部指针设置到开始位置。
- en: 'The `glVertexAttributePointer` method uses our `aPositionLocation` variable
    along with our `GLManager` static constants and of course the `vertices` `ByteBuffer`
    to associate our vertices with the `aPosition` variable in the vertex shader.
    Finally, for this chunk of code, we tell OpenGL to enable the attribute array:'
  id: totrans-1751
  prefs: []
  type: TYPE_NORMAL
  zh: '`glVertexAttributePointer`方法使用我们的`aPositionLocation`变量以及`GLManager`静态常量，当然还有`vertices`
    `ByteBuffer`，将我们的顶点与顶点着色器中的`aPosition`变量关联起来。最后，对于这段代码，我们告诉OpenGL启用属性数组：'
- en: '[PRE346]'
  id: totrans-1752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: Now, we put our matrices to work. We create an identity matrix out of our `modelMatrix`
    array by calling `setIndentityM()`.
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将我们的矩阵投入使用。通过调用`setIndentityM()`，我们从`modelMatrix`数组中创建一个单位矩阵。
- en: Note
  id: totrans-1754
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As we will see, we are going to be using and combining quite a lot of matrices.
    An identity matrix acts as a starting point or container on which we can build
    a matrix, which combines all the transformations that we need to occur. A very
    simple but not entirely accurate way of thinking about an identity matrix is that
    it is like the number 1\. When you multiply by an identity matrix, it doesn't
    cause any alteration to the other part of the sum. However, the answer is correct
    for moving on to the next part of the equation. If this is annoying you and you
    want to know more, take a look at these really quick tutorials on matrices and
    the identity matrix.
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将要看到的，我们将使用和组合相当多的矩阵。一个单位矩阵充当一个起点或容器，我们可以在此基础上构建一个矩阵，该矩阵结合了我们需要的所有变换。关于单位矩阵的一个非常简单但并不完全准确的想法是，它就像数字1。当你乘以一个单位矩阵时，它不会对总和的其他部分造成任何改变。然而，这个答案是正确的，可以继续进行方程的下一部分。如果你感到烦恼并且想了解更多，请查看这些关于矩阵和单位矩阵的快速教程。
- en: 'Matrices:'
  id: totrans-1756
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵：
- en: '[https://www.khanacademy.org/math/precalculus/precalc-matrices/Basic_matrix_operations/v/introduction-to-the-matrix](https://www.khanacademy.org/math/precalculus/precalc-matrices/Basic_matrix_operations/v/introduction-to-the-matrix)'
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.khanacademy.org/math/precalculus/precalc-matrices/Basic_matrix_operations/v/introduction-to-the-matrix](https://www.khanacademy.org/math/precalculus/precalc-matrices/Basic_matrix_operations/v/introduction-to-the-matrix)'
- en: 'Identity matrix:'
  id: totrans-1758
  prefs: []
  type: TYPE_NORMAL
  zh: 单位矩阵：
- en: '[https://www.khanacademy.org/math/precalculus/precalc-matrices/zero-identity-matrix-tutorial/v/identity-matrix](https://www.khanacademy.org/math/precalculus/precalc-matrices/zero-identity-matrix-tutorial/v/identity-matrix)'
  id: totrans-1759
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.khanacademy.org/math/precalculus/precalc-matrices/zero-identity-matrix-tutorial/v/identity-matrix](https://www.khanacademy.org/math/precalculus/precalc-matrices/zero-identity-matrix-tutorial/v/identity-matrix)'
- en: 'We then pass our new `modelMatrix` into the `translateM` method. Translate
    is math speak for move. Look closely at the arguments passed into `translateM()`.
    We are passing in the *x* any *y* world locations of the object. This is how OpenGL
    knows where the object is:'
  id: totrans-1760
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将新的 `modelMatrix` 传递到 `translateM` 方法中。平移是数学术语，意为移动。仔细观察传递给 `translateM()`
    的参数。我们传递了对象的 *x* 和 *y* 世界位置。这是 OpenGL 知道对象位置的方式：
- en: '[PRE347]'
  id: totrans-1761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: We know that OpenGL has a matrix to translate our object to its world location.
    It also has a `ByteBuffer` class with the model space coordinates, but how does
    it convert translated model space coordinates to our viewport drawn using OpenGL
    coordinate system?
  id: totrans-1762
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道 OpenGL 有一个矩阵可以将我们的对象转换到其世界位置。它还有一个 `ByteBuffer` 类，包含模型空间坐标，但它如何将平移后的模型空间坐标转换为使用
    OpenGL 坐标系绘制的视口？
- en: 'It uses the viewport matrix, which is modified by each frame and passed into
    this method. All we need to do is multiply `viewportMatrix` and the recently translated
    `modelMatrix` together using `multiplyMM()`. This method creates the combined
    or multiplied matrix and stores the result in `viewportModelMatrix`:'
  id: totrans-1763
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用视口矩阵，该矩阵由每一帧修改并传递到这个方法中。我们所需做的只是使用 `multiplyMM()` 将 `viewportMatrix` 和最近平移的
    `modelMatrix` 相乘。此方法创建组合或乘积矩阵，并将结果存储在 `viewportModelMatrix` 中：
- en: '[PRE348]'
  id: totrans-1764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: We are almost done creating our matrix. The only other possible distortion that
    OpenGL will need to make to the vertices in the `ByteBuffer` is to rotate them
    to the `facingAngle` parameter.
  id: totrans-1765
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了矩阵的创建。OpenGL 需要对 `ByteBuffer` 中的顶点进行的唯一其他可能的扭曲是将它们旋转到 `facingAngle` 参数。
- en: Next, we create a rotation matrix appropriate to the current object's facing
    angle and storing the result back in `modelMatrix`.
  id: totrans-1766
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个适合当前对象面向角度的旋转矩阵，并将结果存储回 `modelMatrix`。
- en: 'Then, we combine or multiply the newly rotated `modelMatrix` with our `viewportModelMatrix`
    and store the result in `rotateViewportModelMatrix`. This is our final matrix
    that we will pass into the OpenGL system:'
  id: totrans-1767
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将新旋转的 `modelMatrix` 与我们的 `viewportModelMatrix` 相结合或相乘，并将结果存储在 `rotateViewportModelMatrix`
    中。这是我们最终将传递到 OpenGL 系统中的矩阵：
- en: '[PRE349]'
  id: totrans-1768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: Now we pass in the matrix using the `glUniformMatrix4fv()` method and use the
    `uMatrixLocation` variable (which is the location of the matrix-related variable
    in the vertex shader) and our final matrix in the arguments.
  id: totrans-1769
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们使用 `glUniformMatrix4fv()` 方法传入矩阵，并使用 `uMatrixLocation` 变量（这是顶点着色器中与矩阵相关的变量的位置）以及我们的最终矩阵作为参数。
- en: We also choose the color by calling `glUniform4f()` with the `uColorLocation`
    and an RGBT (Red, Green, Blue, Transparency) value. All values are set to 1.0,
    so the fragment shader will draw white.
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还通过调用 `glUniform4f()` 并使用 `uColorLocation` 和一个 RGBT（红色、绿色、蓝色、透明度）值来选择颜色。所有值都设置为
    1.0，因此片段着色器将绘制白色。
- en: '[PRE350]'
  id: totrans-1771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: 'Finally, we switch based on the object type and draw either points, lines,
    or triangle primitives:'
  id: totrans-1772
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们根据对象类型进行切换，并绘制点、线或三角形原语：
- en: '[PRE351]'
  id: totrans-1773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: Now that we have the fundamentals of our `GameObject` class, we can make a class
    to represent our spaceship and draw it to the screen.
  id: totrans-1774
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了 `GameObject` 类的基础，我们可以创建一个表示我们的飞船并将其绘制到屏幕上的类。
- en: The spaceship
  id: totrans-1775
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 飞船
- en: This class is nice and simple, although it will evolve with the project. The
    constructor receives the starting location within the game world. We set the ship's
    type and world location using the methods from the `GameObject` class, and we
    set a width and height.
  id: totrans-1776
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类既简洁又简单，尽管它将随着项目的进展而发展。构造函数接收游戏世界内的起始位置。我们使用 `GameObject` 类的方法设置飞船的类型和世界位置，并设置宽度和高度。
- en: We declare and initialize some variables to simplify the initialization of the
    model space coordinates, and then we go ahead and initialize a float array with
    three vertices that represent the triangle that is our ship. Note that the values
    are based around a center of *x = 0* and *y = 0*.
  id: totrans-1777
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明并初始化一些变量以简化模型空间坐标的初始化，然后我们继续初始化一个包含三个顶点的浮点数组，这三个顶点代表我们的飞船。注意，这些值是以 *x =
    0* 和 *y = 0* 为中心的。
- en: 'All we do next is, call `setVertices()`, and `GameObject` will prepare the
    `ByteBuffer` ready for OpenGL:'
  id: totrans-1778
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们只需调用 `setVertices()`，`GameObject` 将准备 `ByteBuffer` 以供 OpenGL 使用：
- en: '[PRE352]'
  id: totrans-1779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: At last, we can see the fruits of our labor.
  id: totrans-1780
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们能够看到我们辛勤工作的成果。
- en: Drawing at 60 + FPS
  id: totrans-1781
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以 60 + FPS 的速度绘制
- en: 'In three simple steps, we will be able to glimpse our spaceship:'
  id: totrans-1782
  prefs: []
  type: TYPE_NORMAL
  zh: 在三个简单的步骤中，我们将能够一瞥我们的宇宙飞船：
- en: 'Add a `SpaceShip` object to the `GameManager` member variables:'
  id: totrans-1783
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `SpaceShip` 对象添加到 `GameManager` 成员变量中：
- en: '[PRE353]'
  id: totrans-1784
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE353]'
- en: 'Add a call to the new `SpaceShip()` to the `createObjects` method:'
  id: totrans-1785
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将对新的 `SpaceShip()` 的调用添加到 `createObjects` 方法中：
- en: '[PRE354]'
  id: totrans-1786
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE354]'
- en: 'Add the call to draw the spaceship in each frame in the `draw` method of `AsteroidsRenderer`:'
  id: totrans-1787
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`AsteroidsRenderer`的`draw`方法中调用绘制太空船的调用，在每个帧中：
- en: '[PRE355]'
  id: totrans-1788
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE355]'
- en: 'Run the game and see the output:'
  id: totrans-1789
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏并查看输出：
- en: '![Drawing at 60 + FPS](img/B04322_09_03.jpg)'
  id: totrans-1790
  prefs: []
  type: TYPE_IMG
  zh: '![60 + FPS下的绘制](img/B04322_09_03.jpg)'
- en: Not exactly impressive visuals, but it is running between 67 and 212 frames
    per second in debug mode while outputting to the console on an ageing Samsung
    Galaxy S2 phone.
  id: totrans-1791
  prefs: []
  type: TYPE_NORMAL
  zh: 并不是特别令人印象深刻的视觉效果，但在调试模式下，当输出到一台老式的三星Galaxy S2手机的控制台时，它每秒可以运行67到212帧。
- en: '![Drawing at 60 + FPS](img/B04322_09_04.jpg)'
  id: totrans-1792
  prefs: []
  type: TYPE_IMG
  zh: '![60 + FPS下的绘制](img/B04322_09_04.jpg)'
- en: It will be our aim throughout the project to add hundreds of objects and keep
    the frames per second over 60.
  id: totrans-1793
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个项目中，我们的目标是将数百个对象添加到游戏中，并保持每秒60帧以上的帧率。
- en: Tip
  id: totrans-1794
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: One of the book's reviewers reported frame rates in excess of 1000 per second
    on a Nexus 5! It will therefore be worth considering a maximum frame rate locking
    strategy to save battery life if you were planning to release this to the Google
    Play store.
  id: totrans-1795
  prefs: []
  type: TYPE_NORMAL
  zh: 该书的一位评论者报告说，在Nexus 5上帧率超过了每秒1000帧！因此，如果你计划将此发布到Google Play商店，考虑一个最大帧率锁定策略以节省电池寿命将是值得考虑的。
- en: Summary
  id: totrans-1796
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Setting up a drawing system was a little bit long-winded. However, now that
    it is done, we can churn out new objects much more easily. All we have to do is
    define the type and the vertices, then we can draw them with ease.
  id: totrans-1797
  prefs: []
  type: TYPE_NORMAL
  zh: 设置绘图系统有点冗长。然而，现在它已经完成，我们可以更容易地生成新对象。我们只需要定义类型和顶点，然后我们可以轻松地绘制它们。
- en: It is because of this ground work that the next chapter will be much more visually
    rewarding. Next, we will create blinking stars, a game world border, spinning
    and moving asteroids, whizzing bullets, and a HUD, as well as add full controls
    and motion to the spaceship.
  id: totrans-1798
  prefs: []
  type: TYPE_NORMAL
  zh: 正是因为这个基础，下一章将更加视觉上令人满意。接下来，我们将创建闪烁的星星、游戏世界边界、旋转和移动的小行星、快速移动的子弹，以及HUD，并添加完整的控制和太空船的运动。
- en: Chapter 10. Move and Draw with OpenGL ES 2
  id: totrans-1799
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章. 使用OpenGL ES 2移动和绘制
- en: In this chapter, we will implement all the graphics, game play, and movement.
    In just over 30 pages, we will complete everything except collision detection.
    We can achieve this much because of the groundwork we laid in the last chapter.
  id: totrans-1800
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将实现所有的图形、游戏玩法和移动。在超过30页的内容中，我们将完成除了碰撞检测之外的所有内容。我们能实现这么多，是因为我们在上一章中打下的基础。
- en: First, we will draw a static border around our game world, then some blinking
    stars, followed by adding movement to our spaceship as well as some bullets. After
    that, we will quickly add controls for the player and we will be whizzing around
    the screen.
  id: totrans-1801
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将绘制一个静态的边界围绕我们的游戏世界，然后是一些闪烁的星星，接着添加太空船的运动以及一些子弹。之后，我们将快速添加玩家的控制，我们将在屏幕上快速移动。
- en: We will also make some noise by implementing our `SoundManager` class with some
    new sound FX.
  id: totrans-1802
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将通过实现带有一些新音效的`SoundManager`类来制造一些噪音。
- en: Once this is done, we will add randomly shaped asteroids that move across the
    world while spinning around at the same time.
  id: totrans-1803
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成这些，我们将在世界中添加随机形状的小行星，它们在旋转的同时移动。
- en: Then, we can add a HUD to highlight the touchable areas of the screen and provide
    a tally of the remaining player lives and asteroids that need destroying before
    the next level.
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以添加一个HUD来突出屏幕的可触摸区域，并提供剩余玩家生命和需要摧毁以进入下一级的小行星的计数。
- en: Drawing a static game border
  id: totrans-1805
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制静态游戏边界
- en: In this simple class, we define four sets of points that will represent four
    lines. Unsurprisingly, the `GameObject` class will draw the border using these
    points as the end points of lines.
  id: totrans-1806
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的类中，我们定义了四组点，这些点将代表四条线。不出所料，`GameObject`类将使用这些点作为线的端点来绘制边界。
- en: In the constructor, which is the entirety of the class, we set the type by calling
    `setType()`, the world location as the center of the map, and `height` and `width`
    as the height and width of the entire map.
  id: totrans-1807
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，即整个类的内容，我们通过调用`setType()`设置类型，将世界位置设置为地图的中心，以及将`height`和`width`设置为整个地图的高度和宽度。
- en: Then, we define the four lines in a float array and call `setVertices()` to
    prepare a `FloatBuffer`.
  id: totrans-1808
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在一个浮点数组中定义四条线，并调用`setVertices()`来准备一个`FloatBuffer`。
- en: 'Create a new class called `Border` and add the following code:'
  id: totrans-1809
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`Border`的新类，并添加以下代码：
- en: '[PRE356]'
  id: totrans-1810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: 'We can then declare a `Border` object as a member of `GameManager` like this:'
  id: totrans-1811
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将一个`Border`对象声明为`GameManager`的一个成员，如下所示：
- en: '[PRE357]'
  id: totrans-1812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: 'Initialize it in the `createObjects` method of `AsteroidsRenderer` like this:'
  id: totrans-1813
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AsteroidsRenderer`的`createObjects`方法中初始化它，如下所示：
- en: '[PRE358]'
  id: totrans-1814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: 'Now, we can draw our border by adding a line of code into the `draw` method
    of the `AsteroidsRendrer` class:'
  id: totrans-1815
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过在`AsteroidsRendrer`类的`draw`方法中添加一行代码来绘制我们的边界：
- en: '[PRE359]'
  id: totrans-1816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: 'You can now run the game. If you want to actually see the border, you can change
    the location to which we initialize the ship to somewhere near the border. Remember
    that in the `draw` method, we center the viewport around the ship. To see the
    border, change this one line in the `SpaceShip` class to this:'
  id: totrans-1817
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以运行游戏了。如果你想真正看到边界，你可以将飞船初始化的位置改为靠近边界的某个地方。记住，在`draw`方法中，我们围绕飞船中心化视口。为了看到边界，将`SpaceShip`类中的这一行代码改为如下：
- en: '[PRE360]'
  id: totrans-1818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: Run the game to take a look.
  id: totrans-1819
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏看看。
- en: '![Drawing a static game border](img/B043422_10_01.jpg)'
  id: totrans-1820
  prefs: []
  type: TYPE_IMG
  zh: '![绘制静态游戏边界](img/B043422_10_01.jpg)'
- en: 'Change it back to this:'
  id: totrans-1821
  prefs: []
  type: TYPE_NORMAL
  zh: 改回这个：
- en: '[PRE361]'
  id: totrans-1822
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: Now, we will fill up the area within the border with stars.
  id: totrans-1823
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将用星星填满边界内的区域。
- en: Twinkling stars
  id: totrans-1824
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 闪烁的星星
- en: We will get a bit more mobile than a static border. Here, we will add an `update`
    method to a simple `Star` class, which can be used to randomly switch the star
    on and off.
  id: totrans-1825
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将比静态边界更灵活。在这里，我们将向一个简单的`Star`类添加一个`update`方法，该方法可以用来随机切换星星的开和关。
- en: We set the type as `normal` and create a random location for the star within
    the confines of the border and call `setWorldLocation()` as always.
  id: totrans-1826
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其类型设置为`normal`，并在边界的限制内为星星创建一个随机位置，然后像往常一样调用`setWorldLocation()`。
- en: Stars will be drawn as points, so our vertex array will simply contain one vertex
    at model space 0,0,0\. Then, we call `setVertices()` as usual.
  id: totrans-1827
  prefs: []
  type: TYPE_NORMAL
  zh: 星星将以点的方式绘制，因此我们的顶点数组将简单地包含一个位于模型空间0,0,0的顶点。然后，我们像往常一样调用`setVertices()`。
- en: 'Create a new class, call it `Star`, and enter the discussed code:'
  id: totrans-1828
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的类，命名为`Star`，并输入所讨论的代码：
- en: '[PRE362]'
  id: totrans-1829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: Here is our `Star` class's `update` method. As we can see, there is a one in
    a 1000 chance in each frame that the star will switch its status. For more blinking,
    use a lower seed, and for less blinking, use a higher seed.
  id: totrans-1830
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的`Star`类的`update`方法。正如我们所见，在每一帧中，星星切换其状态的概率是千分之一。为了更多的闪烁，使用较低的种子值，而为了较少的闪烁，使用较高的种子值。
- en: '[PRE363]'
  id: totrans-1831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: 'We then declare a `Star` array, as a member of `GameManager`, and an extra
    `int` variable to control how many stars we want to draw, as follows:'
  id: totrans-1832
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们声明一个`Star`数组，作为`GameManager`的一个成员，以及一个额外的`int`变量来控制我们想要绘制的星星数量，如下所示：
- en: '[PRE364]'
  id: totrans-1833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: 'Initialize the array of `Star` objects in the `createObjects` method of `AsteroidsRenderer`
    as follows:'
  id: totrans-1834
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AsteroidsRenderer`的`createObjects`方法中初始化`Star`对象数组如下：
- en: '[PRE365]'
  id: totrans-1835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: Now, we can draw our stars by adding these lines of code into the `draw` method
    of the `AsteroidsRenderer` class. Note that we draw the stars first as they are
    in the background.
  id: totrans-1836
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过将这些代码行添加到`AsteroidsRenderer`类的`draw`方法中来绘制我们的星星。注意，我们首先绘制星星，因为它们在背景中。
- en: '[PRE366]'
  id: totrans-1837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: 'Of course, to make them blink, we call their `update` method from the `AsteroidsRenderer`
    class''s `update` method like this:'
  id: totrans-1838
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，为了使它们闪烁，我们从`AsteroidsRenderer`类的`update`方法中调用它们的`update`方法，如下所示：
- en: '[PRE367]'
  id: totrans-1839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: 'You can now run the game:'
  id: totrans-1840
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以运行游戏了：
- en: '![Twinkling stars](img/B043422_10_02.jpg)'
  id: totrans-1841
  prefs: []
  type: TYPE_IMG
  zh: '![闪烁的星星](img/B043422_10_02.jpg)'
- en: Bringing the spaceship to life
  id: totrans-1842
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使飞船栩栩如生
- en: First, we need to add a bit more functionality to our `GameObject` class. We
    do so in `GameObject` because bullets and asteroids share a surprising amount
    of similarities with a spaceship.
  id: totrans-1843
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要对我们的`GameObject`类添加一些更多功能。我们在`GameObject`中这样做，因为子弹和陨石与飞船有惊人的相似之处。
- en: 'We need a bunch of getters and setters to get and set the rotation rate, traveling
    angle, and facing angle. Add the following methods to the `GameObject` class:'
  id: totrans-1844
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些getter和setter来获取和设置旋转速率、移动角度和面向角度。将以下方法添加到`GameObject`类中：
- en: '[PRE368]'
  id: totrans-1845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: 'Now, we add a `move` method, which adjusts the *x* and *y* coordinates as well
    as the `facingAngle` of the object based on the current frames per second. Add
    the `move` method:'
  id: totrans-1846
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们添加一个`move`方法，该方法根据当前每秒帧数调整对象的*x*和*y*坐标以及`facingAngle`。添加`move`方法：
- en: '[PRE369]'
  id: totrans-1847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: 'To complete our additions to the `GameObject` class, add these getters and
    setters for velocity, speed, and maximum speed:'
  id: totrans-1848
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们对`GameObject`类的补充，添加以下用于速度、速度和最大速度的getter和setter：
- en: '[PRE370]'
  id: totrans-1849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: 'We can make some additions to the `SpaceShip` class. Add these three members
    to the `SpaceShip` class to control if the player''s ship is turning or moving
    forward:'
  id: totrans-1850
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向`SpaceShip`类添加一些功能。添加以下三个成员以控制玩家的飞船是否转向或向前移动：
- en: '[PRE371]'
  id: totrans-1851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: 'Now, inside the `SpaceShip` constructor, let''s set the maximum speed of the
    ship. I have highlighted the new line of code among the existing code:'
  id: totrans-1852
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`SpaceShip`构造函数内部，让我们设置飞船的最大速度。我在现有代码中突出显示了新的一行代码：
- en: '[PRE372]'
  id: totrans-1853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: Next, in the `SpaceShip` class, we add an `update` method that, first of all,
    increases and decreases the speed based on whether `isThrusting` is true or false.
  id: totrans-1854
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`SpaceShip`类中，我们添加一个`update`方法，首先根据`isThrusting`是`true`还是`false`增加和减少速度。
- en: '[PRE373]'
  id: totrans-1855
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: Then, we set the *x* and *y* velocity based on the angle, which way the ship
    is facing, and the speed.
  id: totrans-1856
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们根据角度设置*x*和*y*速度，即船面对的方向和速度。
- en: Note
  id: totrans-1857
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'We use speed multiplied by the cosine of the angle the ship is facing to set
    the velocity on the *x* axis. This works because the cosine function is a perfect
    variant that will return a value of -1 or 1, when the ship is facing exactly left
    or right, respectively; the variant returns a precise value of 0 when the ship
    is pointing exactly up or down. It also returns fine values in between as well.
    The sine of the angle works in exactly the same way on the *y* axis. The slightly
    convoluted looking code is because we need to convert our angle to radians and
    we must add 90 degrees to our `facingAngle` because 0 degrees is pointing to three
    o''clock. This fact is not conducive to using it on an *x*, *y* plane the way
    we have it, so we modify it by 90 degrees and the ship moves as expected. For
    more information about how this works check out this tutorial:'
  id: totrans-1858
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用速度乘以船面对的角度的余弦值来设置*x*轴上的速度。这是因为余弦函数是一个完美的变体，当船正好面向左或右时，它会返回-1或1的值；当船正好向上或向下时，变体会返回精确的0值。它也会在中间返回精细的值。角度的正弦在*y*轴上以完全相同的方式工作。代码看起来稍微复杂一些，是因为我们需要将我们的角度转换为弧度，并且必须将90度添加到我们的`facingAngle`中，因为0度是指向三点的。这个事实不利于我们在*x*，*y*平面上以我们有的方式使用它，所以我们将其修改为90度，船就会按预期移动。有关此工作方式的更多信息，请查看这个教程：
- en: '[http://gamecodeschool.com/essentials/calculating-heading-in-2d-games-using-trigonometric-functions-part-1/](http://gamecodeschool.com/essentials/calculating-heading-in-2d-games-using-trigonometric-functions-part-1/)'
  id: totrans-1859
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用三角函数计算2D游戏中的航向 - 第1部分](http://gamecodeschool.com/essentials/calculating-heading-in-2d-games-using-trigonometric-functions-part-1/)'
- en: '[PRE374]'
  id: totrans-1860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: Now, we set the rotation rate based on whether the player is turning left or
    right. Finally, we call `move()` to put all the updates into effect.
  id: totrans-1861
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们根据玩家是否向左或向右转动设置旋转速率。最后，我们调用`move()`以使所有更新生效。
- en: '[PRE375]'
  id: totrans-1862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: Now, we need to add a `pullTrigger` method, which for now, we just return `true`.
    We also provide three methods for our future `InputController` to call and trigger
    the `update` method to make its various changes.
  id: totrans-1863
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要添加一个`pullTrigger`方法，目前我们只是返回`true`。我们还提供了三个方法供我们的未来`InputController`调用并触发`update`方法，以进行各种更改。
- en: '[PRE376]'
  id: totrans-1864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: 'We are already drawing the ship in each frame, but we need to add one line
    of code in the `AsteroidsRenderer` class''s `update` method. Add this line of
    code to call the `SpaceShip` class''s `update` method:'
  id: totrans-1865
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在每一帧中绘制了船，但需要在`AsteroidsRenderer`类的`update`方法中添加一行代码。将此行代码添加到调用`SpaceShip`类的`update`方法：
- en: '[PRE377]'
  id: totrans-1866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: Obviously, we can't actually move until we add the player controls. Let's quickly
    add some bullets to the game. Then, we will add sound and controls so that we
    can see and hear the cool new features we added.
  id: totrans-1867
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在我们添加玩家控制之前，我们无法实际移动。让我们快速为游戏添加一些子弹。然后，我们将添加声音和控件，以便我们可以看到和听到我们添加的酷炫新功能。
- en: Rapid fire bullets
  id: totrans-1868
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连续射击子弹
- en: I've been addicted to games since Pong in the '70s, and remember my delight
    when a friend actually had a Space Invaders machine in his home for about a week.
    Although what really made asteroids so much better than Space Invaders, was how
    quickly you could shoot. In that tradition, we will make a satisfying, rapid fire
    stream of bullets.
  id: totrans-1869
  prefs: []
  type: TYPE_NORMAL
  zh: 自从70年代的Pong以来，我就沉迷于游戏，并记得当一位朋友在家里有一台太空侵略者机器大约一周时的喜悦。尽管真正让小行星比太空侵略者更好的是你可以射击得多快。在这个传统中，我们将制作一个令人满意的快速射击子弹流。
- en: Create a new class called `Bullet`, which has one vertex and will be drawn with
    a point. Note that we also declare and initialize an `inFlight` Boolean.
  id: totrans-1870
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的类`Bullet`，它有一个顶点，并将以点的方式绘制。请注意，我们还声明并初始化了一个`inFlight`布尔值。
- en: '[PRE378]'
  id: totrans-1871
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: Next, we have the `shoot` method that sets the `facingAngle` of the bullet to
    that of the ship. This will cause the bullet to move in the direction the ship
    was facing at the time the fire button was pressed. We also set `inFlight` to
    true and see how this is used in the `update` method. Finally, we set the speed
    to `300`.
  id: totrans-1872
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有`shoot`方法，该方法将子弹的`facingAngle`设置为船的`facingAngle`。这将导致子弹在按下射击按钮时以船当时面对的方向移动。我们还设置`inFlight`为`true`，并查看这在`update`方法中的使用方式。最后，我们将速度设置为`300`。
- en: We also add a `resetBullet` method, which sets the bullet inside the ship and
    cancels its velocity and speed. This gives us a clue as to how we will implement
    our bullets. The bullets will sit invisibly inside the ship until they are fired.
  id: totrans-1873
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个`resetBullet`方法，它将子弹设置在船内并取消其速度和速度。这给我们提供了关于我们将如何实现子弹的线索。子弹将隐形地坐在船内，直到它们被发射。
- en: '[PRE379]'
  id: totrans-1874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: Now, we move the bullet based on its `facingAngle` and speed, only if `inFlight`
    is true. Otherwise, we keep the bullet inside the ship. Then, we call `move()`.
  id: totrans-1875
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们根据子弹的`facingAngle`和速度移动子弹，只有当`inFlight`为真时。否则，我们保持子弹在船内。然后，我们调用`move()`。
- en: '[PRE380]'
  id: totrans-1876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: Now, we have a `Bullet` class, we can declare an array, to hold a bunch of objects
    of this type in our `GameManager` class.
  id: totrans-1877
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个`Bullet`类，我们可以在`GameManager`类中声明一个数组，用来存放这种类型的一组对象。
- en: '[PRE381]'
  id: totrans-1878
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: Initialize them in `createObjects()` right after our stars from the last section
    in `AsteroidsRenderer`. Note how we initialize their location in the game world
    as the center of the ship.
  id: totrans-1879
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AsteroidsRenderer`中的`createObjects()`方法中初始化它们，紧接上一节中的星星之后。注意我们如何初始化它们在游戏世界中的位置，即船的中心。
- en: '[PRE382]'
  id: totrans-1880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: Update them in the `update` method, again right after our blinking stars.
  id: totrans-1881
  prefs: []
  type: TYPE_NORMAL
  zh: 在`update`方法中更新它们，再次紧接我们的闪烁星星之后。
- en: '[PRE383]'
  id: totrans-1882
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: Draw them in the `draw` method, once more, after the stars.
  id: totrans-1883
  prefs: []
  type: TYPE_NORMAL
  zh: 在`draw`方法中再次绘制它们，在星星之后。
- en: '[PRE384]'
  id: totrans-1884
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: The bullets are now ready to be fired!
  id: totrans-1885
  prefs: []
  type: TYPE_NORMAL
  zh: 子弹现在可以发射了！
- en: We will add a `SoundManager` and `InputController` class, then we can see our
    ship and its rapid fire gun in action.
  id: totrans-1886
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个`SoundManager`和`InputController`类，然后我们就可以看到我们的船和它的快速射击枪在行动了。
- en: Reusing existing classes
  id: totrans-1887
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重用现有类
- en: Let's quickly add our `SoundManager` and `InputController` classes to this project
    because they only need a little tweak to accommodate our needs here too.
  id: totrans-1888
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速将`SoundManager`和`InputController`类添加到这个项目中，因为它们只需要稍作调整就能满足我们的需求。
- en: Add a member for a `SoundManager` and an `InputController` object in both the
    `AsteroidsView` and `AsteroidsRenderer` classes.
  id: totrans-1889
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AsteroidsView`和`AsteroidsRenderer`类中为`SoundManager`和`InputController`对象添加一个成员。
- en: '[PRE385]'
  id: totrans-1890
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: 'Initialize the new objects in the `onCreate` method of the `AsteroidsView`
    class and call the `loadSound` method like this:'
  id: totrans-1891
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AsteroidsView`类的`onCreate`方法中初始化新对象，并像这样调用`loadSound`方法：
- en: '[PRE386]'
  id: totrans-1892
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: Also in `AsteroidsView`, add an extra two arguments to the call to the `AsteroidsRenderer`
    constructor to pass in references to the `SoundManager` and `InputController`
    objects.
  id: totrans-1893
  prefs: []
  type: TYPE_NORMAL
  zh: 同样在`AsteroidsView`中，向调用`AsteroidsRenderer`构造函数的调用中添加两个额外的参数，以传递`SoundManager`和`InputController`对象的引用。
- en: '[PRE387]'
  id: totrans-1894
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: 'Now in the `AsteroidsRenderer` constructor add the two extra parameters and
    initialize the two new members like this:'
  id: totrans-1895
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`AsteroidsRenderer`构造函数中添加两个额外的参数，并像这样初始化两个新成员：
- en: '[PRE388]'
  id: totrans-1896
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: You will have errors in your IDE until we add the two classes. We will do that
    now.
  id: totrans-1897
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们添加这两个类之前，你的IDE中会出现错误。我们现在就来添加它们。
- en: Adding the SoundManager class
  id: totrans-1898
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加SoundManager类
- en: The `SoundManager` class works exactly the same way as it did with the previous
    project, so there is nothing new to explain here.
  id: totrans-1899
  prefs: []
  type: TYPE_NORMAL
  zh: '`SoundManager`类的工作方式与上一个项目完全相同，所以这里没有新的内容需要解释。'
- en: Add all the sound files from the download bundle `Chapter10/assets` folder to
    the assets folder of your project. As in the last two projects, you may need to
    create the assets folder in the `.../app/src/main` folder of your project.
  id: totrans-1900
  prefs: []
  type: TYPE_NORMAL
  zh: 将下载包`Chapter10/assets`文件夹中的所有声音文件添加到你的项目资源文件夹中。和前两个项目一样，你可能需要在项目的`.../app/src/main`文件夹中创建资源文件夹。
- en: Tip
  id: totrans-1901
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: As usual, you can use the sound effects provided or create your own.
  id: totrans-1902
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，你可以使用提供的声音效果或创建自己的。
- en: 'Now, add a new class to the project called `SoundManager`. Note that the functionality
    of the class is identical to the last project, but the code is different simply
    because of the names of the sound files and their related variables. Add this
    code to the `SoundManager` class:'
  id: totrans-1903
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，向项目中添加一个名为`SoundManager`的新类。请注意，该类的功能与上一个项目相同，但代码不同，仅仅是因为声音文件及其相关变量的名称不同。将此代码添加到`SoundManager`类中：
- en: '[PRE389]'
  id: totrans-1904
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: We are now ready to call `playSound()` from anywhere we have a reference to
    our new class.
  id: totrans-1905
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在任何有我们新类引用的地方调用`playSound()`。
- en: Adding the InputController class
  id: totrans-1906
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加InputController类
- en: This works the same way as it did in the last project, except that we call the
    appropriate `PlayerShip` methods instead of Bob's. Furthermore, we will not be
    moving the viewport while paused, so it is not necessary to handle the screen
    touches differently when the game is paused; making this `InputController` a little
    simpler and shorter.
  id: totrans-1907
  prefs: []
  type: TYPE_NORMAL
  zh: 这与上一个项目中的方式相同，只是我们调用适当的`PlayerShip`方法而不是Bob的。此外，在游戏暂停时，我们不会移动视口，因此当游戏暂停时，不需要以不同的方式处理屏幕触摸；这使得这个`InputController`更简单、更短。
- en: 'Add the `onTouchEvent` method to the `AsteroidsView` class to pass responsibility
    for handling touches to `InputController`:'
  id: totrans-1908
  prefs: []
  type: TYPE_NORMAL
  zh: 将`onTouchEvent`方法添加到`AsteroidsView`类中，以便将处理触摸的责任传递给`InputController`：
- en: '[PRE390]'
  id: totrans-1909
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: Add a new class called `InputController`, and add the following code which is
    straightforward, except for the way that we handle the player firing a shot.
  id: totrans-1910
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个名为`InputController`的新类，并添加以下代码，除了处理玩家射击的方式外，其他都很直接。
- en: We declare a member `int currentBullet` that keeps track of which bullet from
    our soon-to-be-declared array we are going to shoot next. Then, we can count the
    bullets out when the fire button is pressed and go back to the first bullet, right
    after the last one in the array is fired.
  id: totrans-1911
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明一个成员`int currentBullet`，它跟踪我们将要发射的下一个子弹来自我们即将声明的数组。然后，当按下射击按钮时，我们可以数出子弹，并在数组中的最后一个子弹发射后回到第一个子弹。
- en: 'Create a new class called `InputController` and enter the following code:'
  id: totrans-1912
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`InputController`的新类，并输入以下代码：
- en: '[PRE391]'
  id: totrans-1913
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: Let's bundle all our buttons together in a list and make them available with
    a public method.
  id: totrans-1914
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将所有按钮打包成一个列表，并通过公共方法使它们可用。
- en: '[PRE392]'
  id: totrans-1915
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: Next, we handle the input as we have before, except we call our `Ship` class's
    methods.
  id: totrans-1916
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们像以前一样处理输入，只是我们调用我们的`Ship`类的方法。
- en: '[PRE393]'
  id: totrans-1917
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: Now, we can fly around and loose off a few space rounds! Of course, you will
    have to estimate the screen positions until we get our HUD drawn later in this
    chapter. Don't forget that the player needs to tap the pause button (top-right)
    first.
  id: totrans-1918
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以四处飞行并发射几发太空弹！当然，在我们绘制HUD之前，你将不得不估计屏幕位置。别忘了玩家需要先点击暂停按钮（右上角）。
- en: Note
  id: totrans-1919
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that at the moment, we don't use the `resetBullet` method, and that once
    you have shot your twenty bullets, you will not be able to shoot any more. We
    can do a quick check to see if the bullet was at a location outside the border
    and then call `resetBullet`, but we will handle this fully, in conjunction with
    all the collision detection, in the next chapter.
  id: totrans-1920
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，目前我们未使用`resetBullet`方法，并且一旦你发射了二十发子弹，你就不能再发射了。我们可以快速检查子弹是否位于边界之外的位置，然后调用`resetBullet`，但我们将与所有碰撞检测一起完全处理这个问题。
- en: Of course, we can't have an asteroids game without any asteroids.
  id: totrans-1921
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，没有彗星的彗星游戏是不完整的。
- en: Drawing and moving the asteroids
  id: totrans-1922
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制和移动彗星
- en: At last, we will add our cool, spinning asteroids. First, we will look at the
    constructor that is fairly similar to the other game object constructors, except
    that we set the world location randomly. However, take a little extra care not
    to spawn them in the center of the map, where the spaceship starts the game.
  id: totrans-1923
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将添加我们酷炫的旋转彗星。首先，我们将查看构造函数，它与其他游戏对象构造函数相当相似，只是我们将世界位置随机设置。然而，请特别注意不要在地图中心生成它们，因为太空船从这里开始游戏。
- en: Create a new class called `Asteroid` and add this constructor. Note that we
    have not defined any vertices. We delegate this to the `generatePoints` method
    that we will see soon.
  id: totrans-1924
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`Asteroid`的新类，并添加此构造函数。请注意，我们尚未定义任何顶点。我们将此委托给即将看到的`generatePoints`方法。
- en: '[PRE394]'
  id: totrans-1925
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: Our update method simply calculates the velocity based on speed and traveling
    angle as we did for the `SpaceShip` class. It then calls `move()` in the usual
    way.
  id: totrans-1926
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的更新方法简单地根据速度和移动角度计算速度，就像我们在`SpaceShip`类中做的那样。然后，它以通常的方式调用`move()`。
- en: '[PRE395]'
  id: totrans-1927
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: Here we see the `generatePoints` method, which will create a randomly shaped
    asteroid. Simply explained, each asteroid will have six vertices. Each vertex
    has a randomly generated position but within fairly strict limits, so we don't
    get any overlapping lines.
  id: totrans-1928
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到`generatePoints`方法，它将创建一个形状随机的彗星。简单来说，每个彗星将有六个顶点。每个顶点都有一个随机生成的位置，但在这个相当严格的限制范围内，所以我们不会得到任何重叠的线条。
- en: '[PRE396]'
  id: totrans-1929
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: Now, we have our six points that we use to build our array of floats that represent
    the vertices. Finally, we call `setVertices()` to create our `ByteBuffer`. Note
    that the asteroids will be drawn as a series of lines, which is why the last vertex
    in the array is the same as the first.
  id: totrans-1930
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有六个点，我们用这些点构建表示顶点的浮点数数组。最后，我们调用`setVertices()`来创建我们的`ByteBuffer`。注意，小行星将以一系列线条的形式绘制，这就是为什么数组中的最后一个顶点与第一个顶点相同。
- en: '[PRE397]'
  id: totrans-1931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: Now as you have probably come to expect, we add an array to `GameManager` to
    hold all our asteroids. At the same time, we will declare some variables which
    will hold the level the player is currently on, as well as the starting (base)
    number of asteroids. Then soon, when we initialize all our asteroids, we will
    see how we will determine the number of asteroids that will need to be destroyed
    to clear a level.
  id: totrans-1932
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可能已经预料到了，我们在`GameManager`中添加了一个数组来存储所有的小行星。同时，我们将声明一些变量，它们将存储玩家当前所在的关卡，以及起始（基础）小行星的数量。然后，当我们初始化所有小行星时，我们将看到我们将如何确定需要摧毁多少小行星才能清除一个关卡。
- en: '[PRE398]'
  id: totrans-1933
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: 'Initialize the array in the `GameManager` constructor:'
  id: totrans-1934
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GameManager`构造函数中初始化数组：
- en: '[PRE399]'
  id: totrans-1935
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: Initialize the objects themselves in the `createObjects` method using our previously
    declared variables to determine the number of asteroids based on the current level.
  id: totrans-1936
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前声明的变量在`createObjects`方法中初始化对象本身，以确定基于当前关卡的小行星数量。
- en: '[PRE400]'
  id: totrans-1937
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: Update them in the `update` method.
  id: totrans-1938
  prefs: []
  type: TYPE_NORMAL
  zh: 在`update`方法中更新它们。
- en: '[PRE401]'
  id: totrans-1939
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: Finally, we can draw all our asteroids in the `draw` method.
  id: totrans-1940
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在`draw`方法中绘制所有我们的小行星。
- en: '[PRE402]'
  id: totrans-1941
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: Now, run the game and check out those smooth, 60+ FPS, spinning asteroids.
  id: totrans-1942
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行游戏并查看那些平滑的、60+ FPS、旋转的小行星。
- en: '![Drawing and moving the asteroids](img/B043422_10_03.jpg)'
  id: totrans-1943
  prefs: []
  type: TYPE_IMG
  zh: '![绘制和移动小行星](img/B043422_10_03.jpg)'
- en: Now, we need to make it easy to control the ship by adding button graphics,
    as well as some other overlay information, with a HUD.
  id: totrans-1944
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要通过添加按钮图形以及一些其他叠加信息，使用HUD（Head-Up Display）使控制飞船变得容易。
- en: Scores and the HUD
  id: totrans-1945
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分数和HUD
- en: The HUD objects will never be rotated. In addition, they are defined in the
    `InputController` class based on screen coordinates, not the game world or even
    Open GL coordinates. Therefore, our `GameObject` class is not a suitable parent
    class.
  id: totrans-1946
  prefs: []
  type: TYPE_NORMAL
  zh: HUD对象永远不会旋转。此外，它们是在`InputController`类中基于屏幕坐标定义的，而不是游戏世界或甚至OpenGL坐标。因此，我们的`GameObject`类不是一个合适的父类。
- en: For the sake of simplicity, each of the three HUD classes will have their own
    `draw` method. We will see how we draw them at a consistent size and screen position
    using a new viewport matrix.
  id: totrans-1947
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，三个HUD类中的每一个都将有自己的`draw`方法。我们将看到如何使用新的视口矩阵以一致的大小和屏幕位置绘制它们。
- en: Once we have created all three of our HUD classes, we will add all of the object
    declarations, initializations, and drawing code.
  id: totrans-1948
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了所有三个HUD类，我们将添加所有对象声明、初始化和绘制代码。
- en: Adding control buttons
  id: totrans-1949
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加控制按钮
- en: The first HUD object we will make a class for, is a simple button.
  id: totrans-1950
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为第一个HUD对象创建一个类，它是一个简单的按钮。
- en: Note
  id: totrans-1951
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: I am showing all the imports explicitly, as they do not get imported automatically.
    Note that the next two classes will need these as well. The code is all in the
    download bundle as usual, if you wish to just copy and paste it.
  id: totrans-1952
  prefs: []
  type: TYPE_NORMAL
  zh: 我明确地显示了所有导入，因为它们不会自动导入。注意，接下来的两个类也需要这些导入。代码通常都在下载包中，如果你只想复制粘贴的话。
- en: Create a new class and call it `GameButton`, then add the following import statements.
    Be sure to state the correct package name based on which chapter's code you are
    using or the name you gave your project.
  id: totrans-1953
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的类，命名为`GameButton`，然后添加以下导入语句。请确保根据你使用的章节代码或你为项目命名的名称，正确地声明包名。
- en: '[PRE403]'
  id: totrans-1954
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: First, we declare some members; `viewportMatrix` into which we will put our
    new matrix for the viewport transformation from the `InputController` class's
    screen based coordinates—An int `glprogram` value, an `int numVertices` value,
    and a `FloatBuffer` class.
  id: totrans-1955
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明一些成员；`viewportMatrix`，我们将把我们的新矩阵放入其中，用于从`InputController`类的基于屏幕坐标的视口变换——一个`int
    glprogram`值，一个`int numVertices`值和一个`FloatBuffer`类。
- en: '[PRE404]'
  id: totrans-1956
  prefs: []
  type: TYPE_PRE
  zh: '[PRE404]'
- en: The first thing we do in the constructor is make our viewport matrix by calling
    `orthoM()` with the screen height and width as `0,0`. This makes OpenGL map a
    coordinate range that is identical to the device resolution over the top of the
    OpenGL coordinate range.
  id: totrans-1957
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们首先通过调用`orthoM()`并使用屏幕的高度和宽度作为`0,0`来创建我们的视口矩阵。这使得OpenGL将一个与设备分辨率相同的坐标范围映射到OpenGL坐标范围之上。
- en: We then get the coordinates of the passed in button and shrink it down to make
    it smaller. Then, we initialize a vertex array as four lines to represent a button.
    Clearly, we will need to create a new button object to represent each and every
    button from our `InputController` class.
  id: totrans-1958
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们获取传入按钮的坐标并将其缩小以使其更小。然后，我们初始化一个顶点数组作为四条线来表示一个按钮。显然，我们将需要创建一个新的按钮对象来表示`InputController`类中的每一个按钮。
- en: '[PRE405]'
  id: totrans-1959
  prefs: []
  type: TYPE_PRE
  zh: '[PRE405]'
- en: Now, we duplicate a little of the code from `GameObject` to prepare `ByteBuffer`,
    but still we use our static `GLManager.getGLProgram()` to get a handle to a GL
    program.
  id: totrans-1960
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们从`GameObject`中复制一小部分代码来准备`ByteBuffer`，但我们仍然使用我们的静态`GLManager.getGLProgram()`来获取GL程序的句柄。
- en: '[PRE406]'
  id: totrans-1961
  prefs: []
  type: TYPE_PRE
  zh: '[PRE406]'
- en: Finally, we implement the `draw` method, which is a simplified version of the
    `draw` method from `GameObject`. Note that we don't need to mess around with model,
    translation, and rotation matrices, and also that we pass a different color to
    the fragment shader.
  id: totrans-1962
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们实现`draw`方法，这是从`GameObject`中的`draw`方法的简化版本。请注意，我们不需要与模型、平移和旋转矩阵纠缠，并且我们还向片段着色器传递了不同的颜色。
- en: '[PRE407]'
  id: totrans-1963
  prefs: []
  type: TYPE_PRE
  zh: '[PRE407]'
- en: Tally icons
  id: totrans-1964
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计数图标
- en: This class is the same as `GameButton`, except that a tally icon will be a single
    straight vertical line; therefore, we only need two vertices.
  id: totrans-1965
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类与`GameButton`相同，除了计数图标将是一条单一的垂直线；因此，我们只需要两个顶点。
- en: However, note that we have a parameter in the constructor called `nthIcon`.
    It will be the responsibility of the calling code to let `TallyIcon` know the
    total quantity of already created `TallyIcon` objects, plus one. Then, the current
    `TallyIcon` object can use the padding variable to position itself appropriately.
  id: totrans-1966
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，我们在构造函数中有一个名为`nthIcon`的参数。调用代码将负责让`TallyIcon`知道已经创建的`TallyIcon`对象的总数，再加一。然后，当前的`TallyIcon`对象可以使用填充变量来适当地定位自己。
- en: 'Create a new class called `TallyIcon` and enter the following code. As we have,
    previously, include the static imports as required. Here is the code for all the
    declarations and the constructor:'
  id: totrans-1967
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`TallyIcon`的新类，并输入以下代码。正如我们之前所做的那样，根据需要包含静态导入。以下是所有声明和构造函数的代码：
- en: '[PRE408]'
  id: totrans-1968
  prefs: []
  type: TYPE_PRE
  zh: '[PRE408]'
- en: This is the draw method which is probably looking quite familiar by now.
  id: totrans-1969
  prefs: []
  type: TYPE_NORMAL
  zh: 这现在看起来可能很熟悉的绘制方法。
- en: '[PRE409]'
  id: totrans-1970
  prefs: []
  type: TYPE_PRE
  zh: '[PRE409]'
- en: Now for the final HUD element.
  id: totrans-1971
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是最后的HUD元素。
- en: Life icons
  id: totrans-1972
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生命图标
- en: Our last icon will be a kind of mini-ship to indicate how many lives the player
    has remaining.
  id: totrans-1973
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后的图标将是一种迷你飞船，用来指示玩家剩余的生命数。
- en: We will construct a triangle shape out of lines to create a nice hollow effect.
    Note that the `LifeIcon` constructor also uses an `nthIcon` element to control
    the padding and on screen position.
  id: totrans-1974
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用线条构建一个三角形形状以创建一个漂亮的空心效果。请注意，`LifeIcon`构造函数也使用`nthIcon`元素来控制填充和在屏幕上的位置。
- en: 'Create a new class called `LifeIcon` and enter the following code, remembering
    all the imports that will not auto-import. Here are the declarations and the constructor:'
  id: totrans-1975
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`LifeIcon`的新类，并输入以下代码，记住所有不会自动导入的导入。以下是声明和构造函数：
- en: '[PRE410]'
  id: totrans-1976
  prefs: []
  type: TYPE_PRE
  zh: '[PRE410]'
- en: 'Here is the `draw` method of the `LifeIcon` class:'
  id: totrans-1977
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`LifeIcon`类的`draw`方法：
- en: '[PRE411]'
  id: totrans-1978
  prefs: []
  type: TYPE_PRE
  zh: '[PRE411]'
- en: We have our three HUD classes, and we can draw them to the screen.
  id: totrans-1979
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三个HUD类，并且可以将它们绘制到屏幕上。
- en: Declaring, initializing, and drawing the HUD objects
  id: totrans-1980
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明、初始化和绘制HUD对象
- en: We will declare, initialize, and draw our HUD objects just like all the `GameObject`
    classes. However, note that, as expected, we don't pass a viewport matrix to the
    `draw` method because the HUD classes provide their own.
  id: totrans-1981
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将声明、初始化和绘制我们的HUD对象，就像所有的`GameObject`类一样。然而，请注意，正如预期的那样，我们不向`draw`方法传递视口矩阵，因为HUD类提供了自己的。
- en: 'Add these members to `GameManager`:'
  id: totrans-1982
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些成员添加到`GameManager`：
- en: '[PRE412]'
  id: totrans-1983
  prefs: []
  type: TYPE_PRE
  zh: '[PRE412]'
- en: 'As we did with the `asteroids` array, initialize `tallyIcons` and `lifeIcons`
    in the `GameManager` constructor:'
  id: totrans-1984
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们对`asteroids`数组所做的那样，在`GameManager`构造函数中初始化`tallyIcons`和`lifeIcons`：
- en: '[PRE413]'
  id: totrans-1985
  prefs: []
  type: TYPE_PRE
  zh: '[PRE413]'
- en: 'Add a new member array to the `AsteroidsRenderer` class:'
  id: totrans-1986
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AsteroidsRenderer`类中添加一个新的成员数组：
- en: '[PRE414]'
  id: totrans-1987
  prefs: []
  type: TYPE_PRE
  zh: '[PRE414]'
- en: 'Add this code to create objects of all our new HUD classes. Add it to the `createObjects`
    method just before the closing curly brace:'
  id: totrans-1988
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码添加以创建所有新HUD类的对象。将其添加到`createObjects`方法中的关闭花括号之前：
- en: '[PRE415]'
  id: totrans-1989
  prefs: []
  type: TYPE_PRE
  zh: '[PRE415]'
- en: 'Now we can draw our HUD based on the number of lives remaining and the number
    of asteroids left before the next level. Add this code to the end of the `draw`
    method:'
  id: totrans-1990
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以根据剩余的生命数和下一关之前剩余的陨石数来绘制我们的HUD。将此代码添加到`draw`方法的末尾：
- en: '[PRE416]'
  id: totrans-1991
  prefs: []
  type: TYPE_PRE
  zh: '[PRE416]'
- en: You can now fly around and admire your new HUD.
  id: totrans-1992
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以飞来飞去，欣赏你新的HUD。
- en: '![Declaring, initializing, and drawing the HUD objects](img/B043422_10_04.jpg)'
  id: totrans-1993
  prefs: []
  type: TYPE_IMG
  zh: '![声明、初始化和绘制HUD对象](img/B043422_10_04.jpg)'
- en: Obviously, if we are going to make any use of our lives and asteroid tally indicators,
    then we first need to be able to shoot asteroids as well as detect them when the
    ship gets hit.
  id: totrans-1994
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果我们想要利用我们的生命和陨石计数指示器，那么我们首先需要能够射击小行星，以及在飞船被击中时检测它们。
- en: Summary
  id: totrans-1995
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: We achieved lots in this chapter, and indeed it would be simple to quickly add
    more game objects. Perhaps, an occasional UFO like in the original arcade classic.
  id: totrans-1996
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中取得了许多成果，实际上简单地添加更多游戏对象也很容易。也许，偶尔会出现像原始街机经典游戏中的UFO。
- en: In the next chapter we will use what we learned in previous projects to set
    up collision detection and finish off the game. However, a game with precise,
    clean, smooth moving lines deserves much more accurate collision detection than
    we used so far.
  id: totrans-1997
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将利用之前项目中学到的知识来设置碰撞检测并完成游戏。然而，一个具有精确、干净、平滑移动线条的游戏需要比我们迄今为止使用的更精确的碰撞检测。
- en: So, we will concentrate solely on implementing precise, efficient collision
    detection that will make our Asteroids simulator complete.
  id: totrans-1998
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将专注于仅实现精确、高效的碰撞检测，这将使我们的《小行星》模拟器完整。
- en: Chapter 11. Things That Go Bump – Part II
  id: totrans-1999
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。碰撞事件——第二部分
- en: The collision detection in this game is much more complex than the previous
    two. For this reason, the code will be quite heavily commented. Sometimes the
    comments will explain things in a bit more detail or in a slightly different way.
  id: totrans-2000
  prefs: []
  type: TYPE_NORMAL
  zh: 这个游戏的碰撞检测比前两个游戏复杂得多。因此，代码将会有很多注释。有时注释会稍微详细或以略不同的方式解释一些内容。
- en: However, that doesn't mean it needs to be hard work. What we need to do is take
    a moment to consider a strategy that will work for us.
  id: totrans-2001
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不意味着它需要是件苦差事。我们需要做的是花点时间考虑一个对我们有效的策略。
- en: Hopefully, this approach will mean that by the end of the chapter, our collision
    detection solutions will appear straightforward.
  id: totrans-2002
  prefs: []
  type: TYPE_NORMAL
  zh: 希望到本章结束时，我们的碰撞检测解决方案将看起来很简单。
- en: Planning for collision detection
  id: totrans-2003
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞检测规划
- en: 'What we are trying to achieve can be put into the following two categories:'
  id: totrans-2004
  prefs: []
  type: TYPE_NORMAL
  zh: 我们试图实现的目标可以分为以下两类：
- en: 'What we want for the border:'
  id: totrans-2005
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们对边界的期望：
- en: Asteroids, bullets, and the ship need to know when they have collided with the
    border
  id: totrans-2006
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小行星、子弹和飞船需要知道它们何时与边界发生碰撞
- en: Asteroids should reverse and head back into the game area when they touch the
    border
  id: totrans-2007
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小行星在接触边界时应该反向并返回游戏区域
- en: A bullet should reset itself at the border
  id: totrans-2008
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子弹应该在边界处重置
- en: The ship should subtract a life and then respawn in the centre
  id: totrans-2009
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 飞船应该减去一条生命并在中心重生
- en: 'What we want for the asteroids. We need to know and respond when:'
  id: totrans-2010
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们对小行星的期望。我们需要知道并响应以下情况：
- en: The ship touches an asteroid
  id: totrans-2011
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 飞船接触小行星
- en: When a bullet touches an asteroid
  id: totrans-2012
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当子弹接触小行星时
- en: As in the original Asteroids game, we will not respond to asteroids bumping
    into each other
  id: totrans-2013
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就像原始的《小行星》游戏一样，我们不会对小行星之间的碰撞做出反应
- en: Although we will not be detecting an asteroid on asteroid collisions, you will
    see that when our collision detection nears completion, achieving asteroid on
    asteroid collision detection will not present much of an extra challenge. However,
    it will put extra strain on the device's CPU.
  id: totrans-2014
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不会在小行星碰撞中检测小行星，但你会看到，当我们的碰撞检测接近完成时，实现小行星之间的碰撞检测不会带来太大的额外挑战。然而，它会给设备的CPU带来额外的压力。
- en: We know that we have object on border collisions to detect and object on asteroid
    collisions to detect.
  id: totrans-2015
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们需要检测边界碰撞上的对象和小行星碰撞上的对象。
- en: Colliding with the border
  id: totrans-2016
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与边界的碰撞
- en: It may sound obvious, but the border is simply four static straight lines. This
    makes a border collision a different problem to an asteroid collision.
  id: totrans-2017
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然听起来很明显，但边界只是四条静态的直线。这使得边界碰撞与小行星碰撞成为不同的问题。
- en: All of the objects that we are interested in have vertices (or one vertex in
    the case of a bullet). This may at first suggest that we can simply compute the
    world location of each vertex from the model space and the centre of the object
    stored in `worldLocation`. We can, but this overlooks the fact that the asteroids
    and the ship rotate, which constantly causes a variation in the actual world locations
    of all the vertices.
  id: totrans-2018
  prefs: []
  type: TYPE_NORMAL
  zh: 我们感兴趣的所有对象都有顶点（或者子弹的情况是一个顶点）。这最初可能表明我们可以简单地从模型空间和存储在`worldLocation`中的对象中心计算每个顶点的世界位置。我们可以这样做，但忽略了小行星和飞船会旋转的事实，这会不断改变所有顶点的实际世界位置。
- en: We will need to translate and rotate the model space vertices, and then test
    if any of them have touched the border. We can do this in the object's `update`
    method for each frame, but we only need the rotated coordinates occasionally,
    when the object is very close to the border.
  id: totrans-2019
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要翻译和旋转模型空间顶点，然后测试它们是否触碰了边界。我们可以在对象的`update`方法中为每一帧做这件事，但只有在对象非常接近边界时，我们才偶尔需要旋转的坐标。
- en: The first phase of border collision detection
  id: totrans-2020
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 边界碰撞检测的第一阶段
- en: This suggests that a preliminary check, a first phase of collision detection,
    is more efficient. It implies that the translation and rotation of the vertices
    will need to take place outside of the object itself.
  id: totrans-2021
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明，一个初步检查，碰撞检测的第一阶段，更有效率。它意味着顶点的平移和旋转需要在对象本身之外进行。
- en: What we will do is use a simple rectangle intersect check based on the centre
    of the object and its width and height. If this cheap method returns a hit, we
    will then rotate and translate each vertex and check their real-world coordinates
    individually against the location of the border.
  id: totrans-2022
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用基于对象中心和其宽度和高度的简单矩形相交检查。如果这个便宜的方法返回一个命中，然后我们将旋转和转换每个顶点，并单独检查它们的实际世界坐标与边界的位置。
- en: Once the rotated game world locations of the vertices are calculated, the collision
    detection is simple.
  id: totrans-2023
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦计算出了顶点的旋转游戏世界位置，碰撞检测就变得简单了。
- en: '[PRE417]'
  id: totrans-2024
  prefs: []
  type: TYPE_PRE
  zh: '[PRE417]'
- en: As we will see, a two-stage solution is appropriate for the asteroid detection
    as well. Also, rotation and translation is involved but it is far less important.
  id: totrans-2025
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将看到的，对于小行星检测，一个两阶段解决方案是合适的。此外，旋转和转换是涉及的，但它远不那么重要。
- en: Colliding with an asteroid
  id: totrans-2026
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与小行星碰撞
- en: Testing for collision with an asteroid is similar in some respects. We need
    to find out if any single vertex from the ship or a bullet crosses into the space
    contained by the vertices of the asteroid.
  id: totrans-2027
  prefs: []
  type: TYPE_NORMAL
  zh: 测试与小行星的碰撞在某些方面是相似的。我们需要找出船或子弹的任何单个顶点是否穿入了由小行星顶点包含的空间。
- en: The first problem is that the asteroid is not only a moving target, but also
    a rotating one. We will not only have to rotate and translate all the vertices
    of the objects, but the asteroids as well.
  id: totrans-2028
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题是小行星不仅是一个移动的目标，而且是一个旋转的目标。我们不仅需要旋转和转换所有对象的顶点，还需要小行星。
- en: We also need to calculate the line made between each pair of vertices on the
    asteroid. Fortunately, at this point, we can fall back on a clever algorithm devised
    and refined by mathematicians far greater than myself. We will use the crossing
    number algorithm. This is how it works.
  id: totrans-2029
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要计算小行星上每对顶点之间的线。幸运的是，在这个时候，我们可以依赖一个比我更伟大的数学家设计的巧妙算法。我们将使用交叉数算法。这是它的工作原理。
- en: The crossing number
  id: totrans-2030
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 交叉数
- en: We compute the line made by a pair of vertices and use the crossing number algorithm
    to see if a particular vertex from the object being tested crossed that line.
    If it did, we increment a variable from 0 to 1.
  id: totrans-2031
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计算由一对顶点形成的线，并使用交叉数算法来查看测试对象中的特定顶点是否穿过了那条线。如果它确实穿过了，我们将变量从0增加到1。
- en: We test the same point against each and every line made by each vertex pair
    from an asteroid, incrementing our variable each time it does. If our variable
    is odd after testing the vertex against every line with the crossing number algorithm,
    we have a hit. If it is even, no collision has occurred.
  id: totrans-2032
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将测试点与来自小行星的每个顶点对形成的每条线进行测试，每次测试时增加我们的变量。如果测试顶点与交叉数算法中的每条线测试后，我们的变量是奇数，我们就有了一个命中。如果是偶数，则没有发生碰撞。
- en: Of course if no collision has occurred, we must proceed to test each and every
    vertex from the object being tested against each and every line formed out of
    the vertex pairs on the asteroid.
  id: totrans-2033
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果没有发生碰撞，我们必须继续测试测试对象中的每一个顶点与由小行星顶点对形成的每一条线的碰撞。
- en: Here is a visual representation of the crossing number algorithm in action.
  id: totrans-2034
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是交叉数算法在作用中的视觉表示。
- en: '![The crossing number](img/B043422_11_01.jpg)'
  id: totrans-2035
  prefs: []
  type: TYPE_IMG
  zh: '![交叉数](img/B043422_11_01.jpg)'
- en: Of course with all these complex calculations going on, we will definitely want
    to do a simple first phase test to see if it is likely there has been a collision
    before doing the complex tests.
  id: totrans-2036
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在所有这些复杂的计算进行中，我们肯定会想先进行一个简单的初步测试，看看是否有可能发生了碰撞，然后再进行复杂的测试。
- en: The first phase and overview of asteroid collision detection
  id: totrans-2037
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 边界碰撞检测的第一阶段和概述
- en: The radius overlap test is quite appropriate when testing a single vertex, such
    as a bullet, a spinning triangle like a ship, or a rotating asteroid.
  id: totrans-2038
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试单个顶点时，例如子弹、旋转的三角形（如飞船）或旋转的小行星，半径重叠测试非常合适。
- en: 'This is an overview of the whole process we will use for testing the collisions
    against asteroids:'
  id: totrans-2039
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将用于测试与小行星碰撞的整个过程的概述：
- en: Is the radius of the object being tested overlapped with the radius of an asteroid?
  id: totrans-2040
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 被测试物体的半径是否与小行星的半径重叠？
- en: If yes, has the first vertex of the object crossed the first line of the asteroid?
  id: totrans-2041
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是，物体的第一个顶点是否穿过了小行星的第一条线？
- en: If yes, `crossingNumber ++`.
  id: totrans-2042
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是，`crossingNumber ++`。
- en: Repeat step 2 with each line on the object.
  id: totrans-2043
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对物体的每条线重复步骤 2。
- en: If `crossingNumber` is odd, return true to calling code because a collision
    has occurred.
  id: totrans-2044
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `crossingNumber` 是奇数，则向调用代码返回 true，因为发生了碰撞。
- en: If `crossingNumber` is even, no collision has occurred (yet) repeat steps 2,
    3, and 4 with the next vertex of the object being tested.
  id: totrans-2045
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `crossingNumber` 是偶数，则尚未发生碰撞（重复步骤 2、3 和 4，使用待测试物体的下一个顶点）。
- en: If all vertices tested and we reached here then no collision has occurred.
  id: totrans-2046
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果所有顶点都已测试并且我们到达这里，那么没有发生碰撞。
- en: We will set up a collision detection class called `CD` with two static methods.
    The `detect` method will test for collisions with asteroids and be called for
    each bullet and ship against each and every asteroid in each frame.
  id: totrans-2047
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设置一个名为 `CD` 的碰撞检测类，其中包含两个静态方法。`detect` 方法将检测与小行星的碰撞，并且会在每一帧中对每一颗小行星与每一颗子弹和飞船进行检测。
- en: The `contain` method will check for collisions with every asteroid, bullet,
    and ship against the border.
  id: totrans-2048
  prefs: []
  type: TYPE_NORMAL
  zh: '`contain` 方法将检查与每个小行星、子弹和飞船的边界的碰撞。'
- en: Doing the calculations outside the objects themselves means that we will need
    a whole bunch of data for the objects we will be testing, and the ones made accessible
    to the new `CD` class's methods.
  id: totrans-2049
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象本身之外进行计算意味着我们需要为将要测试的对象以及提供给新 `CD` 类方法的数据准备大量数据。
- en: The CollisionPackage class
  id: totrans-2050
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 碰撞包类
- en: We know that we need a certain set of data to carry out detections properly.
    This next class will hold all the data that our collision detection class's methods
    will need in order to do its job, and every object that we need to detect collisions
    for will have one.
  id: totrans-2051
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们需要一组数据来正确执行检测。下一个类将保存我们的碰撞检测类方法执行其工作所需的所有数据，并且每个需要检测碰撞的对象都将有一个。
- en: When the time comes to rotate all the points to their real-world location, our
    collision package will need to know which way the object is facing. We have a
    float called `facingAngle`.
  id: totrans-2052
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要将所有点旋转到其实际位置时，我们的碰撞包需要知道物体面向的方向。我们有一个名为 `facingAngle` 的浮点数。
- en: We will obviously need a copy of the model space vertices. As with the rotated
    location, we will not go through the trouble of updating every frame and will
    do so only after the first phase of collision detection shows that a collision
    is likely.
  id: totrans-2053
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们需要一个模型空间顶点的副本。就像旋转的位置一样，我们不会每帧都更新，而只是在第一阶段的碰撞检测显示可能发生碰撞之后才这样做。
- en: We will also hold the precomputed value for the length of the array that holds
    these vertices. It can potentially save time in the collision detection process.
  id: totrans-2054
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将保留包含这些顶点的数组长度的预计算值。这可能在碰撞检测过程中节省时间。
- en: Therefore, we will also need the world coordinates of the object. This, we will
    update every frame.
  id: totrans-2055
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们还需要物体的世界坐标。这将每帧更新一次。
- en: Each object will have a precomputed `radius` variable, which is the size of
    the object from its centre to its furthest vertex. This will be used in our `detect`
    method for radius overlapping, phase one detection.
  id: totrans-2056
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象都将有一个预计算的 `radius` 变量，这是从物体的中心到其最远顶点的尺寸。这将在我们的 `detect` 方法中用于半径重叠，第一阶段检测。
- en: We will also have a couple of `PointF` objects, `currentPoint`, and `currentPoint2,`
    which are just handy objects that will avoid us potentially summoning the garbage
    collector during an intensive part of the two collision detection methods.
  id: totrans-2057
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将有几个 `PointF` 对象，`currentPoint` 和 `currentPoint2`，这些只是方便的对象，将避免我们在两个碰撞检测方法的密集部分可能调用垃圾收集器。
- en: 'Create a new class, call it `CollisionPackage`, and implement the members we
    have just discussed:'
  id: totrans-2058
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的类，命名为 `CollisionPackage`，并实现我们刚刚讨论的成员：
- en: '[PRE418]'
  id: totrans-2059
  prefs: []
  type: TYPE_PRE
  zh: '[PRE418]'
- en: 'Next, we have a simple constructor that will receive all the necessary data
    from each object at the end of each object''s constructor. Implement the `CollisionPackage`
    constructor as shown here:'
  id: totrans-2060
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个简单的构造函数，它将在每个对象的构造函数结束时接收每个对象所需的所有数据。按照以下方式实现`CollisionPackage`构造函数：
- en: '[PRE419]'
  id: totrans-2061
  prefs: []
  type: TYPE_PRE
  zh: '[PRE419]'
- en: That's all the data we need for advanced collision detection.
  id: totrans-2062
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要用于高级碰撞检测的所有数据。
- en: Adding collision packages to the objects and making them accessible
  id: totrans-2063
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将碰撞包添加到对象中并使其可访问
- en: Now, we have our `CollisionPackage` class. We will see how to add one to each
    object we need to monitor.
  id: totrans-2064
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了我们的`CollisionPackage`类。我们将看到如何为每个需要监控的对象添加一个。
- en: Adding a collision package to the Bullet class
  id: totrans-2065
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将碰撞包添加到`Bullet`类
- en: Open up the `Bullet` class, and we will see how to make use of our `CollisionPackage`
    constructor on the simplest case (just a point). Add a new member for the collision
    package.
  id: totrans-2066
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Bullet`类，我们将看到如何在最简单的情况下（只是一个点）使用我们的`CollisionPackage`构造函数。为碰撞包添加一个新成员。
- en: 'Add a new member of type `CollisionPackage` to the `Bullet` class:'
  id: totrans-2067
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Bullet`类中添加一个类型为`CollisionPackage`的新成员：
- en: '[PRE420]'
  id: totrans-2068
  prefs: []
  type: TYPE_PRE
  zh: '[PRE420]'
- en: 'Now, we create a structure to pass in to our `CollisionPackage` constructor
    and initialize the collision package. Note that we send in a single element array
    with the model space coordinates that will be 0,0,0\. Then, we send in the world
    location, 1, for the radius and the angle the bullet is facing. Enter the following
    code at the end of the `Bullet` class''s constructor:'
  id: totrans-2069
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们创建一个结构，将其传递给我们的`CollisionPackage`构造函数并初始化碰撞包。注意，我们发送一个包含模型空间坐标的单元素数组，这些坐标将是0,0,0。然后，我们发送世界位置，1作为半径和子弹面向的角度。在`Bullet`类构造函数的末尾输入以下代码：
- en: '[PRE421]'
  id: totrans-2070
  prefs: []
  type: TYPE_PRE
  zh: '[PRE421]'
- en: 'Finally for the `Bullet` class, we update the collision package in each frame
    by adding this code to the very end of the `Bullet` class''s `update` method:'
  id: totrans-2071
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于`Bullet`类，我们通过在`Bullet`类的`update`方法的末尾添加以下代码来在每一帧更新碰撞包：
- en: '[PRE422]'
  id: totrans-2072
  prefs: []
  type: TYPE_PRE
  zh: '[PRE422]'
- en: Now, our bullets are all set for detection.
  id: totrans-2073
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的子弹都已设置好用于检测。
- en: Adding a collision package to the SpaceShip class
  id: totrans-2074
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将碰撞包添加到`SpaceShip`类
- en: 'Open up the `SpaceShip` class and add these members. We will then see how to
    use them in the `SpaceShip` constructor:'
  id: totrans-2075
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`SpaceShip`类并添加这些成员。然后我们将看到如何在`SpaceShip`构造函数中使用它们：
- en: '[PRE423]'
  id: totrans-2076
  prefs: []
  type: TYPE_PRE
  zh: '[PRE423]'
- en: 'Here, we do something extra compared to the `Bullet` class. We add three more
    model space coordinates. OpenGL will not know about these and doesn''t need them.
    They are positioned in the middle of each of the three lines, which make the ship.
    We do this to make it harder for a vertex of an asteroid to drift inside the ship
    without a vertex of the ship being inside the asteroid. This is a visual representation
    of the problem that we are solving. The ships vertices are heavily emphasized
    to highlight the problem. Refer to the following diagram:'
  id: totrans-2077
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们与`Bullet`类相比做了些额外的事情。我们添加了三个额外的模型空间坐标。OpenGL不会知道这些，也不需要它们。它们位于构成船的每条线的中间。我们这样做是为了使小行星的顶点难以漂移到船内，而船的顶点不在小行星内。这是我们所解决问题的可视化表示。船的顶点被强调以突出问题。请参考以下图表：
- en: '![Adding a collision package to the SpaceShip class](img/B043422_11_02.jpg)'
  id: totrans-2078
  prefs: []
  type: TYPE_IMG
  zh: '![将碰撞包添加到`SpaceShip`类](img/B043422_11_02.jpg)'
- en: 'We can completely solve this problem by testing all the asteroids vertices
    against all of the ship''s lines as well as what we are planning to do; test all
    the ship''s vertices against all the asteroids lines. However, just adding a few
    extra points to the ship does produce near-perfect detection as shown next:'
  id: totrans-2079
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过测试所有小行星的顶点与船的所有线以及我们计划做的事情来解决此问题；测试船的所有顶点与小行星的所有线。然而，仅仅在船上添加几个额外的点就能产生几乎完美的检测，如下所示：
- en: '![Adding a collision package to the SpaceShip class](img/B043422_11_03.jpg)'
  id: totrans-2080
  prefs: []
  type: TYPE_IMG
  zh: '![将碰撞包添加到`SpaceShip`类](img/B043422_11_03.jpg)'
- en: 'Now, right after the call to `setVertices()` in the `SpaceShip` constructor
    implement the code we just discussed:'
  id: totrans-2081
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`SpaceShip`构造函数中调用`setVertices()`之后立即实现我们刚才讨论的代码：
- en: '[PRE424]'
  id: totrans-2082
  prefs: []
  type: TYPE_PRE
  zh: '[PRE424]'
- en: Next as we did for the `Bullet` class, we synchronize the collision package
    each frame in the `SpaceShip` class's `update` method. We do this at the very
    end of the method after the call to `move()` has updated the ship's coordinates.
  id: totrans-2083
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，就像我们在`Bullet`类中所做的那样，在`SpaceShip`类的`update`方法中同步碰撞包。我们在调用`move()`更新船的坐标后，在方法的末尾这样做。
- en: '[PRE425]'
  id: totrans-2084
  prefs: []
  type: TYPE_PRE
  zh: '[PRE425]'
- en: Finally, we will add a collision package to the asteroids.
  id: totrans-2085
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将向小行星添加碰撞包。
- en: Adding a collision package to the Asteroid class
  id: totrans-2086
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将碰撞包添加到`Asteroid`类
- en: 'Open up the `Asteroid` class and add a `CollisionPackage` member:'
  id: totrans-2087
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Asteroid`类并添加一个`CollisionPackage`成员：
- en: '[PRE426]'
  id: totrans-2088
  prefs: []
  type: TYPE_PRE
  zh: '[PRE426]'
- en: 'At the end of the `Asteroid` constructor, just after the call to `generatePoints()`,
    we initialize the `CollisionPackage` object:'
  id: totrans-2089
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Asteroid`构造函数的末尾，在调用`generatePoints()`之后，我们初始化`CollisionPackage`对象：
- en: '[PRE427]'
  id: totrans-2090
  prefs: []
  type: TYPE_PRE
  zh: '[PRE427]'
- en: 'Next, we add a helper method that reverses the direction of travel and *bounces*
    the asteroid back by a few pixels when a collision has been detected. We will
    call this method when we detect a collision with the border. Add the `bounce`
    method to the `Asteroid` class:'
  id: totrans-2091
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加一个辅助方法，当检测到碰撞时，它会反转移动方向并将陨石弹回几个像素。当我们检测到与边界的碰撞时，我们将调用这个方法。将`bounce`方法添加到`Asteroid`类中：
- en: '[PRE428]'
  id: totrans-2092
  prefs: []
  type: TYPE_PRE
  zh: '[PRE428]'
- en: 'As with the `SpaceShip` and `Bullet` classes, we will update the collision
    package in the `update` method just after the call to `move` at the very end of
    the `update` method:'
  id: totrans-2093
  prefs: []
  type: TYPE_NORMAL
  zh: 与`SpaceShip`和`Bullet`类一样，我们将在`update`方法的末尾调用`move`之后更新碰撞包：
- en: '[PRE429]'
  id: totrans-2094
  prefs: []
  type: TYPE_PRE
  zh: '[PRE429]'
- en: Now, we need to do something that we didn't need to do for the other classes.
    Our crossing number algorithm uses lines not vertices, so we need to make a line
    out of the last vertex by joining it with the first. We didn't need to do this
    with the `SpaceShip` class because of the way our collision data code worked.
    The collision data code will test the points of the bullets and ship against the
    lines of the asteroids. Not the other way around.
  id: totrans-2095
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要做一些对于其他类来说不需要做的事情。我们的交叉数算法使用的是线而不是顶点，因此我们需要通过将其与第一个顶点连接来制作一条线。由于我们的碰撞数据代码的工作方式，我们不需要对`SpaceShip`类做这件事。碰撞数据代码将测试子弹和飞船的点与陨石的线，而不是反过来。
- en: 'Here is the extra code to add to the seventh point in the `generatePoints`
    method. In the following code, I have included the existing code on either side
    of the new highlighted code:'
  id: totrans-2096
  prefs: []
  type: TYPE_NORMAL
  zh: 这是添加到`generatePoints`方法第七点的额外代码。在下面的代码中，我包括了新高亮代码两侧的现有代码：
- en: '[PRE430]'
  id: totrans-2097
  prefs: []
  type: TYPE_PRE
  zh: '[PRE430]'
- en: Now, we can talk about building the collision detection class itself.
  id: totrans-2098
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以讨论构建碰撞检测类本身了。
- en: The CD class outline
  id: totrans-2099
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CD类概要
- en: We will now implement the first phase of collision detection. As discussed,
    the algorithms we will use are computationally expensive, and we only want to
    use them when there is a realistic chance of a collision.
  id: totrans-2100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将实现碰撞检测的第一阶段。正如讨论的那样，我们将使用的算法计算量很大，我们只想在存在实际碰撞可能性的情况下使用它们。
- en: Therefore, we will check each bullet and the ship against every asteroid using
    the radius overlapping method discussed in [Chapter 3](ch12.html "Chapter 3. Tappy
    Defender – Taking Flight"), *Tappy Defender – Taking Flight*. We will check the
    asteroids, ship, and bullets against the border using a simplified rectangle intersection
    method.
  id: totrans-2101
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将使用第3章中讨论的半径重叠方法，即[Tappy Defender – Taking Flight](ch12.html "Chapter 3. Tappy
    Defender – Taking Flight")，检查每一颗子弹和飞船与每一颗陨石之间的碰撞。我们将使用简化的矩形交集方法检查陨石、飞船和子弹与边界之间的碰撞。
- en: After the next two sections, you will actually be able to play the game, but
    you will see that the basic collision detection that we have used so far is not
    satisfying enough for this type of game.
  id: totrans-2102
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两个部分之后，你实际上将能够玩游戏，但你将看到我们迄今为止使用的碰撞检测的基本方法对于这种类型的游戏来说还不够令人满意。
- en: These first checks will decide whether we then move on to do the more accurate
    and computationally expensive checks.
  id: totrans-2103
  prefs: []
  type: TYPE_NORMAL
  zh: 这些初步检查将决定我们是否继续进行更精确且计算量更大的检查。
- en: We will implement these second phase checks in the sections *Precise collision
    detection with the border* and *Precise collision detection with an asteroid*,
    which will use the more advanced algorithms and put the data in our collision
    packages to full use.
  id: totrans-2104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在“精确碰撞检测与边界”和“精确碰撞检测与陨石”这两个部分实现这些第二阶段的检查，这些部分将使用更高级的算法，并充分利用我们的碰撞包中的数据。
- en: To get started, create a new class and call it `CD`. Add a member `PointF` object
    and initialize it. We will use it to avoid creating new objects during the critical
    parts of the code.
  id: totrans-2105
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，创建一个新的类，并将其命名为`CD`。添加一个`PointF`成员对象并初始化它。我们将在代码的关键部分使用它来避免创建新的对象。
- en: '[PRE431]'
  id: totrans-2106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE431]'
- en: Now, let's discuss the methods.
  id: totrans-2107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论这些方法。
- en: Implementing radius overlapping for asteroids and ships
  id: totrans-2108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现陨石和飞船的半径重叠
- en: Let's add our first method to the `CD` class, to detect collisions between bullets
    and asteroids as well as the ship and asteroids. As we discussed, we are only
    implementing the first part of this method for now. Here is the implementation
    of the radius overlapping code.
  id: totrans-2109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把第一个方法添加到`CD`类中，用于检测子弹和陨石之间的碰撞，以及飞船和陨石之间的碰撞。正如我们讨论的那样，我们现在只实现这个方法的第一部分。以下是半径重叠代码的实现。
- en: The code works by making a hypothetical triangle with a missing side, and then
    using Pythagoras' theorem to calculate the missing side that is the distance between
    the centre points of the two objects. If the combined radii of the two objects
    is greater than the distance between the two object centers, we have an overlap.
  id: totrans-2110
  prefs: []
  type: TYPE_NORMAL
  zh: 代码通过构建一个假设的缺失一边的三角形，然后使用毕达哥拉斯定理来计算两个物体中心点之间的距离，即缺失的一边。如果两个物体的总半径大于两个物体中心点之间的距离，我们就有一个重叠。
- en: Add the `detect` method with the radius overlapping code. Note that we return
    `true` if the radii overlap. This one line of code will be replaced with the more
    accurate detection later in this chapter.
  id: totrans-2111
  prefs: []
  type: TYPE_NORMAL
  zh: 添加带有半径重叠代码的 `detect` 方法。注意，如果半径重叠，我们返回 `true`。这一行代码将在本章后面替换为更精确的检测。
- en: '[PRE432]'
  id: totrans-2112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE432]'
- en: Now, let's discuss the border.
  id: totrans-2113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论边界。
- en: Implementing rectangle intersection for the border
  id: totrans-2114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现边界的矩形相交
- en: We will see if any asteroids, bullets, or the ship need containing within the
    border. As discussed, we will carry out a simple rectangle intersect test and
    return `true` if detected. Later, we will delete the return `true` and add the
    more sophisticated code.
  id: totrans-2115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将检查是否有小行星、子弹或飞船需要被包含在边界内。如前所述，我们将执行一个简单的矩形相交测试，并在检测到时返回 `true`。稍后，我们将删除返回
    `true` 并添加更复杂的代码。
- en: 'Implement the `contain` method as shown next:'
  id: totrans-2116
  prefs: []
  type: TYPE_NORMAL
  zh: 按照下面的示例实现 `contain` 方法：
- en: '[PRE433]'
  id: totrans-2117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE433]'
- en: Now, we have two methods that we just need to call them on all the appropriate
    object combinations.
  id: totrans-2118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有两个方法，我们只需要在所有适当的对象组合上调用它们。
- en: Performing the checks
  id: totrans-2119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行检查
- en: We are really close to being able to play our game, albeit with simplified collision
    detection. First add some methods that handle what happens when certain collisions
    are detected and then see how we actually use our `CD` class.
  id: totrans-2120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们离能够玩我们的游戏已经很近了，尽管碰撞检测是简化的。首先添加一些处理检测到某些碰撞时会发生什么的方法，然后看看我们如何实际使用我们的 `CD` 类。
- en: Helper methods
  id: totrans-2121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 辅助方法
- en: First of all, we need a couple of helper methods to respond, when we detect
    various types of collisions.
  id: totrans-2122
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一些辅助方法来响应，当我们检测到各种类型的碰撞时。
- en: We need a method for when the ship is destroyed and a method for when an asteroid
    is destroyed. The next two subsections cover this.
  id: totrans-2123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个方法来处理当飞船被摧毁时的情况，以及当小行星被摧毁时的情况。接下来的两个小节将涵盖这一点。
- en: Destroying a ship
  id: totrans-2124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摧毁一艘船
- en: The death of a ship can be detected in two places, so it makes sense to add
    a method to handle the events that follow. In this next method, we reset the ship's
    location to the center of the map, play a sound, and decrement `numLives`.
  id: totrans-2125
  prefs: []
  type: TYPE_NORMAL
  zh: 飞船的死亡可以在两个地方检测到，因此添加一个处理后续事件的方法是有意义的。在下一个方法中，我们将飞船的位置重置为地图中心，播放声音，并减少 `numLives`。
- en: If `numLives` is equal to zero, set `levelNumber` back to one, `numLives` to
    three, call `createObjects()` to redraw a level, pause the game, and then play
    a sound suitable to let the player know that he is starting again.
  id: totrans-2126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `numLives` 等于零，将 `levelNumber` 重置为一，将 `numLives` 设置为三，调用 `createObjects()`
    重新绘制一个关卡，暂停游戏，然后播放一个适合让玩家知道他正在重新开始的声音。
- en: 'Now, add the `lifeLost` method to the `AsteroidsRenderer` class:'
  id: totrans-2127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将 `lifeLost` 方法添加到 `AsteroidsRenderer` 类中：
- en: '[PRE434]'
  id: totrans-2128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE434]'
- en: We will handle what happens when an asteroid dies.
  id: totrans-2129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将处理小行星死亡时会发生什么。
- en: Destroying an asteroid
  id: totrans-2130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摧毁一个小行星
- en: This method will be called when the ship or a bullet hits an asteroid. First,
    we set the asteroid that triggered the collision to `setActive(false)`. It will
    not be drawn or updated any more.
  id: totrans-2131
  prefs: []
  type: TYPE_NORMAL
  zh: 当飞船或子弹击中小行星时，将调用此方法。首先，我们将触发碰撞的小行星设置为 `setActive(false)`。它将不再被绘制或更新。
- en: Next, we play a sound and decrement `numAsteroidsRemaining`. Finally if `numAsteroidsRemaining`
    is equal to zero, the player has cleared an entire level. In that case, we increment
    `levelNumber` and `numLives`, play a victorious sound, and start a harder level
    by calling `createObjects()`.
  id: totrans-2132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们播放一个声音并减少 `numAsteroidsRemaining`。最后，如果 `numAsteroidsRemaining` 等于零，玩家已经清空了一个整个关卡。在这种情况下，我们增加
    `levelNumber` 和 `numLives`，播放胜利的声音，并通过调用 `createObjects()` 开始一个更难的关卡。
- en: 'Now, add the `destroyAsteroid()` method to the `AsteroidsRenderer` class:'
  id: totrans-2133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将 `destroyAsteroid()` 方法添加到 `AsteroidsRenderer` 类中：
- en: '[PRE435]'
  id: totrans-2134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE435]'
- en: We can now call our new `CD` class's static methods and respond when we get
    a collision.
  id: totrans-2135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以调用我们新的 `CD` 类的静态方法，并在检测到碰撞时做出响应。
- en: Testing for collisions in update()
  id: totrans-2136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 update() 中测试碰撞
- en: First, we will check to see if the ship needs containing. We simply call `CD.contain()`
    with the `mapWidth`, `mapHeight`, and the ship's collision package. If there is
    a collision, the code calls `lifeLost()`.
  id: totrans-2137
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将检查飞船是否需要包含。我们只需使用`mapWidth`、`mapHeight`和飞船的碰撞包调用`CD.contain()`。如果有碰撞，代码将调用`lifeLost()`。
- en: 'Add the collision detection code after all the code that updates the objects
    in the `update` method:'
  id: totrans-2138
  prefs: []
  type: TYPE_NORMAL
  zh: 在`update`方法中更新对象的所有代码之后添加碰撞检测代码：
- en: '[PRE436]'
  id: totrans-2139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE436]'
- en: This is the code that detects if any of the asteroids are attempting to leave
    the asteroid simulator. It works exactly the same way as the previous block of
    code except that we loop through each asteroid, check if it is active, and call
    bounce on the asteroid if we detect a collision.
  id: totrans-2140
  prefs: []
  type: TYPE_NORMAL
  zh: 这是检测是否有任何小行星试图离开小行星模拟器的代码。它的工作方式与之前的代码块完全相同，只是我们遍历每个小行星，检查它是否活跃，并在检测到碰撞时在小行星上调用`bounce`。
- en: '[PRE437]'
  id: totrans-2141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE437]'
- en: The code for the bullets looks a little more complicated, but it isn't really.
    The call to `CD.contain()` is identical, and we do so for each bullet. However,
    some last minute balancing of the game play is necessary for the bullet to be
    reset as it left the viewport (if that was before the border), because otherwise
    the ship can just spin round and destroy the asteroids from a great distance.
  id: totrans-2142
  prefs: []
  type: TYPE_NORMAL
  zh: 子弹的代码看起来有点复杂，但实际上并不复杂。对`CD.contain()`的调用是相同的，我们为每个子弹都这样做。然而，为了使子弹在离开视口（如果是在边界之前）时重置，需要进行一些最后的游戏平衡，否则飞船可以绕着转并从远处摧毁小行星。
- en: 'Enter the code to detect bullet collisions with the border and the edge of
    the viewport:'
  id: totrans-2143
  prefs: []
  type: TYPE_NORMAL
  zh: 输入检测子弹与边界和视口边缘碰撞的代码：
- en: '[PRE438]'
  id: totrans-2144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE438]'
- en: You can run the game now and see how the `CD.contain()` method does a fairly
    good job of keeping everything within the asteroid simulator.
  id: totrans-2145
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以运行游戏，看看`CD.contain()`方法如何很好地将所有内容保持在小行星模拟器内。
- en: We will call our `detect` method to see if anything is bumping into an asteroid.
  id: totrans-2146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将调用`detect`方法来查看是否有任何东西撞到小行星。
- en: First, check the bullets. Note that we do a preliminary check to make sure the
    bullet is in flight, and the asteroid is active before we trouble our `CD.detect`
    method. Then, we just pass in the two collision packages and `CD.detect` does
    the rest. If a bullet collides with the border, we call `resetBullet()` on the
    appropriate bullet.
  id: totrans-2147
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，检查子弹。注意，在我们麻烦`CD.detect`方法之前，我们进行初步检查以确保子弹在飞行中，并且小行星是活跃的。然后，我们只需传入两个碰撞包，`CD.detect`就会完成剩余的工作。如果子弹与边界碰撞，我们就在适当的子弹上调用`resetBullet()`。
- en: '[PRE439]'
  id: totrans-2148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE439]'
- en: Now, we test for the ship. If a collision is detected, we call `destroyAsteroid()`
    followed by `lifeLost()`.
  id: totrans-2149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们测试飞船。如果检测到碰撞，我们调用`destroyAsteroid()`然后调用`lifeLost()`。
- en: '[PRE440]'
  id: totrans-2150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE440]'
- en: At this point, you can play the game and our rudimentary collision detection
    will work. However, fly too close to an asteroid, and you will lose a life without
    touching it or merely shoot a bullet close and the asteroid is gone. We need to
    be able to skim the surface of the border or asteroid and only get a hit when
    a point actually crosses into the exact space of another object.
  id: totrans-2151
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可以玩游戏，我们的基本碰撞检测将工作。然而，如果飞得太靠近小行星，你会在不接触它或仅射击子弹的情况下失去生命。我们需要能够擦过边界或小行星的表面，并且只有在实际点进入另一个对象的精确空间时才得分。
- en: Precise collision detection with the border
  id: totrans-2152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与边界的精确碰撞检测
- en: To upgrade our `detect` method, we need to replace the return statement in the
    `if(possibleCollision)` block with the more precise detection code.
  id: totrans-2153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了升级我们的`detect`方法，我们需要将`if(possibleCollision)`块中的返回语句替换为更精确的检测代码。
- en: First, initialize `radianAngle` to be the radian equivalent of whichever direction
    (in degrees) our object is facing. The `Math` class uses radians as they are more
    mathematically useful in calculations than the easier to visualize degree measurement.
  id: totrans-2154
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将`radianAngle`初始化为对象面向的方向的弧度等效值（以度为单位）。`Math`类使用弧度，因为它们在计算中比容易可视化的度数测量更有数学意义。
- en: The variables `cosAngle` and `sinAngle` are just what the name suggests, and
    are used in the block of code which follows this one.
  id: totrans-2155
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`cosAngle`和`sinAngle`正如其名，用于跟随此代码块的代码块中。
- en: Tip
  id: totrans-2156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It is worth mentioning that the `Math.cos()` and `Math.sin()` methods are relatively
    time consuming. We can speed up our collision detection class by precomputing
    360 values for both `sin` and `cos` and then using a simple lookup method instead
    of this calculation.
  id: totrans-2157
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`Math.cos()`和`Math.sin()`方法相对耗时。我们可以通过预先计算`sin`和`cos`的360个值，然后使用简单的查找方法来代替这个计算，从而加快我们的碰撞检测类。
- en: However, we maintain our goal of over 60 frames per second, so don't do so here.
  id: totrans-2158
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们仍然保持每秒超过60帧的目标，所以在这里不要这样做。
- en: 'Delete the return statement and add this code in the `if(possibleCollision)`
    block:'
  id: totrans-2159
  prefs: []
  type: TYPE_NORMAL
  zh: 删除返回语句，并在`if(possibleCollision)`块中添加以下代码：
- en: '[PRE441]'
  id: totrans-2160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE441]'
- en: In the next block of code, enter a `for` loop that loops through each of the
    object's vertices, translates them from model-space to world-space coordinates,
    then uses our previously computed values for cosine and sine of the `facingAngle`
    object to rotate them to their precise locations in the game world.
  id: totrans-2161
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一块代码中，输入一个`for`循环，该循环遍历对象的每个顶点，将它们从模型空间坐标转换为世界空间坐标，然后使用我们之前计算出的`facingAngle`对象的余弦和正弦值来将它们旋转到游戏世界中的精确位置。
- en: '[PRE442]'
  id: totrans-2162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE442]'
- en: Now all we do is see if the rotated and translated vertex falls outside of either
    the left, right, top, or bottom of the border/map. If it does, we return `true`;
    if not, the loop continues to check each and every vertex the same way (translate,
    rotate, check, and so on).
  id: totrans-2163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们所做的只是检查旋转并转换后的顶点是否落在边界/地图的左侧、右侧、顶部或底部之外。如果是，我们返回`true`；如果不是，循环继续以相同的方式检查每个顶点（转换、旋转、检查等）。
- en: '[PRE443]'
  id: totrans-2164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE443]'
- en: You can run the game now and watch the bullets disappear with a satisfying thud
    into the border or fly your ship deadly close to the border.
  id: totrans-2165
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以运行游戏，并观看子弹满意地砰然撞入边界或驾驶你的飞船危险地靠近边界。
- en: Let's improve our asteroid collisions.
  id: totrans-2166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们改进我们的小行星碰撞。
- en: Precise collision detection with an asteroid
  id: totrans-2167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与小行星的精确碰撞检测
- en: We did this last because there is a more complicated final step. As in the border
    detection, we will need to translate and rotate our object's vertices. However
    this time, we will need to do it for two objects.
  id: totrans-2168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做是因为有一个更复杂的最后一步。就像在边界检测中一样，我们需要转换和旋转我们的对象的顶点。然而这次，我们需要为两个对象都这样做。
- en: Furthermore, once we rotated and translated the asteroid's vertices, we will
    need to handle them in pairs of vertices that form a line. These are lines that
    we will test against each and every vertex from the other object. This test is
    of course our crossing number method that we discussed.
  id: totrans-2169
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一旦我们旋转并转换了小行星的顶点，我们还需要以顶点对的形式处理它们，这些顶点对形成了一条线。这些是我们将测试每个顶点与其他对象每个顶点的线。这个测试当然是我们之前讨论的交叉数方法。
- en: We need to do all of this within the body of the `if (distance < cp1.radius
    + cp2.radius) { ...}`, where we previously just set the `collided` Boolean to
    `true`.
  id: totrans-2170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`if (distance < cp1.radius + cp2.radius) { ...}`的主体中完成所有这些，我们之前只是将`collided`布尔值设置为`true`。
- en: There is quite a lot of code, so we will split it into chunks and see what is
    going on at each stage. Also, the code indentation will not always be consistent
    from block to block in order to format it in the most readable way possible.
  id: totrans-2171
  prefs: []
  type: TYPE_NORMAL
  zh: 代码量相当大，所以我们将它分成几块，看看每个阶段发生了什么。此外，代码缩进并不总是从块到块保持一致，以便以最可读的方式格式化。
- en: The next few blocks of code are the entire contents of the aforementioned, `if`
    block that needs replacing.
  id: totrans-2172
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几块代码是上述需要替换的`if`块的全部内容。
- en: Tip
  id: totrans-2173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: As mentioned previously, we can use a sine and cosine lookup table here too.
  id: totrans-2174
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们也可以在这里使用正弦和余弦查找表。
- en: We could make a method to rotate angles as we do this so often. But this is
    not as straightforward as it may seem. If we put the rotation code in a method,
    we will either have to put the following sine and cosine calculations in it, which
    will make it slow or precompute it before the method call and the `for` loops
    which is kind of untidy itself.
  id: totrans-2175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个方法来旋转角度，因为我们经常这样做。但这并不像看起来那么简单。如果我们把旋转代码放在方法中，我们可能不得不在它里面放以下正弦和余弦计算，这将使它变慢，或者在我们调用方法之前和`for`循环之前预先计算它，这本身也是一种不太整洁的做法。
- en: Also, if you consider that we need more than one value for both the sine and
    cosine of an angle, the method needs to *know* which value to use, and this isn't
    rocket science, but it starts to get even less compact than we might have initially
    imagined. So, I opted to avoid the method call altogether, even if the code is
    a little sprawling. Actually, if you place the whole lot in a method call, you
    still get nearly 60 FPS on an old Galaxy S2 phone. So if you want to tidy things
    up, go ahead; I just thought it was worth discussing why I did things this way.
  id: totrans-2176
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你考虑我们需要一个角度的正弦和余弦值超过一个，那么这个方法需要*知道*使用哪个值，这并不是什么火箭科学，但它开始变得比我们最初想象的还要紧凑。因此，我选择完全避免方法调用，即使代码有点零散。实际上，如果你把所有这些都放在方法调用中，你仍然可以在旧Galaxy
    S2手机上获得近60 FPS。所以如果你想整理一下，那就去做吧；我只是觉得讨论为什么我这样做是有价值的。
- en: Before we jump into the `for` loops, as we did with the border detection, we
    will compute a few things that won't change for the duration of this method. The
    sine and cosine of the facing angle from each of the two collision packages.
  id: totrans-2177
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们跳入`for`循环之前，就像我们在边界检测中做的那样，我们将计算一些在整个方法执行期间不会改变的事情。即从两个碰撞包中的每个碰撞包面对角度的正弦和余弦值。
- en: '[PRE444]'
  id: totrans-2178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE444]'
- en: Now, we loop through all the vertices from `cp2`, then test each in turn with
    all the sides (vertex pairs) from `cp1`. Remember an asteroid has an extra vertex
    of padding that is the same as the first. Therefore, we can test the last side
    of the asteroid. We must always pass in the asteroid collision package as the
    *second* argument when calling `CD.detect()`.
  id: totrans-2179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们遍历`cp2`中的所有顶点，然后依次将每个顶点与`cp1`中的所有边（顶点对）进行测试。记住，陨石有一个额外的填充顶点，它与第一个顶点相同。因此，我们可以测试陨石的最后一侧。在调用`CD.detect()`时，我们必须始终将陨石碰撞包作为第二个参数传递。
- en: In the next block of code, translate and then rotate the object being tested
    against an asteroid.
  id: totrans-2180
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一块代码中，我们将测试对象相对于陨石进行平移和旋转。
- en: '[PRE445]'
  id: totrans-2181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE445]'
- en: Now using a pair of vertices at a time, from the asteroid, translate and rotate
    both to their final world-space coordinates ready for the next block of code,
    where we will use the vertex locations calculated in the previous block and this
    block.
  id: totrans-2182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在每次使用一对顶点，从陨石中平移和旋转，使其到达最终的世界空间坐标，为下一块代码做准备，我们将使用上一块和这一块中计算出的顶点位置。
- en: '[PRE446]'
  id: totrans-2183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE446]'
- en: Here, we detect if the current vertex from either the ship or a bullet crosses
    the line formed by the current vertex pair of the asteroid. If it does, we increment
    `numCrosses`.
  id: totrans-2184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们检测当前顶点（无论是飞船还是子弹）是否跨越了由当前顶点对形成的陨石线。如果是，我们增加`numCrosses`。
- en: '[PRE447]'
  id: totrans-2185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE447]'
- en: Finally, we use the modulus operator to determine if `numCrosses` is odd or
    even. As discussed, we return `true` (collision) for odd and `false` (no collision)
    for even.
  id: totrans-2186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用模运算符来确定`numCrosses`是奇数还是偶数。如前所述，对于奇数我们返回`true`（碰撞），对于偶数返回`false`（无碰撞）。
- en: '[PRE448]'
  id: totrans-2187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE448]'
- en: 'You can now fly your ship right up to the asteroids and only get hit when it
    really looks like you should. Refer to the following screenshot:'
  id: totrans-2188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以将你的飞船开到陨石旁边，只有在真正看起来你应该被击中时才会被击中。请参考以下截图：
- en: '![Precise collision detection with an asteroid](img/B043422_11_04.jpg)'
  id: totrans-2189
  prefs: []
  type: TYPE_IMG
  zh: '![与陨石进行精确碰撞检测](img/B043422_11_04.jpg)'
- en: Now, all of our collision detection and our Asteroids simulator game is done!
  id: totrans-2190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的碰撞检测和Asteroids模拟游戏已经完成了！
- en: Finishing touches
  id: totrans-2191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后的修饰
- en: We can continue to improve our game. For example, it wouldn't be too hard to
    spawn two or three smaller asteroids when the current asteroid is destroyed. We
    just need an array to hold the smaller asteroids. When we deactivate the regular
    asteroid, the array activates some previously instantiated smaller ones at the
    same location as the regular one. We can then make some minor modifications to
    the way we count asteroids, and we will have a neat new feature.
  id: totrans-2192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续改进我们的游戏。例如，当当前小行星被摧毁时，生成两个或三个更小的陨石并不太难。我们只需要一个数组来存储这些较小的陨石。当我们停用常规陨石时，该数组会在常规陨石相同的位置激活一些之前实例化的较小陨石。然后我们可以对计算陨石数量的方式做一些小的修改，这样我们就会有一个整洁的新功能。
- en: The arcade classic, Asteroids, had a mean UFO that would turn up occasionally.
    It would be simple to design a UFO shape from lines, and have it randomly proceed
    from left to right, or right to left, moving up and down a bit as well.
  id: totrans-2193
  prefs: []
  type: TYPE_NORMAL
  zh: 休闲游戏经典《小行星》有一个平均水平的UFO偶尔会出现。设计一个由线条组成的UFO形状很简单，并且它可以随机从左到右或从右到左移动，同时上下移动一点。
- en: Finally, we can add a hyperspace button. This is a kind of last resort for the
    player when they are sure that death is imminent. Tap the hyperspace button and
    the ship will respawn in a random location. We will just need to add a button
    to the array in the `InputController` class and a call to a new, simple `randomHyperspaceJUmp`
    method in the `Ship` class.
  id: totrans-2194
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以添加一个超空间按钮。这是玩家在确信死亡即将到来时的最后手段。点击超空间按钮，飞船将在一个随机位置重生。我们只需要在`InputController`类中的数组中添加一个按钮，并在`Ship`类中调用一个新的简单`randomHyperspaceJump`方法。
- en: 'We can also add Google Play achievements and leaderboards and then publish
    the game. If you publish a game that uses OpenGL, you need to add this declaration
    to the `AndroidManifest.xml` file:'
  id: totrans-2195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以添加Google Play成就和排行榜，然后发布游戏。如果你发布一个使用OpenGL的游戏，你需要在`AndroidManifest.xml`文件中添加以下声明：
- en: '[PRE449]'
  id: totrans-2196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE449]'
- en: Try and add some of the improvements we talked about and perhaps some more of
    your own. If you publish your game or even if you don't, I would love to hear
    your ideas or see a link to your projects on [gamecodeschool.com](http://gamecodeschool.com).
  id: totrans-2197
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试添加我们讨论的一些改进，也许还可以添加一些你自己的想法。无论你是否发布你的游戏，我都非常乐意听到你的想法或看到你项目链接到[gamecodeschool.com](http://gamecodeschool.com)。
- en: I think we are done!
  id: totrans-2198
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为我们完成了！
- en: Summary
  id: totrans-2199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: I hope you have enjoyed our whirl-wind tour, making games for Android, and I
    hope you keep making lots of new games!
  id: totrans-2200
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你喜欢我们这次快速浏览，制作Android游戏，并希望你能继续制作许多新游戏！
