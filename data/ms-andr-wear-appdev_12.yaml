- en: Chapter 12. Publishing Apps to Google Play
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 12 章。将应用发布到 Google Play
- en: '*"I always believe that the sky is the beginning of the limit."            
                                                                   - MC Hammer*'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"我一直相信，天空是极限的开始。" - MC Hammer*'
- en: Testing is an important precursor to the distribution of the app via Google
    Play store. In this chapter, we will provide an overview of the importance of
    testing our Android Wear app and the tooling available for it, as well as how
    to automate UI testing. We will conclude the chapter with step-by-step instructions
    on how to get the app ready for publishing.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是应用通过 Google Play 商店分发的重要前提。在本章中，我们将概述测试我们的 Android Wear 应用的重要性以及可用的工具，以及如何自动化
    UI 测试。我们将以逐步指导结束本章，说明如何使应用准备好发布。
- en: Testing
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: It does not take too long for any programmer to learn the hard and valuable
    lesson that testing code is as important as coding itself. Ignore that lesson
    and a QA team worth its salt will be sure to bring you to your knees. Testing
    all on its own is a topic that deserves a lot of attention. There are countless
    resources, including books, out there that will sell you on a wide array of testing
    methodologies and philosophies. **Test-driven Development** (**TDD**) is worth
    researching if you are new to testing.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 任何程序员学习到测试代码与编码本身一样重要的艰难而有价值的教训都不会花费太多时间。忽视这个教训，一个有价值的 QA 团队肯定会让你屈服。测试本身就是一个值得大量关注的主题。有无数的资源，包括书籍，会向你推销各种各样的测试方法和哲学。如果你是测试的新手，**测试驱动开发**（**TDD**）值得研究。
- en: However, all that is out of the scope of this book. In this chapter, we are
    more concerned about the testing tooling provided by the Android platform geared
    toward Wear development, as well as the test APIs that are at your disposal. Let's
    take a closer look at that in the sections that follow.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，所有这些都超出了本书的范围。在本章中，我们更关注的是针对 Wear 开发提供的 Android 平台测试工具，以及可用的测试 API。让我们在接下来的部分中更详细地看看这些。
- en: The need for testing
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试的需求
- en: The single most compelling reason to test code, in general, is to catch regressions
    as early as possible in the application development life cycle. With every code
    change that is made, there is a possibility that it has impacted the way another
    area of the system works, often negatively. But by crafting well thought out (repeatable)
    tests for every isolated and smallest possible unit of code, we have a means to
    ensure that it continues to function as it is meant to. These unit tests are critical
    validation points that, through their failures, raise flags of code instability.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码的最有说服力的理由是在应用开发生命周期中尽早捕捉回归。随着每次代码更改，都有可能影响系统其他部分的工作方式，通常是负面的。但是，通过为每个独立的、尽可能小的代码单元精心设计的（可重复的）测试，我们有一种确保它继续按预期工作的手段。这些单元测试是关键验证点，通过它们的失败，会引发代码不稳定性的红旗。
- en: Since each piece of code is to be tested in isolation, it often becomes necessary
    to simulate the forces that are external to the unit of code in question. Mocking
    frameworks used in conjunction with unit tests make this easy; for example, mocking
    an external service that is called by the unit under test.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每一块代码都需要单独测试，因此通常有必要模拟与待测试代码单元外部的作用力。与单元测试一起使用的模拟框架使这变得容易；例如，模拟被测试单元调用的外部服务。
- en: Types of unit test
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试类型
- en: 'Based on whether the unit of code runs independent of the Android platform,
    there are two types of tests, local tests and instrumented test:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 根据代码单元是否独立于 Android 平台运行，有两种测试类型，本地测试和仪器化测试：
- en: '**Local tests**: These tests are the unit tests that run on the local **Java
    Virtual Machine** (**JVM**). Any code run as a local test will run without any
    dependency on the Android system, or it will at the very least be able to simulate
    such a dependency through a mocking framework.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地测试**：这些测试是在本地 **Java 虚拟机**（**JVM**）上运行的单元测试。任何作为本地测试运行的代码都将无需依赖 Android
    系统，或者至少能够通过模拟框架模拟这种依赖。'
- en: The online documentation for the step-by-step instruction on unit tests can
    found at [https://developer.android.com/training/testing/unit-testing/index.html](https://developer.android.com/training/testing/unit-testing/index.html).
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于单元测试的逐步指导的在线文档可以在 [https://developer.android.com/training/testing/unit-testing/index.html](https://developer.android.com/training/testing/unit-testing/index.html)
    找到。
- en: '**Instrumented tests**: These tests, in contrast, run on an Android device
    or emulator and are the recommended approach to run unit tests that have Android
    dependencies that are too complex or involved to simulate using mocking frameworks.
    These tests provide ready access to instrumentation information, such as access
    to the global information about an application environment through the `android.content.Context`
    class.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仪器化测试**：相比之下，这些测试在Android设备或模拟器上运行，是运行具有过于复杂或涉及Android依赖关系的单元测试的推荐方法。这些测试提供了对仪器化信息的直接访问，例如通过`android.content.Context`类访问关于应用程序环境的全局信息。'
- en: For step-by-step instructions on building instrumented tests, refer to the documentation
    at [https://developer.android.com/training/testing/unit-testing/instrumented-unit-tests.html](https://developer.android.com/training/testing/unit-testing/instrumented-unit-tests.html).
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于构建仪器化测试的逐步说明，请参阅[https://developer.android.com/training/testing/unit-testing/instrumented-unit-tests.html](https://developer.android.com/training/testing/unit-testing/instrumented-unit-tests.html)上的文档。
- en: One difference that will jump out at you right away is that in your Android
    Studio project, the source files for local unit tests are stored in the `module-name/src/test/java`
    folder, while the source files for instrumented unit tests are stored in the `module-name/src/androidTest/java`
    folder.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一个会立即引起你注意的区别是，在你的Android Studio项目中，本地单元测试的源文件存储在`module-name/src/test/java`文件夹中，而仪器化单元测试的源文件存储在`module-name/src/androidTest/java`文件夹中。
- en: Automating user interface tests
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化用户界面测试
- en: For Wear apps in particular, there are certain aspects of development that need
    to be tested very carefully, and unit tests may not be sufficient in these cases.
    Complex UI interactions are one such example. Ideally, a human tester would be
    able to catch many of these issues, but it does not take long for that to prove
    inefficient in terms of time and cost, not to mention prone to human error and
    oversight.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于特定于Wear的应用，有一些开发方面需要非常仔细地测试，单元测试在这些情况下可能不足以满足需求。复杂的UI交互就是一个例子。理想情况下，人类测试员能够捕捉到许多这些问题，但很快就会证明这在时间和成本上效率低下，更不用说容易受到人为错误和疏忽的影响。
- en: By writing our UI tests to simulate human interaction, we can save time and
    increase confidence in the quality of our tests. Automated UI tests are coded
    in the same designated Android test folder as our instrumented unit tests, that
    is, the `module-name/src/androidTest/java` folder.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写我们的UI测试来模拟人类交互，我们可以节省时间并提高我们对测试质量的信心。自动化的UI测试是用与我们的仪器化单元测试相同的指定Android测试文件夹编写的，即`module-name/src/androidTest/java`文件夹。
- en: Code implemented in this folder is built by the Android plugin for Gradle and
    executed on the same device that the app is intended to run on. This lets us use
    UI testing frameworks to simulate user interactions on the target app. Furthermore,
    automated UI tests may span a single app or multiple apps.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件夹中实现的代码是由Android插件为Gradle构建的，并在应用打算运行的同一设备上执行。这使得我们可以使用UI测试框架来模拟目标应用上的用户交互。此外，自动化的UI测试可以跨越单个应用或多个应用。
- en: Single app tests, using a UI testing framework such as **Espresso**, allow us
    to programmatically simulate user interactions such as entering a specific input
    on a specific activity. They also let us exercise the effects of user interactions
    on various activities of the app by letting us test that the correct UI output
    is rendered in response to a piece of user interaction.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 单应用测试，使用如**Espresso**这样的UI测试框架，允许我们以编程方式模拟用户交互，例如在特定活动上输入特定的输入。它们还允许我们通过测试正确的UI输出是否在用户交互后呈现来锻炼用户交互对应用各种活动的影响。
- en: Multi-app tests (also known as the cross-app functional tests), using a UI testing
    framework such as UI Automator, let us verify interactions between apps. For instance,
    if we wanted our test to launch (say) the calculator app and perform a calculation
    that will, in turn, be used to drive an input to a field in our app, **UI Automator**
    makes this possible.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 多应用测试（也称为跨应用功能测试），使用如UI Automator这样的UI测试框架，使我们能够验证应用之间的交互。例如，如果我们想使我们的测试启动（比如说）计算器应用并执行一个计算，这个计算反过来将被用来驱动我们应用中的一个字段输入，**UI
    Automator**使这成为可能。
- en: Test APIs
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试API
- en: Android tests are based on **JUnit**. We write our unit or integration test
    classes as JUnit 4 classes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Android测试基于**JUnit**。我们编写我们的单元或集成测试类作为JUnit 4类。
- en: JUnit
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JUnit
- en: JUnit is an instance of the **xUnit** architecture for unit testing frameworks.
    It offers a way to perform common setup, teardown, and assertion operations in
    our unit tests. A test class can contain one or more methods. Common JUnit annotations
    can be used to mark a method that performs setup work (the `@Before` class) or
    teardown work (the `@After` class) work. The `@Test` annotation marks a test method.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 是单元测试框架的 **xUnit** 架构的一个实例。它为我们提供了在单元测试中执行常见设置、拆解和断言操作的方法。一个测试类可以包含一个或多个方法。常见的
    JUnit 注解可以用来标记执行设置工作（`@Before` 类）或拆解工作（`@After` 类）的方法。`@Test` 注解标记测试方法。
- en: From within a JUnit test class, we can use the `AndroidJUnitRunner` test runner
    class to invoke the Espresso or UI Automator APIs to implement our user interactions
    and inter-app simulations.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JUnit 测试类内部，我们可以使用 `AndroidJUnitRunner` 测试运行器类来调用 Espresso 或 UI Automator
    API 以实现我们的用户交互和应用程序间模拟。
- en: The AndroidJUnitRunner class
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`AndroidJUnitRunner` 类'
- en: 'The `AndroidJUnitRunner` class is a test runner that lets us run JUnit test
    classes on Android devices. The test runner loads our test package and our app
    to a device and then runs our tests and reports results. Apart from JUnit support,
    the `AndroidJUnitRunner` class includes the following features:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`AndroidJUnitRunner` 类是一个测试运行器，它允许我们在 Android 设备上运行 JUnit 测试类。测试运行器将我们的测试包和我们的应用到设备上加载，然后运行我们的测试并报告结果。除了
    JUnit 支持，`AndroidJUnitRunner` 类还包括以下功能：'
- en: '**Access to instrumentation information**: An `InstrumentationRegistry` class
    provides easy access to the instrumentation object, the target app''s `Context`
    object, and the test app''s `Context` object. This data becomes particularly useful
    when our tests use the UI Automator framework.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问仪器信息**：`InstrumentationRegistry` 类提供了对仪器对象、目标应用的 `Context` 对象和测试应用的 `Context`
    对象的便捷访问。当我们的测试使用 UI Automator 框架时，这些数据变得特别有用。'
- en: '**Test filtering**: In addition to standard annotations supported by JUnit
    4, some Android-specific annotations are also available. The `@RequiresDevice`
    annotation specifies that the test should run only on physical devices (and not
    on emulators). The `@SdkSuppress` annotation keeps the test from running on an
    Android API level that is lower than a specified level; for example, the `@SDKSupress(minSdkVersion=18)`
    annotation will suppress tests on all API levels that are lower than 18.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试过滤**：除了 JUnit 4 支持的标准注解外，还有一些特定于 Android 的注解也可用。`@RequiresDevice` 注解指定测试应在物理设备上运行（而不是在模拟器上）。`@SdkSuppress`
    注解阻止测试在低于指定级别的 Android API 级别上运行；例如，`@SDKSupress(minSdkVersion=18)` 注解将抑制所有低于
    18 的 API 级别的测试。'
- en: '**Test Sharding**: The `AndroidJUnitRunner` class provides support to split
    a test suite into multiple shards thereby allowing the grouping of tests by any
    given shard (identifiable by an index number).'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试分片**：`AndroidJUnitRunner` 类提供了将测试套件拆分为多个分片的支持，从而允许通过任何给定的分片（通过索引号识别）对测试进行分组。'
- en: Espresso
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Espresso
- en: Espresso is a testing framework geared toward testing user flows within an app.
    It provides a set of APIs that let us craft tests that use the implementation
    details from the app that is being tested. Features include view and adapter matching,
    action APIs, and UI thread synchronization, each discussed briefly in the following
    sections.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Espresso 是一个针对测试应用内部用户流程的测试框架。它提供了一套 API，使我们能够创建使用正在测试的应用的实现细节的测试。功能包括视图和适配器匹配、动作
    API 和 UI 线程同步，这些内容将在以下各节中简要介绍。
- en: View and Adapter matching
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 视图和适配器匹配
- en: 'The `Expresso.onView()` method gives us access to a specific UI component in
    the target app. The method searches the view hierarchy for a match and returns
    a View reference that meets the specified criteria (which is supplied as part
    of the matcher argument passed to the method). Consider the following example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`Expresso.onView()` 方法让我们能够访问目标应用中的特定 UI 组件。该方法在视图层次结构中搜索匹配项，并返回一个满足指定标准（作为方法传递的匹配器参数的一部分提供）的
    View 引用。考虑以下示例：'
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The returned reference can then be used to perform user actions on it or test
    assertions against it.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的引用可以用来执行用户操作或对其执行断言。
- en: While View matching lets you bring back a View reference, Adapter matching is
    useful when the target View is inside a layout that is subclassed from the `AdapterView`
    class. In this case, only a subset of the layout's views may be loaded in the
    current view hierarchy. The `Espresso.onData()` method can be used to access a
    target view element.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当 View 匹配让您能够恢复 View 引用时，Adapter 匹配在目标 View 位于继承自 `AdapterView` 类的布局内部时非常有用。在这种情况下，当前视图层次结构中可能只加载布局的子集视图。可以使用
    `Espresso.onData()` 方法来访问目标视图元素。
- en: Action APIs
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动作 API
- en: Using the `android.support.test.espresso.action.ViewActions` API, we can perform
    user actions such as clicks, swipes, button presses, text entry, and hyperlinking.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `android.support.test.espresso.action.ViewActions` API，我们可以执行用户操作，如点击、滑动、按钮按下、文本输入和超链接。
- en: UI Automator
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UI Automator
- en: Google's UI Automator provides a set of APIs that enables UI tests to interact
    with user apps and system apps. The UI Automator API lets us programmatically
    open the **Settings** menu or the app launcher on a test device. If the test code
    does not depend on the implementation details of the target app, then the UI Automator
    framework can be a good candidate for writing automated tests.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Google 的 UI Automator 提供了一套 API，它使 UI 测试能够与用户应用和系统应用交互。UI Automator API 允许我们以编程方式在测试设备上打开
    **设置** 菜单或应用启动器。如果测试代码不依赖于目标应用的实现细节，那么 UI Automator 框架可以是一个编写自动化测试的好选择。
- en: 'This framework includes the following components:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此框架包括以下组件：
- en: The UI Automator viewer to inspect layout hierarchy and view properties of UI
    components that are visible in the device foreground. This tool is located in
    the `<android-sdk>/tools` directory.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI Automator 查看器用于检查设备前台可见的 UI 组件的布局层次结构和视图属性。此工具位于 `<android-sdk>/tools` 目录中。
- en: The `android.support.test.uiautomator.UiDevice` API to retrieve state information
    and perform operations on the device on which the target app is running. The `UiDevice`
    class supports operations such as changing the device rotation, pressing the back,
    home, or menu buttons; and taking a screenshot of the current view.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android.support.test.uiautomator.UiDevice` API 用于检索目标应用运行设备的状态信息并执行操作。`UiDevice`
    类支持更改设备旋转、按下后退、主页或菜单按钮以及截取当前视图的屏幕截图等操作。'
- en: 'The following code snippet demonstrates how the `UiDevice` class can be used
    easily to simulate a short press on the home button:'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下代码片段演示了如何轻松使用 `UiDevice` 类来模拟对主按钮的短按：
- en: '[PRE1]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The UI Automator APIs that support cross-app UI testing. These APIs let us capture
    and manipulate UI components across multiple apps.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持跨应用 UI 测试的 UI Automator API。这些 API 允许我们捕获和操作多个应用中的 UI 组件。
- en: Monkey and monkeyrunner
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Monkey 和 monkeyrunner
- en: Monkey is a command-line tool that sends pseudorandom streams of gestures, keystrokes
    and touches to devices. It is run via the **Android Debug Bridge** (**ADB**) tool,
    and is primarily meant to stress test your app.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Monkey 是一个命令行工具，它向设备发送伪随机的手势、按键和触摸流。它通过 **Android 调试桥**（**ADB**）工具运行，主要用于对您的应用进行压力测试。
- en: Monkeyrunner is an API and execution environment for test programmers coded
    in Python. It includes functions for connecting to a device, installing and uninstalling
    packages, taking screenshots, and so on. A monkeyrunner command-line tool is available
    to run programs that use the monkeyrunner API.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Monkeyrunner 是一个用于测试程序员的 API 和执行环境，这些程序是用 Python 编写的。它包括连接到设备、安装和卸载包、截图等功能。Monkeyrunner
    命令行工具可用于运行使用 monkeyrunner API 的程序。
- en: For a more in-depth look at these topics, as well as how to measure UI performance
    and automate UI performance tests, we should take a look at the online documentation
    on the developer's site ([https://developer.android.com/training/testing/start/index.html](https://developer.android.com/training/testing/start/index.html))
    as our primary reference.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要深入了解这些主题，以及如何衡量 UI 性能和自动化 UI 性能测试，我们应该查看开发者网站上关于这些主题的在线文档（[https://developer.android.com/training/testing/start/index.html](https://developer.android.com/training/testing/start/index.html)）作为我们的主要参考。
- en: The human touch
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 人的触摸
- en: No matter how solid our automated testing strategy, we really haven't tested
    our app until we have used it. That is why it is paramount to set time aside in
    our development cycle to test out the various features of our app, as well as
    user interactions. Every UI implementation code path must be exercised. There
    is no substitute for visual verification when it comes to confirming that our
    screens render acceptably in both square and round watch faces.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们的自动化测试策略多么稳固，我们直到使用它之前都没有真正测试过我们的应用。这就是为什么在开发周期中留出时间来测试我们应用的各种功能和用户交互至关重要。每个UI实现代码路径都必须进行测试。在确认我们的屏幕在方形和圆形手表表面上都能良好渲染时，视觉验证是无可替代的。
- en: There may also be valuable insights gained to help us improve the way our user
    interactions are implemented. We should leverage the material design concepts
    we covered in previous chapters and use them to our advantage as much as possible.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可能获得有价值的见解，帮助我们改进用户交互的实现方式。我们应该利用我们在前几章中介绍的材料设计概念，并尽可能多地利用它们。
- en: App distribution
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用分发
- en: In the previous section, we covered in some detail how to test our app. Testing
    is a prerequisite for distribution, and it would serve us well to familiarize
    ourselves with what differentiates a Wear app in terms of quality. Check out the
    article from the online documentation at [https://developer.android.com/distribute/essentials/quality/wear.html](https://developer.android.com/distribute/essentials/quality/wear.html),
    which serves as a reminder in this regard.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们详细介绍了如何测试我们的应用。测试是分发的先决条件，了解在质量方面区分Wear应用的不同之处对我们大有裨益。查看在线文档中的文章[https://developer.android.com/distribute/essentials/quality/wear.html](https://developer.android.com/distribute/essentials/quality/wear.html)，这可以作为这方面的提醒。
- en: Once we have implemented our well-designed app and tested it as much as we can,
    we can start preparing to distribute it to potential users. That is the focus
    of this section to examine how to ready and distribute our Wear apps to users
    through Google Play.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们实现了精心设计的应用并尽可能多地进行了测试，我们就可以开始准备将其分发给潜在用户。本节的重点是检查如何通过Google Play准备和分发我们的可穿戴应用给用户。
- en: Packaging
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打包
- en: As we go through the process of building our release APKs using Android Studio,
    we find that two different APKs are generated, one for mobile and one for wearable.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用Android Studio构建发布APK的过程中，我们发现生成了两个不同的APK，一个用于移动，一个用于可穿戴。
- en: 'Packaging a wearable app in Android Studio involves the following steps:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中打包可穿戴应用涉及以下步骤：
- en: Replicate all permissions from the manifest file of the wearable app module
    to the manifest file of the handheld app module.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将可穿戴应用模块的清单文件中的所有权限复制到手持应用模块的清单文件中。
- en: Ensure that the wearable and handheld app modules have the same package name
    and version number.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保可穿戴和手持应用模块具有相同的包名和版本号。
- en: Specify a Gradle dependency in the handheld app's `build.gradle` file to the
    wearable app module.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在手持应用的`build.gradle`文件中指定一个Gradle依赖项到可穿戴应用模块。
- en: Navigate to **Build** | **Generate Signed APK...**.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**构建** | **生成签名APK...**。
- en: 'These steps are illustrated in the following screenshot:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤在以下屏幕截图中进行了说明：
- en: '![Packaging](img/image00234.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![打包](img/image00234.jpeg)'
- en: 'Pick a module to generate the APK for mobile or wear, as shown in the following
    screenshot:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个模块来生成移动或可穿戴的APK，如图所示：
- en: '![Packaging](img/image00235.jpeg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![打包](img/image00235.jpeg)'
- en: 'Specify your release keystore by creating a new one or picking the one you
    already have available:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个新的或选择你已有的一个来指定你的发布密钥库：
- en: '![Packaging](img/image00236.jpeg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![打包](img/image00236.jpeg)'
- en: 'Here, we create a new keystore path and sign our app using it:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个新的密钥库路径，并使用它对我们的应用进行签名：
- en: '![Packaging](img/image00237.jpeg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![打包](img/image00237.jpeg)'
- en: 'Specify a destination folder for the APK files and then click **Finish**, as
    shown in the following screenshot:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 指定APK文件的目标文件夹，然后点击**完成**，如图所示：
- en: '![Packaging](img/image00238.jpeg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![打包](img/image00238.jpeg)'
- en: 'We should now find the two APK files available in the folder we specified:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该找到我们在指定文件夹中可用的两个APK文件：
- en: '![Packaging](img/image00239.jpeg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![打包](img/image00239.jpeg)'
- en: Publishing and opt-in
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布和同意
- en: Once we have built our APKs, run it through our tests for Wear app quality and
    determined that it is ready for release, we upload it to the **Developer Console**.
    This is the step during which we set up distribution options and update the store
    listing with any screenshots of our Wear app. A detailed launch checklist is available
    in the online documentation ([https://developer.android.com/distribute/tools/launch-checklist.html](https://developer.android.com/distribute/tools/launch-checklist.html)),
    and it is recommended that you read it prior to publishing.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们构建了APK文件，通过Wear app质量测试并确定其已准备好发布，我们将其上传到**开发者控制台**。这是我们设置分发选项并更新Wear app商店列表的截图。详细的发布清单可在在线文档中找到（[https://developer.android.com/distribute/tools/launch-checklist.html](https://developer.android.com/distribute/tools/launch-checklist.html)），建议在发布前阅读。
- en: 'Once our app is ready for release, we may opt into Android Wear from the *Pricing
    and Distribution* section of the Developer Console. Opt-in implies that our app
    meets the Wear app quality criteria and is an affirmation that we want our app
    to be made more discoverable to Android Wear users through Google Play. Consider
    the following diagram depicting the process:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的app准备就绪，我们可以在开发者控制台的**定价和分发**部分选择Android Wear。自愿参与意味着我们的app符合Wear app质量标准，并且是我们希望通过Google
    Play使我们的app对Android Wear用户更具可发现性的确认。以下图表展示了该过程：
- en: '![Publishing and opt-in](img/image00240.jpeg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![发布和自愿参与](img/image00240.jpeg)'
- en: Once we have opted in, we can publish our app as usual, at which stage Google
    Play submits our app for review against the **Wear App Quality criteria**. We
    are notified of the results once they become available. If the app is found to
    meet all the Wear App quality criteria, Google Play will proceed to make it more
    discoverable to Android Wear users.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们自愿参与，我们就可以像往常一样发布我们的app，此时Google Play会根据**Wear App质量标准**对我们的app进行审查。一旦结果可用，我们会收到通知。如果发现app符合所有Wear
    App质量标准，Google Play将采取措施使其对Android Wear用户更具可发现性。
- en: If, however, the app is found to fall short, then an e-mail notification is
    sent to our developer account address with the areas highlighted requiring our
    attention. Once we address these issues, we can upload a new version of our app
    to the Developer Console to initiate another round of opt-in and review.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果发现应用存在不足，则会向我们的开发者账户地址发送电子邮件通知，其中突出显示需要我们注意的区域。一旦我们解决了这些问题，我们就可以将新版本的app上传到开发者控制台，以启动另一轮的自愿参与和审查。
- en: The *Pricing and Distribution* page in the *Android Wear* section of the **Google
    Play Developer Console** holds the review and approval status of our app at any
    given time.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**Google Play开发者控制台**中**Android Wear**部分的**定价和分发**页面持有我们app在任何给定时间的审查和批准状态。'
- en: 'We click on the **Add new application** button, as shown in the following screenshot,
    to upload our app:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如下截图所示，我们点击**添加新应用**按钮来上传我们的app：
- en: '![Publishing and opt-in](img/image00241.jpeg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![发布和自愿参与](img/image00241.jpeg)'
- en: 'We specify a default language and a title before proceeding to upload the APK:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在上传APK之前，我们指定一个默认语言和标题：
- en: '![Publishing and opt-in](img/image00242.jpeg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![发布和自愿参与](img/image00242.jpeg)'
- en: 'Choose the type of release, that is, **Production**, **Beta**, or **Alpha Testing** ,
    and then click the relevant **Upload** button:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 选择发布类型，即**生产**、**Beta**或**Alpha测试**，然后点击相应的**上传**按钮：
- en: '![Publishing and opt-in](img/image00243.jpeg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![发布和自愿参与](img/image00243.jpeg)'
- en: 'We then pick our Wear (or mobile) APK file and attempt the upload, depicted
    in the following screenshot:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后选择我们的穿戴（或移动）APK文件并尝试上传，如下截图所示：
- en: '![Publishing and opt-in](img/image00244.jpeg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![发布和自愿参与](img/image00244.jpeg)'
- en: 'At this point, we are prompted to fill in app metadata that is necessary for
    publishing:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段，我们会提示填写必要的app元数据以进行发布：
- en: '![Publishing and opt-in](img/image00245.jpeg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![发布和自愿参与](img/image00245.jpeg)'
- en: 'We can click on the **Why can''t I publish?**  link in the top-right corner
    to display any items that are missing. Here is an example of all the items needed
    to publish the app. Once they are added, the app should be ready for publishing:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以点击右上角的**为什么我无法发布？**链接以显示任何缺失的项目。以下是需要发布app的所有项目的示例。一旦添加，app应准备好发布：
- en: '![Publishing and opt-in](img/image00246.jpeg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![发布和自愿参与](img/image00246.jpeg)'
- en: Summary
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced Android testing and distinguished between local
    unit tests and instrumented tests. We then summarized the tooling available for
    testing our wear apps in Android Studio before we took a brief look at how to
    accomplish automation with UI testing. We concluded with a discussion of the stages
    that must be traversed when preparing our apps for distribution via Google Play.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Android测试，并区分了本地单元测试和仪器化测试。然后，在我们简要了解如何通过UI测试实现自动化之前，我们总结了在Android
    Studio中测试我们的可穿戴应用可用的工具。最后，我们讨论了在准备通过Google Play分发我们的应用时必须跨越的阶段。
