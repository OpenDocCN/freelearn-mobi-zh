- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Using Platform-Specific Features
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用平台特定功能
- en: In the last six chapters, we developed a fundamental password manager app. So
    far, all platform-specific features have been managed by .NET MAUI, making the
    developed features appear platform-agnostic. However, addressing platform-specific
    features is not always avoidable. In this chapter, we will delve into the implementation
    of such features.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的六章中，我们开发了一个基本的密码管理器应用程序。到目前为止，所有平台特定功能都由 .NET MAUI 管理，使得开发的功能看起来是平台无关的。然而，处理平台特定功能并非总是可以避免的。在本章中，我们将深入探讨这些功能的实现。
- en: We will explore how to utilize device features on supported platforms. By applying
    the knowledge gained in this chapter, we will incorporate fingerprint support
    and a customized Markdown view into our app.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨如何在支持的平台上利用设备功能。通过应用本章获得的知识，我们将把指纹支持和定制的 Markdown 视图集成到我们的应用程序中。
- en: While this chapter does touch on platform-specific features, its primary focus
    isn’t platform-specific programming. Delving deeper into platform-specific implementations
    would require specific programming knowledge for Android, iOS, WinUI, and so on.
    Given this would require a considerable amount of knowledge, instead of teaching
    you to write your own plugins or specific UI controls for each platform, we will
    consider some of the high-level concepts involved in creating these elements.
    To help you become familiar with these concepts, our focus will be on how to extend
    these features and incorporate them into our app.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本章确实涉及了平台特定功能，但其主要焦点不是平台特定编程。深入了解平台特定实现需要针对 Android、iOS、WinUI 等特定编程知识。鉴于这需要相当多的知识，我们不会教您为每个平台编写自己的插件或特定的
    UI 控件，而是会考虑创建这些元素所涉及的一些高级概念。为了帮助您熟悉这些概念，我们的重点将放在如何扩展这些功能并将它们集成到我们的应用程序中。
- en: To use .NET for native application development, you would need to write a specialized
    book for each platform. You can refer to the *Further reading* section for more
    information about Android and iOS native application development using Xamarin.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 .NET 进行原生应用程序开发，您需要为每个平台编写一本专门的书籍。您可以参考 *进一步阅读* 部分，了解更多关于使用 Xamarin 进行 Android
    和 iOS 原生应用程序开发的信息。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Implementing platform-specific code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现平台特定代码
- en: .NET MAUI plugins
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET MAUI 插件
- en: Customizing controls
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义控件
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To test and debug the source code in this chapter, you need to have Visual Studio
    2022 installed on your PC or Mac. Please refer to the *Development environment
    setup* section in *Chapter 1*, *Getting Started with .NET MAUI*, for the details.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试和调试本章中的源代码，您需要在您的 PC 或 Mac 上安装 Visual Studio 2022。请参阅 *第 1 章*，*使用 .NET MAUI
    入门* 中的 *开发环境设置* 部分，以获取详细信息。
- en: 'The source code for this chapter is available in the following GitHub repository:
    [https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/main/2nd/chapter07](https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/269e26ce42e9d82430a8c8deeda25ffb80a501d0).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可在以下 GitHub 仓库中找到：[https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/main/2nd/chapter07](https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/269e26ce42e9d82430a8c8deeda25ffb80a501d0).
- en: 'To check out the source code of this chapter, we can use the below command:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看本章的源代码，我们可以使用以下命令：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To find out more about the source code in this book, please refer to the section
    *Managing the source code in this book* in *Chapter 2*, *Building Our First .NET
    MAUI App*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本书中源代码的信息，请参阅 *第 2 章*，*构建我们的第一个 .NET MAUI 应用程序* 中的 *管理本书中的源代码* 部分。
- en: Implementing platform-specific code
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现平台特定代码
- en: In the realm of .NET MAUI application development, there are numerous instances
    where we might need to write platform-specific code. In this section, we will
    examine the guidelines for implementing such code. Following that, we will explore
    the two most common scenarios that necessitate writing platform-specific code
    in this chapter. The first scenario involves accessing platform features that
    are not readily available in .NET MAUI APIs. The second scenario may require creating
    custom controls or customizing existing controls.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET MAUI应用程序开发领域，我们可能会遇到许多需要编写特定平台代码的实例。在本节中，我们将探讨实现此类代码的指南。随后，我们将在本章中探讨两种最常见需要编写特定平台代码的场景。第一种场景涉及访问.NET
    MAUI API中不可直接使用的平台功能。第二种场景可能需要创建自定义控件或自定义现有控件。
- en: Before delving into how to access platform APIs, it’s important to distinguish
    between the terms .NET MAUI API and platform API. In *Chapter 1*, *Getting Started
    with .NET MAUI*, we have the following architecture diagram of a .NET MAUI application
    (*Figure 7.1*).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨如何访问平台API之前，区分.NET MAUI API和平台API这两个术语非常重要。在*第一章* *开始使用.NET MAUI*中，我们有以下.NET
    MAUI应用程序的架构图（*图7.1*）。
- en: '![A group of colorful rectangular boxes with text  Description automatically
    generated](img/B21554_07_01.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![一组带有文本的多彩矩形框，描述由自动生成](img/B21554_07_01.png)'
- en: 'Figure 7.1: .NET MAUI architecture'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '图7.1: .NET MAUI架构'
- en: 'Since most of the components in the architectural diagram are open-source,
    I’ve numbered the components for the discussion. You can reference these numbers
    in the *Further reading* section to locate the corresponding source code on GitHub:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于架构图中的大多数组件都是开源的，我已经为这些组件编号以便讨论。您可以在*进一步阅读*部分引用这些编号，以在GitHub上找到相应的源代码：
- en: '**.NET MAUI APIs** **(6)** are the cross-platform APIs offered by the .NET
    MAUI framework. These APIs maintain consistency and unification across various
    platforms.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**.NET MAUI API** **(6**) 是.NET MAUI框架提供的跨平台API。这些API在各个平台之间保持一致性和统一性。'
- en: '**Platform APIs** **(7)(8)(9)(10)**, on the other hand, pertain to the platform-specific
    APIs provided by the underlying target platforms (Android, iOS/macOS, and Windows).
    These APIs enable you to access native features, devices, and functionalities
    unique to each platform.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平台API** **(7)(8)(9)(10**)，另一方面，涉及由底层目标平台（Android、iOS/macOS和Windows）提供的特定平台API。这些API允许您访问每个平台特有的本地功能、设备和功能。'
- en: Generally, to incorporate platform code in .NET MAUI, we can utilize techniques
    such as conditional compilation and interfaces, as well as partial classes and
    methods.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，要将平台代码集成到.NET MAUI中，我们可以利用条件编译、接口以及部分类和方法等技术。
- en: Conditional compilation
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件编译
- en: In .NET MAUI, it is possible to employ conditional compilation to invoke platform-specific
    code by defining compiler directives tailored to each platform. These directives
    enable you to incorporate or omit particular code segments, depending on the target
    platform throughout the compilation process.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET MAUI中，可以通过定义针对每个平台的编译器指令来使用条件编译调用特定平台的代码。这些指令允许你在编译过程中根据目标平台包含或省略特定的代码段。
- en: 'In the subsequent code snippet, the Markdown encoding varies on Android. By
    utilizing conditional compilation, we can manage the Android code independently:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在随后的代码片段中，Android上的Markdown编码有所不同。通过使用条件编译，我们可以独立管理Android代码：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This modular approach enables the effective use of platform-specific APIs while
    preserving a shared codebase, facilitating a more seamless cross-platform development
    process. The conditional compilation method described is typically used for simple
    implementations. However, if platform-specific implementations involve more complex
    logic, it’s best to utilize interfaces and partial classes. These provide a more
    structured approach, allowing for better organization and maintainability of the
    code, especially when dealing with complex, platform-specific logic.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模块化方法使得在保持共享代码库的同时，有效地使用特定平台的API，从而促进了更顺畅的跨平台开发过程。所描述的条件编译方法通常用于简单的实现。然而，如果特定平台的实现涉及更复杂的逻辑，最好利用接口和部分类。这些提供了更结构化的方法，有助于更好地组织和管理代码，尤其是在处理复杂、特定平台的逻辑时。
- en: Interfaces, partial class, and methods
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口、部分类和方法
- en: 'Using interfaces, partial classes, and methods to implement platform-specific
    features provides several benefits to developers when building cross-platform
    applications, ensuring clean code organization, maintainability, and flexibility.
    Here are the advantages of using these techniques:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用接口、部分类和方法来实现平台特定功能，在构建跨平台应用程序时为开发者提供了许多好处，确保了代码组织的清洁性、可维护性和灵活性。以下是使用这些技术的优势：
- en: 'Abstraction and modularity:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象和模块化：
- en: '**Interfaces**: Interfaces provide a way to define contracts that must be implemented
    by the platform-specific classes, encapsulating platform-specific code while ensuring
    consistency across different platform implementations. This promotes a clear separation
    of concerns and allows for modular code that is easier to manage and maintain.'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口**：接口提供了一种定义必须由平台特定类实现合约的方法，封装了平台特定代码，同时确保了不同平台实现的一致性。这促进了关注点的清晰分离，并允许模块化代码，使其更容易管理和维护。'
- en: '**Partial classes**: Partial classes enable you to split the implementation
    of a single class across multiple files, which is particularly useful when working
    with platform-specific features. Each platform’s implementation can be separated
    into different files, resulting in cleaner and more organized code.'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部分类**：部分类允许你将单个类的实现拆分到多个文件中，这在处理平台特定功能时特别有用。每个平台的实现可以分别放入不同的文件中，从而产生更干净、更有组织的代码。'
- en: 'Code reusability and maintainability:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码重用性和可维护性：
- en: Using interfaces allows you to create reusable components that can be easily
    plugged into different platform-specific implementations without modifying the
    shared code. This improves maintainability, as changes in platform-specific code
    do not affect the rest of the application, reducing the potential for errors and
    simplifying updates.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用接口允许你创建可重用的组件，这些组件可以轻松地插入到不同的平台特定实现中，而无需修改共享代码。这提高了可维护性，因为平台特定代码的变化不会影响应用程序的其他部分，从而减少了错误的可能性并简化了更新。
- en: Partial methods serve as optional method implementations within partial classes.
    They enable you to define a method signature in the shared code without providing
    an implementation. The platform-specific code can then provide the implementation
    if needed, which can be left empty otherwise. This approach keeps the codebase
    cleaner by avoiding unnecessary empty method implementations and helps to maintain
    a more consistent structure across platforms.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 部分方法作为部分类中的可选方法实现。它们允许你在共享代码中定义方法签名，而不提供实现。平台特定代码可以在需要时提供实现，否则可以留空。这种方法通过避免不必要的空方法实现，使代码库更干净，并有助于在平台之间保持更一致的结构。
- en: 'Flexibility and testability:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灵活性和可测试性：
- en: Interfaces offer flexibility when implementing platform-specific features, as
    different implementations can be easily swapped for testing purposes or to support
    future platforms. It allows for dependency injection, making it easier to write
    unit tests and mock platform-specific components during development and testing.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接口在实现平台特定功能时提供了灵活性，因为不同的实现可以轻松地交换用于测试目的或支持未来平台。它允许依赖注入，使得在开发和测试期间编写单元测试和模拟平台特定组件变得更加容易。
- en: In order to utilize platform features that are not directly supported by .NET
    MAUI, we typically create components known as plugins. In the upcoming section,
    we will use the fingerprint plugin as a case study to gain insight into the implementation
    of .NET MAUI plugins through interfaces, partial classes, or abstract classes.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了利用.NET MAUI不支持的平台功能，我们通常创建称为插件的组件。在接下来的部分中，我们将使用指纹插件作为一个案例研究，通过接口、部分类或抽象类来深入了解.NET
    MAUI插件的实现。
- en: .NET MAUI/Xamarin plugins
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET MAUI/Xamarin插件
- en: To utilize platform features in a cross-platform manner, we typically create
    components known as plugins. In .NET MAUI plugins (or Xamarin plugins), we establish
    cross-platform APIs to access native platform features or services. These plugins
    empower you to write platform-independent code in your shared project while concurrently
    harnessing native functionality on each platform (Android, iOS, macOS, and Windows).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以跨平台的方式利用平台功能，我们通常创建称为插件的组件。在.NET MAUI插件（或Xamarin插件）中，我们建立跨平台API来访问原生平台功能或服务。这些插件使你能够在共享项目中编写平台无关的代码，同时同时在每个平台上（Android、iOS、macOS和Windows）利用原生功能。
- en: Plugins abstract platform-specific code, enabling you to use a standardized
    API in your shared project for accessing native features. This streamlines development
    and helps you maintain a neater and more readable codebase that adheres to the
    **Model-View-ViewModel** (**MVVM**) pattern.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 插件抽象了平台特定的代码，使您能够在共享项目中使用标准化的API来访问原生功能。这简化了开发，并帮助您维护一个更整洁、更易于阅读的代码库，遵循**模型-视图-视图模型**（**MVVM**）模式。
- en: Although I have used the term “.NET MAUI plugins,” it’s important to note that
    it’s not limited purely to .NET MAUI. In fact, it’s possible to develop a plugin
    that can be used by both .NET MAUI and Xamarin.Forms simultaneously. Typically,
    a plugin is a multi-target .NET project where the developer can decide the number
    of platforms to support. The content in this chapter regarding plugins is also
    applicable to .NET MAUI Blazor Hybrid apps. We will delve into .NET MAUI Blazor
    Hybrid app development in the next chapter.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我使用了“.NET MAUI插件”这个术语，但重要的是要注意，它并不仅限于.NET MAUI。实际上，可以开发一个同时被.NET MAUI和Xamarin.Forms使用的插件。通常，插件是一个多目标.NET项目，开发者可以决定支持的平台数量。本章关于插件的内容也适用于.NET
    MAUI Blazor混合应用。我们将在下一章深入探讨.NET MAUI Blazor混合应用的开发。
- en: As plugin development can be fairly flexible and potent, the compatibility of
    plugin libraries is determined by individual developers. To standardize a variety
    of plugins from the community, let’s evaluate the evolutionary path of .NET MAUI
    or Xamarin plugins in the upcoming section.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于插件开发可以相当灵活和强大，插件库的兼容性由个别开发者决定。为了标准化社区中的各种插件，让我们在下一节中评估.NET MAUI或Xamarin插件的演变路径。
- en: The evolution of .NET MAUI/Xamarin plugins
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET MAUI/Xamarin插件的演变
- en: Previously, in order to utilize a device feature without a built-in cross-platform
    interface, we could often find Xamarin plugins developed by the community. Xamarin
    plugins, created by Xamarin developers, are packaged in a cross-platform format.
    However, these plugins lack standardization, which may result in the existence
    of multiple plugins catering to the same device features.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前，为了在没有内置跨平台接口的情况下利用设备功能，我们通常可以找到由社区开发的Xamarin插件。由Xamarin开发者创建的Xamarin插件以跨平台格式打包。然而，这些插件缺乏标准化，可能会导致存在多个针对相同设备功能的插件。
- en: As the Xamarin ecosystem evolved and matured, Xamarin.Essentials was introduced
    as an all-embracing, harmonized alternative. By consolidating popular plugins
    into a single cross-platform library, it simplified the utilization of native
    APIs across Android, iOS, and Windows devices.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Xamarin生态系统的发展和成熟，Xamarin.Essentials被引入作为一种全面、统一的替代方案。通过将流行的插件整合到一个单一的多平台库中，它简化了在Android、iOS和Windows设备上使用原生API的过程。
- en: Xamarin.Essentials serves as both a library and a namespace. Within this namespace,
    we can access hardware interfaces, such as a battery, flashlight, vibration, geolocation
    sensor, etc.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin.Essentials既是一个库也是一个命名空间。在这个命名空间中，我们可以访问硬件接口，例如电池、手电筒、振动、地理位置传感器等。
- en: With the advent of .NET MAUI, Xamarin.Essentials has undergone further development,
    resulting in a collection of individual namespaces housed under the `Microsoft.Maui`
    namespace, as depicted in *Figure 7.2*.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 随着NET MAUI的出现，Xamarin.Essentials经历了进一步的发展，结果在`Microsoft.Maui`命名空间下形成了一系列单独的命名空间，如图7.2所示。
- en: '![A diagram of a computer program  Description automatically generated](img/B21554_07_02.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![计算机程序图  描述自动生成](img/B21554_07_02.png)'
- en: 'Figure 7.2: Evolution of Xamarin.Essentials'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2：Xamarin.Essentials的演变
- en: In Xamarin.Essentials, all features are consolidated under a single namespace,
    resulting in a sizable and flat library. In contrast, .NET MAUI adopts a more
    refined design by dividing the features into multiple namespaces, as illustrated
    in *Table 7.1*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin.Essentials中，所有功能都整合在一个单一的命名空间下，从而形成一个庞大且扁平的库。相比之下，.NET MAUI通过将功能划分为多个命名空间，采用了更精细的设计，如图7.1所示。
- en: '| **Namespace** | **Description** |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| **命名空间** | **描述** |'
- en: '| `Microsoft.Maui.ApplicationModel` | Within this namespace, it encompasses
    APIs that enable access to platform-specific application-level information and
    activities. Examples of these include app actions, app information, the browser,
    the launcher, the main thread, maps, permissions, and version tracking. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `Microsoft.Maui.ApplicationModel` | 在这个命名空间中，它包含允许访问平台特定应用程序级信息和活动的API。这些包括应用操作、应用信息、浏览器、启动器、主线程、地图、权限和版本跟踪等示例。|'
- en: '| `Microsoft.Maui.ApplicationModel.Communication` | Within this namespace,
    we have access to various communication services, including contacts, email, networking,
    the phone dialer, sms, and web authenticator functionality. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `Microsoft.Maui.ApplicationModel.Communication` | 在这个命名空间中，我们可以访问各种通信服务，包括联系人、电子邮件、网络、电话拨号器、短信和网页身份验证功能。
    |'
- en: '| `Microsoft.Maui.ApplicationModel.DataTransfer` | Clipboard and sharing APIs
    can be found in this namespace. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `Microsoft.Maui.ApplicationModel.DataTransfer` | 剪贴板和共享API可以在这个命名空间中找到。 |'
- en: '| `Microsoft.Maui.Devices` | In this namespace, we have the capability to access
    various hardware sensors and accelerators, including the battery, the device display,
    device information, device sensors, the flashlight, geocoding, geolocation, haptic
    feedback, and vibration. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `Microsoft.Maui.Devices` | 在这个命名空间中，我们有能力访问各种硬件传感器和加速器，包括电池、设备显示、设备信息、设备传感器、手电筒、地理编码、地理位置、触觉反馈和振动。
    |'
- en: '| `Microsoft.Maui.Media` | We can access video and photos in this namespace,
    such as the media picker, screenshot, text-to-speech, or unit converters. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `Microsoft.Maui.Media` | 我们可以在这个命名空间中访问视频和照片，例如媒体选择器、截图、语音合成或单位转换器。 |'
- en: '| `Microsoft.Maui.Storage` | To access various local storage in preferences
    or secure storage, we can use this namespace. We can find a cross-platform file
    picker and filesystem helpers here. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `Microsoft.Maui.Storage` | 要访问偏好设置或安全存储中的各种本地存储，我们可以使用这个命名空间。在这里，我们可以找到一个跨平台的文件选择器和文件系统辅助工具。
    |'
- en: 'Table 7.1: Device features in Microsoft.Maui'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.1：Microsoft.Maui中的设备功能
- en: While the cross-platform APIs listed in *Table 7.1* allow us to access various
    device features, there are still some platform features unavailable. In such instances,
    we must either implement our own solutions or utilize plugins developed by the
    community. For instance, there are no cross-platform APIs available for fingerprint
    functionality. To incorporate fingerprint features in our app, we need to rely
    on community-developed plugins.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管列表7.1中列出的跨平台API允许我们访问各种设备功能，但仍有一些平台功能不可用。在这种情况下，我们必须要么实现自己的解决方案，要么利用社区开发的插件。例如，没有可用的跨平台API支持指纹功能。为了在我们的应用中集成指纹功能，我们需要依赖社区开发的插件。
- en: As .NET MAUI APIs currently do not support fingerprint functionality, we will
    employ an open-source plugin called `Plugin.Fingerprint`, which was previously
    used in the Xamarin version of `PassXYZ.Vault`. In this chapter, we will utilize
    the same plugin to facilitate fingerprint support in the .NET MAUI version of
    PassXYZ.Vault. `Plugin.Fingerprint` is an example of a library that can support
    both .NET MAUI and Xamarin.Forms.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于.NET MAUI API目前不支持指纹功能，我们将使用一个名为`Plugin.Fingerprint`的开源插件，该插件之前在`PassXYZ.Vault`的Xamarin版本中使用过。在本章中，我们将利用相同的插件来促进PassXYZ.Vault的.NET
    MAUI版本的指纹支持。`Plugin.Fingerprint`是一个可以支持.NET MAUI和Xamarin.Forms的库的例子。
- en: The introduction of Plugin.Fingerprint
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Plugin.Fingerprint的介绍
- en: 'In this session, we will utilize `Plugin.Fingerprint` as a case study to demonstrate
    the implementation of .NET MAUI plugins. You can find the fingerprint plugin we
    will be using at the following GitHub URL: [https://github.com/smstuebe/xamarin-fingerprint](https://github.com/smstuebe/xamarin-fingerprint).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本次会议中，我们将利用`Plugin.Fingerprint`作为一个案例研究来展示.NET MAUI插件的实现。您可以在以下GitHub URL找到我们将要使用的指纹插件：[https://github.com/smstuebe/xamarin-fingerprint](https://github.com/smstuebe/xamarin-fingerprint)。
- en: 'To use `Plugin.Fingerprint` in our project, we can add the package to our project
    by using the below command:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的项目中使用`Plugin.Fingerprint`，我们可以通过以下命令将包添加到项目中：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In order to implement a plugin, it is common practice to begin by defining an
    interface. This interface serves as a means to access the features provided by
    the plugin.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现一个插件，通常的做法是首先定义一个接口。这个接口作为访问插件提供的功能的一种方式。
- en: The concrete implementation is divided into two components, the cross-platform
    aspect and the platform-specific aspect, which are achieved using either a partial
    class or an abstract class.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 具体实现分为两个组件，跨平台方面和特定平台方面，这些是通过部分类或抽象类实现的。
- en: '![A diagram of a fingerprint  Description automatically generated](img/B21554_07_03.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![指纹的示意图  自动生成的描述](img/B21554_07_03.png)'
- en: 'Figure 7.3: Plugin.Fingerprint'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3：Plugin.Fingerprint
- en: '*Figure 7.3* presents the class diagram of `Plugin.Fingerprint`. It is evident
    that `Plugin.Fingerprint` establishes an interface called `IFingerprint`. An abstract
    class, `FingerprintImplementationBase`, carries out the implementation of this
    interface. This abstract class is responsible for cross-platform functionality
    and outlines abstract methods designated for platform-specific implementation.
    `FingerprintImplementation`, a separate class on each platform, defines the platform-specific
    implementation. In the following block, we will examine the code of `IFingerprint`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.3* 展示了 `Plugin.Fingerprint` 类的类图。很明显，`Plugin.Fingerprint` 建立了一个名为 `IFingerprint`
    的接口。一个抽象类 `FingerprintImplementationBase` 执行这个接口的实现。这个抽象类负责跨平台功能，并概述了为特定平台实现指定的抽象方法。每个平台都有一个单独的类
    `FingerprintImplementation`，定义了特定平台的实现。在下面的代码块中，我们将检查 `IFingerprint` 的代码：'
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `IFingerprint` interface defines four methods:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`IFingerprint` 接口定义了四个方法：'
- en: '`GetAvailabilityAsync` checks the availability of fingerprint authentication.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetAvailabilityAsync` 检查指纹认证的可用性。'
- en: '`IsAvailableAsync` serves as a wrapper for `GetAvailabilityAsync`, offering
    easier access.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IsAvailableAsync` 作为 `GetAvailabilityAsync` 的包装器，提供更简单的访问方式。'
- en: '`AuthenticateAsync` handles the actual authentication, using fingerprint data.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AuthenticateAsync` 处理实际的认证，使用指纹数据。'
- en: '`GetAuthenticationTypeAsync` allows users to retrieve the currently available
    authentication type.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetAuthenticationTypeAsync` 允许用户检索当前可用的认证类型。'
- en: 'Now, let’s examine `FingerprintImplementationBase`, which implements the `IFingerprint`
    interface:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查实现 `IFingerprint` 接口的 `FingerprintImplementationBase`：
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the `FingerprintImplementationBase` class, the `AuthenticateAsync` method
    is implemented by invoking the `NativeAuthenticateAsync` method. The latter is
    defined as an abstract method that is implemented in the platform layer.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `FingerprintImplementationBase` 类中，`AuthenticateAsync` 方法通过调用 `NativeAuthenticateAsync`
    方法实现。后者定义为在平台层实现的抽象方法。
- en: It also defines `GetAvailabilityAsync` and `GetAuthenticationTypeAsync` as abstract
    methods, which are subsequently implemented in the platform layer.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 它还定义了 `GetAvailabilityAsync` 和 `GetAuthenticationTypeAsync` 为抽象方法，这些方法随后在平台层实现。
- en: The `IsAvailableAsync` method simply invokes `GetAvailabilityAsync` and then
    compares the return value.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsAvailableAsync` 方法简单地调用 `GetAvailabilityAsync` 并比较返回值。'
- en: 'In order to instantiate the `IFingerprint` interface, `Plugin.Fingerprint`
    employs a class named `CrossFingerprint`. This class utilizes a creational design
    pattern, along with lazy initialization, to generate `IFingerprint` interface
    instances during runtime, as we can see in the following code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实例化 `IFingerprint` 接口，`Plugin.Fingerprint` 使用一个名为 `CrossFingerprint` 的类。这个类利用创建型设计模式，结合懒加载，在运行时生成
    `IFingerprint` 接口实例，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In `CrossFingerprint`, a static property called `Current` **(2)** is defined,
    which can be utilized to obtain the instance of `IFingerprint`. The property `Current`
    returns the value of a `Lazy<IFingerprint>` object, specified in the variable
    `_implementation` **(1)**, which implements lazy initialization. Within `Lazy<IFingerprint>`,
    the `IFingerprint` instance is created using the factory method `CreateFingerprint`
    **(3)**.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `CrossFingerprint` 中，定义了一个名为 `Current` 的静态属性 **(2**)，可以用来获取 `IFingerprint`
    的实例。属性 `Current` 返回一个 `Lazy<IFingerprint>` 对象的值，该对象由变量 `_implementation` **(1**)
    指定，实现了懒加载。在 `Lazy<IFingerprint>` 中，使用工厂方法 `CreateFingerprint` **(3**) 创建 `IFingerprint`
    实例。
- en: Now that we have introduced `Plugin.Fingerprint`, let’s explore how to incorporate
    fingerprint support in our app using this plugin.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了 `Plugin.Fingerprint`，让我们探索如何使用此插件在我们的应用程序中集成指纹支持。
- en: Supporting fingerprint functionality using Plugin.Fingerprint
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Plugin.Fingerprint 支持指纹功能
- en: 'To incorporate fingerprint functionality using `Plugin.Fingerprint`, we must
    first configure it within our project before making any code modifications. This
    step involves adding the NuGet package `Plugin.Fingerprint` to our project file,
    as detailed below:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `Plugin.Fingerprint` 集成指纹功能，我们必须首先在我们的项目中配置它，然后再进行任何代码修改。这一步涉及将 NuGet 包
    `Plugin.Fingerprint` 添加到我们的项目文件中，具体如下：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For now, please disregard the NuGet package `EJL.MauiHybridWebView`. We will
    delve into a discussion about it later in this chapter.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，请忽略 NuGet 包 `EJL.MauiHybridWebView`。我们将在本章的后面部分深入讨论它。
- en: As users must access device-specific features within each platform, it is essential
    to configure the required permissions for our application in their respective
    configuration files.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于用户必须在每个平台上访问特定于设备的功能，因此在我们的应用程序的相应配置文件中配置所需的权限是至关重要的。
- en: 'For the Android platform, it is necessary to request specific permissions within
    the `AndroidManifest.xml` file:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Android平台，需要在`AndroidManifest.xml`文件中请求特定的权限：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For the iOS platform, we need to do the same in `Info.plist`, as below:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于iOS平台，我们需要在`Info.plist`中执行相同的操作，如下所示：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Incorporating fingerprint functionality is an objective we aim to achieve in
    our application. By employing the MVVM pattern, we can initially integrate this
    fingerprint feature within our view model. Subsequently, we can utilize this functionality
    in our XAML pages.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 将指纹功能集成到我们的应用程序中是我们希望实现的目标。通过使用MVVM模式，我们最初可以在我们的视图中集成此指纹功能。随后，我们可以在我们的XAML页面上使用此功能。
- en: 'Our users will utilize fingerprint authentication to log in, so we can incorporate
    the fingerprint plugin into the `LoginViewModel`. The users will engage with `LoginPage`
    to carry out the login process. However, before they can employ fingerprint authentication
    within `LoginPage`, they must first enable the fingerprint feature in our app’s
    settings. The implementation of these settings is found in the `SettingsPage`.
    The relationship between `IFingerprint`, `LoginViewModel`, `LoginPage`, and `SettingsPage`
    is illustrated in *Figure 7.4*:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的用户将使用指纹认证进行登录，因此我们可以将指纹插件集成到`LoginViewModel`中。用户将通过`LoginPage`进行登录过程。然而，在`LoginPage`中使用指纹认证之前，他们必须首先在我们的应用设置中启用指纹功能。这些设置的实现可以在`SettingsPage`中找到。`IFingerprint`、`LoginViewModel`、`LoginPage`和`SettingsPage`之间的关系如图7.4所示：
- en: '![A diagram of a computer program  Description automatically generated](img/B21554_07_04.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![计算机程序图  自动生成描述](img/B21554_07_04.png)'
- en: 'Figure 7.4: Plugin.Fingerprint integration'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4：插件.Fingerprint集成
- en: 'As we are utilizing dependency injection to manage dependencies, it is necessary
    to initially include the `IFingerprint` interface in the configuration found in
    `MauiProgram.cs`, as demonstrated below:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在使用依赖注入来管理依赖项，因此需要首先在`MauiProgram.cs`中找到的配置中包含`IFingerprint`接口，如下所示：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Having completed the aforementioned setup and configuration, let us now examine
    the code of the `LoginViewModel` provided below:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 完成上述设置和配置后，现在让我们查看以下提供的`LoginViewModel`代码：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 7.1: `LoginViewModel.cs` ([https://epa.ms/LoginViewModel7-1](https://epa.ms/LoginViewModel7-1))'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.1：`LoginViewModel.cs` ([https://epa.ms/LoginViewModel7-1](https://epa.ms/LoginViewModel7-1))
- en: In the `LoginViewModel`, we obtain an instance of the `IFingerprint` interface
    **(1)** via constructor dependency injection and save it in the member variable
    `_fingerprint`. This `IFingerprint` instance is then utilized to implement fingerprint
    status validation and authentication functions.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在`LoginViewModel`中，我们通过构造函数依赖注入获取`IFingerprint`接口的实例 **(1**) 并将其保存在成员变量`_fingerprint`中。然后，使用此`IFingerprint`实例来实现指纹状态验证和认证功能。
- en: The function `CheckFingerprintStatus` **(3)** has been implemented to evaluate
    the device’s capability and status, specifically determining if the device supports
    fingerprint recognition and if it is enabled for the current user. The properties
    `IsFingerprintEnabled` **(4)** and `IsFingerprintAvailable` **(5)** will be updated
    by this function.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 已实现`CheckFingerprintStatus` **(3**) 函数来评估设备的性能和状态，具体确定设备是否支持指纹识别以及是否为当前用户启用。该函数将更新`IsFingerprintEnabled`
    **(4**) 和`IsFingerprintAvailable` **(5**) 属性。
- en: To enable fingerprint authentication, `FingerprintLogin` **(2)** is incorporated
    to execute login via fingerprint recognition. The function `AuthenticateAsync`
    **(6)** is utilized for fingerprint verification; however, it does not carry out
    the login process.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用指纹认证，`FingerprintLogin` **(2**) 被集成以通过指纹识别执行登录。使用`AuthenticateAsync` **(6**)
    函数进行指纹验证；然而，它并不执行登录过程。
- en: After implementing the view model, we can focus on developing the user interface.
    To incorporate fingerprint functionality, it is necessary for the user to activate
    it initially. We employ a settings page for this purpose. When the fingerprint
    feature is enabled, the user can access the system using their fingerprint. This
    login function is incorporated into the `LoginPage`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现视图模型后，我们可以专注于开发用户界面。为了集成指纹功能，用户最初需要激活它。我们为此使用设置页面。当指纹功能启用时，用户可以使用指纹访问系统。此登录功能被集成到`LoginPage`中。
- en: Fingerprint settings
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指纹设置
- en: Please refer to *Figure 7.5* for the fingerprint configuration. The user interface
    design is notably minimalistic, utilizing only a switch control to activate or
    deactivate the fingerprint function.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考图7.5中的指纹配置。用户界面设计明显简约，仅使用开关控件来激活或禁用指纹功能。
- en: '![A white background with black dots  Description automatically generated](img/B21554_07_05.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![白色背景上有黑色点  自动生成的描述](img/B21554_07_05.png)'
- en: 'Figure 7.5: SettingsPage'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '图7.5: SettingsPage'
- en: 'The user interface for the `SettingsPage` is relatively straightforward, which
    allows us to bypass discussing its XAML. Instead, we will focus on examining the
    code-behind file of the `SettingsPage` in *Listing 7.2*:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`SettingsPage`的用户界面相对简单，这使我们能够跳过讨论其XAML。相反，我们将专注于检查列表7.2中的`SettingsPage`的后台代码文件：'
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 7.2: `SettingsPage.xaml.cs` ([https://epa.ms/SettingsPage7-2](https://epa.ms/SettingsPage7-2))'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '列表7.2: `SettingsPage.xaml.cs` ([https://epa.ms/SettingsPage7-2](https://epa.ms/SettingsPage7-2))'
- en: In the `SettingsPage`, we incorporate `LoginViewModel` **(1)** and `LoginService`
    through dependency injection. We override the lifecycle method `OnAppearing` **(2)**
    to evaluate fingerprint support by invoking `CheckFingerprintStatus` **(3)**.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SettingsPage`中，我们通过依赖注入引入了`LoginViewModel` **(1**) 和`LoginService`。我们重写生命周期方法`OnAppearing`
    **(2**) 来通过调用`CheckFingerprintStatus` **(3**) 评估指纹支持。
- en: Following this, we execute the function `SetFingerprintSwitcher` **(4)** to
    update the UI. When users toggle the switch on or off, the event handler `OnSwitcherToggleAsync`
    **(5)** is activated. Within this event handler, we authenticate the fingerprint
    by calling `AuthenticateAsync` **(6)** and subsequently save the master password
    in secure storage. If fingerprint authentication is not used, we remove the master
    password from secure storage to disable this feature.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，我们执行函数`SetFingerprintSwitcher` **(4**) 来更新UI。当用户切换开关时，事件处理器`OnSwitcherToggleAsync`
    **(5**) 被激活。在此事件处理器中，我们通过调用`AuthenticateAsync` **(6**) 验证指纹，并随后在安全存储中保存主密码。如果不使用指纹认证，我们将从安全存储中移除主密码以禁用此功能。
- en: Login using a fingerprint
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用指纹登录
- en: Upon activating the fingerprint feature in the `SettingsPage`, users can utilize
    fingerprint login, as illustrated in *Figure 7.6*. With the fingerprint function
    enabled, a fingerprint icon appears next to the password field. By clicking on
    this icon, users can access the fingerprint login user interface.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SettingsPage`中激活指纹功能后，用户可以利用指纹登录，如图7.6所示。启用指纹功能后，密码字段旁边会出现指纹图标。点击此图标，用户可以访问指纹登录用户界面。
- en: '![A screenshot of a login screen  Description automatically generated](img/B21554_07_06.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![登录屏幕截图  自动生成的描述](img/B21554_07_06.png)'
- en: 'Figure 7.6: LoginPage'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '图7.6: LoginPage'
- en: 'We can examine the implementation of this fingerprint icon by reviewing the
    XAML code provided below:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过查看以下提供的XAML代码来检查此指纹图标的实现：
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The fingerprint icon is designed as an `ImageButton`, which will only be visible
    when `IsFingerprintEnabled` is set to true through data binding. Upon clicking
    the icon, the `FingerprintLoginCommand` will be triggered. By leveraging the MVVM
    pattern, we simply need to add this `ImageButton` to the XAML page, while the
    remaining logic is implemented within the view model.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 指纹图标被设计为`ImageButton`，只有当通过数据绑定将`IsFingerprintEnabled`设置为true时才会可见。点击图标，将触发`FingerprintLoginCommand`。通过利用MVVM模式，我们只需将此`ImageButton`添加到XAML页面，而其余逻辑则在视图模型中实现。
- en: We have now completed the introduction of .NET MAUI/Xamarin plugins. Our app’s
    fingerprint support was made possible through the use of `Plugin.Fingerprint`.
    In the upcoming section, we will explore another case – creating custom controls
    or customizing existing ones.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了.NET MAUI/Xamarin插件的介绍。我们的应用程序指纹支持是通过使用`Plugin.Fingerprint`实现的。在下一节中，我们将探讨另一个案例——创建自定义控件或自定义现有控件。
- en: Customizing controls
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义控件
- en: .NET MAUI controls are built on the foundation of native controls. There may
    be instances where we would like these native controls to exhibit customized behavior
    to cater to our specific needs. Additionally, there might be situations when we
    need to create our own controls, particularly when the desired native controls
    are not readily available in .NET MAUI.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI 控件建立在原生控件的基础上。可能会有这样的情况，我们希望这些原生控件能够表现出定制的行为以满足我们的特定需求。此外，还可能存在我们需要创建自己的控件的情况，尤其是当所需的原生控件在
    .NET MAUI 中不可用时。
- en: In this section, we will discuss the .NET MAUI implementations of cross-platform
    controls and use an example to illustrate how to enhance a cross-platform control
    with new capabilities.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论 .NET MAUI 的跨平台控件实现，并使用示例来说明如何通过新功能增强跨平台控件。
- en: In our application, we might want to present a password entry as a secure note,
    rather than as a standard password entry on the details page. To improve the user
    experience, we aim to support Markdown text instead of plain text. As .NET MAUI
    currently does not provide a Markdown view control, we must create our own. We
    will use this scenario as an example to demonstrate how to expand the functionality
    of existing controls to develop a new one.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们可能希望将密码输入作为安全便签来展示，而不是在详情页上的标准密码输入。为了提升用户体验，我们旨在支持 Markdown 文本而不是纯文本。由于
    .NET MAUI 目前没有提供 Markdown 视图控件，我们必须创建自己的。我们将使用这个场景作为示例来演示如何扩展现有控件的功能以开发新的控件。
- en: Overview of handlers
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理器概述
- en: In .NET MAUI, handlers play a crucial role in the rendering process by transforming
    cross-platform view elements (controls) into their corresponding platform-specific
    native UI components. The implementation of handlers bears a resemblance to the
    approach taken in the `Plugin.Fingerprint` implementation, where a control-specific
    interface is employed to distinguish between the cross-platform view and the native
    view. As we plan to implement our `MarkdownView` using the `WebView` control,
    we will use the `WebView` control as an example to explain handlers.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET MAUI 中，处理器在渲染过程中起着至关重要的作用，通过将跨平台视图元素（控件）转换为相应的平台特定原生 UI 组件。处理器的实现方式与
    `Plugin.Fingerprint` 实现中采用的方法相似，其中使用特定于控制的接口来区分跨平台视图和原生视图。由于我们计划使用 `WebView` 控件来实现
    `MarkdownView`，我们将使用 `WebView` 控件作为示例来解释处理器。
- en: A `WebView` displays web content and HTML within a .NET MAUI application. In
    .NET MAUI, each supported platform (iOS, Android, macOS, and Windows) has corresponding
    handlers for the `WebView` control, mapping it to native controls. Such examples
    include `WKWebView` for iOS and macOS, `WebView` for Android, and `WebView2` for
    Windows.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebView` 在 .NET MAUI 应用程序中显示网页内容和 HTML。在 .NET MAUI 中，每个支持的平台（iOS、Android、macOS
    和 Windows）都有对应于 `WebView` 控件的处理器，将其映射到原生控件。例如，iOS 和 macOS 使用 `WKWebView`，Android
    使用 `WebView`，Windows 使用 `WebView2`。'
- en: '![A diagram of a company  Description automatically generated](img/B21554_07_07.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![公司架构图  描述自动生成](img/B21554_07_07.png)'
- en: 'Figure 7.7: .NET MAUI handlers'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '图 7.7: .NET MAUI 处理器'
- en: 'As depicted in *Figure 7.7*, the architecture consists of three layers: a virtual
    view, handlers, and native views. Cross-platform controls interact with native
    views via a control-specific interface implemented by the handlers. In the case
    of `WebView`, it communicates with `WebViewHandler` through the `IWebView` interface.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 7.7* 所示，架构由三层组成：虚拟视图、处理器和原生视图。跨平台控件通过处理器实现的特定于控制的接口与原生视图交互。在 `WebView`
    的情况下，它通过 `IWebView` 接口与 `WebViewHandler` 通信。
- en: 'The `IWebView` interface is implemented by `WebViewHandler`, which utilizes
    partial classes to segregate the platform-specific implementation, such as:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`IWebView` 接口由 `WebViewHandler` 实现，它使用部分类来分离平台特定的实现，例如：'
- en: '`WebViewHandler.iOS.cs`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebViewHandler.iOS.cs`'
- en: '`WebViewHandler.Android.cs`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebViewHandler.Android.cs`'
- en: '`WebViewHandler.WinUI.cs`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebViewHandler.WinUI.cs`'
- en: '`WebViewHandler.MacCatalyst.cs`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebViewHandler.MacCatalyst.cs`'
- en: Within the handler, the `VirtualView` property is defined as a reference to
    the cross-platform control, while the `PlatformView` property refers to the native
    view. A property mapper is utilized to establish a connection between the cross-platform
    control’s API and the native view’s API.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理器中，`VirtualView` 属性被定义为对跨平台控制的引用，而 `PlatformView` 属性则指向原生视图。使用属性映射器来建立跨平台控制
    API 与原生视图 API 之间的连接。
- en: The implementation of .NET MAUI handlers illustrates the architectural differences
    between .NET MAUI and Xamarin.Forms. For more information on .NET MAUI handlers,
    you can refer to the Microsoft article titled “*Create a custom control using
    handlers*” in the *Further reading* section. This article provides extensive insights
    into the creation and application of custom controls using handlers.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI 处理程序的实现说明了 .NET MAUI 和 Xamarin.Forms 之间的架构差异。有关 .NET MAUI 处理程序的更多信息，您可以参考
    Microsoft 文章“*使用处理程序创建自定义控件*”，该文章位于“进一步阅读”部分。这篇文章提供了关于使用处理程序创建和应用自定义控件的深入见解。
- en: Using HybridWebView
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 HybridWebView
- en: As we introduce handlers, we will investigate the implementation of a Markdown
    view using `WebView`. A common approach to displaying Markdown text involves converting
    it into HTML and then presenting the HTML content within a `WebView`. Our challenge
    lies in transforming the Markdown text into HTML. There are .NET libraries available
    to accomplish this, such as Markdig, which can be found at [https://github.com/xoofx/markdig](https://github.com/xoofx/markdig).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们引入处理程序时，我们将研究使用 `WebView` 实现 Markdown 视图的实现。显示 Markdown 文本的常见方法是将它转换为 HTML，然后在
    `WebView` 中呈现 HTML 内容。我们的挑战在于将 Markdown 文本转换为 HTML。有一些 .NET 库可以完成这项任务，例如可以在 [https://github.com/xoofx/markdig](https://github.com/xoofx/markdig)
    找到的 Markdig。
- en: Opting for this approach requires us to convert Markdown text into HTML at runtime
    and subsequently assemble an HTML page. Since `WebView` will be employed, a more
    straightforward method involves directly passing the Markdown text to `WebView`
    and allowing `WebView` to interpret the text, using a JavaScript library. However,
    the default `WebView` lacks sufficient JavaScript interoperability to facilitate
    this process. As a solution, we will implement our Markdown view using the open-source
    project `HybridWebView`, developed by Eilon Lipton, which can be found at [https://github.com/Eilon/MauiHybridWebView](https://github.com/Eilon/MauiHybridWebView).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 选择这种方法需要我们在运行时将 Markdown 文本转换为 HTML，然后组装一个 HTML 页面。由于将使用 `WebView`，一个更直接的方法是直接将
    Markdown 文本传递给 `WebView`，并允许 `WebView` 使用 JavaScript 库来解释文本。然而，默认的 `WebView` 缺乏足够的
    JavaScript 互操作性来支持此过程。作为解决方案，我们将使用由 Eilon Lipton 开发的开源项目 `HybridWebView` 来实现我们的
    Markdown 视图，该项目可以在 [https://github.com/Eilon/MauiHybridWebView](https://github.com/Eilon/MauiHybridWebView)
    找到。
- en: '`HybridWebView` improves `WebView` by supporting more sophisticated JavaScript
    interoperability. This enhancement allows for the following functionalities:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`HybridWebView` 通过支持更复杂的 JavaScript 互操作性来改进 `WebView`。这种增强允许以下功能：'
- en: We can configure a JavaScript library and resources by utilizing .NET MAUI raw
    resources, packaging them similarly to a static website. At runtime, we can load
    it in `WebView`, which resembles a **Single Page Application** (**SPA**). There
    is a sample app that demonstrates how to convert an existing React application
    into a .NET MAUI application running in `WebView`.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过使用 .NET MAUI 原始资源来配置一个 JavaScript 库和资源，将它们打包成类似静态网站的方式。在运行时，我们可以在 `WebView`
    中加载它，它类似于 **单页应用**（**SPA**）。有一个示例应用演示了如何将现有的 React 应用程序转换为在 `WebView` 中运行的 .NET
    MAUI 应用程序。
- en: '`HybridWebView` also augments event handling and enables JavaScript functions
    to invoke .NET functions, and vice versa.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HybridWebView` 还增强了事件处理，并允许 JavaScript 函数调用 .NET 函数，反之亦然。'
- en: With the assistance of `HybridWebView`, let’s explore how to incorporate `MarkdownView`
    into our app.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `HybridWebView` 的帮助下，让我们探讨如何将 `MarkdownView` 集成到我们的应用中。
- en: Implementing MarkdownView
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现 `MarkdownView`
- en: The concept behind `MarkdownView` is to directly pass the Markdown text that
    we wish to display to `HybridWebView`. This employs a JavaScript library to render
    the text. To achieve this, we require a JavaScript-based Markdown interpreter.
    Given that Markdown is widely utilized in numerous web applications, several JavaScript
    libraries are available for this purpose. We will use a compact, yet efficient
    library called Marked, which can be found at [https://github.com/markedjs/marked](https://github.com/markedjs/marked).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`MarkdownView` 的概念是将我们希望显示的 Markdown 文本直接传递给 `HybridWebView`。这使用了一个 JavaScript
    库来渲染文本。为了实现这一点，我们需要一个基于 JavaScript 的 Markdown 解释器。鉴于 Markdown 在众多网络应用中被广泛使用，为此目的有几个
    JavaScript 库可用。我们将使用一个紧凑且高效的库，称为 Marked，可以在 [https://github.com/markedjs/marked](https://github.com/markedjs/marked)
    找到。'
- en: 'Utilizing the Marked library is quite simple. You can simply invoke it as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 利用 Marked 库非常简单。你可以简单地按如下方式调用它：
- en: '[PRE13]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We can observe that displaying a Markdown string is achieved by passing it to
    the `marked.parse` function.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，通过将其传递给`marked.parse`函数来实现Markdown字符串的显示。
- en: However, before we proceed, we must determine the appropriate moment to pass
    this Markdown string to `WebView`. If we simply call a JavaScript function from
    the .NET side, the JavaScript function in the HTML file may not be fully prepared.
    Hence, it is essential to wait for the HTML file to load completely in `WebView`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们继续之前，我们必须确定将这个Markdown字符串传递给`WebView`的适当时机。如果我们简单地从.NET方面调用一个JavaScript函数，HTML文件中的JavaScript函数可能还没有完全准备好。因此，等待HTML文件在`WebView`中完全加载是至关重要的。
- en: By employing the jQuery library, we can obtain an event that notifies .NET when
    the HTML page is ready, as illustrated in *Figure 7.8*.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用jQuery库，我们可以获得一个通知.NET当HTML页面准备就绪的事件，如*图7.8*所示。
- en: '![A screenshot of a computer program  Description automatically generated](img/B21554_07_08.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![计算机程序截图  自动生成的描述](img/B21554_07_08.png)'
- en: 'Figure 7.8: HTML and JavaScript resources'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8：HTML和JavaScript资源
- en: As depicted in *Figure 7.8*, we create a folder named `hybrid_root` within the
    `Raw` directory under the `Resources` folder. Within the `hybrid_root` folder,
    we store JavaScript files in the `js` folder and CSS files in the `styles` folder.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图7.8*所示，我们在“Resources”文件夹下的“Raw”目录中创建了一个名为`hybrid_root`的文件夹。在`hybrid_root`文件夹中，我们将JavaScript文件存储在`js`文件夹中，将CSS文件存储在`styles`文件夹中。
- en: The `js` folder houses local copies of both Marked and jQuery, eliminating the
    need for network requests when displaying a Markdown string. The left side of
    *Figure 7.8* displays the contents of `hybrid_app.xhtml`. Inside this file, we
    utilize the jQuery function `$(document).ready()` to send an event to the .NET
    side when the page has loaded. Once the .NET side receives this event, it can
    invoke the `MarkdownToHtml` function by passing a Markdown string to it. In this
    manner, we can display any Markdown string using `MarkdownView`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`js`文件夹包含了Marked和jQuery的本地副本，当显示Markdown字符串时，无需进行网络请求。*图7.8*的左侧显示了`hybrid_app.xhtml`的内容。在这个文件中，我们使用jQuery函数`$(document).ready()`在页面加载时向.NET方面发送一个事件。一旦.NET方面接收到这个事件，它就可以通过传递一个Markdown字符串来调用`MarkdownToHtml`函数。这样，我们就可以使用`MarkdownView`显示任何Markdown字符串。'
- en: 'Having explained the necessary preparations for HTML and JavaScript, let’s
    examine what we need to implement on the .NET side. We can begin by looking at
    the implementation of `MarkdownView` in *Listing 7.3*:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释了HTML和JavaScript的必要准备工作之后，让我们来看看在.NET方面我们需要实现什么。我们可以从查看*列表7.3*中的`MarkdownView`实现开始。
- en: '[PRE14]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 7.3: `MarkdownView.cs` ([https://epa.ms/MarkdownView7-3](https://epa.ms/MarkdownView7-3))'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.3：`MarkdownView.cs` ([https://epa.ms/MarkdownView7-3](https://epa.ms/MarkdownView7-3))
- en: In the `MarkdownView`, we must establish the web asset’s root as `hybrid_root`
    **(1)**, and `hybrid_app.xhtml` **(2)** is the HTML file that needs to be loaded.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MarkdownView`中，我们必须将网络资源的根设置为`hybrid_root` **(1**)，`hybrid_app.xhtml` **(2**)是需要加载的HTML文件。
- en: 'A function called `DisplayMarkdown` is created to showcase Markdown text, and
    it will invoke the JavaScript function `MarkdownToHtml` **(4)** to display the
    text. Since the encoding of Markdown text varies between Android, Windows, and
    iOS/macOS, the string encoding function `JavaScriptStringEncode` **(3)** has to
    be called for Windows and iOS/macOS platforms. After implementing `MarkdownView`,
    we can develop the user interface to render Markdown text, as demonstrated in
    *Listing 7.4*:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一个名为`DisplayMarkdown`的函数来展示Markdown文本，它将调用JavaScript函数`MarkdownToHtml` **(4**)来显示文本。由于Markdown文本的编码在Android、Windows和iOS/macOS之间有所不同，因此对于Windows和iOS/macOS平台，必须调用字符串编码函数`JavaScriptStringEncode`
    **(3**)。在实现`MarkdownView`之后，我们可以开发用户界面来渲染Markdown文本，如*列表7.4*所示：
- en: '[PRE15]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 7.4: `NotesPage.xaml` ([https://epa.ms/NotesPage7-4](https://epa.ms/NotesPage7-4))'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.4：`NotesPage.xaml` ([https://epa.ms/NotesPage7-4](https://epa.ms/NotesPage7-4))
- en: 'In *Listing 7.4*, a `MarkdownView` called `markdownview` is defined. An event
    handler, `OnHybridWebViewRawMessageReceived`, is registered, and its implementation
    can be found in the code-behind file in *Listing 7.5*:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在*列表7.4*中，定义了一个名为`markdownview`的`MarkdownView`。注册了一个事件处理器`OnHybridWebViewRawMessageReceived`，其实现可以在*列表7.5*中的代码后文件中找到：
- en: '[PRE16]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 7.5: `NotesPage.xaml.cs` ([https://epa.ms/NotesPage7-5](https://epa.ms/NotesPage7-5))'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.5：`NotesPage.xaml.cs` ([https://epa.ms/NotesPage7-5](https://epa.ms/NotesPage7-5))
- en: In the `NotesPage.xaml.cs` file, we override the `OnAppearing` function **(1)**.
    This function ensures that `MarkdownView` is reloaded every time the page is loaded.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `NotesPage.xaml.cs` 文件中，我们重写了 `OnAppearing` 函数 **(1)**。此函数确保每次页面加载时都会重新加载
    `MarkdownView`。
- en: The `OnHybridWebViewRawMessageReceived` event handler is where we invoke `DisplayMarkdown`
    **(2)** to showcase the Markdown text. *Figure 7.9* displays the completed user
    interface.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnHybridWebViewRawMessageReceived` 事件处理器是我们调用 `DisplayMarkdown` **(2)** 来展示
    Markdown 文本的地方。*图 7.9* 显示了完成后的用户界面。'
- en: '![A screenshot of a phone  Description automatically generated](img/B21554_07_09.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![手机的截图  自动生成的描述](img/B21554_07_09.png)'
- en: 'Figure 7.9: MarkdownView'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.9：MarkdownView
- en: With the introduction of `MarkdownView`, we have gained knowledge on expanding
    an existing control to accommodate the necessary new features.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 `MarkdownView` 的引入，我们获得了扩展现有控件以适应必要的新功能的知识。
- en: Summary
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we presented guidelines on implementing platform-specific code
    within a .NET MAUI project. There are numerous instances where platform-specific
    code implementation may be required. Regardless of whether we aim to create a
    plugin or a custom control, it is crucial to begin with an interface definition.
    A pre-defined interface facilitates the seamless separation of cross-platform
    and native implementations. To implement the interface, we have the option to
    employ either an abstract class or a partial class, allowing us to distribute
    the implementation for each platform across individual files.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了在 .NET MAUI 项目中实现特定平台代码的指南。在许多情况下，可能需要实现特定平台的代码。无论我们旨在创建插件还是自定义控件，从接口定义开始都是至关重要的。预定义的接口有助于实现跨平台和本地实现的无缝分离。为了实现接口，我们有选择使用抽象类或部分类，这样我们可以将每个平台的实现分散到单独的文件中。
- en: The introduction of `HybridWebView` opens the door to integrating or reusing
    JavaScript libraries. By crafting hybrid solutions, we can harness the advantages
    of both .NET and the JavaScript ecosystem. `HybridWebView` enables the development
    of .NET solutions that incorporate various JavaScript frameworks.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`HybridWebView` 的引入为我们打开了集成或重用 JavaScript 库的大门。通过构建混合解决方案，我们可以利用 .NET 和 JavaScript
    生态系统的优势。`HybridWebView` 使开发包含各种 JavaScript 框架的 .NET 解决方案成为可能。'
- en: Having completed the current version of the password manager app, we have now
    reached the end of *Part 1* of this book.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了密码管理器应用程序的当前版本后，我们现在已经到达了本书第一部分的结尾。
- en: In *Part 2*, we will delve into the Blazor Hybrid app within .NET MAUI, which
    is a novel feature that is not present in Xamarin.Forms. By employing Blazor,
    we can introduce some cutting-edge frontend development methods to .NET MAUI development.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第二部分* 中，我们将深入探讨 .NET MAUI 中的 Blazor 混合应用程序，这是在 Xamarin.Forms 中不存在的新特性。通过使用
    Blazor，我们可以将一些前沿的前端开发方法引入 .NET MAUI 开发。
- en: Further reading
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Biometric / fingerprint plugin for Xamarin: [https://github.com/smstuebe/xamarin-fingerprint](https://github.com/smstuebe/xamarin-fingerprint)'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Xamarin 生物识别/指纹插件：[https://github.com/smstuebe/xamarin-fingerprint](https://github.com/smstuebe/xamarin-fingerprint)
- en: '.NET MAUI HybridWebView: [https://github.com/Eilon/MauiHybridWebView](https://github.com/Eilon/MauiHybridWebView)'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET MAUI HybridWebView：[https://github.com/Eilon/MauiHybridWebView](https://github.com/Eilon/MauiHybridWebView)
- en: 'Marked – Markdown parser: [https://marked.js.org](https://marked.js.org)'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Marked – Markdown 解析器：[https://marked.js.org](https://marked.js.org)
- en: 'Xamarin Mobile Application Development for Android: [https://www.oreilly.com/library/view/xamarin-mobile-application/9781785280375/](https://www.oreilly.com/library/view/xamarin-mobile-application/9781785280375/)'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android 平台上的 Xamarin 移动应用程序开发：[https://www.oreilly.com/library/view/xamarin-mobile-application/9781785280375/](https://www.oreilly.com/library/view/xamarin-mobile-application/9781785280375/)
- en: 'Beginning Xamarin Development for the Mac: Create iOS, watchOS, and Apple tvOS
    apps with Xamarin.iOS and Visual Studio for Mac: [https://www.oreilly.com/library/view/beginning-xamarin-development/9781484231326/](https://www.oreilly.com/library/view/beginning-xamarin-development/9781484231326/)'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 macOS 上开始使用 Xamarin 进行开发：使用 Xamarin.iOS 和 Visual Studio for Mac 创建 iOS、watchOS
    和 Apple tvOS 应用程序：[https://www.oreilly.com/library/view/beginning-xamarin-development/9781484231326/](https://www.oreilly.com/library/view/beginning-xamarin-development/9781484231326/)
- en: '.NET MAUI source code: [https://github.com/dotnet/maui](https://github.com/dotnet/maui)'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET MAUI 源代码：[https://github.com/dotnet/maui](https://github.com/dotnet/maui)
- en: '.NET for Android source code – both .NET for Android and Xamarin.Android are
    built from this repository with different build configurations: [https://github.com/xamarin/xamarin-android](https://github.com/xamarin/xamarin-android)'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET for Android源代码 – .NET for Android和Xamarin.Android都是从这个仓库构建的，具有不同的构建配置：[https://github.com/xamarin/xamarin-android](https://github.com/xamarin/xamarin-android)
- en: '.NET for iOS source code – both .NET for iOS and Xamarin.iOS are built from
    this repository with different build configurations: [https://github.com/xamarin/xamarin-macios](https://github.com/xamarin/xamarin-macios)'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET for iOS源代码 – .NET for iOS和Xamarin.iOS都是从这个仓库构建的，具有不同的构建配置：[https://github.com/xamarin/xamarin-macios](https://github.com/xamarin/xamarin-macios)
- en: '.NET for Mac source code – .NET for iOS and .NET for Mac share the same codebase
    with different build configurations: [https://github.com/xamarin/xamarin-macios](https://github.com/xamarin/xamarin-macios)'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET for Mac源代码 – .NET for iOS和.NET for Mac共享相同的代码库，但具有不同的构建配置：[https://github.com/xamarin/xamarin-macios](https://github.com/xamarin/xamarin-macios)
- en: 'WinUI: [https://github.com/microsoft/microsoft-ui-xaml](https://github.com/microsoft/microsoft-ui-xaml)'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WinUI：[https://github.com/microsoft/microsoft-ui-xaml](https://github.com/microsoft/microsoft-ui-xaml)
- en: 'Create a custom control using handlers: [https://learn.microsoft.com/en-us/dotnet/maui/user-interface/handlers/create?view=net-maui-8.0](https://learn.microsoft.com/en-us/dotnet/maui/user-interface/handlers/create?view=net-maui-8.0)'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用处理程序创建自定义控件：[https://learn.microsoft.com/en-us/dotnet/maui/user-interface/handlers/create?view=net-maui-8.0](https://learn.microsoft.com/en-us/dotnet/maui/user-interface/handlers/create?view=net-maui-8.0)
- en: 'Introducing Shared Class Library – multi-target Xamarin.Forms and .NET MAUI
    from a single project: [https://egvijayanand.in/2022/05/25/introducing-shared-class-library-multi-target-xamarin-forms-and-dotnet-maui-from-a-single-project/](https://egvijayanand.in/2022/05/25/introducing-shared-class-library-multi-target-xamarin-forms-and-dotnet-maui-from-a-single-project/)'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍共享类库 – 从单个项目中多目标Xamarin.Forms和.NET MAUI：[https://egvijayanand.in/2022/05/25/introducing-shared-class-library-multi-target-xamarin-forms-and-dotnet-maui-from-a-single-project/](https://egvijayanand.in/2022/05/25/introducing-shared-class-library-multi-target-xamarin-forms-and-dotnet-maui-from-a-single-project/)
- en: Leave a review!
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 留下评论！
- en: '*Enjoying this book? Help readers like you by leaving an Amazon review. Scan
    the QR code below for a 40% discount code.*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*喜欢这本书吗？通过留下亚马逊评论来帮助像你这样的读者。扫描下面的二维码以获取40%的折扣码。*'
- en: '![](img/Leave_a_review_QR.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Leave_a_review_QR.png)'
- en: '**Limited Offer*'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**限时优惠**'
