- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Testing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: Software testing serves as a critical part of the software development life
    cycle, acting as a safeguard against defects and enhancing the overall quality
    of software products. Certification from **Quality Assurance** (**QA**) is often
    used as the indicator of whether the software product is ready to go live.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 软件测试是软件开发生命周期中的一个关键部分，作为缺陷的防护措施，并提高软件产品的整体质量。**质量保证（QA**）的认证通常用作软件产品是否准备发布的指标。
- en: This chapter delves into the fundamental principles of software testing, exploring
    its significance, methodologies, and best practices.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了软件测试的基本原则，探讨了其重要性、方法和最佳实践。
- en: We will discuss the role of QA and software testers in the industry. We will
    summarize the understanding of the role and how it might mean something different
    to different people.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论QA和软件测试人员在行业中的作用。我们将总结对这个角色的理解以及它可能对不同的人意味着不同的事情。
- en: We will explore several types of software testing and the testing pyramid. Additionally,
    we will discuss automated testing practices, which have gained popularity for
    their ability to enhance efficiency and ensure consistent test coverage.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨几种类型的软件测试和测试金字塔。此外，我们还将讨论自动化测试实践，这些实践因其提高效率和确保一致测试覆盖率的特性而受到欢迎。
- en: We will also run an exercise of strict **Test-Driven Development** (**TDD**)
    using Kotest to gain insights into this methodology.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将通过使用Kotest进行严格的**测试驱动开发（TDD**）练习，深入了解这一方法。
- en: 'This chapter aims to provide a comprehensive overview of software testing,
    equipping you with the knowledge and tools necessary to implement effective testing
    strategies. This chapter will empower you to contribute to the creation of high-quality
    software that meets user expectations and stands the test of time. We are going
    to cover the following topics in the chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在提供软件测试的全面概述，为您提供实施有效测试策略所需的知识和工具。本章将使您能够为创建满足用户期望并经得起时间考验的高质量软件做出贡献。本章将涵盖以下主题：
- en: The role of QA and its involvement in software development
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: QA的作用及其在软件开发中的参与
- en: The testing pyramid
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试金字塔
- en: TDD with an exercise
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带练习的TDD
- en: BDD
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BDD
- en: Live testing, A/B testing, and segmentation
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现场测试、A/B测试和细分
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find all the code files used in this chapter on GitHub:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章中使用的所有代码文件：
- en: '[https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-13](https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-13%0D)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-13](https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-13%0D)'
- en: The role of QA and software testers
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QA和软件测试人员的作用
- en: 'The primary goals of software testing are as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 软件测试的主要目标如下：
- en: To identify and rectify defects before a product reaches the end user
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在产品达到最终用户之前识别和纠正缺陷
- en: To ensure the software product behaviors meet the functional specifications
    or business expectations
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保软件产品的行为符合功能规范或业务期望
- en: It is essential even for a startup company or the first product launch by a
    new company.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 即使对于初创公司或新公司首次发布的产品，这也是至关重要的。
- en: 'The role of QA or software tester can be confusing and is often misunderstood.
    Like software architect as a role, QA is not necessarily a job title, though you
    might have seen these titles in the job market:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: QA或软件测试人员的作用可能令人困惑，并且经常被误解。就像软件架构师作为一个角色一样，QA不一定是一个职位名称，尽管您可能在就业市场上看到过这些标题：
- en: QA
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: QA
- en: QA tester
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: QA测试人员
- en: QA engineer
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: QA工程师
- en: Quality engineer
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 质量工程师
- en: Software tester
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件测试人员
- en: Test engineer
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试工程师
- en: Automation tester
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化测试人员
- en: '**Software Development Engineer in** **Test** (**SDET**)'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试开发工程师（SDET**）'
- en: Different organizations may have different interpretations or expectations for
    each title. In this chapter, we use the term QA to represent an engineer who is
    responsible for software quality.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的组织可能对每个标题有不同的解释或期望。在本章中，我们使用QA一词来代表负责软件质量的工程师。
- en: 'The role of a QA is illustrated in *Figure 13**.1*:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: QA的作用如图13.1所示：
- en: '![Figure 13.1 – The role of QA](img/B21737_13_1.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 13.1 – The role of QA](img/B21737_13_1.jpg)'
- en: Figure 13.1 – The role of QA
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 – QA的作用
- en: It is important to emphasize that QA should be a full-time engagement embedded
    in the team organized by business functions, as described in [*Chapter 1*](B21737_01.xhtml#_idTextAnchor013).
    QAs, just like other engineers, are involved in understanding business priorities,
    requirement analysis, test plan creation, and acceptance criteria definitions.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 强调QA应该是一个全职的、嵌入到由业务功能组织的团队中的参与，正如在[*第一章*](B21737_01.xhtml#_idTextAnchor013)中所述。QA与其他工程师一样，参与理解业务优先级、需求分析、测试计划创建和验收标准定义。
- en: However, from this point onward, QAs have a different focus than the engineers
    who develop the software for the business. QAs focus on overall testing strategies,
    test script creation, test processes and tools, **User Acceptance Test** (**UAT**)
    planning, and exploratory testing.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从这一点开始，QA的关注点与为业务开发软件的工程师不同。QA专注于整体测试策略、测试脚本创建、测试流程和工具、**用户验收测试**（**UAT**）规划和探索性测试。
- en: The objectives of QAs are like those of the engineers who develop the software.
    They both want the software to have complete features that are good enough to
    meet business expectations. QAs do have a different focus and approaches to achieving
    the objectives though – by ensuring the software is developed to a high standard
    as required.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: QA的目标与开发软件的工程师的目标相似。他们都希望软件具有完整的功能，足以满足业务期望。尽管如此，QA在实现目标时确实有不同的关注点和方法——通过确保软件按照所需的高标准开发。
- en: To code or not to code?
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码还是不编码？
- en: The question of whether a QA should code often lacks clarity. QAs should leverage
    all available tools and resources to meet software quality standards. Coding can
    be essential for creating specific test scripts or enhancing tools. Ultimately,
    the debate about whether QAs should code is somewhat misguided; for many situations,
    writing code is a necessary part of their role.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 关于QA是否应该编码的问题往往缺乏清晰性。QA应利用所有可用的工具和资源来满足软件质量标准。编写代码对于创建特定的测试脚本或增强工具可能是必不可少的。最终，关于QA是否应该编码的争论有些误导；在许多情况下，编写代码是他们角色中必要的一部分。
- en: Job titles for QA in the industry tend to include the term *engineers* (e.g.,
    QA engineers) when the organization expects the QA person to write code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 行业中QA的职位通常包括术语*工程师*（例如，QA工程师），当组织期望QA人员编写代码时。
- en: Software quality is everyone’s responsibility
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件质量是每个人的责任
- en: It seems obvious to say that software quality is everyone’s responsibility,
    but it may not be so clear to some organizations. Software quality is best assured
    when it is embedded in the software development process from the beginning to
    the end.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 说软件质量是每个人的责任似乎很显然，但对于某些组织来说可能并不那么清楚。软件质量最好是从软件开发过程开始到结束都嵌入其中。
- en: That includes all the activities during the software development process, starting
    from clear business priorities to well-written code, and eventually business user
    signoff and software launch. This involves every member of the team, not just
    QAs.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括软件开发生命周期中的所有活动，从明确的企业优先级到编写良好的代码，最终到业务用户签字和软件发布。这涉及到团队中的每个成员，而不仅仅是QA。
- en: QA is the role that ensures software quality is taken care of every step of
    the way, so the outcome is a high-quality and well-tested software product.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: QA是确保软件质量在每个步骤都得到关注的角色，因此结果是高质量且经过良好测试的软件产品。
- en: With increasing complexity in software systems and the growing demand for robust
    applications, effective testing strategies are essential. By adopting a systematic
    approach to testing, organizations can mitigate risks, reduce costs associated
    with post-release defects, and foster user trust.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 随着软件系统复杂性的增加和对稳健应用需求的增长，有效的测试策略是必不可少的。通过采用系统化的测试方法，组织可以降低风险，减少与发布后缺陷相关的成本，并培养用户信任。
- en: By fostering an environment that prioritizes QA, organizations can not only
    improve product outcomes but also enhance team collaboration and communication.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通过营造优先考虑QA的环境，组织不仅可以提高产品结果，还可以增强团队合作和沟通。
- en: QA’s involvement in the software development life cycle
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QA在软件开发生命周期中的参与
- en: The team, including QAs, understands business priorities collectively. Then
    the team analyzes the requirements together and creates a couple of user stories.
    Each user story represents a unit of work and is a part of the bigger business
    feature, but each story also brings some value to the business.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 团队，包括质量保证人员，共同理解业务优先级。然后团队一起分析需求，并创建几个用户故事。每个用户故事代表一个工作单元，是更大业务功能的一部分，但每个故事也给业务带来一些价值。
- en: A user story needs to be refined to have a set of acceptance criteria that decides
    whether the story has satisfied the expectations of stakeholders. Every acceptance
    criterion should be concise and testable.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 用户故事需要细化，以便有一套验收标准，这些标准决定故事是否满足了利益相关者的期望。每个验收标准都应该是简洁且可测试的。
- en: The convention of acceptance criteria
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 验收标准的惯例
- en: 'An acceptance criterion can follow a popular structure of **given-when-then**.
    *Given* provides the initial context of the state of the system before the action
    is performed. *When* is the action performed given the context. *Then* is the
    expected outcome because of the action performed. An example of an acceptance
    criterion in given-when-then structure is as follows: *“Given that a household
    does not exist in the system, when the household creates an account in the system,
    then the corresponding household record* *is created.”*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 验收标准可以遵循流行的**给定-当-然后**结构。*给定*提供了在执行操作之前系统状态的初始上下文。*当*是在给定上下文的情况下执行的操作。*然后*是执行操作后的预期结果。一个给定-当-然后结构中的验收标准示例如下：“*给定系统中不存在家庭，当在系统中创建家庭账户时，然后相应的家庭记录*
    *被创建。”*
- en: From the acceptance criteria, engineers start their technical design on how
    to make a change to satisfy the conditions. Meanwhile, QAs start creating a test
    plan on how to verify that the change has satisfied the conditions.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 从验收标准开始，工程师开始进行技术设计，以确定如何进行更改以满足条件。同时，质量保证人员开始创建测试计划，以验证更改是否满足条件。
- en: The test plan should be cascaded into actual test scripts. Test scripts are
    detailed executable scripts describing how the software is tested. It includes
    setting up the data (the *given*), executing the actions (the *when*), and verifying
    the results (the *then*). The test scripts can be in any format, such as a document
    of the steps, an automation script, or even an independently executed program.
    The content of the testing is more important than the format.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 测试计划应分解为实际的测试脚本。测试脚本是一系列详细的可执行脚本，描述了如何对软件进行测试。它包括设置数据（即*给定*），执行操作（即*当*），以及验证结果（即*然后*）。测试脚本可以是任何格式，例如步骤文档、自动化脚本，甚至是一个独立执行程序。测试内容的重要性高于格式。
- en: In addition to scripted testing, QAs perform exploratory testing, which emphasizes
    the testers’ autonomy and creativity. QAs can explore the application freely,
    learning about it while actively testing it. Often, QAs find inconsistent system
    behaviors, loopholes, or hidden defects that cannot be discovered with fixed scripts.
    Exploratory tests are often time-boxed. There will also be a document on the findings,
    bugs discovered, unusual behaviors, and areas that require further investigation.
    These documents are often hosted in an **issue tracking system** such as JIRA,
    Asana, Trello, GitHub Issues, and so on.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 除了脚本测试之外，质量保证人员还执行探索性测试，这强调测试人员的自主性和创造力。质量保证人员可以自由地探索应用程序，在积极测试的同时了解它。通常，质量保证人员会发现系统行为不一致、漏洞或隐藏缺陷，这些缺陷无法通过固定脚本发现。探索性测试通常有时间限制。还将有一份关于发现、发现的错误、异常行为和需要进一步调查的领域的文档。这些文档通常托管在**问题跟踪系统**中，如JIRA、Asana、Trello、GitHub
    Issues等。
- en: QAs are also involved in planning UATs where business testers (stakeholders
    and potentially real users) are involved. QAs help shape the testing process and
    are the ones to respond to queries by business testers. This is also an opportunity
    for QAs to confirm that the requirements are fully captured and to identify any
    features missed in the scope.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 质量保证人员也参与规划用户验收测试（UAT），其中涉及业务测试人员（利益相关者和可能的实际用户）。质量保证人员帮助塑造测试过程，并负责回应业务测试人员的查询。这也是质量保证人员确认需求是否完全捕获并识别任何遗漏在范围之外的功能的机会。
- en: Apart from business delivery-focused testing activities, QAs are also responsible
    for having an overall testing strategy to align with other teams and share best
    practices. QAs are also responsible for maintaining test processes and tools.
    Quite often, QAs enhance existing test frameworks and maintain the end-to-end
    test suite.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 除了以业务交付为重点的测试活动之外，质量保证（QA）人员还负责制定整体测试策略，以与其他团队保持一致并分享最佳实践。QA人员还负责维护测试流程和工具。通常情况下，QA人员会增强现有的测试框架并维护端到端测试套件。
- en: Up next, we are going to concentrate on the testing methodology, starting with
    the testing pyramid.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将专注于测试方法，从测试金字塔开始。
- en: Testing pyramid
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试金字塔
- en: 'The testing pyramid is a conceptual framework in which various levels of tests
    in software development emerge as a hierarchical structure. This concept was made
    popular by Martin Fowler in 2009 in his *The Testing Pyramid* article. The testing
    pyramid is illustrated in *Figure 13**.2*:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 测试金字塔是一个概念框架，其中软件开发中的各种测试层级以层次结构的形式出现。这个概念由马丁·福勒在2009年的*《测试金字塔》*文章中推广。测试金字塔在*图13.2*中展示。2*：
- en: '![Figure 13.2 – Testing pyramid](img/B21737_13_2.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图13.2 – 测试金字塔](img/B21737_13_2.jpg)'
- en: Figure 13.2 – Testing pyramid
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2 – 测试金字塔
- en: In this section, we’ll explore all the levels of the testing pyramid.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨测试金字塔的所有层级。
- en: Unit testing
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: The bottom level of the pyramid is unit testing. Unit tests are the foundation
    of the testing pyramid. They focus on the smallest building blocks that can be
    tested in isolation. They often test the behaviors of functions, and they are
    executed as a part of the local project build.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 金字塔的底层是单元测试。单元测试是测试金字塔的基础。它们关注可以独立测试的最小构建块。它们通常测试函数的行为，并且作为本地项目构建的一部分执行。
- en: Unit tests are comparatively easy to write and execute due to their small size
    and scope. Unit tests can be run inside the **Integrated Development Environment**
    (**IDE**), which provides the quickest feedback loop. Bugs can be found and reported
    by unit tests within minutes – if not seconds.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于规模小和范围有限，单元测试相对容易编写和执行。单元测试可以在**集成开发环境**（**IDE**）中运行，这提供了最快的反馈循环。单元测试可以在几分钟内（如果不是几秒钟内）找到并报告错误。
- en: It is common for the local project build to fail if any unit tests are unsuccessful.
    Integrating automated unit tests into the build process helps identify bugs early
    in development. Testing and fixing bugs is most cost-effective during unit testing
    because the bugs are smaller in size, require less effort to address, and provide
    quicker feedback compared to other testing stages. Additionally, a system typically
    has more unit tests than any other type of test, as unit tests target the smallest
    components, resulting in a larger quantity compared to larger tests.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何单元测试失败，本地项目构建通常会失败。将自动化单元测试集成到构建过程中有助于在开发早期识别错误。在单元测试中测试和修复错误是最具成本效益的，因为错误规模较小，需要较少的努力来解决，并且与其他测试阶段相比提供更快的反馈。此外，系统通常比任何其他类型的测试都有更多的单元测试，因为单元测试针对的是最小的组件，与较大的测试相比，数量更多。
- en: Unit tests should be meaningful
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试应该是具有意义的
- en: While unit tests are the smallest building blocks that can be tested, there
    are a few cases where a function is too small to be tested. If engineers struggle
    to explain what the test aims to verify, it is likely that the function is too
    small to be tested. A private function usually does not require a unit test, but
    a function that’s called by other packages (i.e., a public function) should have
    a unit test. Functions extracted merely to avoid duplicated code are unlikely
    to form a meaning that requires testing. To summarize, unit tests should be meaningful.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然单元测试是可以测试的最小构建块，但也有一些情况下，一个函数太小而无法进行测试。如果工程师难以解释测试旨在验证的内容，那么这个函数可能太小而无法进行测试。通常，私有函数不需要单元测试，但被其他包（即公共函数）调用的函数应该有单元测试。仅仅为了避免代码重复而提取的函数不太可能形成需要测试的意义。总之，单元测试应该是具有意义的。
- en: 'Here is an example of a unit test in Kotlin powered by the Kotest framework:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个由 Kotest 框架驱动的 Kotlin 单元测试的例子：
- en: '[PRE0]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The Kotest framework provides many test templates as specifications. `FunSpec`
    is the one used in the example. The test cases are passed in as lambda expressions.
    The `test` function takes the test name as an argument. A lambda expression under
    the scope of `TestScope` is passed in for the actual test. This unit test targets
    the `findBiggestNumber` function, which is given a list of integers: `17`, `18`,
    and `6`. The `shouldBe` infix function mimics the natural English language and
    validates whether the expected result is `18`.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Kotest 框架提供了许多作为规范的测试模板。`FunSpec` 是示例中使用的。测试用例作为 lambda 表达式传入。`test` 函数接受测试名称作为参数。在
    `TestScope` 范围内的 lambda 表达式被传入以进行实际测试。这个单元测试针对 `findBiggestNumber` 函数，它接受一个整数列表：`17`、`18`
    和 `6`。`shouldBe` 内联函数模仿自然英语语言，并验证预期结果是否为 `18`。
- en: Parameterized testing
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数化测试
- en: 'You might question whether one test case is not enough to thoroughly test this
    function. The Kotest framework supports parameterized testing as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会质疑是否一个测试用例不足以彻底测试这个函数。Kotest 框架支持以下参数化测试：
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For a function that takes a list of integers and returns the maximum number,
    there are many cases we can think of:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个接受整数列表并返回最大数字的函数，我们可以想到许多情况：
- en: Empty lists
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空列表
- en: Lists of one integer
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个整数的列表
- en: Lists of two integers
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个整数的列表
- en: All positive integers
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有正整数
- en: All negative integers
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有负整数
- en: A mixture of zero, positive, and negative integers
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零、正数和负数的混合
- en: Maximum, minimum, maximum plus one, minimum minus one, and the negation of these
    integers
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大值、最小值、最大值加一、最小值减一，以及这些整数的否定
- en: With parameterized testing, it is possible to test them all with code footprints
    smaller than if we had to duplicate them into separate test cases.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用参数化测试，可以以比我们必须将它们复制到单独的测试用例中更小的代码足迹测试它们所有。
- en: 'At this point, you might want to see the source code of the function being
    tested, to ensure that you have covered all cases, but do you need to? There is
    no right or wrong answer here because it represents two methods of software testing:
    **blackbox testing** and **whitebox testing**. Please note that these two testing
    styles are applicable to all levels of testing in the pyramid.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能想查看正在测试的函数的源代码，以确保你已经覆盖了所有情况，但你需要吗？这里没有正确或错误的答案，因为它代表了两种软件测试方法：**黑盒测试**和**白盒测试**。请注意，这两种测试风格适用于金字塔中所有级别的测试。
- en: 'Before we discuss these two testing styles in detail, let us reveal the implementation:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们详细讨论这两种测试风格之前，让我们揭示实现：
- en: '[PRE2]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It is a very simple implementation and uses the built-in `maxOrNull` Kotlin
    function to find the maximum number in the list or null for an empty list.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的实现，并使用内置的 `maxOrNull` Kotlin 函数在列表中找到最大数字或空列表的 null。
- en: Blackbox testing
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 黑盒测试
- en: Blackbox testing evaluates the functionality being tested without any knowledge
    of the internal code or structure. Testers focus merely on the inputs, expected
    outputs, and alleged functionality provided (known as the *contract*).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 黑盒测试评估被测试的功能，而不了解任何内部代码或结构。测试人员仅关注输入、预期输出和声称的功能（称为*合同*）。
- en: Whitebox testing
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 白盒测试
- en: Whitebox testing goes in the opposite direction. It involves examining the internal
    implementation of the functionality being tested. Testers have knowledge of the
    code and internal logic, allowing them to design test cases based on the implementation
    details.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 白盒测试朝相反的方向进行。它涉及检查正在测试的功能的内部实现。测试人员了解代码和内部逻辑，使他们能够根据实现细节设计测试用例。
- en: Comparing blackbox and whitebox testing
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较黑盒测试和白盒测试
- en: Blackbox testing focuses on the results and functionalities that would affect
    user experience. Not depending on implementation also enables testers to discover
    any discrepancies between actual and expected behaviors, revealing requirements
    that may not have been thoroughly defined. It may, however, miss some code branches
    in the test suite, which potentially hinders complete code coverage. Organizations
    that have independent QA teams, separated from the development teams, typically
    use blackbox testing as their default approach.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 黑盒测试关注会影响用户体验的结果和功能。不依赖于实现也使测试人员能够发现实际行为和预期行为之间的任何差异，揭示可能没有充分定义的需求。然而，它可能会在测试套件中错过一些代码分支，这可能会阻碍完整的代码覆盖率。通常，拥有独立
    QA 团队且与开发团队分离的组织会使用黑盒测试作为其默认方法。
- en: Whitebox testing enables comprehensive testing of internal logic, leading to
    the discovery of hidden bugs or vulnerabilities under specific circumstances.
    Knowing the code also helps testers identify security vulnerabilities and optimization
    opportunities that would help meet the non-functional requirements. Knowing the
    code also brings bias in test cases to unknowingly omit test cases that can comprehensively
    cover external behaviors and user experience.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 白盒测试能够全面测试内部逻辑，导致在特定情况下发现隐藏的漏洞或缺陷。了解代码也有助于测试人员识别安全漏洞和优化机会，这些可以帮助满足非功能性需求。了解代码也可能在测试用例中引入偏见，无意中省略了可以全面覆盖外部行为和用户体验的测试用例。
- en: There are also human factors in play between the two styles. Once a tester has
    seen the internal implementation, it is difficult to pretend not to have seen
    it before and to write bias-free blackbox tests.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种风格之间也存在人为因素。一旦测试人员看到了内部实现，就很难假装之前没有看到过，并编写无偏见的黑盒测试。
- en: Both test styles have their merits and disadvantages. Due to the human factor
    mentioned, it is recommended to start writing blackbox tests without knowing the
    implementation first and to focus on testing the external behaviors. Afterward,
    check the implementation to write whitebox test cases and focus on code branches
    and non-functional requirements.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 两种测试风格都有其优点和缺点。由于提到的人为因素，建议首先在不了解实现的情况下编写黑盒测试，并专注于测试外部行为。之后，检查实现来编写白盒测试用例，并专注于代码分支和非功能性需求。
- en: This will lead to a topic called TDD, which will be covered later in this chapter.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致一个称为TDD的话题，将在本章后面进行介绍。
- en: Component testing
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件测试
- en: Known as **module testing**, component testing is one level above unit testing
    in the pyramid. It focuses on testing the higher-order behaviors of self-contained
    modules. Component focuses on the behaviors emerging from the interactions of
    several units of code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为**模块测试**的组件测试在金字塔中位于单元测试之上。它专注于测试自包含模块的高级行为。组件测试关注于由几个代码单元的交互产生的行为。
- en: Component tests are also included as part of the local project build. So, if
    a component test has failed, the local project build fails. It is also often executed
    from IDE to provide a quick feedback loop.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 组件测试也被包括在本地项目构建的一部分。因此，如果组件测试失败，本地项目构建也会失败。它通常从IDE执行，以提供快速反馈循环。
- en: However, component tests are bigger and require more effort to write. Each test
    usually involves setting a combination of states before the test. The test itself
    often involves multiple steps, and there are usually multiple places to verify
    the results. If there is a problem found, it is not immediately obvious where
    the problem is, and it would require some time to troubleshoot and debug. So,
    the cost of testing and fixing bugs is higher than unit testing.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，组件测试更大，需要更多的努力来编写。每个测试通常涉及在测试之前设置一组状态。测试本身通常涉及多个步骤，并且通常有多个地方需要验证结果。如果发现问题，问题所在并不立即明显，需要一些时间来调试和解决问题。因此，测试和修复错误的成本高于单元测试。
- en: One of the examples of component testing can be found in applications that use
    modular and layered architecture, as mentioned in [*Chapter 7*](B21737_07.xhtml#_idTextAnchor255).
    For example, if we use the **hexagonal architecture**, component testing can be
    conducted at the core layer to verify the pure business logic without coupling
    technology choices. This is particularly useful if the bounded context of the
    application belongs to the Core domain, as mentioned in [*Chapter 8*](B21737_08.xhtml#_idTextAnchor289).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 组件测试的一个例子可以在提到模块化和分层架构的应用程序中找到，如[*第7章*](B21737_07.xhtml#_idTextAnchor255)所述。例如，如果我们使用**六边形架构**，可以在核心层进行组件测试，以验证纯业务逻辑，而不受技术选择的影响。如果应用程序的边界上下文属于核心域，这如[*第8章*](B21737_08.xhtml#_idTextAnchor289)所述，这尤其有用。
- en: The core layer of the Core domain is often perceived as the “crown jewel” of
    the entire system. It serves as the heartbeat around which everything else revolves.
    It makes the case to use component testing to ensure the central pure business
    behaviors are intact in every change made in the system.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 核心域的核心层通常被视为整个系统的“皇冠上的宝石”。它作为一切围绕其旋转的心脏。它主张使用组件测试来确保在系统中的每一次变更中，核心的纯业务行为都保持完整。
- en: Component testing the core layer of the Core domain with blackbox testing first
    would become the **Behavior-Driven Development** (**BDD**) approach, which will
    be discussed later in this chapter.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用黑盒测试首先对核心域的核心层进行组件测试将成为**行为驱动开发（BDD）**方法，这将在本章后面讨论。
- en: Mocking external resources
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模拟外部资源
- en: When writing component tests, it is almost inevitable to encounter situations
    when the code tries to integrate with external resources such as queues, files,
    databases, or other applications. These integration points put a burden on the
    testers to prepare the context and increase the effort of writing the test.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写组件测试时，几乎不可避免地会遇到代码试图与外部资源（如队列、文件、数据库或其他应用程序）集成的场景。这些集成点给测试人员带来了准备测试环境和增加编写测试工作量的负担。
- en: 'Mocking enables testers to isolate the component being tested from external
    dependencies. There are a few common mocking scenarios:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟使测试人员能够将正在测试的组件从外部依赖项中隔离出来。有一些常见的模拟场景：
- en: Verify whether the component has interacted with the external dependencies as
    expected, such as checking whether the correct API with expected parameters was
    called
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证组件是否按预期与外部依赖项交互，例如检查是否调用了具有预期参数的正确API
- en: Enable the component test to run without needing external dependencies to be
    available, for example, the database
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使组件测试能够在不需要外部依赖项（例如数据库）可用的情况下运行
- en: Verify whether the component can handle the failures of external dependencies
    as expected
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证组件是否能够按预期处理外部依赖项的失败
- en: Maintain states that allow testing different conditions, such as returning different
    values based on the context of the tests
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护允许测试不同条件的状态，例如根据测试的上下文返回不同的值
- en: 'Here is an example of component testing with mocking, also using Kotest:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用Kotest进行组件测试的模拟示例：
- en: '[PRE3]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Firstly, this component test uses the `BehaviorSpec` from Kotest that follows
    the given-when-then format. It also matches the test pattern of **Arrange, Act,**
    **Assert** (**3A**).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这个组件测试使用了遵循给定-当-然后（given-when-then）格式的Kotest的`BehaviorSpec`。它还匹配**安排（Arrange）**、**执行（Act）**、**断言（Assert）**（**3A**）的测试模式。
- en: The 3A test pattern
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 3A测试模式
- en: The 3A test pattern can be used in a unit test. It helps engineers and testers
    to organize tests by dividing them into three distinct sections. As a result,
    test scripts are easier to read, understand, reason, and maintain. *Arrange* is
    the initialization of preconditions and input data for the test. *Act* is the
    execution of the behaviors being tested. *Assert* is the verification of the actual
    outcome against the expected result.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 3A测试模式可以在单元测试中使用。它帮助工程师和测试人员通过将测试分为三个不同的部分来组织测试。因此，测试脚本更容易阅读、理解、推理和维护。"安排（Arrange）"是测试的先决条件和输入数据的初始化。"执行（Act）"是执行被测试的行为。"断言（Assert）"是验证实际结果与预期结果是否一致。
- en: 'Secondly, there is an external `ExerciseLog` dependency, which may involve
    persisting data in files or databases:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，存在一个外部的`ExerciseLog`依赖项，可能涉及在文件或数据库中持久化数据：
- en: '[PRE4]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The function record accepts an `Exercise` object and the corresponding time
    when the exercise was done:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 函数记录接受一个`Exercise`对象和练习完成时的相应时间：
- en: '[PRE5]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As the focus of the test is the logic of `ExerciseExecutor`, not `ExerciseLog`,
    we use the `mockk` function from the `ExerciseLog` interface. We set up the mock
    object to accept the invocation of the `record` function with any parameters and
    to return a `Unit`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由于测试的重点是`ExerciseExecutor`的逻辑，而不是`ExerciseLog`，我们使用了`ExerciseLog`接口的`mockk`函数。我们设置模拟对象以接受任何参数的`record`函数调用，并返回一个`Unit`。
- en: 'The primary validation is that when the weather is sunny, the function returns
    `RunInThePark`, as defined by this sealed class:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 主要验证是当天气晴朗时，该函数返回由这个密封类定义的`RunInThePark`：
- en: '[PRE6]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The second validation is that `ExerciseExecutor` has passed the correct parameters
    to `ExerciseLog` to record this exercise. Here is the full implementation of `ExerciseExecutor`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个验证是`ExerciseExecutor`已将正确的参数传递给`ExerciseLog`以记录此练习。以下是`ExerciseExecutor`的完整实现：
- en: '[PRE7]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Mocks are one of the five types of **test doubles** used in software testing.
    Here is the full list:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟是软件测试中使用的五种**测试替身（test doubles）**类型之一。以下是完整的列表：
- en: '**Mocks**: These are pre-programmed with expectations of how they should be
    used. They are used to verify whether the specific functions are invoked with
    the expected parameters'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模拟（Mocks）**：这些预先编程了它们应该如何被使用的期望。它们被用来验证特定的函数是否以预期的参数被调用'
- en: '**Stubs**: These provide pre-defined responses to functions but do not verify
    interactions.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存根**：这些为函数提供预定义的响应，但不验证交互。'
- en: '**Spies**: Spies log the parameters used and count the function calls. The
    actual function is still invoked.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**间谍**：间谍记录使用的参数并计算函数调用次数。实际的函数仍然被调用。'
- en: '**Fakes**: These allow for a simplified implementation of the external dependencies
    for testing purposes.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模拟**：这些允许在测试目的下简化外部依赖的实现。'
- en: '**Dummies**: A dummy is a simple object used just to satisfy parameter requirements
    without needing to implement any behavior.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模拟对象**：模拟对象是一个简单的对象，仅用于满足参数要求，而不需要实现任何行为。'
- en: Contract testing
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合同测试
- en: Contract testing focuses on the interaction between API producers and consumers.
    It only aims at the communication protocol and the message content. It should
    not be used for business case testing because we already have component testing
    covering it in the lower level of the testing pyramid.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**合同测试**：这主要关注API生产者和消费者之间的交互。它仅针对通信协议和消息内容。不应将其用于业务案例测试，因为我们已经有组件测试在测试金字塔的较低层次覆盖了这一点。'
- en: 'There are two types of contract testing:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 合同测试有两种类型：
- en: '**Consumer testing**: This focuses on the service that makes requests to another
    service. It defines the expectations of the interactions it will have with the
    producer, typically through a contract. It also verifies that the consumer service
    can handle all documented responses to the requests made. Consumer contract testing
    uses stubs or fakes to set up the target service to communicate with.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消费者测试**：这主要关注向其他服务发出请求的那个服务。它定义了它与生产者交互的期望，通常通过合同。它还验证消费者服务可以处理所有已记录的请求响应。消费者合同测试使用存根或模拟来设置目标服务以进行通信。'
- en: '**Producer testing**: This focuses on the service that provides the functionality
    or data requested by another service. It aims to assert that the producer has
    fulfilled the API contract and met the expectations of its consumers. Producer
    tests may involve running the actual service, which makes it seem as though it
    should be higher up in the testing pyramid. It is also possible that producer
    testing mocks the business logic to produce the message and response defined in
    the contract. Producer testing is often used to ensure that updates and changes
    to contracts are backward compatible.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生产者测试**：这主要关注提供其他服务所需功能或数据的那个服务。其目的是断言生产者已经履行了API合同并满足了消费者的期望。生产者测试可能涉及运行实际服务，这使得它似乎应该在测试金字塔的更高层次。也有可能生产者测试会模拟业务逻辑以产生合同中定义的消息和响应。生产者测试通常用于确保合同的更新和更改具有向后兼容性。'
- en: It is, however, important to have contract tests focus on the communication
    and message content only. For example, the `openapi.yaml` file. This leads to
    more reliable and maintainable systems, especially in microservices architectures.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，重要的是让合同测试仅关注通信和消息内容。例如，`openapi.yaml`文件。这导致更可靠和可维护的系统，尤其是在微服务架构中。
- en: Integration testing
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成测试
- en: Integration testing focuses on the interactions between different components
    or modules of the application. It is one level up from contract testing in the
    pyramid as integration tests do not use stubs or fakes. They identify issues when
    integrating various parts of the system and verify the parts work together as
    intended. Integration testing is also a part of the local project build.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**集成测试**：这主要关注应用程序不同组件或模块之间的交互。在金字塔中，集成测试位于合同测试之上，因为集成测试不使用存根或模拟。它们在集成系统的各个部分时识别问题，并验证这些部分是否按预期协同工作。集成测试也是本地项目构建的一部分。'
- en: 'Integration testing usually involves databases, file systems, external services,
    or APIs. The following are the common types of integration testing:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试通常涉及数据库、文件系统、外部服务或API。以下是一些常见的集成测试类型：
- en: '**API integration testing**: Use the exposed APIs to interact with the application
    for the given use case and to verify the result from the response.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API集成测试**：使用公开的API与应用程序进行交互，以验证给定用例的结果和响应。'
- en: '**Database integration testing**: Confirm that data is correctly processed
    in the database. This is typically related to **Create, Read, Update, Delete**
    (**CRUD**) operations.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库集成测试**：确认数据在数据库中正确处理。这通常与**创建、读取、更新、删除**（**CRUD**）操作相关。'
- en: '**File system integration testing**: Verify that the application can read from
    or write to files correctly, and verify the file reflects the result of the operations
    in the test.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件系统集成测试**：验证应用程序能否正确地从文件中读取或写入，并验证文件反映了测试中操作的结果。'
- en: '**Middleware or external service integration testing**: Verify that the integration
    of middleware or external service connectivity is correctly configured, as well
    as that the application and middleware or external service can communicate as
    intended.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中间件或外部服务集成测试**：验证中间件或外部服务连接的集成配置是否正确，以及应用程序和中间件或外部服务能否按预期进行通信。'
- en: Integration tests are bigger than component and unit tests due to the required
    configuration and preparation. Integration tests are also more complex to write
    and reason about. Integration tests might involve various combinations of configurations,
    for instance, supporting multiple pluggable databases or message providers, while
    the business functionality remains the same.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试比组件和单元测试更大，因为需要配置和准备。集成测试编写和推理也更复杂。集成测试可能涉及各种配置组合，例如，支持多个可插拔数据库或消息提供者，而业务功能保持不变。
- en: Some tests may become uncertain due to how external resources or external services
    behave, especially if there is asynchronous processing external to the application.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一些测试可能由于外部资源或外部服务的表现而变得不确定，尤其是如果存在应用程序之外的非同步处理。
- en: Referring to component testing, if component testing focuses on the Core layer
    of a hexagonal architecture application, then integration testing focuses on the
    adapter layer.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 参考组件测试，如果组件测试关注六边形架构应用的Core层，那么集成测试则关注适配器层。
- en: 'Extending the exercise code example, we are going to write an integration test
    for an implementation of the `ExerciseLog` interface that appends a line to a
    file for each invocation. Each line starts with a local date-time using UTC, separated
    by a colon, and ends with the name of the exercise, as shown here:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在扩展练习代码示例的基础上，我们将编写一个针对`ExerciseLog`接口实现的集成测试，该接口为每次调用向文件追加一行。每行以UTC使用的本地日期时间开始，由冒号分隔，以锻炼的名称结束，如下所示：
- en: '[PRE8]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'An integration test can be written as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试可以编写如下：
- en: '[PRE9]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The test starts by creating a temporary file that will be deleted on exit. Then
    a list of two exercise entries is passed into the `ExerciseFileLog` object. The
    verification starts by reading the file line by line and asserts that each line
    contains the expected content.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 测试开始时创建一个临时文件，该文件将在退出时被删除。然后，将两个锻炼条目列表传递给`ExerciseFileLog`对象。验证开始时逐行读取文件，并断言每行包含预期的内容。
- en: 'The `ExerciseFileLog` class itself is straightforward:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExerciseFileLog`类本身很简单：'
- en: '[PRE10]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Test scripts should mostly be integration tests in the supporting and generic
    subdomain applications, as discussed in [*Chapter 8*](B21737_08.xhtml#_idTextAnchor289).
    This is because these subdomains usually do not contain a lot of business logic,
    or the combination of business cases is simple enough to be covered by integration
    tests.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 测试脚本应主要是在支持性和通用子域应用程序中作为集成测试，如[*第8章*](B21737_08.xhtml#_idTextAnchor289)中所述。这是因为这些子域通常不包含很多业务逻辑，或者业务用例的组合足够简单，可以被集成测试覆盖。
- en: End-to-end and automated GUI testing
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 端到端和自动化GUI测试
- en: So far, all the tests we have discussed have focused on either a single backend
    service or a specific group of software components. The next level is end-to-end
    automated testing, which includes graphical user interface (GUI) testing and contract
    testing. This type of testing evaluates system behavior across multiple services
    horizontally and across various tiers vertically. Additionally, it becomes more
    transparent to business stakeholders.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论的所有测试都集中在单个后端服务或特定的软件组件组上。下一个层次是端到端自动化测试，这包括图形用户界面（GUI）测试和契约测试。此类测试评估系统在多个服务横向和多个层级纵向上的行为。此外，它对业务利益相关者来说更加透明。
- en: End-to-end and automated GUI testing focuses on a user journey that covers multiple
    services or components in the system. For example, an end-to-end test could involve
    creating two household records, and then having one household draft a contract
    with another household. Both households would then negotiate to reach an agreed
    contract, and finally, each of them would exercise the contract for the service
    described in the contract.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端和自动化GUI测试专注于覆盖系统中的多个服务或组件的用户旅程。例如，端到端测试可能涉及创建两个家庭记录，然后一个家庭与另一个家庭签订合同。然后，两个家庭将协商以达成一致合同，最后，他们各自将执行合同中描述的服务合同。
- en: End-to-end testing uses APIs for communication with various parts of the system,
    while automated GUI testing simulates human interaction with the system.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试使用API与系统的各个部分进行通信，而自动化GUI测试模拟人类与系统的交互。
- en: Some systems have a suite of public APIs for integration with external **Software-as-a-Service**
    (**SaaS**) platforms (as discussed in [*Chapter 6*](B21737_06.xhtml#_idTextAnchor212)).
    In this case, end-to-end testing should ensure that the user journey can be fulfilled
    by calling the exposed public APIs. The testing of this public API integration,
    known as headless integration, is as important as visual GUI testing.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一些系统有一套公共API，用于与外部**软件即服务（SaaS**）平台集成（如第6章所述）。在这种情况下，端到端测试应确保用户旅程可以通过调用公开的公共API来完成。这种公共API集成的测试，称为无头集成，与视觉GUI测试一样重要。
- en: The test script for one user journey is complex and fragile. It requires multiple
    services to be operational in an environment, which implies stable infrastructure
    as well. It is not practical to test all the variations of user journeys, as the
    test suite takes a long time to finish.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一个用户旅程的测试脚本复杂且脆弱。它需要在环境中运行多个服务，这意味着需要稳定的基础设施。测试所有用户旅程的变体并不实际，因为测试套件需要很长时间才能完成。
- en: Tests at this level typically only cover the most crucial and user-facing features.
    They also usually only cover successful cases. The tests are run periodically,
    or on demand. If an error is found during the test, it would take a longer time
    to troubleshoot, and sometimes it could be caused by stability issues in the environment
    instead of actual bugs.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此层级的测试通常仅涵盖最关键和面向用户的功能。它们通常也仅涵盖成功案例。测试是定期运行或按需进行的。如果在测试过程中发现错误，则排查错误需要更长的时间，有时可能是由于环境中的稳定性问题而不是实际的错误。
- en: Manual and exploratory testing
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动和探索性测试
- en: Manual and exploratory testing is the highest level in the pyramid. It is not
    automated, so it is up to the QAs to manually run through the cases. This level
    of testing is the most time-consuming and laborious.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 手动和探索性测试是金字塔中的最高层级。它不是自动化的，因此需要质量保证人员手动运行测试用例。这一层级的测试是最耗时和费力的。
- en: 'If a manual can be automated, QAs will aim to automate it as soon as possible
    to reduce the cost. There are a few cases where manual testing is necessary:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可以自动化手册，质量保证人员将尽快自动化以降低成本。有一些情况下，手动测试是必要的：
- en: '**Usability testing**: Evaluating user experience requires subjective analysis,
    involving elements such as visual layout, design, and overall satisfaction.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性测试**：评估用户体验需要主观分析，包括视觉布局、设计和整体满意度等元素。'
- en: '**Short-lived features**: Investment in automating tests may not be justified
    for short-lived features.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**短期功能**：对短期功能的测试自动化投资可能是不合理的。'
- en: '**Context-heavy testing**: Some tests heavily depend on complex workflows,
    interactions, or context understanding. Automating these tests to be reliable
    could outweigh the effort of testing them manually.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上下文密集型测试**：一些测试高度依赖于复杂的流程、交互或上下文理解。自动化这些测试以使其可靠可能超过了手动测试的努力。'
- en: '**Security testing**: Many security assessments, such as penetration testing,
    rely on the security expertise of humans to identify vulnerabilities that automated
    tests may not catch. Some tests require a quick pivot of the next step decided
    by security experts; these are difficult to automate.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性测试**：许多安全评估，如渗透测试，依赖于人类的安全专业知识来识别自动化测试可能无法捕捉到的漏洞。一些测试需要安全专家快速决定下一步；这些难以自动化。'
- en: Manual and exploratory testing is often executed on an ad hoc basis; however,
    some organizations allow QAs to timebox exploratory testing to discover hidden
    defects and usability issues.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 手动和探索性测试通常是基于临时执行的；然而，一些组织允许质量保证人员将探索性测试时间框定以发现隐藏的缺陷和可用性问题。
- en: Benefits of the testing pyramid
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试金字塔的好处
- en: The testing pyramid serves as a guiding principle for structuring a testing
    strategy in software development. As testing and bug fixing become more expensive
    going up each level, it is natural to prioritize unit tests, followed by component
    tests, all the way up to manual tests, so the team can achieve a more efficient
    and cost-effective QA process.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 测试金字塔作为软件开发生成测试策略的指导原则。随着测试和错误修复在每一级变得越来越昂贵，优先考虑单元测试，然后是组件测试，一直到最后是手动测试，这是很自然的，这样团队可以实现更高效和成本效益的
    QA 流程。
- en: By putting test cases at their appropriate level in the pyramid, the team not
    only enhances the overall quality of the software but also allows for a quick
    iterative feedback loop that incrementally improves software development practices.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将测试用例放在金字塔的适当层级，团队不仅提高了软件的整体质量，还允许快速迭代反馈循环，从而逐步改进软件开发实践。
- en: 'So far, all the test case examples in this chapter have only used Kotest. However,
    there are a few other frameworks that can be considered as well:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章中所有的测试用例示例都只使用了 Kotest。然而，还有几个其他框架也可以考虑：
- en: 'Atrium: [https://github.com/robstoll/atrium](https://github.com/robstoll/atrium%0D)'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Atrium: [https://github.com/robstoll/atrium](https://github.com/robstoll/atrium%0D)'
- en: 'Kluent: [https://markusamshove.github.io/Kluent/](https://markusamshove.github.io/Kluent/%0D)'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Kluent: [https://markusamshove.github.io/Kluent/](https://markusamshove.github.io/Kluent/%0D)'
- en: 'Spek: [https://spekframework.github.io/spek/docs/latest/](https://spekframework.github.io/spek/docs/latest/%0D)'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Spek: [https://spekframework.github.io/spek/docs/latest/](https://spekframework.github.io/spek/docs/latest/%0D)'
- en: Up next, we are going to discuss the TDD approach.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论 TDD 方法。
- en: TDD
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TDD
- en: TDD has a history dating back to the 1970s, when the idea of “test-first” programming
    was discussed. It was not popular until TDD became a part of **Extreme Programming**
    (**XP**), which was introduced by Kent Beck in the 1990s.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: TDD 的历史可以追溯到 20 世纪 70 年代，当时讨论了“先测试”编程的想法。直到 TDD 成为 20 世纪 90 年代由 Kent Beck 引入的**极限编程**（**XP**）的一部分，它才变得流行。
- en: XP
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: XP
- en: XP is an agile software development methodology that aims to deliver high-quality
    software, meet evolving user requirements, and reduce risks due to uncertainties
    in the process. It has five core values — *communication*, *simplicity*, *feedback*,
    *courage*, and *respect*. It emphasizes short iterative development cycles and
    close collaboration between developers and stakeholders, encouraging frequent
    feedback to adapt to changing requirements. The key practices of XP include pair
    programming, TDD, continuous integration, and frequent releases of small and incremental
    changes.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: XP 是一种敏捷软件开发方法，旨在交付高质量的软件，满足不断变化的需求，并减少由于过程的不确定性带来的风险。它有五个核心价值观——*沟通*、*简洁*、*反馈*、*勇气*和*尊重*。它强调短迭代开发周期和开发人员与利益相关者之间的紧密合作，鼓励频繁的反馈以适应变化的需求。XP
    的关键实践包括结对编程、TDD、持续集成和频繁发布小型和增量更改。
- en: 'In 2002, Beck published the book *Test-Driven-Development: By Example*, which
    provided detailed guidance on the TDD process and has since significantly influenced
    a lot of engineering practices, even today. TDD has even become a must-have interview
    coding practice in some organizations.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '2002 年，Beck 出版了《Test-Driven-Development: By Example》一书，提供了关于 TDD 流程的详细指导，并自那时以来显著影响了大量的工程实践，甚至至今。在某些组织中，TDD
    甚至已成为面试编码实践必备的技能。'
- en: 'TDD uses a simple workflow of writing tests and production code, as shown in
    *Figure 13**.3*:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: TDD 使用一个简单的流程，即编写测试和生产代码，如图 *图 13.3* 所示：
- en: '![Figure 13.3 – TDD workflow](img/B21737_13_3.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.3 – TDD 工作流程](img/B21737_13_3.jpg)'
- en: Figure 13.3 – TDD workflow
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.3 – TDD 工作流程
- en: The first step of TDD is to write a list of test scenarios. Test scenarios are
    written in business language that does not involve technical implementation. It
    describes what the expected behavior of the application is under certain conditions,
    without knowing how the application achieves it.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: TDD 的第一步是编写测试场景列表。测试场景是用业务语言编写的，不涉及技术实现。它描述了在特定条件下应用程序的预期行为，而不了解应用程序是如何实现它的。
- en: A test scenario is picked from the list, and we start writing the test. This
    part is interesting because the test case code usually does not compile due to
    requiring an enhancement of current APIs or a new API. This is normal because
    API contracts should be derived from the needs of the user, not the provider.
    Designing an API from users’ perspectives naturally conforms to the **Interface
    Segregation Principle** (**ISP**), which we discussed in [*Chapter 2*](B21737_02.xhtml#_idTextAnchor045).
    The test case should set up the preconditions, attempt to execute the steps, and
    verify the result.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 从列表中选择一个测试场景，然后我们开始编写测试。这部分很有趣，因为测试用例代码通常无法编译，因为需要增强当前的 API 或创建一个新的 API。这是正常的，因为
    API 合同应该从用户的需求中得出，而不是提供者。从用户的角度设计 API 自然符合我们之前讨论的**接口隔离原则**（**ISP**）。测试用例应该设置先决条件，尝试执行步骤，并验证结果。
- en: At this moment, you are left with a test case that either does not pass (**red**)
    or does not even compile. The next step is to change the code so that the test
    passes (**green**). It is important to ensure that all other tests pass too. This
    is exactly what the influential advocator of TDD, Kent Beck, suggested when he
    said *“fake it till you* *make it”*.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你面前的是一个要么不通过（**红色**）要么甚至无法编译的测试用例。下一步是更改代码，使测试通过（**绿色**）。确保所有其他测试也通过非常重要。这正是
    TDD 的重要倡导者 Kent Beck 在他说“假装直到你做到”时提出的建议。
- en: 'The test will now pass, but you might not be unsatisfied because the code can
    be optimized or organized better. This is your opportunity to improve quality
    by refactoring the code while ensuring all tests continue to pass. That is why
    TDD has another name: **red-green-refactor**.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 测试现在会通过，但你可能不会感到满意，因为代码可以被优化或组织得更好。这是你通过重构代码来提高质量的机会，同时确保所有测试继续通过。这就是为什么 TDD
    另有一个名字：**红-绿-重构**。
- en: There may be more test scenarios that need test cases written, or we may discover
    missed test scenarios. Nonetheless, the cycle repeats until there are no more
    test cases to write.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 可能还有更多需要编写测试用例的测试场景，或者我们可能会发现遗漏的测试场景。无论如何，这个循环会一直重复，直到没有更多的测试用例需要编写。
- en: An exercise on TDD
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TDD 练习
- en: The essence of TDD is best experienced in practice. So, we are going to run
    through a small exercise on TDD.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: TDD 的精髓最好在实践中体验。所以，我们将进行一个小型的 TDD 练习。
- en: The team is asked to develop a feature to allow users to create a household
    record in the system. There is no code written for this feature.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 团队被要求开发一个功能，允许用户在系统中创建家庭记录。这个功能还没有编写代码。
- en: Step 1 – write a list of test scenarios
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 1 步 - 编写测试场景列表
- en: 'The first step for TDD is to write a list of test scenarios. QAs and engineers
    should ask stakeholders a lot of questions and turn these answers into test scenarios.
    Here are some examples:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: TDD 的第一步是编写测试场景列表。QAs 和工程师应该向利益相关者提出很多问题，并将这些答案转化为测试场景。以下是一些例子：
- en: What are the attributes of a household record? The answer would be a surname
    and email address.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 家庭记录有哪些属性？答案是一个姓氏和电子邮件地址。
- en: Can two different households have the same surname? No, this is a small village
    where all households have distinct surnames.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个不同的家庭可以有相同的姓氏吗？不可以，这是一个小村庄，所有家庭都有不同的姓氏。
- en: Can a household have no surname? No.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个家庭可以没有姓氏吗？不可以。
- en: 'This is the first draft list of test scenarios from the answers:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这是测试场景的第一个草案列表：
- en: Fail to create a household with an empty surname
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试创建一个姓氏为空的家庭记录失败
- en: Successfully create a household
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功创建家庭
- en: Fail to create a household if the surname already exists
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果姓氏已存在，则无法创建家庭
- en: Now we can pick the first test scenario and write a test case.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以选择第一个测试场景并编写一个测试用例。
- en: Step 2 – write a test case
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 2 步 - 编写测试用例
- en: 'We want to assert that creating a household record with an empty surname results
    in failure. Again, we are using Kotest framework’s `StringSpec` as the testing
    style:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要断言创建一个姓氏为空的家庭记录会导致失败。再次，我们使用 Kotest 框架的 `StringSpec` 作为测试风格：
- en: '[PRE11]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This test case creates a `HouseholdService` object and then invokes the `createHousehold`
    function with a `Household` object with an empty surname. The test expects the
    function to return a `Failure` object that provides an appropriate reason for
    the failure.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试用例创建了一个 `HouseholdService` 对象，然后使用一个姓氏为空的 `Household` 对象调用 `createHousehold`
    函数。测试预期该函数返回一个 `Failure` 对象，提供适当的失败原因。
- en: Obviously, the code does not compile. The `HouseholdService` and `Failure` classes
    are dreamed up by the test case. They do not exist. However, writing this test
    case requires us to consider how the API should be built and what the user’s expectations
    are.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，代码无法编译。`HouseholdService` 和 `Failure` 类是由测试用例虚构的。它们不存在。然而，编写这个测试用例要求我们考虑
    API 应该如何构建以及用户的期望是什么。
- en: Step 3 – make tests pass
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 3 步 - 使测试通过
- en: 'Your IDE should indicate compilation errors for the non-existing classes and
    functions. Hopefully, your IDE should have a “quick fix” function that creates
    classes for you. It is recommended to let the IDE first create all classes, then
    functions, so the IDE has the context to generate functions with new classes.
    These classes are empty and may look like this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 IDE 应该会显示非现有类和函数的编译错误。希望您的 IDE 有一个“快速修复”功能，可以为您创建类。建议首先让 IDE 创建所有类，然后创建函数，这样
    IDE 就有上下文来生成带有新类的函数。这些类是空的，可能看起来像这样：
- en: '[PRE12]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We are ready to run the test. It has failed with this message:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好运行测试。它失败了，并显示以下信息：
- en: '[PRE13]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is a good start. The test runs and it is red (i.e., it has failed). Now
    try to *make it green* with the *simplest* *possible implementation*.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个好的开始。测试运行了，它是红色的（即，它失败了）。现在尝试用最简单的可能实现将其变为绿色。
- en: 'Hardcoding the function to return the expected `Failure` object would be the
    simplest option, wouldn’t it? Most engineers would feel the urge to fix everything
    and make the classes reasonable. However, the goal here is to write the least
    amount of code to make the test pass. Here are the changes:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数硬编码为返回预期的 `Failure` 对象可能是最简单的方法，不是吗？大多数工程师都会有修复一切并使类合理的冲动。然而，这里的目的是编写尽可能少的代码来使测试通过。以下是更改内容：
- en: '[PRE14]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `Failure` class has changed to a `data` class so that the test case gets
    the reason for verification. The `createHousehold` function now returns a hardcoded
    `Failure` object just to pass the test. The `Household` class has not changed.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`Failure` 类已更改为 `data` 类，以便测试用例能够获取验证的原因。现在 `createHousehold` 函数仅返回一个硬编码的 `Failure`
    对象以通过测试。`Household` 类没有变化。'
- en: At this point, this is only a hack implementation. However, it will evolve with
    more test cases. Let us pick the next test scenario.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这只是一个临时解决方案。然而，随着更多测试用例的出现，它将不断发展。让我们选择下一个测试场景。
- en: Step 2 again – a new test case
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 2 步再次 - 新的测试用例
- en: 'The next test scenario is the successful creation of a household record. The
    surname of the household is no longer empty, and the test expects `HouseholdService`
    to respond with a successful result that contains the created `Household` record.
    See the code of the test case here:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个测试场景是成功创建一个家庭记录。家庭的姓氏不再为空，测试期望 `HouseholdService` 返回一个包含已创建 `Household` 记录的成功结果。请在此查看测试用例的代码：
- en: '[PRE15]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The test case uses the `Arb` class from the Kotest property module (`io.kotest:kotest-property`)
    to generate a random surname for the `Household` object. The test case uses a
    randomly generated string with a minimum size of three as the surname.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 测试用例使用 Kotest 属性模块（`io.kotest:kotest-property`）中的 `Arb` 类为 `Household` 对象生成一个随机姓氏。测试用例使用最小长度为三个的随机字符串作为姓氏。
- en: Again, the test case does not compile. The `Success` class does not exist, and
    the `createHousehold` function does not return such a type.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，测试用例无法编译。`Success` 类不存在，`createHousehold` 函数也没有返回这种类型。
- en: Step 3 again – make all tests pass
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 3 步再次 - 使所有测试通过
- en: 'Aiming to have two test cases pass is going to drive the code’s development.
    This is quite literally development driven by tests. We can use the IDE feature
    to generate the `Success` class. It is also easy enough to write one ourselves:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 旨在让两个测试用例通过将推动代码的开发。这可以说是由测试驱动的开发。我们可以使用 IDE 功能来生成 `Success` 类。自己编写一个也是足够简单的：
- en: '[PRE16]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The compilation error is resolved. We need to run *all* the tests during the
    TDD cycle. This is to ensure that we do not break existing tests. Test results
    show that the first test still passes, but the second test fails with the following
    message:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 编译错误已解决。在 TDD 循环中，我们需要运行 *所有* 测试。这是为了确保我们没有破坏现有的测试。测试结果显示第一个测试仍然通过，但第二个测试失败，并显示以下信息：
- en: '[PRE17]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We need the `createHousehold` function to return a `Success` object for successful
    creation or a `Failure` object for failure. The simplest approach is the use of
    Kotlin’s `sealed` class. Engineers may use other constructs, such as the following:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要 `createHousehold` 函数返回一个 `Success` 对象以表示成功创建，或者返回一个 `Failure` 对象以表示失败。最简单的方法是使用
    Kotlin 的 `sealed` 类。工程师们可能会使用其他结构，例如以下内容：
- en: '`Result4k<Household, String>` from the `String`'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Result4k<Household, String>` 来自 `String`'
- en: '`Either<String, Household>` from the `String`, and the right parameter is the
    type for the success response'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Either<String, Household>` 来自 `String`，右边的参数是成功响应的类型'
- en: 'The `sealed` class approach would look like this:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`sealed` 类的方法看起来是这样的：'
- en: '[PRE18]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `createHousehold` function needs to evolve to handle both test cases. Doing
    so would require removing the previous hack implementation and implementing actual
    validation logic. The `Household` class is changed to a `data` class so the function
    can access the surname to perform the validation:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`createHousehold` 函数需要进化以处理这两个测试用例。这样做将需要移除之前的黑客实现并实现实际的验证逻辑。`Household` 类被改为
    `data` 类，以便函数可以访问姓氏以执行验证：'
- en: '[PRE19]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The function has changed the return type to `Result`. A simple validation is
    also added to ensure that only non-blank surnames are accepted:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 函数已将返回类型更改为 `Result`。还添加了一个简单的验证，以确保只接受非空姓氏：
- en: '[PRE20]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now all tests have passed. However, the use of the `IsNotBlank` function might
    get you thinking that non-empty strings filled with spaces or tabs should have
    resulted in failure, but these cases are not tested.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有测试都通过了。然而，使用 `IsNotBlank` 函数可能会让你想到，应该导致失败的空字符串或只包含空格或制表符的字符串，但这些情况并未进行测试。
- en: Step 4 – refactor code
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第4步 - 代码重构
- en: 'We want to enhance the first test case by parameterizing several blank strings,
    as well as mixing whitespaces, tabs, and new-line characters. The `DescribeSpec`
    in Kotest supports this type of parameterization better, so the test class is
    changed to inherit from `DescribeSpec`. This change also affects test case number
    two, and all test names are updated accordingly:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望通过参数化几个空字符串以及混合空格、制表符和换行符来增强第一个测试用例。Kotest 中的 `DescribeSpec` 更好地支持这种参数化，因此测试类被修改为继承自
    `DescribeSpec`。这个更改也影响了第二个测试用例，并且所有测试名称都相应地进行了更新：
- en: '[PRE21]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now we have a parameterized setting for the first test, covering multiple combinations
    of blank strings. We are now satisfied enough to repeat the process.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们为第一个测试设置了一个参数化配置，覆盖了多个空字符串组合。我们现在对重复这个过程感到足够满意。
- en: Additional steps
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 额外步骤
- en: If this exercise goes further and picks up the next test scenario, “fail to
    create a household if the surname already exists,” then it involves keeping a
    created household record somewhere to provide a stateful validation if a household
    already exists. To drive a persistent implementation, such as saving the household
    record, we need to add test scenarios such as “retrieve a household record created
    by another household service instance.” In a way, it encourages us to write better
    and more test scenarios as well.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个练习进一步扩展并选择了下一个测试场景，“如果姓氏已存在，则无法创建家庭”，那么它涉及到在某个地方保留已创建的家庭记录以提供状态验证，如果家庭已存在。为了驱动持久化实现，例如保存家庭记录，我们需要添加测试场景，如“检索由另一个家庭服务实例创建的家庭记录”。从某种意义上说，这鼓励我们编写更好和更多的测试场景。
- en: Moreover, as we suggest making all tests pass with the simplest possible implementation,
    we end up with the simplest but complete implementation, which fulfills both the
    **Keep it simple, stupid!** (**KISS**) and **You aren’t gonna need it** (**YAGNI**)
    principles, as discussed in [*Chapter 2*](B21737_02.xhtml#_idTextAnchor045).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，正如我们建议的，通过使用最简单的实现来使所有测试通过，我们最终得到了最简单但完整的实现，它满足了**简单至上，傻瓜也能理解**（**KISS**）和**你不会需要它**（**YAGNI**）的原则，正如在[*第2章*](B21737_02.xhtml#_idTextAnchor045)中讨论的那样。
- en: The KISS principle
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 简单至上，傻瓜也能理解（**KISS**）原则
- en: The KISS principle is a design philosophy emphasizing simplicity in both design
    and implementation. It was first seen in the American newspaper *Minnesota Star
    Tribune* in 1938\. The KISS acronym was coined by lead military engineer Kelly
    Johnson. The KISS principle advocates that systems should be as straightforward
    as possible, avoiding unnecessary complexity. Simplicity enhances maintainability,
    reduces the likelihood of errors, and improves user experience.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 简单至上，傻瓜也能理解（**KISS**）原则是一种强调设计和实现中简单性的设计哲学。它首次出现在1938年的美国报纸《明尼苏达星报》上。KISS的首字母缩略词是由首席军事工程师凯利·约翰逊提出的。KISS原则主张系统应尽可能简单，避免不必要的复杂性。简单性提高了可维护性，减少了错误的可能性，并改善了用户体验。
- en: TDD is meant to be practiced as a short and iterative process, as illustrated
    by the TDD exercise steps explained earlier. Together with the simplest possible
    implementation during the process, TDD can produce simple implementations that
    are naturally 100% covered by tests.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: TDD旨在作为一种短周期和迭代的实践，如前面解释的TDD练习步骤所示。结合过程中最简单的实现，TDD可以产生简单且自然地被测试覆盖100%的实现。
- en: TDD is particularly useful if QAs and engineers are learning features as they
    go because TDD encourages learning and improving both test cases and implementation
    via short iterations.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果QA和工程师在学习过程中学习功能，TDD特别有用，因为TDD鼓励通过短周期迭代学习和改进测试用例和实现。
- en: However, for well-established systems, a strict TDD approach may not be as effective.
    The APIs may already be there and there could be only one line of code that’s
    updated for the behavior change. It may just be simpler to update existing tests
    to assert the new behavior and make them fail than to update the implementation
    to make all tests pass. There may not be a need to start from nothing.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于已经建立良好的系统，严格的TDD方法可能并不那么有效。API可能已经存在，并且可能只有一行代码需要更新以适应行为变化。可能直接更新现有测试以断言新行为并使它们失败，比更新实现以使所有测试通过要简单得多。可能没有必要从头开始。
- en: Coming next, we are going to discuss a sibling of TDD – BDD.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论TDD的兄弟——BDD。
- en: BDD
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BDD
- en: BDD evolved from TDD with the goal of addressing some of the limitations of
    TDD, such as test case classes filled with technical syntax that non-technical
    stakeholders would find difficult to read.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: BDD是从TDD演变而来的，旨在解决TDD的一些局限性，例如测试用例类中充满了非技术利益相关者难以阅读的技术语法。
- en: The concept of BDD was introduced by Dan North in 2003 during the discussions
    on improvement collaboration between technical and non-technical team members.
    This is also the year when he started the development of the **JBehave** framework
    as a replacement for the **JUnit** framework, emphasizing behaviors rather than
    tests.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: BDD的概念是由Dan North在2003年提出的，当时是在讨论技术团队和非技术团队成员之间的改进协作。这也是他开始开发**JBehave**框架作为**JUnit**框架替代品的年份，强调行为而不是测试。
- en: The **Gherkin** language was created in the year after that, as a domain-specific
    language that is close to the natural English language. The language aims to bring
    non-technical stakeholders closer to technical team members.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '**Gherkin**语言是在那一年创建的，作为一种接近自然英语的领域特定语言。该语言旨在使非技术利益相关者更接近技术团队成员。'
- en: 'The test scenario we have worked on during the TDD exercise can be expressed
    in the Gherkin language as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在TDD练习中工作的测试场景可以用以下Gherkin语言表达：
- en: '[PRE22]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Gherkin uses a simple structured syntax to define test scenarios. The primary
    keywords include the following:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Gherkin使用简单的结构化语法来定义测试场景。主要关键字包括以下内容：
- en: '**Feature**: A feature of the application'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能**：应用程序的功能'
- en: '**Scenario**: A specific situation or example'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**场景**：特定的情境或示例'
- en: '**Given**: Conditions before the test starts'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**给定**：测试开始前的条件'
- en: '**When**: Action or event that triggers behavior'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当**：触发行为的动作或事件'
- en: '**Then**: Expected outcome'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**然后**：预期的结果'
- en: '**And/But**: Add additional steps, conditions, or expected outcome'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**和/但**：添加额外的步骤、条件或预期结果'
- en: A test scenario written in the Gherkin language needs to be translated into
    programming languages to be executed. **Cucumber** ([https://github.com/cucumber](https://github.com/cucumber))
    is the first major tool for BDD, and it was developed around 2005\. It can translate
    test scenarios in Gherkin language to test scripts into multiple programming languages,
    such as Ruby, Rust, Java, Go, JavaScript, and Kotlin.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 用Gherkin语言编写的测试场景需要被翻译成编程语言才能执行。**Cucumber** ([https://github.com/cucumber](https://github.com/cucumber))是BDD的第一个主要工具，它大约在2005年开发。它可以将Gherkin语言中的测试场景翻译成多种编程语言的测试脚本，例如Ruby、Rust、Java、Go、JavaScript和Kotlin。
- en: Specification by Example (SBE)
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 规范化示例（SBE）
- en: BDD has a close relationship with **Specification by Example** (**SBE**). The
    term SBE was made popular by *Gojko Adzic* in his book *Specification by Example*,
    which was published in 2011.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: BDD与**规范化示例**（**SBE**）有密切的关系。SBE这个术语是由*Gojko Adzic*在他的书*规范化示例*中推广的，这本书于2011年出版。
- en: 'SBE advocates using concrete examples in real-world scenarios to clarify specifications
    and to communicate with non-technical stakeholders. This has influenced the conventional
    format of user stories as follows: *“As a [user], I want to [feature], so that
    [business values]”*. This ensures clear and testable specifications based on real
    examples.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: SBE倡导在现实场景中使用具体示例来阐明规范，并与非技术利益相关者进行沟通。这影响了用户故事的常规格式如下：*“作为一个[用户]，我想[功能]，以便[业务价值]”*。这确保了基于真实示例的清晰和可测试的规范。
- en: A user story is further expanded to have acceptance criteria to determine whether
    the feature is completed to the user’s satisfaction. These acceptance criteria
    are reflected in the test scenarios, possibly in the Gherkin language as a BDD
    practice.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 用户故事进一步扩展，以包含验收标准，以确定功能是否满足用户的满意度。这些验收标准反映在测试场景中，可能是作为BDD实践在Gherkin语言中。
- en: Adopting SBE and BDD has several implications. The test scenarios are written
    in Gherkin language and the vocabulary used should align with Ubiquitous Language,
    as discussed in [*Chapter 8*](B21737_08.xhtml#_idTextAnchor289). Secondly, human-readable
    test scenarios strongly suggest blackbox testing as the major approach.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 采用SBE和BDD有几个影响。测试场景是用Gherkin语言编写的，所使用的词汇应与通用语言一致，正如在[*第8章*](B21737_08.xhtml#_idTextAnchor289)中讨论的那样。其次，可读性强的测试场景强烈暗示黑盒测试是主要方法。
- en: Finally, many teams using Agile methodologies would even use SBE and BDD to
    improve their requirement gathering and testing processes. In a way, the concrete
    examples from SBE and test scenarios from BDD become the de facto agreement with
    non-technical stakeholders on the understanding of the feature.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，许多使用敏捷方法的团队甚至使用SBE和BDD来改进他们的需求收集和测试流程。从某种意义上说，SBE的具体示例和BDD的测试场景成为非技术利益相关者对功能理解的事实上的协议。
- en: BDD adoption in Kotlin
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kotlin中的BDD采用
- en: BDD is still actively adopted by many teams nowadays. Many Kotlin engineers
    are still using Cucumber as their BDD tool. However, there are reasons why some
    teams make a conscious decision not to use the Gherkin language to define test
    scenarios.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: BDD至今仍被许多团队积极采用。许多Kotlin工程师仍在使用Cucumber作为他们的BDD工具。然而，有些团队有意识地决定不使用Gherkin语言来定义测试场景。
- en: The Kotlin language is concise and less verbose than its predecessor, Java.
    Kotlin provides a lot of innate syntactic support and syntactic sugar to simplify
    the code for better readability.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin语言比其前身Java更加简洁和简洁。Kotlin提供了大量的语法支持和语法糖，以简化代码，提高可读性。
- en: With modern testing frameworks such as Kotest, Spek ([https://www.spekframework.org](https://www.spekframework.org)),
    and Kluent ([https://github.com/MarkusAmshove/Kluent](https://github.com/MarkusAmshove/Kluent)),
    it is possible to have readable Kotlin-based test scripts that mimic the Gherkin
    format for test scenarios to a good extent.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 使用现代测试框架，如Kotest、Spek ([https://www.spekframework.org](https://www.spekframework.org))
    和 Kluent ([https://github.com/MarkusAmshove/Kluent](https://github.com/MarkusAmshove/Kluent))，可以编写出可读性强的基于Kotlin的测试脚本，这些脚本在很大程度模仿了Gherkin格式的测试场景。
- en: It diminishes the need to introduce a translation layer, which can sometimes
    introduce bugs during testing. It is also a balanced act between the benefits
    of reading test scenarios and the cost of translating Gherkin test scripts to
    Kotlin.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 它减少了引入翻译层的需要，这有时会在测试期间引入错误。它也是阅读测试场景的好处和将Gherkin测试脚本转换为Kotlin的成本之间的平衡。
- en: However, having BDD and SBE in mind in the agile development process is always
    beneficial, as it elicits meaningful conversations with non-technical stakeholders
    in the endeavor of understanding user requirements.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在敏捷开发过程中始终考虑BDD和SBE是有益的，因为它在理解用户需求的过程中与非技术利益相关者进行有意义的对话。
- en: There are a few types of testing that are conducted in production environments.
    There are justifications for why they need to run in customer-facing environments,
    and we are going to explore the reasons behind them.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中进行了一些类型的测试。他们需要在面向客户的环境中运行的理由，我们将探讨这些理由背后的原因。
- en: Live testing, A/B testing, and segmentation
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现场测试、A/B测试和细分
- en: Live tests are no replacement for other types of tests conducted in lower environments.
    Each type of live testing serves a unique purpose in that it can only be executed
    in a live environment.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现场测试不能替代在较低环境中进行的其他类型的测试。每种现场测试都有其独特的作用，因为它只能在现场环境中执行。
- en: Post-release testing
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布后测试
- en: Some systems integrate with external systems that do not provide a lower environment
    for testing. Engineers would normally mitigate this risk by having a simulator
    running in lower environments. The simulator is a fake component that runs simplified
    logic just to act like the target external system. Engineers rely on documentation
    or information from the third-party company to implement the simulator.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 一些系统与不提供测试环境的第三方系统集成。工程师通常会通过在较低环境中运行模拟器来减轻这种风险。模拟器是一个假组件，它运行简化的逻辑，仅为了模仿目标外部系统。工程师依赖于文档或第三方公司的信息来实现模拟器。
- en: 'This approach is not ideal, but it is better than having nothing to detect
    defects in lower environments. Several risks come with this approach:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法并不理想，但比在较低环境中没有东西来检测缺陷要好。这种方法伴随着一些风险：
- en: The simulator logic needs to closely follow the steps of external system changes.
    Otherwise, it creates a time gap of discrepancies.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟器逻辑需要紧密遵循外部系统更改的步骤。否则，它会产生不一致的时间差距。
- en: The external system may release its changes without informing the team, resulting
    in malfunctioning of the system and requiring hotfixes.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部系统可能在不通知团队的情况下发布其更改，导致系统故障并需要热修复。
- en: Engineers must ensure that the simulator never runs in production environments
    to create false data. Data damage and remediation come at a huge cost.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工程师必须确保模拟器永远不会在生产环境中运行以创建虚假数据。数据损坏和修复的成本非常高。
- en: Having all safety measures in place, the external system may simply be unavailable
    after release. Thus, the system is only partially operational.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管采取了所有安全措施，外部系统在发布后可能仍然不可用。因此，系统只能部分运行。
- en: Regardless of whether there is a test environment for external system integration,
    some mission-critical systems, such as financial trading systems, would perform
    a “test trade” with a minimal amount to ensure that the crucial features are operational
    and the corresponding data is correct.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是否存在外部系统集成测试环境，一些关键任务系统，如金融交易系统，都会进行“测试交易”，以最小金额确保关键功能正常运作且对应数据正确。
- en: A/B testing and segmentation
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A/B测试和细分
- en: Some tests are run in production for a longer period for reasons other than
    QA. A/B testing and segmentation are executed to discover needs and opportunities
    in the market.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 一些测试由于QA以外的其他原因在生产环境中运行了更长的时间。A/B测试和细分执行是为了发现市场和机会。
- en: 'Some organizations would segment their users into at least two groups. The
    segmentation can be done in the following ways:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 一些组织会将用户至少分成两组。细分可以通过以下方式进行：
- en: A stateless algorithm
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无状态算法
- en: User data, such as demographics or preferences
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户数据，例如人口统计信息或偏好
- en: Signed up voluntarily by users
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户自愿注册
- en: Random and sticky assignments
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机和粘性分配
- en: Manually assigned to small groups
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动分配到小群体
- en: 'Each group has a different user experience, and metrics are in place to measure
    business metrics such as page landing counts, purchase statistics, and customer
    satisfaction. This is a typical segmentation setup:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组都有不同的用户体验，并设置了指标来衡量业务指标，如页面着陆次数、购买统计和客户满意度。这是一个典型的细分设置：
- en: '**Control group**: The original experience; the baseline for comparisons'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对照组**：原始体验；比较的基线'
- en: '**Variant groups**: The modified experiences'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变体组**：修改后的体验'
- en: By conducting A/B testing, the organization can gather useful information about
    users and the market. The data collected provides a quantitative perspective on
    which user experiences lead to a better outcome. This provides insights on real-user
    behaviors using empirical evidence, and it fosters a culture of hypothesis testing
    and data-driven decision-making.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 通过进行A/B测试，组织可以收集有关用户和市场的有用信息。收集的数据提供了对哪些用户体验导致更好结果的定量视角。这通过经验证据提供了对真实用户行为的洞察，并促进了假设检验和数据驱动决策的文化。
- en: Some A/B tests could run only for a limited time just to collect enough data
    for analysis, while some could run for a very long time for continuous improvements.
    Some organizations would even run multiple A/B tests at the same time, but this
    comes at the cost of exponential complexity when performing statistical analysis.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 一些A/B测试可能只能运行有限的时间，只是为了收集足够的数据进行分析，而另一些则可能运行很长时间以进行持续改进。一些组织甚至会同时运行多个A/B测试，但这在执行统计分析时会导致指数级复杂性的增加。
- en: Summary
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed the role and involvement of QA in the software
    development cycle. We covered the testing pyramid in depth, explored each layer
    with code examples, and mentioned some of the techniques used in test scripts
    such as blackbox and whitebox testing, mocking, and parameterized testing.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了质量保证（QA）在软件开发周期中的作用和参与。我们深入探讨了测试金字塔，通过代码示例探讨了每一层，并提到了测试脚本中使用的某些技术，例如黑盒和白盒测试、模拟和参数化测试。
- en: We explored the concepts of TDD. We ran through an exercise of TDD with small
    and frequent iterations, using real-life examples.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了测试驱动开发（TDD）的概念。我们通过使用真实生活例子，进行小而频繁迭代的TDD练习。
- en: We discussed BDD, a close relative of TDD. We elaborated on its history and
    how it evolved from TDD. We also introduced SBE, which works closely with BDD
    practices. Finally, we briefly discussed the modern adoption of BDD in Kotlin.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了行为驱动开发（BDD），它是TDD的近亲。我们详细介绍了它的历史以及它是如何从TDD演变而来的。我们还介绍了SBE，它与BDD实践紧密合作。最后，我们简要讨论了Kotlin中BDD的现代采用情况。
- en: We also briefly introduced some types and examples of testing that are executed
    in live environments and the reasons behind them.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还简要介绍了在实时环境中执行的一些测试类型和示例及其背后的原因。
- en: The next chapter will cover an important aspect of software systems – security.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将涵盖软件系统的一个重要方面——安全性。
