- en: Adding Animation to Your Game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为你的游戏添加动画
- en: 'We have learned how to create sprites on screen as well as made our background
    image scroll continuously. Sprites are basically just images, which are used for
    game assets. Now, it is time to add a bit more spice to it and make it interesting.
    In this chapter, we will make our player character appear on screen on top of
    our background and add an animation that will make the player run. In this chapter,
    you will learn the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何在屏幕上创建精灵以及使我们的背景图像连续滚动。精灵基本上只是图像，用于游戏资源。现在，是时候给它添加一些更多的风味，使其变得有趣。在本章中，我们将使我们的玩家角色出现在屏幕上，位于我们的背景之上，并添加一个使玩家跑步的动画。在本章中，你将学习以下内容：
- en: Creating sprite animations based on sprite sheets
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于精灵图集创建精灵动画
- en: Running basic animations
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行基本动画
- en: Creating an abstract class to serve as a foundation for our future game objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个抽象类作为我们未来游戏对象的基础
- en: By the end of this chapter, you will have a running character on screen. So
    let's begin!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将在屏幕上看到一个正在运行的字符。那么，让我们开始吧！
- en: Adding animations to make your game more awesome
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加动画让你的游戏更加精彩
- en: 'To start this chapter, we will need a collection of images, which we call sprites.
    We saw in the previous chapter how we had used  `image_1` and `image_2` as examples,
    but we will expand on them and make this more interesting. We will try and make
    a proper run cycle of our player character in a sprite sheet. To understand this
    in a better way, let''s take a look at the following image:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始本章，我们需要一组图像，我们称之为精灵。我们在上一章中看到了如何使用 `image_1` 和 `image_2` 作为例子，但我们将在此基础上进行扩展，使其更有趣。我们将尝试在精灵图集中制作我们玩家角色的正确运行周期。为了更好地理解这一点，让我们看看以下图像：
- en: '![](img/B05066_05_01.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B05066_05_01.png)'
- en: Our run cycle animation sprites
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的运行周期动画精灵
- en: 'In the preceding image, you can observe we have a set of images that are prefixed
    with the text `Run` followed by a set of numbers that represent frames. So, basically,
    we will loop from frame `Run_000` to `Run_009`, which will give us a continuous
    running effect. However, for the sake of simplicity, we will be merging these
    frames into one single image and read pixel data from it. Also, to keep it simple,
    we will only make the run cycle animation to three frames. If you want, you can
    add more frames for better animation quality. So, we will be using the following
    sprite sheet:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图像中，你可以观察到我们有一组以文本 `Run` 开头，后面跟着一组代表帧数的数字的图像。所以，基本上，我们将从帧 `Run_000` 循环到
    `Run_009`，这将给我们一个连续的运行效果。然而，为了简化，我们将把这些帧合并成一张单独的图像，并从中读取像素数据。此外，为了保持简单，我们只会制作三个帧的运行周期动画。如果你想的话，你可以添加更多帧以获得更好的动画质量。因此，我们将使用以下精灵图集：
- en: '![](img/B05066_05_02.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B05066_05_02.jpg)'
- en: This is what an actual sprite sheet looks like; we will name this sprite sheet
    as player_run.png
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是实际的精灵图集的样子；我们将把这个精灵图集命名为 player_run.png
- en: We will be dealing with pixels to run our animation, so it is extremely important
    for us to know the dimensions of this image. In simple terms, we need to know
    the width and height of this image in pixels. The dimensions of one frame of our
    image are 200 x 82 pixels, where 200 represents the width and 82 represents the
    height of our image. In our sprite sheet, we have three such sprites. Thus, we
    simply multiply our width by the number of images in our sprite sheet, which is
    three in this case. So, the overall width of our image is 600 pixels. As you can
    see, we are using an image that has a landscape orientation, which means that
    our image's width is more than the height, so our height dimension remains the
    same. So, basically to run our animation, we only need to scan through our frames
    horizontally. The final resolution of our sprite sheet is 200 x 82.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将处理像素以运行我们的动画，因此了解这张图像的尺寸对我们来说至关重要。简单来说，我们需要知道这张图像的宽度和高度（以像素为单位）。我们图像的一帧的尺寸是
    200 x 82 像素，其中 200 代表图像的宽度，82 代表图像的高度。在我们的精灵图集中有三个这样的精灵。因此，我们只需将宽度乘以我们的精灵图集中的图像数量，在这个例子中是三个。所以，我们图像的总宽度是
    600 像素。正如你所见，我们使用的是具有风景方向的图像，这意味着我们的图像宽度大于高度，所以我们的高度维度保持不变。所以，基本上，为了运行我们的动画，我们只需要水平扫描我们的帧。我们的精灵图集最终分辨率是
    200 x 82。
- en: The resolution of your image might differ from the ones in this book, so make
    sure that you calculate the numbers properly before proceeding with writing them
    in the code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你的图像分辨率可能与本书中的不同，所以在继续编写代码之前，请确保正确地计算出这些数字。
- en: 'So, let''s dive into the art of animating our player character; however, before
    we do that, we also need to create our player character on screen. Here''s our
    task list for now:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们深入到动画我们的玩家角色的艺术中；然而，在我们这样做之前，我们还需要在屏幕上创建我们的玩家角色。以下是我们的当前任务列表：
- en: Create a player on screen.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕上创建一个玩家。
- en: Make Run animation play.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让运行动画播放。
- en: Once we are done with these two objectives, we will take touch input in order
    to make our player jump.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这两个目标后，我们将获取触摸输入以便让我们的玩家跳跃。
- en: Making our player character
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的玩家角色
- en: We saw in the previous chapter how to create our background image. In theory,
    it is almost similar to the previous chapter to create our player character, but
    since we are going to deal with animations in the further part of this chapter,
    we will need to modify our code a bit. Let's get started with that first.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何创建我们的背景图像。理论上，创建我们的玩家角色与上一章几乎相同，但由于我们将在本章的后续部分处理动画，我们需要对我们的代码进行一些修改。让我们首先开始做这件事。
- en: Now, as a programmer, you have to keep in mind that there are many ways to do
    one particular thing; therefore, just as a demonstration to get a clearer understanding,
    we will modify our background image code a little. Open up your `BackgroundImage.java`
    file and remove the `setVector` method. Now, you will see that there will be an
    error in our `GameView.java` file since our `setVector` method does not exist;
    let's fix that. Make a static final variable, which will be accessible from any
    class. We will then set it as a speed variable. Then, in our `BackgroundImage.java`
    file's constructor, we will set the displacement variable as the speed for this.
    Here's how we will modify our code blocks. Code changes are marked in bold.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，作为一个程序员，你必须记住，做一件特定的事情有无数种方法；因此，为了更清晰地展示，我们将稍微修改我们的背景图像代码。打开你的`BackgroundImage.java`文件，并删除`setVector`方法。现在，你将看到我们的`GameView.java`文件中会有一个错误，因为我们的`setVector`方法不存在；让我们修复它。创建一个静态最终变量，它可以从任何类中访问。然后，我们将将其设置为速度变量。然后，在我们的`BackgroundImage.java`文件的构造函数中，我们将设置位移变量为这个速度。以下是我们将如何修改我们的代码块。代码更改用粗体标出。
- en: 'The following is the code for `BackgroundImage.java`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为`BackgroundImage.java`编写的代码：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, let''s take a look at the code for `GameView.java`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看`GameView.java`的代码：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, we haven't done anything really here. We have just modified a logic with
    different variables. In a similar fashion, you can also apply your own logic to
    come up with different ways to do one particular thing. Let's now move on to actually
    make our player character appear on the screen.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在这里实际上并没有做任何事情。我们只是用不同的变量修改了一个逻辑。以类似的方式，你也可以应用你自己的逻辑来想出不同的方法来做一件特定的事情。现在，让我们真正地让我们的玩家角色出现在屏幕上。
- en: Try tweaking the code with your own logic and keeping the output same as a challenge
    to test your skills.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用你自己的逻辑调整代码，并保持输出与挑战相同，以测试你的技能。
- en: 'We will now create an abstract class for our future game objects, such as our
    player character, missiles, and everything else. We are doing this because there
    are some sets of data, which are required in almost every object we will be creating
    in future for our game. So, for the purpose of reusability and persistence, we
    will create this class. We will call it `GameObj.java`. Go ahead and create your
    new class with the steps that we learned from our previous chapters and write
    the following code in it:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将为我们的未来游戏对象创建一个抽象类，例如我们的玩家角色、导弹以及其他所有东西。我们这样做是因为有一些数据集，几乎是我们将在未来为我们的游戏创建的每个对象中都需要。因此，为了重用和持久性，我们将创建这个类。我们将称之为`GameObj.java`。按照我们之前章节中学到的步骤创建你的新类，并在其中编写以下代码：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: So, here we have our abstract `GameObj.java` class file, which has the variables
    and get set methods for them. Observe here that we have also used a `getRectangle()`
    method. This method will be used in the next chapter when we will be working with
    collisions. In theory, to detect collisions on any object, we need to get its
    rectangular bounds. Anyway, moving ahead, let's now create our `Player` class
    with the help of this new abstract class we made.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在有了我们的抽象类`GameObj.java`文件，其中包含了它们的变量和获取设置方法。注意这里我们还有一个`getRectangle()`方法。这个方法将在下一章中使用，当我们处理碰撞时。理论上，为了检测任何对象的碰撞，我们需要获取它的矩形边界。无论如何，让我们继续前进，现在让我们利用这个新创建的抽象类来创建我们的`Player`类。
- en: 'Create a new class and name it `PlayerCharacter.java`, and write the following
    code in it:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的类，并将其命名为`PlayerCharacter.java`，然后在其中编写以下代码：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s now understand what we have done in our `PlayerCharacter` code in further
    detail:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在更详细地了解我们在 `PlayerCharacter` 代码中做了些什么：
- en: We created our class and extended it to our abstract class, `GameObj`, to get
    access to all the default variables needed for our `PlayerCharacter`
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个类，并将其扩展到我们的抽象类 `GameObj`，以获取我们 `PlayerCharacter` 所需的所有默认变量
- en: We created the default constructor for our `PlayerCharacter` in which we pass
    the required data to draw `PlayerCharacter` on screen just like the image component
    is passed in the `res` variable along with the width and height of our image with
    the number of frames we need in our animation
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为我们的 `PlayerCharacter` 创建了默认构造函数，其中我们传递了所需的数据来在屏幕上绘制 `PlayerCharacter`，就像图像组件一样，通过
    `res` 变量传递，以及我们的图像的宽度和高度，以及我们动画中需要的帧数
- en: In our constructor, we created a `for` loop, which will run through our sprite
    sheet and give us the animation effect followed by a 10-millisecond delay to play
    our animations
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的构造函数中，我们创建了一个 `for` 循环，它会遍历我们的精灵图，并给我们动画效果，之后会有一个 10 毫秒的延迟来播放我们的动画
- en: We then created our `setUp()` function, which will take care of the jumping
    functionality of our player
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们创建了我们的 `setUp()` 函数，该函数将处理玩家的跳跃功能
- en: In our `update()` function, we created a loop of events that assign a `score`
    to the player as well as keep the player between upper and lower bounds
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的 `update()` 函数中，我们创建了一个事件循环，它将分数分配给玩家，并保持玩家在上限和下限之间
- en: After this, we created the `draw()` method, which gets the animation from our
    `ac` variable and drew it onto our canvas
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此后，我们创建了 `draw()` 方法，该方法从我们的 `ac` 变量获取动画，并将其绘制到我们的画布上
- en: This is then followed by simple get and set methods for rest of the variables
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后是其他变量的简单获取和设置方法
- en: 'Our player character is ready; however, we still have to write our `AnimationClass`.
    As you can clearly observe, you must be getting an error on the `AnimationClass`
    line. So, let''s go ahead and create our `AnimationClass.java` file and write
    the following code in it:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的角色玩家已经准备好了；然而，我们仍然需要编写我们的 `AnimationClass`。正如你可以清楚地观察到的，你必须在 `AnimationClass`
    行上得到一个错误。所以，让我们继续创建我们的 `AnimationClass.java` 文件，并在其中写入以下代码：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This `AnimationClass.java` file is important to run our character''s animations.
    Our `AnimationClass` has three main functions, namely `setFrames()`, `update()`,
    and `getImage()`. Let''s take a look at what we have done in this class:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `AnimationClass.java` 文件对于运行我们角色的动画非常重要。我们的 `AnimationClass` 有三个主要功能，即 `setFrames()`、`update()`
    和 `getImage()`。让我们看看在这个类中我们做了些什么：
- en: We created variables that are needed to access our frames
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了访问我们帧所需的变量
- en: We created variables that will control the start time and delay between animation
    frames
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了控制动画帧开始时间和延迟的变量
- en: We created a Boolean, which will trigger the animation
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个布尔值，用于触发动画
- en: Next, we created a `setFrames()` function, to set frames and set the current
    frame to `0` at start
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们创建了一个 `setFrames()` 函数，用于设置帧并将当前帧在开始时设置为 `0`
- en: After that, a `setDelay()` function, was created in order to tell the animation
    to run at short intervals
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，我们创建了一个 `setDelay()` 函数，以便告诉动画在短间隔内运行
- en: We then created a `setFrame()` function to set the current frame in the running
    animation
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们随后创建了一个 `setFrame()` 函数来设置正在运行的动画中的当前帧
- en: In our `update()` function, we started calculating the delay in terms of milliseconds
    using some simple math calculations, and upon certain intervals, switched the
    frame of the image
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的 `update()` 函数中，我们开始使用一些简单的数学计算来计算延迟（以毫秒为单位），并在某些间隔内切换图像的帧
- en: We added a condition that if our last frame has elapsed then we will reset our
    current frame to 0 in order to give a continuous looping effect
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了一个条件，如果我们的最后一帧已经过去，那么我们将当前帧重置为 0，以给出连续循环的效果
- en: In our `getImage()` function, we simply return the value of the image that is
    currently being drawn on the screen
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的 `getImage()` 函数中，我们简单地返回当前正在屏幕上绘制的图像的值
- en: The `getFrame()` function returns us the integer value of the current frame
    that is being displayed
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getFrame()` 函数返回当前正在显示的帧的整数值'
- en: With the last function, `playedOnce()`, as a placeholder for our further gameplay
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用最后一个函数 `playedOnce()` 作为我们未来游戏玩法的一个占位符
- en: '`setFrames()` and `setFrame()` are two different functions. `setFrames()` is
    used to initialize our frames from 0, whereas `setFrame()` is used to set frames
    individually while running.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`setFrames()` 和 `setFrame()` 是两个不同的函数。`setFrames()` 用于从 0 初始化我们的帧，而 `setFrame()`
    用于在运行时单独设置帧。'
- en: 'Now, before moving on to the next part, ensure that you have your image in
    your drawable folder that you want to use for our player character. Once you have
    it, it''s now time to move on to the next step and instantiate our player on screen.
    The procedure for this is the same as we did with our background image. Modify
    your `GameView.java` file code to look like this; changes from the preceding code
    have been highlighted in bold:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在继续下一部分之前，确保你已经在你的 drawable 文件夹中有你想要用于玩家角色的图像。一旦你有了它，现在就是继续下一步并实例化屏幕上的玩家的时候了。这个过程与我们的背景图像相同。将你的
    `GameView.java` 文件代码修改如下；与前一段代码相比，更改已被加粗显示：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s do a breakdown of what we did here:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下我们在这里做了什么：
- en: We created a reference variable for our `PlayerCharacter` using the variable
    `playerCharacter`.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用变量 `playerCharacter` 为我们的 `PlayerCharacter` 创建了一个引用变量。
- en: Then, in our `surfaceCreated()` method, we gave the `playerCharacter` class
    constructor all the values that it requires. We passed the `player_run` image
    into this code for it to fetch our player's sprite sheet. In the parameters for
    the constructor of `PlayerCharacter(BitmapFactory.decodeResource(getResources(),R.drawable.player_run),w/3,h,3);`,
    the 'w' corresponds to the width of the image and 'h' corresponds to the height
    of the image. The parameter 3 here will depend on the number of frames of your
    sprite. If you have six frames in your sprite, then the parameters would be `(w/6,h,6)`.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在我们的 `surfaceCreated()` 方法中，我们向 `playerCharacter` 类构造函数传递了它所需的所有值。我们将 `player_run`
    图像传递到这段代码中，以便它获取我们的玩家精灵表。在 `PlayerCharacter(BitmapFactory.decodeResource(getResources(),R.drawable.player_run),w/3,h,3);`
    构造函数的参数中，'w' 对应图像的宽度，'h' 对应图像的高度。这里的参数 3 将取决于你的精灵帧数。如果你有六个帧在你的精灵中，那么参数将是 `(w/6,h,6)`。
- en: After that, in our `update()` method, which is after `bgImg.update()`, we called
    the `playerCharacter.update()` method that gives a call to the update function
    of our `PlayerCharacter` and thereby plays the animation from the `AnimationClass.java`
    file.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，在我们的 `update()` 方法中，该方法位于 `bgImg.update()` 之后，我们调用了 `playerCharacter.update()`
    方法，该方法调用我们的 `PlayerCharacter` 的更新函数，从而从 `AnimationClass.java` 文件中播放动画。
- en: Lastly, we then drew our player character onto our canvas using the `playerCharacter.draw(canvas);`
    code.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用 `playerCharacter.draw(canvas);` 代码在画布上绘制了我们的玩家角色。
- en: 'After you are done with these steps, build and run your game on an emulator
    or your Android phone device; you will get the following output:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，在模拟器或你的 Android 手机设备上构建并运行你的游戏；你将得到以下输出：
- en: '![](img/B05066_05_03.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B05066_05_03.png)'
- en: Hurray! Our player character is running on the screen (literally)
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 哈哈！我们的玩家角色现在在屏幕上奔跑（字面意思）
- en: If you have done everything correctly, then you will have your player character
    running on the screen on the spot while your background is scrolling continuously;
    almost half of our game is done here.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一切操作正确，那么你的玩家角色将立即在屏幕上开始奔跑，而你的背景将持续滚动；几乎我们的一半游戏工作已经完成。
- en: Since we have created our `GameObj` class, we will be relying on it heavily
    for our further game objects, such as missiles, particle effects, and everything
    else.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们创建了 `GameObj` 类，我们将大量依赖它来创建我们的进一步游戏对象，例如导弹、粒子效果等。
- en: Congratulations! You just created your first animation!
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你刚刚创建了你第一个动画！
- en: Summary
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to effectively create animations from your
    sprite sheet as well as create an abstract class to create a foundation for your
    future game objects. In the next chapter, we will learn how to create our game
    even more interesting by controlling our animation based on touch inputs. We will
    learn about collision detection along with creating a missile AI that will spawn
    from the extreme right of the screen, and our objective will be to dodge the missile.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何有效地从你的精灵表中创建动画，以及创建一个抽象类来为你的未来游戏对象打下基础。在下一章中，我们将学习如何通过基于触摸输入来控制动画，使我们的游戏更加有趣。我们将学习碰撞检测，并创建一个从屏幕最右侧生成的导弹
    AI，我们的目标将是躲避导弹。
- en: We will learn about different collision techniques as well as create interactive
    objects, where we will also add a score on collecting them instead of just incrementing
    the score with time.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习不同的碰撞技术以及创建交互式对象，在收集它们时我们也会添加分数，而不仅仅是随着时间的推移增加分数。
