- en: Chapter 6. Working with Playgrounds
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章。使用 playground
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Creating the first playground
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建第一个 playground
- en: Watching some graphics
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观看一些图形
- en: Watching a temperature with color
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察颜色变化下的温度
- en: Stretching an image
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整图像大小
- en: Beautifying your text with Pangrams
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 pangrams 美化你的文本
- en: Receiving JSONs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收 JSON
- en: Creating our own class representations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们自己的类表示
- en: Rich documentation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 丰富的文档
- en: Navigating pages in playgrounds
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 playground 中导航页面
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: If you've ever programmed with an interpreted language such as Python, Perl,
    Ruby, or JavaScript, you probably have noticed an advantage with these languages
    over native languages such as C, Objective-C, or C++, which is the possibility
    of testing a code without the need of adding an extra code to your project.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用过 Python、Perl、Ruby 或 JavaScript 等解释型语言进行编程，你可能已经注意到这些语言与 C、Objective-C
    或 C++ 等本地语言相比的一个优势是，可以在不添加额外代码到项目的情况下测试代码。
- en: Sometimes a developer needs to test a code before adding it to the project,
    mainly when you are learning the way Swift works. But even if you are very experienced
    with Swift, there will be times when you will have new ideas and you probably
    will need to check whether this is a valid idea before coding it into your project.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候开发者需要在将代码添加到项目之前对其进行测试，尤其是在学习 Swift 的工作方式时。即使你对 Swift 非常熟悉，也可能会遇到新的想法，你可能在将它们编码到项目中之前需要检查这些想法是否有效。
- en: For situations like the previously mentioned, Apple has released playground,
    a place where you can play with your code, test it, visualize it, and of course,
    take a decision on the code before adding it to your application.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于之前提到的情况，苹果推出了 playground，这是一个你可以在这里玩转代码、测试代码、可视化代码，并在将其添加到应用程序之前对代码做出决定的地方。
- en: It's quite impressive that Swift is a compiled language, but you can use playground
    to test your code as you go, like if you were on an interpreted language, watching
    the results in real time.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 很令人印象深刻的是，Swift 是一种编译型语言，但你可以在 playground 中边编写边测试你的代码，就像在使用解释型语言一样，可以实时查看结果。
- en: Creating the first playground
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建第一个 playground
- en: In this recipe, you are going to get familiarized with the **Xcode playground**,
    here you are going to learn some basics of this Xcode feature, and after that
    you will be able to test your own code using this new friend.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，你将熟悉**Xcode playground**，在这里你将学习这个 Xcode 功能的一些基础知识，然后你将能够使用这个新朋友测试你自己的代码。
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'Open your Xcode, but this time, instead of creating a new project, now you
    have to choose **Get started with playground**:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的 Xcode，但这次，你不需要创建一个新的项目，而是选择**使用 playground 开始**：
- en: '![Getting ready](img/00050.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/00050.jpeg)'
- en: 'Once you have done it, you are going to see that the next dialog is a very
    simple one, which will ask only the project name and the platform (iOS, Mac OS,
    or tvOS). Call it `Chapter 6 First Playground` and select **iOS**:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你会看到下一个对话框非常简单，只会询问项目名称和平台（iOS、Mac OS 或 tvOS）。命名为 `Chapter 6 First Playground`
    并选择 **iOS**：
- en: '![Getting ready](img/00051.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/00051.jpeg)'
- en: Then you will see the famous dialog, which asks you where to store your app.
    Choose the folder that you want for it. If you have doubts, choose the documents
    folder.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你会看到著名的对话框，询问你将应用程序存储在哪里。选择你想要的文件夹。如果有疑问，请选择文档文件夹。
- en: Before we start with our playground, open the **Finder** window corresponding
    to the folder where you saved your project, right-click (or control click) on
    your playground project, and choose **Show package contents**.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用 playground 之前，打开保存项目的文件夹对应的**Finder**窗口，右键单击（或按住控制键单击）你的 playground
    项目，并选择**显示包内容**。
- en: 'Now you can see that there are three files there: `contents.xcplayground`,
    `results.playgrounddata`, and `section-1.swift`. Right now, you can imagine what
    these files do but I would like to emphasize that, as your playground grows, the
    number of files also increases. Remember that playground has its own bundle in
    which you can add pictures and other stuff.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以看到那里有三个文件：`contents.xcplayground`、`results.playgrounddata`和`section-1.swift`。现在你可以想象这些文件的作用，但我想要强调的是，随着
    playground 的增长，文件的数量也会增加。记住，playground 有自己的包，你可以在其中添加图片和其他内容。
- en: How to do it…
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to create the first playground:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建第一个 playground：
- en: Return to your Xcode, have a look at your playground. It started importing the
    UIKit and a string variable, which says **Hello, playground**. You can also see,
    on the right-hand side, the result of this variable.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到你的Xcode，看看你的游乐场。它开始导入UIKit和一个字符串变量，该变量显示**Hello, playground**。你还可以在右侧看到这个变量的结果。
- en: 'Let''s start defining another variable called `name`, before the `str` variable,
    and change the `str` variable to have an interpolation, something like the following
    code:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们开始定义另一个变量，称为`name`，在`str`变量之前，并将`str`变量更改为具有插值，就像以下代码：
- en: '[PRE0]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now you will see that on your right you have both variables processed:'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在你将看到在你的右侧你有处理过的两个变量：
- en: '![How to do it…](img/00052.jpeg)'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做……](img/00052.jpeg)'
- en: 'Once you''ve understood this, let''s complete this code with an `if` statement,
    so after the previous code, add an `if` statement like this one:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你理解了这一点，让我们用`if`语句来完成这个代码，所以在之前的代码之后，添加一个像这样的`if`语句：
- en: '[PRE1]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: After coding it, see to it that you have the result for one statement but not
    for the other one:![How to do it…](img/00053.jpeg)
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码后，确保你有一个语句的结果，但没有另一个语句的结果：![如何做……](img/00053.jpeg)
- en: 'It''s time to try a loop, let''s calculate, for example, the famous Fibonacci
    function:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候尝试一个循环了，让我们计算，例如，著名的斐波那契函数：
- en: '[PRE2]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now you can appreciate the result in a different way, instead of displaying
    the variable value, you can see the number of times that the instruction was executed.
    If you move your mouse pointer over the result of each instruction, you can see
    that two small icons will appear.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，你可以以不同的方式欣赏结果，而不是显示变量的值，你可以看到指令被执行的次数。如果你将鼠标指针移到每个指令的结果上，你会看到出现两个小图标。
- en: The first one, which is like an eye, is for watching the variable result representation,
    the other one is for the timeline, which shows the values assigned to the variable
    on each loop iteration. We will talk about this later in the recipes *Watching
    some graphics* and *Beautifying your text using Pangrams*:![How to do it…](img/00054.jpeg)
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个，就像一只眼睛，是用来观察变量结果表示的，另一个是用来时间线的，它显示了每次循环迭代中分配给变量的值。我们将在后面的食谱“观看一些图形”和“使用Pangrams美化你的文本”中讨论这一点：![如何做……](img/00054.jpeg)
- en: The reason why we wrote the variable `fib_n` alone at the end of our code is
    because that is the way you can visualize the final of a variable, in this case
    we can see that the result of our code is **55**.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在代码末尾单独写下变量`fib_n`的原因是因为这是你可以可视化变量最终值的方式，在这种情况下，我们可以看到代码的结果是**55**。
- en: 'Now we can compare this code with the equivalent one as a recursive function,
    then we can take a decision about which code is going to be used on our application:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以将这段代码与等效的递归函数进行比较，然后我们可以决定在应用程序中使用哪种代码：
- en: '[PRE3]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After coding it, you can check two important pieces of information; the first
    one is the result, which is the same as the previous code. The second one is the
    number of times the function was called, as you can see in this case we had 54
    times on the recursive function against 8 of the interactive function.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码后，你可以检查两个重要的信息点；第一个是结果，与之前的代码相同。第二个是函数被调用的次数，正如你所见，在这个例子中，递归函数调用了54次，而交互式函数调用了8次。
- en: How it works…
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: As you can see, every time you write a code it is recompiled and executed; the
    advantage is that it gives you information about your code, you can use it to
    compare different codes, and also check whether the idea you have in mind is the
    right one for your application.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每次你编写代码，它都会被重新编译和执行；优势是它给你关于代码的信息，你可以用它来比较不同的代码，还可以检查你心中的想法是否适合你的应用程序。
- en: There's more…
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: Now you have a basic idea about how to use the playground. The next thing we
    are going to learn is how to visualize the information and its progress in a graphical
    way.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对如何使用游乐场有了基本的了解。接下来我们要学习的是如何以图形方式可视化和跟踪信息及其进展。
- en: Watching some graphics
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观看一些图形
- en: Knowing that a loop iterates 8 times instead of 54 is fine. It gives you a good
    idea about the best algorithm to choose, but there are times when we need to visualize
    the variable values during the loop iterations. For cases like this Apple has
    created the timeline.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 知道循环迭代8次而不是54次是可以的。这能给你一个好的选择最佳算法的思路，但有时我们需要在循环迭代过程中可视化变量的值。对于这种情况，苹果公司创建了时间线。
- en: Getting ready
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You can open your Xcode and click on **Get started with playground**, or if
    you already have your Xcode opened, you can click on the file menu, then on the
    **New** option, and then click on **Playground**.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以打开您的Xcode并点击**开始使用游乐场**，或者如果您已经打开了Xcode，您可以点击文件菜单，然后点击**新建**选项，然后点击**游乐场**。
- en: Name your project `Chapter 6 Timeline` and save it in your workspace folder.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的项目命名为`第6章时间线`并将其保存在您的项目文件夹中。
- en: How to do it…
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'First, let''s type a code where we print some output, in this case we are going
    to print a triangle with stars:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们编写一段代码来打印一些输出，在这种情况下，我们将打印一个由星号组成的三角形：
- en: '[PRE4]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Once you've typed this code, you wouldn't appreciate the triangle yet. Go to
    the icon that looks like two overlapped circles and click on it:![How to do it…](img/00055.jpeg)
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您输入了这段代码，您可能还不会欣赏到三角形。转到看起来像两个重叠圆圈的图标并点击它：![如何操作…](img/00055.jpeg)
- en: Behold the Xcode split in to two parts. The new part on the right is called
    the timeline. Now you should see the console output, which should be similar to
    the following screenshot:![How to do it…](img/00056.jpeg)
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看看Xcode如何分成两部分。右侧的新部分被称为时间线。现在您应该看到控制台输出，它应该类似于以下截图：![如何操作…](img/00056.jpeg)
- en: Tip
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If for any reason you close the console output, you can reopen it by just re-running
    your code.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果出于任何原因您关闭了控制台输出，您可以通过重新运行您的代码来重新打开它。
- en: 'Now, let''s see the values of a variable; in this case we don''t have many
    options, so we are going to check the value of the j variable. To do it, just
    type j after the print instruction, something like the following code:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看变量的值；在这种情况下，我们没有很多选项，所以我们将检查`j`变量的值。要做到这一点，只需在打印指令后输入`j`，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now click on the round icon on the same level as the `j` variable:![How to do
    it…](img/00057.jpeg)
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在点击与`j`变量同一级别的圆形图标：![如何操作…](img/00057.jpeg)
- en: Now you can see the values of `j` according to the iteration on the following
    graphic:![How to do it…](img/00058.jpeg)
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以在以下图形中看到`j`的值，根据迭代进行变化：![如何操作…](img/00058.jpeg)
- en: If you want to see the value of your variable more clearly, you can slide the
    red bar that is on the bottom of your Xcode screen:![How to do it…](img/00059.jpeg)
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想更清楚地看到变量的值，您可以滑动位于Xcode屏幕底部的红色条：![如何操作…](img/00059.jpeg)
- en: If for any reason you have lots of graphs, you can close them to save space,
    but if you would like to keep some graphs, you can collapse them by double-clicking
    on their titles, and of course you can expand them just by double-clicking again:![How
    to do it…](img/00060.jpeg)
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果出于任何原因您有很多图表，您可以关闭它们以节省空间，但如果您想保留一些图表，您可以双击它们的标题来折叠它们，当然您也可以通过再次双击来展开它们：![如何操作…](img/00060.jpeg)
- en: As you can see, in this case you've got only the title **j // <- yes only the
    letter "j"** instead of the whole graph.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，在这种情况下，您只有标题**j // <- 只是有字母"j"**而不是整个图表。
- en: How it works…
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'The timeline has three different editors: the Standard Editor, which gives
    us more space to code and watch our code routine; the Assistant Editor, which
    gives us more information about our code execution, and the Version Editor, which
    shows us the modifications that our playground has.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 时间线有三个不同的编辑器：标准编辑器，它为我们提供了更多的空间来编写和查看我们的代码流程；辅助编辑器，它为我们提供了更多关于我们的代码执行的信息，以及版本编辑器，它显示了我们的游乐场所做的修改。
- en: The Assistant Editor gives us more accuracy about the variables evolution and
    their values. Using a graph helps us to know how a variable is changing its value.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助编辑器为我们提供了关于变量演变及其值的更多准确性。使用图表有助于我们了解变量值是如何变化的。
- en: The console output is also important; pay attention that if you try to visualize
    the print instruction only, you are going to see lots of stars, each of them on
    a different line. This kind of information is not useful for the developer.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出也很重要；请注意，如果您只尝试可视化打印指令，您将看到很多星号，每个星号都在不同的行上。这类信息对开发者来说并不有用。
- en: There's more…
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容…
- en: Playground isn't limited to displaying graphics only; you can also add some
    colors to it. In the next recipe, you are going to work with colors on your playground.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 游乐场不仅限于显示图形；您还可以添加一些颜色。在下一个菜谱中，您将在您的游乐场中处理颜色。
- en: Watching a temperature with color
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用颜色观察温度
- en: When Xerox engineers created the window system based on Smalltalk, they brought
    a big concept to the computer world, the idea of analog representation on digital
    devices (computer).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当施乐工程师基于Smalltalk创建窗口系统时，他们为计算机世界带来了一个重大概念，即在数字设备（计算机）上的模拟表示（思想）。
- en: It means that for us human beings, it is easier to understand how long a process
    will take watching a progress bar instead of by watching a percentage on a screen.
    Here we are going to watch some colors instead of numbers.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着对于我们人类来说，通过观察进度条而不是屏幕上的百分比来了解一个过程将花费多长时间更容易理解。这里我们将观察一些颜色而不是数字。
- en: In this recipe, we are going to watch the color of a temperature instead of
    watching its value; this way you can have a better idea about the chill.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将观察温度的颜色而不是观察它的值；这样你可以更好地了解寒冷。
- en: Getting ready
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Open your Xcode and create a new playground called `Chapter 6 Color`, remove
    the `str` string but leave the UIKit import.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的Xcode，创建一个新的playground，命名为`第6章 颜色`，移除`str`字符串但保留UIKit导入。
- en: How to do it…
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'First of all, let''s make an array with temperatures, in this case the temperatures
    are measured in degrees celsius:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个包含温度的数组，在这种情况下，温度是以摄氏度来衡量的：
- en: '[PRE6]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The next step is iterating over the array. For each iteration, we are going
    to store the result into a variable called color:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是遍历数组。对于每次迭代，我们将结果存储到一个名为color的变量中：
- en: '[PRE7]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now you have to add the color variable from the last loop sentence to the timeline;
    you can see a result similar to the following one:![How to do it…](img/00061.jpeg)
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你必须将上一个循环句子中的颜色变量添加到时间线中；你可以看到以下类似的结果：![如何做…](img/00061.jpeg)
- en: How it works…
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Timeline is not only about displaying numbers, it's also about giving us information
    where we could have a better idea about the code. Watching numbers such as 13
    degrees Celsius is something that doesn't give us a good idea of temperature,
    but watching a color can give us a better idea if it is cold or hot, mainly if
    you work with Fahrenheit values.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 时间线不仅关乎显示数字，还关乎提供信息，让我们能更好地理解代码。观察像13摄氏度这样的数字并不能很好地让我们了解温度，但观察颜色可以更好地告诉我们它是冷还是热，尤其是如果你使用华氏值的话。
- en: 'As you know, your computer screen works with three primary colors: red, green
    and blue. UIColor also has a fourth factor, which is the alpha factor, zero means
    transparent and one means opaque.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，你的电脑屏幕使用三种原色：红色、绿色和蓝色。UIColor还有一个第四个因素，即alpha因素，零表示透明，一表示不透明。
- en: In this recipe, we kept alpha as one and green as zero in every case, but for
    cold days we assumed that we need a high level of blue and a low level of red.
    For warm days we had to create a color with a high level of red and low level
    of blue. This means that a very blue color is saying that we had a very low temperature,
    and a very red color means a very high temperature.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们始终将alpha设为1，绿色设为0，但对于寒冷的日子，我们假设我们需要高水平的蓝色和低水平的红色。对于温暖的日子，我们必须创建一个红色水平高、蓝色水平低的颜色。这意味着非常蓝色的颜色表示温度非常低，而非常红色的颜色表示温度非常高。
- en: What about the intermediate temperature? In this case, we will have a purple
    color, which is the color created with 50% red and 50% blue.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 那中间的温度怎么办？在这种情况下，我们将有一个紫色，这是由50%红色和50%蓝色混合而成的颜色。
- en: Have a look that this kind of measure is more useful using playgrounds rather
    than using it on an app. Presumably, in a real app you won't store a color, you
    would store the real temperature, but you can get an idea if the values you have
    are to your liking or not before coding it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这种度量在playground中比在应用程序中使用更有用。大概在真实的应用程序中，你不会存储颜色，你会存储实际的温度，但在编码之前，你可以了解你拥有的值是否满意。
- en: There's more…
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多…
- en: In this case, we used the colors for getting a better idea about our values,
    but what else can we use? In the next recipe, you are going to learn how to use
    images.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用了颜色来更好地了解我们的值，但我们还能用什么呢？在下一个菜谱中，你将学习如何使用图片。
- en: Stretching an image
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展开图片
- en: Sometimes it's necessary to have more than one sample of a picture to see which
    ratio is the desired one. Let's imagine that we have a message, but we don't want
    to show it to the user, we only want to show something that gives him an idea
    that there is something, and the application is going to show the correct ratio
    later.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，需要多个图片样本才能看到哪个比例是我们想要的。让我们想象一下，我们有一个消息，但我们不想展示给用户，我们只想让他知道有东西，应用程序稍后会显示正确的比例。
- en: For cases like this, you can use `UIImage` and `ImageView`, and visualize it
    on the playground.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种情况，你可以使用`UIImage`和`ImageView`，并在playground中可视化它。
- en: Getting ready
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new playground called `Chapter 6 Stretching Image` and also have an
    image ready for this recipe, I would recommend to download the image `secret_message.png`,
    which is included in the resources files of this book.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `Chapter 6 Stretching Image` 的新游乐场，并且为这个食谱准备一张图片，我建议下载图片 `secret_message.png`，它包含在这本书的资源文件中。
- en: How to do it…
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Close the Xcode and open a **Finder** window, go to the folder where you saved
    the playground, click on the project that you created, and right-click (or control
    click) on it. In the menu, choose the option **Show Package Contents** as we learned
    in the beginning of this chapter:![How to do it…](img/00062.jpeg)
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭 Xcode 并打开一个 **Finder** 窗口，转到你保存游乐场的文件夹，点击你创建的项目，然后右键（或按住控制键点击）它。在菜单中，选择我们在这章开头学到的
    **Show Package Contents** 选项：![如何操作…](img/00062.jpeg)
- en: Now, create a folder called `Resources` and copy your image file into it. After
    that, reopen your playground.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为 `Resources` 的文件夹，并将你的图片文件复制进去。之后，重新打开你的游乐场。
- en: 'Remove the `str` variable because we are not going to use it. Let''s create
    a new class where we have a `ImageView`, its size, and the number of times that
    the `ImageView` was stretched:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除 `str` 变量，因为我们不会使用它。让我们创建一个新的类，其中包含 `ImageView`，其大小以及 `ImageView` 被拉伸的次数：
- en: '[PRE8]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once you''ve coded it, we need to create an object of this type, so add the
    following to your playground:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你编写了代码，我们需要创建这个类型的对象，所以请将以下内容添加到你的游乐场中：
- en: '[PRE9]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Good, now you have an object but the image is still in its original size. If
    you call the `stretch` method, you are going to see the image stretched only once,
    so let''s repeat this to get a better idea about how much we should stretch the
    picture:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，现在你有一个对象了，但图片仍然是原始大小。如果你调用 `stretch` 方法，你会看到图片只被拉伸一次，所以让我们重复这个过程，以便更好地了解我们应该将图片拉伸多少：
- en: '[PRE10]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For visualizing the different results, you can click on the value history icon,
    and then you can see lots of samples.![How to do it…](img/00063.jpeg)
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了可视化不同的结果，你可以点击值历史图标，然后你可以看到很多示例。![如何操作…](img/00063.jpeg)
- en: For having a better idea of the `ImageView`, you can click on the right-hand
    side of the sample row, where there is an eye icon. Click on the number **10**
    for example, and see what you've got:![How to do it…](img/00064.jpeg)
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了更好地了解 `ImageView`，你可以点击样本行的右侧，那里有一个眼睛图标。例如，点击数字 **10**，看看你得到了什么：![如何操作…](img/00064.jpeg)
- en: How it works…
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Views are allowed to be used on the playground; you can pre-visualize for example,
    how your `UIImageView`, `UILabel`, `UITextField,` and so on will be drawn. In
    this case, we had to repeat it a few times; it means that only the `ImageView`
    wouldn't give us the complete information.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 视图可以在游乐场中使用；例如，你可以预先可视化你的 `UIImageView`、`UILabel`、`UITextField` 等将如何绘制。在这种情况下，我们不得不重复几次；这意味着只有
    `ImageView` 不会给我们完整的信息。
- en: The best way is by creating our own class and storing the information we need,
    such as how many times we've stretched the `ImageView` and the current size of
    the `ImageView`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的方法是创建我们自己的类，并存储我们需要的所有信息，例如我们拉伸 `ImageView` 的次数以及 `ImageView` 的当前大小。
- en: On the right-hand side of the result, as you can see there is a small eye icon
    (quick look), it will show you how the view was at that moment.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在结果的右侧，正如你所看到的，有一个小眼睛图标（快速查看），它将显示视图在那个时刻的状态。
- en: Note
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's very common to work with a framework called **CoreImage** when you want
    to user a filter on an image (like hiding a secret message), unfortunately this
    framework doesn't work with playground yet.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想在图片上使用过滤器（如隐藏秘密信息）时，通常会使用一个名为 **CoreImage** 的框架，不幸的是，这个框架目前还不能与游乐场一起使用。
- en: There's more…
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: If you need to store information with your playground, you probably want to
    print the constant `XCPSharedDataDirectoryPath`. It will show you where the playground
    stores this information.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要将信息存储在你的游乐场中，你可能想打印出常量 `XCPSharedDataDirectoryPath`。它将显示游乐场存储这些信息的位置。
- en: Sometimes we would like to hide a message and sometimes we would like to make
    it more readable. In the next recipe, we are going to learn how you can pre-visualize
    a text with different fonts.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们可能想隐藏信息，有时候我们可能想让它更容易阅读。在下一个食谱中，我们将学习如何使用不同的字体预先可视化文本。
- en: Beautifying your text using Pangrams
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Pangrams 美化你的文本
- en: Have you ever seen the phrase "The quick brown fox jumps over the lazy dog"?
    Why is it so famous? The reason is that it is an English Pangram; it means a phrase
    with every letter from the alphabet.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有见过这样的短语“The quick brown fox jumps over the lazy dog”？为什么它这么有名？原因是它是一个英语Pangram；这意味着一个包含字母表中每个字母的短语。
- en: Pangrams are useful when you want to visualize properties of a font, such as
    size, color, or boldness. In this recipe, we are going to check different fonts,
    using `NSAttributedString` and playground.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Pangrams在你想要可视化字体属性时很有用，比如大小、颜色或粗体。在这个菜谱中，我们将使用`NSAttributedString`和游乐场来检查不同的字体。
- en: Getting ready
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new playground called `Chapter 6 Text` and remove the string that comes
    by default.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的游乐场，命名为`第6章 文本`，并移除默认出现的字符串。
- en: How to do it…
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'First, let''s create our attributed string:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建我们的属性字符串：
- en: '[PRE11]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: After that you will see a new icon with the letter **a** appearing. It means
    that the playground has recognized it as an attributed string. Click on the Quick
    Look icon and you will see the current string with its attributes:![How to do
    it…](img/00065.jpeg)
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后你将看到一个带有字母**a**的新图标出现。这意味着游乐场已经将其识别为属性字符串。点击快速查看图标，你会看到当前字符串及其属性：![如何做到这一点…](img/00065.jpeg)
- en: 'Now let''s choose some font sizes and colors for our text:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们为我们的文本选择一些字体大小和颜色：
- en: '[PRE12]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As we also would like to choose a few different fonts, we need to create another
    array; however, it can''t be a simple array of strings because we are going to
    call different methods. So we will need to create an array of closures:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们还想选择一些不同的字体，我们需要创建另一个数组；然而，它不能是一个简单的字符串数组，因为我们将要调用不同的方法。所以我们需要创建一个闭包数组：
- en: '[PRE13]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once we''ve done it, we have our playground ready to execute the main part.
    To do it, let''s create three nested loops, each of which will iterate over one
    of our arrays:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们完成了，我们的游乐场就准备好了，可以执行主要部分。为了做到这一点，让我们创建三个嵌套循环，每个循环将遍历我们的数组之一：
- en: '[PRE14]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you prefer, instead of using `for` loops, you can use a more swift way of
    iterating over an array, using the `map` closure:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你愿意，你不必使用`for`循环，你可以使用一种更快捷的方式来遍历数组，使用`map`闭包：
- en: '[PRE15]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It doesn't matter which procedure you've chosen, click on the value history
    of the line that only contains the word `string`. Now you can appreciate the samples
    of the attributed string.![How to do it…](img/00066.jpeg)
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无论你选择了哪种程序，点击只包含单词`string`的行的值历史。现在你可以欣赏到属性字符串的样本。![如何做到这一点…](img/00066.jpeg)
- en: How it works…
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Attributed strings are accepted by playground, and this procedure is very useful
    when you have to choose a configuration for your app without running the full
    application.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 属性字符串被游乐场接受，当你需要为你的应用程序选择配置而不运行完整应用程序时，这个程序非常有用。
- en: If we were using Objective-C instead of Swift we probably would have created
    an array of selectors rather than blocks. However, Swift doesn't follow this philosophy
    anymore, and the function `performSelector` now asks for a delay time to start.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用Objective-C而不是Swift，我们可能已经创建了一个选择器数组而不是闭包。然而，Swift不再遵循这种哲学，现在`performSelector`函数要求一个延迟时间来启动。
- en: Using blocks or closures is more flexible and it also makes the code easier
    to maintain. One limitation that you can see here is that you can't copy the array
    of functions from the quick look. Better saying, you can do it, but the only text
    that you are going to copy is Function, which is not very useful.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用块或闭包更加灵活，同时也使得代码更容易维护。你可以在这里看到的一个限制是，你不能从快速查看中复制函数数组。更好的说法是，你可以这样做，但你将要复制的唯一文本是“函数”，这并不太有用。
- en: There's more…
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Here we had our own text, but what if we need some text from a remote server?
    In the next recipes, we are going to learn how to treat HTTP requests on playground.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们有我们自己的文本，但如果我们需要从远程服务器获取一些文本怎么办？在接下来的菜谱中，我们将学习如何在游乐场中处理HTTP请求。
- en: Receiving JSONs
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接收JSONs
- en: Asking for remote information is something very common today. What happens if
    your playground finishes before you receive a server response? In this recipe,
    we are going to learn how to deal with this problem.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 请求远程信息在今天是非常常见的。如果你的游乐场在你收到服务器响应之前就结束了，会发生什么？在这个菜谱中，我们将学习如何处理这个问题。
- en: Getting ready
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new playground called `Chapter 6 Requesting JSONs`, and just in case,
    check your Internet connection.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的游乐场，命名为`第6章 请求JSONs`，并且以防万一，检查你的互联网连接。
- en: How to do it…
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'First, we need to locate a URL, which can return us more websites. In this
    case we are going to use this URL: [https://api.github.com/users/mralexgray/repos](https://api.github.com/users/mralexgray/repos).'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要找到一个可以返回更多网站的URL。在这种情况下，我们将使用这个URL：[https://api.github.com/users/mralexgray/repos](https://api.github.com/users/mralexgray/repos)。
- en: 'Create a constant with the URL mentioned previously:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含之前提到的URL的常量：
- en: '[PRE16]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Click on the quick look icon and check that you have received a JSON response.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击快速查看图标并检查你是否收到了JSON响应。
- en: Tip
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can use the quick look with NSURL for checking websites. If you are testing
    something that is modifying a website, you can use quick look to check the new
    website look.
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以使用NSURL进行快速查看以检查网站。如果你正在测试修改网站的内容，你可以使用快速查看来检查新的网站外观。
- en: 'Now let''s create a request for our URL:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们为我们的URL创建一个请求：
- en: '[PRE17]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The next step is requesting the content of the URL:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是请求URL的内容：
- en: '[PRE18]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Check the playground result. Unfortunately, the playground finished before
    we got the response. Go to the beginning of your playground and add the following
    lines:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查沙盒的结果。不幸的是，沙盒在收到响应之前就结束了。回到你的沙盒开始处，添加以下行：
- en: '[PRE19]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now we will be able to receive a response, however as you can see, the response
    isn''t the one we were waiting for. Fixing this issue will require us to implement
    a new class and set it as `NSURLConnectionDelegate`. Place this code before sending
    your asynchronous request:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将能够收到响应，然而正如你所看到的，响应并不是我们等待的那个。解决这个问题需要我们实现一个新的类并将其设置为`NSURLConnectionDelegate`。在发送异步请求之前放置以下代码：
- en: '[PRE20]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `total` variable will be used afterwards, now the only thing you need to
    do is check that we could receive the response as we expected. Only one request
    might not be enough to do a benchmark, in which case we need to go to the line
    where we are inspecting the `data` argument and add the following code:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`total`变量将在之后使用，现在你唯一需要做的就是检查我们是否能够按照预期收到响应。只有一个请求可能不足以进行基准测试，在这种情况下，我们需要转到检查`data`参数的行，并添加以下代码：'
- en: '[PRE21]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Good, now as you can see we have a more acceptable result. If you'd like to
    get a better result for your benchmarking, reduce the running time of your playground
    by changing the number of seconds, located at the lower-right-hand corner to **3**
    seconds.![How to do it…](img/00067.jpeg)
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，现在正如你所看到的，我们得到了一个更可接受的结果。如果你想为基准测试得到更好的结果，通过将右下角的秒数更改为**3**秒来减少沙盒的运行时间。![如何做…](img/00067.jpeg)
- en: Now check how many times you received a response, that's your real statistic.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在检查你收到了多少次回复，这就是你的真实统计数据。
- en: How it works…
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Playground has its own framework called `XCPlayground`. It was created to add
    some features to your playground according to your test needs. In this case we
    started using the function `XCPSetExecutionShouldContinueIndefinitely`, which
    keeps playground running even if it has reached the last code line.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 沙盒有一个自己的框架，称为`XCPlayground`。它是为了根据你的测试需求添加一些功能而创建的。在这种情况下，我们开始使用函数`XCPSetExecutionShouldContinueIndefinitely`，它使沙盒即使在达到最后一行代码后也能继续运行。
- en: The `XCPlayground` framework also helped us with the `XCPCaptureValue` function.
    This function allows us to store a value from different parts of our code and
    create a single graph for it, as we did with the `total` variable.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`XCPlayground`框架还帮助我们使用了`XCPCaptureValue`函数。这个函数允许我们从代码的不同部分存储一个值，并为它创建一个单独的图表，就像我们对`total`变量所做的那样。'
- en: We also had to fix an issue about the connection, which was being denied by
    the HTTPS protocol. In this case, we tried to create the connection and we could
    see that it was being rejected, that's a good reason for using playground before
    coding into your app, so we can solve this issue much faster.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须解决一个关于连接的问题，它被HTTPS协议拒绝。在这种情况下，我们尝试创建连接，我们可以看到它被拒绝，这是在将代码编入你的应用之前使用沙盒的一个很好的理由，这样我们可以更快地解决这个问题。
- en: At the end, we could change the execution limit time of our playground, by default
    it starts with 30 seconds but it might be too much for cases like this. Reducing
    this time allowed us to get a better idea about how many requests our app is able
    to do in a second.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以更改我们的沙盒执行时间限制，默认情况下它从30秒开始，但对于这种情况可能太长了。减少这个时间让我们能够更好地了解我们的应用每秒能处理多少请求。
- en: There's more…
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: As you can see, playground has its own framework. It allows us to control and
    get better results from playground. To complete it, in the next recipe we are
    going to learn how to create personalized quick looks.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，playground有其自己的框架。它允许我们更好地控制playground并获取更好的结果。为了完成它，在下一个菜谱中，我们将学习如何创建个性化的快速查看。
- en: Creating our own class representations
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们自己的类表示
- en: Quick look is a good tool that helps us to visualize the current status of an
    object, but sometimes when we create our own class with its own logic, quick look
    won't be able to draw something that represents the object without your help.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 快速查看是一个很好的工具，它帮助我们可视化对象当前的状态，但有时当我们创建具有自己逻辑的自己的类时，快速查看可能无法在没有你的帮助的情况下绘制代表对象的任何东西。
- en: In this recipe, we are going to learn how to create our own class representation,
    and to do it we are going to create a class that represents a checkers board.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何创建我们自己的类表示，为此我们将创建一个代表国际象棋棋盘的类。
- en: Getting ready
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new playground called `Chapter 6 Checkers` with the iOS option selected.
    If you select Mac OS, remember to import Cocoa and replace some types with the
    equivalent ones, such as `NSBezierPath` instead of `UIBezierPath`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的名为`第6章国际象棋`的playground，并选择iOS选项。如果你选择Mac OS，请记住导入Cocoa并将一些类型替换为等效类型，例如用`NSBezierPath`代替`UIBezierPath`。
- en: How to do it…
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Let''s start creating a class that inherits from `NSObject`:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们开始创建一个从`NSObject`继承的类：
- en: '[PRE22]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Before we go any further, we need to define the status of each square; as you
    know it could have a black piece, a white piece, or it could be empty:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们需要定义每个方格的状态；正如你所知，它可能有一个黑子、一个白子，或者它可能是空的：
- en: '[PRE23]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now let''s define the board. In this case, it''s a two-dimensional array attribute,
    and the initial value of each square must be `.FREE`:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们定义棋盘。在这种情况下，它是一个二维数组属性，并且每个方格的初始值必须是`.FREE`：
- en: '[PRE24]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As we never know whether the board has the right size, we are going to create
    a constant that represents the size of a square. You can change this value if
    you think the board is too big or too small:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们永远不知道棋盘是否有正确的大小，我们将创建一个表示正方形大小的常量。如果你认为棋盘太大或太小，你可以更改这个值：
- en: '[PRE25]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The next step is creating a method called `debugQuickLookObject`. It is not
    a random name, it must be called like that:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是创建一个名为`debugQuickLookObject`的方法。这个名字不是随意的，它必须这样命名：
- en: '[PRE26]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Tip
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Use the `debugQuickLookObject` method in your application, Swift and Objective-C
    debuggers also use this method to give you an idea of your object.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在你的应用程序中使用`debugQuickLookObject`方法，Swift和Objective-C调试器也使用这个方法来给你一个关于你对象的想法。
- en: 'Start creating an image context with the size of the checkers board:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始创建一个与国际象棋棋盘大小相同的图像上下文：
- en: '[PRE27]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create two loops that will draw each square of the board:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个循环，将绘制棋盘的每个方格：
- en: '[PRE28]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Inside these loops, we need to calculate where the current position is:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这些循环中，我们需要计算当前位置：
- en: '[PRE29]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'After that, we need to know whether we are going to draw a black square or
    a white one. To do it, the `row` and `col` variables will help us:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们需要知道我们将绘制黑色方格还是白色方格。为此，`row`和`col`变量将帮助我们：
- en: '[PRE30]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, fill the square with the current color:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，用当前颜色填充方格：
- en: '[PRE31]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Once we have painted the square, we are going to draw a circle that represents
    a player piece:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们画好了方格，我们将画一个代表玩家棋子的圆圈：
- en: '[PRE32]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The loops are done, we can now finish them, return the image, and finish the
    board class:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环完成了，我们现在可以完成它们，返回图像，并完成棋盘类：
- en: '[PRE33]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As you may imagine, we need to test our class by instantiating it, adding some
    pieces to the board, and visualizing it:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所想，我们需要通过实例化类、在棋盘上添加一些棋子并可视化它来测试我们的类：
- en: '[PRE34]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now click on Quick Look of the board (last line) and you should see a result
    like the following one:![How to do it…](img/00068.jpeg)
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在点击棋盘的快速查看（最后一行），你应该看到以下结果：![如何做到这一点…](img/00068.jpeg)
- en: How it works…
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: For displaying a custom Quick Look, you have to create a class that inherits
    from `NSObject` and implements the method `debugQuickLookObject`. Although this
    method returns an object of type `AnyObject`, on its declaration, it should return
    anything that could be represented by playground, such as colors, bezier paths,
    views, and so on.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示自定义的快速查看，你必须创建一个从`NSObject`继承的类并实现`debugQuickLookObject`方法。尽管这个方法返回一个`AnyObject`类型的对象，但在其声明中，它应该返回playground可以表示的任何东西，例如颜色、贝塞尔路径、视图等等。
- en: In this recipe, we used a bezier path, which has a different coordinate system
    from the traditional views. Bezier paths have the initial point (`x = 0` and `y
    = 0`) on the lower-left-hand corner. It didn't affect us because we used only
    squares and circles, but bear this problem in mind, because you can get wrong
    results.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用了一个贝塞尔路径，它与传统视图有不同的坐标系。贝塞尔路径的初始点（`x = 0` 和 `y = 0`）位于左下角。由于我们只使用了正方形和圆形，这并没有影响我们，但请记住这个问题，因为可能会得到错误的结果。
- en: '`UIColor` has some methods that indicate the color that should be used in the
    current context for filling a shape (`setFill`), and to draw the border of it
    (`setStroke`). These colors are going to be applied when you call the corresponding
    action to use them, such as `bezier.fill()`.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIColor` 有一些方法可以指示在当前上下文中应使用的颜色来填充形状（`setFill`），以及绘制其边框（`setStroke`）。这些颜色将在调用相应的动作来使用它们时应用，例如
    `bezier.fill()`。'
- en: There's more…
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Sometimes we need to indicate that we want to show a view on our playground,
    to do that we have a function called `XCPShowView`, so it's another way to visualize
    an object. In the next chapter, we are going to learn how to debug our app; it
    is very useful when we have too much code and we are not able to test it on the
    playground.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们需要指示在游乐场中显示一个视图，为此我们有一个名为 `XCPShowView` 的函数，所以这是可视化对象的另一种方式。在下一章中，我们将学习如何调试我们的应用程序；当我们有太多代码且无法在游乐场中测试时，这非常有用。
- en: Rich documentation
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 丰富的文档
- en: Providing clean and concise documentation will result in direct insight into
    the structure and functionality of your code. This greatly benefits collaborators
    who work with your code, as well as yourself when revisiting previous code you
    have worked on. Additionally, Xcode can leverage this documentation and provide
    instant quick look information anywhere your code is used, keeping you from having
    to switch between multiple files for reference.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 提供清晰简洁的文档将直接揭示代码的结构和功能。这对与你代码合作的同事以及你在回顾之前所写的代码时非常有帮助。此外，Xcode 可以利用这些文档，并在代码使用的任何地方提供即时快速查看信息，这样你就不必在多个文件之间切换以进行参考。
- en: In this recipe we will take a generic class declaration and document its methods
    and properties using the new documentation syntax in Xcode 7 with Swift.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用 Xcode 7 中 Swift 的新文档语法来对一个通用类声明进行文档化，并记录其方法和属性。
- en: Getting ready
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new playground and name it `Documentation`. This recipe will not require
    a project file so do not worry about any project settings.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的游乐场，并将其命名为 `Documentation`。这个示例不需要项目文件，所以不用担心任何项目设置。
- en: How to do it…
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Copy the following code into your playground as our starting point:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码复制到你的游乐场中作为我们的起点：
- en: '[PRE35]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can see, this class contains a couple of variables and two methods; one
    with parameters and a return value, and another without either.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，这个类包含几个变量和两个方法；一个带有参数和返回值，另一个则没有。
- en: 'To start, let''s add documentation to the class itself. Add the following code
    above the class declaration:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们给类本身添加文档。在类声明上方添加以下代码：
- en: '[PRE36]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`///` represents a single line comment. This is convenient for documentation
    that does not require any parameters or return values. Xcode will recognize `///`
    and parse the information for quick look access.'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`///` 表示单行注释。这对于不需要任何参数或返回值的文档来说很方便。Xcode 会识别 `///` 并解析信息以供快速查看访问。'
- en: 'To test it out, option click on `SomeSimpleClass` and you should see the following
    screenshot:'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了测试它，按住选项键点击 `SomeSimpleClass`，你应该会看到以下截图：
- en: '![How to do it…](img/00069.jpeg)'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/00069.jpeg)'
- en: 'Add the following code to the line just above the `doSomething()` method and
    option click to verify it is working properly:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `doSomething()` 方法正上方的一行添加以下代码，并按住选项键点击以验证其是否正常工作：
- en: '[PRE37]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now that we have covered the single line documentation, let''s add documentation
    to the `doSomethingWithStuff()` method. Add the following code just above the
    method declaration:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经覆盖了单行文档，让我们给 `doSomethingWithStuff()` 方法添加文档。在方法声明上方添加以下代码：
- en: '[PRE38]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: For multiline documentation, we want to place all documentation between `/**
    */`. Xcode will parse these lines accordingly for quick look. Additionally, we
    are able to explicitly define both parameters and return type. Option click on
    the `doSomethingWithStuff()` method to see the following Quick Look view:![How
    to do it…](img/00070.jpeg)
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于多行文档，我们希望在`/** */`之间放置所有文档。Xcode将相应地解析这些行以快速查看。此外，我们还可以显式地定义参数和返回类型。点击`doSomethingWithStuff()`方法的选项，可以看到以下快速查看视图：![如何操作…](img/00070.jpeg)
- en: 'Update the code block in the previous step to the following code:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将上一步中的代码块更新为以下代码：
- en: '[PRE39]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: When dealing with multiple parameters, it is good practice (and easier to read)
    to specify the parameter's section rather than each individual parameter.
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当处理多个参数时，指定参数部分而不是每个单独的参数是一个好的做法（并且更容易阅读）。
- en: 'Swift also allows for additional description fields. Add the following code
    to the `doSomethingWithStuff()` documentation block:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Swift还允许添加额外的描述字段。将以下代码添加到`doSomethingWithStuff()`文档块中：
- en: '[PRE40]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You should see the following screen:'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您应该看到以下屏幕：
- en: '![How to do it…](img/00071.jpeg)'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/00071.jpeg)'
- en: Tip
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'For an extensive list of available fields, visit the Apple documentation found
    here: [https://developer.apple.com/library/ios/documentation/Xcode/Reference/xcode_markup_formatting_ref/](https://developer.apple.com/library/ios/documentation/Xcode/Reference/xcode_markup_formatting_ref/)'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要查看可用的字段列表，请访问以下Apple文档：[https://developer.apple.com/library/ios/documentation/Xcode/Reference/xcode_markup_formatting_ref/](https://developer.apple.com/library/ios/documentation/Xcode/Reference/xcode_markup_formatting_ref/)
- en: 'Xcode also allows headers, formatting, and ordered/unordered lists. Add the
    following code to the documentation block:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Xcode还允许使用标题、格式化和有序/无序列表。将以下代码添加到文档块中：
- en: '[PRE41]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Xcode supports three headings: `#` represents heading 1; `##` and `###` represent
    heading two and three respectively:'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Xcode支持三种标题：`#`代表一级标题；`##`和`###`分别代表二级和三级标题：
- en: '![How to do it…](img/00072.jpeg)'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/00072.jpeg)'
- en: How it works…
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Xcode will automatically parse the added documentation and organize it according
    to the keywords used in the documentation block. This requires no additional settings
    and will work on anyone's computer running Xcode 7.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode将自动解析添加的文档，并根据文档块中使用的关键字对其进行组织。这不需要额外的设置，并且将在运行Xcode 7的任何计算机上工作。
- en: There's more…
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容…
- en: Sometimes documentation may need to be formatted similarly to an instruction
    manual, with multiple pages for better organization. With the power of playgrounds,
    you can provide detailed documentation with multiple pages and link between them
    for easy access. This will be covered in the next recipe.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 有时文档可能需要以类似说明书的方式格式化，以便有多个页面以更好地组织。利用游乐场的功能，您可以提供具有多个页面的详细文档，并在它们之间建立链接以便于访问。这将在下一个食谱中介绍。
- en: Navigating pages in playgrounds
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在游乐场中导航页面
- en: Playgrounds are proving to be more and more powerful, as Apple continues to
    add functionality. One great new feature is the ability to navigate through pages
    in a single playground. Doing so allows you to format your documentation in a
    more organized way. Additionally, you can even structure your documentation and
    code similarly to a digital book and allow readers to navigate with ease.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 游乐场正变得越来越强大，随着Apple不断添加功能。一个很棒的新特性是能够在单个游乐场中导航页面。这样做允许您以更组织化的方式格式化文档。此外，您甚至可以将文档和代码结构化得类似于数字书，并允许读者轻松导航。
- en: Getting ready
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Create a new playground and name it `Paging`. This recipe will not require
    a project file so do not worry about any project settings. Next, select **File**
    | **New** | **Playground** **Page**. In the navigator on the right, you should
    see two pages: `Untitled Page` and `Untitled Page 2`. Rename these `Intro` and
    `Start Now` respectively.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的游乐场，并将其命名为`Paging`。本食谱不需要项目文件，因此请不用担心任何项目设置。接下来，选择**文件** | **新建** | **游乐场**
    **页面**。在右侧的导航器中，您应该看到两个页面：`未命名页面`和`未命名页面 2`。分别将它们重命名为`Intro`和`Start Now`。
- en: How to do it…
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Add the following code to the bottom of the Intro page:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到Intro页面的底部：
- en: '[PRE42]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Xcode will recognize `//:` as a markup command similar to `///`. The navigation
    between pages uses a standard format of `[Link Title](location to link to)`. In
    this instance, we name the link `Next`, and use the standard `@next` option to
    let Xcode know to navigate to the next page (based on project order).
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Xcode会将`//:`识别为类似于`///`的标记命令。页面之间的导航使用标准的格式 `[链接标题](链接到的位置)`。在这个例子中，我们命名链接为`Next`，并使用标准的`@next`选项让Xcode知道要导航到下一页（基于项目顺序）。
- en: Select **Editor** | **Show Rendered Markup** from the top menu. In order to
    view our navigation, we will need Xcode to render it based on the supplied markup.
    You should see something similar to this:![How to do it…](img/00073.jpeg)
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从顶部菜单选择**编辑器** | **显示渲染标记**。为了查看我们的导航，我们需要Xcode根据提供的标记进行渲染。您应该看到类似以下内容：![如何操作…](img/00073.jpeg)
- en: Selecting the next button will automatically bring you to the `Start` page previously
    created. You will notice the boilerplate code for a new page automatically produces
    its own previous and next links. Select **Editor** | **Show Raw Markup** to see
    the code. Everything is identical, with the exception of using `@previous` as
    the link location for the previous link.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择下一个按钮将自动带您到之前创建的`Start`页面。您会注意到新页面的样板代码会自动生成其自己的上一页和下一页链接。选择**编辑器** | **显示原始标记**来查看代码。所有内容都是相同的，除了使用`@previous`作为上一页的链接位置。
- en: 'Navigate back to the `Intro` page and add the following code to the end of
    the file:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到`Intro`页面，并将以下代码添加到文件末尾：
- en: '[PRE43]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: By specifying the name of a page as the location, we can navigate directly to
    the specified page.
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过指定页面名称作为位置，我们可以直接导航到指定的页面。
- en: Note
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that page names with spaces require the `%20` ASCII space code to work
    properly.
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，带有空格的页面名称需要使用`%20` ASCII 空格代码才能正常工作。
- en: How it works…
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Like all other documentation and markup, Xcode will automatically parse the
    text into the proper commands and link everything properly.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 就像所有其他文档和标记一样，Xcode会自动将文本解析为正确的命令，并正确链接所有内容。
- en: See also
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Although we covered all of the basics, there are still additional features
    provided by Apple for dealing with documentation and playgrounds. For more information,
    visit this link: [https://developer.apple.com/library/ios/documentation/Xcode/Reference/xcode_markup_formatting_ref/](https://developer.apple.com/library/ios/documentation/Xcode/Reference/xcode_markup_formatting_ref/)'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然我们已经涵盖了所有基础知识，但苹果公司仍提供了额外的功能来处理文档和游乐场。更多信息，请访问此链接：[https://developer.apple.com/library/ios/documentation/Xcode/Reference/xcode_markup_formatting_ref/](https://developer.apple.com/library/ios/documentation/Xcode/Reference/xcode_markup_formatting_ref/)
