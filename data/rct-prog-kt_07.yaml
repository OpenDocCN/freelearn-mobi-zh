- en: Concurrency and Parallel Processing in RxKotlin with Schedulers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用调度器在 RxKotlin 中进行并发和并行处理
- en: So, up until now, you have learned the basics of reactive programming. You learned
    about Observable, Observers, and Subjects, as well as backpressure, Flowable,
    processors, and operators. Now, it's time for us to learn some other new topics
    in reactive programming, probably the most important ones—concurrency and parallel
    processing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，到目前为止，你已经学习了响应式编程的基础。你学习了 Observable、Observers 和 Subjects，以及背压、Flowable、处理器和操作符。现在，是我们学习响应式编程中一些其他新主题的时候了，可能是最重要的主题——并发和并行处理。
- en: A popular misconception regarding reactive programming is that reactive programming
    is multi-threaded by default. The truth is actually that RxKotlin works on a single
    thread by default, although it provides us with loads of operators to implement
    multi-threading as per our business logic and requirements with ease.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 关于响应式编程的一个常见误解是响应式编程默认是多线程的。实际上，RxKotlin 默认是在单线程上工作的，尽管它为我们提供了大量的操作符，可以轻松地根据我们的业务逻辑和需求实现多线程。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introduction to concurrency
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发编程简介
- en: The `subscribeOn()` and `observeOn()` operator
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subscribeOn()` 和 `observeOn()` 操作符'
- en: Parallelization
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行化
- en: Introduction to concurrency
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发编程简介
- en: 'The definition of concurrency can be described as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 并发的定义可以描述如下：
- en: As a programming paradigm, concurrent computing is a form of modular programming,
    namely factoring an overall computation into subcomputations that may be executed
    concurrently.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种编程范式，并发计算是一种模块化编程，即把整体计算分解成可以并发执行的子计算。
- en: – Wikipedia
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: – 维基百科
- en: As the definition says, concurrency is all about breaking the entire task into
    small parts and then executing them concurrently (there's a small difference between
    concurrent execution and parallel execution, which we will discuss shortly).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，并发就是将整个任务分解成小部分，然后并发执行（并发执行和并行执行之间有一个小的区别，我们将在稍后讨论）。
- en: So, what does it mean to execute subcomputations concurrently? Let's look at
    a real-life example. Think of a situation where you're cooking a new dish at your
    home and you have three chores—bring the spices, cut the vegetables, and also
    marinate something. Now, if you're doing it all alone, you have to do them one
    by one, but if you have a family member at your disposal, then you can distribute
    the tasks between the two of you. You can cut the vegetables while the other person
    is bringing the spices, and whoever between you two completes early can continue
    on the third task—marinating the food.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，并发执行子计算意味着什么呢？让我们看看一个现实生活中的例子。想象一下你在家做一道新菜，你有三项任务——拿调料、切蔬菜，以及腌制一些东西。现在，如果你一个人做，你必须一个接一个地做，但如果你有一个家庭成员可以帮忙，那么你们可以分担任务。你可以在另一个人拿调料的时候切蔬菜，而你们中谁先完成可以继续第三个任务——腌制食物。
- en: You can think of you and the family member (who helped you) as two threads,
    or, to be more specific, you're the main thread of the program (here, cooking)
    as you're the responsible person for the entire job, and you'll be distributing
    tasks between you and the family member, who is a worker thread. Together, you
    and your family member form a thread pool.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把你自己和帮助你的人（家庭成员）想象成两个线程，或者更具体地说，你作为程序的主要线程（在这里，烹饪）是整个工作的负责人，你将分配任务给你和家庭成员，他是工作线程。你们两个和你的家庭成员共同构成一个线程池。
- en: The entire program will execute faster if there are more threads and the complete
    task is divided properly among them.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有更多的线程并且整个任务被适当地分配给它们，整个程序将执行得更快。
- en: Parallel execution versus concurrency
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行执行与并发
- en: The concepts of concurrency and parallelization are not only related, but they
    are deeply connected to each other; you may think of them as identical twin brothers.
    They look almost the same, but there are differences. Let's try to discover.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 并发和并行化的概念不仅相关，而且它们之间有着深刻的联系；你可以把它们想象成孪生兄弟。它们看起来几乎一样，但也有一些区别。让我们试着去发现。
- en: In the previous example, we discussed concurrency, but it seemed to execute
    in parallel. Now, let's take a better example, which will not only help us understand
    parallelization, but will allow us to understand the differences between concurrency
    and parallelization as well.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的例子中，我们讨论了并发，但它似乎是在并行执行的。现在，让我们用一个更好的例子来代替，这个例子不仅可以帮助我们理解并行化，还可以让我们理解并发和并行化之间的区别。
- en: Think of a hotel with 5 customers who ordered 15 dishes. These 15 dishes represent
    identical tasks, and each of them require to be cooked by a chef. Now, as with
    the previous example, think of the cooks as threads (in the previous example,
    you and your family member were playing the role of a cook in your home), but
    rather than sharing sub-parts of a dish, they will cook each dish at a time (because,
    obviously, there are 15 orders!).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下有一家酒店，有5位顾客点了15道菜。这15道菜代表的是相同的工作任务，每个任务都需要厨师来烹饪。现在，就像之前的例子一样，把厨师想象成线程（在之前的例子中，你和你的家庭成员扮演的是在家中的厨师角色），但他们不会共享菜肴的子部分，而是每次只烹饪一道菜（因为显然有15个订单！）。
- en: Now, if you get 15 cooks at your disposal (along with 15 ovens and other resources),
    then you can get all the dishes to be cooked in one go, but that's not quite economical.
    You cannot infinitely increase your cooks and resources with the number of orders.
    The more economical solution would be to hire 5 cooks and make a pool (or you
    may say a queue) of orders and execute orders one after another. So, each cook
    has to make three dishes (or iterations of tasks). If there are more orders, then
    the pool would grow bigger.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你有15名厨师可供使用（包括15个烤箱和其他资源），那么你可以一次性完成所有菜肴的烹饪，但这并不经济。你不能随着订单数量的增加无限地增加厨师和资源。更经济的方法是雇佣5名厨师，并创建一个订单池（或者你也可以说是一个队列），依次执行订单。因此，每位厨师需要制作三道菜（或任务的迭代）。如果有更多的订单，那么池子会变得更大。
- en: Parallelization says to wisely divide tasks in a pool; instead of creating threads
    for each task, create a pool of tasks, and assign them to an existing thread,
    and reuse them.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 并行化建议在池中明智地划分任务；而不是为每个任务创建线程，创建一个任务池，并将它们分配给现有的线程，并重复使用它们。
- en: The conclusion is, parallelization is achieved with concurrency, but it is not
    the same thing; rather, it is about how to use concurrency.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 结论是，通过并发实现并行化，但这并不是同一件事；相反，它关乎如何使用并发。
- en: Now, why is it so important? Or rather, why is it required at all? I think you
    already got the answer, but let's inspect.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为什么这如此重要？或者更确切地说，为什么它真的有必要？我想你已经得到了答案，但让我们来检查一下。
- en: Think of a situation where you're working with a large dataset, and also have
    a long chain of operations to be performed on them before being displayed to the
    user. If you're an application developer, you'd probably want to perform all the
    operations in the background and pass the resultant data to the foreground for
    displaying it to the user. Concurrency is useful for this same scenario.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下你正在处理一个大型数据集，并且需要在将数据展示给用户之前对它们执行一系列长链操作。如果你是应用开发者，你可能希望在后台执行所有操作，并将结果数据传递到前台以展示给用户。并发对于这种情况非常有用。
- en: As I mentioned earlier, RxKotlin doesn't perform actions concurrently, but provides
    you with loads of options to perform the selected operations concurrently, leaving
    the choice to you.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，RxKotlin不会并发执行操作，但它提供了大量的选项来并发执行选定的操作，并将选择权留给你。
- en: You're probably wondering if RxKotlin really is single threaded by default,
    then how is the subscription handled by it? Should the subscription be concurrent?
    Let's find the answers before we proceed further with concurrent computing with
    RxKotlin.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道，如果RxKotlin默认是单线程的，那么它是如何处理订阅的？订阅应该是并发的吗？在我们进一步使用RxKotlin进行并发计算之前，让我们找到答案。
- en: So, whenever you subscribe to an Observable and/or Flowable, the current thread
    is blocked until all the items are emitted and received by the Observer chain
    (except for the cases with interval and timer factory methods). Surprising, right?
    However, it's actually good, because, for an Observable chain, if a separate thread
    is assigned to each operator (any operator generally subscribes to the source
    Observable and performs operations on the emissions, the next operator subscribes
    to the emissions by the current one), then it would be totally messy.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，无论何时你订阅了一个 `Observable` 和/或 `Flowable`，当前线程都会被阻塞，直到所有项目都被观察者链发出和接收（除了具有间隔和定时器工厂方法的场景）。惊讶吗？然而，这实际上很好，因为对于
    `Observable` 链，如果为每个操作符分配一个单独的线程（任何操作符通常订阅源 `Observable` 并对其发射进行操作，下一个操作符订阅当前操作符的发射），那么将会非常混乱。
- en: To resolve this scenario, ReactiveX provided us with scheduler and scheduling
    operators. By using them, thread management becomes easy, as the synchronization
    is almost automatic and there's no shared data between threads (as a basic property
    of functional programming, thus functional reactive programming).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个场景，ReactiveX 为我们提供了调度器和调度操作符。通过使用它们，线程管理变得简单，因为同步几乎是自动的，并且线程之间没有共享数据（作为函数式编程的基本属性，因此是函数式响应式编程）。
- en: Now that we have got some hands on the ideas behind concurrency, we can move
    forward with implementing concurrency using RxKotlin.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了并发背后的理念，我们可以继续使用 RxKotlin 来实现并发。
- en: What is a scheduler?
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是调度器？
- en: In ReactiveX, the heart of concurrency lies in schedulers. As I have already
    mentioned, by default, the Observable and the chain of operators applied to it
    will do the work on the same thread where subscribe is called, and the thread
    will be blocked until Observer receives the `onComplete` or `onError` notification.
    We can use schedulers to change this behavior.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ReactiveX 中，并发的核心在于调度器。正如我已经提到的，默认情况下，`Observable` 和应用于它的操作符链将在调用 `subscribe`
    的同一线程上执行工作，并且线程将被阻塞，直到观察者收到 `onComplete` 或 `onError` 通知。我们可以使用调度器来改变这种行为。
- en: A scheduler can be thought of as a thread pool, from which ReactiveX can pool
    a thread and execute its task on it. It's basically an abstraction over multithreading
    and concurrency, making the implementation of concurrency a lot easier in ReactiveX.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 调度器可以被视为一个线程池，ReactiveX 可以从中池化一个线程并在其上执行任务。它基本上是多线程和并发的抽象，使得在 ReactiveX 中实现并发变得更加容易。
- en: Types of scheduler
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调度器类型
- en: 'As an abstraction layer for thread pool management, the scheduler API provides
    you with some pre-composed scheduler. It also allows you to create a new user-defined
    scheduler. Let''s take a look at the available scheduler types:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 作为线程池管理的抽象层，调度器 API 为你提供了一些预定义的调度器。它还允许你创建一个新的用户定义的调度器。让我们看看可用的调度器类型：
- en: '`Schedulers.io()`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Schedulers.io()`'
- en: '`Schedulers.computation()`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Schedulers.computation()`'
- en: '`Schedulers.newThread()`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Schedulers.newThread()`'
- en: '`Schedulers.single()`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Schedulers.single()`'
- en: '`Schedulers.trampoline()`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Schedulers.trampoline()`'
- en: '`Schedulers.from()`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Schedulers.from()`'
- en: We will look into their definitions and their prescribed use-cases, but first,
    let's get started with some code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨它们的定义和预定的使用场景，但首先，让我们从一些代码开始。
- en: 'We will start with a usual example without a scheduler, and then we will implement
    a scheduler in the same example to observe the difference, as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从没有调度器的常规示例开始，然后在这个示例中实现一个调度器来观察差异，如下所示：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this program, we used two `Observable`; we used delay inside their subscription
    to simulate long running tasks.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们使用了两个 `Observable`；我们在它们的订阅中使用了延迟来模拟长时间运行的任务。
- en: 'The following output displays the expected result. The Observers run one after
    another:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的输出显示了预期的结果。观察者一个接一个地运行：
- en: '![](img/5c3babe4-c0e1-48dd-a586-a38386fcf3af.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5c3babe4-c0e1-48dd-a586-a38386fcf3af.jpg)'
- en: 'The total execution time of this program would be around 3,100 milliseconds
    (as the delay is performed before printing), while the thread pool was sitting
    idle in between. Using scheduler, this time can be significantly reduced. Let''s
    get it done:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的总执行时间大约为 3,100 毫秒（因为延迟是在打印之前执行的），而线程池在这期间处于空闲状态。使用调度器，这个时间可以显著减少。让我们来完成它：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This program contains three new lines as compared to the previous one. On comment
    `(1)` and `(2)`, `subscribeOn(Schedulers.computation())`, and `runBlocking { delay(2100)
    }` on comment `(3)`. We will inspect the significance of those lines after taking
    a look at the output:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一个程序相比，此程序包含三条新行。在注释`(1)`和`(2)`处，`subscribeOn(Schedulers.computation())`，以及在注释`(3)`处的`runBlocking
    { delay(2100) }`。在查看输出后，我们将检查这些行的意义：
- en: '![](img/46462863-a4a6-4db2-a7d4-eb39eb80ba97.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46462863-a4a6-4db2-a7d4-eb39eb80ba97.png)'
- en: As the output shows, `Observable` in this example is emitted concurrently. The
    line of the `subscribeOn(Schedulers.computation())` code enabled both downstreams
    to subscribe to the `Observable` in a different (background) thread, which influenced
    concurrency. You should already be used to it with using it `runBlocking { delay(2100)
    }` on comment `(3)`; we use it to keep the program alive. As all the operations
    are being performed in different threads, we need to block the main thread to
    keep the program alive. However, notice the time duration of the delay we passed;
    it's only 2,100 milliseconds, and the output confirms both the subscriptions processed
    all the emissions. So, it's clear, we saved 1,000 milliseconds right away.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如输出所示，此例中的`Observable`是并发发出的。`subscribeOn(Schedulers.computation())`代码的这一行使得两个下游都可以在不同的（后台）线程中订阅`Observable`，这影响了并发性。你应该已经习惯了在注释`(3)`中使用`runBlocking
    { delay(2100) }`；我们使用它来保持程序运行。由于所有操作都在不同的线程中执行，我们需要阻塞主线程以保持程序运行。然而，请注意我们传递的延迟时间；它仅为2,100毫秒，输出确认了两次订阅都处理了所有发射。因此，很明显，我们立即节省了1,000毫秒。
- en: Let's now continue discussions on different types of schedulers available—we
    will then dive into different ways to use them.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续讨论可用的不同类型的调度器——然后我们将深入了解如何使用它们的不同方法。
- en: Schedulers.io() - I/O bound scheduler
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Schedulers.io() - I/O密集型调度器
- en: '`Schedulers.io()` provides us with I/O bound threads. To be more accurate,
    `Schedulers.io()` provides you with `ThreadPool`, which can create an unbounded
    number of worker threads that are meant to be performing I/O bounded tasks.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`Schedulers.io()`为我们提供了I/O密集型线程。更准确地说，`Schedulers.io()`为你提供了一个`ThreadPool`，它可以创建无限数量的工作线程，这些线程旨在执行I/O密集型任务。'
- en: Now, what exactly does the I/O bounded thread mean? And why are we calling it
    I/O bounded? Let's inspect.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，I/O密集型线程究竟是什么意思？为什么我们称之为I/O密集型？让我们来检查一下。
- en: All the threads in this pool are blocking and are meant to perform more I/O
    operations than computationally intense tasks, giving less load to CPUs, but may
    take longer due to waiting for I/O. By I/O operations, we mean interactions with
    file systems, databases, services, or I/O devices.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此池中的所有线程都是阻塞的，并且旨在执行比计算密集型任务更多的I/O操作，从而减轻CPU的负载，但由于等待I/O，可能会花费更长的时间。通过I/O操作，我们指的是与文件系统、数据库、服务或I/O设备的交互。
- en: We should be cautious about using this scheduler as it can create an infinite
    number of threads (until the memory lasts) and can cause `OutOfMemory` errors.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在使用此调度器时应谨慎，因为它可以创建无限数量的线程（直到内存耗尽），并可能导致`OutOfMemory`错误。
- en: Schedulers.computation() - CPU bound schedulers
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Schedulers.computation() - CPU密集型调度器
- en: The `Schedulers.computation()` is probably the most useful scheduler for programmers.
    It provides us with a bounded thread-pool, which can contain a number of threads
    equal to the number of available CPU cores. As the name suggests, this scheduler
    is meant for CPU intense works.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`Schedulers.computation()`可能是对程序员最有用的调度器。它为我们提供了一个有界线程池，该线程池可以包含与可用CPU核心数量相等的线程数。正如其名称所暗示的，此调度器旨在用于CPU密集型工作。'
- en: We should use this scheduler only for CPU—intense tasks and not for any other
    cause. The reason is that the threads in this scheduler keeps the CPU cores busy,
    and may slow down the entire application if it is used for I/O bound or any other
    tasks that involves non-computational tasks.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该只将此调度器用于CPU密集型任务，而不用于任何其他原因。原因是此调度器中的线程会保持CPU核心忙碌，如果用于I/O密集型或涉及非计算任务的任何其他任务，可能会减慢整个应用程序的运行速度。
- en: The main reason why we should consider `Schedulers.io()` for I/O bound tasks
    and `Schedulers.computation()` for computational purposes is that `computation()`
    threads utilize the processors better and create no more threads than the available
    CPU cores, and reuses them. While `Schedulers.io()` is unbounded, and if you schedule
    10,000 computational tasks on `io()` in parallel, then each of those 10,000 tasks
    each have their own thread and be competing for CPU incurring context switching
    costs.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该考虑使用 `Schedulers.io()` 来处理 I/O 密集型任务，以及使用 `Schedulers.computation()` 来处理计算任务的主要原因，是因为
    `computation()` 线程更好地利用了处理器，并且不会创建超过可用 CPU 核心的线程，而是重用它们。而 `Schedulers.io()` 是无界的，如果你在
    `io()` 上并行调度 10,000 个计算任务，那么每个任务都将拥有自己的线程，并竞争 CPU，从而产生上下文切换的成本。
- en: Schedulers.newThread()
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Schedulers.newThread()
- en: The `Schedulers.newThread()` provides us with a scheduler that creates a new
    thread for each task provided. While at first glance it may seem similar to `Schedulers.io()`,
    there's actually a huge difference.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`Schedulers.newThread()` 为我们提供了一个创建每个任务都分配一个新线程的调度器。虽然乍一看可能看起来与 `Schedulers.io()`
    相似，但实际上存在巨大的差异。'
- en: The `Schedulers.io()` uses a thread pool, and whenever it gets a new unit of
    work, it first looks into the thread pool to see if any idle thread is available
    to take up the task; it proceeds to create a new thread if no pre-existing thread
    is available to take up the work.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`Schedulers.io()` 使用线程池，并且每当它得到一个新的工作单元时，它首先检查线程池，看是否有空闲的线程可以承担任务；如果没有可用的现有线程来承担工作，它将创建一个新的线程。'
- en: However, `Schedulers.newThread()` doesn't even use a thread pool; instead, it
    creates a new thread for every request and forgets them forever.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`Schedulers.newThread()` 甚至不使用线程池；相反，它为每个请求创建一个新的线程，并且永远不再记住它们。
- en: In most of the cases, when you're not using `Schedulers.computation()`, you
    should consider `Schedulers.io()` and should predominantly avoid using `Schedulers.newThread()`;
    threads are very expensive resources, you should try to avoid the creation of
    new threads as much as possible.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，当你不使用 `Schedulers.computation()` 时，你应该考虑使用 `Schedulers.io()`，并且应该主要避免使用
    `Schedulers.newThread()`；线程是非常昂贵的资源，你应该尽可能避免创建新的线程。
- en: Schedulers.single()
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Schedulers.single()
- en: The `Schedulers.single()` provides us with a scheduler that contains only one
    thread and returns the single instance for every call. Confused? Let's make it
    clear. Think of a situation where you need to execute tasks that are strongly
    sequential—`Schedulers.single()` is the best available option for you here. As
    it provides you with only one thread, every task that you enqueue here is bound
    to be executed sequentially.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`Schedulers.single()` 为我们提供了一个只包含一个线程的调度器，并为每个调用返回单个实例。困惑吗？让我们澄清一下。想象一下你需要执行强顺序的任务的情况——`Schedulers.single()`
    是你这里的最佳选择。因为它只提供给你一个线程，所以你在这里排队的每个任务都必然是顺序执行的。'
- en: Schedulers.trampoline()
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Schedulers.trampoline()
- en: '`Schedulers.single()` and `Schedulers.trampoline()` sound somewhat similar,
    both the schedulers are for sequential execution. While `Schedulers.single()`
    guarantees that all its task will run sequentially, it may run parallel to the
    thread it was called upon (if not, that thread is from `Schedulers.single()` as
    well); the `Schedulers.trampoline()` is different in that sector.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`Schedulers.single()` 和 `Schedulers.trampoline()` 听起来有些相似，这两个调度器都是用于顺序执行。虽然
    `Schedulers.single()` 保证所有任务都将顺序执行，但它可能与被调用的线程并行运行（如果不是，那么该线程也是来自 `Schedulers.single()`）；而
    `Schedulers.trampoline()` 在这一点上有所不同。'
- en: Unlike maintaining a thread to its disposal like `Schedulers.single()`, `Schedulers.trampoline()`
    queues up the task on the thread it was called on.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Schedulers.single()` 一样维护一个线程不同，`Schedulers.trampoline()` 将任务排队到被调用的线程上。
- en: So, it'll be sequential with the thread it was called upon.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，它将与被调用的线程顺序执行。
- en: 'Let''s look at some examples of `Schedulers.single()` and `Schedulers.trampoline()`
    to understand them better:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `Schedulers.single()` 和 `Schedulers.trampoline()` 的几个示例，以更好地理解它们：
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output is as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/cfd79afb-d432-441b-8621-cc726d151517.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cfd79afb-d432-441b-8621-cc726d151517.jpg)'
- en: The output clearly shows that despite the fact that both the subscriptions run
    sequentially, they run in parallel to the calling thread.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 输出清楚地显示，尽管两个订阅都是顺序执行的，但它们与调用线程并行运行。
- en: 'Now, let''s implement the same code with `Schedulers.trampoline()` and observe
    the difference:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 `Schedulers.trampoline()` 实现相同的代码，并观察差异：
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following output shows that the scheduler ran sequentially to the calling
    thread:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出显示了调度器是顺序运行到调用线程的：
- en: '![](img/d045d0b4-1881-49ec-b7a2-784db8c0e416.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d045d0b4-1881-49ec-b7a2-784db8c0e416.jpg)'
- en: Schedulers.from
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Schedulers.from
- en: So far, we've seen the default/predefined schedulers available within RxKotlin.
    However, while developing applications, you may need to define your custom scheduler.
    Keeping that scenario in mind, ReactiveX has provided you with `Schedulers.from(executor:Executor)`,
    which lets you convert any executor into a scheduler.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了 RxKotlin 中可用的默认/预定义的调度器。然而，在开发应用程序时，您可能需要定义自己的自定义调度器。考虑到这种情况，ReactiveX
    为您提供了 `Schedulers.from(executor:Executor)`，这允许您将任何执行器转换为调度器。
- en: 'Let''s look at the following example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, we've created a custom `Scheduler` from an `Executor` (for
    the sake of simplicity, we've used a standard Thread Pool Executor; you're free
    to use your own custom executor).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们从一个 `Executor`（为了简单起见，我们使用了标准的线程池执行器；您可以使用自己的自定义执行器）创建了一个自定义 `Scheduler`。
- en: On comment `(1)`, we created the executor with the `Executors.newFixedThreadPool()`
    method, on comment `(2)`, we created the `scheduler` instance with the help of
    `Schedulers.from(executor:Executor)`. We used the `scheduler` instance on comment
    `(3)`, comment `(4)`, and comment `(5)`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释 `(1)` 中，我们使用 `Executors.newFixedThreadPool()` 方法创建了执行器，在注释 `(2)` 中，我们使用
    `Schedulers.from(executor:Executor)` 创建了 `scheduler` 实例。我们在注释 `(3)`、`(4)` 和 `(5)`
    中使用了 `scheduler` 实例。
- en: 'Here is the output:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果：
- en: '![](img/44fd479d-be13-44bf-ad1c-3fc16bd4f185.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/44fd479d-be13-44bf-ad1c-3fc16bd4f185.jpg)'
- en: How to use schedulers – subscribeOn and observeOn operators
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使用调度器 - `subscribeOn` 和 `observeOn` 操作符
- en: Now that we have gained some grip on what schedulers are, how many types of
    schedulers are available, and how to create a `scheduler` instance, we will focus
    on how to use schedulers.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对调度器有了基本的了解，知道了有多少种类型的调度器，以及如何创建 `scheduler` 实例，我们将关注如何使用调度器。
- en: There are basically two operators that help us implement schedulers. Up until
    now, in this chapter, we've used the `subscribeOn` operator in all the examples
    with a scheduler; however, there's another operator—`observeOn`. We will now focus
    on these two operators, learning how they work, and how they differ.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上有两个操作符帮助我们实现调度器。到目前为止，在本章中，我们在所有示例中都使用了带有调度器的 `subscribeOn` 操作符；然而，还有一个操作符——`observeOn`。我们现在将专注于这两个操作符，学习它们是如何工作的，以及它们之间的区别。
- en: Let's start with the `subscribeOn` operator.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `subscribeOn` 操作符开始。
- en: Changing thread on subscription – subscribeOn operator
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在订阅时更改线程 - `subscribeOn` 操作符
- en: 'We need to understand how the `Observable` works before delving any further
    in how to use scheduler. Let''s take a look at the following graphics:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解如何使用调度器之前，我们需要理解 `Observable` 的工作原理。让我们看看以下图形：
- en: '![](img/6dd696f1-ad49-4bcf-92a0-13d1d2b4c943.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6dd696f1-ad49-4bcf-92a0-13d1d2b4c943.jpg)'
- en: As the preceding image depicts, it's the threads that are responsible for carrying
    items from the source all the way to the Subscriber through operators. It may
    be a single thread throughout the subscription, or it may even be different threads
    at different levels.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，是线程负责通过操作符将项目从源传递到订阅者。在整个订阅过程中，这可能是一个线程，或者在不同级别上可能是不同的线程。
- en: By default, the thread in which we perform the subscription is the responsible
    of bringing all the emissions down to the Subscriber, unless we instruct it otherwise.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，我们执行订阅的线程负责将所有排放项传递给订阅者，除非我们指示它这样做。
- en: 'Let''s take a look at the code example first:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看代码示例：
- en: '[PRE5]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It's a simple RxKotlin code example; we are creating `Observable`, mapping it,
    and then subscribing to it. The only difference here is that I've printed the
    `Thread` name inside both the `map` and the `subscribe` lambdas.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的 RxKotlin 代码示例；我们创建了一个 `Observable`，对其进行映射，然后订阅它。这里唯一的区别是我已经在 `map` 和
    `subscribe` 独立函数中打印了 `Thread` 名称。
- en: 'Let''s take a look at the output:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看输出结果：
- en: '![](img/baa99960-4bda-454e-be6d-66a998433fd7.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/baa99960-4bda-454e-be6d-66a998433fd7.jpg)'
- en: From the output, we can determine that the main thread executes the entire subscription.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，我们可以确定主线程执行了整个订阅过程。
- en: 'The `subscribeOn` operator, as the name suggests, helps us change the thread
    of a subscription. Let''s modify the program once and take a look:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`subscribeOn` 操作符，正如其名所示，帮助我们改变订阅的线程。让我们修改一次程序并查看结果：'
- en: '[PRE6]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The entire program remains the same, except that, in between `map` and `subscribe`,
    we used the `subscribeOn` operator at comment `(1)`. Let''s check the output:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 整个程序保持不变，只是在 `map` 和 `subscribe` 之间，我们在注释 `(1)` 中使用了 `subscribeOn` 操作符。让我们查看输出结果：
- en: '![](img/440f9c65-9f1a-4eaf-b124-21e413b55ab2.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/440f9c65-9f1a-4eaf-b124-21e413b55ab2.jpg)'
- en: The `subscribeOn` operator changes the thread for the entire subscription; you
    can use it wherever you want in the subscription flow. It will change the thread
    once and for all.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`subscribeOn`操作符会改变整个订阅的线程；你可以在订阅流程的任何位置使用它。它将一次改变线程，并永久改变。'
- en: Observing on a different thread – observeOn operator
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在不同的线程上进行观察——`observeOn`操作符
- en: While `subscribeOn` looks like an awesome gift from heaven, it may not be suited
    in some cases. For example, you may want to do computations on the `computation`
    threads and display the results from the `io` threads, which actually you should
    do. The `subscribeOn` operator requires a companion for all these things; while
    it'll specify the thread for the entire subscription, it requires its companion
    to specify threads for specific operators.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`subscribeOn`看起来像是来自天堂的神奇礼物，但在某些情况下可能并不适用。例如，你可能想在`computation`线程上进行计算，并从`io`线程显示结果，这实际上是你应该做的。`subscribeOn`操作符需要所有这些事情的伴侣；虽然它将指定整个订阅的线程，但它需要其伴侣来指定特定操作符的线程。
- en: The perfect companion to the `subscribeOn` operator is the `observeOn` operator.
    The `observeOn` operator specifies the scheduler for all the operators called
    after it.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`subscribeOn`操作符的完美伴侣是`observeOn`操作符。`observeOn`操作符指定了其后所有调用操作符的调度器。'
- en: 'Let''s modify our program with `observeOn` to perform the `map` operation in
    the `Schedulers.computation()` and receive the result of the subscription (`onNext`)
    in the `Schedulers.io()`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过`observeOn`修改我们的程序，以在`Schedulers.computation()`中执行`map`操作，并在`Schedulers.io()`中接收订阅的结果（`onNext`）：
- en: '[PRE7]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following output clearly shows we''re successful in achieving our objective:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出清楚地表明我们成功地实现了我们的目标：
- en: '![](img/10acaff9-5525-4572-8318-425df7c4a0de.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/10acaff9-5525-4572-8318-425df7c4a0de.jpg)'
- en: So, what did we do? We specified the `computation` threads for the `map` operator
    by calling `observeOn(Schedulers.computation())` just before it, and called `observeOn(Schedulers.io())`
    before subscribe to switch to `io` threads to receive the results.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们做了什么呢？我们在`map`操作符之前通过调用`observeOn(Schedulers.computation())`来指定`computation`线程，并在订阅之前调用`observeOn(Schedulers.io())`以切换到`io`线程来接收结果。
- en: In this program, we did a context switch; we exchanged data with threads and
    implemented communication in between threads with such an ease, with merely 7-8
    lines of code—that's the abstraction schedulers provides us with.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们进行了上下文切换；我们轻松地与线程交换数据，并通过仅仅7-8行代码实现了线程间的通信——这就是调度器为我们提供的抽象。
- en: Summary
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about concurrent execution and parallelism and
    how to achieve multithreading in RxKotlin. Multithreading is a necessity in today's
    app driven era, as modern users don't like to wait, or, to be blocked, you need
    to constantly switch threads to perform computations and UX operations.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了并发执行和并行性，以及如何在RxKotlin中实现多线程。在当今以应用程序驱动的时代，多线程是必要的，因为现代用户不喜欢等待，或者，为了避免阻塞，你需要不断地切换线程来执行计算和UX操作。
- en: In this chapter, you learned how schedulers in RxKotlin can help you, or, rather,
    how schedulers abstract the complexities of multithreading.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了RxKotlin中的调度器如何帮助你，或者更确切地说，调度器如何抽象出多线程的复杂性。
- en: While concurrent execution and parallelism is an essential part of modern application
    development, testing is probably the most crucial part. We cannot deliver any
    app without testing it. Agile methodology (though we are not discussing agile
    here) says we should perform testing repeatedly and with every iteration of our
    product (application) development.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然并发执行和并行性是现代应用程序开发的一个基本组成部分，但测试可能是最关键的部分。我们无法在没有测试的情况下交付任何应用程序。敏捷方法（尽管我们在这里不讨论敏捷）表示我们应该反复进行测试，并且在我们产品的（应用程序）开发的每一次迭代中都要进行测试。
- en: In the [Chapter 8](08299ee7-7cdc-4700-ae32-362b3145d26d.xhtml), *Testing RxKotlin
    Applications*, we will discuss testing. Don't dare miss it out, turn the page
    right now!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](08299ee7-7cdc-4700-ae32-362b3145d26d.xhtml)《测试RxKotlin应用程序》中，我们将讨论测试。不要错过它，现在就翻到下一页！
