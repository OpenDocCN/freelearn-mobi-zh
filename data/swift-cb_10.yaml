- en: SwiftUI and Combine Framework
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: SwiftUI 和 Combine 框架
- en: At the Apple **Worldwide Developer Conference** (**WWDC**) in 2019, Apple took
    a lot of us by surprise with the announcement of SwiftUI, a brand new **user interface**
    (**UI**) framework written from the ground up, entirely in Swift.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2019 年的 Apple **全球开发者大会**（**WWDC**）上，苹果公司宣布了 SwiftUI，这是一个全新的、从头开始用 Swift 编写的
    **用户界面**（**UI**）框架，让很多人感到惊讶。
- en: Making use of the declarative programming paradigm, SwiftUI not only offers
    a powerful way to programmatically create and design your UI but a functional
    and logical approach too.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 利用声明式编程范式，SwiftUI 不仅提供了一种强大的方式来程序化创建和设计你的 UI，还提供了一种功能性和逻辑性的方法。
- en: Alongside many other announcements at WWDC 19, Apple also announced its very
    own entry into the reactive programming stream with a new framework called **Combine**.
    Combine replaces the traditional delegate pattern most of us will be accustomed
    to in iOS and macOS development.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WWDC 19 的许多其他公告中，苹果公司还宣布了其进入响应式编程流的新框架，名为 **Combine**。Combine 替换了我们在 iOS 和
    macOS 开发中习惯使用的传统代理模式。
- en: With SwiftUI's change to the dynamics of how UI patterns are written programmatically,
    Combine is a welcome addition alongside the SwiftUI framework. In this chapter,
    we'll take a tour of the inner workings of SwiftUI and how to build our very own
    app—alongside this, we'll integrate the power of Combine to give us a truly unique
    and reactive workflow.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 SwiftUI 对 UI 模式编写程序化动态的改变，Combine 是 SwiftUI 框架的一个受欢迎的补充。在本章中，我们将深入了解 SwiftUI
    的内部工作原理以及如何构建我们自己的应用程序——同时，我们将整合 Combine 的强大功能，以提供真正独特和响应式的流程。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Declarative syntax
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明式语法
- en: Function builders, property wrappers, and opaque return types
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数构建器、属性包装器和不可见返回类型
- en: Building simple views in SwiftUI
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 SwiftUI 中构建简单视图
- en: Combine and data flow in SwiftUI
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Combine 和 SwiftUI 中的数据流
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter10](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter10)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上找到本章的代码文件，链接为 [https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter10](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter10)
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3qE2mpv](https://bit.ly/3qE2mpv)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 观看以下视频以查看代码的实际操作：[https://bit.ly/3qE2mpv](https://bit.ly/3qE2mpv)
- en: Declarative syntax
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明式语法
- en: With the introduction of SwiftUI comes a new coding paradigm called declarative
    syntax. Well, I say "new"—it's actually been around for a while; it's just something
    we've never really used in iOS or macOS development. In this section, we'll take
    a look at what exactly declarative syntax is and how it compares to the style
    of syntax we might be used to seeing already.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 SwiftUI 的引入，出现了一种新的编程范式，称为声明式语法。好吧，我说是“新的”——实际上它已经存在一段时间了；只是我们从未真正在 iOS 或
    macOS 开发中使用过。在本节中，我们将探讨声明式语法的确切含义以及它与我们已经习惯看到的语法风格的比较。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this section, you'll need the latest version of Xcode available from the
    Mac App Store.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节，你需要从 Mac App Store 获取的最新版本的 Xcode。
- en: How to do it...
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open Xcode and select **File** | **New** | **Playground**, then select ***Blank***
    in order to open a new Playground canvas to work from.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Xcode 并选择 **文件** | **新建** | **Playground**，然后选择 ***空白*** 以打开一个新的 Playground
    画布进行工作。
- en: 'Once open, add in the following syntax:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开之后，添加以下语法：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first `import` statement we've seen before and should be familiar with already.
    The next is our one for SwiftUI—pretty self-explanatory as to why we need this.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经看到过的第一个 `import` 语句，应该已经熟悉了。下一个是我们对 SwiftUI 的 `import` 语句——为什么需要它，解释得很清楚。
- en: 'Now, let''s create a view in SwiftUI by adding in the following highlighted
    code:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们通过添加以下突出显示的代码来在 SwiftUI 中创建一个视图：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: All SwiftUI views are built in a struct that conforms to the `View` type—this
    then houses another struct, which looks a bit like a computed property called
    `body`, which in turn conforms to `some View`. Inside this property—or "function
    builder", as it's known (which we'll touch on later in this chapter)—we have certain
    elements that start to make up our UI.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 SwiftUI 视图都是在符合 `View` 类型的结构体中构建的——然后它包含另一个结构体，这个结构体看起来有点像计算属性 `body`，它反过来又符合
    `some View`。在这个属性（或称为“函数构建器”，我们将在本章后面讨论）内部，我们有某些元素开始构成我们的 UI。
- en: There is a `VStack` or **vertical stack**, which will wrap all enclosing views
    "vertically" within itself. A VStack is, again, a `View.`
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个`VStack`或**垂直堆叠**，它将把所有封装的视图“垂直”地包裹在其中。VStack再次是一个`View`。
- en: Inside here, we have a `Text()` view where we set our text to be displayed.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个`Text()`视图，我们设置要显示的文本。
- en: 'If we add the following to our Playground, we''ll be able to see our SwiftUI
    in action:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们在Playground中添加以下内容，我们就能看到SwiftUI的实际应用：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: However, where does the declarative syntax come into all this? Well, it already
    has done; you've written it, right there in your struct. Let's dig a little deeper
    into how declarative syntax works.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，声明式语法在这个过程中的作用在哪里？嗯，它已经做到了；你已经在你的struct中写下了它。让我们更深入地了解声明式语法是如何工作的。
- en: How it works...
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In SwiftUI everything is made from Views, from the main container that is presented
    to the app's window, to text, a button, or even a toggle.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在SwiftUI中，一切都是由`View`组成的，从展示给应用窗口的主容器，到文本、按钮，甚至是切换器。
- en: Thinking back to how UIKit works, this theory isn't too dissimilar—most objects
    are a subclass of `UIView()`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下UIKit的工作方式，这个理论并不太相似——大多数对象都是`UIView()`的子类。
- en: The only fundamental difference is that with SwiftUI, the layout and construction
    of all this is much more visible; this is the declarative syntax coming into play.
    The best way to think about declarative syntax is in a functional and logical
    way.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的基本区别是，在SwiftUI中，所有这些布局和构建都更加可见；这是声明式语法的作用。最好以功能和逻辑的方式思考声明式语法。
- en: 'I want to vertically align items on my view:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我想在视图中垂直对齐项目：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'I then want to add a `Text` box:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我想添加一个`Text`框：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, let''s add a button:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们添加一个按钮：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Even the construction of the button is declarative itself: ***set an action***;
    ***set a label***.Everything is just... functional.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至按钮的构建本身也是声明式的：**设置一个动作**；**设置一个标签**。一切都是功能性的。
- en: 'Another way to think of this would be similar to how we would work through
    a food recipe:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种思考方式可以类似于我们处理食物食谱的方式：
- en: Chop onions.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切洋葱。
- en: Fry onions.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 炒洋葱。
- en: Add seasoning.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加调味料。
- en: And so on...
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以此类推...
- en: 'With our more traditional style of programming (or **imperative** programming,
    as it''s known), you might perform things a little differently and a little less
    logically:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们更传统的编程风格（或称为**命令式**编程，正如它所知），你可能执行的事情会有所不同，并且逻辑性会稍微差一些：
- en: Get seasoning
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取调味料
- en: Get onion
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取洋葱
- en: Peel onion
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 剥洋葱
- en: Chop onion
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切洋葱
- en: Heat pan
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 热锅
- en: And so on...
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以此类推...
- en: While with declarative syntax all the preceding steps still need to exist to
    make it work, the framework that it is written on does a lot of the work for you—we
    just simply "tell it" what to do.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用声明式语法，所有前面的步骤仍然需要存在才能使其工作，但构建它的框架为你做了很多工作——我们只是简单地“告诉它”要做什么。
- en: There's more...
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Declarative syntax has been around for a while now; you may have used it before
    without even realizing it. Let''s take a look at the following **Structured Query
    Language** (**SQL**) syntax:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式语法已经存在了一段时间；你可能在使用它之前甚至没有意识到。让我们看看以下**结构化查询语言**（**SQL**）的语法：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Notice anything familiar? That''s right: declarative syntax right there...
    give me `column1` and `column2` from a ***particular table*** where this `condition`
    is met.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到什么熟悉的东西了吗？没错：就在那里...给我从**特定表格**中的`column1`和`column2`，其中满足这个`条件`。
- en: Most recently, the declarative syntax has been making its way into even more
    UI frameworks such as Google's Flutter and, most recently, into Android's new
    Jetpack Compose, both of which use a declarative syntax style to allow developers
    and designers to build a UI.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，声明式语法已经进入甚至更多的UI框架，如Google的Flutter，以及最新的Android的新Jetpack Compose，这两个框架都使用声明式语法风格，允许开发者和设计师构建UI。
- en: We've mentioned a few times already that declarative syntax gives us a much
    more functional and logical approach to programming. They are paradigms that sit
    beneath the declarative paradigm as a whole. SQL, for example, sits within **DSL**
    (**Domain-Specific Language**), along with HTML and other markup languages.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到好几次了，声明式语法给我们提供了一个更功能性和逻辑性的编程方法。它们是作为整体声明范式之下的范式。例如，SQL位于**领域特定语言**（**DSL**）中，以及HTML和其他标记语言。
- en: See also
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Android Jetpack Compose: [https://developer.android.com/jetpack/compose](https://developer.android.com/jetpack/compose)'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Android Jetpack Compose: [https://developer.android.com/jetpack/compose](https://developer.android.com/jetpack/compose)'
- en: 'Google''s Flutter: [https://flutter.dev/](https://flutter.dev/)'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Google的Flutter: [https://flutter.dev/](https://flutter.dev/)'
- en: Function builders, property wrappers, and opaque return types
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数构建器、属性包装器和不可见返回类型
- en: SwiftUI certainly brings a lot to the table, especially as it's been built from
    the ground up using Swift at its core. This itself has a plethora of benefits,
    which include making use of some of the features we are about to cover in this
    section.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: SwiftUI确实带来了很多好处，尤其是在它完全使用Swift的核心构建时。这本身就有很多好处，包括利用我们将在本节中介绍的一些功能。
- en: Getting ready
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this section, you'll need the latest version of Xcode available from the
    Mac App Store.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这一部分，你需要从Mac App Store获取的最新版本的Xcode。
- en: How to do it...
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Continuing with our existing Playground project, let''s take another look at
    how things "stack up". We''ll start by taking another look at our VStack:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续使用我们现有的Playground项目，让我们再次看看事物是如何“堆叠”起来的。我们将首先再次审视我们的`VStack`：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here is a block of code, which in SwiftUI terms is a View to be displayed. The
    view is a vertical stack—think `UITableView`, but at the same time don't think
    `UITableView`, as it's bad practice to try to compare SwiftUI to UIKit.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一段代码，在SwiftUI术语中，这是一个要显示的视图。这个视图是一个垂直堆叠——想象一下`UITableView`，但同时不要把它和`UITableView`相比较，因为试图将SwiftUI与UIKit相比较是不好的做法。
- en: All the code sitting within our VStack will be displayed vertically and then
    presented back to the main View, but where is the logic that adds our `Text()`
    and `Button()` views to the `VStack`? There's no `item` or `row` for index (see,
    it's bad to compare this to `UITableView`); there's no `.add()` or `.append()`
    function that you would see when building an array. Everything just sits inside
    what are called **function builders**.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的代码都位于我们的`VStack`内部，将垂直显示，然后返回到主视图，但添加我们的`Text()`和`Button()`视图到`VStack`的逻辑在哪里？没有`item`或`row`用于索引（看，与`UITableView`比较是不好的）；也没有在构建数组时你会看到的`.add()`或`.append()`函数。所有的一切都位于所谓的**函数构建器**内部。
- en: 'Let''s add another in for good measure:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了增加趣味性，我们再添加一个：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code, we've added an `HStack`, which (yep, you guessed it)
    gives us a horizontal stack of Views—another function builder like before, this
    time housing a `Text()` and an `Image()` view.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们添加了一个`HStack`，正如你所猜到的，它给我们提供了一个水平堆叠的视图——另一个像之前一样的函数构建器，这次它包含了一个`Text()`和一个`Image()`视图。
- en: 'Notice how we''ve added our `HStack` function builder inside our existing VStack?
    This is like we said before: our Stacks are just Views, so our top-level VStack
    just treats it like that and our `HStack` does all the work of arranging its `Text()`
    and `Image()` views.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何在现有的`VStack`内部添加了我们的`HStack`函数构建器？正如我们之前所说的：我们的堆叠只是视图，所以顶层`VStack`只是把它当作那样处理，而`HStack`则负责安排它的`Text()`和`Image()`视图。
- en: But what is being returned here? When building Views in functions programmatically,
    you might expect to see the `return` keyword, with the return type specific to
    the object type being returned.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 但这里返回的是什么？在函数中程序性地构建视图时，你可能会期望看到`return`关键字，以及特定于返回对象类型的返回类型。
- en: 'However, with Swift 5.1, we can harness the power of **opaque return types**.
    Let''s look back at the body of our SwiftUI view:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，随着Swift 5.1的推出，我们可以利用不可见返回类型的强大功能。让我们回顾一下我们的SwiftUI视图的主体：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice the `some View` return type. This is an opaque return type and allows
    SwiftUI to return any type that conforms to the View protocol, such as `Text`,
    `Button`, `Image`, and so on. Without this, SwiftUI would not be as versatile
    in terms of allowing us to build up a view, and our view builder would simply
    not exist.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`some View`的返回类型。这是一个不可见返回类型，它允许SwiftUI返回任何符合View协议的类型，例如`Text`、`Button`、`Image`等等。没有这个，SwiftUI在允许我们构建视图方面就不会如此灵活，我们的视图构建器也将不存在。
- en: But the beauty of **o****paque return types** is that they are not SwiftUI-specific;
    they are just a natural evolution of the Swift language, again demonstrating how
    much SwiftUI has been built from the core Swift programming language.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 但不可见返回类型的美丽之处在于它们不是SwiftUI特有的；它们只是Swift语言的自然演变，再次证明了SwiftUI是如何从核心Swift编程语言构建起来的。
- en: 'Another thing we see here is the omission of the `return` keyword. Again, a
    new feature introduced in Swift 5.1: our SwiftUI code can now interpret a final
    return type to be passed back up the View hierarchy. But what about our `HStack`
    or `VStack`? Well, as these are **function builders**, they are not being returned
    back as such; it is more that they are being added to the Stack, which then, in
    turn, is passed back up.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们看到的另一个特点是省略了`return`关键字。再次强调，这是Swift 5.1中引入的新特性：我们的SwiftUI代码现在可以解释一个最终的返回类型，并将其传递回视图层次结构。那么我们的`HStack`或`VStack`呢？嗯，因为这些是**函数构建器**，它们不会被作为返回值返回；更多的是它们被添加到栈中，然后栈再向上传递。
- en: 'However, there is always the possibility that you may need an `HStack` sitting
    alongside a `VStack`**,** like so:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，总有这样的可能性，你可能需要一个`HStack`与一个`VStack`并排放置**，**如下所示：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'At this point, the compiler will need a little help. Unfortunately, we can''t
    just add in a `return` keyword as we want both to be returned, so we could add
    these into another Stack—but as we don''t really need one that would be unnecessary,
    so we simply wrap these in a `Group()` view instead:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，编译器需要一点帮助。不幸的是，我们无法简单地添加一个`return`关键字，因为我们希望两者都返回，所以我们可以将这些添加到另一个Stack中——但因为我们实际上不需要一个，所以这是不必要的，所以我们只是将这些包装在`Group()`视图中：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: A `Group` view itself is another view that can then be passed back up as `some
    View` to our body—nice!
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`Group`视图本身也是一个可以向上传递为`some View`的视图——真不错！'
- en: We're certainly getting all the ingredients together in order to make a start
    with SwiftUI, but before we get stuck in, let's take a look at another feature
    introduced in SwiftUI, again from our ever-evolving Swift programming language.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们当然正在收集所有必要的成分，以便开始使用SwiftUI，但在我们深入之前，让我们看看SwiftUI中引入的另一个特性，再次来自我们不断发展的Swift编程语言。
- en: '**Property wrappers** in SwiftUI are one of the features that really help make
    it shine, and are used for a wide variety of things. The main purpose that each
    one holds is to reduce the amount of maintenance required for your specific view.
    Let''s take a look at some of the more common ones you might use:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: SwiftUI中的**属性包装器**是真正帮助其发光的特性之一，用于广泛的各种用途。每个包装器的主要目的是减少你对特定视图所需的维护量。让我们看看你可能使用的一些更常见的例子：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`@State` allows SwiftUI to modify specific properties of specific views without
    the need to call a specific function to do so. For example, make the following
    highlighted changes to your code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`@State`允许SwiftUI在不调用特定函数的情况下修改特定视图的特定属性。例如，对你的代码进行以下突出显示的更改：'
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We've added a variable called `count` and have given this the `@State` property
    wrapper, and we now update our button click to increase the integer by `1`. Next,
    we add some logic based on the value of `count`**.**
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个名为`count`的变量，并给它赋予了`@State`属性包装器，现在我们更新了按钮点击，使整数增加`1`。接下来，我们根据`count`的值添加一些逻辑**。**
- en: By changing the value of `count` we have now bound our property that is being
    used within SwiftUI to the value and any changes that are made, thus invalidating
    the SwiftUI layout and rebuilding our view using the new value.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通过改变`count`的值，我们现在将SwiftUI中使用的属性绑定到值和任何更改，从而使SwiftUI布局无效，并使用新值重建我们的视图。
- en: Go ahead—run this in the Playground and try it out for yourself.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧——在Playground中运行它，亲自试试。
- en: '`@Binding` is another well-used property wrapper specifically used in conjunction
    with passing values to state properties that may live in another view. Let''s
    take a look at how we might do this, starting by separating out some code and
    creating another SwiftUI view. We can do this just underneath our current `MyView`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Binding`是另一个常用的属性包装器，专门用于与传递给可能存在于另一个视图中的状态属性值一起使用。让我们看看我们可能如何做到这一点，首先通过分离一些代码并创建另一个SwiftUI视图。我们可以在当前的`MyView`下面这样做：'
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we're simply just creating a SwiftUI view that returns a `Text` view,
    but this is a great way to see how easy it is to separate out specific view logic
    that you might want to work on separately (or make reusable).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是创建了一个返回`Text`视图的SwiftUI视图，但这是一种很好的方式，可以看看如何轻松地分离出你可能想要单独工作（或使其可重用）的特定视图逻辑。
- en: 'Notice here we were also using our `count` variable, although this time with
    the `@Binding` wrapper. This is because we won''t be controlling the value of
    `count` from within this view; this will be done externally back in `MyView`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在这里也使用了`count`变量，尽管这次使用了`@Binding`包装器。这是因为我们不会在这个视图中控制`count`的值；这将在`MyView`外部完成：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding highlighted code, notice we still have our `@State` variable,
    and our `Button` action is still updating this value on each press. We've also
    added in our new `ResultView`, passing in our `@State` variable and "binding"
    this to our variable in `ResultView`, thus forcing a change to that view every
    time `count` is updated. Go ahead and try it for yourself.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的高亮代码中，请注意我们仍然有我们的`@State`变量，并且我们的`Button`动作仍然在每次点击时更新这个值。我们还添加了新的`ResultView`，传递我们的`@State`变量并将其“绑定”到`ResultView`中的变量，从而在`count`更新时强制更改该视图。现在就试试吧。
- en: There's more...
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We''ve covered some of the property wrappers that you are more than likely
    to be exposed to with SwiftUI from the outset, but there are plenty more where
    they came from, some of which we''ll cover later on in this chapter, specifically
    when it comes to working with the Combine framework. However, here is a run-through
    of some of the others and what they have to offer:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了一些您在 SwiftUI 中一开始可能会遇到的属性包装器，但还有很多其他的，其中一些我们将在本章后面介绍，特别是当涉及到与 Combine
    框架一起工作时。然而，这里是一些其他属性包装器的概述以及它们能提供什么：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Think of this as a global object—sometimes you might want to keep track of certain
    things throughout your app that you might not necessarily need or feel the need
    to pass through to every view. However, it's important to know that `EnvironmentObject`
    isn't a single source of truth; it's data—it's merely referencing it from the
    source, and should the source change, `EnvironmentObject` will trigger a state
    change (which is what we want).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 将其视为一个全局对象——有时您可能想在您的应用中跟踪某些事物，而这些事物您可能并不一定需要或觉得有必要传递给每个视图。然而，重要的是要知道`EnvironmentObject`不是一个单一的真实来源；它是数据——它只是从源中引用它，如果源发生变化，`EnvironmentObject`将触发状态变化（这正是我们想要的）。
- en: 'An example of how we could use this is to create a class we want to observe,
    conforming to `ObservableObject`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个示例来创建一个我们想要观察的类，使其符合`ObservableObject`：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, reference it from anywhere in our SwiftUI project, like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以从我们的 SwiftUI 项目中的任何地方引用它，如下所示：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Another great and certainly convenient property wrapper is `@AppStorage`, used
    as a way to access data stored within `UserDefaults`. As of iOS 14, we can incorporate
    this straight into our SwiftUI views, without the need for additional logic or
    functions. Let''s take a look at how we would do this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个很棒且确实方便的属性包装器是`@AppStorage`，它用作访问存储在`UserDefaults`中的数据的方式。截至 iOS 14，我们可以直接将其集成到我们的
    SwiftUI 视图中，而无需额外的逻辑或函数。让我们看看我们如何做到这一点：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Notice here that we have a default value should there be no data already persisted.
    If we want to write to this, we simply assign the property a value:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里，如果没有已经持久化的数据，我们将有一个默认值。如果我们想写入这个值，我们只需将属性赋值：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Go ahead and try this in your Playground. If you get stuck, have a look at the
    GitHub resource to see how I did it.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的 Playgrounds 中尝试这个。如果您遇到困难，请查看 GitHub 资源以了解我是如何做到的。
- en: 'Due to the architecture of SwiftUI, there is—and will be—an ever-growing list
    of available property wrappers. We''ll cover some more later on in this chapter,
    but here are some others to be aware of:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 SwiftUI 的架构，将有一个——并且将会是一个不断增长的可用属性包装器列表。我们将在本章后面介绍更多内容，但这里有一些其他需要了解的：
- en: '`@GestureState`—Tracks the current gesture that is being performed'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@GestureState`——跟踪正在执行的手势'
- en: '`@FetchRequest`—Performs a fetch for Core Data entities'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@FetchRequest`——执行对 Core Data 实体的检索'
- en: See also
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'States: [https://developer.apple.com/documentation/swiftui/state](https://developer.apple.com/documentation/swiftui/state)'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态：[https://developer.apple.com/documentation/swiftui/state](https://developer.apple.com/documentation/swiftui/state)
- en: 'Bindings: [https://developer.apple.com/documentation/swiftui/binding](https://developer.apple.com/documentation/swiftui/binding)'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定：[https://developer.apple.com/documentation/swiftui/binding](https://developer.apple.com/documentation/swiftui/binding)
- en: Building simple views in SwiftUI
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 SwiftUI 中构建简单视图
- en: We've covered some of the fundamentals of how SwiftUI is built up from the Swift
    programming language, but it's time now to get into how we build an actual app
    in SwiftUI.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了一些从 Swift 编程语言构建 SwiftUI 的基础知识，但现在是我们深入了解如何在 SwiftUI 中构建实际应用的时候了。
- en: In this section, we'll take everything we've learned so far and apply it in
    order for us to build a list app similar to the one we created previously.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将把到目前为止所学的所有知识应用到构建一个类似于我们之前创建的应用程序列表中。
- en: Getting ready
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this section, you'll need the latest version of Xcode from the Mac App Store.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节，您需要从 Mac App Store 获取 Xcode 的最新版本。
- en: How to do it...
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Let''s get going. First, we''ll create a brand new project—in Xcode, click
    on File | **New** | **Project**. Then, select Single View App and make sure you''ve
    selected `SwiftUI` for the Interface style, just like I''ve done here:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们开始吧。首先，我们将创建一个全新的项目——在 Xcode 中，点击文件 | **新建** | **项目**。然后，选择单视图应用程序，并确保你已经选择了
    `SwiftUI` 作为界面样式，就像我这里做的那样：
- en: '![](img/579ddfcc-c33e-4c4e-bf52-9f3cd99f47ca.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/579ddfcc-c33e-4c4e-bf52-9f3cd99f47ca.png)'
- en: Figure 10.1 – Creating a new project
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – 创建新项目
- en: 'Click Next and select a location on your disk. Once that is done, the familiar
    site of Xcode should appear; however, you may notice something new. On the right-hand
    side, you''ll see the Live Window screen. Go ahead and click Resume—you should
    see the following:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“下一步”并选择你的磁盘上的一个位置。一旦完成，熟悉的 Xcode 界面应该会出现；然而，你可能注意到一些新内容。在右侧，你会看到实时窗口屏幕。点击“Resume”——你应该能看到以下内容：
- en: '![](img/ca17d0c7-67b2-47a7-8b3a-1ee0bf71ca2c.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ca17d0c7-67b2-47a7-8b3a-1ee0bf71ca2c.png)'
- en: Figure 10.2 – Xcode and Live Window screen
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – Xcode 和实时窗口屏幕
- en: 'Here, we''ve got a generated preview of our boilerplate SwiftUI code. Notice
    our `ContentView()` struct, just as we expect with its **body**. Now, look at
    the struct below it:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有一个我们样板 SwiftUI 代码的生成预览。注意我们的 `ContentView()` 结构体，正如我们预期的那样，有它的 **body**。现在，看看下面的结构体：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is our `PreviewProvider` struct, allowing us to test out our SwiftUI views
    at design time, without the need to keep rerunning the simulator and rebuilding
    our application—neat!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的 `PreviewProvider` 结构体，它允许我们在设计时测试我们的 SwiftUI 视图，而无需不断重新运行模拟器和重新构建我们的应用程序——真方便！
- en: 'Now, for our initial list, we''re going to need some mock data:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于我们的初始列表，我们需要一些模拟数据：
- en: 'Create the following struct (this can be in a new file if you want):'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下结构体（如果你愿意，可以放在一个新文件中）：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Comparing this to our `Task` model in [Chapter 8](9ce1feb3-8fca-4656-91dc-796ba77c3d07.xhtml),
    *Server-Side Swift*, it's pretty much identical in terms of properties and the
    data we want it to hold. The only difference we've had to make is for our model
    to conform to `Identifiable` and be given a unique ID—this is required by SwiftUI
    for anything that we are going to iterate around.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 将其与 [第 8 章](9ce1feb3-8fca-4656-91dc-796ba77c3d07.xhtml) 中的 `Task` 模型进行比较，*服务器端
    Swift*，在属性和我们要它持有的数据方面几乎完全相同。我们唯一需要做出的不同是让我们的模型符合 `Identifiable` 并赋予一个唯一的 ID——这是
    SwiftUI 对任何我们将迭代的内容的要求。
- en: 'Next, let''s create a little helper function for some mock data:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个用于一些模拟数据的小助手函数：
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This mock data will come in handy in SwiftUI in more than one way, but we'll
    get to that shortly. Let's hook this up to our app.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这组模拟数据在 SwiftUI 中将非常有用，但我们会很快看到。让我们将其连接到我们的应用程序。
- en: 'Back over to our `ContentView`, replace the `Hello World` text view with the
    following:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到我们的 `ContentView`，将 `Hello World` 文本视图替换为以下内容：
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Notice something about our `List()` view? That''s right: another function builder
    accepts an argument of an array of items, where the items conform to `Identifiable`.
    A variable is given back to us in the closure, representing each one of these
    items so that we can then use them inside our list builder as we see fit.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到我们的 `List()` 视图有什么特点？没错：另一个函数构建器接受一个项目数组的参数，其中项目符合 `Identifiable`。在闭包中返回一个变量给我们，代表这些项目中的每一个，这样我们就可以在列表构建器中使用它们，就像我们想要的那样。
- en: 'Here, we are just adding the description to a text view for now. If not already
    showing in the live preview, click R**esume** (sometimes this is needed in Xcode),
    and you should now see the following:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们只是暂时将描述添加到一个文本视图中。如果实时预览中没有显示，请点击 R**esume**（有时在 Xcode 中需要这样做），你现在应该能看到以下内容：
- en: '![](img/f8374630-e7d3-4000-8379-d49bbd66d0bd.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f8374630-e7d3-4000-8379-d49bbd66d0bd.png)'
- en: Figure 10.3 – Preview screen
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 – 预览屏幕
- en: Now, run this in the simulator, and you should see the exact same thing—great
    job!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在模拟器中运行这个，你应该看到完全相同的内容——做得好！
- en: 'Time for a little refactoring now, so make the following highlighted changes
    to the `ContentView`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候进行一点重构了，所以请对 `ContentView` 进行以下突出显示的更改：
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here, we''re removing our call to our mock data helper as, for production code,
    we shouldn''t be calling this in here. With this change, let''s head on over to
    `PreviewProvider` and make the following highlighted changes there:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在移除对模拟数据助手的调用，因为在生产代码中，我们不应该在这里调用它。进行此更改后，让我们转到 `PreviewProvider` 并进行以下突出显示的更改：
- en: '[PRE26]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As our `ContentView` struct now has a non-optional `tasks` variable, it requires
    us to pass some data in; here, we'll pass in our `MockHelper` function.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的 `ContentView` 结构体现在有一个非可选的 `tasks` 变量，它需要我们传递一些数据；在这里，我们将传递我们的 `MockHelper`
    函数。
- en: 'If not already showing, go ahead and resume the live preview. All being well,
    everything should be working as expected. However, let''s see what happens when
    we try to run this in the simulator—that''s right: no data.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果还没有显示，请继续进行实时预览。一切顺利的话，一切应该都按预期工作。然而，让我们看看在模拟器中运行时会发生什么——没错：没有数据。
- en: If you take a closer look at the change we just made, you'll see why we're now
    only injecting our mock data into our `ContentView` via the Preview Provider so
    that when our actual app runs, our `tasks` array is empty.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细看看我们刚才做的更改，你就会明白为什么我们现在只通过预览提供者将模拟数据注入到我们的`ContentView`中，这样当我们的实际应用程序运行时，我们的`tasks`数组是空的。
- en: But this is right; as we'll be hooking our app up to the **REpresentational
    State Transfer application** **programming interface** (**REST API**) we created
    in [Chapter 8](9ce1feb3-8fca-4656-91dc-796ba77c3d07.xhtml), *Server-Side Swift*,
    by injecting the mock data via the Preview Provider, we can continue to build
    our UI long before we build in any networking functionality, so let's continue.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 但这是正确的；因为我们将在我们的应用程序中连接到我们在第8章中创建的**表示状态传输应用程序编程接口**（**REST API**），通过预览提供者注入模拟数据，我们可以在构建任何网络功能之前继续构建我们的UI，所以让我们继续。
- en: Remember from the previous section how we refactored out our `Result` view?
    We're going to do the same again here for each row in our `List` view.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在上一节中我们如何重构了我们的`Result`视图吗？我们将在这里为`List`视图中的每一行做同样的事情。
- en: 'Create a new SwiftUI file and call it `ListRowView`, then update the boilerplate
    code to look like the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的SwiftUI文件，并将其命名为`ListRowView`，然后更新模板代码，使其看起来如下：
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'From here, head back over to `ContentView.swift` and make the following highlighted
    changes:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，回到`ContentView.swift`并做出以下突出显示的更改：
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Just like before, we're replacing our text view with the view we just created.
    Click Resume to view the live preview and see for yourself.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，我们用我们刚刚创建的视图替换了我们的文本视图。点击“继续”以查看实时预览并亲自看看。
- en: 'Now we know that''s working, we want to work on the style of our `ListRowView`
    a little, so let''s head back on over there now and start by updating the Preview
    Provider so that we can work from there:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道它正在工作，我们想要稍微修改一下`ListRowView`的样式，所以现在让我们回到那里，并首先更新预览提供者，这样我们就可以从那里开始工作：
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As you can see from the preceding highlighted code, we''ve added some mock
    data for use in our Live Preview. If this is not already showing, click Resume
    and you should see the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的突出显示代码所示，我们为我们的实时预览添加了一些模拟数据。如果这还没有显示，请点击“继续”，你应该会看到以下内容：
- en: '![](img/174b3e71-a967-4b6b-b60e-a12b0c1424ba.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/174b3e71-a967-4b6b-b60e-a12b0c1424ba.png)'
- en: Figure 10.4 – Live Preview screen with some mock data
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – 带有模拟数据的实时预览屏幕
- en: 'It works but doesn''t look much like a `List` row, but that''s fine—we just
    need to tell the Preview Provider what we intend to use it for:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 它确实可以工作，但看起来并不像`List`行，但这没关系——我们只需要告诉预览提供者我们打算用它来做什么：
- en: '[PRE30]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: It really is that simple. We just wrap it around a `List` view and SwiftUI does
    the rest, and we can now get to work on decorating our row.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 真的是很简单。我们只是将其包裹在一个`List`视图中，SwiftUI就会完成剩下的工作，现在我们可以开始装饰我们的行。
- en: 'Back in the body of our `ListRowView`, make the following highlighted changes:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`ListRowView`的主体中，进行以下突出显示的更改：
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, we've added modifiers to our views. Modifiers allow us to decorate and
    style our views just like we would with properties in UIKit, and each modifier
    is tied specifically to its type of view.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们向我们的视图添加了修饰符。修饰符允许我们装饰和样式化我们的视图，就像我们在UIKit中使用属性一样，每个修饰符都与特定类型的视图紧密相关。
- en: 'SwiftUI has gone a little further with some of the modifiers available, giving
    us a wide variety of options. Let''s take the `.font` modifier, for example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: SwiftUI在可用的一些修饰符方面又前进了一步，为我们提供了丰富的选项。以`.font`修饰符为例：
- en: '[PRE32]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The preceding fonts are all available to use straight out of the box; however,
    if you still want to specify your own font, you can do so by using the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的字体都可以直接使用；然而，如果你仍然想指定自己的字体，你可以使用以下方式：
- en: '[PRE33]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s finish off the base of our app by adding in an image based on the category
    type:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加基于类别类型的图片来完善我们应用程序的基础：
- en: '[PRE34]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Notice in the preceding code how we've now introduced an `HStack` and wrapped
    this around our current `VStack`, which allows us to now add views outside of
    our original `VStack` and align them horizontally, just like we've done with the
    `Image` view.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在前面代码中，我们如何现在引入了一个 `HStack` 并将其包裹在当前的 `VStack` 中，这使得我们现在可以添加原始 `VStack` 之外的观点，并使它们水平对齐，就像我们对
    `Image` 视图所做的那样。
- en: The use of the `Spacer()` view in SwiftUI has pushed out our two horizontal
    views (our `VStack` on the left and `Image` on the right) so that they act as
    leading and trailing views to the parent view (the body, in this case).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SwiftUI 中，`Spacer()` 视图的用法将我们的两个水平视图（左边的 `VStack` 和右边的 `Image`）推离，使它们作为父视图（在这个例子中是主体）的引导和尾随视图。
- en: How it works...
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The base of our app is now ready to hook up to an external data source, but
    first, let''s go over how modifiers work and how we can create our very own. Either
    add the following code to your `ListRowView.swift` file or create a new file (it''s
    up to you):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序的基础现在已准备好连接到外部数据源，但首先，让我们了解一下修饰符的工作原理以及我们如何创建自己的修饰符。你可以将以下代码添加到你的 `ListRowView.swift`
    文件中，或者创建一个新的文件（由你决定）：
- en: '[PRE35]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, we've created a struct called `CategoryText` that conforms to the `ViewModifier`
    protocol. In here, there is a function called `Body` for which we are setting
    the modifiers of `.font` and `.foregroundColor`. These modifiers are available
    on anything that inherits from `View`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为 `CategoryText` 的结构体，它符合 `ViewModifier` 协议。在这里，有一个名为 `Body` 的函数，我们正在设置
    `.font` 和 `.foregroundColor` 的修饰符。这些修饰符适用于从 `View` 继承的任何内容。
- en: 'Feel free to have a play around with some of the modifiers available. You could
    add the following and really give the `Category` label a little punch:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 随意尝试一些可用的修饰符。你可以添加以下内容，并真正为 `Category` 标签增添一些活力：
- en: '[PRE36]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let''s now add this to our `Text` view:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将它添加到我们的 `Text` 视图中：
- en: '[PRE37]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We''re using the `.modifier` (modifier) in order to call our custom struct;
    this is good from a readability point of view as it allows you to quickly identify
    anything that could potentially be custom as opposed to anything that is a system
    API. However, if you are like me and want it to look just right, simply create
    an extension of `View`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `.modifier`（修饰符）来调用我们的自定义结构体；从可读性的角度来看，这很好，因为它允许你快速识别任何可能被自定义的内容，而不是系统
    API 中的内容。然而，如果你像我一样，想要它看起来恰到好处，只需创建 `View` 的扩展：
- en: '[PRE38]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, use it like this:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，像这样使用它：
- en: '[PRE39]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You might have noticed we glossed over assigning a specific image to a category.
    This was with good reason, as I wanted to expand further on the use of SF Symbols
    within SwiftUI.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们略过了为某个类别分配特定图像的过程。这是出于很好的原因，因为我想要进一步探讨 SF Symbols 在 SwiftUI 中的使用。
- en: Also available for use with UIKit, SF Symbols works exceptionally well in SwiftUI,
    especially when used with modifiers like the ones we've just been playing with.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: SF Symbols 也可以与 UIKit 一起使用，在 SwiftUI 中表现异常出色，尤其是在使用我们刚刚玩过的修饰符时。
- en: 'SF Symbols are exactly what they say they are—symbols (not images), they are
    fonts and can be treated just like fonts too:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: SF Symbols 正如其名——符号（不是图像），它们是字体，也可以像字体一样处理：
- en: '[PRE40]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: No need for stretching images or **2x** or **3x** images' assets. SF Symbols
    will handle this just like having your own vector right in the app, with the added
    benefit that it's all included in the Swift API without extra assets bulking up
    your app.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 没有必要拉伸图像或**2x**或**3x**图像的资产。SF Symbols 将像处理你自己的矢量一样处理这些，额外的优点是它全部包含在 Swift API
    中，无需额外的资产来增加你的应用程序的体积。
- en: 'As the name of the symbol is just written in plain text, let''s write a little
    function that works out what we need to display:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 由于符号的名称只是以纯文本形式书写，让我们编写一个简单的函数来确定我们需要显示的内容：
- en: '[PRE41]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In an ideal world, our categories would be enums with `String` values that
    we could cast to, but for this demo, a basic string match will suffice. Now, replace
    the static text in the `Image` constructor to call this new static function:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想的世界里，我们的类别将是具有 `String` 值的枚举，我们可以将其转换为，但在这个演示中，基本的字符串匹配就足够了。现在，将 `Image`
    构造函数中的静态文本替换为调用这个新的静态函数：
- en: '[PRE42]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The only drawback is the following: is the image you want to use included in
    the library?'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的缺点是以下：你想要使用的图像是否包含在库中？
- en: With iOS 14, Apple introduced a much wider range of SF Symbols. There's even
    a Mac app you can download that catalogs all these for you in a nice **graphical
    UI** (**GUI**).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在 iOS 14 中，苹果引入了更广泛的 SF Symbols。甚至有一个你可以下载的 Mac 应用程序，它会以漂亮的**图形用户界面**（**GUI**）为你整理所有这些符号。
- en: There's more...
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We've touched on the Preview Provider a couple of times so far, but this handy
    little feature of SwiftUI does have a couple more tricks up its sleeve.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经几次提到了预览提供者，但 SwiftUI 这个小巧实用的功能还有一些其他技巧。
- en: 'By default, the device it will preview on will be that of the one currently
    selected in Xcode, but if you want to change this, simply add in the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，它将预览的设备将是当前在 Xcode 中选定的设备，但如果你想要更改这一点，只需添加以下内容：
- en: '[PRE43]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`.previewDevice`—This specifies the device you want to use—the raw value string
    matched that of an internal enum for that specific device (*basically the string
    name as you would see in the simulator list*).'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`.previewDevice`——这指定了你想要使用的设备——原始值字符串与特定设备的内部枚举值匹配（基本上是你在模拟器列表中看到的字符串名称）。'
- en: '`.previewDisplayName`—This is a custom name given for that device, as shown
    in the Live Preview window.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`.previewDisplayName`——这是为该设备提供的自定义名称，如实时预览窗口中所示。'
- en: 'The display name can come in handy for other reasons too, specifically if we
    have more than one preview running:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 显示名称在其他情况下也可能很有用，特别是如果我们有多个预览正在运行：
- en: '[PRE44]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As highlighted, we've created an additional preview to run in our Live Preview
    window, which in turn passes in different data and tests on a different device.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如同所强调的，我们创建了一个额外的预览来在我们的实时预览窗口中运行，它反过来传递不同的数据和在不同设备上的测试。
- en: With this, we could create mock data for every condition or style we wanted
    and have them previewing on all manner of device types, allowing us to test right
    there without the need to launch each version on a simulator.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们可以为每个我们想要的条件或样式创建模拟数据，并在所有类型的设备上预览，这样我们就可以直接测试，而无需在每个模拟器版本上启动。
- en: SwiftUI is no doubt powerful and, especially with the latest release of iOS
    14 at WWDC 2020, things have improved vastly, but we must not forget that at less
    than 2 years old it's still well within its infancy, and there will be more than
    one occasion when you'll need to revert back to UIKit for some form of component.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: SwiftUI 无疑非常强大，尤其是在 2020 年 WWDC 上最新发布的 iOS 14 中，事物有了极大的改进，但我们不能忘记，它还不到 2 年的历史，仍然处于婴儿期，你将不止一次需要回退到
    UIKit 来使用某些组件。
- en: Luckily for us, Apple has us ready to go with `UIViewRepresentable`, a protocol
    that we can use to harness UIKit components and return them as SwiftUI views.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Apple 已经为我们准备好了 `UIViewRepresentable` 协议，这是一个我们可以用来利用 UIKit 组件并将其作为 SwiftUI
    视图返回的协议。
- en: A good example would be `UITextView()`, currently not available in SwiftUI or
    any direct equivalent (*although with iOS 14, TextEditor for SwiftUI now does
    a lot of what we want, but is still not a direct replacement as such*).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的例子是 `UITextView()`，目前 SwiftUI 或任何直接等效功能中都没有（尽管在 iOS 14 中，SwiftUI 的 TextEditor
    现在已经做了我们想要的很多事情，但仍然不是直接替代品）。
- en: 'Create a new Swift file and call it `TextView`, then start by pasting the following
    methods in one by one:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 Swift 文件，并将其命名为 `TextView`，然后逐个粘贴以下方法：
- en: '[PRE45]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Our `UIViewRepresentable` protocol requires us to conform to certain functions
    such as `makeUIView()`, which is, in turn, responsible for instantiating the UIKit
    component we want to wrap.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `UIViewRepresentable` 协议要求我们符合某些函数，例如 `makeUIView()`，它反过来负责实例化我们想要包装的 UIKit
    组件。
- en: 'Next, add the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加以下内容：
- en: '[PRE46]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: With `updateUIView()`, we set the instance of our `UITextView` with whatever
    we want. Here, we are setting the `text` value from our variable.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `updateUIView()`，我们设置我们的 `UITextView` 实例为我们想要的任何内容。在这里，我们正在设置变量的 `text` 值。
- en: 'Next, we''ll add the `makeCoordinator()` function, which returns an instance
    of `Coordinator`, padding in our `@Binding` text field. The best way to think
    about the `Coordinator` is as a way of handling the delegate methods we might
    use for our UIKit component. Add in the following, and this should make more sense:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加 `makeCoordinator()` 函数，它返回一个 `Coordinator` 实例，填充我们的 `@Binding` 文本字段。将
    `Coordinator` 视为处理我们可能用于 UIKit 组件的代理方法的一种方式。添加以下内容，这应该会更有意义：
- en: '[PRE47]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'See how our `Coordinator` conforms to `UITextViewDelegate`, and we have `textViewDidChange()`
    in there. As our text variable being passed in is a `Binding` string, changes
    made will reflect in the delegate method being called, just as they would in UIKit:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们的 `Coordinator` 如何符合 `UITextViewDelegate` 协议，并且我们在其中实现了 `textViewDidChange()`
    方法。由于我们传递的文本变量是一个 `Binding` 字符串，所做的更改将反映在被调用的代理方法中，就像在 UIKit 中一样：
- en: '[PRE48]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In order to call this, we would simply add this as we would any other SwiftUI
    view.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调用这个功能，我们只需像添加任何其他 SwiftUI 视图一样添加它。
- en: See also
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'SF Symbols Mac app: [https://developer.apple.com/design/human-interface-guidelines/sf-symbols/overview/](https://developer.apple.com/design/human-interface-guidelines/sf-symbols/overview/)'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: SF Symbols Mac应用：[https://developer.apple.com/design/human-interface-guidelines/sf-symbols/overview/](https://developer.apple.com/design/human-interface-guidelines/sf-symbols/overview/)
- en: '`UIViewRepresentable`: [https://developer.apple.com/documentation/swiftui/uiviewrepresentable](https://developer.apple.com/documentation/swiftui/uiviewrepresentable)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIViewRepresentable`：[https://developer.apple.com/documentation/swiftui/uiviewrepresentable](https://developer.apple.com/documentation/swiftui/uiviewrepresentable)'
- en: Combine and data flow in SwiftUI
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SwiftUI中的组合和数据流
- en: For many years, the reactive programming stream has played a big part in development
    architecture in terms of iOS and macOS. You may have heard of RxSwift and RxCocoa,
    a massive community committed to the reactive stream that allows for asynchronous
    events to be processed.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，响应式编程流在iOS和macOS的开发架构中扮演了重要角色。你可能听说过RxSwift和RxCocoa，这是一个致力于响应式流的庞大社区，它允许异步事件被处理。
- en: If you are not familiar with the terminology of Rx or reactive programming,
    you may have seen the use of **Publishers**, **Subscribers**, and **Operators**
    in your code base. If you have, then you've most likely been subject to reactive
    programming at some point.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉Rx或响应式编程的术语，你可能已经在你的代码库中看到了**发布者**、**订阅者**和**操作符**的使用。如果你看到了，那么你很可能在某些时候受到了响应式编程的影响。
- en: In this section, we are going to take a look at Apple's offering for reactive
    programming, called **Combine**. Introduced alongside SwiftUI at WWDC 2019, Combine
    is the perfect accompaniment for the new layout and structure of SwiftUI (although
    not bound solely to SwiftUI). We'll take a look at how we can create a seamless
    flow of data from our REST API, right up to our UI layer.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨苹果为响应式编程提供的解决方案，称为**Combine**。在2019年WWDC上与SwiftUI一同推出，Combine是SwiftUI新布局和结构的完美伴侣（尽管不仅仅局限于SwiftUI）。我们将探讨如何从REST
    API创建无缝的数据流，直到我们的UI层。
- en: Getting ready
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this section, you'll need the latest version of Xcode from the Mac App Store
    and the project from the previous section.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节，你需要从Mac App Store获取最新版本的Xcode以及上一节的项目。
- en: How to do it...
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'First, we''ll start by updating our `Task` model to a class, by making the
    following highlighted changes:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将通过以下突出显示的更改将我们的`Task`模型更新为类：
- en: '[PRE49]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Here, we've converted our model to a class (more on that later), and have added
    a custom initializer and a couple of computed properties too.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经将我们的模型转换为类（关于这一点稍后讨论），并添加了一个自定义初始化器和几个计算属性。
- en: 'We''ve also added a variable of type `TaskResponse`, so let''s go ahead and
    create that now in a new file:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个类型为`TaskResponse`的变量，所以现在让我们在新的文件中创建它：
- en: '[PRE50]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Here, we have a basic codable response from the REST API we created earlier.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个来自我们之前创建的REST API的基本`codable`响应。
- en: 'Now, for a bit of boilerplate networking code; create a new file called `NetworkManager.swift`
    and add the following code into it:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了编写一些样板式的网络代码；创建一个名为`NetworkManager.swift`的新文件，并将以下代码添加到其中：
- en: '[PRE51]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Here, we have a basic implementation of `URLSession`, which is being passed
    a **Uniform Resource Locator** (**URL**), parsing the **JavaScript Object Notation**
    (**JSON**) response into a `Codable` object (our `TaskResponse` model). The function
    we've created has a completion handler that returns an array of our `TaskResponse`
    model, should the response and decoding be successful.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个基本的`URLSession`实现，它接收一个**统一资源定位符**（**URL**），将**JavaScript对象表示法**（**JSON**）响应解析为一个`Codable`对象（我们的`TaskResponse`模型）。我们创建的函数有一个完成处理程序，如果响应和解码成功，则返回一个`TaskResponse`模型的数组。
- en: 'Next, create a file called `TaskViewModel` and add in the following code:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为`TaskViewModel`的新文件，并添加以下代码：
- en: '[PRE52]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In the preceding code, I've highlighted some areas of interest. First is how
    we've conformed our class to `ObservableObject`—this is required as our `tasks`
    variable has the `@Published` wrapper and will be looking for changes as and when
    they occur.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我突出显示了一些感兴趣的区域。首先是我们的类如何符合`ObservableObject`——这是必需的，因为我们的`tasks`变量有`@Published`包装器，并且将根据它们发生的情况寻找变化。
- en: Next is the local URL we're passing into our `NetworkingManager`—this is our
    local instance of the REST API we created earlier.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是我们传递给`NetworkingManager`的本地URL——这是我们之前创建的REST API的本地实例。
- en: 'Now, head on back over to our `ContentView.swift` file and make the following
    highlighted changes:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到我们的`ContentView.swift`文件，进行以下突出显示的更改：
- en: '[PRE53]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We've now renamed our `tasks` variable to `model`, and this in turn has now
    created a new instance of `TaskViewModel()`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已将`tasks`变量重命名为`model`，这反过来又创建了一个新的`TaskViewModel()`实例。
- en: 'As we''ve updated a few things here, the structure of how we inject our mock
    data will need adjusting too, so make the following highlighted changes to our
    `MockHelper` function:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在这里更新了一些东西，因此我们需要调整注入模拟数据的方式的结构，因此对我们的`MockHelper`函数进行以下突出显示的更改：
- en: '[PRE54]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: As our `ContentView` now accepts an array of `TaskResponse`, we've just made
    the adjustment accordingly.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的`ContentView`现在接受`TaskResponse`数组，我们已相应地进行了调整。
- en: 'Now for the magic—from our previous project, launch our local instance of our
    Task API and add a couple of things into the database:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是魔法——从我们之前的项目中，启动我们的本地Task API实例，并在数据库中添加一些内容：
- en: '[PRE55]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'With this done, it''s time to see the magic happen. Launch the app, and if
    all''s going well, you should see something like this:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，是时候见证魔法发生了。启动应用，如果一切顺利，你应该会看到类似这样的东西：
- en: '![](img/c69127f9-fd03-4bfb-8a1c-249b6823c02b.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c69127f9-fd03-4bfb-8a1c-249b6823c02b.png)'
- en: Figure 10.5 – Launching the app
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 – 启动应用
- en: Here is a simple yet exceptionally effective demonstration of how Combine can
    and should be used within SwiftUI. Let's take a look now at how all this actually
    works.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单但非常有效的演示，说明了Combine如何在SwiftUI中使用，以及应该如何使用。现在让我们看看这一切是如何实际工作的。
- en: How it works...
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s start at the `ContentView` and work our way back:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`ContentView`开始，逐步回溯：
- en: '[PRE58]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Two things to note here—our model is that of an `@ObservedObject`, meaning any
    changes made to this model will result in an update being fired and thus forcing
    a refresh of our UI (just like we saw with `@State` earlier).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个需要注意的地方——我们的模型是`@ObservedObject`的模型，这意味着对模型所做的任何更改都将触发更新并因此强制刷新我们的UI（就像我们之前看到的`@State`一样）。
- en: 'Next, we''re instantiating our `TaskViewModel()` when the `ContentView` is
    rendered. Let''s dive into our `TaskViewModel` and see why:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在`ContentView`渲染时实例化`TaskViewModel()`。让我们深入了解`TaskViewModel`并看看为什么：
- en: '[PRE59]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We already touched earlier on our class conforming to `ObservableObject`. This
    is what allows us to use `@ObservedObject` when declaring this back over in our
    `ContentView` (we're creating a **data flow** connection, so to speak).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经提到我们的类符合`ObservableObject`。这就是我们能够在`ContentView`中声明`@ObservedObject`的原因（我们正在创建一种**数据流**连接，可以说）。
- en: Notice here that we've also added a call to our `getTasks()`function so that
    when we initialize the class (back over in `ContentView`), we'll kick off a networking
    request to get a list of tasks.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里，我们还添加了对`getTasks()`函数的调用，这样当我们在`ContentView`中初始化类时，我们将启动一个网络请求以获取任务列表。
- en: 'If we now have a quick look inside our `getTasks()` function, you''ll see that
    once we get a successful response, we assign this to our `@Published tasks` variable:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在快速查看我们的`getTasks()`函数，你会看到一旦我们得到成功的响应，我们就将其分配给我们的`@Published tasks`变量：
- en: '[PRE60]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: And as soon as the variable is updated, our `Observable` object class lets anything
    listening know about a change (our `@ObservedObject` in our `ContentView`, for
    example).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦变量更新，我们的`Observable`对象类就会让任何监听者知道有变化（例如，我们的`ContentView`中的`@ObservedObject`）。
- en: If you think back to how the `UITableView` works, if there are any updates or
    changes to the data source, we then have to call `UITableView.reloadData()`manually,
    and within our UI layer.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回顾一下`UITableView`的工作方式，如果有任何更新或更改数据源，我们随后必须手动调用`UITableView.reloadData()`，并在我们的UI层中。
- en: With this approach, everything has been handled the way it should be and is
    in the right place, passing data changes from the source of truth up to the UI
    layer.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种方法，一切都被处理得恰到好处，并且处于正确的位置，将数据更改从真实来源传递到UI层。
- en: See also
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Swift Combine: [https://developer.apple.com/documentation/combine](https://developer.apple.com/documentation/combine)'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Swift Combine: [https://developer.apple.com/documentation/combine](https://developer.apple.com/documentation/combine)'
