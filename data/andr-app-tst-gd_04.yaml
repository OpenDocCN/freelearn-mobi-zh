- en: Chapter 4. Test Driven Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：测试驱动开发
- en: This chapter introduces the Test Driven Development discipline. We will start
    with a general revision and later on move to the concepts and techniques closely
    related to the Android platform.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了测试驱动开发的学科。我们将从一般复习开始，然后转向与Android平台密切相关概念和技术。
- en: This is a code intensive chapter, so be prepared to type as you read, which
    would be the best way to seize the examples provided.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个代码密集的章节，所以当你阅读时请准备好输入，这将是最有效地掌握所提供示例的方法。
- en: 'In this chapter, we:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Introduce and explain Test Driven Development
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍并解释测试驱动开发（Test Driven Development）
- en: Analyze its advantages
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析其优势
- en: Introduce a potential real life example
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍一个潜在的真实生活例子
- en: Understand requirements by writing the tests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过编写测试来理解需求
- en: Evolve through the project by applying TDD
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过应用TDD（测试驱动开发）来逐步完善项目
- en: Get the application that fully complies with the requirements
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取完全符合要求的程序
- en: Getting started with TDD
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用TDD（测试驱动开发）
- en: Briefly, Test Driven Development is the strategy of writing tests along the
    development process. These test cases are written in advance of the code that
    is supposed to satisfy them.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，测试驱动开发是在开发过程中编写测试的策略。这些测试用例是在满足它们的代码之前编写的。
- en: A single test is added, then the code needed to satisfy the compilation of this
    test and finally the full set of test cases is run to verify their results.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个单独的测试，然后编写满足这个测试编译所需的代码，最后运行完整的测试用例集以验证其结果。
- en: This contrasts with other approaches to the development process where the tests
    are written at the end when all the coding has been done.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这与其他开发过程的方法形成对比，在这些方法中，测试是在所有编码完成后编写的。
- en: Writing the tests in advance of the code that satisfies them has several advantages.
    First, is that the tests are written in one way or another, while if the tests
    are left till the end it is highly probable that they are never written. Second,
    developers take more responsibility for the quality of their work.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写满足它们的代码之前编写测试有几个优点。首先，测试无论如何都会被编写，而如果测试留到最后，它们很可能永远不会被编写。其次，开发者对他们的工作质量承担更多的责任。
- en: Design decisions are taken in single steps and finally the code satisfying the
    tests is improved by refactoring it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 设计决策是分步骤进行的，最后通过重构来改进满足测试的代码。
- en: 'This UML activity diagram depicts the Test Driven Development to help us understand
    the process:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个UML活动图描绘了测试驱动开发，以帮助我们理解这个过程：
- en: '![Getting started with TDD](img/3500OS_04_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![开始使用TDD](img/3500OS_04_01.jpg)'
- en: The following sections explain the individual activities depicted in this activity
    diagram.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分解释了活动图中描述的各个活动。
- en: Writing a test case
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写测试用例
- en: We start our development process with writing a test case. This apparently simple
    process will put some machinery to work inside our heads. After all, it is not
    possible to write some code, test it or not, if we don't have a clear understanding
    of the problem domain and its details. Usually, this step will get you face to
    face with the aspects of the problem you don't understand, and you need to grasp
    if you want to model and write the code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的开发过程从编写一个测试用例开始。这个看似简单的过程将在我们的大脑中启动一些机制。毕竟，如果我们没有对问题域及其细节有清晰的理解，就不可能编写一些代码，无论是否进行测试。通常，这一步会让你直面你不理解的问题方面，如果你想要建模和编写代码，你需要掌握这些。
- en: Running all tests
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行所有测试
- en: Once the test is written the obvious following step is to run it, altogether
    with other tests we have written so far. Here, the importance of an IDE with built-in
    support of the testing environment is perhaps more evident than in other situations
    and this could cut the development time by a good fraction. It is expected that
    firstly, our test fails as we still haven't written any code!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦编写了测试，接下来的明显步骤就是运行它，连同我们迄今为止编写的其他测试。在这里，具有内置测试环境支持的IDE的重要性可能比其他情况下更为明显，这可能会大大减少开发时间。预期的是，首先，我们的测试会失败，因为我们还没有编写任何代码！
- en: To be able to complete our test, we usually write additional code and take design
    decisions. The additional code written is the minimum possible to get our test
    to compile. Consider here that not compiling is failing.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够完成我们的测试，我们通常需要编写额外的代码并做出设计决策。所编写的额外代码是最小的，以便让我们的测试能够编译。请考虑这里，如果不能编译就是失败。
- en: When we get the test to compile and run, if the test fails then we try to write
    the minimum amount of code necessary to make the test succeed. This may sound
    awkward at this point but the following code example in this chapter will help
    you understand the process.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编译并运行测试时，如果测试失败，我们就尝试编写最少的代码来使测试通过。这一点在此处可能听起来有些奇怪，但本章中的以下代码示例将帮助您理解这个过程。
- en: Optionally, instead of running all tests again you can just run the newly added
    test first to save some time as sometimes running the tests on the emulator could
    be rather slow. Then run the whole test suite to verify that everything is still
    working properly. We don't want to add a new feature by breaking an existing one.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，您不必再次运行所有测试，只需先运行新添加的测试以节省时间，因为有时在模拟器上运行测试可能会相当慢。然后运行整个测试套件以验证一切是否仍然正常工作。我们不希望通过破坏现有功能来添加新功能。
- en: Refactoring the code
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构代码
- en: When the test succeeds, we refactor the code added to keep it tidy, clean, and
    minimal.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试成功时，我们重构添加的代码以保持其整洁、干净和最小化。
- en: We run all the tests again, to verify that our refactoring has not broken anything
    and if the tests are again satisfied, and no more refactoring is needed we finish
    our task.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次运行所有测试，以验证我们的重构没有破坏任何东西，如果测试再次满足，并且不再需要重构，我们就完成我们的任务。
- en: Running the tests after refactoring is an incredible safety net which has been
    put in place by this methodology. If we made a mistake refactoring an algorithm,
    extracting variables, introducing parameters, changing signatures or whatever
    your refactoring is composed of, this testing infrastructure will detect the problem.
    Furthermore, if some refactoring or optimization could not be valid for every
    possible case we can verify it for every case used by the application and expressed
    as a test case.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在重构后运行测试是这种方法中设置的一个令人难以置信的安全网。如果我们重构算法时犯了错误，提取变量、引入参数、更改签名或无论您的重构由什么组成，这个测试基础设施都会检测到问题。此外，如果某些重构或优化不能适用于所有可能的情况，我们可以验证它适用于应用程序使用的每个案例，并作为测试用例表达。
- en: What is the advantage?
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优势是什么？
- en: 'Personally, the main advantage I''ve seen so far is that you focus your destination
    quickly and is much difficult to divert implementing options in your software
    that will never be used. This implementation of unneeded features is a wasting
    of your precious development time and effort. And as you may already know, judiciously
    administering these resources may be the difference between successfully reaching
    the end of the project or not. Probably, Test Driven Development could not be
    indiscriminately applied to any project. I think that, as well as any other technique,
    you should use your judgment and expertise to recognize where it can be applied
    and where not. But keep this in mind: **there are no silver bullets**.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 个人来说，我迄今为止看到的主要优势是您可以快速集中精力，并且很难在软件中实现那些永远不会使用的实现选项。这种不必要的功能的实现是对您宝贵的发展时间和精力的浪费。而且正如您可能已经知道的，明智地管理这些资源可能是成功完成项目或失败的区别。可能，测试驱动开发不能无差别地应用于任何项目。我认为，就像任何其他技术一样，您应该使用您的判断力和专业知识来识别它可以在哪里应用，在哪里不能。但请记住：**没有银弹**。
- en: The other advantage is that you always have a safety net for your changes. Every
    time you change a piece of code, you can be absolutely sure that other parts of
    the system are not affected as long as there are tests verifying that the conditions
    haven't changed.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个优势是您始终有一个安全网来保护您的更改。每次您更改一段代码时，您都可以绝对确信，只要存在测试来验证条件没有改变，系统的其他部分就不会受到影响。
- en: Understanding the requirements
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解需求
- en: To be able to write a test about any subject, we should first understand the
    Subject under test.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够编写关于任何主题的测试，我们首先应该理解要测试的主题。
- en: We also mentioned that one of the advantages is that you focus your destination
    quickly instead of revolving around the requirements.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还提到，优势之一是您可以快速集中精力，而不是围绕需求旋转。
- en: Translating requirements into tests and cross referencing them is perhaps the
    best way to understand the requirements, and be sure that there is always an implementation
    and verification for all of them. Also, when the requirements change (something
    that is very frequent in software development projects), we can change the tests
    verifying these requirements and then change the implementation to be sure that
    everything was correctly understood and mapped to code.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 将需求转换为测试并交叉引用可能是理解需求、确保所有需求都有实现和验证的最好方法。此外，当需求发生变化（在软件开发项目中这是非常常见的情况）时，我们可以更改验证这些需求的测试，然后更改实现以确保所有内容都被正确理解并映射到代码中。
- en: Creating a sample project—the Temperature Converter
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个示例项目——温度转换器
- en: Our examples will revolve around an extremely simple Android sample project.
    It doesn't try to show all the fancy Android features but focuses on testing and
    gradually building the application from the test, applying the concepts learned
    before.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例将围绕一个极其简单的Android示例项目。它并不试图展示所有花哨的Android功能，而是专注于测试，并从测试开始逐步构建应用程序，应用之前学到的概念。
- en: Let's pretend that we have received a list of requirements to develop an Android
    temperature converter application. Though oversimplified, we will be following
    the steps you normally would to develop such an application. However, in this
    case we will introduce the Test Driven Development techniques in the process.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们收到了一个开发Android温度转换器应用程序的需求列表。虽然这个例子过于简化，但我们将遵循您通常开发此类应用程序的步骤。然而，在这种情况下，我们将在这个过程中引入测试驱动开发技术。
- en: The list of requirements
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需求列表
- en: Most usual than not, the list of requirements is very vague and there is a high
    number of details not fully covered.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，需求列表非常模糊，有很多细节没有完全涵盖。
- en: 'As an example, let''s pretend that we receive this list from the project owner:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们假设我们收到了项目所有者提供的这个列表：
- en: The application converts temperatures from Celsius to Fahrenheit and vice-versa
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该应用程序将温度从摄氏度转换为华氏度，反之亦然
- en: The user interface presents two fields to enter the temperatures, one for Celsius
    other for Fahrenheit
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户界面提供了两个输入温度的字段，一个用于摄氏度，另一个用于华氏度
- en: When one temperature is entered in one field the other one is automatically
    updated with the conversion
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在一个字段中输入一个温度时，另一个字段会自动更新为转换值
- en: If there are errors, they should be displayed to the user, possibly using the
    same fields
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有错误，应向用户显示，可能使用相同的字段
- en: Some space in the user interface should be reserved for the on screen keyboard
    to ease the application operation when several conversions are entered
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户界面中应预留一些空间以容纳屏幕键盘，以便在输入多个转换时简化应用程序操作
- en: Entry fields should start empty
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入字段应保持为空
- en: Values entered are decimal values with two digits after the point
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入的值是两位小数的十进制值
- en: Digits are right aligned
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字应右对齐
- en: Last entered values should be retained even after the application is paused
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使应用程序暂停后，也应保留最后输入的值
- en: User interface concept design
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户界面概念设计
- en: 'Let''s assume that we receive this conceptual user interface design from the
    User Interface Design team:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们收到了用户界面设计团队提供的这个概念用户界面设计：
- en: '![User interface concept design](img/3500_04_02.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![用户界面概念设计](img/3500_04_02.jpg)'
- en: Creating the projects
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建项目
- en: 'Our first step is to create the project. As we mentioned earlier, we are creating
    a main and a test project. The following screenshot shows the creation of the
    `TemperatureConverter` project (all values are typical Android project values):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是创建项目。正如我们之前提到的，我们正在创建一个主项目和测试项目。以下屏幕截图显示了`TemperatureConverter`项目的创建（所有值都是典型的Android项目值）：
- en: '![Creating the projects](img/3500_04_03.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![创建项目](img/3500_04_03.jpg)'
- en: When you are ready to continue you should press the **Next >** button in order
    to create the related test project.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当您准备好继续时，应按下**下一步 >**按钮以创建相关的测试项目。
- en: 'The creation of the test project is displayed in this screenshot. All values
    will be selected for you based on your previous entries:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 测试项目的创建显示在这个屏幕截图中。所有值都将根据您的先前输入为您选择：
- en: '![Creating the projects](img/3500_04_04.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![创建项目](img/3500_04_04.jpg)'
- en: Creating the TemperatureConverterActivityTests project
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建TemperatureConverterActivityTests项目
- en: 'We only have some templates in our **main project** created by the Android
    ADT plugin, such as:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的**主项目**中，只有一些由Android ADT插件创建的模板，例如：
- en: '`TemperatureConverterActivity`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TemperatureConverterActivity`'
- en: '`main.xml` layout'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main.xml` 布局'
- en: '`strings.xml` resources'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strings.xml` 资源'
- en: Other resources, like icons
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他资源，如图标
- en: 'Additionally, we have some templates created in our **test project**. The corresponding
    test packages to keep our tests separated from the main package are:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们在我们的**测试项目**中创建了一些模板。为了将我们的测试与主包分开，相应的测试包是：
- en: '`main.xml` layout'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main.xml` 布局'
- en: '`strings.xml` resources'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strings.xml` 资源'
- en: Other resources, like icons
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他资源，如图标
- en: Note
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Be very cautious and don't let the template files fool you. There's little or
    no use of these resources in the test project so to avoid confusion, you should
    delete them. If later on you discover that some tests require specific resources,
    you can add only the needed ones.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请务必谨慎，不要让模板文件迷惑你。在测试项目中这些资源几乎或完全没有用途，为了避免混淆，你应该删除它们。如果你后来发现某些测试需要特定的资源，你只能添加所需的资源。
- en: Proceed with creating the first test by selecting the main test package name
    **com.example.aatg.tc.test** in Eclipse's **Package Explorer**, and then right-click
    on it. Select **New | JUnit Test Case**.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在Eclipse的**包资源管理器**中，通过选择主测试包名**com.example.aatg.tc.test**并右键单击它来创建第一个测试。选择**新建
    | JUnit测试用例**。
- en: 'You should have a dialog like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该有一个这样的对话框：
- en: '![Creating the TemperatureConverterActivityTests project](img/3500_04_05.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![创建TemperatureConverterActivityTests项目](img/3500_04_05.jpg)'
- en: 'Here, you need to enter the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你需要输入以下内容：
- en: '| Field | Description |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 字段 | 描述 |'
- en: '| --- | --- |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **New JUnit 3 test** | JUnit 3 is the version supported by Android. Always
    use this option. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| **新的JUnit 3测试** | JUnit 3是Android支持的版本。始终使用此选项。 |'
- en: '| **Source folder:** | The default source folder for the tests. The default
    value should be fine. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| **源文件夹:** | 测试的默认源文件夹。默认值应该足够。 |'
- en: '| **Package:** | The default package for the tests. This is usually the default
    package name for your main project followed by the subpackage test. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| **包:** | 测试的默认包。这通常是你的主项目的默认包名，后面跟着子包test。 |'
- en: '| **Name:** | The name of the class for this test. The best practice here is
    to use the same class name of the class under test followed by the word Tests,
    in plural because most probably we will be hosting several tests in it. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| **名称:** | 此测试类的名称。这里的最佳实践是使用与被测试类相同的类名，后面跟着单词Tests，因为很可能会在其中托管多个测试。 |'
- en: '| **Superclass:** | We should select our superclass depending on what and how
    we are going to test. In [Chapter 3](ch03.html "Chapter 3. Building Blocks on
    the Android SDK"), *Building Blocks on the Android SDK*, we reviewed the available
    alternatives. Use it as a reference when you try to decide what superclass to
    use.In this particular case and because we are testing a single `Activity` and
    using the system infrastructure we use `ActivityInstrumentationTestCase2`. Also
    note that as `ActivityInstrumentationTestCase2` is a generic class, we need the
    template parameter as well. This is the `Activity` under test which in our case
    is `TemperatureConverterActivity`.We can ignore the warning indicating that the
    superclass does not exist for now; we will be fixing the imports soon. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| **超类:** | 我们应该根据我们将要测试的内容和方式来选择我们的超类。在[第3章](ch03.html "第3章。Android SDK的构建块")中，*Android
    SDK的构建块*，我们回顾了可用的替代方案。当你尝试决定使用哪个超类时，请将其作为参考。在这种情况下，因为我们正在测试单个`Activity`并使用系统基础设施，所以我们使用`ActivityInstrumentationTestCase2`。请注意，由于`ActivityInstrumentationTestCase2`是一个通用类，我们还需要模板参数。这是我们正在测试的`Activity`，在我们的例子中是`TemperatureConverterActivity`。现在我们可以忽略指示超类不存在的警告；我们很快就会修复导入。
    |'
- en: '| **Method stubs** | Select the method stubs you want created. If at this point
    you are not sure what you would need, then select them all, as default stubs will
    be invoking their super counterparts. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| **方法存根:** | 选择你想要创建的方法存根。如果你现在还不确定你需要什么，那么选择所有，因为默认存根将调用它们的超类对应方法。 |'
- en: '| **Do you want to add comments?** | Generates Javadoc comments for the stub
    test method.Usually, unless you have changed the default template in Code Templates,
    the generated comments will be:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '| **你想添加注释吗？** | 为存根测试方法生成Javadoc注释。通常，除非你已更改代码模板中的默认模板，否则生成的注释将是：'
- en: '[PRE0]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '|'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Class under test:** | This is the class we are testing - `TemperatureConverterActivity`
    in this case. This is the most useful in other situations where the class under
    test has been implemented already and we would be able to select the list of methods
    we would like to test. Remember that in our case we haven''t implemented the class
    yet so we will be presented with the only method that is in the Android ADT plugin
    template, which is `onCreate`. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| **测试中的类** | 这是我们要测试的类 - 在这种情况下是`TemperatureConverterActivity`。在其他情况下，当测试中的类已经实现并且我们可以选择我们想要测试的方法列表时，这最有用。记住，在我们的情况下，我们还没有实现这个类，所以我们将只看到Android
    ADT插件模板中唯一的方法，即`onCreate`。|'
- en: This situation, where the class under test has not been implemented yet and
    only the method created by the Android ADT is available, is better understood
    pressing **Next >**. Here, the list of methods available to test is presented,
    and in our case we don't have any methods implemented yet other than `onCreate`
    and the inherited methods from Activity.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况，即测试中的类尚未实现，只有Android ADT创建的方法可用，通过按下**下一步 >**可以更好地理解。在这里，展示了可用于测试的方法列表，在我们的例子中，除了`onCreate`和从Activity继承的方法外，我们还没有实现任何其他方法。
- en: '![Creating the TemperatureConverterActivityTests project](img/3500_04_06.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![创建TemperatureConverterActivityTests项目](img/3500_04_06.jpg)'
- en: 'This dialog has the following components:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对话框有以下组件：
- en: '| Field | Description |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 字段 | 描述 |'
- en: '| --- | --- |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **Available methods:** | This is the list of all the methods we may want
    to test.When methods are overloaded, test names are generated accordingly to cope
    with the situation and parameter names are mangled into the test name. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| **可用方法** | 这是所有我们可能想要测试的方法的列表。当方法重载时，测试名称会相应生成以应对这种情况，参数名称会被混淆到测试名称中。|'
- en: '| **Create final method stubs** | Convenience set to add the final modifier
    to stub methods.The final modifier prevents these methods from being overridden
    by a subclass. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| **创建最终方法存根** | 便利设置以将最终修饰符添加到存根方法。最终修饰符防止子类覆盖这些方法。|'
- en: '| **Create tasks for generated test methods** | Creates a TODO comment in the
    test case. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| **为生成的测试方法创建任务** | 在测试用例中创建一个TODO注释。|'
- en: Either way, we may select `onCreate(Bundle)` to generate the `testOnCreateBundle`
    method for us, but we are leaving the selection list empty for now to avoid extra
    complexity of this simple demonstration application.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，我们都可以选择`onCreate(Bundle)`来为我们生成`testOnCreateBundle`方法，但现在我们留空选择列表以避免增加这个简单演示应用程序的额外复杂性。
- en: We now notice that our automatically generated class has some errors we need
    to fix before running. Otherwise the errors will prevent the test from running.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在注意到，我们自动生成的类有一些错误需要我们在运行之前修复。否则，这些错误将阻止测试运行。
- en: First we should add the missing imports, using the shortcut *Shift+Ctrl+O*.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们应该添加缺少的导入，使用快捷键*Shift+Ctrl+O*。
- en: 'Second, the problem we need to fix has been described before in [Chapter 3](ch03.html
    "Chapter 3. Building Blocks on the Android SDK"), *Building Blocks on the Android
    SDK* under the section *The no-argument constructor*. As this pattern dictates,
    we need to implement it:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，我们需要解决的问题在[第3章](ch03.html "第3章。Android SDK的构建块")中已经描述过，在*The no-argument
    constructor*部分下的*Building Blocks on the Android SDK*。根据这个模式，我们需要实现它：
- en: '[PRE1]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We added the no argument constructor `TemperatureConverterActivityTests()`.
    From this constructor, we invoke the constructor that takes a name as a parameter.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了无参数构造函数`TemperatureConverterActivityTests()`。从这个构造函数中，我们调用带参数名称的构造函数。
- en: Finally, in this given name constructor, we invoke the super constructor and
    set the name.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，在这个给定的无参数构造函数中，我们调用带参数的构造函数并设置名称。
- en: To verify that everything has been set up in place, you may run the tests by
    using **Run as | Android JUnit Test**. There are no tests to run yet but at least
    we can verify that the infrastructure supporting our tests is already in place.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证一切设置到位，您可以通过使用**运行方式 | Android JUnit 测试**来运行测试。目前还没有测试可以运行，但至少我们可以验证支持我们的测试的基础设施已经就绪。
- en: Creating the fixture
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建固定装置
- en: 'We can start creating our test fixture by populating the `setUp` method with
    the elements we need in our tests. Almost unavoidable, in this case, is the use
    of the `Activity` under test, so let''s prepare for the situation and add it to
    the fixture:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在`setUp`方法中填充我们测试所需的元素来开始创建我们的测试固定装置。在这种情况下，不可避免地要使用测试中的`Activity`，所以让我们为这种情况做好准备，并将其添加到固定装置中：
- en: '[PRE2]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let's create the `mActivity` field as well as the one proposed by Eclipse.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们同时创建`mActivity`字段以及Eclipse提出的字段。
- en: The `ActivityInstrumentationTestCase2.getActivity()` method has a side effect.
    If the `Activity` under test is not running, it is started. This may change the
    intention of a test if we use `getActivity()` as a simple accessor several times
    in a test and for some reason the `Activity` finishes or crashes before test completion.
    We will be inadvertently restarting the `Activity`, that is why in our tests we
    discourage the use of `getActivity()` in favor of having it in the fixture.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActivityInstrumentationTestCase2.getActivity()`方法有一个副作用。如果被测试的`Activity`没有运行，它将被启动。如果我们多次在测试中使用`getActivity()`作为简单的访问器，并且由于某种原因`Activity`在测试完成前结束或崩溃，这可能会改变测试的意图。我们将无意中重新启动`Activity`，这就是为什么在我们的测试中我们不建议使用`getActivity()`，而是将其包含在测试用例中。'
- en: Test preconditions
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试前置条件
- en: We mentioned this before and this can be identified as another pattern. It's
    very useful to test all the preconditions and be sure that our fixture has been
    created correctly.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到过，这可以被视为另一种模式。测试所有前置条件并确保我们的测试用例已正确创建是非常有用的。
- en: '[PRE3]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: That is, let's check that our fixture is composed by "not null" values.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，让我们检查我们的测试用例是否由“非空”值组成。
- en: 'We can run the tests to verify that everything is correct and green as shown
    in this screenshot:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以运行测试以验证一切是否正确且绿色，如图中所示：
- en: '![Test preconditions](img/3500_04_07.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![测试前置条件](img/3500_04_07.jpg)'
- en: Creating the user interface
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建用户界面
- en: Back to our Test Driven Development track, we need from our concise list of
    requirements that there be two entries for Celsius and Fahrenheit temperatures
    respectively. So let's add them to our test fixture.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的测试驱动开发轨道，我们需要从我们简洁的需求列表中知道，分别有两个条目用于摄氏度和华氏温度。所以让我们将它们添加到我们的测试用例中。
- en: They don't exist yet, and we haven't even started designing the user interface
    layout, but we know that there should be two entries like these for sure.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 它们目前还不存在，我们甚至还没有开始设计用户界面布局，但我们确信应该有两个这样的条目。
- en: 'This is the code you should add to the `setUp()` method:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您应该添加到`setUp()`方法中的代码：
- en: '[PRE4]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There are some important things to notice:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些重要的事情需要注意：
- en: We define the fields for our fixture using `EditText` that we should import
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`EditText`定义我们的测试用例字段，这是我们应该导入的
- en: We use previously created `mActivity` to find the `Views` by ID
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用之前创建的`mActivity`通过ID查找`Views`
- en: We use the R class for the main project, not the one in the test project
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用主项目的R类，而不是测试项目的R类
- en: Testing the existence of the user interface components
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试用户界面组件的存在
- en: 'Once we have added them to the `setUp()` method, as indicated in the previous
    section, we can check their existence in a specific test:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一小节所示，一旦我们将它们添加到`setUp()`方法中，我们就可以在特定的测试中检查它们的存在：
- en: '[PRE5]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We are not able to run the tests yet because we must fix some compilation problems
    first. We should fix the missing IDs in the R class.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前还不能运行测试，因为我们必须首先修复一些编译问题。我们应该修复R类中缺失的ID。
- en: Having created our test fixture that references elements and IDs in the user
    interface that we don't have yet, it's mandated by the Test Driven Development
    paradigm that we add the needed code to satisfy our tests. The first thing we
    should do is get it to compile at least, so if we have some tests testing unimplemented
    features they will fail.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了引用用户界面中尚未存在的元素和ID的测试用例后，测试驱动开发范式要求我们添加必要的代码以满足我们的测试。我们首先应该做的是至少让它编译通过，所以如果我们有一些测试正在测试未实现的功能，它们将会失败。
- en: Getting the IDs defined
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义ID
- en: Our first stop would be to have the IDs for the user interface elements defined
    in the `R` class so the errors generated by referencing undefined constants `com.example.aatg.tc.R.id.celsius`
    and `com.example.aatg.tc.R.id.fahrenheit` go away.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步应该是让用户界面元素的ID在`R`类中定义，这样引用未定义常量`com.example.aatg.tc.R.id.celsius`和`com.example.aatg.tc.R.id.fahrenheit`产生的错误就会消失。
- en: You, as an experienced Android developer, know how to do it. I'll give you a
    refresher anyway. Open the `main.xml` layout in the layout editor and add the
    required user interface components to get something that resembles the design
    previously introduced in the section *User Interface concept design*.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您作为一位经验丰富的Android开发者，知道如何做。无论如何，我会给您一个复习。在布局编辑器中打开`main.xml`布局，并添加所需用户界面组件以获得类似于在*用户界面概念设计*部分中先前引入的设计。
- en: '[PRE6]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Doing so we get our tests to compile. Running them we get the following results:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做可以使我们的测试编译通过。运行它们，我们得到以下结果：
- en: '`testPreconditions` succeeded'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testPreconditions` 测试成功'
- en: '`testHasInputFields` succeeded'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testHasInputFields` 测试成功'
- en: Everything is green now
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在一切正常
- en: This clearly means that we are on track with applying TDD.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这清楚地表明我们在应用TDD方面进展顺利。
- en: You may also have noticed that we added some decorative and non functional items
    to our user interface that we are not testing, mainly to keep our example as simple
    as possible. In a real case scenario you may want to add tests for these elements
    too.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能也注意到了，我们在用户界面中添加了一些装饰性和非功能性项目，这些项目我们并未进行测试，主要是为了使我们的示例尽可能简单。在实际场景中，您可能也想对这些元素进行测试。
- en: Translating requirements to tests
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将需求转换为测试
- en: Tests have a double feature. They verify the correctness of our code but sometimes,
    and more prominently in TDD, they help us understand the design and digest what
    we are implementing. To be able to create the tests, we need to understand the
    problem we are dealing with and if we don't, we should at least have a rough understanding
    of the problem to allow us to handle it.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 测试有两个特性。它们验证我们代码的正确性，但有时，尤其是在TDD中，它们帮助我们理解设计和消化我们正在实现的内容。为了能够创建测试，我们需要理解我们正在处理的问题，如果我们不了解，我们至少应该有一个对该问题的粗略理解，以便我们能够处理它。
- en: Many times, the requirements behind the user interface are not clearly expressed
    and you should be able to understand them from the schematic UI design. If we
    pretend that this is the case, then we can grasp it by writing our tests first.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 许多时候，用户界面的背后需求并没有明确表达，您应该能够从UI设计图解中理解它们。如果我们假设这是情况，那么我们可以通过先编写测试来掌握它。
- en: Empty fields
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空字段
- en: 'From one of our requirements, we get: Entry fields should start empty.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的一个需求中，我们得到：输入字段应从空开始。
- en: 'To express this in a test we can write:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在测试中表达这一点，我们可以编写：
- en: '[PRE7]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we simply compare the initial contents of the fields against the empty
    string.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们只是将字段的初始内容与空字符串进行比较。
- en: Not very surprisingly, we find that the test fails on execution. We forgot to
    clear the initial contents of the fields and they are not empty. Even though we
    haven't added any value to the `android:text` property of these fields, the ADT
    plugin layout editor adds some default values. Thus removing the default values
    from `android:text="@~+id/EditText01"` and `android:text="@+id/EditText02"` will
    force starting with empty temperature fields. These values may have been added
    by the ADT plugin itself or maybe by you when entering properties.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 并不出奇，我们发现测试在执行时失败了。我们忘记清除字段的初始内容，它们并不是空的。即使我们没有向这些字段的 `android:text` 属性添加任何值，ADT插件布局编辑器也会添加一些默认值。因此，从
    `android:text="@~+id/EditText01"` 和 `android:text="@+id/EditText02"` 中移除默认值将强制从空温度字段开始。这些值可能是ADT插件本身添加的，或者可能是您在输入属性时添加的。
- en: On running the test again, we find that it passes. We successfully converted
    one requirement to a test and validated it by obtaining the test results.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试后，我们发现它通过了。我们成功地将一个需求转换为测试，并通过获取测试结果来验证它。
- en: View properties
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 视图属性
- en: 'Identically, we can verify other properties of the `Views` composing our layout.
    Among other things we can verify:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以验证组成我们布局的 `Views` 的其他属性。例如，我们可以验证：
- en: Fields appear on the screen as expected
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字段如预期出现在屏幕上
- en: Font sizes
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字体大小
- en: Margins
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边距
- en: Screen alignment
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 屏幕对齐
- en: 'Let''s start verifying that the fields are on the screen:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始验证字段是否显示在屏幕上：
- en: '[PRE8]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As explained before, we use an assert form here: `ViewAsserts: assertOnScreen`.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '如前所述，我们在这里使用断言形式：`ViewAsserts: assertOnScreen`。'
- en: Note
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: Static imports and how to add them to Eclipse's Content Assist was explained
    in [Chapter 3](ch03.html "Chapter 3. Building Blocks on the Android SDK"), *Building
    Blocks on the Android SDK*. If you haven't done it before, now is the time.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 静态导入和如何在Eclipse的内容辅助中添加它们在[第3章](ch03.html "第3章。Android SDK的构建块")中已解释，*Android
    SDK的构建块*。如果您之前没有这样做，现在是时候了。
- en: The `assertOnScreen` method needs an origin to start looking for the other `Views`.
    In this case, because we want to start from the top most level, we use `getDecorView(),`
    which retrieves the top-level window decor view containing the standard window
    frame and decorations, and the client's content inside.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`assertOnScreen` 方法需要一个起点来开始寻找其他 `Views`。在这种情况下，因为我们想从最高级别开始，所以我们使用 `getDecorView()`，它检索包含标准窗口框架和装饰以及客户端内容的顶级窗口装饰视图。'
- en: By running this test, we can ensure that the entry fields are on the screen
    as the UI design dictates. In some way we already knew that some Views with these
    specific IDs existed. That is, we made the fixture compile by adding the Views
    to the main layout, but we were not sure they were appearing on the screen at
    all. So, nothing else is needed but the sole presence of this test to ensure that
    the condition is not changed in the future. If we remove one of the fields for
    some reason, this test will tell us that it is missing and not complying with
    the UI design.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行这个测试，我们可以确保输入字段按照UI设计显示在屏幕上。在某种程度上，我们已知具有这些特定ID的一些`Views`存在。也就是说，我们通过将`Views`添加到主布局中来使测试用例编译，但我们不确定它们是否真的出现在屏幕上。所以，除了这个测试的唯一存在外，不需要其他任何东西来确保将来条件不会改变。如果我们出于某种原因删除了一个字段，这个测试将告诉我们它缺失并且不符合UI设计。
- en: 'Following with our list of requirements, we should test that the `Views` are
    aligned in the layout as we expect:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 按照我们的需求列表，我们应该测试`Views`在布局中对齐的方式是否符合我们的预期：
- en: '[PRE9]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We continue using asserts from `ViewAssert`—in this case, `assertLeftAligned`
    and `assertRightAligned`. These methods verify the alignment of the specified
    `Views`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续使用来自`ViewAssert`的断言——在这个例子中，`assertLeftAligned`和`assertRightAligned`。这些方法验证指定`Views`的对齐方式。
- en: The `LinearLayout` we are using by default arranges the fields in the way we
    are expecting them. Again, while we don't need to add anything to the layout,
    to satisfy the test, this will act as a guard condition.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们默认使用的`LinearLayout`以我们期望的方式排列字段。同样，虽然我们不需要向布局中添加任何东西，为了满足测试，这将作为一个保护条件。
- en: 'Once we''ve verified that they are correctly aligned, we should verify that
    they are covering the whole screen width as specified by the schematic drawing.
    In this example, it''s sufficient to verify the `LayoutParams` having the correct
    values:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们验证它们已经正确对齐，我们就应该验证它们是否覆盖了由原理图指定的整个屏幕宽度。在这个例子中，验证`LayoutParams`具有正确的值就足够了：
- en: '[PRE10]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We used a custom message to easily identify the problem in case the test fails.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用自定义消息来在测试失败时轻松识别问题。
- en: 'By running this test, we obtain the following message indicating that the test
    failed:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行这个测试，我们得到以下消息，表明测试失败：
- en: '**junit.framework.AssertionFailedError: mCelsius layout width is not MATCH_PARENT
    expected:<-1> but was:<-2>**'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**junit.framework.AssertionFailedError: mCelsius布局宽度不是MATCH_PARENT，期望<-1>但实际是<-2>**'
- en: 'This leads us to the layout definition. We must change `layout_width` to be
    `match_parent` for Celsius and Fahrenheit fields:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这引导我们到布局定义。我们必须将摄氏度和华氏度字段的`layout_width`更改为`match_parent`。
- en: '[PRE11]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Same for Fahrenheit—after the change is done, we repeat the cycle and by running
    the test again, we can verify that it is now successful.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于华氏度也是如此——更改完成后，我们重复循环，再次运行测试，可以验证它现在成功了。
- en: Our method is starting to appear. We create the test to verify a condition described
    in the requirements. If it's not met, we change the cause of the problem and running
    the tests again we verify that the latest change solves the problem, and what
    is perhaps more important is that the change doesn't break the exiting code.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的方法开始显现。我们创建测试来验证需求中描述的条件。如果没有满足，我们改变问题的原因并再次运行测试，以验证最新的更改解决了问题，也许更重要的是，这个更改并没有破坏现有的代码。
- en: 'Next, let''s verify that font sizes are as defined in our requirements:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们验证字体大小是否符合我们的要求：
- en: '[PRE12]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Retrieving the font size used by the field is enough in this case.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个情况下，获取字段使用的字体大小就足够了。
- en: The default font size is not `24px`, so we need to add this to our layout. It's
    a good practice to add the corresponding dimension to a resource file and then
    use it where it's needed in the layout. So, let's add `label_text_size` to `res/values/dimens.xml`
    with a value of `24px`. Then reference it in the `Text size` property of both
    labels, `celsius_label` and `fahrenheit_label`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 默认字体大小不是`24px`，因此我们需要将其添加到我们的布局中。将相应的尺寸添加到资源文件中，然后在布局中需要的地方使用它是一个好习惯。所以，让我们将`label_text_size`添加到`res/values/dimens.xml`中，其值为`24px`。然后在其`Text
    size`属性中引用它，对于两个标签`celsius_label`和`fahrenheit_label`。
- en: Now the test is passed.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试通过了。
- en: 'Finally, let''s verify that margins are interpreted as described in the user
    interface design:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们验证边距是否被解释为用户界面设计中所描述的那样：
- en: '[PRE13]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is a similar case as before. We need to add this to our layout. Let's add
    the margin dimension to the resource file and then use it where it's needed in
    the layout. Set the `margin` dimension in `res/values/dimens.xml` to a value of
    `6px`. Then reference it in the `Margin` property of both fields, `celsius` and
    `fahrenheit`, and in the `Left margin` of the labels.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前的情况类似。我们需要将这个添加到我们的布局中。让我们将边距维度添加到资源文件中，然后在布局中需要的地方使用它。将`margin`维度在`res/values/dimens.xml`中设置为`6px`的值。然后在其`Margin`属性中引用两个字段，即`celsius`和`fahrenheit`，以及标签的`Left
    margin`。
- en: 'One more thing that is left is the verification of the justification of the
    entered values. We will validate input shortly to allow only the permitted values
    but for now let''s just pay attention to the justification. The intention is to
    have values that are smaller than the whole field justified to the right and vertically
    centered:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的一个问题是验证输入值的合理性。我们将很快验证输入，只允许允许的值，但现在让我们只关注合理性。目的是使小于整个字段值的值右对齐并垂直居中：
- en: '[PRE14]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here we verify the gravity values as usual. However, we are using a custom message
    to help us identify the values that could be wrong. As `Gravity` class defines
    several constants whose values are better identified if expressed in hexadecimal,
    we are converting the values to this base in the message.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们像往常一样验证重力值。然而，我们使用一个自定义消息来帮助我们识别可能错误的值。由于`Gravity`类定义了几个常量，其值如果以十六进制表示则更容易识别，因此我们在消息中将值转换为这个基数。
- en: If this test is failing due to the default gravity used for the fields, then
    what is only left is to change it. Go to the layout definition and alter these
    gravity values so that the test succeeds.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个测试因为字段使用的默认重力而失败，那么唯一剩下的事情就是改变它。转到布局定义并更改这些重力值，以便测试成功。
- en: 'This is precisely what we need to add:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们需要添加的：
- en: '[PRE15]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Screen layout
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 屏幕布局
- en: We now want to verify that the requirement specifying that enough screen space
    should be reserved to display the keyboard is actually fulfilled.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在想验证指定为保留足够屏幕空间以显示键盘的要求是否实际上得到了满足。
- en: 'We can write a test like this:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写一个像这样的测试：
- en: '[PRE16]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This verifies that the actual position of the last field in the screen, which
    is `mFahrenheit`, is not lower than a suggested value.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这验证了屏幕上最后一个字段的实际位置，即`mFahrenheit`，不低于一个建议的值。
- en: We can run the tests again verifying that everything is green again.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以再次运行测试，验证一切是否再次变为绿色。
- en: Adding functionality
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加功能
- en: The user interface is in place. Now we start adding some basic functionality.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面已经就绪。现在我们开始添加一些基本功能。
- en: This functionality will include the code to handle the actual temperature conversion.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能将包括处理实际温度转换的代码。
- en: Temperature conversion
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 温度转换
- en: 'From the list of requirements we can obtain this statement: When one temperature
    is entered in one field the other one is automatically updated with the conversion.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 从需求列表中，我们可以获得这个陈述：当在一个字段中输入一个温度时，另一个字段会自动更新为转换值。
- en: 'Following our plan we must implement this as a test to verify that the correct
    functionality is there. Our test would look something like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 按照我们的计划，我们必须将其实现为一个测试来验证正确的功能是否存在。我们的测试看起来可能像这样：
- en: '[PRE17]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Firstly, as we already know, to interact with the UI changing its values we
    should run the test on the UI thread and thus is annotated with `@UiThreadTest`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，正如我们已经知道的，为了与UI交互并更改其值，我们应该在UI线程上运行测试，因此它被注解为`@UiThreadTest`。
- en: Secondly, we are using a specialized class to replace `EditText` providing some
    convenience methods like `clear()` or `setNumber()`. This would improve our application
    design.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们正在使用一个专门的类来替换`EditText`，提供一些便利方法，如`clear()`或`setNumber()`。这将改善我们的应用程序设计。
- en: Next, we invoke a converter, named `TemperatureConverter`, a utility class providing
    the different methods to convert between different temperature units and using
    different types for the temperature values.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用一个名为`TemperatureConverter`的转换器，这是一个提供在不同温度单位之间转换的不同方法的实用类，并使用不同的类型表示温度值。
- en: Finally, as we will be truncating the results to provide them in a suitable
    format presented in the user interface we should compare against a delta to assert
    the value of the conversion.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于我们将截断结果以在用户界面中以合适的格式呈现，我们应该比较一个delta来断言转换的值。
- en: Creating the test as it is will force us to follow the planned path. Our first
    objective is to add the needed code to get the test to compile and then to satisfy
    the test's needs.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这种方式创建测试将迫使我们遵循计划路径。我们的第一个目标是添加必要的代码以使测试可编译，然后满足测试的需求。
- en: The EditNumber class
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EditNumber 类
- en: In our main project, not in the tests one, we should create the class `EditNumber`
    extending `EditText` as we need to extend its functionality.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的主项目中，而不是在测试项目中，我们应该创建扩展 `EditText` 的 `EditNumber` 类，因为我们需要扩展其功能。
- en: We use Eclipse's help to create this class using **File | New | Class** or its
    shortcut in the Toolbars.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Eclipse 的帮助使用 **文件 | 新建 | 类** 或工具栏中的快捷键来创建此类。
- en: 'This screenshot shows the window that appears after using this shortcut:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 此截图显示了使用此快捷键后出现的窗口：
- en: '![The EditNumber class](img/3500_04_08.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![EditNumber 类](img/3500_04_08.jpg)'
- en: 'The following table describes the most important fields and their meaning in
    the previous screen:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 下表描述了上一屏幕中最重要的字段及其含义：
- en: '| Field | Description |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| 字段 | 描述 |'
- en: '| --- | --- |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **Source folder:** | The source folder for the newly-created class. In this
    case the default location is fine. |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| **源文件夹:** | 新创建类的源文件夹。在这种情况下，默认位置是合适的。 |'
- en: '| **Package:** | The package where the new class is created. In this case the
    default package `com.example.aatg.tc` is fine too. |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| **包:** | 新类创建的包。在这种情况下，默认包 `com.example.aatg.tc` 也是合适的。 |'
- en: '| **Name:** | The name of the class. In this case we use `EditNumber`. |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| **名称:** | 类的名称。在这种情况下，我们使用 `EditNumber`。 |'
- en: '| **Modifiers:** | Modifiers for the class. In this particular case we are
    creating a public class. |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| **修饰符:** | 类的修饰符。在这种情况下，我们正在创建一个公共类。 |'
- en: '| **Superclass:** | The superclass for the newly-created type. We are creating
    a custom `View` and extending the behavior of `EditText`, so this is precisely
    the class we select for the supertype.Remember to use **Browse..**. to find the
    correct package. |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| **超类:** | 新创建类型的超类。我们正在创建一个自定义的 `View` 并扩展 `EditText` 的行为，因此这正是我们选择的超类。记住使用
    **浏览..**. 来找到正确的包。 |'
- en: '| **Which method stubs would you like to create?** | These are the method stubs
    we want Eclipse to create for us. Selecting **Constructors from superclass** and
    **Inherited abstract methods** would be of great help.As we are creating a custom
    View we should provide the constructors that are used in different situations,
    for example when the custom View is used inside an XML layout. |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| **您想创建哪些方法占位符？** | 这些是我们希望 Eclipse 为我们创建的方法占位符。选择 **从超类创建构造函数** 和 **继承的抽象方法**
    将非常有帮助。由于我们正在创建一个自定义视图，我们应该提供在不同情况下使用的构造函数，例如当自定义视图在 XML 布局中使用时。 |'
- en: '| **Do you want to add comments?** | Some comments are added automatically
    when this option is selected. You can configure Eclipse to personalize these comments.
    |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| **您想添加注释吗？** | 当选择此选项时，会自动添加一些注释。您可以配置 Eclipse 以个性化这些注释。 |'
- en: 'Once the class is created we need to change the type of the fields first in
    our test:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了类，我们首先需要在测试中更改字段的类型：
- en: '[PRE18]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Then change any cast that is present in the tests. Eclipse will help you do
    that.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然后更改测试中存在的任何类型转换。Eclipse 将帮助您完成此操作。
- en: 'If everything goes well, there are still two problems we need to fix before
    being able to compile the test:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，在能够编译测试之前，我们还需要解决两个问题：
- en: We still don't have the methods `clear()` and `setNumber()` in `EditNumber`
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们仍然没有在 `EditNumber` 中 `clear()` 和 `setNumber()` 方法
- en: We don't have the `TemperatureConverter` utility class
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们没有 `TemperatureConverter` 工具类
- en: To create the methods we are using Eclipse's helpful actions. Let's choose **Create
    method clear() in type EditNumber**.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们正在使用的方法，我们使用 Eclipse 的有用操作。让我们选择 **在类型 EditNumber 中创建方法 clear()**。
- en: Same for `setNumber()` and `getNumber().`
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `setNumber()` 和 `getNumber()` 也是如此。
- en: Finally, we must create the `TemperatureConverter` class.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须创建 `TemperatureConverter` 类。
- en: Tip
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Be sure to create it in the main project and not in the test project.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在主项目中创建它，而不是在测试项目中。
- en: '![The EditNumber class](img/3500_04_09.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![EditNumber 类](img/3500_04_09.jpg)'
- en: Having done this, in our test select **Create method fahrenheitToCelsius in
    type TemperatureConverter**.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，在我们的测试中选择 **在类型 TemperatureConverter 中创建方法 fahrenheitToCelsius**。
- en: This fixes our last problem and leads us to a test that we can now compile and
    run.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这解决了我们最后一个问题，并使我们能够编译和运行测试。
- en: 'Surprisingly, or not, when we run the tests, they will fail with an exception:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 惊讶的是，或者不是，当我们运行测试时，它们将因异常而失败：
- en: '**09-06 13:22:36.927: INFO/TestRunner(348): java.lang.ClassCastException: android.widget.EditText**'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**09-06 13:22:36.927: INFO/TestRunner(348): java.lang.ClassCastException: android.widget.EditText**'
- en: '**09-06 13:22:36.927: INFO/TestRunner(348): at com.example.aatg.tc.test.TemperatureConverterActivityTests.setUp(TemperatureConverterActivityTests.java:41)**'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**09-06 13:22:36.927: INFO/TestRunner(348): at com.example.aatg.tc.test.TemperatureConverterActivityTests.setUp(TemperatureConverterActivityTests.java:41)**'
- en: '**09-06 13:22:36.927: INFO/TestRunner(348): at junit.framework.TestCase.runBare(TestCase.java:125)**'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**09-06 13:22:36.927: INFO/TestRunner(348): at junit.framework.TestCase.runBare(TestCase.java:125)**'
- en: That is because we updated all of our Java files to include our newly-created
    `EditNumber` class but forgot to change the XMLs, and this could only be detected
    at runtime.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们更新了所有的Java文件以包含我们新创建的`EditNumber`类，但忘记了更改XML，这只能在运行时检测到。
- en: 'Let''s proceed to update our UI definition:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续更新我们的UI定义：
- en: '[PRE19]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: That is, we replace the original `EditText` by `com.example.aatg.tc.EditNumber`
    which is a `View` extending the original `EditText`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，我们将原始的`EditText`替换为`com.example.aatg.tc.EditNumber`，这是一个扩展原始`EditText`的`View`。
- en: Now we run the tests again and we discover that all tests pass.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们再次运行测试，并发现所有测试都通过了。
- en: But wait a minute, we haven't implemented any conversion or any handling of
    values in the new `EditNumber` class and all tests passed with no problem. Yes,
    they passed because we don't have enough restrictions in our system and the ones
    in place simply cancel themselves.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等，我们还没有在新的`EditNumber`类中实现任何转换或对值的处理，所有测试都顺利通过，没有任何问题。是的，它们通过了，因为我们系统中没有足够的限制，现有的限制只是相互抵消。
- en: Before going further, let's analyze what just happened. Our test invoked the
    `mFahrenheit.setNumber(f)` method to set the temperature entered in the **Fahrenheit**
    field, but `setNumber()` is not implemented and it is an empty method as generated
    by Eclipse and does nothing at all. So the field remains empty.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在进一步之前，让我们分析一下刚才发生的事情。我们的测试调用了`mFahrenheit.setNumber(f)`方法来设置在**华氏**字段中输入的温度，但`setNumber()`没有实现，它是一个由Eclipse生成的空方法，什么也不做。所以字段仍然是空的。
- en: Next, the value for `expectedC`—the expected temperature in Celsius is calculated
    invoking `TemperatureConverter.fahrenheitToCelsius(f)`, but this is also an empty
    method as generated by Eclipse. In this case, because Eclipse knows about the
    return type it returns a constant 0\. So `expectedC` becomes 0.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过调用`TemperatureConverter.fahrenheitToCelsius(f)`计算`expectedC`的值——预期的摄氏温度，但这也是一个由Eclipse生成的空方法。在这种情况下，因为Eclipse知道返回类型，它返回一个常数0。所以`expectedC`变为0。
- en: Then the actual value for the conversion is obtained from the UI. In this case
    invoking `getNumber()` from `EditNumber`. But once again this method was automatically
    generated by Eclipse and to satisfy the restriction imposed by its signature,
    it must return a value that Eclipse fills with 0.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 然后从UI中获取转换的实际值。在这种情况下，通过`EditNumber`调用`getNumber()`。但又一次，这个方法是由Eclipse自动生成的，为了满足其签名强加的限制，它必须返回一个由Eclipse填充为0的值。
- en: The delta value is again 0, as calculated by `Math.abs(expectedC actualC)`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Δ值再次为0，这是通过`Math.abs(expectedC - actualC)`计算得出的。
- en: And finally our assertion `assertTrue(msg, delta < 0.005)` is true because `delta=0`
    satisfies the condition, and the test passes.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的断言`assertTrue(msg, delta < 0.005)`为真，因为`delta=0`满足条件，测试通过。
- en: So, is our methodology flawed as it cannot detect a simple situation like this?
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们的方法论有缺陷吗？它不能检测像这种情况这样的简单情况？
- en: No, not at all. The problem here is that we don't have enough restrictions and
    they are satisfied by the default values used by Eclipse to complete auto-generated
    methods. One alternative could be to throw exceptions at all of the auto-generated
    methods, something like `RuntimeException("not yet implemented")` to detect its
    use when not implemented. But we will be adding enough restrictions in our system
    to easily trap this condition.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 不，一点也不是。这里的问题是，我们没有足够的限制，并且它们被Eclipse用于完成自动生成方法的默认值所满足。一个替代方案可能是抛出所有自动生成方法的异常，例如`RuntimeException("not
    yet implemented")`，以检测未实现时的使用。但我们将添加足够的限制到我们的系统中，以便轻松捕获这种条件。
- en: TemperatureConverter unit tests
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 温度转换器单元测试
- en: It seems, from our previous experience, that the default conversion implemented
    by Eclipse always returns 0, so we need something more robust. Otherwise this
    will be only returning a valid result when the parameter takes the value of 32F.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们以前的经验来看，Eclipse实现的默认转换总是返回0，所以我们需要更健壮的东西。否则，这只会当参数取值为32F时返回有效结果。
- en: The `TemperatureConverter` is a utility class not related with the Android infrastructure,
    so a standard unit test will be enough to test it.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`TemperatureConverter` 是一个与 Android 基础设施无关的实用工具类，因此标准的单元测试就足够测试它了。'
- en: We create our tests using Eclipse's **File | New | JUnit Test Case**, filling
    in some appropriate values, and selecting the method to generate a test as shown
    in the next screenshot.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Eclipse 的 **文件 | 新建 | JUnit 测试用例** 来创建测试，填写一些适当的值，并选择生成测试的方法，如下一张截图所示。
- en: 'Firstly, we create the unit test by extending `junit.framework.TestCase` and
    selecting `com.example.aatg.tc.TemperatureConverter` as the class under test:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过扩展 `junit.framework.TestCase` 并选择 `com.example.aatg.tc.TemperatureConverter`
    作为测试的类来创建单元测试：
- en: '![TemperatureConverter unit tests](img/3500_04_10.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![TemperatureConverter 单元测试](img/3500_04_10.jpg)'
- en: 'Then by pressing the **Next >** button we can obtain the list of methods we
    may want to test:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通过按下 **下一步 >** 按钮，我们可以获得我们可能想要测试的方法列表：
- en: '![TemperatureConverter unit tests](img/3500_04_11.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![TemperatureConverter 单元测试](img/3500_04_11.jpg)'
- en: We have implemented only one method in `TemperatureConverter`, so it's the only
    one appearing in the list. Other classes implementing more methods will display
    all the options here.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `TemperatureConverter` 中只实现了一个方法，所以它就是列表中唯一出现的方法。实现更多方法的其它类将在这里显示所有选项。
- en: It's good to note that even if the test method is auto-generated by Eclipse
    it won't pass. It will fail with the message *Not yet implemented* to remind us
    that something is missing.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，即使测试方法是 Eclipse 自动生成的，它也不会通过。它会失败，并显示消息 *Not yet implemented* 来提醒我们某些东西缺失。
- en: 'Let''s start by changing this:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先改变这个：
- en: '[PRE20]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Creating a conversion table with values for different temperature conversion
    we know from other sources would be a good way to drive this test.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含不同温度转换值的转换表，这些值来自其他来源，这将是一个驱动测试的好方法。
- en: '[PRE21]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We may just run this test to verify that it fails, giving us this trace:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以运行这个测试来验证它是否失败，给出以下跟踪信息：
- en: '**junit.framework.AssertionFailedError: -40.0F -> -40.0C but is 0.0 (delta
    40.0)**'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**junit.framework.AssertionFailedError: -40.0F -> -40.0C but is 0.0 (delta
    40.0)**'
- en: '**at com.example.aatg.tc.test.TemperatureConverterTests.testFahrenheitToCelsius(TemperatureConverterTests.java:62)**'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**at com.example.aatg.tc.test.TemperatureConverterTests.testFahrenheitToCelsius(TemperatureConverterTests.java:62)**'
- en: '**at java.lang.reflect.Method.invokeNative(Native Method)**'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '**at java.lang.reflect.Method.invokeNative(Native Method)**'
- en: '**at android.test.AndroidTestRunner.runTest(AndroidTestRunner.java:169)**'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '**at android.test.AndroidTestRunner.runTest(AndroidTestRunner.java:169)**'
- en: '**at android.test.AndroidTestRunner.runTest(AndroidTestRunner.java:154)**'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '**at android.test.AndroidTestRunner.runTest(AndroidTestRunner.java:154)**'
- en: '**at android.test.InstrumentationTestRunner.onStart(InstrumentationTestRunner.java:520)**'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**at android.test.InstrumentationTestRunner.onStart(InstrumentationTestRunner.java:520)**'
- en: '**at android.app.Instrumentation$InstrumentationThread.run(Instrumentation.java:1447)**'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '**at android.app.Instrumentation$InstrumentationThread.run(Instrumentation.java:1447)**'
- en: 'Well, this was something we were expecting as our conversion always returns
    0\. Implementing our conversion, we discover that we need some `ABSOLUTE_ZERO_F`
    constant:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这正是我们所预期的，因为我们的转换总是返回 0。实现我们的转换后，我们发现我们需要一个 `ABSOLUTE_ZERO_F` 常量：
- en: '[PRE22]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Absolute zero is the theoretical temperature at which entropy would reach its
    minimum value. To be able to reach this absolute zero state, according to the
    laws of thermodynamics, the system should be isolated from the rest of the universe.
    Thus it is an unreachable state. However, by international agreement, absolute
    zero is defined as 0K on the Kelvin scale and as -273.15°C on the Celsius scale
    or to -459.67°F on the Fahrenheit scale.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 绝对零是熵达到其最小值的理论温度。根据热力学定律，为了能够达到这个绝对零状态，系统应该与宇宙的其余部分隔离。因此，这是一个无法达到的状态。然而，根据国际协议，绝对零被定义为开尔文温标上的
    0K，摄氏温标上的 -273.15°C，或者华氏温标上的 -459.67°F。
- en: We are creating a custom exception, `InvalidTemperatureException`, to indicate
    a failure providing a valid temperature to the conversion method. This exception
    is created simply by extending `RuntimeException:`
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建一个自定义异常 `InvalidTemperatureException`，以指示向转换方法提供有效温度时失败。这个异常是通过扩展 `RuntimeException:`
    简单创建的。
- en: '[PRE23]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Running the tests again we now discover that `testFahrenheitToCelsiusConversion`
    test fails, however `testFahrenheitToCelsius` succeeds. This tells us that now
    conversions are correctly handled by the converter class but there are still some
    problems with the UI handling this conversion.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试后，我们发现 `testFahrenheitToCelsiusConversion` 测试失败，而 `testFahrenheitToCelsius`
    测试成功。这告诉我们现在转换已经被转换器类正确处理，但仍然存在一些与 UI 处理这个转换相关的问题。
- en: A closer look at the failure trace reveals that there's something still returning
    0 when it shouldn't.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细查看失败跟踪，我们发现当不应该返回 0 时，仍然有东西返回了 0。
- en: This reminds us that we are still lacking a proper `EditNumber` implementation.
    Before proceeding to implement the mentioned methods, let's create the corresponding
    tests to verify what we are implementing is correct.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这提醒我们，我们仍然缺少一个合适的 `EditNumber` 实现。在继续实现所提到的方法之前，让我们创建相应的测试来验证我们所实现的是否正确。
- en: The EditNumber tests
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EditNumber 测试
- en: From the previous chapter, we can now determine that the best base class for
    our custom `View` tests is `AndroidTestCase`, as we need a mock `Context` to create
    the custom `View` but we don't need system infrastructure.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一章，我们现在可以确定，对于我们的自定义 `View` 测试，最佳基类是 `AndroidTestCase`，因为我们需要一个模拟的 `Context`
    来创建自定义 `View`，但我们不需要系统基础设施。
- en: 'This is the dialog we have to complete to create the tests. In this case using
    `android.test.AndroidTestCase` as the base class and `com.example.aatg.tc.EditNumber`
    as the class under test:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们必须完成的对话框，以创建测试。在这种情况下，使用 `android.test.AndroidTestCase` 作为基类，并将 `com.example.aatg.tc.EditNumber`
    作为待测试的类：
- en: '![The EditNumber tests](img/3500_04_12.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![EditNumber 测试](img/3500_04_12.jpg)'
- en: 'After pressing **Next >**, we select the methods for which stubs are created:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在按下 **下一步 >** 后，我们选择要创建存根的方法：
- en: '![The EditNumber tests](img/3500_04_13.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![EditNumber 测试](img/3500_04_13.jpg)'
- en: 'We need to update the auto-generated constructor to reflect the pattern we
    identified before, the given name pattern:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更新自动生成的构造函数，以反映我们之前确定的模式，即给定的名称模式：
- en: '[PRE24]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The next step is to create the fixture. In this case this is a simple `EditNumber`
    which we will be testing:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建测试用例。在这种情况下，这是一个简单的 `EditNumber`，我们将对其进行测试：
- en: '[PRE25]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The mock context is obtained from the protected field mContext ([http://developer.android.com/reference/android/test/AndroidTestCase.html#mContext](http://developer.android.com/reference/android/test/AndroidTestCase.html#mContext))
    available in the `AndroidTestCase` class.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟的上下文是从 `AndroidTestCase` 类中可用的受保护字段 `mContext` ([http://developer.android.com/reference/android/test/AndroidTestCase.html#mContext](http://developer.android.com/reference/android/test/AndroidTestCase.html#mContext))
    获取的。
- en: At the end of the test we set `mEditNumber` as a focusable `View`, that is it
    will be able to gain focus, as it will be participating in a bunch of tests simulating
    UIs that may need to request its focus explicitly.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试结束时，我们将 `mEditNumber` 设置为可聚焦的 `View`，这意味着它将能够获得焦点，因为它将参与一系列模拟 UI 的测试，这些测试可能需要显式请求其焦点。
- en: 'Next, we test that the required `clear()` functionality is implemented correctly
    in the `testClear()` method:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们测试在 `testClear()` 方法中正确实现了所需的 `clear()` 功能：
- en: '[PRE26]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Running the test we verify that it fails:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试以验证它失败：
- en: '**junit.framework.ComparisonFailure: expected:<> but was:<123.45>**'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '**junit.framework.ComparisonFailure: expected:<> but was:<123.45>**'
- en: '**at com.example.aatg.tc.test.EditNumberTests.testClear(EditNumberTests.java:62)**'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '**在 com.example.aatg.tc.test.EditNumberTests.testClear(EditNumberTests.java:62)**'
- en: '**at android.test.AndroidTestRunner.runTest(AndroidTestRunner.java:169)**'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '**在 android.test.AndroidTestRunner.runTest(AndroidTestRunner.java:169)**'
- en: '**at android.test.AndroidTestRunner.runTest(AndroidTestRunner.java:154)**'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '**在 android.test.AndroidTestRunner.runTest(AndroidTestRunner.java:154)**'
- en: '**at android.test.InstrumentationTestRunner.onStart(InstrumentationTestRunner.java:529)**'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**在 android.test.InstrumentationTestRunner.onStart(InstrumentationTestRunner.java:529)**'
- en: '**at android.app.Instrumentation$InstrumentationThread.run(Instrumentation.java:1447)**'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**在 android.app.Instrumentation$InstrumentationThread.run(Instrumentation.java:1447)**'
- en: We need to implement `EditNumber.clear()` correctly.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要正确实现 `EditNumber.clear()`。
- en: 'This is a simple case, so just by adding this implementation to `EditNumber`
    we satisfy the test:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的情况，所以只需将此实现添加到 `EditNumber` 中，我们就能满足测试：
- en: '[PRE27]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Run the test and proceed. Now let''s complete the `testSetNumber()` implementation:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试并继续。现在让我们完成 `testSetNumber()` 的实现：
- en: '[PRE28]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Which fails unless we implement `EditNumber.setNumber()`, similar to this implementation:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 除非我们实现了 `EditNumber.setNumber()`，类似于这个实现：
- en: '[PRE29]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We are using a constant, `DEFAULT_FORMAT`, to hold the desired format to convert
    the numbers. This can be later converted to a property that could also be specified
    in the `xml` layout definition of the field.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个常量 `DEFAULT_FORMAT` 来保存要转换数字的期望格式。这可以稍后转换为可以在字段的 `xml` 布局定义中指定的属性。
- en: 'The same goes for the `testGetNumber()` and `getNumber()` pair:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `testGetNumber()` 和 `getNumber()` 对，情况相同：
- en: '[PRE30]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'And:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 然后：
- en: '[PRE31]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Surprisingly these tests succeed. But now there''s a test that was passing
    that started to fail: `testFahrenheitToCelsiusConversion()`. The reason is that
    now that we have implemented `EditNumber.setNumber()` and `EditNumber.getNumber()`
    correctly, some values are returned differently and this test method was relying
    on spurious values.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 意外地，这些测试成功了。但现在有一个之前通过而现在开始失败的测试：`testFahrenheitToCelsiusConversion()`。原因是现在我们已经正确实现了`EditNumber.setNumber()`和`EditNumber.getNumber()`，一些值返回的方式不同，而这个测试方法依赖于这些虚假的值。
- en: 'This is a screenshot of the results obtained after running the tests:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这是运行测试后获得的结果截图：
- en: '![The EditNumber tests](img/3500_04_14.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![The EditNumber tests](img/3500_04_14.jpg)'
- en: If you closely analyze the case, you can discover where the problem is.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细分析这个案例，你可以发现问题的所在。
- en: Got it ?
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 明白了？
- en: 'Our test method is expecting the conversion to be realized automatically when
    the focus changes, as was specified in our list of requirements: when one temperature
    is entered in one field the other one is automatically updated with the conversion.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试方法期望在焦点改变时自动实现转换，正如我们在需求列表中所指定的：当一个温度值在一个字段中输入时，另一个值会自动通过转换更新。
- en: Remember, we don't have buttons or anything else to convert temperature values,
    so the conversion is expected to be done automatically once the values are entered.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们没有按钮或其他任何东西来转换温度值，所以一旦输入了值，转换应该自动完成。
- en: This leads us again to the `TemperatureConverterActivity` and the way it handles
    the conversions.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这又让我们回到了`TemperatureConverterActivity`以及它处理转换的方式。
- en: The TemperatureChangeWatcher class
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`TemperatureChangeWatcher`类'
- en: One way of implementing the required behavior of constantly updating the other
    temperature value once one has changed is through a `TextWatcher`. From the documentation
    we can understand that a `TextWatcher` is an object of a type that is attached
    to an `Editable`; its methods will be called when the text is changed ([http://developer.android.com/intl/de/reference/android/text/TextWatcher.html](http://developer.android.com/intl/de/reference/android/text/TextWatcher.html)).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 实现所需行为的一种方法是在一个值改变后不断更新另一个温度值，可以通过`TextWatcher`来实现。从文档中我们可以理解，`TextWatcher`是一个附加到`Editable`对象上的对象类型；当文本改变时，它的方法会被调用（[http://developer.android.com/intl/de/reference/android/text/TextWatcher.html](http://developer.android.com/intl/de/reference/android/text/TextWatcher.html)）。
- en: It seems that is what we need.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎就是我们需要的东西。
- en: 'We implement this class as an inner class of `TemperatureConverterActivity`.
    This is the screenshot of the New Java Class in Eclipse:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们把这个类实现为`TemperatureConverterActivity`的内部类。这是在Eclipse中创建新Java类的截图：
- en: '![The TemperatureChangeWatcher class](img/3500_04_15.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![The TemperatureChangeWatcher class](img/3500_04_15.jpg)'
- en: And this is our code after some additions to the recently created class.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在最近创建的类中添加一些内容后的代码：
- en: '[PRE32]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We implement extending `TextWatcher` and overriding the unimplemented methods.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了扩展`TextWatcher`并重写未实现的方法。
- en: Because we will be using the same `TemperatureChangeWatcher` implementation
    for both fields, Celsius and Fahrenheit, we keep a reference to the fields used
    as source and destination as well as the operation needed to update their values.
    To specify this operation we are introducing an `enum` to the `TemperatureConverter`
    class.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们将使用相同的`TemperatureChangeWatcher`实现来处理两个字段，摄氏度和华氏度，所以我们保留了对用作源和目标的字段以及更新它们的值的操作的引用。为了指定这个操作，我们在`TemperatureConverter`类中引入了一个`enum`。
- en: '[PRE33]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This operation is specified in the constructor and the destination and source
    `EditNumber` are selected accordingly. This way we can use the same watcher for
    different conversions.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作在构造函数中指定，并且根据需要选择源和目标`EditNumber`。这样我们就可以为不同的转换使用相同的监视器。
- en: The method of the `TextWatcher` interface we are mainly interested in is `onTextChanged`,
    that will be called any time the text changes. At the beginning we avoid potential
    loops, checking who has focus and returning if the conditions are not met.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们主要感兴趣的`TextWatcher`接口的方法是`onTextChanged`，它将在文本改变时被调用。一开始我们避免潜在的循环，检查谁有焦点，如果条件不满足则返回。
- en: We also set the destination field as an empty `String` if the source is empty.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 如果源数据为空，我们也把目标字段设置为空的`String`。
- en: Finally, we try to set the resulting value of invoking the corresponding conversion
    method to set the destination field. We flag the error as necessary, avoiding
    showing premature errors when the conversion was invoked with a partially entered
    number.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们尝试将调用相应转换方法的结果设置到目标字段。根据需要标记错误，避免在转换使用部分输入的数字时显示过早的错误。
- en: We need to set the listener on the fields in `TemperatureConverterActivity.onCreate():`
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`TemperatureConverterActivity.onCreate():`中的字段上设置监听器。
- en: '[PRE34]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: To be able to run the tests we should compile them. To compile we need at least
    to define the `celsiusToFahrenheit`, which is not yet defined.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够运行测试，我们应该编译它们。为了编译，我们至少需要定义`celsiusToFahrenheit`，它尚未定义。
- en: More TemperatureConverter tests
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多温度转换器测试
- en: We need to implement `celsiusToFahrenheit` and as usual we start from the test.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现`celsiusToFahrenheit`，并且像往常一样，我们从测试开始。
- en: 'This is fairly equivalent to the other conversion method `fahrenheitToCelsius`
    and we can use the infrastructure we devised while creating this test:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这与另一个转换方法`fahrenheitToCelsius`相当，我们可以使用我们在创建此测试时设计的框架：
- en: '[PRE35]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We use the conversion table to exercise the method through different conversions
    and we verify that the error is less than a predefined delta.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用转换表通过不同的转换来练习方法，并验证错误小于预定义的delta。
- en: 'Then, the correspondent conversion implementation in `TemperatureConverter`
    class is:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`TemperatureConverter`类中的相应转换实现如下：
- en: '[PRE36]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now all the tests are passing but we are still not testing all the common conditions.
    You should check if errors and exceptions are correctly generated, besides all
    the normal cases we created so far.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有的测试都通过了，但我们仍然没有测试所有常见的条件。你应该检查是否正确生成了错误和异常，除了到目前为止我们创建的所有正常情况之外。
- en: 'This is the test we create to check the correct generation of exceptions when
    a temperature below absolute zero is used in a conversion:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建的测试，用于检查在转换中使用低于绝对零的温度时正确生成异常：
- en: '[PRE37]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In this test we decrement the absolute zero temperature to obtain an even smaller
    value and then we attempt the conversion. We check for the correct exception being
    caught and finally we assert this condition:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们将绝对零温度递减以获得更小的值，然后尝试转换。我们检查是否正确捕获了正确的异常，并最终断言这个条件：
- en: '[PRE38]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In a similar manner we test for the exception being thrown when the attempted
    conversion involves a temperature in Celsius which is lower than the absolute
    zero.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，我们测试当尝试的转换涉及低于绝对零的温度时抛出的异常。
- en: The InputFilter tests
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入过滤器测试
- en: We want to filter the input that is received by the conversion utility so no
    garbage reaches this point.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望过滤由转换工具接收到的输入，以便没有垃圾输入到这个点。
- en: 'The `EditNumber` class already filters valid input and generates exceptions
    otherwise. We can verify this condition by generating some new tests in `TemperatureConverterActivityTests`.
    We choose this class because we are sending keys to the entry fields, just as
    a real user would do:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '`EditNumber`类已经过滤了有效的输入并生成异常，否则。我们可以通过在`TemperatureConverterActivityTests`中生成一些新的测试来验证这个条件。我们选择这个类是因为我们向输入字段发送键，就像一个真实用户会做的那样：'
- en: '[PRE39]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This test requests the focus to the Celsius field using the pattern we have
    reviewed before to run parts of a test in the UI thread, and then send some keys.
    The keys sent are an invalid sequence containing more than one period, which is
    not accepted for a well formed decimal number. It is expected that when the filter
    is in place, this sequence will be filtered and only the valid characters reach
    the field. We use the possibly generated `NumberFormatException` to detect the
    error and then we assert that the value returned by `mCelsius.getNumber()` is
    what we are expecting after filtering.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试请求使用我们之前审查的模式将焦点放在摄氏度字段上，以在UI线程中运行测试的部分，然后发送一些键。发送的键是一个包含多个点的无效序列，这对于一个良好的十进制数字是不接受的。预期当过滤器到位时，这个序列将被过滤，并且只有有效的字符到达字段。我们使用可能生成的`NumberFormatException`来检测错误，然后断言`mCelsius.getNumber()`返回的值是我们过滤后预期的值。
- en: To implement this filter, we need to add an `InputFilter` to `EditNumber`. Because
    this should be added to all of the constructors we create an additional method
    `init()` which we invoke from them. To achieve our goal we use an instance of
    `DigitsKeyListener` accepting digits, signs, and decimal points.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这个过滤器，我们需要向`EditNumber`添加一个`InputFilter`。因为这将添加到我们创建的所有构造函数中，所以我们创建了一个额外的`init()`方法，并从它们中调用它。为了达到我们的目标，我们使用一个接受数字、符号和小数点的`DigitsKeyListener`实例。
- en: '[PRE40]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This `init` method is factored and invoked from different constructors.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`init`方法是从不同的构造函数中分解和调用的。
- en: Running the tests again we can verify that all have passed and now everything
    is green again.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试，我们可以验证所有测试都已通过，现在一切又都是绿色的。
- en: Viewing our final application
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看我们的最终应用程序
- en: This is our final application which satisfies all the requirements.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们满足所有要求的应用程序。
- en: 'In the following screenshot we are showing one of these requirements, which
    is the detection of an attempt to convert a temperature below the absolute zero
    temperature in Celsius (-1000.00C):'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下屏幕截图中，我们展示了这些要求之一，即检测尝试将温度转换为摄氏度绝对零度以下的情况（-1000.00°C）：
- en: '![Viewing our final application](img/3500_04_16.jpg)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![查看我们的最终应用程序](img/3500_04_16.jpg)'
- en: The UI respects the guidelines provided; the temperatures can be converted by
    entering them in the corresponding unit field.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: UI 遵循提供的指南；可以在相应的单位字段中输入温度进行转换。
- en: 'To recap, this was the list of requirements:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，这是需求列表：
- en: The application converts temperatures from Celsius to Fahrenheit and vice versa
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该应用程序可以将温度从摄氏度转换为华氏度，反之亦然
- en: The user interface presents two fields to enter the temperatures, one for Celsius
    and the other for Fahrenheit
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户界面提供了两个输入温度的字段，一个用于摄氏度，另一个用于华氏度
- en: When one temperature is entered in one field the other one is automatically
    updated with the conversion
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在一个字段中输入一个温度时，另一个字段会自动更新为转换值
- en: If there are errors, they should be displayed to the user, possibly using the
    same fields
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有错误，它们应该显示给用户，可能使用相同的字段
- en: Some space in the user interface should be reserved for the on-screen keyboard
    to ease the application operation when several conversions are entered
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户界面应预留一些空间用于屏幕键盘，以便在输入多个转换时简化应用程序操作。
- en: Entry fields should start empty
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入字段应保持为空
- en: Values entered are decimal values with two digits after the point
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入的值是带有小数点后两位数字的十进制值
- en: Digits are right aligned
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字是右对齐的
- en: But what is perhaps more important is that we can assure that the application
    not only satisfies the requirements but also has no evident problems or bugs because
    we took every step by analyzing the test results and fixing the problems at their
    first appearance. This will ensure that the same bug, once discovered, will not
    resurface again.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 但也许更重要的是，我们可以确保应用程序不仅满足要求，而且没有明显的错误或漏洞，因为我们通过分析测试结果并在问题首次出现时修复它们来采取每一步。这将确保一旦发现相同的错误，它将不会再次出现。
- en: Summary
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We presented Test Driven Development introducing its concepts and later on applying
    them step-by-step in a potential real-life problem.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了测试驱动开发，介绍了其概念，并在之后逐步在一个潜在的真实问题中应用它们。
- en: We started with a concise list of requirement describing the Temperature Converter
    application.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个简洁的需求列表开始，描述了温度转换应用程序。
- en: Then, we implemented every test followed by the code that satisfies it. In this
    manner we implemented the application behavior as well as its presentation, conducting
    tests to verify that the UI we designed follows the specifications.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们实现了每个测试，随后是实现满足它的代码。以这种方式，我们实现了应用程序的行为以及其展示，通过测试来验证我们设计的 UI 是否遵循规范。
- en: Having the tests in place lead us to analyze the different possibilities we
    have in running them and the next chapter will focus on the Testing Environment.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 进行测试使我们能够分析运行它们的不同可能性，下一章将专注于测试环境。
