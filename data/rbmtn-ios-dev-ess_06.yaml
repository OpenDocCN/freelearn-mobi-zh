- en: Chapter 6. Device Capability – Power Unleashed
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. 设备功能 – 力量释放
- en: '*"Software will give you respect, but hardware will give you the Power."*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*"软件会给你尊重，但硬件会给你力量。"*'
- en: '*- Akshat Paul*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*- 阿克夏特·保罗*'
- en: An iPhone is not only used for making calls, surfing the Internet, and playing
    music, but it is also the most advanced piece of hardware that can be used to
    take pictures, know your present location, comprehend gestures, and to do so many
    other things. So why not take advantage of these incredible device capabilities
    in your application. The beauty of these features is that just by tapping into
    the tools that the iPhone SDK provides, one can quickly import pictures, locations,
    and maps with minimal lines of code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: iPhone不仅用于打电话、上网和播放音乐，它也是可以用来拍照、了解当前位置、理解手势以及做许多其他事情的最先进的硬件。那么，为什么不在你的应用程序中利用这些令人难以置信的设备功能呢。这些功能的美丽之处在于，只需通过iPhone
    SDK提供的工具进行操作，就可以快速导入图片、位置和地图，而代码行数最少。
- en: 'In this chapter we will focus on the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注以下主题：
- en: Camera
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相机
- en: Location Manager (GPS)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置管理器（GPS）
- en: Gestures
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手势
- en: Core Data
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Core Data
- en: Address Book
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地址簿
- en: Camera – smile please!
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相机 – 微笑吧！
- en: The camera is probably the most widely used feature of an iOS device. In this
    section, we will cover the most frequently used Camera events by creating an application
    that will allow us to take a picture using the Camera device and to select a picture
    from the Gallery.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 摄像头可能是iOS设备上最广泛使用的功能。在本节中，我们将通过创建一个应用程序来介绍最常用的相机事件，该应用程序将允许我们使用相机设备拍照，并从图库中选择图片。
- en: An iPhone implements image selection through a picker that allows us to get
    images from different sources, such as Camera Roll or Photo Library. The `UIImagePickerController`
    class provides basic, customizable user interfaces (UIs) for taking pictures and
    videos, also providing the user with some simple editing capabilities for newly
    captured media.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: iPhone通过一个允许我们从不同的来源获取图像的选择器来实现图像选择，例如相机胶卷或照片库。`UIImagePickerController`类提供了基本的、可定制的用户界面（UI），用于拍照和录像，同时也为用户提供了对新捕获媒体的一些简单编辑功能。
- en: 'The role and appearance of a `UIImagePickerController` class depends on the
    value of `sourceType` assigned to it. There are three ways to choose the source
    of an image, as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIImagePickerController`类的角色和外观取决于分配给它的`sourceType`的值。有三种方式可以选择图像的来源，如下所示：'
- en: 'Choose from Camera:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从相机中选择：
- en: '[PRE0]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Choose from any folder in Gallery:'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从图库中的任何文件夹中选择：
- en: '[PRE1]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Choose from Photo Album (Camera Roll):'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从照片专辑（相机胶卷）中选择：
- en: '[PRE2]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Camera example
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相机示例
- en: 'Let''s create an application that will allow us to capture a photo from the
    camera and select an image from Photo Gallery. Perform the following steps:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个应用程序，允许我们从相机捕获照片并从照片图库中选择图像。执行以下步骤：
- en: 'Create an application with the `motion` command:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`motion`命令创建一个应用程序：
- en: '[PRE3]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Update `app_delegate.rb` and set the root controller to `CameraController`:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`app_delegate.rb`并将根控制器设置为`CameraController`：
- en: '[PRE4]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create a file named `camera_controller.rb` inside the `app` folder:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app`文件夹内创建一个名为`camera_controller.rb`的文件：
- en: '[PRE5]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s see what we have done so far by testing our application on the simulator
    using the following command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在模拟器上使用以下命令测试我们的应用程序来看看我们已经做了什么：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can see the results as shown in the following screenshot:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到以下截图所示的结果：
- en: '![Camera example](img/5220OT_06_01.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![相机示例](img/5220OT_06_01.jpg)'
- en: 'As we are using an iPhone simulator, we cannot access the camera hardware.
    However, if we test our application with an iPhone device, we will be able to
    use the camera hardware and capture images from it. Now let''s choose an image
    from Gallery by clicking on the **Choose from Gallery** button:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用的是iPhone模拟器，我们无法访问相机硬件。然而，如果我们用iPhone设备测试我们的应用程序，我们将能够使用相机硬件并从中捕获图像。现在让我们通过点击**从图库选择**按钮来选择一个图像：
- en: '![Camera example](img/5220OT_06_02.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![相机示例](img/5220OT_06_02.jpg)'
- en: Understanding the Camera code
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解相机代码
- en: 'First, we need to initiate two buttons for the photo-taking process and choose
    a picture from Gallery. We will also create an image picker:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要为拍照过程初始化两个按钮，并从图库中选择一张图片。我们还将创建一个图片选择器：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'So when we click on the **Click from camera** and **Choose from Gallery** buttons,
    the `start_camera` and `open_gallery` actions will be called, respectively:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们点击**从相机点击**和**从图库选择**按钮时，将分别调用`start_camera`和`open_gallery`操作：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: So we have used `UIImagePickerControllerSourceTypeCamera` and `UIImagePickerControllerSourceTypePhotoLibrary`
    as source types; they will open the Camera and Photo Library tools, respectively.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们使用了 `UIImagePickerControllerSourceTypeCamera` 和 `UIImagePickerControllerSourceTypePhotoLibrary`
    作为源类型；它们将分别打开相机和照片库工具。
- en: Tip
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As an iOS application can also be installed on devices such as an iPod, which
    does not have a camera, to check the device for a camera, the `UIImagePickerController.isSourceTypeAvailable(UIImagePickerControllerSourceTypeCamera)`
    method is used.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 iOS 应用程序也可以安装在如 iPod 这样的设备上，这些设备没有相机，因此为了检查设备是否有相机，使用 `UIImagePickerController.isSourceTypeAvailable(UIImagePickerControllerSourceTypeCamera)`
    方法。
- en: 'The following two camera picker delegates are available:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个相机选择器代理可用：
- en: '`imagePickerController:didFinishPickingImage`: This is called when the image
    is selected'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`imagePickerController:didFinishPickingImage`: 当图像被选中时调用此方法'
- en: '`imagePickerControllerDidCancel`: This is called when the **Cancel** button
    is clicked'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`imagePickerControllerDidCancel`: 当点击**取消**按钮时调用此方法'
- en: 'The following delegate will be called when an image is selected:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代理将在图像被选中时被调用：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `self.dismissModalViewControllerAnimated(true)` method is called explicitly
    to remove the pop-up, and then the image is displayed using `UIImageView`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 明确调用 `self.dismissModalViewControllerAnimated(true)` 方法来移除弹出窗口，然后使用 `UIImageView`
    显示图像。
- en: Location Manager – directions for apps
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 位置管理器 – 应用程序指南
- en: 'You must have observed that in many iOS applications, your current location
    is spotted automatically. With RubyMotion, we can easily use the location capabilities
    of your device with our application. There are two parts to this: the first is
    to find the device location and the second is to display it in our application.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须已经观察到在许多 iOS 应用程序中，您的当前位置会自动被定位。使用 RubyMotion，我们可以轻松地使用设备的定位功能。这包括两个部分：第一是找到设备位置，第二是在我们的应用程序中显示它。
- en: iOS SDK contains various layers; one of them is the **Core Services** layer
    and a part of this layer is the **Core Location** framework. This framework uses
    the available hardware to determine a user's current position and where they are
    heading. Core Location provides us with coordinates, text strings, and number
    values instead of visual location information such as maps. Later in the chapter,
    we will also use Map Kit that will help us embed maps directly in our views using
    our knowledge of the Core Location framework.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: iOS SDK 包含各种层；其中之一是 **Core Services** 层，该层的一部分是 **Core Location** 框架。此框架使用可用的硬件来确定用户的当前位置以及他们正在前往的方向。Core
    Location 提供给我们坐标、文本字符串和数值，而不是像地图这样的视觉位置信息。在接下来的章节中，我们还将使用 Map Kit，这将帮助我们使用 Core
    Location 框架的知识直接在视图中嵌入地图。
- en: Location Manager example
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 位置管理器示例
- en: 'Let''s create an application to demonstrate how we can use Location Manager
    with the RubyMotion application. Perform the following steps:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个应用程序来演示如何使用 RubyMotion 应用程序与位置管理器一起使用。执行以下步骤：
- en: 'Create an application with the `motion` command:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `motion` 命令创建应用程序：
- en: '[PRE10]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Update the `app_delegate.rb` file:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `app_delegate.rb` 文件：
- en: '[PRE11]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Update the `rake` file and add the following line of code:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `rake` 文件并添加以下行代码：
- en: '[PRE12]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To use the Location service, we have to include the following two frameworks:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用位置服务，我们必须包含以下两个框架：
- en: '`CoreLocation`: The `CoreLocation` framework lets you determine the current
    location. This framework uses the available hardware of the device to determine
    the device''s current position and where it is heading.'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CoreLocation`: `CoreLocation` 框架允许您确定当前位置。此框架使用设备的可用硬件来确定设备的当前位置以及它们正在前往的方向。'
- en: '`MapKit`: The `MapKit` framework provides an interface for embedding maps directly
    into your app''s views.'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MapKit`: `MapKit` 框架提供了一个将地图直接嵌入到您的应用程序视图中的接口。'
- en: 'Create the `location_controller.rb` controller in the `app` folder and add
    the following code:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `app` 文件夹中创建 `location_controller.rb` 控制器并添加以下代码：
- en: '[PRE13]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding code, we configured the `CLLocationManager` object using the
    following steps:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用以下步骤配置了 `CLLocationManager` 对象：
- en: Always check to see whether the desired services are available before starting
    any service and abandon the operation if they are not. You can do so by triggering
    `CLLocationManager.locationServicesEnable`. If this returns `true`, the service
    has been enabled for your application.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开始任何服务之前，始终检查所需的服务是否可用，如果不可用，则放弃操作。您可以通过触发 `CLLocationManager.locationServicesEnable`
    来实现。如果此方法返回 `true`，则服务已为您的应用程序启用。
- en: Note
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The user has the option of denying applications the ability to access its Location
    service data. During the initial use by an application, the Core Location framework
    prompts the user to confirm that using the Location service is acceptable. If
    the user denies the request, the `CLLocationManager` object reports an appropriate
    error to the delegate in future requests.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用户可以选择拒绝应用程序访问其位置服务数据的能力。在应用程序的初始使用过程中，Core Location框架提示用户确认使用位置服务是否可接受。如果用户拒绝请求，`CLLocationManager`对象将在未来的请求中向代理报告适当的错误。
- en: 'Then we created an instance of the `CLLocationManager` class:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建了一个`CLLocationManager`类的实例：
- en: '[PRE14]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we configured additional properties relevant to the Location service:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们配置了与位置服务相关的其他属性：
- en: '[PRE15]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`desiredAccuracy` supports a wide range of methods that provide different levels
    of accuracy. You can also use `KCLLocationAccuracyBest`; it will give you more
    accurate results but it will also drain the battery. `KCLLocationAccuracyKilometer`
    doesn''t give an accurate location but is more effective in terms of performance.'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`desiredAccuracy`支持广泛的方法，提供不同级别的精度。您还可以使用`KCLLocationAccuracyBest`；这将提供更精确的结果，但也会耗电。`KCLLocationAccuracyKilometer`不会提供精确的位置，但在性能方面更有效。'
- en: '[PRE16]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This message will appear when the application asks for permissions.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当应用程序请求权限时，此消息将显示。
- en: 'Then we created a delegate to handle the latitude and longitude for our application:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建了一个代理来处理我们应用程序的纬度和经度：
- en: '[PRE17]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Lastly, we called the appropriate start method to begin the delivery of events:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们调用了适当的启动方法以开始事件的传递：
- en: '[PRE18]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s fire up the terminal and test our app using the following command:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启动终端并使用以下命令测试我们的应用程序：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output is as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Location Manager example](img/5220OT_06_03.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![位置管理器示例](img/5220OT_06_03.jpg)'
- en: If your location is not set in your simulator, you will get a pop-up showing
    an error, as shown in the preceding screenshot.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的位置在模拟器中没有设置，你将得到一个弹出窗口显示错误，如前一个截图所示。
- en: As we are using the iOS simulator, we do not have physical GPS access for the
    iPhone device. However, iOS simulator does give us the option to mimic this by
    selecting or adding values via the emulator. From the toolbar, navigate to **Debug**
    | **Location** and either choose or add custom longitude and latitude values.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用的是iOS模拟器，因此我们无法访问iPhone设备的物理GPS。然而，iOS模拟器确实提供了通过模拟器选择或添加值来模拟此功能的选择。从工具栏中，导航到**调试**
    | **位置**，然后选择或添加自定义经纬度值。
- en: '![Location Manager example](img/5220OT_06_04.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![位置管理器示例](img/5220OT_06_04.jpg)'
- en: 'You can see a pop-up on the screen with a custom message, which we had described
    in our code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在屏幕上看到一个带有自定义消息的弹出窗口，这是我们代码中描述的：
- en: '![Location Manager example](img/5220OT_06_05.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![位置管理器示例](img/5220OT_06_05.jpg)'
- en: 'Once we click on **OK**, we will see the longitude and latitude of our current
    location as shown in the following screenshot:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们点击**确定**，我们将在以下截图所示的位置看到经纬度：
- en: '![Location Manager example](img/5220OT_06_06.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![位置管理器示例](img/5220OT_06_06.jpg)'
- en: Now let's plot the current location on a map and display this on our screen.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在地图上绘制当前位置，并在屏幕上显示。
- en: 'Add the following code to the `location_controller.rb` file in the `app` folder:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`app`文件夹中的`location_controller.rb`文件：
- en: '[PRE20]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We have chosen `MKMapTypeStandard`, but `MKMapView` provides the following
    three types of maps:'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们选择了`MKMapTypeStandard`，但`MKMapView`提供了以下三种类型的地图：
- en: '`MKMapTypeStandard`: This shows a street and some road names'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MKMapTypeStandard`：这显示了街道和一些道路名称'
- en: '`MKMapTypeSatellite`: This shows satellite imagery'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MKMapTypeSatellite`：这显示了卫星图像'
- en: '`MKMapTypeHybrid`: This shows a satellite image of the area with roads and
    their names along with other information superimposed'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MKMapTypeHybrid`：这显示了该区域的卫星图像，包括道路及其名称以及其他叠加信息'
- en: 'Then, add the following code in the `viewDidLoad` method in the `location_controller.rb`
    file:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`location_controller.rb`文件中的`viewDidLoad`方法中添加以下代码：
- en: '[PRE21]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now run the application in the simulator using the following command:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在模拟器中使用以下命令运行应用程序：
- en: '[PRE22]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output is as follows:'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Location Manager example](img/5220OT_06_07.jpg)'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![位置管理器示例](img/5220OT_06_07.jpg)'
- en: The preceding code will only show a map on the screen and not pinpoint the location.
    We are now going to add a pin—annotations in MapKit terms—to our map.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码将在屏幕上显示地图，但不会精确显示位置。我们现在将添加一个图钉——在MapKit术语中称为注释——到我们的地图上。
- en: 'Update the `show_map` method in the `location_controller.rb` file:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`location_controller.rb`文件中的`show_map`方法：
- en: '[PRE23]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`CLLocationCoordinate2D` is a structure that contains the geographical coordinate
    of a location.'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`CLLocationCoordinate2D` 是一个包含位置地理坐标的结构体。'
- en: 'To add the pin (Annotation), you must create a class that explicitly implements
    the `MKAnnotation` protocol. We should define the following attributes in this
    class:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加图钉（注释），你必须创建一个显式实现 `MKAnnotation` 协议的类。在这个类中，我们应该定义以下属性：
- en: '`coordinate`'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`coordinate`'
- en: '`title`'
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`'
- en: '`subtitle`'
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subtitle`'
- en: 'Let''s create a file named `my_annotation.rb` inside the `app` folder. Create
    a class named `MyAnnotation` that has these attributes:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 `app` 文件夹内创建一个名为 `my_annotation.rb` 的文件。创建一个名为 `MyAnnotation` 的类，它具有以下属性：
- en: '[PRE24]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Update the `location_controller.rb` file with the following code:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码更新 `location_controller.rb` 文件：
- en: '[PRE25]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s fire up the terminal and run our application using the following command:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们打开终端，使用以下命令运行我们的应用程序：
- en: '[PRE26]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output is as follows:'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Location Manager example](img/5220OT_06_08.jpg)'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![位置管理器示例](img/5220OT_06_08.jpg)'
- en: In the preceding screenshot, we can see a map with the current location and
    its description.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们可以看到一个带有当前位置及其描述的地图。
- en: Tip
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can change the location in the simulator by navigating to **Debug** | **Change
    Location**.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过导航到 **调试** | **更改位置** 来在模拟器中更改位置。
- en: Gestures – non-verbal communication
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手势 – 非语言交流
- en: Gestures are a big part of iOS applications. For example, when we pinch on a
    picture, it gets zoomed, or when we rotate our device, the orientation of the
    picture changes. Detecting gestures in your application is very easy with the
    built-in `UIGestureRecognizer` classes.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 手势是 iOS 应用程序的重要组成部分。例如，当我们捏住一张图片时，它会放大，或者当我们旋转设备时，图片的方向会改变。使用内置的 `UIGestureRecognizer`
    类在你的应用程序中检测手势非常简单。
- en: 'There are a few subclasses of `UIGestureRecognizer`, each designed to detect
    a specific type of gesture. You can handle the most commonly used gestures with
    the following subclasses:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIGestureRecognizer` 有几个子类，每个子类都设计用来检测特定类型的手势。你可以使用以下子类来处理最常用的手势：'
- en: '`UITapGestureRecognizer`: This class detects the tapping gesture made on the
    device screen by the user.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UITapGestureRecognizer`：这个类可以检测用户在设备屏幕上所做的点击手势。'
- en: '`UIPinchGestureRecognizer`: This class detects the pinching gesture made on
    screen by the user. This motion is usually used to zoom in or out of a view or
    to change the size of a visual component.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UIPinchGestureRecognizer`：这个类可以检测用户在屏幕上所做的捏合手势。这种动作通常用于放大或缩小视图，或改变视觉组件的大小。'
- en: '`UIPanGestureRecognizer`: This class detects the dragging or panning gesture
    that the user makes.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UIPanGestureRecognizer`：这个类可以检测用户所做的拖动或平移手势。'
- en: '`UISwipeGestureRecognizer`: This class detects when the user makes a swiping
    gesture across the screen. Instances of this class may be configured to detect
    motion only in a specific direction.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UISwipeGestureRecognizer`：这个类可以检测用户在屏幕上做出滑动手势的情况。这个类的实例可能被配置为只检测特定方向的运动。'
- en: '`UIRotationGestureRecognizer`: This class identifies the rotation gesture that
    the user makes. (To make a rotation gesture, move two fingers located opposite
    each other in contact with the screen and move them in a circular motion.)'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UIRotationGestureRecognizer`：这个类可以识别用户所做的旋转手势。（要做出旋转手势，请将两个相对的手指放在屏幕上接触，并使它们做圆形运动。）'
- en: '`UILongPressGestureRecognizer`: This class is used to identify when the user
    touches the screen with one or more fingers for a specified period of time.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UILongPressGestureRecognizer`：这个类用于识别用户用一只或多只手指触摸屏幕一段时间的情况。'
- en: Gesture example
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手势示例
- en: 'The following is an example of how the gesture feature can be used:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何使用手势功能的示例：
- en: 'Create an application that will help us understand the various gestures we
    have discussed in the last section:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个应用程序，帮助我们理解上一节中讨论的各种手势：
- en: '[PRE27]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Update the `app_delegate.rb` file in the `app` folder:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `app` 文件夹中的 `app_delegate.rb` 文件：
- en: '[PRE28]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, create a file named `gesture_controller.rb` in the `app` folder and add
    the following code:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `app` 文件夹中创建一个名为 `gesture_controller.rb` 的文件，并添加以下代码：
- en: '[PRE29]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Run the application using the following command:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行应用程序：
- en: '[PRE30]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output is as follows:'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Gesture example](img/5220OT_06_09.jpg)'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![手势示例](img/5220OT_06_09.jpg)'
- en: Tip
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You must be wondering how we can use multi-touch on a simulator. To use this
    feature on a simulator, hold the *Option* key; doing this will display two circles
    on the simulator screen. You can move them in the desired direction.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能想知道我们如何在模拟器上使用多点触控。要在模拟器上使用此功能，请按住*Option*键；这样做将在模拟器屏幕上显示两个圆圈。你可以将它们移动到所需的方向。
- en: '![Gesture example](img/5220OT_06_10.jpg)'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![手势示例](img/5220OT_06_10.jpg)'
- en: 'Now let''s understand the code. First, we created a different recognizer for
    each class:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来理解一下代码。首先，我们为每个类创建了一个不同的识别器：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: For each recognizer, we'll call an action. This means that whenever the user
    creates a pattern or makes a gesture, such as a rotation, its corresponding action
    is called. For example, when a user tries to pinch the view, `pinchGestureRecognizer`
    gets called.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个识别器，我们将调用一个动作。这意味着每当用户创建一个模式或做出一个手势，如旋转，其对应动作就会被调用。例如，当用户尝试捏合视图时，`pinchGestureRecognizer`就会被调用。
- en: 'Remember that after we have created the recognizers, we need to add them to
    the view so that users can interact with them. We did this by adding them to the
    `addGestureRecognizer()` method by passing the recognizer object to the view:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在我们创建了识别器之后，我们需要将它们添加到视图中，以便用户可以与之交互。我们通过将识别器对象传递给`addGestureRecognizer()`方法来实现这一点：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, we created actions for each gesture. We are just showing a pop-up when
    the user shows any of the common gestures. For example, when we pinch, the following
    code is called:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为每个手势创建了动作。当用户展示任何常见手势时，我们只是显示一个弹出窗口。例如，当我们进行捏合操作时，以下代码会被调用：
- en: '[PRE33]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This action is called in several states, such as when pinching starts and when
    pinching stops. For discrete gestures, such as a tapping gesture, the gesture
    recognizer invokes the method once per recognition; for continuous gestures, the
    gesture recognizer invokes the method at repeated intervals until the gesture
    ends (that is, until the last finger is lifted from the gesture recognizer''s
    view). So, there can be many states that you can find by `UIGestureRecognizerState`.
    Its value can be one of the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个动作会在几个状态下被调用，例如捏合开始和捏合停止时。对于离散手势，如轻触手势，手势识别器会在每次识别时调用该方法；对于连续手势，手势识别器会在重复的间隔内调用该方法，直到手势结束（即，直到最后一个手指从手势识别器的视图中抬起）。因此，你可以通过`UIGestureRecognizerState`找到许多状态，其值可以是以下之一：
- en: '`UIGestureRecognizerStatePossible`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UIGestureRecognizerStatePossible`'
- en: '`UIGestureRecognizerStateBegan`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UIGestureRecognizerStateBegan`'
- en: '`UIGestureRecognizerStateChanged`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UIGestureRecognizerStateChanged`'
- en: '`UIGestureRecognizerStateEnded`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UIGestureRecognizerStateEnded`'
- en: '`UIGestureRecognizerStateCancelled`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UIGestureRecognizerStateCancelled`'
- en: '`UIGestureRecognizerStateFailed`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UIGestureRecognizerStateFailed`'
- en: '`UIGestureRecognizerStateRecognized` = `UIGestureRecognizerStateEnded`![Gesture
    example](img/5220OT_06_11.jpg)'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UIGestureRecognizerStateRecognized` = `UIGestureRecognizerStateEnded`![手势示例](img/5220OT_06_11.jpg)'
- en: As shown in the preceding figure, when a gesture is recognized, every subsequent
    state transition causes an action message to be sent to the target. When a gesture
    recognizer reaches the **Recognized** or **Ended** state, it is asked to reset
    its internal state in preparation for a new attempt at recognizing the gesture.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，当一个手势被识别时，每个后续的状态转换都会导致向目标发送一个动作消息。当手势识别器达到**Recognized**或**Ended**状态时，它会被要求重置其内部状态，以便为新尝试识别手势做准备。
- en: Tip
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Responses to the gestures should be in line with what the users expect. For
    example, a pinching gesture should scale a view, zooming it in and out; it should
    not be interpreted as, say, a selection request, for which a tap is more appropriate.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对手势的响应应与用户期望的一致。例如，捏合手势应该缩放视图，使其放大和缩小；它不应被解释为，比如说，选择请求，对于这种请求，轻触更合适。
- en: Do it yourself
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自己动手做
- en: 'You can implement your own custom gesture recognizer. To implement this, first
    create a subclass of `UIGestureRecognizer`. Then you can override the following
    methods:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以实现自己的自定义手势识别器。要实现这一点，首先创建一个`UIGestureRecognizer`的子类。然后你可以重写以下方法：
- en: '`reset`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reset`'
- en: '`touchesBegan`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`touchesBegan`'
- en: '`touchesMoved`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`touchesMoved`'
- en: '`touchesEnded`'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`touchesEnded`'
- en: '`touchesCancelled`'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`touchesCancelled`'
- en: Core Data – manage your data
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Core Data – 管理你的数据
- en: Sometimes applications are required to save and manipulate user data. iOS SDK
    provides a framework for this purpose known as Core Data.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 有时应用程序需要保存和操作用户数据。iOS SDK为此目的提供了一个名为Core Data的框架。
- en: The **Core Data** framework provides comprehensive and automated solutions related
    to an object's life cycle and its searching and persistence features. It can retrieve
    and manipulate data purely on an object level without having to worry about the
    details of storage and retrieval.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**Core Data** 框架提供了与对象生命周期及其搜索和持久化功能相关的全面和自动化的解决方案。它可以在对象级别上检索和操作数据，而不必担心存储和检索的细节。'
- en: With Core Data, data can be handled using higher-level objects indicating entities
    and their relationships. Core Data interfaces directly with SQLite, separating
    the developer from the underlying SQL.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Core Data，可以通过表示实体及其关系的更高级对象来处理数据。Core Data 直接与 SQLite 交互，将开发者与底层的 SQL 分隔开来。
- en: So does it mean Core Data is a database? No; Core Data is not a database and
    the best example of this is that Core Data can be used totally in memory without
    any form of persistence. Then is Core Data similar to an ORM such as Active Record
    or Hibernate? No; Core Data is an object graph manager with life cycle, searching,
    and persistence features. With Core Data, an app can define a database schema,
    create a database file, and create and manage record data.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这意味着 Core Data 是一个数据库吗？不；Core Data 不是一个数据库，最好的例子是 Core Data 可以完全在内存中使用，而不需要任何持久化形式。那么
    Core Data 是否类似于 Active Record 或 Hibernate 这样的 ORM？不；Core Data 是一个具有生命周期、搜索和持久化功能的对象图管理器。使用
    Core Data，应用程序可以定义数据库模式、创建数据库文件以及创建和管理记录数据。
- en: Core Data example
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Core Data 示例
- en: 'We will create a simple employee application that will allow us to add the
    name and age of an employee. This example is only used to demonstrate how Core
    Data works:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的员工应用程序，允许我们添加员工的姓名和年龄。这个例子仅用于演示 Core Data 的工作原理：
- en: 'Let''s create an application using the `motion` command:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `motion` 命令创建一个应用程序：
- en: '[PRE34]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Add the `CoreData` framework in the `rake.rb` file:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `rake.rb` 文件中添加 `CoreData` 框架：
- en: '[PRE35]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This will be an MVC application, so let''s create a model named `employee.rb`
    in the `app` folder:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将是一个 MVC 应用程序，所以让我们在 `app` 文件夹中创建一个名为 `employee.rb` 的模型：
- en: '[PRE36]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You must have noticed that we have inherited the `Employee` class from `NSManagedObject`.
    We have created an array of arrays for attributes in the `employee` table with
    the attributes `name` and `age`. You must be wondering what other parameters there
    are in this array. To understand this, we will have to write a few helpers in
    our application.
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你一定注意到了，我们已经从 `NSManagedObject` 继承了 `Employee` 类。我们在 `employee` 表的属性中创建了一个数组数组，属性包括
    `name` 和 `age`。你可能想知道这个数组中还有哪些其他参数。为了理解这一点，我们将在应用程序中编写一些辅助函数。
- en: 'Let''s create a folder named `helper` and add a file named `NSEntityDescription.rb`
    with the following code in it:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `helper` 的文件夹，并在其中添加一个名为 `NSEntityDescription.rb` 的文件，文件中包含以下代码：
- en: '[PRE37]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The attributes that we have created in the employee model are defined through
    this class. For each attribute, the `NSAttributeDescription` class will be used
    to define them. The `NSAttributeDescription` class is used to describe attributes
    of an entity described by an instance of `NSEntityDescription`. It is inherited
    from `NSPropertyDescription`, which provides most of the basic behavior. Instances
    of `NSAttributeDescription` are used to describe attributes, as distinct from
    relationships. We can define many properties for an object of `NSAttributeDescription`;
    for example, we can put a validation on it, we can index the attribute, and much
    more.
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在员工模型中创建的属性是通过这个类定义的。对于每个属性，将使用 `NSAttributeDescription` 类来定义它们。`NSAttributeDescription`
    类用于描述由 `NSEntityDescription` 实例描述的实体的属性。它继承自 `NSPropertyDescription`，它提供了大部分基本行为。`NSAttributeDescription`
    的实例用于描述属性，而不是关系。我们可以为 `NSAttributeDescription` 的对象定义许多属性；例如，我们可以在它上面添加验证，我们可以对属性进行索引，等等。
- en: 'Next, create a file named `NSManagedObject.rb` in the `app` folder and add
    the following code:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在 `app` 文件夹中创建一个名为 `NSManagedObject.rb` 的文件，并添加以下代码：
- en: '[PRE38]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: An `NSEntityDescription` object describes an entity in Core Data. An entity
    to a manage object is what a class is to an ID or, to use a database analogy,
    what tables are to rows. An `NSEntityDescription` object may have `NSAttributeDescription`
    and `NSRelationshipDescription` objects that represent the properties of the entity
    in the schema. An entity may also have fetched properties, represented by instances
    of `NSFetchedPropertyDescription`, and the model may have fetched request templates,
    represented by instances of `NSFetchRequest`.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`NSEntityDescription`对象描述了Core Data中的一个实体。对于一个托管对象来说，实体就像类对于ID一样，或者用数据库的比喻来说，就像表对于行一样。`NSEntityDescription`对象可能包含`NSAttributeDescription`和`NSRelationshipDescription`对象，它们代表了模式中实体的属性。实体还可以有检索属性，由`NSFetchedPropertyDescription`的实例表示，模型还可以有检索请求模板，由`NSFetchRequest`的实例表示。'
- en: 'Now, add the following code to the `app_delegate.rb` file:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将以下代码添加到`app_delegate.rb`文件中：
- en: '[PRE39]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Till now we have done some basic settings that we are required to do before
    actually using database operations. In this case, we are stating that our objects
    must be stored in a SQLite database at a location we define in our code with the
    filename `EmployeeStore.sqlite`.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经完成了一些基本的设置，这是在实际使用数据库操作之前必须做的。在这种情况下，我们声明我们的对象必须存储在我们代码中定义的位置的SQLite数据库中，文件名为`EmployeeStore.sqlite`。
- en: In the preceding code, we have created an object of `NSManagedObjectModel` with
    all the entities. You can think of this object as a reference of the objects to
    be used by Core Data. The next object needed is the `NSPersistentStoreCoordinator`
    object that will allow Core Data to persist the information. It is also responsible
    for choosing a location to save our objects.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个包含所有实体的`NSManagedObjectModel`对象。你可以把这个对象想象成Core Data将要使用的对象的参考。下一个需要的对象是`NSPersistentStoreCoordinator`对象，它将允许Core
    Data持久化信息。它还负责选择一个位置来保存我们的对象。
- en: In the last part of our code, we have used the most important class, which is
    the `NSManagedObjectContext` class. This class is responsible for creating, destroying,
    and fetching the objects. An instance of `NSManagedObjectContext` represents a
    single "object space" or scratch pad in an application. Its primary responsibility
    is to manage a collection of managed objects. These objects form a group of related
    model objects that represent an internally consistent view of one or more persistent
    stores. A single managed object instance exists in one and only one context, but
    multiple copies of an object can exist in different contexts.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们代码的最后部分，我们使用了最重要的类，即`NSManagedObjectContext`类。这个类负责创建、销毁和检索对象。`NSManagedObjectContext`的一个实例代表应用程序中的一个单个“对象空间”或草稿板。它的主要职责是管理一组托管对象。这些对象形成了一个相关模型对象的组，代表了一个或多个持久存储的内部一致视图。单个托管对象实例存在于一个上下文中，并且只有一个上下文，但一个对象可以在不同的上下文中存在多个副本。
- en: 'Let''s fire up the terminal and run our application using the following command:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们启动终端并使用以下命令运行我们的应用程序：
- en: '[PRE40]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '![Core Data example](img/5220OT_06_12.jpg)'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Core Data示例](img/5220OT_06_12.jpg)'
- en: 'You will see a blank screen as we have not yet created the controller and view.
    We will create them in the next section, but before that, let''s first update
    the `app_delegate` file to accommodate the controller and view with the following
    code:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将看到一个空白的屏幕，因为我们还没有创建控制器和视图。我们将在下一节中创建它们，但在那之前，让我们首先使用以下代码更新`app_delegate`文件以适应控制器和视图：
- en: '[PRE41]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Creating an employee
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建员工
- en: 'In the last part of the previous code snippet, we initialized `EmployeeViewController`.
    Next, we will pass the managed object context to the next controller that will
    later be used for either creating, fetching, or deleting objects. And in the end,
    we will create a window and assign `EmployeeViewController` as its root controller:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一段代码的最后部分，我们初始化了`EmployeeViewController`。接下来，我们将管理对象上下文传递给下一个控制器，该控制器将用于创建、检索或删除对象。最后，我们将创建一个窗口并将`EmployeeViewController`设置为它的根控制器：
- en: 'Create a file named `employee_view_controller.rb` in the `app` folder with
    the following code in it:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app`文件夹中创建一个名为`employee_view_controller.rb`的文件，并在其中添加以下代码：
- en: '[PRE42]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, let''s fetch specific objects using the `NSFetchRequest` object. We also
    need to tell Core Data which entity we want to retrieve. This can be done using
    `NSEntityDescription`:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们使用`NSFetchRequest`对象检索特定对象。我们还需要告诉Core Data我们想要检索哪个实体。这可以通过`NSEntityDescription`来完成：
- en: '[PRE43]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: That's a lot of code; let's try to understand it. First, we created a `tableView`
    to create a table as it's the best way to represent this type of data. Then, we
    created a **+** button at the top of the navigation bar with the `add_new_employee`
    action associated with it. When this button is pressed, it calls the `add_new_employee`
    action that, in turn, calls a new view, shows a form, and adds a new employee.
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码很多；让我们尝试理解它。首先，我们创建了一个 `tableView` 来创建表格，因为这是表示此类数据的最佳方式。然后，我们在导航栏顶部创建了一个
    **+** 按钮，并将其与 `add_new_employee` 动作关联。当按下此按钮时，它会调用 `add_new_employee` 动作，该动作反过来调用一个新视图，显示表单，并添加一个新员工。
- en: Then, we created a `reload_data` method that will be called to refresh the view
    with employee data. It will fetch the employee data using the `NSFetchRequest`
    object. Then, we declared `NSEntityDescription` for the `Employee` object so we
    can tell Core Data which entity we want to retrieve. We also sorted the result
    by name using `NSSortDescriptor`.
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们创建了一个 `reload_data` 方法，该方法将被调用来刷新视图并显示员工数据。它将使用 `NSFetchRequest` 对象获取员工数据。然后，我们声明了
    `NSEntityDescription` 用于 `Employee` 对象，这样我们就可以告诉 Core Data 我们想要检索哪个实体。我们还使用 `NSSortDescriptor`
    对结果按名称进行排序。
- en: 'In the last part of our example, we created an `update_fetched_employee_with_fetch_request`
    method that will fetch the employee array and update the table to show all of
    the data. `NSManagedObjectContext` executes the fetch request that we created
    using the following code:'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的示例的最后部分，我们创建了一个 `update_fetched_employee_with_fetch_request` 方法，该方法将获取员工数组并更新表格以显示所有数据。`NSManagedObjectContext`
    执行我们创建的以下代码的获取请求：
- en: '[PRE44]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Next, we will create the view that will be called when the **+** button is
    clicked on. Let''s create a file named `add_employee_view_controller.rb` and add
    the following code to it:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建当点击 **+** 按钮时将被调用的视图。让我们创建一个名为 `add_employee_view_controller.rb` 的文件，并向其中添加以下代码：
- en: '[PRE45]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'With the preceding code, we created two text fields, one for name and the other
    for age and we first added a **Save** button on top of the view that will save
    the employee details by calling the `save_employee` action. In the `save_employee`
    action, we used Core Data to create a new instance of the `employee` object in
    the following way:'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用前面的代码，我们创建了两个文本框，一个用于姓名，另一个用于年龄，并在视图顶部添加了一个 **保存** 按钮，通过调用 `save_employee`
    动作来保存员工详细信息。在 `save_employee` 动作中，我们使用 Core Data 以以下方式创建 `employee` 对象的新实例：
- en: '[PRE46]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Then, we assigned the value of the text field to the `employee` object and finally
    saved that object and navigated to `EmployeeViewController`.
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们将文本框的值赋给 `employee` 对象，并最终保存该对象并导航到 `EmployeeViewController`。
- en: 'Let''s fire up the terminal and run our application using the following command:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们启动终端，并使用以下命令运行我们的应用程序：
- en: '[PRE47]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The output is as follows:'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Creating an employee](img/5220OT_06_13.jpg)'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![创建员工](img/5220OT_06_13.jpg)'
- en: Now, let's add data to the **Employee** form using the view:![Creating an employee](img/5220OT_06_14.jpg)
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用视图向 **Employee** 表单添加数据：![创建员工](img/5220OT_06_14.jpg)
- en: Deleting the employee
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除员工
- en: 'With the completion of the last section, our Core Data application is capable
    of adding new employee records. But there may be instances when we''ll need to
    delete an employee record. In this section, we''ll enhance our app to delete employee
    records. The use case for this feature will be such that when we slide any row,
    the system will ask for a confirmation. And once we confirm, the record will be
    deleted:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 完成最后部分后，我们的 Core Data 应用程序能够添加新的员工记录。但可能会有需要删除员工记录的情况。在本节中，我们将增强我们的应用程序以删除员工记录。此功能的用例将是，当我们滑动任何行时，系统将要求确认。一旦我们确认，记录将被删除：
- en: 'Update the `employee_view_controller.rb` file with the following code:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `employee_view_controller.rb` 文件，添加以下代码：
- en: '[PRE48]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'With the iOS `tableView`, we have a direct way of creating or deleting a row.
    In the preceding code, we first passed the value `true` to the `tableView(tableView,
    canEditRowAtIndexPath: indexPath)` delegate. Then in order to perform a delete
    action, we defined the `tableView(tableView, commitEditingStyle: editingStyle,
    forRowAtIndexPath: indexPath)` delegate.'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '使用 iOS 的 `tableView`，我们有直接创建或删除行的方法。在前面代码中，我们首先将值 `true` 传递给 `tableView(tableView,
    canEditRowAtIndexPath: indexPath)` 代理。然后为了执行删除操作，我们定义了 `tableView(tableView, commitEditingStyle:
    editingStyle, forRowAtIndexPath: indexPath)` 代理。'
- en: 'Once we fetch the row that we want to delete, we use `NSManagedObjectContext`
    to delete that object:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们获取到要删除的行，我们使用 `NSManagedObjectContext` 来删除该对象：
- en: '[PRE49]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Tip
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Remember that we have to always call `save` to persist it to our database.
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记住，我们必须始终调用`save`来将其持久化到我们的数据库中。
- en: 'Let''s fire up the terminal and run the application using the following command:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们启动终端并使用以下命令运行应用程序：
- en: '[PRE50]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The output is as follows:'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Deleting the employee](img/5220OT_06_15.jpg)'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![删除员工](img/5220OT_06_15.jpg)'
- en: As shown in the preceding screenshot, when we slide the row, we get a system
    prompt to delete the row. And once we click on **Delete**, the row gets deleted.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个屏幕截图所示，当我们滑动行时，系统会提示我们删除该行。一旦我们点击**删除**，该行就会被删除。
- en: Address Book – manage your contacts
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通讯录 – 管理您的联系人
- en: Address Book for iOS provides a way to store the contact information and other
    personal information of people in a centralized database that can then be shared
    between various applications. In this section, we will perform basic operations
    related to the Address Book.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: iOS通讯录提供了一种方式，可以将人们的联系信息和其它个人信息存储在一个集中的数据库中，然后可以在各种应用程序之间共享。在本节中，我们将执行与通讯录相关的基本操作。
- en: 'We will perform the following operations in this section:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将执行以下操作：
- en: Access the device's Address Book
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问设备的通讯录
- en: Choose a desired user
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择一个用户
- en: Copy data from the Address Book into our application
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将通讯录中的数据复制到我们的应用程序中
- en: 'Perform the following steps to work with an Address Book:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以使用通讯录：
- en: 'Let''s first create a sample address book application with our favorite `motion`
    command:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先使用我们最喜欢的`motion`命令创建一个示例通讯录应用程序：
- en: '[PRE51]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Next, let''s create a controller named `addressbook_controller.rb` and replace
    the following code in `app_delegate.rb` so that our delegate points to our address
    book controller:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个名为`addressbook_controller.rb`的控制器，并在`app_delegate.rb`中替换以下代码，以便我们的代理指向通讯录控制器：
- en: '[PRE52]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Next, in our `addressbook_controller.rb` controller, which will initially be
    empty, we will add a button and two labels. With the button, we will access our
    Address Book and thereafter choose the desired contact. In the labels, we will
    display the data of the user that we had selected from the Address Book. Let''s
    add the following code in our `addressbook_controller` controller:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在我们的`addressbook_controller.rb`控制器中，它最初将是空的，我们将添加一个按钮和两个标签。通过按钮，我们将访问我们的通讯录，然后选择所需的联系人。在标签中，我们将显示从通讯录中选定的用户的数据。让我们在我们的`addressbook_controller`控制器中添加以下代码：
- en: '[PRE53]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Let''s `rake` and see the progress so far:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们`rake`并查看到目前为止的进度：
- en: '[PRE54]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The output is as follows:'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Address Book – manage your contacts](img/5220OT_06_16.jpg)'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![通讯录 – 管理您的联系人](img/5220OT_06_16.jpg)'
- en: 'In the preceding step, we mentioned about a `phonebook_access` method; let''s
    create it. This method will help us access our device''s Address Book. Further,
    let''s add the following code to our `addressbook_controller.rb` file:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前一个步骤中，我们提到了`phonebook_access`方法；让我们创建它。这个方法将帮助我们访问设备的通讯录。此外，让我们将以下代码添加到我们的`addressbook_controller.rb`文件中：
- en: '[PRE55]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Once again, let's execute the `rake` command and see if we are able to access
    the Address Book by clicking on the **Click for contacts** button:![Address Book
    – manage your contacts](img/5220OT_06_17.jpg)
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次执行`rake`命令，看看我们是否能够通过点击**点击以选择联系人**按钮访问通讯录：![通讯录 – 管理您的联系人](img/5220OT_06_17.jpg)
- en: 'With the last step, we are in our Address Book and can see the list of contacts.
    Next, we need to add a method that will copy the desired contact and navigate
    back to our application. This can be done with `peoplePickerNavigationController`.
    Further, we''ll add the following code in `addressbook_controller`:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最后一步，我们已经进入了通讯录，可以看到联系人的列表。接下来，我们需要添加一个方法来复制所需的联系人并返回到我们的应用程序。这可以通过`peoplePickerNavigationController`来实现。此外，我们将在`addressbook_controller`中添加以下代码：
- en: '[PRE56]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now we need to display all of the data we have copied from the Address Book.
    This can be done using the `displayPerson` method that will let us use the saved
    values. Add the following method to `addressbook_controller`:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要显示从通讯录复制的所有数据。这可以通过使用`displayPerson`方法来实现，它将允许我们使用保存的值。将以下方法添加到`addressbook_controller`：
- en: '[PRE57]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '![Address Book – manage your contacts](img/5220OT_06_18.jpg)'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![通讯录 – 管理您的联系人](img/5220OT_06_18.jpg)'
- en: 'Great! But we have missed something. What if a user changes his mind and does
    not want any contact? We need to find a way to get back to the original application
    from the Address Book. This can be done by adding the following three-line method
    in `addressbook_controller`:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！但我们遗漏了一些东西。如果用户改变主意，不想选择任何联系人怎么办？我们需要找到一种方法从通讯录返回到原始应用程序。这可以通过在`addressbook_controller`中添加以下三行方法来实现：
- en: '[PRE58]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Do it yourself
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 亲自动手
- en: 'So far we have learned a lot; now let''s use our acquired knowledge and improvise
    our restro application by implementing the following changes:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学到了很多；现在让我们利用我们所获得的知识，通过实现以下更改来改进我们的restro应用程序：
- en: Task 1 – show nearest restaurant
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务1 – 显示最近的餐厅
- en: To get data from the server, use the `http://restro.nalwaya.com/restaurants/find_restaurent_distance.json?latitude=#{latitude}&&longitude=#{longitude}`
    API.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 要从服务器获取数据，请使用`http://restro.nalwaya.com/restaurants/find_restaurent_distance.json?latitude=#{latitude}&&longitude=#{longitude}`
    API。
- en: You have to pass the latitude and longitude with this request, and in return,
    you will get a list of restaurants in the JSON format. Use this as input and create
    a view displaying the results.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须与这个请求一起传递纬度和经度，然后您将获得一个包含餐厅列表的JSON格式。使用这个作为输入并创建一个显示结果的视图。
- en: Task 2 – mark each restaurant on a map with a pin
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务2 – 在地图上用图钉标记每个餐厅
- en: Use the `http://restro.nalwaya.com/restaurants/search.json?city={city_name}`
    API that will give you a list of restaurants with their latitude and longitude
    in the JSON format. Use these coordinates to show their location on the map.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`http://restro.nalwaya.com/restaurants/search.json?city={city_name}` API，它将为您提供包含经纬度的餐厅列表，格式为JSON。使用这些坐标在地图上显示他们的位置。
- en: Once you are done with this exercise, compare your solution with the one available
    in the chapter code available with this book.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个练习后，将你的解决方案与本书提供的章节代码中的解决方案进行比较。
- en: Summary
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'The following is what we have learned in this chapter:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们在本章中学到的内容：
- en: How to access Camera
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何访问相机
- en: How to use Core Location
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Core Location
- en: How to use different device gestures
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用不同的设备手势
- en: How to store data on a phone using Core Data
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Core Data在手机上存储数据
- en: How to access the Address Book
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何访问通讯录
- en: Now that we are acclimatized with the basics of RubyMotion, in the next chapter
    we will dig deep into the advanced features of iOS SDK with RubyMotion. iOS SDK
    is very powerful and has vast functionalities. In the next chapter, we will discuss
    how to use `.storyboard`, `.xib`, and `WebView` in detail, to create a truly interactive
    application.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了RubyMotion的基础知识，在下一章中，我们将深入探讨RubyMotion的iOS SDK高级功能。iOS SDK功能强大，具有广泛的功能。在下一章中，我们将详细讨论如何使用`.storyboard`、`.xib`和`WebView`，以创建一个真正交互式的应用程序。
