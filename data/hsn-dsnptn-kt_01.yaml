- en: Getting Started with Kotlin
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin 入门
- en: In this chapter, we'll cover basic Kotlin syntax, and discuss what design patterns
    are good for and why they should be used in Kotlin.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍基本的 Kotlin 语法，并讨论哪些设计模式是好的，以及为什么应该在 Kotlin 中使用它们。
- en: The goal of this chapter is not to cover the entire language vocabulary, but
    to get you familiar with some basic concepts and idioms. The following chapters
    will slowly expose you to more language features as they become relevant to the
    design patterns we'll discuss.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标不是涵盖整个语言词汇表，而是让你熟悉一些基本概念和惯用语。接下来的章节将逐渐向你展示更多与我们将讨论的设计模式相关的语言特性。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Basic language syntax and features
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本语言语法和特性
- en: Introduction to design patterns
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计模式简介
- en: Basic language syntax and features
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本语言语法和特性
- en: Whether you come from Java, C#, Scala or any other statically typed programming
    language, you'll find Kotlin syntax quite familiar. This is not by coincidence,
    but to make the transfer to this new language as smooth as possible for those
    with previous experience in other languages. Besides that familiarity, Kotlin
    brings a vast amount of features, such as better type safety. As we move ahead,
    you'll notice that all of them are attempting to solve real-world problems. That
    pragmatic approach is very consistent across the language. For example, one of
    the strongest sides of Kotlin is complete Java interoperability. You can have
    Java and Kotlin classes alongside each other, and freely use any library that
    is available in Java for a Kotlin project.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是从 Java、C#、Scala 还是任何其他静态类型编程语言开始，你都会发现 Kotlin 语法非常熟悉。这不是巧合，而是为了让那些在其他语言中有经验的人尽可能顺利地过渡到这门新语言。除了这种熟悉感之外，Kotlin
    还带来了大量的特性，如更好的类型安全性。随着我们前进，你会发现它们都在尝试解决现实世界的问题。这种实用主义方法在语言中非常一致。例如，Kotlin 最强的优势之一是完整的
    Java 互操作性。你可以在 Java 和 Kotlin 类旁边使用，并且可以自由地使用任何可用于 Kotlin 项目的 Java 库。
- en: 'To summarize, the goals of language are as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，语言的目标如下：
- en: Pragmatism
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实用主义
- en: Having clear syntax
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有清晰的语法
- en: Being type-safe
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有类型安全性
- en: Interoperability
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互操作性
- en: The first chapter will discuss how these goals are achieved.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 第一章将讨论如何实现这些目标。
- en: Multi-paradigm
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多范式
- en: Some of the major paradigms in programming languages are procedural, object-oriented,
    and functional paradigms.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言中的主要范式包括过程范式、面向对象范式和函数式范式。
- en: Being practical, Kotlin allows for any of these paradigms. It has classes and
    inheritance, coming from the object-oriented approach. It has higher-order functions
    from functional programming. But you don't have to wrap everything in classes
    if you don't want to. You can structure your entire code as just a set of procedures
    and structs. You will see how all these approaches come together, as different
    examples will use different paradigms to solve the problems discussed.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 是一个实用的语言，它允许使用任何这些范式。它有类和继承，来自面向对象的方法。它有来自函数式编程的高阶函数。但如果你不想的话，不必将所有内容都封装在类中。你可以将整个代码结构为一系列过程和结构。你将看到所有这些方法是如何结合在一起的，因为不同的示例将使用不同的范式来解决讨论中的问题。
- en: Code structure
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码结构
- en: The first thing you'll need to do when you start programming in Kotlin is create
    a new file. Kotlin's extension is usually `.kt`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始用 Kotlin 编程时，你需要做的第一件事是创建一个新文件。Kotlin 的扩展名通常是 `.kt`。
- en: Unlike Java, there's no strong relationship between the filename and class name.
    You can put as many public classes in your file as you want, as long as the classes
    are related to one another and your file doesn't grow too long to read.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Java 不同，文件名和类名之间没有强烈的关系。你可以将尽可能多的公共类放入文件中，只要这些类彼此相关，并且文件不要太长，难以阅读。
- en: No semicolons
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无分号
- en: 'In Java, every line of code must be terminated with a semicolon:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，每一行代码都必须以分号结束：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'But Kotlin is a pragmatic language. So, instead, it infers during compilation
    where it should put the semicolons:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 但 Kotlin 是一种实用主义语言。因此，它会在编译期间推断出应该放置分号的位置：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Most of the time, you won't need to put semicolons in your code. They're considered
    optional.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，你不需要在代码中添加分号。它们被认为是可选的。
- en: Naming conventions
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名约定
- en: As a convention, if your file contains a single class, name your file the same
    as your class.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个惯例，如果你的文件中只有一个类，那么将文件名与类名相同。
- en: If your file contains more than one class, then the filename should describe
    the common purpose of those classes. Use CamelCase when naming your files, as
    per the Kotlin Coding Conventions: [https://kotlinlang.org/docs/reference/coding-conventions.html#naming-rules](https://kotlinlang.org/docs/reference/coding-conventions.html#naming-rules).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的文件包含多个类，那么文件名应该描述这些类的共同用途。根据Kotlin编码规范，使用驼峰式命名文件：[https://kotlinlang.org/docs/reference/coding-conventions.html#naming-rules](https://kotlinlang.org/docs/reference/coding-conventions.html#naming-rules)。
- en: 'Actually, you don''t have to write your code in a file for simple snippets.
    You can also play with the language online: try [http://kotlinlang.org/](http://kotlinlang.org/) or
    use REPL and interactive shell after installing Kotlin and running `kotlinc`.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你不需要为简单的代码片段编写文件。你还可以在线与语言互动：尝试[http://kotlinlang.org/](http://kotlinlang.org/)或安装Kotlin后运行`kotlinc`并使用REPL和交互式shell。
- en: Packages
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包
- en: It wouldn't be convenient to have all your classes and functions in the same
    folder or under the same namespace. That's the reason Kotlin, similar to many
    other languages, uses the notion of a package.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的所有类和函数都在同一个文件夹或同一个命名空间下，这并不方便。这就是为什么Kotlin，类似于许多其他语言，使用包的概念。
- en: 'Like Java, Kotlin uses packages:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 与Java一样，Kotlin使用包：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you're mixing Java and Kotlin, Kotlin files should follow Java package rules.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你混合使用Java和Kotlin，Kotlin文件应遵循Java包规则。
- en: In purely Kotlin projects, common package prefixes can be omitted from the folder
    structure. For example, if all your projects are under the `me.soshin` package,
    place your controllers in the `/controllers` folder and not in the `/me/soshin/controllers`
    folder like Java does.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯Kotlin项目中，可以从文件夹结构中省略常见的包前缀。例如，如果你的所有项目都在`me.soshin`包下，请将控制器放在`/controllers`文件夹中，而不是像Java那样放在`/me/soshin/controllers`文件夹中。
- en: Types
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型
- en: We'll start with the Kotlin type system, and compare it to what Java provides.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从Kotlin类型系统开始，并将其与Java提供的进行比较。
- en: The Java examples are for familiarity, and not to prove that Kotlin is superior
    to Java in any way.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Java示例是为了熟悉，并不是为了证明Kotlin在任何一个方面都优于Java。
- en: Type inference
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型推断
- en: 'Let''s define a simple string in Java:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Java中定义一个简单的字符串：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We defined that `s` is of type `String`. But why? Isn't it obvious at this point?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了`s`是`String`类型。但为什么？在这个时候不是显然的吗？
- en: 'Kotlin provides us with type inference:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin为我们提供了类型推断：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, the compiler will decide what type of variable should be used. Unlike
    interpreted languages (such as JavaScript, Groovy, or Ruby), the type of variable
    is defined only once. This will not work:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编译器将决定应该使用哪种类型的变量。与解释型语言（如JavaScript、Groovy或Ruby）不同，变量的类型只定义一次。这不会起作用：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You may wonder why we've used one `var` and one `val` to define the variables.
    We'll explain it shortly.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么我们使用了一个`var`和一个`val`来定义变量。我们很快就会解释。
- en: val versus var
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`val`与`var`'
- en: 'In Java, variables can be declared final. Final variables can be assigned only
    once:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，变量可以被声明为`final`。`final`变量只能赋值一次：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Kotlin urges you to use immutable data as much as possible. Final variables
    in Kotlin are simply `val`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin强烈建议尽可能使用不可变数据。Kotlin中的`final`变量只是`val`：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you do have a case in which you would like to reassign a variable, use `var` instead:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实有一个想要重新分配变量的情况，请使用`var`：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Comparison
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较
- en: We were taught very early in Java that comparing objects using `==` won't produce
    the expected results, since it tests for reference equality, and we need to use
    `equals()` for that.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Java的早期学习中就被告知，使用`==`比较对象不会产生预期的结果，因为它测试的是引用相等性，我们需要使用`equals()`来做到这一点。
- en: 'JVM does string interning to prevent that in some basic cases, so for the sake
    of the example we''ll use `new String()` to avoid that:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: JVM在基本情况下进行字符串池化以防止这种情况，因此为了示例，我们将使用`new String()`来避免这种情况：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Kotlin translates `==` to `equals()`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin将`==`转换为`equals()`：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you do want to check for reference equality, use `===`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实想检查引用相等性，请使用`===`：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Null safety
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空安全
- en: Probably the most notorious exception in the Java world is `NullPointerException`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java世界中，最臭名昭著的异常可能是`NullPointerException`。
- en: 'The reason behind this exception is that every object in Java can be `null`.
    The code here shows us why:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这种异常背后的原因是Java中的每个对象都可以是`null`。这里的代码展示了原因：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this case, marking `s` as `final` would prevent the exception.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，将`s`标记为`final`将防止异常发生。
- en: 'But what about this one:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个呢：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'From anywhere in the code it''s still possible to pass `null`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码的任何地方都可以传递`null`：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Since Java 8, there''s been an `optional` construct:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 自Java 8以来，有一个`optional`构造：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In a more functional style:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在更函数式的方式中：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: But... it doesn't solve our problem. We can still pass `null` instead of the
    proper `Optional.empty()` and crash the program.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 但是……这并没有解决我们的问题。我们仍然可以用`null`代替正确的`Optional.empty()`并使程序崩溃。
- en: 'Kotlin checks it even earlier—during compile time:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin在编译时就会检查它：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s go back to our `printLength()` function:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的`printLength()`函数：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Calling this function with null won''t compile any more:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用null调用这个函数将无法编译：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you specifically want your type to be able to receive nulls, you''ll need
    to mark it as nullable using the question mark:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望您的类型能够接收null值，您需要使用问号将其标记为可空：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Declaring functions
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明函数
- en: Everything is an object in Java. If you have a method that doesn't rely on any
    state, it still must be wrapped by a class. You're probably familiar with a lot
    of `Util` classes in Java that only have static methods, and their only purpose
    is to satisfy the language requirements and bundle those methods together.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，一切都是对象。如果您有一个不依赖于任何状态的方法，它仍然必须被类包裹。您可能熟悉Java中许多只包含静态方法的`Util`类，它们的唯一目的是满足语言要求并将这些方法捆绑在一起。
- en: 'In Kotlin, a function can be declared outside of a class instead of the following
    code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，函数可以声明在类外部，而不是以下代码：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'It''s enough to have:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 只需这样就可以了：
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Functions declared outside of any class are already static.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何类外部声明的函数已经是静态的。
- en: 'Many examples in this book assume that the code we provide is wrapped in the
    main function. If you don''t see a signature of the function, it probably should
    be:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的许多示例都假设我们提供的代码被包裹在主函数中。如果您没有看到函数的签名，它可能应该是这样的：
- en: '`fun main(args: Array<String>)`.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`fun main(args: Array<String>)`。'
- en: The keyword to declare a function is `fun`. The argument type comes after the
    argument name, and not before. And if the function doesn't return anything, the
    return type can be omitted completely.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 声明函数的关键字是`fun`。参数类型跟在参数名称之后，而不是之前。如果函数不返回任何内容，可以完全省略返回类型。
- en: 'What if you do want to declare the return type? Again, it will come after the
    function declaration:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您确实想声明返回类型？同样，它将紧跟在函数声明之后：
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: There are lots of other topics regarding function declarations, such as default
    and named arguments, default parameters, and variable numbers of arguments. We'll
    introduce them in the following chapters, with relevant examples.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 关于函数声明还有很多其他主题，比如默认和命名参数、默认参数和可变数量的参数。我们将在接下来的章节中介绍它们，并附上相关示例。
- en: Control flow
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制流
- en: 'One could say that control flow is the bread and butter of writing programs.
    We''ll start with two conditional expressions: `if` and `when`.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说，控制流是编写程序的基础。我们将从两个条件表达式开始：`if`和`when`。
- en: Using the if expression
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用if表达式
- en: 'Previously it was noted that Kotin likes variables to be assigned only once.
    And it also doesn''t like nulls so much. You probably wondered how that would
    ever work out in the real world. In Java, constructs such as this are quite common:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到Kotlin喜欢变量只分配一次。它也不太喜欢null。您可能想知道这在现实世界中是如何工作的。在Java中，这样的结构相当常见：
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Of course, this is an oversimplified situation, but still, you have a variable
    that at some point absolutely must be `null`, right?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是一个过于简化的情况，但仍然，您有一个变量，在某个时刻绝对必须是`null`，对吧？
- en: 'In Java, `if` is just a statement and doesn''t return anything. On the contrary,
    in Kotlin, `if` is an expression, meaning it returns a value:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，`if`只是一个语句，不返回任何内容。相反，在Kotlin中，`if`是一个表达式，意味着它返回一个值：
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If you are familiar with Java, you can easily read this code. This function
    receives a Boolean (which cannot be null), and returns a string (and never a null).
    But since it is an expression, it can return a result. And the result is assigned
    to our variable only once.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉Java，您可以轻松阅读这段代码。这个函数接收一个布尔值（不能为null），并返回一个字符串（永远不会为null）。但由于它是一个表达式，它可以返回一个结果。并且结果只分配给我们的变量一次。
- en: 'We can simplify it even further:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以进一步简化它：
- en: The return type could be inferred
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回类型可以推断
- en: The return as the last line can be omitted
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后一行的返回可以省略
- en: A simple `if` expression can be written in one line
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个简单的`if`表达式可以写在一行中
- en: 'So, our final result in Kotlin will look like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的最终结果在Kotlin中将看起来像这样：
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Single line functions in Kotlin are very cool and pragmatic. But you should
    make sure that somebody else other than you can understand what they do. Use with
    care.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin中的单行函数非常酷且实用。但您应该确保除了您之外的其他人也能理解它们的功能。请谨慎使用。
- en: Using the when expression
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`when`表达式
- en: What if (no pun intended) we want to have more conditions in our `if` statement?
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果（不是字面意义上的玩笑）我们想在`if`语句中有更多的条件呢？
- en: In Java, we use the `switch` statement. In Kotlin, there's a `when` expression,
    which is a lot more powerful, since it can embed some other Kotlin features.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，我们使用`switch`语句。在Kotlin中，有一个更强大的`when`表达式，因为它可以嵌入一些其他的Kotlin特性。
- en: 'Let''s create a method that''s based on the amount of money that  will give
    cause to suggest a nice birthday gift:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个基于将产生建议一个不错的生日礼物的原因的金额的方法：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, `when` also supports a range of values. The default case is
    covered by the `else` block. In the following examples, we will elaborate on even
    more powerful ways to use this expression.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`when`也支持一系列值。默认情况由`else`块处理。在下面的示例中，我们将更详细地阐述使用这个表达式的更强大方式。
- en: As a general rule, use `when` if you have more than two conditions. Use `if`
    for simple checks.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一般规则是，如果有超过两个条件，使用`when`。对于简单的检查，使用`if`。
- en: String interpolation
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串插值
- en: What if we would like to actually print those results?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要实际打印这些结果呢？
- en: First, as you may have already noticed, in one of the examples above, Kotlin
    provides a nifty `println()` standard function that wraps the bulkier `System.out.println()`
    from Java.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，正如你可能已经注意到的，在上面的一个示例中，Kotlin提供了一个巧妙的`println()`标准函数，它封装了Java中更庞大的`System.out.println()`。
- en: 'But, more importantly, as in many other modern languages, Kotlin supports string
    interpolation using the `${}` syntax. Following on from the example before:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，更重要的是，就像许多其他现代语言一样，Kotlin支持使用`${}`语法进行字符串插值。在之前的示例之后继续：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The preceding code would print:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将打印以下内容：
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you''re interpolating a variable, and not a function, curly braces could
    be omitted:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在插值一个变量，而不是一个函数，可以省略大括号：
- en: '[PRE31]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This would print the following output:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印以下输出：
- en: '[PRE32]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Classes and inheritance
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类和继承
- en: Although Kotlin is multi-paradigm, it has a strong affinity to the Java programming
    language, which is based on classes. Keeping Java and JVM interoperability in
    mind, it's no wonder that Kotlin also has the notion of classes and classical
    inheritance.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Kotlin是多范式的，但它与基于类的Java编程语言有着强烈的亲和力。考虑到Java和JVM的互操作性，Kotlin也有类和经典继承的概念也就不足为奇了。
- en: Classes
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: 'To declare a `class`, we use a class keyword, exactly like in Java:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了声明一个`class`，我们使用类关键字，就像在Java中一样：
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'There''s no `new` keyword in Kotlin. The instantiation of a class simply looks
    like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin中没有`new`关键字。类的实例化看起来就像这样：
- en: '[PRE34]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If the class has no body, as in this simple example, we can omit the **curly
    brackets**:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类没有主体，就像这个简单的例子一样，我们可以省略大括号：
- en: '[PRE35]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Inheritance
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: 'Exactly like in Java, abstract classes are marked by `abstract` and interfaces
    by the `interface` keyword:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 正如Java中的情况一样，抽象类由`abstract`关键字标记，接口由`interface`关键字标记：
- en: '[PRE36]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As in Java 8, interfaces in Kotlin can have a default implementation of functions,
    as long as they don''t rely on any state:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Java 8一样，Kotlin中的接口可以有函数的默认实现，只要它们不依赖于任何状态：
- en: '[PRE37]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'There are no `inherits` and `implements` keywords in Kotlin. Instead, both
    the name of an abstract class and all the names of the interfaces that class implements
    are put after a colon:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin中没有`inherits`和`implements`关键字。相反，抽象类的名称以及该类实现的所有接口的名称都放在冒号后面：
- en: '[PRE38]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We can still distinguish the abstract class by the parenthesis that comes after
    its name, and there can still be only one `abstract` class, as there are no multiple
    inheritances in Kotlin.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以通过其名称后面的括号来区分抽象类，并且仍然只能有一个`abstract`类，因为Kotlin中没有多重继承。
- en: 'Our `DungeonMaster` has access to both functions from `Greeter` and `AbstractDungeonMaster`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`DungeonMaster`可以访问`Greeter`和`AbstractDungeonMaster`中的两个函数：
- en: '[PRE39]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Calling the preceding code, it will print the following output:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 调用前面的代码，它将打印以下输出：
- en: '[PRE40]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Constructors
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数
- en: 'Our `DungeonMaster` looks a bit awkward now, since it can proclaim the start
    of only one game. Let''s add a non-empty constructor to our `abstract` class to
    fix that:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`DungeonMaster`现在看起来有点尴尬，因为它只能宣布开始一个游戏。让我们给我们的`abstract`类添加一个非空构造函数来解决这个问题：
- en: '[PRE41]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, our `DungeonMaster` must receive the name of the game and pass it to the
    `abstract` class:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的`DungeonMaster`必须接收游戏名称并将其传递给`abstract`类：
- en: '[PRE42]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: What if we wanted to extend `DungeonMaster` by having an `EvilDungeonMaster`?
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要通过一个`EvilDungeonMaster`来扩展`DungeonMaster`呢？
- en: In Java, all classes can be extended, unless they're marked `final`. In Kotlin,
    no class can be extended, unless it's marked `open`. The same goes for functions
    in abstract classes. That's the reason why we declared `DungeonMaster` as `open`
    in the first place.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，除非被标记为`final`，否则所有类都可以被扩展。在Kotlin中，除非被标记为`open`，否则没有类可以被扩展。这同样适用于抽象类中的函数。这就是为什么我们最初将`DungeonMaster`声明为`open`的原因。
- en: 'We''ll change `AbstractDungeonMaster` a bit again to give more power to the
    evil ruler:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对`AbstractDungeonMaster`进行一些修改，以赋予邪恶统治者更多的权力：
- en: '[PRE43]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, we add the following to our `EvilDungeonMaster` implementation:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在我们的`EvilDungeonMaster`实现中添加以下内容：
- en: '[PRE44]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Whereas in Java, `@Override` is an optional annotation, in Kotlin it is a mandatory
    keyword.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 而在Java中，`@Override`是一个可选的注解，在Kotlin中则是一个强制的关键字。
- en: You cannot hide supertype methods, and code that doesn't use `override` explicitly
    won't compile.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能隐藏超类型方法，并且没有显式使用`override`的代码将无法编译。
- en: Properties
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性
- en: 'In Java, we are used to the concept of getters and setters. A typical class
    may look something like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，我们习惯于getter和setter的概念。一个典型的类可能看起来像这样：
- en: '[PRE45]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If we want to get a person's name, we call `getName()`. If we want to change
    it, we call `setName()`. That's quite simple.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要获取一个人的名字，我们调用`getName()`。如果我们想更改它，我们调用`setName()`。这很简单。
- en: 'If we want to set the name only once, during object instantiation, we can specify
    the non-default constructor and remove the setter as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想在对象实例化期间设置一次名字，我们可以指定非默认构造函数并删除setter，如下所示：
- en: '[PRE46]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: All this dates back to the beginning of Java, somewhere around '95.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都可以追溯到Java的起点，大约在1995年左右。
- en: 'But if you''ve worked with C#, for example, you''re probably familiar with
    the idea of properties. To understand them, let''s go to the first example and
    change it a bit:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你例如与C#一起工作过，你可能熟悉属性的概念。为了理解它们，让我们回到第一个示例并稍作修改：
- en: '[PRE47]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Reading a person''s name is not much shorter: `p.name`.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 读取一个人的名字并不短多少：`p.name`。
- en: 'Also, changing the name is much more intuitive: `p.name = "Alex";`.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，更改名字的方式更加直观：`p.name = "Alex";`。
- en: But by doing so, we lost a lot of control over our object. We cannot make `PublicPerson`
    immutable. If we want everybody to be able to read the person's name, they'll
    also be able to change it at any point in time. And what if later we decide that
    all names must be uppercase? With setter, we could do that. But not with the public
    field.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 但这样做，我们失去了对我们对象的大量控制。我们无法使`PublicPerson`不可变。如果我们想让每个人都能读取人的名字，他们也可以在任何时候更改它。如果我们后来决定所有名字都必须是大写字母，我们可以通过setter来实现这一点。但不是通过公共字段。
- en: 'Properties provide a solution for all those problems:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 属性为所有这些问题提供了一个解决方案：
- en: '[PRE48]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This may look the same as the Java example, with all its problems. But actually,
    behind the scenes, it's compiled to a getter and setter pair, just like the first
    example.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来与Java示例相同，带有所有其问题。但实际上，在幕后，它被编译为一个getter和setter对，就像第一个示例一样。
- en: 'And since properties in Kotlin are translated into getters and setters, we
    can also control their behavior:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Kotlin中的属性被转换为getter和setter，我们也可以控制它们的行为：
- en: '[PRE49]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note that we don't need to check that `value` is null. The `String` type simply
    cannot receive nulls.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不需要检查`value`是否为null。`String`类型简单地不能接收null值。
- en: 'Coming from Java, it may seem intuitive to use the following assignment: `this.name
    = value.toUpperCase()`. But, in Kotlin, this will create a circular dependency.
    Instead, there''s a `field` identifier that we''re using, which is provided automatically.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 来自Java，使用以下赋值可能看起来很直观：`this.name = value.toUpperCase()`。但在Kotlin中，这将创建一个循环依赖。相反，我们使用了一个`field`标识符，它是自动提供的。
- en: Data classes
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类
- en: Remember how Kotlin is all about productiveness? One of the most common tasks
    for Java developers is to create another **Plain Old Java Object** (**POJO**).
    If you're not familiar with POJO, it is basically an object that only has getters,
    setters, and an implementation of `equals` or `hashCode` methods.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 记得Kotlin的全部都是关于生产力吗？Java开发者最常见的任务之一是创建另一个 **普通的Java对象** (**POJO**)。如果你不熟悉POJO，它基本上是一个只有getter、setter以及`equals`或`hashCode`方法实现的对象。
- en: 'This task is so common that Kotlin has it built into the language:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务如此常见，以至于Kotlin将其内置到语言中：
- en: '[PRE50]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This will generate a class with two getters and no setters (note the `val` part),
    which will also implement `equals`, `hashCode`, and `clone` functions in the correct
    way.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个具有两个getter而没有setter（注意`val`部分）的类，它还将以正确的方式实现`equals`、`hashCode`和`clone`函数。
- en: The introduction of data classes is one of the biggest improvements in reducing
    the amount of boilerplate in the language.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类的引入是语言中减少样板代码的最大改进之一。
- en: More control flow – loops
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多的控制流 - 循环
- en: Now let's discuss another common control structure—a loop. Loops are a very
    natural construct for most developers. Without loops, it would be very hard to
    repeat the same block of code more than once (although we will discuss how to
    do that without loops in later chapters).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们讨论另一个常见的控制结构——循环。循环对于大多数开发者来说是一个非常自然的结构。没有循环，重复相同的代码块将非常困难（尽管我们将在后面的章节中讨论如何在没有循环的情况下做到这一点）。
- en: The for loop
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: For 循环
- en: 'The `for` loop in Java, which prints each character of a string on a new line,
    may look something like this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Java 中的 `for` 循环，它将字符串的每个字符打印在新的一行上，可能看起来像这样：
- en: '[PRE51]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The same loop in Kotlin is:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 中的相同循环如下：
- en: '[PRE52]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note that while the usual `for` loop in Java is exclusive (it excludes the last
    index by definition, unless specified otherwise), the `for` loop over ranges in
    Kotlin is inclusive. That's the reason we have to subtract one from the length
    to prevent overflow (string index out of range): `(word.length-1)`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然 Java 中的常规 `for` 循环是排他的（它根据定义排除了最后一个索引，除非有其他指定），但 Kotlin 中对范围的 `for` 循环是包含的。这就是为什么我们必须从长度中减去一来防止溢出（字符串索引超出范围）：`(word.length-1)`。
- en: 'If you want to avoid that, you can use the `until` function:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想避免这种情况，可以使用 `until` 函数：
- en: '[PRE53]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Unlike some other languages, reversing the range indexes won''t work:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他一些语言不同，反转范围索引不起作用：
- en: '[PRE54]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If your intention is to print the word in reverse order, for example, use the
    `downTo` function:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要以相反的顺序打印单词，例如，使用 `downTo` 函数：
- en: '[PRE55]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'It will print the following output:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 它将打印以下输出：
- en: '[PRE56]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: It may seem confusing that `until` and `downTo` are called functions, although
    they look more like operators. This is another interesting Kotlin feature called
    **infix call**, which will be discussed later on.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会让人困惑的是，尽管 `until` 和 `downTo` 看起来更像操作符，但它们被称为函数。这是 Kotlin 另一个有趣的功能，称为 **中缀调用**，稍后我们将讨论。
- en: For-each loop
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: For-each 循环
- en: 'Of course, if you''re a bit familiar with Java, you may argue that the previous
    code could be improved by using a `for-each` construct instead:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你对 Java 有点熟悉，你可能会争辩说，前面的代码可以通过使用 `for-each` 构造来改进：
- en: '[PRE57]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The same in Kotlin would be:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，这将是相同的：
- en: '[PRE58]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: While loop
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: While 循环
- en: 'There are no changes to the `while` loop functionality, so we''ll cover them
    very briefly:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环的功能没有变化，所以我们非常简短地介绍它们：'
- en: '[PRE59]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This will print numbers from 1 to 10\. Note that we are forced to define `x`
    as `var`. In the following chapters, we'll discuss much more idiomatic ways to
    do this.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印从 1 到 10 的数字。请注意，我们被迫将 `x` 定义为 `var`。在接下来的章节中，我们将讨论更多更习惯性的方法来做这件事。
- en: 'The lesser used `do while` loop is also present in the language:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 较少使用的 `do while` 循环也存在于该语言中：
- en: '[PRE60]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Extension functions
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展函数
- en: You may have noticed from the previous examples that `String` in Kotlin has
    some methods that its Java counterpart is lacking, such as `reversed()`. How is
    that achieved, if it's the same `String` type as in Java and, as we know, `String`
    in Java cannot be extended by any other class, since it's declared `final`?
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，从前面的例子中，Kotlin 中的 `String` 有一些方法，其 Java 对应版本缺少，例如 `reversed()`。如果它与
    Java 中的 `String` 类型相同，并且我们知道，Java 中的 `String` 不能被任何其他类扩展，因为它被声明为 `final`，那么这是如何实现的呢？
- en: 'If you look at the source code, you''ll find the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看源代码，你会发现以下内容：
- en: '[PRE61]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This feature is called an extension function, and it also exists in some other
    languages, such as C# or Groovy.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性被称为扩展函数，它也存在于一些其他语言中，例如 C# 或 Groovy。
- en: To extend a class without inheriting from it, we prefix the function name, `reversed`
    in our example, with a class name we want to extend.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要在不继承的情况下扩展一个类，我们可以在示例中函数名 `reversed` 前面加上我们想要扩展的类名。
- en: Do note that the extension function cannot override the member function. The `inline` keyword
    will be discussed in later chapters.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，扩展函数不能覆盖成员函数。`inline` 关键字将在后面的章节中讨论。
- en: Introduction to design patterns
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式简介
- en: Now that we are a bit familiar with basic Kotlin syntax, we can move on to discuss
    what design patterns are all about.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对 Kotlin 的基本语法有点熟悉了，我们可以继续讨论设计模式是什么。
- en: What are design patterns?
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式是什么？
- en: 'There are different misconceptions surrounding design patterns. In general,
    they are as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 围绕设计模式存在不同的误解。一般来说，它们如下：
- en: Missing language features
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺失的语言特性
- en: Not necessary in dynamic language
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在动态语言中不是必需的
- en: Relevant only to object-oriented languages
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅适用于面向对象的语言
- en: Relevant only to enterprises
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅适用于企业
- en: But actually, design patterns are just a proven way to solve a common problem.
    As a concept, they are not limited to a specific programming language (Java),
    nor to a family of languages (C-family, for example), nor are they limited to
    programming in general. You may have even heard of design patterns in software
    architecture, which discuss how different systems can efficiently communicate
    with each other. There are service-oriented architectural patterns, which you
    may know as **Service-Oriented Architecture** (**SOA**), and microservice design
    patterns that evolved from SOA and emerged over the past few years. The future
    will, for sure, bring us even more design pattern *families*.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 但实际上，设计模式只是解决常见问题的一种经过验证的方法。作为一个概念，它们并不局限于特定的编程语言（例如Java），也不局限于语言家族（例如C家族），甚至不局限于编程本身。你可能甚至听说过软件架构中的设计模式，它们讨论了不同的系统如何高效地相互通信。有面向服务的架构模式，你可能知道它为**面向服务架构**（**SOA**），以及从SOA演变而来的微服务设计模式，这些模式在过去几年中逐渐出现。未来肯定会给我们带来更多的设计模式**家族**。
- en: Even in the physical world, outside software development, we're surrounded by
    design patterns and commonly accepted solutions to a certain problem. Let's look
    at an example.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在物理世界中，在软件开发之外，我们也被设计模式和某些问题的常见解决方案所包围。让我们看看一个例子。
- en: Design patterns in real life
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生活中的设计模式
- en: Did you ride an elevator lately? Was there a mirror on the wall of the elevator?
    Why is that?
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 你最近乘坐过电梯吗？电梯墙上有没有镜子？为什么会有这样的设计？
- en: How did you feel when you last rode an elevator that had no mirror and no glass
    walls?
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当你上次乘坐没有镜子也没有玻璃墙的电梯时，你感觉如何？
- en: The main reason we commonly have mirrors in our elevators is to solve a common
    problem. Riding in an elevator is boring. We could put in a picture. But a picture
    would also get boring after a while, if you rode the same elevator at least twice
    a day. Cheap, but not much of an improvement.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在电梯中普遍安装镜子的主要原因是为了解决一个常见问题。乘坐电梯是无聊的。我们可以放一张图片。但如果你每天至少乘坐两次相同的电梯，图片也会很快变得无聊。虽然便宜，但改善不大。
- en: We could put in a TV screen, as some do. But it makes the elevator more expensive.
    And it also requires a lot of maintenance. We need to put some content on the
    screen, to make it not too repetitive. So either there's a person whose responsibility
    is to renew the content once in a while, or a third-party company that does it
    for us. We'll also have to handle different problems that may occur with screen
    hardware and the software behind it. Seeing the "Blue Screen of Death" is amusing,
    of course, but only mildly.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以安装一个电视屏幕，就像有些人做的那样。但这会使电梯更贵。而且它还需要大量的维护。我们需要在屏幕上放置一些内容，以避免重复。所以要么有一个人的责任是偶尔更新内容，要么有一个第三方公司为我们做这件事。我们还得处理屏幕硬件及其背后的软件可能出现的不同问题。当然，看到“蓝屏死机”是很有趣的，但只是轻微的乐趣。
- en: Some architects even go for putting elevator shafts on the building exterior,
    and making part of the walls transparent. This may provide some exciting views.
    But this solution also requires maintenance (dirty windows don't make for the
    best view), and a lot of architectural planning.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 一些建筑师甚至选择将电梯井安装在建筑外部，并使部分墙壁透明。这可能提供一些令人兴奋的视野。但这个解决方案也需要维护（脏窗户不会提供最好的视野），以及大量的建筑规划。
- en: So, we put in a mirror. You get to watch an attractive person even if you ride
    alone. Some studies indicate that we find ourselves more attractive than we are,
    anyway. Maybe you get a chance to review your appearances one last time before
    that important meeting. Mirrors visually expand the visual space and make the
    entire trip less claustrophobic, or less awkward, if it's the start of a day and
    the elevator is really crowded.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们安装了镜子。即使你独自乘坐，你也能看到吸引人的面孔。一些研究表明，我们发现自己比实际更吸引人。也许你有机会在重要会议之前最后一次审视你的外表。镜子从视觉上扩展了视觉空间，使整个旅程不那么令人窒息，或者不那么尴尬，如果这是新的一天，电梯真的很拥挤。
- en: Design process
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计过程
- en: Let's try and understand what we did just now.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试理解我们刚才做了什么。
- en: We didn't invent mirrors in elevators. We've seen them thousands of times. But
    we formalized the problem (riding in an elevator is boring) and discussed alternative
    solutions (TV screens, glass walls) and the benefits of the commonly used solution
    (solves the problem, easy to implement). That's what design patterns are all about.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有在电梯里发明镜子。我们见过它们成千上万次。但我们正式化了这个问题（乘坐电梯很无聊）并讨论了替代方案（电视屏幕、玻璃墙）以及常用解决方案的好处（解决问题，易于实现）。这就是设计模式的所有内容。
- en: 'The basic steps of the design process are:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 设计过程的基本步骤是：
- en: Define exactly what the current problem is.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准确定义当前的问题。
- en: Consider different alternatives, based on the pros and cons.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑不同的替代方案，基于其优缺点。
- en: Choose the solution that solves the problem, while best fitting your specific
    constraints.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择解决问题的方案，同时最好地符合你的具体约束。
- en: Why use design patterns in Kotlin?
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么在 Kotlin 中使用设计模式？
- en: Kotlin comes to solve the real-world problems of today. In the following chapters,
    we will discuss both *Design Patterns* first introduced by the Gang of Four back
    in '94, as well as design patterns that emerged from the functional programming
    paradigm.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 出现是为了解决当今的现实世界问题。在接下来的章节中，我们将讨论由四人帮在 94 年首次提出的 *设计模式*，以及从函数式编程范式出现的设计模式。
- en: You'll find that some of the design patterns are so common or useful that they're
    already built into the language as reserved keywords or standard functions. Some
    of them will need to combine a set of language features. And some are not so useful
    any more, since the world has moved forward, and they're being replaced by some
    other patterns.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现，一些设计模式非常常见或有用，以至于它们已经作为保留关键字或标准函数内置到语言中。其中一些需要结合一组语言特性。而一些则不再那么有用，因为世界已经前进，它们正被一些其他模式所取代。
- en: But in any case, familiarity with design patterns and best practices expands
    your "developer toolbox" and creates shared vocabulary between you and your colleagues.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 但无论如何，熟悉设计模式和最佳实践扩展了你的“开发者工具箱”，并在你和你同事之间创造了共享的词汇。
- en: Summary
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: So, in this chapter, we covered the main goals of the Kotlin programming language.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们介绍了 Kotlin 编程语言的主要目标。
- en: 'We went through the variables that are defined, such as `val`, `var`, null
    safety, and type inference. We observed how program flow is controlled by commands
    such as `if`, `when`, `for`, and `while`, and we also took a look at the different
    keywords used to define classes and interfaces: `class`, `interface`, `data`,
    and `abstract` class. We learned how to construct new classes and how we inherit
    from interfaces and implement classes. And finally, we learned what design patterns
    are good for, and why we need them in Kotlin.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了定义的变量，例如 `val`、`var`、空安全性和类型推断。我们观察了程序流程是如何通过 `if`、`when`、`for` 和 `while`
    等命令来控制的，我们还查看了解决类和接口定义的不同关键字：`class`、`interface`、`data` 和 `abstract` 类。我们学习了如何构建新的类，以及我们如何从接口继承和实现类。最后，我们学习了设计模式的好处，以及为什么在
    Kotlin 中需要它们。
- en: 'In the next chapter, we''ll start discussing the first of the three design
    pattern families: creation patterns.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始讨论三种设计模式家族中的第一个：创建型模式。
