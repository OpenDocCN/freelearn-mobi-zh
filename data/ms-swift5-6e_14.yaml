- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Working with Closures
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与闭包一起工作
- en: Today, most major programming languages have functionalities similar to those
    of closures in Swift. Some of these implementations are really hard to use (Objective-C
    blocks), while others are easy (Java lambdas and C# delegates). I have found that
    the functionality that closures provide is especially useful when developing frameworks.
    I have also used them extensively when communicating with remote services over
    a network connection. While blocks in Objective-C are incredibly useful, the syntax
    used to declare a block is absolutely horrible. Luckily, when Apple was developing
    the Swift language, they made the syntax of closures much easier to use and understand.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，大多数主要的编程语言都有类似于 Swift 中闭包的功能。其中一些实现非常难以使用（Objective-C 的 blocks），而其他则相对容易（Java
    的 lambdas 和 C# 的 delegates）。我发现闭包提供的功能在开发框架时特别有用。我也在通过网络连接与远程服务通信时广泛使用了它们。虽然 Objective-C
    中的 blocks 非常有用，但声明 block 所使用的语法绝对糟糕。幸运的是，当 Apple 开发 Swift 语言时，他们使闭包的语法更容易使用和理解。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What are closures?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是闭包？
- en: How to create a closure
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建闭包
- en: How to use a closure
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用闭包
- en: What are some examples of useful closures?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有哪些有用的闭包示例？
- en: How to avoid strong reference cycles within closures
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何避免闭包内的强引用循环
- en: An introduction to closures
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 闭包简介
- en: Closures are self-contained blocks of code that can be passed around and used
    throughout our application. We can think of the `Int` type as a type that contains
    an integer, and the `String` type as a type that contains a string. In this context,
    a closure can be thought of as a type that contains a block of code. This means
    that we can assign closures to a variable, pass them as arguments to functions,
    and return them from a function.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包是包含代码块的自包含代码块，可以在我们的应用程序中传递和使用。我们可以将 `Int` 类型视为包含整数的类型，将 `String` 类型视为包含字符串的类型。在这种情况下，闭包可以被视为包含代码块的类型。这意味着我们可以将闭包赋值给变量，将它们作为参数传递给函数，并从函数中返回它们。
- en: Closures can capture and store references to any variable or constant from the
    context in which they were defined. This is known as closing over the variables
    or constants and, for the most part, Swift will handle the memory management for
    us. The only exception is in creating a strong reference cycle, and we will look
    at how to resolve this in the *Creating strong reference cycles with closures*
    section of *Chapter 18*, *Memory Management*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包可以捕获并存储它们定义上下文中的任何变量或常量的引用。这被称为覆盖变量或常量，并且大部分情况下，Swift 会为我们处理内存管理。唯一的例外是在创建强引用循环时，我们将在第
    18 章“内存管理”的“使用闭包创建强引用循环”部分中探讨如何解决这个问题。
- en: 'Closures in Swift are similar to blocks in Objective-C; however, closures in
    Swift are a lot easier to use and understand. Let''s look at the syntax used to
    define a closure in Swift:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 中的闭包与 Objective-C 中的 blocks 类似；然而，Swift 中的闭包使用起来更容易，也更易于理解。让我们看看在 Swift
    中定义闭包所使用的语法：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The syntax used to create a closure looks very similar to the syntax we use
    to create functions, and in Swift, global and nested functions are closures. The
    biggest difference in the format between closures and functions is the `in` keyword.
    The `in` keyword is used in place of curly brackets to separate the definition
    of the closure's parameter and return types from the body of the closure.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 创建闭包所使用的语法看起来与我们用来创建函数的语法非常相似，在 Swift 中，全局和嵌套函数都是闭包。闭包和函数之间格式上的最大区别是 `in` 关键字。`in`
    关键字用于代替花括号，将闭包的参数和返回类型的定义与闭包体分开。
- en: There are many uses for closures, and we will go over a number of them later
    in this chapter, but first, we need to understand the basics of closures. Let's
    start by looking at some very basic closures so that we can get a better understanding
    of what they are, how to define them, and how to use them.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包有很多用途，我们将在本章后面讨论其中的一些，但首先，我们需要了解闭包的基本知识。让我们先看看一些非常基础的闭包，以便我们更好地理解它们是什么，如何定义它们，以及如何使用它们。
- en: Simple closures
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单闭包
- en: 'We will begin by creating a very simple closure that does not accept any arguments
    and does not return any value. All it does is print `Hello World` to the console.
    Let''s look at the following code:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从创建一个非常简单的闭包开始，这个闭包不接受任何参数，也不返回任何值。它所做的只是将 `Hello World` 打印到控制台。让我们看看以下代码：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, we create a closure and assign it to the `clos1` constant.
    Since there are no parameters defined between the parentheses, this closure will
    not accept any parameters. Also, the return type is defined as `Void`; therefore,
    this closure will not return any value. The body of the closure contains one line,
    which prints `Hello World` to the console.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个闭包并将其赋值给`clos1`常量。由于括号之间没有定义任何参数，这个闭包将不接受任何参数。此外，返回类型被定义为`Void`；因此，这个闭包不会返回任何值。闭包的主体包含一行，将`Hello
    World`打印到控制台。
- en: 'There are many ways to use closures; in this example, all we want to do is
    execute it. We can execute the closure as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用闭包的方法有很多；在这个例子中，我们只想执行它。我们可以按照以下方式执行闭包：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After executing the closure, we will see that `Hello World` is printed to the
    console. At this point, closures may not seem that useful, but as we get further
    along in this chapter, we will see how useful and powerful they can be.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行闭包之后，我们会看到`Hello World`被打印到了控制台。在这个阶段，闭包可能看起来并不那么有用，但随着我们继续学习本章内容，我们将看到它们是多么有用和强大。
- en: 'Let''s look at another simple example. This closure will accept one `String`
    parameter named `name` but will not return a value. Within the body of the closure,
    we will print out a greeting to the name passed into the closure through the `name`
    parameter. Here is the code for this second closure:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个简单的例子。这个闭包将接受一个名为`name`的`String`参数，但不会返回任何值。在闭包的主体内部，我们将打印出通过`name`参数传递给闭包的问候语。这是第二个闭包的代码：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The big difference between the `clos2` closure and the `clos1` closure is that
    we define a single `String` parameter between the parentheses. As we can see,
    we define parameters for closures just like we define parameters for functions.
    We can execute this closure in the same way in which we executed the `clos1` closure.
    The following code shows how this is done:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`clos2`闭包和`clos1`闭包之间最大的区别是我们定义了一个单独的`String`参数在括号之间。正如我们所看到的，我们为闭包定义参数的方式就像我们为函数定义参数一样。我们可以以执行`clos1`闭包相同的方式执行这个闭包。下面的代码展示了如何做到这一点：'
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This example, when executed, will print the `Hello Jon` message to the console.
    Let's look at another way we can use the `clos2` closure. One thing to note in
    this example is that the named parameters in a closure do not require the parameter
    name to be used.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个例子执行时，将会打印出`Hello Jon`的消息到控制台。让我们看看另一种我们可以使用`clos2`闭包的方法。在这个例子中需要注意的一点是，闭包中的命名参数不需要使用参数名。
- en: 'Our original definition of closures stated that Closures are self-contained
    blocks of code that can be passed around and used throughout our application.
    This tells us that we can pass our closures from the context that they were created
    into other parts of our code. Let''s look at how to pass our `clos2` closure into
    a function. We will define a function that accepts our `clos2` closure, as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对闭包的原始定义是：闭包是自包含的代码块，可以在我们的应用程序中传递和使用。这告诉我们我们可以将我们的闭包从它们被创建的上下文中传递到代码的其他部分。让我们看看如何将我们的`clos2`闭包传递给一个函数。我们将定义一个函数，它接受我们的`clos2`闭包，如下所示：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We define the function just like we would any other function; however, in the
    parameter list, we define a parameter named `handler`, and the type defined for
    the `handler` parameter is `(String) -> Void`. If we look closely, we can see
    that the `(String) -> Void` definition of the `handler` parameter matches the
    parameter and return types that we defined for the `clos2` closure. This means
    that we can pass the `clos2` closure into the function. Let''s look at how to
    do this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义函数的方式就像定义任何其他函数一样；然而，在参数列表中，我们定义了一个名为`handler`的参数，并为`handler`参数定义了类型`(String)
    -> Void`。如果我们仔细观察，我们可以看到`handler`参数的`(String) -> Void`定义与为`clos2`闭包定义的参数和返回类型相匹配。这意味着我们可以将`clos2`闭包传递给函数。让我们看看如何做到这一点：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We call the `testClosure()` function just like any other function, and the
    closure that is being passed in looks like any other variable. Since the `clos2`
    closure is executed in the `testClosure()` function, we will see the message `Hello
    Dasher` printed to the console when this code is executed. As we will see a little
    later in this chapter, the ability to pass closures to functions is what makes
    closures so exciting and powerful. As the final piece to the closure puzzle, let''s
    look at how to return a value from a closure. The following example shows this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像调用任何其他函数一样调用 `testClosure()` 函数，传入的闭包看起来就像任何其他变量一样。由于 `clos2` 闭包在 `testClosure()`
    函数中被执行，因此当这段代码执行时，我们将在控制台看到打印出的消息 `Hello Dasher`。正如我们将在本章稍后看到的那样，将闭包传递给函数的能力使得闭包如此令人兴奋和强大。作为闭包拼图的最后一部分，让我们看看如何从闭包中返回一个值。以下示例展示了这一点：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The definition of the `clos3` closure looks very similar to how we defined
    the `clos2` closure. The difference is that we changed the `Void` return type
    to a `String` type. Then, in the body of the closure, instead of printing the
    message to the console, we used the return statement to return the message. We
    can now execute the `clos3` closure just like the previous two closures or pass
    the closure to a function like we did with the `clos2` closure. The following
    example shows how to execute the `clos3` closure:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`clos3` 闭包的定义看起来与我们之前定义的 `clos2` 闭包非常相似。不同之处在于我们将返回类型从 `Void` 改为了 `String`
    类型。然后，在闭包体中，我们不是将消息打印到控制台，而是使用返回语句返回消息。现在我们可以像之前两个闭包一样执行 `clos3` 闭包，或者像处理 `clos2`
    闭包那样将闭包传递给函数。以下示例展示了如何执行 `clos3` 闭包：'
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After this line of code is executed, the message variable will contain the `Hello
    Buddy` string. The previous three examples of closures demonstrate the format
    and how to define a typical closure. Those who are familiar with Objective-C can
    see that the format of closures in Swift is a lot cleaner and easier to use. The
    syntax for creating closures that we have shown so far in this chapter is pretty
    short; however, we can shorten it even more. In this next section, we will look
    at how to do this.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此行代码后，消息变量将包含 `Hello Buddy` 字符串。前面三个闭包示例展示了闭包的格式和定义典型闭包的方法。熟悉 Objective-C
    的人可以注意到，Swift 中闭包的格式要干净得多，也更容易使用。我们在本章中迄今为止展示的闭包创建语法相当简短；然而，我们还可以进一步缩短它。在下一节中，我们将探讨如何做到这一点。
- en: Shorthand syntax for closures
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 闭包的简写语法
- en: In this section, we will look at a couple of ways to shorten the syntax.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨几种缩短语法的途径。
- en: Using the shorthand syntax for closures is really a matter of personal preference.
    A lot of developers like to make their code as small and compact as possible,
    and they take great pride in doing so. However, at times this can make the code
    hard to read and understand for other developers.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用闭包的简写语法完全是个人喜好问题。许多开发者喜欢将他们的代码尽可能小和紧凑，并且为此感到非常自豪。然而，有时这会使代码对其他开发者来说难以阅读和理解。
- en: 'The first shorthand syntax for closures that we are going to look at is one
    of the most popular, which is the syntax we saw when we were using algorithms
    with arrays in *Chapter 5*, Using Swift Collections. This format is mainly used
    when we want to send a really small (usually one line) closure to a function,
    like we did with the algorithms for arrays. Before we look at this shorthand syntax,
    we need to write a function that will accept a closure as a parameter:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的第一个闭包简写语法是最受欢迎的之一，这是我们使用 *第 5 章* 中数组算法时看到的语法。这种格式主要用于当我们想要向函数发送一个非常小的闭包（通常是单行）时，就像我们处理数组算法那样。在我们查看这种简写语法之前，我们需要编写一个接受闭包作为参数的函数：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This function accepts two parameters; the first parameter is an integer named
    `num`, and the second parameter is a closure named `handler`, which does not have
    any parameters and does not return any value. Within the function, we create a
    `for` loop that will use the `num` integer to define how many times it loops.
    Within the `for` loop, we call the `handler` closure that was passed into the
    function. Now let''s create a closure and pass it to `testFunction()` as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受两个参数；第一个参数是一个名为 `num` 的整数，第二个参数是一个名为 `handler` 的闭包，该闭包没有参数，也不返回任何值。在函数内部，我们创建一个
    `for` 循环，该循环将使用 `num` 整数来定义循环的次数。在 `for` 循环中，我们调用传入函数的 `handler` 闭包。现在让我们创建一个闭包并将其传递给
    `testFunction()`，如下所示：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This code is very easy to read and understand; however, it does take five lines
    of code. Now let''s look at how to shorten it by writing the closure inline within
    the function call:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码非常易于阅读和理解；然而，它需要五行代码。现在让我们看看如何通过在函数调用内编写闭包来缩短它：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this example, we created the closure inline within the function call, using
    the same syntax that we used with the algorithms for arrays. The closure is placed
    in between two curly brackets (`{}`), which means the code to create the closure
    is `{print("Hello from Shorthand closure")}`. When this code is executed, it will
    print out the `Hello from Shorthand closure` message five times on the screen.
    The ideal way to call the `testFunction()` with a closure, for both compactness
    and readability, would be as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用与数组算法相同的语法在函数调用内行内创建了闭包。闭包放在两个花括号（`{}`）之间，这意味着创建闭包的代码是 `{print("Hello
    from Shorthand closure")}`。当这段代码执行时，它会在屏幕上打印出五次“Hello from Shorthand closure”消息。调用
    `testFunction()` 时，为了简洁性和可读性，理想的方式如下：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Having the closure as the final parameter allows us to leave off the label
    when calling the function. This example gives us both compact and readable code.
    Let''s look at how to use parameters with this shorthand syntax. We will begin
    by creating a new function that will accept a closure with a single parameter.
    We will name this function `testFunction2`. The following example shows what the
    new `testFunction2` function does:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 将闭包作为最后一个参数允许我们在调用函数时省略标签。这个例子给出了既紧凑又易读的代码。让我们看看如何使用这种简写语法来使用参数。我们将首先创建一个新的函数，该函数将接受一个具有单个参数的闭包。我们将把这个函数命名为
    `testFunction2`。以下示例显示了新的 `testFunction2` 函数的作用：
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In `testFunction2`, we define the closure like this: `(_ : String)->Void`.
    This definition means that the closure accepts one parameter and does not return
    any value. Now let''s look at how to use the same shorthand syntax to call this
    function:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '在 `testFunction2` 中，我们这样定义闭包：`(_ : String)->Void`。这个定义意味着闭包接受一个参数并且不返回任何值。现在让我们看看如何使用相同的简写语法来调用这个函数：'
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The difference between this closure definition and the previous one is `$0`.
    The `$0` parameter is shorthand for the first parameter passed into the function.
    If we execute this code, it prints out the `Hello from Me` message five times.
    Using the dollar sign (`$`) followed by a number with inline closures allows us
    to define the closure without having to create a parameter list in the definition.
    The number after the dollar sign defines the position of the parameter in the
    parameter list. Let''s examine this format a bit more, because we are not limited
    to only using the dollar sign (`$`) and number shorthand format with inline closures.
    This shorthand syntax can also be used to shorten the closure definition by allowing
    us to leave the parameter names off. The following example demonstrates this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个闭包定义与之前的定义之间的区别是 `$0`。`$0` 参数是传递给函数的第一个参数的简写。如果我们执行这段代码，它会打印出五次“Hello from
    Me”消息。使用美元符号（`$`）后跟一个数字的行内闭包允许我们在定义中不需要创建参数列表就能定义闭包。美元符号后面的数字定义了参数在参数列表中的位置。让我们更详细地考察一下这个格式，因为我们不仅限于只使用美元符号（`$`）和数字简写格式来定义行内闭包。这种简写语法也可以用来缩短闭包定义，允许我们省略参数名称。以下示例演示了这一点：
- en: '[PRE15]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this example, the closure has two string parameters defined; however, we
    do not give them names. The parameters are defined like this: (`String`, `String`).
    We can then access the parameters within the body of the closure using `$0` and
    `$1`. Also, note that the closure definition is after the colon (`:`), using the
    same syntax that we use to define a variable type rather than inside the curly
    brackets. When we use anonymous arguments, this is how we would define the closure.
    It will not be valid to define the closure as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，闭包定义了两个字符串参数；然而，我们没有给它们命名。参数是这样定义的：（`String`，`String`）。我们可以在闭包体中使用 `$0`
    和 `$1` 访问这些参数。此外，请注意，闭包定义在冒号（`:`）之后，使用的是我们用来定义变量类型的相同语法，而不是在花括号内。当我们使用匿名参数时，这就是我们定义闭包的方式。以下定义闭包的方式是不正确的：
- en: '[PRE16]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this example, we will receive an error letting us know that this format
    is not valid. Next, let''s look at how we would use the `clos5` closure:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们会收到一个错误，告诉我们这种格式是无效的。接下来，让我们看看如何使用 `clos5` 闭包：
- en: '[PRE17]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Since `Hello` is the first string in the parameter list, it is accessed with
    `$0`, and as `Kara` is the second string in the parameter list, it is accessed
    with `$1`. When we execute this code, we will see the `Hello Kara` message printed
    to the console. This next example is used when the closure doesn''t return any
    value. Rather than defining the return type as `Void`, we can use parentheses,
    as the following example shows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Hello` 是参数列表中的第一个字符串，它通过 `$0` 访问，而 `Kara` 作为参数列表中的第二个字符串，通过 `$1` 访问。当我们执行这段代码时，我们将看到
    `Hello Kara` 消息打印到控制台。下一个示例用于当闭包不返回任何值时。我们不必将返回类型定义为 `Void`，我们可以使用括号，如下例所示：
- en: '[PRE18]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In this example, we define the closure as `() -> ()`. This tells Swift that
    the closure does not accept any parameters and also does not return a value. We
    will execute this closure as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将闭包定义为 `() -> ()`。这告诉 Swift 该闭包不接受任何参数，也不返回任何值。我们将如下执行这个闭包：
- en: '[PRE19]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As a personal preference, I am not very fond of this shorthand syntax. I think
    the code is much easier to read when the `Void` keyword is used rather than the
    parentheses.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 作为个人偏好，我并不特别喜欢这种简写语法。我认为当使用 `Void` 关键字而不是括号时，代码更容易阅读。
- en: 'We have one more shorthand closure example to demonstrate before we begin showing
    some really useful examples of closures. In this last example, we will demonstrate
    how we can return a value from the closure without the need to include the `return`
    keyword. If the entire closure body consists of only a single statement, we can
    omit the `return` keyword, and the results of the statement will be returned.
    Let''s look at an example of this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始展示一些非常有用的闭包示例之前，我们还有一个简写闭包示例要展示。在这个最后的例子中，我们将演示我们如何从闭包中返回一个值，而无需包含 `return`
    关键字。如果整个闭包体只包含一个语句，我们可以省略 `return` 关键字，该语句的结果将被返回。让我们看看一个这样的例子：
- en: '[PRE20]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this example, the closure accepts two parameters of the `Int` type and will
    return an instance of the `Int` type. The only statement within the body of the
    closure adds the first parameter to the second parameter. However, if you notice,
    we do not include the `return` keyword before the additional statement. Swift
    will see that this is a single-statement closure and will automatically return
    the results, just as if we put the `return` keyword before the additional statement.
    We do need to make sure the result type of our statement matches the return type
    of the closure.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，闭包接受两个 `Int` 类型的参数，并将返回一个 `Int` 类型的实例。闭包体内的唯一语句是将第一个参数添加到第二个参数。然而，如果你注意到，我们在附加语句之前没有包含
    `return` 关键字。Swift 会看到这是一个单语句闭包，并将自动返回结果，就像我们在附加语句之前放置了 `return` 关键字一样。我们确实需要确保我们语句的结果类型与闭包的返回类型相匹配。
- en: All of the examples shown in the previous two sections were designed to show
    how to define and use closures. On their own, these examples do not really show
    off the power of closures and they do not show how incredibly useful closures
    are. The remainder of this chapter will demonstrate the power and usefulness of
    closures in Swift.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个部分中展示的所有示例都是为了展示如何定义和使用闭包。单独来看，这些示例并没有真正展示闭包的力量，也没有展示闭包是多么有用。本章的剩余部分将展示 Swift
    中闭包的力量和实用性。
- en: Using closures with Swift arrays
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Swift 数组与闭包
- en: In *Chapter 5*, *Using Swift Collections*, we looked at several built-in algorithms
    that we can use with Swift's arrays. In that chapter, we briefly looked at how
    to add simple rules to each of these algorithms with very basic closures. Now
    that we have a better understanding of closures, let's look at how we can expand
    on these algorithms using more advanced closures.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第五章*，*使用 Swift 集合* 中，我们查看了一些可以与 Swift 数组一起使用的内置算法。在那一章中，我们简要地看了如何使用非常基本的闭包为这些算法中的每一个添加简单的规则。现在我们更好地理解了闭包，让我们看看我们如何可以使用更高级的闭包来扩展这些算法。
- en: Using closures with Swift's array algorithms
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Swift 的数组算法与闭包
- en: 'In this section, we will primarily be using the `map` algorithm for consistency
    purposes; however, we can use the basic ideas demonstrated with any of the algorithms.
    We will start by defining an array to use:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将主要使用 `map` 算法以保持一致性；然而，我们可以使用任何算法中展示的基本思想。我们将首先定义一个数组来使用：
- en: '[PRE21]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This array contains a list of names and the array is named `guests`. This array
    will be used for the majority of the examples in this section. Now that we have
    our `guests` array, let''s add a closure that will print a greeting to each of
    the names in the array:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数组包含一个名字列表，这个数组被命名为`guests`。这个数组将用于本节的大部分示例。现在我们有了`guests`数组，让我们添加一个闭包，该闭包将打印数组中每个名字的问候语：
- en: '[PRE22]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Since the `map` algorithm applies the closure to each item of the array, this
    example will print out a greeting for each name within the array. After the first
    section in this chapter, we should have a pretty good understanding of how this
    closure works. Using the shorthand syntax that we saw in the previous section,
    we could reduce the preceding example down to the following single line of code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`map`算法将闭包应用于数组的每个项目，此示例将为数组中的每个名字打印一个问候语。在本章的第一部分之后，我们应该对闭包的工作原理有一个相当好的理解。使用我们在上一节中看到的简写语法，我们可以将前面的示例简化为以下单行代码：
- en: '[PRE23]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This is one of the few times, in my opinion, where the shorthand syntax may
    be easier to read than the standard syntax. Now, let''s say that rather than printing
    the greeting to the console, we wanted to return a new array that contained the
    greetings. For this, we would return a `String` type from our closure, as shown
    in the following example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，这可能是少数几次，简写语法可能比标准语法更容易阅读的情况之一。现在，假设我们不是要将问候语打印到控制台，而是想要返回一个包含问候语的新数组。为此，我们应从闭包中返回一个`String`类型，如下面的示例所示：
- en: '[PRE24]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When this code is executed, the `messages` array will contain a greeting to
    each of the names in the `guests` array, while the array will remain unchanged.
    We could access the greetings as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当这段代码执行时，`messages`数组将包含对`guests`数组中每个名字的问候，而数组本身将保持不变。我们可以按如下方式访问问候语：
- en: '[PRE25]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding examples in this section showed how to add a closure to the `map`
    algorithm inline. This is good if we only had one closure that we wanted to use
    with the `map` algorithm, but what if we had more than one closure that we wanted
    to use, or if we wanted to use the closure multiple times or reuse it with different
    arrays? For this, we could assign the closure to a constant or variable and then
    pass in the closure, using its constant or variable name, as needed. Let's look
    at how to do this. We will begin by defining two closures.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 本节前面的示例展示了如何在`map`算法中内联添加闭包。如果我们只想使用一个闭包与`map`算法，这是很好的，但如果我们想使用多个闭包，或者想多次使用闭包或在不同数组中重用它们呢？为此，我们可以将闭包分配给一个常量或变量，然后根据需要使用闭包的常量或变量名。让我们看看如何做到这一点。我们将首先定义两个闭包。
- en: 'One of the closures will print a greeting for each element in the array, and
    the other closure will print a goodbye message for each element in the array:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个闭包将打印数组中每个元素的问候语，另一个闭包将打印数组中每个元素的告别信息：
- en: '[PRE26]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now that we have two closures, we can use them with the `map` algorithm as
    needed. The following code shows how to use these closures interchangeably with
    the `guests` array:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了两个闭包，我们可以根据需要使用它们与`map`算法。下面的代码展示了如何将这些闭包与`guests`数组交互使用：
- en: '[PRE27]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When we use the `greetGuest` closure with the `guests` array, the greeting
    message is printed to the console, and when we use the `sayGoodbye` closure with
    the `guests` array, the goodbye message is printed to the console. If we had another
    array named `guests2`, we could use the same closures for that array, as shown
    in the following example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`greetGuest`闭包与`guests`数组一起使用时，问候信息将被打印到控制台；当我们使用`sayGoodbye`闭包与`guests`数组一起使用时，告别信息将被打印到控制台。如果我们还有一个名为`guests2`的数组，我们可以使用相同的闭包来处理该数组，如下面的示例所示：
- en: '[PRE28]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'All of the examples in this section so far have either printed a message to
    the console or returned a new array from the closure. We are not limited to such
    basic functionality in our closures. For example, we can filter the array within
    the closure, as shown in the following example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本节中的所有示例要么是将消息打印到控制台，要么是从闭包中返回一个新数组。我们的闭包并不局限于这样的基本功能。例如，我们可以在闭包内过滤数组，如下面的示例所示：
- en: '[PRE29]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this example, we print out a different message depending on whether the name
    starts with the letter `K`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们根据名字是否以字母`K`开头打印不同的消息。
- en: 'As mentioned earlier in the chapter, closures have the ability to capture and
    store references to any variable or constant from the context in which they were
    defined. Let''s look at an example of this. Let''s say that we have a function
    that contains the highest temperature for the last seven days at a given location
    and this function accepts a closure as a parameter. This function will execute
    the closure on the array of temperatures. The function can be written as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所述，闭包具有捕获并存储它们定义上下文中任何变量或常量的引用的能力。让我们来看一个这样的例子。假设我们有一个函数，它包含了一个特定位置过去七天的最高温度，并且这个函数接受一个闭包作为参数。这个函数将在温度数组的数组上执行闭包。这个函数可以写成如下形式：
- en: '[PRE30]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This function accepts a closure, defined as `(Int)-> Void`. We then use the
    `map` algorithm to execute this closure for each item of the `tempArray` array.
    The key to using a closure correctly in this situation is to understand that the
    `temperatures` function does not know, or care, about what goes on inside the
    `calculate` closure. Also, be aware that the closure is also unable to update
    or change the items within the function's context, which means that the closure
    cannot change any other variable within the temperature's function; however, it
    can update variables in the context that it was created in.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受一个闭包，定义为`(Int)-> Void`。然后我们使用`map`算法来执行`tempArray`数组中的每个元素的闭包。在这种情况下正确使用闭包的关键是理解`temperatures`函数不知道，也不关心`calculate`闭包内部的任何操作。此外，请注意，闭包也无法更新或更改函数上下文中的项目，这意味着闭包不能更改温度函数中的任何其他变量；然而，它可以更新它在创建上下文中定义的变量。
- en: 'Let''s look at the function that we will create the closure in. We will name
    this function `testFunction`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们将创建闭包的函数。我们将把这个函数命名为`testFunction`：
- en: '[PRE31]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this function, we begin by defining two variables, named `total` and `count`,
    where both variables are of the `Int` type. We then create a closure named `addTemps`
    that will be used to add all the temperatures from the `temperatures` function
    together. The `addTemps` closure will also count how many temperatures there are
    in the array. To do this, the `addTemps` closure calculates the sum of each item
    in the array and keeps the total in the `total` variable that was defined at the
    beginning of the function. The `addTemps` closure also keeps track of the number
    of items in the array by incrementing the `count` variable for each item. Notice
    that neither the `total` nor `count` variables are defined within the closure;
    however, we are able to use them within the closure because they were defined
    in the same context as the closure.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们首先定义了两个变量，分别命名为`total`和`count`，这两个变量都是`Int`类型。然后我们创建了一个名为`addTemps`的闭包，它将被用来将`temperatures`函数中的所有温度加在一起。`addTemps`闭包还将计算数组中的温度数量。为此，`addTemps`闭包计算数组中每个项目的总和，并将总和保存在函数开头定义的`total`变量中。`addTemps`闭包还通过为每个项目递增`count`变量来跟踪数组中的项目数量。请注意，`total`和`count`变量都没有在闭包内部定义；然而，我们能够在闭包中使用它们，因为它们是在与闭包相同的上下文中定义的。
- en: 'We then call the `temperatures` function and pass it the `addTemps` closure.
    Finally, we print the `Total`, `Count`, and `Average` temperature to the console.
    When `testFunction` is executed, we will see the following output to the console:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们调用`temperatures`函数，并传递`addTemps`闭包。最后，我们将`Total`、`Count`和`Average`温度打印到控制台。当`testFunction`执行时，我们将在控制台看到以下输出：
- en: '[PRE32]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As we can see from the output, the `addTemps` closure is able to update and
    use items that are defined within the context that it was created in, even when
    the closure is used in a different context.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如输出所示，`addTemps`闭包能够更新和使用在它创建的上下文中定义的项目，即使闭包在另一个上下文中使用。
- en: Now that we have looked at using closures with the array `map` algorithm, let's
    look at using closures by themselves. We will also look at the ways we can clean
    up our code to make it easier to read and use.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看了如何使用数组`map`算法与闭包一起使用，让我们看看如何单独使用闭包。我们还将看看我们可以如何清理代码，使其更容易阅读和使用。
- en: Non-contiguous elements from an array
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组中的非连续元素
- en: In *Chapter 5*, *Using Swift Collections*, we showed how to retrieve non-contiguous
    sub-elements from an array using the `subrange` method with a closure. Now that
    we know a little more about closures, let's take a look at this again.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第5章*，*使用Swift集合*中，我们展示了如何使用带有闭包的`subrange`方法从数组中检索非连续的子元素。现在我们知道了更多关于闭包的知识，让我们再次看看这个例子。
- en: 'The code we used in *Chapter 5*, *Using Swift Collections*, retrieved the even
    numbers from an array of integers. Let''s look at this code again:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*第5章*，*使用Swift集合*中使用的代码，从整数数组中检索了偶数。让我们再次看看这段代码：
- en: '[PRE33]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In this example, we used `isMultiple(of: )` from the `Int` type to retrieve
    all elements that are even numbers. Since the `subranges(where: )` method takes
    a closure, we can use other logic as well. For example, if we wanted to retrieve
    all elements that were equal to or less than 6, we could use the following line
    of code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了`Int`类型的`isMultiple(of:)`来检索所有偶数元素。由于`subranges(where:)`方法接受一个闭包，我们也可以使用其他逻辑。例如，如果我们想检索所有等于或小于6的元素，我们可以使用以下代码行：
- en: '[PRE34]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now that we are familiar with closures, we can see some of the possibilities
    of the `subrange(where: )` method.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们熟悉了闭包，我们可以看到`subrange(where:)`方法的一些可能性。
- en: Uninitialized arrays
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 未初始化的数组
- en: 'Swift 5.2 with SE-0245 introduced a new initializer for arrays that does not
    pre-fill the values with a default value. This initializer enables us to provide
    a closure to fill in the values however we like. Let''s take a look at how to
    do this by creating an array that will contain the value of 20 dice rolls:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 5.2与SE-0245一起引入了一个新的数组初始化器，它不会预先使用默认值填充值。这个初始化器使我们能够提供一个闭包来填充我们想要的任何值。让我们通过创建一个将包含20次掷骰子值的数组来看看如何做：
- en: '[PRE35]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We begin by setting a constant that contains the capacity for the array. We
    do this because we need to provide that value in several spots within the initializer
    and by using the constant, if we need to change this capacity at a later time,
    then it only needs to be changed in one spot.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先设置一个包含数组容量的常量。我们这样做是因为我们需要在初始化器中的几个地方提供这个值，通过使用常量，如果我们以后需要更改这个容量，那么只需要在一个地方更改。
- en: The rest of the code initializes the array. The closure provides an unsafe mutable
    buffer pointer, which we named `buffer` in the previous code, that can be used
    to write the values for the array too. We use a `for` loop to populate the array
    with random integer values from 1 to 6.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其余部分初始化了数组。闭包提供了一个不安全的可变缓冲区指针，我们在前面的代码中将其命名为`buffer`，也可以用它来为数组写入值。我们使用`for`循环用1到6的随机整数填充数组。
- en: 'There are some general rules when you are using this initializer:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用这个初始化器时，有一些通用规则：
- en: You do not need to use the full capacity that you ask for; however, you cannot
    use more. In our example, we ask for a capacity of 20 elements, which means we
    can use less than 20, but we cannot use more than 20.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不需要使用你请求的全部容量；然而，你不能使用更多。在我们的例子中，我们请求20个元素的容量，这意味着我们可以使用少于20个，但不能使用超过20个。
- en: If you do not initialize an element, then it will probably be filled with random
    data (very bad idea). In our example, where we request a capacity of 20 elements,
    if we only populated the first 10 elements then the second 10 elements would contain
    random garbage.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你没有初始化一个元素，那么它可能被填充了随机数据（一个非常糟糕的想法）。在我们的例子中，我们请求20个元素的容量，如果我们只填充了前10个元素，那么后面的10个元素将包含随机垃圾。
- en: If `initializedCount` is not set then it will default to `0` and all of the
    data will be lost.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`initializedCount`没有设置，则默认为`0`，所有数据都将丢失。
- en: 'This is a very handy initializer to use but it is also very easy to make a
    mistake with it. We could also rewrite the `diceRolls` initializer using the `map`
    array algorithm, as the following code shows:'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个非常方便的初始化器，但也很容易出错。我们也可以使用`map`数组算法重写`diceRolls`初始化器，如下面的代码所示：
- en: '[PRE36]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: However, this would be less efficient because initializing the array as shown
    in the first example is internally optimized for better performance. If you are
    not worried about the best performance, then the map algorithm is much easier
    to read and understand.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，这会效率更低，因为像第一个例子中那样初始化数组在内部优化了更好的性能。如果你不担心最佳性能，那么映射算法更容易阅读和理解。
- en: Now let's look at how we can use closures to change functionality at runtime.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看我们如何可以使用闭包在运行时改变功能。
- en: Changing functionality
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改变功能
- en: Closures also give us the ability to change the functionality of types on the
    fly. In *Chapter 11*, *Generics*, we saw that generics give us the ability to
    write functions that are valid for multiple types. With closures, we are able
    to write functions and types whose functionality can change, based on the closure
    that is passed in. In this section, we will show you how to write a function whose
    functionality can be changed with a closure.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包还赋予我们动态改变类型功能的能力。在 *第11章*，*泛型* 中，我们看到了泛型赋予我们编写适用于多种类型的函数的能力。通过闭包，我们能够编写功能和类型可以根据传入的闭包而变化的函数。在本节中，我们将向您展示如何编写一个可以通过闭包改变功能的函数。
- en: 'Let''s begin by defining a type that will be used to demonstrate how to swap
    out a functionality. We will name this type `TestType`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从定义一个类型开始，这个类型将用来演示如何替换功能。我们将把这个类型命名为 `TestType`：
- en: '[PRE37]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We begin this type by defining a `typealias` for our closure, which is named
    `GetNumClosure`. Any closure that is defined as a `GetNumClosure` closure will
    take two integers and return a single integer. Within this closure, we assume
    that it does something with the integers that we pass in to get the value to return,
    but it really doesn't have to do anything with the integers. To be honest, this
    class doesn't really care what the closure does as long as it conforms to the
    `GetNumClosure` type. Next, we define three integers, named `numOne`, `numTwo`,
    and `results`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从这个类型开始，定义了一个名为 `GetNumClosure` 的闭包 `typealias`。任何定义为 `GetNumClosure` 闭包的闭包都将接受两个整数并返回一个整数。在这个闭包内部，我们假设它会对我们传入的整数做些处理以得到返回的值，但实际上它并不需要与整数有任何关系。说实话，这个类并不关心闭包做了什么，只要它符合
    `GetNumClosure` 类型即可。接下来，我们定义了三个整数，分别命名为 `numOne`、`numTwo` 和 `results`。
- en: 'We also define a method named `getNum()`. This method accepts a closure that
    conforms to the `GetNumClosure` type as its only parameter. Within the `getNum()`
    method, we execute the closure by passing in the `numOne` and `numTwo` variables,
    and the integer that is returned is put into the `results` class variable. Now
    let''s look at several closures that conform to the `GetNumClosure` type that
    we can use with the `getNum()` method:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了一个名为 `getNum()` 的方法。这个方法接受一个符合 `GetNumClosure` 类型的闭包作为其唯一参数。在 `getNum()`
    方法内部，我们通过传入 `numOne` 和 `numTwo` 变量以及返回的整数来执行闭包，并将返回的整数放入 `results` 类变量中。现在让我们看看几个符合
    `GetNumClosure` 类型的闭包，我们可以使用这些闭包与 `getNum()` 方法一起使用：
- en: '[PRE38]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In this code, we define five closures that conform to the `GetNumClosure` type:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们定义了五个符合 `GetNumClosure` 类型的闭包：
- en: '`max`: This returns the maximum value of the two integers that are passed'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max`：返回传入的两个整数中的最大值'
- en: '`in min`: This returns the minimum value of the two integers that are passed'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`in min`：返回传入的两个整数中的最小值'
- en: '`in multiply`: This multiplies both the values that are passed in and returns
    the product'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`in multiply`：将传入的两个值相乘并返回乘积'
- en: '`second`: This returns the second parameter that was passed in'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`second`：返回传入的第二个参数'
- en: '`answer`: This returns the answer to life, the universe, and everything'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`answer`：返回生命、宇宙和万物的答案'
- en: 'In the `answer` closure, we have an extra line that looks like it does not
    have a purpose:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `answer` 闭包中，有一行看起来似乎没有作用：
- en: '[PRE39]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We do this deliberately because the following code is not valid:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意这样做，因为以下代码是不合法的：
- en: '[PRE40]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This type gives us the error Contextual type for closure argument list expects
    two arguments, which cannot be implicitly ignored. As we can see by the error,
    Swift will not let us ignore the expected parameters within the body of the closure.
    In the second closure, Swift assumes that there are two parameters because `$1`
    specifies the second parameter. We can now pass each one of these closures to
    the `getNum()` method to change the functionality of the function to suit our
    needs. The following code illustrates this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型会给我们一个错误：闭包参数列表的上下文类型期望两个参数，这些参数不能被隐式忽略。正如错误所示，Swift 不允许我们在闭包体中忽略期望的参数。在第二个闭包中，Swift
    假设有两个参数，因为 `$1` 指定了第二个参数。现在我们可以将这些闭包中的每一个传递给 `getNum()` 方法，以改变函数的功能以适应我们的需求。以下代码说明了这一点：
- en: '[PRE41]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'When this code is run, we will receive the following results for each of the
    closures:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行此代码时，我们将为每个闭包收到以下结果：
- en: '[PRE42]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The last example we are going to show you is one that is used a lot in frameworks,
    especially ones that have a functionality that is designed to be run asynchronously.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要展示的最后一个例子是在框架中经常使用的一个，尤其是在那些设计为异步运行的功能性框架中。
- en: Selecting a closure based on results
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根据结果选择闭包
- en: In the final example, we will pass two closures to a method, and then, depending
    on some logic, one or possibly both of the closures will be executed. Generally,
    one of the closures is called if the method was successfully executed and the
    other closure is called if the method failed.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后的例子中，我们将向一个方法传递两个闭包，然后根据某些逻辑，一个或两个闭包将被执行。通常，如果方法成功执行，则调用一个闭包；如果方法失败，则调用另一个闭包。
- en: 'Let''s start by creating a type that will contain a method that will accept
    two closures and then execute one of the closures based on the defined logic.
    We will name this type `TestType`. Here is the code for the `TestType` type:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建一个类型，该类型将包含一个方法，该方法将接受两个闭包，然后根据定义的逻辑执行其中一个闭包。我们将这个名字命名为`TestType`。以下是`TestType`类型的代码：
- en: '[PRE43]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We begin this type by creating a `typealias` that defines the closure that we
    will use for both the successful and failure closures. We will name this `typealiasResultsClosure`.
    This example also illustrates why you should use a `typealias` rather than retyping
    the closure definition. It saves us a lot of typing and prevents us from making
    mistakes. In this example, if we do not use a `typealias`, we would need to retype
    the closure definition four times, and if we need to change the closure definition,
    we would need to change it in four spots. With the type alias, we only need to
    type the closure definition once and then use the alias throughout the remaining
    code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过创建一个`typealias`来定义我们将要用于成功和失败闭包的闭包。我们将这个名字命名为`typealiasResultsClosure`。这个例子也说明了为什么你应该使用`typealias`而不是重新输入闭包定义。这可以节省我们大量的输入，并防止我们出错。在这个例子中，如果我们不使用`typealias`，我们就需要重新输入闭包定义四次，如果我们需要更改闭包定义，我们就需要在四个地方进行更改。使用类型别名，我们只需要输入一次闭包定义，然后在整个剩余的代码中使用别名。
- en: 'We then create a method named `isGreater`, which takes two integers as the
    first two parameters, and two closures as the next two parameters. The first closure
    is named `successHandler`, and the second closure is named `failureHandler`. Within
    this method, we check whether the first integer parameter is greater than the
    second. If the first integer is greater, the `successHandler` closure is executed;
    otherwise, the `failureHandler` closure is executed. Now, let''s create two closures
    outside of the `TestType` structure. The code for these two closures is as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个名为`isGreater`的方法，它接受两个整数作为前两个参数，以及两个闭包作为接下来的两个参数。第一个闭包命名为`successHandler`，第二个闭包命名为`failureHandler`。在这个方法内部，我们检查第一个整数参数是否大于第二个。如果第一个整数大于第二个，则执行`successHandler`闭包；否则，执行`failureHandler`闭包。现在，让我们在`TestType`结构外部创建两个闭包。这两个闭包的代码如下：
- en: '[PRE44]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Note that both closures are defined as the `TestClass.ResultsClosure` type.
    In each closure, we simply print a message to the console to let us know which
    closure was executed. Normally, we would put some functionality in the closure.
    We will then call the method with both the closures, as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，两个闭包都被定义为`TestClass.ResultsClosure`类型。在每个闭包中，我们只是简单地打印一条消息到控制台，让我们知道哪个闭包被执行。通常，我们会在闭包中放置一些功能。然后我们将调用方法，如下所示：
- en: '[PRE45]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Note that in the method call, we are sending both the success closure and the
    failure closure. In this example, we will see the `Success: 8 is greater than
    6` message. If we reversed the numbers, we would see the `Failure: 6 is not greater
    than 8` message. This use case is really good when we call asynchronous methods,
    such as loading data from a web service. If the web service call was successful,
    the success closure is called; otherwise, the failure closure is called.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，在方法调用中，我们发送了成功闭包和失败闭包。在这个例子中，我们将看到`Success: 8 is greater than 6`的消息。如果我们反转数字，我们会看到`Failure:
    6 is not greater than 8`的消息。这种用例在调用异步方法时非常好，例如从网络服务加载数据。如果网络服务调用成功，则调用成功闭包；否则，调用失败闭包。'
- en: 'One big advantage of using closures like this is that the UI does not freeze
    while we wait for the asynchronous call to complete. This also involves a concurrency
    piece, which we will be covering in *Chapter 16*, *Concurrency and Parallelism
    in Swift*. As an example, imagine we tried to retrieve data from a web service
    as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种闭包的一个大优点是，在我们等待异步调用完成时，UI不会冻结。这也涉及到并发部分，我们将在第16章中介绍，即Swift中的并发与并行。作为一个例子，想象我们尝试以下方式从网络服务中检索数据：
- en: '[PRE46]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Our UI would freeze while we waited for the response, or we would have to make
    the call in a separate thread so that the UI would not hang. With closures, we
    pass the closures to the networking framework and rely on the framework to execute
    the appropriate closure when it is done. This relies on the framework to implement
    concurrency correctly, to make the calls asynchronously, but a decent framework
    should handle that for us.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们等待响应时，我们的 UI 会冻结，或者我们必须在单独的线程中进行调用，这样 UI 就不会挂起。有了闭包，我们将闭包传递给网络框架，并依赖框架在完成时执行适当的闭包。这依赖于框架正确实现并发，以异步方式进行调用，但一个不错的框架应该为我们处理这一点。
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw that we can define a closure just like we can define
    an integer or string type. We can assign closures to a variable, pass them as
    an argument to functions, and return them from functions. Closures capture strong
    references to any constants or variables from the context in which the closure
    was defined. We do have to be careful with this functionality, to make sure that
    we do not create a strong reference cycle, which would lead to memory leaks in
    our applications.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解到我们可以定义闭包，就像定义整数或字符串类型一样。我们可以将闭包赋值给变量，将它们作为函数的参数传递，并从函数中返回它们。闭包会捕获定义闭包时上下文中的任何常量或变量的强引用。我们必须小心使用这个功能，以确保我们不创建强引用循环，这会导致我们的应用程序中出现内存泄漏。
- en: Swift closures are very similar to blocks in Objective-C, but they have a much
    cleaner and more eloquent syntax. This makes them a lot easier to use and understand.
    Having a good understanding of closures is vital to mastering the Swift programming
    language and will make it easier to develop great applications that are easy to
    maintain. They are also essential for creating first-class frameworks that are
    easy both to use and to maintain.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 中的闭包与 Objective-C 中的 blocks 非常相似，但它们的语法更加简洁和优雅。这使得它们更容易使用和理解。对闭包有良好的理解对于掌握
    Swift 编程语言至关重要，这将使开发易于维护的优秀应用程序变得更加容易。它们对于创建既易于使用又易于维护的一等框架也是必不可少的。
- en: The use cases that we looked at in this chapter are by no means the only useful
    use cases for closures. I can promise you that the more you use closures in Swift,
    the more uses you will find for them. Closures are definitely one of the most
    powerful and useful features of the Swift language, and Apple did a great job
    by implementing them.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中我们探讨的使用案例绝非闭包的唯一有用用例。我可以向你保证，你在 Swift 中使用闭包越多，你会发现它们的应用越广泛。闭包无疑是 Swift 语言中最强大和最有用的特性之一，而苹果通过实现它们做得非常出色。
- en: In the next chapter, we will look at how we can use the advanced bitwise operators
    provided by Swift and how we can create our own custom operators.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何使用 Swift 提供的高级位运算符，以及如何创建我们自己的自定义运算符。
