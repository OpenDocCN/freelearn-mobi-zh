- en: '*Chapter 6*: Understanding the Swift Type System'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第6章*：理解Swift类型系统'
- en: The previous chapters have left you with a solid foundation that you can use
    to build great, adaptive apps on. At this point, it is a good idea to take a step
    back and look at the code you have written to gain a deeper understanding of Swift
    and how it works. This section focuses on teaching you more about Swift as a language,
    regardless of what you intend to build.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 前几章已经为你打下了坚实的基础，你可以用它来构建出色的、适应性强的应用程序。在这个时候，退一步审视你编写的代码，以更深入地理解Swift及其工作方式是个好主意。本节侧重于教你更多关于Swift作为一门语言的知识，无论你打算构建什么。
- en: In this chapter, you will learn about Swift's fantastic type system. Swift's
    type system is one of its most powerful features because it allows developers
    to express complex and flexible principles safely and predictably.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解Swift的出色类型系统。Swift的类型系统是其最强大的特性之一，因为它允许开发者安全且可预测地表达复杂和灵活的原则。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding available types in Swift
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Swift中可用的类型
- en: Understanding differences in types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解类型之间的差异
- en: Deciding which type to use
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定使用哪种类型
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you'll need to download Xcode version 11.4 or above from Apple's
    App Store.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要从Apple的App Store下载11.4或更高版本的Xcode。
- en: You'll also need to be running the latest version of macOS (Catalina or above).
    Simply search for `Xcode` in the App Store and select and download the latest
    version. Launch Xcode and follow any additional installation instructions that
    your system may prompt you with. Once Xcode has fully launched, you're ready to
    go.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要运行最新的macOS版本（Catalina或更高）。只需在App Store中搜索`Xcode`，选择并下载最新版本。启动Xcode，并遵循系统可能提示的任何附加安装说明。一旦Xcode完全启动，你就可以开始了。
- en: 'Download the sample code from the following GitHub link:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下GitHub链接下载示例代码：
- en: '[https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition](https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition](https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition)'
- en: Understanding available types in Swift
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Swift中可用的类型
- en: To write great code, you need to learn what tools are available in your toolbox.
    This applies to building apps and understanding the features UIKit has to offer,
    but it also applies to the language you use to write software in. Different languages
    come with various features, best practices, pros, and cons. The deeper your understanding
    of the language you work with is, the better the decisions you can make about
    the code you write. As mentioned before, Swift's type system is one of the features
    that make Swift such an excellent language for both experts and beginners to develop
    in.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写优秀的代码，你需要了解你的工具箱中都有哪些工具。这适用于构建应用程序和理解UIKit所能提供的功能，但也适用于你用来编写软件的语言。不同的语言都有各自的特点、最佳实践、优点和缺点。你对所使用语言的了解越深入，你就能做出越好的关于你编写代码的决定。正如之前提到的，Swift的类型系统是使Swift成为专家和初学者开发中都如此出色的语言的一个特性。
- en: 'Before you dive into the details of Swift''s types and how they compare to
    each other, it''s essential that you know what types Swift has to offer. On a
    high level, you can argue that Swift has two types:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在你深入研究Swift的类型细节以及它们如何相互比较之前，了解Swift提供哪些类型是至关重要的。从高层次上讲，你可以争辩说Swift有两种类型：
- en: Reference types
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用类型
- en: Value types
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值类型
- en: Let's have a closer look at each type to see what they mean, how they work,
    and how you can use them.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看每种类型，了解它们代表什么，如何工作，以及如何使用它们。
- en: Working with reference types
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用引用类型
- en: 'The types you have seen so far in this book were mostly, if not all, reference
    types. Two types of objects are classified as reference types:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中你看到的类型大多是，如果不是全部都是引用类型。两种类型的对象被归类为引用类型：
- en: Classes
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类
- en: Closures
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭包
- en: You have seen both of these object types in this book already. For instance,
    all the `UIViewController` subclasses you have created are reference types. All
    the closures that you used as callbacks or to perform animations are also reference
    types.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这本书中已经看到了这两种对象类型。例如，你创建的所有`UIViewController`子类都是引用类型。你用作回调或执行动画的所有闭包也是引用类型。
- en: So, what does it mean if something is a reference type, and why should it matter
    to you? Well, reference types come with behavior that can be both convenient and
    very frustrating depending on what you are trying to achieve in your code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果某物是引用类型，这意味着什么？为什么这对你很重要？嗯，引用类型具有可以既方便又非常令人沮丧的行为，这取决于你试图在代码中实现什么。
- en: One feature that is unique to reference types and classes is the ability to
    subclass. The only type that can inherit functionality from another object is
    a class. This will be covered in more depth when you learn about the differences
    between types, but it's good to be aware of this information already. Let's examine
    reference types up close by writing some code in a playground.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型和类独有的一个特性是能够进行子类化。唯一可以从另一个对象继承功能的是类。当你学习到类型之间的区别时，这将会被更深入地探讨，但了解这些信息已经很好了。让我们通过在游乐场中编写一些代码来近距离考察引用类型。
- en: 'Create a new playground project in Xcode and give it any name you like. Then,
    add the following code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xcode 中创建一个新的游乐场项目，并给它起任何你喜欢的名字。然后，添加以下代码：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Likely, you're not too excited about this little snippet of code. All it does
    is define a new `Pet` class, make an instance of it, and then pass that instance
    into `printName(for:)`. However, this code is extremely well-suited to illustrating
    what a reference type is.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能，你对这段小代码并不太兴奋。它所做的只是定义一个新的 `Pet` 类，创建一个实例，然后将该实例传递给 `printName(for:)`。然而，这段代码非常适合说明引用类型是什么。
- en: 'When you call `printName(for: cat)`, you pass a *reference* to your `cat` instance
    to `printName(for:)`. This means that it is possible for anybody who gets ahold
    of this reference to make changes to the object that is referenced. If this sounds
    confusing, that''s okay.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '当你调用 `printName(for: cat)` 时，你将你的 `cat` 实例的 *引用* 传递给 `printName(for:)`。这意味着任何获得这个引用的人都可以修改被引用的对象。如果这听起来很困惑，那没关系。'
- en: 'Add the following code to the playground you have created, and then run it:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到你所创建的游乐场中，然后运行它：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: What do you notice in the console after running this?
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这段代码后，你在控制台里注意到什么？
- en: If you noticed that the dog's name changes from `Astro` to `Pugwash`, you have
    just observed what it means to pass a reference to something around.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到狗的名字从 `Astro` 变成了 `Pugwash`，你刚刚观察到了传递引用的含义。
- en: Since `printName2(for:)` received a reference to your `Pet` instance, it was
    able to change its name. If you have programmed in other languages, this might
    be obvious to you. If not, this might be very surprising.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `printName2(for:)` 接收了你的 `Pet` 实例的引用，它能够改变它的名字。如果你在其他语言中编程过，这对你来说可能很显然。如果没有，这可能会让你感到非常惊讶。
- en: One more thing you should note is that `dog` was declared as a constant. Regardless,
    you were able to change the name of your instance from `Astro` to `Pugwash`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一点你应该注意，`dog` 被声明为常量。尽管如此，你仍然能够将你的实例的名字从 `Astro` 改成 `Pugwash`。
- en: 'If you think this is obvious, add the following code to your playground and
    run it:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为这是显而易见的，请在你的游乐场中添加以下代码并运行它：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This code is very similar to what you did with the `Pet` instance. You make
    a constant instance of a thing, and then you change one of its properties. This
    time, however, when you try to run your playground, you should see the following
    error:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与你之前对 `Pet` 实例所做的是非常相似的。你创建了一个常量实例，然后改变它的一个属性。然而，这次，当你尝试运行你的游乐场时，你应该会看到以下错误：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Even though the code you implemented so far is pretty short, it does a great
    job of demonstrating reference types. You have currently seen two properties of
    a reference type in action:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你到目前为止实现的代码相当短，但它很好地展示了引用类型。你目前看到了引用类型的两个特性在行动：
- en: Anybody that receives an instance of a reference type can mutate it.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何接收引用类型实例的人都可以修改它。
- en: You can change properties on a reference type, even if the property that holds
    onto the reference type is declared as a constant.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在引用类型上更改属性，即使持有引用类型的属性被声明为常量。
- en: These two characteristics are typical of reference types. The reason reference
    types work like this is that a variable or constant that is assigned a reference
    type *does not contain or own* the object. The constant or variable only points
    to an address in memory where the instance is stored.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个特性是引用类型的典型特征。引用类型之所以这样工作，是因为被分配引用类型的变量或常量 *不包含或拥有* 对象。常量或变量只指向内存中存储实例的地址。
- en: Any time you create an instance of a reference type, it is written to RAM, where
    it will exist at a particular address. RAM is a special type of memory that is
    used by computers, such as an iPhone, to temporarily store data that is used by
    a certain program.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 任何时候你创建引用类型的实例，它都会写入 RAM，在那里它将在特定的地址存在。RAM 是一种计算机使用的特殊内存类型，例如 iPhone，用于临时存储某个程序使用的数据。
- en: 'When you assign an instance of a reference type to a property, the property
    will have a **pointer** to the memory address for this instance. Let''s have another
    look at the following line of code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将引用类型的实例分配给属性时，该属性将有一个 **指针** 指向该实例的内存地址。让我们再次看看以下代码行：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `dog` constant now points to a particular address in memory where the `Pet`
    instance is stored. You are allowed to change properties on the `Pet` instance
    as long as the underlying memory address isn't changed.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `dog` 常量指向内存中存储 `Pet` 实例的特定地址。只要基本内存地址没有改变，你就可以更改 `Pet` 实例上的属性。
- en: In fact, you could theoretically put something entirely different at that memory
    address, and `let dog` won't care because it still points to the same address.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，理论上你可以在那个内存地址处放置完全不同的内容，而 `let dog` 不会在意，因为它仍然指向相同的地址。
- en: For this same reason, it is possible for `printName2(for:)` to change a pet's
    name. Instead of passing it an instance of `Pet`, you pass it the memory address
    at which the instance is expected to exist. It's okay for `printName2(for:)` to
    make changes to the `Pet` instance because it doesn't change the underlying address
    in memory.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于同样的原因，`printName2(for:)` 可以更改宠物的名称。你不需要传递 `Pet` 的实例，而是传递实例预期存在的内存地址。`printName2(for:)`
    对 `Pet` 实例进行更改是可以的，因为它不会更改内存中的基本地址。
- en: 'If you tried to assign a new instance to `dog` by typing the following, you
    would get an error:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试通过以下方式将新实例分配给 `dog`，你会得到一个错误：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The reason this would cause an error is that you can't change the memory address
    `dog` points to since it's a constant.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这种错误发生的原因是你不能更改 `dog` 指向的内存地址，因为它是常量。
- en: Now that you know what a reference type is and how it works, you might have
    already concluded that `CGPoint` that you saw in the preceding example must be
    a value type. Next, let's see what value types are all about.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了引用类型是什么以及它是如何工作的，你可能已经得出结论，前面例子中看到的 `CGPoint` 必须是值类型。接下来，让我们看看值类型究竟是什么。
- en: Working with value types
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与值类型一起工作
- en: 'In the examples for references types, you saw the following snippet of code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在引用类型的例子中，你看到了以下代码片段：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: At first sight, you might expect a value type to be a special kind of class
    because it looks like this snippet creates an instance of a class called `CGPoint`.
    You would be right in your observation, but your conclusion is wrong. `CGPoint`
    is not a class at all.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，你可能会期望值类型是一种特殊的类，因为这段代码看起来像创建了名为 `CGPoint` 的类的实例。你的观察是正确的，但你的结论是错误的。`CGPoint`
    实际上根本不是类。
- en: Classes are inherently reference types, and they can't ever be something else.
    So, what are value types, then?
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 类本质上是引用类型，它们永远不会变成其他类型。那么，值类型是什么呢？
- en: 'There are two types of objects that are considered to be value types:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 被视为值类型的对象有两种：
- en: Stucts
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体
- en: Enums
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举
- en: These two types are both very different, so let's make sure that you understand
    the basics of value types first, and then you'll learn what each of these two
    types is.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种类型都大不相同，所以让我们确保你首先理解值类型的基本知识，然后你将学习这两种类型各自是什么。
- en: Let's have a look at the `Pet` example again, but use a struct instead of a
    class.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看 `Pet` 的例子，但使用结构体而不是类。
- en: Create a new playground page in Xcode, again naming this anything you like.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xcode 中创建一个新的游乐场页面，再次将其命名为你喜欢的任何名称。
- en: 'Once created, add the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建，请添加以下代码：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You will immediately notice that Xcode complains.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你会立即注意到 Xcode 会报错。
- en: 'The error you should see in the console tells you that `pet` is a `let` constant
    and you are not allowed to change its name. You can turn `pet` into a variable
    by updating `printName`, as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台中应该看到的错误告诉你 `pet` 是一个 `let` 常量，你不允许更改它的名称。你可以通过更新 `printName` 将 `pet` 转换为变量，如下所示：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you run your playground now, make sure to look at the console closely. You'll
    notice that the pet's name remains unchanged in the second print.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行你的游乐场，请确保仔细查看控制台。你会注意到在第二次打印中宠物的名字保持不变。
- en: This demonstrates one of the key features of a value type. Instead of passing
    a reference to an address in memory around, a copy of the object is passed around.
    This explains why you aren't allowed to change properties on a value type that
    is assigned to a constant.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了值类型的一个关键特性。不是传递内存地址的引用，而是传递对象的副本。这也解释了为什么不允许在赋值给常量的值类型上更改属性。
- en: Changing that property would change the value type's value, and it would, therefore,
    change the value of the constant. This also means that when you pass `dog` to
    `printName`, you pass a copy of the `Pet` instance to `printName`, meaning that
    any changes made to the instance are local to the `printName` function and won't
    be applied to `dog`, in this case.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 改变那个属性会改变值类型的值，因此也会改变常量的值。这也意味着当你将`dog`传递给`printName`时，你传递的是`Pet`实例的副本给`printName`，这意味着对该实例所做的任何更改都是局部的，并且不会应用到`dog`上，在这种情况下。
- en: This behavior makes using value types extremely safe because it's tough for
    other objects or functions to make unwanted changes to a value type. Also, if
    you define something as a constant, it truly is a constant. Another characteristic
    of value types is that they're typically very fast and lightweight because they
    can exist on the stack, while reference types exist on the heap. You'll learn
    more about this later when we compare reference types and value types.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为使得使用值类型极其安全，因为其他对象或函数很难对值类型进行不希望的改变。此外，如果你将某个东西定义为常量，它确实就是一个常量。值类型的另一个特点是它们通常非常快速且轻量，因为它们可以存在于栈上，而引用类型存在于堆上。当你我们比较引用类型和值类型时，你将了解更多关于这方面的内容。
- en: Now that you have a basic understanding of value types, let's have a look at
    the specific value types.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对值类型有了基本的了解，让我们来看看具体的值类型。
- en: Understanding structs
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解结构体
- en: 'Structs are similar to classes in the way you define them. If you look at the
    `Pet` class you defined earlier, it might be easy to miss the fact that it''s
    a struct. If you pay close attention, you will notice one big difference, though:
    you didn''t have to write an initializer for the struct! Swift can automatically
    generate initializers for structs. This is extremely convenient and can save you
    a lot of typing for larger structs.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体的定义方式与类相似。如果你看看你之前定义的`Pet`类，可能会忽略它实际上是一个结构体的事实。如果你仔细观察，你会注意到一个很大的不同：你不需要为结构体编写初始化器！Swift可以自动为结构体生成初始化器。这非常方便，并且可以为你节省大量的输入，特别是对于较大的结构体。
- en: Structs also can't inherit functionality from other objects. This means that
    structs always have a very flat and transparent set of properties and methods.
    This allows the compiler to make optimizations to your code that make structs
    extremely lightweight and fast.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体也不能从其他对象继承功能。这意味着结构体始终有一组非常平坦且透明的属性和方法。这允许编译器对你的代码进行优化，使得结构体非常轻量且快速。
- en: A struct can, however, conform to protocols. The Swift standard library is full
    of protocols that define features for many of the built-in types, such as `Array`,
    `Dictionary`, and `Collection`. Most of these built-in types are implemented as
    structs that adopt one or more protocols.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，结构体可以遵循协议。Swift标准库充满了定义许多内置类型功能的协议，例如`Array`、`Dictionary`和`Collection`。这些内置类型中的大多数都是作为采用一个或多个协议的结构体实现的。
- en: 'One last thing you need to understand about structs is that they are very strict
    about whether they can be modified. Consider a struct that looks as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 关于结构体，你需要了解的最后一件事是它们对是否可以被修改非常严格。考虑一个如下所示的结构体：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This struct will cause the compiler to throw an error.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构体会导致编译器抛出错误。
- en: 'A struct itself is immutable by default, which means you cannot change any
    of its values. It''s up to you to make it explicit to the compiler when a method
    can mutate or change a struct. You do this by adding the `mutating` keyword to
    a function, as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体默认是不可变的，这意味着你不能改变它的任何值。当方法可以修改或改变结构体时，你需要让编译器明确这一点。你可以通过在函数中添加`mutating`关键字来实现，如下所示：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When you create a constant instance of `Car` and call `fillFuelTank()` on it,
    the compiler will error again. If you call a mutating function on a `let` instance,
    you mutate the instance, meaning the value of the property would change. Because
    of this, you can only call mutating functions on variable properties.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个`Car`常量实例并在其上调用`fillFuelTank()`时，编译器将再次报错。如果你在`let`实例上调用一个修改函数，你将修改实例，这意味着属性的值会改变。因此，你只能对变量属性调用修改函数。
- en: Understanding enums
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解枚举
- en: 'An enum is a type that holds a finite set of predefined values. Enums are often
    used to represent a particular state or result of an operation. The best way to
    learn what this means is to look at an example of an enum that represents the
    state of a traffic light:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举是一种包含有限预定义值的类型。枚举通常用于表示特定状态或操作的特定结果。了解这意味着什么最好的方式是查看一个表示交通灯状态的枚举示例：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This sample shows a `TrafficLight` struct that has a `state` property. The type
    of this property is `TrafficLightState`, which is an enum.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例展示了一个具有`state`属性的`TrafficLight`结构体。这个属性的类型是`TrafficLightState`，它是一个枚举。
- en: '`TrafficLightState` defines three possible states for a traffic light. This
    is very convenient because an enum such as this eliminates the possibility of
    a bad state because the compiler can now enforce that you never end up with an
    invalid value.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`TrafficLightState` 定义了交通灯的三个可能状态。这非常方便，因为这样的枚举可以消除错误状态的可能性，因为编译器现在可以强制你不会得到一个无效的值。'
- en: Enums can also contain properties and methods, just like structs can. However,
    an enum can also have an *associated value*. This means that each possible case
    can have a representation in a different type, such as a string.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举也可以包含属性和方法，就像结构体一样。然而，枚举还可以有一个*关联值*。这意味着每个可能的案例都可以在不同的类型中有表示，例如字符串。
- en: 'If you modify `TrafficLightState`, as shown here, it will have `String` for
    `rawValue`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你像这里所示修改`TrafficLightState`，它将为`rawValue`具有`String`：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If Swift can infer the raw value, you don't have to do anything more than add
    the type of the raw value to the enum's type declaration. In this sample, the
    raw value for the `green` enum case will be the `green` string. This can be convenient
    if you need to map your enum to a different type – for instance, to set it as
    a label's text.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你Swift可以推断出原始值，你不需要做任何更多的事情，只需将原始值的类型添加到枚举的类型声明中即可。在这个示例中，`green`枚举情况的原始值将是`green`字符串。如果你需要将枚举映射到不同的类型，这可能很有用——例如，将其设置为标签的文本。
- en: Just like structs, enums cannot inherit functionality from other objects, but
    they can conform to protocols. You make an enum conform to a protocol with an
    extension, just like you would do for classes and structs.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 就像结构体一样，枚举不能从其他对象继承功能，但它们可以遵循协议。你通过扩展使枚举遵循协议，就像你为类和结构体做的那样。
- en: This wraps up the exploration of value types. Now that you know what value types
    and reference types are, let's explore some of their differences!
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这总结了值类型的探索。现在你了解了值类型和引用类型是什么，让我们探索它们之间的一些差异！
- en: Understanding differences in types
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解类型之间的差异
- en: Being aware of the available types in Swift – knowing their similarities and,
    more importantly, their differences – will help you make better decisions about
    the way you write your code. The preceding segments have listed several properties
    of value types and reference types. More specifically, you learned a lot about
    classes, structs, and enums. Closures are also a reference type because they get
    passed around by their location in memory, rather than their value, but there
    isn't much else to say about them in this context.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 了解Swift中可用的类型——了解它们的相似之处和，更重要的是，它们的差异——将帮助你做出更好的决策，关于你编写代码的方式。前面的部分已经列出了值类型和引用类型的几个属性。更具体地说，你学到了很多关于类、结构体和枚举的知识。闭包也是引用类型，因为它们是通过它们在内存中的位置而不是它们的值来传递的，但在这个上下文中没有太多可说的。
- en: The most obvious comparison you can make is probably between structs and classes.
    They look very similar, but they have very different characteristics, as you have
    already seen. Enums are a special type altogether; they represent a value from
    a fixed number of possible values but are very similar to structs otherwise.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你能做的最明显的比较可能是结构体和类之间的比较。它们看起来非常相似，但它们具有非常不同的特性，正如你之前所看到的。枚举是另一种特殊类型；它们代表一组固定可能值的值，但在其他方面与结构体非常相似。
- en: The most important difference you need to understand is the general difference
    between value types and reference types, and the difference between structs and
    classes specifically. Let's have a look at value types and reference types first,
    so you have the general picture. Then, you'll learn about the specific differences
    between structs and classes.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要理解的最重要区别是值类型和引用类型的一般区别，以及结构体和类之间的具体区别。让我们首先看看值类型和引用类型，这样你就能有一个大致的了解。然后，你将学习结构体和类之间的具体区别。
- en: Comparing value types to reference types
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较值类型和引用类型
- en: When comparing value types to reference types, it is essential to distinguish
    between the differences you can see as a developer and the differences that are
    internal to Swift and the way your app will end up working. Knowing these details
    will ensure that you can make a well-informed decision that considers all the
    implications instead of only focusing on memory usage or developer convenience.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当比较值类型和引用类型时，区分作为开发者可见的差异以及Swift内部差异以及你的应用最终的工作方式是至关重要的。了解这些细节将确保你可以做出考虑所有影响的明智决策，而不仅仅是关注内存使用或开发者便利性。
- en: Let's examine the more obvious and visible differences first. Afterward, you
    will learn about the memory implications for each type.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先检查更明显和可见的差异。之后，你将了解每种类型的内存影响。
- en: Differences in usage
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用差异
- en: 'Create a new playground, once again naming it anything you like, and add the
    following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的游乐场，再次给它起一个你喜欢的名字，并添加以下代码：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This code defines a `PetProtocol` that requires two properties to exist on all
    objects that conform to this protocol. The `name` property is defined as a constant
    since it only needs it to be gettable, and `ownerName` is a variable since it
    requires both `get` and `set`. The code also defines an `Animal` and `Pet` class.
    `Pet` is a subclass of `Animal`, and it conforms to `PetProtocol` because `Animal`
    satisfies the `name` constant requirement and `Pet` itself satisfies the `ownerName`
    variable.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码定义了一个 `PetProtocol`，该协议要求所有符合此协议的对象都必须存在两个属性。`name` 属性被定义为常量，因为它只需要可获取性，而
    `ownerName` 是变量，因为它需要 `get` 和 `set`。代码还定义了 `Animal` 和 `Pet` 类。`Pet` 是 `Animal`
    的子类，并且它符合 `PetProtocol`，因为 `Animal` 满足 `name` 常量要求，而 `Pet` 本身满足 `ownerName` 变量要求。
- en: Try changing the `class` declarations to `struct`. Your playground will not
    compile now because structs cannot inherit from other objects as classes can.
    This is a limitation that is sometimes frustrating because you can end up with
    a lot of code duplication. Imagine that, in addition to `Pet`, you would like
    to create more types of animals, such as a `WildAnimal` or `SeaCreature`. This
    would be easy to achieve with classes because you can inherit from `Animal`. This
    is not possible with structs, so you would implement all these types as structs
    they would need to duplicate their `Animal` logic.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将 `class` 声明更改为 `struct`。现在你的游乐场将无法编译，因为结构体不能像类一样继承其他对象。这是一个有时会令人沮丧的限制，因为你可能会遇到大量的代码重复。想象一下，除了
    `Pet` 之外，你还想创建更多类型的动物，比如 `WildAnimal` 或 `SeaCreature`。这可以通过类来实现，因为你可以从 `Animal`
    继承。对于结构体来说，这是不可能的，所以你必须将这些类型作为结构体实现，它们需要复制它们的 `Animal` 逻辑。
- en: 'Another difference between value types and reference types is how they act
    when they are passed around. Add the following code to your playground:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型和引用类型之间的另一个区别是它们在传递时的行为。将以下代码添加到你的游乐场中：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The declarations for `info` and `location` look very similar, but their underlying
    types are entirely different. Try writing a function that takes both `ImageLocation`
    and `ImageInformation` as an argument. Then, try updating the `isLoaded` property
    of `location` and changing the `name` property of `info`. The compiler will complain
    when you try to set `isLoaded` because the argument for `ImageLocation` is `let
    constant`. The reason for this was described earlier in the discussion on value
    types.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`info` 和 `location` 的声明看起来非常相似，但它们的底层类型完全不同。尝试编写一个函数，该函数接受 `ImageLocation`
    和 `ImageInformation` 作为参数。然后，尝试更新 `location` 的 `isLoaded` 属性和 `info` 的 `name`
    属性。当你尝试设置 `isLoaded` 时，编译器会报错，因为 `ImageLocation` 的参数是一个 `let` 常量。这个原因在关于值类型的讨论中已经描述过。'
- en: Value types are passed around by value, meaning that changing the property of
    the argument will change the value altogether. Arguments for a function are always
    constants. This might not be obvious when you use a reference type, though, because
    it is perfectly fine to change the `name` property on `ImageInformation` inside
    of a function. This is because you don't pass the entire value around when you
    pass a reference type to a function; you pass the reference to the memory address
    around. This means that instead of the value being a constant, the underlying
    memory address is a constant. This, in turn, means that you can change whatever
    is in memory as much as you like; you just can't change the address that a constant
    points to.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型是通过值传递的，这意味着改变参数的属性将完全改变值。函数的参数始终是常量。然而，当你使用引用类型时，这可能并不明显，因为改变函数内部`ImageInformation`上的`name`属性是完全可行的。这是因为当你将引用类型传递给函数时，你并没有传递整个值；你传递的是内存地址的引用。这意味着，而不是值是常量，底层的内存地址是常量。这反过来意味着你可以随意更改内存中的任何内容；你只是不能改变常量所指向的地址。
- en: Imagine that you need to drive to somebody's house and they send you the address
    where they live. This is what it's like to pass around a reference type. Rather
    than sending you their entire house, they send you the address for their house.
    While you are driving to their house, the house can change in many ways. The owner
    could paint it, or replace the windows or doors, anything. In the end, you will
    still find the house because you received the address for this house, and, as
    long as the owner doesn't move to a different address, you will find the correct
    house.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你需要开车去某人的家，他们给你他们住址。这就是传递引用类型的感觉。他们不会给你整个房子，而是给你他们家的地址。在你开车去他们家的路上，房子可能会以许多方式改变。房主可能会粉刷它，或者更换窗户或门，任何事都可能。最后，你仍然能找到房子，因为你收到了这个房子的地址，而且只要房主不搬到一个不同的地址，你就能找到正确的房子。
- en: If you change this analogy to use value types, the person whose house you're
    looking for will simply send you a full copy of their house. So, rather than you
    driving toward their house based on the address, they won't give you an address;
    they will just send you their whole house. If the owner makes changes to their
    copy of the house, you won't be able to see them reflected on your copy of the
    house unless they send you a new copy. This is also true for any modifications
    you make to your copy of the house.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这个类比改为使用值类型，那么你要找的那个人会直接给你他们房子的完整副本。所以，你不会根据地址开车去他们的家；他们不会给你地址；他们只会给你他们的整个房子。如果房主对其房子的副本进行了更改，除非他们给你一个新的副本，否则你将无法在你的房子副本上看到这些更改的反映。这也适用于你对房子副本所做的任何修改。
- en: You can imagine that in some cases, it can be very efficient to send somebody
    a copy of something rather than the address. The example of a house might be a
    bit extreme, but I'm pretty sure that if you order a parcel, you would much rather
    receive the parcel itself than receiving an address to fetch the parcel. This
    sort of efficiency is what you will learn about next by comparing how value types
    and reference types behave in terms of memory allocation.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象，在某些情况下，发送某物的副本而不是地址可能非常高效。房子的例子可能有点极端，但我很确定，如果你订购一个包裹，你更愿意收到包裹本身而不是收到一个去取包裹的地址。这种效率就是你在接下来通过比较值类型和引用类型在内存分配方面的行为时将要了解的内容。
- en: Deciding which type to use
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 决定使用哪种类型
- en: Choosing the wrong type of object to use in your application can have bad implications
    for your app on several levels. For instance, your app could suffer from unwanted
    side effects when a reference type is modified in some unexpected place. Or, you
    could end up with a lot of duplicated logic if you use a struct instead of a class
    in certain places. Your app could even suffer in terms of performance when you
    choose a slow reference type where a value type would have been a better choice.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用程序中使用错误类型的对象可能会对你的应用程序产生多方面的不良影响。例如，如果你的应用程序中某个意外的位置修改了引用类型，你的应用程序可能会遭受不想要的副作用。或者，如果你在某些地方使用结构体而不是类，你可能会遇到大量的重复逻辑。如果你的应用程序选择了慢速引用类型而不是更好的值类型，你的应用程序甚至可能在性能方面受到影响。
- en: You should always evaluate what type of object is best suited for your current
    use case to make sure your code strikes a balanced trade-off between maintainability
    and performance.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该始终评估哪种类型的对象最适合你的当前用例，以确保你的代码在可维护性和性能之间达到平衡的权衡。
- en: When should I use a reference type?
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时应该使用引用类型？
- en: A great time to use a reference type is when you are subclassing a built-in
    class, such as `UIViewController`. In these cases, there is no point in fighting
    the system because that would definitely do more harm than good. Another time
    to use a reference type is when you are creating your own delegate protocols.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用引用类型的绝佳时机是当你正在继承内置类，例如`UIViewController`时。在这些情况下，与系统作斗争是没有意义的，因为这肯定会造成更多的伤害而不是好处。另一个使用引用类型的时机是当你创建自己的代理协议时。
- en: Delegates are best implemented as weak reference types. This means that the
    object that acts as a delegate is referenced weakly by an object to avoid memory
    leaks.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 代理最好实现为弱引用类型。这意味着充当代理的对象被对象弱引用，以避免内存泄漏。
- en: Because value types are passed around by making copies, it does not make sense
    to have a weak reference to them. In this case, your only choice is to use a reference
    type.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由于值类型是通过复制来传递的，因此对它们有弱引用是没有意义的。在这种情况下，你唯一的选择是使用引用类型。
- en: You also need a reference type if it doesn't make sense to pass around copies
    of something. If you think back to the example of driving to somebody's house,
    it makes a lot more sense to pass around the address of a house than to give everybody
    full copies of the house. You might consider the house as having an identity.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为传递某个对象的副本没有意义，你也需要一个引用类型。如果你回想起开车去别人家的例子，传递房子的地址比给每个人提供房子的完整副本更有意义。你可能会认为房子有一个身份。
- en: This means that each house is *unique*; there is only one house with that exact
    address, and making copies of it makes no sense. If you are working with an object
    where copying it makes no sense, you likely want to implement it as a reference
    type, so everybody that receives an instance of that type is looking at the same
    instance.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着每一栋房子都是**独特**的；只有一个房子拥有那个确切的地址，复制它也没有意义。如果你正在处理一个复制它没有意义的对象，你很可能希望将其实现为引用类型，这样所有接收该类型实例的人都在查看同一个实例。
- en: One last reason to choose a reference type is if it can save you a lot of typing
    by subclassing. A lot of people consider subclassing bad, and you can often avoid
    it, but sometimes it just makes a lot more sense to work with a class hierarchy.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 选择引用类型的最后一个原因是，如果它可以通过继承来节省大量代码。很多人认为继承是糟糕的，你通常可以避免它，但有时使用类层次结构工作会更有意义。
- en: The downside is that a lot of subclasses can lead to muddy classes that contain
    functionality to save typing on a couple of subclasses even though the functionality
    is not relevant to all subclasses. But just like many tools, subclassing can be
    quite convenient when used correctly; it's not inherently bad to use it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点是，许多子类可能导致功能混乱的类，这些类包含为节省几个子类中的打字而保存的功能，尽管这些功能并不适用于所有子类。但就像许多工具一样，如果正确使用，继承可以非常方便；使用它本身并不是固有的坏处。
- en: When to use a value type
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用值类型
- en: It is often said that you should always start with a struct and change to a
    different type when needed. This is great advice for a lot of cases because structs
    are often fine for most cases. However, structs aren't the only value type, and
    it's always good to not default to using certain things blindly.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 人们常说，你应该始终从结构体开始，并在需要时更改到其他类型。这在很多情况下都是很好的建议，因为结构体通常适用于大多数情况。然而，结构体并不是唯一的价值类型，始终避免盲目使用某些东西总是好的。
- en: If you need an object that represents a finite set of possible states or results,
    such as a network connection state, a traffic light state, or a limited set of
    valid configuration options for your app, you will likely need an enum.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个表示有限可能状态或结果的对象，例如网络连接状态、交通灯状态或应用的有效配置选项的有限集，你很可能需要一个枚举。
- en: Regardless of the value semantics that make value types great, an enum is a
    great way to avoid typos and represent a state. It's often pretty clear when you
    should use an enum due to its nature.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管值类型的价值语义使它们很棒，但枚举是避免拼写错误和表示状态的好方法。由于其本质，通常很清楚何时应该使用枚举。
- en: Structs are used for objects that do not have an identity. In other words, it
    makes sense to pass copies of it around. A good example of this is when you create
    a struct that can communicate with the network or a database. This struct would
    have no identity because it's mostly a collection of properties and methods that
    aren't associated with a single version of the struct.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体用于没有身份的对象。换句话说，传递它的副本是有意义的。一个很好的例子是当你创建一个可以与网络或数据库通信的结构体时。这个结构体将没有身份，因为它主要是一组属性和方法，这些属性和方法与结构体的单个版本没有关联。
- en: A good example of a struct is the `CGPoint` struct that you read about at the
    beginning of this section. `CGPoint` represents a location in a two-dimensional
    grid. It has no identity, and passing copies of it around makes sense. It only
    contains two properties, so it doesn't require any inheritance. These features
    make it a great candidate to be implemented as a value type.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一个结构体的好例子是你在本节开头读到的 `CGPoint` 结构体。`CGPoint` 表示二维网格中的一个位置。它没有身份，传递它的副本是有意义的。它只包含两个属性，因此不需要任何继承。这些特性使它成为实现为值类型的绝佳候选者。
- en: If you follow the advice of always starting with a struct, try to figure out
    reasons for your new object to *not* be a struct. If you find a good reason to
    not use a struct, then make it a class. Often, you won't be able to find a good
    reason to use a class instead of a struct. If this is the case, make your new
    object a struct; you can always switch to using a class later. It's usually harder
    to switch from a class to a struct due to the stricter rules regarding mutability
    and the lack of subclassing for structs.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遵循始终从结构体开始的建议，试着找出你的新对象为什么不应该是一个结构体的原因。如果你找到一个不使用结构体的好理由，那么就将其改为类。通常，你不会找到使用类而不是结构体的好理由。如果是这种情况，将你的新对象改为结构体；你总是可以在以后切换到使用类。由于结构体对可变性的严格规则以及缺乏子类化，从类切换到结构体通常更困难。
- en: Summary
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You learned a lot about value types and reference types in this chapter. You
    learned what each type is and how you can use them. You learned that you can use
    classes, closures, structs, and enums in Swift and that each of these object types
    has its own pros and cons.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了关于值类型和引用类型的大量知识。你学习了每种类型是什么以及如何使用它们。你了解到你可以在 Swift 中使用类、闭包、结构体和枚举，并且每种对象类型都有其自身的优缺点。
- en: After learning about all types, you saw how value types and reference types
    compare to each other, which has shed some light on the sometimes subtle and sometimes
    obvious use cases for each type. You learned that structs can't be subclasses,
    while classes can. You also learned that passing around value types passes around
    copies of each instance, and passing around reference types does not copy each
    instance but rather passes around a pointer to the addresses in memory. Then,
    you learned how each type is held in memory and what this means for the performance
    of the objects you create.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了所有类型之后，你看到了值类型和引用类型是如何相互比较的，这为每种类型的有时微妙有时明显的使用案例提供了一些启示。你了解到结构体不能作为子类，而类可以。你还了解到传递值类型会传递每个实例的副本，而传递引用类型则不会复制每个实例，而是传递指向内存地址的指针。然后，你学习了每种类型在内存中的存储方式以及这对你创建的对象的性能意味着什么。
- en: Lastly, you read about how to choose between value types and reference types
    by using several rules of thumb that should make choosing between structs, classes,
    and enums fairly straightforward without blindly picking one. The next chapter
    will take your Swift knowledge one step further by showing you how to write ultra-flexible
    code with Swift's generics.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你了解到如何通过使用一些经验法则来选择值类型和引用类型，这些法则应该可以使选择结构体、类和枚举变得相当直接，而无需盲目选择。下一章将通过展示如何使用
    Swift 的泛型编写超灵活的代码，将你的 Swift 知识提升到一个新的层次。
