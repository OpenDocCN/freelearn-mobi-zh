- en: Chapter 2. Building a UI
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：构建UI
- en: The **Material Design** UI paradigm has brought a whole new look and feel to
    the Android platform. This new approach aims to give Android apps a clean and
    simple appearance with intuitive controls and animations. Google talks of virtual
    paper and virtual ink, and this concept can be seen most clearly in the new screen
    component (or widget), the Card (or `CardView`), which unlike previous Android
    widgets casts a shadow and has rounded corners.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**Material Design** UI范式为Android平台带来了全新的外观和感觉。这种新的方法旨在为Android应用程序提供一个干净、简单的外观，具有直观的控件和动画。谷歌谈论虚拟纸张和虚拟墨水，这个概念在新屏幕组件（或小部件）卡片（或`CardView`）中最为明显，它不同于之前的Android小部件，可以投射阴影并具有圆角。'
- en: '![Building a UI](img/B04321_02_01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![构建UI](img/B04321_02_01.jpg)'
- en: Even before we have placed our first `CardView` widget into our layout, we can
    start to utilize Material Design by applying and customizing one of the material
    themes. These themes allow us to define a few base colors and properties which
    are then automatically applied throughout our app, giving it a brand identity
    that helps our app to be easily recognized by the user.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将第一个`CardView`小部件放置到布局中之前，我们可以开始利用Material Design，通过应用和自定义一个材质主题。这些主题允许我们定义一些基本颜色和属性，然后自动应用于我们的应用程序，赋予它一个品牌身份，帮助用户轻松识别我们的应用程序。
- en: Having created our layout, we can then see how Java is used to provide functionality.
    Here, we will use a button to launch a simple Material Design animation, which
    we will then adapt to our layout to handle screen rotations and provide textual
    context to our images for users with visual impairments.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建完我们的布局后，我们可以看到Java是如何用来提供功能的。在这里，我们将使用一个按钮来启动一个简单的Material Design动画，然后将其应用到我们的布局中，以处理屏幕旋转，并为有视觉障碍的用户提供图像的文本上下文。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Apply a material theme to our app
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将材质主题应用到我们的应用程序中
- en: Apply your brand colors
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用您的品牌颜色
- en: Understand Material Design color guidelines
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Material Design颜色指南
- en: Add new widgets to a relative layout
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向相对布局添加新的小部件
- en: Write some Java code to detect button clicks
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一些Java代码来检测按钮点击
- en: Write code to produce an animation
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写代码以生成动画
- en: Observe the build process with the Gradle console
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Gradle控制台观察构建过程
- en: Apply accessibility options for images
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为图像应用可访问性选项
- en: Create layouts for alternative screen orientations
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建适用于不同屏幕方向的布局
- en: In this chapter, we will continue to develop the `Hello World` app that we started
    in the previous chapter and use it to demonstrate a simple animation. The code
    can be downloaded from the Packt Publishing website and is called `Hello World
    - Chapter 2`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续开发在前一章中开始创建的`Hello World`应用程序，并使用它来演示一个简单的动画。代码可以从Packt Publishing网站下载，名称为`Hello
    World - Chapter 2`。
- en: Applying a Material Design theme
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用Material Design主题
- en: Android themes govern the general appearance of our app, controlling things
    like default background colors and text colors and sizes. Prior to Android 5,
    the Holo theme was the most widely used built-in theme, and you can preview it
    by clicking on the **App Theme** button at the top of the `activity_main.xml`
    file, when viewed in the **Design** tab.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Android主题控制着应用程序的一般外观，如默认背景颜色、文本颜色和大小。在Android 5之前，Holo主题是最广泛使用的内置主题，您可以通过在**设计**选项卡中查看`activity_main.xml`文件顶部点击**App
    Theme**按钮来预览它。
- en: Tip
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that previewing a theme will have no effect on the app when it is run on
    a handset or an emulator, as this has to be achieved within the code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当在手机或模拟器上运行应用程序时，预览主题不会对应用程序产生影响，因为这必须在代码中实现。
- en: 'All Android themes are highly configurable and none more so than the material
    theme, which allows us, with just a few lines of code, to set a color scheme that
    is applied across the app, and unlike its predecessors, to also change the color
    of the toolbar and the navigation bar. The following exercise details how such
    branding can be applied to the project we set up in the last chapter:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Android主题都高度可配置，没有比材质主题更可配置的，它允许我们仅用几行代码就设置一个应用于整个应用程序的颜色方案，并且与它的前辈不同，还可以更改工具栏和导航栏的颜色。以下练习详细说明了如何将这种品牌应用到我们在上一章中设置的项目中：
- en: Open the `Hello World` project from the last chapter.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从上一章打开`Hello World`项目。
- en: If it is not open already, open the **Project** tool window from the menu with
    **View** | **Tool Windows** | **Project**.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它还没有打开，请从菜单中使用**视图** | **工具窗口** | **项目**打开**项目**工具窗口。
- en: Locate the `res/values` folder and right-click on it.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位到`res/values`文件夹，并右键单击它。
- en: Select **New** | **XML** | **Values XML File** from the menu and call the file
    `colors`.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从菜单中选择**新建** | **XML** | **值 XML 文件**，并将文件命名为`colors`。
- en: 'Fill out the `colors.xml` file as follows here:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式填写`colors.xml`文件：
- en: '[PRE0]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Open the `res/values/styles/styles.xml (v21)` file and complete it as below:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`res/values/styles/styles.xml (v21)`文件，并按照以下方式完成它：
- en: '[PRE1]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can now run the app on a handset or an emulator, to see how our brand colors
    have been applied:![Applying a Material Design theme](img/B04321_02_02.jpg)
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以在手机或模拟器上运行应用，以查看我们的品牌颜色是如何应用的：![应用 Material Design 主题](img/B04321_02_02.jpg)
- en: Tip
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that not all the material theme colors will show up on the standard Android
    AVDs, in particular, the status and navigation bars. To view the changes, you
    will need a real device or one of the third-party emulators.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，并非所有材料主题颜色都会在标准的 Android AVD 上显示，特别是状态栏和导航栏。要查看更改，您需要一个真实设备或第三方模拟器。
- en: Being able to apply our own color scheme to the previously un-editable UI elements,
    such as the status and navigation bars is a huge bonus. Not only does it give
    us control over how the entire screen looks, but it gives our apps an identifiable
    and individual feel.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 能够将我们自己的颜色方案应用到之前不可编辑的 UI 元素，如状态栏和导航栏，这是一个巨大的优势。这不仅让我们能够控制整个屏幕的外观，而且让我们的应用具有可识别和独特的风格。
- en: Android provides fields such as `colorPrimaryDark` and `navigationBarColor`
    as convenient ways to apply our color schemes throughout the app. It is generally
    recommended that the navigation bar be left black, and was colored here simply
    by way of demonstration. We did not use all the color attributes that we could
    have; had we wanted to, we could have set the window background color with `windowBackground`
    and `statusBarColor`, which will override it being set by default as `colorPrimaryDark`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Android 提供了`colorPrimaryDark`和`navigationBarColor`等字段，作为在应用中应用我们的颜色方案的便捷方式。通常建议导航栏保持黑色，这里仅通过演示进行了着色。我们没有使用所有可能使用的颜色属性；如果我们想使用，我们可以使用`windowBackground`和`statusBarColor`设置窗口背景颜色，这将覆盖默认的`colorPrimaryDark`设置。
- en: Tip
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that `colorAccent` is not visible in this demonstration. It is used for
    switches, sliders and editable text views, among other things. It is included
    here as we will be using this theme (or one with colors of your choice) throughout
    the book and the inclusion of `colorAccent` will become evident as we progress.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`colorAccent`在此演示中不可见。它用于开关、滑块和可编辑的文本视图等。它包含在这里，因为我们将在整本书中使用这个主题（或您选择的颜色），随着我们的进展，`colorAccent`的包含将变得明显。
- en: 'Selecting colors for our theme is made remarkably easy with the help of an
    IDE, as you can see that the colors we have defined are displayed in the gutter:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IDE 的帮助下，为我们的主题选择颜色变得非常容易，正如你所看到的，我们定义的颜色在侧边栏中显示：
- en: '![Applying a Material Design theme](img/B04321_02_03.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![应用 Material Design 主题](img/B04321_02_03.jpg)'
- en: From the `colors.xml` file, these colors can be clicked on to produce a dynamic
    color wheel for us to select from. Although we are free to use any colors we like
    for our theme, Google design guidelines suggest that colors should be picked from
    the recommended hues, a full list of which can be found at [http://www.google.com/design/spec/style/color.html](http://www.google.com/design/spec/style/color.html).
    Furthermore, Google also recommends that the primary color should have a value
    of 500 and the darker version should be 700.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从`colors.xml`文件中，我们可以点击这些颜色以生成一个动态的颜色轮，供我们选择。虽然我们可以自由地为我们主题选择任何喜欢的颜色，但 Google
    设计指南建议从推荐的色调中选择颜色，完整的列表可以在[http://www.google.com/design/spec/style/color.html](http://www.google.com/design/spec/style/color.html)找到。此外，Google
    还建议主要颜色应具有值 500，较深的版本应为 700。
- en: In the `colors.xml` file, it can be seen that the text colors are defined with
    alpha channels.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在`colors.xml`文件中，可以看到文字颜色是用 alpha 通道定义的。
- en: Google recommends that we use transparency to produce various shades of text.
    In particular, they suggest around 87% opacity for our primary text and 54% for
    the secondary. When dealing with white text on a dark background, opacity values
    of 100% and 70% should be used. Edit text hints should be around 28% for either
    background.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Google 建议我们使用透明度来产生各种文字的阴影。特别是，他们建议我们的主要文字的透明度约为 87%，次要文字的透明度约为 54%。当处理深色背景上的白色文字时，应使用
    100% 和 70% 的透明度值。文本提示的透明度应约为 28%，无论是背景还是前景。
- en: You will have noticed that there are two `styles.xml` files, the `v21` version
    that we used and another with the same name. This other styles file is used for
    providing alternative themes for when we need to make our apps backward compatible.
    We will come to this in due course, but for now the other styles file can be safely
    ignored.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到有两个`styles.xml`文件，一个是我们在`v21`版本中使用的，另一个与同一个名字。这个其他样式文件用于在需要使我们的应用向后兼容时提供替代主题。我们将在适当的时候讨论这个问题，但现在可以安全地忽略其他样式文件。
- en: Material Design guidelines do not have to be followed rigidly, especially if
    you are designing a full-screen app such as a game. They are there to help developers
    build apps that provide a consistent experience across the platform, and how strictly
    you adhere to the guidelines is entirely up to you.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 材料设计指南不必严格遵循，尤其是当你设计一个全屏应用，比如游戏时。它们的存在是为了帮助开发者构建在整个平台上提供一致体验的应用，而你如何严格遵循这些指南完全取决于你。
- en: Having seen how easy it is to apply a personalized theme to our app, we can
    now start to add more visual components to our layout and take a look at how they
    can then be controlled programmatically with Java. We will continue with our `Hello
    World` project and to make it a little more interesting, we will add in some simple
    Android 5 animations.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 看过如何轻松地将个性化主题应用到我们的应用后，我们现在可以开始向布局添加更多视觉组件，并查看它们如何随后用Java编程控制。我们将继续使用`Hello
    World`项目，并使其变得更有趣，我们将添加一些简单的Android 5动画。
- en: Adding animated widgets
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加动画小部件
- en: As with many programming languages, design and functionality are dealt with
    more or less separately. We use XML to design our layouts and Java to provide
    them with functionality. Here, we will see how both of these are done and will
    deal separately with each.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 就像许多编程语言一样，设计和功能基本上是分开处理的。我们使用XML来设计我们的布局，使用Java来提供它们的功能。在这里，我们将看到这两者是如何完成的，并将分别处理每个。
- en: Designing an XML layout
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计XML布局
- en: We will be using the graphical design view to construct this UI, but it is worth
    checking the text view from the tab at the bottom after each step, to see how
    the changes that we make are applied in XML.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用图形设计视图来构建这个UI，但值得在每个步骤后从底部的标签检查文本视图，看看我们做出的更改是如何应用到XML中的。
- en: Open the `Hello World` project and then the `activity_main.xml` file.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Hello World`项目，然后是`activity_main.xml`文件。
- en: Click on the **Design** tab at the bottom to view the device preview.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击底部的**设计**标签以查看设备预览。
- en: Drag a `TextView` control into the middle of the screen, like so:![Designing
    an XML layout](img/B04321_02_04.jpg)
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`TextView`控件拖动到屏幕中间，就像这样：![设计XML布局](img/B04321_02_04.jpg)
- en: From the **Palette** on the left, drag and drop a **Button** widget to the bottom-center
    of the screen.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从左侧的**调色板**中拖放一个**按钮**小部件到屏幕的底部中央。
- en: 'Drag an **ImageView** control from the **Palette** just under the **TextView**.
    The tip at the top should read:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从位于**TextView**下方的**调色板**中拖动一个**ImageView**控件。顶部的提示应该读作：
- en: '[PRE2]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With the **ImageView** still selected, or by selecting it in the **Component
    Tree** pane, locate `src` in the **Properties** pane beneath this and click on
    the **....** button to bring up this dialog box:![Designing an XML layout](img/B04321_02_05.jpg)
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择**ImageView**的情况下，或者通过在**组件树**面板中选择它，在下面的**属性**面板中找到`src`并点击**....**按钮以打开此对话框：![设计XML布局](img/B04321_02_05.jpg)
- en: Select **Mip Map** | **ic_launcher** and click on **OK**.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Mip Map** | **ic_launcher**并点击**确定**。
- en: Selecting the **ImageView** in the preview window and press *Ctrl* + *C* followed
    by *Ctrl* + *V*.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在预览窗口中选择**ImageView**并按*Ctrl* + *C*，然后按*Ctrl* + *V*。
- en: Place the **ImageView** copy to the right of the one we just created.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**ImageView**副本放置在我们刚刚创建的一个右侧。
- en: Repeat this process, placing a third **ImageView** to the left, so that the
    lower half of the layout looks like this:![Designing an XML layout](img/B04321_02_06.jpg)
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复此过程，将第三个**ImageView**放置在左侧，这样布局的下半部分看起来就像这样：![设计XML布局](img/B04321_02_06.jpg)
- en: Now, open the **Text** view of our layout with the tab at the bottom.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用底部的标签打开我们布局的**文本**视图。
- en: Locate the **Button** node and click on the line that reads `android:text="New
    Button"`. An amber quick fix bulb will appear along with a warning about hardcoding
    strings.![Designing an XML layout](img/B04321_02_07.jpg)
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位到**按钮**节点，并点击显示`android:text="New Button"`的行。一个琥珀色的快速修复灯泡会出现，同时会显示有关硬编码字符串的警告。![设计XML布局](img/B04321_02_07.jpg)
- en: Click on the **quick fix** drop-down and select **Extract string resource**.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**快速修复**下拉菜单并选择**提取字符串资源**。
- en: In the resultant dialog, provide the **Resource name** as `button_text` and
    click on **OK**.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在结果对话框中，将**资源名称**设置为`button_text`并点击**确定**。
- en: 'Open the file in **Text** view and add this line to the `RelativeLayout` element:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以**文本**视图打开文件，并将此行添加到`RelativeLayout`元素中：
- en: '[PRE3]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, add this line to the **TextView**:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将此行添加到**TextView**：
- en: '[PRE4]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: That's it, as far as designing our layout is concerned!
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就设计布局而言，这就完成了！
- en: Tip
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can use *Ctrl* + *Alt* + *L* to automatically format any code. *Ctrl* +
    *Alt* + *Shift* + *L* will bring up the reformatting dialog.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用*Ctrl* + *Alt* + *L*来自动格式化任何代码。*Ctrl* + *Alt* + *Shift* + *L*将打开重排对话框。
- en: All Android layout designs have at their root a container object called a **ViewGroup**,
    in to which all other graphical objects are placed. This includes other ViewGroups,
    although complex layouts with lots of nested ViewGroups can have a negative effect
    on performance.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Android布局设计在其根部都有一个名为**ViewGroup**的容器对象，其中放置了所有其他图形对象。这包括其他ViewGroup，尽管具有许多嵌套ViewGroup的复杂布局可能会对性能产生负面影响。
- en: 'The ViewGroup widget container we used here was the **RelativeLayout**. There
    are several other types of layout, each being suited to a particular purpose,
    and we will encounter these throughout the book. The RelativeLayout widget container
    we used here allows us to define widget positions relative to other widgets. For
    example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的ViewGroup小部件容器是**RelativeLayout**。还有几种其他类型的布局，每种布局都适合特定的目的，我们将在整本书中遇到这些布局。我们在这里使用的RelativeLayout小部件容器允许我们定义小部件相对于其他小部件的位置。例如：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is very handy when it comes to designing layouts that will run on screens
    of varying sizes and ratios.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到设计将在不同尺寸和比例的屏幕上运行的布局时，这非常方便。
- en: There are three tools at our disposal when it comes to generating layout files.
    We have the (almost) WYSIWYG device preview window, that allows us to position
    and size the widgets, the **Properties** pane which lets us set particular values
    and, perhaps most powerfully, the **Text** edit window which provides control
    over every aspect of our design.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成布局文件方面，我们有三种工具可供使用。我们有（几乎）所见即所得的设备预览窗口，允许我们定位和调整小部件的大小，**属性**面板允许我们设置特定的值，也许最强大的是**文本**编辑窗口，它提供了对我们设计每个方面的控制。
- en: We set the size of our text with `android:attr/textAppearanceMedium`. We could
    have set the size exactly with something like `android:textSize="42sp"`, but using
    `textAppearanceMedium` or `textAppearanceLarge` or `textAppearanceSmall` takes
    into consideration the text settings that the user has configured on their phone.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`android:attr/textAppearanceMedium`设置了文本的大小。我们本可以使用类似`android:textSize="42sp"`的东西来精确设置大小，但使用`textAppearanceMedium`、`textAppearanceLarge`或`textAppearanceSmall`会考虑用户在手机上配置的文本设置。
- en: By far the most important aspect of what we have just done is the fact that
    each widget has an identifier in the form of `android:id="@+id/some_unique_identifier"`.
    These IDs are how we refer to and control widgets during runtime from our Java
    code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚所做的一切中，最重要的方面是每个小部件都有一个标识符，形式为`android:id="@+id/some_unique_identifier"`。这些ID是我们从Java代码中在运行时引用和控制小部件的方式。
- en: We used the built-in application icon for our **ImageView** controls as a matter
    of convenience, but we could have supplied our own imagery, stored it in the `res(ources)/drawable`
    folder and used its filename (without the extension) as its ID. We will be doing
    a lot of this later, so it is not necessary to worry about it here. If you take
    a look inside the `mipmap` folder, you will see that there are four `ic_launcher`
    icons, for varying screen densities. To achieve high quality icons for all available
    screen densities, you will need to provide all four icons.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们出于方便使用了内置的应用程序图标作为我们的**ImageView**控件，但我们也可以提供自己的图像，将其存储在`res(ources)/drawable`文件夹中，并使用其文件名（不带扩展名）作为其ID。我们将在后面做很多这样的事情，所以在这里不必担心。如果您查看`mipmap`文件夹，您将看到有四个`ic_launcher`图标，针对不同的屏幕密度。为了为所有可用的屏幕密度提供高质量图标，您需要提供所有四个图标。
- en: When we created the button on our screen, IDE provided the text **New Button**
    for us. Although a hardcoded string like this will work perfectly well, it is
    not recommended, for the reason that you will not be able to provide translations
    into other languages.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在屏幕上创建按钮时，IDE为我们提供了文本**新按钮**。尽管像这样的硬编码字符串可以完美工作，但并不推荐这样做，因为您将无法提供其他语言的翻译。
- en: With our layout in place, we can now get on with the business of making it do
    something. Here, we will apply some of the new Android 5 animations which work
    when the button is clicked on.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的布局已经就绪，现在我们可以继续让它执行一些操作。在这里，我们将应用一些新的 Android 5 动画，这些动画在按钮被点击时生效。
- en: Controlling the widget behavior with Java
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Java 控制小部件行为
- en: 'Android 5 introduces a new and simpler way of animating screen elements. These
    animations are of most use when transitioning between one screen to another, and
    can be used to intuitively display to the user what the app is doing. This app
    has only one screen (`Activity`), so we will just animate our widgets to fly off
    the screen and then return. Before we start though, we need to configure the IDE
    to automatically import the Java libraries our app will use. Follow these steps
    to see how both tasks are done:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Android 5 引入了一种新的、更简单的屏幕元素动画方式。这些动画在从一个屏幕切换到另一个屏幕时非常有用，并且可以直观地向用户展示应用正在做什么。这个应用只有一个屏幕（`Activity`），所以我们将只让我们的小部件飞离屏幕，然后返回。但在开始之前，我们需要配置
    IDE 以自动导入应用将使用的 Java 库。按照以下步骤查看如何完成这两个任务：
- en: From the **File Menu** select **Settings** | **Editor** | **General** | **Auto
    Import** and check all boxes as below:![Controlling the widget behavior with Java](img/B04321_02_10.jpg)
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **文件菜单** 选择 **设置** | **编辑器** | **通用** | **自动导入**，并勾选以下所有复选框：![使用 Java 控制小部件行为](img/B04321_02_10.jpg)
- en: Open the `MainActivity.java` file.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainActivity.java` 文件。
- en: 'At the top of the class, add these fields:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类顶部添加以下字段：
- en: '[PRE6]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the `onCreate()` method underneath the line `setContentView(R.layout.activity_main);`
    add this code:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onCreate()` 方法中，在 `setContentView(R.layout.activity_main);` 行下方添加以下代码：
- en: '[PRE7]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Beneath this, add the code for the `Button` control as follows:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此之下，添加 `Button` 控制的代码如下：
- en: '[PRE8]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Create a new method called `toggle()` and complete it like this:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `toggle()` 的新方法，并按照以下方式完成它：
- en: '[PRE9]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The app can now be tested on an emulator or a connected handset. Click on the
    run icon on the IDE toolbar:![Controlling the widget behavior with Java](img/B04321_02_08.jpg)
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用现在可以在模拟器或连接的手机上进行测试。在 IDE 工具栏上点击运行图标：![使用 Java 控制小部件行为](img/B04321_02_08.jpg)
- en: Although simple to follow, the code here covers some very important points.
    Firstly, there is the `onCreate()` method. This method is called as soon as the
    Activity is launched, usually with the application icon, and will form the start
    point of almost every Android app you will ever create. The first three lines,
    that were created for us, inflate our layout. We then used `findViewById()`, to
    associate our layout widgets with our Java instances.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然代码易于理解，但它涵盖了非常关键的一些点。首先，是 `onCreate()` 方法。该方法在 Activity 启动时立即被调用，通常是通过应用程序图标，并将成为你将创建的几乎所有
    Android 应用的起点。我们为我们创建的前三条线填充了布局。然后我们使用 `findViewById()` 将我们的布局小部件与 Java 实例关联起来。
- en: Note
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that, for convenience, we used the names that the editor suggested here.
    In future, we will use the form `textView` to declare the Java instances and `text_view`
    for the XML counterparts.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了方便，我们在这里使用了编辑器建议的名称。将来，我们将使用 `textView` 形式声明 Java 实例，以及 `text_view` 用于
    XML 对应物。
- en: We also changed the text inside two of our widgets using the `setText()` method.
    We could have done this from within the XML, but it is very useful to know how
    to do this dynamically with Java.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用 `setText()` 方法更改了我们两个小部件内的文本。我们也可以在 XML 中这样做，但了解如何使用 Java 动态完成此操作非常有用。
- en: The `OnClickListener()` interface we attached to our button provides us with
    the `onClick()` method, giving us control over what actions are performed when
    our widgets are clicked on. There was only one button in this Activity, so we
    created an `OnClickListener()` specifically for it. Often, our apps will have
    more than one button or clickable control and, as we will see in the next chapter,
    we can have the Activity itself implement a click listener and then have one `onClick()`
    method to handle all our buttons.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们附加到按钮上的 `OnClickListener()` 接口为我们提供了 `onClick()` 方法，使我们能够控制在小部件被点击时执行哪些操作。在这个
    Activity 中只有一个按钮，所以我们为它创建了一个特定的 `OnClickListener()`。通常，我们的应用将拥有多个按钮或可点击控件，正如我们将在下一章中看到的，Activity
    本身可以实现一个点击监听器，然后有一个 `onClick()` 方法来处理所有按钮。
- en: The animation itself is configured and triggered with the `TransitionManager`
    class and we will return to this later in the book. For now, it is worth changing
    the term `Explode()` to `Fade()` or `Slide()`. The effect these changes have will
    not surprise you, but it is useful to know that they are available. Most of the
    time, when we apply animations to our apps, they are for the purpose of demonstrating
    transitions from one Activity to another, rather than being merely for decoration,
    as we did here.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 动画本身是通过`TransitionManager`类配置和触发的，我们将在本书稍后回到这个话题。现在，值得将术语`Explode()`更改为`Fade()`或`Slide()`。这些更改产生的影响不会让你感到惊讶，但了解它们是可用的很有用。大多数时候，当我们将动画应用到我们的应用中时，它们是为了演示从一个Activity到另一个Activity的过渡，而不仅仅是作为装饰，就像我们在这里所做的那样。
- en: Once you click on the run icon, the build process can be quite slow, particularly
    on older machines. There are, however, one or two handy tools that allow us to
    observe this process. Hover over the small icon in the lower left corner of the
    IDE and select **Gradle Console**.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你点击运行图标，构建过程可能会相当慢，尤其是在较旧的机器上。然而，有一些方便的工具可以帮助我们观察这个过程。将鼠标悬停在IDE左下角的小图标上，并选择**Gradle控制台**。
- en: '![Controlling the widget behavior with Java](img/B04321_02_09.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![使用Java控制小部件行为](img/B04321_02_09.jpg)'
- en: It is not necessary to understand the output of the Gradle console, but it is
    reassuring to see that the process has not ground to a halt on longer builds.
    Two other very useful windows that can be accessed in the same manner are the
    **Android** and **Run** windows. These can also be opened from the keyboard with
    *Alt* + *4* and *Alt* + *6* respectively.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 不必理解Gradle控制台输出的内容，但看到在较长的构建过程中过程没有停止是令人放心的。以相同的方式可以访问的其他两个非常有用的窗口是**Android**和**运行**窗口。这些也可以通过键盘上的*Alt*
    + *4*和*Alt* + *6*分别打开。
- en: If you have spent any time experimenting with the above app, you will have noticed
    that when the emulator or the device is rotated through 90 degrees, one or two
    things do not work as we might hope. Firstly, the animation resets whenever the
    device is rotated. This is because this, along with any other Activity, is reloaded
    whenever the the orientation changes and the `onCreate()` method is called afresh.
    There are, however, several other callback methods that allow us to intercept
    this process. We will be taking a closer look at the Activity life-cycle later
    on, but for now we will explore the second issue, which is the way the system
    positions our text and images in the landscape view.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你花了一些时间实验上述应用，你会注意到当模拟器或设备旋转90度时，有一两件事情并没有按我们希望的方式工作。首先，每次设备旋转时动画都会重置。这是因为这，以及任何其他Activity，都会在方向改变和`onCreate()`方法被重新调用时重新加载。然而，还有几个其他回调方法允许我们拦截这个过程。我们将在稍后更详细地查看Activity生命周期，但现在我们将探索第二个问题，即系统在横屏视图中定位我们的文本和图像的方式。
- en: Tip
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: An AVD can be rotated through 90 degrees by pressing *Ctrl* + *F12*. Pressing
    the home key returns the AVD to its home screen and *Esc* is the same as pressing
    the device's back button.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过按*Ctrl* + *F12*将AVD旋转90度。按主页键将AVD返回到其主页，而*Esc*键与按设备后退按钮相同。
- en: Creating alternative layouts
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建替代布局
- en: When a device running one of our apps is rotated into landscape orientation,
    it refers to the same XML file as it does in portrait mode. Often this works perfectly
    well, but it is incredibly simple to set up an alternative layout that better
    suits the shape of a landscape screen. Follow these steps to create an alternative
    layout file for landscape viewing.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行我们应用之一的设备旋转到横屏模式时，它引用的XML文件与在竖屏模式下的相同。通常这工作得非常好，但设置一个更适合横屏屏幕形状的替代布局非常简单。按照以下步骤创建一个用于横屏查看的替代布局文件。
- en: Open the `activity_main.xml` file in **Design** view.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**设计**视图中打开`activity_main.xml`文件。
- en: Click on the icon in the top-left and select **Create Landscape Variation**.![Creating
    alternative layouts](img/B04321_02_11.jpg)
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左上角的图标，并选择**创建横屏变体**。![创建替代布局](img/B04321_02_11.jpg)
- en: Drag and rearrange the onscreen widgets to form a more pleasing use of space.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖动并重新排列屏幕上的小部件，以形成更令人愉悦的空间使用。
- en: Select one of the `ImageView` controls. Then click on the amber quick-fix icon.
    It will inform you that the image is missing a `contentDescription`. Click on
    this message and complete the resultant dialog as below:![Creating alternative
    layouts](img/B04321_02_12.jpg)
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个`ImageView`控件。然后点击琥珀色的快速修复图标。它会通知你图片缺少`contentDescription`。点击这条消息并完成如下所示的对话框：![创建替代布局](img/B04321_02_12.jpg)
- en: Finally, run the app on a device or an emulator and check its behavior when
    rotated.![Creating alternative layouts](img/B04321_02_13.jpg)
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在设备或模拟器上运行应用程序并检查其旋转时的行为。![创建替代布局](img/B04321_02_13.jpg)
- en: Including a layout file for landscape orientation is as simple as placing a
    file with the same name and widget IDs in the `res/layout-land` directory instead
    of the `res/layout` directory. This file can then be edited in any way we like
    and will be automatically inflated whenever the screen is rotated to a landscape
    orientation.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 包含一个用于横屏方向的布局文件就像在`res/layout-land`目录中放置一个具有相同名称和控件ID的文件，而不是在`res/layout`目录中。然后我们可以以任何我们喜欢的方式编辑此文件，并且当屏幕旋转到横屏方向时，它将自动展开。
- en: As creating alternative layout files is such a quick and simple task, we also
    looked at how to provide alternative output for users with visual impairments
    in the form of content description for images. When a user with a visual impairment
    sets accessibility options and we have provided an appropriate text alternative,
    this description will be read out to the user. For the sake of brevity, we will
    not be adding this description for every exercise in this book, but it is recommended
    that such attributes are included in any apps intended for release.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于创建替代布局文件是一项如此快速且简单的任务，我们还探讨了如何为有视觉障碍的用户提供替代输出，形式为图像的内容描述。当有视觉障碍的用户设置了辅助功能选项，并且我们提供了适当的文本替代品时，此描述将被读给用户听。为了简洁起见，我们不会在本书的每个练习中都添加此描述，但建议在打算发布的任何应用程序中都包含此类属性。
- en: Tip
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.packtpub.com](http://www.packtpub.com)的账户中下载您购买的所有Packt书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册以直接将文件通过电子邮件发送给您。
- en: Summary
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This concludes our introduction to the relationship between XML layouts and
    Java code. We have seen how to produce layouts for a wide variety of screen sizes
    and orientations and how to connect these XML definitions to a dynamic Java code
    that controls our app's behavior at runtime. Significantly, we have seen how the
    `onCreate()` method is used to set up our app and how it is called whenever a
    device is rotated. We took advantage of this fact by creating an alternative layout,
    designed specifically for a rotated screen.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对XML布局与Java代码之间关系的介绍。我们看到了如何为各种屏幕尺寸和方向生成布局，以及如何将这些XML定义连接到动态的Java代码，该代码在运行时控制我们应用程序的行为。值得注意的是，我们看到了`onCreate()`方法是如何用来设置我们的应用程序的，以及它何时被调用以响应设备的旋转。我们利用这一事实，通过创建一个专门为旋转屏幕设计的替代布局来利用这一事实。
- en: In the next chapter, we will look at how to implement the two newest Android
    widgets, the `CardView`, which is a convenient and stylish container for whatever
    information we wish to display, and the `RecyclerView`, which manages the lists
    of `CardView` controls, or other views, in a memory efficient manner.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何实现两个最新的Android小部件，即`CardView`，它是一个方便且时尚的容器，可以显示我们希望展示的任何信息，以及`RecyclerView`，它以内存高效的方式管理`CardView`控件或其他视图的列表。
