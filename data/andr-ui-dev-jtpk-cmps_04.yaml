- en: 'Chapter 3: Exploring the Key Principles of Compose'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章：探索 Compose 的关键原则
- en: In the first chapter of this book, we built and run our first Jetpack Compose
    app. Then, in [*Chapter 2*](B17505_02_ePub.xhtml#_idTextAnchor040), *Understanding
    the Declarative Paradigm*, we explained the imperative nature of Android's traditional
    UI toolkit, illustrated some of its weaknesses, and saw how a declarative approach
    can overcome them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第一章中，我们构建并运行了我们的第一个 Jetpack Compose 应用。然后，在[*第二章*](B17505_02_ePub.xhtml#_idTextAnchor040)，*理解声明式范式*中，我们解释了
    Android 传统 UI 工具箱的命令式本质，展示了其一些弱点，并看到了声明式方法如何克服它们。
- en: In this chapter, we build upon these foundations by examining a few key principles
    Jetpack Compose relies on. This knowledge is essential for writing well-behaving
    Compose apps. This chapter introduces these key principles.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过考察 Jetpack Compose 依赖的一些关键原则来建立这些基础。这些知识对于编写表现良好的 Compose 应用至关重要。本章介绍了这些关键原则。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Looking closer at composable functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仔细研究可组合函数
- en: Composing and recomposing the **user interface** (**UI**)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合和重新组合**用户界面**（**UI**）
- en: Modifying the behavior of composable functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改可组合函数的行为
- en: We will start by revisiting composable functions, the building blocks of a composable
    UI. This time, we will dig much deeper into their underlying ideas and concepts.
    By the end of the first main section, you will have established a thorough understanding
    of what composable functions are, how they are written, and how they are used.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先回顾可组合函数，这是可组合 UI 的构建块。这次，我们将深入挖掘其背后的思想和概念。到第一主要部分的结尾，你将全面理解什么是可组合函数，它们是如何编写的，以及它们是如何被使用的。
- en: The following section focuses on creating and updating the UI. You will learn
    how Jetpack Compose achieves what other UI frameworks call repainting. This mechanism,
    which is called **recomposition** in Compose, takes place automatically whenever
    something relevant to the UI changes. To keep this process fluent, your composable
    functions must adhere to a few best practices. I will explain them to you in this
    section.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将专注于创建和更新 UI。您将了解 Jetpack Compose 如何实现其他 UI 框架所说的重绘。这种机制在 Compose 中被称为**重新组合**，每当与
    UI 相关的内容发生变化时，它就会自动发生。为了保持这个过程流畅，您的可组合函数必须遵循一些最佳实践。我将在本节中为您解释它们。
- en: We will close this chapter by expanding our knowledge of the concept of modifiers.
    We will take a close look at how modifier chains work and what you need to keep
    in mind to always get the intended results. You will also learn how to implement
    custom modifiers. They allow you to amend any composable function to look or behave
    in precisely the way you want them to.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过扩展我们对修饰符概念的了解来结束本章。我们将仔细研究修饰符链是如何工作的，以及您需要记住什么才能始终得到预期的结果。您还将学习如何实现自定义修饰符。它们允许您修改任何可组合函数，使其看起来或表现成您想要的方式。
- en: Now, let's get started!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始吧！
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Please refer to the *Technical requirements* section of [*Chapter 1*](B17505_01_ePub.xhtml#_idTextAnchor014),
    *Building Your First Compose App*, for information on how to install and set up
    Android Studio, as well as how to get the sample apps. If you want to try the
    `ShortColoredTextDemo()` and `ColoredTextDemo()` composables from the *Looking
    closer at composable functions* section, you can use the `Sandbox` app project
    in the top-level directory of this book's GitHub repository at [https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose](https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose).
    Open `SandboxActivity` and copy the composable functions from `code_snippets.txt`,
    which will be located in the `/chapter_03` folder.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[*第一章*](B17505_01_ePub.xhtml#_idTextAnchor014)，*构建您的第一个 Compose 应用*中的*技术要求*部分，了解如何安装和设置
    Android Studio，以及如何获取示例应用。如果您想尝试*仔细研究可组合函数*部分中的`ShortColoredTextDemo()`和`ColoredTextDemo()`可组合函数，您可以使用位于本书
    GitHub 仓库顶层目录中的`Sandbox`应用项目。打开`SandboxActivity`，从位于`/chapter_03`文件夹中的`code_snippets.txt`复制可组合函数。
- en: Looking closer at composable functions
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仔细研究可组合函数
- en: The UI of a Compose app is built by writing and calling composable functions.
    We have already done both in the previous chapters, but my explanations regarding
    the structure of a composable, as well as its internals, have been quite basic
    – it's time to fix that.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Compose 应用程序的 UI 是通过编写和调用可组合函数来构建的。我们已经在之前的章节中做了这两件事，但关于可组合函数的结构及其内部结构的解释相当基础——现在是时候解决这个问题了。
- en: Building blocks of composable functions
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可组合函数的构建块
- en: 'A `@Composable`.     All composables *must* be marked this way because the annotation informs the Compose
    compiler that the function converts data into UI elements.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '一个 `@Composable`。     所有可组合函数都必须这样标记，因为注解会通知 Compose 编译器该函数将数据转换为 UI 元素。'
- en: 'The signature of a Kotlin function consists of the following parts or building
    blocks:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 函数的签名由以下部分或构建块组成：
- en: An optional visibility modifier (`private`, `protected`, `internal`, or `public`)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的可见性修饰符（`private`、`protected`、`internal` 或 `public`）
- en: The `fun` keyword
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fun` 关键字'
- en: A name
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名称
- en: A list of parameters (can be empty) or, optionally, a default value
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数列表（可以空着）或，可选地，一个默认值
- en: An optional return type
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的返回类型
- en: A block of code
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一段代码块
- en: Let's explore these parts in greater detail.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地探讨这些部分。
- en: The default visibility (if you omit the modifier) is `public`. This means that
    the (composable) function can be called from anywhere. If a function is meant
    to be reused (for example, a text styled to match your brand), it should be publicly
    available. On the other hand, if a function is tied to a particular **context**
    (the region of code, such as a class), it may make sense to restrict its access.
    There is an open debate on how rigid the visibility of functions should be restrained.
    In the end, you and your team need to agree on a point of view and stick to it.
    For the sake of simplicity, my examples are usually public.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 默认可见性（如果你省略了修饰符）是 `public`。这意味着（可组合的）函数可以从任何地方调用。如果一个函数打算被重用（例如，一个与你的品牌风格匹配的文本），它应该是公开可用的。另一方面，如果一个函数与特定的
    **上下文**（如一个类）相关联，限制其访问可能是有意义的。关于函数可见性应该有多严格，有一个公开的讨论。最终，你和你的团队需要就一个观点达成一致，并坚持下去。为了简单起见，我的例子通常是公开的。
- en: 'The name of a composable function uses the *PascalCase* notation: it starts
    with an uppercase letter, whereas the remaining characters are lowercase. If the
    name consists of more than one word, each word follows this rule. The name should
    be a noun (`Demo`), or a noun that has been prefixed with a descriptive adjective
    (`FancyDemo`). Unlike other (ordinary) Kotlin functions, it should *not* be a
    verb or a verb phrase (`getDataFromServer`). The *API Guidelines for Jetpack Compose*
    file, which is available at [https://github.com/androidx/androidx/blob/androidx-main/compose/docs/compose-api-guidelines.md](https://github.com/androidx/androidx/blob/androidx-main/compose/docs/compose-api-guidelines.md),
    details these naming conventions.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 可组合函数的名称使用 *PascalCase* 语法：它以大写字母开头，其余字符为小写。如果名称由多个单词组成，每个单词都遵循这个规则。名称应该是名词（`Demo`），或者是一个带有描述性形容词的前缀的名词（`FancyDemo`）。与其它（普通）Kotlin
    函数不同，它不应该是一个动词或动词短语（`getDataFromServer`）。可在 [https://github.com/androidx/androidx/blob/androidx-main/compose/docs/compose-api-guidelines.md](https://github.com/androidx/androidx/blob/androidx-main/compose/docs/compose-api-guidelines.md)
    找到的 *Jetpack Compose API 指南* 文件，详细说明了这些命名约定。
- en: 'All the data you want to pass to a composable function is provided through
    a comma-separated list, which is enclosed in parenthesis. If a composable does
    not require values, the list remains empty. Here''s a composable function that
    can receive two parameters:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要传递给可组合函数的所有数据都通过一个逗号分隔的列表提供，该列表被括号包围。如果一个可组合函数不需要值，列表保持为空。以下是一个可以接收两个参数的可组合函数示例：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In Kotlin, function parameters are defined as `name: type`. Parameters are
    separated by a comma. You can specify a default value by adding `= ...`. This
    is used if no value is provided for a particular parameter when the function is
    being invocated.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '在 Kotlin 中，函数参数定义为 `name: type`。参数通过逗号分隔。你可以通过添加 `= ...` 来指定默认值。当函数被调用时，如果没有为特定参数提供值，就会使用这个默认值。'
- en: 'The return type of a function is optional. In this case, the function returns
    `Unit`. `Unit` is a type with only one value: `Unit`. If, like in this example,
    it is omitted, the function body follows immediately after the list of arguments.
    Most composable functions you will be writing do not need to return anything,
    so do not need a return type. Situations that require it will be covered in the
    *Returning values* section.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的返回类型是可选的。在这种情况下，函数返回`Unit`。`Unit`是一个只有一个值的类型：`Unit`。如果，像这个例子一样，它被省略了，函数体将直接跟在参数列表之后。您将要编写的多数可组合函数都不需要返回任何内容，因此不需要返回类型。需要返回类型的情况将在*返回值*部分介绍。
- en: If the code of a function contains more than one statement or expression, it
    will be enclosed in curly braces. Kotlin offers a nice abbreviation for if just
    one expression needs to be executed – Jetpack Compose itself uses this quite frequently.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数的代码包含多个语句或表达式，它将被括号包围。Kotlin提供了一个很好的缩写，如果只需要执行一个表达式，那就是Jetpack Compose本身经常使用的。
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, the expression follows an equals sign. This means that `ShortColoredTextDemo()`
    returns whatever `Text()` is returning.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，表达式遵循一个等号。这意味着`ShortColoredTextDemo()`返回`Text()`返回的任何内容。
- en: 'Unlike Java, Kotlin does not know about the `void` keyword, so all the functions
    must return *something*. By omitting the return type, we implicitly tell Kotlin
    that the return type of a function is `kotlin.Unit`. This type has only one value:
    the `Unit` object. So, `Unit` corresponds to `void` in Java.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 与Java不同，Kotlin不知道`void`关键字，所以所有函数都必须返回**一些内容**。通过省略返回类型，我们隐式地告诉Kotlin函数的返回类型是`kotlin.Unit`。这个类型只有一个值：`Unit`对象。因此，`Unit`对应于Java中的`void`。
- en: 'Let''s test this by printing the result of invoking a composable function:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过打印调用一个可组合函数的结果来测试这一点：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you run the app, the following line will be printed:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行应用程序，以下行将被打印：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'While this may not look too exciting, its implications are profound. Think
    of it: although the `ColoredTextDemo()` composable function returns nothing interesting,
    some text is shown on the screen. This happens because it invokes another composable,
    called `Text()`. So, whatever may be needed to show text must happen inside `Text()`,
    and it cannot have anything to do with the return value of a composable.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这看起来可能并不太令人兴奋，但其影响是深远的。想想看：尽管`ColoredTextDemo()`可组合函数返回了没有太多意义的内容，但屏幕上显示了某些文本。这是因为它调用了另一个可组合函数，称为`Text()`。所以，无论需要显示文本的什么内容，都必须在`Text()`内部发生，并且它与可组合函数的返回值无关。
- en: In the previous chapter, I said that composable functions *emit* UI elements.
    I will explain what this means in the next section.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我说过可组合函数会**发出**UI元素。我将在下一节解释这意味着什么。
- en: Emitting UI elements
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发出UI元素
- en: A Compose UI is created by nesting calls to composable functions, which can
    be provided by the Jetpack Compose libraries, code of other developers, or your
    app.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通过嵌套对可组合函数的调用创建Compose UI，这些函数可以由Jetpack Compose库、其他开发者的代码或您的应用程序提供。
- en: Let's find out what happens once `ColoredTextDemo()` has called `androidx.compose.material.Text()`.
    To see the source code of (among others) composable functions in Android Studio,
    you can click on their names while holding down the *Ctrl* key (on a Mac, it's
    the *cmd* key).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找出一旦`ColoredTextDemo()`调用了`androidx.compose.material.Text()`会发生什么。要在Android
    Studio中查看（包括其他）可组合函数的源代码，您可以在按住*Ctrl*键（在Mac上为*cmd*键）的同时单击它们的名称。
- en: Please Note
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意
- en: I will only show you the important steps because otherwise, I would need to
    copy too much code. To get the best learning experience, please follow the call
    chain directly in your IDE.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我只会展示重要的步骤，因为否则我需要复制太多的代码。为了获得最佳的学习体验，请直接在您的IDE中跟随调用链。
- en: '`Text()` defines two variables, `textColor` and `mergedStyle`, and passes them
    to `androidx.compose.foundation.text.BasicText()`. Although you can use `BasicText()`
    in your code, you should choose `androidx.compose.material.Text()` if possible,
    because it consumes style information from a theme. Please refer to [*Chapter
    6*](B17505_06_ePub.xhtml#_idTextAnchor105), *Putting Pieces Together*, for more
    information about themes.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`Text()`定义了两个变量，`textColor`和`mergedStyle`，并将它们传递给`androidx.compose.foundation.text.BasicText()`。尽管您可以在代码中使用`BasicText()`，但如果可能的话，您应该选择`androidx.compose.material.Text()`，因为它会从主题中消耗样式信息。请参阅[*第6章*](B17505_06_ePub.xhtml#_idTextAnchor105)，*将部件组合在一起*，了解更多关于主题的信息。'
- en: '`BasicText()` immediately delegates to `CoreText()`, which belongs to the `androidx.compose.foundation.text`
    package too. It is an internal composable function, meaning you can''t use it
    in your apps.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`BasicText()` 立即委托给 `CoreText()`，它也属于 `androidx.compose.foundation.text` 包。它是一个内部可组合函数，这意味着你无法在应用程序中使用它。'
- en: '`CoreText()` initializes and remembers quite a few variables. There is no need
    to explain them all here, but the most important piece is the invocation of another
    composable function: `Layout()`.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`CoreText()` 初始化并记住相当多的变量。这里没有必要解释它们的所有内容，但最重要的是调用另一个可组合函数：`Layout()`。'
- en: '`Layout()` belongs to the `androidx.compose.ui.layout` package. It is the core
    composable function for the layout, with its purpose being to size and position
    children. [*Chapter 4*](B17505_04_ePub.xhtml#_idTextAnchor076), *Laying Out UI
    Elements*, covers this in great detail. Right now, we still need to find out what
    *emitting UI elements* means. So, let''s see what `Layout()` does:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`Layout()` 属于 `androidx.compose.ui.layout` 包。它是布局的核心可组合函数，其目的是对子节点进行尺寸和位置调整。[*第
    4 章*](B17505_04_ePub.xhtml#_idTextAnchor076)，*布局 UI 元素*，对此进行了详细的介绍。现在，我们还需要找出
    *发出 UI 元素* 的含义。所以，让我们看看 `Layout()` 做了什么：'
- en: '![Figure 3.1 – Source code of Layout()'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.1 – Layout() 的源代码'
- en: '](img/B17505_03_1.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17505_03_1.jpg)'
- en: Figure 3.1 – Source code of Layout()
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – Layout() 的源代码
- en: '`Layout()` invokes `ReusableComposeNode()`, which belongs to the `androidx.compose.runtime`
    package. This composable function *emits* a so-called `factory` argument. The
    `update` and `skippableUpdate` parameters receive code that performs updates on
    the node, with the latter one handling modifiers (we will be taking a closer look
    at them at the end of this chapter). Finally, `content` contains composable functions
    that become the children of the node.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`Layout()` 调用 `ReusableComposeNode()`，它属于 `androidx.compose.runtime` 包。这是一个可组合函数，它
    *发出* 一个所谓的 `factory` 参数。`update` 和 `skippableUpdate` 参数接收执行节点更新的代码，后者处理修饰符（我们将在本章末尾对其进行更详细的探讨）。最后，`content`
    包含成为节点子节点的可组合函数。'
- en: Please Note
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意事项
- en: When we speak of composable functions *emitting* UI elements, we mean that **nodes**
    are added to data structures that are internal to Jetpack Compose. This will eventually
    lead to UI elements being visible.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论可组合函数 *发出* UI 元素时，我们的意思是 **节点** 被添加到 Jetpack Compose 内部的数据结构中。这最终会导致 UI
    元素可见。
- en: 'To complete the call chain, let''s briefly look at `ReusableComposeNode()`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '要完成调用链，让我们简要看看 `ReusableComposeNode()`:'
- en: '![Figure 3.2 – Source code of ReusableComposeNode()'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.2 – ReusableComposeNode() 的源代码'
- en: '](img/B17505_03_2.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17505_03_2.jpg)'
- en: Figure 3.2 – Source code of ReusableComposeNode()
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – ReusableComposeNode() 的源代码
- en: '`currentComposer` is a top-level variable inside `androidx.compose.runtime.Composables.kt`.
    Its type is `Composer`, which is an interface. `Composer` is targeted by the Jetpack
    Compose Kotlin compiler plugin and used by code generation helpers; your code
    should not call it directly. `ReusableComposeNode` determines if a new node should
    be created or whether an existing one should be reused. It then performs updates
    and finally emits the content to the node by invoking `content()`.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`currentComposer` 是 `androidx.compose.runtime.Composables.kt` 内的一个顶级变量。它的类型是
    `Composer`，这是一个接口。`Composer` 是由 Jetpack Compose Kotlin 编译器插件针对的，并由代码生成助手使用；你的代码不应直接调用它。`ReusableComposeNode`
    确定是否创建新节点或是否重用现有节点。然后它执行更新，并通过调用 `content()` 最终将内容发出到节点。'
- en: 'Based on what you know by now, let me elaborate a little more on nodes. `Layout()`
    passes `ComposeUiNode.Constructor` to `ReusableComposeNode` as the `factory` argument,
    which is used to create a node (`currentComposer.createNode(factory)`). So, the
    features of a node are defined by the `ComposeUiNode` interface:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你目前所知，让我对节点进行更详细的阐述。`Layout()` 将 `ComposeUiNode.Constructor` 传递给 `ReusableComposeNode`
    作为 `factory` 参数，该参数用于创建一个节点（`currentComposer.createNode(factory)`）。因此，节点的特性由 `ComposeUiNode`
    接口定义：
- en: '![Figure 3.3 – Source code of ComposeUiNode'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.3 – ComposeUiNode 的源代码'
- en: '](img/B17505_03_3.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17505_03_3.jpg)'
- en: Figure 3.3 – Source code of ComposeUiNode
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – ComposeUiNode 的源代码
- en: 'A node has four properties, as defined by the following classes or interfaces:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 节点有四个属性，如以下类或接口定义：
- en: '`MeasurePolicy`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MeasurePolicy`'
- en: '`LayoutDirection`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LayoutDirection`'
- en: '`Density`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Density`'
- en: '`Modifier`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Modifier`'
- en: In essence, a node is an element in a Compose hierarchy. You will not be dealing
    with them in your code because nodes are part of the inner workings of Jetpack
    Compose that are not exposed to apps. However, you will see `MeasurePolicy`, `LayoutDirection`,
    `Density`, and `Modifier` throughout this book. They represent important data
    structures and concepts that are relevant to apps.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，一个节点是Compose层次结构中的一个元素。你不会在代码中处理它们，因为节点是Jetpack Compose内部工作的一部分，这些工作没有暴露给应用程序。然而，你将在本书中看到`MeasurePolicy`、`LayoutDirection`、`Density`和`Modifier`。它们代表与应用程序相关的重要数据结构和概念。
- en: This concludes our investigation of how UI elements are emitted (nodes are added
    to data structures that are internal to Jetpack Compose). In the next section,
    we will look at composable functions that return values.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对UI元素是如何发出的（节点被添加到Jetpack Compose内部的某些数据结构中）的调查。在下一节中，我们将查看返回值的可组合函数。
- en: Returning values
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回值
- en: Most of your composable functions will not need to return something, so they
    will not specify a return type. This is because the main purpose of a composable
    is to compose the UI. As you saw in the previous section, this is done by emitting
    UI elements or element hierarchies. But when do we need to return something different
    than `Unit`?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你的大部分可组合函数不需要返回任何东西，因此它们不会指定返回类型。这是因为可组合函数的主要目的是组合UI。正如你在上一节中看到的，这是通过发出UI元素或元素层次结构来完成的。但何时我们需要返回不同于`Unit`的东西呢？
- en: Some of my examples invoke `remember {}` to retain state for future use and
    `stringResource()` to access strings that are stored in the `strings.xml` file.
    To be able to perform their tasks, both must be composable functions.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一些我的例子使用了`remember {}`来保留状态以供将来使用，以及`stringResource()`来访问存储在`strings.xml`文件中的字符串。为了能够执行它们的任务，这两个都必须是可组合的函数。
- en: 'Let''s look at `stringResource()` to see why. Remember that you can press Ctrl
    + click on a name to see its source code. The function is pretty short; it does
    just two things:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`stringResource()`来了解原因。记住，你可以按Ctrl + 点击一个名称来查看其源代码。这个函数相当短；它只做了两件事：
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`resources()` is a composable too. It returns `LocalContext.current.resources`.
    `LocalContext` is a top-level variable in `AndroidCompositionLocals.android.kt`
    that belongs to the `androidx.compose.ui.platform` package. It returns an instance
    of `StaticProvidableCompositionLocal`, which holds `android.content.Context`.
    This object provides access to resources.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources()`也是一个可组合函数。它返回`LocalContext.current.resources`。`LocalContext`是`AndroidCompositionLocals.android.kt`中的一个顶级变量，属于`androidx.compose.ui.platform`包。它返回一个`StaticProvidableCompositionLocal`的实例，该实例持有`android.content.Context`。此对象提供对资源的访问。'
- en: Even though the returned data has nothing to do with Jetpack Compose, the code
    that obtains it must conform to Jetpack Compose mechanics because, in the end,
    it will be called from a composable function. The important thing to remember
    is that if you need to return something that is part of the composition and recomposition
    mechanic, you must make your function composable by annotating it with `@Composable`.
    Also, such functions do not follow the naming conventions for composable functions
    but follow a *camelCase* style (they begin with a small letter, with the subsequent
    word starting in uppercase) and consist of verb phrases (`rememberScrollState`).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 即使返回的数据与Jetpack Compose无关，获取它的代码也必须遵循Jetpack Compose的机制，因为最终它将从一个可组合函数中被调用。重要的是要记住，如果你需要返回属于组合和重新组合机制的部分，你必须通过使用`@Composable`注解来使你的函数可组合。此外，这样的函数不遵循可组合函数的命名约定，而是遵循*camelCase*风格（它们以小写字母开头，后续单词以大写字母开头）并且由动词短语（如`rememberScrollState`）组成。
- en: In the next section, we will return to composing UIs at the app level. You will
    learn more about the terms **composition** and **recomposition**.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将回到在应用程序级别组合UI。你将了解更多关于**组合**和**重新组合**这两个术语。
- en: Composing and recomposing the UI
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合和重新组合UI
- en: Unlike imperative UI frameworks, Jetpack Compose does not depend on the developer
    proactively modifying a component tree when changes in the app data require changes
    to be made to the UI. Instead, Jetpack Compose detects such changes on its own
    and updates only the affected parts.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 与命令式UI框架不同，Jetpack Compose不需要开发者主动修改组件树，当应用程序数据的变化需要更改UI时。相反，Jetpack Compose会自动检测这些变化，并只更新受影响的部分。
- en: As you know by now, a Compose UI is declared *based on* the current app data.
    In my previous examples, you have seen quite a few conditional expressions (such
    as `if` or `when`) that determine which composable function is called or which
    parameters it receives. So, we are describing the *complete* UI in our code. The
    branch that will be executed depends on the app data (state) during runtime. The
    Web framework that React has a similar concept called Virtual DOM. But doesn't
    this contradict with me saying *Compose detects such changes on its own and updates
    only the affected parts*?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如您现在所知，Compose UI是基于当前应用数据声明的。在我之前的例子中，您已经看到了很多条件表达式（如`if`或`when`），这些表达式决定了哪个可组合函数被调用或它接收哪些参数。因此，我们在代码中描述了*完整*的UI。将要执行的分支取决于运行时的应用数据（状态）。React的Web框架有一个类似的概念，称为Virtual
    DOM。但这不是与我说*Compose会自动检测这些更改并只更新受影响的部分*相矛盾吗？
- en: Conceptually, Jetpack Compose regenerates the entire UI when changes need to
    be applied. This, of course, would waste time, battery, and processing power.
    And it might be noticeable by the user as screen flickering. Therefore, the framework
    puts a lot of effort into making sure only those parts of the UI element tree
    requiring an update are regenerated.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，Jetpack Compose在需要应用更改时重新生成整个UI。这当然会浪费时间、电池和处理能力。而且可能会被用户注意到屏幕闪烁。因此，该框架投入了大量精力确保仅重新生成需要更新的UI元素树的部分。
- en: 'You saw some of these efforts in the previous section, where I briefly mentioned
    `update` and `skippableUpdate`. To ensure fast and reliable `ColorPickerDemo`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，您已经看到了一些这些努力的例子，我简要提到了`update`和`skippableUpdate`。为了确保`ColorPickerDemo`快速且可靠：
- en: '![Figure 3.4 – The ColorPickerDemo app'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.4 – ColorPickerDemo应用'
- en: '](img/B17505_03_4.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17505_03_4.jpg)'
- en: Figure 3.4 – The ColorPickerDemo app
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – ColorPickerDemo应用
- en: The app aims to set a color by specifying its **red, green, and blue** (**RGB**)
    portions. This color is used as the background color of a text (which displays
    the value of the color as a hexadecimal string). The foreground color is complementary
    to the selected one.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用旨在通过指定其**红色、绿色和蓝色**（**RGB**）部分来设置颜色。此颜色用作文本的背景色（显示颜色的十六进制字符串值）。前景色与所选颜色互补。
- en: In the next few sections, we look at its code. You will learn how sliders communicate
    changes in their values.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将查看其代码。您将了解滑块如何在其值发生变化时进行通信。
- en: Sharing state among composable functions
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在可组合函数之间共享状态
- en: 'Sometimes, you may want to use a state in more than one composable function.
    For example, you may wish to use the color portion that''s been set by one slider
    to create the full color, which, in turn, becomes the background color of a text.
    So, how can you share state? Let''s start by looking at `ColorPicker()` – it groups
    three sliders vertically in a `Column()`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，您可能想在多个可组合函数中使用一个状态。例如，您可能希望使用一个滑块设置的颜色部分来创建完整的颜色，而这个颜色反过来又成为文本的背景色。那么，您如何共享状态？让我们先看看`ColorPicker()`
    – 它在`Column()`中垂直排列三个滑块：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The composable receives one parameter: `MutableState<Color>`. The `value` property
    of `color` contains an instance of `androidx.compose.ui.graphics.Color`. Its `red`,
    `green`, and `blue` properties return a `Float` based on the so-called `ColorSpaces.Srgb`.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 可组合函数接收一个参数：`MutableState<Color>`。`color`的`value`属性包含一个`androidx.compose.ui.graphics.Color`实例。它的`red`、`green`和`blue`属性返回一个基于所谓的`ColorSpaces.Srgb`的`Float`。
- en: My code does not set a particular color space, so it defaults to `ColorSpaces.Srgb`.
    This causes the value being returned to be between `0F` and `1F`. The first three
    lines assign the red, green, and blue portions of the color to local variables
    named `red`, `green`, and `blue`. They are used for the `Slider()` functions;
    let's see how.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我的代码没有设置特定的颜色空间，因此它默认为`ColorSpaces.Srgb`。这导致返回的值在`0F`和`1F`之间。前三条线将颜色的红色、绿色和蓝色部分分配给名为`red`、`green`和`blue`的局部变量。它们用于`Slider()`函数；让我们看看它是如何工作的。
- en: 'Each slider in my example receives two parameters: `value` and `onValueChange`.
    The first specifies the value that the slider will display. It must be between
    `0F` and `1F` (which fits nicely with `red`, `green`, and `blue`). If needed,
    you can supply an alternative range through the optional `valueRange` parameter.
    `onValueChange` is invoked when the user drags the slider handle or clicks on
    the thin line underneath. The code of the three lambda expressions is quite similar:
    a new `Color` object is created and assigned to `color.value`. Color portions
    that are being controlled by other sliders are taken from the corresponding local
    variables. They have not been changed. The new color portion of the current slider
    can be obtained from `it` because it is the new slider value, which is passed
    to `onValueChange`.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的例子中，每个滑块接收两个参数：`value`和`onValueChange`。第一个指定滑块将显示的值。它必须在`0F`和`1F`之间（这与`red`、`green`和`blue`相匹配）。如果需要，你可以通过可选的`valueRange`参数提供替代范围。`onValueChange`在用户拖动滑块手柄或点击下方的细线时被调用。三个lambda表达式的代码相当相似：创建一个新的`Color`对象并将其分配给`color.value`。受其他滑块控制的颜色部分来自相应的局部变量。它们没有被更改。当前滑块的新颜色部分可以从`it`中获得，因为它是新的滑块值，它被传递给`onValueChange`。
- en: 'By now, you may be wondering why `ColorPicker()` receives the color wrapped
    inside a `MutableState<Color>`. Wouldn''t it suffice to pass it directly, using
    `color: Color`? As shown in *Figure 3.4*, the app shows the selected color as
    a text with complementary background and foreground colors. But `ColorPicker()`
    does not emit text. This happens somewhere else (as you will see shortly, inside
    a `Column()`). To show the correct color, the text must receive it too. As the
    color change takes place inside `ColorPicker()`, we must inform the caller about
    it. An ordinary `Color` instance being passed as a parameter can''t do that because
    Kotlin function parameters are immutable.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '到目前为止，你可能想知道为什么`ColorPicker()`接收被包裹在`MutableState<Color>`中的颜色。直接使用`color: Color`传递它不是足够吗？如*图3.4*所示，应用程序以互补的背景和前景颜色显示所选颜色作为文本。但`ColorPicker()`不会发出文本。这发生在其他地方（如你将很快看到的，在`Column()`内部）。为了显示正确的颜色，文本也必须接收它。由于颜色更改发生在`ColorPicker()`内部，我们必须通知调用者。作为参数传递的普通`Color`实例无法做到这一点，因为Kotlin函数参数是不可变的。'
- en: We can achieve changeability using global properties. But this is not recommended
    for Jetpack Compose. Composables should not use global variables at all. It is
    a best practice to pass all the data that influences the look or behavior of a
    composable function as parameters. If that data is modified inside the composable,
    you should use `MutableState`. Moving state to a composable's caller by receiving
    a state is called `MutableState` and applying changes inside a composable is to
    pass the change logic as a lambda expression. In my example, `onValueChange` would
    just provide the new slider value to the lambda expression.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用全局属性来实现可变性。但这对Jetpack Compose来说并不推荐。可组合组件不应使用任何全局变量。将影响可组合函数外观或行为的所有数据作为参数传递是一种最佳实践。如果这些数据在可组合组件内部被修改，你应该使用`MutableState`。通过接收状态将状态移动到可组合组件的调用者称为`MutableState`，在可组合组件内部应用更改是将更改逻辑作为lambda表达式传递。在我的例子中，`onValueChange`只会将新的滑块值提供给lambda表达式。
- en: Important
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 重要
- en: Try to make your composables side effect-free. Having no side effects means
    calling a function repeatedly with the same set of arguments that will always
    produce the same result. Besides getting all the relevant data from the caller,
    being free of side effects also requires not relying on global properties or calling
    functions that return unpredictable values. There are a few scenarios where you
    want side effects. I will cover these in [*Chapter 7*](B17505_07_ePub.xhtml#_idTextAnchor119),
    *Tips, Tricks, and Best Practices*.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量使你的可组合组件无副作用。无副作用意味着使用相同的参数集重复调用函数，将始终产生相同的结果。除了从调用者获取所有相关数据外，无副作用还要求不依赖全局属性或调用返回不可预测值的函数。有一些场景下你希望有副作用。我将在[*第7章*](B17505_07_ePub.xhtml#_idTextAnchor119)“技巧、窍门和最佳实践”中介绍这些内容。
- en: 'Now, let''s learn how the color is passed to the text:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习颜色是如何传递给文本的：
- en: '[PRE6]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`ColorPicker()` and `Text()` are laid out vertically (being centered horizontally)
    inside a `Column()`. The width of the column is either `400` density-independent
    pixels or `maxWidth`, depending on which value is smaller. `maxWidth` is defined
    by the predefined `BoxWithConstraints()` composable (you will learn more about
    it in the *Controlling size* section). The color for both `ColorPicker()` and
    `Text()` is defined like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`ColorPicker()`和`Text()`在`Column()`内部垂直排列（水平居中）。列的宽度是`400`密度无关像素或`maxWidth`，取决于哪个值更小。`maxWidth`由预定义的`BoxWithConstraints()`组合函数定义（你将在*控制大小*部分了解更多关于它的内容）。`ColorPicker()`和`Text()`的颜色定义如下：'
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When `Column()` is composed for the first time, `mutableStateOf(Color.Magenta)`
    is executed. This creates `color`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Column()`首次组合时，会执行`mutableStateOf(Color.Magenta)`。这创建了`color`。
- en: But what does `remember` mean? Any subsequent composition, which is called `color`
    receiving the value created by `mutableStateOf` – that is, a reference to a `MutableState<Color>`
    (state hoisting). The lambda expression that's passed to `remember` is called
    a **calculation**. It will only be evaluated once. Recompositions always return
    the same value.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 但`remember`是什么意思？任何后续的组合，称为`color`接收由`mutableStateOf`创建的值——即`MutableState<Color>`（状态提升）。传递给`remember`的lambda表达式被称为**计算**。它只会被评估一次。重组总是返回相同的值。
- en: If the reference remains the same, how can the color be changed? The actual
    color is accessed through the `value` property. You saw this in the code of `ColorPicker()`.
    `Text()` does not modify the color – it only works with it. Therefore, we pass
    `color.value` (which is the color), not the mutable state (`color`), to some of
    its parameters, such as `background`. Note that this is a modifier. You will learn
    more about them in the *Modifying behavior* section. It sets the background color
    of a UI element that's emitted by a composable function.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果引用保持不变，如何改变颜色？实际颜色是通过`value`属性访问的。你在`ColorPicker()`的代码中看到了这一点。`Text()`不会修改颜色——它只是与之一起工作。因此，我们将`color.value`（即颜色）而不是可变状态（`color`）传递给其一些参数，例如`background`。请注意，这是一个修饰符。你将在*修改行为*部分了解更多关于它们的内容。它设置由组合函数发出的UI元素的背景颜色。
- en: 'Also, have you noticed the call of `complementary()` inside `TextStyle()`?
    Here''s what it does:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你注意到`TextStyle()`内部的`complementary()`调用吗？这是它的作用：
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`complementary()` is an extension function of `Color`. It computes the complementary
    color to the one it receives. This is done to make the text (the hexadecimal RGB
    value of the color that was selected using the three sliders) readable, regardless
    of the currently selected color (which is used as the background of the text).'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`complementary()`是`Color`的扩展函数。它计算接收到的颜色的互补色。这样做是为了使文本（使用三个滑块选择的颜色的十六进制RGB值）可读，无论当前选中的颜色（用作文本的背景）如何。'
- en: 'In this section, I talked about some very important Jetpack Compose concepts.
    Let''s recap what we''ve learned so far:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我谈到了一些非常重要的Jetpack Compose概念。让我们回顾一下我们到目前为止学到了什么：
- en: A compose UI is defined by nesting calls to composable functions
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合UI是通过嵌套调用组合函数来定义的
- en: Composable functions emit UI elements or UI element hierarchies
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合函数会发出UI元素或UI元素层次结构
- en: Building the UI for the first time is called **composition**
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首次构建UI的过程被称为**组合**
- en: Rebuilding the UI upon changes being made to app data is called **recomposition**
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在对应用数据进行更改后重建UI的过程被称为**重组**
- en: Recomposition happens automatically
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重组是自动发生的
- en: Important
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要
- en: There is no way for your app to predict when or how often recomposition will
    take place. If animations are involved, this may happen each frame. Therefore,
    it is of utmost importance to make your composables as fast as possible. You may
    never do time-consuming calculations, load or save data, or access the network.
    Any such code must be executed outside of composable functions. They only receive
    ready data. Also, please note that the order of recomposition is unspecified.
    This means that the first child of, say, a `Column()`, might be recomposed later
    than a sibling that appears after it in the source code. Recomposition can occur
    in parallel and it may be skipped. Therefore, never rely on a particular order
    of recomposition, and never compute something in a composable that is needed somewhere
    else.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你的应用无法预测重组何时以及多久发生一次。如果涉及动画，这可能会在每一帧发生。因此，使你的组合函数尽可能快是非常重要的。你永远不应该进行耗时的计算、加载数据或保存数据，或访问网络。任何这样的代码都必须在组合函数之外执行。它们只接收准备好的数据。此外，请注意，重组的顺序是不确定的。这意味着
    `Column()` 的第一个子元素可能在源代码中出现在其后的兄弟元素之后才被重组。重组可以并行发生，也可能被跳过。因此，永远不要依赖于特定的重组顺序，也永远不要在组合函数中计算在其他地方需要的东西。
- en: In the next section, we will finish our walkthrough of the `ColorPickerDemo`
    app. I will show you how to specify and limit the dimensions of composable functions.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将完成对 `ColorPickerDemo` 应用的浏览。我会向你展示如何指定和限制组合函数的尺寸。
- en: Controlling size
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制尺寸
- en: Most of my examples contain code such as `fillMaxSize()` or `fillMaxWidth()`.
    Both modifiers control the size of a composable. `fillMaxSize()` uses all the
    available horizontal and vertical space, while `fillMaxWidth()` maximizes only
    the horizontal expansion.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我的大部分示例都包含 `fillMaxSize()` 或 `fillMaxWidth()` 这样的代码。这两个修饰符都控制组合函数的大小。`fillMaxSize()`
    使用所有可用的水平和垂直空间，而 `fillMaxWidth()` 只最大化水平扩展。
- en: 'However, `fillMaxWidth()` may not be the right choice for sliders. In my opinion,
    large sliders are awkward to use due to the distance you would need to drag their
    handles to reach the minimum or maximum value. So, the question is, how can we
    limit its width? The most straightforward solution is to use the `width()` modifier.
    It sets the preferred width of a composable to a particular size. I want sliders
    to be 400 density-independent pixels wide at most. If the screen is smaller, its
    width should be used instead. Here''s how you achieve this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`fillMaxWidth()` 可能不是滑块的合适选择。在我看来，由于需要拖动滑块的手柄到达最小或最大值，大滑块使用起来会感到笨拙。所以，问题是如何限制其宽度？最直接的方法是使用
    `width()` 修饰符。它将组合函数的首选宽度设置为特定的大小。我希望滑块的最大宽度为 400 密度无关像素。如果屏幕更小，则使用其宽度。以下是实现方法：
- en: '[PRE9]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The modifier belongs to the `Column()` property that contains both `ColorPicker()`
    and `Text()`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 修饰符属于包含 `ColorPicker()` 和 `Text()` 的 `Column()` 属性。
- en: '`maxWidth` is provided by the `BoxWithConstraints()` composable:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`maxWidth` 由 `BoxWithConstraints()` 组合函数提供：'
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Its content receives an instance of a `BoxWithConstraintsScope` scope, which
    provides access to `constraints`, `minWidth`, `minHeight`, `maxWidth`, and `maxHeight`.
    `BoxWithConstraints()` defines its content according to the available space, based
    on incoming constraints. You will learn more about this in [*Chapter 4*](B17505_04_ePub.xhtml#_idTextAnchor076),
    *Laying Out UI Elements*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 其内容接收一个 `BoxWithConstraintsScope` 范围的实例，该范围提供了对 `constraints`、`minWidth`、`minHeight`、`maxWidth`
    和 `maxHeight` 的访问。`BoxWithConstraints()` 根据传入的约束定义其内容，基于可用空间。你将在 [*第 4 章*](B17505_04_ePub.xhtml#_idTextAnchor076)
    中了解更多，*布局 UI 元素*。
- en: This concludes our walkthrough of the `ColorPickerDemo` app. In the next section,
    we take a closer look at how a composable hierarchy is displayed in an `Activity`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了对 `ColorPickerDemo` 应用的浏览。在下一节中，我们将更详细地了解组合函数层次结构如何在 `Activity` 中显示。
- en: Displaying a composable hierarchy inside an Activity
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Activity 中显示组合函数层次结构
- en: In the previous section, we built a UI element hierarchy consisting of three
    sliders and some text. We embedded it in an `Activity` using `setContent`, an
    extension function of `androidx.activity.ComponentActivity`. This implies that
    you cannot invoke `setContent` on *any* activity, but only ones that extend `ComponentActivty`.
    This is the case for `androidx.appcompat.app.AppCompatActivity`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们构建了一个由三个滑块和一些文本组成的 UI 元素层次结构。我们使用 `setContent`（`androidx.activity.ComponentActivity`
    的扩展函数）将其嵌入到一个 `Activity` 中。这意味着你不能在 *任何* 活动上调用 `setContent`，而只能是在扩展 `ComponentActivty`
    的活动上。`androidx.appcompat.app.AppCompatActivity` 就是这种情况。
- en: However, this class inherits quite a lot of functionality that is relevant for
    the old View-based world, such as support for toolbars and the options menu. Jetpack
    Compose handles these differently. You will learn more about this in [*Chapter
    6*](B17505_06_ePub.xhtml#_idTextAnchor105), *Putting Pieces Together*. Therefore,
    you should avoid using `AppCompatActivity`, and instead extend `ComponentActivity`
    if possible. For combining View-based and Compose UIs, please refer to [*Chapter
    9*](B17505_09_ePub.xhtml#_idTextAnchor148), *Exploring Interoperability APIs*.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个类继承了很多与旧 View 基础世界相关的功能，例如对工具栏和选项菜单的支持。Jetpack Compose 处理这些方式不同。你将在 [*第
    6 章*](B17505_06_ePub.xhtml#_idTextAnchor105)，*整合组件* 中了解更多。因此，你应该避免使用 `AppCompatActivity`，如果可能的话，应该扩展
    `ComponentActivity`。有关结合基于 View 和 Compose UI 的信息，请参阅 [*第 9 章*](B17505_09_ePub.xhtml#_idTextAnchor148)，*探索互操作性
    API*。
- en: 'Let''s return to `setContent`. It expects two parameters:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到 `setContent`。它期望两个参数：
- en: '`parent`, an optional `CompositionContext`'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parent`，一个可选的 `CompositionContext`'
- en: '`content`, a composable function for declaring the UI'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`content`，一个用于声明 UI 的可组合函数'
- en: 'You will likely omit `parent` most of the time. `CompositionContext` is an
    abstract class that belongs to the `androidx.compose.runtime` package. It is used
    to logically connect two compositions. This refers to the inner workings of Jetpack
    Compose that you do not need to worry about in your app code. Yet, to get an idea
    of what this means, let''s look at the source code of `setContent`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你很可能会在大多数情况下省略 `parent`。`CompositionContext` 是一个属于 `androidx.compose.runtime`
    包的抽象类。它用于在逻辑上连接两个组合。这指的是 Jetpack Compose 的内部工作原理，你不需要在你的应用代码中担心这些。然而，为了了解这意味着什么，让我们看看
    `setContent` 的源代码：
- en: '![Figure 3.5 – The source code of setContent'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.5 – `setContent` 的源代码'
- en: '](img/B17505_03_5.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17505_03_5.jpg)'
- en: Figure 3.5 – The source code of setContent
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – `setContent` 的源代码
- en: First, `findViewById()` is used to find out if the activity already contains
    content that is an instance of `androidx.compose.ui.platform.ComposeView`. If
    so, the `setParentCompositionContext()` and `setContent()` methods of this view
    will be invoked.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用 `findViewById()` 来确定活动是否已经包含一个 `androidx.compose.ui.platform.ComposeView`
    的实例。如果是这样，这个视图的 `setParentCompositionContext()` 和 `setContent()` 方法将被调用。
- en: 'Let''s look at `setParentCompositionContext()` first. It belongs to `AbstractComposeView`,
    the immediate parent of `ComposeView`. It sets a `CompositionContext` that should
    be the parent of the view''s composition. If that context is `null`, it will be
    determined automatically: `AbstractComposeView` contains a private function called
    `ensureCompositionCreated()`. It invokes another implementation of `setContent`
    (an internal extension function of `ViewGroup` that''s defined in `Wrapper.android.kt`)
    and passes the result of a call to `resolveParentCompositionContext()` as a `parent`.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们看看 `setParentCompositionContext()` 方法。它属于 `AbstractComposeView`，这是 `ComposeView`
    的直接父类。它设置一个 `CompositionContext`，这个上下文应该是视图组合的父级。如果这个上下文是 `null`，它将自动确定：`AbstractComposeView`
    包含一个名为 `ensureCompositionCreated()` 的私有函数。它调用另一个 `setContent` 的实现（这是定义在 `Wrapper.android.kt`
    中的 `ViewGroup` 的内部扩展函数）并将 `resolveParentCompositionContext()` 调用的结果作为 `parent`
    传递。
- en: Now, let's return to the version of `setContent()` that's shown in the preceding
    screenshot. Once `setParentCompositionContext()` has been called, it invokes yet
    another version of `setContent()`. This implementation belongs to `ComposeView`.
    It sets the content of the view.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到前面截图所示的 `setContent()` 版本。一旦调用 `setParentCompositionContext()`，它将调用另一个版本的
    `setContent()`。这个实现属于 `ComposeView`。它设置视图的内容。
- en: If `findViewById()` does not return a `ComposeView`, a new instance is created
    and passed to `setContentView`, after `setParentCompositionContext()` and `setContent()`
    have been invoked.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `findViewById()` 返回的不是 `ComposeView`，则创建一个新的实例，并在调用 `setParentCompositionContext()`
    和 `setContent()` 之后将其传递给 `setContentView`。
- en: In this section, we continued looking at some of the inner workings of Jetpack
    Compose. You now know that `ComposeView` is the missing link to the old-fashioned
    View-based world. We will revisit this class in [*Chapter 9*](B17505_09_ePub.xhtml#_idTextAnchor148),
    *Exploring Interoperability APIs*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们继续探讨了 Jetpack Compose 的一些内部工作原理。你现在知道 `ComposeView` 是连接旧式 View 基础世界的缺失环节。我们将在
    [*第 9 章*](B17505_09_ePub.xhtml#_idTextAnchor148)，*探索互操作性 API* 中重新访问这个类。
- en: In the next section, we will return modifiers; you will learn how they work
    under the hood and how you can write your own.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将返回修饰符；你将学习它们在底层是如何工作的，以及你如何编写自己的修饰符。
- en: Modifying the behavior of composable functions
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改可组合函数的行为
- en: Unlike components in traditional imperative UI frameworks, composable functions
    do not share a basic set of properties. They also do not automatically (in the
    sense of inheriting) reuse functionality. This must be done explicitly by calling
    other composables. Their visual appearance and behavior can be controlled through
    parameters, modifiers, or both. In a way, modifiers pick up the idea of properties
    in a component but enhance it – unlike properties of components, modifiers can
    be used completely at the discretion of the developer.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统命令式 UI 框架中的组件不同，可组合函数不共享一组基本属性。它们也不自动（在继承意义上）重用功能。这必须通过调用其他可组合函数来显式完成。它们的视觉外观和行为可以通过参数、修饰符或两者共同控制。从某种意义上说，修饰符拾取了组件属性的概念，但对其进行了增强
    – 与组件属性不同，修饰符可以完全由开发者自行决定使用。
- en: 'You have already seen quite a few modifiers in my examples, such as the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在我的例子中看到了很多修饰符，例如以下这些：
- en: '`width()`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`width()`'
- en: '`fillMaxWidth()`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fillMaxWidth()`'
- en: '`fillMaxSize()`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fillMaxSize()`'
- en: These control the width and size of the corresponding UI element; `background()`
    can set a background color and shape, while `clickable {}` allows the user to
    interact with the composable function by clicking on the UI element. Jetpack Compose
    provides an extensive list of modifiers, so it may take some time to make yourself
    familiar with most of them. Conceptually, these modifiers can be assigned to one
    of several categories, such as *Actions* (`draggable()`), *Alignment* (`alignByBaseline()`),
    or *Drawing* (`paint()`). You can find a list of modifiers grouped by category
    at [https://developer.android.com/jetpack/compose/modifiers-list](https://developer.android.com/jetpack/compose/modifiers-list).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这些控制相应 UI 元素的宽度和大小；`background()` 可以设置背景颜色和形状，而 `clickable {}` 允许用户通过点击 UI 元素与可组合函数进行交互。Jetpack
    Compose 提供了大量的修饰符，因此熟悉其中大部分可能需要一些时间。从概念上讲，这些修饰符可以分配到几个类别之一，如 *动作* (`draggable()`),
    *对齐* (`alignByBaseline()`) 或 *绘图* (`paint()`)。你可以在 [https://developer.android.com/jetpack/compose/modifiers-list](https://developer.android.com/jetpack/compose/modifiers-list)
    找到按类别分组的修饰符列表。
- en: 'To further familiarize yourself with modifiers, let''s look at the `ModifierDemo`
    example. It contains several composable functions. The following screenshot shows
    the app running `OrderDemo()`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步熟悉修饰符，让我们看看 `ModifierDemo` 示例。它包含几个可组合函数。以下截图显示了正在运行 `OrderDemo()` 的应用程序：
- en: '![Figure 3.6 – The ModifierDemo app'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.6 – ModifierDemo 应用程序'
- en: '](img/B17505_03_6.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17505_03_6.jpg](img/B17505_03_6.jpg)'
- en: Figure 3.6 – The ModifierDemo app
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – ModifierDemo 应用程序
- en: The composable produces a gap of 32 density-independent pixels on all its sides,
    followed by a 2 density-independent pixels wide blue border. The inner rectangle
    is painted in light gray.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 可组合函数在其所有边上产生一个 32 密度无关像素的间隙，然后是一个 2 密度无关像素宽的蓝色边框。内部矩形被涂成浅灰色。
- en: 'Here''s what the code looks like:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是代码的样子：
- en: '[PRE11]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`Box()` is clickable – doing so changes the border color from blue to red and
    back. If you click inside the gaps, nothing will happen. If, however, you move`.clickable
    { }` before `.padding(32.dp)`, clicks work inside the gaps too. This is intentional.
    Here''s what happens: you define a modifier chain by combining several modifiers
    with `.`. In doing so, you specify the order in which the modifiers are used.
    The location of a modifier in the chain determines when it is executed. As `clickable
    {}` only reacts to clicks inside the bounds of a composable, the padding is not
    considered for clicks when it occurs before `clickable {}`.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`Box()` 是可点击的 – 点击它将边框颜色从蓝色变为红色，然后再变回。如果你在间隙内点击，则不会发生任何事。然而，如果你在 `.padding(32.dp)`
    之前移动 `.clickable { }`，点击也会在间隙内工作。这是故意的。下面是发生的事情：你通过结合几个修饰符并使用 `.` 来定义一个修饰符链。这样做时，你指定了修饰符的使用顺序。修饰符在链中的位置决定了它的执行时机。由于
    `clickable {}` 只对可组合组件边界内的点击做出反应，因此当它出现在 `clickable {}` 之前时，填充不会考虑点击。'
- en: In the next section, I will show you how Jetpack Compose handles modifiers and
    modifier chains internally.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我将向你展示 Jetpack Compose 如何在内部处理修饰符和修饰符链。
- en: Understanding how modifiers work
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解修饰符如何工作
- en: Composable functions that accept modifiers should receive them via the `modifier`
    parameter and assign it a default value of `Modifier`. `modifier` should be the
    first optional parameter and thus appear after all the required ones, except for
    trailing lambda parameters.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接受修饰符的可组合函数应通过 `modifier` 参数接收它们，并将其分配一个默认值 `Modifier`。`modifier` 应该是第一个可选参数，因此它出现在所有必需参数之后，除了尾随
    lambda 参数。
- en: 'Let''s see how a composable can receive a `modifier` parameter:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个可组合函数如何接收 `modifier` 参数：
- en: '[PRE12]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This way, the composable can receive a modifier chain from the caller. If none
    are provided, `Modifier` acts as a new, empty chain. In both cases, the composable
    can add additional modifiers, such as `background()` in the previous code snippet.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，可组合的元素可以从调用者那里接收一个修饰符链。如果没有提供，`Modifier` 就会作为一个新的空链。在两种情况下，可组合的元素都可以添加额外的修饰符，例如在之前的代码片段中使用的
    `background()`。
- en: If a composable function accepts a modifier that will be applied to a specific
    part or child of its corresponding UI element, the name of this part or child
    should be used as a prefix, such as `titleModifier`. Such modifiers follow the
    rules I mentioned previously. They should be grouped and appear after the parent's
    modifier. Please refer to [https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier](https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier)
    for additional information regarding the definition of modifier parameters.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个组合函数接受一个将应用于其对应 UI 元素特定部分或子元素的修饰符，那么这个部分或子元素的名称应该用作前缀，例如 `titleModifier`。这样的修饰符遵循我之前提到的规则。它们应该分组并出现在父修饰符之后。请参阅
    [https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier](https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier)
    以获取有关修饰符参数定义的更多信息。
- en: Now that you know how to define a `modifier` parameter in a composable function,
    let's focus a little more on the idea of chaining. `Modifier` is both an interface
    and a companion object. The interface belongs to the `androidx.compose.ui` package.
    It defines several functions, such as `foldIn()` and `foldOut()`. You won't need
    them, though. The important one is `then()`. It concatenates two modifiers. As
    you will see shortly, you need to invoke it in your modifiers. The `Element` interface
    extends `Modifier`. It defines a single element contained within a `Modifier`
    chain. Finally, the `Modifier` companion object is the empty, default modifier,
    which contains no elements.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何在组合函数中定义 `modifier` 参数，让我们更深入地关注一下链式调用的概念。`Modifier` 既是接口也是伴随对象。接口属于
    `androidx.compose.ui` 包。它定义了几个函数，例如 `foldIn()` 和 `foldOut()`。尽管如此，你不需要它们。重要的是
    `then()`。它连接两个修饰符。正如你很快就会看到的，你需要在你的修饰符中调用它。`Element` 接口扩展了 `Modifier`。它定义了 `Modifier`
    链中包含的单个元素。最后，`Modifier` 伴随对象是空的、默认的修饰符，它不包含任何元素。
- en: To Summarize
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 总结
- en: A modifier is an ordered, immutable collection of modifier elements.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 修饰符是一个有序的、不可变的修饰符元素集合。
- en: 'Next, let''s see how the `background()` modifier is implemented:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 `background()` 修饰符是如何实现的：
- en: '![Figure 3.7 – Source code of the background() modifier'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.7 – background() 修饰符的源代码'
- en: '](img/B17505_03_7.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17505_03_7.jpg)'
- en: Figure 3.7 – Source code of the background() modifier
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – background() 修饰符的源代码
- en: '`background()` is an extension function of `Modifier`. It receives a `Modifier`
    instance. It invokes `then()` and returns the result (a concatenated modifier).
    `then()` expects just one parameter: the *other* modifier that should be concatenated
    with the current one. In the case of `background()`, *other* is an instance of
    `Background`. This class extends `InspectorValueInfo` and implements the `DrawModifier`
    interface, which, in turn, extends `Modifier.Element`. As `InspectorValueInfo`
    is primarily used for debugging purposes, I will not elaborate on it any further.
    `DrawModifier`, on the other hand, is very interesting. Implementations can draw
    into the space of a UI element. We will make use of this in the final section.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`background()` 是 `Modifier` 的一个扩展函数。它接收一个 `Modifier` 实例。它调用 `then()` 并返回结果（一个连接的修饰符）。`then()`
    需要一个参数：应该与当前修饰符连接的 *其他* 修饰符。在 `background()` 的情况下，*其他* 是 `Background` 的一个实例。这个类扩展了
    `InspectorValueInfo` 并实现了 `DrawModifier` 接口，而 `DrawModifier` 接口反过来又扩展了 `Modifier.Element`。由于
    `InspectorValueInfo` 主要用于调试目的，我将不再进一步阐述。另一方面，`DrawModifier` 非常有趣。实现可以绘制到 UI 元素的空间中。我们将在最后一节中使用这一点。'
- en: Implementing custom modifiers
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现自定义修饰符
- en: 'Although Jetpack Compose contains an extensive list of modifiers, you may want
    to implement your own. Let me show you how to do this. My example, `drawYellowCross()`,
    draws two thick yellow lines behind the content, which is some `Text()` here:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Jetpack Compose包含了一个广泛的修饰符列表，但你可能想实现自己的。让我给你展示如何做到这一点。我的例子 `drawYellowCross()`
    在内容后面绘制了两条粗黄色的线条，这里的 `Text()` 是一些文本：
- en: '![Figure 3.8 – A custom modifier'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.8 – 自定义修饰符'
- en: '](img/B17505_03_8.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17505_03_8.jpg)'
- en: Figure 3.8 – A custom modifier
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – 自定义修饰符
- en: 'The modifier is invoked like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 修饰符的调用方式如下：
- en: '[PRE13]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As you can see, the modifier integrates nicely into an existing modifier chain.
    Now, let''s look at the source code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，修饰符很好地整合到了现有的修饰符链中。现在，让我们看看源代码：
- en: '[PRE14]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`drawYellowCross()` is an extension function of `Modifier`. This means we can
    invoke `then()` and simply return the result. `then()` receives an instance of
    `DrawModifier`. After that, we need to implement only one function, called `draw()`,
    which is an extension function of `ContentDrawScope`. This interface defines one
    function (`drawContent()`) and extends `DrawScope`; this way, we gain access to
    quite a few drawing primitives, such as `drawLine()`, `drawRect()`, and `drawImage()`.
    `drawContent()` draws the UI element, so depending on when it is invoked, the
    element appears in front of, or behind, the other drawing primitives. In my example,
    it is the last instruction, so the UI element (for example, `Text()`) is the topmost
    one.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawYellowCross()` 是 `Modifier` 的一个扩展函数。这意味着我们可以调用 `then()` 并简单地返回结果。`then()`
    接收一个 `DrawModifier` 的实例。之后，我们只需要实现一个函数，称为 `draw()`，它是 `ContentDrawScope` 的扩展函数。这个接口定义了一个函数（`drawContent()`）并扩展了
    `DrawScope`；这样，我们就能够访问到相当多的绘图原语，例如 `drawLine()`、`drawRect()` 和 `drawImage()`。`drawContent()`
    绘制 UI 元素，因此根据它的调用时间，元素会出现在其他绘图原语之前或之后。在我的例子中，它是最后的指令，所以 UI 元素（例如，`Text()`）是最顶层的一个。'
- en: Jetpack Compose also includes a modifier called `drawBehind {}`. It receives
    a lambda expression that can contain drawing primitives, just like in my example.
    To learn even more about the internals of Jetpack Compose, you may want to take
    a look at its source code. To see it, just click on `drawBehind()` in your code
    while pressing the *Ctrl* key.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Jetpack Compose 还包括一个名为 `drawBehind {}` 的修饰符。它接收一个包含绘图原语的表达式 lambda，就像我的例子一样。为了更深入地了解
    Jetpack Compose 的内部机制，你可能想看看它的源代码。要查看它，只需在按住 *Ctrl* 键的同时点击代码中的 `drawBehind()`
    即可。
- en: This concludes my explanations of modifiers. As you have seen, they are a very
    elegant way to control both the visual appearance and behavior of composable functions.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我对修饰符的解释。正如你所见，它们是一种非常优雅的方式来控制可组合函数的视觉外观和行为。
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced you to the key principles of Jetpack Compose. We closely
    looked at the underlying ideas and concepts of composable functions, and you now
    know how they are written and used. We also focused on how to create and update
    the UI, as well as how Jetpack Compose achieves what other frameworks call repainting
    or updating the screen. When relevant app data changes, the UI changes, or so-called
    recomposition takes place automatically, this is one of the advantages over the
    traditional View-based approach, where the developer must imperatively change
    the component tree.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向你介绍了 Jetpack Compose 的关键原则。我们仔细研究了可组合函数的底层思想和概念，你现在知道了它们是如何编写和使用的。我们还关注了如何创建和更新
    UI，以及 Jetpack Compose 如何实现其他框架所说的重绘或更新屏幕。当相关应用数据发生变化时，UI 会发生变化，或者所谓的重新组合会自动发生，这是与传统基于
    View 的方法相比的一个优势，在传统方法中，开发者必须强制性地更改组件树。
- en: We then expanded our knowledge of the concept of modifiers. We looked at how
    modifier chains work and what you need to keep in mind to always get the intended
    results. For example, to receive clicks inside padding, `padding {}` must occur
    after `clickable {}` in the `modifier` chain. Finally, you learned how to implement
    custom modifiers.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们扩展了对修饰符概念的理解。我们研究了修饰符链的工作方式以及你需要注意什么，以确保始终得到预期的结果。例如，为了在填充内接收点击，`padding
    {}` 必须在 `modifier` 链中的 `clickable {}` 之后出现。最后，你学习了如何实现自定义修饰符。
- en: In [*Chapter 4*](B17505_04_ePub.xhtml#_idTextAnchor076), *Laying Out UI Elements*,
    we will examine how to lay out UI elements and introduce you to the **single measure
    pass**. We will explore built-in layouts, but also write a custom Compose layout.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 4 章*](B17505_04_ePub.xhtml#_idTextAnchor076)“布局 UI 元素”中，我们将探讨如何布局 UI 元素，并介绍**单测量遍历**。我们将探索内置布局，同时也会编写一个自定义的
    Compose 布局。
