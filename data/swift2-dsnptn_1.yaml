- en: Chapter 1. Creational Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章 创建型模式
- en: The creational patterns are designed to deal with the object creation mechanism
    in software designing. A system using these patterns becomes independent of how
    objects are created, which means it is independent of how concrete classes are
    instantiated.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 创建型模式旨在处理软件设计中的对象创建机制。使用这些模式后，系统变得独立于对象的创建方式，这意味着它独立于具体类的实例化方式。
- en: These patterns encapsulate the use of concrete classes and favor the use of
    interfaces in the relationship between objects, allowing to have better abstraction
    of the global system conception.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式封装了具体类的使用，并倾向于在对象之间的关系中使用接口，从而允许更好地抽象全局系统概念。
- en: Thus, if we analyze the **singleton** pattern, a pattern designed to instantiate
    only one instance of a class, we find that the mechanism that controls the unique
    access to this instance is fully encapsulated in the class, which means that this
    is completely transparent to the client consuming the instance of the class.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们分析**单例**模式，这是一个旨在仅实例化类的一个实例的模式，我们发现控制对这一实例唯一访问的机制完全封装在类中，这意味着这对消耗类实例的客户是完全透明的。
- en: 'In this chapter, we will introduce you to the five creational patterns and
    discuss how we can use them with Swift:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向您介绍五种创建型模式，并讨论如何使用 Swift 来应用它们：
- en: The prototype pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原型模式
- en: The factory method pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂方法模式
- en: The singleton pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例模式
- en: The abstract factory pattern
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象工厂模式
- en: The builder pattern
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建者模式
- en: 'The objectives of these patterns are described in the following table:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式的目标在以下表格中描述：
- en: '| Pattern | Objective |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| 模式 | 目标 |'
- en: '| --- | --- |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| The prototype pattern | This pattern allows you to create new objects by
    duplicating existing objects called prototypes. This pattern has the cloning capability.
    |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 原型模式 | 此模式允许您通过复制称为原型的现有对象来创建新对象。此模式具有克隆能力。|'
- en: '| The factory method pattern | This pattern introduces you to an abstract method
    that allows you to create an object by telling its subclasses about the effective
    creation of the object. |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 工厂方法模式 | 此模式向您介绍一个抽象方法，允许您通过告诉其子类关于对象有效创建的信息来创建对象。|'
- en: '| The singleton pattern | This pattern ensures that a class has only one instance.
    This class provides a unique point of access that returns this instance. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 单例模式 | 此模式确保一个类只有一个实例。此类提供了一个唯一的访问点，返回此实例。|'
- en: '| The abstract factory pattern | This pattern allows you to create an object
    that is grouped in families by hiding the concrete classes that are needed to
    create these objects. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 抽象工厂模式 | 此模式允许您创建一个对象，该对象通过隐藏创建这些对象所需的具体类来按家族分组。|'
- en: '| The builder pattern | This pattern allows you to separate the creation of
    complex objects from their implementation. This permits a client to create complex
    objects having different representations. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 构建者模式 | 此模式允许您将复杂对象的创建与其实现分离。这允许客户端创建具有不同表示的复杂对象。|'
- en: The prototype pattern
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原型模式
- en: Our first pattern will be the prototype pattern; we will see how we can use
    it to accelerate the creation of an instance. We will see how we can use it to
    copy an existing instance, and eventually, we will see how to modify the new one
    to our needs.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先介绍的是原型模式；我们将看到如何使用它来加速实例的创建。我们将看到如何使用它来复制现有实例，最终，我们将看到如何根据我们的需求修改新实例。
- en: Roles
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 角色
- en: The prototype pattern is used to create a new object by duplicating existing
    objects called **prototypes**, and they have a cloning capability.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 原型模式通过复制称为**原型**的现有对象来创建新对象，并且它们具有克隆能力。
- en: 'This pattern is used in the following use cases:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式在以下用例中使用：
- en: When you need to create an instance without knowing the hierarchy of a class
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您需要创建一个实例，而不知道类的层次结构时
- en: When you need to create class instances that are dynamically loaded
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您需要创建动态加载的类实例时
- en: When you need to have a simple object system and not include a parallel hierarchy
    of a factory class
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您需要一个简单的对象系统，而不包括工厂类的并行层次结构时
- en: Design
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计
- en: 'The following diagram shows the generic class of the prototype pattern:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了原型模式的通用类：
- en: '![Design](img/4852_01_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![设计](img/4852_01_01.jpg)'
- en: Participants
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参与者
- en: 'Participant to this pattern are as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 参与者到这个模式如下：
- en: '`Client`: This class contains a list of objects called prototypes that are
    instances of the `AbstractPrototype` abstract class. The `Client` class needs
    to clone these prototypes without having to know their internal structure and
    subclass hierarchy.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Client`：这个类包含了一个对象列表，这些对象是`AbstractPrototype`抽象类的实例。`Client`类需要克隆这些原型，而无需了解它们的内部结构和子类层次结构。'
- en: '`AbstractPrototype`: This is an abstract class that can duplicate itself. This
    class contains a cloning method called `clone()`.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AbstractPrototype`：这是一个可以自我复制的抽象类。这个类包含一个名为`clone()`的克隆方法。'
- en: '`ConcretePrototype1` and `ConcretePrototype2`: These are concrete classes that
    inherit from the `AbstractPrototype` class. They define a prototype and have both
    a cloning method called `clone()`.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcretePrototype1`和`ConcretePrototype2`：这些是继承自`AbstractPrototype`类的具体类。它们定义了一个原型，并且都有一个名为`clone()`的克隆方法。'
- en: Collaborations
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协作
- en: The client asks to one or more prototypes to clone themselves.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端请求一个或多个原型进行自我克隆。
- en: Illustration
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插图
- en: 'A simple and real example of where this pattern can be applied is the famous
    game *HeartStone* from *Blizzard* (the creator of *World of Warcraft*). In this
    strategy card game, when you spend "mana" to use spells, weapons, or put a minion
    on the board, there is a special minion that has the ability to clone a particular
    card. When a player uses this card, it selects the minion that he or she wants
    to clone and the card becomes an exact copy of the selected card. The following
    card represent the "HeartStone" card that have this behavior:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单且真实的例子是来自*Blizzard*（*魔兽世界*的创造者）的著名游戏*炉石传说*。在这款策略卡牌游戏中，当你使用“法力”来使用法术、武器或将随从放在场上时，有一个特殊的随从具有克隆特定卡牌的能力。当玩家使用这张卡牌时，它会选择玩家想要克隆的随从，并且这张卡牌成为所选卡牌的精确副本。以下卡片代表具有这种行为的“炉石传说”卡牌：
- en: '![Illustration](img/4852_01_02.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![插图](img/4852_01_02.jpg)'
- en: Implementation
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'The following code represent the implementation of the pattern using Swift:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了使用Swift实现该模式的代码示例：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `AbstractPrototype` class is our `AbstractCard` class, where we implement
    a way to return a copy of itself using the `clone()` method.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbstractPrototype`类是我们的`AbstractCard`类，我们在其中实现了一种使用`clone()`方法返回自身副本的方式。'
- en: Usage
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用法
- en: 'The following code simulate how the client will interact with the `Card` object
    which implement the prototype pattern:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码模拟了客户端如何与实现原型模式的`Card`对象交互：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Since the code is written in a Playground file, you should consider it as the
    code that you'll put in the `Client` class.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于代码是写在Playground文件中的，你应该将其视为你将放入`Client`类中的代码。
- en: First, we instantiate a new card named `Raid Leader`. This is a concrete prototype
    class. Let say that you have the "Faceless Manipulator" card and you want to use
    it to clone the "Raid Leader" card, then you simply need to use the `raidLeader.clone()`
    method that will return a new instance with the exact same properties as "Raid
    Leader".
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们实例化一个新的卡牌名为`Raid Leader`。这是一个具体原型类。假设你有一张“无面操纵者”卡牌，并且你想用它来克隆“Raid Leader”卡牌，那么你只需使用`raidLeader.clone()`方法，这将返回一个具有与“Raid
    Leader”完全相同属性的新的实例。
- en: 'By checking the details on the right-hand side of the Playground file, you''ll
    see that the `facelessManipulator` constant has exactly the same properties as
    `raidLeader` (line 39), as shown in the following screenshot:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查Playground文件右侧的细节，你会看到`facelessManipulator`常量与`raidLeader`（第39行）具有完全相同的属性，如下面的截图所示：
- en: '![Usage](img/4852_01_03.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![用法](img/4852_01_03.jpg)'
- en: The factory method pattern
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂方法模式
- en: 'Our second pattern is a very well-known pattern. It introduces you to the famous
    concept: "Program to an interface, not an implementation." The instantiation is
    done in the factory class that depends on the type that we need and the type that
    needs to be returned to the client.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个模式是一个非常著名的模式。它介绍了著名的概念：“面向接口编程，而不是面向实现。”实例化是在工厂类中完成的，该类依赖于我们需要的类型以及需要返回给客户端的类型。
- en: Roles
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 角色
- en: The factory method pattern is one of the most used patterns in software designs.
    The purpose of this pattern is to abstract the creation of an object. The factory
    method lets a class defer instantiation to subclasses.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂方法模式是软件设计中用得最多的模式之一。这个模式的目的在于抽象对象的创建。工厂方法允许一个类将实例化推迟到子类。
- en: You'll see from that time to time that we have mentioned "program to an interface."
    This is exactly what this pattern does. With Swift, instead of an interface, you'll
    code with the "protocol" instead of the class itself.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你会时不时地看到我们提到“面向接口编程”。这正是这个模式所做的事情。在Swift中，你将使用“协议”而不是类本身来代替接口。
- en: 'This pattern is used in the following use cases:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式在以下用例中使用：
- en: A class only knows about abstract classes or interfaces of objects with whom
    it has some relationships
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类只知道与其有某些关系的抽象类或接口的对象
- en: A class wants its subclasses to instantiate the object in order to benefit of
    polymorphism mechanism
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类希望其子类实例化对象以利用多态机制
- en: Design
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计
- en: 'The following diagram shows the generic class of the factory method pattern:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图展示了工厂方法模式的通用类：
- en: '![Design](img/4852_01_04.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![设计](img/4852_01_04.jpg)'
- en: Participants
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参与者
- en: 'Participant to this pattern are as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 参与该模式的参与者如下：
- en: '**Product interface**: This class contains the definition of our product. We
    will define what a card is here.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**产品接口**：此类包含我们产品的定义。在这里我们将定义什么是卡片。'
- en: '**Abstract product**: This abstract class implements the signature of our cards
    and some methods. You''ll see that we keep the prototype pattern that allows us
    to eventually clone a card. These classes define the properties of our products.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象产品**：此抽象类实现了我们卡片的签名和一些方法。你会看到我们保留了原型模式，这允许我们最终克隆一个卡片。这些类定义了产品的属性。'
- en: '**Concrete product**: This class defines our product; in our example, the `Raid
    Leader` card is a concrete product, such as the `Faceless Manipulator` card.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具体产品**：此类定义了我们的产品；在我们的例子中，`Raid Leader`卡片是一个具体产品，例如`Faceless Manipulator`卡片。'
- en: '**Concrete creator**: This class implements our factory method.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具体创建者**：此类实现了我们的工厂方法。'
- en: Illustration
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: 'In our previous pattern, you would have seen the following line:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的模式中，你会看到以下行：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we directly program an implementation. We need a way to create some cards,
    but without having the knowledge to know exactly how to construct the card; we
    can only tell to create the `raidLeader` and `Faceless Manipulator` cards. At
    this point of time, the client doesn't want to know that the `Raid Leader` card
    needs three manas, so it provides two points of attack and two points of defense.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们直接编写实现。我们需要一种创建一些卡片的方法，但不知道确切如何构建卡片；我们只能告诉创建`raidLeader`和`Faceless Manipulator`卡片。在这个时候，客户端不想知道`Raid
    Leader`卡片需要三个法力值，所以它提供了两个攻击点和两个防御点。
- en: Implementation
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现方式
- en: 'The implementation of the factory method pattern is as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂方法模式的具体实现如下：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Usage
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用法
- en: 'To simulate the use of the factory method pattern by a client, we can write
    the card creation as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟客户端使用工厂方法模式，我们可以将卡片创建编写如下：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To simulate our client, we simply tell the `CardFactory` method that we want
    a `FacelessManipulator` card.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟我们的客户端，我们只需告诉`CardFactory`方法我们想要一个`FacelessManipulator`卡片。
- en: To do this, we use the `createCard` method (our factory method), and this method
    will delegate the instantiation of the card that was asked.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们使用`createCard`方法（我们的工厂方法），此方法将委派请求的卡片的实例化。
- en: The variable `c` has the type `Card` and not `FacelessManipulator`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`c`的类型是`Card`而不是`FacelessManipulator`。
- en: The singleton pattern
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例模式
- en: This pattern is certainly the pattern that every developer learns first. It
    is often used with a factory or abstract factory class to ensure that there is
    only one instance of the class.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式无疑是每个开发者首先学习的模式。它通常与工厂或抽象工厂类一起使用，以确保只有一个类的实例。
- en: Roles
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 角色
- en: The singleton pattern ensures that a class has only one instance and provides
    a global point of access to it, and at this point, it returns an instance of this
    class.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式确保一个类只有一个实例，并提供一个全局访问点，此时它返回该类的实例。
- en: In some cases, it can be useful to have some classes that have only one instance;
    for example, in the case of the abstract factory, where it is not useful to have
    several instances.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，拥有只有一个实例的类可能很有用；例如，在抽象工厂的情况下，拥有多个实例是没有用的。
- en: Design
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计
- en: The following figure shows the generic UML class diagram of the singleton pattern.
    There are many way to write the singleton pattern using Swift.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图展示了单例模式的通用UML类图。使用Swift编写单例模式有许多方法。
- en: 'Here, we use the easiest way to do this. With Swift, you''ll see that we can
    change the way in which we apply it, thanks to the class constant:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用最简单的方法来做这件事。使用 Swift，你会发现我们可以通过类常量来改变我们应用它的方式：
- en: '![Design](img/4852_01_05.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![设计](img/4852_01_05.jpg)'
- en: Participants
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参与者
- en: 'There is only one participant in this pattern: the `Singleton` class.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式只有一个参与者：`Singleton`类。
- en: This class provides a method that returns only one instance of the class. The
    mechanism locks the creation of other instances. It was introduced with Swift
    1.2\. We can now use class constants.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类提供了一个返回类唯一实例的方法。该机制锁定其他实例的创建。它是在 Swift 1.2 中引入的。我们现在可以使用类常量。
- en: With Swift 1.2, we will use the class constants to provide us with a way to
    ensure the unique creation of the instance.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Swift 1.2，我们将使用类常量来为我们提供一种确保实例唯一创建的方法。
- en: 'A class constant is defined as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 类常量定义如下：
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Collaborations
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协作
- en: Every client will have access to the unique instance of the `Singleton` class
    by calling the `Instance` method.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 每个客户端都可以通过调用`Instance`方法来访问`Singleton`类的唯一实例。
- en: With Swift, the approach we'll consider is the one that accesses our unique
    instance of the `Singleton` class using the class constant that we will call `sharedInstance`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Swift，我们将考虑的方法是使用类常量来访问我们的`Singleton`类的唯一实例，我们将称之为`sharedInstance`。
- en: Illustration
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: You are developing your card game and you need to manage all the data of the
    current game. In our game, we have two players; each player has a deck, mana reserve,
    name, and so on. We have a board (the table where we put our cards) and a game
    state (who is currently playing). To manage all of this information, you'll need
    a `BoardManager` class. This class will be a singleton class because we will not
    have several boards at the same time (we only allow one game at a time). The singleton
    pattern can be something interesting that can be used here in order to make sure
    that we access the good data.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您正在开发您的卡牌游戏，并且需要管理当前游戏的所有数据。在我们的游戏中，我们有两个玩家；每个玩家都有一个牌组、法力储备、名字等等。我们有一个棋盘（我们放置卡牌的桌子）和一个游戏状态（谁正在玩）。为了管理所有这些信息，您需要一个`BoardManager`类。这个类将是一个单例类，因为我们不会同时有几个棋盘（我们只允许同时进行一个游戏）。单例模式可以是一个有趣的概念，可以在这里使用，以确保我们访问正确的数据。
- en: Implementation
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'The following approach supports lazy initialization, and it is thread safe
    by the definition of `let`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法支持懒初始化，并且由于`let`的定义，它是线程安全的：
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Usage
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用法
- en: 'To use our singleton object, each client will access it using the following
    code :'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用我们的单例对象，每个客户端都将使用以下代码来访问它：
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `boardManager` variable contains all the members available in our singleton
    object and will be initialized only once.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`boardManager`变量包含我们单例对象中所有可用的成员，并且只初始化一次。'
- en: 'This pattern is used in the following cases:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式在以下情况下使用：
- en: We must have only one instance of a class
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须只有一个类的实例
- en: This instance must be accessible to clients from a well-known access point
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个实例必须从众所周知的访问点对客户端可访问。
- en: The abstract factory pattern
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象工厂模式
- en: 'We already introduced you to a very popular concept in design patterns: **factories**.
    Factories are the classes that handle the instantiation of related objects without
    subclassing. The factory method pattern that we have already seen hides the class
    name from where an object is instantiated. The abstract factory pattern is more
    complete as it creates families of related or dependent objects.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经向您介绍了一个在设计模式中非常流行的概念：**工厂**。工厂是处理相关对象实例化的类，而不需要子类化。我们已经看到的工厂方法模式隐藏了对象实例化的类名。抽象工厂模式更完整，因为它创建相关或依赖对象的系列。
- en: Roles
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 角色
- en: The abstract factory pattern is designed to build objects grouped in families
    without having to know the concrete class needed to create the object.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂模式旨在构建分组在家族中的对象，而不需要知道创建对象所需的具体类。
- en: 'This pattern is generally used in the following domains:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式通常在以下领域使用：
- en: A system that uses products needs to stay independent of how these products
    are grouped and instantiated
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用产品的系统需要保持独立于这些产品如何分组和实例化
- en: A system can have several product families that can evolve
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个系统可以有多个可以演化的产品系列
- en: Design
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计
- en: 'The following diagram represents the generic structure of the abstract factory
    pattern. You will see how products and families are decoupled:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表示抽象工厂模式的通用结构。您将看到产品和家庭是如何解耦的：
- en: '![Design](img/4852_01_06.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![设计](img/4852_01_06.jpg)'
- en: Participants
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参与者
- en: 'The abstract factory pattern has a lot of participants:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂模式有很多参与者：
- en: '`Abstract` `Factory`: This abstract class defines the signature of the different
    methods that create our products.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Abstract Factory`：这个抽象类定义了创建我们产品的不同方法的签名。'
- en: '`ConcreteFactory1` and `ConcreteFactory2`: These are our concrete classes that
    implement our methods for each products'' families. By knowing the family and
    product, the factory is able to create an instance of the product for that family.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcreteFactory1` 和 `ConcreteFactory2`：这些是我们实现每个产品家族方法的具体类。通过了解家族和产品，工厂能够为该家族创建一个产品实例。'
- en: '`IProductA` and `IProductB`: These are our interfaces that define our products
    that are independent of their family. A family is introduced in their concrete
    subclasses.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IProductA` 和 `IProductB`：这些是我们定义的接口，它们定义了独立于其家族的产品。家族在其具体子类中引入。'
- en: '`ProductA` and `ProductB`: These are the concrete classes that implement `IProductA`
    and `IProductB`, respectively.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProductA` 和 `ProductB`：这些是分别实现 `IProductA` 和 `IProductB` 的具体类。'
- en: Collaborations
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协作
- en: The `Client` class uses one instance of one of the concrete factories to create
    products throughout the interface of the abstract factory.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`Client` 类使用一个具体工厂的一个实例，通过抽象工厂的接口创建产品。'
- en: Illustration
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插图
- en: 'Our company specializes in manufacturing watches. Our watches are built in
    two parts: a band and dial. Our watches come in two sizes, so we must adapt the
    manufacturing of the band and dial according to the size of our watch.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的公司专门从事制造手表。我们的手表由两部分组成：表带和表盘。我们的手表有两种尺寸，因此我们必须根据我们手表的尺寸调整表带和表盘的制造。
- en: In order to simplify how to manage the manufacturing of our watches, the direction
    team decided to use one manufacturer who specializes in products that are adapted
    to the 38 mm model of our watch, and another manufacturer whose products are adapted
    to the 42 mm model of our watch.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化我们手表制造的管理，方向团队决定使用一家专门生产适应我们手表 38 毫米型号产品的制造商，以及另一家其产品适应我们手表 42 毫米型号的制造商。
- en: Each of these manufacturers will build a dial and band that are adapted to the
    dimension of the watch.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这些制造商中的每一个都将构建适应手表尺寸的表盘和表带。
- en: Implementation
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: To implement our pattern, we first need to identify our actors. The two manufacturers
    represent the `ConcreteFactory1` and `ConcreteFactory2` classes. These two factories
    implement the `AbstractFactory` method, which tell us that we can create a band
    or dial. Of course, the concrete factories will create the dial adapted to the
    size of the watch produced in that manufacture.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现我们的模式，我们首先需要确定我们的参与者。两个制造商代表 `ConcreteFactory1` 和 `ConcreteFactory2` 类。这两个工厂实现了
    `AbstractFactory` 方法，这告诉我们我们可以创建一个表带或表盘。当然，具体工厂将创建适应该工厂生产的表尺寸的表盘。
- en: 'Our `ConcreteProductA` and `ConcreteProductB` classes are the band and the
    dial; each of these products implements their respective `IProductA` and `IProductB`
    interfaces, as shown in the following code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `ConcreteProductA` 和 `ConcreteProductB` 类是表带和表盘；每个产品都实现了它们各自的 `IProductA`
    和 `IProductB` 接口，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Usage
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用方法
- en: 'To simulate our client, we will use the following code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟我们的客户端，我们将使用以下代码：
- en: '[PRE9]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Tip
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在 [http://www.packtpub.com](http://www.packtpub.com) 的账户下载所有已购买的 Packt
    出版物的示例代码文件。如果您在其他地方购买了此书，您可以访问 [http://www.packtpub.com/support](http://www.packtpub.com/support)
    并注册，以便将文件直接通过电子邮件发送给您。
- en: 'The Playground file will display our product''s properties, depending on the
    factory used. The details of product *A* (the band) and product *B* (the dial)
    from the `manufacture1` object are shown in the following screenshot:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 操场文件将显示我们的产品属性，具体取决于使用的工厂。以下截图显示了 `manufacture1` 对象的产品 *A*（表带）和产品 *B*（表盘）的详细信息：
- en: '![Usage](img/4852_01_07.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![Usage](img/4852_01_07.jpg)'
- en: 'The details of product *C* (the band) and product *D* (the dial) from the `manufacture2`
    object are shown in the following screenshot:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 `manufacture2` 对象的产品 *C*（表带）和产品 *D*（表盘）的详细信息：
- en: '![Usage](img/4852_01_08.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![Usage](img/4852_01_08.jpg)'
- en: The sizes of the band and the dial adapt to the manufacturer who delivers the
    product.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 表带和表盘的尺寸将适应提供产品的制造商。
- en: Note
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We should use the singleton pattern to ensure that we have only one instance
    of our abstract factory. This instance can be shared between several clients.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该使用单例模式来确保我们只有一个抽象工厂的实例。这个实例可以在多个客户端之间共享。
- en: The builder pattern
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建模式
- en: Unlike the abstract factory pattern, which will produce parts of products of
    the same family, the builder pattern will help us build the finalized product
    that consists of several parts.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 与会生产同一家族产品部分的抽象工厂模式不同，构建模式将帮助我们构建由多个部分组成的最终产品。
- en: Roles
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 角色
- en: The main purpose of the builder pattern is to abstract the building of complex
    objects from its actual construction. Having the same construction process can
    create different representations of the product.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 构建模式的主要目的是将复杂对象的构建过程与其实际构建过程抽象化。具有相同的构建过程可以创建不同表示的产品。
- en: 'This pattern can be used when:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式可用于以下情况：
- en: A client needs to construct complex objects without having to know its implementation
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户需要构建复杂对象，而不必了解其实现
- en: A client needs to construct complex objects that need to have several implementations
    or representations
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户需要构建需要具有多个实现或表示的复杂对象
- en: Design
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计
- en: 'The following figure shows the generic UML class diagram of the builder pattern:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图展示了构建模式的通用UML类图：
- en: '![Design](img/4852_01_09.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![设计](img/4852_01_09.jpg)'
- en: Participants
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参与者
- en: 'This pattern is quite simple as it has only a few participants:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式相当简单，因为它只有少数参与者：
- en: '`Director`: This class constructs the product using the interface of the `AbstractBuilder`
    class.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Director`：此类使用`AbstractBuilder`类的接口构建产品。'
- en: '`AbstractBuilder`: This class defines the method signature that allows the
    construction of all the parts of the product, and it contains a signature of a
    method that returns the product once this is built.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AbstractBuilder`：此类定义了构建产品所有部分的签名方法，并包含一个返回构建完成后的产品的签名方法。'
- en: '`ConcreteBuilder`: This is the `Concrete` class that implements the method
    of the `AbstractBuilder` class.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcreteBuilder`：这是实现`AbstractBuilder`类方法的`Concrete`类。'
- en: '`Product`: This is the finalized product. The product contains all the parts
    of the watch.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Product`：这是最终产品。产品包含手表的所有部分。'
- en: Collaborations
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协作
- en: The client creates the `ConcreteBuilder` and `Director` classes. The `Director`
    class will then build an object if the client asks him to do so by invoking the
    constructor and returns the finalized product to the client.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 客户创建`ConcreteBuilder`和`Director`类。然后，如果客户要求，`Director`类将通过调用构造函数构建一个对象，并将最终产品返回给客户。
- en: Illustration
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: 'Using the `AbstractFactory` method, we can use the builder pattern to build
    a watch. As we''ve seen that a watch has several parts: a dial and band. A watch
    can have two sizes too, and as we have already seen, the representation of the
    dial or band depends on the size of the watch too.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`AbstractFactory`方法，我们可以使用构建模式来构建手表。正如我们所见，手表有几个部分：表盘和表带。手表还可以有两种尺寸，正如我们之前所看到的，表盘或表带的表示也取决于手表的尺寸。
- en: Implementation
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: If we want to build some watches that are represented with a dial and band,
    we will define a `Director` class that will define the construction order of all
    the parts of our watches and return the finalized watch to the client.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要构建一些由表盘和表带表示的表，我们将定义一个`Director`类，该类将定义我们手表所有部分的构建顺序，并将最终完成的手表返回给客户。
- en: The `Director` class will call all the constructors who are in charge to construct
    one part of the watch. To implement this, we will reuse the existing code of the
    abstract factory pattern and add the following code.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`Director`类将调用所有负责构建手表一个部分的构造函数。为了实现这一点，我们将重用抽象工厂模式的现有代码，并添加以下代码。'
- en: 'Open the `Builder.playground` file in Xcode to see the added code at the bottom
    of the file:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xcode中打开`Builder.playground`文件，查看文件底部的添加代码：
- en: '[PRE10]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Usage
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用法
- en: 'To simulate our client, we will tell our director to create two watches:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟我们的客户，我们将告诉我们的导演创建两块手表：
- en: A 42 mm aluminium dial with a sports band
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一款直径42毫米的铝合金表盘配运动表带
- en: A 38 mm gold dial with a milanese band
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一款直径38毫米的金色表盘配米兰尼斯表带
- en: 'The code for the example is as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码如下：
- en: '[PRE11]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The result is shown in Playground like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 结果在Playground中显示如下：
- en: '![Usage](img/4852_01_10.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![用法](img/4852_01_10.jpg)'
- en: Note
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Swift allows the use of closure that simplifies the creation of our complex
    objects. Regarding the example that we provided earlier, we can write the following
    code to build our two watches.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 允许使用闭包来简化我们复杂对象的创建。关于我们之前提供的示例，我们可以编写以下代码来构建我们的两个手表。
- en: Implementation using closures
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用闭包的实现
- en: Here, we don't need to use the `Director` and `ConcreteBuilder` classes. Instead,
    we will tell our `Watch` class that the builder will be in the closure.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不需要使用`Director`和`ConcreteBuilder`类。相反，我们将告诉我们的`Watch`类，构建器将在闭包中。
- en: In the previous example, remove the `Director`, `AbstractBuilder`, and `ConcreteBuilder`
    classes.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，移除`Director`、`AbstractBuilder`和`ConcreteBuilder`类。
- en: 'We just need to write the `Watch` class, as shown in the following code (you
    can find the following code in the `BuilderClosures.playground` file accompanying
    this chapter):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要编写如下的`Watch`类，如下代码所示（你可以在伴随本章的`BuilderClosures.playground`文件中找到以下代码）：
- en: '[PRE12]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, to simulate our client, we can write the following code which will call
    the appropriate constructor assigned to the band or dial property of the `Watch`
    object:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了模拟我们的客户端，我们可以编写以下代码，该代码将调用分配给`Watch`对象带或表盘属性的适当构造函数：
- en: '[PRE13]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The result is as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![Implementation using closures](img/4852_01_11.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![使用闭包的实现](img/4852_01_11.jpg)'
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'Well, I hope that this chapter was a good introduction to the use of patterns
    using Swift. We learned the five creational patterns: the prototype pattern, the
    factory method pattern, the singleton pattern, the abstract factory pattern, and
    the builder pattern. We also learned when to use them and how to implement them.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我希望这一章对使用 Swift 的模式进行了良好的介绍。我们学习了五种创建型模式：原型模式、工厂方法模式、单例模式、抽象工厂模式和建造者模式。我们还学习了何时使用它们以及如何实现它们。
- en: In the next chapter, we will introduce you to three structural patterns that
    are designed to ease the relationship between entities.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将向您介绍三种旨在简化实体之间关系的结构模式。
