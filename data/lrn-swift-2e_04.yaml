- en: Chapter 4. To Be or Not To Be – Optionals
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章.存在与否——可选类型
- en: As we discussed in [Chapter 2](ch02.html "Chapter 2. Building Blocks – Variables,
    Collections, and Flow Control"), *Building Blocks – Variables, Collections, and
    Flow Control*, all variables and constants must always have a value before they
    are used. This is a great safety feature because it prevents you from creating
    a scenario where you forget to give a variable an initial value. It may make sense
    for some number variables, such as the number of sandwiches ordered to start at
    zero, but it doesn't make sense for all variables. For example, the number of
    bowling pins standing should start at 10, not zero. In Swift, the compiler forces
    you to decide what the variable should start at, instead of providing a default
    value that could be incorrect.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第二章](ch02.html "第二章.构建块——变量、集合和流程控制")中讨论的，*构建块——变量、集合和流程控制*，所有变量和常量在使用之前都必须有一个值。这是一个很好的安全特性，因为它可以防止你忘记为变量提供一个初始值。对于某些数字变量，例如开始时点三明治的数量为零，这可能是有意义的，但对于所有变量来说并不合理。例如，站立保龄球柱的数量应该从10开始，而不是零。在Swift中，编译器强制你决定变量应该从哪里开始，而不是提供一个可能不正确的默认值。
- en: However, there are other scenarios where you will have to represent the complete
    absence of a value. A great example is if you have a dictionary of word definitions
    and you try to lookup a word that isn't in the dictionary. Normally, this will
    return a String, so you could potentially return an empty String, but what if
    you also need to represent the idea that a word exists without a definition? Also,
    for another programmer who is using your dictionary, it will not be immediately
    obvious what will happen when they look up a word that doesn't exist. To satisfy
    this need to represent the absence of a value, Swift has a special type called
    an **optional**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有其他场景，你需要表示值的完全缺失。一个很好的例子是，如果你有一个单词定义的字典，并且尝试查找字典中不存在的单词。通常，这将返回一个字符串，所以你可以返回一个空字符串，但如果你还需要表示一个单词存在但没有定义的情况呢？另外，对于使用你的字典的其他程序员来说，当他们查找不存在的单词时会发生什么可能并不明显。为了满足表示值缺失的需求，Swift有一个特殊的类型，称为**可选类型**。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Defining an optional
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个可选类型
- en: Unwrapping an optional
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解包可选类型
- en: Optional chaining
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选链
- en: Implicitly unwrapped optionals
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式展开可选类型
- en: Debugging optionals
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选类型的调试
- en: The underlying implementation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 底层实现
- en: Defining an optional
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义一个可选类型
- en: 'So we know that the purpose of optionals in Swift is to allow the representation
    of the absence of a value, but what does that look like and how does it work?
    An optional is a special type that can "wrap" any other type. This means that
    you can make an optional `String`, optional `Array`, and so on. You can do this
    by adding a question mark (`?`) to the type name, as shown:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们知道Swift中可选类型的作用是允许表示值的缺失，但它看起来是什么样子，又是如何工作的呢？可选类型是一个特殊的类型，可以“包装”任何其他类型。这意味着你可以创建一个可选的`String`，可选的`Array`等等。你可以通过在类型名称后添加一个问号（`?`）来实现这一点，如下所示：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Note that this code does not specify any initial values. This is because all
    optionals, by default, are set to no value at all. If we want to provide an initial
    value we can do so similar to any other variable:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此代码没有指定任何初始值。这是因为所有可选类型默认情况下都没有值。如果我们想提供一个初始值，我们可以像其他任何变量一样这样做：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Also, note that if we left out the type specification (`: Int?`), `possibleInt`
    would be inferred to be of type `Int` instead of an optional `Int`.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '此外，请注意，如果我们省略了类型指定（`: Int?`），`possibleInt`将被推断为`Int`类型，而不是可选的`Int`。'
- en: Now, it is pretty verbose to say that a variable lacks a value. Instead, if
    an optional lacks a variable, we say it is nil. So both `possibleString` and `possibleArray`
    are nil, while `possibleInt` is `10`. However, `possibleInt` is not truly `10`.
    It is still wrapped in an optional.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，说一个变量没有值是很冗长的。相反，如果一个可选变量没有值，我们说它是nil。所以`possibleString`和`possibleArray`都是nil，而`possibleInt`是`10`。然而，`possibleInt`并不是真正的`10`。它仍然被包装在可选类型中。
- en: 'You can see all the forms a variable can take by putting the following code
    into a playground:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在游乐场中放入以下代码来查看变量可以采取的所有形式：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see, `actualInt` prints out just as we expected, but `possibleInt`
    prints out as an optional that contains the value `10` instead of just `10`. This
    is a very important distinction because an optional cannot be used as the value
    it is wrapping. `nilInt` just reports that it is nil. At any point, you can update
    the value within an optional; this includes assigning it a value for the first
    time, using the assignment operator (`=`):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`actualInt`打印出的结果正如我们所期望的，但`possibleInt`打印出的结果是一个包含值`10`的可选值，而不是仅仅是`10`。这是一个非常重要的区别，因为可选值不能用作它所包裹的值。`nilInt`只是报告它为nil。在任何时候，你都可以更新可选值中的值；这包括使用赋值运算符（`=`）为其赋值：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can even remove the value within an optional by assigning it to `nil`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以通过将其赋值为`nil`来移除可选值中的值：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: So we have this wrapped form of a variable that may or may not contain a value.
    What do we do if we need to access the value within an optional? The answer is
    that we must unwrap it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有了这种可能包含也可能不包含值的变量包装形式。如果我们需要访问可选值中的值，我们该怎么办？答案是，我们必须解包它。
- en: Unwrapping an optional
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解包可选值
- en: There are multiple ways to unwrap an optional. All of them essentially assert
    that there is truly a value within the optional. This is a wonderful safety feature
    of Swift. The compiler forces you to consider the possibility that an optional
    lacks any value at all. In other languages, this is a very commonly overlooked
    scenario that can cause obscure bugs.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 解包可选值有多种方式。它们本质上都断言可选值中确实有值。这是Swift的一个非常好的安全特性。编译器强制你考虑一个可能的情况，即可选值可能没有任何值。在其他语言中，这是一个非常常见的被忽视的场景，可能导致难以追踪的bug。
- en: Optional binding
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选绑定
- en: 'The safest way to unwrap an optional is to use something called **optional
    binding**. With this technique, you can assign a temporary constant or variable
    to the value contained within the optional. This process is contained within an
    `if` statement, so that you can use an else statement when there is no value.
    Optional binding looks similar to the following code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 解包可选值最安全的方式是使用一种称为**可选绑定**的技术。使用这种技术，你可以将一个临时常量或变量赋值给可选值中包含的值。这个过程包含在一个`if`语句中，这样你就可以在没有值的情况下使用`else`语句。可选绑定看起来类似于以下代码：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: An optional binding is distinguished from an `if` statement primarily by the
    `if let` syntax. Semantically, this code is saying, "if you can let the constant
    `string` be equal to the value within `possibleString`, print out its value; otherwise,
    print that it has no value." The primary purpose of an optional binding is to
    create a temporary constant that is the normal (non-optional) version of the optional.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 可选绑定与`if`语句的主要区别在于`if let`语法。从语义上看，这段代码的意思是：“如果你可以让常量`string`等于`possibleString`中的值，就打印出它的值；否则，打印出它没有值。”可选绑定的主要目的是创建一个临时常量，它是可选值的正常（非可选）版本。
- en: 'We can also use a temporary variable in an optional binding:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在可选绑定中使用一个临时变量：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note that an asterisk (`*`) is used for multiplication in Swift. You should
    also notice something important about this code. If you put it into a playground,
    even though we multiplied the `actualInt` by `2`, the value within the optional
    does not change. When we print out `possibleInt` later, the value is still `Optional(10)`.
    This is because even though we made `actualInt` a variable (otherwise known as
    mutable), it is simply a temporary copy of the value within `possibleInt`. No
    matter what we do with `actualInt`, nothing will get changed about the value within
    `possibleInt`. If we have to update the actual value stored within `possibleInt`,
    we simply assign `possibleInt` to `actualInt` after we are done modifying it:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在Swift中，星号（`*`）用于乘法。你还应该注意这个代码的一个重要特点。如果你将它放入一个playground中，即使我们乘以了`actualInt`，可选值内部的值也不会改变。当我们稍后打印出`possibleInt`时，值仍然是`Optional(10)`。这是因为尽管我们将`actualInt`变成了一个变量（也称为可变），它只是`possibleInt`内部值的临时副本。无论我们对`actualInt`做什么，都不会改变`possibleInt`内部的值。如果我们必须更新`possibleInt`中实际存储的值，我们只需在修改完成后将`possibleInt`赋值给`actualInt`：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, the value wrapped inside `possibleInt` has actually been updated.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`possibleInt`内部包裹的值实际上已经被更新了。
- en: 'A common scenario that you will probably come across is the need to unwrap
    multiple optional values. One option is to simply nest the optional bindings:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到的一个常见场景是需要解包多个可选值。一个选择是简单地嵌套可选绑定：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'However, this can be a pain, as it increases the indentation level each time
    to keep the code organized. Instead, you can actually list multiple optional bindings
    into a single statement separated by commas:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这可能会很麻烦，因为它每次都会增加缩进级别以保持代码的整洁。相反，你实际上可以将多个可选绑定列在单个语句中，用逗号分隔：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This generally produces more readable code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常会产生更易读的代码。
- en: 'Another great way to do a concise optional binding within functions is to use
    the guard statement. This way, you can do a series of unwrapping without increasing
    the indent level of the code at all:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内进行简洁的可选绑定还有另一种很好的方法，就是使用guard语句。这样，你可以进行一系列解包操作，而无需增加代码的缩进级别：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This construct allows us to access the unwrapped values after the guard statement,
    because the guard statement guarantees that we would have exited the function
    before reaching that code, if the optional value was nil.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构允许我们在guard语句之后访问解包后的值，因为guard语句保证了如果可选值为nil，我们会在到达该代码之前退出函数。
- en: This way of unwrapping is great, but saying that optional binding is the safest
    way to access the value within an optional, implies that there is an unsafe way
    to unwrap an optional. This way is called **forced unwrapping**.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解包方式很好，但说可选绑定是访问可选值内值最安全的方式，这意味着存在一种不安全地解包可选值的方法。这种方法被称为**强制解包**。
- en: Forced unwrapping
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强制解包
- en: 'The shortest way to unwrap an optional is to use forced unwrapping. It is done
    using an exclamation mark (`!`) after the variable name when being used:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 解包可选值最短的方式是使用强制解包。当使用时，在变量名后使用感叹号（`!`）：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'However, the reason it is considered unsafe is that your entire program will
    crash if you try to unwrap an optional that is currently nil:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它被认为是不安全的，是因为如果你尝试解包当前为nil的可选值，整个程序将会崩溃：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The complete error you get is **unexpectedly found nil while unwrapping an optional
    value**. This is because the forced unwrapping is essentially your personal guarantee
    that the optional truly does hold a value. That is why it is called "forced".
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你得到的完整错误是**在解包可选值时意外地发现值为nil**。这是因为强制解包本质上是你个人保证可选值确实包含值的保证。这就是为什么它被称为“强制”。
- en: Therefore, forced unwrapping should be used in limited circumstances. It should
    never be used just to shorten up the code. Instead, it should only be used when
    you can guarantee from the structure of the code that it cannot be nil, even though
    it is defined as an optional. Even in that case, you should see if it is possible
    to use a non-optional variable instead. The only other place you may use it is
    if your program truly could not recover from an optional being nil. In those circumstances,
    you should at least consider presenting an error to the user, which is always
    better than simply having your program crash.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，强制解包应仅限于有限的情况下使用。它绝不应该仅仅为了缩短代码而使用。相反，它只应在你可以从代码的结构保证它不可能是nil的情况下使用，即使它被定义为可选的。即使在那种情况下，你也应该看看是否可以使用非可选变量。你可能会使用的另一个地方是如果你的程序真的无法从可选值为nil中恢复。在这种情况下，你应该至少考虑向用户显示错误，这总比程序崩溃要好。
- en: 'An example of a scenario where it may be used effectively is with lazily calculated
    values. A lazily calculated value is the one that is not created until the first
    time it is accessed. To illustrate this, let''s consider a hypothetical class
    that represents a file system directory. It will have a property listing its contents
    that is lazily calculated. The code will look similar to the following code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能有效使用场景的例子是与延迟计算值一起使用。延迟计算值是在第一次访问时才创建的值。为了说明这一点，让我们考虑一个代表文件系统目录的假设类。它将有一个列出其内容的属性，该属性是延迟计算的。代码将类似于以下代码：
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we have defined a superclass called `FileSystemItem` that both `File`
    and `Directory` inherit from. The content of a directory is a list of `FileSystemItem`.
    We define `contents` as a calculated variable and store the real value within
    the `realContents` property. The calculated property checks if there is a value
    loaded for `realContents`; if there isn't, it loads the contents and puts them
    into the `realContents` property. Based on this logic, we know for 100% certainty
    that there will be a value within `realContents` by the time we get to the return
    statement, so it is perfectly safe to use forced unwrapping.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个名为 `FileSystemItem` 的超类，`File` 和 `Directory` 都继承自它。目录的内容是一个 `FileSystemItem`
    列表。我们定义 `contents` 为一个计算变量，并将实际值存储在 `realContents` 属性中。计算属性检查 `realContents` 是否有值加载；如果没有，它将加载内容并将它们放入
    `realContents` 属性中。基于这种逻辑，我们知道当我们到达返回语句时，`realContents` 内部肯定会有一个值，因此使用强制解包是绝对安全的。
- en: Nil coalescing
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: nil 合并
- en: 'In addition to optional binding and forced unwrapping, Swift also provides
    an operator called the **nil coalescing operator** to unwrap an optional. This
    is represented by a double question mark (`??`). Basically, this operator lets
    us provide a default value for a variable or operation result, in case it is nil.
    This is a safe way to turn an optional value into a non-optional value and it
    would look similar to the following code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可选绑定和强制解包之外，Swift 还提供了一个名为 **nil 合并运算符** 的运算符来解包可选值。它由一个双问号（`??`）表示。基本上，这个运算符允许我们为变量或操作结果提供一个默认值，以防它是
    nil。这是一种将可选值安全转换为非可选值的方法，其代码看起来可能如下所示：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we are asking the program to print out `possibleString` unless it is nil;
    in which case, it will just print `"Default String"`. Since we did give it a value,
    it printed out that value and it is important to note that it printed out as a
    regular variable, not an optional. This is because one way or another, an actual
    value was going to be printed.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们要求程序打印出 `possibleString`，除非它是 nil；如果是 nil，则只打印 `"Default String"`。由于我们确实给它赋了一个值，所以它打印出了那个值，并且值得注意的是，它是以常规变量的形式打印出来的，而不是可选值。这是因为无论如何，一个实际值都将被打印出来。
- en: This is a great tool for concisely and safely unwrapping an optional when a
    default value makes sense.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在默认值有意义时，简洁且安全地解包可选值的好工具。
- en: Optional chaining
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可选链
- en: 'A common scenario in Swift is to have an optional that you must calculate something
    from. If the optional has a value, you will want to store the result of the calculation
    on it, but if it is nil, the result should just be set to nil:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，一个常见的场景是必须从一个可选值中计算出一些内容。如果可选值有值，你将希望将计算结果存储在其上，但如果它是 nil，则结果应直接设置为
    nil：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is pretty verbose. To shorten this up in an unsafe way, we could use forced
    unwrapping:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当冗长。为了在不安全的方式中缩短它，我们可以使用强制解包：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'However, optional chaining will allow us to do this safely. Essentially, it
    allows optional operations on an optional. When the operation is called, if the
    optional is nil, it immediately returns nil; otherwise, it returns the result
    of performing the operation on the value within the optional:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可选链允许我们安全地做到这一点。本质上，它允许对可选值进行可选操作。当调用操作时，如果可选值是 nil，它立即返回 nil；否则，它返回对可选值内部值执行操作的结果：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: So in this call, `invitee` is an optional. Instead of unwrapping it, we use
    optional chaining by placing a question mark (`?`) after it, followed by the optional
    operation. In this case, we are asking for the `uppercaseInvitee` property on
    it. If `invitee` is nil, `uppercaseInvitee` is immediately set to nil without
    even trying to access `uppercaseString`. If it actually does contain a value,
    `uppercaseInvitee` gets set to the `uppercaseString` property of the contained
    value. Note that all optional chains return an optional result.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个调用中，`invitee` 是一个可选值。我们不是解包它，而是在它后面放置一个问号（`?`），然后进行可选操作。在这种情况下，我们要求获取它的
    `uppercaseInvitee` 属性。如果 `invitee` 是 nil，则 `uppercaseInvitee` 立即设置为 nil，甚至没有尝试访问
    `uppercaseString`。如果它实际上包含一个值，则 `uppercaseInvitee` 被设置为包含值的 `uppercaseString`
    属性。请注意，所有可选链都返回一个可选结果。
- en: 'You can chain as many calls as you want, both optional and non-optional, together
    in this way:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以以这种方式将任意多的调用（可选和非可选）一起链起来：
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This code checks if the first element of the invitees-list starts with the
    letter `A`, even if it is a lowercase `A`. First, it uses an optional chain in
    case `invitees` is nil. Then the call to `first` uses an additional optional chain
    because that method returns an optional `String`. We then call `uppercaseString`,
    which does not return an optional, allowing us to access `hasPrefix` on the result
    without having to use another optional chain. If at any point any of the optionals
    are nil, the result will be nil. This can happen for two different reasons:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码检查邀请人列表的第一个元素是否以字母`A`开头，即使它是小写`A`。首先，它使用可选链，以防`invitees`是nil。然后对`first`的调用使用额外的可选链，因为该方法返回一个可选`String`。然后我们调用`uppercaseString`，它不返回可选值，这使得我们可以在结果上访问`hasPrefix`而无需使用另一个可选链。如果在任何时刻任何一个可选值是nil，结果将是nil。这可以有两个不同的原因：
- en: invitees is `nil`
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 邀请人是 `nil`
- en: '`first` returns `nil` because the array is empty'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`first`返回`nil`，因为数组是空的'
- en: If the chain makes it all the way to `uppercaseString`, there is no longer a
    failure path and it will definitely return an actual value. You will notice that
    there are exactly two question marks being used in this chain and there are two
    possible failure reasons.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果链一直到达`uppercaseString`，就没有失败路径了，它肯定会返回一个实际值。你会注意到在这个链中恰好使用了两个问号，并且有两个可能的失败原因。
- en: 'At first, it can be hard to understand when you should and should not use a
    question mark to create a chain of calls; the rule is to always use a question
    mark if the previous element in the chain returns an optional. However, so you
    are prepared, let''s take a look at what happens if you use an optional chain
    improperly:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，可能难以理解何时应该和不应该使用问号来创建一系列调用；规则是如果链中的前一个元素返回一个可选值，则始终使用问号。然而，为了做好准备，让我们看看如果你不正确地使用可选链会发生什么：
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this case, we try to call a method directly on an optional without a chain,
    so we get an error that says **Value of optional type ''[String]?'' not unwrapped;
    did you mean to use ''!'' or ''?''?**. Not only does it tell us that the value
    is not unwrapped, it even suggests two common ways of dealing with the problem:
    forced unwrapping or optional chaining.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们试图在不使用链的情况下直接在可选值上调用一个方法，所以我们得到一个错误，说**可选类型'[String]?'的值未展开；你是指要使用'!'还是'?'吗？**。这不仅告诉我们值没有被展开，甚至建议两种处理问题的常见方法：强制展开或可选链。
- en: 'We also have the case where we try to use an optional chain inappropriately:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有试图不恰当地使用可选链的情况：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we get an error that says **Cannot use optional chaining on non-optional
    value of type '[String]'**. It is great to have a good sense of the errors you
    might see when you make mistakes; so that you can correct them quickly because
    we all make silly mistakes from time-to-time.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们得到一个错误，说**不能在非可选值类型'[String]'上使用可选链**。了解你可能会在犯错时看到的错误感非常好；这样你就可以快速纠正它们，因为我们都时不时地会犯愚蠢的错误。
- en: 'Another great feature of optional chaining is that it can be used for method
    calls on an optional that does not actually return a value:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 可选链的另一个伟大特性是它可以用于对不实际返回值的可选进行方法调用：
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this case, we only want to call `removeAll` if there is truly a value within
    the optional array. So with this code, if there is a value, all the elements are
    removed from it; otherwise, it remains nil.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只想在可选数组中确实有值时调用`removeAll`。所以，用这段代码，如果有值，所有元素都会从它中移除；否则，它将保持nil。
- en: In the end, option chaining is a great choice for writing a concise code that
    still remains expressive and understandable.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，链式调用是一个编写简洁代码的好选择，同时仍然保持表达性和可理解性。
- en: Implicitly unwrapped optionals
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式展开的可选
- en: There is a second type of optional called an **implicitly unwrapped optional**.
    There are really two ways to look at what an implicitly unwrapped optional is;
    one way is to say that it is a normal variable that can also be nil; the other
    way is to say that it is an optional that you don't have to unwrap to use. The
    important thing to understand about them is that, similar to optionals, they can
    be nil, but you do not have to unwrap them like a normal variable.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可选类型称为**隐式展开的可选**。实际上有两种看待隐式展开可选的方式；一种方式是说它是一个也可以是nil的正常变量；另一种方式是说它是一个你不必展开即可使用的可选。重要的是要理解的是，与可选类似，它们可以是nil，但你不必像正常变量那样展开它们。
- en: 'You can define an implicitly unwrapped optional with an exclamation mark (`!`)
    instead of a question mark (`?`) after the type name:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用感叹号（`!`）而不是问号（`?`）在类型名后定义一个隐式未包装的可选类型：
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Similar to regular optionals, implicitly unwrapped optionals do not need to
    be given an initial value because they are nil by default.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与常规可选类型类似，隐式未包装的可选类型不需要给出一个初始值，因为它们默认为nil。
- en: 'At first it may sound like it is the best of both worlds, but in reality it
    is more like the worst of both worlds. Even though an implicitly unwrapped optional
    does not have to be unwrapped, it will crash your entire program if it is nil
    when used:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 起初这听起来像是两者的最佳之处，但现实中它更像是两者的最坏之处。即使隐式未包装的可选类型不需要解包，如果它在使用时为nil，它也会使你的整个程序崩溃：
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: A great way to think about them is that every time it is used, it is implicitly
    doing a forced unwrapping. The exclamation mark is placed in its type declaration,
    instead of each time it is used. This can be problematic because it appears the
    same as any other variable except for how it is declared. That means it is very
    unsafe to use, unlike a normal optional.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 想象它们的一个好方法是，每次使用时，它都会隐式地进行强制解包。感叹号放在其类型声明中，而不是每次使用时。这可能会引起问题，因为它看起来与其他任何变量相同，除了它的声明方式。这意味着它非常不安全，与普通可选类型不同。
- en: So if the implicitly unwrapped optionals are the worst of both worlds and are
    so unsafe, why do they even exist? The reality is that in rare circumstances,
    they are necessary. They are used in circumstances where a variable is not truly
    optional, but you also cannot give an initial value to it. This is almost always
    the case for custom types that have a member variable that is non-optional but
    cannot be set during initialization.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果隐式未包装的可选类型是两者的最坏之处，并且如此不安全，那么它们为什么甚至存在呢？现实是，在罕见的情况下，它们是必要的。它们用于变量不是真正可选的情况，但你也不能给它一个初始值。这对于具有非可选成员变量但无法在初始化期间设置的定制类型几乎总是这种情况。
- en: 'A rare example of this is with a view in iOS. UIKit, as we discussed before,
    is the framework Apple provides for iOS development. In it, Apple has a class
    called `UIView` that is used to display content on the screen. Apple also provides
    a tool in Xcode called Interface Builder that lets you design these views in a
    visual editor instead of in code. Many views designed in this way will need references
    to other views that can be accessed later, programmatically. When one of these
    views is loaded, it is initialized without anything connected and then all the
    connections are made. Once all of the connections are made, a function called
    `awakeFromNib` is called on the view. This means that these connections are not
    available to be used during initialization but are available once `awakeFromNib`
    is called. This order of operations also ensures that `awakeFromNib` is always
    called before anything actually uses the view. This is a circumstance where it
    is necessary to use an implicitly unwrapped optional. A member variable may not
    be able to be defined until after the view is initialized, when it is completely
    loaded:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况的一个罕见例子是在iOS中的视图。正如我们之前讨论的，UIKit是苹果为iOS开发提供的框架。在这个框架中，苹果提供了一个名为`UIView`的类，用于在屏幕上显示内容。苹果还在Xcode中提供了一个名为Interface
    Builder的工具，它允许你在可视化编辑器中而不是在代码中设计这些视图。许多以这种方式设计的视图将需要引用其他可以在以后通过编程访问的视图。当一个这样的视图被加载时，它是在没有任何连接的情况下初始化的，然后所有连接都会被建立。一旦所有连接都建立好了，视图上就会调用一个名为`awakeFromNib`的函数。这意味着这些连接在初始化期间不可用，但在`awakeFromNib`被调用后可用。这种操作顺序也确保了`awakeFromNib`总是在实际使用视图之前被调用。这是一个需要使用隐式未包装可选类型的情况。成员变量可能无法在视图初始化后定义，当它完全加载时：
- en: '[PRE24]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Notice that we have actually declared two implicitly unwrapped optionals. The
    first is a connection to a button. We know that this is a connection because it
    is preceded by `@IBOutlet`. This is declared as an implicitly unwrapped optional
    because connections are not set up until after initialization, but they are still
    guaranteed to be set up before any other methods are called on the view.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们实际上声明了两个隐式未包装的可选类型。第一个是一个按钮的连接。我们知道这是一个连接，因为它前面有`@IBOutlet`。因为这个连接是在初始化之后才设置的，所以它被声明为隐式未包装的可选类型，但它们仍然保证在调用视图上的任何其他方法之前被设置。
- en: This then leads us to unwrapping our second variable, `buttonOriginalWidth`,
    implicitly because we need to wait until the connection is made before we can
    determine the width of the button. After `awakeFromNib` is called, it is safe
    to treat both `button` and `buttonOriginalWidth` as non-optional.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这就引出了我们解包第二个变量`buttonOriginalWidth`的情况，这是隐式进行的，因为我们需要等待连接建立，才能确定按钮的宽度。在调用`awakeFromNib`之后，我们可以安全地将`button`和`buttonOriginalWidth`视为非可选类型。
- en: You may have noticed that we had to dive pretty deep into app development to
    find a valid use case for implicitly unwrapped optionals and this is arguably
    only because UIKit is implemented in Objective-C, as we will learn more about
    in [Chapter 10](ch10.html "Chapter 10. Harnessing the Past – Understanding and
    Translating Objective-C"), *Harnessing the Past – Understanding and Translating
    Objective-C*. This is another testament to the fact that they should be used sparingly.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们必须深入到应用程序开发中，才能找到一个隐式可选类型的有效用例，这可能是由于UIKit是用Objective-C实现的，正如我们将在第10章[第10章。利用过去
    – 理解和翻译Objective-C](ch10.html "Chapter 10. Harnessing the Past – Understanding
    and Translating Objective-C")中了解到的那样。这是对这样一个事实的又一证明，即它们应该被谨慎使用。
- en: Debugging optionals
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试可选类型
- en: We have already seen a couple of the compiler errors we will commonly see because
    of optionals. If we try to call a method on an optional that we intended to call
    on the wrapped value, we will get an error. If we try to unwrap a value that is
    not actually optional, we will also get an error. We also need to be prepared
    for the runtime errors that optionals can cause.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了由于可选类型导致的几种常见的编译器错误。如果我们尝试在一个本应应用于包装值的可选类型上调用方法，我们会得到一个错误。如果我们尝试解包一个实际上不是可选类型的值，我们也会得到一个错误。我们还需要准备好可选类型可能导致的运行时错误。
- en: As we have discussed, optionals cause runtime errors that are also referred
    to as crashes, if you try to forcefully unwrap one that is nil. This can happen
    with both explicit and implicitly forced unwrapping. If you have followed my advice
    so far in this chapter, this should be a rare occurrence. However, we all end
    up working with a third party code and maybe they were lazy or maybe they use
    forced unwrapping to enforce their expectations about how their code should be
    used.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，如果尝试强制解包一个为nil的可选类型，它会导致运行时错误，也被称为崩溃。这既可能发生在显式强制解包中，也可能发生在隐式强制解包中。如果你到目前为止已经遵循了我在本章中的建议，这种情况应该很少发生。然而，我们最终都会与第三方代码打交道，也许他们很懒惰，或者他们使用强制解包来强制他们的代码使用期望。
- en: Also, we all suffer from being lazy from time to time. It can be exhausting
    or discouraging to worry about all the edge cases when you are excited about programming
    the core functionality of your app. We may use forced unwrapping temporarily while
    we worry about that main functionality and plan to come back to handle it later.
    After all, during development it is better to have a forced unwrapping crash the
    development version of your app than it is for it to fail silently if you have
    not yet handled that edge case. We may even decide that an edge case is not worth
    the development effort of handling because everything about developing an app
    is a trade off. Either way, we need to recognize a crash from forced unwrapping
    quickly so we don't waste extra time trying to figure out what went wrong.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们有时都会因为懒惰而感到疲惫。当你对编写应用程序的核心功能感到兴奋时，担心所有边缘情况可能会令人疲惫或气馁。我们可能会在担心主要功能的同时临时使用强制解包，并计划稍后回来处理它。毕竟，在开发过程中，让强制解包导致应用程序的开发版本崩溃，比它未处理该边缘情况而默默失败要好。我们甚至可能决定，处理边缘情况不值得开发努力，因为开发应用程序的每一件事都是一种权衡。无论如何，我们需要快速识别强制解包导致的崩溃，以免浪费额外的时间试图找出出了什么问题。
- en: 'When an app tries to unwrap a nil value, if you are currently debugging the
    app, Xcode will show you the line that is trying to do the unwrapping. The line
    will report that there was an **EXC_BAD_INSTRUCTION** error and you will also
    get a message in the console saying **fatal error: unexpectedly found nil while
    unwrapping an Optional value**:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序尝试解包一个nil值时，如果你当前正在调试应用程序，Xcode会显示尝试解包的行。该行会报告存在一个**EXC_BAD_INSTRUCTION**错误，你也会在控制台中收到一条消息，说**致命错误：在解包可选值时意外发现nil**：
- en: '![Debugging optionals](img/B05103_04_01.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![调试可选类型](img/B05103_04_01.jpg)'
- en: You will also sometimes have to look at what code is currently calling the code
    that failed. To do that, you can use the call stack in Xcode. The call stack is
    the full path of all function calls that got to this location. So, if you have
    `function1` call `function2`, which then calls `function3`, `function3` will be
    at the top and `function1` will be at the bottom. Once the execution exits `function3`,
    it will be removed from the stack so you will just have `function2` on top of
    `function1`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你有时还必须查看当前正在调用失败代码的代码。为此，你可以使用Xcode中的调用栈。调用栈是所有到达此位置的功能调用的完整路径。所以，如果你有`function1`调用`function2`，然后`function2`调用`function3`，`function3`将在顶部，`function1`将在底部。一旦执行退出`function3`，它将从栈中移除，所以你将只有`function2`在`function1`的顶部。
- en: 'When your program crashes, Xcode will automatically display the call stack,
    but you can also manually show it by navigating to **View** | **Navigators** |
    **Show Debug Navigator**. It will look similar to the following screenshot:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的程序崩溃时，Xcode会自动显示调用栈，但你也可以通过导航到**视图** | **导航器** | **显示调试导航器**来手动显示它。它看起来会类似于以下截图：
- en: '![Debugging optionals](img/B05103_04_02.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![调试可选参数](img/B05103_04_02.jpg)'
- en: Here, you can click around different levels of code to see the state of things.
    This will become even more important if the program is crashing within one of
    Apple's framework, where you do not have access to the code. In that case, you
    will want to move up the call stack to the point where your code called into the
    framework. You may also be able to look at the names of the functions to help
    you figure out what may have gone wrong.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以点击不同的代码级别来查看事物的状态。如果程序在Apple的框架中崩溃，而你无法访问代码，这将变得更加重要。在这种情况下，你可能需要将调用栈向上移动到你的代码调用框架的点。你也许还能够查看函数的名称，以帮助你弄清楚可能出了什么问题。
- en: 'Anywhere on the call stack, you can look at the state of the variables in the
    debugger, as shown:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用栈的任何地方，你都可以查看调试器中变量的状态，如下所示：
- en: '![Debugging optionals](img/B05103_04_03.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![调试可选参数](img/B05103_04_03.jpg)'
- en: If you do not see this variable's view, you can display it by clicking on the
    button in the bottom-right corner of the screen, second from the right that will
    be grayed out. Here, you can see that `invitee` is indeed nil, which is what caused
    the crash.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看不到这个变量的视图，你可以通过点击屏幕右下角第二个从右边的按钮来显示它，该按钮将被灰色显示。在这里，你可以看到`invitee`确实是nil，这就是导致崩溃的原因。
- en: As powerful as the debugger is, if you find that it isn't helping you find the
    problem, you can always put `print` statements in important parts of the code.
    It is always safe to print out an optional, as long as you don't forcefully unwrap
    it as shown in the preceding example. As we have seen before, when an optional
    is printed, it will print **nil** if it doesn't have a value, or it will print
    **Optional(<value>)** if it has a value.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然调试器非常强大，但如果发现它没有帮助你找到问题，你可以在代码的重要部分添加`print`语句。只要你不像前一个例子那样强制展开可选参数，打印可选参数总是安全的。正如我们之前看到的，当可选参数被打印时，如果没有值，它会打印**nil**，如果有值，它会打印**Optional(<value>)**。
- en: Debugging is an extremely important part of becoming a productive developer
    because we all make mistakes and create bugs. Being a great developer means that
    you can identify problems quickly and understand how to fix them soon after that.
    This will largely come from practice, but it will also come from having a firm
    grasp of what is really happening with your code versus simply adapting some code
    you find online to fit your needs through trial and error.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 调试是成为一名高效开发者极其重要的部分，因为我们都会犯错误并创建bug。成为一名优秀的开发者意味着你能够快速识别问题，并在之后很快地理解如何修复它们。这主要来自于实践，但也会来自于对你代码的实际运行情况有牢固的掌握，而不是简单地通过试错来适应你在网上找到的代码以适应你的需求。
- en: The underlying implementation
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本实现
- en: At this point, you should have a pretty strong grasp of what an optional is
    and how to use and debug it, but it will be valuable to look a little deeper at
    optionals to see how they actually work.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该已经对可选参数有了相当强的理解，以及如何使用和调试它，但深入了解一下可选参数的实际工作原理将非常有价值。
- en: In reality, the question mark syntax for optionals is just special shorthand.
    Writing `String?` is equivalent to writing `Optional<String>`. Writing `String!`
    is equivalent to writing `ImplicitlyUnwrappedOptional<String>`. The Swift compiler
    has the shorthand versions because they are so commonly used. This allows the
    code to be more concise and readable.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，可选类型的问号语法只是一个特殊的缩写。写`String?`相当于写`Optional<String>`。写`String!`相当于写`ImplicitlyUnwrappedOptional<String>`。Swift编译器有简写版本，因为它们非常常用。这使得代码更加简洁易读。
- en: 'If you declare an optional using the long form, you can see Swift''s implementation
    by holding *Command* and clicking on the word **Optional**. Here, you can see
    that `Optional` is implemented as an enumeration. Simplifying the code a little,
    we have:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用长形式声明一个可选类型，你可以通过按住*Command*键并点击单词**Optional**来查看Swift的实现。在这里，你可以看到`Optional`被实现为一个枚举。稍微简化一下代码，我们有：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'So we can see that an optional really has two cases: `None` and `Some`. `None`
    stands for the nil case, while the `Some` case has an associated value, which
    is the value wrapped inside the optional. Unwrapping is the process of retrieving
    the associated value out of the `Some` case.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以看到可选类型实际上有两种情况：`None`和`Some`。`None`代表nil的情况，而`Some`情况有一个关联的值，即可选类型中包裹的值。解包是检索`Some`情况中关联值的过程。
- en: The one part of this that you have not seen yet is the angled bracket syntax
    (`<T>`). This is called a **generic** and it essentially allows the enumeration
    to have an associated value of any type. We will cover generics in-depth in [Chapter
    6](ch06.html "Chapter 6. Make Swift Work For You – Protocols and Generics"), *Make
    Swift Work For You – Protocols and Generics*.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分你还没有看到的是角度括号语法（`<T>`）。这被称为**泛型**，它本质上允许枚举具有任何类型的关联值。我们将在[第6章](ch06.html
    "第6章。让Swift为你工作 – 协议和泛型")*让Swift为你工作 – 协议和泛型*中深入探讨泛型。
- en: Realizing that optionals are simply enumerations will help you understand how
    to use them. It also gives you some insight into how concepts are built on top
    of other concepts. Optionals seem really complex until you realize that they are
    just a two case enumeration. Once you understand enumerations, you can pretty
    easily understand optionals as well.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 认识到可选类型仅仅是枚举将帮助你理解如何使用它们。这也让你对概念是如何建立在其他概念之上的有了更深的洞察。可选类型在你意识到它们只是两个情况的枚举之前看起来非常复杂。一旦你理解了枚举，你就可以很容易地理解可选类型了。
- en: Summary
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have only covered a single concept, optionals, in this chapter, but we have
    seen that this is a pretty dense topic. We have seen that at the surface level,
    optionals are pretty straightforward. They are a way to represent a variable that
    has no value. However, there are multiple ways to get access to the value wrapped
    within an optional that have very specific use cases. Optional binding is always
    preferred, as it is the safest method, but we can also use forced unwrapping if
    we are confident that an optional is not nil. We also have a type called implicitly
    unwrapped optional, to delay the assigning of a variable that is not intended
    to be optional; however, we should use it sparingly because there is almost always
    a better alternative.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们只覆盖了单个概念，即可选类型，但我们已经看到这是一个相当密集的话题。我们看到在表面层面上，可选类型相当直接。它们是一种表示没有值的变量的方式。然而，有多种方法可以访问可选类型中包裹的值，并且它们有非常特定的用例。可选绑定始终是首选，因为它是最安全的方法，但如果我们确信可选类型不是nil，我们也可以使用强制解包。我们还有一个名为隐式解包可选的类型，用于延迟分配一个不打算是可选的变量；然而，我们应该谨慎使用它，因为几乎总是有更好的替代方案。
- en: Now that we have a firm understanding of optionals, we can begin to look at
    something else that may appear minor on the surface but actually opens up a whole
    world of possibilities. All functions in Swift are actually variables or constants
    themselves. We will explore what this means in the next chapter.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对可选类型有了牢固的理解，我们可以开始看看表面上可能看似微不足道但实际上开启了一个全新世界的东西。Swift中的所有函数实际上都是变量或常量本身。我们将在下一章探讨这意味着什么。
