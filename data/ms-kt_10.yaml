- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Debugging Your App
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试您的应用
- en: Debugging is a very important aspect of developing apps. It helps us identify
    and fix bugs in our code. It is a very important skill to have as a developer.
    It also helps us avoid bugs in the future. Many tools can help us debug our code.
    In this chapter, we will be looking at some of the tools that can help us debug
    our code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 调试是开发应用的重要方面。它帮助我们识别和修复代码中的错误。对于开发者来说，这是一项非常重要的技能。它还有助于我们避免未来的错误。许多工具可以帮助我们调试代码。在本章中，我们将探讨一些可以帮助我们调试代码的工具。
- en: In this chapter, we will learn debugging tips and tricks, how to detect leaks
    using LeakCanary, how to inspect network requests/responses fired by our app using
    Chucker, and how to inspect our Room database, network requests, and background
    tasks using App Inspection.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习调试技巧和窍门，如何使用 LeakCanary 检测泄漏，如何使用 Chucker 检查我们应用发出的网络请求/响应，以及如何使用
    App Inspection 检查我们的 Room 数据库、网络请求和后台任务。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: General debugging tips and tricks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用调试技巧和窍门
- en: Detecting leaks with LeakCanary
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 LeakCanary 检测泄漏
- en: Inspecting network requests with Chucker
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Chucker 检查网络请求
- en: Using App Inspection
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 App Inspection
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the instructions in this chapter, you will need to have Android Studio
    Hedgehog or later ([https://developer.android.com/studio](https://developer.android.com/studio))
    downloaded.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章的说明，您需要下载 Android Studio Hedgehog 或更高版本([https://developer.android.com/studio](https://developer.android.com/studio))。
- en: You can use the previous chapter’s code to follow the instructions in this chapter.
    You can find the code for this chapter at [https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterten](https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterten).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用上一章的代码来遵循本章的说明。您可以在[https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterten](https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterten)找到本章的代码。
- en: General debugging tips and tricks
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用调试技巧和窍门
- en: 'Android Studio provides us with a variety of features that help us debug our
    code. Some of the features are listed in the following points:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio 提供了各种功能，帮助我们调试代码。以下列出了其中的一些功能：
- en: '**Logcat**'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Logcat**'
- en: '**Stack Traces**'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**堆栈跟踪**'
- en: '**Breakpoints**'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断点**'
- en: Let us look at each of these closely.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一仔细看看这些内容。
- en: Logcat
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Logcat
- en: 'Logcat in Android Studio displays log messages in real-time from our apps.
    Each log message has a priority level attached to it. We add log messages in our
    app using the `Log` class. This class offers different priority levels that we
    can use to log messages. The different priority levels are as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio 中的 Logcat 实时显示来自我们应用的日志消息。每个日志消息都附加了一个优先级级别。我们使用 `Log` 类在我们的应用中添加日志消息。这个类提供了我们可以用来记录消息的不同优先级。不同的优先级如下：
- en: '**V**: Verbose (lowest priority)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**V**: 详述（最低优先级）'
- en: '**D**: Debug'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D**: 调试'
- en: '**I**: Info'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I**: 信息'
- en: '**W**: Warning'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**W**: 警告'
- en: '**E**: Error'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**E**: 错误'
- en: '**F**: Fatal'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**F**: 致命'
- en: '**S**: Silent (highest priority)'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S**: 静默（最高优先级）'
- en: 'We use the preceding letters to specify the log level. For example, if we want
    to log a message with the debug level, we will use the following code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用前面的字母来指定日志级别。例如，如果我们想以调试级别记录一条消息，我们将使用以下代码：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The first parameter is the tag. The tag is used to identify the source of a
    log message. The second parameter is the message that we want to log. Each time
    we run our app, Logcat shows up at the bottom of the Android Studio window, as
    shown in the following figure:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是标签。标签用于识别日志消息的来源。第二个参数是我们想要记录的消息。每次我们运行我们的应用时，Logcat 都会在 Android Studio
    窗口的底部显示，如下面的图所示：
- en: '![Figure 10.1 – Logcat](img/B19779_10_01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1 – Logcat](img/B19779_10_01.jpg)'
- en: Figure 10.1 – Logcat
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – Logcat
- en: 'From the preceding figure, we can see at the top that the Logcat window shows
    the device we are running our app on. In this case, we are running our app on
    a **Pixel 6 Pro API 33** emulator; yours can be different depending on the emulator
    you have installed. Next to the device, we can see the **package** of the app
    we are running. This has a search bar that allows us to search for specific logs
    with their tags. Below the search are the actual logs. We can see that each log
    has a tag, the priority level, the package name of the app, the time the log was
    created, and the message. We can also see that the logs are color-coded. To see
    all the color settings for our Logcat, we go to **Settings** | **Editor** | **Color
    Scheme** | **Android Logcat**, which shows the color settings as shown in the
    following figure:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图中，我们可以看到顶部显示的是我们在其上运行应用的设备。在这种情况下，我们正在一个**Pixel 6 Pro API 33**模拟器上运行我们的应用；这取决于你安装的模拟器，你的可能不同。在设备旁边，我们可以看到我们正在运行的应用的**包名**。这里有一个搜索栏，允许我们通过它们的标签搜索特定的日志。在搜索栏下方是实际的日志。我们可以看到每个日志都有一个标签，优先级级别，应用的包名，日志创建的时间，以及消息。我们还可以看到日志是彩色的。要查看我们Logcat的所有颜色设置，我们转到**设置**
    | **编辑器** | **颜色方案** | **Android Logcat**，如图下所示：
- en: '![Figure 10.2 – Logcat color settings](img/B19779_10_02.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2 – Logcat颜色设置](img/B19779_10_02.jpg)'
- en: Figure 10.2 – Logcat color settings
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – Logcat颜色设置
- en: This way, we can set a color scheme for our Logcat. In the preceding figure,
    the color scheme has been set to **Classic Light**. There is a list that shows
    the colors for each log level, and you can change the color for each log level.
    We can also change the font style and size for our Logcat.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以为我们的Logcat设置颜色方案。在先前的图中，颜色方案已被设置为**经典亮色**。有一个列表显示了每个日志级别的颜色，你可以为每个日志级别更改颜色。我们还可以更改Logcat的字体样式和大小。
- en: 'With this, let us see how to create our first Logcat message. Let us head over
    to the `MainActivity.kt` file and add a log message in the `onCreate()` method
    as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何创建我们的第一个Logcat消息。让我们转到`MainActivity.kt`文件，并在`onCreate()`方法中添加以下日志消息：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Run the app and add `First Log` as a search query in the search bar:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用并在搜索栏中添加`First Log`作为搜索查询：
- en: '![Figure 10.3 – Logcat search](img/B19779_10_03.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3 – Logcat搜索](img/B19779_10_03.jpg)'
- en: Figure 10.3 – Logcat search
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – Logcat搜索
- en: This only shows the log message that has the tag **First Log**. This is particularly
    useful when we have a lot of logs, and we want to search for a specific log.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这只显示带有标签**First Log**的日志消息。当我们有很多日志，并且想要搜索特定日志时，这特别有用。
- en: Stack traces
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 堆栈跟踪
- en: A **stack trace** is a list of method calls from the point where the app was
    started to the point where the exception was thrown. It is extremely useful in
    helping us identify the cause of an exception. Stack traces are normally displayed
    in Logcat.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**堆栈跟踪**是从应用开始到异常抛出点的调用方法列表。它在帮助我们识别异常原因方面非常有用。堆栈跟踪通常在Logcat中显示。'
- en: 'To be able to see our first stack trace, let us head over to the `MainActivity.kt`
    file and add the following code in the `onCreate()` method:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够看到我们的第一个堆栈跟踪，让我们转到`MainActivity.kt`文件，并在`onCreate()`方法中添加以下代码：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding code will cause the app to crash when you run it. The app crashes
    immediately after executing the preceding code, and by checking our Logcat, we
    should be able to see the stack trace:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码会在运行应用时导致应用崩溃。应用在执行上述代码后立即崩溃，通过检查我们的Logcat，我们应该能够看到堆栈跟踪：
- en: '![Figure 10.4 – Crash stack trace](img/B19779_10_04.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4 – 崩溃堆栈跟踪](img/B19779_10_04.jpg)'
- en: Figure 10.4 – Crash stack trace
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – 崩溃堆栈跟踪
- en: As shown in the preceding figure, the stack trace shows the exception or reason
    for the crash. Additionally, it shows the class and method where the exception
    was thrown. It also shows the line number where the exception was thrown. This
    is particularly useful in helping us identify the cause of the exception. We can
    click on the line number directly and it will take us to the line of code where
    the exception was thrown.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，堆栈跟踪显示了异常或崩溃的原因。此外，它还显示了异常抛出的类和方法。它还显示了异常抛出的行号。这特别有助于我们识别异常原因。我们可以直接点击行号，它将带我们到抛出异常的代码行。
- en: The stack trace is a crucial tool in helping us debug our code and quickly detect
    crashes and the cause of crashes. Before moving on, remember to remove the code
    that throws the exception so that we can continue with the rest of the chapter.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈跟踪是帮助我们调试代码和快速检测崩溃及其原因的关键工具。在继续之前，请记住删除引发异常的代码，以便我们可以继续本章的其余部分。
- en: 'Android Studio allows us to copy and paste stack traces from a different source
    and see them in our Logcat. Copy the following stack trace:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio 允许我们从不同的来源复制和粘贴堆栈跟踪，并在我们的 Logcat 中查看它们。复制以下堆栈跟踪：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once you are done copying the stack trace, head over to the **Code** tab at
    the top of Android Studio and select **Analyze Stack Trace or Thread Dump**, paste
    the stack trace, and you will see the following dialog with the stack trace:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 完成复制堆栈跟踪后，转到 Android Studio 顶部的 **代码** 选项卡，选择 **分析堆栈跟踪或线程转储**，粘贴堆栈跟踪，您将看到以下带有堆栈跟踪的对话框：
- en: '![Figure 10.5 – Analyze stack trace](img/B19779_10_05.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.5 – 分析堆栈跟踪](img/B19779_10_05.jpg)'
- en: Figure 10.5 – Analyze stack trace
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5 – 分析堆栈跟踪
- en: This shows the preview of the stack trace we just pasted. Clicking on **OK**
    takes us to Logcat and shows us the stack trace as in *Figure 10**.4*
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了刚刚粘贴的堆栈跟踪的预览。点击 **确定** 将我们带到 Logcat，并显示与 *图 10.4* 中的堆栈跟踪相同的堆栈跟踪。
- en: Breakpoints
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 断点
- en: 'We use **breakpoints** to debug code for our apps. A breakpoint is a point
    in our code where we want the debugger to pause the execution of our code. This
    is useful when we are trying to find bugs that only appear under certain conditions.
    Android Studio allows us to add breakpoints to our code. We can add breakpoints
    to our code by clicking on the left side of the line number as shown in the following
    figure:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 **断点** 来调试我们的应用代码。断点是我们希望调试器暂停代码执行的位置。当我们试图找到只在特定条件下出现的错误时，这非常有用。Android
    Studio 允许我们在代码中添加断点。我们可以通过点击以下图中所示行号的左侧来添加断点：
- en: '![Figure 10.6 – Breakpoint](img/B19779_10_06.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.6 – 断点](img/B19779_10_06.jpg)'
- en: Figure 10.6 – Breakpoint
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 – 断点
- en: 'As shown in *Figure 10**.6*, a red circle is displayed when we add a breakpoint.
    To be able to see how the breakpoint works, we need to run the app in **debug
    mode**. We can do this by clicking on the **Debug** button:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 10.6* 所示，当我们添加断点时，会显示一个红色圆圈。为了能够看到断点的工作方式，我们需要以 **调试模式** 运行应用。我们可以通过点击
    **调试** 按钮来完成此操作：
- en: '![Figure 10.7 – Debug app](img/B19779_10_07.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.7 – 调试应用](img/B19779_10_07.jpg)'
- en: Figure 10.7 – Debug app
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7 – 调试应用
- en: 'Since the breakpoint is on the `onCreate()` method, the debugger will pause
    the execution of our code at the breakpoint. Android Studio will highlight the
    line where the breakpoint is:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于断点设置在 `onCreate()` 方法上，调试器将在断点处暂停我们的代码执行。Android Studio 将突出显示断点所在的行：
- en: '![Figure 10.8 – Line breakpoint](img/B19779_10_08.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.8 – 行断点](img/B19779_10_08.jpg)'
- en: Figure 10.8 – Line breakpoint
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8 – 行断点
- en: 'It also shows a **Debug** window at the bottom:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 它还在底部显示一个 **调试** 窗口：
- en: '![Figure 10.9 – Debug window](img/B19779_10_09.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.9 – 调试窗口](img/B19779_10_09.jpg)'
- en: Figure 10.9 – Debug window
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9 – 调试窗口
- en: The **Debug** window shows us the variables that are in the scope of the breakpoint.
    We can also see the call stack, which shows us the methods that have been called
    before the breakpoint. We can also see the threads that are running in our app.
    We can also see the breakpoints that we have added to our code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**调试** 窗口显示断点作用域内的变量。我们还可以看到调用堆栈，它显示了在断点之前被调用的方法。我们还可以看到应用中正在运行的线程。我们还可以看到添加到代码中的断点。'
- en: 'The **Debug** window has some buttons at the top that are immensely helpful
    in debugging our code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**调试** 窗口顶部有一些按钮，在调试代码时非常有帮助：'
- en: '![Figure 10.10 – Debug window buttons](img/B19779_10_10.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.10 – 调试窗口按钮](img/B19779_10_10.jpg)'
- en: Figure 10.10 – Debug window buttons
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.10 – 调试窗口按钮
- en: 'The buttons are as highlighted in *Figure 10**.10*. Starting from the left
    to right, the buttons are:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮如 *图 10.10* 中所示突出显示。从左到右，按钮依次为：
- en: '**Show execution point**: This button shows the line of code where the debugger
    is paused'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显示执行点**：此按钮显示调试器暂停的代码行'
- en: '**Step Over**: This button allows us to execute the current line of code and
    move to the next line of code'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单步执行**：此按钮允许我们执行当前代码行并移动到下一行代码'
- en: '**Step Into**: This button allows us to step into a method call'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进入**：此按钮允许我们进入方法调用'
- en: '**Step Out**: This button allows us to step out of a method call'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跳出**：此按钮允许我们从方法调用中退出'
- en: '**Run to Cursor**: This button allows us to run the code until the cursor reaches
    the line of code where the cursor is'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行到光标处**：此按钮允许我们运行代码，直到光标到达光标所在的代码行'
- en: On the left of the **Debug** window, we can also see the **Play** and **Stop**
    buttons. The **Play** button allows us to resume the execution of our code and
    continue the debugging session until the next breakpoint or until the program
    completes execution. To learn more about breakpoints, visit the official documentation
    at [https://developer.android.com/studio/debug](https://developer.android.com/studio/debug).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **调试** 窗口的左侧，我们还可以看到 **播放** 和 **停止** 按钮。**播放** 按钮允许我们恢复代码的执行并继续调试会话，直到下一个断点或程序完成执行。要了解更多关于断点的信息，请访问官方文档
    [https://developer.android.com/studio/debug](https://developer.android.com/studio/debug)。
- en: In this section, we have learned about the different debugging options available
    in Android Studio. We learned about Logcat, stack traces, and breakpoints. We
    have also learned how to use these tools to debug our code. In the next section,
    we will learn about a different debugging tool, LeakCanary, and how to use it
    to detect memory leaks in our apps.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了 Android Studio 中可用的不同调试选项。我们学习了 Logcat、堆栈跟踪和断点。我们还学习了如何使用这些工具来调试我们的代码。在下一节中，我们将学习另一个调试工具
    LeakCanary 以及如何使用它来检测我们应用中的内存泄漏。
- en: Detecting memory leaks with LeakCanary
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 LeakCanary 检测内存泄漏
- en: '**LeakCanary** is an open-source library developed by Square that helps us
    detect memory leaks in our apps. The library has knowledge of the internals of
    the Android Framework that allows it to narrow down the cause of the memory leak.
    It helps reduce the **Application Not Responding** (**ANR**) errors and **out-of-memory
    crashes** in our apps. Here are some of the most common causes of memory leaks:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**LeakCanary** 是由 Square 开发的一个开源库，帮助我们检测应用中的内存泄漏。该库了解 Android 框架的内部结构，使其能够缩小内存泄漏的原因。它有助于减少我们应用中的
    **应用无响应** （**ANR**） 错误和 **内存不足崩溃**。以下是一些最常见内存泄漏原因：'
- en: Storing instances of `Activity` as `Context` filed in an object that survives
    activity recreation due to configuration changes
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `Activity` 实例存储为对象中的 `Context` 字段，该对象因配置更改而存活，从而重新创建活动
- en: Forgetting to unregister broadcast receivers, listeners, callbacks, or RxJava
    subscriptions when they are no longer needed
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忘记在不再需要时注销广播接收器、监听器、回调或 RxJava 订阅
- en: Storing references to `Context` in a background thread
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在后台线程中存储对 `Context` 的引用
- en: 'LeakCanary is quite easy to set up and no code implementation is needed to
    use it. We just need to add the `leakcanary-android` dependency in our `libs.version.toml`
    file:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: LeakCanary 非常容易设置，使用它不需要代码实现。我们只需在我们的 `libs.version.toml` 文件中添加 `leakcanary-android`
    依赖项：
- en: '[PRE4]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Tap the `build.gradle.kts` file:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 `build.gradle.kts` 文件：
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We have added the dependency using the `debugImplementation` configuration
    so that it is only added to debug builds. This is because LeakCanary is only used
    for debugging purposes. We can now run our app and see how LeakCanary works. A
    separate app will be installed on our device or emulator as shown in the following
    figure:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已使用 `debugImplementation` 配置添加了依赖项，因此它仅添加到调试构建中。这是因为 LeakCanary 仅用于调试目的。我们现在可以运行我们的应用并查看
    LeakCanary 的运行情况。如以下图所示，将在我们的设备或模拟器上安装一个单独的应用程序：
- en: '![Figure 10.11 – Leaks app](img/B19779_10_11.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.11 – 泄漏应用](img/B19779_10_11.jpg)'
- en: Figure 10.11 – Leaks app
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.11 – 泄漏应用
- en: 'Opening the app brings up the following screen:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 打开应用会显示以下屏幕：
- en: '![Figure 10.12 – LeakCanary screen](img/B19779_10_12.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.12 – LeakCanary 屏幕截图](img/B19779_10_12.jpg)'
- en: Figure 10.12 – LeakCanary screen
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.12 – LeakCanary 屏幕截图
- en: The screen shows the **Leaks**, **Heap Dumps**, and **About** tabs. The **Leaks**
    tab shows us the memory leaks that have been detected in our app. The **Heap Dumps**
    tab shows us the heap dumps that have been taken. The **About** tab shows us the
    version of LeakCanary we are using as well as general information. For now, there
    is no memory leak detected. When a memory leak is detected, LeakCanary will generate
    a notification or log output with detailed information about the memory leak.
    This information helps us identify the cause of the memory leak and fix it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕显示了 **泄漏**、**堆转储** 和 **关于** 选项卡。**泄漏** 选项卡显示了在我们应用中检测到的内存泄漏。**堆转储** 选项卡显示了已捕获的堆转储。**关于**
    选项卡显示了我们所使用的 LeakCanary 版本以及一般信息。目前，没有检测到内存泄漏。当检测到内存泄漏时，LeakCanary 将生成一个通知或日志输出，其中包含有关内存泄漏的详细信息。这些信息帮助我们识别内存泄漏的原因并修复它。
- en: 'Let us now create a memory leak in our app and see how LeakCanary works:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在我们的应用中创建一个内存泄漏，并看看 LeakCanary 是如何工作的：
- en: 'Create a new file inside the `com.packt.chapterten` package and call it `LeakCanaryTest.kt`.
    Add the following code to the file:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `com.packt.chapterten` 包内创建一个新文件，并将其命名为 `LeakCanaryTest.kt`。将以下代码添加到文件中：
- en: '[PRE6]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, we have created a class called `LeakCanaryTest` and another
    class called `LeakTestUtils`, with a companion object that stores the `LeakCanaryTest`
    singleton in a static field.
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个名为 `LeakCanaryTest` 的类和一个名为 `LeakTestUtils` 的类，其中包含一个伴生对象，该对象将
    `LeakCanaryTest` 单例存储在一个静态字段中。
- en: 'Let us now head over to the `MainActivity.kt` file and add the following code
    in the `onCreate()` code:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们转到 `MainActivity.kt` 文件，并在 `onCreate()` 代码中添加以下代码：
- en: '[PRE7]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, we are telling LeakCanary that the singleton instance
    of `LeakCanaryTest` will be garbage collected.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们正在告诉 LeakCanary，`LeakCanaryTest` 的单例实例将被垃圾回收。
- en: 'Let us run the app. We can see that LeakCanary has detected a memory leak and
    shows a notification as seen in the following figure:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行应用。我们可以看到 LeakCanary 检测到了内存泄漏，并显示了一个通知，如图所示：
- en: '![Figure 10.13 – Memory leak notification](img/B19779_10_13.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.13 – 内存泄漏通知](img/B19779_10_13.jpg)'
- en: Figure 10.13 – Memory leak notification
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.13 – 内存泄漏通知
- en: 'Click on the notification and it will take us to the LeakCanary app where we
    can see the details of the memory leak:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击通知，它将带我们到 LeakCanary 应用，在那里我们可以看到内存泄漏的详细信息：
- en: '![Figure 10.14 – Memory leak details](img/B19779_10_14.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.14 – 内存泄漏详情](img/B19779_10_14.jpg)'
- en: Figure 10.14 – Memory leak details
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.14 – 内存泄漏详情
- en: As shown in the preceding figure, LeakCanary shows the location of the memory
    leak and underlines the objects causing the leak. In this case, it is the `leakCanaryTest`
    object that is causing the memory leak. Every time we get a memory leak, we will
    receive such detailed information.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，LeakCanary 显示了内存泄漏的位置，并下划线了导致泄漏的对象。在这种情况下，是 `leakCanaryTest` 对象导致了内存泄漏。每次我们遇到内存泄漏时，我们都会收到这样的详细信息。
- en: Remember to remove the code that causes the memory leak in the `MainActivity`
    `onCreate()` method so that we can continue with the rest of the chapter.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 记得从 `MainActivity` 的 `onCreate()` 方法中移除导致内存泄漏的代码，这样我们就可以继续本章的其余部分。
- en: We have learned about LeakCanary and how to use it to detect memory leaks in
    our apps. You can learn more about LeakCanary at [https://square.github.io/leakcanary/](https://square.github.io/leakcanary/).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了 LeakCanary 以及如何使用它来检测应用中的内存泄漏。您可以在 [https://square.github.io/leakcanary/](https://square.github.io/leakcanary/)
    上了解更多关于 LeakCanary 的信息。
- en: In the next section, we will learn about Chucker, another debugging tool that
    helps us inspect network requests in our apps.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将了解 Chucker，另一个调试工具，它帮助我们检查应用中的网络请求。
- en: Inspecting network requests with Chucker
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Chucker 检查网络请求
- en: 'This is from the Chucker GitHub ([https://github.com/ChuckerTeam/chucker](https://github.com/ChuckerTeam/chucker))
    page:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从 Chucker GitHub ([https://github.com/ChuckerTeam/chucker](https://github.com/ChuckerTeam/chucker))
    页面获取的：
- en: Chucker simplifies the inspection of HTTP(S) requests/responses fired by our
    Android apps. Chucker works as an OkHttp Interceptor persisting all those events
    inside our application, and providing a UI for inspecting and sharing their content.
    Chucker displays a notification showing a summary of the ongoing network request.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Chucker 简化了检查我们 Android 应用发出的 HTTP(S) 请求/响应的过程。Chucker 作为 OkHttp Interceptor，将所有这些事件持久化在我们的应用中，并提供一个
    UI 来检查和分享它们的内容。Chucker 显示一个通知，显示当前网络请求的摘要。
- en: Tapping the Chucker notification mentioned previously launches the Chucker UI.
    Chucker UI shows a list of all the network requests that have been made by our
    app. We can tap on a request to see the details of the request.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 点击前面提到的 Chucker 通知将启动 Chucker UI。Chucker UI 显示了我们的应用发出的所有网络请求的列表。我们可以点击一个请求来查看请求的详细信息。
- en: 'To use Chucker, follow these steps:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Chucker，请按照以下步骤操作：
- en: 'Add the `chucker` dependency in the `libs.versions.toml` file:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `libs.versions.toml` 文件中添加 `chucker` 依赖项：
- en: '[PRE8]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding code, we have added two dependencies: the first one is the
    Chucker library, and the second one is a no-op library variant to isolate Chucker
    from release builds since we only want to see the requests on debug builds.'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们添加了两个依赖项：第一个是 Chucker 库，第二个是一个无操作库变体，用于将 Chucker 从发布构建中隔离出来，因为我们只想在调试构建中看到请求。
- en: Tap the **Sync Now** button at the top to sync the project.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击顶部的 **Sync Now** 按钮以同步项目。
- en: 'Next, we need to add the dependency in our app’s `build.gradle.kts` file:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要在我们的应用程序的 `build.gradle.kts` 文件中添加依赖项：
- en: '[PRE9]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Tap **Sync Now** at the top. This will add the Chucker dependency in debug builds
    only.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶部点击**立即同步**。这将仅在调试构建中添加 Chucker 依赖项。
- en: 'Next, we need to create a new `OkHttp` client and add the Chucker interceptor
    to it. Let us head over to the `Modules.kt` file and add the following module
    to the `appModules` module block:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个新的 `OkHttp` 客户端并将 Chucker 拦截器添加到其中。让我们转到 `Modules.kt` 文件并添加以下模块到
    `appModules` 模块块：
- en: '[PRE10]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following explains the preceding code:'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面的代码解释了前面的代码：
- en: We have created a `ChuckerCollector` instance and passed in the `context`, `showNotification`,
    and `retentionPeriod` parameters. The `context` is the Android context, `showNotification`
    is a boolean that determines whether to show a notification when a request is
    made, and `retentionPeriod` is the period for which the data is kept. In this
    case, we keep the data for one hour.
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个 `ChuckerCollector` 实例，并传递了 `context`、`showNotification` 和 `retentionPeriod`
    参数。`context` 是 Android 上下文，`showNotification` 是一个布尔值，用于确定在发出请求时是否显示通知，而 `retentionPeriod`
    是数据保留的期限。在这种情况下，我们保留数据一小时。
- en: We have created a `ChuckerInterceptor` instance and passed in the `context`,
    `collector`, `maxContentLength`, `redactHeaders`, and `alwaysReadResponseBody`
    parameters. The `context` is the Android context, `collector` is the `ChuckerCollector`
    instance we created previously, `maxContentLength` is the maximum length of the
    response body, `redactHeaders` is a set of headers to replace with `**` and `alwaysReadResponseBody`
    is a boolean that determines whether to always read the response body.
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个 `ChuckerInterceptor` 实例，并传递了 `context`、`collector`、`maxContentLength`、`redactHeaders`
    和 `alwaysReadResponseBody` 参数。`context` 是 Android 上下文，`collector` 是我们之前创建的 `ChuckerCollector`
    实例，`maxContentLength` 是响应体的最大长度，`redactHeaders` 是一组用 `**` 替换的头，而 `alwaysReadResponseBody`
    是一个布尔值，用于确定是否始终读取响应体。
- en: We have created an `OkHttpClient` instance and added the `ChuckerInterceptor`
    to it.
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个 `OkHttpClient` 实例并添加了 `ChuckerInterceptor`。
- en: We can now use the `OkHttpClient` instance to make network requests.
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在可以使用 `OkHttpClient` 实例来发出网络请求。
- en: 'Let us modify our `Retrofit` instance to use the `OkHttpClient` instance we
    just created. Still in the `Modules.kt` file, modify the Retrofit instance as
    follows:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们修改我们的 `Retrofit` 实例以使用我们刚刚创建的 `OkHttpClient` 实例。仍然在 `Modules.kt` 文件中，按如下方式修改
    Retrofit 实例：
- en: '[PRE11]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We have added the `client` parameter and passed it in the `OkHttpClient` instance
    we created previously using Koin’s `get()` call.
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们添加了 `client` 参数，并使用 Koin 的 `get()` 调用传递了我们之前创建的 `OkHttpClient` 实例。
- en: With that, our Chucker setup is now complete.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这样，我们的 Chucker 设置现在就完成了。
- en: 'Build and run the app. We can see that Chucker has detected the network request
    and shows a notification, as seen in the following figure:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行应用程序。我们可以看到 Chucker 已经检测到网络请求并显示了一个通知，如下图所示：
- en: '![Figure 10.15 – Chucker notification](img/B19779_10_15.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.15 – Chucker 通知](img/B19779_10_15.jpg)'
- en: Figure 10.15 – Chucker notification
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.15 – Chucker 通知
- en: From the preceding figure, we can see that Chucker has detected the network
    request and shows the status code, the method, and the URL of the request.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图中，我们可以看到 Chucker 已经检测到网络请求并显示了状态码、方法和请求的 URL。
- en: 'We can tap on the notification and it will take us to the Chucker UI:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以点击通知，它将带我们到 Chucker UI：
- en: '![Figure 10.16 – Chucker list of requests](img/B19779_10_16.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.16 – Chucker 请求列表](img/B19779_10_16.jpg)'
- en: Figure 10.16 – Chucker list of requests
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.16 – Chucker 请求列表
- en: This shows the list of the network requests that have been made by our app.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了我们的应用程序发出的网络请求列表。
- en: 'Tap on a request to see the details of the request:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击一个请求以查看请求的详细信息：
- en: '![Figure 10.17 – Chucker overview tab](img/B19779_10_17.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.17 – Chucker 概览标签页](img/B19779_10_17.jpg)'
- en: Figure 10.17 – Chucker overview tab
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.17 – Chucker 概览标签页
- en: 'The details screen has three tabs as shown in the preceding figure. The first
    tab is the **Overview** tab, which is shown in *Figure 10**.17*. The **Overview**
    tab shows the overview of the request. It shows the request details such as URL,
    method, response, duration, response size, and so on. The second tab is the **Request**
    tab, which shows the request headers and body:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，详情屏幕有三个标签页。第一个标签页是**概览**标签页，如图 *图 10**.17* 所示。**概览**标签页显示了请求的概览。它显示了请求的详细信息，如
    URL、方法、响应、持续时间、响应大小等。第二个标签页是**请求**标签页，它显示了请求头和正文：
- en: '![Figure 10.18 – Chucker request tab](img/B19779_10_18.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.18 – Chucker 请求标签页](img/B19779_10_18.jpg)'
- en: Figure 10.18 – Chucker request tab
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.18 – Chucker 请求选项卡
- en: 'For this request, the body is empty since it was a get request. The third tab
    is the **Response** tab, which shows the response headers and body:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个请求，由于它是一个 GET 请求，所以正文是空的。第三个选项卡是 **响应** 选项卡，它显示了响应头和正文：
- en: '![Figure 10.19 – Chucker response tab](img/B19779_10_19.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.19 – Chucker 响应选项卡](img/B19779_10_19.jpg)'
- en: Figure 10.19 – Chucker response tab
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.19 – Chucker 响应选项卡
- en: From the preceding figure, we can see the response headers and body in JSON
    format.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图中，我们可以看到以 JSON 格式显示的响应头和正文。
- en: The toolbar of the details screen has **Search**, **Share**, and **Save** buttons.
    The **Search** button allows us to search in either the request or the response.
    The **Share** button allows us to share the request or response details in JSON
    format. The **Save** button allows us to save the request or response details
    to a file.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 详细信息屏幕的工具栏有 **搜索**、**分享** 和 **保存** 按钮。**搜索** 按钮允许我们在请求或响应中进行搜索。**分享** 按钮允许我们以
    JSON 格式分享请求或响应的详细信息。**保存** 按钮允许我们将请求或响应的详细信息保存到文件中。
- en: Chucker is very helpful in debugging network requests in our apps. When non-technical
    teams test the debuggable version of our app, we can always tell them to share
    these requests, especially when they’re facing issues with their network requests.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Chucker 在调试我们应用中的网络请求方面非常有帮助。当非技术团队测试可调试版本的应用时，我们总是可以告诉他们分享这些请求，尤其是在他们遇到网络请求问题时。
- en: That’s it for Chucker. Every time our app makes a network request, Chucker will
    show a notification and we can tap on the notification to see the details of the
    request.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 Chucker 的全部内容。每次我们的应用发起网络请求时，Chucker 都会显示一个通知，我们可以点击通知来查看请求的详细信息。
- en: We have learned about Chucker and how to use it to inspect network requests
    in our apps. In the next section, we will learn how to use App Inspection to inspect
    our app’s room database and explore the features App Inspection offers.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了 Chucker 以及如何使用它来检查我们应用中的网络请求。在下一节中，我们将学习如何使用应用检查来检查我们应用的 Room 数据库并探索应用检查提供的功能。
- en: Using App Inspection
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用应用检查
- en: '**App Inspection** allows us to debug our database, inspect network traffic,
    and debug our background tasks. It is a very important tool in helping us debug
    our apps. To use App Inspection, let us run our app and then navigate to **View**
    | **Tool Windows** | **App Inspection** in Android Studio:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用检查**允许我们调试数据库、检查网络流量以及调试后台任务。它是帮助我们调试应用的一个非常重要的工具。要使用应用检查，让我们在 Android
    Studio 中运行我们的应用，然后导航到 **视图** | **工具窗口** | **应用检查**：'
- en: '![Figure 10.20 – App Inspection](img/B19779_10_20.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.20 – 应用检查](img/B19779_10_20.jpg)'
- en: Figure 10.20 – App Inspection
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.20 – 应用检查
- en: 'App Inspection automatically connects to our app. The first tab is **Database
    Inspector**. On the left, we can see the different databases created by our app.
    We have the WorkManager, Chucker, LeakCanary, and Cat databases that we created
    earlier on. Let us click on the **Cat** database, and we can see the columns of
    the table that we created in the database:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 应用检查会自动连接到我们的应用。第一个选项卡是 **数据库检查器**。在左侧，我们可以看到我们应用创建的不同数据库。我们有之前创建的工作管理器、Chucker、LeakCanary
    和 Cat 数据库。让我们点击 **Cat** 数据库，我们可以看到数据库中创建的表的列：
- en: '![Figure 10.21 – Cat database](img/B19779_10_21.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.21 – 猫数据库](img/B19779_10_21.jpg)'
- en: Figure 10.21 – Cat database
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.21 – 猫数据库
- en: 'This shows the columns and the values that have been saved in the database.
    We can also run queries in the database. The query option is highlighted in the
    following figure:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了数据库中已保存的列和值。我们也可以在数据库中运行查询。查询选项在以下图中突出显示：
- en: '![Figure 10.22 – Execute query button](img/B19779_10_22.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.22 – 执行查询按钮](img/B19779_10_22.jpg)'
- en: Figure 10.22 – Execute query button
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.22 – 执行查询按钮
- en: 'We want to run a query that shows the cats with a specific `id`. We can do
    this by running the following query:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想运行一个显示具有特定 `id` 的猫的查询。我们可以通过运行以下查询来完成此操作：
- en: '[PRE12]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can use a different `id` per the data you have. The query results will
    be as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以根据您拥有的数据使用不同的 `id`。查询结果将如下所示：
- en: '![Figure 10.23 – Query results](img/B19779_10_23.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.23 – 查询结果](img/B19779_10_23.jpg)'
- en: Figure 10.23 – Query results
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.23 – 查询结果
- en: The data has all the cats that have the ID we specified. One thing to note is
    to ensure that you execute the queries on the correct database, as shown in *Figure
    10**.23*. The database inspector helps us debug and write queries to our database
    and is very useful when working on apps that use a database.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包含所有具有我们指定的 ID 的猫咪。需要注意的是，确保你在正确的数据库上执行查询，如图 *图 10*.23 所示。数据库检查器帮助我们调试并编写查询到我们的数据库，当我们在使用数据库的应用上工作时非常有用。
- en: 'Let us now head over to the **Network Inspector** tab. This tab shows us the
    network requests that have been made by our app. We can see the request method,
    the URL, the status code, and the duration of the request:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转到 **网络检查器** 标签页。此标签页显示了我们的应用发出的网络请求。我们可以看到请求方法、URL、状态码和请求持续时间：
- en: '![Figure 10.24 – Network Inspector](img/B19779_10_24.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.24 – 网络检查器](img/B19779_10_24.jpg)'
- en: Figure 10.24 – Network Inspector
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.24 – 网络检查器
- en: From the preceding figure, we can see that the requests are for loading the
    cute cat images and all the details of the request. Similar to Chucker, it also
    has the request and response tabs that provide more information on the request.
    However, unlike Chucker, **Network Inspector** captures the network requests made
    by the app without any additional setup in the code. The **Network Inspector**
    tab is very useful in helping us debug network requests in our apps, especially
    when working on apps that make a lot of network requests.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图中，我们可以看到请求是用于加载可爱的猫咪图片以及请求的所有详细信息。与 Chucker 类似，它也有请求和响应标签页，提供了更多关于请求的信息。然而，与
    Chucker 不同，**网络检查器**可以在代码中无需任何额外设置的情况下捕获应用发出的网络请求。**网络检查器**标签页在帮助我们调试应用中的网络请求时非常有用，尤其是在处理发出大量网络请求的应用时。
- en: 'Lastly, let us head over to the **Background Task Inspector** tab. This tab
    shows us the background task requests that have been made by our app. Our app
    should show the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们转到 **背景任务检查器** 标签页。此标签页显示了我们的应用发出的背景任务请求。我们的应用应显示以下内容：
- en: '![Figure 10.25 – Background Task Inspector](img/B19779_10_25.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.25 – 背景任务检查器](img/B19779_10_25.jpg)'
- en: Figure 10.25 – Background Task Inspector
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.25 – 背景任务检查器
- en: The Background Task Inspector shows us the details of our background tasks.
    It has information for WorkManager `PetsSyncWorker` worker has succeeded. On the
    right are more details of the worker, as shown in *Figure 10**.25*. The details
    show the UUID, constraints, state, and results of the worker, such as the output
    data, number of retries, and the time it started. This information is very helpful
    to check whether our background tasks are running as expected.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 背景任务检查器显示了我们的背景任务的详细信息。它提供了 WorkManager `PetsSyncWorker` 工作者已成功的信息。在右侧是工作者更详细的信息，如图
    *图 10*.25 所示。这些详细信息显示了工作者的 UUID、约束、状态和结果，例如输出数据、重试次数以及开始时间。这些信息对于检查我们的背景任务是否按预期运行非常有帮助。
- en: Summary
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned some debugging tips and tricks, how to detect leaks
    using LeakCanary, how to inspect network requests/responses fired by our app using
    Chucker, and how to use App Inspection to debug our database, inspect our network
    requests, and inspect background tasks, too.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了一些调试技巧和窍门，如何使用 LeakCanary 检测泄漏，如何使用 Chucker 检查我们应用发出的网络请求/响应，以及如何使用
    App Inspection 调试我们的数据库、检查我们的网络请求以及检查背景任务。
- en: In the next chapter, we will learn Kotlin style and the best practices for writing
    Kotlin code. We will also learn how to use plugins such as Ktlint and Detekt to
    format, lint, and detect the code smells early.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习 Kotlin 风格和编写 Kotlin 代码的最佳实践。我们还将学习如何使用 Ktlint 和 Detekt 等插件来格式化、检查和早期检测代码异味。
