- en: '*Chapter 8*: Getting Started with Clean Architecture in Android'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 8 章*：Android 中开始使用 Clean Architecture'
- en: In this chapter, we're continuing our journey of improving the architectural
    design of the Restaurants application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们继续改进 Restaurants 应用程序的架构设计之旅。
- en: 'More specifically, we will try to adopt some design decisions from the well-known
    Clean Architecture. **Clean Architecture** is a software design philosophy that
    tries to create projects with the best level of the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，我们将尝试采用一些来自知名 Clean Architecture 的设计决策。**Clean Architecture** 是一种软件设计哲学，试图创建具有以下最佳水平的项目：
- en: Separation of concerns
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关注点的分离
- en: Testability
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可测试性
- en: Independence of frameworks or libraries used in peripheral layers, such as the
    UI or Model layer
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外围层（如 UI 或模型层）使用的框架或库的独立性
- en: By doing so, Clean Architecture tries to allow the business parts of our applications
    to adapt to changing technologies and interfaces.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，Clean Architecture 试图让我们的应用程序的业务部分能够适应不断变化的技术和接口。
- en: Clean Architecture is a very broad and complex topic, so, in this chapter, we
    will try to focus only on establishing a better separation of concerns by separating
    existing layers even further, but more importantly, by defining a new layer called
    the **Domain layer**.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Clean Architecture 是一个非常广泛且复杂的话题，因此，在本章中，我们将尝试仅通过进一步分离现有层来建立更好的关注点分离，但更重要的是，通过定义一个名为
    **领域层** 的新层。
- en: In this chapter, we will on one hand borrow some architectural decisions from
    Clean Architecture through the *Defining the Domain layer with Use Cases* section
    and the *Separating the Domain model from Data models* section. On the other hand,
    we will try to improve project architecture with other techniques through the
    *Creating a package structure* section and the *Decoupling the Compose-based UI
    layer from ViewModel* section.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将一方面通过 *使用用例定义领域层* 部分和 *将领域模型与数据模型分离* 部分借鉴 Clean Architecture 的一些架构决策。另一方面，我们将通过
    *创建包结构* 部分和 *将基于 Compose 的 UI 层与 ViewModel 解耦* 部分尝试使用其他技术改进项目架构。
- en: Another essential principle of Clean Architecture is the **Dependency Rule**
    that we will briefly cover in the *Further reading* section where you will find
    proper resources to follow up with.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Clean Architecture 的另一个基本原则是 **依赖规则**，我们将在 *进一步阅读* 部分简要介绍，在那里您将找到适当的资源以跟进。
- en: 'We will cover the following topics in this section:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将涵盖以下主题：
- en: Defining the Domain layer with Use Cases
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用用例定义领域层
- en: Separating the Domain model from Data models
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将领域模型与数据模型分离
- en: Creating a package structure
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建包结构
- en: Decoupling the Compose-based UI layer from ViewModel
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将基于 Compose 的 UI 层与 ViewModel 解耦
- en: Before jumping in, let's set up the technical requirements for this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入之前，让我们为本章设置技术要求。
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Building Compose-based Android projects for this chapter usually requires your
    day-to-day tools. However, to follow along smoothly, make sure you have the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为本章构建基于 Compose 的 Android 项目通常需要您日常使用的工具。然而，为了顺利跟进，请确保您拥有以下内容：
- en: The Arctic Fox 2020.3.1 version of Android Studio. You can also use a newer
    Android Studio version or even Canary builds, but note that the IDE interface
    and other generated code files might differ from the ones used throughout this
    book.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arctic Fox 2020.3.1 版本的 Android Studio。您也可以使用更新的 Android Studio 版本或甚至 Canary
    构建，但请注意，IDE 界面和其他生成的代码文件可能与本书中使用的不同。
- en: Kotlin 1.6.10 or a newer plugin installed in Android Studio
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装在 Android Studio 中的 Kotlin 1.6.10 或更高版本的插件
- en: The Restaurants app code from the previous chapter
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上一章的 Restaurants 应用程序代码
- en: The starting point for this chapter is represented by the Restaurants application
    developed in the previous chapter. If you haven't followed the implementation
    from the previous chapter, access the starting point for this chapter by navigating
    to the `Chapter_07` directory of the repository and importing the Android project
    titled `chapter_7_restaurants_app`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的起点由上一章开发的 Restaurants 应用程序表示。如果您没有跟随上一章的实施，请通过导航到存储库的 `Chapter_07` 目录并导入名为
    `chapter_7_restaurants_app` 的 Android 项目来访问本章的起点。
- en: 'To access the solution code for this chapter, navigate to the `Chapter_08`
    directory:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本章的解决方案代码，请导航到 `Chapter_08` 目录：
- en: '[https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_08/chapter_8_restaurants_app](https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_08/chapter_8_restaurants_app).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_08/chapter_8_restaurants_app](https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_08/chapter_8_restaurants_app).'
- en: Defining the Domain layer with Use Cases
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用用例定义领域层
- en: So far, we've talked about the Presentation layer (with UI and presentation
    logic) and the Model layer (with data logic). Yet, apart from these two layers,
    most of the time, applications also encapsulate a different type of logic, different
    from UI, presentation, or data logic.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了表示层（带有UI和表示逻辑）和模型层（带有数据逻辑）。然而，除了这两个层之外，大多数时候，应用程序还会封装一种不同类型的逻辑，这种逻辑不同于UI、表示或数据逻辑。
- en: To identify this type of logic, we must first acknowledge that most applications
    have a dedicated business scope – for example, a food delivery application could
    have the business scope of taking orders and generating revenue for the stakeholder.
    The **stakeholder** is the entity interested in the business, such as the company
    that owns the restaurant chain.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要识别这种逻辑，我们首先必须承认大多数应用程序都有一个专门的业务范围——例如，一个食品配送应用程序的业务范围可能是接受订单并为股东创造收入。**股东**是指对业务感兴趣的实体，例如拥有连锁餐厅的公司。
- en: Such applications can contain business rules imposed by the stakeholders that
    can vary from minimum order amounts, custom availability ranges for certain restaurants,
    or predefined time frames for different delivery charges; the list could go on.
    We can refer to such business rules that are dictated by stakeholders as **business
    logic**.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的应用程序可以包含由股东强加的业务规则，这些规则可能包括最低订单金额、某些餐厅的定制可用性范围或不同配送费用的预定义时间框架；这个列表可以继续下去。我们可以将这种由股东规定的业务规则称为**业务逻辑**。
- en: For our Restaurants app, let's imagine that the stakeholder (for example, the
    company we would be building the application for) asked us to always show the
    restaurants alphabetically, no matter what. This shouldn't be something that the
    user would know about; instead, it should be a predefined business rule that we
    must implement.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的餐厅应用程序，让我们想象一下，股东（例如，我们为该公司构建的应用程序）要求我们始终按字母顺序显示餐厅，无论什么情况。这不应该是什么用户会知道的事情；相反，它应该是一个预定义的业务规则，我们必须实现它。
- en: Now, sorting restaurants alphabetically isn't that big of a deal, so the natural
    question that arises is, where should we apply this sorting logic?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按字母顺序排序餐厅并不是什么大问题，所以自然而然出现的问题是，我们应该在哪里应用这种排序逻辑？
- en: To figure this out, let's recap the current layering of the project. Right now,
    the Presentation layer is connected to the Model layer.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了弄清楚这一点，让我们回顾一下项目的当前分层。目前，表示层连接到模型层。
- en: '![Figure 8.1 – Layering of responsibilities in the Restaurants app'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.1 – 餐厅应用程序的责任分层'
- en: '](img/B17788_08_01.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17788_08_01.jpg)'
- en: Figure 8.1 – Layering of responsibilities in the Restaurants app
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 餐厅应用程序的责任分层
- en: 'With our existing layer structuring, we could sort the restaurants in the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们现有的分层结构，我们可以在以下方面对餐厅进行排序：
- en: '**UI level (composables)**: Since this sorting logic is business logic, we
    should try to avoid adding it here.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UI级别（可组合项）**：由于这种排序逻辑是业务逻辑，我们应该尽量避免在这里添加它。'
- en: '`ViewModel` class; yet, remember that this rule is part of the business requirements,
    and the user shouldn''t know about it, so it''s probably not a good idea to implement
    it here.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewModel`类；然而，请记住，这个规则是业务需求的一部分，用户不应该知道这一点，所以在这里实现它可能不是一个好主意。'
- en: '**Inside the Repository**: Here, we store data logic (such as caching), which
    is different from business logic.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在存储库内部**：在这里，我们存储数据逻辑（例如缓存），这与业务逻辑不同。'
- en: 'None of the options are ideal, and we will see in a moment why this is the
    case. Until then, let''s have a compromise and add this business rule inside the
    Model layer:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何一种选择是理想的，我们很快就会看到为什么是这样。在此之前，让我们妥协一下，在模型层内部添加这个业务规则：
- en: 'Inside `RestaurantsRepository`, refactor the `getAllRestaurants()` method to
    sort the restaurants by `title` by calling the `sortedBy { }` extension function
    on the restaurants that are returned:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RestaurantsRepository`内部，重构`getAllRestaurants()`方法，通过在返回的餐厅上调用`sortedBy {
    }`扩展函数来按`title`排序餐厅：
- en: '[PRE0]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Build and run the application.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行应用程序。
- en: The restaurants are now correctly sorted by their title, yet if you toggle a
    restaurant as a favorite, you might notice an initial flicker and a re-ordering
    effect on the list. Can you guess why this has happened?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 餐厅现在已按标题正确排序，但如果你将餐厅切换为收藏夹，你可能会注意到列表上的初始闪烁和重新排序效果。你能猜到这是为什么吗？
- en: 'The issue here is that in `RestaurantsRepository`, the `toggleFavoriteRestaurant()`
    method returns the unsorted version of the restaurants from the **Data Access
    Object** (**DAO**):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，在`RestaurantsRepository`中，`toggleFavoriteRestaurant()`方法从**数据访问对象**（**DAO**）返回未排序的餐厅版本：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To fix this, we could repeat the same sorting logic from the `getAllRestaurants()`
    method.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以重复`getAllRestaurants()`方法中的相同排序逻辑。
- en: Yet, this approach is problematic because we would be repeating or duplicating
    the sorting business rule. Worse than that, since we are in the Model layer, we're
    mixing data logic with business logic. We shouldn't be mixing data caching logic
    with business rules.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法是有问题的，因为我们可能会重复或复制排序业务规则。更糟糕的是，由于我们处于模型层，我们将数据逻辑与业务逻辑混合在一起。我们不应该将数据缓存逻辑与业务规则混合。
- en: It's clear that for us to correctly encapsulate business logic and to be able
    to reuse it, we should extract it to a separate layer. Just like whenever we wanted
    to prevent any changes impacting the Presentation layer from affecting other layers,
    such as the UI or Model layers, we want to separate the business logic inside
    a separate layer so that any changes to the business logic shouldn't impact other
    layers and their corresponding logic.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，为了正确封装业务逻辑并能够重用，我们应该将其提取到单独的一层。就像我们想要防止任何对表示层的更改影响其他层，例如UI或模型层，我们希望将业务逻辑放在一个单独的层中，以便任何对业务逻辑的更改都不应影响其他层及其相应的逻辑。
- en: According to Clean Architecture concepts, the layer that encapsulates business
    rules and business logic is referred to as the Domain layer. This layer sits between
    the Presentation layer and the Model layer. It should process the data from the
    Model layer by applying the business rules that it incorporates, and then feed
    the Presentation layer with the business-compliant content.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 根据清洁架构的概念，封装业务规则和业务逻辑的层被称为领域层。该层位于表示层和模型层之间。它应该通过应用其包含的业务规则来处理模型层的数据，然后将符合业务规则的内容提供给表示层。
- en: '![Figure 8.2 – Layering of responsibilities in the Restaurants app, including
    the Domain layer'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.2 – 餐厅应用中的责任分层，包括领域层'
- en: '](img/B17788_08_02.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17788_08_02.jpg]'
- en: Figure 8.2 – Layering of responsibilities in the Restaurants app, including
    the Domain layer
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – 餐厅应用中的责任分层，包括领域层
- en: In other words, in a particular flow (as in the screen with the list of restaurants),
    the Presentation layer through the `ViewModel` would connect to the Domain layer
    instead of the Model layer. In turn, the Domain layer would get the data from
    the Model layer.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，在特定的流程中（例如，在包含餐厅列表的屏幕中），表示层将通过`ViewModel`连接到领域层而不是模型层。反过来，领域层将从模型层获取数据。
- en: Note
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Not all applications, screens, or flows contain business logic. For these cases,
    the Domain layer is optional. The Domain layer should hold business logic, but,
    if there is no such logic, there should be no such layer.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有应用程序、屏幕或流程都包含业务逻辑。对于这些情况，领域层是可选的。领域层应该包含业务逻辑，但如果不存在此类逻辑，则不应存在此类层。
- en: But what should the Domain layer contain?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 但领域层应该包含什么内容呢？
- en: According to Clean Architecture concepts, repeatable business logic that is
    related to a specific application action or flow should be encapsulated in a Use
    Case. In other words, **Use Cases** are classes that extract repeatable business
    rules related to a single functionality of your application as a single unit of
    business logic.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 根据清洁架构的概念，与特定应用程序操作或流程相关的可重复业务逻辑应该封装在用例中。换句话说，**用例**是类，它们将与应用程序单个功能相关的可重复业务规则作为一个业务逻辑单元提取出来。
- en: For example, an online ordering app can have business logic related to displaying
    only stores in the near proximity of the user. To encapsulate this business rule,
    we could create a `GetStoresInProximityUseCase` class. Or, maybe there is some
    business logic associated with the logout action triggered by the user (such as
    executing some user benefits or points calculation behind the scenes); then, we
    could implement `LogOutUserUseCase`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个在线订餐应用可以拥有与仅显示用户附近商店相关的业务逻辑。为了封装这个业务规则，我们可以创建一个`GetStoresInProximityUseCase`类。或者，可能有一些与用户触发的注销操作相关的业务逻辑（例如在幕后执行一些用户福利或积分计算）；那么，我们可以实现`LogOutUserUseCase`。
- en: 'So, in our Restaurants app, any business logic must be encapsulated in a Use
    Case that sits between the Presentation layer and the Model layer:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的餐厅应用中，任何业务逻辑都必须封装在位于表示层和模型层之间的用例中：
- en: '![Figure 8.3 – Layering of responsibilities where the Domain layer contains
    Use Cases'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.3 – 责任分层，其中领域层包含用例'
- en: '](img/B17788_08_03.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17788_08_03.jpg](img/B17788_08_03.jpg)'
- en: Figure 8.3 – Layering of responsibilities where the Domain layer contains Use
    Cases
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – 责任分层，其中领域层包含用例
- en: 'A separated Domain layer brings the following benefits:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 分离的领域层带来以下好处：
- en: Improves the testability of the app by separating business logic into its own
    classes. This way, business responsibilities are separated from other components
    and their logic can be tested separately without having to care about components
    from other layers.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将业务逻辑分离到其自己的类中，提高了应用程序的可测试性。这样，业务责任与其他组件分离，并且可以单独测试其逻辑，而无需关心其他层的组件。
- en: By separating business logic inside Use Cases, we avoid code duplication, and
    we improve the re-usability of business rules and their corresponding logic.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在用例内部分离业务逻辑，我们避免了代码重复，并提高了业务规则及其对应逻辑的可重用性。
- en: Improves the readability of the classes that contain Use Cases dependencies.
    This is because each unit of business is now extracted separately and provides
    developers with valuable insights into the business actions each screen or flow
    executes.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将业务逻辑分离到其自己的类中，提高了包含用例依赖项的类的可读性。这是因为每个业务单元现在都是单独提取的，并为开发者提供了关于每个屏幕或流程执行的业务动作的宝贵见解。
- en: 'Before jumping into a practical example, let''s briefly cover a few important
    aspects of Use Cases:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入实际例子之前，让我们简要介绍一些用例的重要方面：
- en: They can use (or depend on) other Use Cases. Since Use Cases define a single
    unit of reusable business logic, then Use Cases can use other Use Cases to define
    complex business logic.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以使用（或依赖于）其他用例。由于用例定义了一个可重用的单一业务逻辑单元，因此用例可以使用其他用例来定义复杂业务逻辑。
- en: They usually obtain their data from the Model layer but are not conditioned
    to only one `Repository` class – in other words, you can access multiple repositories
    from within your Use Case.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们通常从模型层获取数据，但不是仅限于一个`Repository`类 – 换句话说，你可以在用例内部访问多个仓库。
- en: They usually have only one public method, mostly because Use Cases encapsulate
    business rules related to a single functionality of your app (like `LogOutUserUseCase`
    does).
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们通常只有一个公共方法，主要是因为用例封装了与您的应用单个功能相关的业务规则（就像`LogOutUserUseCase`所做的那样）。
- en: They should follow a naming convention. A popular convention for the Use Case
    class is a verb in the present tense that defines the action, usually followed
    by a few words that express the *what*, and that ends with the UseCase suffix.
    Some examples could be `GetStoresInProximityUseCase` or `CalculateOrderTotalUseCase`.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们应该遵循一个命名约定。用例类的流行约定是现在时态的动词，定义动作，通常后面跟几个表示*什么*的词，并以UseCase后缀结尾。一些例子可以是`GetStoresInProximityUseCase`或`CalculateOrderTotalUseCase`。
- en: 'It''s time to see what a Use Case class looks like. In our Restaurants app,
    the business logic of sorting restaurants alphabetically is a good match for it
    being extracted to a Use Case because of the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候看看用例类是什么样的了。在我们的餐厅应用中，按字母顺序排序餐厅的业务逻辑非常适合提取到用例中，因为以下原因：
- en: It's a business rule dictated by the stakeholder.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个由利益相关者规定的业务规则。
- en: It's repeated twice.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它重复了两次。
- en: It's part of a specific action of the app (getting the restaurants).
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是应用中特定操作的一部分（获取餐厅信息）。
- en: Let's define our first Use Case class!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义我们的第一个用例类！
- en: 'Click on the application package, select `GetRestaurantsUseCase` as the name,
    select **Class**, and add this code:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击应用程序包，将`GetRestaurantsUseCase`作为名称，选择**类**，并添加以下代码：
- en: '[PRE2]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Functionally, this Use Case class gets the restaurants from `RestaurantsRepository`,
    applies the business rule of sorting the restaurants alphabetically, just like
    `RestarauntsViewModel` did, and then returns the list. In other words, `GetRestaurantsUseCase`
    is now the one responsible for applying business rules.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 功能上，这个用例类从`RestaurantsRepository`获取餐厅，应用了按字母顺序排序餐厅的业务规则，就像`RestarauntsViewModel`所做的那样，然后返回列表。换句话说，`GetRestaurantsUseCase`现在负责应用业务规则。
- en: This Use Case does that with only one public method, which is also a `suspend`
    function because the `repository.getAllRestaurants()` call is a suspending function
    call. But, more importantly, why did we name the function of the Use Case as `invoke()`
    while also specifying the `operator` keyword?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个用例通过一个公共方法实现，这个方法也是一个`suspend`函数，因为`repository.getAllRestaurants()`调用是一个挂起函数调用。但更重要的是，为什么我们给用例的函数命名为`invoke()`，同时指定了`operator`关键字？
- en: 'We did that because Kotlin allows us to define an `invoke` operator on a class
    so we can call it on any instances of the class without a method name. This is
    how we will call the `invoke()` operator of `GetRestaurantsUseCase`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做是因为Kotlin允许我们在类上定义一个`invoke`操作符，这样我们就可以在类的任何实例上调用它而不需要方法名。这就是我们将如何调用`GetRestaurantsUseCase`的`invoke()`操作符：
- en: '[PRE3]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This syntax is especially useful for us because our Use Case classes have only
    one method, and the name of the class is already suggestive enough, so we don't
    need a named function.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法对我们特别有用，因为我们的用例类只有一个方法，类的名称已经足够有暗示性，所以我们不需要命名函数。
- en: 'Make sure to remove the sorting logic that we initially added in the `getAllRestaurants()`
    method in `RestaurantsRepository`. The returned data of the method should look
    like this:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保删除我们在`RestaurantsRepository`的`getAllRestaurants()`方法中最初添加的排序逻辑。该方法返回的数据应如下所示：
- en: '[PRE4]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Inside `RestaurantsViewModel`, add a new dependency to the `GetRestaurantsUseCase`
    class:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RestaurantsViewModel`内部，向`GetRestaurantsUseCase`类添加一个新的依赖项：
- en: '[PRE5]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, inside the `getRestaurants()` method of the `ViewModel`, remove the call
    for restaurants to the `repository` variable, and instead, call the `invoke()`
    operator for the `getRestaurantsUseCase` variable:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`ViewModel`的`getRestaurants()`方法中，移除对`repository`变量的餐厅调用，而是调用`getRestaurantsUseCase`变量的`invoke()`操作符：
- en: '[PRE6]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Before building and running the app, let's try to identify any other business
    rules for this particular flow of the app.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建和运行应用程序之前，让我们尝试识别此应用程序特定流程的任何其他业务规则。
- en: 'If we have a look inside `RestaurantsRepository`, the `toggleFavoriteRestaurant()`
    method takes in an `oldValue: Boolean` parameter, and negates it before passing
    it to `PartialRestaurant`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '如果我们查看`RestaurantsRepository`内部，`toggleFavoriteRestaurant()`方法接受一个`oldValue:
    Boolean`参数，并在将其传递给`PartialRestaurant`的`isFavorite`字段之前对其进行取反：'
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This happens every time we mark a restaurant as a favorite or not favorite.
    The rule of negating `oldValue` of the favorite status of the restaurant (by passing
    `!oldValue`) can be considered a business rule imposed by the stakeholder: *whenever
    a user presses on the heart icon of a restaurant, we must toggle its favorite
    status to the opposite value*.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这发生在我们标记餐厅为收藏或非收藏的任何时候。通过传递`!oldValue`取消餐厅收藏状态`oldValue`的规则可以被视为利益相关者强加的业务规则：*每当用户点击餐厅的心形图标时，我们必须将其收藏状态切换到相反的值*。
- en: To be able to reuse this business logic and not have it done by `RestaurantsRepository`
    , let's also extract this rule to a Use Case.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够重用这个业务逻辑，而不是由`RestaurantsRepository`执行，让我们也将这个规则提取到一个用例中。
- en: 'First, inside `RestaurantsRepository`, rename the `oldValue` parameter to `value`
    and make sure to not negate it anymore when passing it to the `isFavorite` field
    of `PartialRestaurant`:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`RestaurantsRepository`内部，将`oldValue`参数重命名为`value`，并确保在将其传递给`PartialRestaurant`的`isFavorite`字段时不再对其进行取反：
- en: '[PRE8]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Click on the application package, select `ToggleRestaurantUseCase` as the name,
    select **Class**, and add this code:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击应用程序包，将`ToggleRestaurantUseCase`作为名称，选择**类**，并添加以下代码：
- en: '[PRE9]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This Use Case now encapsulates the business rule of negating the favorite flag
    of a restaurant with the `val newFav = oldValue.not()` line. While the business
    logic here is rather slim, in production apps, things tend to get more complex.
    This Use Case should be called whenever we mark a restaurant as a favorite or
    not favorite.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个用例现在封装了通过`val newFav = oldValue.not()`行取消餐厅收藏标志的业务规则。虽然这里的业务逻辑相当简单，但在生产应用中，事情往往会变得更加复杂。每当我们将餐厅标记为收藏或非收藏时，都应该调用此用例。
- en: 'Inside `RestaurantsViewModel`, add a new dependency to the `ToggleRestaurantUseCase`
    class:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RestaurantsViewModel`内部，添加对`ToggleRestaurantUseCase`类的新依赖：
- en: '[PRE10]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: At this step, you can also safely remove the `RestaurantsViewModel` class's
    dependency to the `RestaurantsRepository` class by removing the `repository` variable.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步，你也可以安全地通过移除`repository`变量来移除`RestaurantsViewModel`类对`RestaurantsRepository`类的依赖。
- en: 'Then, inside the `toggleFavorite()` method of the `ViewModel`, remove the call
    for toggling the restaurant on the `repository` variable, and instead, call the
    `invoke()` operator for the `toggleRestaurantUseCase` variable:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`ViewModel`的`toggleFavorite()`方法中，移除对`repository`变量的切换餐厅调用，而是调用`toggleRestaurantUseCase`变量的`invoke()`运算符：
- en: '[PRE11]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, the business rule of toggling a restaurant as a favorite or not is done
    inside `ToggleRestaurantUseCase`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将餐厅切换为收藏或非收藏的业务规则是在`ToggleRestaurantUseCase`内部完成的。
- en: Now that we have extracted business logic into Use Case classes, build the app
    and run it. The application should behave the same.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经将业务逻辑提取到Use Case类中，构建并运行应用程序。应用程序应该表现相同。
- en: Yet, if you try toggling a restaurant as a favorite, the list of restaurants
    still flickers, and their order seems to change. Can you think of why this happens?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你尝试切换餐厅为收藏，餐厅列表仍然闪烁，它们的顺序似乎在改变。你能想到为什么会发生这种情况吗？
- en: 'Let''s circle back to `RestaurantsRepository` and check out the `toggleFavoriteRestaurant`
    method:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`RestaurantsRepository`并检查`toggleFavoriteRestaurant`方法：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The problem with this method is that it returns the restaurants obtained from
    the Room DAO by calling `restaurantsDao.getAll()`. These restaurants are not sorted
    alphabetically, as our business rules now indicate. So, every time we toggle a
    restaurant as favorite, we update the UI with the unsorted list of restaurants.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点在于它通过调用`restaurantsDao.getAll()`从Room DAO获取餐厅，这些餐厅并没有按照我们的业务规则进行字母顺序排序。因此，每次我们切换餐厅为收藏时，我们都会用未排序的餐厅列表更新UI。
- en: 'We need to somehow reuse the sorting logic from `GetRestaurantsUseCase`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要以某种方式重用`GetRestaurantsUseCase`中的排序逻辑：
- en: 'First, from within `RestaurantsRepository`, remove the `restaurantsDao.getAll()`
    call from the `toggleFavoriteRestaurant` method:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`RestaurantsRepository`内部，从`toggleFavoriteRestaurant`方法中移除`restaurantsDao.getAll()`调用：
- en: '[PRE13]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This way, this method no longer returns a list of restaurants; it just updates
    a specific restaurant. As of now, the `toggleFavoriteRestaurant` method doesn't
    return anything anymore.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，这个方法就不再返回餐厅列表；它只是更新一个特定的餐厅。到目前为止，`toggleFavoriteRestaurant`方法不再返回任何内容。
- en: 'Then, inside the `ToggleRestaurantUseCase` class, remove the return statement
    for the `repository.toggleFavoriteRestaurant()` line, and instead return the sorted
    list of restaurants by directly instantiating and calling the `invoke()` operator
    on the `GetRestaurantsUseCase` class:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`ToggleRestaurantUseCase`类中，移除`repository.toggleFavoriteRestaurant()`行的返回语句，而是通过直接实例化和调用`GetRestaurantsUseCase`类的`invoke()`运算符来返回排序后的餐厅列表：
- en: '[PRE14]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This approach fixes our issue – whenever we toggle a restaurant as a favorite
    or not, the UI no longer flickers because the UI is updated with the correctly
    sorted list – yet this happens with a lengthy delay.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法解决了我们的问题——每次我们切换餐厅为收藏或非收藏时，UI不再闪烁，因为UI是用正确排序的列表更新的——但这发生在一个漫长的延迟之后。
- en: Unfortunately, this functionality is not efficient at all because whenever we
    toggle a restaurant as a favorite or not, the `GetRestaurantsUseCase` calls the
    `RestaurantsRepository` class's `getAllRestaurants()` method that, in turn, triggers
    a request to get the restaurants again from the Web API, attempts to cache them
    into `Room`, and only then provides us with a list, hence the delay we've just
    experienced.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这个功能非常低效，因为每次我们切换餐厅为收藏或非收藏时，`GetRestaurantsUseCase`都会调用`RestaurantsRepository`类的`getAllRestaurants()`方法，这反过来又触发了从Web
    API获取餐厅的请求，尝试将它们缓存到`Room`中，然后才提供给我们列表，这就是我们刚才经历的延迟。
- en: 'In a good application architecture, a network request that gets the new list
    of items shouldn''t be done after every UI interaction with an item. Let''s fix
    this by refactoring our code and by creating a new Use Case that only retrieves
    the cached restaurants, sorts them, and returns them:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在良好的应用程序架构中，获取新项目列表的网络请求不应该在每次与项目进行UI交互后都执行。让我们通过重构我们的代码并创建一个新的仅检索缓存餐厅、排序并返回它们的Use
    Case来解决这个问题：
- en: 'First, inside `RestaurantsRepository`, add a new method called `getRestaurants()`
    that only retrieves the restaurants from our Room DAO:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`RestaurantsRepository`内部添加一个名为`getRestaurants()`的新方法，该方法仅从我们的Room DAO检索餐厅：
- en: '[PRE15]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Click on the application package, select `GetSortedRestaurantsUseCase` as the
    name, select **Class**, and add this code:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击应用程序包，选择`GetSortedRestaurantsUseCase`作为名称，选择**类**，并添加以下代码：
- en: '[PRE16]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `GetSortedRestaurantsUseCase` class now retrieves the restaurants from the
    `RestaurantsRepository` by calling the previously created `getRestaurants()` method
    (without triggering any network request or caching), applies the sorting business
    rule, and finally, returns the list of restaurants.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetSortedRestaurantsUseCase`类现在通过调用之前创建的`getRestaurants()`方法（不触发任何网络请求或缓存）从`RestaurantsRepository`检索餐厅，应用排序业务规则，并最终返回餐厅列表。'
- en: 'Use the newly created `GetSortedRestaurantsUseCase` class inside `ToggleRestaurantUseCase`
    so that we only get the cached restaurants every time we toggle a restaurant as
    a favorite or not:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ToggleRestaurantUseCase`中使用新创建的`GetSortedRestaurantsUseCase`类，这样我们每次切换餐厅的收藏或不收藏状态时都只获取缓存的餐厅：
- en: '[PRE17]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we must refactor `GetRestaurantsUseCase` to reuse the sorting business
    logic from within `GetSortedRestaurantsUseCase` because the alphabetical sorting
    logic is now duplicated in both Use Cases:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须重构`GetRestaurantsUseCase`，以便重用`GetSortedRestaurantsUseCase`中的排序业务逻辑，因为字母排序逻辑现在在两个Use
    Case中都重复了：
- en: 'First, inside `RestaurantsRepository`, update the `getAllRestaurants` method
    to no longer return the restaurants by no longer returning `restaurantsDao.getAll()`,
    while also removing the function''s return type:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`RestaurantsRepository`内部更新`getAllRestaurants`方法，不再通过不再返回`restaurantsDao.getAll()`来返回餐厅，同时删除函数的返回类型：
- en: '[PRE18]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Rename the `getAllRestaurants` method to `loadRestaurants()` to better reflect
    its responsibility:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`getAllRestaurants`方法重命名为`loadRestaurants()`以更好地反映其职责：
- en: '[PRE19]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Inside `GetRestaurantsUseCase`, add a new dependency to the `GetSortedRestaurantUseCase`
    class and refactor the class as follows:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GetRestaurantsUseCase`内部添加一个新依赖项到`GetSortedRestaurantUseCase`类，并按以下方式重构该类：
- en: '[PRE20]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Inside the `invoke()` function, we made sure to first call the newly renamed
    `loadRestaurants()` method of the `RestaurantsRepository` and then, in addition,
    to invoke `GetSortedRestaurantsUseCase`, which is now also returned.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在`invoke()`函数内部，我们确保首先调用新命名的`loadRestaurants()`方法，然后调用`GetSortedRestaurantsUseCase`，它现在也被返回。
- en: 'To better reflect its purpose, rename the `GetRestaurantsUseCase` class to
    `GetInitialRestaurantsUseCase`:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了更好地反映其目的，将`GetRestaurantsUseCase`类重命名为`GetInitialRestaurantsUseCase`：
- en: '[PRE21]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As a consequence, inside `RestaurantsViewModel`, update the type for the `getRestaurantsUseCase`
    variable:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为结果，在`RestaurantsViewModel`内部更新`getRestaurantsUseCase`变量的类型：
- en: '[PRE22]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Build the app and run it. The application should now behave correctly when marking
    a restaurant as a favorite or not; the restaurants remain sorted alphabetically.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行应用。现在，当标记餐厅为收藏或不收藏时，应用应表现正确；餐厅保持字母顺序排序。
- en: Let's now move on to another way of improving the architecture of our app.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在转向另一种改进我们应用架构的方法。
- en: Separating the Domain model from Data models
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将域模型与数据模型分离
- en: Inside the Domain layer, apart from Use Cases, another essential business component
    in our app is the **Domain model component**. The Domain model components are
    those classes that represent core business data or concepts used throughout the
    application.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在域层内部，除了Use Cases之外，我们应用中的另一个重要业务组件是**域模型组件**。域模型组件是那些代表应用中使用的核心业务数据或概念的类。
- en: Note
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Since the Domain models reside inside the Domain layer, they should be agnostic
    of any third-party library or dependency – ideally, they should be pure Java or
    Kotlin classes.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于域模型位于域层内部，它们应该对任何第三方库或依赖项无感知——理想情况下，它们应该是纯Java或Kotlin类。
- en: For example, in our Restaurants app, the core entity used throughout the app
    (retrieved, updated, and displayed) is the `Restaurant` data class, which contains
    data such as `title` and `description`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的餐厅应用中，整个应用中使用的核心实体（检索、更新和显示）是`Restaurant`数据类，它包含诸如`title`和`description`之类的数据。
- en: 'If we think about it, our Restaurants app''s core business entity is represented
    by the restaurant itself: that''s what the application is about, so it''s only
    natural that we would consider the `Restaurant` class as a business entity.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细思考，我们的餐厅应用的核心业务实体就是餐厅本身：这正是应用的主题，因此将`Restaurant`类视为业务实体是顺理成章的。
- en: Note
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In Clean Architecture, Domain model classes are often referred to as Entity
    classes. However, it's important to mention that the Room database `@Entity` annotation
    has nothing to do with Clean Architecture; any class annotated with the Room `@Entity`
    annotation doesn't automatically become an entity. In fact, as per Clean Architecture,
    Entity classes should have no library dependencies such as database annotations.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Clean Architecture 中，领域模型类通常被称为实体类。然而，重要的是要提到，Room 数据库 `@Entity` 注解与 Clean
    Architecture 没有关系；任何带有 Room `@Entity` 注解的类都不会自动成为实体。实际上，根据 Clean Architecture，实体类应该没有库依赖，例如数据库注解。
- en: 'If we have a look at our `Restaurant` data class though, we can identify a
    serious issue:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，如果我们看一下我们的 `Restaurant` 数据类，我们可以识别出一个严重的问题：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Can you spot the problem?
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你能找到问题吗？
- en: While, in the beginning, the `Restaurant` data class was a pure Kotlin data
    class with some fields, in time, it grew to something more than that.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一开始，`Restaurant` 数据类只是一个包含一些字段的纯 Kotlin 数据类，但随着时间的推移，它变得比这更多。
- en: We first added Retrofit to our app so we could get the restaurants from a Web
    API, and had to mark the fields we obtained with `@SerializedName` annotations
    so that the GSON (Google Gson) deserialization would work. Then we added Room
    to the mix because we wanted to cache the restaurants, so we had to add an `@Entity`
    annotation to the class, and other annotations, such as `@PrimaryKey` and `@ColumnInfo`,
    to its fields.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将 Retrofit 添加到我们的应用程序中，以便从 Web API 获取餐厅，并必须使用 `@SerializedName` 注解标记我们获取的字段，以便
    GSON（Google Gson）反序列化能够工作。然后我们添加了 Room，因为我们想缓存餐厅，所以我们必须在类上添加 `@Entity` 注解，以及对其字段的其他注解，如
    `@PrimaryKey` 和 `@ColumnInfo`。
- en: While it was convenient for us to use only one Data model class throughout the
    app, we have now coupled a Domain model class (`Restaurant.kt`) to library dependencies,
    such as GSON or Room. This means that our Domain model is coupled to the Data
    or Model layer that is responsible for obtaining data.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在整个应用程序中使用单个数据模型类对我们来说很方便，但现在我们已经将领域模型类 (`Restaurant.kt`) 与库依赖项（如 GSON 或 Room）耦合。这意味着我们的领域模型与负责获取数据的或模型层耦合。
- en: According to Clean Architecture, the Domain model classes should reside inside
    the Domain layer and be agnostic of any libraries tightly related to the way we
    retrieve or cache data from several sources.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 Clean Architecture，领域模型类应位于领域层，并且对与从多个来源检索或缓存数据的方式紧密相关的任何库保持无知。
- en: In other words, we need to make a separation between Domain models and **Data
    Transfer Objects** (**DTOs**) by creating separate classes for both types. While
    Domain models are plain Kotlin classes, DTOs are classes that contain both the
    fields needed for a specific data operation, such as caching items to a local
    source, but also dependencies such as library annotations.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们需要通过为这两种类型创建单独的类来在领域模型和 **数据传输对象**（**DTOs**）之间进行分离。虽然领域模型是普通的 Kotlin
    类，但 DTOs 是包含特定数据操作所需字段以及依赖项（如库注解）的类。
- en: With such a separation, the Domain model is now a business entity that doesn't
    care about implementation details (such as libraries), so every time we might
    have to replace a library (such as Retrofit or Room) with another library, we
    must only update the DTOs (hence, the Model layer) and not classes within the
    Domain model.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种分离，领域模型现在是一个不关心实现细节（如库）的业务实体，因此每次我们可能需要用另一个库（如 Retrofit 或 Room）替换库时，我们只需更新
    DTOs（即模型层），而无需更新领域模型中的类。
- en: '![Figure 8.4 – Separating Domain models from DTO models'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.4 – 将领域模型与 DTO 模型分离'
- en: '](img/B17788_08_04.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17788_08_04.jpg)'
- en: Figure 8.4 – Separating Domain models from DTO models
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 – 将领域模型与 DTO 模型分离
- en: 'To achieve such a separation in our Restaurants app, we must split our `Restaurant`
    class into three classes. We must do the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的餐厅应用程序中实现这种分离，我们必须将 `Restaurant` 类拆分为三个类。我们必须执行以下操作：
- en: 'Create two DTOs as `data class` classes that will be used for transferring
    data:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建两个 DTO 作为 `data class` 类，它们将被用于传输数据：
- en: A `RemoteRestaurant` class that will contain the fields received from the Web
    API. These fields will also be annotated with GSON serialization annotations required
    by Retrofit to parse the response.
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `RemoteRestaurant` 类，它将包含从 Web API 接收的字段。这些字段也将带有 Retrofit 解析响应所需的 GSON 序列化注解。
- en: A `LocalRestaurant` class that will contain the fields and their corresponding
    annotations required by Room to cache restaurants.
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `LocalRestaurant` 类，它将包含 Room 缓存餐厅所需的字段及其相应的注解。
- en: Refactor the `Restaurant` data class to be a plain Kotlin data class, without
    any third-party dependencies. This way, the `Restaurant` data class will be a
    proper Domain model class, independent of the Model layer that is tightly coupled
    to third-party libraries.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`Restaurant`数据类重构为没有第三方依赖的纯Kotlin数据类。这样，`Restaurant`数据类将是一个合适的领域模型类，独立于紧密耦合到第三方库的模型层。
- en: Let's begin!
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: 'Click on the application package, select `RemoteRestaurant` as the name, select
    **Class**, and add this code to define the DTO for our remote source (Firebase
    remote database):'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击应用程序包，选择`RemoteRestaurant`作为名称，选择**类**，并将此代码添加以定义我们的远程源（Firebase远程数据库）的DTO：
- en: '[PRE24]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Inside this class, we have added all the fields received from the Web API, along
    with their corresponding serialization fields. You can get these annotations and
    their imports from the `Restaurant` class.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类内部，我们添加了从Web API接收的所有字段及其相应的序列化字段。你可以从`Restaurant`类中获取这些注解及其导入。
- en: Another advantage of having a separate DTO class is that it now contains only
    the necessary fields – for instance, unlike `Restaurant`, `RemoteRestaurant` no
    longer contains an `isFavorite` field because we don't receive it from the REST
    API of our Firebase Database.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个单独的DTO类的另一个优点是，它现在只包含必要的字段——例如，与`Restaurant`不同，`RemoteRestaurant`不再包含`isFavorite`字段，因为我们没有从我们的Firebase数据库的REST
    API中接收它。
- en: 'Click on the application package and create a new file called `LocalRestaurant`.
    Add this code to define the DTO for our local source (Room local database):'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击应用程序包并创建一个名为`LocalRestaurant`的新文件。将此代码添加以定义我们的本地源（Room本地数据库）的DTO：
- en: '[PRE25]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You can get the fields, annotations, and their imports from the `Restaurant`
    class.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从`Restaurant`类中获取字段、注解及其导入。
- en: 'Now, navigate to the `Restaurant` class. It''s time to remove all its third-party
    dependencies to Room and GSON and keep it as a simple Domain model class containing
    the fields that define our restaurant entity. It should now look like this:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，导航到`Restaurant`类。是时候移除所有对Room和GSON的第三方依赖，将其保留为一个简单的领域模型类，包含定义我们餐厅实体的字段。现在它应该看起来像这样：
- en: '[PRE26]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Make sure to also remove any imports for the GSON and Room annotations.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 确保删除任何对GSON和Room注解的导入。
- en: 'Inside the `RestaurantsDb` class, update the entity used in Room to our newly
    created `LocalRestaurant`, while also updating the schema version to `3`, just
    to be sure that Room will provide a fresh start:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RestaurantsDb`类内部，更新Room中使用的实体为我们的新创建的`LocalRestaurant`，同时更新模式版本为`3`，只是为了确保Room将提供一个全新的开始：
- en: '[PRE27]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Rename the `PartialRestaurant` class to `PartialLocalRestaurant` to better
    clarify that this class is used by our local data source, Room:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`PartialRestaurant`类重命名为`PartialLocalRestaurant`以更好地说明这个类是用于我们的本地数据源，Room：
- en: '[PRE28]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Inside the `RestaurantsDao` interface, replace the `Restaurant` class usages
    with `LocalRestaurant`, and the `PartialRestaurant` class usages with `PartialLocalRestaurant`:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RestaurantsDao`接口内部，将`Restaurant`类的使用替换为`LocalRestaurant`，将`PartialRestaurant`类的使用替换为`PartialLocalRestaurant`：
- en: '[PRE29]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Inside `RestaurantsRepository`, navigate to the `toggleFavoriteRestaurant()`
    method, and replace the `PartialRestaurant` usage with `PartialLocalRestaurant`:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RestaurantsRepository`内部，导航到`toggleFavoriteRestaurant()`方法，并将`PartialRestaurant`的使用替换为`PartialLocalRestaurant`：
- en: '[PRE30]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Still inside `RestaurantsRepository`, navigate to the `getRestaurants()` method,
    and map the `LocalRestaurant` objects (received by the `restaurantsDao.getAll()`
    method call) to `Restaurant` objects:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在`RestaurantsRepository`内部，导航到`getRestaurants()`方法，并将`LocalRestaurant`对象（通过`restaurantsDao.getAll()`方法调用接收）映射到`Restaurant`对象：
- en: '[PRE31]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We have mapped `List<LocalRestaurant>` to `List<Restaurant>` by using the `.map
    { }` extension function. We did that by constructing and returning a `Restaurant`
    object from `LocalRestaurant`, represented by the `it` implicit variable name.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用`.map { }`扩展函数将`List<LocalRestaurant>`映射到`List<Restaurant>`。我们通过从`LocalRestaurant`构造并返回一个`Restaurant`对象来实现，`it`是隐含变量名。
- en: Note
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Your Model layer (represented by the `Repository` here), should only return
    Domain model objects to the Domain entity. In our case, `RestaurantsRepository`
    should return `Restaurant` objects, and not `LocalRestaurants` objects, simply
    because the Use Case classes (so, the Domain layer) that use this `Repository`
    shouldn't have any knowledge of DTO classes from the Model layer.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你的模型层（在这里由`Repository`表示），应该只向领域实体返回领域模型对象。在我们的案例中，`RestaurantsRepository`应该返回`Restaurant`对象，而不是`LocalRestaurants`对象，简单来说，因为使用这个`Repository`的使用案例类（因此，领域层）不应该有任何关于模型层DTO类的知识。
- en: 'Navigate to the `RestaurantsApiService` interface (the Retrofit interface)
    and replace the usages of the `Restaurant` class with `RemoteRestaurant`:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `RestaurantsApiService` 接口（Retrofit 接口）并将 `Restaurant` 类的使用替换为 `RemoteRestaurant`：
- en: '[PRE32]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Going back to `RestaurantsRepository`, navigate to the `refreshCache()` method
    and map the `remoteRestaurants` list from Retrofit to `LocalRestaurant` objects
    so that `restaurantsDao` can cache them:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到 `RestaurantsRepository`，导航到 `refreshCache()` 方法并将 Retrofit 的 `remoteRestaurants`
    列表映射到 `LocalRestaurant` 对象，以便 `restaurantsDao` 可以缓存它们：
- en: '[PRE33]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Additionally, make sure to update the usage of `PartialRestaurant` to `PartialLocalRestaurant`
    in the `restaurantsDao.updateAll()` method call.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请确保在 `restaurantsDao.updateAll()` 方法调用中更新 `PartialRestaurant` 的使用为 `PartialLocalRestaurant`。
- en: 'Navigate to `RestaurantsDetailsViewModel` and, inside the `getRemoteRestaurant()`
    method, map the `RemoteRestaurant` object received from the Retrofit API to a
    `Restaurant` object by using the `?.let{ }` extension function:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `RestaurantsDetailsViewModel` 并在 `getRemoteRestaurant()` 方法中，使用 `?.let{
    }` 扩展函数将从 Retrofit API 收到的 `RemoteRestaurant` 对象映射到 `Restaurant` 对象：
- en: '[PRE34]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Remember that in the restaurant details screen, we don't have any business logic
    or Use Cases, or even a `Repository`, so we have directly added a variable for
    the Retrofit interface inside the `ViewModel` – and that's why we are mapping
    the Domain model inside the `ViewModel`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在餐厅详情屏幕中，我们没有任何业务逻辑或用例，甚至没有 `Repository`，所以我们直接在 `ViewModel` 中添加了一个 Retrofit
    接口的变量 – 这就是为什么我们在 `ViewModel` 中映射领域模型的原因。
- en: Build and run the app. The app should behave the same.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行应用程序。应用程序应该表现相同。
- en: Let's now take a break from creating classes and let's organize our project
    a bit.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们暂时放下创建类的工作，让我们对项目进行一些组织。
- en: Creating a package structure
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建包结构
- en: Our Restaurants app has come a long way. As we tried to separate responsibilities
    and concerns as much as possible, new classes emerged – quite a few actually.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的餐厅应用已经走了很长的路。随着我们尽可能地将责任和关注点分离，新的类出现了 – 实际上有很多。
- en: If we have a look on the left of Android Studio, on the **Project** tab, we
    have an overview of the classes we've defined in our project.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 Android Studio 的左侧查看，在 **项目** 选项卡中，我们可以看到我们在项目中定义的类的概述。
- en: '![Figure 8.5 – Project structure without any package structuring strategy'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.5 – 没有任何包结构策略的项目结构'
- en: '](img/B17788_08_05.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.5 – 没有任何包结构策略的项目结构'
- en: Figure 8.5 – Project structure without any package structuring strategy
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 – 没有任何包结构策略的项目结构
- en: It's clear that our project has no folder structure at all – all files and classes
    are tossed around inside the `restaurantsapp` root package.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，我们的项目完全没有文件夹结构 – 所有文件和类都随意放在 `restaurantsapp` 根包中。
- en: Note
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The name of the root package might differ if you selected a different name for
    your app.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您为您的应用程序选择了不同的名称，根包的名称可能会有所不同。
- en: Because we've opted to throw any new class inside the root package, it's difficult
    to have clear visibility over the project. Our approach is similar to adding dozens
    of files and assets on the desktop of our PC – in time, it becomes impossible
    to find anything on the screen.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们选择将任何新的类都放入根包中，所以很难对项目有清晰的可见性。我们的方法类似于在我们的电脑桌面上添加几十个文件和资产 – 随着时间的推移，在屏幕上找到任何东西都变得不可能。
- en: To alleviate this issue, we can opt for a **packaging strategy** for our project
    in which each class belongs to a folder. A clear folder structure allows developers
    to have good visibility and to gain valuable insight into the application's components,
    there by allowing easier access and navigation through the project files.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了缓解这个问题，我们可以为我们的项目选择一种**打包策略**，其中每个类都属于一个文件夹。清晰的文件夹结构允许开发者有良好的可见性，并能够获得对应用程序组件的宝贵洞察，从而更容易访问和导航项目文件。
- en: 'The most common package organizing strategies are as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的包组织策略如下：
- en: '`presentation` package would contain all the files related to the Presentation
    layer, regardless of the feature they belong to, such as all the files with composables,
    and all the `ViewModel` classes.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`presentation` 包将包含与表示层相关的所有文件，无论它们属于哪个功能，例如所有带有 composables 的文件以及所有的 `ViewModel`
    类。'
- en: Similarly, a `data` package would contain all files related to the Model layer,
    regardless of the feature they belong to, such as repositories, Retrofit interfaces,
    or Room DAO interfaces.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，一个 `data` 包将包含与模型层相关的所有文件，无论它们属于哪个功能，例如仓库、Retrofit 接口或 Room DAO 接口。
- en: '`restaurants` package would contain all the classes related to the `restaurants`
    feature, from UI classes to `ViewModel` classes, Use Cases, and repositories.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`restaurants` 包将包含与 `restaurants` 功能相关的所有类，从 UI 类到 `ViewModel` 类、用例和仓库。'
- en: Both approaches have their pros and cons, but most notably, the package organization
    by layer doesn't scale well if the app has a lot of features, as there is no way
    to differentiate between classes from different features.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都有其优缺点，但最值得注意的是，如果应用程序有很多功能，按层组织包的方式扩展性不佳，因为没有方法来区分来自不同功能类的类。
- en: On the other hand, the package organization by feature can be problematic if,
    in each feature package, all classes are thrown around without any distinct categorization.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果每个功能包中的所有类都没有任何明确的分类，那么按功能组织包可能会出现问题。
- en: 'For our Restaurants app, we will use a mix of these two strategies. More specifically,
    we will do the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的餐厅应用程序，我们将结合使用这两种策略。更具体地说，我们将执行以下操作：
- en: Keep `RestaurantsApplication.kt` inside the root package.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `RestaurantsApplication.kt` 放置在根包内。
- en: Create a root package for the only feature our application has, named `restaurants`.
    This package will contain the functionality for displaying both the list of restaurants
    and the detail screen.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们应用程序的唯一功能创建一个根包，命名为 `restaurants`。这个包将包含显示餐厅列表和详情屏幕的功能。
- en: 'Create sub-packages inside the `restaurants` package for each layer:'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `restaurants` 包内为每个层创建子包：
- en: '`Presentation`: For composables and `ViewModel` classes. Inside this package,
    we can also break the screens that we have into separate packages: `list` for
    the first screen with the list of restaurants, and `details` for the second screen
    with the details of one restaurant. Additionally, we will keep the `MainActivity`
    class inside the `presentation` package since it''s the host component for the
    UI.'
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Presentation`: 用于可组合的类和 `ViewModel` 类。在这个包内，我们还可以将我们已有的屏幕拆分为单独的包：`list` 用于包含餐厅列表的第一个屏幕，`details`
    用于包含单个餐厅详情的第二个屏幕。此外，我们还将 `MainActivity` 类放在 `presentation` 包内，因为它是我们 UI 的宿主组件。'
- en: '`Data`: For classes within the Model layer. Here, we will not only add `RestaurantsRepository,`
    but we''ll also create two sub-packages for the two different data sources: `local`
    (for caching classes such as `RestaurantsDao` and `LocalRestaurant`), and `remote`
    (for classes related to the remote source such as `RestaurantsApiService` and
    `RemoteRestaurant`).'
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Data`: 用于模型层内的类。在这里，我们不仅会添加 `RestaurantsRepository`，还会为两个不同的数据源创建两个子包：`local`（用于缓存类，如
    `RestaurantsDao` 和 `LocalRestaurant`），以及 `remote`（用于与远程源相关的类，如 `RestaurantsApiService`
    和 `RemoteRestaurant`）。'
- en: '`Domain`: For business-related classes, the Use Case classes, and also the
    `Restaurant.kt` Domain model class.'
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Domain`: 用于业务相关的类、用例类，以及 `Restaurant.kt` 领域模型类。'
- en: With this approach, if we were to add a new feature, maybe related to ordering
    (which we could call `ordering`), the package structure would provide us with
    immediate information about the features our application contains. When expanding
    a certain feature package, we can expand the package of the layer we're interested
    in working with and have a clear overview of the components we need to update
    or modify.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，如果我们添加一个新功能，比如与订单相关的功能（我们可以称之为 `ordering`），包结构将立即提供我们应用程序包含的功能信息。当我们展开某个功能包时，我们可以展开我们感兴趣工作的层的包，并清楚地了解我们需要更新或修改的组件。
- en: 'To achieve such a packaging structure, you will have to perform the following
    actions a few times:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这种包装结构，您将需要多次执行以下操作：
- en: Create a new package. To do that, left-click on a certain existing package (such
    as the `restaurantsapp` package), select **New**, then **Package**, and finally,
    enter the name of the package.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的包。为此，左键单击某个现有包（例如 `restaurantsapp` 包），选择 **新建**，然后 **包**，最后输入包名。
- en: Move an existing class into an existing package. To do that, simply drag the
    file and drop it into the desired package.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将现有类移动到现有包中。为此，只需将文件拖动并放入所需的包中。
- en: 'In the end, the package structure that we described and that we want to achieve
    is the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们描述并希望实现的包结构如下：
- en: '![Figure 8.6 – Project structure after applying our package structuring strategy'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.6 – 应用我们的包结构策略后的项目结构'
- en: '](img/B17788_08_06.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17788_08_06.jpg)'
- en: Figure 8.6 – Project structure after applying our package structuring strategy
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 – 应用我们的包结构策略后的项目结构
- en: 'Keep in mind, however, that when moving the `MainActivity.kt` file from its
    initial location to the `presentation` package, you might have to update the `Manifest.xml`
    file to reference the new correct path to the `MainActivity.kt` file:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，当将 `MainActivity.kt` 文件从其初始位置移动到 `presentation` 包时，你可能需要更新 `Manifest.xml`
    文件以引用新的正确路径到 `MainActivity.kt` 文件：
- en: '[PRE35]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Some versions of Android Studio do that out of the box for you; however, if
    they don't, you might end up with a nasty compilation error because the `Manifest.xml`
    file is no longer detecting our `Activity`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 一些版本的 Android Studio 会为你自动完成这项工作；然而，如果它们没有这样做，你可能会遇到一个讨厌的编译错误，因为 `Manifest.xml`
    文件不再检测到我们的 `Activity`。
- en: Now that we have refactored the structure of our project, we can say that the
    packages structure provides us with immediate information about the features of
    the app (in our case, there is only one feature related to restaurants) and also
    with a clear overview of the components corresponding to a specific feature.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经重构了项目的结构，我们可以这样说，包结构为我们提供了关于应用功能（在我们的案例中，只有一个与餐厅相关的功能）的即时信息，同时也提供了一个关于特定功能的组件的清晰概览。
- en: Note
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The autogenerated files for Compose projects (`Color.kt`, `Shape.kt`, `Theme.kt`,
    and `Type.kt`) were left inside the `theme` package that resides inside the `ui`
    package. This is because theming should be consistent across features.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Compose 项目的自动生成文件（`Color.kt`、`Shape.kt`、`Theme.kt` 和 `Type.kt`）被留在了 `ui` 包内的
    `theme` 包中。这是因为主题应该在整个功能中保持一致性。
- en: Let's now move on to another way of improving the decoupling inside the UI layer
    between the composables and the `ViewModel`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在转向另一种改进 UI 层内部组合函数与 `ViewModel` 之间解耦的方法。
- en: Decoupling the Compose-based UI layer from ViewModel
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解耦基于 Compose 的 UI 层与 ViewModel
- en: 'Our UI layer (represented by the composable functions) is tightly coupled to
    the `ViewModel`. This is natural, since the screen composables instantiate their
    own `ViewModel` to do the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 UI 层（由组合函数表示）与 `ViewModel` 紧密耦合。这是自然的，因为屏幕组合函数会实例化自己的 `ViewModel` 来执行以下操作：
- en: Obtain the UI state and consume it
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取 UI 状态并消费它
- en: Pass events (such as clicking on a UI item) up to the `ViewModel`
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将事件（如点击 UI 项目）传递到 `ViewModel`
- en: 'As an example, we can see how the `RestaurantsScreen()` composable uses an
    instance of `RestaurantsViewModel`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以看到 `RestaurantsScreen()` 组合函数是如何使用 `RestaurantsViewModel` 实例的：
- en: '[PRE36]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The problem with our approach is that if we want to later test the UI layer,
    then, inside the test, the `RestaurantsScreen` composable will instantiate `RestaurantsViewModel`,
    which in turn will get data from Use Case classes, which in turn will trigger
    heavy I/O work in `RestaurantsRepository` (like the network request to obtain
    the restaurants, or the operation of saving them inside the local database).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的方法的问题是，如果我们想稍后测试 UI 层，那么在测试中，`RestaurantsScreen` 组合函数将实例化 `RestaurantsViewModel`，这反过来又会从
    Use Case 类获取数据，进而触发 `RestaurantsRepository` 中的重 I/O 工作（如获取餐厅的网络请求，或将其保存在本地数据库中的操作）。
- en: When we have to test the UI, we should not care whether the `ViewModel` obtains
    the data correctly and translates it into a proper UI state. The effect of separating
    concerns is to facilitate testing a target class (or composable in this discussion)
    without having to care about other layers doing their work.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们必须测试 UI 时，我们不应该关心 `ViewModel` 是否正确获取数据并将其转换为适当的 UI 状态。分离关注点的效果是，在不需要关心其他层执行其工作的前提下，便于测试目标类（或本讨论中的组合函数）。
- en: Right now, our screen composables are tied to a library dependency, the `ViewModel`,
    and it's ideal to decouple such dependencies as much as possible to promote reusability
    and testability.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的屏幕组合函数与一个库依赖项，即 `ViewModel`，紧密相连，理想情况下，我们应该尽可能解耦这样的依赖项，以促进可重用性和可测试性。
- en: 'In order to decouple the `RestaurantsScreen()` composable as much as possible
    from its `ViewModel`, we will refactor it so that the following happens:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尽可能地将 `RestaurantsScreen()` 组合函数与其 `ViewModel` 解耦，我们将对其进行重构，以便以下情况发生：
- en: It will no longer reference a `ViewModel` class (the `RestaurantsViewModel`
    class).
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将不再引用一个 `ViewModel` 类（即 `RestaurantsViewModel` 类）。
- en: Instead, it will receive a `RestaurantsScreenState` object as a parameter.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相反，它将接收一个 `RestaurantsScreenState` 对象作为参数。
- en: It will also define new function parameters to expose callbacks to its caller
    – we will see who the caller is in a minute.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它还将定义新的函数参数来向其调用者公开回调 - 我们将在稍后看到调用者是谁。
- en: Note
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: By extracting the `ViewModel` instantiation from screen composables, such as
    `RestaurantsScreen()`, we're promoting reusability in the sense that we can much
    easier replace the ViewModel type that creates the state for this composable.
    This approach also enables us to port the Compose-based UI layer much easier to
    **Kotlin Multiplatform** (**KMP**) projects.
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过从屏幕组合器，如 `RestaurantsScreen()` 中提取 `ViewModel` 实例化，我们在可重用性方面进行了提升，这意味着我们可以更容易地替换创建此组合器状态的
    ViewModel 类型。这种方法还使我们能够更容易地将基于 Compose 的 UI 层移植到 **Kotlin Multiplatform**（**KMP**）项目中。
- en: Let's begin!
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: 'Inside the `RestaurantsScreen` file, update the `RestaurantsScreen()` composable
    by removing its `viewModel` and `state` variables, while also making sure it receives
    a `RestaurantsScreenState` object as a `state` parameter and an `onFavoriteClick`
    function:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `RestaurantsScreen` 文件中，通过删除其 `viewModel` 和 `state` 变量来更新 `RestaurantsScreen()`
    组合器，同时确保它接收一个 `RestaurantsScreenState` 对象作为 `state` 参数和一个 `onFavoriteClick` 函数：
- en: '[PRE37]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Additionally, make sure to remove the `viewModel.toggleFavorite()` call and
    instead, call the newly added `onFavoriteClick()` function inside the `RestaurantItem`
    corresponding callback.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请确保删除 `viewModel.toggleFavorite()` 调用，并改为在 `RestaurantItem` 对应的回调中调用新添加的
    `onFavoriteClick()` 函数。
- en: 'Since we changed the signature of the `RestaurantsScreen()` function, we must
    also update the `DefaultPreview()` composable to correctly call the `RestaurantsScreen()`
    composable:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们更改了 `RestaurantsScreen()` 函数的签名，我们必须更新 `DefaultPreview()` 组合器以正确调用 `RestaurantsScreen()`
    组合器：
- en: '[PRE38]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the `MainActivity` class and inside the `RestaurantsApp()` composable, make
    the destination composable for `RestaurantsScreen()` responsible for wiring up
    the screen composable with its `ViewModel`, thereby ensuring good communication
    between `RestaurantsScreen()` and `RestaurantsViewModel`:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainActivity` 类和 `RestaurantsApp()` 组合器内部，使 `RestaurantsScreen()` 的目标组合器负责连接屏幕组合器与其
    `ViewModel`，从而确保 `RestaurantsScreen()` 和 `RestaurantsViewModel` 之间良好的通信：
- en: '[PRE39]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'With this approach, the destination `composable()` with the initial route of
    `"restaurants"` is the composable that manages and wires up the `RestaurantsScreen()`
    composable to its content by doing the following:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，与初始路由 `"restaurants"` 组合的 `composable()` 是管理并连接 `RestaurantsScreen()`
    组合到其内容的组合器，通过以下步骤实现：
- en: Instantiating `RestaurantsViewModel`
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例化 `RestaurantsViewModel`
- en: Getting and passing the state to `RestaurantsScreen()`
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取并将状态传递给 `RestaurantsScreen()`
- en: Handling the `onItemClick()` and `onFavoriteClick()` callbacks
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理 `onItemClick()` 和 `onFavoriteClick()` 回调
- en: Build and run the application. The app should behave the same.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行应用程序。应用应该表现相同。
- en: You will notice that if you rebuild the project and navigate back to the `RestaurantsScreen()`
    composable, the preview will now function correctly because the `RestaurantsScreen()`
    composable is no longer tied to a `ViewModel`, and so Compose can very easily
    preview its content.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会注意到，如果你重新构建项目并导航回 `RestaurantsScreen()` 组合器，预览现在将正常工作，因为 `RestaurantsScreen()`
    组合器不再绑定到 `ViewModel`，因此 Compose 可以非常容易地预览其内容。
- en: Assignment
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 赋值
- en: In this chapter, we have better decoupled the first screen of the app (the `RestaurantScreen()`
    composable) from its `ViewModel` to promote reusability and testability. As homework,
    you can practice doing the same for the `RestaurantDetailScreen()` composable.
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本章中，我们更好地解耦了应用的第一屏幕（`RestaurantScreen()` 组合器）与其 `ViewModel`，以促进重用性和可测试性。作为作业，你可以练习对
    `RestaurantDetailScreen()` 组合器做同样的处理。
- en: Summary
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have dipped our toes into Clean Architecture in Android.
    We started by understanding a bit about what Clean Architecture means and some
    of the best ways we can achieve this in our Restaurants app, while also covering
    the main benefits of following such a software design philosophy.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们初步探讨了 Android 中的 Clean Architecture。我们首先了解了一些关于 Clean Architecture 的含义以及我们如何在我们的餐厅应用中实现它的一些最佳方法，同时也涵盖了遵循这种软件设计哲学的主要好处。
- en: We started with Clean Architecture in the first section, where we defined the
    Domain layer with Use Cases, and continued refactoring in the second section,
    where we separated the Domain model from Data models.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分，我们开始了 Clean Architecture 的介绍，其中我们定义了领域层与用例，并在第二部分继续重构，将领域模型与数据模型分离。
- en: Then, we improved the architecture of the app by creating a package structure
    and by decoupling the Compose-based UI layer from the `ViewModel` classes even
    further.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过创建包结构和进一步解耦基于 Compose 的 UI 层与 `ViewModel` 类来改进应用的架构。
- en: In the next chapter, we will continue our journey of improving the architecture
    of our application by adopting dependency injection.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续通过采用依赖注入来改进我们应用程序的架构之旅。
- en: Further reading
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Clean Architecture is a very complex subject, and one chapter is simply not
    enough to cover it. However, one of the most important concepts that Clean Architecture
    brings is the Dependency Rule. The Dependency Rule states that within a project,
    dependencies can only point inward.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 清洁架构是一个非常复杂的话题，单靠一章内容是远远不够涵盖的。然而，清洁架构带来的最重要的概念之一就是依赖规则。依赖规则指出，在一个项目中，依赖关系只能指向内部。
- en: To understand what the Dependency Rule is about, let's visualize the layer dependencies
    of our Restaurants app through a simplified version of concentric circles. Each
    concentric circle represents different areas of software with their corresponding
    layer dependencies (and libraries).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解依赖规则是什么，让我们通过同心圆的简化版本来可视化我们的餐厅应用程序的层依赖关系。每个同心圆代表软件的不同领域及其相应的层依赖关系（和库）。
- en: '![Figure 8.7 – The Dependency Rule with layers and components'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.7 – 层和组件的依赖规则'
- en: '](img/B17788_08_07.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17788_08_07.jpg)'
- en: Figure 8.7 – The Dependency Rule with layers and components
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7 – 层和组件的依赖规则
- en: This representation dictates that implementation details should be placed in
    *outer* circles (just as Compose is an implementation detail of the UI layer or
    Retrofit is an implementation detail for the Data layer), while business policies
    (Use Cases from the Domain layer) are placed within the *inner* circle.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这种表示方法规定，实现细节应放置在*外部*圆圈中（正如 Compose 是 UI 层的实现细节，或者 Retrofit 是数据层的实现细节），而业务策略（来自领域层的用例）则放置在*内部*圆圈中。
- en: The purpose of this representation is to enforce the Dependency Rule that states
    how dependencies should only be pointing inward.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这种表示的目的是强制执行依赖规则，该规则指出依赖关系应该只指向内部。
- en: 'The Dependency Rule (expressed with the inward-pointing arrows) showcases the
    following:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖规则（用指向内部的箭头表示）展示了以下内容：
- en: The Presentation layer depends inward on the Domain layer (just like the `ViewModel`
    classes in our app correctly depend on Use Case classes) and how the Data layer
    should also depend inward on the Domain layer (in our app, Use Cases depend on
    `Repository` classes, while it should be the other way around – more on this in
    a second).
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示层依赖于领域层（正如我们应用中的`ViewModel`类正确地依赖于用例类）以及数据层应该如何也依赖于领域层（在我们的应用中，用例依赖于`Repository`类，而应该是相反的——更多内容将在下一部分讨论）。
- en: The Domain layer should not depend on an outer layer – in our app, the Use Cases
    depend on `Repository` classes, which violates the Dependency Rule.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域层不应依赖于外部层——在我们的应用中，用例依赖于`Repository`类，这违反了依赖规则。
- en: The approach of having the Presentation and Data layers (that contain details
    of implementation such as the Compose, Room, and Retrofit libraries) depend on
    the inner Domain layer is beneficial because it allows us to effectively separate
    the business policies (from within the inner circle, that is, the Domain layer)
    from outer layers. Outer layers can frequently change their implementation and
    we don't want these changes to impact the inner Domain layer.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 让表示层和数据层（包含实现细节，如 Compose、Room 和 Retrofit 库）依赖于内部领域层的方法是有益的，因为它允许我们有效地将业务策略（即内部圆圈，也就是领域层）与外部层分离。外部层经常改变其实现，我们不希望这些变化影响到内部领域层。
- en: In our Restaurants app though, the Domain layer depends on the Data layer because
    Use Case classes depend on `Repository` classes. In other words, the Dependency
    Rule is violated because the inner circle (the Domain layer) depends on an outer
    circle.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们的餐厅应用程序中，领域层依赖于数据层，因为用例类依赖于`Repository`类。换句话说，由于内部圆圈（领域层）依赖于外部圆圈，因此违反了依赖规则。
- en: To fix this, we could define an `interface` class for the Data layer (for the
    `Repository` classes) and consider it part of the Domain layer (for now, by moving
    it inside the `domain` package).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以为数据层（对于`Repository`类）定义一个`interface`类，并将其视为领域层的一部分（目前，通过将其移动到`domain`包内部）。
- en: This way, the Use Cases depend on an interface defined within the Domain layer,
    so now, the Domain layer has no outer dependencies. On the other hand, the `Repository`
    class (the Data layer) implements an interface provided by the Domain layer, so
    the Data layer (from the outer circle) now depends on the Domain layer (from the
    inner circle), thereby correctly adhering to the Dependency Rule.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，用例依赖于在领域层内部定义的接口，因此现在领域层没有外部依赖。另一方面，`Repository` 类（数据层）实现了由领域层提供的接口，因此数据层（来自外部圈）现在依赖于领域层（来自内部圈），从而正确地遵守了依赖规则。
- en: Note
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Another way of separating concerns (or layers) and making sure to respect the
    Dependency Rule is to modularize the app into layers, where each layer is a Gradle
    module.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种分离关注点（或层）并确保遵守依赖规则的方法是将应用程序模块化成层，其中每一层都是一个 Gradle 模块。
- en: 'I encourage you to study more about the Dependency Rule in Robert C. Martin''s
    blog, while also checking out other strategies for achieving Clean Architecture:
    [https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html).'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你研究罗伯特·C·马丁的博客中关于依赖规则的更多内容，同时也可以查看实现整洁架构的其他策略：[https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)。
