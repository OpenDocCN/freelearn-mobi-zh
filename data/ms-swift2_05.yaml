- en: Chapter 5. Classes and Structures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章。类和结构体
- en: The first programming language that I learned was BASIC. It was a good language
    to begin programming with, but once I traded in my Commodore Vic-20 for a PCjr
    (yes, I had a PCjr and I really enjoyed it), I realized that there were other,
    more advanced languages out there, and spent a lot of time learning Pascal and
    C. It wasn't until I started college that I heard the term "object-oriented language".
    At that time, object-oriented languages were so new that there were no real courses
    on them, but I was able to experiment a little with C++. After I graduated, I
    left object-oriented programming behind, and it really wasn't until several years
    later, when I started to experiment with C++ again, that I really discovered the
    power and flexibility of object-oriented programming.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我最初学习的编程语言是 BASIC。这是一个开始编程的好语言，但当我用 Commodore Vic-20 交换成 PCjr（是的，我确实有 PCjr，并且真的很喜欢它）时，我意识到还有其他更高级的语言，于是花了很多时间学习
    Pascal 和 C。直到我开始上大学，我才听到“面向对象语言”这个术语。当时，面向对象语言还非常新，没有真正的课程，但我能够尝试使用 C++ 进行一些实验。毕业后，我放弃了面向对象编程，直到几年后，当我再次开始尝试使用
    C++ 时，我才真正发现了面向对象编程的强大和灵活性。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating and using classes and structures
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用类和结构体
- en: Adding properties and property observers to classes and structures
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为类和结构体添加属性和属性观察器
- en: Adding methods to classes and structures
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为类和结构体添加方法
- en: Adding initializers to classes and structures
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为类和结构体添加初始化器
- en: Using access controls
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用访问控制
- en: Creating a class hierarchy
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建类层次结构
- en: Extending a class
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展类
- en: Understanding memory management and ARC
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解内存管理和 ARC
- en: What are classes and structures?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是类和结构体？
- en: 'In Swift, classes and structures are very similar. If we really want to master
    Swift, it is very important to understand what makes classes and structures so
    similar and also what sets them apart because they are the building blocks of
    your applications. Apple describes classes and structures as:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，类和结构体非常相似。如果我们真的想精通 Swift，了解使类和结构体如此相似以及它们之间区别的原因非常重要，因为它们是应用程序的构建块。Apple
    将类和结构体描述为：
- en: '*"Classes and structures are general-purpose, flexible constructs that become
    the building blocks of your program''s code. You define properties and methods
    to add functionality to your classes and structures by using the already familiar
    syntax of constants, variables, and functions."*'
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"类和结构体是通用、灵活的构造，成为你程序代码的构建块。你通过使用已经熟悉的常量、变量和函数的语法来定义属性和方法，为你的类和结构体添加功能。"*'
- en: Let's begin by taking a quick look at some of the similarities between classes
    and structures.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先快速看一下类和结构体之间的一些相似之处。
- en: Similarities between classes and structures
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类和结构体之间的相似性
- en: 'In Swift, classes and structures are more similar than they are in other languages,
    such as Objective-C. The following is a list of some of the features that classes
    and structures share:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，类和结构体比其他语言，如 Objective-C，更为相似。以下是一些类和结构体共有的特性列表：
- en: 'Properties: These are used to store information in our classes and structures'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性：这些用于在类和结构体中存储信息
- en: 'Methods: These provide functionality for our classes and structures'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法：这些为我们的类和结构体提供功能
- en: 'Initializers: These are used when initializing instances of our classes and
    structures'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化器：这些用于初始化我们的类和结构体实例
- en: 'Subscripts: These provide access to values using the subscript syntax'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下标：这些通过下标语法提供对值的访问
- en: 'Extensions: These help in extending both classes and structures'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展：这些有助于扩展类和结构体
- en: Now let's take a quick look at some of the differences between classes and structures.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们快速看一下类和结构体之间的一些区别。
- en: Differences between classes and structures
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类和结构体之间的区别
- en: 'While classes and structures are very similar, there are also several very
    important differences. The following is a list of some of the differences between
    classes and structures in Swift:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然类和结构体非常相似，但也有几个非常重要的区别。以下是在 Swift 中类和结构体之间的一些区别列表：
- en: 'Type: A structure is a value type while a class is a reference type'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型：结构体是一个值类型，而类是一个引用类型
- en: 'Inheritance: A structure cannot inherit from other types while a class can'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承：结构体不能从其他类型继承，而类可以
- en: 'Deinitializers: Structures cannot have custom deinitializers while a class
    can'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化器：在类存在时，结构体不能有自定义的析构器
- en: 'Multiple references: We can have more than one reference to a class instance;
    however, with structures, we cannot'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多重引用：我们可以对一个类的实例有多个引用；然而，对于结构体来说，则不行
- en: Throughout this chapter, we will be emphasizing the differences between classes
    and structures to help us understand when to use each. Before we really dive into
    classes and structures, let's take a look at the difference between value types
    (structures) and reference types (classes). In order to understand when to use
    classes and structures and how to properly use them, it is important to understand
    the difference between value and reference types.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将强调类和结构体之间的区别，以帮助我们了解何时使用哪一个。在我们真正深入类和结构体之前，让我们看看值类型（结构体）和引用类型（类）之间的区别。为了理解何时使用类和结构体以及如何正确使用它们，了解值类型和引用类型之间的区别是非常重要的。
- en: Value versus reference types
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 值类型与引用类型
- en: Structures such as enums and tuples are value types. This means when we pass
    instances of a structure within our application, we pass a copy of the structure
    and not the original structure. Classes are reference types, which means when
    we pass an instance of a class within our application, we pass a reference to
    the original instance. It is very important to understand the difference between
    value and reference types. We will give a very high-level view here, and will
    provide additional details in the *Memory management* section at the end of this
    chapter.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举和元组等结构体是值类型。这意味着当我们在我们应用程序中传递结构体的实例时，我们传递的是结构体的副本，而不是原始结构体。类是引用类型，这意味着当我们在我们应用程序中传递类的实例时，我们传递的是原始实例的引用。理解值类型和引用类型之间的区别非常重要。在这里，我们将提供一个非常高级的概述，并在本章末尾的
    *内存管理* 部分提供更多详细信息。
- en: When we pass structures within our application, we are passing copies of the
    structures and not the original structures. Since a function gets its own copy
    of the structure, it can change it as needed, without affecting the original instance
    of the structure.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在应用程序中传递结构体时，我们传递的是结构体的副本，而不是原始结构体。由于函数获得的是结构体的副本，它可以按需更改它，而不会影响结构体的原始实例。
- en: When we pass an instance of a class within our application, we are passing a
    reference to the original instance of the class. Since we pass an instance of
    a class to a function, the function is getting a reference to the original instance;
    therefore, any changes made within the function will remain once the function
    exits.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在应用程序中传递类的实例时，我们传递的是该类原始实例的引用。由于我们将类的实例传递给函数，函数获得的是原始实例的引用；因此，在函数退出后，函数内所做的任何更改都将保持不变。
- en: To illustrate the difference between value and reference types, let's look at
    a real-world object—a book. If we had a friend that wanted to read *Mastering
    Swift*, we could either buy them their own copy or share ours.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明值类型和引用类型之间的区别，让我们看看一个现实世界的对象——一本书。如果我们有一个朋友想阅读 *Mastering Swift*，我们可以给他们买自己的副本，或者分享我们的副本。
- en: If we bought our friend their own copy of the book, then any notes they made
    within the book would remain in their copy of the book and would not be reflected
    in our copy. This is how pass by value works with structures and variables. Any
    changes that are made to the structure or variable within the function are not
    reflected in the original instance of the structure or variable.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为我们朋友买了书的副本，那么他们在书中做的任何笔记都会保留在他们自己的副本中，而不会反映在我们的副本中。这就是结构体和变量使用按值传递的方式。在函数中对结构体或变量所做的任何更改都不会反映在结构体或变量的原始实例中。
- en: If we share our copy of the book, then any notes they made within the book would
    stay in the book when they returned it to us. This is how pass by reference works.
    Any changes that are made to the instance of the class remains when the function
    exits.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们分享我们的书副本，那么他们在书中做的任何笔记在他们归还给我们时都会留在书中。这就是按引用传递的工作方式。对类的实例所做的任何更改在函数退出后都将保持不变。
- en: To read more about value versus reference types, see the *Memory management*
    section at the end of this chapter.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于值类型与引用类型的信息，请参阅本章末尾的 *内存管理* 部分。
- en: Creating a class or structure
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建类或结构体
- en: 'We use the same syntax to define classes and structures. The only difference
    is we define a class using the `class` keyword, and a structure by using the `struct`
    keyword. Let''s look at the syntax used to create both classes and structures:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的语法来定义类和结构体。唯一的区别是我们使用 `class` 关键字定义类，使用 `struct` 关键字定义结构体。让我们看看创建类和结构体所使用的语法：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, we define a new class named `MyClass` and a new structure
    named `MyStruct`. This effectively creates two new Swift types named `MyClass`
    and `MyStruct`. When we name a new type, we want to use the standard naming convention
    set by Swift where the name is in camel case, with the first letter being uppercase.
    Any method or property defined within the class or structure should also be named
    using camel case with the first letter being lowercase.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了一个名为 `MyClass` 的新类和一个名为 `MyStruct` 的新结构体。这实际上创建了两个新的 Swift 类型，分别名为
    `MyClass` 和 `MyStruct`。当我们命名一个新类型时，我们希望使用 Swift 定义的命名约定，即名称为驼峰式，首字母大写。在类或结构体内部定义的任何方法或属性也应使用驼峰式命名，首字母小写。
- en: Empty classes and structures are not that useful, so let's look at how we can
    add properties to our classes and structures.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 空类和结构体并不那么有用，因此让我们看看我们如何向我们的类和结构体添加属性。
- en: Properties
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性
- en: 'Properties associate values with a class or a structure. There are two types
    of properties, which are as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 属性将值与类或结构体关联。属性有两种类型，如下所示：
- en: 'Stored properties: They store variable or constant values as part of an instance
    of a class or structure. Stored properties can also have property observers that
    can monitor the property for changes and respond with custom actions when the
    value of the property changes.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储属性：它们将变量或常量值作为类或结构体实例的一部分存储。存储属性还可以有属性观察器，可以监视属性的变化，并在属性值发生变化时执行自定义操作。
- en: 'Computed properties: They do not store a value themselves, but retrieve and
    possibly set other properties. The value returned by a computed property can also
    be calculated when it is requested.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算属性：它们本身不存储值，但检索并可能设置其他属性。计算属性的值也可以在请求时计算。
- en: Stored properties
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储属性
- en: 'A stored property is a variable or constant that is stored as part of an instance
    of a class or structure. We can provide a default value for stored properties.
    These are defined with the `var` keyword. Let''s look at how we would use stored
    properties in classes and structures. In the following code, we will create a
    structure named `MyStruct` and a class named `MyClass`. The structure and the
    class both contain two stored properties, `c` and `v`. The stored property `c`
    is a constant because it is defined with the `let` keyword, and `v` is a variable
    because it is defined with the `var` keyword. Let''s take a look at the following
    code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 存储属性是作为类或结构体实例的一部分存储的变量或常量。我们可以为存储属性提供默认值。这些使用 `var` 关键字定义。让我们看看如何在类和结构体中使用存储属性。在以下代码中，我们将创建一个名为
    `MyStruct` 的结构体和一个名为 `MyClass` 的类。结构和类都包含两个存储属性，`c` 和 `v`。存储属性 `c` 是一个常量，因为它使用
    `let` 关键字定义，而 `v` 是一个变量，因为它使用 `var` 关键字定义。让我们看一下以下代码：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As we can see from the example, the syntax to define a stored property is the
    same for both classes and properties. Let''s look at how we would create an instance
    of both the structure and class. The following code creates an instance of the
    `MyStruct` structure named `myStruct` and an instance of the `MyClass` class named
    `myClass`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如示例所示，定义存储属性的语法对类和结构体都是相同的。让我们看看如何创建结构和类的实例。以下代码创建了一个名为 `myStruct` 的 `MyStruct`
    结构体实例和一个名为 `myClass` 的 `MyClass` 类实例：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'One of the differences between a structure and a class is that, by default,
    a structure creates an initializer that lets us populate the stored properties
    when we create an instance of the structure. Therefore, we could also create an
    instance of the `MyStruct` like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体和类之间的一个区别是，默认情况下，结构体会创建一个初始化器，允许我们在创建结构体实例时填充存储属性。因此，我们也可以这样创建 `MyStruct`
    的实例：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding example, the initializer is used to set the variable `v`,
    and the `c` constant will contain the number 5 that is set in the `struct` itself.
    If, for example, we did not give the constant an initial value, as shown in the
    following example, the default initializer would be used to also set the constant
    as well:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，初始化器用于设置变量`v`，而`c`常量将包含在`struct`本身中设置的数字5。例如，如果我们没有为常量提供一个初始值，如以下示例所示，则默认初始化器也会用来设置常量：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following example shows how the initializer for this new `struct` would
    work:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了新`struct`的初始化器将如何工作：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This allows us to define a constant where we set the value when we initialize
    the class or struct at runtime rather than hardcoding the value of the constant
    in our code.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们在运行时初始化类或结构体时设置值，而不是在我们的代码中硬编码常量的值。
- en: The order in which the parameters appear in the initializer is the order that
    we defined them in. In the previous example, we defined the c constant first;
    therefore, it is the first parameter in the initializer. We defined the v parameter
    second; therefore it is the second parameter in the initializer.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化器中参数出现的顺序是我们定义它们的顺序。在之前的示例中，我们首先定义了c常量；因此，它是初始化器中的第一个参数。我们定义了v参数第二个；因此它是初始化器中的第二个参数。
- en: 'To set or read a stored property, we use the standard dot syntax. Let''s look
    at how we would set and read stored properties in Swift:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置或读取存储属性，我们使用标准的点语法。让我们看看在Swift中如何设置和读取存储属性：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Before we move on to computed properties, let''s create a structure and class
    that will represent an employee. We will be using and expanding these throughout
    this chapter to show how classes and structures are similar and how they differ:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续到计算属性之前，让我们创建一个表示员工的结构体和类。我们将在这个章节中使用和扩展这些内容，以展示类和结构体是如何相似以及它们有何不同：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The employee structure is named `EmployeeStruct` and the employee class is
    named `EmployeeClass`. Both the class and structure have three stored properties:
    `firstName`, `lastName`, and `salaryYear`.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 员工结构体命名为`EmployeeStruct`，员工类命名为`EmployeeClass`。类和结构体都有三个存储属性：`firstName`、`lastName`和`salaryYear`。
- en: 'Within our structure or class, we can now access these properties by using
    the name of the property or the `self` keyword. Every instance of a structure
    or class has a property named `self`. This property refers to the instance itself;
    therefore, we can use it to access the properties within the instance. The following
    examples show how we can access the properties with the `self` keyword within
    the instance of the structure or class:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的结构体或类中，我们现在可以通过使用属性名或`self`关键字来访问这些属性。结构体或类的每个实例都有一个名为`self`的属性。这个属性指向实例本身；因此，我们可以使用它来访问实例内的属性。以下示例显示了如何在结构体或类的实例中使用`self`关键字来访问属性：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Computed properties
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算属性
- en: 'Computed properties are properties that do not have backend variables that
    are used to store the values associated with the property. The values of a computed
    property are usually computed when code requests it. You can think of a computed
    property as a function disguised as a property. Let''s take a look at how we would
    define a read-only computed property:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 计算属性是没有用于存储与属性相关值的后端变量的属性。计算属性的值通常在代码请求时计算。你可以将计算属性视为一个伪装成属性的函数。让我们看看我们如何定义一个只读计算属性：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To create a read-only computed property, we begin by defining it as if it were
    a normal variable with the `var` keyword, followed by the variable name, colon
    and the variable type. What comes next is different; we add a curly bracket at
    the end of the declaration and then define a `getter` method that is called when
    the value of our computed property is requested. In the example, the `getter`
    method divides the current value of the `salaryYear` property by `52` to get the
    employee's weekly salary.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个只读计算属性，我们首先使用`var`关键字定义它，就像它是一个普通的变量，然后是变量名，冒号和变量类型。接下来的是不同的；我们在声明末尾添加一个花括号，然后定义一个`getter`方法，当请求计算属性的值时会被调用。在示例中，`getter`方法将`salaryYear`属性的当前值除以`52`以获取员工的周薪。
- en: 'We can simplify the definition of the read-only computed property by removing
    the `get` keyword. We could rewrite the `salaryWeek` function like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过移除`get`关键字来简化只读计算属性的定义。我们可以将`salaryWeek`函数重写如下：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Computed properties are not limited to being read-only, we can also write to
    them. To enable the `salaryWeek` property to be writeable, we would need to add
    a `setter` method. The following example shows how we would add a `setter` method
    that will set the `salaryYear` property, based on the value being passed into
    the `salaryWeek` property:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 计算属性不仅限于只读，我们也可以写入它们。要使 `salaryWeek` 属性可写，我们需要添加一个 `setter` 方法。以下示例显示了如何添加一个
    `setter` 方法，该方法将根据传递给 `salaryWeek` 属性的值设置 `salaryYear` 属性：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can simplify the setter definition by not defining a name for the new value.
    In this case, the value would be assigned to a default variable name, `newValue`.
    The `salaryWeek` computed property could be rewritten like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过不定义新值的名称来简化设置器的定义。在这种情况下，值将被分配给默认变量名，`newValue`。`salaryWeek` 计算属性可以重写如下：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `salaryWeek` computed property, as written in the preceding example, could
    be added to either the `EmployeeClass` class or the `EmployeeStruct` structure
    without any modifications. Let''s see how we would do this by adding the `salaryWeek`
    property to our `EmployeeClass` class:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，`salaryWeek` 计算属性可以添加到 `EmployeeClass` 类或 `EmployeeStruct` 结构体中，无需任何修改。让我们通过将
    `salaryWeek` 属性添加到我们的 `EmployeeClass` 类中来看如何实现这一点：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, let''s look at how we would add the `salaryWeek` computed property to
    the `EmployeeStruct` structure:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何将计算属性 `salaryWeek` 添加到 `EmployeeStruct` 结构体中：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As we can see, the class and structure definitions are the same so far, except
    for the initial class or `struct` keywords are used to define them as either a
    structure or a class.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，类和结构体的定义到目前为止是相同的，只是使用初始的类或 `struct` 关键字来定义它们是结构体还是类。
- en: 'We read and write to a computed property exactly as we would to a stored property.
    Code that is external to the class or structure should not be aware that the property
    is a computer property. Let''s see this in action by creating an instance of the
    `EmployeeStruct` structure:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对计算属性的读写方式与对存储属性的读写方式相同。类或结构体外部代码不应知道该属性是计算属性。让我们通过创建 `EmployeeStruct` 结构体的一个实例来观察这个动作：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding example starts off by creating an instance of the `EmployStruct`
    structure with the `salaryYear` value being set to `39,000`. Next, we print the
    value of the `salaryWeek` property to the `console`. This value is currently `750.00`.
    We then set the `salaryWeek` property to `1000.00` and print out both the `salaryWeek`
    and `salaryYear` properties to the console. The values of the `salaryWeek` and
    `salaryYear` properties are now `1000.00` and `52000` respectively. As we can
    see, in this example, setting either the `salaryWeek` or `salaryYear` property
    changes the values returned by both.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子首先创建了一个 `EmployStruct` 结构体的实例，并将 `salaryYear` 的值设置为 `39,000`。接下来，我们将 `salaryWeek`
    属性的值打印到 `console`。当前这个值是 `750.00`。然后我们将 `salaryWeek` 属性设置为 `1000.00`，并将 `salaryWeek`
    和 `salaryYear` 属性的值都打印到 `console`。现在 `salaryWeek` 和 `salaryYear` 属性的值分别是 `1000.00`
    和 `52000`。正如我们所看到的，在这个例子中，设置 `salaryWeek` 或 `salaryYear` 属性都会改变两个属性返回的值。
- en: Computed properties can be very useful for offering different views of the same
    data. For example, if we had a value that represented the length of something,
    we could store the length in centimeters and then use computed properties that
    calculate the values for meters, millimeters, and kilometers.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 计算属性对于提供相同数据的不同视图非常有用。例如，如果我们有一个表示某物长度的值，我们可以将长度存储为厘米，然后使用计算属性来计算米、毫米和千米的值。
- en: Now, let's take a look at property observers.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看属性观察者。
- en: Property observers
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性观察者
- en: Property observers are called every time the value of the property is set. We
    can add property observers to any non-lazy stored property. We can also add property
    observers to any inherited stored or computed property by overriding the property
    in the subclass. We will look at the *Overriding properties* section a little
    later in this chapter.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 每当属性的值被设置时，都会调用属性观察者。我们可以将属性观察者添加到任何非懒加载的存储属性。我们还可以通过在子类中重写属性来将属性观察者添加到任何继承的存储或计算属性。我们将在本章稍后的
    *重写属性* 部分讨论这个问题。
- en: There are two property observers that we can set in Swift—`willSet` and `didSet`.
    The `willSet` observer is called right before the property is set, and the `didSet`
    observer is called right after the property is set.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，我们可以设置两种属性观察者——`willSet` 和 `didSet`。`willSet` 观察者在属性被设置之前被调用，而 `didSet`
    观察者在属性被设置之后被调用。
- en: 'One thing to note about property observers is that they are not called when
    the value is set during initialization. Let''s look at how we would add a property
    observer to the salary property of our `EmployeeClass` class and `EmployeeStruct`
    structure:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 关于属性观察者需要注意的一点是，当在初始化期间设置值时，它们不会被调用。让我们看看如何向我们的`EmployeeClass`类和`EmployeeStruct`结构的工资属性添加属性观察者：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When we add a property observer to a stored property, we need to include the
    type of the value being stored within the definition of the property. In the preceding
    example, we did not need to define our `salaryYear` property as a `Double` type;
    however, when we add property observers the definition is required.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向存储属性添加属性观察者时，我们需要在属性的定义中包含要存储的值的类型。在先前的例子中，我们不需要将`salaryYear`属性定义为`Double`类型；然而，当我们添加属性观察者时，定义是必需的。
- en: After the property definition, we define a `willSet` observer that simply prints
    out the new value that the `salaryYear` property will be set to. We also define
    a `didSet` observer that will check whether the new value is greater than the
    old value and if so, it will print out that the employee got a raise, otherwise,
    it will print out that the employee did not get a raise.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在属性定义之后，我们定义一个`willSet`观察者，它简单地打印出`salaryYear`属性将被设置的新值。我们还定义了一个`didSet`观察者，它将检查新值是否大于旧值；如果是，它将打印出员工得到了加薪，否则，它将打印出员工没有得到加薪。
- en: 'As with the getter in computed properties, we do not need to define the name
    for the new value for the `willSet` observer. If we do not define a name, the
    new value is put in a constant named `newValue`. The following example shows how
    we would rewrite the previous `willSet` observer without defining a name for the
    new value:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 就像计算属性中的getter一样，我们不需要为`willSet`观察者定义新值的名称。如果我们不定义名称，新值将被放入一个名为`newValue`的常量中。以下示例显示了如何不定义新值的名称来重写之前的`willSet`观察者：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As we have seen, properties are mainly used to store information associated
    with a class or structure, and methods are mainly used to add the business logic
    to a class or structure. Let's look at how we would add methods to class or structure.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，属性主要用于存储与类或结构相关的信息，而方法主要用于向类或结构添加业务逻辑。让我们看看如何向类或结构添加方法。
- en: Methods
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法
- en: 'Methods are functions that are associated with a class or structure. A method,
    like a function, will encapsulate the code for a specific task or functionality
    that is associated with the class or structure. Let''s look at how we would define
    a method in classes and structures. The following code will return the full name
    of the employee by using the `firstName` and `lastName` properties:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 方法是与类或结构相关联的函数。方法，就像函数一样，将封装与类或结构相关联的特定任务或功能的相关代码。让我们看看如何在类和结构中定义方法。以下代码将通过使用`firstName`和`lastName`属性来返回员工的完整姓名：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We define this method exactly as we would define any function. A method is simply
    a function that is associated with a specific class or structure, and everything
    that we learned about functions in the previous chapters applies to methods. The
    `getFullName()` function can be added directly to the `EmployeeClass` class or
    `EmployeeStruct` structure without any modification.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义这个方法就像定义任何函数一样。方法简单地说就是一个与特定类或结构相关联的函数，我们之前章节中学到的关于函数的所有内容都适用于方法。`getFullName()`函数可以直接添加到`EmployeeClass`类或`EmployeeStruct`结构中，无需任何修改。
- en: 'To access a method, we use the same dot syntax we used to access properties.
    The following code shows how we would access the `getFullName()` method of a class
    and a structure:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问方法，我们使用与访问属性相同的点语法。以下代码显示了如何访问类和结构中的`getFullName()`方法：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding example, we initialize an instance of both the `EmployeeClass`
    class and `EmployeeStruct` structure. We populate the structure and class with
    the same information and then use the `getFullName()` method to print the full
    name of the employee to the console. In both cases, `Jon Hoffman` is printed to
    the console.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们初始化了`EmployeeClass`类和`EmployeeStruct`结构的实例。我们用相同的信息填充结构和类，然后使用`getFullName()`方法将员工的完整姓名打印到控制台。在两种情况下，都会打印出`Jon
    Hoffman`到控制台。
- en: 'There is a difference in how we define methods for classes and structures,
    which we need to update property values within the method. Let''s look at how
    we would define a method that gives an employee a raise within the `EmployeeClass`
    class:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义类和结构体的方法方面存在差异，我们需要在方法中更新属性值。让我们看看我们如何在 `EmployeeClass` 类中定义一个给员工加薪的方法：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If we add the preceding code to our `EmployeeClass`, it works as expected and
    when we call the method, with an amount, the employee gets a raise. However, if
    we try to add this method as it is written to the `EmployeeStruct` structure,
    we receive the `Cannot invoke ''+='' with an argument list of type ''(Double,
    Double)''` error. By default, we are not allowed to update property values within
    a method of a structure. If we want to modify a property, we can opt into mutating
    behavior for that method by adding the `mutating` keyword before the `func` keyword
    of the method declaration. Therefore, the following code would be the correct
    way to define the `giveRaise()` method for the `EmployeeStruct` structure:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将前面的代码添加到我们的 `EmployeeClass` 中，它将按预期工作，并且当我们调用该方法并传递一个金额时，员工会得到加薪。然而，如果我们尝试将此方法按原样添加到
    `EmployeeStruct` 结构体中，我们会收到 `Cannot invoke '+=' with an argument list of type
    '(Double, Double)'` 错误。默认情况下，我们不允许在结构体的方法中更新属性值。如果我们想修改属性，我们可以通过在方法声明的 `func`
    关键字之前添加 `mutating` 关键字来选择该方法进入修改行为。因此，以下代码将是定义 `EmployeeStruct` 结构体的 `giveRaise()`
    方法的正确方式：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding examples, we used the `self` property. Every instance of a
    type has a property called `self`, which is the instance itself. We use the `self`
    property to refer to the current instance of the type within the instance itself,
    so when we write `self.salaryYear`, we ask for the value of the `salaryYear` property
    of the current instance.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了 `self` 属性。类型的每个实例都有一个名为 `self` 的属性，它就是该实例本身。我们使用 `self` 属性来在实例本身中引用类型的当前实例，因此当我们写
    `self.salaryYear` 时，我们请求当前实例的 `salaryYear` 属性的值。
- en: 'The `self` property can be used to distinguish between a local variable and
    instance variable that have the same name. Let''s look at an example that illustrates
    this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `self` 属性来区分具有相同名称的局部变量和实例变量。让我们看看一个示例，以说明这一点：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding example, the method accepts an argument with the name, `firstName`.
    There is also a property that has this name. We use the self property to specify
    that we want the instance property with the name, `firstName`, and not the local
    variable with this name.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，方法接受一个名为 `firstName` 的参数。还有一个具有此名称的属性。我们使用 `self` 属性来指定我们想要具有该名称的实例属性，而不是具有此名称的局部变量。
- en: Other than the `mutating` keyword being required for methods that change the
    value of the structure's properties, methods can be defined and used exactly as
    functions are defined and used. Therefore, everything we learned about functions
    in the previous chapter can be applied to methods.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 除了需要 `mutating` 关键字来定义更改结构体属性值的函数外，方法可以像定义和使用函数一样定义和使用。因此，我们之前章节中学到的关于函数的所有内容都可以应用到方法上。
- en: There are times when we want to initialize properties or perform some business
    logic when a class or structure is first initialized. For this, we will use an
    initializer.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们希望在类或结构体首次初始化时初始化属性或执行一些业务逻辑。为此，我们将使用初始化器。
- en: Custom initializers
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义初始化器
- en: Initializers are called when we initialize a new instance of a particular type
    (class or structure). Initialization is the process of preparing an instance for
    use. The initialization process can include setting initial values for stored
    properties, verifying resources, such as web services, files, and so on are available,
    or setting up the UI properly. Initializers are generally used to ensure that
    the instance of the class or structure is properly initialized prior to first
    use.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们初始化特定类型（类或结构体）的新实例时，会调用初始化器。初始化是准备实例以供使用的进程。初始化过程可能包括设置存储属性的初始值、验证资源，例如网络服务、文件等是否可用，或正确设置用户界面。初始化器通常用于确保类或结构体的实例在使用前得到适当的初始化。
- en: 'Initializers are special methods that are used to create a new instance of
    a type. We define an initializer exactly as we would define other methods, but
    we must use the `init` keyword as the name of the initializer to tell the compiler
    that this method is an initializer. In its simplest form, the initializer does
    not accept any arguments. Let''s look at the syntax used to write a simple initializer:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化器是用于创建类型新实例的特殊方法。我们定义初始化器的方式与定义其他方法相同，但我们必须使用 `init` 关键字作为初始化器的名称，以告诉编译器这个方法是初始化器。在其最简单的形式中，初始化器不接受任何参数。让我们看看编写简单初始化器所使用的语法：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This format works for both classes and structures. By default, all classes
    and structures have an empty default initializer that we can override if we choose
    to. We saw these default initializers when we used the `EmployeeClass` class and
    `EmployeeStruct` structure in the previous section. Structures also have an additional
    default initializer, which we saw with the `EmployeeStruct` structure that accepts
    a value for each stored property and initializes them with those values. Let''s
    look at how we would add custom initializers to our `EmployeeClass` class and
    `EmployeeStruct` structure. In the following code, we create three custom initializers
    that will work for both the `EmployeeClass` class and `EmployeeStruct` structure:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这种格式适用于类和结构体。默认情况下，所有类和结构体都有一个空的默认初始化器，我们可以选择覆盖它。我们在使用 `EmployeeClass` 类和 `EmployeeStruct`
    结构体时看到了这些默认初始化器。结构体还有一个额外的默认初始化器，我们在 `EmployeeStruct` 结构体中看到了，它接受每个存储属性的值并将它们初始化为这些值。让我们看看我们如何向我们的
    `EmployeeClass` 类和 `EmployeeStruct` 结构体添加自定义初始化器。在下面的代码中，我们创建了三个自定义初始化器，它们将适用于
    `EmployeeClass` 类和 `EmployeeStruct` 结构体：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The first initializer, `init()`, when used, will set all of the stored properties
    to their default values. The second initializer, `init(firstName: String, lastName:
    String)`, when used, will populate the `firstName` and `lastName` properties with
    the values of the arguments. The third initializer, `init(firstName: String, lastName:
    String, salaryYear: Double)`, will populate all the properties with the values
    of the arguments.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '第一个初始化器 `init()`，当使用时，将所有存储属性设置为它们的默认值。第二个初始化器 `init(firstName: String, lastName:
    String)`，当使用时，将 `firstName` 和 `lastName` 属性填充为参数的值。第三个初始化器 `init(firstName: String,
    lastName: String, salaryYear: Double)`，将所有属性填充为参数的值。'
- en: 'In the previous example we can see that in Swift, unlike Objective-C, an initializer
    does not have a return value. This means that we do not have to define the return
    type for the initializer or have a return statement within the initializer. Let''s
    look at how we would use these initializers:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们可以看到在 Swift 中，与 Objective-C 不同，初始化器没有返回值。这意味着我们不需要为初始化器定义返回类型，或者初始化器内部不需要有返回语句。让我们看看我们如何使用这些初始化器：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The variable `g` uses the `init()` initializer to create an instance of the
    `EmployeeClass` class; therefore, all the properties of this `EmployeeClass` instance
    contain their default values.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `g` 使用 `init()` 初始化器创建 `EmployeeClass` 类的一个实例；因此，这个 `EmployeeClass` 实例的所有属性都包含它们的默认值。
- en: 'The `h` variable uses the `init(firstName: String, lastName: String)` initializer
    to create an instance of the `EmployeeStruct` structure; therefore, the `firstName`
    property of the structure is set to `Me` and the `lastName` property is set to
    `Moe`, which are the two arguments passed into the initializer. The `salaryYear`
    property is still set to the default value of 0.0.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '变量 `h` 使用 `init(firstName: String, lastName: String)` 初始化器创建 `EmployeeStruct`
    结构体的一个实例；因此，结构体的 `firstName` 属性被设置为 `Me`，`lastName` 属性被设置为 `Moe`，这两个参数被传递到初始化器中。`salaryYear`
    属性仍然设置为默认值 0.0。'
- en: 'The `EmployeeClass` sets the `init(firstName: String, lastName: String, salaryYear:
    Double)` initializer to create an instance of the `EmployeeClass` class; therefore,
    the `firstName` property is set to `Me`, the `lastName` property is set to `Moe`,
    and the `salaryYear` is set to `45000`.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`EmployeeClass` 使用 `init(firstName: String, lastName: String, salaryYear: Double)`
    初始化器创建 `EmployeeClass` 类的一个实例；因此，`firstName` 属性被设置为 `Me`，`lastName` 属性被设置为 `Moe`，`salaryYear`
    被设置为 `45000`。'
- en: Since all the initializers are identified with the `init` keyword, the parameters
    and parameter types are used to identify which initializer to use. Therefore,
    Swift provides automatic external names for all of these parameters. In the previous
    example. We can see that when we use an initializer that has parameters, we include
    the parameter names. Let's take a look at internal and external parameter names
    with initializers.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有初始化器都与`init`关键字相关联，因此参数和参数类型被用来识别要使用哪个初始化器。因此，Swift为所有这些参数提供了自动的外部名称。在先前的例子中，我们可以看到当我们使用具有参数的初始化器时，我们会包含参数名称。让我们来看看初始化器中内部和外部参数名称。
- en: Internal and external parameter names
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内部和外部参数名称
- en: Just like functions, the parameters associated with an initializer can have
    separate internal and external names. Unlike functions, if we do not supply external
    parameter names for our parameters, Swift will automatically generate them for
    us. In the previous examples, we did not include external parameter names in the
    definition of the initializers, so Swift created them for us using the internal
    parameter name as the external parameter name.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 就像函数一样，与初始化器关联的参数可以有独立的内部和外部名称。与函数不同，如果我们没有为我们的参数提供外部参数名称，Swift会自动为我们生成它们。在先前的例子中，我们没有在初始化器的定义中包含外部参数名称，所以Swift使用内部参数名称作为外部参数名称。
- en: 'If we wanted to supply our own parameter names, we would do so by putting the
    external function name before the internal function name, exactly as we do with
    any normal function. Let''s look at how we would define our own external parameter
    names by redefining one of the initializers within our `EmployeeClass` class:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要提供自己的参数名称，我们会在内部函数名称之前放置外部函数名称，这与我们对任何正常函数的做法完全一样。让我们看看我们如何通过重新定义`EmployeeClass`类中的一个初始化器来定义我们自己的外部参数名称：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the preceding example, we created the `init(employeeWithFirstName firstName:
    String, lastName lastName: String, andSalary salaryYear: Double)` initializer.
    This initializer will create an instance of the `EmployeeClass` class and populate
    the instance properties with the value of the arguments. In this example, each
    of the parameters has both external and internal property names. Let''s look at
    how we would use this initializer, with the external property names, to create
    an instance of the `EmployeeClass` class:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '在先前的例子中，我们创建了`init(employeeWithFirstName firstName: String, lastName lastName:
    String, andSalary salaryYear: Double)`初始化器。这个初始化器将创建`EmployeeClass`类的一个实例，并用参数的值填充实例属性。在这个例子中，每个参数都有外部和内部属性名称。让我们看看我们如何使用这个初始化器（带有外部属性名称）来创建`EmployeeClass`类的一个实例：'
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Notice that we are now using the external parameter names as we defined in our
    initializer. Using external parameter names can help make our code more readable
    and differentiate between different initializers.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们现在正在使用我们在初始化器中定义的外部参数名称。使用外部参数名称可以帮助使我们的代码更易于阅读，并区分不同的初始化器。
- en: So, what will happen if our initializer fails? For example, what if our class
    relies on a specific resource, such as web service or a specific file that is
    not currently available? This is where failable initializers come in.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果我们的初始化器失败会发生什么？例如，如果我们的类依赖于一个特定的资源，比如网络服务或当前不可用的特定文件，会怎样？这就是failable初始化器发挥作用的地方。
- en: Failable initializers
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Failable初始化器
- en: A failable initializer is an initializer that may fail to initialize the resources
    needed for a class or a structure, thereby rendering the instance unusable. When
    using a failable initializer, the result of the initializer is an optional type,
    containing either a valid instance of the type or nil.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一个failable初始化器是一个可能无法初始化类或结构体所需资源的初始化器，从而使实例不可用。当使用failable初始化器时，初始化器的结果是可选类型，包含该类型的有效实例或nil。
- en: 'An initializer can be made failable by adding a question mark (`?`) after the
    `init` keyword. Let''s look at how we would create a failable initializer that
    will not allow a new employee to be initialized with a salary below `$20,000`
    a year:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在`init`关键字后添加一个问号（`?`）来使初始化器成为failable。让我们看看我们如何创建一个不允许新员工以每年低于$20,000的薪水进行初始化的failable初始化器：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the previous example, we did not include a `return` statement within the
    initializer because Swift does not need to return the initialized instance; however,
    in a failable initializer, if the initialization fails, we will return a `nil`.
    If the initializer successfully initializes the instance, we do not need to return
    anything. Therefore, in our example, if the yearly salary that is passed in is
    below `$20,000` a year, we return `nil`, indicating that the initialization failed,
    otherwise, nothing will be returned. Let''s look at how we would use a failable
    initializer to create an instance of a class or structure:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们没有在初始化器中包含 `return` 语句，因为 Swift 不需要返回初始化的实例；然而，在可失败初始化器中，如果初始化失败，我们将返回
    `nil`。如果初始化器成功初始化了实例，我们不需要返回任何内容。因此，在我们的示例中，如果传入的年薪低于 `$20,000` 一年，我们返回 `nil`，表示初始化失败，否则，将不返回任何内容。让我们看看如何使用可失败初始化器来创建类或结构的实例：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the previous example, we initialize the instance of the `EmployeeClass`
    class with a yearly salary greater than $20,000; therefore, the instance gets
    initialized correctly and the full name of `Jon Hoffman` is printed to the console.
    Now let''s try to initialize an instance of the `EmployeeClass` class with a yearly
    salary less than $20,000 to see how it fails:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用年薪超过 $20,000 初始化 `EmployeeClass` 类的实例；因此，实例被正确初始化，并在控制台打印出 `Jon
    Hoffman` 的全名。现在让我们尝试使用年薪低于 $20,000 初始化 `EmployeeClass` 类的实例，以查看它如何失败：
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the example, the yearly salary that we are attempting to initialize for our
    employee is less than $20,000; therefore, the initialization fails and a `Failed
    to initialize` message is printed to the console.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我们尝试为我们的员工初始化的年薪低于 $20,000；因此，初始化失败，并在控制台打印出“Failed to initialize”消息。
- en: There are times when we want to restrict access to certain parts of our code.
    This enables us to hide implementation details and only expose the interfaces
    we want to expose. This feature is handled with named access controls.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们希望限制对代码中某些部分的访问。这使我们能够隐藏实现细节，仅暴露我们希望暴露的接口。此功能通过命名访问控制来处理。
- en: Access control allows us to restrict the access and visibility to parts of our
    code. This allows us to hide implementation details and only expose the interfaces
    we want the external code to access. We can assign specific access levels to both
    classes and structures. We can also assign specific access levels to properties,
    methods, and initializers that belong to our classes and structures.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 访问控制允许我们限制对代码中某些部分的访问和可见性。这使我们能够隐藏实现细节，仅暴露外部代码希望访问的接口。我们可以为类和结构体分配特定的访问级别。我们还可以为属于我们的类和结构体的属性、方法和初始化器分配特定的访问级别。
- en: 'In Swift, there are three access levels:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，有三个访问级别：
- en: '**Public**: This is the most visible access control level. It allows us to
    use the property, method, class, and so on anywhere we want to import the module.
    Basically, anything can use a property, method, class, and so on that has an access
    control level of public. This level is primarily used by frameworks to expose
    the framework''s public API.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Public**：这是最可见的访问控制级别。它允许我们在任何我们想要导入模块的地方使用属性、方法、类等。基本上，任何具有公共访问控制级别的属性、方法、类等都可以使用。此级别主要用于框架，以暴露框架的公共
    API。'
- en: '**Internal**: This is the default access level. This access level allows us
    to use the property, method, class, and so on in the defining source as well as
    the module that the source is in (the application or framework). If this level
    is used in a framework, it lets other parts of the framework use the property,
    method, class, and so on, but code outside the framework will be unable to access
    it.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Internal**：这是默认的访问级别。此访问级别允许我们在定义源以及源所在的模块（应用程序或框架）中使用属性、方法、类等。如果在此级别中使用框架，它允许框架的其他部分使用属性、方法、类等，但框架外部的代码将无法访问它。'
- en: '**Private**: This is the least visible access control level. It only allows
    us to use the property, method, class, and so on in the source file that defines
    it.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Private**：这是最不可见的访问控制级别。它只允许我们在定义它的源文件中使用属性、方法、类等。'
- en: If we are writing code that will be self-contained within a single application
    and there is no need for it to be made available outside the application, then
    we can largely ignore access controls. The default access level of internal already
    matches this requirement. We may, however, want to hide parts of the implementation,
    which can be done by setting the access level to private, but that should be an
    exception and not the rule.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在编写将在单个应用程序内自包含的代码，并且不需要将其提供给应用程序外部，那么我们可以很大程度上忽略访问控制。内部默认的访问级别已经符合这一要求。然而，我们可能仍然想隐藏实现的一部分，这可以通过将访问级别设置为私有来实现，但这应该是一个例外而不是规则。
- en: When we are developing frameworks, the access controls really become useful.
    We would need to mark the public facing interfaces as public, so other modules
    such as applications that import the framework can use them. We would then use
    the internal and private access control levels to mark the interfaces that we
    want to use internally to the framework and the source file, respectively.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开发框架时，访问控制变得非常有用。我们需要将面向公众的接口标记为公共，以便其他模块，如导入框架的应用程序，可以使用它们。然后，我们将使用内部和私有访问控制级别来标记我们希望在框架和源文件内部使用的接口。
- en: 'To define access levels, we place the name of the level before the definition
    of the entity. The following code shows examples of how we would add access levels
    to several entities:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义访问级别，我们在实体的定义之前放置级别的名称。以下代码显示了如何向几个实体添加访问级别的示例：
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: There are some limitations with access controls, but these limitations are there
    to ensure that access levels in Swift follow a simple guiding principle—*no entity
    can be defined in terms of another entity that has a lower (more restrictive)
    access level*. What this means is we cannot assign a higher (less restrictive)
    access level to an entity when it relies on another entity that has a lower (more
    restrictive) access level.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在访问控制方面存在一些限制，但这些限制是为了确保 Swift 中的访问级别遵循一个简单的指导原则——*没有实体可以被定义为低于（更限制性）访问级别的另一个实体的术语*。这意味着当我们依赖一个具有较低（更限制性）访问级别的实体时，我们不能将较高的（较少限制性）访问级别分配给该实体。
- en: 'As following examples:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下示例所示：
- en: We cannot mark a method as being public when one of the arguments or the return
    type has an access level of private because external code would not have access
    to the private type
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果其中一个参数或返回类型具有私有访问级别，我们不能将方法标记为公共，因为外部代码无法访问私有类型。
- en: We cannot set the access level of a method or property to public when the class
    or structure has an access level of private because external code would not be
    able to access the constructor when the class is private
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果类或结构体的访问级别为私有，我们不能将方法或属性的访问级别设置为公共，因为外部代码无法在类为私有时访问构造函数。
- en: Inheritance
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: The concept of inheritance is a basic object-oriented development concept. Inheritance
    allows a class to be defined as having a certain set of characteristics and then
    other classes can be derived from that class. The derived class inherits all of
    the features of the class it is inheriting from (unless the derived class overrides
    those characteristics) and then usually adds additional characteristics of its
    own.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 继承的概念是面向对象开发的基本概念。继承允许一个类被定义为具有一组特定的特征，然后其他类可以从该类派生。派生类继承了它所继承的类的所有特征（除非派生类覆盖了这些特征），然后通常还会添加它自己的额外特征。
- en: With inheritance, we can create what is known as a class hierarchy. In a class
    hierarchy, the class at the top of the hierarchy is known as the **base class**
    and the derived classes are known as **subclasses**. We are not limited to only
    creating subclasses from a base class; we can also create subclasses from other
    subclasses. The class that a subclass is derived from is known as the parent or
    superclass. In Swift, a class can have only one parent class, known as single
    inheritance.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通过继承，我们可以创建所谓的类层次结构。在类层次结构中，层次结构顶部的类被称为**基类**，派生类被称为**子类**。我们不仅限于仅从基类创建子类；我们还可以从其他子类创建子类。子类所继承的类被称为父类或超类。在
    Swift 中，一个类只能有一个父类，这被称为单一继承。
- en: Note
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Inheritance is one of the fundamental differences that separate classes from
    structures. Classes can be derived from a parent or super class, but a structure
    cannot be.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是区分类和结构体的基本差异之一。类可以从父类或超类派生，但结构体不能。
- en: Subclasses can call and access the properties, methods, and subscripts of their
    super class. They can also override the properties, methods, and subscripts of
    their super class. Subclasses can add property observers to properties that they
    inherit from a super class, so they can be notified when the values of the properties
    change. Let's look at an example that illustrates how inheritance works in Swift.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 子类可以调用和访问其超类的属性、方法和下标。它们还可以覆盖其超类的属性、方法和下标。子类可以向从超类继承的属性添加属性观察者，以便在属性值发生变化时收到通知。让我们看看一个示例，说明
    Swift 中继承是如何工作的。
- en: 'We will start off by defining a base class named `Plant`. The `Plant` class
    will have two properties, `height` and `age`. It will also have one method, `growHeight()`.
    The `height` property will represent the height of the plant, the `age` property
    will represent the age of the plant, and the `growHeight()` method will be used
    to increase the height of the plant. Here is how we would define the `Plant` class:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定义一个名为 `Plant` 的基类。`Plant` 类将有两个属性，`height` 和 `age`。它还将有一个方法，`growHeight()`。`height`
    属性将代表植物的高度，`age` 属性将代表植物的年龄，`growHeight()` 方法将用于增加植物的高度。以下是定义 `Plant` 类的方法：
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now that we have our `Plant` base class, let''s see how we would define a subclass
    of it. We will name this subclass `Tree`. The `Tree` class will inherit the `age`
    and `height` properties of the `Plant` class and add one additional property named
    `limbs`. It will also inherit the `growHeight()` method of the `Plant` class and
    add two additional methods: `limbGrow()`, where a new limbs is grown, and `limbFall()`,
    where one of the limbs falls off the tree. Let''s have a look at the following
    code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了 `Plant` 基类，让我们看看我们如何定义它的子类。我们将把这个子类命名为 `Tree`。`Tree` 类将继承 `Plant` 类的
    `age` 和 `height` 属性，并添加一个额外的属性名为 `limbs`。它还将继承 `Plant` 类的 `growHeight()` 方法，并添加两个额外的方法：`limbGrow()`，用于生长新的枝条，以及
    `limbFall()`，用于树枝从树上掉落。让我们看看以下代码：
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We indicate that a class has a super class by adding a colon and the name of
    the super class to the end of the class definition. In the `Tree` example, we
    indicated that the `Tree` class has a super class named `Plant`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在类定义的末尾添加一个冒号和超类的名称来表示一个类有一个超类。在 `Tree` 示例中，我们表明 `Tree` 类有一个名为 `Plant` 的超类。
- en: 'Now, let''s look at how we could use the `Tree` class that inherited the `age`
    and `height` properties from the `Plant` class:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何使用从 `Plant` 类继承来的 `age` 和 `height` 属性的 `Tree` 类：
- en: '[PRE34]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The preceding example begins by creating an instance of the `Tree` class. We
    then set the `age` and `height` properties to `5` and `4`, respectively, and add
    two limbs to the tree by calling the `limbGrow()` method twice.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下面的示例开始，我们创建了一个 `Tree` 类的实例。然后我们将 `age` 和 `height` 属性分别设置为 `5` 和 `4`，并通过调用
    `limbGrow()` 方法两次来给树添加两个枝条。
- en: 'We now have a base class named `Plant` that has a subclass named `Tree`. This
    means that the super (or parent) class of `Tree` is the `Plant` class. This also
    means that one of the subclasses (or child classes) of `Plant` is named `Tree`.
    There are, however, lots of different kinds of trees in the world. Let''s create
    two subclasses from the `Tree` class. These subclasses will be the `PineTree`
    class and the `OakTree` class:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个名为 `Plant` 的基类，它有一个名为 `Tree` 的子类。这意味着 `Tree` 的超类（或父类）是 `Plant` 类。这也意味着
    `Plant` 的一个子类（或子类）被命名为 `Tree`。然而，世界上有各种各样的树木。让我们从 `Tree` 类创建两个子类。这两个子类将是 `PineTree`
    类和 `OakTree` 类：
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The class hierarchy now looks like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的类层次结构看起来是这样的：
- en: '![Inheritance](img/B05115_05_01.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![继承](img/B05115_05_01.jpg)'
- en: It is important to keep in mind that in Swift, a class can have multiple subclasses;
    however, a class can have only one super class. There are times when a subclass
    needs to provide its own implementation of a method or property that it inherited
    from its super class. This is known as overriding.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，一个类可以有多个子类；然而，一个类只能有一个超类。有时子类需要为其从超类继承来的方法或属性提供自己的实现。这被称为覆盖。
- en: Overriding methods and properties
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 覆盖方法和属性
- en: To override a method, property, or subscript, we need to prefix the definition
    with the `override` keyword. This tells the compiler that we intend to override
    something in the super class and that we did not make a duplicate definition by
    mistake. The `override` keyword does prompt the Swift compiler to verify that
    the super class (or one of its parents) has a matching declaration that can be
    overridden. If it cannot find a matching declaration in one of the super classes,
    an error will be thrown.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要重写一个方法、属性或索引，我们需要在定义前加上`override`关键字。这告诉编译器我们打算重写超类中的某个东西，并且我们没有错误地创建了重复的定义。`override`关键字会提示Swift编译器验证超类（或其父类之一）中是否存在可以重写的匹配声明。如果它在一个超类中找不到匹配的声明，将会抛出错误。
- en: Overriding methods
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重写方法
- en: 'Let''s look at how we would override a method. We will start by adding a `getDetails()`
    method to the `Plant` class that we will then override in the child classes. The
    following code shows how the new Plant class looks similar to with the `getDetails()`
    method added:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何重写一个方法。我们将首先向`Plant`类添加一个`getDetails()`方法，然后将在子类中重写它。以下代码显示了添加了`getDetails()`方法后的新`Plant`类的外观：
- en: '[PRE36]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now let''s see how we would override the `getDetails()` method in the `Tree`
    class:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何在`Tree`类中重写`getDetails()`方法：
- en: '[PRE37]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The thing to note here is that we do not use the `override` keyword in the
    `Plant` class because it is the first class to implement this method; however,
    we do include it in the `Tree` class since we are overriding the `getDetails()`
    method from the `Plant` class. Now, let''s see what happens if we call the `getDetails()`
    method from an instance of the `Plant` and `Tree` classes:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的是，我们在`Plant`类中不使用`override`关键字，因为它是最先实现此方法的类；然而，我们在`Tree`类中包含它，因为我们正在重写从`Plant`类继承的`getDetails()`方法。现在，让我们看看如果我们从一个`Plant`和`Tree`类的实例中调用`getDetails()`方法会发生什么：
- en: '[PRE38]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The previous example would print the following two lines to the console:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子会在控制台打印以下两行：
- en: '[PRE39]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As we can see, the `getDetails()` method in the `Tree` subclass overrides the
    `getDetails()` of its parent `Plant` class.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`Tree`子类中的`getDetails()`方法重写了其父类`Plant`中的`getDetails()`方法。
- en: 'Inside the `Tree` class, we can still call the `getDetails()` method (or any
    overridden method, property, or subscript) of its super class by using the `super`
    prefix. Let''s see how we would call the `getDetails()` method of the `Plant`
    class from an instance of the `Tree` class. We will begin by replacing the `getDetails()`
    method in the `Plant` class with the following method that will generate a string
    containing the values of the `height` and `age` properties. Let''s take a look
    at the following code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Tree`类内部，我们仍然可以通过使用`super`前缀来调用其超类（在这种情况下是`Plant`类）的`getDetails()`方法（或任何重写的方法、属性或索引）。让我们看看如何从一个`Tree`类的实例中调用`Plant`类的`getDetails()`方法。我们将首先将`Plant`类中的`getDetails()`方法替换为以下方法，该方法将生成包含`height`和`age`属性值的字符串。让我们看一下以下代码：
- en: '[PRE40]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the preceding code, we are changing the `getDetails()` method to return
    a string that contains the `height` and `age` of the plant. Now let''s replace
    the `getDetails()` method for the `Tree` class with the following method:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将`getDetails()`方法更改为返回一个包含植物`height`和`age`的字符串。现在让我们用以下方法替换`Tree`类的`getDetails()`方法：
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the preceding example, we begin by calling the `getDetails()` method of
    the super class (the `Plant` class in this case) to get a string containing the
    tree''s `height` and `age`. We then build a new string object that contains the
    results of the `getDetails()` method from the super class, adds the number of
    limbs to it and then returns it. Let''s look at what happens if we call the `getDetails()`
    method of the `Tree` class:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们首先调用超类（在这种情况下是`Plant`类）的`getDetails()`方法，以获取包含树木的`height`和`age`的字符串。然后我们构建一个新的字符串对象，包含从超类中调用`getDetails()`方法的结果，将其添加到其中，然后返回它。让我们看看如果我们调用`Tree`类的`getDetails()`方法会发生什么：
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If we run the preceding code, the following line would be printed to the console:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的代码，控制台将打印以下行：
- en: '[PRE43]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As we can see, the string that is returned contains the `height` and `age` information
    from the `Plant` class and the limbs information from the `Tree` class.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，返回的字符串包含了来自`Plant`类的`height`和`age`信息以及来自`Tree`类的树枝信息。
- en: 'We can also chain the overridden methods. Let''s see what happens if we add
    the following method to the `OakTree` class:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以链式调用重写的方法。让我们看看如果我们向`OakTree`类添加以下方法会发生什么：
- en: '[PRE44]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'When we call the `getDetails()` method of an instance of the `OakTree` class,
    it calls the `getDetails()` method of its super class (the `Tree` class). The
    `getDetails()` method of the `Tree` class also calls the `getDetails()` method
    of its super class (the `Plant` class). The `getDetails()` method of the `Tree`
    class will finally create a string object that contains the `height` and `age`
    from the `Plant` class, the `limbs` from the `Tree` class, and the `leaves` from
    the `OakTree` class. Let''s look at an example of this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 `OakTree` 类实例的 `getDetails()` 方法时，它会调用其超类（`Tree` 类）的 `getDetails()` 方法。`Tree`
    类的 `getDetails()` 方法也会调用其超类（`Plant` 类）的 `getDetails()` 方法。`Tree` 类的 `getDetails()`
    方法最终将创建一个包含来自 `Plant` 类的 `height` 和 `age`、来自 `Tree` 类的 `limbs` 以及来自 `OakTree`
    类的 `leaves` 的字符串对象。让我们看看这个例子：
- en: '[PRE45]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If we run the preceding code, we would see the following line printed to the
    console:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的代码，我们会在控制台看到以下行打印出来：
- en: '[PRE46]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Overriding properties
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重写属性
- en: We can provide custom `getter` and `setter` to override any inherited property.
    When we override a property, we must provide the name and the type of property
    we are overriding, so the compiler can verify one of the classes in the class
    hierarchy has a matching property to override. While overriding properties are
    not as common as overriding methods, it is good for us to know how to do this
    when we need.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以提供自定义的 `getter` 和 `setter` 来重写任何继承的属性。当我们重写一个属性时，我们必须提供我们正在重写的属性名称和类型，以便编译器可以验证类层次结构中的某个类是否有一个匹配的重写属性。虽然重写属性不如重写方法常见，但当我们需要时了解如何做是好的。
- en: 'Let''s see how we would override a property by adding the following method
    to our `Plant` class:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何通过向我们的 `Plant` 类添加以下方法来重写属性：
- en: '[PRE47]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `description` property is a basic read-only property. This property returns
    the string, `Base class is Plant.`. Now let''s override this property by adding
    the following property to the `Tree` class:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`description` 属性是一个基本的只读属性。该属性返回字符串 `Base class is Plant.`。现在让我们通过向 `Tree`
    类添加以下属性来重写这个属性：'
- en: '[PRE48]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: When we override a property, we use the same `override` keyword that we use
    when we override a method. The `override` keyword tells the compiler that we want
    to override a property, so the compiler can verify that another class in the class
    hierarchy contains a matching property to override. We then implement the property
    as we would any other property. Calling the `description` property of the tree
    would result in the `Base class is Plant. I am a Tree class.`. string being returned.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们重写一个属性时，我们使用与重写方法时相同的 `override` 关键字。`override` 关键字告诉编译器我们想要重写一个属性，因此编译器可以验证类层次结构中的另一个类是否包含一个匹配的重写属性。然后我们像实现任何其他属性一样实现该属性。调用树的
    `description` 属性将返回字符串 `Base class is Plant. I am a Tree class.`。
- en: There are times when we want to prevent a subclass from overriding the properties
    and methods. There are also times when we want to prevent an entire class from
    being subclassed. Let's see how we do this.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们可能想要防止子类重写属性和方法。也有时候，我们可能想要防止整个类被继承。让我们看看我们如何做到这一点。
- en: Preventing overrides
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防止重写
- en: To prevent overrides or subclassing, we use the `final` keyword. To use the
    `final` keyword, we add it before the item's definition. Examples are `final func`,
    `final var`, and `final class`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止重写或子类化，我们使用 `final` 关键字。要使用 `final` 关键字，我们将其添加到项的定义之前。例如，有 `final func`、`final
    var` 和 `final class`。
- en: Any attempt to override an item marked final will throw a compile-time error.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 任何尝试重写标记为 `final` 的项都会抛出编译时错误。
- en: Protocols
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协议
- en: There are times when we would like to describe the implementations (methods,
    properties, and other requirements) of a class without actually providing the
    implementation. For this, we would use protocols.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们可能想要描述一个类的实现（方法、属性和其他要求），而不实际提供实现。为此，我们会使用协议。
- en: Protocols define a blueprint of methods, properties, and other requirements
    for a class or a structure. A class or a structure can then provide an implementation
    that conforms to those requirements. The class or structure that provides the
    implementation is said to conform to the protocol.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 协议定义了一个类或结构的方法、属性和其他要求的蓝图。然后，类或结构可以提供一个符合这些要求的实现。提供实现的类或结构被称为符合该协议。
- en: Protocol syntax
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协议语法
- en: 'The syntax to define a protocol is very similar to how we define a class or
    a structure. The following example shows the syntax used to define a protocol:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 定义协议的语法与我们定义类或结构体非常相似。以下示例显示了定义协议时使用的语法：
- en: '[PRE49]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We state that a class or structure conforms to a particular protocol by placing
    the name of the protocol after the class or structure''s name, separated by a
    colon. Here is an example of how we would state that a class conforms to the `MyProtocol`
    protocol:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在类或结构体名称之后放置协议名称，并用冒号分隔来声明一个类或结构体符合特定的协议。以下是一个示例，说明我们如何声明一个类符合 `MyProtocol`
    协议：
- en: '[PRE50]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'A class or a structure can conform to multiple protocols. We would list the
    protocols that the class or structure conforms to by separating them with commas.
    The following example shows how we would state that our class conforms to multiple
    protocols:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类或结构体可以符合多个协议。我们会通过逗号分隔来列出类或结构体符合的协议。以下示例显示了如何声明我们的类符合多个协议：
- en: '[PRE51]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'When we need a class to inherit from a super class and implement a protocol,
    we would list the super class first, followed by the protocols. The following
    example illustrates this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要一个类继承自一个超类并实现一个协议时，我们会首先列出超类，然后是协议。以下示例说明了这一点：
- en: '[PRE52]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Property requirements
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性要求
- en: A protocol can require that the conforming class or structure provide certain
    properties with a specified name and type. The protocol does not say if the property
    should be a stored or computed property because the implementation details are
    left up to the conforming class or structure.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 协议可以要求符合该协议的类或结构提供具有指定名称和类型的某些属性。协议没有说明属性应该是存储属性还是计算属性，因为实现细节留给了符合协议的类或结构。
- en: 'When defining a property within a protocol, we must specify whether the property
    is a read-only or a read-write property by using the `get` and `set` keywords.
    Let''s look at how we would define properties within a protocol by creating a
    `FullName` protocol:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在协议中定义属性时，我们必须使用 `get` 和 `set` 关键字来指定属性是只读的还是可读写的。让我们通过创建一个 `FullName` 协议来看看如何在协议中定义属性：
- en: '[PRE53]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `FullName` protocol defines two properties, which any class or structure
    that conforms to the protocol must implement. These are the `firstName` and `lastName`
    properties. Both these properties in the `FullName` protocol are read-write properties.
    If we wanted to specify that the property is read-only, we would define it with
    only the `get` keyword, like this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`FullName` 协议定义了两个属性，任何符合该协议的类或结构都必须实现这些属性。这些属性是 `firstName` 和 `lastName` 属性。在
    `FullName` 协议中，这两个属性都是可读写属性。如果我们想指定属性是只读的，我们可以只使用 `get` 关键字来定义它，如下所示：'
- en: '[PRE54]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let''s see how we would create a `Scientist` class that conforms to this protocol:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何创建一个符合此协议的 `Scientist` 类：
- en: '[PRE55]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If we had forgotten to include either the `firstName` or `lastName` property,
    we would have received a `Scientist does not conform to protocol 'FullName'` error
    message. We also need to make sure that the type of the property is the same.
    For example, if we changed the `lastName` definition in the `Scientist` class
    to `var lastName = 42`, we would also receive a `Scientist does not conform to
    protocol 'FullName'` error message because the protocol specifies that we must
    have a `lastName` property of the string type.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们忘记包含 `firstName` 或 `lastName` 属性中的任何一个，我们会收到 `Scientist does not conform
    to protocol 'FullName'` 错误信息。我们还需要确保属性的类型相同。例如，如果我们将 `Scientist` 类中的 `lastName`
    定义更改为 `var lastName = 42`，我们也会收到 `Scientist does not conform to protocol 'FullName'`
    错误信息，因为协议指定我们必须有一个字符串类型的 `lastName` 属性。
- en: Method requirements
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法要求
- en: A protocol can require that the conforming class or structure provide certain
    methods. We define a method within a protocol exactly as we do within a normal
    class or structure, except without the curly braces or method body. Let's add
    a `getFullName()` method to our `FullName` protocol and `Scientist` class.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 协议可以要求符合该协议的类或结构提供某些方法。我们可以在协议中定义一个方法，就像在普通类或结构体中定义一样，只是不需要花括号或方法体。让我们向我们的 `FullName`
    协议和 `Scientist` 类添加一个 `getFullName()` 方法。
- en: 'The following example shows how the `FullName` protocol would look with the
    `getFullName()` method added:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了添加了 `getFullName()` 方法的 `FullName` 协议的外观：
- en: '[PRE56]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, we will need to add a `getFullName()` method to our Scientist class so
    that it will properly conform to the `FullName` protocol:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在我们的 `Scientist` 类中添加一个 `getFullName()` 方法，以便它能够正确符合 `FullName` 协议：
- en: '[PRE57]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Structures can conform to Swift protocols exactly as classes do. The following
    example shows how we can create a `FootballPlayer` structure that conforms to
    the `FullName` protocol:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体可以像类一样符合 Swift 协议。以下示例展示了我们如何创建一个符合 `FullName` 协议的 `FootballPlayer` 结构体：
- en: '[PRE58]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: When a class or structure conforms to a Swift protocol, we can be sure that
    it has implemented the required properties and methods. This can be very useful
    when we want to ensure that certain properties or methods are implemented over
    various classes, as our preceding examples show.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类或结构体符合 Swift 协议时，我们可以确信它已经实现了必需的属性和方法。这在我们想要确保在多个类中实现某些属性或方法时非常有用，如我们前面的例子所示。
- en: 'Protocols are also very useful when we want to decouple our code from requiring
    specific classes or structures. The following code shows how we would decouple
    our code using the `FullName` protocol, the `Scientist` class, and the `FootballPlayer`
    structure that we have already built:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 协议在我们要将代码与特定的类或结构体解耦时也非常有用。以下代码展示了我们如何使用 `FullName` 协议、`Scientist` 类和已经构建的 `FootballPlayer`
    结构体来解耦我们的代码：
- en: '[PRE59]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In the preceding code, we begin by creating an instance of the `Scientist` class
    and the `FootballPlayer` structure. We then create a `person` variable that is
    of the `FullName` (protocol) type and set it to the `scientist` instance that
    we just created. We then call the `getFullName()` method to retrieve our description.
    This will print out the `Kara Hoffman studies Physics` message to the console.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先创建了一个 `Scientist` 类的实例和一个 `FootballPlayer` 结构体的实例。然后我们创建了一个 `person`
    变量，其类型为 `FullName`（协议），并将其设置为刚刚创建的 `scientist` 实例。然后我们调用 `getFullName()` 方法来获取我们的描述。这将打印出
    `Kara Hoffman 研究物理学` 的消息到控制台。
- en: We then set the `person` variable equal to the `player` instance and call the
    `getFullName()` method again. This will print out the `Dan Marino has the number
    13` message to the console.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 接着我们将 `person` 变量设置为 `player` 实例，并再次调用 `getFullName()` 方法。这将打印出 `Dan Marino
    穿着号码 13` 的消息到控制台。
- en: As we can see, the `person` variable does not care what the actual implementation
    class or structure is. Since we defined the `person` variable to be of the `FullName`
    type, we can set the `person` variable to an instance of any class or structure
    that conforms to the `FullName` protocol.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`person` 变量并不关心实际的实现类或结构体是什么。由于我们将 `person` 变量定义为 `FullName` 类型，因此我们可以将
    `person` 变量设置为任何符合 `FullName` 协议的类或结构体的实例。
- en: Optional requirements
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选要求
- en: There are times when we want protocols to define optional requirements, that
    is, methods or properties that are not required to be implemented. To use optional
    requirements, we need to start off by marking the protocol with the `@objc` attribute.
    To mark a property or method as optional, we use the `optional` keyword.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们希望协议定义可选要求，也就是说，不是必须实现的方法或属性。要使用可选要求，我们需要首先使用 `@objc` 属性标记协议。要将属性或方法标记为可选，我们使用
    `optional` 关键字。
- en: Note
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: One very important thing to note about using the `@objc` attribute is that only
    classes can adopt protocols marked with it; structures cannot adopt these protocols.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `@objc` 属性时，有一点非常重要需要注意，那就是只有类可以采用标记了 `@objc` 属性的协议；结构体不能采用这些协议。
- en: 'Let''s look at how we would use the `optional` keyword to define optional properties
    and methods:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 `optional` 关键字来定义可选属性和方法：
- en: '[PRE60]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In the `Phone` protocol we just created, we defined a required property named
    `phoneNumber`, and an optional property named `emailAddress`. Also, in the `Phone`
    protocol, we defined a required function named `dialNumber()` and an optional
    function named `getEmail()`. This means that a class that adopts the `Phone` protocol
    must provide a `phoneNumber` property and a `dialNumber()` method. A class that
    adopts the Phone protocol can also optionally provide an `emailAddress` property
    and a `getEmail()` method, but it is not required too.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚刚创建的 `Phone` 协议中，我们定义了一个必需的属性名为 `phoneNumber`，以及一个可选属性名为 `emailAddress`。此外，在
    `Phone` 协议中，我们还定义了一个必需的函数名为 `dialNumber()` 和一个可选函数名为 `getEmail()`。这意味着采用 `Phone`
    协议的类必须提供一个 `phoneNumber` 属性和一个 `dialNumber()` 方法。采用 `Phone` 协议的类也可以选择性地提供一个 `emailAddress`
    属性和一个 `getEmail()` 方法，但这不是必需的。
- en: Swift 2 adds protocol extensions to Swift. This is a very exciting and important
    feature in the Swift language. To read about protocol extensions, please refer
    to [Chapter 6](ch06.html "Chapter 6. Using Protocols and Protocol Extensions"),
    *Using Protocols and Protocol Extensions*.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 2 为 Swift 添加了协议扩展功能。这是 Swift 语言中一个非常激动人心且重要的特性。要了解有关协议扩展的内容，请参阅[第 6 章](ch06.html
    "第 6 章。使用协议和协议扩展")，*使用协议和协议扩展*。
- en: There are times when we need to add additional functionality to an existing
    class or structure. To do this, we use extensions.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们需要向现有的类或结构体添加额外的功能。为此，我们使用扩展。
- en: Extensions
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展
- en: With extensions, we can add new properties, methods, initializers, and subscripts,
    or make an existing class or structure conform to a protocol. One thing to note
    is that extensions cannot override the existing functionality.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 使用扩展，我们可以添加新的属性、方法、构造函数和下标，或者使现有的类或结构体符合一个协议。需要注意的是，扩展不能覆盖现有的功能。
- en: 'To define an extension, we use the `extension` keyword, followed by the type
    that we are extending. The following example shows how we would create an extension
    that extends the string class:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个扩展，我们使用 `extension` 关键字，后跟我们要扩展的类型。以下示例展示了我们如何创建一个扩展来扩展字符串类：
- en: '[PRE61]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Let''s see how extensions work by adding a `reverse()` method and a `firstLetter`
    property to Swift''s standard string class:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过向 Swift 的标准字符串类添加一个 `reverse()` 方法和 `firstLetter` 属性来了解扩展是如何工作的：
- en: '[PRE62]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: When we extend an existing class or structure, we define properties, methods,
    initializers, subscripts, and protocols in exactly the same way as we would normally
    define them in a standard class or structure. In the string extension example,
    we see that we define the `reverse()` method and the `firstLetter` property exactly
    as we would define them in a normal class.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们扩展一个现有的类或结构体时，我们定义属性、方法、构造函数、下标和协议的方式与我们在标准类或结构体中通常定义它们的方式完全相同。在字符串扩展示例中，我们看到我们定义
    `reverse()` 方法和 `firstLetter` 属性的方式与我们在正常类中定义它们的方式完全相同。
- en: Extensions are very useful for adding additional functionality to classes and
    structures from external frameworks, even for Apple's frameworks, as demonstrated
    in the examples. It is preferred to use extensions to add additional functionality
    to classes from external frameworks rather than subclassing because it allows
    us to use the classes provided by the frameworks throughout our code.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展对于向外部框架中的类和结构体添加额外功能非常有用，甚至对于苹果的框架也是如此，如示例所示。我们更倾向于使用扩展来向外部框架中的类添加额外功能，而不是子类化，因为这允许我们在整个代码中使用框架提供的类。
- en: Memory management
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存管理
- en: As I mentioned at the start of this chapter, structures are value types and
    classes are reference types. What this means is that when we pass an instance
    of a structure within our application, such as a parameter of a method, we create
    a new instance of the structure in the memory. This new instance of the structure
    is only valid while the application is in the scope where the structure was created.
    Once the structure goes out of scope, the new instance of the structure is destroyed
    and the memory is released. This makes memory management of structures pretty
    easy and somewhat painless.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如我在本章开头提到的，结构体是值类型，而类是引用类型。这意味着当我们在我们应用程序中传递结构体的实例时，例如方法的一个参数，我们会在内存中创建结构体的一个新实例。这个结构体的新实例仅在结构体创建的作用域内有效。一旦结构体超出作用域，结构体的这个新实例就会被销毁，并且内存会被释放。这使得结构体的内存管理变得相当简单，并且相对无痛。
- en: Classes, on the other hand, are of the reference type. This means that we allocate
    the memory for the instance of the class only once when it is initially created.
    When we want to pass an instance of the class within our application, as either
    a function argument or by assigning it to a variable, we really pass a reference
    to where the instance is stored in the memory. Since the instance of a class may
    be referenced in multiple scopes (unlike a structure), it cannot be automatically
    destroyed, and memory is not released when it goes out of scope if it is referenced
    in another scope. Therefore, Swift need some form of memory management to track
    and release the memory used by instances of classes when the class is no longer
    needed. Swift uses **Automatic Reference Counting (ARC)** to track and manage
    memory usage.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相反，类是引用类型。这意味着当类首次创建实例时，我们只为其分配一次内存。当我们想要在我们的应用程序中将类的实例传递给函数作为参数，或者将其分配给变量时，我们实际上传递的是实例在内存中存储位置的引用。由于类的实例可能在多个作用域中被引用（与结构体不同），它不能被自动销毁，如果它在另一个作用域中被引用，当它超出作用域时，内存不会被释放。因此，Swift需要某种形式的内存管理来跟踪和释放当类不再需要时实例使用的内存。Swift使用**自动引用计数（ARC）**来跟踪和管理内存使用。
- en: With ARC, for the most part, memory management in Swift simply works. ARC will
    automatically track the references to instances of classes, and when an instance
    is no longer needed (no references pointing to it), ARC will automatically destroy
    the instance and release the memory. There are a few instances where ARC requires
    additional information about relationships to properly manage the memory. Before
    we look at the instances where ARC needs help, let's look at how memory management
    and ARC work.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在ARC中，大部分情况下，Swift的内存管理很简单。ARC会自动跟踪类的实例引用，当一个实例不再需要时（没有引用指向它），ARC会自动销毁该实例并释放内存。有一些情况下，ARC需要额外的信息来正确管理内存。在我们查看ARC需要帮助的实例之前，让我们看看内存管理和ARC是如何工作的。
- en: Reference versus value types
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用类型与值类型
- en: 'Let''s look at an example that illustrates how a reference type (instance of
    a class) and a value type (instance of a structure or a variable) are passed to
    a function. We will begin by defining a new class named `MyClass` and a new structure
    named `MyStruct`. The `MyClass` class and the `MyStruct` structure each contain
    one property named `name`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来了解如何将引用类型（类的实例）和值类型（结构体或变量的实例）传递给函数。我们将首先定义一个新的类`MyClass`和一个新的结构体`MyStruct`。`MyClass`类和`MyStruct`结构体各自包含一个名为`name`的属性：
- en: '[PRE63]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We will now create a function that will accept, as parameters, one instance
    of the `MyClass` class and one instance of the `MyStruct` struct. Within the function,
    we will change the value of the `name` property of both the `MyClass` class and
    the `MyStruct` structure. Then, by examining the value of that property once the
    function exits, we will be able to see how instances of a class and structure
    are passed to functions. Here is the code for the `showPass()` function:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个函数，该函数将接受一个`MyClass`类的实例和一个`MyStruct`结构体的实例作为参数。在函数内部，我们将改变`MyClass`类和`MyStruct`结构体的`name`属性的值。然后，通过在函数退出后检查该属性的值，我们将能够看到类和结构体的实例是如何传递给函数的。以下是`showPass()`函数的代码：
- en: '[PRE64]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In the `showPass()` function, we print the values of the named properties for
    both the `MyClass` and `MyStruct` instances to the console. We then change the
    values of the named properties and reprint the values to the console again. This
    will show us the value of the properties when the function first begins and the
    value after the properties were changed (just before the function exits).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在`showPass()`函数中，我们将`MyClass`和`MyStruct`实例的命名属性值打印到控制台。然后我们改变命名属性的值，并将这些值再次打印到控制台。这将显示函数开始时的属性值以及属性更改后的值（在函数退出之前）。
- en: 'Now, to see how a reference type and a value type are passed to a function,
    we will create an instance of both the `MyClass` class and the `MyStruct` structure,
    set the values of the `name` properties, and pass those instances to the `showPass()`
    function. The function will then change the values of the `name` properties and
    then return control back to the code that calls it. Finally, we will examine the
    value of the name properties after the `showPass()` function exits to see whether
    they have their original value or the value set in the function. Here is the code
    to do this:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了了解引用类型和值类型是如何传递给函数的，我们将创建`MyClass`类和`MyStruct`结构体的实例，设置`name`属性的值，并将这些实例传递给`showPass()`函数。然后，该函数将更改`name`属性的值，并返回控制权给调用它的代码。最后，我们将在`showPass()`函数退出后检查`name`属性的值，以查看它们是否保持了原始值或函数中设置的值。以下是执行此操作的代码：
- en: '[PRE65]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'If we run this code, we see the following output:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行此代码，我们将看到以下输出：
- en: '[PRE66]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: As we can see from the output, the `showPass()` function receives the instance
    of the class and structure with the name properties set to `set in main - class`
    and `set in main - struct`, respectively. Next, just before the function exits
    we see, that the `name` property of the class is set to `Set in function - class`
    and the `name` property of the structure is set to `Set in function - struct`.
    Finally, when the function exits and we are back to the main part of the code,
    we see that the `name` property of the class is set to `Set in function - class`,
    which was set in the `showPass()` function. However, the `name` property of the
    structure has the value that was originally set prior to calling the function,
    `set in main - struct`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从输出中可以看到，`showPass()`函数接收了类和结构体的实例，其`name`属性分别设置为`在main中设置 - class`和`在main中设置
    - struct`。接下来，在函数退出之前，我们看到类的`name`属性被设置为`在函数中设置 - class`，而结构的`name`属性被设置为`在函数中设置
    - struct`。最后，当函数退出，我们回到代码的主要部分时，我们看到类的`name`属性被设置为`在函数中设置 - class`，这是在`showPass()`函数中设置的。然而，结构的`name`属性具有在调用函数之前设置的原始值，即`在main中设置
    - struct`。
- en: This example illustrates that when we pass a reference type (instance of a class)
    to a function, we are passing a reference to the original class that means any
    changes we make are kept when the function exits. When we pass a value type (instance
    of a structure or a variable) to a function, we are passing the value (copy of
    the instance), which means any changes that we make are made to the local copy
    and are lost once the function exits.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子说明，当我们向函数传递引用类型（类的实例）时，我们传递的是原始类的引用，这意味着我们在函数退出时保留所做的任何更改。当我们向函数传递值类型（结构体或变量的实例）时，我们传递的是值（实例的副本），这意味着我们对局部副本所做的任何更改都会丢失，一旦函数退出。
- en: The working of ARC
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动引用计数（ARC）的工作原理
- en: Whenever we create a new instance of a class, ARC allocates the memory needed
    to store that class. This ensures that there is enough memory to store the information
    associated with that instance of the class, and also locks the memory so that
    nothing overwrites it. When the instance of the class is no longer needed, ARC
    will release the memory allocated for the class so that it can be used for other
    purposes. This ensures that we are not tying up memory that is no longer needed.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们创建一个新的类实例时，ARC都会分配存储该类所需的内存。这确保了有足够的内存来存储与该类实例相关的信息，并且锁定内存，以防止任何东西覆盖它。当类的实例不再需要时，ARC将释放为该类分配的内存，以便它可以用于其他目的。这确保了我们不会占用不再需要的内存。
- en: If ARC were to release the memory for an instance of a class that we still needed,
    it would not be possible to retrieve the class information from memory. If we
    did try to access the instance of the class after the memory was released, there
    is a possibility that our application would crash. To ensure memory is not released
    for an instance of a class that is still needed, ARC counts how many times the
    instance is referenced (how many active properties, variables, or constants are
    pointing to the instance of the class). Once the reference count for an instance
    of a class equals zero (nothing is referencing the instance), the memory is released.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果ARC释放了我们仍然需要的类的实例的内存，将无法从内存中检索类信息。如果我们尝试在内存释放后访问类的实例，应用程序可能会崩溃。为了确保不会释放我们仍然需要的类的实例的内存，ARC会计算实例被引用的次数（有多少活跃的属性、变量或常量指向类的实例）。一旦类的实例的引用计数为零（没有东西引用该实例），内存就会被释放。
- en: All of the previous examples run properly in a Playground, the following examples
    will not. When we run sample code in a Playground, ARC does not release objects
    that we create; this is by design so that we can see how the application runs
    and also the state of the objects at each step. Therefore, we will need to run
    these samples as an iOS or OS X project. Let's look at an example of how ARC works.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前一个示例在Playground中都能正常运行，下面的示例将无法运行。当我们运行Playground中的示例代码时，ARC不会释放我们创建的对象；这是设计上的考虑，以便我们可以看到应用程序的运行情况以及每个步骤中对象的状态。因此，我们需要将这些样本作为iOS或OS
    X项目来运行。让我们看看ARC是如何工作的一个例子。
- en: 'We begin by creating a `MyClass` class with the following code:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用以下代码创建一个`MyClass`类：
- en: '[PRE67]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This class is very similar to our previous `MyClass` class, except that we add
    a deinitializer that is called just before an instance of the class is destroyed
    and removed from memory. This deinitializer prints out a message to the console
    that lets us know that the instance of the class is about to be removed.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类与我们之前的`MyClass`类非常相似，除了我们添加了一个析构器，它在类的实例被销毁并从内存中移除之前被调用。这个析构器会在控制台打印一条消息，让我们知道类的实例即将被移除。
- en: 'Now, let''s look at the code that shows how ARC creates and destroys instances
    of a class:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看展示ARC如何创建和销毁类实例的代码：
- en: '[PRE68]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: In the example, we begin by creating two instances of the `MyClass` class named
    `class1ref1` (which stands for class 1 reference 1) and `class2ref1` (which stands
    for class 2 reference 1). We then create a second reference to `class2ref1` named
    `class2ref2`. Now, in order to see how ARC works, we need to begin setting the
    references to nil. We start out by setting the `class1ref1` to `nil`. Since there
    is only one reference to `class1ref1`, the deinitializer will be called. Once
    the deinitializer completes its task, in our case, it prints a message to the
    console letting us know that the instance of the class has been destroyed and
    the memory has been released.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我们首先创建了两个`MyClass`类的实例，分别命名为`class1ref1`（代表类1引用1）和`class2ref1`（代表类2引用1）。然后，我们为`class2ref1`创建了一个名为`class2ref2`的第二个引用。现在，为了了解ARC的工作原理，我们需要开始将引用设置为nil。我们首先将`class1ref1`设置为`nil`。由于只有一个引用指向`class1ref1`，因此将调用析构器。一旦析构器完成其任务，在我们的例子中，它会在控制台打印一条消息，让我们知道类的实例已被销毁，内存已被释放。
- en: We then set the `class2ref1` to nil, but there is a second reference to this
    class (`class2ref2`) that prevents ARC from destroying the instance so that the
    deinitializer is not called. Finally, we set `class2ref2` to nil, which allows
    ARC to destroy this instance of the `MyClass` class.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将`class2ref1`设置为nil，但还有一个指向这个类的第二个引用（`class2ref2`），这阻止了ARC销毁实例，因此不会调用析构器。最后，我们将`class2ref2`设置为nil，这允许ARC销毁这个`MyClass`类的实例。
- en: 'If we run this code, we will see the following output, which illustrates how
    ARC works:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这段代码，我们将看到以下输出，它说明了ARC的工作原理：
- en: '[PRE69]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: From the example, it seems that ARC handles memory management very well. However,
    it is possible to write code that will prevent ARC from working properly.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 从示例中可以看出，ARC处理内存管理得非常好。然而，编写防止ARC正常工作的代码是可能的。
- en: Strong reference cycles
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强引用循环
- en: 'A strong reference cycle is where the instance of two classes holds a strong
    reference to each other, preventing ARC from releasing either instance. Strong
    reference cycles are a lot easier to understand with an example, so let''s create
    one. Once again, we are not able to use a Playground for this example, so we need
    to create an Xcode project. In the project, we start off by creating two classes
    named `MyClass1` and `MyClass2` with the following code:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 强引用循环是指两个类的实例相互持有强引用，阻止ARC释放任一实例。通过示例来理解强引用循环要容易得多，所以让我们创建一个。再次强调，我们无法在这个例子中使用Playground，因此我们需要创建一个Xcode项目。在项目中，我们首先创建两个名为`MyClass1`和`MyClass2`的类，代码如下：
- en: '[PRE70]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'As we can see from the code, `MyClass1` contains an instance of `MyClass2`;
    therefore, the instance of `MyClass2` cannot be released until `MyClass1` is destroyed.
    We can also see from the code that `MyClass2` contains an instance of `MyClass1`;
    therefore, the instance of `MyClass1` cannot be released until `MyClass2` is destroyed.
    This creates a cycle of dependency in which neither instance can be destroyed
    until the other one is destroyed. Let''s see how this works by running the following
    code:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从代码中可以看到，`MyClass1` 包含了 `MyClass2` 的一个实例；因此，直到 `MyClass1` 被销毁，`MyClass2`
    的实例都不能被释放。我们也可以从代码中看到，`MyClass2` 包含了 `MyClass1` 的一个实例；因此，直到 `MyClass2` 被销毁，`MyClass1`
    的实例都不能被释放。这创建了一个依赖循环，其中两个实例都无法被销毁，直到另一个被销毁。让我们通过运行以下代码来查看这是如何工作的：
- en: '[PRE71]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: As we can see from the comments in the example, the reference counters for each
    instance never reaches zero; therefore, ARC cannot destroy the instances, thereby
    creating a memory leak. A memory leak is where an application continues to use
    memory but does not properly release it. This can cause an application to eventually
    crash.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从示例中的注释中可以看到，每个实例的引用计数器从未达到零；因此，自动引用计数（ARC）无法销毁实例，从而创建了内存泄漏。内存泄漏是指应用程序继续使用内存但未正确释放它。这可能导致应用程序最终崩溃。
- en: To resolve a strong reference cycle, we need to prevent one of the classes from
    keeping a strong hold on the instance of the other class, thereby allowing ARC
    to destroy them both. Swift provides two ways of doing this by letting us define
    the properties as either a weak reference or an unowned reference.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决强引用循环，我们需要防止其中一个类对另一个类的实例保持强引用，从而允许 ARC 销毁它们。Swift 通过让我们定义属性为弱引用或无主引用提供了两种方法来做这件事。
- en: The difference between a weak reference and an unowned reference is that the
    instance which a weak reference refers to can be nil, whereas the instance that
    an unowned reference is referring to cannot be nil. This means that when we use
    a weak reference, the property must be an optional property since it can be nil.
    Let's see how we would use unowned and weak references to resolve a strong reference
    cycle. Let's start by looking at the unowned reference.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 弱引用和无主引用之间的区别是，弱引用所引用的实例可以是 nil，而无主引用所引用的实例不能是 nil。这意味着当我们使用弱引用时，属性必须是可选属性，因为它可以是
    nil。让我们看看如何使用无主引用和弱引用来解决强引用循环。让我们首先看看无主引用。
- en: 'We begin by creating two more classes, `MyClass3` and `MyClass4`:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建另外两个类，`MyClass3` 和 `MyClass4`：
- en: '[PRE72]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The `MyClass4` class looks pretty similar to the `MyClass1` and `MyClass2` classes
    in the preceding example. What is different here is the `MyClass3` class. In the
    `MyClass3` class, we set the `class4` property to `unowned`, which means it cannot
    be nil and it does not keep a strong reference to the `MyClass4` instance that
    it is referring to. Since the `class4` property cannot be `nil`, we also need
    to set it when the class is initialized.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyClass4` 类在先前的示例中看起来与 `MyClass1` 和 `MyClass2` 类非常相似。这里的不同之处在于 `MyClass3`
    类。在 `MyClass3` 类中，我们将 `class4` 属性设置为 `unowned`，这意味着它不能是 nil，并且它不会保持对它所引用的 `MyClass4`
    实例的强引用。由于 `class4` 属性不能是 `nil`，我们还需要在类初始化时设置它。'
- en: 'Now let''s see how we can initialize and deinitialize the instances of these
    classes with the following code:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何使用以下代码初始化和销毁这些类的实例：
- en: '[PRE73]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In the preceding code, we create an instance of the `MyClass4` class and then
    use that instance to create an instance of the `MyClass3` class. We then set the
    `class3` property of the `MyClass4` instance to the `MyClass3` instance we just
    created. This creates a reference cycle of dependency between the two classes
    again, but this time, the `MyClass3` instance is not keeping a strong hold on
    the `MyClass4` instance, allowing ARC to release both instances when they are
    no longer needed.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个 `MyClass4` 类的实例，然后使用该实例创建了一个 `MyClass3` 类的实例。然后我们将 `MyClass4`
    实例的 `class3` 属性设置为刚刚创建的 `MyClass3` 实例。这再次在两个类之间创建了一个依赖循环，但这次 `MyClass3` 实例并没有对
    `MyClass4` 实例保持强引用，允许 ARC 在不再需要时释放这两个实例。
- en: 'If we run this code, we see the following output, showing that both the `MyClass3`
    and `MyClass4` instances are released and the memory is freed:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行此代码，我们将看到以下输出，显示 `MyClass3` 和 `MyClass4` 的实例都被释放，内存也被释放了：
- en: '[PRE74]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now let''s look at how we would use a weak reference to prevent a strong reference
    cycle. We begin by creating two new classes:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何使用弱引用来防止强引用循环。我们首先创建两个新的类：
- en: '[PRE75]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The `MyClass5` and `MyClass6` classes look very similar to the `MyClass1` and
    `MyClass2` classes we created earlier to show how a strong reference cycle works.
    The big difference is that we define the `class5` property in the `MyClass6` class
    as a weak reference.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyClass5`和`MyClass6`类与我们之前创建的`MyClass1`和`MyClass2`类非常相似，用以展示强引用循环的工作原理。最大的不同之处在于我们在`MyClass6`类中定义了`class5`属性为一个弱引用。'
- en: 'Now, let''s see how we can initialize and deinitialize instances of these classes
    with the following code:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用以下代码初始化和销毁这些类的实例：
- en: '[PRE76]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: In the preceding code, we create instances of the `MyClass5` and `MyClass6`
    classes and then set the properties of those classes to point to the instance
    of the other class. Once again, this creates a cycle of dependency, but since
    we set the `class5` property of the `MyClass6` class to weak, it does not create
    a strong reference, allowing both instances to be released.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了`MyClass5`和`MyClass6`类的实例，并将这些类的属性设置为指向另一个类的实例。再次，这创建了一个依赖循环，但由于我们将`MyClass6`类的`class5`属性设置为弱引用，它不会创建强引用，从而允许两个实例都被释放。
- en: 'If we run the code, we will see the following output, showing that both the
    `MyClass5` and `MyClass6` instances are released and the memory is freed:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行代码，我们将看到以下输出，显示`MyClass5`和`MyClass6`实例已被释放，内存已被释放：
- en: '[PRE77]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: It is recommended that we avoid creating circular dependencies, as shown in
    this section, but there are times when we need them. For those times, remember
    that ARC does need some help to release them.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 建议我们避免创建循环依赖，正如本节所示，但有时我们确实需要它们。对于那些时候，请记住，自动引用计数（ARC）确实需要一些帮助来释放它们。
- en: Summary
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As this chapter ends, we end the introduction to the Swift programming language.
    At this point, we have enough knowledge of the Swift language to begin writing
    our own applications; however, there is still much to learn.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 随着本章的结束，我们完成了对 Swift 编程语言的介绍。到目前为止，我们对 Swift 语言已经有了足够的了解，可以开始编写自己的应用程序；然而，还有很多东西需要学习。
- en: In the following chapters, we will look in more depth at some of the concepts
    that we already discussed, such as optionals and subscripts. We will also show
    how we would perform common tasks with Swift, such as parsing common file formats
    and handling concurrency. Finally, we will also have some chapters that will help
    us write better code like a sample Swift style guide, and a chapter on design
    patterns.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将更深入地探讨一些我们已经讨论过的概念，例如可选值和下标。我们还将展示如何使用 Swift 执行常见任务，例如解析常见文件格式和处理并发。最后，我们还将有一些章节帮助我们编写更好的代码，例如一个
    Swift 风格指南的示例，以及一个关于设计模式的章节。
