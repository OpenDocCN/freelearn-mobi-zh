- en: Chapter 8. Paths Less Traveled – Error Handling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 少有人走的路 - 错误处理
- en: One of the biggest changes in Swift 2 is that Apple added a feature called **error
    handling**. Handling error situations is often the least fun part of programming.
    It is usually much more exciting to handle a successful case, often referred to
    as the *happy path* because that is where the exciting functionality is. However,
    to make a truly great user experience and therefore a truly great piece of software,
    we must pay careful attention to what our software does when errors occur. The
    error-handling features of Swift help us in handling these situations succinctly
    and discourage us from ignoring errors in the first place.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 2 中最大的变化之一是苹果增加了一个名为**错误处理**的功能。处理错误情况通常是编程中最不有趣的部分。处理成功的情况通常更有趣，通常被称为*快乐路径*，因为那里是功能最吸引人的地方。然而，为了制作真正出色的用户体验，因此制作出真正出色的软件，我们必须仔细关注软件在出现错误时做了什么。Swift
    的错误处理功能帮助我们简洁地处理这些情况，并阻止我们最初就忽略错误。
- en: 'In this chapter, we will discuss exactly what error-handling features Swift
    has and how they help us to write better software. We will do so by covering the
    following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论 Swift 具体的错误处理功能以及它们如何帮助我们编写更好的软件。我们将通过涵盖以下主题来完成：
- en: Throwing errors
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抛出错误
- en: Handling errors
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理错误
- en: Cleaning up in error situations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误情况下的清理
- en: Throwing errors
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抛出错误
- en: Before we talk about handling an error, we need to discuss how we can signal
    that an error has occurred in the first place. The term for this is *throwing
    an error*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论如何处理错误之前，我们需要讨论如何首先发出错误已发生的信号。这个术语是*抛出错误*。
- en: Defining an error type
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义错误类型
- en: 'The first part of throwing an error is defining an error that we can throw.
    Any type can be thrown as an error as long as it implements the `ErrorType` protocol,
    as shown:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出错误的第一个部分是定义一个我们可以抛出的错误。任何实现了`ErrorType`协议的类型都可以被抛出，如下所示：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This protocol doesn't have any requirements, so the type just needs to list
    it as a protocol it implements. It is now ready to be thrown from a function or
    method.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此协议没有任何要求，因此类型只需将其列为它实现的协议即可。现在它就可以从函数或方法中抛出了。
- en: Defining a function that throws an error
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义一个抛出错误的函数
- en: Let's define a function that will take a string and repeat it until it is at
    least a certain length. This will be very simple to implement but there will be
    a problem scenario. If the passed in string is empty, it will never become longer,
    no matter how many times we repeat it. In this scenario, we should throw an error.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个函数，它将接受一个字符串并将其重复，直到它至少达到一定的长度。这将非常简单实现，但会有一个问题场景。如果传入的字符串为空，无论我们重复多少次，它都不会变长。在这种情况下，我们应该抛出一个错误。
- en: 'Any function or method can throw an error as long as it is marked with the
    `throws` keyword, as shown in the following code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 任何函数或方法都可以抛出错误，只要它被标记为带有`throws`关键字，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `throws` keyword always comes after the parameters and before a return type.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`throws`关键字始终位于参数之后和返回类型之前。'
- en: Implementing a function that throws an error
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现抛出错误的函数
- en: 'Now, we can test if the passed in string is empty and throw an error if it
    is. To do this, we use the `throw` keyword with an instance of our error:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以测试传入的字符串是否为空，如果为空则抛出一个错误。为此，我们使用`throw`关键字和我们的错误实例：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'An important thing to note here is that when we throw an error, it immediately
    exits the function. In the preceding case, if the string is empty, it goes to
    the throw line and then it does not execute the rest of the function. In this
    case, it is often more appropriate to use a `guard` statement instead of a simple
    `if` statement, as shown in the following code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一个重要事情是，当我们抛出一个错误时，它会立即退出函数。在前面的例子中，如果字符串为空，它会跳到抛出行，然后不会执行函数的其余部分。在这种情况下，通常更合适使用`guard`语句而不是简单的`if`语句，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Ultimately this doesn't act any differently from the previous implementation,
    but it reiterates that the rest of the function will not be executed if it fails
    the condition. We are now ready to try to use the function.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，这与之前的实现没有太大区别，但它重申了如果函数失败，则不会执行函数的其余部分。我们现在可以尝试使用这个函数。
- en: Handling errors
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理错误
- en: 'If we try to call a function, such as normal, Swift is going to give us an
    error, as shown in the following example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试调用一个函数，比如正常情况下，Swift 会给我们一个错误，如下面的示例所示：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To eliminate this error, we must add the `try` keyword before the call. However,
    before we move forward, I would recommend that you wrap all of your code inside
    a function, if you are following along in a playground. This is because throwing
    errors at the root level of a playground will not be handled properly and may
    even cause the playground to stop working. To wrap your code in a function, you
    can simply add the following code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了消除这个错误，我们必须在调用之前添加`try`关键字。然而，在我们继续之前，我建议如果你在游乐场中跟随，将所有代码包裹在一个函数中。这是因为游乐场根级别的错误抛出将不会被正确处理，甚至可能导致游乐场停止工作。要包裹你的代码在函数中，你可以简单地添加以下代码：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This defines a function called `main` that contains all the normal playground
    code that is called once, at the end of the playground.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个名为`main`的函数，它包含所有在游乐场末尾一次性调用的正常游乐场代码。
- en: 'Now, let''s get back to using the `try` keyword. There are actually three forms
    of it: `try`, `try?`, and `try!`. Let''s start by discussing the exclamation point
    form, as it is the simplest form.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到使用`try`关键字。实际上，它有三种形式：`try`、`try?`和`try!`。让我们先讨论感叹号形式，因为它是最简单的形式。
- en: Forceful try
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强制尝试
- en: 'The `try!` keyword is called the **forceful try**. The error will completely
    go away if you use it, by using the following code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`try!`关键字被称为**强制尝试**。如果你使用它，错误将完全消失，如下所示：'
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The drawback of this approach might be intuitive, based on the exclamation point
    and what it has meant in the past. Just like with forced unwrapping and forced
    casting, an exclamation point is a sign that there will be a scenario which will
    crash the entire program. In this case, the crash will be caused if an error is
    thrown from the function. There may be times when you can really assert that an
    error will never be thrown from a call to a throwing function or method, but in
    general this isn't an advisable solution, considering the fact that we are trying
    to gracefully handle our error situations.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点可能基于感叹号及其过去的意义是直观的。就像强制解包和强制转换一样，感叹号是一个标志，表明将会有一个会导致整个程序崩溃的场景。在这种情况下，崩溃将是由函数抛出的错误引起的。有时你可以真正断言从抛出函数或方法的调用中永远不会抛出错误，但一般来说，这不是一个可取的解决方案，考虑到我们正在尝试优雅地处理我们的错误情况。
- en: Optional try
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选尝试
- en: 'We can also use the `try?` keyword, which is referred to as an **optional try**.
    Instead of allowing for the possibility of a crash, this will turn the result
    of the function into an optional:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`try?`关键字，这被称为**可选尝试**。它不会允许崩溃的可能性，而是将函数的结果转换为可选值：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The advantage here is that if the function throws an error, `repeated3` will
    simply be set to `nil`. However, there are a couple strange scenarios with this.
    First, if the function already returns an optional, the result will be converted
    to an optional of an optional:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的好处是，如果函数抛出错误，`repeated3`将简单地设置为`nil`。然而，与此相关有几个奇怪的情况。首先，如果函数已经返回了一个可选值，结果将转换为可选的可选值：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This means that you will have to unwrap the optional twice in order to get to
    the real value. The outer optional will be nil if an error is thrown and the inner
    optional will be nil if the method returned nil.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你将不得不解包可选值两次才能到达真正的值。如果抛出错误，外层的可选值将是`nil`，如果方法返回`nil`，则内层的可选值也将是`nil`。
- en: 'The other strange scenario is if the function doesn''t return anything at all.
    In this case, using an optional try will create an optional void, as shown:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个奇怪的情况是，如果函数根本不返回任何内容。在这种情况下，使用可选的`try`将创建一个可选的空值，如下所示：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can check the result for nil to determine if an error was thrown.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过检查结果是否为`nil`来确定是否抛出了错误。
- en: The biggest drawback to this technique is that there is no way to determine
    the reason an error was thrown. This isn't a problem for our `repeatString:untilLongerThan:`
    function because there is only one error scenario, but we will often have functions
    or methods that can fail in multiple ways. Especially, if these are called based
    on user input, we will want to be able to report to the user exactly why an error
    occurred.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术的最大缺点是，无法确定错误抛出的原因。对于我们的`repeatString:untilLongerThan:`函数来说这不是问题，因为只有一个错误场景，但我们会经常遇到可以以多种方式失败的功能或方法。特别是，如果这些是基于用户输入调用的，我们希望能够向用户报告错误发生的确切原因。
- en: To allow us to get more precise information on the reason for an error, we can
    use the final keyword, which is simply `try`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们能够获取关于错误原因的更精确信息，我们可以使用`final`关键字，它简单地就是`try`。
- en: Catching an error
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获错误
- en: To get an idea of the usefulness of catching an error, let's look at writing
    a new function that will create a list of random numbers. Our function will allow
    the user to configure how long the list should be and also what the range of possible
    random numbers should be.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解捕获错误的有用性，让我们看看编写一个新函数，该函数将创建一个随机数列表。我们的函数将允许用户配置列表的长度以及可能的随机数的范围。
- en: 'The idea behind catching an error is that you get a chance to look at the error
    that was thrown. With our current error type, this wouldn''t be terribly useful
    because there is no way to create different types of errors. A great option to
    fix this is to use an enumeration that implements the `ErrorType` protocol:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获错误的背后的想法是，你有机会查看抛出的错误。就我们当前的错误类型而言，这不会非常有用，因为没有办法创建不同类型的错误。一个很好的解决方案是使用实现`ErrorType`协议的枚举：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This enumeration has a case for both the errors which we will want to throw,
    so now we are ready to implement our function:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个枚举为我们将要抛出的错误提供了两种情况，因此我们现在可以开始实现我们的函数：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This function begins by checking the error scenarios. It first checks to make
    sure that we are not trying to create a list of negative length. It then checks
    to make sure that the high value of the range is in fact greater than the low
    one. After that, we repeatedly add a random number to the output array for the
    requested number of times.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数首先检查错误场景。它首先检查我们是否试图创建一个负长度的列表。然后，它检查范围的高值是否确实大于低值。之后，我们重复将随机数添加到输出数组中，次数与请求的次数相同。
- en: Note that this implementation uses the `rand` function, which we used in [Chapter
    2](ch02.html "Chapter 2. Building Blocks – Variables, Collections, and Flow Control"),
    *Building Blocks – Variables, Collections, and Flow Control*. To use it, you will
    need to `import Foundation` and also seed the random number with `srand` again.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个实现使用了`rand`函数，我们在[第2章](ch02.html "第2章。构建块 – 变量、集合和流程控制")中使用了它，*构建块 – 变量、集合和流程控制*。要使用它，你需要`import
    Foundation`，并且再次使用`srand`来初始化随机数。
- en: Also, this use of random is a bit more complicated. Previously, we only needed
    to make sure that the random number was between zero and the length of our array;
    now, we need it to be between two arbitrary numbers. First, we determine the amount
    of different numbers we can generate, which is the difference between the high
    and low number plus one, because we want to include the high number. Then, we
    generate the random number within that range and finally, shift it to the actual
    range we want by adding the low number to the result. To make sure this works,
    let's think through a simple scenario. Lets say we want to generate a number between
    `4` and `10`. The range size here will be `10` `- 4 + 1 = 7`, so we will be generating
    random numbers between `0` and `6`. Then, when we add `4` to it, it will move
    that range to be between `4` and `10`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这种随机数的使用稍微复杂一些。之前，我们只需要确保随机数在零和数组长度之间；现在，我们需要它在两个任意数之间。首先，我们确定可以生成多少个不同的数字，这是高数和低数之差加一，因为我们想包括高数。然后，我们在那个范围内生成随机数，最后，通过将低数加到结果上来将其移到我们想要的实际范围。为了确保这能正常工作，让我们通过一个简单的场景来思考。假设我们想要生成一个介于`4`和`10`之间的数字。这里的范围大小将是`10`
    `- 4 + 1 = 7`，所以我们将生成介于`0`和`6`之间的随机数。然后，当我们加上`4`时，它将那个范围移动到`4`和`10`之间。
- en: 'So, we now have a function that throws a couple of types of errors. If we want
    to catch the errors, we have to embed the call inside a `do` block and also add
    the `try` keyword:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在有一个会抛出几种类型错误的函数。如果我们想捕获这些错误，我们必须在`do`块中嵌入调用，并添加`try`关键字：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'However, if we put this into a playground, within the `main` function, we will
    still get an error that the errors thrown from here are not handled. This will
    not produce an error if you put it at the root level of the playground because
    the playground will handle any error thrown by default. To handle them within
    a function, we need to add catch blocks. A `catch` block works the same as a `switch`
    case, just as if the `switch` were being performed on the error:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们把它放在playground的`main`函数中，我们仍然会得到一个错误，即这里抛出的错误没有被处理。如果你把它放在playground的根级别，这不会产生错误，因为playground会默认处理任何抛出的错误。要在函数中处理它们，我们需要添加`catch`块。`catch`块的工作方式与`switch`案例相同，就像`switch`是在错误上执行一样：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'A `catch` block is defined with the keyword `catch` followed by the case description
    and then curly brackets that contain the code to be run for that case. Each `catch`
    block acts as a separate switch case. In our preceding example, we have defined
    two different `catch` blocks: one for each of the errors where we print out a
    user-understandable message.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`catch` 块是通过关键字 `catch` 后跟情况描述，然后是包含要运行该情况的代码的大括号来定义的。每个 `catch` 块都作为一个独立的
    switch case。在我们的前一个例子中，我们定义了两个不同的 `catch` 块：一个用于每个错误，我们打印出用户可理解的错误信息。'
- en: 'However, if we add this to our playground, we still get an error that all errors
    are not handled because the enclosing catch is not exhaustive. That is because
    `catch` blocks are just like switches in that they have to cover every possible
    case. There is no way to say if our function can only throw random list errors,
    so we need to add a final `catch` block that handles any other errors:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们把这段代码添加到我们的游乐场中，我们仍然会得到一个错误，因为所有错误都没有被处理，因为外层的 `catch` 块不是穷尽的。这是因为 `catch`
    块就像 switches 一样，必须覆盖所有可能的情况。我们无法说明我们的函数只能抛出随机的列表错误，因此我们需要添加一个最后的 `catch` 块来处理任何其他错误：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The last `catch` block stores the error into a variable that is just of type
    `ErrorType`. All we can really do with that type is print it out. With our current
    implementation this will never be called, but it is possible that it will be called
    if we add a different error to our function later and forget to add a new `catch`
    block.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的 `catch` 块将错误存储到一个仅类型为 `ErrorType` 的变量中。我们真正能做的只是将其打印出来。根据我们当前的实现，这个块永远不会被调用，但如果我们在以后向函数添加不同的错误并忘记添加新的
    `catch` 块，它可能会被调用。
- en: 'Note that currently there is no way to specify what type of error can be thrown
    from a specific function; so with this implementation there is no way for the
    compiler to ensure that we are covering every case of our error enumeration. We
    could instead perform a `switch` within a `catch` block, so that the compiler
    will at least force us to handle every case:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，目前没有方法可以指定从特定函数可以抛出哪种类型的错误；因此，在这个实现中，编译器无法确保我们覆盖了错误枚举的每个情况。我们可以在 `catch`
    块内执行一个 `switch`，这样编译器至少会强制我们处理每个情况：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This technique will not cause the compiler to give us an error if we throw a
    completely different type of error from our function, but it will at least give
    us an error if we add a new case to our enumeration.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术不会在从我们的函数抛出完全不同类型的错误时让编译器给出错误，但至少如果我们在枚举中添加新的情况，它会给出错误。
- en: 'Another technique that we can use would be to define an error type that includes
    a description that should be displayed to a user:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用的另一种技术是定义一个包含应显示给用户的描述的错误类型：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Instead of throwing enumeration cases, we are creating instances of the `UserError`
    type with a text description of the problem. Now, when we call the function, we
    can just catch the error as a `UserError` type and print out the value of its
    `userReadableDescription` property:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是抛出枚举情况，而是创建 `UserError` 类型的实例，并带有问题的文本描述。现在，当我们调用函数时，我们只需捕获错误作为 `UserError`
    类型，并打印出其 `userReadableDescription` 属性的值：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is a pretty attractive technique but it has its own drawback. This doesn't
    allow us to easily run certain code if a certain error occurs. This isn't important
    in a scenario where we are just reporting the error to the user, but it is very
    important for scenarios where we might more intelligently handle errors. For example,
    if we have an app that uploads information to the Internet, we will often run
    into Internet connection problems. Instead of just telling the user to try again
    later, we can save the information locally and automatically try to upload it
    again later without having to bother the user. However, Internet connectivity
    won't be the only reason an upload might fail. In other error circumstances, we
    will probably want to do something else.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当吸引人的技术，但它也有自己的缺点。这不允许我们在发生特定错误时轻松运行某些代码。在仅仅向用户报告错误的情况下，这并不重要，但在我们可能更智能地处理错误的情况下，这非常重要。例如，如果我们有一个上传信息到互联网的应用程序，我们经常会遇到互联网连接问题。我们不仅可以告诉用户稍后再试，还可以将信息本地保存，并自动稍后尝试再次上传，而无需打扰用户。然而，互联网连接问题不会是上传失败的唯一原因。在其他错误情况下，我们可能想要做其他的事情。
- en: 'A more robust solution might be to create a combination of both of these techniques.
    We can start by defining a protocol for errors that can be reported directly to
    the user:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更健壮的解决方案可能是结合这两种技术。我们可以从定义一个可以直接报告给用户的错误协议开始：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now we can create an enumeration for our specific errors that implements that
    protocol:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以为我们的特定错误创建一个枚举，该枚举实现了该协议：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This enumeration is set up to have a raw type that is a string. This allows
    us to write a simpler implementation of the `userReadableDescription` property
    that just returns the raw value.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个枚举被设置为具有原始类型的字符串。这允许我们编写一个更简单的 `userReadableDescription` 属性的实现，它只返回原始值。
- en: 'With this, our implementation of the function looks the same as earlier:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们的函数实现看起来和之前一样：
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'However, our error handling can now be more advanced. We can always just catch
    any `UserErrorType` and display it to the user, but we can also catch a specific
    enumeration case if we want to do something special in this scenario:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的错误处理现在可以更高级。我们总是可以捕获任何 `UserErrorType` 并将其显示给用户，但如果我们想在这种情况下做些特别的事情，我们也可以捕获特定的枚举情况：
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Keep in mind that the order of our catch blocks is very important, just like
    the order of switch cases is important. If we put our `UserErrorType` block before
    the `NegativeListLength` block, we would always just report it to the user, because
    once a catch block is satisfied, the program will skip every remaining block.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们的 catch 块的顺序非常重要，就像 switch 情况的顺序一样重要。如果我们把 `UserErrorType` 块放在 `NegativeListLength`
    块之前，我们就会总是向用户报告它，因为一旦一个 catch 块被满足，程序就会跳过所有剩余的块。
- en: This is a pretty heavy handed solution; so, you may want to use a simpler solution
    at times. You may even come up with your own solutions in the future, but this
    gives you some options to play around with.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当直接的方法；因此，你可能有时想使用一个更简单的解决方案。你甚至可能在将来想出你自己的解决方案，但这也为你提供了一些可以尝试的选项。
- en: Propagating errors
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传播错误
- en: 'The last option for handling an error is to allow it to propagate. This is
    only possible when the containing function or method is also marked as throwing
    errors, but it is simple to implement if that is true:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 处理错误的最后一个选项是允许它传播。这只有在包含的函数或方法也被标记为抛出错误时才可能，但如果这是真的，那么实现起来就很简单：
- en: '[PRE22]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this case, the `try` call does not have to be wrapped in a do-catch, because
    all errors thrown by `createRandomListContainingXNumbers:between:and:` will be
    rethrown by `parentFunction`. In fact, you can still use a do-catch block, but
    the catch cases no longer need to be exhaustive, because any errors not caught
    will simply be rethrown. This allows you to only catch the errors relevant to
    you.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`try` 调用不需要被包裹在 do-catch 中，因为 `createRandomListContainingXNumbers:between:and:`
    抛出的所有错误都会被 `parentFunction` 重新抛出。实际上，你仍然可以使用 do-catch 块，但是 catch 情况不再需要是详尽的，因为任何未被捕获的错误将简单地被重新抛出。这允许你只捕获与你相关的错误。
- en: However, while this can be a useful technique, I would be careful not to do
    it too much. The earlier you handle the error situations, the simpler your code
    can be. Every possible error thrown is like adding a new road to a highway system;
    it becomes harder to determine where someone took a wrong turn if they are going
    the wrong way. The earlier we handle errors, the fewer chances we have to create
    additional code paths in the parent functions.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，虽然这可以是一个有用的技术，但我建议不要过度使用。你处理错误的情况越早，你的代码就越简单。每个可能抛出的错误就像是在高速公路系统中增加了一条新道路；如果有人走错了方向，确定他们走错路的地方就会变得更难。我们处理错误得越早，在父函数中创建额外的代码路径的机会就越少。
- en: Cleaning up in error situations
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误情况下的清理
- en: So far, we have not had to be too concerned about what happens in a function
    after we throw an error. There are times when we will need to perform a certain
    action before exiting a function, regardless of if we threw an error or not.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们并不需要过于担心在抛出错误后函数中会发生什么。有时，无论是否抛出错误，我们都需要在退出函数之前执行某些操作。
- en: Order of execution when errors occur
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发生错误时的执行顺序
- en: 'An important part to remember about throwing errors is that the execution of
    the current scope exits. This is easy to think about for functions if you think
    of it as just a call to return. Any code after the throw will not be executed.
    It is a little less intuitive within do-catch blocks. A do-catch can have multiple
    calls to functions that may throw errors, but as soon as a function throws an
    error, the execution will jump to the first catch block that matches the error:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出错误的一个重要注意事项是当前作用域的执行会退出。如果你把它看作是一个简单的返回调用，那么对于函数来说这很容易理解。在抛出之后的所有代码将不会被执行。在
    do-catch 块中这稍微有点不那么直观。一个 do-catch 可以有多个可能抛出错误的函数调用，但是一旦一个函数抛出错误，执行就会跳转到第一个匹配该错误的
    catch 块：
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here, if `function1` throws an error, `function2` and `function3` will not
    be called. If `function1` does not throw but `function2` does, then only `function3`
    will not be called. Also note that we can prevent that skipping behavior using
    either of the two other `try` keywords:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果 `function1` 抛出错误，`function2` 和 `function3` 将不会被调用。如果 `function1` 没有抛出错误但
    `function2` 抛出了，那么只有 `function3` 不会被调用。此外，请注意，我们可以使用两个其他的 `try` 关键字中的任何一个来防止跳过行为：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now if `function1` throws an error, the whole program will crash and if `function2`
    throws an error, it will just continue right on with executing `function3`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果 `function1` 抛出错误，整个程序将会崩溃，如果 `function2` 抛出错误，它将直接继续执行 `function3`。
- en: Deferring execution
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 延迟执行
- en: 'Now, as I hinted before, there will be circumstances where we need to perform
    some action before exiting a function or method regardless of if we throw an error
    or not. You could potentially put that functionality into a function which is
    called before throwing each error, but Swift provides a better way called a **defer
    block**. A defer block simply allows you to give some code to be run right before
    exiting the function or method. Let''s take a look at an example of a personal
    chef type that must always clean up after attempting to cook some food:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如我之前暗示的，在某些情况下，无论是否抛出错误，我们都需要在退出函数或方法之前执行某些操作。你可以将那种功能放入一个在抛出每个错误之前被调用的函数中，但
    Swift 提供了一种更好的方式，称为 **defer 块**。defer 块简单地允许你在退出函数或方法之前运行一些代码。让我们看看一个个人厨师类型的例子，这种类型在尝试烹饪食物后必须始终进行清理：
- en: '[PRE25]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the make crème brûlée method, we start out with a defer block that calls
    the clean method. This is not executed right away; it's executed immediately after
    an error is thrown or immediately before the method exits. This ensures that no
    matter how the making of the crème brûlée goes, the personal chef will still clean
    up after itself.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在制作焦糖布丁的方法中，我们从一个调用清理方法的 defer 块开始。这不会立即执行；它会在抛出错误或方法退出之前立即执行。这确保了无论焦糖布丁的制作过程如何，个人厨师都会进行清理。
- en: 'In fact, defer even works when returning from a function or method at any point:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，即使在从函数或方法返回的任何时刻，`defer` 也会起作用：
- en: '[PRE26]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, we have defined a small ingredient type and a pantry type. The pantry
    has a list of ingredients and a method to help us get an ingredient out of it.
    When we go to get an ingredient, we first have to open the door, so we need to
    make sure that we close the door at the end, whether or not we find an ingredient.
    This is another perfect scenario for a defer block.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个小的成分类型和一个储藏室类型。储藏室有一个成分列表和一个帮助我们从中获取成分的方法。当我们去获取成分时，我们首先必须打开门，因此我们需要确保无论是否找到成分，我们都要在最后关闭门。这是一个
    defer 块的另一个完美场景。
- en: 'One last thing to be aware of with defer blocks is that you can define as many
    defer blocks as you like. Each defer block will be called in the reverse order
    to which they are defined. So, the most recent deferred block will be called first
    and the oldest deferred block will be called last. We can take a look at a simple
    example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 defer 块，还有一点需要注意，你可以定义任意多的 defer 块。每个 defer 块将按照它们定义的相反顺序被调用。因此，最近的延迟块将首先被调用，最旧的延迟块将最后被调用。我们可以看看一个简单的例子：
- en: '[PRE27]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this example, `"A"` will be printed first because it was the last block to
    be deferred and `"C"` will be printed last.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`"A"` 将首先被打印出来，因为它是最晚被延迟的块，而 `"C"` 将最后被打印出来。
- en: Ultimately, it is a great idea to use defer any time you perform some action
    that will require clean-up. You may not have any extra returns or throws when
    first implementing it, but it will make it much safer to make updates to your
    code later.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，在执行任何需要清理操作的动作时使用 `defer` 是一个很好的主意。在最初实现它时，你可能没有额外的返回或抛出，但它将使以后对代码的更新更加安全。
- en: Summary
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: Error handling isn't usually the most fun part of programming, but as you can
    see, there can absolutely be some interesting design strategies around it. It
    is also absolutely critical in developing quality software. We like to think that
    our users will never run into any problems or unforeseen scenarios, but you might
    be amazed at how often that happens. We want to do the very best we can to make
    those scenarios work well, because users will form lasting negative impressions
    of your product if they get bogged down in unavoidable error situations.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理通常不是编程中最有趣的部分，但正如你所见，围绕它绝对可以有一些有趣的设计策略。在开发高质量软件时，它也是绝对关键的。我们喜欢认为我们的用户永远不会遇到任何问题或未预见的场景，但你可能会惊讶于这种情况发生的频率。我们希望尽我们所能让这些场景运行良好，因为如果用户在不可避免的错误情况下陷入困境，他们会对你的产品留下持久的负面印象。
- en: We saw that Swift provides us with a paradigm to help with this called error
    handling. Functions and methods can be marked as possibly throwing errors and
    then we can throw any type that implements the `ErrorType` protocol. We can handle
    those thrown errors in different ways. We can assert that an error will never
    be thrown using the `try!` keyword, we can convert a throwing function or method
    into an optional with the `try?` keyword, or we can catch and inspect errors with
    do-catch blocks. Lastly, we went over defer blocks, that help us ensure certain
    actions happen no matter if we throw an error or return early.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到Swift为我们提供了一个称为错误处理的范式来帮助解决这个问题。函数和方法可以被标记为可能抛出错误，然后我们可以抛出任何实现了`ErrorType`协议的类型。我们可以以不同的方式处理这些抛出的错误。我们可以使用`try!`关键字断言错误永远不会被抛出，我们可以使用`try?`关键字将抛出函数或方法转换为可选，或者我们可以使用do-catch块捕获和检查错误。最后，我们讨论了defer块，它帮助我们确保无论我们是否抛出错误或提前返回，某些操作都会发生。
- en: Now that we've got error handling out of the way, we can jump into the more
    artful side of computer programming called design patterns.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解决了错误处理的问题，我们可以跳入计算机编程的更具艺术性的方面，即设计模式。
