- en: '*Chapter 12*: Exploring the Jetpack Lifecycle Components'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第12章*：探索Jetpack生命周期组件'
- en: In this chapter, we're adding a countdown timer component to our Repositories
    app from [*Chapter 11*](B17788_11_ePub.xhtml#_idTextAnchor317), *Creating Infinite
    Lists with Jetpack Paging and Kotlin Flow*, while also exploring the Jetpack Lifecycle
    components.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将在[*第11章*](B17788_11_ePub.xhtml#_idTextAnchor317)，*使用Jetpack Paging和Kotlin
    Flow创建无限列表*的基础上，向我们的仓库应用添加倒计时计时器组件，同时探索Jetpack生命周期组件。
- en: In the first section, *Introducing the Jetpack Lifecycle components*, we want
    to explore how the lifecycle events and states are tied to Android components
    such as `Activity` or `Fragment`, and then how predefined components from the
    `Lifecycle` package can react to them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分，*介绍Jetpack生命周期组件*，我们想要探索生命周期事件和状态是如何与Android组件如`Activity`或`Fragment`相关联的，然后预定义的`Lifecycle`包中的组件是如何对它们做出反应的。
- en: Next, in the *Adding a countdown component in the Repositories app* section,
    we will be creating and adding a countdown timer component to the Repositories
    app. When a 60-second countdown finishes, we will award users with a fictional
    prize.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在*在仓库应用中添加倒计时组件*部分，我们将创建并添加一个倒计时计时器组件到仓库应用中。当60秒倒计时结束时，我们将向用户颁发一个虚构的奖品。
- en: However, we will want the countdown to run as long as the timer is visible on
    the screen; otherwise, users could cheat by minimizing the application and having
    the countdown run in background. In the *Creating your own lifecycle-aware component*
    section, we will prevent users from cheating by making our timer component aware
    of the different lifecycle events and states that our Android components traverse.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们希望倒计时在计时器在屏幕上可见时运行；否则，用户可以通过最小化应用程序并在后台运行倒计时来作弊。在*创建自己的生命周期感知组件*部分，我们将通过使我们的计时器组件感知Android组件遍历的不同生命周期事件和状态来防止用户作弊。
- en: In the *Making our countdown component aware of the lifecycle of composables*
    section, we will realize that users can also cheat on the countdown contest by
    scrolling and hiding the timer countdown UI element. To prevent them from doing
    that, we will also make sure that our countdown component knows how to react to
    composition cycles that our Compose UI features.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在*使我们的倒计时组件感知composables的生命周期*部分，我们会意识到用户也可以通过滚动和隐藏计时器倒计时UI元素来在倒计时竞赛中作弊。为了防止他们这样做，我们还将确保我们的倒计时组件知道如何对我们的Compose
    UI功能中的组合周期做出反应。
- en: 'To summarize, in this chapter, we will be covering the following sections:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在本章中，我们将涵盖以下部分：
- en: Introducing the Jetpack Lifecycle components
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Jetpack生命周期组件
- en: Adding a countdown component in the Repositories app
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在仓库应用中添加倒计时组件
- en: Creating your own lifecycle-aware component
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自己的生命周期感知组件
- en: Making our countdown component aware of the lifecycle of composables
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使我们的倒计时组件感知composables的生命周期
- en: Before jumping in, let's set up the technical requirements for this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入之前，让我们为本章设置技术要求。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Building Compose-based Android projects for this chapter usually requires your
    day-to-day tools. However, to follow along with this chapter smoothly, make sure
    that you also have the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为本章构建基于Compose的Android项目通常需要您日常使用的工具。然而，为了顺利跟随本章，请确保您还具有以下内容：
- en: The Arctic Fox 2020.3.1 version of Android Studio. You can also use a newer
    Android Studio version or even Canary builds but note that the IDE interface and
    other generated code files might differ from the ones used throughout this book.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arctic Fox 2020.3.1版本的Android Studio。您也可以使用更新的Android Studio版本或甚至Canary构建，但请注意，IDE界面和其他生成的代码文件可能与此书中的不同。
- en: A Kotlin 1.6.10 or newer plugin installed in Android Studio.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Android Studio中安装的Kotlin 1.6.10或更高版本的插件。
- en: The existing Repositories app from the GitHub repository of the book.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自本书GitHub仓库的现有仓库应用。
- en: The starting point for this chapter is represented by the Repositories app developed
    in the previous chapter. If you haven't followed the implementation from the previous
    chapter, access the starting point for this chapter by navigating to the `Chapter_11`
    directory of the repository and importing the Android project entitled `repositories_app_solution_ch11`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的起点是上一章开发的仓库应用。如果您没有跟随上一章的实现，可以通过导航到仓库的`Chapter_11`目录并导入名为`repositories_app_solution_ch11`的Android项目来访问本章的起点。
- en: 'To access the solution code for this chapter, navigate to the `Chapter_12`
    directory: [https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_12/repositories_app_ch12](https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_12/repositories_app_ch12).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本章的解决方案代码，请导航到`Chapter_12`目录：[https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_12/repositories_app_ch12](https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_12/repositories_app_ch12)。
- en: Introducing the Jetpack Lifecycle components
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Jetpack Lifecycle组件
- en: It's no secret by now that components within the Android framework have certain
    lifecycles that we must respect when we need to interact with them. The most common
    components that own a lifecycle are `Activity` and `Fragment`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，秘密已经不再是秘密了，Android框架中的组件在需要与之交互时都有一定的生命周期，我们必须尊重这些生命周期。拥有生命周期的最常见组件是`Activity`和`Fragment`。
- en: As programmers, we cannot control the lifecycle of Android components because
    their lifecycle is defined and controlled by the system or the way Android works.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，我们无法控制Android组件的生命周期，因为它们的生命周期是由系统或Android的工作方式定义和控制的。
- en: Going back to Lifecycle components, a very good example is the entry point to
    our Android application, represented by the `Activity` component, which, as we
    know, possesses a lifecycle. This means that in order to create a screen in our
    Android application, we need to create an `Activity` component – from this point
    on, all our components must be aware of its lifecycle to not leak any memory.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 回到Lifecycle组件，一个很好的例子是Android应用的入口点，由`Activity`组件表示，正如我们所知，它具有生命周期。这意味着为了在Android应用中创建一个屏幕，我们需要创建一个`Activity`组件——从这一点开始，我们所有的组件都必须了解其生命周期，以避免内存泄漏。
- en: 'Now, when we say that `Activity` has a system-defined lifecycle, this actually
    translates into our `Activity` class inheriting from `ComponentActivity()`, which
    in turn contains a `Lifecycle` object. If we have a look at our `MainActivity`
    class from the Repositories app, we can see that it inherits from `ComponentActivity()`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们说`Activity`有一个系统定义的生命周期时，这实际上意味着我们的`Activity`类从`ComponentActivity()`继承，它反过来包含一个`Lifecycle`对象。如果我们查看来自Repositories应用的`MainActivity`类，我们可以看到它从`ComponentActivity()`继承：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, if we dig into the source code of the `ComponentActivity.java` class,
    we can see that it implements the `LifecycleOwner` interface:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们深入研究`ComponentActivity.java`类的源代码，我们可以看到它实现了`LifecycleOwner`接口：
- en: '![Figure 12.1 – Observing how ComponentActivity implements the LifecycleOwner
    interface'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.1 – 观察ComponentActivity如何实现LifecycleOwner接口'
- en: '](img/B17788_12_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17788_12_01.jpg)'
- en: Figure 12.1 – Observing how ComponentActivity implements the LifecycleOwner
    interface
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1 – 观察ComponentActivity如何实现LifecycleOwner接口
- en: 'In other words, the `ComponentActivity` class is an owner of a lifecycle. If
    we check out the implementation of the `LifecycleOwner` interface a few hundreds
    of lines downward in the source code, we can see that the `LifecycleOwner` interface
    contains a single method called `getLifecycle()` that returns a `Lifecycle` object:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，`ComponentActivity`类是一个生命周期的拥有者。如果我们查看源代码中向下几百行处的`LifecycleOwner`接口实现，我们可以看到`LifecycleOwner`接口包含一个名为`getLifecycle()`的单个方法，它返回一个`Lifecycle`对象：
- en: '![Figure 12.2 – Observing the implementation of the LifecycleOwner interface
    method'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.2 – 观察LifecycleOwner接口方法实现'
- en: '](img/B17788_12_02.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17788_12_02.jpg)'
- en: Figure 12.2 – Observing the implementation of the LifecycleOwner interface method
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2 – 观察LifecycleOwner接口方法实现
- en: From these findings, we can deduct that our `Activity` classes have a system-defined
    lifecycle, as they implement the `LifecycleOwner` interface, which in turn means
    that they own a `Lifecycle` object.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些发现中，我们可以推断出我们的`Activity`类具有系统定义的生命周期，因为它们实现了`LifecycleOwner`接口，这反过来意味着它们拥有一个`Lifecycle`对象。
- en: Note
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There are several other components in Android that have a lifecycle. In the
    context of the `Activity` classes, there are other classes inheriting directly
    or indirectly from `ComponentActivity`, therefore owning a `Lifecycle` object
    – see `AppCompatActivity` or `FragmentActivity`. Alternatively, just as `Activity`
    classes have a lifecycle, so do `Fragment` components. If you check out the source
    code of the `Fragment` class, you will notice that it also implements the `LifecycleOwner`
    interface, and so it also contains a `Lifecycle` object.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中还有其他几个组件具有生命周期。在`Activity`类的上下文中，有其他直接或间接继承自`ComponentActivity`的类，因此拥有一个`Lifecycle`对象
    – 例如`AppCompatActivity`或`FragmentActivity`。或者，就像`Activity`类有生命周期一样，`Fragment`组件也有生命周期。如果你查看`Fragment`类的源代码，你会注意到它也实现了`LifecycleOwner`接口，因此它也包含一个`Lifecycle`对象。
- en: Simply put, the concept of a component having a lifecycle boils down to the
    idea of it providing a concrete implementation of the `Lifecycle` interface. This
    brings the idea that components with a lifecycle, such as `Activity`, expose information
    related to their lifecycle.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，组件具有生命周期的概念可以归结为它提供了`Lifecycle`接口的具体实现。这带来了这样的想法，即具有生命周期的组件，如`Activity`，会公开与其生命周期相关的信息。
- en: 'To better understand what we can find out about a component''s lifecycle, we
    must explore the source code of the `Lifecycle` abstract class. If we do that,
    we will learn that the `Lifecycle` class contains information about the lifecycle
    state of the component that it''s bound to, such as `Activity` or `Fragment`.
    The `Lifecycle` class features two main tracking pieces of information in the
    form of enumerations:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解我们可以从组件的生命周期中找到什么信息，我们必须探索`Lifecycle`抽象类的源代码。如果我们这样做，我们将了解到`Lifecycle`类包含了它所绑定组件（如`Activity`或`Fragment`）的生命周期状态信息。`Lifecycle`类以枚举的形式提供了两个主要的信息追踪点：
- en: '`onCreate()`, `onStart()`, `onResume()`, `onPause()`, `onStop()`, and `onDestroy()`).'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onCreate()`, `onStart()`, `onResume()`, `onPause()`, `onStop()`, 和 `onDestroy()`).'
- en: '`INITIALIZED`, `DESTROYED`, `CREATED`, `STARTED`, and `RESUMED`. If our `Activity`
    just received the `onResume()` callback, it means that until a new event arrives,
    it will stay in the `RESUMED` state. Upon every new event (the lifecycle callback),
    the state changes.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INITIALIZED`, `DESTROYED`, `CREATED`, `STARTED`, 和 `RESUMED`。如果我们的`Activity`刚刚接收到`onResume()`回调，这意味着在新的事件到来之前，它将保持在`RESUMED`状态。每当有新的事件（生命周期回调）发生时，状态就会改变。'
- en: While we were already pretty familiar with the lifecycle events (callbacks),
    we might need to better understand how lifecycle states are defined.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经对生命周期事件（回调）相当熟悉，但我们可能需要更好地理解生命周期状态是如何定义的。
- en: 'Let''s take a practical example and explore what information a `Lifecycle`
    object can provide about an `Activity` component. As previously mentioned, the
    information is structured in the form of events and states:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个实际例子来探讨`Lifecycle`对象可以提供关于`Activity`组件的哪些信息。如前所述，信息是以事件和状态的形式组织的：
- en: '![Figure 12.3 – The lifecycle of an Activity picturing its lifecycle events
    and states'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.3 – 活动生命周期图，展示了其生命周期事件和状态'
- en: '](img/B17788_12_03.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17788_12_03.jpg)'
- en: Figure 12.3 – The lifecycle of an Activity picturing its lifecycle events and
    states
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 – 活动生命周期图，展示了其生命周期事件和状态
- en: In the preceding diagram, we were able to dissect the lifecycle of an `Activity`
    component by its events and states. We also now have a better overview of how
    lifecycle events trigger transitions between lifecycle states.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们能够通过事件和状态来剖析`Activity`组件的生命周期。现在我们也对生命周期事件如何触发生命周期状态之间的转换有了更好的了解。
- en: But why do all these events and states matter to us?
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么所有这些事件和状态对我们来说都很重要呢？
- en: In fact, most of our code is driven with respect to lifecycle information. To
    avoid potential crashes, memory leaks, or wasting resources, it's essential to
    perform actions only in the correct state or on the correct lifecycle event.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们的大部分代码都是根据生命周期信息驱动的。为了避免潜在的崩溃、内存泄漏或资源浪费，仅在正确的状态或正确的生命周期事件上执行操作是至关重要的。
- en: When we think of lifecycle events, we can say that different types of functionalities
    can and should only be executed at appropriate times, or after certain lifecycle
    callbacks. For example, we wouldn't want to update our UI components with data
    after the `onDestroy()` callback in our `Activity`, as it's very likely that our
    app would crash simply because the UI has been scrapped by this time. Another
    example would be that when the `onResume()` event is called in our `Activity`,
    we would know that our `Activity` has gained (or regained) focus, so we can perform
    certain actions in our code such as initializing our camera component.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑生命周期事件时，我们可以这样说，不同类型的功能只能在适当的时间或在某些生命周期回调之后执行。例如，我们不会想在`Activity`的`onDestroy()`回调之后更新我们的UI组件，因为这很可能导致我们的应用崩溃，因为此时UI已经被丢弃。另一个例子是，当我们的`Activity`中的`onResume()`事件被调用时，我们知道我们的`Activity`已经获得了（或重新获得了）焦点，因此我们可以在代码中执行某些操作，比如初始化我们的相机组件。
- en: When we think of lifecycle states, we can say that different continuous actions
    can and should be running only during certain lifecycle periods – for example,
    we would want to start observing database changes if the state is `RESUMED` because
    that's when the user can interact with the screen and mutate data. When this state
    transitions to a different one, such as `CREATED` or `DESTROYED`, we might want
    to stop observing database changes so that we avoid memory leaks and don't waste
    resources.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑生命周期状态时，我们可以这样说，不同的持续动作只能在某些生命周期期间运行——例如，如果状态是`RESUMED`，我们可能想要开始观察数据库变化，因为那时用户可以与屏幕交互并更改数据。当这个状态转换到另一个状态，比如`CREATED`或`DESTROYED`时，我们可能想要停止观察数据库变化，以避免内存泄漏和资源浪费。
- en: From the previous examples, it's clear that our code should be aware of the
    lifecycle of Android components. When we write code based on lifecycle events
    or states, we're writing code that is aware of the lifecycle of a specific component.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的例子中可以看出，我们的代码应该了解Android组件的生命周期。当我们根据生命周期事件或状态编写代码时，我们正在编写了解特定组件生命周期的代码。
- en: 'Let''s take an example and use our imagination a bit – the `Presenter` class
    features a data stream produced by several network requests. That data stream
    is observed and passed to the UI. However, any ongoing network requests must be
    canceled in the `cancelOngoingNetworkRequests()` method, as our UI no longer needs
    to consume their response:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个例子，并稍微发挥一下想象力——`Presenter`类具有由多个网络请求产生的一个数据流。这个数据流被观察并传递到UI。然而，任何正在进行的网络请求都必须在`cancelOngoingNetworkRequests()`方法中取消，因为我们的UI不再需要消费它们的响应：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s say that an instance of our `Presenter` class is used inside `MainActivity.`
    Naturally, it must respect the lifecycle of the `MainActivity` class. That''s
    why we should stop any ongoing network requests from within the `Presenter` class
    by calling the `cancelOngoingNetworkRequests()` method of the `Presenter` class
    inside the `onDestroyed()` lifecycle callback of the `MainActivity` class:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的`Presenter`类实例在`MainActivity`中使用。自然，它必须尊重`MainActivity`类的生命周期。这就是为什么我们应该通过在`MainActivity`类的`onDestroyed()`生命周期回调中调用`Presenter`类的`cancelOngoingNetworkRequests()`方法来停止`Presenter`类中的任何正在进行的网络请求：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can say that our `Presenter` is aware of the lifecycle of its host, `MainActivity`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说，我们的`Presenter`类了解其宿主`MainActivity`的生命周期。
- en: If a component respects the lifecycle of an Android component such as `Activity`,
    then we can consider that component to be **lifecycle-aware**.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个组件尊重Android组件（如`Activity`）的生命周期，那么我们可以认为该组件是**生命周期感知的**。
- en: However, we manually made our `Presenter` class be lifecycle-aware by manually
    calling a certain cleanup method from the `MainActivity` lifecycle callback. In
    other words, we had our `MainActivity` manually tell `Presenter` that it must
    stop its ongoing work.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们通过手动从`MainActivity`生命周期回调中调用某个清理方法，手动使我们的`Presenter`类成为生命周期感知的。换句话说，我们的`MainActivity`手动告诉`Presenter`它必须停止其正在进行的工作。
- en: Also, whenever we need to use our `Presenter` in some other `Activity` or `Fragment`
    classes, that component will need to remember to call the `cancelOngoingNetworkRequests()`
    method of `Presenter` on a certain lifecycle callback, therefore producing boilerplate
    code. If `Presenter` needed multiple actions on certain lifecycle callbacks, then
    that boilerplate code would have multiplied.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，无论何时我们需要在其他`Activity`或`Fragment`类中使用我们的`Presenter`，该组件都需要记住在某个生命周期回调中调用`Presenter`的`cancelOngoingNetworkRequests()`方法，因此会产生样板代码。如果`Presenter`需要在某些生命周期回调上执行多个操作，那么这些样板代码就会成倍增加。
- en: With the `Activity` or `Fragment` components manually inform our classes that
    a certain lifecycle event was triggered, or a certain state was reached – the
    `Lifecycle` package will help us receive the callbacks directly inside our components
    in a more efficient manner.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Activity`或`Fragment`组件手动通知我们的类某个生命周期事件已被触发，或达到了某种状态 - `Lifecycle`包将帮助我们以更有效的方式在我们的组件内部直接接收回调。
- en: 'The Jetpack `Lifecycle` package provides us with the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Jetpack的`Lifecycle`包为我们提供了以下内容：
- en: 'Predefined lifecycle-aware components with different purposes that require
    less boilerplate or work from our side. Such components are two Jetpack libraries:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预定义的不同目的的生命周期感知组件，这些组件需要我们更少的样板代码或工作。这些组件是两个Jetpack库：
- en: '`ViewModel`'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewModel`'
- en: '`LiveData`'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LiveData`'
- en: A Lifecycle API that allows us to create a custom lifecycle-aware component
    much easier with less boilerplate code.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个生命周期API，使我们能够通过更少的样板代码更容易地创建一个自定义的生命周期感知组件。
- en: Before creating our own lifecycle-aware component, we should briefly cover the
    two predefined lifecycle-aware components that the Jetpack `Lifecycle` package
    provides us with. Let's begin with `ViewModel`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建我们自己的生命周期感知组件之前，我们应该简要介绍Jetpack `Lifecycle`包为我们提供的两个预定义的生命周期感知组件。让我们从`ViewModel`开始。
- en: ViewModel
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ViewModel
- en: In this book, we have already covered Jetpack's `ViewModel` as a class where
    our UI state resides and where most of the presentation logic is found. However,
    we also learned that in order to properly cancel data streams or ongoing network
    requests, `ViewModel` is aware of the lifecycle of its host `Activity`, `Fragment`,
    and even its composable destination (in conjunction with the Jetpack Navigation
    component).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们已经介绍了Jetpack的`ViewModel`作为一个类，我们的UI状态驻留于此，并且大多数展示逻辑也在这里。然而，我们也了解到，为了正确取消数据流或正在进行的网络请求，`ViewModel`了解其宿主`Activity`、`Fragment`甚至其组合目的地（与Jetpack导航组件一起）的生命周期。
- en: In contrast to our `Presenter` class, whose lifecycle we have manually tied
    to the lifecycle of a host `Activity`, Jetpack's `ViewModel` is a lifecycle-aware
    component that we can use to eliminate any boilerplate calls from `Activity` or
    `Fragmen`t components.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们手动将生命周期与宿主`Activity`的生命周期关联的`Presenter`类相比，Jetpack的`ViewModel`是一个生命周期感知组件，我们可以用它来消除`Activity`或`Fragment`组件中的任何样板调用。
- en: To be more precise, `ViewModel` knows when its host component with a lifecycle
    reaches the end of its lifecycle and provides us with a callback method that we
    can use by overriding the `onCleared()` method. Inside this callback, we can cancel
    any pending work whose result we're no longer interested in to avoid memory leaks
    or wasting resources.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 更精确地说，`ViewModel`知道其宿主组件的生命周期何时结束，并提供了一个回调方法，我们可以通过重写`onCleared()`方法来使用它。在这个回调内部，我们可以取消任何我们不再感兴趣的挂起工作，以避免内存泄漏或资源浪费。
- en: 'As an example, if our `ViewModel` is hosted by an `Activity`, then it knows
    when in the lifecycle of that `Activity` the `onDestroy()` event was called, and
    so it automatically triggers the `onCleared()` callback:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们的`ViewModel`由`Activity`托管，那么它知道在`Activity`的生命周期中何时调用了`onDestroy()`事件，因此它会自动触发`onCleared()`回调：
- en: '![Figure 12.4 – The lifecycle of ViewModel is tied to the lifecycle of an Activity'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.4 – ViewModel的生命周期与Activity的生命周期相关联'
- en: '](img/B17788_12_04.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17788_12_04.jpg)'
- en: Figure 12.4 – The lifecycle of ViewModel is tied to the lifecycle of an Activity
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 – ViewModel的生命周期与Activity的生命周期相关联
- en: 'This basically means that instead of manually having our `Activity` inform
    the `ViewModel` that its lifecycle has ended so that it can stop its work, `ViewModel`
    is a lifecycle-aware component that does that out of the box for you by providing
    a handle for that event – that is, the `onCleared()` callback:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上意味着，我们不需要手动让我们的`Activity`通知`ViewModel`其生命周期已结束，以便它可以停止其工作，`ViewModel`是一个生命周期感知组件，它为您提供了处理该事件的句柄
    - 即`onCleared()`回调：
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Additionally, in the context of an `Activity` host, the `ViewModel` component
    is also aware of any lifecycle callbacks caused by events such as a configuration
    change, so it knows how to outlive those and helps us maintain the UI state, even
    after a configuration change.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在`Activity`宿主的环境中，`ViewModel`组件也了解由配置更改等事件引起的任何生命周期回调，因此它知道如何超越这些回调并帮助我们保持UI状态，即使在配置更改之后。
- en: 'But how does `ViewModel` know about the lifecycle callbacks of an `Activity`
    component? To answer that, we can look at a traditional way of instantiating a
    `ViewModel` inside an `Activity` by using the `ViewModelProvider` API and specifying
    the type of `ViewModel` that must be retrieved – that is, `MyViewModel`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，`ViewModel`是如何知道`Activity`组件的生命周期回调的呢？为了回答这个问题，我们可以通过使用`ViewModelProvider`
    API并在`Activity`内部实例化`ViewModel`来查看传统的做法，并指定必须检索的`ViewModel`类型——即`MyViewModel`：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To get an instance of `MyViewModel`, we used the `ViewModelProvider()` constructor
    and passed the `this` instance of the `MyActivity` class to the `owner` parameter
    that expected a `ViewModelStoreOwner` object. `MyActivity` indirectly implements
    the `ViewModelStoreOwner` interface because `ComponentActivity` does so.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取`MyViewModel`的实例，我们使用了`ViewModelProvider()`构造函数，并将`MyActivity`类的`this`实例传递给期望一个`ViewModelStoreOwner`对象的`owner`参数。`MyActivity`间接实现了`ViewModelStoreOwner`接口，因为`ComponentActivity`实现了这个接口。
- en: To control the lifetime of the instance of our `ViewModel`, `ViewModelProvider`
    needs an instance of `ViewModelStoreOwner` because when it instantiates our `MyViewModel`,
    it will *link* the lifetime of this instance to the lifetime of the `ViewModelStoreOwner`
    – that is, `MyActivity`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制`ViewModel`实例的生命周期，`ViewModelProvider`需要一个`ViewModelStoreOwner`实例，因为当它实例化我们的`MyViewModel`时，它将*链接*此实例的生命周期到`ViewModelStoreOwner`的生命周期——即`MyActivity`。
- en: But how does `ViewModel` know when it must be cleared? In other words, what
    triggers the `onCleared()` method of the `MyViewModel` class?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，`ViewModel`是如何知道它必须被清除的呢？换句话说，什么触发了`MyViewModel`类的`onCleared()`方法？
- en: '`ComponentActivity` will wait for its `onDestroy()` lifecycle callback, and
    when that event is triggered, it will call the `getViewModelStore()` method of
    the `ViewModelStoreOwner` interface and obtain a `ViewModelStore` object. On this
    object, it will then call the `clear()` method to clear the `ViewModel` instance
    that was linked to `ComponentActivity` – in our case, the `MyViewModel` instance.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`ComponentActivity`将等待其`onDestroy()`生命周期回调，当该事件被触发时，它将调用`ViewModelStoreOwner`接口的`getViewModelStore()`方法，并获取一个`ViewModelStore`对象。在这个对象上，它将调用`clear()`方法来清除与`ComponentActivity`关联的`ViewModel`实例——在我们的例子中，是`MyViewModel`实例。'
- en: 'If you check out the source code of the `ComponentActivity` class, you will
    find the following implementation, which proves the previous points we''re trying
    to express:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`ComponentActivity`类的源代码，你会找到以下实现，这证明了我们试图表达的前述观点：
- en: '![Figure 12.5 – ViewModel is cleared on the onDestroy() callback of ComponentActivity'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.5 – 在`ComponentActivity`的`onDestroy()`回调中清除`ViewModel`'
- en: '](img/B17788_12_05.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17788_12_05.jpg](img/B17788_12_05.jpg)'
- en: Figure 12.5 – ViewModel is cleared on the onDestroy() callback of ComponentActivity
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5 – 在`ComponentActivity`的`onDestroy()`回调中清除`ViewModel`
- en: Now, the `ViewModel` lifecycle-aware component is helpful because it allows
    us to easily stop pending work and also persist UI state across configuration
    changes.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`ViewModel`生命周期感知组件非常有用，因为它允许我们轻松停止挂起的任务，并在配置更改之间持久化UI状态。
- en: However, there is another important lifecycle-aware component that we haven't
    covered in this book and that we should briefly mention, and that is `LiveData`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有另一个重要的生命周期感知组件我们没有在本章中介绍，并且我们应该简要提及，那就是`LiveData`。
- en: LiveData
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LiveData
- en: '`LiveData` is an observable data holder class that allows us to get data updates
    in a lifecycle-aware manner inside our Android components, such as `Activity`
    and `Fragment`. While specific implementations of Kotlin Flow data streams are
    similar to `LiveData` because both allow us to receive multiple data events over
    time, `LiveData` presents the advantage of being a lifecycle-aware component.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`LiveData`是一个可观察的数据持有类，它允许我们在Android组件内部以生命周期感知的方式获取数据更新，例如`Activity`和`Fragment`。虽然Kotlin
    Flow数据流的特定实现与`LiveData`相似，因为两者都允许我们在一段时间内接收多个数据事件，但`LiveData`具有作为生命周期感知组件的优势。'
- en: Note
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In this section, we won't cover `LiveData` extensively to understand its API.
    Instead, we will try to highlight its lifecycle-aware character. Right now, you
    don't have to code along.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们不会广泛介绍`LiveData`的API，而是尝试突出其生命周期感知特性。目前，你不需要跟随代码编写。
- en: Without going into too much detail, let's see a simple usage of a `LiveData`
    object kept inside a `ViewModel` class and consumed from an `Activity` component.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 不深入细节，让我们看看在`ViewModel`类内部保持的`LiveData`对象的一个简单用法，并从`Activity`组件中消费它。
- en: 'Inside `ViewModel`, we instantiated a `MutableLiveData` object that will hold
    values of type `Int`, passed an initial value of `0`, and then in the `init{}`
    block launched a coroutine, where we''ve set the value to `100` after a `5000`-millisecond
    delay:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ViewModel` 中，我们实例化了一个 `MutableLiveData` 对象，该对象将持有 `Int` 类型的值，传递了一个初始值为 `0`，然后在
    `init{}` 块中启动了一个协程，在 `5000` 毫秒的延迟后，将值设置为 `100`：
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`numberLiveData` is now a data holder that will first notify any components
    observing it of the value `0` and, after 5 seconds, the value `100`.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`numberLiveData` 现在是一个数据持有者，它将首先通知观察它的任何组件其值为 `0`，然后在 5 秒后，值变为 `100`。'
- en: 'Now, an `Activity` can be observing these values by first obtaining an instance
    of `MyViewModel`, tapping into its `numberLiveData` object, and then starting
    to observe the changes through the `observe()` method:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一个 `Activity` 可以通过首先获取 `MyViewModel` 的实例，访问其 `numberLiveData` 对象，然后通过 `observe()`
    方法开始观察变化来进行观察：
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, to the `observe()` method, we''ve passed the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看传递给 `observe()` 方法的以下内容：
- en: First, the `this` instance of the `MyActivity` class to the `owner` parameter
    that expected a `LifecycleOwner` object. This worked because `MyActivity` indirectly
    implements (through `ComponentActivity`) the `LifecycleOwner` interface and therefore
    owns a `Lifecycle` object. The `observe()` method expected a `LifecycleOwner`
    as its first parameter, so that the observing feature is lifecycle-aware of the
    lifecycle of `MainActivity`.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，将 `MyActivity` 类的 `this` 实例传递给期望 `LifecycleOwner` 对象的 `owner` 参数。这之所以有效，是因为
    `MyActivity` 通过 `ComponentActivity` 间接实现了 `LifecycleOwner` 接口，因此拥有一个 `Lifecycle`
    对象。`observe()` 方法期望 `LifecycleOwner` 作为其第一个参数，这样观察功能就具有对 `MainActivity` 生命周期的生命周期感知性。
- en: An `Observer<Int>` Kotlin inner `object` that allows us to receive the data
    events (holding the `Int` values) from the `MutableLiveData` object inside the
    `onChanged()` callback. Each time a new value is propagated, this callback will
    be triggered, and we will receive the latest value.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Kotlin 内部 `Observer<Int>` 对象，允许我们在 `onChanged()` 回调中接收来自 `MutableLiveData`
    对象的数据事件（持有 `Int` 值）。每次有新值传播时，此回调将被触发，我们将接收到最新的值。
- en: Now that we have briefly covered how to use `LiveData`, let's better understand
    the whole reason why we are talking about `LiveData`. As we've mentioned, `LiveData`
    is a lifecycle-aware component, but how does it achieve that?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经简要介绍了如何使用 `LiveData`，让我们更好地理解我们为什么要谈论 `LiveData` 的整个原因。正如我们提到的，`LiveData`
    是一个生命周期感知组件，但它是如何实现这一点的呢？
- en: When we passed our `MainActivity` as `LifecycleOwner` to the `owner` parameter
    of the `observe()` method, behind the scenes, `LiveData` started an observing
    process dependent on the `Lifecycle` object of the provided `owner`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将 `MainActivity` 作为 `LifecycleOwner` 传递给 `observe()` 方法的 `owner` 参数时，在幕后，`LiveData`
    开始了一个依赖于提供 `owner` 的 `Lifecycle` 对象的观察过程。
- en: More precisely, the `Observer` object provided as the second parameter to the
    `observe()` method will only receive updates if the owner – that is, `MainActivity`
    – is in the `STARTED` or `RESUMED` lifecycle state.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 更确切地说，作为 `observe()` 方法的第二个参数提供的 `Observer` 对象将仅在所有者（即 `MainActivity`）处于 `STARTED`
    或 `RESUMED` 生命周期状态时接收更新。
- en: '*This behavior is essential, as it allows Activity components to only receive
    UI updates from ViewModel components when they are visible or in focus*, therefore
    making sure that the UI can safely handle the data events and not waste resources.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*这种行为是至关重要的，因为它允许 Activity 组件仅在它们可见或处于焦点时才从 ViewModel 组件接收 UI 更新，从而确保 UI 可以安全地处理数据事件，不会浪费资源*。'
- en: If, however, updates would have occurred in other states when the UI would not
    have been initialized, our app could have misbehaved or, even worse, crashed or
    introduced memory leaks. To be sure that such behavior doesn't occur, if the owner
    moves to the `DESTROYED` state, the `Observer` object will be automatically removed.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果更新发生在其他状态，而 UI 未经初始化，我们的应用可能会出现异常行为，甚至更糟，可能会崩溃或引入内存泄漏。为了确保这种行为不会发生，如果所有者移动到
    `DESTROYED` 状态，`Observer` 对象将被自动移除。
- en: 'In the following diagram, you will be able to visualize how `LiveData` updates
    only come when the `Activity` component is in the `RESUMED` or `STARTED` state,
    while also automatically removing the `Observer` object when the state becomes
    `DESTROYED`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图中，您将能够可视化 `LiveData` 更新仅在 `Activity` 组件处于 `RESUMED` 或 `STARTED` 状态时发生，同时当状态变为
    `DESTROYED` 时，自动移除 `Observer` 对象：
- en: '![](img/B17788_12_06.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17788_12_06.jpg)'
- en: Figure 12.6 – Lifecycle states and events when LiveData updates are received
    and the LiveData Observer is removed
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6 – 当接收到LiveData更新并移除LiveData观察者时的生命周期状态和事件
- en: With such behavior, `LiveData` becomes a lifecycle-aware component in the sense
    that any `LifecycleOwner` must be in an active lifecycle state to be receiving
    updates from it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种行为下，`LiveData`成为了一个生命周期感知组件，因为任何`LifecycleOwner`都必须处于一个活跃的生命周期状态才能从它那里接收更新。
- en: Now that we have covered the two predefined lifecycle-aware components (`ViewModel`
    and `LiveData`) that are part of the `Lifecycle` package, it's time to add a countdown
    timer component in our Repositories app so that later on, we can transform it
    into a custom lifecycle-aware component with the help of the Lifecycle APIs.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了`Lifecycle`包中的两个预定义的生命周期感知组件（`ViewModel`和`LiveData`），现在是时候在我们的“仓库”应用中添加一个倒计时计时器组件了，这样我们就可以在以后使用Lifecycle
    API将其转换为一个自定义的生命周期感知组件。
- en: Adding a countdown component in the Repositories app
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在“仓库”应用中添加倒计时组件
- en: Our plan is to learn how to create our own lifecycle-aware component. However,
    before we can do that, we must first create a normal component that, by default,
    is not aware of the lifecycle of any Android component.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的计划是学习如何创建我们自己的生命周期感知组件。然而，在我们能够做到这一点之前，我们必须首先创建一个默认情况下不知道任何Android组件生命周期的普通组件。
- en: To do that, we can create a countdown timer component inside our Repositories
    app that will track whether the user has spent at least 60 seconds on the app,
    and if so, we will award the user with a fictional prize.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们可以在我们的“仓库”应用中创建一个倒计时计时器组件，该组件将跟踪用户是否在应用上至少花费了60秒，如果是这样，我们将向用户颁发一个虚构的奖品。
- en: More precisely, our plan is to create a countdown timer widget inside the `RepositoriesScreen()`
    that will award the user with a prize upon a 60-second countdown. However, for
    the countdown to work and the prize to be awarded, the user must be inside `RepositoriesScreen()`
    and have the countdown composable visible.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，我们的计划是在`RepositoriesScreen()`内部创建一个倒计时计时器小部件，当倒计时达到60秒时，将向用户颁发奖品。然而，为了使倒计时工作并颁发奖品，用户必须处于`RepositoriesScreen()`内部，并且倒计时组合可见。
- en: 'The countdown will behave like so:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 倒计时将表现得如下：
- en: It will start from 60 and finish when the countdown reaches 0\. Upon every second,
    the timer will decrease by 1 unit.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将从60开始，当倒计时达到0时结束。每过一秒，计时器将减少1个单位。
- en: When the countdown has finished, a prize message will be displayed.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当倒计时结束时，将显示一个奖品信息。
- en: It will be paused if the countdown composable is not visible. In other words,
    if the user is not inside the `RepositoriesScreen()` composable or the timer composable
    is not visible or hidden within `RepositoriesScreen()`, then the countdown should
    be paused.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果倒计时组合不可见，它将被暂停。换句话说，如果用户不在`RepositoriesScreen()`组合内部，或者计时器组合在`RepositoriesScreen()`内部不可见或隐藏，那么倒计时应该被暂停。
- en: 'Now that we have a plan, let''s implement a countdown timer component:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了计划，让我们实现一个倒计时计时器组件：
- en: 'Inside the root package, create a new class called `CustomCountdown` and define
    its constructor to feature two function parameters that will be called as the
    countdown timer functions:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根包内部，创建一个名为`CustomCountdown`的新类，并定义其构造函数，使其具有两个将被作为倒计时计时器函数调用的函数参数：
- en: '[PRE7]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We will have to call the `onTick()` function after every second has passed and
    the `onFinish()` function when the countdown has ended.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在每过一秒后调用`onTick()`函数，并在倒计时结束时调用`onFinish()`函数。
- en: 'Now, inside the `CustomCountdown` class, let''s create an inner class called
    `InternalTimer` that will inherit from the built-in Android `android.os.CountDownTimer`
    class and handle the actual countdown sequence:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`CustomCountdown`类内部，让我们创建一个名为`InternalTimer`的内部类，它将继承自内置的Android `android.os.CountDownTimer`类，并处理实际的倒计时序列：
- en: '[PRE8]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: While the constructor of `InternalTimer` also accepts two identical function
    parameters, as `CustomCountdown` does, it's essential to note its `millisInFuture`
    and `countDownInterval` parameters that it forwards to the built-in Android `CountDownTimer`
    class. These two parameters will configure the core functionality of the timer
    – the countdown starting point in time and the time period that passes between
    timer ticks.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`InternalTimer`的构造函数也接受两个相同的函数参数，就像`CustomCountdown`一样，但必须注意它传递给内置Android
    `CountDownTimer`类的`millisInFuture`和`countDownInterval`参数。这两个参数将配置计时器的核心功能——倒计时开始的时间和计时器滴答之间的时间间隔。
- en: 'Next up, let''s finish the implementation of the `InternalTimer` class:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们完成`InternalTimer`类的实现：
- en: '[PRE9]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To make sure the timer works as expected, we have done the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保计时器按预期工作，我们已执行以下操作：
- en: Called the `start()` method provided by the inherited parent, `CountDownTimer`,
    inside the `init{}` block. This should automatically start the timer upon inception.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`init{}`块中调用继承的父类`CountDownTimer`提供的`start()`方法。这应该在创建时自动启动计时器。
- en: Implemented the two mandatory `onFinish()` and `onTick()` methods of the inherited
    parent, `CountDownTimer`, and propagated the events to the caller of `InternalTimer`
    by calling its `onFinish()` and `onTick()` function parameters.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现了继承的父类`CountDownTimer`的两个强制`onFinish()`和`onTick()`方法，并通过调用其`onFinish()`和`onTick()`函数参数将事件传播给`InternalTimer`的调用者。
- en: Then, back in the `CustomCountdown` class, let's create an instance of `InternalTimer`
    and configure it to work like a 60-second countdown timer that starts from `60`
    and finishes at `0`.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，回到`CustomCountdown`类中，让我们创建一个`InternalTimer`实例，并配置它像一个从`60`开始到`0`结束的60秒倒计时计时器：
- en: 'To do that, let''s pass to its constructor not only the `onFinish` and `onTick`
    function parameters but also 60 seconds (as `60000` milliseconds) to the `millisInFuture`
    parameter and 1 second (as `1000` milliseconds) to the `countDownInterval` parameter:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，让我们将其构造函数传递给`onFinish`和`onTick`函数参数，并将60秒（作为`60000`毫秒）传递给`millisInFuture`参数，将1秒（作为`1000`毫秒）传递给`countDownInterval`参数：
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Still inside `CustomCountdown`, to provide a way for canceling the countdown,
    add a `stop()` method that will allow us to call the `cancel()` method inherited
    by `InternalTimer` from the Android `CountDownTimer` class:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在`CustomCountdown`内部，为了提供一个取消倒计时的方法，添加一个`stop()`方法，这将允许我们调用从Android `CountDownTimer`类继承的`InternalTimer`的`cancel()`方法：
- en: '[PRE11]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, in `RepositoriesViewModel`, add not only a `timerState` variable that
    will hold the text state displayed by our countdown composable but also a `timer`
    variable that will hold a `CustomCountdown` object:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`RepositoriesViewModel`中，添加一个`timerState`变量，它将保存我们的倒计时可组合显示的文本状态，以及一个`timer`变量，它将保存一个`CustomCountdown`对象：
- en: '[PRE12]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Inside the `onTick` callback, we are computing the remaining seconds and setting
    a `String` message about our countdown to `timerState`. Then, in the `onFinish`
    callback, we're setting a prize message to `timerState`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onTick`回调内部，我们正在计算剩余的秒数，并将关于我们的倒计时的`String`消息设置到`timerState`。然后，在`onFinish`回调中，我们将奖品信息设置到`timerState`。
- en: 'As a good practice, inside `RepositoriesViewModel`, make sure to stop the timer
    inside the `onCleared()` callback if the user moves to a different screen. This
    would mean that `RepositoriesScreen()` wouldn''t be composed anymore, so this
    `ViewModel` would be cleared and the countdown should be stopped so that it doesn''t
    send events and waste resources:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为一种良好的实践，在`RepositoriesViewModel`内部，确保在用户移动到不同的屏幕时在`onCleared()`回调中停止计时器。这意味着`RepositoriesScreen()`将不再被组合，因此这个`ViewModel`将被清除，倒计时应该停止，这样它就不会发送事件和浪费资源：
- en: '[PRE13]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, move to `MainActivity` and make sure that just as the repositories are
    consumed and passed to the `RepositoriesScreen()` composable, the countdown timer
    text produced by `ViewModel` is also consumed and passed to `RepositoriesScreen()`:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，转到`MainActivity`并确保，正如仓库被消费并传递给`RepositoriesScreen()`可组合一样，由`ViewModel`产生的倒计时计时器文本也被消费并传递给`RepositoriesScreen()`：
- en: '[PRE14]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, at the end of the `RepositoriesScreen.kt` file, create a simple `CountdownItem()`
    composable function that takes in a `timerText: String` parameter and sets its
    value to a `Text` composable:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '然后，在`RepositoriesScreen.kt`文件末尾，创建一个简单的`CountdownItem()`可组合函数，该函数接受一个`timerText:
    String`参数并将其值设置为`Text`可组合：'
- en: '[PRE15]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, in the `RepositoriesScreen()` composable, add a new parameter for the
    countdown text called `timerText`, and inside the `LazyColumn` scope, before the
    `itemsIndexed()` call, add a singular `item()` `CountdownItem()` composable while
    passing the `timerText` variable to it:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`RepositoriesScreen()`可组合中，添加一个名为`timerText`的新参数，并在`LazyColumn`作用域内，在`itemsIndexed()`调用之前，添加一个单独的`item()`
    `CountdownItem()`可组合，并将`timerText`变量传递给它：
- en: '[PRE16]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: By doing so, we make sure that the countdown timer is displayed at the top of
    the screen as the first item within the list of repositories.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们确保倒计时计时器显示在屏幕顶部，作为仓库列表中的第一个项目。
- en: 'Build and run the application. You should first see the countdown timer telling
    you how much time you need to wait, and after approximately 1 minute, you should
    see the prize message displayed:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行应用程序。你应该首先看到倒计时计时器告诉你需要等待多长时间，大约1分钟后，你应该看到奖品信息显示：
- en: '![Figure 12.7 – Observing how the countdown timer works'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.7 – 观察倒计时计时器的工作情况]'
- en: '](img/B17788_12_07.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.7 – 观察倒计时计时器的工作情况](img/B17788_12_07.jpg)'
- en: Figure 12.7 – Observing how the countdown timer works
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7 – 观察倒计时计时器的工作情况
- en: We have now finished incorporating the countdown timer that ends by awarding
    the user with a fictional prize.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了将倒计时计时器整合到应用中，该计时器通过授予用户虚构的奖品来结束。
- en: 'However, there is a scenario where our timer doesn''t work as expected. Let''s
    identify it:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一种情况是我们计时器的工作并不如预期。让我们来识别它：
- en: Restart the application. You can do that by closing the current instance of
    the app and reopening it.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动应用。你可以通过关闭当前应用实例并重新打开它来实现。
- en: The countdown should have started from 60 again at this point.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，倒计时应该再次从60开始。
- en: Before the countdown finishes, remember or write down somewhere the current
    countdown value and then put the app in background.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在倒计时结束之前，记住或写下当前的倒计时值，然后将应用置于后台。
- en: Wait for a few seconds and then bring the app back to the foreground.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待几秒钟，然后将应用恢复到前台。
- en: You should notice that while the app was in the background, the countdown kept
    going. We wanted the timer to be paused when the app was put in the background
    and then resumed when the app was brought back to the foreground – this would
    have allowed us to award the prize to users that actively use the app and have
    the countdown timer visible. This behavior didn't occur, as the timer kept on
    counting while the app was not visible or in focus.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意到，当应用处于后台时，倒计时仍在继续。我们希望当应用被置于后台时计时器会暂停，当应用被恢复到前台时计时器会继续。这将允许我们奖励那些积极使用应用并且使倒计时计时器可见的用户。然而，这种行为没有发生，因为当应用不可见或未聚焦时，计时器仍在继续计数。
- en: This is happening because we didn't do anything to pause the timer when the
    app goes into the background or resume it when the app comes back to the foreground.
    In other words, our countdown timer is not lifecycle-aware, so it doesn't get
    notified and can't react to the lifecycle events of the `Activity` host.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为当应用进入后台或恢复到前台时，我们没有做任何暂停计时器的操作。换句话说，我们的倒计时计时器没有生命周期感知，因此它不会收到通知，也无法对`Activity`宿主的生命周期事件做出反应。
- en: Next, let's make our countdown timer a lifecycle-aware component.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使我们的倒计时计时器成为一个具有生命周期感知的组件。
- en: Creating your own lifecycle-aware component
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自己的生命周期感知组件
- en: We need to make our `CustomCountdown` aware of the lifecycle of `MainActivity`.
    In other words, our countdown logic should observe and react to the lifecycle
    events of our `LifecycleOwner` – that is, `MainActivity`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要让我们的`CustomCountdown`了解`MainActivity`的生命周期。换句话说，我们的倒计时逻辑应该观察并响应我们的`LifecycleOwner`（即`MainActivity`）的生命周期事件。
- en: To make our `CustomCountdown` lifecycle-aware, we must force it to implement
    the `DefaultLifecycleObserver` interface. By doing so, the `CustomCountdown` will
    be observing the lifecycle events or states defined by the `Lifecycle` object
    that `LifecycleOwner` provides.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的`CustomCountdown`具有生命周期感知，我们必须强制它实现`DefaultLifecycleObserver`接口。通过这样做，`CustomCountdown`将观察`LifecycleOwner`提供的`Lifecycle`对象定义的生命周期事件或状态。
- en: 'Our main goal is to pause the countdown when the app is put in the background
    and to resume it when the app is brought back into the foreground. More precisely,
    our `CustomCountdown` must react to the following lifecycle events of `MainActivity`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主要目标是当应用被置于后台时暂停倒计时，当应用被恢复到前台时恢复倒计时。更确切地说，我们的`CustomCountdown`必须对`MainActivity`的以下生命周期事件做出反应：
- en: '`onPause()`: When the `onPause()` callback comes in `MainActivity`, `CustomCountdown`
    must pause its countdown.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onPause()`: 当`onPause()`回调进入`MainActivity`时，`CustomCountdown`必须暂停其倒计时。'
- en: '`onResume()`: When the `onResume()` callback comes in `MainActivity`, `CustomCountdown`
    must resume its countdown.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onResume()`: 当`onResume()`回调进入`MainActivity`时，`CustomCountdown`必须恢复其倒计时。'
- en: With this behavior, we can award the prize to users that actively use the app
    and have the countdown timer visible and in focus.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种行为，我们可以奖励那些积极使用应用并且使倒计时计时器可见并处于焦点的用户。
- en: Now that we have a plan, let's start coding.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了计划，让我们开始编码。
- en: 'Make the `CustomCountdown` class implement the `DefaultLifecycleObserver` interface
    and then override the two lifecycle callbacks we''re interested in, `onResume()`
    and `onPause()`:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让`CustomCountdown`类实现`DefaultLifecycleObserver`接口，然后重写我们感兴趣的两种生命周期回调，`onResume()`和`onPause()`：
- en: '[PRE17]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once we make our `CustomCountdown` observe the lifecycle of `MainActivity`,
    its `onResume(owner: LifecycleOwner)` callback will be called when the `onResume()`
    callback of `MainActivity` is called, and similarly, its `onPause(owner: LifecycleOwner)`
    callback will be called when the `onPause()` callback of `MainActivity` is called.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '一旦我们的 `CustomCountdown` 观察了 `MainActivity` 的生命周期，当 `MainActivity` 的 `onResume()`
    回调被调用时，它的 `onResume(owner: LifecycleOwner)` 回调将被调用，同样地，当 `MainActivity` 的 `onPause()`
    回调被调用时，它的 `onPause(owner: LifecycleOwner)` 回调将被调用。'
- en: Now that we know when to pause and resume our countdown timer, we need to find
    ways to actually pause and resume it.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们知道了何时暂停和恢复我们的倒计时计时器，我们需要找到实际暂停和恢复它的方法。
- en: 'First, let''s pause the countdown in the `onPause()` callback by calling the
    `cancel()` method of the `timer` variable:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在 `onPause()` 回调中通过调用 `timer` 变量的 `cancel()` 方法来暂停倒计时。
- en: '[PRE18]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With this behavior, when `MainActivity` is paused, we are stopping the countdown
    run by the `InternalTime` instance held inside the `timer` variable.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种行为下，当 `MainActivity` 暂停时，我们正在停止由 `timer` 变量中持有的 `InternalTime` 实例执行的倒计时。
- en: Next up, we need to resume the `timer` in the `onResume()` callback. However,
    to resume it, we need to know the value of the last countdown before the `onPause()`
    callback was triggered and the timer was canceled. With that last known countdown
    value, we can reinitiate our timer in the `onResume()` callback.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要在 `onResume()` 回调中恢复 `timer`。然而，为了恢复它，我们需要知道在 `onPause()` 回调触发和计时器被取消之前最后一次倒计时的值。有了这个最后的已知倒计时值，我们可以在
    `onResume()` 回调中重新初始化我们的计时器。
- en: 'Inside the inner `InternalTimer` class, create a `lastKnownTime` variable,
    initiate it with the value of `millisInFuture`, and then make sure to update it
    in the `onFinish()` and `onTick()` timer callbacks:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部 `InternalTimer` 类中，创建一个 `lastKnownTime` 变量，用 `millisInFuture` 的值初始化它，然后确保在
    `onFinish()` 和 `onTick()` 计时器回调中更新它：
- en: '[PRE19]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: While in the `onFinish()` callback, we've set `lastKnownTime` to `0` because
    the countdown has finished, in the `onTick()` callback, we've made sure to save
    inside the `lastKnownTime` variable the latest value received from the `onTick()`
    callback – that is, `millisUntilFinished`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `onFinish()` 回调中，我们已经将 `lastKnownTime` 设置为 `0`，因为倒计时已经完成；在 `onTick()` 回调中，我们确保将最新接收到的
    `onTick()` 回调值——即 `millisUntilFinished`——保存到 `lastKnownTime` 变量中。
- en: 'Now, going back in the parent `CustomCountdown` class, resume the countdown
    in the `onResume()` callback of `CustomCountdown` by first canceling the countdown
    of the previous timer and then by storing inside the `timer` variable another
    instance of `InternalTimer`, which now starts the countdown from the `lastKnownTime`
    value of the previous `InternalTimer` instance:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，回到父类 `CustomCountdown`，在 `CustomCountdown` 的 `onResume()` 回调中恢复倒计时，首先取消上一个计时器的倒计时，然后在
    `timer` 变量中存储另一个 `InternalTimer` 实例，该实例现在从上一个 `InternalTimer` 实例的 `lastKnownTime`
    值开始倒计时：
- en: '[PRE20]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: With this behavior, when `MainActivity` is resumed, we are creating a new `InternalTimer`
    instance that starts off the countdown from the value that the previous timer
    recorded before being paused. Also, note that the new instance of `InternalTimer`
    receives the same parameters as the first initialization of the `timer` variable
    – the same `onTick()` and `onFinish()` callbacks and the same `countDownInterval`
    – the only difference is the starting point of the countdown, which should now
    be less than 60 seconds.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种行为下，当 `MainActivity` 恢复时，我们正在创建一个新的 `InternalTimer` 实例，该实例从上一个计时器在暂停之前记录的值开始倒计时。此外，请注意，新的
    `InternalTimer` 实例接收与 `timer` 变量的第一次初始化相同的参数——相同的 `onTick()` 和 `onFinish()` 回调以及相同的
    `countDownInterval` ——唯一的区别是倒计时的起点，现在应该小于 60 秒。
- en: For the `onPause()` and `onResume()` callbacks of the `CustomCountdown` class
    to be called when their corresponding lifecycle events are called inside `MainActivity`,
    we must effectively bind our `DefaultLifecycleObserver` – that is, the `CustomCountdown`
    instance – to the lifecycle of our `LifecycleOwner` – that is, `MainActivity`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 `CustomCountdown` 类的 `onPause()` 和 `onResume()` 回调在 `MainActivity` 内部调用相应生命周期事件时被调用，我们必须有效地将我们的
    `DefaultLifecycleObserver`——即 `CustomCountdown` 实例——绑定到我们的 `LifecycleOwner`——即
    `MainActivity` 的生命周期上。
- en: Let's do that next.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接下来这么做。
- en: 'Go back inside the `RepositoriesScreen.kt` file, and inside the `CountdownItem()`
    composable, first obtain the `LifecycleOwner` instance that the composable function
    belongs to by tapping into the `LocalLifeCycleOwner` API and then get the owner
    by accessing its `current` variable:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到`RepositoriesScreen.kt`文件，在`CountdownItem()`组合组件内部，首先通过调用`LocalLifeCycleOwner`
    API获取组合函数所属的`LifecycleOwner`实例，然后通过访问其`current`变量来获取所有者：
- en: '[PRE21]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Finally, we've stored the `LifecycleOwner` instance into the `lifecycleOwner`
    variable.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将`LifecycleOwner`实例存储到`lifecycleOwner`变量中。
- en: It's important to mention that since the parent composable of `CountdownItem()`
    – that is, `RepositoriesScreen()` – is hosted by `MainActivity`, it's only natural
    that the `LifecycleOwner` instance that we have obtained is in fact `MainActivity`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 需要指出的是，由于`CountdownItem()`的父组合组件即`RepositoriesScreen()`是由`MainActivity`承载的，因此我们获得的`LifecycleOwner`实例实际上是`MainActivity`，这是很自然的。
- en: Then, we need to make sure that the `Lifecycle` instance of our `lifecycleOwner`
    adds and removes our `DefaultLifecycleObserver` timer.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要确保我们的`lifecycleOwner`的`Lifecycle`实例添加和移除我们的`DefaultLifecycleObserver`计时器。
- en: To achieve that, we need to first create a composition side effect that allows
    us to know when the `CountdownItem()` composable first entered composition so
    that we can add the observer, and then when it was removed from composition so
    that we can remove the observer.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们首先需要创建一个组合副作用，这样我们就可以知道`CountdownItem()`组合组件首次进入组合的时间，以便我们可以添加观察者，然后当它从组合中移除时，我们可以移除观察者。
- en: 'For such a case, we can use the `DisposableEffect()` composable, which provides
    us with a block of code where we can perform actions when the composable enters
    composition, and then perform other actions when the composable leaves composition
    through its inner `onDispose()` block:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种情况，我们可以使用`DisposableEffect()`组合组件，它为我们提供了一个代码块，在组合组件进入组合时我们可以执行操作，然后通过其内部的`onDispose()`块执行其他操作：
- en: '[PRE22]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Since this is a side effect, anything we add inside the block of code exposed
    by the `DisposableEffect` function will not be re-executed upon recomposition.
    However, this effect will be restarted if the value provided to the `key1` parameter
    changes. In our case, we want this effect to be restarted if the value of `lifecycleOwner`
    changes - this will allow us to have access to the correct `lifecycleOwner` instance
    inside this side-effect composable.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个副作用，我们在`DisposableEffect`函数暴露的代码块中添加的任何内容在重新组合时都不会重新执行。然而，如果提供给`key1`参数的值发生变化，这种效果将会重新启动。在我们的情况下，我们希望这种效果在`lifecycleOwner`的值发生变化时重新启动——这将允许我们在副作用组合组件内部访问正确的`lifecycleOwner`实例。
- en: 'Now that we know when and where we can add and then remove the observer, let''s
    first obtain the `Lifecycle` object from the `lifecycleOwner` variable so that
    we can store it inside the `lifecycle` variable:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 既然我们知道何时何地可以添加和移除观察者，让我们首先从`lifecycleOwner`变量中获取`Lifecycle`对象，以便我们可以将其存储在`lifecycle`变量中：
- en: '[PRE23]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Next, on the `Lifecycle` object from within the `lifecycle` variable, we will
    add and remove the observer.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`lifecycle`变量内部的`Lifecycle`对象上，我们将添加和移除观察者。
- en: 'Inside the block of code exposed by the `DisposableEffect()` composable, add
    the observer on the `lifecycle` variable by calling its `addObserver()` method,
    and then inside its exposed `onDispose()` callback, remove it with the `removeObserver()`
    method:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DisposableEffect()`组合组件暴露的代码块内部，通过调用其`addObserver()`方法在`lifecycle`变量上添加观察者，然后在其暴露的`onDispose()`回调中，使用`removeObserver()`方法将其移除：
- en: '[PRE24]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: With this approach, when the `CountdownItem()` composable is first composed,
    we will make our countdown component observe the lifecycle events of `MainActivity`.
    Then, when the `CountdownItem()` leaves composition, our countdown component will
    no longer observe such events.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，当`CountdownItem()`组合组件首次被组合时，我们的倒计时组件将开始观察`MainActivity`的生命周期事件。然后，当`CountdownItem()`离开组合时，我们的倒计时组件将不再观察这些事件。
- en: However, you might have noticed that both the `addObserver()` and `removeObserver()`
    methods expect a `LifecycleObserver` object, but we didn't provide any.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可能已经注意到，`addObserver()`和`removeObserver()`方法都期望一个`LifecycleObserver`对象，但我们没有提供任何。
- en: In fact, we should have passed the `CustomCountdown` instance to the `addObserver()`
    and `removeObserver()` methods because `CustomCountdown` is the component that
    implements `DefaultLifecycleObserver` and that we want to react to the lifecycle
    changes of our `MainActivity`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们应该将`CustomCountdown`实例传递给`addObserver()`和`removeObserver()`方法，因为`CustomCountdown`是实现`DefaultLifecycleObserver`的组件，而我们希望它能够响应我们的`MainActivity`的生命周期变化。
- en: Next, let's obtain the `CustomCountdown` instance.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们获取`CustomCountdown`实例。
- en: 'Update the `CountdownItem()` function definition to receive a `getTimer()`
    function parameter that returns a `CustomCountdown` timer. This callback method
    should be called to provide the `addObserver()` and `removeObserver()` methods
    with a `LifecycleObserver` instance:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`CountdownItem()`函数定义，以接收一个返回`CustomCountdown`计时器的`getTimer()`函数参数。这个回调方法应该被调用，为`addObserver()`和`removeObserver()`方法提供一个`LifecycleObserver`实例：
- en: '[PRE25]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Since the `CustomCountdown` class implements `DefaultLifecycleObserver`, which
    extends `FullLifecycleObserver`, which in turn extends `LifecycleObserver`, the
    `addObserver()` and `removeObserver()` methods accept our `CustomCountdown` instance
    as an observer to the `Lifecycle` object of our `lifecycleOwner` – that is, `MainActivity`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`CustomCountdown`类实现了`DefaultLifecycleObserver`，它继承自`FullLifecycleObserver`，而`FullLifecycleObserver`又继承自`LifecycleObserver`，因此`addObserver()`和`removeObserver()`方法接受我们的`CustomCountdown`实例作为观察者，观察我们的`lifecycleOwner`（即`MainActivity`）的`Lifecycle`对象。
- en: 'Since `CountdownItem()` now expects a `getTimer: ()-> CustomCountdown` callback
    function, we must also force our `RepositoriesScreen()` composable to accept such
    a callback function as well and then pass it to our `CountdownItem()` composable:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '由于`CountdownItem()`现在期望一个`getTimer: ()-> CustomCountdown`回调函数，我们必须也强制我们的`RepositoriesScreen()`可组合接受这样的回调函数，并将其传递给我们的`CountdownItem()`可组合：'
- en: '[PRE26]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Lastly, inside `MainActivity`, update the `RepositoriesScreen()` composable
    call to provide a `getTimer()` function implementation, where we will get the
    `CustomCountdown` instance from the `viewModel` variable through its `timer` field:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`MainActivity`内部，更新`RepositoriesScreen()`可组合调用，以提供`getTimer()`函数的实现，我们将从`viewModel`变量的`timer`字段中获取`CustomCountdown`实例：
- en: '[PRE27]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We have finally tied our `DefaultLifecycleObserver` – that is, the `CustomCountdown`
    instance – to the lifecycle of our `LifecycleOwner` – that is, `MainActivity`.
    Now that the `CustomCountdown` class should react to the lifecycle events of our
    `MainActivity`, let's test our problematic scenario from before.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终将我们的`DefaultLifecycleObserver`（即`CustomCountdown`实例）绑定到了我们的`LifecycleOwner`（即`MainActivity`）的生命周期上。现在`CustomCountdown`类应该能够响应我们的`MainActivity`的生命周期事件，让我们测试之前的问题场景。
- en: Build and run the app. The countdown should have started from 60 again at this
    point.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行应用。此时倒计时应该从60再次开始。
- en: Before the countdown finishes, remember or write down somewhere the current
    countdown value and put the app in background.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在倒计时结束之前，记得或记下当前的倒计时值，并将应用置于后台。
- en: Wait for a few seconds and then bring the app back to foreground.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待几秒钟，然后将应用带回前台。
- en: You should now notice that while the app was in background, the countdown was
    paused. We wanted the timer to be paused when the app was put in background and
    then resumed when the app was brought back to foreground – and now this is happening!
    We can now award the prize to users that actively use the app.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该注意到，当应用处于后台时，倒计时被暂停了。我们希望当应用被置于后台时计时器被暂停，当应用被带到前台时再恢复——现在这正是发生的！我们可以现在奖励那些积极使用应用的用户。
- en: 'However, there is still an edge case that we haven''t covered. Let''s discover
    it:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还没有涵盖一个边缘情况。让我们来发现它：
- en: Build and run the app. The countdown should have started from 60 again at this
    point.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行应用。此时倒计时应该从60再次开始。
- en: Before the countdown finishes, remember or write down somewhere the current
    countdown value and then quickly scroll down past four or five repositories within
    the list until the countdown is not visible anymore.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在倒计时结束之前，记得或记下当前的倒计时值，然后快速向下滚动列表，超过四到五个存储库，直到倒计时不再可见。
- en: Wait for a few seconds and then scroll back up to the top of the list so that
    the countdown is visible again.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待几秒钟，然后向上滚动到列表的顶部，以便倒计时再次可见。
- en: Note that after we scrolled down, while the timer wasn't visible, the countdown
    kept going. We wanted the timer to be paused when the timer isn't visible anymore
    and then resumed when the timer is visible again – this would have allowed us
    to award the prize to users that have the countdown timer visible so that they
    didn't cheat on our contest. This behavior didn't occur, as the timer kept on
    counting while the timer wasn't visible.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在我们向下滚动后，当计时器不可见时，倒计时仍在继续。我们希望当计时器不再可见时暂停计时器，当计时器再次可见时恢复计时器——这样我们就可以奖励那些计时器可见的用户，使他们不会在我们的比赛中作弊。然而，这种行为没有发生，因为当计时器不可见时，计时器仍在继续计数。
- en: This is happening because we didn't do anything to pause the timer when the
    timer composable leaves composition or resume it when the timer composable is
    composed again. In other words, our countdown timer is not aware of the lifecycle
    of our timer composable.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为当计时器组合组件离开组合或再次组合时，我们没有做任何操作来暂停计时器，也没有在组合组件再次组合时恢复它。换句话说，我们的倒计时计时器并不了解我们的计时器组合组件的生命周期。
- en: Next, let's make our countdown timer aware of Compose composition cycles so
    that users don't cheat in our contest.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使我们的倒计时计时器了解Compose组合周期，这样用户就不会在我们的比赛中作弊。
- en: Making our countdown component aware of the lifecycle of composables
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使我们的倒计时组件了解组合组件的生命周期
- en: The main issue is that our `CustomCountdown` component still runs its countdown
    even after the `CountdownItem()` composable leaves composition. We want to pause
    the timer when its corresponding composable is not visible anymore. With such
    an approach, we can prevent users from cheating, and we can award the prize only
    to users that have had the countdown timer visible for the full amount of time.
    Basically, if the timer is not visible anymore, the countdown should stop.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 主要问题是我们的`CustomCountdown`组件即使在`CountdownItem()`组合组件离开组合后仍在运行倒计时。我们希望在相应的组合组件不再可见时暂停计时器。采用这种方法，我们可以防止用户作弊，并且只能奖励那些整个倒计时计时器都可见的用户。基本上，如果计时器不再可见，倒计时应该停止。
- en: To pause the timer when its corresponding composable function leaves composition,
    we must somehow call the `stop()` function exposed by `CustomCountdown`. But when
    should we do that?
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在相应的组合组件离开组合时暂停计时器，我们必须以某种方式调用`CustomCountdown`暴露的`stop()`函数。但我们应该何时这样做呢？
- en: 'If you look inside the body of the `CountdownItem()` composable, you will notice
    that we have already registered a `DisposableEffect()` composable that notifies
    us when the `CountdownItem()` composable leaves composition by exposing the `onDispose()`
    callback:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`CountdownItem()`组合组件的主体，你会注意到我们已注册了一个`DisposableEffect()`组合组件，它会通知我们当`CountdownItem()`组合组件离开组合时，通过暴露`onDispose()`回调：
- en: '[PRE28]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When the composable leaves composition, inside the `onDispose()` callback,
    we are already removing the `CustomCountdown` as an observer to the lifecycle
    of our `MainActivity`. Exactly at this point, we can also pause the timer because
    the composable leaves composition:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当组合组件离开组合时，在`onDispose()`回调中，我们已经在将`CustomCountdown`作为观察者从我们的`MainActivity`的生命周期中移除。正是在这一点上，我们也可以暂停计时器，因为组合组件已经离开了组合：
- en: 'Update the `CountdownItem()` function definition to accept a new `onPauseTimer()`
    callback function and then make sure to call it inside the `onDispose()` callback
    of `DisposableEffect()`:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`CountdownItem()`函数定义，使其接受一个新的`onPauseTimer()`回调函数，然后确保在`DisposableEffect()`的`onDispose()`回调中调用它：
- en: '[PRE29]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Since `CountdownItem()` now expects an `onPauseTimer: () -> Unit` callback
    function, we must also force our `RepositoriesScreen()` composable to accept such
    a callback function and then pass it to our `CountdownItem()` composable:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '由于`CountdownItem()`现在期望一个`onPauseTimer: () -> Unit`回调函数，我们必须也强制我们的`RepositoriesScreen()`组合组件接受这样的回调函数，并将其传递给我们的`CountdownItem()`组合组件：'
- en: '[PRE30]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Lastly, inside `MainActivity`, update the `RepositoriesScreen()` composable
    call to provide an `onPauseTimer()` function implementation, where we will pause
    the timer by calling the `stop()` method of the `CustomCountdown` instance obtained
    from the `viewModel` variable through its `timer` field:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`MainActivity`内部，更新`RepositoriesScreen()`组合组件的调用，以提供`onPauseTimer()`函数实现，我们将通过`viewModel`变量通过其`timer`字段获取的`CustomCountdown`实例的`stop()`方法来暂停计时器：
- en: '[PRE31]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Build and run the app. The countdown should have started from 60 again at this
    point.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行应用。此时，倒计时应该再次从60开始。
- en: Before the countdown finishes, remember or write down somewhere the current
    countdown value and then quickly scroll down past four or five repositories within
    the list until the countdown is not visible anymore. Make sure to scroll past
    a few repositories so that Compose removes the node of the timer composable –
    if you scroll just a bit, the node of the timer won't be removed.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在倒计时结束之前，记得或记下当前的倒计时值，然后快速向下滚动列表，直到倒计时不再可见。确保滚动过几个仓库，这样Compose就会移除计时器可组合组件的节点——如果你只滚动一点，计时器的节点就不会被移除。
- en: Wait for a few seconds and then scroll back up to the top of the list so that
    the countdown is visible again.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待几秒钟，然后向上滚动到列表的顶部，以便倒计时再次可见。
- en: Note that the timer was now paused while the `CountdownItem()` composable was
    not visible. We have now achieved the desired effect!
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当`CountdownItem()`可组合组件不可见时，计时器现在是暂停的。我们现在已经实现了预期的效果！
- en: But how come the countdown is resumed when the composable becomes visible again?
    We didn't do anything to cover that case – we only stopped the timer when the
    `CountdownItem()` composable left composition, but we didn't resume it when it
    became visible again as it re-entered composition.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么当可组合组件再次可见时，倒计时会恢复？我们没有做任何处理来覆盖这种情况——当`CountdownItem()`可组合组件离开组合状态时，我们停止了计时器，但没有在它重新进入组合状态时恢复它。
- en: Fortunately, the timer is resumed out of the box when the `CountdownItem()`
    composable re-enters composition – but why is this happening?
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，当`CountdownItem()`可组合组件重新进入组合状态时，计时器会自动恢复——但这是为什么？
- en: This behavior is exhibited because of an interesting side effect provided by
    the Lifecycle APIs. More precisely, as soon as we're binding the `LifecycleObserver`
    instance to the `Lifecycle` instance of our `LifecycleOwner`, the observer instantly
    receives as a first event the event corresponding to the current state of `LifecycleOwner`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为是由于Lifecycle API提供的一个有趣的副作用所导致的。更确切地说，一旦我们将`LifecycleObserver`实例绑定到`LifecycleOwner`的`Lifecycle`实例上，观察者就会立即接收到对应`LifecycleOwner`当前状态的事件。
- en: 'Let''s have a look inside the `CountdownItem()` composable and see how this
    could be happening:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`CountdownItem()`可组合组件内部，看看这是如何发生的：
- en: '[PRE32]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In our case, as soon as we're binding the `DefaultLifecycleObserver` instance
    – that is, `CustomCountdown` – to the `Lifecycle` of the `LifecycleOwner` instance
    – that is, `MainActivity` – the observer receives as a first event the event corresponding
    to the current state.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，一旦我们将`DefaultLifecycleObserver`实例——即`CustomCountdown`——绑定到`LifecycleOwner`实例的`Lifecycle`上——即`MainActivity`——观察者就会接收到对应当前状态的事件作为第一个事件。
- en: 'In other words, as soon as our timer composable is visible, we''re adding the
    timer as an observer to the lifecycle of our `MainActivity` class. At that point,
    the `RESUMED` state is the current state of `MainActivity`, so the `onResume()`
    callback is triggered inside the `CustomCountdown` component, which effectively
    resumes the timer countdown in our specific scenario:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，一旦我们的计时器可组合组件可见，我们就将其作为观察者添加到`MainActivity`类的生命周期中。在那个时刻，`RESUMED`状态是`MainActivity`的当前状态，因此`onResume()`回调在`CustomCountdown`组件内部被触发，从而在我们的特定场景中有效地恢复了计时器的倒计时：
- en: '[PRE33]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We have now made our countdown timer aware of the Compose composition cycles
    as well.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的倒计时计时器已经能够感知Compose组合周期了。
- en: Summary
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we understood what a lifecycle-aware component is and how we
    can create one.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了生命周期感知组件是什么，以及我们如何创建一个。
- en: We first explored how the lifecycle events and states are tied to Android components,
    such as `Activity` or `Fragment`, and then how predefined components from the
    `Lifecycle` package can react to them. Then, we created and added a countdown
    timer component to the Repositories app.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先探讨了生命周期事件和状态是如何与Android组件，如`Activity`或`Fragment`相关联的，然后是如何通过`Lifecycle`包中的预定义组件来响应它们。然后，我们在Repositories应用中创建并添加了一个倒计时计时器组件。
- en: Finally, we prevented users from cheating by making our timer component aware
    not only of the different lifecycle events and states of `Activity` components
    but also of the lifecycle of composables.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过使我们的计时器组件不仅能够感知`Activity`组件的不同生命周期事件和状态，还能感知可组合组件的生命周期，从而阻止用户作弊。
- en: Further reading
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'In this chapter, we briefly covered how to create a lifecycle-aware component
    by making our `CustomCountdown` component aware of the lifecycle events that `MainActivity`
    exhibits. However, when needed, we can also tap into the lifecycle states of `LifecycleOwner`.
    To understand how you can do that, check out the official docs for an example:
    [https://developer.android.com/topic/libraries/architecture/lifecycle#lco](https://developer.android.com/topic/libraries/architecture/lifecycle#lco).'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们简要介绍了如何通过使我们的`CustomCountdown`组件了解`MainActivity`所展示的生命周期事件来创建一个生命周期感知的组件。然而，当需要时，我们也可以利用`LifecycleOwner`的生命周期状态。要了解如何做到这一点，请查看官方文档中的示例：[https://developer.android.com/topic/libraries/architecture/lifecycle#lco](https://developer.android.com/topic/libraries/architecture/lifecycle#lco)。
