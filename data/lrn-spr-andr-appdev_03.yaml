- en: Overview of Spring Framework
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring 框架概述
- en: Spring is a powerful, lightweight application framework that provides support
    for various frameworks, such as Hibernate, Struts, and JSF. Spring Framework is
    one of the top enterprise frameworks for building the most complex, secure and
    robust products. This framework is very popular for Java developers, as most developers
    working in Java Enterprise are working with Spring. Nowadays, Spring supports
    the Kotlin language, so it's becoming more popular with other language users.
    In this book, we'll develop Spring projects in Kotlin.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 是一个强大、轻量级的应用程序框架，为各种框架提供支持，如 Hibernate、Struts 和 JSF。Spring 框架是构建最复杂、最安全和最健壮产品的顶级企业框架之一。这个框架在
    Java 开发者中非常受欢迎，因为大多数在 Java 企业中工作的开发者都在使用 Spring。如今，Spring 支持 Kotlin 语言，因此它越来越受到其他语言用户的欢迎。在这本书中，我们将使用
    Kotlin 开发 Spring 项目。
- en: In this chapter, we'll learn about the basics of Spring Framework. We'll discuss the basics
    of Spring and also see some examples of how to implement them with Spring MVC
    and SpringBoot.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习 Spring 框架的基础知识。我们将讨论 Spring 的基础知识，并查看一些使用 Spring MVC 和 SpringBoot
    实现它们的示例。
- en: 'This chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Introduction to Spring
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring 简介
- en: The advantages of Spring
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring 的优势
- en: Spring architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring 架构
- en: Configuring beans
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 Bean
- en: Spring MVC
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring MVC
- en: SpringBoot
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SpringBoot
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In [Chapter 1](bfdcd6b3-5a5a-4fc7-af79-67e780f46ccb.xhtml), *About the Environment,* we
    demonstrated how to set up the environment and what tools, software, and IDE are
    needed in order to develop Spring. To begin, visit [https://start.spring.io/](https://start.spring.io/) and
    create your very first project. The following options will be available there:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 1 章](bfdcd6b3-5a5a-4fc7-af79-67e780f46ccb.xhtml)，*关于环境*，我们展示了如何设置环境以及开发
    Spring 所需的工具、软件和 IDE。首先，访问 [https://start.spring.io/](https://start.spring.io/)
    创建您的第一个项目。以下选项将可供选择：
- en: A Maven project or a Gradle project (we've chosen Maven)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven 项目或 Gradle 项目（我们选择了 Maven）
- en: '**Language**: Java or Kotlin (we''ve chosen Kotlin)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语言**：Java 或 Kotlin（我们选择了 Kotlin）'
- en: '**Spring Boot version**: 2.1.1 (SNAPSHOT)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spring Boot 版本**：2.1.1 (SNAPSHOT)'
- en: Once you click on Create, you need to give information, such as **Group**, **Artifact**,
    **Name**, **Description**, **Package Name**, **Packaging**, and **Java Version**.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦点击创建，您需要提供信息，例如 **组**、**工件**、**名称**、**描述**、**包名**、**打包**和 **Java 版本**。
- en: For this stage, there's no need to add any dependencies. Lastly, generate the
    project and import this into your IDE.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个阶段，无需添加任何依赖。最后，生成项目并将其导入到您的 IDE 中。
- en: The source code with an example for this chapter is available on GitHub: [https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/Chapter03](https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/Chapter03).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例源代码可在 GitHub 上找到：[https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/Chapter03](https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/Chapter03)。
- en: Introduction to Spring
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring 简介
- en: Spring Framework is an open source framework. This is written in Java and developed
    by Pivotal software. Any Java-based enterprise applications can use the core of
    this framework. Spring Framework uses the **Plain Old Java Object** (**POJO**),
    which makes it easier to build an enterprise application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 框架是一个开源框架。这是一个用 Java 编写的框架，由 Pivotal 软件开发。任何基于 Java 的企业应用程序都可以使用该框架的核心。Spring
    框架使用 **普通 Java 对象（POJO**），这使得构建企业应用程序更加容易。
- en: A POJO is a Java object that isn't bound by any restriction other than those
    forced by the Java language specification. POJOs are used to increase the readability
    and reusability of an application.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: POJO 是不受任何限制（除了由 Java 语言规范强制实施的限制）的 Java 对象。POJO 用于提高应用程序的可读性和可重用性。
- en: Let's learn the advantages of Spring and architectures in the following sections.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在接下来的章节中学习 Spring 的优势和架构。
- en: The advantages of Spring
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring 的优势
- en: 'Spring Framework is a component-rich framework with the following advantages:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 框架是一个组件丰富的框架，具有以下优势：
- en: Spring can be utilized for independent applications, web applications, and mobile
    applications.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring 可用于独立应用程序、Web 应用程序和移动应用程序。
- en: Spring has given an answer for free coupling through the creation of **dependency
    injection **(**DI**). This gives a configuration file (or annotation) to rearrange
    the conditions.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring 通过创建 **依赖注入（DI**）来提供免费耦合的解决方案。这提供了一个配置文件（或注解）来重新排列条件。
- en: It utilizes **aspect-oriented programming** (**AOP**) and makes it possible to
    isolate cross-cutting concerns, such as logging, reserving, and security.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用 **面向切面编程** (**AOP**) 并使得隔离跨切面关注点，如日志记录、事务管理和安全性成为可能。
- en: It limits boilerplate code. Spring has a huge amount of bundles and classes
    that decrease coding and keep away from the boilerplate code.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它限制了样板代码。Spring 有大量的包和类，减少了编码并避免了样板代码。
- en: It bolsters different frameworks, such as *ORM*, *Hibernate*, *Logging*, and *JEE*.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持不同的框架，例如 *ORM*、*Hibernate*、*Logging* 和 *JEE*。
- en: Spring provides a simple and secure approach to dealing with login frameworks,
    forms, and so on.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring 提供了一种简单且安全的方法来处理登录框架、表单等。
- en: It handles *autowiring*, which can be a nightmare when building a complex web
    application.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它处理 *自动装配*，这在构建复杂网络应用时可能是一个噩梦。
- en: Spring Web Framework has a web *MVC framework*, which gives leverage, rather
    than a legacy web framework.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Web 框架有一个 Web *MVC 框架*，它提供了比传统的 Web 框架更多的优势。
- en: It has the ability to take out the creation of singleton and factory classes.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有能力移除单例和工厂类的创建。
- en: Spring Framework incorporates support for overseeing business objects and presenting
    their administrations to the introduction-level segments with the aim.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring 框架包含了对监控业务对象并将它们的操作提供给引入层段的支持。
- en: It underpins both *XML* and *annotation* arrangements.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持 *XML* 和 *注解* 配置。
- en: Spring Architecture
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring 架构
- en: Spring Framework is a layered architecture that's composed of a few modules.
    All modules are based on the highest point of its core container. These modules
    give a developer everything they may require for use in the enterprise application
    development. In any case, developers allowed to pick the highlights they need
    and dispose of the modules that are of no use.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 框架是一个分层架构，由几个模块组成。所有模块都基于其核心容器的最高点。这些模块为开发者提供了在企业应用开发中可能需要的所有功能。无论如何，开发者可以选择他们需要的特性，并丢弃无用的模块。
- en: '**Modular programming** is a software design technique. This separates the
    functionality of a program into independent modules so that each contains one
    specific functionality.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**模块化编程** 是一种软件设计技术。它将程序的功能分离成独立的模块，以便每个模块包含一个特定的功能。'
- en: 'Here''s a diagram of the Spring architecture:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 Spring 架构的图示：
- en: '![](img/0c8913af-0b5c-4ccf-80d0-d9d3e457296c.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0c8913af-0b5c-4ccf-80d0-d9d3e457296c.png)'
- en: Spring Framework has about 20 modules, which are grouped into **Core Containers**,
    **Data Access/Integration**, **Web**, **AOP**, **Instrumentation**, and **Test.**
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 框架大约有 20 个模块，它们被分为 **核心容器**、**数据访问/集成**、**Web**、**AOP**、**Instrumentation**
    和 **测试**。
- en: Let's learn about the components of Spring architecture.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解 Spring 架构的组件。
- en: Core containers
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心容器
- en: This section consists of **Core**, **Beans**, **Context**, and **Expression
    Language** modules.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包括 **核心**、**Beans**、**Context** 和 **表达式语言** 模块。
- en: The **Core** module is the center of the Spring architecture. This provides
    the implementation for features such as **Inversion of Control** (**IoC**) and  **Dependency
    Injection** (**DI**). IoC is one of the center containers of the Spring core. DI
    is another known name of IoC. This container is responsible for creating forms
    of objects and controls the complete life cycle. During this life cycle, the system
    creates a dependency and the container injects those dependencies while it creates
    the bean. This inverse process of DI is basically called IoC.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**核心** 模块是 Spring 架构的中心。这提供了诸如 **控制反转** (**IoC**) 和 **依赖注入** (**DI**) 等特性的实现。IoC
    是 Spring 核心中的一个中心容器。DI 是 IoC 的另一个名称。这个容器负责创建对象形式并控制其完整生命周期。在这个过程中，系统创建依赖，容器在创建
    Bean 时注入这些依赖。DI 的这个逆过程基本上被称为 IoC。'
- en: '`org.springframework.beans` and `org.springframework.context` are the two containers
    of Spring Framework''s IoC. IoC has a root interface, called `BeanFactory`, which
    is executed by the items and holds various bean definitions, each bean being recognized
    by a String name. A propelled configuration component is given by this interface
    to deal with items. `ApplicationContext` is a sub-interface of `BeanFactory`,
    which includes more application-layer settings. For example, it includes `WebApplicationContext`
    for use in web applications. `ApplicationContext` is in charge of instantiating,
    designing, and collecting the beans.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`org.springframework.beans`和`org.springframework.context`是Spring框架IoC的两大容器。IoC有一个根接口，称为`BeanFactory`，由这些项目执行并持有各种bean定义，每个bean都有一个字符串名称识别。该接口提供了一个推动配置组件来处理项目。`ApplicationContext`是`BeanFactory`的子接口，它包括更多应用层设置。例如，它包括`WebApplicationContext`，用于Web应用程序。`ApplicationContext`负责实例化、设计和收集bean。'
- en: 'The tasks of object instantiation, configuration, and object assembling are
    specified for the container in the configuration metadata. There are three ways
    to configure the metadata: through XML, annotation, or code. This occurs in spite
    of the way that we work with Kotlin, so we''ll write code and metadata in the
    Kotlin language.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 容器在配置元数据中指定了对象实例化、配置和对象组装的任务。配置元数据有三种配置方式：通过XML、注解或代码。尽管我们使用Kotlin进行工作，但我们将以Kotlin语言编写代码和元数据。
- en: 'Here''s a simple diagram of the flow of the **Core** container:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是**核心**容器的简单流程图：
- en: '![](img/660caf35-f1b3-4ca7-8571-aba84e886953.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/660caf35-f1b3-4ca7-8571-aba84e886953.png)'
- en: The core container is the process of getting the Spring project ready to see
    the output. With the help of **Java POJO Classes**, which are mainly the business
    objects and the **Metadata** (the configuration metadata), the **Spring Container**
    represents the ready application as output.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 核心容器是使Spring项目准备就绪以查看输出的过程。在**Java POJO类**（主要是业务对象和**元数据**，即配置元数据）的帮助下，**Spring容器**将准备好的应用程序作为输出表示。
- en: The **Bean** module represents a bean, which is an object that's assembled,
    managed, and instantiated by the IoC Container.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**Bean**模块代表一个bean，这是一个由IoC容器组装、管理和实例化的对象。'
- en: The **Context** module supports EJB, JMS, Basic Remoting, and so on. The `ApplicationContext` interface
    is the point of concurrence of the **Context** module.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**上下文**模块支持EJB、JMS、基本远程通信等。`ApplicationContext`接口是**上下文**模块的并发点。'
- en: 'The** Expression Language** module is normally used to execute logic, such
    as data query, sum, divide, and mod, in the application. To execute the logic,
    this module provides powerful expressions, as listed here:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**表达式语言**模块通常用于在应用程序中执行逻辑，如数据查询、求和、除法和取模。为此，该模块提供了以下强大的表达式：'
- en: '| **Arithmetic** | `+`, `-`, `*`, `/`, `%`, `^` |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| **算术** | `+`, `-`, `*`, `/`, `%`, `^` |'
- en: '| **Relational** | `<=`, `>=`,`<`, `>`, `==`, `!=` |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| **关系** | `<=`, `>=`,`<`, `>`, `==`, `!=` |'
- en: '| **Logical** | `&&`, `&#124;&#124;`, `!` |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| **逻辑** | `&&`, `&#124;&#124;`, `!` |'
- en: '| **Conditional** | `?`, `:` |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| **条件** | `?`, `:` |'
- en: '| **Regex** | `matches` |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| **正则表达式** | `matches` |'
- en: Data Access/Integration
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据访问/集成
- en: '**Data Access/Integration** is responsible for setting and getting public or
    private data. It acts as a bridge between the data-access layer and the business
    layer. Here are some names of the data modules:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据访问/集成**负责设置和获取公共或私有数据。它作为数据访问层和业务层之间的桥梁。以下是一些数据模块的名称：'
- en: '**JDBC**: **Java Database Connectivity** (**JDBC**) helps the application to
    connect with the database.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JDBC**: **Java数据库连接**（**JDBC**）帮助应用程序连接到数据库。'
- en: '**Object-relational mapping**: This uses as an integration layer for **object-relational
    mapping** (**ORM**) APIs.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象关系映射**: 这用作**对象关系映射**（**ORM**）API的集成层。'
- en: '**Object/XML mapping:** This uses as an integration layer for **object/XML
    mapping** (**OXM**) implementations.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象/XML映射**: 这用作**对象/XML映射**（**OXM**）实现的集成层。'
- en: '** Java Messaging Service**: This is used to provide support in Spring for the
    **Java Messaging Service** (**JMS**).'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java消息服务**: 这用于在Spring中为**Java消息服务**（**JMS**）提供支持。'
- en: '**Transactions**: This is used to provide programmatic and declarative transaction
    management for the POJO classes.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事务**: 这用于为POJO类提供程序性和声明性事务管理。'
- en: Web
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web
- en: 'The **web** is the center of the Spring MVC framework. We can also integrate
    other technologies, such as JSF and Spring MVC. The web provides some basic integration
    features, such as login, logout, and uploading or downloading files. The web layer
    has four modules:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**Web**是Spring MVC框架的中心。我们还可以集成其他技术，如JSF和Spring MVC。Web提供了一些基本的集成功能，例如登录、注销、上传或下载文件。Web层有四个模块：'
- en: '**Web**: This provides the basic web-oriented integration features.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web**: 这提供了基本的面向Web的集成功能。'
- en: '**Web-servlet**: This module contains Spring''s MVC implementation for the
    web application.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web-servlet**: 此模块包含Spring对Web应用程序的MVC实现。'
- en: '**Web-struts**: This module provides an enhanced and improved framework to
    make web development easier.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web-struts**: 此模块提供了一个增强和改进的框架，以使Web开发更加容易。'
- en: '**Web-portlet**: This module is an identical representation of the web MVC
    framework.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web-portlet**: 此模块是Web MVC框架的相同表示。'
- en: Aspect-oriented programming
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向切面编程
- en: '**Aspect-oriented programming** (**AOP**) is a key component of Spring Framework.
    This provides a new way to think about the structure of a program. AOP can be
    implemented in Java and Kotlin. It can be configured in the bean.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向切面编程**（**AOP**）是Spring框架的关键组件。这提供了一种新的思考程序结构的方法。AOP可以在Java和Kotlin中实现。它可以在bean中进行配置。'
- en: AOP splits program logic into certain parts, called **affirmed concerns**. In
    any enterprise application, there are cross-cutting concerns, which should to
    be separate from the basic business logic. Logging, transaction handling, performance
    observing, and security are known as cross-cutting concerns within the application.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: AOP将程序逻辑分割成某些部分，称为**确认关注点**。在任何企业应用程序中，都存在横切关注点，这些关注点应与基本业务逻辑分开。日志记录、事务处理、性能监控和安全被认为是应用程序中的横切关注点。
- en: Instrumentation
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仪器化
- en: Instrumentation is the capacity to screen the level of an item's performance,
    to analyze mistakes, and to compose the trace information. Instrumentation is
    one of the key highlights of Spring Framework for auditing application performance. Spring
    supports instrumentation through AOP and logging.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 仪器化是评估项目性能水平、分析错误和编写跟踪信息的能力。仪器化是Spring框架审计应用程序性能的关键亮点之一。Spring通过AOP和日志记录支持仪器化。
- en: Test
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: One of the essential parts of an enterprise software development is **testing**.
    JUnit or TestNG can be used to test Spring components. This supports the unit
    and integration testing of Spring elements.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 企业软件开发的一个基本部分是**测试**。JUnit或TestNG可以用来测试Spring组件。这支持Spring元素的单元和集成测试。
- en: Configuring beans
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Bean
- en: 'A bean is an object that can be instantiated and assembled by the Spring IoC.
    These beans are created by configuring Spring''s metadata. Here''s a set of properties
    that represent each bean definition:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Bean是由Spring IoC实例化和组装的对象。这些Bean是通过配置Spring的元数据创建的。以下是一组表示每个Bean定义的属性：
- en: Class
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类
- en: Name
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称
- en: Scope
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作用域
- en: Constructor-arg
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数参数
- en: Let's learn about the configured metadata's uses in the following sections.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在以下章节中了解配置元数据的用途。
- en: Spring configuration metadata
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring配置元数据
- en: 'The three major functions that provide configuration metadata with the Spring
    container are as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 提供配置元数据的三个主要功能如下：
- en: XML-based configuration
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于XML的配置
- en: Kotlin/Java-annotation-based configuration
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于 Kotlin/Java 注解的配置
- en: Kotlin/Java-code-based configuration
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于 Kotlin/Java 代码的配置
- en: XML-based configuration
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于XML的配置
- en: The XML-based configuration was introduced in Spring 2.0, and enhanced and extended
    in Spring 2.5 and 3.0\. The main reason for moving to XML-based configuration
    files was to make Spring XML configuration easier. The *classic* `<bean/>` based
    approach is good, but also adds some more configuration that can become complex
    in the big project.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 基于XML的配置在Spring 2.0中引入，并在Spring 2.5和3.0中增强和扩展。转向基于XML的配置文件的主要原因是为了使Spring XML配置更容易。基于`<bean/>`的*经典*方法很好，但也增加了一些可能在大项目中变得复杂的配置。
- en: 'Let''s take a look at an example of an XML-based setup document with various
    bean definitions, including the scope, initialization technique, and destruction
    strategy, and then we''ll discuss this. Here''s a piece of code for `bean.xml`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个基于XML的配置文件示例，其中包含各种Bean定义，包括作用域、初始化技术和销毁策略，然后我们将讨论这个问题。以下是`bean.xml`的代码片段：
- en: '[PRE0]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Bean scopes
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bean作用域
- en: We can choose to proclaim an extension for a bean while defining it. For instance,
    if we constrain Spring to deliver another bean occasion each time, we can initialize
    a prototype scope as an attribute of a bean. Additionally, if we need Spring to
    restore a similar bean example, we should proclaim the bean's scope attribute
    to be a *singleton*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义一个Bean时，我们可以选择声明其作用域为扩展。例如，如果我们限制Spring每次都提供另一个Bean实例，我们可以将原型作用域初始化为Bean的一个属性。此外，如果我们需要Spring恢复一个类似的Bean实例，我们应该声明Bean的作用域属性为*单例*。
- en: 'Spring Framework underpins the accompanying five scopes, three of which are
    accessible in the event that we utilize a web-aware `ApplicationContext`. Here
    are some common scopes:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Spring框架支持以下五个作用域，其中三个在如果我们使用一个感知Web的`ApplicationContext`时是可用的。以下是一些常见的作用域：
- en: '**Singleton**: Returns the same instance that''s used by default every time'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单例**：每次都返回默认使用的相同实例'
- en: '**Prototype**: Returns a different instance every time'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原型**：每次都返回不同的实例'
- en: '**Request**: Defines an HTTP request that''s visible in a single JSP page of
    the application'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求**：定义一个在应用程序的单个JSP页面中可见的HTTP请求'
- en: '**Session**: Defines an HTTP session that''s visible in all JSP pages of the
    application'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**会话**：定义一个在应用程序的所有JSP页面中可见的HTTP会话'
- en: Singleton scope
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例作用域
- en: 'The default scope is always a `singleton`. This is a bean definition of the
    Spring IoC container that returns a single object instance in every object initialization. Here''s
    a piece of code for the singleton scope:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 默认作用域始终是`单例`。这是Spring IoC容器的一个Bean定义，它在每次对象初始化时返回一个单一的对象实例。以下是一个单例作用域的代码示例：
- en: '[PRE1]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let's take a look at an example of a `singleton` scope.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个`单例`作用域的示例。
- en: Create a Spring project in the IDE. To do this, create two `kt` files and a
    bean XML configuration file under the `src` folder.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在IDE中创建一个Spring项目。为此，在`src`文件夹下创建两个`kt`文件和一个Bean XML配置文件。
- en: 'Here''s a piece of the code of `CreateUserGreeting.kt`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个`CreateUserGreeting.kt`的代码片段：
- en: '[PRE2]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The content of **`BeansScopeApplication.kt` **is as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`BeansScopeApplication.kt`的内容如下：'
- en: '[PRE3]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following is the `beans.xml` configuration file:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个`beans.xml`配置文件：
- en: '[PRE4]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After running this project, you will find this output:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此项目后，您将看到以下输出：
- en: '[PRE5]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Prototype scope
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原型作用域
- en: 'A `prototype` scope creates a new instance of a bean in every object initialization.
    This scope is preferred for the stateful beans. The container doesn''t manage
    the full life cycle of this `prototype` scope. Here''s a code piece for a `prototype`
    scope:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`原型`作用域在每次对象初始化时都会创建一个Bean的新实例。这个作用域更适合有状态的Bean。容器不管理这个`原型`作用域的完整生命周期。以下是一个`原型`作用域的代码示例：'
- en: '[PRE6]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let's look at an example of a `prototype` scope.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个`原型`作用域的示例。
- en: 'Reuse the previous project and modify the bean XML configuration file, as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 重新使用之前的工程，并修改Bean XML配置文件，如下所示：
- en: '[PRE7]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once we finish creating the source and bean configuration files, we can run
    the application. If there''s no error, we''ll get the following message:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成创建源文件和Bean配置文件，我们就可以运行应用程序。如果没有错误，我们将得到以下消息：
- en: '[PRE8]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Bean life cycle
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bean生命周期
- en: Occasionally, we need to instate assets in the bean classes. For instance, this
    is possible by making database associations or approving third-party services
    at the season of initialization before any customer request. Spring Framework
    gives distinctive courses through which we can give post-introduction and pre-annihilation
    techniques in a Spring bean life cycle.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要在Bean类中实例化资源。例如，这可以通过在初始化阶段（在处理任何客户请求之前）建立数据库连接或批准第三方服务来实现。Spring框架提供了不同的方法，通过这些方法我们可以在Spring
    Bean的生命周期中提供介绍和销毁技术。
- en: 'These are as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 它们如下所示：
- en: By actualizing the `InitializingBean` and `DisposableBean` interfaces—both of
    these interfaces announce a solitary strategy where we can instate/close assets
    in the bean. For `post-instatement`, we can execute the `InitializingBean` interface
    and provide an implementation of the `afterPropertiesSet()` function. For `pre-destroy`,
    we can actualize the `DisposableBean` interface and provide an implementation
    of the `destroy()` function. These functions are the callback techniques, which
    are similar to servlet audience implementations. This functionality is easy to
    utilize, yet it's not recommended, as it will cause tight coupling with Spring
    Framework in our bean implementations.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过实现 `InitializingBean` 和 `DisposableBean` 接口——这两个接口都宣布了一个单一策略，我们可以在这个策略中实例化/关闭资源。对于
    `post-instatement`，我们可以执行 `InitializingBean` 接口并提供 `afterPropertiesSet()` 函数的实现。对于
    `pre-destroy`，我们可以实现 `DisposableBean` 接口并提供 `destroy()` 函数的实现。这些函数是回调技术，类似于 servlet
    监听器实现。这个功能易于使用，但并不推荐，因为它会使我们的 bean 实现与 Spring 框架紧密耦合。
- en: Giving `init-function` and `destroy-function` quality values for the bean in
    the Spring bean configuration file. This is the prescribed functionality as there's
    no immediate dependency to Spring Framework. We can also make our own functions.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Spring 的 bean 配置文件中为 bean 提供初始化函数 `init-function` 和销毁函数 `destroy-function`
    的质量值。这是规定的功能，因为没有立即依赖 Spring 框架。我们也可以创建自己的函数。
- en: Both the `post-init` and `pre-destroy` functions shouldn't have any contentions,
    but they can throw exceptions. We would also have to get the bean occasion from
    the Spring application setting for these functions.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`post-init` 和 `pre-destroy` 函数不应有任何冲突，但它们可以抛出异常。我们还需要从 Spring 应用程序设置中获取这些函数的
    bean 事件。'
- en: 'Let''s see an example of the life cycle of a bean. Here, we''ll look at how
    to initialize and destroy the bean function. Reuse the previous project and modify
    the bean XML configuration file as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个 bean 生命周期的例子。在这里，我们将看看如何初始化和销毁 bean 函数。重新使用之前的工程，并按如下修改 bean XML 配置文件：
- en: '[PRE9]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now add two functions in `UserGreeting.kt`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在 `UserGreeting.kt` 中添加两个函数：
- en: '[PRE10]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Call `registerShutdownHook()` after the task is completed in the `main` function
    of the class:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在类的 `main` 函数任务完成后调用 `registerShutdownHook()`：
- en: '[PRE11]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output will be as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE12]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Dependency injection
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入
- en: DI is a system where dependencies of an object are provided by outside containers.
    Spring DI helps in wiring a class with its dependencies and keeping them decoupled
    so that we can inject these dependencies at runtime.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: DI 是一个系统，其中对象的依赖由外部容器提供。Spring DI 帮助将类与其依赖项连接起来，并保持它们解耦，以便我们可以在运行时注入这些依赖项。
- en: The dependencies are characterized in the bean configuration. The two most common
    approaches to injecting objects utilizing XML are *constructor* *injection* *and
    setter injection,* which we'll take a look at now*:*Constructor injection
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项在 bean 配置中定义。使用 XML 注入对象的最常见两种方法是 *构造函数注入* 和 *setter 注入*，我们现在将探讨它们：*构造函数注入*
- en: 'Constructor injections inject dependencies to the class constructor. Let''s
    take a look at an example of the constructor injection. Reuse the previous project
    and modify the content of `beans.xml`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数注入将依赖项注入到类构造函数中。让我们看看构造函数注入的一个例子。重新使用之前的工程，并修改 `beans.xml` 的内容：
- en: '[PRE13]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`constructor-arg` is utilized to inject dependencies. The reference of `constructor-arg`
    is an object of the constructor.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`constructor-arg` 用于注入依赖项。`constructor-arg` 的引用是构造函数的对象。'
- en: 'Create a class of `UserSurname.kt` to see the use of the constructor injection**.**
    We''ll get the surname from this class, as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 `UserSurname.kt` 类来查看构造函数注入的使用**。**我们将从这个类中获取姓氏，如下所示：
- en: '[PRE14]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Initialize `UserSurname` and add the `getUserSurname()` function to `CreateUserGreeting.kt`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化 `UserSurname` 并将 `getUserSurname()` 函数添加到 `CreateUserGreeting.kt`：
- en: '[PRE15]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, if we call the `getUserSurname()` function in `BeansScopeApplication`,
    we'll get the `UserSurname`class.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们调用 `BeansScopeApplication` 中的 `getUserSurname()` 函数，我们将得到 `UserSurname`
    类。
- en: Here's the sample code of `BeansScopeApplication.kt`**:**
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `BeansScopeApplication.kt` 的示例代码**：**
- en: '[PRE16]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output will be as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Setter injection**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**setter 注入**'
- en: In Spring, a setter injection is a kind of DI in which the framework injects
    the objects that are dependent on another object into the customer using a `setter`
    function. The container first calls the no contention constructor and then calls
    the setters. The setter-based injection will work regardless of whether a few
    dependencies have been injected utilizing the constructor.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring中，setter注入是一种DI，其中框架使用`setter`函数将依赖于另一个对象的`对象`注入到客户中。容器首先调用无参构造函数，然后调用setter。基于setter的注入将无论是否使用构造函数注入了一些依赖项都能正常工作。
- en: 'Let''s see an example of the `setter` injection. Here, reuse the previous project
    and modify the content of `beans.xml`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`setter`注入的一个示例。这里，重用之前的工程并修改`beans.xml`的内容：
- en: '[PRE18]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After modifying the bean file, add a setter and getter of `UserSurname` to
    the `CreateUserGreeting.kt` file:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 修改bean文件后，将`UserSurname`的setter和getter添加到`CreateUserGreeting.kt`文件中：
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The result will be as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'An example of an empty string or `null` value is as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 空字符串或`null`值的示例如下：
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Auto-wiring beans
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动装配bean
- en: We've been utilizing `<constructor-arg>` and `<property>` to inject dependencies.
    Instead, we can `autowire` the dependencies, which helps to diminish the measure
    of configurations that should be composed.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直使用`<constructor-arg>`和`<property>`来注入依赖项。相反，我们可以自动装配依赖项，这有助于减少需要组成的配置量。
- en: There are diverse choices for auto-wiring that manage the Spring container on
    the most proficient method to infuse the conditions. A bean has no auto-wiring
    by default.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 自动装配有多种选择，这些选择管理Spring容器以最有效的方式注入条件。默认情况下，bean没有自动装配。
- en: 'Here are the two major types of auto-wiring:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了两种主要的自动装配类型：
- en: '`byName`: To `autowire` a bean, the Spring container chooses the bean by the
    class name. Here''s an example of the use of `byName`:'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`byName`：要`自动装配`一个bean，Spring容器通过类名选择bean。下面是`byName`使用的一个示例：'
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`byType`: To autowire a bean, the Spring container chooses the bean according
    to the class type. Here is an example of the use of `byType`:'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`byType`：要自动装配一个bean，Spring容器根据类类型选择bean。下面是`byType`使用的一个示例：'
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If there are multiple implementing classes for a `Service` interface, you'll
    find two types of scenario.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个`Service`接口有多个实现类，你会遇到两种情况。
- en: In the case of `services` (a cluster of `services` execute the `Service` interface), bean won't
    allow us to execute the `autowire` of `byName`. If there isn't an occurrence of
    `byName`, it will inject all the executing objects.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在`services`（一组`services`执行`Service`接口）的情况下，bean不允许我们执行`byName`的自动装配。如果没有`byName`的发生，它将注入所有执行对象。
- en: In the case of **`mainService`** (an object actualizes the `Service` interface), for
    the `byType`/constructor, allocate the autowire-applicant attribute in the `<bean>`
    tag of all executing classes as `false`, keeping one of them as `true`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在**`mainService`**（一个对象实现了`Service`接口）的情况下，对于`byType`/构造函数，在所有执行类的`<bean>`标签中将自动装配申请属性设置为`false`，保持其中一个为`true`。
- en: 'Here''s an example of how to handle multiple implementing classes for a `Service`
    interface in `beans.xml`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何在`beans.xml`中处理`Service`接口多个实现类的一个示例：
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'For `byName`, either rename `mainService` in the application class to one of
    the actualizing classes (that is, `userSurname`), or rename the bean `id` of that
    class in the XML configuration to `mainService`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`byName`，可以在应用程序类中将`mainService`重命名为实际化类之一（即`userSurname`），或者在该类的XML配置中将bean的`id`重命名为`mainService`：
- en: '[PRE25]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here are some limitations of auto-wiring:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了自动装配的一些限制：
- en: '**Overriding possibility**: To specify the dependencies, you can use the `<constructor-arg>`
    and `<property>` settings, which will override auto-wiring.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**覆盖可能性**：要指定依赖项，可以使用`<constructor-arg>`和`<property>`设置，这将覆盖自动装配。'
- en: '**Primitive data types**: Primitives, strings, and classes can''t be called.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原始数据类型**：原始数据类型、字符串和类不能被调用。'
- en: '**Confusing nature**: Auto-wiring is less accurate than unequivocal wiring.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混淆性**：自动装配不如明确装配准确。'
- en: Annotation-based configuration
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于注解的配置
- en: Annotations are the new technology of DI**.** This started being used with Spring
    2.5\. There was no need for any XML files to maintain the configuration. To use
    the annotation-based configuration, you need to create a component class in which
    you can implement bean configurations. Annotations are unique names or markers
    on the pertinent class, function, or field revelation.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 注解是DI的新技术**。**它从Spring 2.5开始被使用。不需要任何XML文件来维护配置。要使用基于注解的配置，你需要创建一个组件类，在其中你可以实现bean配置。注解是在相关的类、函数或字段上独特的名称或标记。
- en: Presumably, you're familiar with `@Override`, which is an annotation that tells
    the compiler that this annotation is an abrogated function.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经熟悉`@Override`，这是一个告诉编译器此注解是一个废弃函数的注解。
- en: In the preceding annotations, the conduct of Spring Framework was to a great
    extent controlled through XML configuration. Today, the utilization of annotations
    gives us many advantages through the way we design the practices of Spring Framework.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的注解中，Spring框架的行为在很大程度上是通过XML配置控制的。今天，通过我们设计Spring框架实践的方式，注解的使用给我们带来了许多优势。
- en: 'Here''s a piece of `bean.xml` code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一段`bean.xml`代码：
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If we use `<context:annotation-config/>` in `bean.xml`, we can begin annotating
    the code to wire values into properties, functions, or constructors. We'll learn
    about a few essential annotations in the following sections.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在`bean.xml`中使用`<context:annotation-config/>`，我们就可以开始注解代码，将值连接到属性、函数或构造函数中。在接下来的几节中，我们将学习一些基本注解。
- en: The @Required annotation
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`@Required`注解'
- en: The `@Required` annotation is applied to bean property-setter functions. The
    bean property must be populated in the XML configuration file at configuration-time. This
    annotation essentially shows that the setter function must be arranged to be dependency-injected
    with a value at configuration-time.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Required`注解应用于bean的属性setter函数。bean属性必须在配置时在XML配置文件中填充。此注解本质上表明setter函数必须安排在配置时使用值进行依赖注入。'
- en: Add a user model and the `Main` class with a `bean.xml` configuration file.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个用户模型和`Main`类，并使用`bean.xml`配置文件。
- en: 'The content of the`bean.xml` configuration file is as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`bean.xml`配置文件的内容如下：'
- en: '[PRE27]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The content of `UsersForReq.kt`is as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`UsersForReq.kt`的内容如下：'
- en: '[PRE28]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The content of `AnnotationBasedReqApp.kt`is as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`AnnotationBasedReqApp.kt`的内容如下：'
- en: '[PRE29]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output of this project will be as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 此项目的输出将如下所示：
- en: '[PRE30]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The @Autowired annotation
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`@Autowired`注解'
- en: The `@Autowired` annotation helps us to connect constructors, fields, and setter
    functions. This annotation injects object dependencies.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Autowired`注解帮助我们连接构造函数、字段和setter函数。此注解注入对象依赖项。'
- en: 'Here''s the sample code of how to use `@Autowired` on a property:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用`@Autowired`注解在属性上的示例代码：
- en: '[PRE31]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here''s the sample code of how to use `@Autowired` on a property:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用`@Autowired`注解在属性上的示例代码：
- en: '[PRE32]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The content of `UserDetails.kt`is as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserDetails.kt`的内容如下：'
- en: '[PRE33]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output of the project will be as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 项目的输出将如下所示：
- en: '[PRE34]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can utilize the `@Autowired` annotation on properties to dispose of the
    setter functions. When we pass values of autowired properties utilizing `<property>`,
    Spring will allocate those properties with the passed values or references. So
    with the utilization of `@Autowired` on properties, the `UsersForAutowired.kt`
    file will become as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用`@Autowired`注解在属性上，以消除setter函数。当我们使用`<property>`传递自动装配属性的值时，Spring将使用传递的值或引用分配这些属性。因此，使用属性上的`@Autowired`，`UsersForAutowired.kt`文件将如下所示：
- en: '[PRE35]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The result will be as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '[PRE36]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You can also apply `@Autowired` to constructors. An `@Autowired` constructor annotation
    demonstrates that the constructor should be autowired when making the bean. This
    should be the case regardless of whether any `<constructor-arg>` components are
    utilized when configuring the bean in the XML file.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将`@Autowired`应用于构造函数。`@Autowired`构造函数注解表明在创建bean时应该自动装配构造函数。这应该是在XML文件中配置bean时，无论是否使用了`<constructor-arg>`组件的情况下。
- en: 'Here is the modified content of`UsersForAutowired.kt`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`UsersForAutowired.kt`修改后的内容：
- en: '[PRE37]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The result will be as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '[PRE38]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The @Qualifier annotation
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`@Qualifier`注解'
- en: You might create an excess of one bean of a similar type and need to wire just
    a single one of them with the property. In such cases, you can utilize the `@Qualifier`
    annotation alongside `@Autowired` to evacuate the disarray by determining which
    correct bean will be wired. In this section, we'll look at a precedent to demonstrate
    the utilization of a `@Qualifier` annotation.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能创建了多个相同类型的bean，但只需要通过属性连接其中一个。在这种情况下，您可以使用`@Qualifier`注解与`@Autowired`一起使用，通过确定哪个正确的bean将被连接来消除混乱。在本节中，我们将通过一个示例来展示`@Qualifier`注解的使用。
- en: 'The content of the`bean.xml` configuration file is as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`bean.xml`配置文件的内容如下：'
- en: '[PRE39]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here''s the content of `AnnotationBasedQualifierApp.kt`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`AnnotationBasedQualifierApp.kt`的内容：
- en: '[PRE40]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, add another class. Here''s the content for `UsersForQualifier.kt`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加另一个类。以下是`UsersForQualifier.kt`的内容：
- en: '[PRE41]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, add the `Fighters.kt` class. Here''s the content ofthis class:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加`Fighters.kt`类。以下是该类的内容：
- en: '[PRE42]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If you run the output, it will be as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行输出，它将是以下内容：
- en: '[PRE43]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Modify the qualifier value like so:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 修改限定符值如下：
- en: '[PRE44]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'It will create the following output:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 它将创建以下输出：
- en: '[PRE45]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Code-based configuration
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于代码的配置
- en: We saw how to design Spring beans by utilizing the XML configuration file. If
    you are used to XML configuration, you can ignore this topic.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何通过使用XML配置文件来设计Spring beans。如果您习惯于XML配置，您可以忽略这个主题。
- en: The code-based configuration alternative empowers you to compose the majority
    of your Spring configuration without XML.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 基于代码的配置选项使您能够在不使用XML的情况下编写大部分Spring配置。
- en: The @Configuration and @Bean annotations
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`@Configuration`和`@Bean`注解'
- en: The use of the `@Configuration` annotation on a class, implies that this class
    will be utilized by the Spring IoC container and will be considered a source of
    bean definitions.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个类上使用`@Configuration`注解意味着这个类将被Spring IoC容器使用，并被视为bean定义的来源。
- en: The use of a `@Bean` annotation on a function means the function will return
    an object that's enrolled as a bean in the Spring application context.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个函数上使用`@Bean`注解意味着该函数将返回一个对象，该对象将被注册为Spring应用程序上下文中的一个bean。
- en: 'Here''s a sample code of `@Configuration` and `@Bean`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`@Configuration`和`@Bean`的示例代码：
- en: '[PRE46]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The previous code will be equivalent to the following XML configuration:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将与以下XML配置等效：
- en: '[PRE47]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Here, the function name is commented on with the `@Bean` annotation, which creates
    and returns the bean definition. Your configuration class can have a presentation
    for in excess of one `@Bean`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，函数名通过`@Bean`注解进行注释，这创建了并返回了bean定义。您的配置类可以有多个`@Bean`。
- en: 'The content of `GreetingConfigurationConfBean.kt`is as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`GreetingConfigurationConfBean.kt`的内容如下：'
- en: '[PRE48]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The content of `GreetingConfBean.kt`is as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`GreetingConfBean.kt`的内容如下：'
- en: '[PRE49]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The content of `MainAppConfBean.kt`is as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainAppConfBean.kt`的内容如下：'
- en: '[PRE50]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The result will be as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是以下内容：
- en: '[PRE51]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Dependency injection bean
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入bean
- en: Annotate the `@Bean` annotation to inject dependencies. Here's the content of
    `GreetingConfigurationDIBean.kt`**:**
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 注释`@Bean`注解以注入依赖项。以下是`GreetingConfigurationDIBean.kt`的内容**：**
- en: '[PRE52]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: When two `@Beans` are dependent on each other, the dependency is as simplistic
    as having one bean method call another.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个`@Beans`相互依赖时，这种依赖关系就像一个bean方法调用另一个bean一样简单。
- en: 'The content of `GreetingDIBean.kt`is as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`GreetingDIBean.kt`的内容如下：'
- en: '[PRE53]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The content of `GreetingDetailsDIBean.kt` is as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`GreetingDetailsDIBean.kt`的内容如下：'
- en: '[PRE54]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The content of `MainApp.kt`is as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainApp.kt`的内容如下：'
- en: '[PRE55]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The result will be the following:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是以下内容：
- en: '[PRE56]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The @Import annotation
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`@Import`注解'
- en: Spring's `@Import` annotation offers functions such as `<import/>` an element
    in Spring XML. By utilizing the `@Import` annotation, you can import at least
    one `@Configuration` class. It can also import classes that contain no less than
    one `@Bean` function.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Spring的`@Import`注解提供了类似于Spring XML中的`<import/>`元素的功能。通过使用`@Import`注解，您可以导入至少一个`@Configuration`类。它还可以导入包含至少一个`@Bean`函数的类。
- en: 'The content of `Boo.kt`is as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boo.kt`的内容如下：'
- en: '[PRE57]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The content of `ConfigBoo.kt`is as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConfigBoo.kt`的内容如下：'
- en: '[PRE58]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'You don''t need to specify both `ConfigFoo.class` and `ConfigBoo.class` when
    instantiating the context, so the following code isn''t required when you initialize
    `AnnotationConfigApplicationContext`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例化上下文时，您不需要指定`ConfigFoo.class`和`ConfigBoo.class`，因此当您初始化`AnnotationConfigApplicationContext`时，以下代码是不必要的：
- en: '[PRE59]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'As bean definitions of `ConfigFoo` are already loaded by using the `@Import`
    annotation with the `ConfigBoo` bean, only `ConfigBoo` needs to be explicitly specified:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`ConfigFoo`的bean定义已经通过使用带有`ConfigBoo` bean的`@Import`注解加载，因此只需显式指定`ConfigBoo`：
- en: '[PRE60]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Here''s the modified complete code of the `main` function of  `MainAppImport.kt`:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`MainAppImport.kt`的`main`函数修改后的完整代码：
- en: '[PRE61]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The result will be as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '[PRE62]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Life cycle callbacks
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生命周期回调
- en: 'A `@Bean` annotation supports determining discretionary introductions and obliteration
    callback functions. If you noticed `beans.xml` in the `XMLBasedSpringConfiguration`
    project, you can find the `init-method` and `destroy-method` attributes. Here''s
    an example of how to initialize the `init-method` and `destroy-method` attributes:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Bean`注解支持确定可选的引入和销毁回调函数。如果您注意到了`XMLBasedSpringConfiguration`项目中的`beans.xml`，您可以在其中找到`init-method`和`destroy-method`属性。以下是如何初始化`init-method`和`destroy-method`属性的示例：'
- en: '[PRE63]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Here''s the modified code of `MainAppLifeCall.kt`:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`MainAppLifeCall.kt`的修改代码：
- en: '[PRE64]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The modified code of `Foo.kt` is as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`Foo.kt`的修改代码如下：'
- en: '[PRE65]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now create a configuration class for `Foo`. The modified code of `ConfigFoo.kt` is
    as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在为`Foo`创建一个配置类。`ConfigFoo.kt`的修改代码如下：
- en: '[PRE66]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The output of this project will be as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 此项目的输出将如下所示：
- en: '[PRE67]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Creating a scope bean
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个作用域bean
- en: 'Create a `@Scope` bean to make a prototype scope with `@Configuration`. `@Configuration`
    represents the configure file of a SpringBoot project. Here''s a piece of code
    that shows how to use the `@Scope` prototype annotation:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@Configuration`创建一个`@Scope` bean以创建原型作用域。`@Configuration`代表SpringBoot项目的配置文件。以下是一段展示如何使用`@Scope`原型注解的代码：
- en: '[PRE68]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Spring MVC
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring MVC
- en: The Spring Web MVC framework uses the **model-view-controller** (**MVC**) architecture,
    which manages the web applications. This provides a ready component that can be
    used by developers to develop a robust and loosely-coupled web application. With
    the presentation of Spring 3.0, the `@Controller` component additionally enables
    you to make peaceful web locales and applications through the `@PathVariable`
    annotation and different features. The MVC pattern separates the different aspects,
    such as input, business, and UI logic of the application.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Web MVC框架使用**模型-视图-控制器**（**MVC**）架构来管理Web应用程序。这为开发者提供了一个现成的组件，可以用来开发强大且松散耦合的Web应用程序。随着Spring
    3.0的推出，`@Controller`组件还通过`@PathVariable`注解和其他特性，使您能够创建和平的Web区域和应用程序。MVC模式将应用程序的不同方面分开，如输入、业务和UI逻辑。
- en: 'There are three parts to MVC:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: MVC有三个部分：
- en: The **model** is at the core of MVC applications. This is where the primary
    logic and information objects that comprise the core usefulness of the application
    are produced.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**是MVC应用程序的核心。这是产生构成应用程序核心有用性的主要逻辑和信息对象的地方。'
- en: The **view**is the place the information given by the model is introduced to
    the client. A view regulates the visual (or other) interface components – it chooses,
    filters, and arranges data provided by the model.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**是模型提供的信息被引入客户端的地方。视图调节视觉（或其他）界面组件——它选择、过滤和安排模型提供的数据。'
- en: The **controller** is in charge of preparing client requests, building a proper
    model, and passing it to the view for rendering.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**负责准备客户端请求，构建适当的模型，并将其传递给视图进行渲染。'
- en: 'Here are some of the advantages of Spring MVC framework:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Spring MVC框架的一些优点：
- en: Spring MVC helps to separate each role, such as the model object and controller.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring MVC有助于分离每个角色，如模型对象和控制器。
- en: When developing and deploying an application, it helps developers to use the
    lightweight servlet container.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发和部署应用程序时，它帮助开发者使用轻量级servlet容器。
- en: It provides a robust and powerful configuration for the project.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为项目提供了一个强大且灵活的配置。
- en: You can develop a project very quickly and in parallel.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以非常快速且并行地开发一个项目。
- en: Testing is very easy and you can inject test data using a setter function.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试非常简单，您可以使用setter函数注入测试数据。
- en: DispatcherServlet
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DispatcherServlet
- en: '`DispatcherServlet` is one of the core components of the Spring MVC. This works
    as a front-controller in an application. A front-controller means the Spring MVC receives
    all incoming requests and forwards these to the Spring MVC controller for processing. This
    is totally coordinated with the Spring IoC container and accordingly enables you
    to utilize each element of Spring.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`DispatcherServlet` 是 Spring MVC 的核心组件之一。它在应用程序中充当前端控制器。前端控制器意味着 Spring MVC
    接收所有传入的请求并将它们转发到 Spring MVC 控制器进行处理。这与 Spring IoC 容器完全协调，因此您可以使用 Spring 的每个元素。'
- en: '`DispatcherServlet` handles all the HTTP requests and responses that are designed
    under the Spring MVC.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`DispatcherServlet` 处理所有在 Spring MVC 下设计的 HTTP 请求和响应。'
- en: 'Here''s a diagram to illustrate `DispatcherServlet`:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个用于说明 `DispatcherServlet` 的图示：
- en: '![](img/94318afd-4eef-42b2-b829-cbb1af7802a9.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/94318afd-4eef-42b2-b829-cbb1af7802a9.png)'
- en: 'The succession of occasions relating to an approaching HTTP request to `DispatcherServlet`
    is as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 与即将到来的 HTTP 请求到 `DispatcherServlet` 相关的事件顺序如下：
- en: The application (as a client) sends a request to `DispatcherServlet`*.*
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序（作为客户端）向 `DispatcherServlet` 发送请求。
- en: '`DispatcherServlet`asks the related `Handler Mapping` to call the `Controller`.'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DispatcherServlet` 会请求相关的 `Handler Mapping` 来调用 `Controller`。'
- en: The `Controller` takes requests from `DispatcherServlet` and calls a relevant
    service function based on the `GET` or `POST` function. The service function sets
    the model data based on the business logic.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Controller` 从 `DispatcherServlet` 接收请求，并根据 `GET` 或 `POST` 方法调用相关的服务函数。服务函数根据业务逻辑设置模型数据。'
- en: '`ViewResolver` selects the defined `View`.'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ViewResolver` 选择定义好的 `View`。'
- en: The defined `View` is executed on the application.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义好的 `View` 在应用程序中执行。
- en: Creating a project
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建项目
- en: 'Now, we''ll learn about the MVC framework with Kotlin. Although this project
    is a web application and we need to utilize Maven for dependencies administration,
    we need to make a dynamic web application and then change it to a Maven venture first.
    The following screenshot demonstrates how to prepare our task skeleton structure:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将学习如何使用 Kotlin 了解 MVC 框架。尽管这个项目是一个 Web 应用程序，我们需要使用 Maven 进行依赖管理，但我们首先需要创建一个动态
    Web 应用程序，然后将其转换为 Maven 项目。以下截图展示了如何准备我们的任务骨架结构：
- en: '![](img/57358265-433c-4cec-8502-a571cb33f1c0.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/57358265-433c-4cec-8502-a571cb33f1c0.png)'
- en: Now we're going to learn how to convert this project into a Maven project.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将学习如何将此项目转换为 Maven 项目。
- en: Converting to a Maven project
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换为 Maven 项目
- en: Now that the skeleton code for our Maven web-application venture is prepared,
    we can begin rolling out improvements to it, as well as making our Spring MVC
    HELLO WORLD application.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了我们的 Maven Web 应用程序项目的骨架代码，我们可以开始对其进行改进，同时创建我们的 Spring MVC HELLO WORLD
    应用程序。
- en: The created project is a non-Maven project. We need to convert the project into
    the Maven project.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的项目是一个非 Maven 项目。我们需要将项目转换为 Maven 项目。
- en: To convert this project into a Maven project, open the existing project. In
    the project tool window, right-click your project and select Add Framework Support.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此项目转换为 Maven 项目，打开现有项目。在项目工具窗口中，右键单击您的项目并选择添加框架支持。
- en: 'In the dialog that opens, select Maven from the options on the left and click
    OK:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开的对话框中，从左侧选项中选择 Maven 并点击确定：
- en: '![](img/8b68d747-7842-4054-936e-d1d30706ed50.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8b68d747-7842-4054-936e-d1d30706ed50.png)'
- en: Spring MVC dependencies to pom.xml
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Spring MVC 依赖项添加到 pom.xml
- en: 'We have to include `spring-web` and `spring**-**webmvc` dependencies in `pom.xml`,
    as well as including a servlet-programming interface, JSP-programming interface,
    and JSTL dependencies. Here''s part of the `pom.xml` file (the full version is
    on GitHub) of our project with the `Spring Core`, `Kotlin`, and `Web` dependencies:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在 `pom.xml` 中包含 `spring-web` 和 `spring**-**webmvc` 依赖项，以及包括一个 servlet 编程接口、JSP
    编程接口和 JSTL 依赖项。以下是我们的项目 `pom.xml` 文件的部分内容（完整版本在 GitHub 上），其中包含 `Spring Core`、`Kotlin`
    和 `Web` 依赖项：
- en: '[PRE69]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Creating Spring configuration beans
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Spring 配置 Bean
- en: 'Go to the `/WebContent/WEB-INF/` directory and create an XML file called `spring-mvc-kotlin-servlet.xml`:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 `/WebContent/WEB-INF/` 目录并创建一个名为 `spring-mvc-kotlin-servlet.xml` 的 XML 文件：
- en: '[PRE70]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In the `spring-mvc-kotlin-servlet.xml` configuration file, we mentioned a `<context:component-scan>`tag. All
    the components from the `mvckotlin` package and all its child packages will now
    be loaded by the Spring:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `spring-mvc-kotlin-servlet.xml` 配置文件中，我们提到了 `<context:component-scan>` 标签。现在，Spring
    将加载来自 `mvckotlin` 包及其所有子包的所有组件：
- en: This will load our `MVCKotlinApp.class` and also assign a `viewResolver` bean.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这将加载我们的 `MVCKotlinApp.class` 并分配一个 `viewResolver` 实例。
- en: '`<property name="prefix" value="/WEB-INF/jsp/" />` will resolve the view and
    add a prefix string named `/WEB-INF/jsp/`.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<property name="prefix" value="/WEB-INF/jsp/" />` 将解析视图并添加一个名为 `/WEB-INF/jsp/`
    的前缀字符串。'
- en: Note that we have returned a `ModelAndView` object with the view name `welcome`in
    our `MVCKotlinApp` class.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，我们在 `MVCKotlinApp` 类中返回了一个名为 `welcome` 的视图 `ModelAndView` 对象。
- en: This will be resolved to the `/WEB-INF/jsp/greeting.jsp` path.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这将被解析为 `/WEB-INF/jsp/greeting.jsp` 路径。
- en: 'There''s a `web.xml` file under the `/WebContent/WEB-INF/` directory. If you
    don''t find it, create it in the `/WebContent/WEB-INF/` directory. Here''s a piece
    of code from `web.xml`:'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `/WebContent/WEB-INF/` 目录下有一个 `web.xml` 文件。如果您找不到它，请在 `/WebContent/WEB-INF/`
    目录中创建它。以下是 `web.xml` 的一部分代码：
- en: '[PRE71]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '`web.xml` will map `DispatcherServlet` with the `/greeting.jsp` URL pattern.
    Furthermore, note that we have mentioned `index.jsp` as a greeting file.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`web.xml` 将将 `DispatcherServlet` 映射到 `/greeting.jsp` URL 模式。此外，请注意，我们已将 `index.jsp`
    作为问候文件提及。'
- en: After initialization, `DispatcherServlet` will look for a file named `[servlet-name]-servlet.xml`
    in the `WEB-INF` folder. The value of the servlet XML file prefix name, and value
    of the `<servlet-name>` tag in `web.xml`, have to be the same. In our example, the
    name of the servlet is `spring-mvc-kotlin-servlet.xml`.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化后，`DispatcherServlet` 将在 `WEB-INF` 文件夹中查找名为 `[servlet-name]-servlet.xml`
    的文件。Servlet XML 文件的前缀名称和 `web.xml` 中 `<servlet-name>` 标签的值必须相同。在我们的示例中，servlet
    的名称是 `spring-mvc-kotlin-servlet.xml`。
- en: Creating a controller class
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建控制器类
- en: 'Go to `src` | `main` | `java` in the project and create the package name that
    we mentioned in `spring-mvc-kotlin-servlet.xml`*.* Assume that our package name
    is `mvckotlin`:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目中转到 `src` | `main` | `java`，创建我们在 `spring-mvc-kotlin-servlet.xml` 中提到的包名。假设我们的包名是
    `mvckotlin`：
- en: '![](img/9c0ad46a-d8c1-43c5-81d7-8176714cc961.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9c0ad46a-d8c1-43c5-81d7-8176714cc961.png)'
- en: 'Create a controller `.kt` file. We call this `MVCKotlinAppController.kt`:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个控制器 `.kt` 文件。我们称这个为 `MVCKotlinAppController.kt`：
- en: '[PRE72]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: We have a class named `MVCKotlinAppController.kt` and annotated this with `@Controller`,
    which means that this class is a controller class. After initializing the project,
    Spring starts to search the bundle from here.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为 `MVCKotlinAppController.kt` 的类，并使用 `@Controller` 注解，这意味着这个类是一个控制器类。在初始化项目后，Spring
    从这里开始搜索包。
- en: The `@RequestMapping("/greeting")` annotation will map a web request and `/greeting`
    will create a base URI.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`@RequestMapping("/greeting")` 注解将映射一个网络请求，`/greeting` 将创建一个基本 URI。'
- en: We have created a function named `greetingMessage()` that will return a `ModelAndView`
    object. Here we just create a sample `HTML` code for greeting. If we go to `http://localhost:8080/greeting`,
    this will return a view based on `greetingMessage()`.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `greetingMessage()` 的函数，它将返回一个 `ModelAndView` 对象。在这里，我们只是创建了一个用于问候的示例
    `HTML` 代码。如果我们访问 `http://localhost:8080/greeting`，这将基于 `greetingMessage()` 返回一个视图。
- en: The view
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图
- en: 'Create a new file named `/WebContent/index.jsp`,with the following content:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `/WebContent/index.jsp` 的新文件，内容如下：
- en: '[PRE73]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Then create another file named `/WebContent/WEB-INF/jsp/greeting.jsp`, with
    the following content:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 然后创建另一个名为 `/WebContent/WEB-INF/jsp/greeting.jsp` 的文件，内容如下：
- en: '[PRE74]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: IntelliJ Ultimate
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IntelliJ Ultimate
- en: 'To run the project, you need to set up the run configuration. Follow these
    steps to do so:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行项目，您需要设置运行配置。按照以下步骤操作：
- en: 'Click the Run...button from the toolbar and then add Maven with the **`clean`
    `install`** comment:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从工具栏中点击 Run... 按钮，然后添加带有 **`clean` `install`** 注释的 Maven：
- en: '![](img/3b1fb350-9e38-46e9-9c1d-7cd2c7268015.png)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3b1fb350-9e38-46e9-9c1d-7cd2c7268015.png)'
- en: 'Add `TomCat Server` --> `Local` and add the `SpringMVCKotlin:war` build from
    Deployment:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `TomCat Server` --> `Local` 并将 `SpringMVCKotlin:war` 构建从部署添加：
- en: '**![](img/ed512f7c-261c-4335-a2e9-cc8b690efe21.png)**'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '**![图片](img/ed512f7c-261c-4335-a2e9-cc8b690efe21.png)**'
- en: Click the RUN button on the menu bar to start the project.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击菜单栏上的运行按钮以启动项目。
- en: Eclipse
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Eclipse
- en: 'Here are the steps to build the project:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 构建项目的步骤如下：
- en: To run the project, right-click on Project | Run As | Maven Build....
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行项目，请右键单击项目 | 运行 As | Maven Build....
- en: Add Goals—**clean install*.***
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加目标—**干净安装**。***
- en: Click Apply and Run.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击应用并运行。
- en: 'If there are no errors, you''ll see the following **BUILD SUCCESS** message:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有错误，您将看到以下 **BUILD SUCCESS** 消息：
- en: '![](img/cbde584e-8221-4b7d-b140-a2df0c96df39.png)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cbde584e-8221-4b7d-b140-a2df0c96df39.png)'
- en: 'Visit  `http://localhost:8080/SpringMVCKotlin/`, where you''ll see the following
    output of the demo code:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 `http://localhost:8080/SpringMVCKotlin/`，您将看到以下演示代码的输出：
- en: '![](img/ca36df6f-c34e-4aea-a135-1c0cee098fef.png)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ca36df6f-c34e-4aea-a135-1c0cee098fef.png)'
- en: SpringBoot
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SpringBoot
- en: '**SpringBoot** is a Spring Framework module that has some features to help
    developers create a production-class application. SpringBoot is a combination
    of two words—**BOOT** is from bootstrap, while **SPRING** is a framework used
    to build Java enterprise applications. This is a large framework that''s also
    supported by numerous other frameworks. SpringBoot is similar in that it lets
    you bootstrap a spring application from scratch, which is how it gets the name
    SpringBoot. According to `spring.io`, here''s the definition of SpringBoot—"Spring
    Boot makes it easy to create stand-alone, production-grade, Spring-based applications
    that you can just run." This means that it helps you to create a runnable project
    without the help of others. In addition, we showed a **production-grade** project here, which is
    a ready-product application. SpringBoot minimizes the pain of setting up an application.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '**SpringBoot**是Spring框架的一个模块，它具有一些帮助开发者创建生产级应用程序的功能。SpringBoot由两个词组成——**BOOT**来自bootstrap，而**SPRING**是用于构建Java企业应用程序的框架。这是一个大型框架，也受到许多其他框架的支持。SpringBoot与之相似，因为它允许您从头开始引导Spring应用程序，这就是它得名SpringBoot的原因。根据`spring.io`，以下是SpringBoot的定义——“Spring
    Boot使创建独立、生产级、基于Spring的应用程序变得容易，您可以直接运行。”这意味着它帮助您在没有他人帮助的情况下创建可运行的项目。此外，我们在这里展示了一个**生产级**的项目，这是一个成品应用程序。SpringBoot最小化了设置应用程序的痛苦。'
- en: 'The features of SpringBoot are as follows:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: SpringBoot的功能如下：
- en: It helps to create a standalone Spring application.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有助于创建独立的Spring应用程序。
- en: It comes with Tomcat, Jetty, or Undertow, and so there's no need to worry about
    setting up the server environment.
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它自带Tomcat、Jetty或Undertow，因此无需担心设置服务器环境。
- en: With the use of SpringBoot, you don't need to deploy WAR files.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SpringBoot，您不需要部署WAR文件。
- en: Third-party frameworks can be imported automatically with their configurations.
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以自动导入第三方框架及其配置。
- en: XML configuration isn't required if you use SpringBoot.
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您使用SpringBoot，则不需要XML配置。
- en: SpringBoot doesn't produce code or make changes to your files. Instead, when
    you start up your application, SpringBoot dynamically wires up beans and settings,
    and applies them to your application context.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: SpringBoot不会生成代码或更改您的文件。相反，当您启动应用程序时，SpringBoot会动态连接beans和设置，并将它们应用到应用程序上下文中。
- en: Let's create a SpringBoot project to learn about its dependencies and features.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个SpringBoot项目来了解其依赖项和功能。
- en: Creating a project
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建项目
- en: 'To create a Spring Boot project, let''s generate a sample project from [https://start.spring.io/](https://start.spring.io/).
    Here, you can add your required dependencies, such as `Web`, `Thymeleaf`, `JPA`
    , and `DevTools`. This can be done as follows:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个Spring Boot项目，让我们从[https://start.spring.io/](https://start.spring.io/)生成一个示例项目。在这里，您可以添加所需的依赖项，例如`Web`、`Thymeleaf`、`JPA`和`DevTools`。可以按照以下步骤操作：
- en: 'In the drop-down menus at the top, select **Maven Project** with **Kotlin** and
    Spring Boot **2.1.1 (SNAPSHOT)**:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶部的下拉菜单中，选择**Maven Project**，带有**Kotlin**和Spring Boot **2.1.1 (SNAPSHOT)**：
- en: '![](img/d65f510d-7aba-49c6-ae62-5dc840d50fc0.png)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d65f510d-7aba-49c6-ae62-5dc840d50fc0.png)'
- en: Give the name of **Group**, **Artifact**, **Package Name**, and add **Dependencies**.
    Then hit Generate Project.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入**组**、**工件**、**包名**，并添加**依赖项**。然后点击生成项目。
- en: Download and unzip the project.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并解压项目。
- en: Import the downloaded project into your IDE.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将下载的项目导入到您的IDE中。
- en: After following these steps, you're ready to use and modify the project. Let's
    see what's inside this project. You'll find a controller file under `src/main/kotlin/{packageName}/AppController.kt`.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这些步骤操作后，您就可以使用和修改项目了。让我们看看这个项目里面有什么。您将在`src/main/kotlin/{packageName}/AppController.kt`下找到一个控制器文件。
- en: 'Here''s a piece of code from the `controller` file:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`controller`文件中的一段代码：
- en: '[PRE75]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Create a class named `HtmlController.kt` and annotate it with the `@RestController`
    annotation to make it a controller class in which we'll deal with web requests.
    `@RestController` is the combination of `@Controller` and `@ResponseBody`.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`HtmlController.kt`的类，并用`@RestController`注解使其成为一个控制器类，我们将处理网络请求。`@RestController`是`@Controller`和`@ResponseBody`的组合。
- en: 'Create a function named `blog(model: Model)` and annotate it with `@GetMappingmaps("/")`.
    This will return `index.xml` as output.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '创建一个名为`blog(model: Model)`的函数，并用`@GetMappingmaps("/")`注解它。这将返回`index.xml`作为输出。'
- en: Creating an application class
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建应用程序类
- en: 'Under **`src/main/kotlin/{packageName}`**,create an application class named
    `SpringBootKotlinApplication.kt`:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `**`src/main/kotlin/{packageName}`**` 下创建一个名为 `SpringBootKotlinApplication.kt`
    的应用程序类：
- en: '[PRE76]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '`@SpringBootApplication` is utilized to empower the following three features:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '`@SpringBootApplication` 用于启用以下三个功能：'
- en: '`@Configuration` enables Java-based configuration.'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Configuration` 启用了基于 Java 的配置。'
- en: '`@EnableAutoConfiguration` enables the auto-configuration feature of SpringBoot.'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@EnableAutoConfiguration` 启用了 SpringBoot 的自动配置功能。'
- en: '`@ComponentScan` enables component scanning.'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ComponentScan` 启用了组件扫描。'
- en: The `main()` function utilizes SpringBoot's `SpringApplication.run()` method
    to dispatch an application. This web application is 100% unadulterated Kotlin
    and there's no need to arrange any pipes or foundations here.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 函数使用 SpringBoot 的 `SpringApplication.run()` 方法来分发应用程序。这个网络应用程序是 100%
    纯 Kotlin，这里不需要安排任何管道或基础结构。'
- en: Similarly, there's a `CommandLineRunner` function set apart as `@Bean` and this
    keeps running on startup. It recovers every one of the beans that were made either
    by your application or were naturally added by SpringBoot. It then sorts and prints
    these out.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，有一个作为 `@Bean` 设置的 `CommandLineRunner` 函数，它在启动时持续运行。它恢复由你的应用程序创建的或由 SpringBoot
    自动添加的所有 bean。然后它对这些进行排序并打印出来。
- en: In the code of the `SpringBootKotlinApplication` class, in contrast with Java,
    you can see the absence of semicolons, the absence of sections in an empty class
    (you can add a few, in case you have to proclaim beans by means of a `@Bean` annotation),
    and the utilization of a `runApplication` top-level function. `runApplication<SpringBootKotlinApplication>(*args)`
    is Kotlin's informal option in contrast to `SpringApplication.run(SpringBootKotlinApplication::class.java,
    *args)`, and this can be utilized to customize the application.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `SpringBootKotlinApplication` 类的代码中，与 Java 相比，你可以看到没有分号，空类中没有部分（如果你需要通过 `@Bean`
    注解声明 beans，可以添加一些），以及使用 `runApplication` 顶级函数。`runApplication<SpringBootKotlinApplication>(*args)`
    是 Kotlin 的非正式选项，与 `SpringApplication.run(SpringBootKotlinApplication::class.java,
    *args)` 相比，并且可以用来自定义应用程序。
- en: Now create an HTML file in the folder underneath `src/main/resources/templates/`.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `src/main/resources/templates/` 下的文件夹中创建一个 HTML 文件。
- en: 'The content of `index.html` is as follows:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html` 的内容如下：'
- en: '[PRE77]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Start the web application by running the `main` function of `SpringBootKotlinApplication.kt`.
    If everything is fine, you''ll see this in the logcat:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行 `SpringBootKotlinApplication.kt` 中的 `main` 函数来启动网络应用程序。如果一切正常，你将在日志中看到以下内容：
- en: '![](img/8497d12c-2632-4b56-8b74-7036ee7c725a.png)'
  id: totrans-405
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8497d12c-2632-4b56-8b74-7036ee7c725a.png)'
- en: 'Next, go to `http://localhost:8080/`. Here, you should see a web page with
    a SpringBoot Kotlin application headline:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，访问 `http://localhost:8080/`。在这里，你应该看到一个带有 SpringBoot Kotlin 应用程序标题的网页：
- en: '![](img/ea5af8b3-1f45-47d1-9f6b-42ac4b9572fe.png)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ea5af8b3-1f45-47d1-9f6b-42ac4b9572fe.png)'
- en: We've covered the basics of SpringBoot. Later, we'll go into this in more depth
    with more dependencies.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了 SpringBoot 的基础知识。稍后，我们将通过更多的依赖项对其进行更深入的探讨。
- en: Summary
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored Spring and its modules, dependencies, and use of
    functions. We attempted to cover all the essential information that will be required
    for the rest of this book. We looked at the steady and solid architecture of Spring
    Framework with Core, Information Access, Web, AOP, Instrumentation, and Test.
    Furthermore, we figured out the life cycle of a bean and how to design beans in
    three different ways. We found out about the depth of bean configurations, and
    we learned about the use of beans in XML, annotation, and code. Now we know how
    to inject the dependencies into the tasks.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 Spring 及其模块、依赖项和函数的使用。我们试图涵盖本书其余部分所需的所有基本信息。我们研究了 Spring 框架的稳定和坚固的架构，包括核心、信息访问、Web、AOP、仪器和测试。此外，我们了解了
    bean 的生命周期以及如何以三种不同的方式设计 bean。我们发现了 bean 配置的深度，并学习了在 XML、注解和代码中使用 bean。现在我们知道了如何将依赖项注入到任务中。
- en: 'We explored two noteworthy frameworks: Spring MVC and SpringBoot. We''ll now
    be able to make an MVC-based venture with its dependencies and modules. In addition,
    we learned out about the use of SpringBoot and created a web application that
    uses Boot, allowing us to make a web page without an HTML file. We also explored
    the contrasts between Spring MVC and SpringBoot. You can now create a Spring project
    in the Kotlin language.'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了两个值得注意的框架：Spring MVC和SpringBoot。现在，我们将能够创建一个基于MVC的项目，包括其依赖项和模块。此外，我们还学习了SpringBoot的使用，并创建了一个使用Boot的Web应用程序，使我们能够在没有HTML文件的情况下制作网页。我们还探讨了Spring
    MVC和SpringBoot之间的区别。现在，您可以使用Kotlin语言创建Spring项目。
- en: In the next chapter, we'll learn about the required Android and Spring modules
    to build a client application on the Android platform.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习构建Android平台上的客户端应用程序所需的Android和Spring模块。
- en: Questions
  id: totrans-413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is Spring Framework?
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是Spring框架？
- en: What is dependency injection?
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是依赖注入？
- en: What is aspect-oriented programming?
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是面向方面的编程？
- en: What is the Spring IoC container?
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是Spring IoC容器？
- en: What is a Spring bean?
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是Spring Bean？
- en: What is a controller in Spring MVC?
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Spring MVC中，控制器是什么？
- en: What is `DispatcherServlet`?
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是`DispatcherServlet`？
- en: What is `ContextLoaderListener`?
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是`ContextLoaderListener`？
- en: What is the boilerplate code?
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是样板代码？
- en: Further reading
  id: totrans-423
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Learning Spring Application Development* ([https://www.packtpub.com/application-development/learning-spring-application-development](https://www.packtpub.com/application-development/learning-spring-application-development))'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《学习Spring应用程序开发》* ([https://www.packtpub.com/application-development/learning-spring-application-development](https://www.packtpub.com/application-development/learning-spring-application-development))'
- en: '*Spring MVC: Beginner''s Guide - Second Edition* ([https://www.packtpub.com/application-development/spring-mvc-beginners-guide-second-edition](https://www.packtpub.com/application-development/spring-mvc-beginners-guide-second-edition))'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Spring MVC：入门指南 - 第二版》* ([https://www.packtpub.com/application-development/spring-mvc-beginners-guide-second-edition](https://www.packtpub.com/application-development/spring-mvc-beginners-guide-second-edition))'
- en: '*Spring: Microservices with Spring Boot* ([https://www.packtpub.com/application-development/spring-microservices-spring-boot](https://www.packtpub.com/application-development/spring-microservices-spring-boot))'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Spring：使用Spring Boot构建微服务》* ([https://www.packtpub.com/application-development/spring-microservices-spring-boot](https://www.packtpub.com/application-development/spring-microservices-spring-boot))'
