- en: Chapter 8. Integrating iOS Features
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。集成iOS功能
- en: 'In this chapter, we will cover the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Starting phone calls
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始电话通话
- en: Sending text messages and e-mails
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送短信和电子邮件
- en: Using text messaging in our application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的应用程序中使用短信
- en: Using e-mail messaging in our application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的应用程序中使用电子邮件消息
- en: Managing the address book
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理地址簿
- en: Displaying contacts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示联系人
- en: Managing the calendar
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理日历
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Mobile devices offer a handful of features to the user. Creating an app that
    interacts with these features to provide a complete experience to users can surely
    be considered as an advantage.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 移动设备为用户提供了许多功能。创建一个与应用这些功能交互以向用户提供完整体验的应用程序可以肯定被视为一种优势。
- en: 'In this chapter, we will discuss some of the most common features of iOS and
    how to integrate some or all of their functionality into our apps. We will see
    how to offer the user the ability to make telephone calls and send SMS and e-mails,
    either using the native platform apps or by integrating the native user interface
    in our projects. Also, we will discuss the following components:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论iOS的一些最常见功能以及如何将它们的一些或全部功能集成到我们的应用程序中。我们将看到如何使用原生平台应用或通过在我们的项目中集成原生用户界面来提供用户拨打电话、发送短信和电子邮件的能力。此外，我们还将讨论以下组件：
- en: '**MFMessageComposeViewController**: This controller is suitable for sending
    text (SMS) messages'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MFMessageComposeViewController**：此控制器适用于发送文本（短信）消息'
- en: '**MFMailComposeViewController**: This controller is used for sending e-mails
    with or without attachments'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MFMailComposeViewController**：此控制器用于发送带或不带附件的电子邮件'
- en: '**ABAddressBook**: This class provides us access to the address book database'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ABAddressBook**：此类为我们提供了访问地址簿数据库的权限'
- en: '**ABPersonViewController**: This controller displays and/or edits contact information
    from the address book'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ABPersonViewController**：此控制器显示和/或编辑地址簿中的联系人信息'
- en: '**EKEventStore**: This class is responsible for managing calendar events'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EKEventStore**：此类负责管理日历事件'
- en: Furthermore, we will learn how to read and save contact information, how to
    display contact details, and interact with the device's calendar.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将学习如何读取和保存联系人信息，如何显示联系人详细信息，以及与设备的日历交互。
- en: Note that some of the examples in this chapter will require a device. For example,
    the simulator does not contain the *Messaging* app. To deploy a simulator to a
    device, you will need to enroll as an iOS Developer through Apple's Developer
    Portal.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，本章中的一些示例可能需要设备。例如，模拟器不包含*消息*应用。要将模拟器部署到设备上，您需要通过苹果开发者门户注册为iOS开发者。
- en: Starting phone calls
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始电话通话
- en: In this recipe, we will learn how to invoke the native *Phone* app to allow
    the user to place a phone call.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何调用原生的*电话*应用，允许用户拨打电话。
- en: Getting ready
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **Single View Application** in Xamarin Studio and name it `PhoneCallApp`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin Studio中创建一个新的**单视图应用程序**，并将其命名为`PhoneCallApp`。
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The native *Phone* app is not available on the simulator. It is only available
    on an iPhone device.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 原生的*电话*应用在模拟器上不可用。它仅在iPhone设备上可用。
- en: How to do it...
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to allow the user to place phone calls:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以允许用户拨打电话：
- en: Add a button on the view of `PhoneCallAppViewController`.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PhoneCallAppViewController`的视图中添加一个按钮。
- en: 'Add the following code in the `ViewDidLoad` method:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ViewDidLoad`方法中添加以下代码：
- en: '[PRE0]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Compile and run the app on the device. Tap the **Call phone number** button
    to start the call. The following screenshot shows the *Phone* app placing a call:![How
    to do it...](img/8924OT_08_01.jpg)
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备上编译并运行应用。点击**呼叫电话号码**按钮开始通话。以下截图显示了*电话*应用正在拨打电话：![如何操作...](img/8924OT_08_01.jpg)
- en: How it works...
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Through the `UIApplication.SharedApplication` static property, we have access
    to the app''s `UIApplication` object. We can use its `OpenUrl` method that accepts
    an `NSUrl` variable to initiate a call using the following line of code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`UIApplication.SharedApplication`静态属性，我们可以访问应用的`UIApplication`对象。我们可以使用其`OpenUrl`方法，该方法接受一个`NSUrl`变量，以下是一行代码来启动通话：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Because not all iOS devices support the native *Phone* app, it would be useful
    to check for availability first. You can do this using the following code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于并非所有iOS设备都支持原生的*电话*应用，因此首先检查其可用性将很有用。您可以使用以下代码来完成此操作：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When the `OpenUrl` method is called, the native *Phone* app will be executed
    and start calling the number immediately. Note that the `tel:` prefix is needed
    to initiate the call.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`OpenUrl`方法时，原生的*Phone*应用将被执行并立即开始拨打电话。请注意，需要`tel:`前缀来发起通话。
- en: There's more...
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Xamarin.iOS also supports the CoreTelephony Framework through the `MonoTouch.CoreTelephony`
    namespace. This is a simple framework that provides information on call state,
    connection, carrier information, and so on. Note that when a call starts, the
    native *Phone* app enters into the foreground, causing the app to be suspended.
    A simple usage of the CoreTelephony Framework is as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin.iOS还通过`MonoTouch.CoreTelephony`命名空间支持CoreTelephony框架。这是一个简单的框架，它提供了有关呼叫状态、连接、运营商信息等方面的信息。请注意，当电话开始时，原生的*Phone*应用进入前台，导致应用挂起。CoreTelephony框架的简单用法如下：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that the handler is assigned with an equals sign (=) instead of the common
    plus-equals (+=) combination. This is because `CallEventHandler` is a property
    and not an event. When the app enters into the background, events are not distributed
    to it. The event that occurred last, however, will be distributed when the app
    returns to the foreground.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，处理程序是用等号（=）而不是常见的加等于（+=）组合分配的。这是因为`CallEventHandler`是一个属性，而不是一个事件。当应用进入后台时，事件不会分配给它。然而，当应用返回前台时，最后发生的事件将被分配。
- en: More information on OpenUrl
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于OpenUrl的更多信息
- en: 'The `OpenUrl` method can be used to open various native and non-native applications.
    For example, to open a web page in Safari, just create an `NSUrl` object with
    the link, as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`OpenUrl`方法可以用来打开各种原生和非原生应用程序。例如，要在Safari中打开网页，只需创建一个包含链接的`NSUrl`对象，如下所示：'
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: See also
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Sending text messages and e-mails* recipe
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发送短信和电子邮件**菜谱'
- en: Sending text messages and e-mails
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送短信和电子邮件
- en: In this recipe, we will learn how to invoke the native *Mail* and *Messaging*
    apps within our own app.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何在我们的应用程序中调用原生的*Mail*和*Messaging*应用。
- en: Getting ready
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **Single View Application** in Xamarin Studio and name it `SendTextApp`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin Studio中创建一个新的**单视图应用程序**，并将其命名为`SendTextApp`。
- en: How to do it...
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to invoke the apps:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以调用应用程序：
- en: Add two buttons on the view of `SendTextAppViewController`.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SendTextAppViewController`的视图中添加两个按钮。
- en: 'Add the following code in the `ViewDidLoad` method:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ViewDidLoad`方法中添加以下代码：
- en: '[PRE5]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Compile and run the app on the device. Click on one of the buttons to open the
    corresponding app.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备上编译并运行应用程序。点击其中一个按钮以打开相应的应用程序。
- en: How it works...
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: 'Once again, using the `OpenUrl` method, we can send text or e-mail messages.
    Just using the `sms:` prefix from the preceding example code will open the native
    text messaging app, as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用`OpenUrl`方法，我们可以发送文本或电子邮件消息。只需使用前面示例代码中的`sms:`前缀即可打开原生的文本消息应用，如下所示：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Adding a cell phone number after the `sms:` prefix will open the native *Messaging*
    app, as shown in the following screenshot:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在`sms:`前缀后添加手机号码将打开原生的*Messaging*应用，如下面的屏幕截图所示：
- en: '![How it works...](img/8924OT_08_02.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/8924OT_08_02.jpg)'
- en: 'For opening the native e-mail app, the process is similar. Pass the `mailto:`
    prefix, as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于打开原生的电子邮件应用，过程类似。传递`mailto:`前缀，如下所示：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This opens the edit mail controller, as shown in the following screenshot:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开编辑邮件控制器，如下面的屏幕截图所示：
- en: '![How it works...](img/8924OT_08_03.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/8924OT_08_03.jpg)'
- en: 'The `mailto:` URL scheme supports various parameters for customizing an e-mail
    message. These parameters allow us to enter the sender address, subject, and message,
    as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`mailto:` URL方案支持各种参数以自定义电子邮件消息。这些参数允许我们输入发件人地址、主题和消息，如下所示：'
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There's more...
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Although iOS provides access to opening the native *Messaging* apps, predefining
    message content in the case of e-mails is where the control from inside the app
    stops. There is no way of actually sending the message through code. It is the
    user that will decide whether to send the message or not.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然iOS提供了打开原生*Messaging*应用的访问权限，但在电子邮件的情况下，在应用内部预定义消息内容是控制停止的地方。实际上，没有通过代码发送消息的方法。是否发送消息将由用户决定。
- en: More information on opening external apps
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于打开外部应用的更多信息
- en: The `OpenUrl` method provides an interface for opening external apps. Opening
    external apps has one drawback, that is, the app that calls the `OpenUrl` method
    transitions to the background. Up to iOS Version 3.*, this was the only way of
    messaging through an application. Since iOS Version 4.0, Apple has provided the
    messaging controllers to the SDK. The following recipes discuss their usage.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`OpenUrl`方法提供了一个打开外部应用程序的接口。打开外部应用程序有一个缺点，那就是调用`OpenUrl`方法的app会切换到后台。在iOS版本3.*之前，这是通过应用程序进行消息传递的唯一方式。自iOS版本4.0以来，苹果向SDK提供了消息控制器。以下食谱讨论了它们的用法。'
- en: See also
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Starting phone calls* and *Using text messaging in our application* recipes
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开始电话通话**和**在我们的应用程序中使用短信**的食谱'
- en: Using text messaging in our application
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的应用程序中使用短信
- en: In this recipe, we will learn how to display the text messaging controller inside
    our app.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习如何在我们的应用程序中显示短信控制器。
- en: Getting ready
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **Single View Application** in Xamarin Studio and name it `TextMessageApp`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin Studio中创建一个新的**单视图应用程序**，并将其命名为`TextMessageApp`。
- en: How to do it...
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to display the text messaging controller in our
    app:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以在我们的应用程序中显示短信控制器：
- en: Add a button on the view of the controller.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制器的视图中添加一个按钮。
- en: 'Enter the following `using` directive in the `TextMessageAppViewController`
    file:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`TextMessageAppViewController`文件中输入以下`using`指令：
- en: '[PRE9]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Implement the `ViewDidLoad` method with the following code, changing the recipient
    number and/or the message body at your discretion:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码实现`ViewDidLoad`方法，根据您的意愿更改收件人号码和/或消息正文：
- en: '[PRE10]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the following method:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下方法：
- en: '[PRE11]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Compile and run the app on the device. Tap the **Send message** button to open
    the message controller. Tap the **Send** button to send the message, or on the
    **Cancel** button to return to the app.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备上编译并运行应用程序。点击**发送消息**按钮以打开消息控制器。点击**发送**按钮发送消息，或点击**取消**按钮返回应用程序。
- en: How it works...
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `MonoTouch.MessageUI` namespace contains the necessary UI elements that
    allow us to implement messaging in an iOS app. For text messaging (SMS), we need
    the `MFMessageComposeViewController` class.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`MonoTouch.MessageUI`命名空间包含实现iOS应用程序中消息传递所需的UI元素。对于短信（SMS），我们需要`MFMessageComposeViewController`类。'
- en: We need to check for texting availability, because not all devices can send
    text messages. The `MFMessageComposeViewController` class contains a static method
    named `CanSendText`, which returns a boolean value indicating whether we can use
    this functionality. The important thing in this case is that we check if the functionality
    of sending text messages is available prior to initializing the controller. This
    is because when you try to initialize the controller on a device that does not
    support text messaging or on the simulator, you will get an exception.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要检查短信可用性，因为并非所有设备都能发送短信。`MFMessageComposeViewController`类包含一个名为`CanSendText`的静态方法，它返回一个布尔值，表示我们是否可以使用此功能。在这种情况下，重要的是在初始化控制器之前检查发送短信功能是否可用。这是因为当你尝试在不支持短信或模拟器上的设备上初始化控制器时，你会得到一个异常。
- en: 'To determine when the user has taken action in the message UI, we subscribe
    to the `Finished` event, as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定用户在消息UI中何时采取了行动，我们订阅了`Finished`事件，如下所示：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Inside the `Finished` method, we can provide functionality according to the
    `MessageComposeResult` parameter. It can have one of the following three values:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Finished`方法内部，我们可以根据`MessageComposeResult`参数提供相应的功能。它可能有以下三个值之一：
- en: 'Sent: This means the message was sent successfully.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已发送：这意味着消息已成功发送。
- en: 'Cancelled: This means the user has tapped the **Cancel** button. The message
    will not be sent.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已取消：这意味着用户点击了**取消**按钮。消息将不会发送。
- en: 'Failed: This means the message sending failed.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 失败：这意味着消息发送失败。
- en: 'The last thing to do is unsubscribe the event and dismiss the message controller,
    as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件要做的事情是取消订阅事件并关闭消息控制器，如下所示：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After initializing the controller, we can set the recipients and body message
    to the appropriate properties, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化控制器之后，我们可以将收件人和正文消息设置为适当的属性，如下所示：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `Recipients` property accepts a `string` array that allows multiple recipient
    numbers.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`Recipients`属性接受一个`string`数组，允许多个收件人号码。'
- en: There's more...
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The fact that SDK allows the user interface to send text messages does not mean
    that it is customizable. Just like invoking the native *Messaging* app, it is
    the user who will decide whether to send the message or discard it. In fact, after
    the controller is presented on the screen, any attempts to change the actual object
    or any of its properties will simply fail. Furthermore, the user can change or
    delete both the recipients and the message body. The real benefit, though, is
    that the messaging user interface is displayed within our app instead of running
    separately.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: SDK允许用户界面发送文本消息的事实并不意味着它是可定制的。就像调用原生*Messaging*应用一样，是否发送消息或丢弃消息的决定权在用户手中。实际上，在控制器显示在屏幕上之后，任何尝试更改实际对象或其任何属性的操作都将失败。此外，用户可以更改或删除收件人和消息正文。真正的优势在于，消息用户界面是在我们的应用内部显示，而不是单独运行。
- en: Attachments
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 附件
- en: 'Starting with iOS 7, the `MFMessageComposeViewController` class supports attachments.
    We can attach a file to a message through the `AddAttachment` method, as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 从iOS 7开始，`MFMessageComposeViewController`类支持附件。我们可以通过`AddAttachment`方法将文件附加到消息中，如下所示：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The second parameter is the string that will appear as a filename on the UI.
    If null is passed, the actual filename will appear.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是将在UI中显示的字符串，作为文件名。如果传递null，则将显示实际文件名。
- en: Using e-mail messaging in our application
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的应用中使用电子邮件消息
- en: In this recipe, we will learn how to use the e-mail messaging interface within
    an application.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何在应用中使用电子邮件消息界面。
- en: Getting ready
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **Single View Application** in Xamarin Studio and name it `EmailMessageApp`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin Studio中创建一个新的**单视图应用程序**，并将其命名为`EmailMessageApp`。
- en: How to do it...
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Add a button on the view of `EmailMessageAppViewController` and the `MonoTouch.MessageUI`
    namespace in the `EmailMessageAppViewController.cs` file.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`EmailMessageAppViewController`的视图中添加一个按钮，并在`EmailMessageAppViewController.cs`文件中添加`MonoTouch.MessageUI`命名空间。
- en: 'Enter the following code in the `ViewDidLoad` method:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ViewDidLoad`方法中输入以下代码：
- en: '[PRE16]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add the following method:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下方法：
- en: '[PRE17]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Compile and run the app either on the simulator or on the device. Click on the
    **Send email** button to display the mail user interface.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器或设备上编译并运行应用。点击**发送电子邮件**按钮以显示邮件用户界面。
- en: Send or cancel the message. The app will work on the simulator and behave just
    like the native *Mail* app on devices, except for the fact that messages will
    not actually be sent or saved.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 发送或取消消息。该应用将在模拟器上运行，并且与设备上的原生*Mail*应用行为相同，只是消息实际上不会发送或保存。
- en: How it works...
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: 'The `MFMailComposeViewController` class provides the native mail composing
    interface. To determine whether the device is capable of sending e-mails, we first
    check its `CanSendMail` property, as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`MFMailComposeViewController`类提供了原生邮件编写界面。为了确定设备是否能够发送电子邮件，我们首先检查其`CanSendMail`属性，如下所示：'
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Just like we did with the `MFMessageComposeViewController` class, we subscribe
    to the `Finished` event of the `MFMailComposeViewController` class. We use this
    event to respond to user actions, without having to implement a `Delegate` object.
    We do this inside the `MailController_Finished` method based on the `MFComposeResultEventArgs.Result`
    property, which is of the `MFMailComposeResult` type. The possible values of the
    `MFMailComposeResult` enumeration will be one of the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们对`MFMessageComposeViewController`类所做的那样，我们订阅了`MFMailComposeViewController`类的`Finished`事件。我们使用此事件来响应用户操作，而无需实现`Delegate`对象。我们根据`MFComposeResultEventArgs.Result`属性在`MailController_Finished`方法中这样做，该属性是`MFMailComposeResult`类型。`MFMailComposeResult`枚举的可能值将如下所示：
- en: 'Sent: This means the e-mail message is queued for sending.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已发送：这意味着电子邮件消息已排队待发送。
- en: 'Saved: This means the user clicked on the **Cancel** button, and the **Save
    Draft** option of the action sheet automatically appears. The following screenshot
    shows the action sheet that appears when the user clicks on the **Cancel** button:![How
    it works...](img/8924OT_08_04.jpg)'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已保存：这意味着用户点击了**取消**按钮，操作表的**保存草稿**选项自动出现。以下截图显示了用户点击**取消**按钮时出现的操作表：![如何工作...](img/8924OT_08_04.jpg)
- en: 'Cancelled: This means the user clicked on the **Cancel** button on the controller
    and selected the **Delete Draft** option on the action sheet.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已取消：这意味着用户在控制器上点击了**取消**按钮，并在操作表中选择了**删除草稿**选项。
- en: 'Failed: This means the e-mail message sending failed.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 失败：这意味着电子邮件消息发送失败。
- en: 'After initializing the object, we can assign a recipient list, subject, and
    message body through the corresponding set of the `Set` prefixed methods, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化对象之后，我们可以通过相应的 `Set` 前缀方法集分配收件人列表、主题和消息正文，如下所示：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If the second parameter of the `SetMessageBody` message is set to `true`, it
    informs the controller that the message should be treated as HTML.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `SetMessageBody` 消息的第二个参数设置为 `true`，它通知控制器该消息应被视为 HTML。
- en: There's more...
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Apart from simple or HTML formatted text, we can also send attachments. We
    can do this with the `AddAttachmentData` method using the following line of code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 除了简单的或 HTML 格式的文本之外，我们还可以发送附件。我们可以使用 `AddAttachmentData` 方法通过以下代码行来实现：
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The first parameter is of the `NSData` type and is the actual content of the
    attachment. In this case, we attach an image through the `UIImage.AsJPEG()` method,
    which returns the image contents inside an `NSData` object. The second parameter
    represents the **Multipurpose Internet Mail Extensions** (**MIME**) type of the
    attachment, and the third parameter represents its filename that will be shown
    to the user.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是 `NSData` 类型，是附件的实际内容。在这种情况下，我们通过 `UIImage.AsJPEG()` 方法附加一个图片，该方法返回一个包含在
    `NSData` 对象中的图片内容。第二个参数代表附件的 **Multipurpose Internet Mail Extensions** (**MIME**)
    类型，第三个参数代表将显示给用户的文件名。
- en: See also
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using text messaging in our application* recipe
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在我们的应用程序中使用文本消息* 菜谱'
- en: Managing the address book
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理地址簿
- en: In this recipe, we will discuss how to access and manage the user's stored contacts
    in the device's address book.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将讨论如何访问和管理设备地址簿中存储的用户联系人。
- en: Getting ready
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **Single View Application** in Xamarin Studio and name it `AddressBookApp`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xamarin Studio 中创建一个新的 **Single View Application** 并将其命名为 `AddressBookApp`。
- en: How to do it...
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Add a button on the view of the controller.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制器的视图中添加一个按钮。
- en: 'Enter the following `using` directive in the `AddressBookAppViewController.cs`
    file:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `AddressBookAppViewController.cs` 文件中输入以下 `using` 指令：
- en: '[PRE21]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Override the `ViewDidLoad` method:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写 `ViewDidLoad` 方法：
- en: '[PRE22]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add the following method:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下方法：
- en: '[PRE23]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Compile and run the app on the simulator. Click on the **Get contacts** button
    and either accept or deny access to the address book. The following screenshot
    displays the alert that appears when we request access to the address book:![How
    to do it...](img/8924OT_08_05.jpg)
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。点击 **获取联系人** 按钮并接受或拒绝访问地址簿。以下截图显示了当我们请求访问地址簿时出现的警报：![如何做...](img/8924OT_08_05.jpg)
- en: Note
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The simulator's address book contains some fake contacts that we can work with.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟器的地址簿包含一些我们可以使用的虚假联系人。
- en: How it works...
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `MonoTouch.AddressBook` namespace contains all the classes that allow us
    to manage the device''s address book. To access the address book, we first need
    to check if the user has previously granted address book access to our app and
    instantiate an `ABAddressBook` instance, as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`MonoTouch.AddressBook` 命名空间包含所有允许我们管理设备地址簿的类。要访问地址簿，我们首先需要检查用户是否以前已授予我们的应用程序地址簿访问权限，并实例化一个
    `ABAddressBook` 实例，如下所示：'
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If the status is `NotDermined`, we call the `RequestAccess` method, which accepts
    an `Action<bool, NSError>` delegate, as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果状态是 `NotDermined`，我们调用 `RequestAccess` 方法，该方法接受一个 `Action<bool, NSError>`
    委托，如下所示：
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `bool` parameter informs us if the user has granted access. If it is `true`,
    we call the `ReadContacts` method so that we proceed with reading the address
    book information we want. Note that we wrap the call of the `ReadContacts` method
    with an `InvokeOnMainThread` call, although it is not accessing the UI. This is
    because the `RequestAccess` method is called on a separate thread.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`bool` 参数告诉我们用户是否已授予访问权限。如果它是 `true`，我们就调用 `ReadContacts` 方法，以便我们继续读取我们想要的地址簿信息。注意，我们用
    `InvokeOnMainThread` 调用包装了 `ReadContacts` 方法的调用，尽管它没有访问 UI。这是因为 `RequestAccess`
    方法是在一个单独的线程上被调用的。'
- en: Note
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can access the address book from other threads other than the main one; however,
    every instance of `ABAddressBook` needs to be used on the same thread.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从除了主线程之外的其他线程访问地址簿；然而，每个 `ABAddressBook` 实例都需要在同一个线程上使用。
- en: 'Inside the `ReadContacts` method, we enumerate the individual contact through
    the `GetPeople` method, as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ReadContacts` 方法内部，我们通过 `GetPeople` 方法枚举单个联系人，如下所示：
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `ABPerson` class contains the contact information we want.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`ABPerson` 类包含我们想要的联系人信息。'
- en: There's more...
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'To get a contact''s stored phone number(s), call the `GetPhones()` method,
    as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取联系人的存储电话号码（s），请调用`GetPhones()`方法，如下所示：
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: It returns an object of the `ABMultiValue<string>` type. `ABMultiValue<T>` is
    a generic collection, especially designed for multiple address book values.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回一个`ABMultiValue<string>`类型的对象。`ABMultiValue<T>`是一个泛型集合，特别设计用于多个地址簿值。
- en: Adding a phone number to a contact
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将电话号码添加到联系人
- en: 'To add a phone number to a contact, we can use the `ABPerson` class'' `SetPhones`
    method. It accepts an `ABMultiValue<string>` object as its parameter, but we cannot
    add new values to the `ABMultiValue` objects. We can, however, write values to
    an `ABMutableMultiValue<T>` object, as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要将电话号码添加到联系人中，我们可以使用`ABPerson`类的`SetPhones`方法。它接受一个`ABMultiValue<string>`对象作为其参数，但我们不能向`ABMultiValue`对象中添加新值。然而，我们可以将值写入一个`ABMutableMultiValue<T>`对象，如下所示：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This line of code creates a new instance of the `ABMutableMultiValue<string>`
    object, which we then use to add the phone number(s) we want, as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码创建了一个新的`ABMutableMultiValue<string>`对象实例，然后我们使用它来添加我们想要的电话号码（s），如下所示：
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The second parameter of the `Add` method is the label that the phone number
    will have when it is saved to the contact. It is important to call the `ABAddressBook.Save()`
    method, or else, the changes will not be saved.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`Add`方法的第二个参数是电话号码在保存到联系人时将拥有的标签。调用`ABAddressBook.Save()`方法非常重要，否则，更改将不会保存。'
- en: Displaying contacts
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示联系人
- en: In this recipe, we will learn how to use the native address book user interface
    to display contact information.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何使用原生地址簿用户界面来显示联系人信息。
- en: Getting ready
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **Single View Application** in Xamarin Studio and name it `DisplayContactApp`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin Studio中创建一个新的**单视图应用程序**，并将其命名为`DisplayContactApp`。
- en: How to do it...
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Add a button on the controller.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制器上添加一个按钮。
- en: 'In the `AppDelegate.cs` file, add the `DisplayContactAppViewController` to
    a navigation controller, as follows:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AppDelegate.cs`文件中，将`DisplayContactAppViewController`添加到导航控制器中，如下所示：
- en: '[PRE30]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Add the following namespaces in the `DisplayContactAppViewController.cs` file:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DisplayContactAppViewController.cs`文件中添加以下命名空间：
- en: '[PRE31]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Add the following code in the `ViewDidLoad` method:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ViewDidLoad`方法中添加以下代码：
- en: '[PRE32]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Add the following method:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下方法：
- en: '[PRE33]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Compile and run the application on the simulator. Tap the button to show the
    contact card screen. The result should be similar to the following screenshot:![How
    to do it...](img/8924OT_08_06.jpg)
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。点击按钮以显示联系人卡片屏幕。结果应类似于以下截图：![如何操作...](img/8924OT_08_06.jpg)
- en: How it works...
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `MonoTouch.AddressBookUI` namespace contains the controllers that the native
    *Contacts* app uses to allow the user to display and manage contacts. Each contact's
    details can be viewed with `ABPersonViewController`. This controller must be pushed
    to `UINavigationController`, or else it will not display correctly.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`MonoTouch.AddressBookUI`命名空间包含原生*联系人*应用程序使用的控制器，允许用户显示和管理联系人。每个联系人的详细信息都可以使用`ABPersonViewController`查看。此控制器必须推送到`UINavigationController`，否则它将无法正确显示。'
- en: 'After initializing it, we set the `ABPerson` object, which we want to be displayed,
    to its `DisplayedPerson` property, as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化后，我们将要显示的`ABPerson`对象设置为它的`DisplayedPerson`属性，如下所示：
- en: '[PRE34]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, we push it to the navigation controller''s stack using the following
    line of code:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用以下代码将其推送到导航控制器的堆栈中：
- en: '[PRE35]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: There's more...
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'The `ABPersonViewController` class can also be used for editing. To do this,
    set the `AllowsEditing` property to `true`, as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`ABPersonViewController`类也可以用于编辑。为此，将`AllowsEditing`属性设置为`true`，如下所示：'
- en: '[PRE36]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note that the changes are saved normally through the `ABPersonViewController`
    class.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，更改通过`ABPersonViewController`类正常保存。
- en: Other address book controllers
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他地址簿控制器
- en: 'The `MonoTouch.AddressBookUI` namespace contains all the controllers we need
    to create our own custom contacts application, as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`MonoTouch.AddressBookUI`命名空间包含我们创建自定义联系人应用程序所需的所有控制器，如下所示：'
- en: '`ABPeoplePickerNavigationController`: This is a navigation controller that
    displays the saved contacts. The user can select a contact from the list.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ABPeoplePickerNavigationController`：这是一个显示已保存联系人的导航控制器。用户可以从列表中选择一个联系人。'
- en: '`ABPersonViewController`: This is described in the example given in this recipe.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ABPersonViewController`：这在本食谱给出的示例中有描述。'
- en: '`ABNewPersonViewController`: This is the controller that creates a new contact.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ABNewPersonViewController`：这是创建新联系人的控制器。'
- en: '`ABUnknownPersonViewController`: This is the controller that is displayed with
    partial data for creating a new contact. This is similar to the controller that
    is displayed when we tap on an unknown number in the list of recent calls on the
    device.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ABUnknownPersonViewController`：这是用于创建新联系人的部分数据显示的控制器。这与我们在设备上最近通话列表中点击未知号码时显示的控制器类似。'
- en: See also
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: The *Managing the address book* recipe
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*管理通讯录* 菜谱'
- en: Managing the calendar
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理日历
- en: In this recipe, we will learn how create an event and save it to the device's
    calendar database.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何创建一个事件并将其保存到设备的日历数据库中。
- en: Getting ready
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **Single View Application** in Xamarin Studio and name it `CalendarEventsApp`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xamarin Studio 中创建一个新的 **Single View Application** 并将其命名为 `CalendarEventsApp`。
- en: The app we will be creating will output the calendar events of the next 30 days.
    Make sure you have some calendar events in that period.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要创建的应用程序将输出未来 30 天的日历事件。请确保在该时间段内有日历事件。
- en: How to do it...
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Let''s create an event and save it to the device''s calendar database by performing
    the following steps:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤创建一个事件并将其保存到设备的日历数据库中：
- en: Add a button on the main view of the controller.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制器的主视图中添加一个按钮。
- en: Add the `MonoTouch.EventKit` namespace in the `CalendarEventAppViewController.cs`
    file.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `CalendarEventAppViewController.cs` 文件中添加 `MonoTouch.EventKit` 命名空间。
- en: 'Enter the following code in the `ViewDidLoad` method:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ViewDidLoad` 方法中输入以下代码：
- en: '[PRE37]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Add the following method:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下方法：
- en: '[PRE38]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Compile and run the app on the device. Click on the **Display events** button
    to output the calendar events of the next 30 days in the **Application Output**
    pad.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备上编译并运行应用程序。点击 **Display events** 按钮以在 **Application Output** 面板中输出未来 30 天的日历事件。
- en: How it works...
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `MonoTouch.EventKit` namespace is responsible for managing the calendar
    events. To read the stored events, we first check if we have access to the calendar
    and initialize an `EKEventStore` object, as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`MonoTouch.EventKit` 命名空间负责管理日历事件。为了读取存储的事件，我们首先检查我们是否有访问日历的权限，并初始化一个 `EKEventStore`
    对象，如下所示：'
- en: '[PRE39]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If the authorization status is `NotDetermined`, we call the `RequestAccessAsync`
    method so that the user is prompted for access, as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果授权状态是 `NotDetermined`，我们调用 `RequestAccessAsync` 方法，以便用户被提示进行访问，如下所示：
- en: '[PRE40]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If the result is `true`, it means that the user has granted calendar access
    to our app. Now, we call the `DisplayEvents` method to read and output the events.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果结果是 `true`，这意味着用户已授予我们的应用程序日历访问权限。现在，我们调用 `DisplayEvents` 方法来读取和输出事件。
- en: 'The `EKEventStore` class provides us access to the stored events. To retrieve
    the calendar events, we need a predicate of the `NSPredicate` type. We can create
    an instance through the `PredicateForEvents` method of the `EKEventStore` class
    using the following code snippet:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`EKEventStore` 类为我们提供了访问已存储事件的方法。要检索日历事件，我们需要一个 `NSPredicate` 类型的谓词。我们可以通过
    `EKEventStore` 类的 `PredicateForEvents` 方法创建一个实例，如下面的代码片段所示：'
- en: '[PRE41]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The first two parameters are of the `NSDate` type (which can be implicitly converted
    to `DateTime`) and represent the start and end dates for which to search events.
    The third parameter is of the `EKCalendar[]`type, and is an array of the calendars
    to search. To search all the available calendars, we pass the return value of
    the `GetCalendars` method.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个参数是 `NSDate` 类型（可以隐式转换为 `DateTime`），代表要搜索事件的开始和结束日期。第三个参数是 `EKCalendar[]`
    类型，代表要搜索的日历数组。要搜索所有可用的日历，我们传递 `GetCalendars` 方法的返回值。
- en: 'Finally, we call the `EnumerateEvents` method using the following line of code:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用以下代码行调用 `EnumerateEvents` 方法：
- en: '[PRE42]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We pass the predicate we created earlier to the first parameter. The second
    parameter is a delegate of the `EKEventSearchCallback` type. To read each event's
    data, we use its `EKEvent` object. Note that the process of enumerating calendar
    events is similar to the one that is used for enumerating assets from the assets
    library, discussed in the previous chapter. This means that if the `EKEvent` object
    is not null, we must explicitly set the `stop` parameter to `false` so that the
    `EKEventStore` class continues enumerating the calendar events.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将之前创建的谓词传递给第一个参数。第二个参数是 `EKEventSearchCallback` 类型的委托。为了读取每个事件的数据，我们使用其 `EKEvent`
    对象。请注意，枚举日历事件的过程与上一章中讨论的从资源库枚举资源的过程类似。这意味着如果 `EKEvent` 对象不为空，我们必须显式地将 `stop` 参数设置为
    `false`，以便 `EKEventStore` 类继续枚举日历事件。
- en: There's more...
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Except from enumerating events, the `EKEventStore` class also allows us to
    create new events. The following example creates and saves a new calendar event:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 除了枚举事件之外，`EKEventStore` 类还允许我们创建新事件。以下示例创建并保存了一个新的日历事件：
- en: '[PRE43]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: For creating a new `EKEvent` instance, we use the `EKEvent.FromStore` static
    method. We then set the start and end dates, a title, and the calendar to which
    the event will be stored. Here, we use the default calendar that we can get with
    the `DefaultCalendarForNewEvents` property of `EKEventStore`. When we have everything
    set up, we call the `SaveEvent` method to save it.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个新的 `EKEvent` 实例，我们使用 `EKEvent.FromStore` 静态方法。然后我们设置开始和结束日期、标题以及事件将要存储的日历。在这里，我们使用默认的日历，我们可以通过
    `EKEventStore` 的 `DefaultCalendarForNewEvents` 属性来获取。当我们设置好一切后，我们调用 `SaveEvent`
    方法来保存它。
- en: Reminders
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提醒事项
- en: You may have noticed the usage of the `EKEntityType` enumeration. This defines
    the entity type we want to have access to. Other than `Event`, which refers to
    the calendar events, we can also use the `Reminder` value so that we can work
    with the tasks the user has in the *Reminders* app.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了 `EKEntityType` 枚举的使用。这定义了我们想要访问的实体类型。除了 `Event`，它指的是日历事件之外，我们还可以使用
    `Reminder` 值，这样我们就可以与用户在 *提醒事项* 应用中的任务一起工作了。
- en: We need to explicitly ask for the **Reminders** permission, even if the user
    has already granted access to the calendar.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 即使用户已经授予了对日历的访问权限，我们也需要明确请求 **提醒事项** 权限。
- en: See also
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Managing album items directly* recipe in [Chapter 7](ch07.html "Chapter 7. Multimedia
    Resources"), *Multimedia Resources*
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 7 章 *多媒体资源* 中，关于 *直接管理相册项目* 的配方，[第 7 章](ch07.html "第 7 章。多媒体资源")
