- en: '*Chapter 19*: Ensuring App Quality with Tests'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第19章*：通过测试确保应用质量'
- en: In all of the chapters so far, the main focus has been code that ran as part
    of an app. The apps you have worked on are small and can easily be tested manually.
    However, this approach doesn't scale well if your apps become larger. This approach
    also doesn't scale if you want to verify lots of different user input, lots of
    screens, convoluted logic, or even if you're going to run tests on many different
    devices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的所有章节中，主要关注的是作为应用一部分运行的代码。你开发的应用程序较小，可以轻松手动测试。然而，如果你的应用程序变得更大，这种方法就不太适用了。如果你想要验证大量的不同用户输入、多个屏幕、复杂的逻辑，或者你打算在许多不同的设备上运行测试，这种方法同样不适用。
- en: Xcode comes with built-in testing tools. These tools allow you to write tests
    so you can make sure that all of the business logic for your app works as expected.
    More importantly, you can test that your user interface functions and behaves
    as intended in many different automated scenarios.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode自带内置的测试工具。这些工具允许你编写测试，以确保你的应用中的所有业务逻辑按预期工作。更重要的是，你可以测试用户界面在许多不同的自动化场景中是否按预期功能和表现。
- en: Many developers tend to shy away from testing and postpone it until the end
    of the project, or don't do it at all. The reason for this is that it's often
    pretty hard to figure out how to write proper tests. This is especially true if
    you're just starting out with testing. Lots of developers feel like large parts
    of the logic their tests validate are so obvious that writing tests for that logic
    just feels silly. When testing is not approached correctly, it can be more of
    a burden than a relief by being high-maintenance and not testing the essential
    areas of code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者倾向于回避测试，直到项目结束时才进行，或者根本不进行测试。原因通常是因为很难想出如何编写合适的测试。如果你刚开始接触测试，这一点尤其正确。许多开发者觉得他们测试的逻辑中的大部分内容非常明显，为这种逻辑编写测试似乎很荒谬。如果测试方法不正确，它可能会成为负担而不是解脱，因为维护成本高且没有测试代码的关键区域。
- en: 'This chapter serves as an introduction to writing both logic and user interface
    tests using Xcode and its built-in tools. By the end of this chapter, you should
    be able to set up a robust suite of tests and understand how you can make use
    of the tools provided by Xcode to write better code that is testable and reliable.
    This chapter covers the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章作为使用Xcode及其内置工具编写逻辑和用户界面测试的介绍。到本章结束时，你应该能够设置一个健壮的测试套件，并了解如何利用Xcode提供的工具编写可测试且可靠的代码。本章涵盖了以下主题：
- en: Testing logic with XCTest
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用XCTest测试逻辑
- en: Optimizing code for testability
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化代码以进行测试
- en: Testing the user interface with XCUITest
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用XCUITest测试用户界面
- en: Testing logic with XCTest
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用XCTest测试逻辑
- en: This section is going to help you to discover the testing capabilities on iOS
    with `XCTest`. Even if you haven't written any tests before, you might have thoughts
    or ideas about it. To start testing code, you don't need to have a computer science
    degree or spend days studying the absolute best way to test your code. In fact,
    the chances are that you're already testing your code and you don't even know
    it.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将帮助你发现iOS上`XCTest`的测试能力。即使你之前没有编写过任何测试，你可能也有自己的想法或想法。要开始测试代码，你不需要拥有计算机科学学位或花费几天时间学习测试代码的绝对最佳方法。实际上，你很可能已经在测试你的代码，而你甚至不知道这一点。
- en: So, what does it mean to test your code? That's what this section aims to make
    clear. First, you will read about the different types of tests you can write.
    Then, you'll learn what `XCTest` is and how you can set up a test suite for an
    app. Finally, you'll learn how to optimally test some actual code and how code
    can be refactored to make it more testable.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，测试代码究竟意味着什么呢？本节旨在阐明这一点。首先，你将了解你可以编写的不同类型的测试。然后，你将学习`XCTest`是什么以及如何为应用设置测试套件。最后，你将学习如何最优地测试实际代码，以及代码如何重构以使其更易于测试。
- en: Understanding what it means to test code
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解测试代码的含义
- en: When you test your code, you're essentially making sure that certain input produces
    the desired output. A very basic example of a test would be to make sure that
    calling a method that increments its input by a given value produces the output
    you expect.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当你测试代码时，你实际上是在确保某些输入产生预期的输出。一个非常基础的测试例子就是确保调用一个将输入增加给定值的函数会产生你预期的输出。
- en: Any time you launch your application and perform any action within your app,
    you are testing some part of your code. Any time you print something to the console
    to verify that the expected value is printed, you are also testing your code.
    Once you think about testing this way, a concept that might have sounded hard
    before actually does not seem as complicated as you may have thought. So, if just
    by using your app, you are indeed testing it already, then, what should you write
    tests for? Let's see how to determine when to write a test for your code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你启动你的应用程序并在其中执行任何操作时，你实际上都在测试你的代码的某个部分。每次你向控制台打印某些内容以验证预期的值被打印出来时，你也在测试你的代码。一旦你这样思考测试，之前可能听起来很困难的概念实际上并不像你可能认为的那么复杂。所以，如果你只是通过使用你的应用程序，实际上已经在测试它了，那么，你应该为哪些内容编写测试呢？让我们看看如何确定何时为你的代码编写测试。
- en: Determining which tests to write
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确定要编写哪些测试
- en: When you start testing, it's often hard to decide what logic you want to test
    and what logic you don't want to test. Reasons for this could include certain
    logic being too trivial, too hard, or just not important enough to test. This
    statement implies that you do not have to test absolutely every line of code in
    your app, and that is intentional. Sometimes it's simply not reasonable to write
    tests for a certain part of your code. For instance, you don't have to test that
    `UIKit` behaves as it should; it's Apple's job to make sure that the frameworks
    they ship are bug-free.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始测试时，通常很难决定你想要测试哪些逻辑，不想要测试哪些逻辑。造成这种情况的原因可能包括某些逻辑过于简单、过于复杂，或者不够重要以至于不值得测试。这个陈述意味着你不需要测试应用程序中的每一行代码，这是故意的。有时为代码的某个部分编写测试是不合理的。例如，你不需要测试`UIKit`是否按预期工作；确保他们发布的框架没有错误是苹果的工作。
- en: Determining what to test is important, and the longer you defer deciding whether
    you will add tests for a particular piece of logic, the harder it will be to write
    tests for it. A simple rule of thumb is that you don't need to test Apple's frameworks.
    It's safe to assume that Apple makes sure that any code they ship is tested and
    if it contains bugs, there's not much you can do to fix it anyway. Moreover, you
    don't want your tests to fail where Apple's tests should have failed.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 确定要测试的内容很重要，而且你推迟决定是否为特定逻辑添加测试的时间越长，编写测试就越困难。一个简单的经验法则是你不需要测试苹果的框架。可以安全地假设苹果会确保他们发布的任何代码都经过测试，而且如果其中包含错误，你实际上也无法做太多来修复它。此外，你不想让你的测试在苹果的测试应该失败的地方失败。
- en: What you should at least test is the *call site* of your methods, structs, and
    classes. You can think of the call site as the methods that other objects use
    to perform tasks. It's a good practice to make anything that's not used by the
    call site of your objects private, meaning that outside code can't access that
    part of the code. We'll cover more on this later when you learn more about refactoring
    code to make it more testable.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你至少应该测试的是你的方法、结构和类的*调用点*。你可以将调用点视为其他对象用来执行任务的那些方法。将任何未被调用点使用的对象部分设为私有是一个好的实践，这意味着外部代码无法访问这部分代码。我们将在你学习更多关于重构代码以提高可测试性时再详细讨论这一点。
- en: You should also test code that you might consider too trivial to write tests
    for. These parts of your code are likely to receive the *too trivial* treatment
    in other parts of the development process too. This usually causes you and your
    coworkers to pay less and less attention to this trivial piece of code, and before
    you know it, a bug gets introduced that might not be spotted until the app is
    in the App Store. Writing trivial tests for trivial code takes very little time
    and saves you from minor oversights that could lead to massive complications.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该测试那些你可能认为太简单而不值得编写测试的代码。这些代码部分在开发过程的其它部分也可能被忽视。这通常会导致你和你的同事越来越不重视这些简单的代码片段，而当你意识到这一点时，可能已经引入了可能直到应用在App
    Store中才会被发现的错误。为简单的代码编写简单的测试几乎不需要时间，并且可以防止可能导致重大复杂性的小疏忽。
- en: 'A few simple guidelines that you should follow when you write tests are the
    following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写测试时，你应该遵循的一些简单指南如下：
- en: '**Test trivial code**: This usually requires minimal effort.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试简单的代码**：这通常需要最少的努力。'
- en: '**Test the call site of your objects**: These tests will ensure that your public
    APIs are consistent and work as expected.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试你的对象的调用点**：这些测试将确保你的公共API是一致的并且按预期工作。'
- en: '**Don''t test Apple''s frameworks or any other dependencies**: Doing this is
    the responsibility of the framework vendor.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要测试苹果的框架或任何其他依赖项**：做这件事是框架供应商的责任。'
- en: Once you've determined what you should test, it's time to start writing the
    actual tests. However, if you've heard about testing before, you might have heard
    of terms such as integration tests, unit tests, sanity tests, and a couple of
    others. The next segment explains a couple of the most important and well-known
    types of testing.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确定了应该测试什么，就是开始编写实际测试的时候了。然而，如果你之前听说过测试，你可能听说过诸如集成测试、单元测试、健全性测试以及其他几个术语。接下来的部分解释了几个最重要和最知名的测试类型。
- en: Choosing the correct test type
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择正确的测试类型
- en: 'When you write tests, it''s often a good idea to ask yourself what kind of
    test you''re writing. The kind of test you want to write will typically guide
    you toward the way your test should be structured and scoped. Having tests that
    are well-scoped, structured, and focused will ensure that you''re building a stable
    test suite that properly tests your code without unintended side-effects that
    influence the quality of your test. Now let''s dive into the following types of
    tests: unit tests and integration tests.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写测试时，通常一个好的想法是问问自己你正在编写什么类型的测试。你想要编写的测试类型通常会指导你如何构建和范围化你的测试。拥有范围明确、结构化和专注的测试将确保你构建的是一个稳定的测试套件，它能够正确地测试你的代码，而不会产生意外的副作用，这些副作用会影响测试的质量。现在让我们深入了解以下几种测试类型：单元测试和集成测试。
- en: Unit tests
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单元测试
- en: Probably the most well-known type of test is the unit test. A lot of people
    call any other test they write a **unit test**, which is probably why this is
    such a well-known term for testing. Another reason for unit tests being so popular
    is that it's a very sensible test type.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最知名的一种测试类型是单元测试。很多人把写的任何其他测试都称为**单元测试**，这可能是为什么这个术语在测试中如此知名。单元测试之所以如此受欢迎的另一个原因是它是一种非常合理的测试类型。
- en: A unit test is intended to make sure that an isolated object works as expected.
    This isolated object will usually be a class or struct, but it could just as well
    be a standalone method. It's important that unit tests do not rely on any other
    test or object. It's perfectly fine to set up an environment that has all the
    preconditions you need for your unit test, but none of this setup should be accidental.
    For instance, you shouldn't accidentally test other objects or depend on the order
    in which your tests are executed.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的目的是确保一个隔离的对象按预期工作。这个隔离的对象通常是一个类或结构体，但它也可以是一个独立的方法。单元测试不依赖于任何其他测试或对象是很重要的。设置一个包含你单元测试所需所有先决条件的环境是完全可以接受的，但这个设置不应该是不经意的。例如，你不应该不经意地测试其他对象或依赖于测试执行的顺序。
- en: When you write a unit test, it's not uncommon to create instances of models
    that are stored in an array to represent a dummy database or fake REST APIs. Creating
    such a list of dummy data is done to ensure that a unit test does not fail due
    to external factors such as a network error. If your test should depend on certain
    external factors, you are probably writing an **integration test**.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写单元测试时，创建存储在数组中的模型实例以表示模拟数据库或伪造REST API是常见的。创建这样的模拟数据列表是为了确保单元测试不会因为外部因素（如网络错误）而失败。如果你的测试应该依赖于某些外部因素，那么你很可能正在编写一个**集成测试**。
- en: Integration tests
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 集成测试
- en: An integration test ensures that a certain part of your code can integrate with
    other components of the system. Similar to unit tests, an integration test should
    never rely on other tests. This is important for any test you write. Whenever
    a test depends on certain preconditions, they must be set up within the test itself.
    If your test does depend on other tests, this dependency might not be obvious
    at first, but it can make your tests fail in weird and unexpected ways.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试确保你的代码的某个部分可以与其他系统组件集成。与单元测试类似，集成测试不应依赖于其他测试。这对于你编写的任何测试都很重要。每当一个测试依赖于某些先决条件时，它们必须在测试本身内设置。如果你的测试确实依赖于其他测试，这种依赖性可能一开始并不明显，但它可能导致你的测试以奇怪和意想不到的方式失败。
- en: Because no test can depend on another test, integration tests require a little
    more setup than unit tests. For example, you might want to set up an API helper,
    fetch some data from the API, and feed it into a database. A test such as this
    verifies that the API helper can cooperate with the database layer. Both layers
    should have their separate unit tests to ensure they work in isolation while the
    integration test ensures that the database and API can work together. There are
    many other types of tests that you can write or learn about, but for now, integration
    tests and unit tests provide an excellent starting point.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因为没有测试可以依赖于另一个测试，集成测试需要比单元测试更多的设置。例如，你可能需要设置一个API辅助工具，从API获取一些数据，并将其输入到数据库中。这样的测试可以验证API辅助工具能否与数据库层协同工作。这两个层都应该有它们各自的单元测试，以确保它们在独立工作时正常工作，而集成测试确保数据库和API可以协同工作。你可以编写或学习许多其他类型的测试，但就目前而言，集成测试和单元测试提供了一个极好的起点。
- en: Isolating tests
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隔离测试
- en: Assumptions are a considerable risk when you're testing. Any time you assume
    anything about the environment you're testing in, your test is not reliable. If
    you're just getting into writing tests, it's tempting to make assumptions such
    as *I'm testing on the simulator and my test user is always logged in so my tests
    can be written under the assumption that a logged-in user exists*. This assumption
    makes a lot of sense to a lot of people, but what if one of your tests logs the
    current user out?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在你测试时是一个相当大的风险。任何时候你对你正在测试的环境中的任何假设，你的测试都不是可靠的。如果你刚开始编写测试，可能会倾向于做出假设，例如“我正在模拟器上测试，我的测试用户总是登录，因此我的测试可以假设存在一个已登录的用户”。这个假设对很多人来说很有道理，但如果你中的一个测试导致当前用户注销怎么办？
- en: When this happens, a lot of your tests will fail due to assumptions that you
    made about the test environment. More importantly, these tests might fail even
    if the code they're testing works flawlessly.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当这种情况发生时，由于你对测试环境所做的假设，你的一些测试将失败。更重要的是，即使它们正在测试的代码工作得完美无缺，这些测试也可能失败。
- en: As mentioned before, tests should test a single thing in your app. They should
    rely on as little outside code as possible, and they should be properly focused.
    A typical pattern that people use to structure their tests and improve reliability
    is the 3-As or AAA approach. The name of this pattern is short for Arrange, Act,
    and Assert. The following is an explanation of each *A*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，测试应该测试你应用中的单个功能。它们应该尽可能少地依赖外部代码，并且应该有适当的焦点。人们用来结构化测试并提高可靠性的典型模式是3-As或AAA方法。这个模式的名称是“安排（Arrange）”、“行动（Act）”和“断言（Assert）”的缩写。以下是对每个“A”的解释。
- en: Arrange
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安排
- en: The arrange step is all about preparation. Make sure a logged-in user exists,
    populate the (in-memory) database, and create instances of your fake API or other
    helpers. You essentially arrange everything to be in place for your testing environment.
    Note that this step should not involve too much setup. If you find yourself writing
    a lot of code in the arrange step, your test might be too broad. Or the code you're
    testing relies on too many other pieces of code. You can't always avoid this,
    but if it happens, make sure you consider refactoring your code and test to keep
    the quality on par with what you're trying to achieve.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 安排步骤完全是关于准备。确保存在一个已登录的用户，填充（内存中的）数据库，并创建你的模拟API或其他辅助工具的实例。你实际上是为你的测试环境安排好一切。请注意，这一步骤不应涉及太多的设置。如果你发现自己正在安排步骤中编写大量代码，那么你的测试可能太宽泛了。或者，你正在测试的代码依赖于太多的其他代码。你无法总是避免这种情况，但如果发生了，确保你考虑重构你的代码和测试，以保持与你要实现的目标相当的质量。
- en: Act
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 行动
- en: In the act step, you set everything for your test in motion. You call methods
    on the object you're testing, you feed it data, and you manipulate it. This is
    where you take your code for a proverbial spin. Don't perform too many actions
    in succession though; too many actions will lead to problems during the next step,
    assert.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在行动步骤中，你启动你的测试。你调用你要测试的对象上的方法，给它提供数据，并对其进行操作。这是你让你的代码进行比喻性试驾的地方。但是不要连续执行太多操作；太多的操作会在下一个步骤，即断言步骤中导致问题。
- en: Assert
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 断言
- en: The final A in the 3-As approach is assert. During the assert step, you make
    sure that the state of the object you're testing is as you'd expect. Act and assert
    can be used multiple times in a single test. For instance, you might want to assert
    that doing something once places the object in a particular state and that doing
    it again places the object in another state. Or possibly that the state stays
    the same. Just as with the other two steps, if you're asserting a lot of things,
    or if you're acting and asserting over and over again in a test, the chances are
    that your test is too broad. This can't always be avoided, but long tests with
    a lot of acting and asserting are often an indication of testing too much at once.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 3-As 方法中的最后一个 A 是断言。在断言步骤中，你确保你正在测试的对象的状态是你所期望的。在单个测试中，你可以多次使用行动和断言。例如，你可能想断言做一次操作将对象置于特定的状态，而再次做同样的操作将对象置于另一个状态。或者可能是状态保持不变。就像其他两个步骤一样，如果你在断言很多事物，或者如果你在测试中反复行动和断言，那么你的测试可能太宽泛了。这有时是无法避免的，但包含大量行动和断言的长测试通常表明一次测试了太多内容。
- en: Reading about testing can be quite dull, and it tends to get abstract quickly,
    so let's leave the theory for now. You will set up a test suite for an existing
    project in Xcode and start writing some tests, so all of the information you've
    taken in so far becomes a bit more tangible.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读有关测试的内容可能会相当枯燥，而且它往往很快就会变得抽象，所以现在我们先放下理论。你将在 Xcode 中为现有项目设置一个测试套件，并开始编写一些测试，这样你之前所学的所有信息就会变得更加具体。
- en: Setting up a test suite with XCTest
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 XCTest 设置测试套件
- en: 'In this section, you''ll work on a test suite for a new app: `Info.plist` file,
    and all the other files you would normally expect to find in a project. There''s
    also a JSON file in the project named `TriviaQuestions.json`. This file contains
    a couple of dummy questions that you can load by uncommenting a bit of code in
    `LoadTriviaViewController.swift`.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将为一个新应用程序工作：`Info.plist` 文件，以及你通常在项目中期望找到的所有其他文件。项目中还有一个名为 `TriviaQuestions.json`
    的 JSON 文件。这个文件包含了一些模拟问题，你可以通过在 `LoadTriviaViewController.swift` 中取消注释一些代码来加载这些问题。
- en: By default, `LoadTriviaViewController.swift` attempts to load questions from
    a non-existing web server. This is intentional, to demonstrate how one would normally
    set up a project like this. Since you don't have a web server at your disposal
    right now, you can swap out the dummy networking code for the JSON file to test
    this app.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`LoadTriviaViewController.swift`试图从一个不存在的网络服务器加载问题。这是故意的，以展示如何通常设置这样的项目。由于你现在没有可用的网络服务器，你可以用
    JSON 文件替换模拟的网络代码来测试这个应用程序。
- en: 'Before you write tests or perform any optimization, you must add a test target
    to the project. You add a test target in the same way you added extensions before.
    The only difference is that you select a different type of target. When adding
    a test target, you should pick the **iOS Unit Testing Bundle** template. The following
    screenshot shows the correct template you should select:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在你编写测试或执行任何优化之前，你必须将一个测试目标添加到项目中。你添加测试目标的方式与你之前添加扩展的方式相同。唯一的区别是，你选择了一个不同的目标类型。在添加测试目标时，你应该选择**iOS
    单元测试包**模板。以下截图显示了你应该选择的正确模板：
- en: '![Figure 19.1 – Adding a unit testing target'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 19.1 – 添加单元测试目标]'
- en: '](img/Figure_19.01_B14717.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_19.01_B14717.jpg]'
- en: Figure 19.1 – Adding a unit testing target
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 19.1 – 添加单元测试目标
- en: After adding the target, Xcode adds a new folder to your project. If you choose
    the default name for the test target, it's called `MovieTriviaTests`. You should
    add all the tests you write for this project to the test target.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 添加目标后，Xcode会在你的项目中添加一个新的文件夹。如果你选择测试目标的默认名称，它被称为`MovieTriviaTests`。你应该将你为这个项目编写的所有测试添加到测试目标中。
- en: If you think about when you used files in multiple targets with extensions,
    you might expect that you would need to add all of the files you want to write
    tests for to both of the targets. Fortunately, this isn't the case. When you write
    tests, you can import the entire app as a testable target, enabling you to write
    tests for all of the code in the app target.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你思考过在多个目标中使用具有扩展名的文件时的情况，你可能预期你需要将所有你想要为它们编写测试的文件添加到这两个目标中。幸运的是，情况并非如此。当你编写测试时，你可以将整个应用程序作为一个可测试的目标导入，这样你就可以为应用程序目标中的所有代码编写测试。
- en: If you look inside the `MovieTriviaTests` folder that Xcode created when you
    added the unit test target, you'll find a single file called `MovieTriviaTests.swift`.
    This file contains a couple of hints about what tests should look like for your
    test suite. First of all, note that the test class inherits from `XCTestCase`.
    All of your test classes should inherit from this `XCTestCase` so they can be
    identified as a test.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 Xcode 在你添加单元测试目标时创建的 `MovieTriviaTests` 文件夹，你会找到一个名为 `MovieTriviaTests.swift`
    的单个文件。这个文件包含了一些关于你的测试套件中测试应该是什么样子的提示。首先，请注意，测试类继承自 `XCTestCase`。所有你的测试类都应该继承自这个
    `XCTestCase`，这样它们才能被识别为测试。
- en: 'One of the methods you''ll find in the test template is the `setUp()` method.
    This method is executed before every test in the file and helps you to fulfill
    the first stage of the AAA pattern in testing: Arrange. You use this method to
    ensure that all of the preconditions for your test are met. You could make sure
    that your user is logged in or that your database is populated with test data.
    Of course, the depth of your setup in this method depends on the unit of code
    for which you''re writing a test.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 测试模板中你会找到的一种方法是 `setUp()` 方法。这个方法在文件中的每个测试之前执行，帮助你完成测试中的 AAA 模式的第一阶段：准备。你使用这个方法来确保你的测试的所有前提条件都得到满足。你可以确保用户已经登录或者数据库中已经填充了测试数据。当然，这个方法中设置的深度取决于你要为哪个代码单元编写测试。
- en: Also, note that there are two methods prefixed with `test` in the `test` class.
    These methods are executed as tests, and they are expected to perform the act
    and assert steps. The majority of the work should be performed in these test methods.
    Do note that it's often better to have multiple short test methods rather than
    a single test method that tests everything. The larger the methods, the harder
    it will be to maintain and debug your tests.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，在 `test` 类中有两个以 `test` 前缀的方法。这些方法作为测试执行，并预期执行操作和断言步骤。大部分工作应该在这些测试方法中完成。请注意，拥有多个简短的测试方法通常比一个测试所有内容的单一测试方法要好。方法越大，维护和调试测试就越困难。
- en: Finally, you'll find a `tearDown()` method. This method is intended to give
    you an opportunity to clean up after yourself. When you have inserted dummy data
    into your database, it's often desirable to remove this data when your tests have
    been completed. This will ensure a clean slate for the next test that runs, and
    it minimizes the chances of your first test accidentally influencing the second
    test that runs. As mentioned before, tests should never depend on other tests.
    This means that you also don't want to pollute other tests by leaving traces of
    previous tests.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你会找到一个 `tearDown()` 方法。这个方法旨在给你一个清理的机会。当你已经将模拟数据插入到数据库中时，在测试完成后删除这些数据通常是期望的。这将确保为下一个运行的测试提供一个干净的起点，并最小化第一个测试意外影响第二个测试的机会。如前所述，测试不应依赖于其他测试。这意味着你也不想通过留下前一个测试的痕迹来污染其他测试。
- en: Note that `setUp()` and `tearDown()` should be specific to the unit you're testing.
    This means that you can't put all of your tests in a single class. Separating
    tests into several classes is a good thing. You should create a test class for
    every unit of code that you're testing. One test class should typically not test
    more than a single class or struct in your app. If you're writing an integration
    test, there might be more than one class involved in the test, but you should
    still make sure that you're only testing a single thing, which is the integration
    between the classes involved in the integration you're testing.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`setUp()` 和 `tearDown()` 应该针对你正在测试的单元是特定的。这意味着你不能把所有的测试都放在一个类中。将测试分成几个类是一个好主意。你应该为每个你正在测试的代码单元创建一个测试类。一个测试类通常不应该测试你应用中的单个类或结构体。如果你正在编写集成测试，测试中可能涉及多个类，但你仍然应该确保你只测试一个东西，即你正在测试的集成中涉及的类之间的集成。
- en: Now that you have a test suite in place, let's see how you can write tests for
    the existing code in the **MovieTrivia** app and how the app can be refactored
    to be tested appropriately.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经建立了一个测试套件，让我们看看你如何为 **MovieTrivia** 应用中现有的代码编写测试，以及应用如何被重构以适当地进行测试。
- en: Optimizing code for testability
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化代码以提高可测试性
- en: Now that the project has a test target, it's time to start adding some tests
    to it. Before you add tests, you should determine what to test. Take some time
    to look at the app and the code and try to think of things to test. Assume that
    the app is finished and that the trivia questions are loaded from a server.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在项目有了测试目标，是时候开始向其中添加一些测试了。在你添加测试之前，你应该确定要测试什么。花些时间查看应用程序和代码，并尝试思考要测试的内容。假设应用程序已完成，并且Trivia问题是从服务器加载的。
- en: 'Some of the things you might have thought of to test are the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能考虑过的一些测试事项如下：
- en: Making sure that we can display the data we load from the network
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保我们可以显示我们从网络加载的数据
- en: Testing that selecting the correct answer triggers the expected code
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试选择正确答案是否触发预期的代码
- en: Testing that choosing a wrong answer triggers the expected code
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试选择错误答案是否触发预期的代码
- en: Ensuring that the first question is displayed after we show the last one
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保在显示最后一个问题之后显示第一个问题
- en: Testing that the question index increments
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试问题索引是否递增
- en: If you came up with most of the tests on this list, good job. You've successfully
    identified a lot of good test cases. But how do you test these cases? The project
    has been made hard to test intentionally, but let's see what tests can be written
    without refactoring the app right away.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想到了这个列表上的大多数测试，做得好。你已经成功地识别了许多好的测试用例。但是，你如何测试这些用例呢？项目有意被设计成难以测试，但让我们看看在不立即重构应用程序的情况下可以编写哪些测试。
- en: 'Remove the test class that Xcode has generated for you and create a new one
    called `LoadQuestionsTest`. Use the following bit of boilerplate code in this
    file''s implementation as a starting point for the tests:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 删除Xcode为你生成的测试类，并创建一个新的名为`LoadQuestionsTest`的类。使用以下样板代码作为此文件实现的测试起点：
- en: '[PRE0]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note the `@testable` import `MovieTrivia` line at the top of the file. This
    line imports the entire app target so you can access it in your tests. Before
    you implement the test body for `testLoadQuestions`, it's wise to think about
    what this method should test. If you look at the code in the app target, the trivia
    questions are loaded in the `viewDidAppear(_:)` method of `LoadTriviaViewController`.
    Once the questions are loaded, the app moves on to the next screen. An important
    detail is that the `triviaJSON` property on `LoadTriviaViewController` is set
    once the questions are loaded.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意文件顶部的`@testable`导入`MovieTrivia`行。这一行导入了整个应用程序目标，以便你可以在测试中访问它。在实现`testLoadQuestions`的测试主体之前，明智的做法是思考这个方法应该测试什么。如果你查看应用程序目标中的代码，Trivia问题是在`LoadTriviaViewController`的`viewDidAppear(_:)`方法中加载的。一旦问题加载，应用程序就会转到下一个屏幕。一个重要的细节是，一旦问题加载，`LoadTriviaViewController`上的`triviaJSON`属性就会被设置。
- en: Based on this information, you could write a test that creates an instance of
    `LoadTriviaViewController`, makes it appear, so the questions will load, and then
    waits until `triviaJSON` has a value to verify that the questions were successfully
    loaded. Writing a test that fits this description would involve many moving parts,
    way more than you should be comfortable with. `MovieTrivia` uses storyboards,
    so to obtain an instance of `LoadTriviaViewController`, the storyboard would have
    to be involved. This means that any changes or mistakes in the user interface
    would cause the logic test that checks whether data is loaded to fail. This is
    not desirable because this test should only verify whether it's possible to load
    data, not whether the user interface updates once the load completes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些信息，你可以编写一个测试，创建一个`LoadTriviaViewController`的实例，使其显示出来，以便加载问题，然后等待`triviaJSON`有值以验证问题是否成功加载。编写符合这种描述的测试将涉及许多移动部件，远远超过你应该感到舒适的范畴。"MovieTrivia"使用故事板，因此要获取`LoadTriviaViewController`的实例，故事板必须被涉及。这意味着用户界面中的任何更改或错误都会导致检查数据是否加载的逻辑测试失败。这不是所希望的，因为这项测试应该只验证是否可以加载数据，而不是在加载完成后用户界面是否更新。
- en: This is a great moment to start refactoring some code and make it more testable.
    The first piece of code that should be revamped for testability is the question-loading
    code.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个开始重构一些代码并使其更具可测试性的好时机。首先应该彻底翻新的代码是问题加载代码。
- en: Introducing the question loader
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍问题加载器
- en: To make `MovieTrivia` more testable, you should create a special helper that
    can load questions. The helper will go to the network and fetch the questions.
    Once the data is loaded, a callback is called to notify the object that initiated
    the request about the loaded questions. Because you already know that you're going
    to write tests for the new helper, you should think of a way to make sure that
    the helper works with both an offline and an online implementation, so the tests
    don't have to depend on an internet connection to work.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使`MovieTrivia`更容易进行测试，你应该创建一个特殊的辅助工具来加载问题。这个辅助工具将访问网络并获取问题。一旦数据被加载，就会调用一个回调来通知发起请求的对象已加载的问题。因为你已经知道你将要对新的辅助工具编写测试，你应该考虑一种方法来确保辅助工具可以与离线和在线实现一起工作，这样测试就不需要依赖互联网连接来运行。
- en: Because tests should rely on as few outside factors as possible, removing the
    networking layer from this test would be great. This means that the helper needs
    to be split into two parts. One part is the helper itself. The other part would
    be a data fetcher. The data fetcher should conform to a protocol that defines
    the interface that a data fetcher must have, so you can choose to inject either
    an online or offline fetcher into the helper.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于测试应该尽可能少地依赖外部因素，从测试中移除网络层将是一个很好的选择。这意味着辅助工具需要分成两部分。一部分是辅助工具本身。另一部分将是一个数据获取器。数据获取器应该符合一个定义数据获取器必须具有的接口的协议，这样你就可以选择将在线或离线获取器注入到辅助工具中。
- en: 'If the preceding explanation seems a little bit abstract and confusing to you,
    that''s OK. The following code samples will show you the process of separating
    the different helpers step by step. Add a new Swift file to the application target
    and call it `QuestionsLoader.swift`. Then add the following implementation to
    it:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面的解释对你来说有点抽象和令人困惑，那没关系。以下代码示例将逐步展示分离不同辅助工具的过程。向应用程序目标添加一个新的Swift文件，并将其命名为`QuestionsLoader.swift`。然后向其中添加以下实现：
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This struct defines a method to load questions with a callback. This is already
    nice and a lot more testable than before. You can now isolate the question loader
    and test it separated from the rest of the app. A test for the helper in its current
    state would look like the test shown in the following code snippet:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构定义了一个使用回调加载问题的方法。这已经很好了，比之前更容易进行测试。现在你可以将问题加载器隔离出来，并单独对其进行测试。当前状态的辅助工具的测试看起来可能像以下代码片段中显示的测试：
- en: '[PRE2]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding test creates an instance of `QuestionLoader` and sets up an expectation.
    An expectation is used when you expect something to happen in your test eventually.
    Since `QuestionLoader` loads its questions asynchronously, you can't expect the
    questions to be loaded by the time this test method is done executing. The callback
    that's called when the questions are loaded is used to fulfill the expectation
    in this test. To make sure that the test waits for the expectation to be fulfilled,
    `waitForExpectations(timeout:handler:)` is called after `loadQuestions(callback:)`.
    If the expectation isn't fulfilled within the 5-second timeout that is specified,
    the test fails.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的测试创建了一个`QuestionLoader`实例并设置了一个期望。期望用于你最终期望测试中发生某些事情时。由于`QuestionLoader`异步加载问题，你不能期望在测试方法执行完毕时问题已经被加载。当问题被加载时调用的回调用于在这个测试中满足期望。为了确保测试等待期望得到满足，在`loadQuestions(callback:)`之后调用了`waitForExpectations(timeout:handler:)`。如果在指定的5秒超时时间内期望没有得到满足，测试将失败。
- en: Examine this test closely; you should be able to see all of the As (Arrange,
    Act, Assert) that you read about earlier. The first A, arrange, is where the loader
    and expectation are created. The second A, act, is when `loadQuestions(callback:)`
    is called. The final A, assert, is inside the callback. This test doesn't validate
    whether the data passed to the callback is valid, but you'll get to that later.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细检查这个测试；你应该能够看到你之前读到的所有A（安排、行动、断言）。第一个A，安排，是创建加载器和期望的地方。第二个A，行动，是调用`loadQuestions(callback:)`的时候。最后的A，断言，是在回调内部。这个测试并没有验证传递给回调的数据是否有效，但稍后你会了解到这一点。
- en: Separating the loader into its own object is great but it still has one problem.
    There is no way to configure whether it loads data from a local file or the network.
    In a production environment, the question loader would load data from the network,
    which would make the test for the question loader depend on the network as well.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 将加载器分离成自己的对象是很好的，但它仍然有一个问题。没有方法可以配置它是否从本地文件或网络加载数据。在生产环境中，问题加载器会从网络加载数据，这将使问题加载器的测试也依赖于网络。
- en: This isn't ideal because a test that depends on the network might fail for reasons
    you can't control.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不理想，因为依赖于网络的测试可能会因为无法控制的原因而失败。
- en: This can be improved by utilizing some protocol-oriented programming and the
    dependency-injection pattern. This means that you should define a protocol that
    defines the public API for a networking layer. Then you should implement a networking
    object in the app target that conforms to the protocol. `QuestionsLoader` should
    have a property that holds anything that conforms to the networking protocol.
    The test target should have its own object that conforms to the networking protocol
    so you can use that object to provide `QuestionsLoader` with mock data.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过利用一些基于协议的编程和依赖注入模式来改进。这意味着你应该定义一个协议，该协议定义了网络层的公共API。然后你应该在应用目标中实现一个符合该协议的网络对象。`QuestionsLoader`应该有一个属性来持有任何符合网络协议的对象。测试目标应该有自己的对象，该对象符合网络协议，这样你就可以使用该对象为`QuestionsLoader`提供模拟数据。
- en: By setting the test up like this, you can take the entire networking logic out
    of the equation and arrange tests in such a way that the networking doesn't matter.
    The mock networking layer will respond with valid, reliable responses that can
    be used as test input.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样设置测试，你可以将整个网络逻辑从等式中去除，并安排测试，使网络无关紧要。模拟网络层将返回有效、可靠的响应，可以用作测试输入。
- en: Mocking API responses
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟API响应
- en: 'It''s common practice to mock API responses when you''re testing. In this segment,
    you will implement the mock API that was described before to improve the quality
    and reliability of the `MovieTrivia` test suite. Follow these steps to create
    a mock response to test your API:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试时模拟API响应是一种常见的做法。在本节中，你将实现之前描述的模拟API，以改进`MovieTrivia`测试套件的品质和可靠性。按照以下步骤创建一个模拟响应来测试你的API：
- en: 'First, let''s define the networking protocol. Create a new file in the app
    target and name it `TriviaAPIProviding`:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们定义网络协议。在应用目标中创建一个新文件，并将其命名为`TriviaAPIProviding`：
- en: '[PRE3]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The protocol only requires a single method. If you want to expand this app later,
    everything related to the Trivia API must be added to the protocol to make sure
    that you can create both an online version of your app and an offline version
    for your tests.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 协议只需要一个方法。如果你想稍后扩展此应用程序，与Trivia API相关的所有内容都必须添加到协议中，以确保你可以创建应用程序的在线版本和用于测试的离线版本。
- en: 'Next, create a file named `TriviaAPI` and add the following implementation
    to it:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为`TriviaAPI`的文件，并将以下实现添加到其中：
- en: '[PRE4]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Lastly, update the `QuestionsLoader` struct with the following implementation:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用以下实现更新`QuestionsLoader`结构体：
- en: '[PRE5]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The question loader now has an `apiProvider` that it uses to load questions.
    Currently, it delegates any load call over to its API provider, but you'll update
    this code soon to make sure that it converts the raw JSON data that the API returns
    to question models.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 问题加载器现在有一个`apiProvider`，它使用它来加载问题。目前，它将任何加载调用委托给其API提供者，但你会很快更新此代码以确保它将API返回的原始JSON数据转换为问题模型。
- en: 'Update the `viewDidAppear(_:)` method of `LoadTriviaViewController` as shown
    in the following code snippet. This implementation uses the loader struct instead
    of directly loading the data inside the view controller:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下代码片段所示，更新`LoadTriviaViewController`的`viewDidAppear(_:)`方法。此实现使用加载器结构体而不是在视图控制器中直接加载数据：
- en: '[PRE6]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding code is not only more testable but also a lot cleaner. The next
    step is to create the mock API in the test target so you can use it to provide
    the question loader with data.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之前的代码不仅更容易测试，而且更加简洁。下一步是在测试目标中创建模拟API，这样你就可以用它来为问题加载器提供数据。
- en: The JSON file in the app target should be removed from the app target and added
    to the test target. You can leave it in the app folder but make sure to update
    the `Target Membership` so the JSON file is only available in the test target.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应该将应用目标中的JSON文件从应用目标中移除，并添加到测试目标中。你可以将其留在应用文件夹中，但请确保更新`Target Membership`，以便JSON文件仅在测试目标中可用。
- en: 'Now add a new Swift file named `MockTriviaAPI` to the test target and add the
    following code to it:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在向测试目标添加一个名为`MockTriviaAPI`的新Swift文件，并将以下代码添加到其中：
- en: '[PRE7]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This code fetches the locally stored JSON file from the test bundle. To determine
    the location of the JSON file, one of the test classes is used to retrieve the
    current bundle. This is not the absolute best way to retrieve a bundle because
    it relies on an external factor to exist in the test target. However, structs
    can't be used to look up the current bundle. Luckily, the compiler will throw
    an error if the class that is used to determine the bundle is removed so the compiler
    would quickly error and the mistake can be fixed. After loading the file, the
    callback is called, and the request has been successfully handled.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此代码从测试包中检索本地存储的JSON文件。为了确定JSON文件的位置，使用了一个测试类来检索当前包。这不是获取包的最佳方式，因为它依赖于测试目标中存在的外部因素。然而，结构体不能用来查找当前包。幸运的是，如果用于确定包的类被移除，编译器将抛出一个错误，因此编译器会快速报错，错误可以被修复。在加载文件后，回调被调用，请求已成功处理。
- en: 'Now update the test in `LoadQuestionsTest` so it uses the mock API as follows:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在更新`LoadQuestionsTest`中的测试，使其使用模拟API如下：
- en: '[PRE8]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s summarize what we have done here: We have defined our API as a protocol.
    By doing that and with dependency injection, we are now capable of creating a
    mock class to test the API. As long as our mock class conforms to that protocol,
    we can inject it anywhere we need the API.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下在这里我们所做的工作：我们已经将我们的API定义为一个协议。通过这样做，并且使用依赖注入，我们现在能够创建一个模拟类来测试API。只要我们的模拟类符合该协议，我们就可以将其注入到需要API的任何地方。
- en: A lot of apps have way more complex interactions than the one you're testing
    now. When you get to implementing more complex scenarios, the main ideas about
    how to architect your app and tests remain the same, regardless of application
    complexity.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序的交互比你现在正在测试的要复杂得多。当你开始实现更复杂的场景时，关于如何架构你的应用程序和测试的主要思想保持不变，无论应用程序的复杂程度如何。
- en: Protocols can be used to define a common interface for certain objects. Combining
    this with dependency-injection as you did for `QuestionsLoader` helps to isolate
    the pieces of your code that you're testing, and it enables you to swap out pieces
    of code to make sure that you don't rely on external factors if you don't have
    to.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 协议可以用来定义某些对象的通用接口。结合你为`QuestionsLoader`所做的那样使用依赖注入，有助于隔离你正在测试的代码部分，并使你能够替换代码片段，以确保如果你不需要，你不会依赖于外部因素。
- en: So far, the test suite is not particularly useful. The only thing that's tested
    at this point is whether `QuestionsLoader` passes requests on to the `TriviaAPIProviding`
    object and whether the callbacks are called as expected. Even though this technically
    qualifies as a test, it's much better also to test whether the loader object can
    convert the loaded data into question objects that the app can display.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，测试套件并不特别有用。到目前为止，唯一被测试的是`QuestionsLoader`是否将请求传递给`TriviaAPIProviding`对象，以及回调是否按预期被调用。尽管从技术上讲这可以算作一个测试，但最好也测试加载器对象是否能够将加载的数据转换为应用程序可以显示的问题对象。
- en: Testing whether `QuestionsLoader` can convert JSON into a `Question` model is
    a test that's a lot more interesting than just testing whether the callback is
    called. A refactor such as this might make you wonder whether you should add a
    new test or modify the existing test.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 测试`QuestionsLoader`是否能够将JSON转换为`Question`模型是一个比仅仅测试回调是否被调用更有趣的测试。这样的重构可能会让你想知道是否应该添加一个新的测试或修改现有的测试。
- en: If you choose to add a new test, your test suite will cover a simple case where
    you only test that the callback is called and a more complex case that ensures
    the loader can convert JSON data to models. When you update the existing test,
    you end up with a test that validates two things. It will make sure that the callback
    is called but also that the data is converted to models.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择添加一个新的测试，你的测试套件将覆盖一个简单的案例，其中你只测试回调是否被调用，以及一个更复杂的案例，确保加载器可以将JSON数据转换为模型。当你更新现有的测试时，你最终得到一个测试，它验证了两件事。它将确保回调被调用，同时数据也被转换为模型。
- en: While the implications for both choices are similar, the second-choice sort
    of assumes that the callback will be called. You always want to limit your assumptions
    when writing tests and there's no harm in adding more tests when you add more
    features. However, if the callback does not get called, none of the tests will
    work. So, in this case, you can work with a single test that makes sure the callback
    is called and that the loader returns the expected models.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然两种选择的影响相似，但第二种选择似乎假设回调将被调用。在编写测试时，总是想限制你的假设，并且在你添加更多功能时添加更多测试并无害处。然而，如果回调没有被调用，则所有测试都不会工作。因此，在这种情况下，你可以使用一个测试来确保回调被调用，并且加载器返回预期的模型。
- en: The test you should end up with will have a single expectation and multiple
    assertions. Writing the test like this makes sure that the expectation of the
    callback is fulfilled when the callback is called, and at the same time you can
    use assertions to ensure that the data that's passed to the callback is valid
    and correct.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你最终得到的测试将只有一个期望和多个断言。这样编写测试可以确保当回调被调用时，回调的期望得到满足，同时你可以使用断言来确保传递给回调的数据是有效和正确的。
- en: By making `QuestionsLoader` create instances of a `Question` model rather than
    using it to return a dictionary of JSON data, it not only makes the test more
    interesting but also improves the app code by making it a lot cleaner. Right now,
    the app uses a dictionary of JSON data to display questions. If the JSON changes,
    you would have to update the view controller's code. If the app grows, you might
    be using the JSON data in multiple places, making the process of updating quite
    painful and error-prone. This is why it's a much better idea to use the `Codable`
    protocol to convert raw API responses to `Question` models. Using `Codable` objects
    means you can get rid of the JSON dictionaries in the view controllers, which
    is a vast improvement.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通过让`QuestionsLoader`创建`Question`模型的实例而不是使用它来返回JSON数据字典，这不仅使测试更有趣，而且通过使代码更加整洁来改进应用程序代码。目前，应用程序使用JSON数据字典来显示问题。如果JSON发生变化，就必须更新视图控制器的代码。如果应用程序增长，你可能会在多个地方使用JSON数据，这使得更新过程非常痛苦且容易出错。这就是为什么使用`Codable`协议将原始API响应转换为`Question`模型是一个更好的主意。使用`Codable`对象意味着你可以从视图控制器中删除JSON字典，这是一个巨大的改进。
- en: Using models for consistency
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用模型以保持一致性
- en: 'Adding a question model to `MovieTrivia` involves quite a bit of refactoring.
    First, you must define the `Question` model. Let''s create and make use of our
    models instead of using JSON structs around the code. Follow these steps:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 将问题模型添加到`MovieTrivia`涉及相当多的重构。首先，你必须定义`Question`模型。让我们创建并使用我们的模型，而不是在代码中使用JSON结构。按照以下步骤操作：
- en: 'Create a new Swift file named `Question` and add the following implementation
    to it:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Question`的新Swift文件，并将以下实现添加到其中：
- en: '[PRE9]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `Question` struct conforms to the `Codable` protocol.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Question`结构体符合`Codable`协议。'
- en: 'Since the dummy JSON data contains a list of questions, you''ll want to define
    a `Codable` object that contains the response as well:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于模拟的JSON数据包含问题列表，你需要定义一个包含响应的`Codable`对象：
- en: '[PRE10]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now that the `Question` model and the response container are in place, a couple
    of changes must be made to the existing code.
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，`Question`模型和响应容器已经就位，必须对现有代码进行一些更改。
- en: 'Modify the `typealias` in the `TriviaAPIProviding` protocol as follows:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`TriviaAPIProviding`协议中的`typealias`定义如下：
- en: '[PRE11]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, update the implementation of the `TriviaAPI` for the `URLSession` callback
    in `loadTriviaQuestions(callback:)` as follows:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，更新`TriviaAPI`在`URLSession`回调中的`loadTriviaQuestions(callback:)`实现如下：
- en: '[PRE12]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Also, update `MockTriviaApi` so it executes its callback with data instead
    of a JSON dictionary:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，更新`MockTriviaApi`，使其使用数据而不是JSON字典来执行回调：
- en: '[PRE13]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Update the `QuestionsLoadedCallback`  `typealias` in `QuestionsLoader` to the
    following definition:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`QuestionsLoader`中的`QuestionsLoadedCallback` `typealias`定义如下：
- en: '[PRE14]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And lastly, update the implementation for `loadQuestions(callback:)` as follows:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，按照以下方式更新`loadQuestions(callback:)`的实现：
- en: '[PRE15]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This wraps up the changes for the API. However, there still is some refactoring
    to be done in the view controllers.
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这完成了对API的更改。然而，在视图控制器中还有一些重构工作要做。
- en: 'Rename the `triviaJSON` property on `LoadTriviaViewController` to the following:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`LoadTriviaViewController`上的`triviaJSON`属性重命名为以下名称：
- en: '[PRE16]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Make sure you replace all occurrences of `triviaJSON` with the new `questions`
    array. Also, make sure you change the following line in `prepare(for:sender:)`:'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保将所有`triviaJSON`的出现替换为新的`questions`数组。同时，确保更改以下`prepare(for:sender:)`中的行：
- en: '[PRE17]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Change the preceding line to this:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将前面的行更改为以下内容：
- en: '[PRE18]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In `QuestionViewController`, change the type of `questions` to `[Question]`
    and remove the `triviaJSON` property.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`QuestionViewController`中，将`questions`的类型更改为`[Question]`并删除`triviaJSON`属性。
- en: At this point, you can clear all of the JSON-related code from the guards in
    this class. You should be able to do this on your own since the compiler should
    guide you with errors. If you get stuck, look at the finished project in the code
    bundle.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您可以清除这个类守卫中所有与JSON相关的代码。由于编译器应该通过错误来引导您，因此您应该能够自己做到这一点。如果您遇到困难，请查看代码包中的完成项目。
- en: By now, you should be able to run the tests, and they should pass. To run your
    tests, click the `Question` models. To make sure this conversion worked, you can
    load the JSON file in the test, count the number of questions in the JSON file,
    and assert that it matches the number of questions in the callback.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，您应该能够运行测试，并且它们应该通过。要运行测试，请点击`Question`模型。为了确保转换成功，您可以在测试中加载JSON文件，计算JSON文件中的问题数量，并断言它与回调中的问题数量匹配。
- en: 'Update the `testLoadQuestions()` method as shown in the following code snippet:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下代码片段更新`testLoadQuestions()`方法：
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This test loads the dummy JSON file and uses `XCTAssert` to make sure that more
    than zero questions were passed to the callback and that the number of questions
    in the JSON file matches the number of questions that were loaded.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试加载了模拟的JSON文件，并使用`XCTAssert`确保传递给回调的问题数量超过零，并且JSON文件中的问题数量与加载的问题数量匹配。
- en: '`XCTAssert` takes a Boolean expression and a description. If the assertion
    fails, the description is shown. Adding good descriptions will help you to quickly
    figure out which assertion in your test has made your test fail.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`XCTAssert`接受一个布尔表达式和一个描述。如果断言失败，将显示描述。添加好的描述将帮助您快速找出测试中哪个断言导致测试失败。'
- en: This new version of the load-questions test is a small addition to the test
    suite but has vast consequences. By improving the test suite, you have improved
    the quality of the app because you can now prove that the question loader correctly
    transforms JSON into model objects. By adding model objects, you have improved
    the code in the view controllers as well. Instead of reading raw JSON, you are
    now reading properties from a model. And lastly, these changes have made your
    view controllers a lot cleaner.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的加载问题测试版本是对测试套件的小幅补充，但具有深远的影响。通过改进测试套件，您提高了应用程序的质量，因为现在您可以证明问题加载器正确地将JSON转换为模型对象。通过添加模型对象，您还改进了视图控制器中的代码。您现在读取的是模型属性，而不是原始JSON。最后，这些更改使您的视图控制器变得更加简洁。
- en: In this section, you have learned how to create and use your own data models
    through your code. By doing so, your code is more consistent and easier to test
    (and maintain).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您已经学会了如何通过代码创建和使用您自己的数据模型。通过这样做，您的代码更加一致，更容易测试（和维护）。
- en: One more metric that has improved by refactoring your code is the amount of
    code that is covered by the test suite. You can measure the percentage of code
    your test suite covers with Xcode's built-in code coverage tracking. You'll learn
    how to use this tool next.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重构代码，另一个提高的指标是测试套件覆盖的代码量。您可以使用Xcode内置的代码覆盖率跟踪来衡量测试套件覆盖的代码百分比。您将在下一节学习如何使用此工具。
- en: Gaining insights through code coverage
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过代码覆盖率获得洞察
- en: Code coverage is a tool in Xcode that is used to gain insights into how much
    of your code you are testing with your test suite. It tells you exactly which
    parts of your code were executed during a test and which parts of your code were
    not. This is extremely useful because you can take focused action based on the
    information provided by code coverage.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率是Xcode中的一个工具，用于了解您的测试套件测试了多少代码。它确切地告诉您在测试期间执行了哪些代码部分以及哪些代码部分没有执行。这非常有用，因为您可以根据代码覆盖率提供的信息采取有针对性的行动。
- en: 'Follow these steps to enable the code coverage functionality:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤启用代码覆盖率功能：
- en: To enable **Code Coverage**, open the scheme editor through the (**Product**
    | **Scheme**) menu:![Figure 19.2 – Editing scheme
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要启用**代码覆盖率**，通过（**产品** | **方案**）菜单打开方案编辑器：![图19.2 – 编辑方案
- en: '](img/Figure_19.02_B14717.jpg)'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_19.02_B14717.jpg)'
- en: Figure 19.2 – Editing scheme
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图19.2 – 编辑方案
- en: Select **Test action** and make sure the **Gather coverage** checkbox on the
    **Options** tab is checked:![Figure 19.3 – Gather coverage option
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**测试操作**并确保在**选项**选项卡上的**收集覆盖率**复选框被勾选：![图19.3 – 收集覆盖率选项
- en: '](img/Figure_19.03_B14717.jpg)'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_19.03_B14717.jpg)'
- en: Figure 19.3 – Gather coverage option
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图19.3 – 收集覆盖率选项
- en: Tip
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can also press *Command + <* to open the scheme editor quickly.
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您也可以按*Command + <* 快速打开方案编辑器。
- en: After doing this, close the scheme editor and run your tests.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成此操作后，关闭方案编辑器并运行您的测试。
- en: This time, Xcode will monitor which parts of your code were executed during
    this test, and which parts weren't. This information can give you some good insights
    into which parts of your code could use some more testing.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这次，Xcode 将监控在这次测试期间您的代码的哪些部分被执行了，哪些部分没有。这些信息可以为您提供一些关于哪些代码部分可能需要更多测试的见解。
- en: 'To see the coverage data, open the **Report navigator** in the left sidebar
    in Xcode. The rightmost icon in this sidebar represents the report navigator:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看覆盖率数据，请打开 Xcode 左侧边栏中的**报告导航器**。此边栏中最右侧的图标代表报告导航器：
- en: '![Figure 19.4 – Coverage option'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![图19.4 – 覆盖率选项'
- en: '](img/Figure_19.04_B14717.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_19.04_B14717.jpg)'
- en: Figure 19.4 – Coverage option
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.4 – 覆盖率选项
- en: 'There are several reports listed under your app name. If you select the **Coverage**
    report, the coverage report will open in the editor area in Xcode. You can see
    all the files in your app and the percentage of code in the file that''s covered
    by your tests. The following screenshot shows coverage for the **MovieTrivia**
    app:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的应用程序名称下列出了几个报告。如果您选择**覆盖率**报告，覆盖率报告将在 Xcode 的编辑器区域中打开。您可以看到应用程序中的所有文件以及文件中由您的测试覆盖的代码百分比。以下截图显示了**MovieTrivia**应用程序的覆盖率：
- en: '![Figure 19.5 – Coverage details'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '![图19.5 – 覆盖率详情'
- en: '](img/Figure_19.05_B14717.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_19.05_B14717.jpg)'
- en: Figure 19.5 – Coverage details
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.5 – 覆盖率详情
- en: The more a bar is filled, the more lines of code in that file or method were
    executed during your test. You'll notice that the `AppDelegate.swift` file is
    covered under the tests even though you haven't written any tests for it. The
    reason this happens is that the app must launch during the test to act as a host
    for the test suite. This means that parts of the code in `AppDelegate.swift` are
    actually executed during the test, and therefore Xcode considers it covered in
    the tests.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 柱状图填充得越多，表示在该文件或方法中执行的代码行数越多。您会注意到，即使在`AppDelegate.swift`文件上没有编写任何测试，它仍然在测试中被覆盖。这种情况发生的原因是，在测试期间应用程序必须启动，作为测试套件的宿主。这意味着`AppDelegate.swift`中的代码部分实际上在测试期间被执行，因此
    Xcode 认为它在测试中被覆盖。
- en: You can see which methods for a specific file were executed by clicking on the
    triangle next to the class name. This enables you to see exactly which parts of
    a file are tested and which parts aren't.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通过单击类名旁边的三角形，您可以查看特定文件中哪些方法被执行了。这使您能够确切地看到文件中的哪些部分被测试了，哪些部分没有被测试。
- en: One last feature of code coverage that's worth mentioning is inline code coverage.
    Inline code coverage will show you how often a specific block of code has been
    executed during testing. This will give you code coverage insights right next
    to your code, without having to navigate to the report navigator. To enable this
    feature, open up your Xcode preferences and navigate to the **Text Editing** tab.
    Check the **Show iteration counts** checkbox at the bottom of the tab. If you
    open a file now, you'll see the iteration count for your code on the right side
    of the editor window.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的代码覆盖率的一个最后特性是内联代码覆盖率。内联代码覆盖率将显示在测试期间特定代码块被执行的频率。这将直接在您的代码旁边提供代码覆盖率见解，而无需导航到报告导航器。要启用此功能，请打开您的
    Xcode 预设并导航到**文本编辑**选项卡。在选项卡底部勾选**显示迭代次数**复选框。如果您现在打开一个文件，您将在编辑器窗口的右侧看到您的代码的迭代次数。
- en: 'The following screenshot shows the iteration count for the `loadQuestions(callback:)`
    method:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了`loadQuestions(callback:)`方法的迭代次数：
- en: '![Figure 19.6 – Show iteration counts'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '![图19.6 – 显示迭代次数'
- en: '](img/Figure_19.06_B14717.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_19.06_B14717.jpg)'
- en: Figure 19.6 – Show iteration counts
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.6 – 显示迭代次数
- en: Even though code coverage is a great tool for gaining insights into your tests,
    you shouldn't let it influence you too much. Regularly check the code coverage
    for your app and look for methods that are untested and are either easy to write
    tests for or should be tested because they contain important logic. Code coverage
    is also great for discovering parts of your code that should be tested but are
    hard to test because they're nested deep inside a view controller or are otherwise
    hard to reach.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管代码覆盖率是一个很好的工具，可以帮助你深入了解测试，但你不应让它过多地影响你。定期检查你应用的代码覆盖率，寻找那些未测试且易于编写测试或应该测试的方法，因为它们包含重要的逻辑。代码覆盖率也非常适合发现那些应该被测试但难以测试的部分，因为它们深嵌在视图控制器中或以其他方式难以触及。
- en: You should always aim for as much code coverage as possible, but don't push
    yourself to reach 100%. Doing this will make you jump through all kinds of hoops,
    and you'll invest way more time in testing than you should. Not all paths in your
    code have to be tested. However, don't shy away from doing some refactoring. Proper
    testing helps you to avoid bugs and to structure your code better. Code coverage
    is just one extra tool in your tool belt to help identify which parts of your
    code could benefit from some tests.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该始终追求尽可能多的代码覆盖率，但不要强迫自己达到 100%。这样做会让你跳过各种障碍，并且你会花费比预期更多的时间在测试上。并不是你代码中的所有路径都需要测试。然而，不要回避进行一些重构。适当的测试可以帮助你避免错误，并更好地组织你的代码。代码覆盖率只是你工具箱中的一项额外工具，帮助你确定哪些代码部分可能需要一些测试。
- en: 'If you look at the current state of the coverage in the `XCTest` can be quite
    hard and tedious. Luckily, there is one last testing tool that we''ll discuss
    in this chapter: `XCUITest`.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看看当前 `XCTest` 的覆盖率状态，可能会觉得相当困难且繁琐。幸运的是，在本章中我们还将讨论最后一个测试工具：`XCUITest`。
- en: Testing the user interface with XCUITest
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 XCUITest 测试用户界面
- en: We have learned how to test your code and the logic behind it. In this section,
    we are going to learn how to test the UI of your app with **XCUITest**.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何测试你的代码及其背后的逻辑。在本节中，我们将学习如何使用 **XCUITest** 测试你应用的 UI。
- en: Knowing that most of your app logic is covered with tests is great. What's not
    so great, however, is adding your view controllers to your logic test. Luckily,
    you can use `XCUITest` to easily record and write tests that focus on the user
    interface of an app. `XCUITest` uses the accessibility features in iOS to gain
    access to the user interface of your app. This means that implementing user interface
    tests forces you to put at least a little bit of effort into accessibility for
    your applications. The better your app's accessibility is, the easier it will
    be to write UI Tests for.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 知道你应用的大部分逻辑都经过了测试是很好的。然而，将你的视图控制器添加到逻辑测试中并不是那么好。幸运的是，你可以使用 `XCUITest` 来轻松录制和编写专注于应用用户界面的测试。`XCUITest`
    使用 iOS 中的易用性功能来访问你应用的用户界面。这意味着实现用户界面测试迫使你至少在易用性方面为你的应用付出一些努力。你应用的可访问性越好，编写 UI
    测试就越容易。
- en: '`XCUITest` has two great features that we''ll look at in greater detail. First
    of all, UI tests help you to enhance the accessibility of your apps. Secondly,
    it''s easy to get started with UI testing because Xcode can record your tests
    while you navigate through your app. This can significantly benefit the amount
    of code that is covered by your test suite since code coverage also takes UI tests
    into account.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`XCUITest` 有两个非常出色的特性，我们将更详细地探讨。首先，UI 测试可以帮助你提高应用的易用性。其次，UI 测试的入门非常简单，因为 Xcode
    可以在你导航应用时记录你的测试。这可以显著增加你的测试套件覆盖的代码量，因为代码覆盖率也考虑了 UI 测试。'
- en: Before we start recording our first UI test, let's have a quick look at accessibility.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始录制第一个 UI 测试之前，让我们快速了解一下易用性。
- en: Making your app accessible to your tests
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使你的应用对测试可访问
- en: One of the lesser thoughts about features in iOS is accessibility. The design
    teams at Apple work hard to ensure that iOS is accessible for everybody. This
    includes blind people and people with other disabilities that could somehow affect
    the user's ability to operate their iOS device.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 iOS 中功能的一个较少被考虑到的方面是易用性。苹果的设计团队努力确保 iOS 对每个人都是可访问的。这包括盲人和其他可能影响用户操作 iOS 设备能力的残疾人士。
- en: Just looking at the accessibility settings in the iOS Settings app makes it
    evident that this is a subject that Apple invests a lot of time in. If you're
    working on an app, Apple expects you to put in the same kind of effort. Doing
    this will be rewarded by more app downloads and if you're lucky, even a couple
    of great reviews. In their talk on iOS accessibility from WWDC 2015, Apple even
    mentioned that implementing accessibility features can be helpful if you ever
    want to be featured in the *App Store*. Only the best apps get featured by Apple,
    and if your app is accessible to all people, that significantly boosts your app's
    quality.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 只需查看 iOS 设置应用程序中的可访问性设置，就可以明显看出这是一个苹果投入了大量时间的主题。如果您正在开发应用程序，苹果期望您投入同样的努力。这样做将得到更多应用程序下载的回报，如果您幸运的话，甚至可能获得几条好评。在
    2015 年的 WWDC 上，苹果甚至在他们的 iOS 可访问性演讲中提到，实现可访问性功能如果将来您希望应用程序出现在 *App Store* 中可能会有所帮助。只有最好的应用程序才能被苹果推荐，如果您的应用程序对所有人都可访问，这将显著提高您应用程序的质量。
- en: A common myth surrounding accessibility is that it's hard to implement or that
    it takes a lot of time. Some people even go so far as to say that it looks ugly
    or gets in the way of beautiful design. None of this is entirely correct. Sure,
    making your app accessible requires some effort, but the UIKit framework is very
    helpful when it comes to accessibility. Using standard components and keeping
    your users in mind while you design your app will make sure that your app is both
    accessible and looks good.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 围绕可访问性有一个常见的误解，即实现起来很困难或需要花费大量时间。有些人甚至说它看起来很丑或会妨碍美观的设计。这些说法并不完全正确。当然，使您的应用程序可访问需要一些努力，但
    UIKit 框架在可访问性方面非常有帮助。使用标准组件并在设计应用程序时考虑到您的用户，将确保您的应用程序既可访问又看起来不错。
- en: 'So, how does accessibility work on iOS? And how can we make sure our app is
    accessible? A fun way to experiment with this is to turn on **VoiceOver** on your
    device. Follow these steps to enable it:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，iOS 上的可访问性是如何工作的？我们如何确保我们的应用程序可访问？一个有趣的实验方法是打开您设备上的 **VoiceOver**。按照以下步骤启用它：
- en: To enable **VoiceOver**, go to the **Accessibility** menu. You'll find several
    vision-related accessibility settings. **VoiceOver** should be the topmost one.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要启用 **VoiceOver**，请转到 **可访问性** 菜单。您将找到几个与视力相关的可访问性设置。**VoiceOver** 应该是最上面的一个。
- en: To quickly enable and disable **VoiceOver**, scroll all the way to the bottom
    of the settings page and select **VoiceOver** as your accessibility shortcut:![Figure
    19.7 – Device Accessibility options
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要快速启用和禁用 **VoiceOver**，请滚动到设置页面的底部并选择 **VoiceOver** 作为您的可访问性快捷键：![图 19.7 – 设备可访问性选项
- en: '](img/Figure_19.07_B14717.jpg)'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_19.07_B14717.jpg)'
- en: Figure 19.7 – Device Accessibility options
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 19.7 – 设备可访问性选项
- en: This will allow you to toggle **VoiceOver** off and on by triple-clicking the
    home button or side button, depending on your device.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将允许您通过三击主按钮或侧按钮来切换 **VoiceOver** 的开关，具体取决于您的设备。
- en: After enabling this, run the **MovieTrivia** app on your device and triple-click
    your home button or the side button to enable **VoiceOver**.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用此功能后，在您的设备上运行 **MovieTrivia** 应用程序，并三击主按钮或侧按钮以启用 **VoiceOver**。
- en: Swipe around and try to use the app.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滑动并尝试使用应用程序。
- en: This is how a person with a visual handicap would use your app. You won't get
    past the loading screen because the dummy questions aren't loaded, but you should
    find the splash screen to be pretty accessible, especially considering no special
    work had to be done to achieve this. UIKit uses great default settings to make
    sure your app will be accessible by default.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是视力障碍人士如何使用您的应用程序。由于模拟问题尚未加载，您将无法通过加载屏幕，但您应该会发现启动屏幕非常易于访问，尤其是考虑到为此并没有做任何特殊的工作。UIKit
    使用了出色的默认设置，以确保您的应用程序默认可访问。
- en: 'You can set your own accessibility information through the **Identity Inspector**
    in Interface Builder. You can add custom labels, hints, identifiers, and traits
    to your interface to aid accessibility and, coincidentally, your UI tests. The
    following screenshot shows the **Accessibility** panel:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过 Interface Builder 中的 **Identity Inspector** 设置自己的可访问性信息。您可以在界面中添加自定义标签、提示、标识符和特性，以帮助可访问性，并且巧合的是，这也有助于您的
    UI 测试。以下截图显示了 **可访问性** 面板：
- en: '![Figure 19.8 – Accessibility options'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 19.8 – 可访问性选项'
- en: '](img/Figure_19.08_B14717.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_19.08_B14717.jpg)'
- en: Figure 19.8 – Accessibility options
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.8 – 可访问性选项
- en: For most UIKit interface elements, you won't have to touch these settings yourself.
    UIKit will make sure that your objects have sensible defaults that automatically
    make your app accessible. Now that you have a little bit of background information
    about accessibility, let's have a look at testing the app's (accessible) UI.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数 UIKit 接口元素，你不需要自己触摸这些设置。UIKit 将确保你的对象有合理的默认值，这些默认值会自动使你的应用易于访问。现在你已经对可访问性有一些背景信息了，让我们来看看测试应用（可访问的）UI。
- en: Recording UI tests
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录 UI 测试
- en: Before you can record UI tests, you must add a UI testing target to the project.
    Follow the same steps as before to add a new testing target but pick the iOS UI
    Testing Bundle this time around. If you look inside the newly created group in
    your project, the structure of your UI tests looks very similar to the structure
    of unit tests.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在你能够记录 UI 测试之前，你必须将 UI 测试目标添加到项目中。按照之前的步骤添加新的测试目标，但这次选择 iOS UI 测试包。如果你查看项目中新创建的组，你的
    UI 测试的结构看起来与单元测试的结构非常相似。
- en: One significant difference between UI test targets and unit test targets is
    that your UI tests do not have access to any code that's inside your app. A UI
    test can only test the interface of your app and make assertions based on that.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: UI 测试目标和单元测试目标之间一个显著的区别是，你的 UI 测试无法访问应用内部的任何代码。UI 测试只能测试应用的界面，并基于此进行断言。
- en: If you open the `MovieTriviaUITest.swift` file, you'll notice the `setUpWithError
    ()` and `tearDown()` methods. Also, all of the tests that must be executed are
    methods with the `test` prefix. This is all similar to what you've already seen
    for `XCUITest`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开 `MovieTriviaUITest.swift` 文件，你会注意到 `setUpWithError ()` 和 `tearDown()`
    方法。此外，所有必须执行的所有测试都是带有 `test` 前缀的方法。这与你已经看到的 `XCUITest` 非常相似。
- en: One big difference is that the app is launched explicitly in the setup stage.
    This is because the UI test target is essentially just a different app that can
    interact with your main app's interface. This limitation is very interesting,
    and it's also the reason why it's important to make your app accessible.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很大的不同之处在于，在设置阶段，应用是明确启动的。这是因为 UI 测试目标是本质上与你的主应用界面交互的不同应用。这个限制非常有趣，也是为什么让你的应用易于访问很重要的原因。
- en: 'To start recording a UI test in Xcode, you must start a recording session.
    If you''re editing code in a UI test target, a new interface element is visible
    in the bottom-left corner of your code editor area:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Xcode 中开始记录 UI 测试，你必须开始一个记录会话。如果你正在编辑 UI 测试目标的代码，你的代码编辑器区域左下角将出现一个新的界面元素：
- en: '![Figure 19.9 – Recording interface'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 19.9 – 记录界面'
- en: '](img/Figure_19.09_B14717.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 19.9 – 记录界面](img/Figure_19.09_B14717.jpg)'
- en: Figure 19.9 – Recording interface
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.9 – 记录界面
- en: 'Place your typing cursor inside the `testExample()` method and click the red
    dot. Your app is launched and anything you do is recorded as a UI test and played
    back when you run your tests. If you tap on the label and the activity indicator
    on the loading screen, Xcode produces the following Swift code in the testing
    method:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的输入光标放在 `testExample()` 方法中，并点击红色圆点。你的应用将被启动，你做的任何操作都会被记录为 UI 测试，并在运行测试时播放。如果你在加载屏幕上点击标签和活动指示器，Xcode
    会在测试方法中生成以下 Swift 代码：
- en: '[PRE20]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The UI test you recorded is a set of instructions that are sent to the app.
    In this sample, the test looks for a certain element in the app's UI and calls
    `tap()` on it. This test doesn't do a lot, so it's not particularly useful. To
    make the test more useful, we should let the app know that it should run in a
    special test mode so it can load questions from the JSON file instead of trying
    to load it from the network. To do this, you can send launch arguments to the
    app. Launch arguments can be used by the app to enable or disable certain functionalities.
    You can think of them as variables that are sent to the app when it launches.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你记录的 UI 测试是一组发送到应用的指令。在这个示例中，测试会在应用的 UI 中查找某个元素，并对它调用 `tap()`。这个测试没有做很多事情，所以它并不特别有用。为了让测试更有用，我们应该让应用知道它应该以特殊测试模式运行，这样它就可以从
    JSON 文件中加载问题，而不是尝试从网络上加载。为此，你可以向应用发送启动参数。应用可以使用启动参数来启用或禁用某些功能。你可以把它们看作是当应用启动时发送到应用的变量。
- en: Passing launch arguments to your app
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向你的应用传递启动参数
- en: To switch the loading of questions from the network to a local file for testing,
    you can pass your app a launch argument. This launch argument is then read by
    the app to make sure it loads questions from the JSON file, as you did before
    in the unit tests, rather than attempting to load trivia questions from the server.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在测试中将问题的加载从网络切换到本地文件，你可以向应用传递一个启动参数。然后，应用会读取这个启动参数，以确保它从JSON文件中加载问题，就像您在单元测试中做的那样，而不是尝试从服务器加载Trivia问题。
- en: To prepare for the launch argument and loading the JSON file, make sure you
    add it to the test target, the app target, and the UI test target. You won't need
    it in the UI test target just yet, but you will later, so you might as well add
    it to the UI test target while you're at it.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备启动参数和加载JSON文件，请确保将其添加到测试目标、应用目标和UI测试目标中。目前您不需要在UI测试目标中使用它，但您稍后需要，所以您不妨在此时将其添加到UI测试目标中。
- en: 'In order to pass launch arguments to the app, the `setUpWithError()` method
    in the UI test class should be modified:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将启动参数传递给应用，UI测试类中的`setUpWithError()`方法应该进行修改：
- en: '[PRE21]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `XCUIApplication` instance that represents the app has a `launchArguments`
    property, which is an array of strings. You can add strings to this array before
    launching the app. These strings can then be extracting inside of the app. Modify
    the `loadTriviaQuestions(callback:)` method in `TriviaAPI.swift` as shown in the
    following code snippet:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 代表应用的`XCUIApplication`实例有一个`launchArguments`属性，它是一个字符串数组。在启动应用之前，你可以向这个数组中添加字符串。然后，你可以在应用内部提取这些字符串。按照以下代码片段修改`TriviaAPI.swift`中的`loadTriviaQuestions(callback:)`方法：
- en: '[PRE22]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The preceding code should be inserted above the existing implementation of this
    method. The snippet checks whether we're UI testing by reading the app's launch
    arguments. If the UI testing argument is present, we call the `loadQuestionsFromFile(callback:)`
    method to load the questions from the JSON file instead of loading it from the
    network.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码应插入到该方法现有实现之上。该片段通过读取应用的启动参数来检查我们是否在进行UI测试。如果存在UI测试参数，我们将调用`loadQuestionsFromFile(callback:)`方法从JSON文件中加载问题，而不是从网络上加载。
- en: 'Note that it''s not ideal to perform checks such as the preceding one in your
    production code. It''s often better to wrap a configuration such as this in a
    struct that can be modified easily. You can then use this struct throughout your
    app instead of directly accessing process info throughout your app. An example
    of such a configuration could look like this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在您的生产代码中执行如上所述的检查并不是最佳实践。通常，将此类配置封装在可以轻松修改的结构体中会更好。然后，您可以在整个应用中使用这个结构体，而不是直接在整个应用中访问进程信息。此类配置的一个示例可能如下所示：
- en: '[PRE23]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We won't use this configuration class in this app since it's not needed for
    an app this small. But for your own apps, you might want to implement a configuration
    object regardless of app size since it leads to more maintainable code in the
    long run.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个应用很小，我们不会使用这个配置类。但就您自己的应用而言，无论应用大小如何，您可能都希望实现一个配置对象，因为从长远来看，它会导致代码更加易于维护。
- en: 'If you build the app right now, you should get a compiler error because `loadQuestionsFromFile(callback:)`
    is not implemented in the API class yet. Add the following implementation for
    this method:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在构建应用，您应该会得到一个编译器错误，因为`loadQuestionsFromFile(callback:)`方法尚未在API类中实现。为此方法添加以下实现：
- en: '[PRE24]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It's very similar to the question-loading method in the unit tests; the only
    difference is that it uses a different way to obtain the bundle from which the
    questions are loaded.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这与单元测试中的问题加载方法非常相似；唯一的区别是它使用了一种不同的方式来获取加载问题的程序包。
- en: If you run your UI tests now, they will fail. The reason for this is that when
    the test framework starts looking for the elements it tapped before, they don't
    exist. This results in a test failure because the test can't tap elements that
    don't exist.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在运行UI测试，它们将会失败。原因在于当测试框架开始寻找之前触摸的元素时，这些元素不存在。这导致测试失败，因为测试无法触摸不存在的元素。
- en: The test should be adjusted a bit because tapping a loader isn't very useful
    anyway. It's a lot more useful to make sure that buttons can be tapped and whether
    the UI updates accordingly. To do this, you can write a UI test that waits for
    the question and buttons to appear, taps them, and checks whether the UI has updated
    accordingly. The dummy data will be loaded in this test as well to verify that
    the correct question is shown and the buttons behave as they should.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应该稍作调整，因为点击加载器本身并不很有用。确保按钮可以被点击并且UI相应更新要更有用。为此，你可以编写一个UI测试，等待问题和按钮出现，点击它们，并检查UI是否已相应更新。在这个测试中也将加载模拟数据，以验证正确的问题被显示，并且按钮的行为符合预期。
- en: Making sure the UI updates as expected
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确保UI按预期更新
- en: You're going to write two tests to make sure that the trivia game works as expected.
    The first test will test that the question and the answer buttons appear and that
    they have the correct labels. The second test will make sure that the answers
    can be tapped and that the UI updates accordingly.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 你将编写两个测试来确保Trivia游戏按预期工作。第一个测试将检查问题和答案按钮是否出现以及它们是否有正确的标签。第二个测试将确保答案可以被点击，并且UI会相应更新。
- en: 'Instead of recording the tests, you''ll write them manually. Writing tests
    manually gives you a bit more control and allows you to do much more than just
    tapping on elements. Before you do this, you should open the `Main.storyboard`
    file and give accessibility identifiers to the UI elements. Follow these steps
    to create a UI test manually:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你将手动记录测试，而不是录制它们。手动编写测试可以让你有更多的控制权，并允许你做比仅仅点击元素更多的事情。在这样做之前，你应该打开`Main.storyboard`文件并给UI元素分配可访问性标识符。按照以下步骤手动创建UI测试：
- en: Select the question title and give `UILabel` an identifier of `QuestionTitle`.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择问题标题，并给`UILabel`分配一个`QuestionTitle`标识符。
- en: Select each of the answers and give them the `AnswerA`, `AnswerB`, and `AnswerC`
    identifiers, respectively.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择每个答案，并分别给它们分配`AnswerA`、`AnswerB`和`AnswerC`标识符。
- en: Also, give the next button an accessibility identifier of `NextQuestion`. The
    following screenshot shows what the question title should look like:![Figure 19.10
    – Accessibility identifiers
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，给“下一步”按钮分配一个可访问性标识符`NextQuestion`。以下截图显示了问题标题应该看起来是什么样子：![图19.10 – 可访问性标识符
- en: '](img/Figure_19.10_B14717.jpg)'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_19.10_B14717.jpg)'
- en: Figure 19.10 – Accessibility identifiers
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图19.10 – 可访问性标识符
- en: 'Remove the existing UI test, called `testExample()`, from the `MovieTriviaUITests`
    class and add the one shown in the following code snippet:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`MovieTriviaUITests`类中移除现有的UI测试`testExample()`，并添加以下代码片段：
- en: '[PRE25]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Each element is selected through its accessibility identifier. You can do this
    because the `XCUIApplication` instance we create provides easy access to the UI
    elements.
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个元素都是通过其可访问性标识符选择的。你可以这样做，因为我们在`XCUIApplication`实例中创建的实例提供了对UI元素的简单访问。
- en: Next, a predicate is created that is used to check whether each element exists,
    and an expectation is created. This expectation will continuously evaluate whether
    the predicate is true and once it is, the predicate will be fulfilled automatically.
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，创建一个用于检查每个元素是否存在的前置条件，并创建一个期望。这个期望将不断评估前置条件是否为真，一旦为真，前置条件将自动满足。
- en: Lastly, the UI test will wait for all expectations to be fulfilled.
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，UI测试将等待所有期望得到满足。
- en: To make sure the questions are loaded correctly, you should load the JSON file
    as you did before.
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了确保正确加载问题，你应该像之前那样加载JSON文件。
- en: 'Add the following property to the test so you have a place to store the trivia
    questions:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向测试添加以下属性，以便有一个地方来存储Trivia问题：
- en: '[PRE26]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, add the following code to the top of the `setUp()` method before launching
    the app:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在启动应用之前，将以下代码添加到`setUp()`方法的顶部：
- en: '[PRE27]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This code should look familiar to you because it''s similar to the code you
    already used to load JSON. To make sure that the correct question is displayed,
    update the test method as shown here:'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码对你来说应该很熟悉，因为它与你之前用来加载JSON的代码类似。为了确保正确的问题被显示，按照以下方式更新测试方法：
- en: '[PRE28]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The preceding code calls `validateQuestionIsDisplayed(_:)`, but this method
    is not implemented yet.
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的代码调用了`validateQuestionIsDisplayed(_:)`，但这个方法尚未实现。
- en: 'Add the following implementation:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下实现：
- en: '[PRE29]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This code is run after checking that the UI elements exist because it's run
    after waiting for the expectations we created. The first question is extracted
    from the JSON data, and all of the relevant labels are then compared to the question
    data using a reusable method that validates whether a specific question is currently
    shown.
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码是在检查UI元素存在之后运行的，因为它是在等待我们创建的期望之后运行的。第一个问题是从JSON数据中提取的，然后所有相关的标签都通过一个可重用的方法与问题数据进行比较，该方法验证特定问题是否当前显示。
- en: 'The second test you should add is intended to check whether the game UI responds
    as expected. After loading a question, the test will tap on the wrong answers
    and then makes sure the UI doesn''t show the button to go to the next question.
    Then, the correct answer will be selected, and the test will attempt to navigate
    to the next question. And of course, the test will then validate that the next
    question is shown:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该添加的第二个测试是为了检查游戏UI是否按预期响应。在加载一个问题后，测试将点击错误的答案，然后确保UI不会显示跳转到下一个问题的按钮。然后，选择正确的答案，测试将尝试导航到下一个问题。当然，测试还会验证下一个问题是否显示：
- en: '[PRE30]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding code shows the entire test that validates that the UI responds
    appropriately to correct and incorrect answers. Tests such as these are quite
    verbose, but they save you a lot of manual testing.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码显示了整个测试，该测试验证UI是否正确响应正确和错误的答案。这样的测试相当冗长，但它们可以为你节省大量的手动测试。
- en: When you test your UI like this, you can rest assured that your app will at
    least be somewhat accessible. The beauty in this is that both UI testing and accessibility
    can significantly improve your app quality and each actively aids the other.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当你这样测试你的UI时，你可以放心，你的应用至少在某种程度上是可访问的。这里的美丽之处在于，UI测试和无障碍性都可以显著提高你的应用质量，并且它们都积极地相互帮助。
- en: Testing your UI is mostly a matter of looking for elements in the UI, checking
    their state or availability, and making assertions based on that. In the two tests
    you have written for **MovieTrivia**, we've combined expectations and assertions
    to test both existing UI elements and elements that might not be on screen yet.
    Note that your UI tests will always attempt to wait for any animations to complete
    before the next command is executed. This will make sure that you don't have to
    write asynchronous expectations for any new UI that is added to the screen with
    an animation.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 测试你的UI主要是一个寻找UI元素、检查它们的状态或可用性，并基于此进行断言的过程。在你为**MovieTrivia**编写的两个测试中，我们结合了期望和断言来测试现有的UI元素以及可能尚未出现在屏幕上的元素。请注意，你的UI测试将始终尝试在执行下一个命令之前等待任何动画完成。这将确保你不需要为任何带有动画的新UI编写异步期望。
- en: Summary
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Congratulations! You've made it to the end of this lengthy, information-packed
    chapter. You should know enough about testing and accessibility right now to begin
    exploring testing in greater depth than we have in this chapter.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经走完了这个漫长、信息量大的章节。现在你应该对测试和无障碍性有足够的了解，可以开始探索比本章更深入的测试。
- en: No matter how small or big your app, writing automated tests will ensure that
    your app is of a high quality. More importantly, instead of assuming that something
    works because it worked before, your automated tests will guarantee that it works
    because your tests won't pass if you've broken your code.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你的应用大小如何，编写自动化测试都将确保你的应用具有高质量。更重要的是，你不需要假设某件事因为之前工作过而工作，你的自动化测试将保证它工作，因为如果你的代码出了问题，测试不会通过。
- en: 'In this chapter, you have learned the fundamentals about `XCTest`: when to
    write tests, which type of tests to write (unit and integration), and how to isolate
    tests following the Arrange-Act-Assert pattern. You also learned about code coverage
    and how to m easure how much of your code is being tested. Finally, you learned
    about `XCUITest` and how it can help you to test parts of your UI.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了关于`XCTest`的基础知识：何时编写测试、编写哪种类型的测试（单元和集成），以及如何按照 Arrange-Act-Assert 模式隔离测试。你还学习了代码覆盖率以及如何衡量你的代码被测试的程度。最后，你学习了`XCUITest`以及它如何帮助你测试UI的各个部分。
- en: You also learned that writing testable code sometimes requires you to refactor
    large portions of code. More often than not, these refactoring sessions leave
    your code in a much better state than before. Code that is easy to test is often
    cleaner and more robust than code that is hard to test.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 你还了解到，编写可测试的代码有时需要你对大量代码进行重构。大多数情况下，这些重构会使得你的代码比之前处于更好的状态。易于测试的代码通常比难以测试的代码更干净、更健壮。
- en: Now that you know how to cover your app with tests, in the next chapter, we'll
    look at how you can submit your app to the App Store.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何用测试来覆盖你的应用，在下一章中，我们将探讨如何将你的应用提交到App Store。
