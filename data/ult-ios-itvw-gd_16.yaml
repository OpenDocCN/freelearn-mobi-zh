- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Drilling into App Architecture
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入探讨应用程序架构
- en: In the last chapter, we discussed an important topic – design patterns. We said
    that design patterns are repeatable solutions that solve common problems. We can
    also say that design patterns are the building blocks of our code. Before looking
    at design patterns in this book, we went over Swift, then built upon it with the
    design patterns. Now we are at the top level – the app architecture.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一章，我们讨论了一个重要的话题——设计模式。我们说，设计模式是可重复的解决方案，用于解决常见问题。我们也可以说，设计模式是代码的构建块。在我们这本书中查看设计模式之前，我们先学习了Swift，然后在此基础上应用设计模式。现在我们处于最高层次——应用程序架构。
- en: '**App architecture** is a critical topic in interviews, not just in the architecture
    design interview. Architecture discussions can happen *earlier*, even in the first
    stage. For example, the interviewer can ask about our previous projects and how
    we built them. Understanding the basic terminology and having the skills to use
    them in our interview is essential.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用程序架构**是面试中的一个关键话题，不仅是在架构设计面试中。架构讨论可以发生得更早，甚至在第一阶段。例如，面试官可以询问我们的先前项目以及我们是如何构建它们的。理解基本术语并具备在面试中使用这些术语的技能是至关重要的。'
- en: 'But don’t worry because in this chapter, we will go over the most fundamental
    principles of mobile architecture:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 但别担心，因为在这一章中，我们将介绍移动架构的最基本原理：
- en: We’ll go over the **Separation of Concerns** (**SoC**) principle
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将回顾**关注点分离（Separation of Concerns）**（**SoC**）原则
- en: We’ll cover some *great tips* for separation in our code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将介绍一些关于代码分离的*优秀技巧*
- en: We’ll learn how to *break our app into layers* and how data flows between them
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将学习如何*将我们的应用程序分层*以及数据如何在它们之间流动
- en: We’ll talk about the *design interview*, how to approach it, and how to communicate
    with the interviewer
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将讨论*设计面试*，如何应对它，以及如何与面试官沟通
- en: We’ve almost reached the end of the book, and as you’ll have learned by now,
    I like to start with the basics, as it helps me to explain complex topics much
    better. The basics of app architecture is the SoC principle.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎到达了本书的结尾，正如你现在所学的，我喜欢从基础开始，因为这有助于我更好地解释复杂话题。应用程序架构的基础是SoC原则。
- en: All about the Separation of Concerns principle
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 所有关于关注点分离（Separation of Concerns）原则的内容
- en: I have mentioned the **SoC principle** in the book several times. In fact, I
    mentioned this principle many times in my previous books and articles as well.
    In a way, the SoC principle sits at the heart of many design patterns and architectural
    decisions, and for a pretty good reason. Before we dive into understanding why,
    let’s try to understand what SoC means.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我在书中多次提到了**SoC原则**。事实上，我在我之前的多本书和文章中也多次提到了这个原则。从某种意义上说，SoC原则位于许多设计模式和架构决策的核心，而且有很好的理由。在我们深入理解为什么之前，让我们先尝试理解SoC的含义。
- en: Defining the Separation of Concerns principle
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义关注点分离（Separation of Concerns）原则
- en: We’ll begin with defining what SoC is. SoC refers to organizing code to separate
    different functionalities into different objects and owners. It means that a class
    or a module must have one and only one responsibility.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从定义什么是SoC开始。SoC指的是将代码组织起来，将不同的功能分离到不同的对象和所有者中。这意味着一个类或模块必须只有一个且仅有一个责任。
- en: 'Look at the following example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下例子：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In our code example, we can see that the `processUserData` function has three
    different responsibilities:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码示例中，我们可以看到`processUserData`函数有三个不同的责任：
- en: '*Validate* the user data'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*验证*用户数据'
- en: '*Save* the user data to a file'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*保存*用户数据到文件'
- en: '*Send* a welcome email to the user'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*发送*欢迎邮件给用户'
- en: Notice that the problem starts earlier – the name `processUserData` indicates
    that the function has an unclear responsibility.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，问题开始得更早——名称`processUserData`表明该函数有一个不明确的责任。
- en: Separating the function into three different functions – `validateUserData`,
    `saveUserDataToFile`, and `sendWelcomeEmail` – would be an excellent solution
    to fix the problem of unclearness.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 将功能分为三个不同的函数——`validateUserData`、`saveUserDataToFile`和`sendWelcomeEmail`——将是解决不明确性问题的一个优秀解决方案。
- en: The SoC principle applies to functions and variables – a variable should have
    its own responsibility, just like functions and classes.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: SoC原则适用于函数和变量——一个变量应该有自己的责任，就像函数和类一样。
- en: 'Take the following example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个例子：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, we use `name` to store both first and last names instead of
    creating two dedicated variables – `firstName` and `lastName`. These bad practices
    often happen when trying to save time, but they are error-prone and can lead to
    issues.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`name`来存储名和姓，而不是创建两个专门的变量——`firstName`和`lastName`。这些不良做法通常发生在试图节省时间时，但它们容易出错，可能导致问题。
- en: We can see that the SoC principle is a relevant factor in all levels of development,
    from variables, functions, and classes up to modules.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，SoC原则是开发所有级别的相关因素，从变量、函数和类到模块。
- en: But…why is it so important? Let’s see.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 但是……为什么它如此重要呢？让我们看看。
- en: Explaining the importance of SoC
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释SoC的重要性
- en: Now that we know what the SoC principle is, it is time to understand why it
    is important when designing and writing code.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了SoC原则是什么，是时候了解为什么在设计编写代码时它很重要了。
- en: 'There are a few reasons why we want to have a single responsibility for every
    part of our app and every variable. Let’s name some of them:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个原因让我们希望我们的应用程序的每个部分和每个变量都有单一的责任。让我们列举一些：
- en: '*Making our code more explicit*: When each part focuses on a single task, it
    is easier for us (and others) to understand what’s happening. Clarity is also
    critical with debugging and code investigation – here’s a quote from Brian Kernighan:
    “*Debugging is twice as hard as writing the code in the first place. Therefore
    if you write the code as cleverly as possible, you are, by definition, not smart
    enough to debug it*.” The only way to reduce the gap between writing and debugging
    is clarity.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使代码更明确*：当每个部分都专注于单一任务时，我们（以及其他人）更容易理解正在发生的事情。清晰度在调试和代码调查中也非常关键——这里有一句来自Brian
    Kernighan的名言：“*调试代码比最初编写代码难两倍。因此，如果你尽可能聪明地编写代码，那么按照定义，你不够聪明来调试它*。”减少编写和调试之间的差距的唯一方法是清晰度。'
- en: '*Maintaining the code becomes easier*: We all know writing code is easier than
    maintaining it. One of the reasons is that every code modification we perform
    can create a new bug. Moreover, modifications often change the code structure
    to something we hadn’t planned when writing it. We are reducing both risks when
    isolating tasks to specific functions or classes.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使代码维护更容易*：我们都知道编写代码比维护代码容易。其中一个原因是，我们进行的每一次代码修改都可能创建一个新的错误。此外，修改通常改变代码结构，使其与我们编写代码时没有计划的结构不同。当我们将任务隔离到特定的函数或类时，我们正在减少这两种风险。'
- en: '*Increase our code reusability*: This is another important benefit of the SoC
    principle. When a view, a controller, or a module has a specific task and responsibility,
    it makes it easier to reuse. Let’s take, for instance, a library that handles
    text manipulation. Adding more features and capabilities to that library may increase
    its dependencies and side effects. It also makes it bigger and more error-prone
    since it now handles more responsibilities irrelevant to what we need and may
    collide with another library we want to link. Separating part of the library from
    another is smarter and allows us to work with different libraries like LEGO pieces.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*提高代码的可重用性*：这是SoC原则的另一个重要好处。当一个视图、控制器或模块有一个特定的任务和责任时，它使得重用变得更加容易。让我们以一个处理文本操作的库为例。向该库添加更多功能和能力可能会增加其依赖性和副作用。这也使得它更大，更容易出错，因为它现在处理了更多与我们需求无关的责任，并且可能与我们要链接的另一个库冲突。将库的一部分与另一部分分离更明智，并允许我们像乐高积木一样使用不同的库。'
- en: '*Improve our code testability*: One of the critical aspects of testing is ensuring
    that the outcomes are predictable. When a method is responsible for multiple tasks,
    it might reduce its predictability over time. Think of a function that returns
    a computed value and updates user defaults. Testing the function’s returned value
    can have side effects we don’t want in our test use case. It is better to separate
    that calculation into another function and test it separately.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*提高代码的可测试性*：测试的一个关键方面是确保结果可预测。当一个方法负责多个任务时，它可能会随着时间的推移降低其可预测性。想象一个返回计算值并更新用户默认值的函数。测试函数返回值可能会在我们的测试用例中产生我们不希望出现的副作用。将这个计算分离到另一个函数中并单独测试它更好。'
- en: These benefits are the foundation of any design pattern or architectural decision
    we make when working on our projects. Moreover, SoC is an essential principle
    to follow when approaching an architectural task in an interview. It is the basis
    for any professional discussion we may have during our interviews.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这些好处是我们做出任何设计模式或架构决策的基础。此外，SoC是在面试中处理架构任务时必须遵循的基本原则。它是我们面试期间可能进行的任何专业讨论的基础。
- en: Now, let’s dive a bit deeper and look at some practical tips for the SoC principle.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入一点，看看一些关于SoC原则的实际技巧。
- en: Going practical with the Separation of Concerns principle
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于关注点分离原则的实践
- en: This chapter aims to prepare us for the architectural interview, which may contain
    whiteboard tasks and professional discussions. We understand the SoC principle’s
    importance, but how do we transform it into practical tools?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在为我们准备架构面试，其中可能包含白板任务和专业讨论。我们理解SoC原则的重要性，但如何将其转化为实际工具呢？
- en: The good news is that we reviewed these tools in previous chapters. Let’s list
    them now and add some more.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是我们在前面的章节中已经回顾了这些工具。现在让我们列出它们，并添加一些更多内容。
- en: Having a clear understanding of using UI design patterns
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对使用UI设计模式有清晰的理解
- en: I do not doubt that the topic of MVVM or MVC will be central in your interviews.
    What’s important here is to really understand the different components and their
    responsibility. If we decide to use MVVM for our screen, we must ensure that we
    do it because we need to manage a complex state and not because “this is how things
    are done today.” We must ensure we use the right tool for the right job and that
    each component performs its role.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我不怀疑MVVM或MVC这个话题将在你的面试中占据核心位置。这里重要的是真正理解不同的组件及其职责。如果我们决定为我们的屏幕使用MVVM，我们必须确保我们这样做是因为我们需要管理复杂的状态，而不是因为“这是今天做事的方式。”我们必须确保我们使用正确的工具来完成正确的工作，并且每个组件都发挥其作用。
- en: 'To help understand this, look at *Figure 12**.1*:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助理解这一点，请查看*图12.1*：
- en: '![Figure 12.1 – The most popular UI design patterns in iOS](img/Figure_12.01_B18653.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1 – iOS中最流行的UI设计模式](img/Figure_12.01_B18653.jpg)'
- en: Figure 12.1 – The most popular UI design patterns in iOS
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – iOS中最流行的UI设计模式
- en: In *Figure 12**.1*, we can see that our selection of design patterns is broader
    than just MVC and MVVM. Furthermore, there are no rules here, just best practices.
    Choosing the correct design pattern while considering the different responsibilities
    and separations is essential to implementing the SoC principle.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图12.1*中，我们可以看到我们选择的设计模式不仅限于MVC和MVVM。此外，这里没有规则，只有最佳实践。在考虑不同的职责和分离的情况下选择正确的设计模式对于实现SoC原则至关重要。
- en: For example, VIPER can be incredible for screens that work with many services
    and data entities, and MVP is suitable for a UI that focuses on formatting and
    presentation tweaks.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，VIPER对于处理许多服务和数据实体的屏幕来说可能非常出色，而MVP适合于专注于格式化和展示调整的UI。
- en: VIPER and MVP?
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: VIPER和MVP？
- en: I won’t go over VIPER and MVP because they are less common design patterns in
    iOS development than MVC and MVVM. I recommended reading about these patterns
    and learning the pros and cons, so you have broader knowledge for your interview.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会过多介绍VIPER和MVP，因为它们在iOS开发中不如MVC和MVVM常见。我建议阅读有关这些模式的内容，了解它们的优缺点，以便你在面试中拥有更广泛的知识。
- en: 'Here are some great reads on VIPER and MVP:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些关于VIPER和MVP的精彩阅读材料：
- en: '- VIPER: [https://www.kodeco.com/8440907-getting-started-with-the-viper-architecture-pattern](https://www.kodeco.com/8440907-getting-started-with-the-viper-architecture-pattern)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '- VIPER: [https://www.kodeco.com/8440907-getting-started-with-the-viper-architecture-pattern](https://www.kodeco.com/8440907-getting-started-with-the-viper-architecture-pattern)'
- en: '- MVP: [https://www.javatpoint.com/ios-model-view-presenter](https://www.javatpoint.com/ios-model-view-presenter)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '- MVP: [https://www.javatpoint.com/ios-model-view-presenter](https://www.javatpoint.com/ios-model-view-presenter)'
- en: Using Clean Architecture
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Clean Architecture
- en: Later, in the *Designing app architecture* section, we will discuss app architecture,
    but for now, we are just laying the groundwork, and **Clean Architecture** serves
    as a great foundation. So, what is Clean Architecture?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在*设计应用架构*部分，我们将讨论应用架构，但到目前为止，我们只是在打下基础，**Clean Architecture**是一个很好的基础。那么，什么是Clean
    Architecture呢？
- en: Clean Architecture is an architectural approach emphasizing the SoC principle
    when developing a full-blown app. It involves dividing our project into layers
    – the data layer, presentation layer, business logic layer, and network layer
    – and pushes for clean SoC between the different layers and components. If we
    take that even further, we’re discussing creating various libraries for other
    parts of the project and trying to make our app feel like a giant puzzle. Notice
    that breaking our app into modules has a price – maintaining different modules
    can be difficult and requires planning and sometimes complex interface decisions.
    We must always consider the trade-off between a stable structure and a complicated
    interface.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 清洁架构是一种在开发完整应用程序时强调SoC（单一职责原则）的架构方法。它涉及将我们的项目划分为层——数据层、表示层、业务逻辑层和网络层——并推动不同层和组件之间的清洁SoC。如果我们更进一步，我们就是在讨论为项目的其他部分创建各种库，并试图让我们的应用程序感觉像是一个巨大的拼图。请注意，将我们的应用程序拆分为模块是有代价的——维护不同的模块可能很困难，需要规划，有时还需要做出复杂的接口决策。我们必须始终考虑稳定结构和复杂接口之间的权衡。
- en: Writing small functions
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写小型函数
- en: This is a tip most of us have heard several times before. They say a function
    length should be “less than a screen,” but if we want to go extreme, we can say
    that functions should be *as small as possible*. Breaking a long function into
    two/three functions is a good idea to make our code cleaner, less error-prone,
    and easier to maintain.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个我们大多数人之前都听过几次的建议。他们说函数长度应该是“小于屏幕”，但如果我们想走极端，我们可以说函数应该是*尽可能小*。将一个长函数拆分成两个/三个函数是一个好主意，可以使我们的代码更干净、更少出错、更容易维护。
- en: 'Look at the following code example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的代码示例：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'While this function works, it has multiple responsibilities – it iterates the
    list of items and calculates their prices. To improve the SoC, we can separate
    this code into another function that calculates a single item’s price:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个函数能正常工作，但它有多个职责——它遍历项目列表并计算它们的价格。为了提高SoC（单一职责原则），我们可以将这段代码分离成另一个函数，用于计算单个项目的价格：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now we have a dedicated function to calculate a specific item price, and we
    use it in the original `calculateTotalPrice()` function. Small modification? Well,
    regarding code design, that’s a dramatic change – we can test the calculation
    separately and reuse it in other places in our code. Also, the code is more readable,
    and the `calculateItemPrice()` function name also saves us from explaining what
    `price*Double(quantity)` does and even avoids unneeded comments.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个专门的函数来计算特定项目的价格，并在原始的 `calculateTotalPrice()` 函数中使用它。这是一个小修改吗？好吧，从代码设计的角度来看，这是一个巨大的变化——我们可以单独测试计算，并在代码的其他地方重用它。此外，代码的可读性更高，`calculateItemPrice()`
    函数的名称也使我们免于解释 `price*Double(quantity)` 做了什么，甚至避免了不必要的注释。
- en: It’s interesting to see that even though the original function was small and
    worked well, we can still break it and improve our code in several aspects. That’s
    why the phrase “as small as possible” is much more accurate.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 很有趣的是，即使原始函数很小且工作良好，我们仍然可以将其拆分，并在多个方面改进我们的代码。这就是为什么“尽可能小”这个说法更加准确。
- en: Using descriptive names
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用描述性名称
- en: Descriptive names are always a good idea, but how does naming help us have good,
    clean, and separated code?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 描述性名称总是一个好主意，但命名如何帮助我们拥有良好、清洁和分离的代码？
- en: Naming has a secret power – it forces us to think about the responsibility of
    our function and describe precisely what it does. The attention we give it can
    help us make the right design decisions.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 命名具有一种神秘的力量——它迫使我们思考函数的职责，并精确描述其功能。我们给予它的关注可以帮助我们做出正确的设计决策。
- en: 'Here’s an example – look at the next function interface:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子——看看下一个函数接口：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It’s clear that `getProducts()` is supposed to fetch and return products. But
    what exactly does it do? Does it load the products from local data storage or
    use a network request?
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，`getProducts()` 函数是用来获取并返回产品的。但它具体做了什么？它是从本地数据存储中加载产品还是使用网络请求？
- en: 'Let’s improve the function name:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们改进函数的名称：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, things have become more apparent. We understand exactly what the function
    does. But the issue is unclear – our question about the function’s job helped
    us think deeply about its responsibility. Maybe originally, we came up with the
    following name:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，事情变得更加清晰。我们确切地知道这个函数的作用。但问题仍然不明确——我们对函数工作的疑问帮助我们深入思考其职责。也许最初，我们提出了以下名称：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: That’s a great indication we need to break the function since describing its
    responsibility becomes long and cumbersome.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的迹象，我们需要打破函数，因为描述其责任变得冗长而繁琐。
- en: 'Here are some more examples of good naming:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些好的命名示例：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Coming to the interview process with naming conventions in mind is a good idea.
    And you know what? You’ll have written hundreds (if not more) functions in your
    life. You just need to think back and reflect on them. Maybe we’ll learn something
    using our code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在面试过程中考虑到命名规范是个好主意。你知道吗？你一生中（如果不是更多的话）已经编写了数百（如果不是更多）个函数。你只需要回顾并反思它们。也许我们可以通过我们的代码学到一些东西。
- en: Here’s a disclaimer!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个免责声明！
- en: I know some tips here are not about “architecture.” But these principles and
    recommendations are relevant at any level.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道这里的一些提示不是关于“架构”的。但这些原则和建议在任何级别都是相关的。
- en: SoC lays the groundwork for designing a scalable, modular, and maintainable
    app architecture. We can move on to designing app architecture now that we understand
    that.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，SoC为设计可扩展、模块化和可维护的应用架构奠定了基础。现在我们明白了这一点，我们可以继续设计应用架构。
- en: Designing app architecture
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计应用架构
- en: One of the most common mistakes candidates make when asked about app architecture
    is replying, “MVVM, of course!”
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当被问到应用架构时，应聘者最常见的错误之一是回答，“当然是MVVM！”
- en: So, I want to remind you – MVVM is a design pattern, not an architecture, and
    I want to emphasize the difference.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我想提醒你——MVVM是一种设计模式，而不是架构，我想强调这一点。
- en: A design pattern is a reusable solution to a common problem. Dependency Injection,
    Singletons, and MVVM are examples of design patterns. On the other hand, architecture
    is the general structure of our project that represents our app idea.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式是对常见问题的一种可重用解决方案。依赖注入、单例和MVVM是设计模式的例子。另一方面，架构是我们项目的总体结构，它代表了我们的应用理念。
- en: An excellent real-world example is a building. In this case, the architecture
    describes the number of floors, where the parking lot and the entry door are,
    or what type of roof we have. Design patterns describe *how each apartment is
    built* – the number of rooms in each apartment, the kitchen’s location, and the
    electrical wiring.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一个优秀的现实世界例子是建筑物。在这种情况下，架构描述了楼层数量、停车场和入口门的位置，或者我们有什么类型的屋顶。设计模式描述了*每个公寓是如何建造的*——每个公寓的房间数量、厨房的位置和电气布线。
- en: We can say that each apartment and floor could be designed differently – meaning
    we can use different design patterns for various problems and needs.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说每个公寓和楼层都可以设计得不同——这意味着我们可以为各种问题和需求使用不同的设计模式。
- en: Valuable insights can be gained by drawing parallels with the building industry,
    as there are many similarities between constructing an application and building
    structures.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通过与建筑行业进行类比，我们可以获得有价值的见解，因为构建应用程序和构建结构之间有许多相似之处。
- en: Instead of apartments, we have application screens; instead of a roof and lobby,
    we have application layers.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有公寓，而是有应用程序屏幕；我们没有屋顶和大厅，而是有应用程序层。
- en: So, let’s talk about application layers for a second.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们先谈谈应用层。
- en: Breaking the architecture into application layers
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将架构分解为应用层
- en: The different layers of an app can be a good starting point for describing an
    app architecture. But what are layers?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的不同层可以作为描述应用架构的起点。但什么是层呢？
- en: 'Layers are different components or sets of components that have different concerns
    and app responsibilities. Most apps work with three primary layers:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 层是具有不同关注点和应用责任的不同组件或组件集合。大多数应用程序使用三个主要层：
- en: '**Presentation layer**: Responsible for presenting information using a UI.
    We can find here the different screens and UI components.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表示层**：负责使用UI展示信息。在这里我们可以找到不同的屏幕和UI组件。'
- en: '**Business logic layer**: Responsible for the app logic, rules, and calculations.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**业务逻辑层**：负责应用程序逻辑、规则和计算。'
- en: '**Data layer**: Responsible for storing and retrieving data from local databases
    or other sources.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据层**：负责从本地数据库或其他来源存储和检索数据。'
- en: Layers or tiers?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 层或层？
- en: One common mistake people make when discussing layers is calling them “tiers.”
    The term “tiers” refer to the physical component of an application, while “layers”
    refers to the software component. For example, a tier can be a different computer
    or server responsible for a specific concern. In the case of an iOS app architecture,
    the term “tiers” is irrelevant unless we include the backend side.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当讨论层时，人们常犯的一个错误是将它们称为“层”。术语“层”指的是应用的物理组件，而“层”指的是软件组件。例如，一个层可以是一个负责特定关注点的不同计算机或服务器。在iOS应用架构的情况下，除非包括后端部分，否则“层”这个术语是不相关的。
- en: For a quick reminder, we’ll review design patterns – MVVM is an example of implementing
    a screen as part of the presentation layer. A Singleton is a design pattern that
    can help us to implement a Core Data handler as part of the data layer.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速提醒，我们将回顾设计模式 – MVVM是作为表示层一部分实现屏幕的一个例子。单例（Singleton）是一种设计模式，可以帮助我们将Core Data处理器作为数据层的一部分实现。
- en: 'Let’s see a typical application architecture (*Figure 12**.2*):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个典型应用架构（*图12.2*）：
- en: '![Figure 12.2 – A typical iOS app architecture](img/Figure_12.02_B18653.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图12.2 – 一个典型的iOS应用架构](img/Figure_12.02_B18653.jpg)'
- en: Figure 12.2 – A typical iOS app architecture
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – 一个典型的iOS应用架构
- en: Don’t be intimidated by the diagram in *Figure 12**.2* – remember, *we already
    know* that things need to be reorganized in our heads.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被*图12.2*中的图表吓倒 – 记住，*我们已经知道*我们需要在脑海中重新组织这些信息。
- en: 'We can see that the architecture in *Figure 12**.2* is separated into the three
    different layers we discussed earlier in this section:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，*图12.2*中的架构被划分为我们在本节前面讨论的三个不同层：
- en: We can see that the *presentation* layer has various technologies and design
    patterns.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以看到，*表示层*有各种技术和设计模式。
- en: In the *business logic* layer, we have another design pattern – Façade, which
    is a design pattern that provides a simplified interface to a complex and large
    code block. This is our entry point to the app logic. We can also see the different
    entities we work with in the business layer, the logic of the workflow, and the
    general app logic.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*业务逻辑*层，我们还有另一个设计模式 – 门面模式（Façade），这是一种提供对复杂和大型代码块简化接口的设计模式。这是我们进入应用逻辑的入口点。我们还可以看到我们在业务层中处理的不同实体，工作流程的逻辑，以及一般的应用逻辑。
- en: In the *data layer*, we can see different service agents (connectors) that can
    help us connect to various services. We can also see analytics and helper services.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*数据层*，我们可以看到不同的服务代理（连接器），它们可以帮助我们连接到各种服务。我们还可以看到分析和辅助服务。
- en: Underneath the diagram, we have external services, such as the database, network,
    and configuration. These services are data sources for the data layer.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在图表下方，我们有外部服务，如数据库、网络和配置。这些服务是数据层的数据源。
- en: 'The architecture diagram illustrates another aspect: how the data flows between
    the different layers, which we will see next.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 架构图还说明了另一个方面：数据在不同层之间的流动，我们将在下一节中看到。
- en: Learning about data flow
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解数据流
- en: We understand that if the presentation layer needs to show information to the
    user, we need it to fetch the information from the business layer all the way
    to the data layer and the database. There are cases where we can have an app with
    more layers, such as notification, security, and persistence layers. In that case,
    the data flow gets a little more complex.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们理解，如果表示层需要向用户展示信息，我们需要它从业务层一直获取信息到数据层和数据库。有些情况下，我们可以有一个具有更多层的应用，例如通知、安全和持久化层。在这种情况下，数据流会变得稍微复杂一些。
- en: One interesting question that may arise is whether it’s feasible for a layer
    to bypass another layer while retrieving data.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 可能出现的一个有趣问题是，在检索数据时，一个层是否可以绕过另一个层。
- en: Let’s try to answer that briefly.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要回答一下。
- en: 'When designing a layered system, there are two terms that we need to learn
    – closed and open layers:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当设计分层系统时，有两个术语我们需要了解 – 封闭层和开放层：
- en: '**Closed layer**: A closed layer means the given layer cannot be bypassed to
    one of the layers below it'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**封闭层**：封闭层意味着给定的层不能绕过它下面的任何层'
- en: '**Open layer**: An open layer means the given layer can be passed to any layer
    below it'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开放层**：开放层意味着给定的层可以被传递到它下面的任何层'
- en: It is considered a best practice for a system to be fully closed or open, but
    in most cases, systems have a mixture of open and closed layers.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 被认为是一个系统完全封闭或开放的最好实践，但在大多数情况下，系统都有开放和封闭层的混合。
- en: So, what are the benefits of having a closed or open layer?
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，拥有关闭或开放层有什么好处呢？
- en: 'Look at *Figure 12**.3*:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 看看 *图 12*.*3*：
- en: '![Figure 12.3 – Open and closed layers](img/Figure_12.03_B18653.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.3 – 开放和关闭层](img/Figure_12.03_B18653.jpg)'
- en: Figure 12.3 – Open and closed layers
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.3 – 开放和关闭层
- en: In *Figure 12**.3*, we can see a system architecture with different layers and
    their dependencies. Layer B is closed, meaning layer A can’t access layers D and
    E. On the other hand, layer C is open, meaning that layer A can access layers
    F and G.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 12*.*3* 中，我们可以看到一个包含不同层及其依赖关系的系统架构。层 B 是关闭的，这意味着层 A 无法访问层 D 和 E。另一方面，层
    C 是开放的，这意味着层 A 可以访问层 F 和 G。
- en: The gray-filled layers are those layer A has access to, but it also means that
    these are dependencies.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 灰色填充的层是层 A 可以访问的层，但也意味着这些都是依赖项。
- en: What the open layer does is increase coupling by exposing the top layers to
    more layers. On the other hand, closed layers are harder to maintain and require
    designing an excellent and flexible interface ahead of time. We already know that
    reducing the number of dependencies creates a loose and flexible system, but it
    doesn’t mean we need to create an overly complex design. This is an excellent
    example of a trade-off between simplicity and flexibility.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 开放层通过将顶层暴露给更多层来增加耦合。另一方面，关闭层更难维护，需要提前设计一个优秀且灵活的接口。我们已经知道，减少依赖项可以创建一个松散且灵活的系统，但这并不意味着我们需要创建一个过于复杂的设计。这是一个简单性和灵活性之间权衡的绝佳例子。
- en: What’s more important is to understand these terms when designing architecture
    and making decisions. Building a layered system without thinking at all is probably
    the worst thing we can do.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，在设计架构和做出决策时理解这些术语。完全不思考就构建分层系统可能是我们能做的最糟糕的事情。
- en: Architecture concepts combined with design patterns are the ground for designing
    good architecture for our projects.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 架构概念与设计模式相结合，是我们为项目设计良好架构的基础。
- en: Let’s take a real-world example and review its design together.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个现实世界的例子来一起回顾其设计。
- en: Designing an offline-first system architecture
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计离线优先的系统架构
- en: An **offline-first** system architecture is a typical design many interviewers
    like to discuss. The reason is that this use case involves working with different
    data sources and design patterns to achieve what seems to be an important advantage
    of having a mobile-native app instead of a web app.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**离线优先**的系统架构是许多面试官喜欢讨论的典型设计。原因是这个用例涉及到处理不同的数据源和设计模式，以实现似乎是在移动原生应用而不是网页应用中拥有的一项重要优势。'
- en: The way an offline-first system works is by having two data sources – a *persistent
    store* and *network* communication. On top of that, we have a *sync service* that
    is responsible for updating the persistent store with data from the network. The
    business logic layer that connects the UI to the data layer works directly with
    the persistent store, regardless of the network status.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 离线优先系统的工作方式是通过拥有两个数据源——一个 *持久存储* 和 *网络* 通信。在此基础上，我们有一个 *同步服务* 负责将网络数据更新到持久存储。连接
    UI 和数据层的业务逻辑层直接与持久存储工作，而不考虑网络状态。
- en: 'Let’s see a diagram of such a system (*Figure 12**.4*):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们看看这样一个系统的图示 (*图 12*.*4*):'
- en: '![Figure 12.4: Offline-first system architecture](img/Figure_12.04_B18653.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.4：离线优先的系统架构](img/Figure_12.04_B18653.jpg)'
- en: 'Figure 12.4: Offline-first system architecture'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.4：离线优先的系统架构
- en: Looking at *Figure 12**.4*, we can see that **Articles Handler** on the business
    layer works directly with Core Data *without being aware* of the network layer.
    The sync service is the only component that links the Core Data store and the
    network.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 *图 12*.*4*，我们可以看到业务层上的 **Articles Handler** 直接与 Core Data *无意识* 地工作，而不考虑网络层。同步服务是唯一连接
    Core Data 存储和网络层的组件。
- en: We provide a superb user experience to our users by adding offline loading.
    Besides that, we have an excellent implementation of the SoC principle with a
    decoupled system that makes its components totally disconnected.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加离线加载，我们为用户提供了一个卓越的用户体验。除此之外，我们还实现了卓越的 SoC 原则，通过解耦的系统使得其组件完全独立。
- en: A typical implementation option candidates love to answer with in interviews
    is doing all the sync work in one class in the business logic or even as part
    of the view model. Sure, that option can work great, but this is a very narrow
    point of view when designing a system that can scale and be maintained over time.
    Having a dedicated service that can handle sync logic and maintain it separately
    is perfectly fine.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在面试中，候选人喜欢回答的一个典型实现选项是在业务逻辑或甚至作为视图模型的一部分进行所有同步工作。当然，这个选项可以工作得很好，但在设计一个可以扩展并随时间维护的系统时，这是一个非常狭隘的观点。拥有一个专门的服务来处理同步逻辑并单独维护它是完全可行的。
- en: It is always important to remind ourselves of the responsibility of every component
    in our system and how it communicates with other components. That can lead us
    to a better and clearer design.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 总是提醒自己系统中每个组件的责任以及它们如何与其他组件通信，这可以引导我们设计出更好、更清晰的设计。
- en: The architecture design interview
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构设计面试
- en: The architecture design interview is a crucial step toward our proposal, and
    it requires skills that are much softer and communication oriented.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 架构设计面试是我们提案的关键步骤，它需要的是更多软技能和沟通技巧。
- en: Unlike Swift, Combine, and Core Data questions, the architecture design interview
    requires us to step forward and come up with a more holistic point of view – product
    requirements, backend, scale, analytics, and user experience are all factors we
    need to consider when trying to design a complete system.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 与Swift、Combine和Core Data的问题不同，架构设计面试要求我们向前迈出一步，提出一个更全面的视角——产品需求、后端、扩展性、分析和用户体验都是我们在尝试设计一个完整系统时需要考虑的因素。
- en: The architecture interview, perhaps even more than the other steps in the hiring
    process, is based on communication and meeting expectations. Therefore, we’ll
    start with understanding the interviewer’s point of view.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 架构面试，可能比招聘流程中的其他步骤更注重沟通和满足期望。因此，我们将从理解面试官的视角开始。
- en: Entering the head of our interviewer
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进入面试官的头脑
- en: So, what does our interviewer want from us? What are their expectations?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们的面试官希望我们从他们那里得到什么？他们的期望是什么？
- en: The most important thing to understand here is that the interviewer doesn’t
    care whether your answer is the most optimized solution, or even whether it’s
    right or wrong. The architecture design interview is definitely in another field,
    and the interviewer is looking for something else – they want to see how we *think*,
    approach problems, *manage trade-offs*, and find a path to a decent solution based
    on the product requirements.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要理解的最重要的一点是，面试官并不关心你的答案是否是最优解，甚至不关心它是对是错。架构设计面试绝对属于另一个领域，面试官在寻找的是其他东西——他们想看看我们是怎样**思考**的，如何**处理问题**，**权衡利弊**，以及根据产品需求找到一条通向合理解决方案的路径。
- en: 'Let’s take, for example, the following interview question:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以以下面试问题为例：
- en: “Design the Messages app that comes with iOS.”
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: “设计随iOS附带的消息应用程序。”
- en: 'Obviously, the top app feature would be the messaging screen (“chat”). Here
    is a list of issues we need to tackle when we approach that problem:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，顶级应用程序功能将是消息屏幕（“聊天”）。以下是我们接近该问题时需要解决的问题列表：
- en: What would the UI components we will use be?
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用哪些UI组件？
- en: What is the data model? What will the properties of each message be?
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据模型是什么？每条消息的属性将是什么？
- en: What endpoints do we need? Are we going to implement pagination? If not, how
    do we handle an endless number of messages?
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要哪些端点？我们将实现分页吗？如果不实现，我们将如何处理无限数量的消息？
- en: Do we support offline use? How are we going to do that?
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否支持离线使用？我们将如何实现？
- en: Do we support attachments? How is it going to work?
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否支持附件？它将如何工作？
- en: What if we want to have a group chat?
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想要进行群聊怎么办？
- en: Are we going to support real-time updates?
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将支持实时更新吗？
- en: These are just some of the questions that arise when approaching this task,
    and none are straightforward. It’s our job to find the answers.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是当接近这个任务时出现的一些问题，而且都不是直接的。我们的任务是找到答案。
- en: So, how do we start?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何开始？
- en: Approaching the mission
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接近任务
- en: I’ve interviewed hundreds of candidates in my life, and many of them struggled
    to understand how to approach an architecture interview.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我一生中面试过数百名候选人，其中许多人挣扎于理解如何应对架构面试。
- en: 'It’s not that they didn’t know how to design an app or explain their ideas
    – they didn’t know two things:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 他们并不是不知道如何设计应用程序或解释他们的想法——他们不知道两件事：
- en: What the starting point for the task was
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务开始的起点
- en: What their boundaries were
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们的边界是什么
- en: These two topics are critical to understand for the interview to warm up and
    get on track to a great solution.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个主题对于面试预热并朝着伟大解决方案的方向前进至关重要。
- en: Let’s begin with the starting point – understanding the problem and the scope.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从起点开始——理解问题和范围。
- en: Understanding the problem and the scope
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解问题和范围
- en: The first thing we need to do when approaching a design question is to stop,
    breathe, and try to understand what the interviewer expects from us. Most candidates
    fail at this point because they know they have limited time to answer a question,
    so they rush up to scribble boxes on the whiteboard.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们接近设计问题时，我们首先需要做的是停下来，深呼吸，并试图理解面试官期望我们从我们这里得到什么。大多数候选人在这一点上失败，因为他们知道他们回答问题的时间有限，所以他们急忙在白板上画盒子。
- en: But the design interview represents a real-life task. The interviewer expects
    us to understand the problem before describing what we do.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 但设计面试代表了一个现实生活中的任务。面试官期望我们在描述我们做什么之前理解问题。
- en: 'Let’s return to our problem – designing a messages app similar to the one that
    comes with iOS. Several questions we can ask the interviewer are as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的问题——设计一个类似于iOS自带的消息应用。我们可以向面试官提出以下问题：
- en: Do we have a UI wireframe or must we produce it ourselves?
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有UI线框图，还是必须我们自己制作？
- en: How many screens do we have?
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有多少个屏幕？
- en: Does the design need to contain the backend services as well?
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计是否需要包含后端服务？
- en: Is it cross-platform (including Android or web) or iOS only?
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是跨平台（包括Android或Web）还是仅限iOS？
- en: Do we have a given database scheme, or do we need to plan it ourselves?
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个既定的数据库模式，还是需要我们自己规划？
- en: These are just a few examples, but they can help us understand what we must
    do.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是几个例子，但它们可以帮助我们理解我们必须做什么。
- en: Once we understand the problem and what to do, we can retrieve the product requirements.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们理解了问题和要做什么，我们就可以检索产品需求。
- en: Getting the product requirements
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取产品需求
- en: Unlike with conventional development tasks, we don’t have a **Product Requirements
    Document** (**PRD**) or a kickoff meeting with our product manager in the architecture
    design interview. Instead, we must understand the product requirements and ask
    our interviewers for more information. In fact – this is what the interviewer
    is looking for!
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统开发任务不同，在架构设计面试中，我们没有**产品需求文档**（**PRD**）或与产品经理的开场会议。相反，我们必须理解产品需求并向我们的面试官询问更多信息。事实上——这正是面试官所寻找的！
- en: Imagine the interview is like a dark maze where we navigate with a flashlight
    and unveil more areas, rooms, and paths. Sometimes even the interviewer doesn’t
    know where we will take the interview!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下面试就像一个黑暗的迷宫，我们用手电筒导航并揭示更多区域、房间和路径。有时甚至面试官也不知道我们会把面试引向何方！
- en: 'Going back to the messages app task, there are some questions we can think
    of when starting to design the app. Take the following examples:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 回到消息应用的任务，在设计应用时我们可以考虑一些问题。以下是一些例子：
- en: Do we support offline reading and writing?
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们支持离线阅读和写入吗？
- en: Do we have an integration with the device contacts?
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否与设备联系人集成了？
- en: Do we need to support notifications and real-time chat?
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要支持通知和实时聊天吗？
- en: Can the user edit or delete messages?
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以编辑或删除消息吗？
- en: Do we need to support landscape mode?
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要支持横幅模式吗？
- en: These questions weren’t posed out of curiosity. They impact the design and technical
    decisions we’ll need to make. For example, offline support is crucial to understand
    our data source’s behavior and sync mechanism. Integration with the device contacts
    influences our data model. Real-time chat defines our network methods, and edit
    and delete features affect how we sync information back to the backend.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题并非出于好奇。它们会影响我们需要做出的设计和技术决策。例如，离线支持对于理解我们的数据源行为和同步机制至关重要。与设备联系人的集成影响我们的数据模型。实时聊天定义了我们的网络方法，而编辑和删除功能会影响我们同步信息回后端的方式。
- en: It is perfectly fine not to ask all the questions at first – sometimes we just
    need to start designing to understand what we need to ask, but having a good start
    is a good idea.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在面试开始时，不问所有问题完全可以接受——有时我们只需要开始设计来了解我们需要问什么，但有一个好的开始是个好主意。
- en: But how do we start the design? With wireframes? Or entities? That’s a good
    question, so let’s see.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们如何开始设计？从线框图开始？还是从实体开始？这是一个好问题，让我们看看。
- en: Starting the design
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始设计
- en: The design part is dynamic. No one expects us to have the final answers when
    we start to draw, and we should expect things to change during the interview according
    to new findings and conclusions. Presenting things clearly and in detail can help
    us communicate better with the interviewer and express our thoughts better.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 设计部分是动态的。没有人期望我们在开始绘图时就拥有最终答案，我们应该预料到在面试过程中根据新的发现和结论，事情会发生变化。清晰地详细地展示事物可以帮助我们更好地与面试官沟通，并更好地表达我们的想法。
- en: Going to the whiteboard – wireframes
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 前往白板 – 线框
- en: We are not product designers, and no one expects us to be. But knowing how to
    present our ideas on a whiteboard is crucial for that process. We already discussed
    that in *Chapter 1* when we discussed technical preparations, and now, we understand
    exactly why.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是产品设计师，没有人期望我们成为。但知道如何在白板上展示我们的想法对于这个过程至关重要。我们已经在*第1章*中讨论了技术准备时讨论过这一点，现在我们完全理解为什么。
- en: 'So, how do we start? Some developers like to start with basic UML that describes
    the different entities or classes. But in my opinion, it is better to start with
    wireframing the different screens when it comes to app architecture. Let’s start
    with the messages screen (*Figure 12**.5*):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何开始？一些开发者喜欢从描述不同实体或类的基本UML开始。但在我看来，当涉及到应用程序架构时，最好从绘制不同屏幕的线框开始。让我们从消息屏幕（*图12.5*）开始：
- en: '![Figure 12.5 – The messages screen](img/Figure_12.05_B18653.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图12.5 – 消息屏幕](img/Figure_12.05_B18653.jpg)'
- en: Figure 12.5 – The messages screen
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5 – 消息屏幕
- en: 'Looking at *Figure 12**.5*, we can understand why starting from the UI is better.
    Ignoring the font size and the layout (I’m not a good designer, I know), it looks
    like there are many things we can learn from this wireframe. Let’s list them:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 看看*图12.5*，我们可以理解为什么从UI开始更好。忽略字体大小和布局（我知道我不是一个好的设计师），看起来我们可以从这个线框中学习到很多东西。让我们列出它们：
- en: We’re starting to understand the *different entities*. For example, we see a
    full name and an avatar – that describes the **Contact** entity. We can also see
    that the list shows the contact’s last message, which contains text property,
    so we have another entity here – **Message**.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们开始理解*不同的实体*。例如，我们看到一个全名和一个头像——这描述了**联系人**实体。我们还可以看到列表显示了联系人的最后一条消息，其中包含文本属性，因此我们在这里还有一个**消息**实体。
- en: We see that the list is being sorted by time. That’s maybe the place to dig
    a little bit deeper – do we want to sort it according to the most updated message
    for each contact, or do we want to have an **updatedTime** property of the **Contact**
    entity? This is a classic *trade-off between performance and simplicity*; we should
    discuss it with our interviewer.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们看到列表是按时间排序的。这可能是一个深入挖掘的地方——我们是否希望根据每个联系人的最新消息进行排序，或者我们是否希望为**联系人**实体添加一个**updatedTime**属性？这是一个经典的*性能与简单性之间的权衡*；我们应该与我们的面试官讨论这个问题。
- en: How about the *UI*? We know we are supposed to have some sort of **UITableView**
    here. But do we want to load all the messages into the table view, or do we want
    to support pagination? What design pattern are we going to use here, MVC or MVVM?
    We should decide on the app’s scale, the first-time experience, and common user
    usage.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于*UI*呢？我们知道我们在这里应该有一些**UITableView**。但我们是否希望将所有消息加载到表格视图中，或者我们是否希望支持分页？我们将使用哪种设计模式，MVC还是MVVM？我们应该根据应用程序的规模、首次体验和常见用户使用来做出决定。
- en: Before we continue, I want you to notice something – there are no clear answers,
    just considerations and trade-offs. I asked questions but haven’t given you any
    answers because the questions we ask ourselves and the interviewer are part of
    the process. That’s the place to show that we understand there are gray areas
    where we need to make the decisions.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我想让你注意一点——没有明确的答案，只有考虑和权衡。我提出了问题，但还没有给你任何答案，因为我们所提出的问题和面试官的问题是过程的一部分。这就是我们展示我们理解存在灰色区域，我们需要在这里做出决策的地方。
- en: So, are we just using the whiteboard to draw a UI? Not necessarily – let’s continue.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们只是在用白板绘制UI吗？不一定——让我们继续。
- en: Adding entities and backend services
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加实体和后端服务
- en: It’s [*Chapter 12*](B18653_12.xhtml#_idTextAnchor360), and we know that an app
    is more than just the UI. But is one screen enough to start designing the other
    parts? Definitely, yes!
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这是[*第12章*](B18653_12.xhtml#_idTextAnchor360)，我们知道一个应用程序不仅仅是UI。但一个屏幕就足够开始设计其他部分了吗？当然，是的！
- en: 'Let’s add entities (*Figure 12**.6*):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加实体（*图12.6*）：
- en: '![Figure 12.6 – Initial entities for the message’s app](img/Figure_12.06_B18653.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图12.6 – 消息应用程序的初始实体](img/Figure_12.06_B18653.jpg)'
- en: Figure 12.6 – Initial entities for the message’s app
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6 – 消息应用程序的初始实体
- en: Writing the entities on the whiteboard sounds like a technical task, but similar
    to wireframing, it can help us find more exciting things about our app.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在白板上写下实体听起来像是一项技术任务，但与线框图类似，它可以帮助我们发现关于我们应用程序的更多有趣之处。
- en: For example, we mentioned a URL for a contact avatar – this means we need to
    create some kind of image downloader service and a caching mechanism based on
    that URL. As a result, the *image downloader* can be added to our drawing on the
    whiteboard.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们提到了联系人头像的URL——这意味着我们需要基于该URL创建某种类型的图像下载服务和一个缓存机制。结果，*图像下载器*可以添加到我们在白板上的绘制中。
- en: Look what we’ve achieved based on a single entity’s property!
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们基于单个实体属性所取得的成就！
- en: But the actual value of drawing the entities is when we start thinking about
    their relationships. We have `Contact` and `Message`. But what describes a conversation
    with a contact? Maybe we need to create another entity named `MessagesThread`.
    And if we have a `MessagesThread` entity, what would its properties be?
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 但实际绘制实体的价值在于我们开始思考它们之间的关系。我们有`Contact`和`Message`。但什么描述了与联系人的对话？也许我们需要创建另一个名为`MessagesThread`的实体。如果我们有一个`MessagesThread`实体，它的属性会是什么？
- en: At this stage, things become a little bit more complex, because thinking about
    the connections brings up more questions – for example, do we support group messaging?
    The answer sets the relation type between `MessageThread` and `Contact`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，事情变得稍微复杂一些，因为思考连接会引发更多问题——例如，我们是否支持群组消息？答案确定了`MessageThread`和`Contact`之间的关系类型。
- en: 'Drawing the entities next to our wireframes creates a back-and-forth process
    that helps us shape our design and make it more complete. Each decision leads
    to more questions, leading to more design decisions. It also sets the path to
    our next task: designing the interaction with our backend.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的线框图旁边绘制实体创建了一个来回的过程，这有助于我们塑造设计并使其更加完整。每个决策都会引发更多问题，进而导致更多设计决策。它还为我们下一个任务设定了路径：设计与后端交互。
- en: Adding network calls
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加网络调用
- en: Now that we have the basic UI wireframes and entities, planning how we will
    work with our backend service should be easier. Remember that the UI and entities
    are still part of our app learning stage – now we understand better what we need
    to do. The different endpoints define the user experience and the design patterns
    we will use, and that’s where we can really work on our app architecture, as we
    learned in this chapter.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了基本的UI线框和实体，规划我们将如何与后端服务合作应该更容易。记住，UI和实体仍然是我们的应用程序学习阶段的一部分——现在我们更好地理解了我们需要做什么。不同的端点定义了用户体验和我们将使用的设计模式，这正是我们可以真正着手构建应用程序架构的地方，正如我们在本章中学到的。
- en: 'Let’s see what endpoints we need for the main screen:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们需要为主屏幕提供哪些端点：
- en: '**GET/threads**: To retrieve the list of all the threads'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GET/threads**：检索所有线程的列表'
- en: '**POST/thread**: To create a new messages thread'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**POST/thread**：创建新的消息线程'
- en: 'Generally, when working with a list of information, it is common to include
    these two endpoints as a part of our design. But there are more things to consider
    here:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当处理信息列表时，将这两个端点作为我们设计的一部分是很常见的。但这里还有更多需要考虑的事情：
- en: How are the threads sorted? Do we get them sorted from the server, or do we
    sort them by a specific property?
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程是如何排序的？我们是直接从服务器获取排序好的线程，还是根据特定的属性进行排序？
- en: Do we have a pagination mechanism? Or do we fetch all threads and use an incremental
    update sync?
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否有分页机制？或者我们获取所有线程并使用增量更新同步？
- en: Do we need the **POST** request at this stage? Or can we do that only after
    the first message we send?
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在这个阶段需要**POST**请求吗？或者我们只能在发送第一条消息之后才能这样做？
- en: 'The endpoints also help us to define the app architecture. They answer important
    questions about the UI layer and its design patterns (MVC/MVVM). But they also
    help us understand our data layer and the different services we will need. The
    following are examples:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 端点也帮助我们定义应用程序架构。它们回答有关UI层及其设计模式（MVC/MVVM）的重要问题。但它们也帮助我们理解我们的数据层和我们将需要的不同服务。以下是一些示例：
- en: Core Data handler
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心数据处理器
- en: Image downloader
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图片下载器
- en: Sync service
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步服务
- en: Network service and real-time management
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络服务和实时管理
- en: If we continue adding more endpoints to the rest of the screens, we will learn
    more about our app and get more answers.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们继续向其他屏幕添加更多端点，我们将了解更多关于我们的应用，并获得更多答案。
- en: Designing an app architecture is a discovery process. Nothing is clear at the
    beginning, and communicating the process to find the answers is essential. That’s
    why our next topic is extremely important – our communication with the interviewer.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 设计应用架构是一个发现过程。一开始没有什么事情是清晰的，向面试官传达寻找答案的过程是至关重要的。这就是为什么我们的下一个主题极其重要——我们与面试官的沟通。
- en: Communicating with the interviewer
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与面试官沟通
- en: As mentioned earlier in this section, many candidates believe their primary
    goal in the architecture design interview is to provide the most optimal solution
    to the problem they just received. But the truth is that the goal is for the interviewer
    to see how we think and offer a decent solution to problems that might come up.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节前面所述，许多候选人认为他们在架构设计面试中的主要目标是提供他们刚刚收到的最优化解决方案。但事实是，目标是让面试官看到我们的思考方式，并为可能出现的难题提供一个合理的解决方案。
- en: Therefore, effective communication with the interviewer is crucial to be successful
    in this kind of interview. Some of our most critical soft skills are being tested
    here!
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，与面试官的有效沟通对于在这种面试中取得成功至关重要。我们的一些最重要的软技能在这里被测试！
- en: 'Let’s go over some tips to help us focus on what matters:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一些有助于我们关注重要事项的建议：
- en: '*Listen to the interviewer*: That’s obvious, right? Of course we are going
    to listen to the interviewer! But I mean, *really* listen to them. First, because
    the task requirements and the scope are very important to be precise on what we
    do. Moreover, there are valuable tips our interviewer will give us that can help
    us with our goal.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*倾听面试官*：这显然是显而易见的，对吧？当然，我们会倾听面试官！但我意思是，*真正地*倾听他们。首先，因为任务要求和范围非常重要，我们需要精确地了解我们在做什么。此外，我们的面试官会给出一些宝贵的建议，这可以帮助我们实现目标。'
- en: '*Clarify doubts*: If you are uncertain about your decision, you must communicate
    this to the interviewer. Interviewers need to see that candidates see things in
    shades of gray and not just black and white, but it is also a way to get clues
    or discuss things with the interviewer.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*澄清疑问*：如果你对自己的决定不确定，你必须向面试官传达这一点。面试官需要看到候选人看到的是灰色而不是黑白，这也是一种获取线索或与面试官讨论事情的方式。'
- en: '*Be confident*: I know it sounds like it contradicts the previous point, but
    it doesn’t. It’s true that when we have doubts, we need to communicate them, but
    when we are confident about something, we must show it. Self-confidence is an
    essential factor in these interviews.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自信*：我知道这听起来似乎与前面的观点相矛盾，但它并不矛盾。当我们有疑问时，我们需要传达它们，但当我们对某事有信心时，我们必须表现出来。自信是这些面试中的一个关键因素。'
- en: '*Think out loud*: We know what we want to achieve with our design, and we even
    drew it on the whiteboard. But what is clear to us is not always apparent to the
    other person in the room. Thinking out loud can help us explain what we’re doing
    more clearly and help the interviewer understand the fantastic architecture we’ve
    just designed.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*大声思考*：我们知道我们想要通过我们的设计实现什么目标，我们甚至已经在白板上画出了它。但对我们来说明显的事情，并不总是对房间里其他人明显。大声思考可以帮助我们更清楚地解释我们在做什么，并帮助面试官理解我们刚刚设计的出色架构。'
- en: '*Use the correct terminology*: In this book, I have been strict about the different
    terms used – method versus function, design pattern versus architecture, and more.
    Using the correct terminology in these interviews is essential, not just to appear
    professional; it also makes our explanations much more evident to our interviewer.
    Not all interviewers are strict about it – but that doesn’t mean we shouldn’t
    be.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用正确的术语*：在这本书中，我对所使用的不同术语非常严格——方法与函数、设计模式与架构等等。在这些面试中使用正确的术语至关重要，这不仅是为了显得专业；这也使得我们的解释对面试官来说更加清晰。并非所有面试官都对此很严格——但这并不意味着我们不应该这样做。'
- en: '*Be open to feedback*: The interviewer may provide feedback or suggestions
    during the interview. Sometimes it is a clue for the direction we can take, or
    sometimes it’s because we went out of scope. What happens many times, in this
    case, is that candidates lose their self-confidence and close themselves off,
    finding it difficult to accept that feedback. We should put our egos aside when
    we enter the design interview (actually, we should put our egos aside all the
    time) and use the interviewer’s feedback to improve our answers. Feedback during
    the interview doesn’t mean we failed – it means that we have a chance to provide
    a better solution.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开放接受反馈*：面试官可能在面试过程中提供反馈或建议。有时这可能是我们可采取方向的线索，有时则是因为我们超出了范围。在这种情况下，许多时候，候选人会失去自信并封闭自己，难以接受反馈。当我们进入设计面试时（实际上，我们应该始终放下自我），应该利用面试官的反馈来改进我们的回答。面试过程中的反馈并不意味着我们失败了——这意味着我们有提供更好解决方案的机会。'
- en: It seems like we are being tested on how we communicate and express ourselves,
    but that’s the reality! The interviewer wants to see what it is like working with
    us, discussing design issues, and having architecture debates. That’s where our
    personality stands out.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们正在接受如何沟通和表达自己的测试，但这正是现实！面试官想了解与我们合作、讨论设计问题和进行架构辩论的情况。这就是我们个性凸显的地方。
- en: Summary
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The architecture design interview is the highlight of the hiring process. It
    incorporates extensive knowledge of design patterns, architectures, iOS user experience,
    and critical soft skills such as planning, communication, and presentation.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 架构设计面试是招聘过程中的亮点。它融合了广泛的设计模式、架构、iOS用户体验以及关键的软技能，如规划、沟通和演示。
- en: However, at this point, we should be in a position where we know how to crack
    the interview with several primary steps.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，到目前为止，我们应该处于一个知道如何通过几个主要步骤通过面试的位置。
- en: In this chapter, we’ve learned about the SoC and how it applies to iOS architecture,
    including function size and naming. We’ve learned about application layers and
    data flows and even discussed an excellent example of an architecture for offline
    working. And finally, we discussed the architecture design interview – how to
    approach it and communicate with the interviewer.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了SoC及其在iOS架构中的应用，包括功能大小和命名。我们了解了应用层和数据流，甚至讨论了一个关于离线工作架构的优秀示例。最后，我们讨论了架构设计面试——如何应对以及与面试官沟通。
- en: 'In the next (and final!) chapter, we will discuss the most practical step in
    the interview: the live coding interview and the home assessment. All hiring processes
    now include this step, and it’s our job to be ready for the unknown.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章（也是最后一章）中，我们将讨论面试中最实用的步骤：现场编码面试和家庭评估。现在所有的招聘流程都包括这一步骤，我们的任务是准备好应对未知。
