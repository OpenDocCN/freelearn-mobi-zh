- en: '*Chapter 6*: Functions and Closures'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第6章*：函数和闭包'
- en: At this point, you can write reasonably complex programs that can make decisions
    and repeat instruction sequences. You can also store data for your programs using
    collection types. As the programs you write grow in size and complexity, it will
    become harder to comprehend what they do.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可以编写合理复杂的程序，这些程序可以做出决策并重复指令序列。你还可以使用集合类型存储程序数据。随着你编写的程序在大小和复杂性上增长，理解它们所做的工作将变得更加困难。
- en: To make large programs easier to understand, Swift allows you to create **functions**,
    which lets you combine a number of instructions together and execute them by calling
    a single name. You can also create **closures**, which lets you combine a number
    of instructions together without a name and assign it to a constant or variable.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使大型程序更容易理解，Swift 允许你创建**函数**，这让你可以将多个指令组合在一起，并通过调用单个名称来执行它们。你还可以创建**闭包**，这让你可以将多个指令组合在一起，而不需要名称，并将其分配给常量或变量。
- en: By the end of this chapter, you'll have learned about functions, nested functions,
    functions as return types, functions as arguments and the `guard` statement. You'll
    also have learned how to create and use closures.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解函数、嵌套函数、作为返回类型的函数、作为参数的函数以及`guard`语句。你还将了解如何创建和使用闭包。
- en: 'The following topics will be covered:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 以下将涵盖以下主题：
- en: Understanding functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解函数
- en: Understanding closures
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解闭包
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The Xcode playground for this chapter is in the `Chapter06` folder of the code
    bundle for this book, which can be downloaded here:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的Xcode游乐场位于本书代码包的`Chapter06`文件夹中，可以在此处下载：
- en: '[https://github.com/PacktPublishing/iOS-15-Programming-for-Beginners-Sixth-Edition](https://github.com/PacktPublishing/iOS-15-Programming-for-Beginners-Sixth-Edition)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/iOS-15-Programming-for-Beginners-Sixth-Edition](https://github.com/PacktPublishing/iOS-15-Programming-for-Beginners-Sixth-Edition)'
- en: 'Check out the following video to see the code in action:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 观看以下视频，看看代码是如何运行的：
- en: '[https://bit.ly/3o2MYTs](https://bit.ly/3o2MYTs)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://bit.ly/3o2MYTs](https://bit.ly/3o2MYTs)'
- en: If you wish to start from scratch, create a new playground and name it `FunctionsAndClosures`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望从头开始，创建一个新的游乐场，并将其命名为`FunctionsAndClosures`。
- en: You can type in and run all of the code in this chapter as you go along. Let's
    start by learning about functions.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在进行过程中输入并运行本章中的所有代码。让我们先学习函数。
- en: Understanding functions
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解函数
- en: 'Functions are useful for encapsulating a number of instructions that collectively
    perform a specific task, for example:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 函数对于封装执行特定任务的一组指令非常有用，例如：
- en: Calculating the 10% service charge for a meal at a restaurant.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算餐厅餐费的10%服务费。
- en: Calculating the monthly payment for a car that you wish to purchase.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算你希望购买的汽车的月供。
- en: 'Here''s what a function looks like:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个函数的样子：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Every function has a descriptive name. You can define one or more values that
    the function takes as input, known as **parameters**. You can also define what
    the function will output when done, known as its **return type**. Both parameters
    and return types are optional.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数都有一个描述性的名称。你可以定义一个或多个作为输入的函数值，这些值被称为**参数**。你还可以定义函数完成后的输出类型，这被称为其**返回类型**。参数和返回类型都是可选的。
- en: 'You "call" a function''s name to execute it. This is what a function call looks
    like:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你“调用”函数的名称来执行它。这就是函数调用的样子：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You provide input values (known as **arguments**) that match the type of the
    function's parameters.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你提供与函数参数类型匹配的输入值（称为**参数**）。
- en: Important Information
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 重要信息
- en: To learn more about functions, visit [https://docs.swift.org/swift-book/LanguageGuide/Functions.html](https://docs.swift.org/swift-book/LanguageGuide/Functions.html).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于函数的信息，请访问[https://docs.swift.org/swift-book/LanguageGuide/Functions.html](https://docs.swift.org/swift-book/LanguageGuide/Functions.html)。
- en: Let's see how you can create a function to calculate a service charge in the
    next section.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看看如何创建一个计算服务费的函数。
- en: Creating a function
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个函数
- en: In its simplest form, a function just executes some instructions, and does not
    have any parameters or return types. You'll see how this works by writing a function
    to calculate the service charge for a meal. The service charge should be 10% of
    the meal cost.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单的形式中，函数只是执行一些指令，没有参数或返回类型。你将通过编写一个计算餐费服务费的函数来了解这是如何工作的。服务费应该是餐费的10%。
- en: 'Add the following code to your playground to create and call this function
    and click the **Play/Stop** button to run it:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到您的游乐场中，以创建并调用此函数，然后点击 **播放/停止** 按钮运行它：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You've just created a very simple function named `serviceCharge()`. All it does
    is calculate the 10% service charge for a meal costing $50, which is `50 / 10`,
    returning `5`. You then call this function using its name. You'll see `Service
    charge is 5` displayed in the Debug area.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚创建了一个名为 `serviceCharge()` 的非常简单的函数。它所做的只是计算价值为 $50 的餐费的 10% 服务费，即 `50 / 10`，返回
    `5`。然后您使用其名称调用此函数。您将在调试区域看到 `Service charge is 5`。
- en: This function is not very useful because `mealCost` is always `50` every time
    you call this function, and the result, `5`, is only printed in the Debug area
    and can't be used elsewhere in your program. Let's add some parameters and a return
    type to this function to make it more useful.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数不太有用，因为每次调用此函数时 `mealCost` 总是 `50`，结果 `5` 只在调试区域打印，并且不能在您的程序的其他地方使用。让我们添加一些参数和一个返回类型来使这个函数更有用。
- en: 'Modify your code as shown:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下所示修改您的代码：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is much better. Now, you can set the meal cost when you call the `serviceCharge(mealCost:)`
    function, and the result can be assigned to a variable or constant. It looks a
    bit awkward, though. You should try to make function signatures in Swift read
    like an English sentence, as this is considered best practice. Let's see how to
    do that in the next section, where you'll use **custom labels** to make your function
    more English-like and easier to understand.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这要好得多。现在，您可以在调用 `serviceCharge(mealCost:)` 函数时设置餐费，并将结果分配给变量或常量。尽管如此，它看起来有点别扭。您应该尝试使
    Swift 中的函数签名读起来像英语句子，因为这被认为是最佳实践。让我们在下一节中看看如何做到这一点，您将使用**自定义标签**使您的函数更具英语风格且更容易理解。
- en: Using custom argument labels
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自定义参数标签
- en: Note that the `serviceCharge(mealCost:)` function is not very English-like.
    You can add a custom label to the parameter to make the function easier to understand.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`serviceCharge(mealCost:)` 函数不太像英语。您可以为参数添加自定义标签，使函数更容易理解。
- en: 'Modify your code as shown:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下所示修改您的代码：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The function works exactly the same as before, but to call it, you use `serviceCharge(forMealPrice:)`.
    This sounds more like English and makes it easier to figure out what the function
    does.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的工作方式与之前完全相同，但为了调用它，您使用 `serviceCharge(forMealPrice:)`。这听起来更像英语，并使您更容易了解函数的功能。
- en: In the next section, you'll learn how to use several smaller functions within
    the bodies of other functions, and these are known as **nested functions**.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将学习如何在其他函数体内使用几个较小的函数，这些函数被称为**嵌套函数**。
- en: Using nested functions
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用嵌套函数
- en: It's possible to have a function within the body of another function, and these
    are called nested functions. A nested function can use the variables of the enclosing
    function. Let's see how nested functions work by writing a function to calculate
    monthly payments for a loan.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个函数体内有一个函数是可能的，这些函数被称为嵌套函数。嵌套函数可以使用封装函数的变量。让我们通过编写一个计算贷款月供的函数来了解嵌套函数是如何工作的。
- en: 'Type in and run the following code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 输入并运行以下代码：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, there are three functions within `calculateMonthlyPayments (carPrice:downPayment:interestRate:paymentTerm:)`.
    Let''s take a look at them:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`calculateMonthlyPayments (carPrice:downPayment:interestRate:paymentTerm:)`
    中有三个函数。让我们来看看它们：
- en: The first nested function, `loanAmount()`, calculates the total loan amount
    by subtracting `downPayment` from `carPrice`. It returns `50000 - 5000` = `45000`.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个嵌套函数 `loanAmount()` 通过从 `carPrice` 中减去 `downPayment` 来计算总贷款金额。它返回 `50000
    - 5000` = `45000`。
- en: The second nested function, `totalInterest()`, calculates the total interest
    amount incurred for the payment term by multiplying `interestRate` with `paymentTerm`.
    It returns `3.5 * 7` = `24.5`.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个嵌套函数 `totalInterest()` 通过将 `interestRate` 乘以 `paymentTerm` 来计算支付期限中产生的总利息金额。它返回
    `3.5 * 7` = `24.5`。
- en: The third nested function, `numberOfMonths()`, calculates the total number of
    months in the payment term by multiplying `paymentTerm` with `12`. It returns
    `7 * 12` = `84`.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个嵌套函数 `numberOfMonths()` 通过将 `paymentTerm` 乘以 `12` 来计算支付期限中的总月份数。它返回 `7 *
    12` = `84`。
- en: Note that the three nested functions all use the variables of the enclosing
    function. The value returned is `( 45000 + ( 45000 * 24.5 / 100 ) ) / 84` = `666.96`,
    which is the amount you have to pay monthly for 7 years to buy this car.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这三个嵌套函数都使用了封装函数的变量。返回的值是 `( 45000 + ( 45000 * 24.5 / 100 ) ) / 84` = `666.96`，这是您为了购买这辆车在7年内每月需要支付的金额。
- en: As you have seen, functions in Swift are similar to functions in other languages,
    but they have a cool feature. Functions are **first-class types** in Swift, so
    they can be used as parameters and return types. Let's see how that is done in
    the next section.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Swift 中的函数与其他语言中的函数类似，但有一个酷炫的功能。函数在 Swift 中是 **一等类型**，因此它们可以用作参数和返回类型。让我们在下一节中看看这是如何实现的。
- en: Using functions as return types
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用函数作为返回类型
- en: 'A function can return another function as its return type. Type in and run
    the following code to create a function that generates a value for Pi:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数可以作为其返回类型返回另一个函数。输入并运行以下代码以创建一个生成 Pi 值的函数：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `makePi()` function's return type is a function that has no parameters and
    the return type is `Double`. `generatePi()` is a function that has no parameters
    and the return type is `Double`, and will be the function that is returned. So,
    `pi` will be assigned `generatePi()` and will return `22.0/7.0` when called. `3.142857142857143`
    will be printed in the Debug area.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`makePi()` 函数的返回类型是一个没有参数且返回类型为 `Double` 的函数。`generatePi()` 是一个没有参数且返回类型为 `Double`
    的函数，它将是返回的函数。因此，`pi` 将被分配给 `generatePi()`，并在调用时返回 `22.0/7.0`。`3.142857142857143`
    将在调试区域打印。'
- en: Let's see how a function can be used as a parameter for another function in
    the next section.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个函数如何作为另一个函数的参数在下一节中使用。
- en: Using functions as parameters
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用函数作为参数
- en: 'A function can take a function as a parameter. Type in and run the following
    code to create a function that determines if a number meeting a certain condition
    exists within a list of numbers:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数可以将另一个函数作为参数。输入并运行以下代码以创建一个函数，该函数用于确定一个满足特定条件的数字是否存在于数字列表中：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`isThereAMatch(listOfNumbers:condition:)` has two parameters; an array of integers
    and a function. The function provided as an argument must take an integer value
    and return a Boolean value. `oddNumber(number:)` takes an integer and returns
    `true` if the number is an odd number, which means it can be an argument for the
    second parameter. `numbersList`, an array containing an odd number, is used as
    the argument for the first parameter. Since `numbersList` contains an odd number,
    `isThereAMatch(listOfNumbers:condition:)` will return `true` when called.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`isThereAMatch(listOfNumbers:condition:)` 有两个参数；一个整数数组和函数。提供的函数作为参数必须接受一个整数值并返回一个布尔值。`oddNumber(number:)`
    接受一个整数并返回 `true` 如果该数字是奇数，这意味着它可以作为第二个参数的参数。包含奇数的 `numbersList` 数组用作第一个参数的参数。由于
    `numbersList` 包含奇数，当调用 `isThereAMatch(listOfNumbers:condition:)` 时，它将返回 `true`。'
- en: In the next section, you'll see how you can perform an early exit on a function
    if the arguments used are not suitable.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将看到如果使用的参数不适合，如何在函数上执行早期退出。
- en: Using a guard statement to exit a function early
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `guard` 语句提前退出函数
- en: If there is something wrong with the input data, it is useful to be able to
    exit a function early. Let's say you need a function to be used in an online purchasing
    terminal. This function will calculate the remaining balance of a debit or credit
    card when you buy something. The price of the item that you want to buy is entered
    in a text field. The value in the text field is converted into an integer so that
    you can calculate the remaining card balance.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入数据有问题，能够提前退出函数是有用的。比如说，你需要一个函数用于在线购买终端。这个函数将在你购买东西时计算借记卡或信用卡的剩余余额。你想要购买的商品价格输入在一个文本字段中。文本字段中的值被转换为整数，以便你可以计算剩余的卡余额。
- en: 'Type in and run the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 输入并运行以下代码：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You should see this result in the Debug area:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在调试区域看到以下结果：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Let's see how this function works. The first line in the function body is a
    `guard` statement. This checks to see whether a condition is `true`; if not, it
    exits the function. Here, it is used to check and see whether the user entered
    a valid price in the online purchasing terminal. If so, the value can be converted
    successfully into an integer, and you can calculate the remaining card balance.
    Otherwise, the `else` clause in the `guard` statement is executed. An error message
    is printed to the Debug area and the unchanged card balance is returned.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个函数是如何工作的。函数体内的第一行是一个 `guard` 语句。这个语句检查一个条件是否为 `true`；如果不是，它将退出函数。在这里，它被用来检查用户是否在在线购买终端中输入了有效的价格。如果是，该值可以成功转换为整数，并且你可以计算剩余的卡余额。否则，`guard`
    语句中的 `else` 子句将被执行。错误信息将在调试区域打印，并且将返回未更改的卡余额。
- en: 'For `print(buySomething(itemValueEntered: "10", cardBalance: 50))`, the item
    price is deducted successfully from the card balance, and `40` is returned.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '对于 `print(buySomething(itemValueEntered: "10", cardBalance: 50))`，商品价格成功从卡余额中扣除，并返回
    `40`。'
- en: 'For `print(buySomething(itemValueEntered: "blue", cardBalance: 50))`, the `guard`
    statement''s condition fails and its `else` clause is executed, resulting in an
    error message being printed to the Debug area and `50` being returned.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '对于 `print(buySomething(itemValueEntered: "blue", cardBalance: 50))`，`guard`
    语句的条件失败，其 `else` 子句被执行，导致错误信息被打印到调试区域，并返回 `50`。'
- en: You now know how to create and use functions. You have also seen how to use
    custom argument labels, nested functions, functions as parameters or return types,
    and the `guard` statement.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何创建和使用函数。你还看到了如何使用自定义参数标签、嵌套函数、函数作为参数或返回类型以及 `guard` 语句。
- en: Now, let's look at closures. Like functions, closures allow you to combine a
    number of instructions together, but closures do not have names and can be assigned
    to a constant or a variable. You'll see how they work in the next section.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看闭包。与函数一样，闭包允许你将多个指令组合在一起，但闭包没有名字，并且可以被分配给一个常量或变量。你将在下一节中看到它们是如何工作的。
- en: Understanding closures
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解闭包
- en: A closure, like a function, contains a sequence of instructions and can take
    arguments and return values. However, closures don't have names. The sequence
    of instructions in a closure is surrounded by curly braces (`{ }`), and the `in`
    keyword separates the arguments and return type from the closure body.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包，就像函数一样，包含一系列指令，可以接受参数并返回值。然而，闭包没有名字。闭包中的指令序列被大括号（`{ }`）包围，`in` 关键字将参数和返回类型与闭包体分开。
- en: Closures can be assigned to a constant or variable, so they're handy if you
    need to pass them around inside your program. For instance, let's say you have
    an app that downloads a file from the internet, and you need to do something to
    the file once it has finished downloading. You can put a list of instructions
    to process the file inside a closure and have your program execute it once the
    file finishes downloading. You'll see how closures are used in [*Chapter 16*](B17469_16_Final_VK_ePub.xhtml#_idTextAnchor223),
    *Getting Started with MapKit*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包可以被分配给一个常量或变量，所以当你需要在程序内部传递它们时，它们非常有用。例如，假设你有一个应用程序从互联网上下载文件，并且你需要在文件下载完成后对文件进行一些操作。你可以在闭包中放置一个处理文件的指令列表，并在文件下载完成后让程序执行它。你将在
    [*第16章*](B17469_16_Final_VK_ePub.xhtml#_idTextAnchor223) *使用 MapKit 入门* 中看到闭包是如何使用的。
- en: Important Information
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 重要信息
- en: To learn more about closures, visit [https://docs.swift.org/swift-book/LanguageGuide/Closures.html](https://docs.swift.org/swift-book/LanguageGuide/Closures.html).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于闭包的信息，请访问 [https://docs.swift.org/swift-book/LanguageGuide/Closures.html](https://docs.swift.org/swift-book/LanguageGuide/Closures.html)。
- en: 'You''ll now write a closure that applies a calculation on each element of an
    array of numbers. Add the following code to your playground and click the **Play/Stop**
    button to run it:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将编写一个闭包，它将对数字数组中的每个元素执行计算。将以下代码添加到你的游乐场中，然后点击**播放/停止**按钮来运行它：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This assigns a closure that calculates a number's power of two to `myClosure`.
    The `map()` function then applies this closure to every element in `numbersArray`.
    Each element is multiplied by itself, and `[4, 16, 36, 49]` appears in the Results
    area.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这将分配一个计算数字的平方的闭包给 `myClosure`。然后 `map()` 函数将这个闭包应用到 `numbersArray` 的每个元素上。每个元素都乘以自身，然后
    `[4, 16, 36, 49]` 出现在结果区域。
- en: It's possible to write closures in a more concise fashion, and you'll see how
    to do that in the next section.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 可以以更简洁的方式编写闭包，你将在下一节中看到如何做到这一点。
- en: Simplifying closures
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简化闭包
- en: 'One of the things that new developers have trouble with is the very concise
    way experienced Swift programmers use to write closures. Consider the code shown
    in the following example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 新的开发者可能会遇到的问题是经验丰富的 Swift 程序员编写闭包的非常简洁的方式。考虑以下示例中的代码：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, you have `testNumbers`, an array of numbers, and you use the `map(_:)`
    function to map a closure to each element of the array in turn. The code in the
    closure multiplies the number by itself, generating the square of that number.
    The result, `[4, 16, 36, 49]`, is then printed to the Debug area. As you will
    see, the closure code can be written more concisely.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你有 `testNumbers`，一个数字数组，你使用 `map(_:)` 函数依次将闭包映射到数组的每个元素上。闭包中的代码将数字乘以自身，生成该数字的平方。然后，结果
    `[4, 16, 36, 49]` 被打印到调试区域。正如你将看到的，闭包代码可以写得更加简洁。
- en: 'When a closure''s type is already known, you can remove the parameter type,
    return type, or both. Single statement closures implicitly return the value of
    their only statement, which means you can remove the `return` statement as well.
    So, you can write the closure as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当闭包的类型已知时，你可以移除参数类型、返回类型或两者。单语句闭包隐式返回其唯一语句的值，这意味着你也可以移除`return`语句。因此，你可以将闭包写成如下形式：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When a closure is the only argument to a function, you can omit the parentheses
    enclosing the closure, as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当闭包是函数的唯一参数时，你可以省略包围闭包的括号，如下所示：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can refer to parameters by a number expressing their relative position
    in the list of arguments instead of by name, as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过一个表示它们在参数列表中相对位置的数字来引用参数，而不是通过名称，如下所示：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: So, the closure now is very concise indeed, but will be challenging for new
    developers to understand. Feel free to write closures in a way that you are comfortable
    with.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，闭包现在确实非常简洁，但对于新开发者来说可能有些难以理解。请随意以你舒适的方式编写闭包。
- en: You now know how to create and use closures, and how to write them more concisely.
    Great!
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经知道了如何创建和使用闭包，以及如何更简洁地编写它们。太棒了！
- en: Summary
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you studied how to group statements together into functions.
    You learned how to use custom argument labels, functions inside other functions,
    functions as return types, and functions as parameters. This will be useful later
    when you need to accomplish the same task at different points in your program.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将语句组合成函数。你了解了如何使用自定义参数标签、函数内的函数、函数作为返回类型以及函数作为参数。这在以后你需要在不同程序点完成相同任务时将非常有用。
- en: You also learned how to create closures. This will be useful when you need to
    pass around blocks of code within your program.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学习了如何创建闭包。当你需要在程序中传递代码块时，这将非常有用。
- en: In the next chapter, you will study classes, structures, and enumerations. Classes
    and structures allow for the creation of complex objects that can store state
    and behavior, and enumerations can be used to limit the values that can be assigned
    to a variable or constant, reducing the chances for error.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习类、结构和枚举。类和结构允许创建可以存储状态和行为的复杂对象，而枚举可以用来限制可以分配给变量或常量的值，从而减少出错的可能性。
