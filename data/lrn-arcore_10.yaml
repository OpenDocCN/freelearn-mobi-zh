- en: Mixing in Mixed Reality
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在混合现实中混合
- en: '**Mixed reality** (**MR**) is the evolution of combining **augmented reality**
    and **virtual reality** into the same experience or app. MR typically uses a wearable
    device to overlay the virtual world on top of the user''s reality. The concept
    first gained traction with Microsoft''s introduction of HoloLens. HoloLens is
    a wearable glasses device that allows you to overlay your real world with virtual
    content using hand gestures, not unlike what we have been doing with ARCore in
    this whole book, except the difference of the wearable part and, of course, the
    price tag.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**混合现实**（**MR**）是将**增强现实**和**虚拟现实**结合到同一体验或应用中的演变。MR通常使用可穿戴设备在用户的现实世界之上叠加虚拟世界。这个概念最初是在微软推出HoloLens时开始受到关注的。HoloLens是一种可穿戴眼镜设备，允许你通过手势将你的现实世界与虚拟内容叠加，这与我们在整本书中用ARCore所做的不太一样，只是可穿戴部分和，当然，价格标签不同。'
- en: Microsoft is currently leading the charge in mixed reality development with
    their platform of the same name, which is great exposure for the whole AR/VR and
    now MR space. Microsoft is a big technology company and, like many big technology
    giants, has decided to redefine the concept of mixed reality to also include virtual
    reality.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 微软目前正领导混合现实开发，他们的同名平台为整个AR/VR和现在的MR空间提供了很好的曝光。微软是一家大型的科技公司，就像许多大型科技巨头一样，已经决定重新定义混合现实的概念，使其也包括虚拟现实。
- en: Wearable devices that allow users to experience mixed reality have been traditionally
    quite expensive, until just recently. Through group funding and other initiatives,
    there are now plenty of cheap, less-than $30 US wearable devices out there that
    will allow you to experience MR. This is perfect for anybody who wants to dive
    in and learn how to develop MR apps. Of course, not all MR platforms are designed
    for mobile devices, or will work with ARCore. Fortunately, an open source project
    called **HoloKit** has released a cardboard MR headset that is designed to work
    with ARCore.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 允许用户体验混合现实的可穿戴设备传统上相当昂贵，直到最近。通过众筹和其他举措，现在有很多价格低廉、不到30美元的美国可穿戴设备可以让你体验混合现实。这对于任何想要深入了解并学习如何开发混合现实应用的人来说是完美的。当然，并非所有混合现实平台都为移动设备设计，或者与ARCore兼容。幸运的是，一个名为**HoloKit**的开源项目发布了一个纸盒混合现实头戴设备，它设计用于与ARCore一起使用。
- en: '"I''m not confused. I''m just well mixed."'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: “我没有困惑，我只是混合得很好。”
- en: '- Robert Frost'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '- 罗伯特·弗罗斯特'
- en: 'In this chapter, we will build a combined AR / MR ARCore app that will be meant
    as a technology and learning demo that showcases the power of AR and MR. We will,
    of course, need to get our feet wet a little with VR as well, which should make
    things interesting. The following is the list of main items we will focus on in
    this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个结合AR / MR ARCore应用，它将作为一个技术和学习演示，展示AR和MR的强大功能。当然，我们还需要在VR方面稍微尝试一下，这应该会使事情变得有趣。以下是本章我们将重点关注的主要项目列表：
- en: Mixed reality and HoloKit
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合现实和HoloKit
- en: Introducing WRLD
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍WRLD
- en: Setting up WRLD for MR
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置WRLD以进行MR
- en: Navigating the map
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航地图
- en: Mapping, GIS, and GPS
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地图绘制、GIS和GPS
- en: What's next
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来是什么
- en: This is a really big chapter with lots of material to go over. Unfortunately,
    we cannot include the content in a completed package due to licensing. However,
    we have tried to write each section in this chapter so that it can be used on
    its own, almost like a cookbook. This will allow you to pick and choose the components
    you want and don't want to use.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个内容非常丰富的章节，有很多内容需要讲解。遗憾的是，由于版权问题，我们无法将其内容作为一个完整的包提供。然而，我们已经尽力将本章的每个部分都写成可以独立使用的样子，几乎就像一本烹饪书。这将允许你挑选和选择你想要和不需要使用的组件。
- en: To best experience the exercises in this chapter, it is recommended that you
    obtain a HoloKit. You should be able to obtain this device for around $30\. If
    you are feeling adventurous, there are even plans available to build your own.
    Here's a link to where you can learn more about HoloKit and order your own at [https://holokit.io/](https://holokit.io/).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最好地体验本章的练习，建议你获得一个HoloKit。你应该能够以大约30美元的价格获得这个设备。如果你感到好奇，甚至有计划可以自己制作。以下是一个链接，你可以在这里了解更多关于HoloKit的信息并订购自己的设备：[https://holokit.io/](https://holokit.io/)。
- en: Mixed reality and HoloKit
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合现实和HoloKit
- en: 'HoloKit was created by Botau Hu, a brilliant new tech innovator that will surely
    experience great success in the industry. It''s a *wearable* device that projects
    your mobile devices screen into a 3D holographic projection. This holographic
    projection is then overlaid onto the user''s view, thus allowing them to experience
    a more immersive environment that often teeters on the edge of VR. The following
    is an illustration of what a HoloKit looks like fully assembled:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: HoloKit是由Botau Hu创建的，他是一位才华横溢的新技术创新者，必将在行业中取得巨大成功。这是一个*可穿戴*设备，可以将你的移动设备屏幕投射成3D全息投影。然后，这个全息投影叠加到用户的视野上，从而使用户能够体验一个更加沉浸的环境，这种环境通常处于VR的边缘。以下是一张完全组装的HoloKit的插图：
- en: '![](img/d033fadf-2219-44c8-8fa1-29155231c5df.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d033fadf-2219-44c8-8fa1-29155231c5df.png)'
- en: Fully assembled HoloKit
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 完全组装的HoloKit
- en: As you can see from the diagram, the device is quite similar in construction
    to that of Google Cardboard. Cardboard was Google's way of democratizing VR to
    the masses, and it worked. If you are unable to quickly get a HoloKit, you can
    also use a modified Google Cardboard. Just cut a slot in the cardboard for the
    device's camera and ensure not to move around too much.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如从图中所示，该设备在构造上与谷歌Cardboard非常相似。Cardboard是谷歌使VR大众化的方式，并且它成功了。如果你无法快速获得HoloKit，你也可以使用修改后的谷歌Cardboard。只需在纸板上为设备的摄像头切一个槽，并确保不要过多地移动。
- en: One of the first things you will note about most mixed reality headsets is the
    ability of the user to see through their environment. This allows the user to
    still be spatially aware of their surroundings, while experiencing what could
    be an almost virtual experience. Since a user is more aware, MR devices are generally
    considered safer, and the user is much less prone to experiencing motion sickness
    and/or falling down. Currently, VR devices are not considered appropriate for
    those under the age of thirteen due to those issues.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你会首先注意到大多数混合现实耳机的一个特点就是用户可以看到他们的环境。这使用户仍然能够对周围的空间有意识，同时体验可能是一种几乎完全虚拟的经历。由于用户更加警觉，MR设备通常被认为更安全，用户很少会经历运动病和/或跌倒。目前，由于这些问题，VR设备被认为不适合13岁以下的人。
- en: VR motion sickness is often more a result of poor app performance or resolution.
    As it turns out, visual artifacts caused by a lagging app or poor resolution are
    responsible for placing additional strain on the user's brain. That strain will
    then manifest itself in the form of a severe headache or nausea. In the early
    days of VR, this was a big problem, but now the technology has improved enough
    for most users to be able to use an app for several hours at a time.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: VR运动病通常更多是应用程序性能不佳或分辨率低的结果。实际上，由延迟的应用程序或低分辨率引起的视觉伪影会对用户的头脑造成额外的压力。这种压力会以剧烈头痛或恶心等形式表现出来。在VR的早期，这是一个大问题，但现在技术已经足够成熟，大多数用户可以连续使用应用程序数小时。
- en: The **Mirage Solo** headset was developed by *Lenovo* for a game by Disney called
    *Jedi Challenges*. Jedi Challenges is really more a proof of concept and showcase
    for mixed reality and what is possible. It will likely also be a collector's item,
    since it is associated with the new Star Wars franchise and just happens to correspond
    to an up-and-coming tech revolution. The only truly unfortunate thing about this
    project is that Lenovo never released a developer kit; hopefully they will rectify
    this is in the future.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**Mirage Solo**耳机是由*联想*为迪士尼的一款名为*绝地挑战*的游戏开发的。绝地挑战实际上更多的是一个混合现实概念的证明和展示，以及可能实现的内容。它很可能也会成为收藏品，因为它与新的星球大战系列相关联，并且恰好与即将到来的技术革命相吻合。这个项目唯一真正不幸的事情是联想从未发布开发者套件；希望他们将来能纠正这一点。'
- en: 'The following is an image of the Lenovo Mirage Solo headset:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一张联想Mirage Solo耳机的图片：
- en: '![](img/4f21f5f8-0271-45d2-966b-ffa171264b1f.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4f21f5f8-0271-45d2-966b-ffa171264b1f.png)'
- en: Jedi Challenges Mixed Reality game
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 绝地挑战混合现实游戏
- en: In order to complete the exercises in this chapter, you won't need HoloKit.
    HoloKit allows for you to switch from AR to MR/VR mode at the press of a button.
    This means that you can still work through all the exercises in this chapter.
    However, it does mean that you won't experience the magical experience of MR.
    In the next section, we set up HoloKit to work with ARCore and get ready to build
    our tech demo.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成本章的练习，你不需要HoloKit。HoloKit允许你通过按按钮从AR切换到MR/VR模式。这意味着你仍然可以完成本章的所有练习。然而，这也意味着你将无法体验到MR的神奇体验。在下一节中，我们将设置HoloKit与ARCore一起工作，并准备好构建我们的技术演示。
- en: Setting up HoloKit
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置HoloKit
- en: 'The great thing about HoloKit is that it comes complete with its own Unity
    template project. This makes our job of getting up and running with HoloKit quite
    painless. Open up Command Prompt or a shell window and do the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: HoloKit的伟大之处在于它自带完整的Unity模板项目。这使得我们使用HoloKit的过程变得非常轻松。打开命令提示符或shell窗口，执行以下操作：
- en: 'If you haven''t already done so, create a new folder from the root called `ARCore`
    and navigate to it:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，从根目录创建一个名为`ARCore`的新文件夹，并导航到它：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Clone the HoloKit repository into it:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将HoloKit仓库克隆到其中：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: That command clones the specific **Android** branch, which we will use. HoloKit
    is also supported for **ARKit** on **iOS**.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该命令克隆了特定的**Android**分支，我们将使用它。HoloKit也支持**iOS**上的**ARKit**。
- en: Open a new instance of the Unity editor. Create and open a new project called
    `HoloCore` in the `ARCore` folder.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的Unity编辑器实例。在`ARCore`文件夹中创建并打开一个名为`HoloCore`的新项目。
- en: In the Project window, create a new folder under Assets called `HoloCore`. Under
    that new folder, create our standard five new folders (`Scripts`, `Scenes`, `Materials`,
    `Models`, and `Prefabs`).
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目窗口中，在Assets下创建一个名为`HoloCore`的新文件夹。在该新文件夹下，创建我们标准的五个新文件夹（`Scripts`、`Scenes`、`Materials`、`Models`和`Prefabs`）。
- en: 'Open the `ARCore/holokitsdk/Assets` folder with a file explorer window. Make
    a copy of the `HoloKitSDK` folder and place it in the `ARCore/HoloCore/Assets`
    folder. When you are done, return to the editor, and you should see the assets
    getting imported and compiled. After the import is complete, confirm that your
    Project window resembles the following:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用文件资源管理器打开`ARCore/holokitsdk/Assets`文件夹。将`HoloKitSDK`文件夹复制并放置在`ARCore/HoloCore/Assets`文件夹中。完成后，返回到编辑器，你应该会看到资产正在导入和编译。导入完成后，确认你的项目窗口如下所示：
- en: '![](img/fd6f2480-9553-4dab-8552-a125c461b64d.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fd6f2480-9553-4dab-8552-a125c461b64d.png)'
- en: Project window folders showing HoloKitSDK
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 显示HoloKitSDK的项目窗口文件夹
- en: If you are prompted to switch to Android, elect to do so by clicking on OK.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你被提示切换到Android，通过点击OK选择这样做。
- en: 'From the menu, select **Edit** | **Project Settings** | **Player**. This will
    open the Player (as in app player) settings panel. Select the Android tab and
    uncheck the Multithreaded Rendering option, and set the Package name, API Levels,
    and ARCore Supported, as shown:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从菜单中选择**编辑** | **项目设置** | **玩家**。这将打开玩家（即应用玩家）设置面板。选择Android选项卡，取消选择多线程渲染选项，并设置包名、API级别和ARCore支持，如下所示：
- en: '![](img/8ef6bef3-3451-40b9-8b41-0b9928b067b0.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8ef6bef3-3451-40b9-8b41-0b9928b067b0.jpg)'
- en: Setting the Player settings for Android
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 设置Android的Player设置
- en: Open up the HoloKit sample scene `CubeOnTheFloor` in the `Assets/HoloKitSDK/Examples`
    folder.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/HoloKitSDK/Examples`文件夹中打开HoloKit示例场景`CubeOnTheFloor`。
- en: From the menu, select File | Save Scene as, and save the scene as Main in the
    **`Assets/HoloCore/Scenes`** folder.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从菜单中选择文件 | 保存场景为，并将场景保存为**`Assets/HoloCore/Scenes`**文件夹中的Main。
- en: Open up Build Settings and add the current scene to the build.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开构建设置并将当前场景添加到构建中。
- en: Connect, build, and run. You should see a rather small button in the top corner
    with the letter C. Press that button to switch from AR to the MR mode. When you
    are ready, put your device into the HoloKit headset and enjoy your first MR app.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接、构建和运行。你应该在右上角看到一个带有字母C的小按钮。按下该按钮即可从AR模式切换到MR模式。准备好后，将你的设备放入HoloKit头戴式设备中，享受你的第一个MR应用。
- en: 'Unlike Google Cardboard, HoloKit needs to let the camera view the user''s surroundings
    in order to track. As such, you may need to modify the headset by cutting out
    a larger hole for the device''s camera to see through. Here''s a pic of a HoloKit
    that needed to be modified in order to accommodate a Samsung Galaxy S8:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 与Google Cardboard不同，HoloKit需要让相机查看用户的环境以便跟踪。因此，你可能需要通过为设备摄像头切割更大的孔来修改头戴式设备。这是一张需要修改以适应三星Galaxy
    S8的HoloKit图片：
- en: '![](img/5118ff56-d549-4d98-9596-54040dc2d87d.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5118ff56-d549-4d98-9596-54040dc2d87d.jpg)'
- en: Modified HoloKit to allow camera to visibly track
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 修改了HoloKit以允许相机可见地跟踪
- en: If you have another device that you want to hack, like Cardboard, then just
    ensure that you cut a space so that the camera is not blocked. Some other mixed
    reality headsets that work with mobile devices already have camera extensions.
    These camera extensions may support a fish eye lens, which allows for the device
    to see a wider area. This works quite well, since it essentially converts the
    camera into a sensor with a wide angle lens.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还有其他你想破解的设备，比如Cardboard，那么只需确保你切割出一个空间，以便相机不会被遮挡。一些与移动设备兼容的其他混合现实头戴式设备已经有了相机扩展。这些相机扩展可能支持鱼眼镜头，这允许设备看到更宽的区域。这效果相当不错，因为它本质上将相机转换成了一个具有广角镜头的传感器。
- en: How does it work?
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的？
- en: 'Before we get too far ahead of ourselves, let''s break open the HoloKit project
    and take a look at how or what it does. Open up the Unity editor and complete
    the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们走得太远之前，让我们打开HoloKit项目，看看它是如何或做什么的。打开Unity编辑器并完成以下操作：
- en: 'Find the HoloKitCameraRig in the Hierarchy window, and then select and expand
    it. Expand the children''s children and so on until you can see the Left Eye and
    Right Eye objects, as shown in the following screenshot:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构窗口中找到HoloKitCameraRig，然后选择并展开它。展开子对象的子对象，等等，直到你可以看到左眼和右眼对象，如下面的截图所示：
- en: '![](img/87e11eba-c03c-44ac-b224-10983823bbd0.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/87e11eba-c03c-44ac-b224-10983823bbd0.png)'
- en: View of the scene's 3 cameras in the Hierarchy window
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在层次结构窗口中查看场景的3个相机视图
- en: The VideoSeeThroughCamera is the main camera used when the app is in AR mode.
    When the app is in MR mode, the Left Eye and Right Eye cameras are used to create
    the stereo 3D vision. Take a closer look at the Eye cameras, and you will note
    that their position is slightly adjusted on the *x* axis. For the right camera,
    the amount is 0.032, and for the left it is -0.032\. This is how we generate 3D
    stereo projections, using an offset camera for each eye.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当应用处于AR模式时，VideoSeeThroughCamera是主要使用的相机。当应用处于MR模式时，左右眼相机被用来创建立体3D视觉。仔细观察眼相机，你会注意到它们在*x*轴上的位置略有调整。对于右相机，调整量为0.032，对于左相机则是-0.032。这就是我们如何通过为每只眼睛使用偏移相机来生成3D立体投影。
- en: 'The other components are as follows:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其他组件如下：
- en: 'HoloKitAmbientLight: It is just a standard directional light with the `ARCore
    Environmental Light` script attached.'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: HoloKitAmbientLight：它只是一个带有`ARCore Environmental Light`脚本的普通方向性光源。
- en: 'HoloKitPlaneGenerator: It is a base object for the `HelloARController` script,
    which we have seen plenty of before.'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: HoloKitPlaneGenerator：它是`HelloARController`脚本的基础对象，我们之前已经见过很多次了。
- en: 'HoloKitPlacementRoot: It is our main anchor point for the scene''s virtual
    objects.'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: HoloKitPlacementRoot：它是场景中虚拟对象的主要锚点。
- en: 'HoloKitCameraRig: It is what controls the app view.'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: HoloKitCameraRig：它是控制应用视图的东西。
- en: 'HoloKitGazeManager: It is new and allows the user to select objects just by
    positioning their gaze or view on the target. You can try this now with the current
    scene and the ball. Fix your gaze on the ball and see what happens.'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: HoloKitGazeManager：它是新的，允许用户通过定位他们的注视点或视图在目标上选择对象。你现在可以用当前场景和球来尝试这个功能。将你的注视点固定在球上，看看会发生什么。
- en: 'HoloKitPointCloud: It serves the same function as its counterpart in ARCore.'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: HoloKitPointCloud：它与其在ARCore中的对应物具有相同的功能。
- en: Go through and continue to expand and inspect the rest of the objects in the
    scene.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续浏览并检查场景中其余对象的其余部分。
- en: Connect, build, and run the scene again. This time, pay attention to the details
    and see if you can get the Gaze to work.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接、构建并再次运行场景。这次，注意细节，看看你是否能让注视点工作。
- en: Well, hopefully that was relatively painless. Now, with HoloKit setup, we have
    the framework in place for our combined AR and MR app. We should expand on what
    our tech demo will do. The premise of our tech demo will be an app that allows
    the user to move between a traditional map interface and an AR or MR interface.
    The name HoloCore is a play on the ability to allow a user to drill into a map
    and render a 3D view in AR or MR. This also nicely ties in with the name ARCore.
    In the next section, we will look at adding a 3D map of the world to our app.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这相对容易。现在，有了HoloKit的设置，我们为我们的AR和MR应用组合建立了框架。我们应该扩展我们的技术演示将做什么。我们的技术演示的前提将是一个允许用户在传统地图界面和AR或MR界面之间移动的应用。HoloCore这个名字是对用户能够钻入地图并在AR或MR中渲染3D视图的能力的一种戏谑。这也很好地与ARCore的名字相呼应。在下一节中，我们将看看如何将世界3D地图添加到我们的应用中。
- en: Introducing WRLD
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍WRLD
- en: Mixed reality apps, because they provide spatial awareness to the user, are
    excellent for viewing massive objects or areas like a map. Unlike virtual reality,
    mixed provides a more intuitive and natural interface for movement since the user
    can also physically move their position. So, what better way to fully explore
    MR than by using it to view a 3D map of the world. Fortunately, there is a relative
    newcomer called **WRLD** that has started to make significant waves in AR / VR
    and MR, because it provides an excellent and simple solution for rendering a fairly-good
    3D map.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 混合现实应用程序，因为它们为用户提供空间感知，非常适合查看大型物体或区域，如地图。与虚拟现实不同，混合现实提供了更直观和自然的界面进行移动，因为用户也可以物理移动他们的位置。所以，还有什么比使用它来查看世界的
    3D 地图来完全探索混合现实更好的方法呢。幸运的是，有一个相对较新的名为 **WRLD** 的平台，它已经开始在 AR / VR 和 MR 领域产生重大影响，因为它提供了一个优秀且简单的解决方案来渲染相当好的
    3D 地图。
- en: WRLD is a great platform for general 3D mapping and visualization. It currently
    does not support more robust backend GIS services, but it certainly could. For
    those professional GIS developers with access to Esri CityEngine, there are also
    some great workflows for bringing CE models into Unity. This means that you can
    also experiment with CE models in MR.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: WRLD 是一个优秀的通用 3D 映射和可视化平台。它目前不支持更强大的后端 GIS 服务，但肯定可以。对于那些可以访问 Esri CityEngine
    的专业 GIS 开发者，也有一些将 CE 模型引入 Unity 的优秀工作流程。这意味着你还可以在混合现实中实验 CE 模型。
- en: 'WRLD is shipped as a Unity asset right to the Asset Store, so installation
    is a breeze. However, before we install, we need to go to the WRLD site and get
    a developer account. WRLD is a commercial service that charges by usage. Fortunately,
    they offer free developer access for a limited, which is perfect for our tech
    demo. Open up a browser and complete the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: WRLD 作为 Unity 资产直接在资产商店中提供，因此安装非常简单。然而，在我们安装之前，我们需要访问 WRLD 网站，并获取一个开发者账户。WRLD
    是一项按使用量收费的商业服务。幸运的是，他们为有限的时间提供免费的开发者访问权限，这对于我们的技术演示来说非常完美。打开浏览器并完成以下操作：
- en: Browse to [wrld3d.com](https://www.wrld3d.com/) and Sign Up for an account.
    Ensure that you verify the account through email.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览到 [wrld3d.com](https://www.wrld3d.com/) 并注册账户。确保通过电子邮件验证账户。
- en: Return to the site and Sign In.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回网站并登录。
- en: Find and click on the Developers link at the top of the page. This will take
    you to the Developers page.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在页面顶部找到并点击“开发者”链接。这将带你去到开发者页面。
- en: Click on the big Access API Keys button at the top of the page.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击页面顶部的“大访问 API 密钥”按钮。
- en: 'Enter the name for your key, `HoloCore`, and click on Create API Key to create
    the key, as shown in the following screenshot:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你的密钥输入名称 `HoloCore`，然后点击“创建 API 密钥”以创建密钥，如图所示：
- en: '![](img/6556db14-acba-4018-bf3d-7e3418ed1c22.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6556db14-acba-4018-bf3d-7e3418ed1c22.png)'
- en: Creating a WRLD API key
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 WRLD API 密钥
- en: Click on Copy API Key to copy the key to your clipboard. We will use it shortly.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“复制 API 密钥”以将密钥复制到剪贴板。我们很快就会用到它。
- en: Return to the Unity editor and, from the menu, select Window | Asset Store.
    This will open a browser page inside the editor.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 Unity 编辑器，从菜单中选择 Window | Asset Store。这将打开编辑器内的浏览器页面。
- en: 'Enter `WRLD` in the search box and click on the Search button. This will open
    the asset page for `WRLD`, offering you to Download the asset. Click on the Download
    button, as shown in the following screenshot:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索框中输入 `WRLD` 并点击搜索按钮。这将打开 `WRLD` 的资产页面，提供下载资产。点击下载按钮，如图所示：
- en: '![](img/0e33f27b-45e8-4b02-bd94-2d9d66a47bc2.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0e33f27b-45e8-4b02-bd94-2d9d66a47bc2.png)'
- en: Downloading the WRLD asset from the Asset Store
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 从资产商店下载 WRLD 资产
- en: This will download the package. After the package downloads, you will be prompted
    with an asset import dialog. Just click on Import to import everything. This may
    take a while, so stretch your legs and grab some refreshments.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将下载包。下载完成后，你将看到一个资产导入对话框。只需点击“导入”即可导入所有内容。这可能需要一些时间，所以请伸展一下腿脚，拿些点心。
- en: In some cases, you may want to be more careful on what you bring into your projects.
    For instance, if you were building a non-tech demo or proof of concept, you would
    likely remove any sample scenes or other excess from a project. We will talk more
    about keeping projects lean in [Chapter 11](e7c0bdd1-e380-4498-af5a-fe9e627eb6cb.xhtml),
    *Performance Tips and Troubleshooting*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能想要更小心地选择将哪些内容带入你的项目中。例如，如果你正在构建一个非技术演示或概念验证，你可能会从项目中移除任何示例场景或其他多余内容。我们将在第
    11 章[性能提示和故障排除](e7c0bdd1-e380-4498-af5a-fe9e627eb6cb.xhtml)中更多地讨论保持项目精简。
- en: You may get a warning prompting you that the versions don't match with your
    version of Unity. Accept the warning and continue.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能会收到一个警告，提示你的版本与Unity的版本不匹配。接受警告并继续。
- en: When you are prompted to get a key after you import `WRLD`, just click on Later.
    After all, we already have a key.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你导入`WRLD`后，被提示获取密钥时，只需点击“稍后”。毕竟，我们已经有了一个密钥。
- en: 'Next, you will probably be prompted to increase the shadow distance with the
    following dialog:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你可能会被提示通过以下对话框增加阴影距离：
- en: '![](img/dd30d3f9-efd8-442a-9bb7-b5b0a10ad4a5.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dd30d3f9-efd8-442a-9bb7-b5b0a10ad4a5.png)'
- en: Skip the Shadow settings dialog
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 跳过阴影设置对话框
- en: Click on the Skip button. We will need to adjust the lighting, materials, and
    shadows later manually.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击跳过按钮。我们稍后需要手动调整光照、材质和阴影。
- en: This imports the `WRLD` asset into our project. In the next section, we will
    cover how to set it up and run `WRLD` for our MR app.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这将`WRLD`资产导入到我们的项目中。在下一节中，我们将介绍如何设置并运行`WRLD`以用于我们的MR应用。
- en: Setting up WRLD for MR
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为WRLD设置MR环境
- en: 'With the asset imported, we can now work on setting up `WRLD` to work in MR.
    The setup requires a little bit of customization, so jump back to Unity and complete
    the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 导入资产后，我们现在可以开始设置`WRLD`以在MR中工作。设置需要一些定制，所以回到Unity并完成以下步骤：
- en: From the menu, select **Assets** | **Setup WRLD Resources For** | **Android**.
    This will ensure that the assets are optimized for Android. We will also talk,
    in a later section, about how the materials can be manually optimized by updating
    or creating your own shaders.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从菜单中选择**Assets** | **Setup WRLD Resources For** | **Android**。这将确保资产针对Android进行了优化。我们还会在稍后的部分讨论如何通过更新或创建自己的着色器来手动优化材质。
- en: Ensure that the Main scene is loaded, and then select and expand the **HoloKitPlacementRoot**.
    Disable the DebugCube and GazeTargetExample child objects. If you forgot how to
    do this, check the Inspector window.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保主场景已加载，然后选择并展开**HoloKitPlacementRoot**。禁用DebugCube和GazeTargetExample子对象。如果你忘记了如何操作，请检查检查器窗口。
- en: Create a new child `GameObject` of HoloKitPlacementRoot called `WRLD`. Go to
    the Inspector window and use Add Component to add the `Wrld Map` component to
    the object.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`WRLD`的新子`GameObject`，属于HoloKitPlacementRoot。转到检查器窗口，并使用添加组件来添加`Wrld Map`组件到对象。
- en: 'Set the component properties of the `Wrld Map`, as shown:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`Wrld Map`组件的属性，如图所示：
- en: '![](img/eff839f7-795d-4bd8-96a9-0c6afdc94785.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eff839f7-795d-4bd8-96a9-0c6afdc94785.png)'
- en: Setting properties for the Wrld Map component
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 设置Wrld Map组件的属性
- en: Select and drag the new `WRLD` object into your `Assets/HoloCore/Prefabs` folder
    to create a prefab that we can use later.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择并拖动新的`WRLD`对象到你的`Assets/HoloCore/Prefabs`文件夹中，以创建一个我们可以稍后使用的预制件。
- en: Select HoloKitCameraRig from the Hierarchy window and set the Transforms Y Position
    to `300`. Since our map is at `0`, `0`, `0`, we want our viewer to look down from
    a height of around 300 meters or about 1000 feet. Then, expand the object until
    you see all of the children.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从层次结构窗口中选择HoloKitCameraRig，并将变换的Y位置设置为`300`。由于我们的地图在`0`，`0`，`0`，我们希望观察者从大约300米或约1000英尺的高度向下看。然后展开对象，直到你看到所有的子对象。
- en: 'Select each of the cameras, VideoSeeThroughCamera, Left Eye, and Right Eye,
    and, in the Inspector window, set the Clipping Planes Far to `5000`, as illustrated:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择每个相机，VideoSeeThroughCamera，左眼和右眼，然后在检查器窗口中，将远裁剪平面设置为`5000`，如图所示：
- en: '![](img/4eba6d12-0d4f-4c26-b9e1-a5aa820b503f.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4eba6d12-0d4f-4c26-b9e1-a5aa820b503f.png)'
- en: Setting the Far plane clipping distance
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 设置远平面裁剪距离
- en: Adjusting the far clipping plane essentially expands our view to include all
    objects to a distance of `5000`. Previously, this was set for `1000`. You may
    also want to increase the Near Clipping Plane to a larger value; `1` to `10` works
    well. If you note a slight flashing on the map, this is likely caused by the clipping
    plane being set to close.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整远裁剪平面实际上将我们的视图扩展到包括距离`5000`的所有对象。之前，这个值设置为`1000`。你可能还想将近裁剪平面增加到更大的值；`1`到`10`效果很好。如果你注意到地图上略有闪烁，这很可能是由于裁剪平面设置得太近造成的。
- en: Connect, build, and run. Set the app to run in MR by clicking on the C button
    and then inserting your device in HoloKit. Enjoy the experience of viewing a map
    in mixed reality.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接、构建和运行。通过点击C按钮并将设备插入HoloKit来设置应用在MR中运行。享受在混合现实中查看地图的体验。
- en: WRLD has several excellent examples on using their API on Unity and other platforms.
    We built this example in order to feature mixing realities, rather than recreating
    their examples. As such, we have omitted placing the map on a surface, but this
    is because WRLD already has a good example for ARKit and, likely, will in the
    future.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: WRLD在Unity和其他平台上使用其API有几个优秀的示例。我们构建这个示例是为了展示现实混合，而不是重新创建他们的示例。因此，我们省略了将地图放置在表面上的操作，但这是因为WRLD已经有一个很好的ARKit示例，并且很可能会在未来提供。
- en: What you just experienced is quite fun, especially considering the minimal effort
    this example took to get setup, except that there are several things missing.
    Most certainly, we want to be able to move and zoom in and out of our map, so
    we will cover movement and navigating in the next section.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚才所体验的相当有趣，尤其是考虑到这个示例在设置上所花费的精力如此之小，除了有一些东西缺失。当然，我们希望能够移动并放大缩小我们的地图，因此我们将在下一节中介绍移动和导航。
- en: Navigating the map
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航地图
- en: In a traditional AR app, you rarely move the user or player. The user or player
    move themselves, and the AR app works around that. We spent a good portion of
    this book understanding how ARCore tracks the user and understands their environment,
    which has worked quite well when working with small objects such as Andy. Except,
    if we want to render massive virtual objects or even embed new environments, then
    we need a way for the user to navigate those as well. Therefore, in this section,
    we will look to implement a mix of navigation methods from a standard touch interface
    to AR and MR versions. If you don't have a HoloKit or are not interested in trying
    MR, then you can stick to just working with the AR.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的AR应用中，你很少移动用户或玩家。用户或玩家自己移动，AR应用则围绕这一点工作。我们在本书中花了很多时间来理解ARCore如何跟踪用户并理解他们的环境，这在处理像Andy这样的小物体时效果相当不错。但是，如果我们想要渲染大量的虚拟物体或者嵌入新的环境，那么我们需要一种让用户也能导航这些物体的方式。因此，在本节中，我们将探讨实现从标准触摸界面到AR和MR版本的混合导航方法。如果你没有HoloKit或者对尝试MR不感兴趣，那么你可以只专注于使用AR。
- en: 'Before adding navigation to our app, we probably should look at how navigation
    is handled by default in WRLD. Open up the Unity editor and follow along:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在向我们的应用添加导航之前，我们可能应该看看WRLD默认是如何处理导航的。打开Unity编辑器并跟随操作：
- en: Save your current scene.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的当前场景。
- en: Create a new scene. Name it `Navigation` and save the scene in the `Assets/HoloCore/Scenes`
    folder.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的场景。将其命名为`Navigation`并在`Assets/HoloCore/Scenes`文件夹中保存场景。
- en: 'From the `Assets/HoloCore/Prefabs` folder, drag the `WRLD` prefab we created
    earlier and drop it in the scene. Set the properties on the `Wrld Map`, as shown
    in this screenshot:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Assets/HoloCore/Prefabs`文件夹中，拖动我们之前创建的`WRLD`预制体并将其放入场景中。设置`Wrld Map`上的属性，如图所示：
- en: '![](img/cbf76eca-2a6e-4138-a9ed-4dc3a17c710c.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cbf76eca-2a6e-4138-a9ed-4dc3a17c710c.png)'
- en: Setting properties for the WRLD prefab
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 设置WRLD预制体的属性
- en: This is more or less the default settings that you will use to just render the
    map to your device in a non-AR interface.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这基本上是你将用于在非AR界面中将地图渲染到设备上的默认设置。
- en: Open the Build Settings dialog and add your new scene to the build. Uncheck
    the Main scene, but don't delete it; we will turn it back on later.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开构建设置对话框并将你的新场景添加到构建中。取消选中主场景，但不要删除它；我们稍后会再次启用它。
- en: Connect, build, and run. You will now see the map as the main element in your
    view. You can use touch gestures to move, pan, and zoom the map.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接、构建和运行。你现在会看到地图成为你视图中的主要元素。你可以使用触摸手势来移动、平移和缩放地图。
- en: As you can see by playing with the app, the map navigation is very slick using
    the touch interface. We will use this to allow the user to navigate the map with
    touch until they see an area of interest that they want to take a close look at.
    Then, they will be able to switch to AR or MR mode to view the items in more detail.
    In order to do this, we will use the scene we just created as our starting scene,
    and use our Main scene to let the user switch to AR or MR.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如您通过操作应用所见，使用触摸界面进行地图导航非常流畅。我们将使用这个场景作为我们的起始场景，并使用我们的主场景让用户切换到AR或MR模式以查看更详细的项目。为此，我们将使用我们刚刚创建的场景作为起始场景，并使用我们的主场景让用户切换到AR或MR。
- en: Being able to switch between interface types like a regular touch-driven UI
    and AR or MR works all the time. An excellent example of this, of course, is the
    popular game *Pokemon Go* from Niantic Labs. This also happens to use a map and
    allows a user to switch to AR to catch Pokemon. If you are curious about how Pokemon
    Go was constructed, take a look at the book *Augmented Reality Game Development*
    by *Micheal Lanham*, also from *Packt*.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在常规触摸驱动的UI、AR或MR等界面类型之间切换始终是可行的。当然，一个很好的例子是来自Niantic Labs的流行游戏 *Pokémon Go*。这也恰好使用地图，并允许用户切换到AR来捕捉宝可梦。如果你对Pokémon
    Go是如何构建的感到好奇，可以查看由 *Micheal Lanham* 编写的书籍 *Augmented Reality Game Development*，该书也来自
    *Packt*。
- en: Switching from AR to MR
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从AR切换到MR
- en: 'Being able to switch scenes and maintain state is common task, but it seems
    to require a bit of work in Unity. Open up the Unity editor to the `Navigation`
    scene and complete the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 能够切换场景并保持状态是一个常见的任务，但在Unity中似乎需要做一点工作。打开Unity编辑器到 `Navigation` 场景并完成以下操作：
- en: Open up the `Assets/HoloCore/Scripts` folder and create a new script called
    `Singleton`. Go to the book's downloaded source `Code/Chapter_10` folder, copy
    the contents of the `Singleton.cs` file, and paste it into your new script. A
    `Singleton` is common pattern in Unity for creating an object you only want one
    of and when you never want that object destroyed. If you are new to `Singleton`,
    it will be in your best interest to spend some time and review the class.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Assets/HoloCore/Scripts` 文件夹，创建一个新的脚本，命名为 `Singleton`。转到书籍下载的源代码文件夹 `Code/Chapter_10`，复制
    `Singleton.cs` 文件的全部内容，并将其粘贴到你的新脚本中。`Singleton` 是Unity中创建只希望有一个对象且永远不希望该对象被销毁的常见模式。如果你对
    `Singleton` 比较陌生，最好花些时间复习这个类。
- en: 'Create a new script in the same folder called `SceneController` and replace
    the generated code with the following:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件夹中创建一个新的脚本，命名为 `SceneController` 并替换生成的代码为以下内容：
- en: '[PRE2]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`SceneController` is a `Singleton` with a `SceneController`. That circular
    reference may be a little confusing, so it is best to think of as a `SceneController`
    that is a `Singleton` which holds the `SceneController` type. Inside the class,
    we need to define a `protected` default constructor in order to force access through
    the `Instance`. We will look at how to use `Instance` shortly.'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SceneController` 是一个具有 `SceneController` 的 `Singleton`。这种循环引用可能有点令人困惑，所以最好将其视为一个
    `SceneController`，它是一个 `Singleton`，持有 `SceneController` 类型。在类内部，我们需要定义一个 `protected`
    默认构造函数，以便通过 `Instance` 强制访问。我们很快就会看看如何使用 `Instance`。'
- en: 'Enter the following right after the constructor:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数之后输入以下内容：
- en: '[PRE3]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Next, we will add a single property to hold the `position` where the camera
    was last fixed. That way, when we switch scenes, we can just pass the `position`
    property back to the scene so that it can determine where to setup. `LatLongAltitude`
    is a spatial data type that holds the position of the camera in latitude, longitude,
    and altitude.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个单独的属性来保存相机最后固定的位置。这样，当我们切换场景时，我们只需将 `position` 属性传递回场景，以便它可以确定设置的位置。`LatLongAltitude`
    是一种空间数据类型，它保存了相机的纬度、经度和高度。
- en: 'Add the following new method, `LoadScene`, with the following code:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下新的方法，`LoadScene`，并使用以下代码：
- en: '[PRE4]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`LoadScene`, is where all the work happens. We will call `LoadScene` on the
    `SceneController`, passing in the `scene` name we want to load at the current
    `map` or WRLD camera. Inside the method, we first test to see whether the current
    `map` is being controlled; if it is, we just ignore the camera and use the controlled
    camera. Next, we test whether the `mapCamera` is null; if it is, we want to exit
    with an error. Otherwise, we extract the current position with `ScreenToGeographicPoint`.
    This method extractsthe camera''s main screen focal point, which we assume is
    at half pixel width and height of the screen; `mapCamera.nearClipPlane` sets the
    front of view frustum or camera if you recall from our earlier discussions, which
    equals the altitude of the camera above ground level, or the map in this case.
    At the end of the method, we use `SceneManager`, which is the Unity helper class
    for loading scenes. We call `LoadScene` with the option to replace the scene using `LoadSceneMode.Single`.'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LoadScene`，这是所有工作发生的地方。我们将在`SceneController`上调用`LoadScene`，传入我们想要在当前`map`或WRLD相机中加载的`scene`名称。在方法内部，我们首先测试当前`map`是否正在被控制；如果是，我们只需忽略相机并使用被控制的相机。接下来，我们测试`mapCamera`是否为null；如果是，我们希望带错误退出。否则，我们使用`ScreenToGeographicPoint`提取当前位置。此方法提取相机的主屏幕焦点，我们假设它位于屏幕宽度和高度的一半像素处；`mapCamera.nearClipPlane`设置视图锥体或相机的正面，如果您还记得我们之前的讨论，这等于相机相对于地面高度，或者在这个例子中是地图。在方法结束时，我们使用`SceneManager`，这是Unity加载场景的辅助类。我们使用`LoadSceneMode.Single`选项调用`LoadScene`。'
- en: That completes our `SceneController`. Now, the useful thing about being a `Singleton`
    is that we never have to physically add the component, because it is now always
    considered available. WRLD bases most of their Unity API on this pattern as well.
    We do still have to add some further code that can be activated from our scene.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们的`SceneController`。现在，作为`Singleton`的好处是，我们永远不需要物理添加组件，因为它现在始终被认为是可用的。WRLD的大部分Unity
    API也是基于这个模式。我们仍然需要添加一些可以从我们的场景激活的额外代码。
- en: Building the SceneSwitcher
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建场景切换器
- en: 'Let''s add another script/component that will just activate our `SceneController`.
    Open up the editor and complete the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加另一个脚本/组件，它将仅激活我们的`SceneController`。打开编辑器并完成以下操作：
- en: 'Create a new C# script called `SceneSwitcher`, and replace all the pre-generated
    code with the following:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的C#脚本，命名为`SceneSwitcher`，并用以下代码替换所有预生成的代码：
- en: '[PRE5]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create the following property inside the class:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类内部创建以下属性：
- en: '[PRE6]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is a placeholder for the `mapCamera`, the camera being used to render the
    `Wrld map`. We need this when the map is not being controlled by the camera, which
    is the case when the user is in AR / MR.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是`mapCamera`的占位符，即用于渲染`Wrld地图`的相机。当地图不是由相机控制时，我们需要这个，这种情况发生在用户处于AR / MR时。
- en: 'Then, create the following method:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建以下方法：
- en: '[PRE7]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This method will be responsible for using the `LoadScene` on the `SceneController`.
    Note the use of `Instance` in between the class and method call. Remember that
    our `SceneController` is a `Singleton`, which is an object and not a static class.
    Therefore, we need an instance, and that is provided with a helper property called
    `Instance` in `Singleton` and so when calling a method on `SceneController`, we
    always call it through `Instance`.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此方法将负责在`SceneController`上使用`LoadScene`。注意类和方法调用之间使用`Instance`。请记住，我们的`SceneController`是一个`Singleton`，它是一个对象而不是静态类。因此，我们需要一个实例，这由`Singleton`中的辅助属性`Instance`提供，因此当在`SceneController`上调用方法时，我们总是通过`Instance`调用它。
- en: Save all your files, if you haven't already done so, and return to Unity. Ensure
    that you have no compiler errors.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，请保存所有文件，并返回Unity。确保您没有编译错误。
- en: Creating the SceneSwitcher prefab
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建场景切换器预制件
- en: 'With the code complete, it is now time to build our `SceneSwitcher` prefab.
    Open the editor to the `Navigation` scene and complete the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 代码完成后，现在是我们构建`SceneSwitcher`预制件的时候了。打开编辑器到`Navigation`场景并完成以下操作：
- en: From the menu, select GameObject | UI | Canvas. Add the `SceneSwitcher` component
    (script) to the canvas and rename it as `SceneSwitcher`. Set the Map Camera property
    on the `Scene Switcher` to use the Main Camera.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从菜单中选择GameObject | UI | Canvas。将`SceneSwitcher`组件（脚本）添加到画布中，并将其重命名为`SceneSwitcher`。将`Scene
    Switcher`上的地图相机属性设置为使用主相机。
- en: 'Select the **SceneSwitcher** object in the Hierarchy window and then, from
    the menu, select GameObject | UI | Panel. Set the properties of the panel, as
    shown in the following excerpt:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“Hierarchy”窗口中选择**SceneSwitcher**对象，然后从菜单中选择GameObject | UI | Panel。设置面板的属性，如下面的摘录所示：
- en: '![](img/4a9ab0a9-5b10-480e-87d2-b1168333b080.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4a9ab0a9-5b10-480e-87d2-b1168333b080.jpg)'
- en: Setting the properties on the Panel
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在面板上设置属性
- en: Set the Anchor by clicking on the button and then, when the Anchor Presets menu
    opens, simultaneously press the pivot and position keys (*Shift* + *Alt* on Windows)
    and then click on the top-left corner. This will set the panel to anchor to the
    top left. You will also need to add a Grid Layout Group component and set the
    properties specified.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击按钮设置锚点，然后当“Anchor Presets”菜单打开时，同时按下旋转和位置键（Windows上的*Shift* + *Alt*）并点击左上角。这将使面板锚定到左上角。您还需要添加一个网格布局组组件并设置指定的属性。
- en: Select the Panel and, from the menu, choose GameObject | UI | Button. Rename
    the button Switch and set the button text to Switch.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择面板，从菜单中选择GameObject | UI | Button。将按钮重命名为Switch并设置按钮文本为Switch。
- en: 'Set an OnClick handler for the Switch button, as follows:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为Switch按钮设置OnClick处理程序，如下所示：
- en: '![](img/3a757e63-cb52-4f4f-b13e-bb07e5d1ab50.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3a757e63-cb52-4f4f-b13e-bb07e5d1ab50.png)'
- en: Adding a button OnClick handler
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 添加按钮的OnClick处理程序
- en: We set the parameter, which is a string, to Main. Main is the name of the scene
    we want to switch to when the user clicks on the button.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将参数设置为字符串类型的“Main”。Main是我们想要切换到的场景名称，当用户点击按钮时，将切换到该场景。
- en: Drag the `SceneSwitcher` object from the Hierarchy window and drop it into the
    `Assets/HoloCore/Prefabs` folder of the Project window. This will create a new
    prefab for us to use in the Main scene.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“Hierarchy”窗口拖动“SceneSwitcher”对象到“Project”窗口的“Assets/HoloCore/Prefabs”文件夹中。这将为我们创建一个新的预制件，以便在主场景中使用。
- en: Double-click on the Main scene in the `Assets/HoloCore/Scenes` folder. When
    prompted, save the `Navigation` scene changes, of course.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击“Assets/HoloCore/Scenes”文件夹中的“Main”场景。当提示保存“Navigation”场景更改时，当然要保存。
- en: Drag the `SceneSwitcher` prefab from the `Assets/HoloCore/Prefabs` folder and
    drop it into an empty area of the Hierarchy window.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“Assets/HoloCore/Prefabs”文件夹拖动“SceneSwitcher”预制件并将其拖放到“Hierarchy”窗口的空白区域。
- en: Set the Map Camera property on the `SceneSwitcher` component (on `SceneSwitcher`
    object) to the VideoSeeThroughCamera.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“SceneSwitcher”组件（在“SceneSwitcher”对象上）上设置地图相机属性为VideoSeeThroughCamera。
- en: Expand the `SceneSwitcher` object and locate the Switch button. Change the OnClick
    event handler to pass `Navigation`,which is the scene we want to load from Main.
    Remember that the scene names must match exactly, so watch your case.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开SceneSwitcher对象并找到Switch按钮。将OnClick事件处理程序更改为传递“Navigation”，这是我们想要从主场景加载的场景。请记住，场景名称必须完全匹配，所以要注意大小写。
- en: Save the scenes.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存场景。
- en: Modifying the Wrld map script
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改Wrld地图脚本
- en: 'We are almost done; the last thing we need to do is let the `Wrld Map` script
    pull the last camera''s position from our singleton `SceneController`. This means
    that we unfortunately have to modify the source of the `Wrld Map` script. Generally,
    we want to avoid modifying a third-party API, except that we have the source,
    and it really is our only option. Open up the `WrldMap` script, located in the
    `Assets/Wrld/API` folder, and follow along:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了；我们最后需要做的是让“Wrld Map”脚本从我们的单例“SceneController”中获取最后一个摄像机的位置。这意味着我们不幸地必须修改“Wrld
    Map”脚本的源代码。通常，我们想要避免修改第三方API，除非我们有源代码，并且它真的是我们唯一的选项。打开位于“Assets/Wrld/API”文件夹中的“WrldMap”脚本，并按照以下步骤操作：
- en: 'Insert the following, between the lines identified:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在指定的行之间插入以下内容：
- en: '[PRE8]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Scroll down to the `SetupApi` method and insert the following code between
    the lines identified:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到“SetupApi”方法并在指定的行之间插入以下代码：
- en: '[PRE9]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: All this does is set the map to the last position the camera was pointed at.
    You can see that we are using the `SceneController` singleton here to access the
    camera's last known position. You can see in the `SetupApi` method where a configuration
    object is defined and set. Hopefully, in the future, `Wrld` allows for this configuration
    to be passed into the script. If that was possible, we could just modify that
    configuration before it is passed to the `WrldMap` script, thus eliminating the
    need for us to add our own code in the class.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有这些做的只是将地图设置到相机最后指向的位置。你可以看到我们在这里使用`SceneController`单例来访问相机最后已知的位置。你可以在`SetupApi`方法中看到定义和设置配置对象的地方。希望在未来，`Wrld`允许将此配置传递到脚本中。如果那样可能，我们就可以在传递给`WrldMap`脚本之前修改该配置，从而消除我们在这个类中添加自己代码的需要。
- en: Save the file and return to Unity. Check for any errors.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并返回Unity。检查是否有任何错误。
- en: 'Open the Build Settings dialog and ensure that both scenes are added, active,
    and in the order shown in the following excerpt:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开构建设置对话框，确保两个场景都已添加、激活，并且顺序如以下摘录所示：
- en: '![](img/5e6692a0-5ea2-40fc-8c14-6f1a8311348a.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5e6692a0-5ea2-40fc-8c14-6f1a8311348a.png)'
- en: Setting the scenes and scene order on Build Settings dialog
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建设置对话框中设置场景和场景顺序
- en: 'Connect, build, and run the app. Since we are starting at `0`, `0` in latitude
    and longitude spatial coordinates, the map will start just off the coast of Africa,
    which is `0`, `0`. Use a pinch touch gesture to zoom out until you see the global
    view of the world. Use a touch slide gesture to pan the map to North America,
    currently the best place to view `WRLD` data. Choose an area that is familiar
    and zoom in until you start to see 3D objects. Then, press the Switch button to
    switch the interface to MR and AR. You can switch back to the Main view by pressing
    Switch again. The following is an image showing the augmented reality mode and
    another user using the mixed reality mode with a HoloKit headset:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接、构建并运行应用。由于我们从`0`开始，即纬度和经度空间坐标的`0`，地图将从非洲海岸开始，这是`0`，`0`。使用捏合触摸手势放大，直到你看到全球视图。使用触摸滑动手势将地图平移到北美洲，目前是查看`WRLD`数据的最佳位置。选择一个熟悉的地方并放大，直到你开始看到3D对象。然后，按一下切换按钮以切换界面到MR和AR。你可以再次按切换按钮返回主视图。以下是一张显示增强现实模式和另一个用户使用HoloKit头戴式设备混合现实模式的图片：
- en: '![](img/8d2c2037-bde3-4528-b0d2-baa90bd633c7.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8d2c2037-bde3-4528-b0d2-baa90bd633c7.png)'
- en: Augmented reality view of the application running
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 应用运行时的增强现实视图
- en: We now have an app that lets a user navigate a map and then switch to view areas
    of interest in AR or MR mode. This works well, except that it would be better
    if the user started at their current position. In order to do that, we need to
    understand a bit more about mapping, GIS, and GPS, which we will cover in the
    next section.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在有一个应用，允许用户在地图上导航，然后切换到AR或MR模式查看感兴趣的区域。这工作得很好，但如果用户从当前位置开始会更好。为了做到这一点，我们需要对地图、GIS和GPS有更多的了解，我们将在下一节中介绍。
- en: Mapping, GIS, and GPS
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地图、GIS和GPS
- en: 'Unity, as we already learned, tracks its objects in 3D space using a point
    with a **Cartesian** coordinate reference system of x, y, and z. When we plot
    a point on a map of the world, it is no different; we need to reference the point,
    except that now we need to use a spherical or **geographic** reference system
    to represent a position on the earth, because as we all know, the earth is spherical.
    However, converting between a geographic system and Cartesian system is expensive.
    Many mapping applications, therefore, use an intermediary reference known as **earth-centered**, **earth-fixed** (**ECEF**),
    which represents mapping data on an earth-fixed Cartesian coordinate reference
    system. The following is a diagram shows the differences between Cartesian, geographic,
    and ECEF coordinate reference systems:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们已学到的，Unity使用一个带有**笛卡尔**坐标参考系统（x、y和z）的点在3D空间中跟踪其对象。当我们在一个世界地图上绘制一个点时，情况并无不同；我们需要参考这个点，但现在我们需要使用球面或**地理**参考系统来表示地球上的一个位置，因为我们都知道地球是球形的。然而，在地理系统和笛卡尔系统之间转换是昂贵的。因此，许多地图应用使用一个称为**地球中心**、**地球固定**（**ECEF**）的中间参考系统，它在一个地球固定的笛卡尔坐标参考系统上表示地图数据。以下是一个显示笛卡尔、地理和ECEF坐标参考系统之间差异的图表：
- en: '![](img/32cf584a-1169-4fd4-8e23-210c0e0ccbf9.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/32cf584a-1169-4fd4-8e23-210c0e0ccbf9.jpg)'
- en: Comparison of coordinate reference systems
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 坐标参考系统比较
- en: Now, you may have already noticed that WRLD supports ECEF out of the box. As
    we mentioned, since ECEF is already in a Cartesian frame of reference, the conversions
    are much easier and quicker. However, for us, we just want to position the camera
    at the user's geographic coordinate reference, which we can easily obtain from
    the user's device using GPS.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能已经注意到WRLD默认支持ECEF。正如我们提到的，由于ECEF已经在笛卡尔坐标系中，转换要容易得多，也快得多。然而，对我们来说，我们只想将相机定位在用户的地理坐标参考上，这可以通过使用GPS从用户的设备中轻松获得。
- en: 'Accessing the user''s GPS on their device takes a bit of work, but fortunately,
    we can do this all in one place. Let''s open up the `SceneController` script and
    make the following modifications:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 访问用户设备上的GPS需要一些工作，但幸运的是，我们可以在一个地方完成所有这些操作。让我们打开`SceneController`脚本并做出以下修改：
- en: 'Add two new properties at the top of the class:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类顶部添加两个新属性：
- en: '[PRE10]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create a new method just under the constructor:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数下方创建一个新方法：
- en: '[PRE11]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `Awake` method is a special Unity method that runs when the `GameObject`
    first initializes. Inside of the method, we are calling `StartCoroutine`. `StartCoroutine`
    is another special method in Unity that allows you to create a `coroutine`. `Coroutines`
    are a way of interrupting or breaking your code flow, doing something else, and
    then returning to complete your original task. In the call, we are passing in
    a method call `GetLocationPoint()`, which sets up that method as a `coroutine`.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Awake`方法是一个特殊的Unity方法，当`GameObject`首次初始化时运行。在方法内部，我们调用`StartCoroutine`。`StartCoroutine`是Unity中的另一个特殊方法，允许你创建`coroutine`。`Coroutines`是一种中断或打断你的代码流，做其他事情，然后返回以完成原始任务的方式。在调用中，我们传递一个方法调用`GetLocationPoint()`，将此方法设置为`coroutine`。'
- en: 'Add the following method to create the `coroutine`:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下方法来创建`coroutine`：
- en: '[PRE12]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A coroutine must return `IEnumerator`. By adding the return type, the method
    can now `yield` or interrupt its execution with a `yield return` statement that
    returns a `YieldInstruction`. We will see how to do that shortly.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 协程必须返回`IEnumerator`。通过添加返回类型，该方法现在可以使用返回`YieldInstruction`的`yield`或中断其执行的`yield
    return`语句。我们很快就会看到如何做到这一点。
- en: 'Just inside `GetLocationPoint`, add the following line:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GetLocationPoint`内部添加以下行：
- en: '[PRE13]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This line of code prompts the user for access to the `location` services, also
    known as GPS. We do this in order to explicitly identify the user's `location`,
    provided that their device's GPS is not being blocked or the user has the `location`
    service disabled.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这行代码提示用户获取对`location`服务的访问权限，也称为GPS。我们这样做是为了明确识别用户的`location`，前提是他们的设备GPS没有被阻止或者用户已经禁用了`location`服务。
- en: Google has developed their own `location` service in essence by mapping wireless
    endpoint MAC addresses to geographic coordinates. Google does this by essentially
    war driving with its self-driving Street View cars. While those cars drive themselves
    around, they are also grabbing the MAC address of every wireless device that they
    can detect at the time of mapping that to a GPS `location`. As it turns out, this
    service can actually be more accurate for providing `location` in more dense metropolitan
    areas where GPS line of sight is difficult.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Google通过将无线端点MAC地址映射到地理坐标的方式本质上开发了他们自己的`location`服务。Google通过本质上使用其自动驾驶街景汽车进行war
    driving来实现这一点。当这些汽车自动驾驶时，它们也在抓取在映射到GPS`location`时可以检测到的每个无线设备的MAC地址。结果证明，这个服务实际上在提供`location`方面可以更准确，尤其是在GPS视线难以到达的更密集的都市地区。
- en: 'Then, add the following:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加以下内容：
- en: '[PRE14]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This block of code checks whether the user had GPS enabled; if they don't, there
    is nothing we can do. We set `isLoaded` to `true`, which will be a flag to let
    outside methods know that we found or didn't find a `location`. Then, we `yield
    return` the results of a call to `SetStatus`. Remember that because we are in
    a `coroutine`, `yield return` means that we want to interrupt code execution at
    this point.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这段代码检查用户是否启用了GPS；如果没有，我们无法做任何事情。我们将`isLoaded`设置为`true`，这将作为一个标志，让外部方法知道我们找到了或没有找到`location`。然后，我们`yield
    return`调用`SetStatus`的结果。记住，因为我们处于`coroutine`中，`yield return`意味着我们想要在此处中断代码执行。
- en: 'Scroll down just past the `GetLocationPoint` method and add the following new
    method:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GetLocationPoint`方法下方向下滚动并添加以下新方法：
- en: '[PRE15]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Inside the method, we are setting our `status` text, which will be a message
    we want to display back to the user. Then, we return a new `WaitForSeconds(time)`,
    where `time` represents the number of seconds to wait. There are many different
    forms of `YieldInstruction` that you can use to break your code. The `YieldInstruction`
    here just waits for a set number of seconds and then returns to continue the code
    where it left off. Keep in mind that after the `yield` has elapsed, for whatever
    reason, code will then resume from exactly where it left off.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在方法内部，我们正在设置我们的`status`文本，这将是我们想要显示给用户的消息。然后，我们返回一个新的`WaitForSeconds(time)`，其中`time`代表要等待的秒数。有许多不同的`YieldInstruction`形式可以用来中断你的代码。这里的`YieldInstruction`只是等待设定数量的秒数，然后返回继续执行代码的当前位置。请注意，在`yield`过期后，无论出于什么原因，代码将从确切的位置继续执行。
- en: Return to where we left off in `GetLocationPoint`. Right after the `yield return
    SetStatus` call, we are executing `yield break`. This line breaks the `coroutine`
    and exits the method, which is equivalent to return in a normal method.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到`GetLocationPoint`中我们离开的地方。在`yield return SetStatus`调用之后，我们正在执行`yield break`。这一行会中断`coroutine`并退出方法，这在普通方法中相当于返回。
- en: 'Now that we understand `coroutines`, let''s enter the next section of code:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经理解了`coroutines`，让我们进入下一部分的代码：
- en: '[PRE16]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: First, we start by setting a `status` message and letting the user know that
    we are starting the service, which we then do. After that, we continually loop,
    breaking every second with `yield return new WaitForSeconds(1)`, adjusting our
    counter `maxWait` for every iteration. We need to wait for the `location` service
    to initialize; sometimes this can take a while.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们设置一个`status`消息并让用户知道我们正在启动服务，然后我们这样做。之后，我们不断地循环，每秒使用`yield return new WaitForSeconds(1)`中断一次，每次迭代调整我们的计数器`maxWait`。我们需要等待`location`服务初始化；有时这可能需要一段时间。
- en: 'Enter the following code to handle when our counter has expired (`maxWait<1`):'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下代码以处理当我们的计数器已过期（`maxWait<1`）的情况：
- en: '[PRE17]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Inside the `if` block, we set the `status` and `loaded` flag. Then, we return
    from the `coroutine` with `yield break`.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`if`块内部，我们设置`status`和`loaded`标志。然后，我们使用`yield break`从`coroutine`返回。
- en: 'Next, we want to handle when the service fails or starts by entering the following:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们想要处理服务失败或启动的情况，如下所示：
- en: '[PRE18]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This code handles the service failure or success. In the failure path, we set
    an error message and exit. Otherwise, we set a `status` and wait for `10` seconds.
    We do this so that the user can read the message. Then, we set the position according
    to the geographic coordinates the device provides us with.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此代码处理服务失败或成功。在失败路径中，我们设置一个错误消息并退出。否则，我们设置一个`status`并等待`10`秒。我们这样做是为了让用户能够阅读消息。然后，我们根据设备提供的地理坐标设置位置。
- en: 'Finally, we stop the service with this:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用以下代码停止服务：
- en: '[PRE19]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We stop the service because we don't need to continually get `location` updates.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们停止服务是因为我们不需要不断地获取`location`更新。
- en: If you want to keep the service open and use it to track the user's `location`,
    such as Pokemon Go, then just ensure that you stop the service when the object
    is being destroyed. You can do this in a method called `OnDisable()`, which is
    another special Unity method that is used to clean up the object.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你想要保持服务开启并使用它来跟踪用户的`location`，例如像《精灵宝可梦GO》这样的应用，那么只需确保在对象被销毁时停止服务。你可以在名为`OnDisable()`的方法中这样做，这是另一个特殊的Unity方法，用于清理对象。
- en: 'At this point, we also want to update and overload the `LoadScene` method with
    the following code:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，我们还想更新并重载`LoadScene`方法，如下所示：
- en: '[PRE20]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We overloaded the method in order to allow two different behaviors when switching
    scenes. The new method we added won't worry about setting the `position` for the
    camera. We also added some logging, so we can see what values are being set by
    looking at our Android debug tools while running the app.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们对方法进行了重载，以便在切换场景时允许两种不同的行为。我们添加的新方法不会担心设置摄像机的`position`。我们还添加了一些日志记录，这样我们可以在运行应用时通过查看Android调试工具来查看正在设置的值。
- en: Save the file when you are done.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后保存文件。
- en: The code we just set up was originally derived from the Unity sample, but it
    has been modified for your reuse. Since accessing the `location` service can take
    a while, we will add a new scene in order to handle the `location` service starting
    up. This will be a splash screen that you can make prettier later on.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚设置的代码最初是从Unity示例中派生出来的，但已经修改过以供你重用。由于访问`location`服务可能需要一段时间，我们将添加一个新的场景来处理`location`服务的启动。这将是一个可以在以后让它更美观的启动画面。
- en: Making the Splash scene
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作Splash场景
- en: 'The `Splash` scene we are building is very basic for now, with just some status
    messages. You can, of course, style it and add any images you like later on. Open
    up the editor and complete the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在构建的`Splash`场景目前非常基础，只有一些状态消息。当然，您可以稍后对其进行样式化并添加您喜欢的任何图像。打开编辑器并完成以下操作：
- en: Create a new scene called `Splash` and save the scene to the `Assets/HoloCore/Scenes`
    folder.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Splash`的新场景，并将其保存到`Assets/HoloCore/Scenes`文件夹中。
- en: From the menu, select GameObject | UI | Panel. This will add a new Canvas with
    a child Panel and EventSystem. Set the background color of Panel to a dark gray.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从菜单中选择GameObject | UI | Panel。这将添加一个新的Canvas，其中包含一个子面板和EventSystem。将面板的背景颜色设置为深灰色。
- en: 'Select the Panel and, from the menu, select GameObject | UI | Text. Change
    the name of the object to `Status` and set its properties in the Inspector window,
    as shown:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择面板，从菜单中选择GameObject | UI | Text。将对象的名称更改为`Status`，并在检查器窗口中设置其属性，如下所示：
- en: '![](img/decf2da0-be21-4626-9c74-3b8befc51038.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/decf2da0-be21-4626-9c74-3b8befc51038.png)'
- en: Setting the Status text properties
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 设置状态文本属性
- en: This is the where we will display those status messages back to the user, which
    means that we need a script that can update the `status` messages as well as know
    when the service has been loaded and the application can start.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是我们将向用户显示那些状态消息的地方，这意味着我们需要一个可以更新`状态`消息并知道服务何时加载以及应用何时可以开始的脚本。
- en: 'Create a new C# script called `SceneLoader` in the `Assets/HoloCore/Scripts`
    folder and replace the pre-generated code with the following:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/HoloCore/Scripts`文件夹中创建一个新的C#脚本名为`SceneLoader`，并用以下代码替换预生成的代码：
- en: '[PRE21]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This simple class is what we will use to track the status of our `SceneController`.
    All the action takes place in the `Update` method. We first check whether the
    `SceneController` has loaded by testing `isLoaded`. If the scene has not loaded,
    we display the `status` text in the `statusText.text` object. Remember that the `Update` method
    is run every rendering frame, so we are testing this condition several times a
    second. Save the script, and next, we need to add it as a component to our scene.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个简单的类是我们用来跟踪我们的`SceneController`的状态的。所有的动作都在`Update`方法中发生。我们首先通过测试`isLoaded`来检查`SceneController`是否已加载。如果场景未加载，我们在`statusText.text`对象中显示`状态`文本。记住，`Update`方法在每个渲染帧中运行，所以我们每秒测试这个条件几次。保存脚本，然后，我们需要将其添加为场景的组件。
- en: Return to the Unity editor and wait for the new class to compile.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回Unity编辑器并等待新类编译。
- en: 'Create a new object called `ScreenLoader` and add the new `ScreenLoader` script
    to it. Then, set the properties of `SceneLoader` to what is shown here:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ScreenLoader`的新对象，并将新的`ScreenLoader`脚本添加到其中。然后，将`SceneLoader`的属性设置如下所示：
- en: '![](img/c6c0e1fe-e4d1-4a08-b4c7-9bded136ac6d.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c6c0e1fe-e4d1-4a08-b4c7-9bded136ac6d.png)'
- en: Setting the SceneLoader component properties
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 设置SceneLoader组件属性
- en: Set the Status Text property to the `Status` object. You can use the bull's-eye
    icon to select the object from the scene or just drag the object from the Hierarchy
    window and drop it into the slot.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将状态文本属性设置为`Status`对象。您可以使用瞄准器图标从场景中选择对象，或者只需从层次结构窗口中拖动对象并将其放入槽中。
- en: Save the scene.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存场景。
- en: 'Open Build Settings, add the `Splash` scene to the build, and ensure that it
    is the first scene, as follows:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开构建设置，将`Splash`场景添加到构建中，并确保它是第一个场景，如下所示：
- en: '![](img/3891abf3-6dc3-49c9-949f-e556357cd172.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3891abf3-6dc3-49c9-949f-e556357cd172.png)'
- en: Adding the Splash scene to the build
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 将Splash场景添加到构建中
- en: Go ahead, connect, build, and run. You will now be taken to `location` as identified
    by the `Location` service, that is, if you allow the service to connect.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续连接、构建和运行。现在，您将被带到由`Location`服务识别的`位置`，即，如果您允许服务连接的话。
- en: Fixing the altitude issue
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决高度问题
- en: 'You may notice an issue if you live above 500 meters above sea level. This
    issue happens because our AR camera is fixed at 500 meters altitude. The problem
    is that we have our AR camera at a fixed height; we now need to adjust that based
    on the camera''s altitude. Open back up the editor and complete the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您居住在海平面以上500米的地方，您可能会遇到一个问题。这个问题发生是因为我们的AR相机固定在500米的高度。问题是我们的AR相机在固定高度；我们现在需要根据相机的高度进行调整。重新打开编辑器并完成以下操作：
- en: 'Create a new C# script and replace the code with the following:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的C#脚本，并用以下代码替换代码：
- en: '[PRE22]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This script creates a new class called `SceneCameraMover`. The job of `SceneCameraMover` is
    to move the AR camera into position when the view switches to AR / MR.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本创建了一个名为`SceneCameraMover`的新类。`SceneCameraMover`的职责是在视图切换到AR / MR时将AR摄像头移动到位。
- en: Save the script and return to Unity.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本并返回Unity。
- en: Open the Main scene from the `Assets/HoloCore/Scenes` folder.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Assets/HoloCore/Scenes`文件夹中打开主场景。
- en: Expand HoloKitCameraRig and select VideoSeeThroughCamera. Then, add the script
    to the component using Add Component and searching for SceneCameraMover.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开HoloKitCameraRig并选择VideoSeeThroughCamera。然后，使用添加组件并搜索SceneCameraMover来将脚本添加到组件中。
- en: Set the Transform on the HoloKitCameraRig to `0`, `0`, `0`. We will now let
    the script move the camera to the position we need.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将HoloKitCameraRig的变换设置为`0`，`0`，`0`。现在我们将让脚本将摄像头移动到所需的位子。
- en: Save the scenes and project.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存场景和项目。
- en: Connect, build, and run. Go to an area that is well above sea level, say the
    mountains, and switch to AR / MR view. The camera should now position itself correctly
    based on the altitude you were viewing the scene at.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接、构建和运行。前往海拔较高的地区，比如山区，并切换到AR / MR视图。现在摄像头应该根据你观看场景的海拔高度正确定位。
- en: Ensure that you explore other areas of interest around the world. In the next
    section, we will finish up the chapter and our discussion of AR and ARCore with
    the next steps, and we'll see where you can go to build your own incredible tech
    demo or commercial app.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你探索世界各地其他感兴趣的区域。在下一节中，我们将完成本章和我们对AR和ARCore的讨论，并讨论下一步行动，看看你可以在哪里构建你自己的令人难以置信的科技演示或商业应用。
- en: The online example demos from WRLD recommend using an alternate streaming camera
    for AR visuals in ARCore or ARKit apps. However, we found that adding an alternate
    camera, alongside the already two additional cameras for the HoloKit, caused the
    app to be more unstable than it already can be. If you don't plan to use MR or
    HoloKit, you likely want to experiment with the alternate streaming camera.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: WRLD的在线示例演示建议在ARCore或ARKit应用中使用备用流式传输摄像头进行AR视觉效果。然而，我们发现添加备用摄像头，加上HoloKit已经有的两个额外摄像头，使得应用比之前更加不稳定。如果你不打算使用MR或HoloKit，你可能想尝试备用流式传输摄像头。
- en: What's next?
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来是什么？
- en: 'The tech demo we developed is an excellent example of the possibilities of
    integrating technologies across user experiences. This has already been done extensively,
    and one popular example is Pokemon Go. In fact, you can say that Pokemon Go put
    AR into our vocabulary. So what is the next big AR app you will develop with ARCore?
    Are you still trying to think of some ideas or possibilities? The following is
    a list of app ideas or industries that are investing heavily in AR right now:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开发的科技演示是跨用户体验集成技术可能性的绝佳例子。这已经得到了广泛的应用，一个流行的例子就是《精灵宝可梦GO》。事实上，你可以说《精灵宝可梦GO》将AR带入了我们的词汇。那么，你接下来会用ARCore开发什么下一个大型的AR应用？你还在尝试想出一些想法或可能性吗？以下是一些应用想法或正在大力投资AR的行业列表：
- en: '**Entertainment (Games)**: Gaming and entertainment is the most competitive
    space you can be in. Developing an app for this space requires hard work and a
    bit of luck. There have been some grand successes in this space, but that was
    after some hard work and considerable backing.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**娱乐（游戏）**：游戏和娱乐是你能进入的最具竞争性的领域。为这个领域开发应用需要辛勤工作和一点运气。这个领域已经取得了一些巨大的成功，但这是在一些艰苦的工作和相当大的支持之后。'
- en: '**Healthcare (Emergency services)**: The healthcare industry is diving into
    the AR / MR and VR world in full force. Since this industry is heavily funded,
    it is now a leader in these technologies. If you want to get into cutting-edge
    reality development, this is the space to be in. It can be more difficult to get
    into, since this industry has traditionally been more isolated, but now there
    are plenty of opportunities with the explosion of growth.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**医疗保健（紧急服务）**：医疗保健行业正全力投入AR / MR和VR世界。由于这个行业资金雄厚，现在在这些技术领域处于领先地位。如果你想进入尖端现实开发领域，这就是你应该所在的空间。进入这个领域可能更具挑战性，因为这个行业传统上更加孤立，但现在随着增长爆炸，有很多机会。'
- en: '**Marketing (Retail)**: As AR becomes more mainstream and readily available,
    we will come across new apps developed in this space. There have already been
    some great novel concepts used to encourage sales, which have worked, except that
    AR has become something of a novelty in this space as of late. However, if you
    talk to anyone in marketing, they will agree that some day a majority of advertising
    will be provided via AR. Until then though, perhaps you can think of the next
    great app that will sell hamburgers.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**市场营销（零售）**：随着增强现实变得更加主流和易于获取，我们将遇到在这个领域开发的新应用。已经有一些伟大的创新概念被用来促进销售，并且效果显著，但增强现实在这个领域最近已经变成了一种新奇事物。然而，如果你和市场营销领域的人交谈，他们会同意总有一天大部分广告将通过增强现实提供。在此之前，也许你可以想想下一个伟大的应用，它将卖出汉堡。'
- en: '**Education (Knowledge transfer)**: This is another really big industry that
    can be hard to get into, that is, if you are planning to put your app in a classroom.
    Alternatively, you can build an educational app that perhaps teaches you how to
    cook but is delivered through an app store. Either way, this can be a difficult
    industry to get into but very rewarding, especially if you like teaching or learning.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**教育（知识转移）**：这是一个非常大的行业，进入可能很困难，尤其是如果你计划将你的应用放入教室。或者，你可以构建一个教育应用，也许教你如何烹饪，但通过应用商店提供。无论如何，这是一个可能很难进入但非常有益的行业，尤其是如果你喜欢教学或学习。'
- en: '**Military**: It''s very difficult to get into, unless you have a military
    background or other established credentials. This likely means a strong educational
    background as well. This is an interesting industry if you can get in, and is
    certainly not for everyone. If this is your choice though, you will most certainly
    be working on cutting-edge apps or tools.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**军事**：除非你有军事背景或其他既定资历，否则进入这个领域非常困难。这很可能意味着你需要有强大的教育背景。如果你能进入这个领域，这确实是一个有趣的选择，但绝对不是适合每个人。如果你选择了这个方向，你肯定会从事最前沿的应用或工具的开发工作。'
- en: '**Travel & tourism (History)**: This one crosses over with education, as some
    of the same principles may apply. Perhaps, it is showing someone a historical
    battle over the area where the real battle took place. There are plenty of opportunities
    for developers of all skill levels to work in this area building AR / MR apps.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**旅游与旅游业（历史）**：这个领域与教育有所交叉，因为可能适用一些相同的原则。也许是通过增强现实向某人展示该地区的历史战役。对于所有技能水平的开发者来说，在这个领域构建增强现实/混合现实应用有很多机会。'
- en: '**Design (All)**: This one can tie in a lot with retail applications. Perhaps
    demonstrating an outfit overlaid onto someone''s body or trying to determine whether
    a chair works in a room. We put this further down in the list because our expert
    survey listed this one lower as well. However, as we demonstrated, ARCore has
    plenty of great design applications.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设计（所有）**：这个领域可以与零售应用紧密相连。也许是在某人身上叠加一套服装，或者尝试确定一把椅子是否适合房间。我们把这个领域放在列表的后面，因为我们的专家调查也把这一项列得较低。然而，正如我们所展示的，ARCore有很多优秀的设计应用。'
- en: '**Industrial (Manufacturing)**: Applications of AR can help human users as
    well as provide better foundations for future automation of systems or other processes.
    This means that the AR systems we build for humans now will also help us make
    the manufacturing robots of the future smarter.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工业（制造业）**：增强现实的应用可以帮助人类用户，同时也为未来系统或其它流程的自动化提供更好的基础。这意味着我们现在为人类构建的增强现实系统也将帮助我们使未来的制造机器人变得更智能。'
- en: '**Automotive**: We have already seen AR system in automobiles for a few years
    now. From heads-up displays to GPS devices, this industry has already embraced
    AR, although it isn''t likely that developing an embedded AR app for this industry
    makes a lot of sense. Most users, drivers, would likely prefer to use an AR off
    their device. Perhaps it makes more sense for the automotive industry to provide
    a docking station for a mobile device in vehicles with an AR interface?'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**汽车**：我们已经看到增强现实系统在汽车中的应用有几年了。从抬头显示到GPS设备，这个行业已经接受了增强现实，尽管为这个行业开发嵌入式增强现实应用可能并不合理。大多数用户，即驾驶员，可能会更愿意使用他们设备上的增强现实。也许对于汽车行业来说，在车辆中提供一个带有增强现实界面的移动设备底座更有意义？'
- en: '**Music**: Think of this as more for the musician and not the audience. This
    is a set of AR tools that help musicians compose and work with music. Not for
    everyone and not well suited to ARCore, perhaps they will embed voice recognition
    or other audio recognition into ARCore someday.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**音乐**：这更多的是针对音乐家而不是听众。这是一套帮助音乐家创作和工作的AR工具。可能并不适合所有人，也许将来ARCore会嵌入语音识别或其他音频识别技术。'
- en: Whatever you plan to build as your next app, we sincerely wish you the best
    of luck and would eagerly like to hear about any great apps. Be sure to contact
    the author with your great app concepts.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你计划构建什么作为你的下一个应用程序，我们都衷心祝愿你一切顺利，并热切地想了解任何伟大的应用程序。请务必与作者联系，分享你的伟大应用程序概念。
- en: Exercises
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: '**Complete the following exercises on your own:**'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**请独立完成以下练习：**'
- en: Go back to the `HoloCore` example and track the user's position with a block
    or sphere. Hint—the first part of this example is in the code download.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到 `HoloCore` 示例，并使用一个方块或球体追踪用户的位置。提示——本示例的第一部分包含在代码下载中。
- en: Track the user's position as they move on the map. Hint—you will now need to
    update the user's position from the most recent GPS readings.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 追踪用户在地图上的移动位置。提示——你现在需要根据最新的GPS读数更新用户的位置。
- en: Track multiple users' positions around you. Hint—you can use the Firebase Realtime
    Database to track the user's position in geographic coordinates.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 追踪你周围多个用户的位置。提示——你可以使用Firebase实时数据库来追踪用户的地理位置坐标。
- en: Summary
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: For this chapter, we diverted away from AR a little and explored mixing augmented
    and mixed reality. We discovered that we can easily experience mixed reality apps
    with a simple device called a HoloKit or other cheap headset. ARCore tracks the
    user well and is a great fit for adding the MR experience. Who knows, in the future
    when everyone is wearing MR glasses, will we even distinguish AR and MR as different?
    We then set up the HoloKit template app and went to work building a quick MR demo.
    After that, we expanded on our demo by adding in WRLD. WRLD, as we learned, is
    a fun and easy-to-use API that can quickly give us some large-scale impressive
    3D scenery that is representative of the user's area. From there, we developed
    a number of scenes for all the users to move a map touch interface to a full mixed-reality
    view of the map, where we were able to obtain the user's geographic coordinates
    from their device's GPS and put them at the same position in WRLD. Finally, we
    looked to the future and industries that you can focus your app development skills
    on.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们稍微偏离了AR，探索了混合增强和混合现实。我们发现，我们可以通过一个简单的设备HoloKit或其他廉价的头盔轻松体验混合现实应用程序。ARCore很好地追踪用户，非常适合添加MR体验。谁知道呢，在未来的某一天，当每个人都戴着MR眼镜时，我们甚至能区分AR和MR的不同吗？然后我们设置了HoloKit模板应用程序，开始构建一个快速的MR演示。之后，我们通过添加WRLD扩展了我们的演示。正如我们所学的，WRLD是一个有趣且易于使用的API，可以快速为我们提供一些大型的、令人印象深刻的3D场景，这些场景代表了用户所在区域。从那里，我们为所有用户开发了一系列场景，将地图触摸界面从地图的全混合现实视角移动，在那里我们能够从他们的设备GPS中获取用户的地理坐标，并将它们放置在WRLD中的相同位置。最后，我们展望未来，并关注你可以专注于应用程序开发的行业。
- en: We complete our journey in the next chapter with a discussion of performance
    and troubleshooting, both of which will be helpful as you grow your skills to
    become a better AR developer.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中完成我们的旅程，讨论性能和故障排除，这两者都将有助于你在提升技能成为更好的AR开发者时有所帮助。
