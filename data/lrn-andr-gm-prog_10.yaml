- en: Working Further on 3D Game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步工作在3D游戏上
- en: Now that we have defined our 3D shape, let's render it on our screen. However, before
    we begin this chapter, let's summarize everything we learned throughout the contents
    of this book since this is our last chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的3D形状，让我们在屏幕上渲染它。然而，在我们开始本章之前，让我们总结一下这本书内容中我们所学到的所有内容，因为这是我们最后一章。
- en: We learned a lot of cool stuff about Android. We started from learning about
    the history of Android and quickly progressed toward the installation of software
    required to develop apps for Android. After that, we installed Android Studio
    and configured it with the latest components of Android-N.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了关于Android的许多有趣的东西。我们从学习Android的历史开始，很快便转向了安装开发Android应用所需的软件。之后，我们安装了Android
    Studio，并使用Android-N的最新组件进行了配置。
- en: Once our environment was set up, we learned how to create a basic app for Android
    and learned about various concepts of Android, such as package names, inputs,
    emulators, and more. After getting an air of familiarity with Android, we learned
    about how to make a transition from making apps to games wherein we learned how
    to create a surface and canvas, which would allow us to create graphics for our
    game, and then we moved on to learn various concepts about game development.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的环境设置完成，我们学习了如何创建一个基本的Android应用，并了解了Android的各种概念，如包名、输入、模拟器等。在熟悉Android之后，我们学习了如何从制作应用过渡到制作游戏，其中我们学习了如何创建表面和画布，这将允许我们为游戏创建图形，然后我们继续学习游戏开发的各种概念。
- en: As we progressed further through our chapters, we started learning about the
    process of making games, and within a couple of chapters, we learned how to create
    a 2D game from scratch with a UI. We completed developing a fully-fledge 2D game
    with the same and then moved on to turning things into 3D.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们章节的深入，我们开始学习制作游戏的过程，在几章之内，我们学会了如何从头开始使用UI创建2D游戏。我们用同样的方法完成了一个完整的2D游戏开发，然后转向将事物转化为3D。
- en: In our previous chapter, we learned that we can create 3D games for native Android
    using OpenGL ES, and so we started with defining basic shapes.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的章节中，我们了解到我们可以使用OpenGL ES为原生Android创建3D游戏，因此我们开始定义基本形状。
- en: 'In this last chapter for this book, we will learn the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的最后一章，我们将学习以下主题：
- en: Rendering our object on screen
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在屏幕上渲染我们的对象
- en: Adding color to our object
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给我们的对象添加颜色
- en: Rotating both of our 3D objects
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旋转我们的两个3D对象
- en: Creating a pyramid
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个金字塔
- en: So without further ado, let's begin with this final part of our book, which
    will set us up with the foundation needed to begin your journey in 3D game development.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，无需多言，让我们开始这本书的最后一部分，这将为我们开始3D游戏开发之旅奠定所需的基础。
- en: Rendering our object on screen
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在屏幕上渲染我们的对象
- en: In our previous chapter, we created a class for our `Triangle` object; however,
    if you run your game, it will still show a blank screen since we have not used
    our render class to display it. We need to create an object for our newly defined
    class, and then using our GL reference, we will draw/render it on our screen.
    Open up your `MyGLRenderer.java` file and let's start by declaring a variable
    of our triangle. We won't be altering any of our code that we wrote in `onSurfaceCreated()`
    or `onSurfaceChanged()` methods.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的章节中，我们为我们的`Triangle`对象创建了一个类；然而，如果你运行你的游戏，它仍然会显示一个空白屏幕，因为我们还没有使用我们的渲染类来显示它。我们需要为我们的新定义的类创建一个对象，然后使用我们的GL引用，我们在屏幕上绘制/渲染它。打开你的`MyGLRenderer.java`文件，让我们首先声明一个三角形变量的声明。我们不会修改我们在`onSurfaceCreated()`或`onSurfaceChanged()`方法中编写的任何代码。
- en: 'In order to draw our object on screen, we will simply follow these steps:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的屏幕上绘制我们的对象，我们将简单地遵循以下步骤：
- en: Define a variable of our `Triangle` class.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义我们的`Triangle`类的变量。
- en: Assign a reference to it in our constructor.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的构造函数中为其分配一个引用。
- en: Using gl, access the `draw()` method in our `Triangle` to display it on screen.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用gl，在我们的`Triangle`中访问`draw()`方法，将其显示在屏幕上。
- en: 'Let''s take a look at how we can do that; just type in the code marked in bold
    in your `MyGLRenderer.java` file:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何做到这一点；只需在你的`MyGLRenderer.java`文件中输入以下加粗代码：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Pretty simple, right? That''s it! Your triangle object is ready to be rendered
    on screen. Don''t believe it? Go ahead; test and run it on your emulator/device,
    and you will get the following output:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 非常简单，就是这样！你的三角形对象已经准备好在屏幕上渲染了。你不相信吗？那就试试吧；在你的模拟器/设备上测试和运行它，你将得到以下输出：
- en: '![](img/B05066_10_01.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B05066_10_01.png)'
- en: Our triangle rendered on screen, finally!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的三角形终于渲染在屏幕上了！
- en: You might think that this object is still 2D, but wait till the part where we
    rotate it. However, before that, let's learn how to add color to this object.
    So let's add some colors.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为这个物体仍然是2D的，但请等到我们旋转它的部分。然而，在那之前，让我们学习如何给这个物体添加颜色。所以，让我们添加一些颜色。
- en: Adding colors to our object
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 给我们的物体添加颜色
- en: In this part, we will demonstrate how we can use different colors to texture
    our object. We will use RGB values using a `colorBuffer` to fetch values from
    the colors of the vertices. After this, we will enable the color-array client
    state, and then these colors are rendered together with the vertices in `glDrawElements()`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，我们将演示我们如何使用不同的颜色来纹理我们的物体。我们将使用`colorBuffer`中的RGB值从顶点的颜色中获取值。之后，我们将启用颜色数组客户端状态，然后这些颜色将与顶点一起在`glDrawElements()`中渲染。
- en: 'Here, we will again use nio''s `FloatBuffer` to declare our `colorBuffer` variable.
    Here are the steps we would use to add color to our object:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们再次使用nio的`FloatBuffer`来声明我们的`colorBuffer`变量。以下是我们要用到的步骤来给我们的物体添加颜色：
- en: We declare our `colorBuffer` variable.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明我们的`colorBuffer`变量。
- en: We declare our color array variable.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明我们的颜色数组变量。
- en: We copy our color vertices data to our buffer.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将我们的颜色顶点数据复制到我们的缓冲区。
- en: Enable our color array.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用我们的颜色数组。
- en: Define color array buffer.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义颜色数组缓冲区。
- en: Disable color array.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用颜色数组。
- en: 'Also, since this is a native property of the triangle, we will write this code
    in our `Triangle.java` class that we created and not in the `MyGLRenderer.java`
    class. Type in the code marked in bold keeping in mind the preceding steps:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于这是三角形的原生属性，我们将在这我们创建的`Triangle.java`类中编写此代码，而不是在`MyGLRenderer.java`类中。在输入代码时，请记住前面的步骤，并输入以下加粗的代码：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, we have a colored triangle. You will get an output like this if you used
    the specified color values. Of course, you are free to change and tweak the colors
    as you please by changing the RGB values in our `colors` variable:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个彩色的三角形。如果你使用了指定的颜色值，你会得到这样的输出。当然，你可以自由地通过改变`colors`变量中的RGB值来更改和调整颜色。
- en: '![](img/B05066_10_02.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B05066_10_02.png)'
- en: Our colored triangle
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们彩色的三角形
- en: Okay, now we will make our triangle rotate, which will clarify our doubts whether
    it is actually a 3D object or not.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们将使我们的三角形旋转，这将澄清我们的疑问，即它是否真的是一个3D物体。
- en: Rotating our object
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 旋转我们的物体
- en: By now, you must have understood that any changes in the rendering of an object
    have to be done in the `MyGLRenderer`, whereas any properties that are local to
    our object are to be done in the respective object's file. So, we will write our
    rotation code in our `MyGLRenderer.java` file because rotating an object is a
    part of the rendering process.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你必须已经明白，任何对物体渲染的改变都必须在`MyGLRenderer`中进行，而任何属于我们物体的本地属性则需要在相应的物体文件中进行。因此，我们将把我们的旋转代码写在`MyGLRenderer.java`文件中，因为旋转一个物体是渲染过程的一部分。
- en: 'Here''s our logic to rotate our triangle:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们旋转三角形的逻辑：
- en: We take our rotation angle
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们获取我们的旋转角度
- en: We rotate our object in a specified rotation angle
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在指定的旋转角度旋转我们的物体。
- en: We increment our rotation angle
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们增加我们的旋转角度
- en: 'Let''s do it; we will simply declare two variables at the start for our rotational
    angle and speed; then in our `onDrawFrame()` method, implement our rotation logic,
    as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来做这件事；我们将在开始时简单地声明两个变量来表示旋转角度和速度；然后在我们的`onDrawFrame()`方法中实现我们的旋转逻辑，如下所示：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After you compile this code, your triangle will start rotating. Cool, right?
    Build and run and see your rotating triangle in action!:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 编译此代码后，你的三角形将开始旋转。酷吧？构建并运行，看看你的旋转三角形在动作中的样子！：
- en: '![](img/B05066_10_03.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B05066_10_03.png)'
- en: Our rotating triangle
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们旋转的三角形
- en: Fantastic! Now, let's use this knowledge to create a proper 3D object, our pyramid!
    We're pretty clear about the process for creating objects, so we will breeze through
    the pyramid part.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在，让我们利用这些知识来创建一个合适的3D物体，我们的金字塔！我们对创建物体的过程非常清楚，所以我们将快速浏览金字塔的部分。
- en: Let's repeat the same steps for our pyramid. This time our object will be purely
    3D rather than just a 2D plane object; so, let's start!
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重复相同的步骤来创建金字塔。这次我们的物体将完全是3D的，而不仅仅是2D平面物体；所以，让我们开始吧！
- en: Creating a pyramid 3D object
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个金字塔3D物体
- en: Now that you have understood how to define shapes and render objects on screen,
    it will be comparatively easier to create our 3D object. We will follow almost
    the same procedure as we did to create our triangle. We will create our pyramid
    right besides our triangle; let's begin.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了如何定义形状并在屏幕上渲染对象，创建我们的3D对象将相对容易。我们将遵循与创建我们的三角形几乎相同的程序。我们将创建金字塔，就在我们的三角形旁边；让我们开始吧。
- en: Defining the shape
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义形状
- en: As we've learned from the previous part, we will first create a class of our
    pyramid in order to define our shape. So create a file `Pyramid.java` to define
    the shape of our pyramid object.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从前面的部分学到的，我们将首先创建一个金字塔的类来定义我们的形状。所以创建一个名为`Pyramid.java`的文件来定义金字塔对象的形状。
- en: 'Our pyramid has five faces, so we will require five vertices to draw our pyramid.
    So after you create your `Pyramid.java`, we will define our vertices, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的金字塔有五个面，因此我们需要五个顶点来绘制金字塔。所以，在您创建了`Pyramid.java`之后，我们将定义我们的顶点，如下所示：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Alright, now we have our vertices set, but just like our triangle, we still
    have our buffers and indices to take care of. We will quickly define our float
    and byte buffers for our shape and colors along with the indices that will make
    our pyramid faces:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，现在我们已经设置了顶点，但就像我们的三角形一样，我们仍然需要处理我们的缓冲区和索引。我们将快速定义我们的形状和颜色以及将构成金字塔面的索引的浮点缓冲区和字节数据缓冲区：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we will write the constructor of our `Pyramid` based on the logic of our
    triangle:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将根据三角形的逻辑编写我们的`Pyramid`构造函数：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, of course, our `draw()` method as shown in the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当然，如以下代码所示，我们的`draw()`方法：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We''re done defining the shape of our `Pyramid`. So, finally your entire code
    for `Pyramid` will be like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了对`Pyramid`形状的定义。所以，最终您的整个`Pyramid`代码将如下所示：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Okay, that's set but we still won't be getting to see the Pyramid on our screen
    since we haven't rendered it yet; let's do that now to bring our pyramid on screen.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，设置好了，但我们仍然看不到屏幕上的金字塔，因为我们还没有渲染它；现在让我们渲染一下，以便将金字塔显示在屏幕上。
- en: Rendering our 3D object
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染我们的3D对象
- en: Based on our understanding of our previous example working with the triangle,
    we are pretty clear that in order to render our objects, we have to use our `MyGLRenderer.java`
    class. Since we are pretty clear on how our 3D rendering works, we will also add
    in our rotation code in the same code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们对之前与三角形一起工作的示例的理解，我们非常清楚，为了渲染我们的对象，我们必须使用我们的`MyGLRenderer.java`类。由于我们对3D渲染的工作原理非常清楚，我们也会在相同的代码中添加我们的旋转代码。
- en: Here's one crucial thing to take into account though, we will be drawing our
    pyramid beside our triangle, so we have to make sure that we don't overlap our
    pyramid over our triangle. To do so, we will use the code `gl.Translate()` that
    we will observe as a follow up inside our `onDrawFrame()` code block after we
    draw our triangle.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个关键的事情需要考虑，我们将绘制金字塔在三角形旁边，所以我们必须确保我们不使金字塔与三角形重叠。为此，我们将使用`gl.Translate()`代码，我们将在绘制三角形后观察`onDrawFrame()`代码块中的后续操作。
- en: 'We will work on our `MyGLRenderer.java` file, so open that file and write in
    the code marked in bold; the rest of the part remains the same:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将工作在`MyGLRenderer.java`文件上，所以打开该文件，并编写以下加粗代码；其余部分保持不变：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Alright, so everything looks set. Build and run your project, and you will
    get the following output:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，所以一切看起来都准备好了。构建并运行您的项目，您将得到以下输出：
- en: '![](img/B05066_10_04.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B05066_10_04.png)'
- en: Both our objects are visible on screen now
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的两个对象现在都显示在屏幕上了
- en: Congratulations! You have successfully created a 3D object using OpenGL. In
    a similar way, you can create any kind of object based on the vertices.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已经成功使用OpenGL创建了一个3D对象。以类似的方式，您可以根据顶点创建任何类型的对象。
- en: This is just the foundation of creating a 3D basic shapes game with OpenGL.
    Creating a fully-fledged 3D game is a huge task of its own, and this is just a
    glimpse of what you can do.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是使用OpenGL创建3D基本形状游戏的基石。创建一个完整的3D游戏是一项巨大的任务，而这只是您能做的事情的一瞥。
- en: We would recommend that you buy our other books on 3D game development to go
    ahead in more depth on creating games in 3D.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您购买我们关于3D游戏开发的其它书籍，以便更深入地学习创建3D游戏。
- en: Summary
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to create 3D objects and render them on the
    screen. We also learned how to add colors to objects as well as rotate them in
    a 3D direction. With this chapter, we conclude this book.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何创建3D对象并在屏幕上渲染它们。我们还学习了如何给对象添加颜色以及以3D方向旋转它们。随着本章的结束，我们完成了这本书。
- en: We have learned how to create games in 2D and 3D using native Android. With
    the knowledge gained from this chapter, you can get started on your journey into
    game development and start creating your own games for Android.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何使用原生 Android 创建 2D 和 3D 游戏。通过本章获得的知识，你可以开始你的游戏开发之旅，并开始为 Android 创建自己的游戏。
- en: This concludes this book for creating your games with Android. The knowledge
    gained through this book will serve as a foundation for the games you make ahead.
    The advantage of creating games in native Android is that primarily, the file
    size of games turns out to be quite small, which is what users generally look
    for. If you were to create any game using an engine, you would end up creating
    a game, which would have a comparatively larger file size by the end of the development
    process; you'd need to optimize it even further, but yet there's only so much
    you can do for that. So, developing native will not only allow you to make games
    with smaller file size, but will also enhance your knowledge and core understanding
    of the entire process.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书关于使用 Android 创建游戏的内容到此结束。通过本书获得的知识将成为你未来制作游戏的基石。在原生 Android 上创建游戏的优点主要是，游戏的文件大小最终会相当小，这正是用户通常所寻求的。如果你使用引擎创建任何游戏，最终你会得到一个游戏，其文件大小在开发过程结束时相对较大；你需要进一步优化它，但在这方面你所能做的还是有限的。因此，开发原生应用不仅允许你制作出文件大小更小的游戏，还能增强你对整个过程的了解和核心理解。
- en: As we conclude this book, it is now up to you and your imagination to start
    creating games with the help of the knowledge you learned through this book. Of
    course, creating games with an engine is definitely a faster process; if you want
    to skip through creating your own classes for each and everything, it is recommended
    that you get started with game engines. Packt has a wide variety of books to help
    you in the process. Perhaps, your best starting point to get started with a game
    engine is *Unity Game Engine*. If you're interested in learning more and giving
    your game development process a boost, then the best recommendation will be to
    go through Packt's book on *Unity Game Engine*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 随着本书的结束，现在就取决于你和你丰富的想象力，开始利用本书所学到的知识来创造游戏。当然，使用引擎来创建游戏无疑是一个更快的流程；如果你想要跳过为每一件事创建自己的类，那么建议你从游戏引擎开始。Packt
    提供了多种书籍来帮助你完成这个过程。也许，你开始使用游戏引擎的最佳起点是 *Unity 游戏引擎*。如果你对学习更多并给你的游戏开发过程带来提升感兴趣，那么最好的建议就是阅读
    Packt 关于 *Unity 游戏引擎* 的书籍。
- en: Wishing you all the best for creating your next game!
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 祝你在创建下一个游戏时一切顺利！
