- en: Chapter 9. Optimizing Your UI
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。优化您的UI
- en: Your app's user interface is your most direct connection to the user, so you'll
    want to make sure it's *perfect*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序的用户界面是您与用户最直接的联系，因此您需要确保它**完美**。
- en: Up until now we've concentrated on creating a beautifully designed user interface
    that's packed with useful features—but this is only half the battle. If your app
    is going to rack up those 5-star Google Play reviews, you'll need to create a
    UI that's quick to render, responsive, and generally delivers an all-around great
    user experience.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直专注于创建一个设计精美、功能丰富的用户界面——但这只是战斗的一半。如果您的应用要获得那些5星Google Play评论，您需要创建一个快速渲染、响应迅速，并且总体上提供卓越用户体验的UI。
- en: Performance is crucial to creating a successful UI, and a successful app in
    general. If your app is laggy, prone to crashing, gobbles up data and memory,
    or drains the user's battery, then no one is going to want to use it, no matter
    how good your UI looks!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 性能对于创建成功的用户界面以及一般意义上的成功应用至关重要。如果您的应用运行缓慢、容易崩溃、消耗大量数据和内存，或者耗尽用户的电池，那么无论您的UI看起来多么好，没有人会想使用它！
- en: In this chapter, I'm going to show you how to hunt out all the most common performance
    problems that may be impacting your app. Since you'll want to fix any problems
    you do encounter, along the way I'll also be touching on some of the reasons why
    these problems occur in the first place, and the steps you can take to address
    them.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将向您展示如何找出可能影响您应用的所有最常见性能问题。由于您会想修复您遇到的任何问题，因此在这个过程中，我还会涉及到这些问题最初发生的原因，以及您可以采取的解决这些问题的步骤。
- en: By the time you've completed this chapter, you'll know how to create a smooth
    and responsive UI that people will *love* using.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本章后，您将知道如何创建一个流畅且响应迅速的UI，人们会**喜爱**使用。
- en: Timing your code
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码计时
- en: Don't wait for your app to start throwing errors before you go looking for performance-related
    problems. Your app could be slowly leaking memory, allocating too many objects,
    or struggling under the weight of a complex view hierarchy. None of these will
    necessarily throw an error, but they'll definitely have a negative impact on your
    app's performance.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 不要等到您的应用开始抛出错误后再去寻找性能相关的问题。您的应用可能会缓慢泄漏内存、分配过多的对象，或者在一个复杂的视图层次结构下苦苦挣扎。这些都不一定会抛出错误，但它们肯定会对您应用的性能产生负面影响。
- en: If you're going to create a high-performance app, you need to go *looking* for
    problems.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您要创建一个高性能的应用，您需要去**寻找**问题。
- en: Timing your code is a powerful way of seeing *exactly* what's going on in your
    app, including any sections of code that are running slower or longer than others.
    The first Android SDK tool we're going to look at lets you do just that.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 代码计时是一种强大的方式，可以确切地了解您的应用中正在发生什么，包括任何运行速度或持续时间比其他部分更慢或更长的代码段。我们将要查看的第一个Android
    SDK工具让您可以做到这一点。
- en: '**TraceView** is a graphical viewer that can profile any Android app running
    on your device.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**TraceView**是一个图形查看器，可以分析您设备上运行的任何Android应用。'
- en: TraceView, like most of the tools we're going to cover in this chapter, can
    only measure a running application. So the first step is to install the app you
    want to test on your Android device, and then attach that device to your computer.
    Alternatively, you could use an emulator and suitable AVD. Make sure your app
    is running and its UI is visible.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: TraceView，就像本章中我们将要介绍的大多数工具一样，只能测量运行中的应用程序。因此，第一步是安装您想要在Android设备上测试的应用程序，然后将该设备连接到您的计算机。或者，您可以使用模拟器和合适的AVD。确保您的应用正在运行，并且其UI是可见的。
- en: Tip
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Before and after—measuring your app''s performance**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**前后对比——衡量您应用的性能**'
- en: When you discover a problem with your app, obviously you're going to want to
    fix that problem. But after you've made some changes, how do you know that the
    problem is truly fixed?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当您发现您的应用存在问题，显然您会想修复这个问题。但您在做出一些更改后，如何知道问题真正得到了解决？
- en: If you use TraceView to measure your app's performance before and after you
    make your changes, you'll have all the data you need to see whether your optimizations
    have had any significant impact on your app's performance. So even if you don't
    identify any code that needs optimizing, TraceView's output is still valuable
    data that you should keep to hand and refer back to as you work on optimizing
    your app.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在更改前后使用TraceView来衡量您应用的性能，您将拥有所有必要的数据来查看您的优化是否对您应用的性能产生了任何显著的影响。所以即使您没有识别出需要优化的代码，TraceView的输出也是您在优化应用时应该保留并参考的宝贵数据。
- en: To launch TraceView, select **Tools** from the Android Studio toolbar, followed
    by **Android** and **Android Device Monitor**. The **Android Device Monitor**
    will open in a new window.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动 TraceView，请从 Android Studio 工具栏中选择 **工具**，然后选择 **Android** 和 **Android 设备监控器**。**Android
    设备监控器**将在新窗口中打开。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: The **Android Device Monitor** is a standalone tool that's included as part
    of the Android SDK. Throughout this chapter, I'll be using several tools that
    are included in the **Android Device Monitor**. Although I'll be accessing the
    **Android Device Monitor** via the Android Studio user interface throughout this
    chapter, you can also launch the **Android Device Monitor** separately. If you
    want to bypass Android Studio, or if you're using Eclipse, you can launch the
    **Android Device Monitor** by finding the `monitor` file in your Android SDK download
    and double-clicking it. The **Android Device Monitor** will then open in a new
    window.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**Android 设备监控器** 是一个独立的工具，它是 Android SDK 的一部分。在本章中，我将使用包含在 **Android 设备监控器**
    中的几个工具。尽管在本章中我将通过 Android Studio 用户界面访问 **Android 设备监控器**，但您也可以单独启动 **Android
    设备监控器**。如果您想绕过 Android Studio，或者如果您正在使用 Eclipse，您可以通过在您的 Android SDK 下载中找到 `monitor`
    文件并双击它来启动 **Android 设备监控器**。然后，**Android 设备监控器** 将在新窗口中打开。'
- en: In the **Android Device Monitor** window, select the **DDMS** tab. Along the
    left-hand side of the screen you'll find a **Devices** tab that lists all the
    currently detected devices and emulators. Select the device or AVD that contains
    your app, and you'll see a list of all the processes that are running on this
    device. Select the process you want to profile.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **Android 设备监控器** 窗口中，选择 **DDMS** 选项卡。屏幕左侧您将找到一个 **设备** 选项卡，其中列出了所有当前检测到的设备和模拟器。选择包含您的应用程序的设备或
    AVD，您将看到在此设备上运行的所有进程的列表。选择您想要分析的进程。
- en: If you don't see your application in the list, check it's running and that its
    UI is visible.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在列表中看不到您的应用程序，请检查它是否正在运行并且其 UI 是否可见。
- en: 'Start method profiling by clicking the Start Method Profiling icon (where the
    cursor is positioned in the following screenshot):'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击开始方法分析图标（如下截图中的光标位置）来开始方法分析：
- en: '![Timing your code](img/B05061_9_1.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![计时您的代码](img/B05061_9_1.jpg)'
- en: 'At this point, you''ll be presented with two profiling options:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您将面临两种分析选项：
- en: '**Trace-based profiling**: Traces the entry and exit of *every *method, no
    matter how small. This kind of profiling has a massive overhead, so you should
    only trace everything when you have absolutely no idea what to profile. You can
    then use this data to narrow your search for a follow-up round of sample-based
    profiling.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于跟踪的分析**：跟踪每个方法的进入和退出，无论大小如何。这种分析类型具有巨大的开销，因此您只有在绝对不知道要分析什么时才应该跟踪一切。然后，您可以使用这些数据来缩小后续基于样本分析的范围。'
- en: '**Sample-based profiling**: Collects the call stacks at a frequency specified
    by you. With this kind of profiling, the overhead is proportional to the sampling
    frequency, so the overhead is generally much more manageable.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于样本的分析**：以您指定的频率收集调用栈。这种分析类型的开销与采样频率成比例，因此开销通常更容易管理。'
- en: Make your selection and TraceView will start recording. Spend some time interacting
    with your app, making sure to interact with all the sections and methods you want
    to profile. Then, click the Stop Method Profiling icon and DDMS will pull the
    trace file from your device and load it in the viewer.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 进行选择后，TraceView 将开始记录。花些时间与您的应用程序交互，确保与您想要分析的所有部分和方法进行交互。然后，点击停止方法分析图标，DDMS
    将从您的设备中提取跟踪文件并将其加载到查看器中。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: Depending on how much recording you've done, this data may take a few moments
    to launch, so you may need to be patient.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您记录的内容量，这些数据可能需要几秒钟才能启动，因此您可能需要耐心等待。
- en: You'll end up with a trace file that looks something like this:![Timing your
    code](img/B05061_9_2.jpg)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您最终会得到一个看起来像这样的跟踪文件：![计时您的代码](img/B05061_9_2.jpg)
- en: 'A trace file consists of:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪文件由以下内容组成：
- en: 'Timeline panel:'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间线面板：
- en: This panel displays where each thread and method started and stopped, so you
    can track how your code is executing over time.
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此面板显示每个线程和方法开始和结束的位置，因此您可以跟踪代码随时间执行的情况。
- en: The timeline panel displays each thread's execution on its own row, in a different
    color. You'll see a spike where each method starts (the left bar) and stops (the
    right bar). The line between these points is the amount of time it took the method
    to execute.
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 时间线面板以不同的颜色显示每个线程的执行情况，每行一个。你会在每个方法开始（左侧条形图）和停止（右侧条形图）的地方看到峰值。这两点之间的线条表示方法执行所需的时间。
- en: If you spot any long lines of the same color, this is an indication that this
    method is eating up processing time and you should gather more information about
    this method. Click on any method you want to learn more about, and its stats will
    appear in the Profile panel.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你发现任何相同颜色的长线条，这表明这种方法正在消耗处理时间，你应该收集更多关于这个方法的信息。点击任何你想要了解更多信息的方法，其统计数据将出现在配置面板中。
- en: 'Profile Panel:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置面板：
- en: This panel provides lots of information about what happened inside the currently
    selected method, including how many times that method was called, how many times
    it was called recursively, and the percentage of total CPU time used by this method,
    inclusive and exclusive of the execution time of all its child methods. This data
    helps you identify any methods that need optimizing.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此面板提供了关于当前所选方法内部发生情况的大量信息，包括该方法被调用的次数、递归调用的次数以及该方法使用的总CPU时间百分比（包括和排除所有子方法执行时间）。这些数据有助于你识别任何需要优化的方法。
- en: Identifying overdraw
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别过度绘制
- en: When Android draws the screen, it starts with the highest-level container and
    then draws all the children and grandchildren on top of this parent view. This
    means that an individual pixel may be drawn more than once in a single cycle,
    in a process known as **overdraw**.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Android 绘制屏幕时，它从最高级别的容器开始，然后在这个父视图中绘制所有子视图和孙视图。这意味着单个像素可能在一个循环中被绘制多次，这个过程被称为**过度绘制**。
- en: Coloring pixels that are only going to end up getting covered by subsequent
    views is a waste of processing power, and the more times you paint the screen,
    the more overdraw you're adding.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为那些最终会被后续视图覆盖的像素着色是浪费处理能力，而且你绘制屏幕的次数越多，你添加的过度绘制就越多。
- en: Overdraw is a particular problem for mobile devices such as Android, which have
    limited memory bandwidth to begin with and may struggle with GPU-intensive drawing
    tasks. By identifying and rectifying unnecessary or excessive overdraw, you'll
    increase your app's rendering speed.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于内存带宽有限且可能难以处理GPU密集型绘图任务的移动设备，如Android，过度绘制是一个特别的问题。通过识别和纠正不必要的或过度的过度绘制，你可以提高应用的渲染速度。
- en: Note
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Large amounts of overdraw can also indicate more serious problems with your
    user interface, so checking the amount of overdraw in your app can also point
    you in the direction of areas you should investigate further.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 大量的过度绘制也可能表明你的用户界面存在更严重的问题，因此检查应用中的过度绘制量也可以帮助你找到需要进一步调查的区域。
- en: It's unrealistic to try and eliminate *every* instance of overdraw, as some
    areas of overdraw are normal and unavoidable. If your app has a blue background,
    then every element you place on top of that background is going to cause some
    overdraw, but this is unavoidable—can you imagine releasing an app that's just
    a single blue screen, and nothing else?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试消除**所有**过度绘制的实例是不现实的，因为一些过度绘制区域是正常且不可避免的。如果你的应用背景是蓝色，那么你放置在背景之上的每一个元素都会导致一些过度绘制，但这不可避免——你能想象发布一个只有单一蓝色屏幕，什么都没有的应用吗？
- en: You only need to worry about excessive amounts of overdraw, such as multiple
    full-screen layers, or overdraw that doesn't contribute anything to the final
    image the user sees on screen, such as content that's completely hidden behind
    other views.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要担心过度绘制过多的情况，比如多个全屏层，或者对用户最终在屏幕上看到的最终图像没有任何贡献的过度绘制，比如完全隐藏在其他视图后面的内容。
- en: Android devices running 4.2 and higher have a built-in feature that lets you
    see the amount of overdraw present in any app installed on your Android device
    (and even the amount of overdraw present throughout the Android system, if you're
    curious about that sort of thing).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 4.2 及更高版本的 Android 设备具有一个内置功能，允许你查看安装在 Android 设备上的任何应用（如果你对此类事物感兴趣，甚至可以查看整个
    Android 系统中存在的过度绘制量）。
- en: 'To see the amount of overdraw that''s occurring in your app, install the app
    you want to test on a physical Android device running 4.2 or later. Then open
    your device''s **Settings**, followed by **Developer options**. Give **Debug GPU
    Overdraw** a tap, and select **Show overdraw areas** from the pop-up that appears:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看应用中发生的过度绘制量，请将你要测试的应用安装在运行4.2或更高版本的物理Android设备上。然后打开你的设备的**设置**，然后是**开发者选项**。点击**调试GPU过度绘制**，并从出现的弹出窗口中选择**显示过度绘制区域**：
- en: '![Identifying overdraw](img/B05061_9_3.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![识别过度绘制](img/B05061_9_3.jpg)'
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The **Debug GPU overdraw** pop-up contains a **Show areas for Deuteranomaly**
    option, which serves the same purpose as the standard **Debug GPU Overdraw**,
    but with color correction to compensate for people with deuteranopia color blindness
    (reduced sensitivity to green light).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**调试GPU过度绘制**弹出窗口包含一个**显示色盲异常区域**选项，它具有与标准**调试GPU过度绘制**相同的功能，但具有颜色校正，以补偿色盲（对绿光敏感度降低）的人。'
- en: With this option selected, the Android system colors each area of the screen
    differently, depending on how many times each pixel has been drawn and redrawn.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 选择此选项后，Android系统根据每个像素被绘制和重绘的次数，以不同的颜色为屏幕的每个区域着色。
- en: '![Identifying overdraw](img/B05061_9_4.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![识别过度绘制](img/B05061_9_4.jpg)'
- en: 'These colors are your guide to areas where overdraw is a particular problem:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这些颜色是指导你识别过度绘制特定问题的区域：
- en: '**No Color = no overdraw**: These pixels were painted once.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无颜色 = 无过度绘制**：这些像素只被绘制了一次。'
- en: '**Blue**: An overdraw of 1x, so these pixels were painted twice. In other words,
    the screen was drawn once, and then drawn again on top. Although the amount of
    overdraw you can afford varies from device to device, the majority of devices
    should be able to handle a single level of overdraw. Large areas of blue are acceptable,
    but if the entire window is blue then you may want to investigate further to see
    whether you can strip away some of this overdraw.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**蓝色**：1倍过度绘制，这意味着这些像素被绘制了两次。换句话说，屏幕被绘制了一次，然后再次在上面绘制。尽管你可以承受的过度绘制量因设备而异，但大多数设备应该能够处理单层过度绘制。大面积的蓝色是可以接受的，但如果整个窗口都是蓝色，那么你可能需要进一步调查，看看是否可以消除一些这种过度绘制。'
- en: '**Green**: An overdraw of 2x. These pixels were painted three times. Medium-sized
    areas of green are okay, but if more than half of your screen is green you should
    look into whether you can optimize some of this green away.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绿色**：2倍过度绘制。中等大小的绿色区域是可以接受的，但如果屏幕超过一半是绿色，你应该调查是否可以优化一些绿色。'
- en: '**Light red**: An overdraw of 3x. Some small areas of light red may be unavoidable,
    but any medium or large areas of red are a cause for concern.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浅红色**：3倍过度绘制。一些浅红色的小区域可能是不可避免的，但任何中等或大面积的红色都应引起关注。'
- en: '**Dark red**: An overdraw of 4x, which means this pixel was painted at least
    five times—possibly even more! You should *always* investigate any dark red areas.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**深红色**：4倍过度绘制，这意味着这个像素至少被绘制了五次——甚至可能更多！你应该**始终**调查任何深红色区域。'
- en: 'When you''re investigating an area of excessive overdraw, your first stop should
    be checking out the layout''s corresponding XML file to see whether there''s any
    obvious areas of overlap. In particular, be on the lookout for:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在调查过度绘制区域时，你的第一步应该是检查布局对应的XML文件，看看是否有明显的重叠区域。特别是要注意：
- en: Any drawables that aren't visible to the user.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何对用户不可见的可绘制元素。
- en: Any backgrounds that are being drawn on top of one another, particularly full-screen
    backgrounds. If your UI has several layers of background before your app even
    starts drawing its content, then you're inevitability going to end up with some
    serious overdraw.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何重叠绘制的背景，尤其是全屏背景。如果你的UI在应用开始绘制内容之前就有几层背景，那么你不可避免地会遇到一些严重的过度绘制。
- en: Any areas that draw a white background on top of another white background.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何在另一个白色背景上绘制白色背景的区域。
- en: '`ViewGroups` nested inside `ViewGroups`. Look into whether you can replace
    these multiple `ViewGroups` with a `RelativeLayout`.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewGroups`嵌套在`ViewGroups`内部。考虑是否可以用`RelativeLayout`替换这些多个`ViewGroups`。'
- en: Another tool that's useful for identifying unnecessary views and nested layouts
    is the **Hierarchy View** tool that comes with the Android SDK and is accessed
    through the **Android Device Monitor**.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用于识别不必要的视图和嵌套布局的有用工具是Android SDK中包含的**层次结构视图**工具，通过**Android设备监控器**访问。
- en: Like many of the diagnostic tools I'll be using throughout this chapter, **Hierarchy
    View** can only communicate with an app that's running in an AVD or a physical
    Android device. However, unlike the other diagnostic tools, **Hierarchy View**
    can only connect to a device that's running a developer version of the Android
    operating system. If you *don't *have a developer device, you can get around this
    restriction by adding the `ViewServer` class ([https://github.com/romainguy/ViewServer](https://github.com/romainguy/ViewServer)
    ) to your project.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章中我将使用的许多诊断工具一样，**层次结构视图**只能与在AVD或物理Android设备上运行的应用程序通信。然而，与其它诊断工具不同，**层次结构视图**只能连接到运行Android操作系统开发者版本的手机。如果您**没有**开发者手机，可以通过将`ViewServer`类（[https://github.com/romainguy/ViewServer](https://github.com/romainguy/ViewServer)）添加到您的项目中来绕过这个限制。
- en: If you're using a physical Android device, you also need to make sure debugging
    is enabled. Open your device's **Settings**, followed by **Developer options**,
    and then drag the **Android debugging** slider to the **On** position.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是物理Android设备，您还需要确保已启用调试。打开您的设备**设置**，然后选择**开发者选项**，并将**Android调试**滑块拖到**开启**位置。
- en: 'Open the Android Device Monitor (by selecting **Tools** | **Android |** **Android
    Device Monitor**) and click the **Hierarchy View** button (where the cursor is
    positioned in the following screenshot):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 打开Android设备监控器（通过选择**工具** | **Android** | **Android设备监控器**）并点击**层次结构视图**按钮（如下截图中的光标位置）：
- en: '![Identifying overdraw](img/B05061_9_5.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![识别过度绘制](img/B05061_9_5.jpg)'
- en: Select your device from the **Windows** tab and you'll see a list of all the
    Activity objects running on the selected device, listed by component name.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 从**窗口**选项卡中选择您的设备，您将看到在所选设备上运行的所有Activity对象的列表，按组件名称列出。
- en: To populate the various **Hierarchy View** panes, click the blue **load the
    view hierarchy into the tree view** icon. Depending on how complex your app's
    view hierarchy is, the tree may take some time to load.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要填充各种**层次结构视图**面板，请点击蓝色**将视图层次结构加载到树视图**图标。根据您的应用视图层次结构的复杂程度，树可能需要一些时间来加载。
- en: Once your project's **Hierarchy View** has loaded, you may want to spend some
    time exploring that hierarchy in the various windows (I'll be discussing these
    in more detail in the next section), but one of the quickest and easiest ways
    of identifying large areas of overdraw is to export the Activity's hierarchy as
    a Photoshop document.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的项目的**层次结构视图**加载完成，您可能想花些时间在各个窗口中探索这个层次结构（我将在下一节中更详细地讨论这些内容），但快速且简单识别大面积过度绘制的一种方法是将Activity的层次结构导出为Photoshop文档。
- en: When you create a PSD document from the **Hierarchy View** output, each `View`
    is displayed as a separate layer. This means you can use the PSD document to peel
    back each layer of your app, and see exactly what each layer is contributing to
    your UI. Inspecting each layer can help you identify sources of overdraw, or if
    you already suspect that certain areas of your app are suffering from overdraw,
    then you can put your theory to the test by hiding the different layers and seeing
    how this impacts the final rendered image the user sees on screen.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当您从**层次结构视图**输出创建PSD文档时，每个`View`都显示为单独的层。这意味着您可以使用PSD文档来剥离您应用的每一层，并确切地看到每一层对UI的贡献。检查每一层可以帮助您识别过度绘制的原因，或者如果您已经怀疑您的应用中某些区域存在过度绘制，那么您可以通过隐藏不同的层来测试您的理论，看看这如何影响用户在屏幕上看到的最终渲染图像。
- en: 'To export your hierarchy as a Photoshop document, click the **Capture the window
    layers as a Photoshop document** icon (where the cursor is positioned in the following
    screenshot):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要将您的层次结构导出为Photoshop文档，请点击**捕获窗口层为Photoshop文档**图标（如下截图中的光标位置）：
- en: '![Identifying overdraw](img/B05061_9_6.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![识别过度绘制](img/B05061_9_6.jpg)'
- en: This button generates a PSD file that you can inspect in Adobe Photoshop or
    in any image-editing tool that supports PSD files, such as the free and open source
    Gimp program ([https://www.gimp.org](https://www.gimp.org)).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此按钮生成一个PSD文件，您可以在Adobe Photoshop或任何支持PSD文件（如免费开源的Gimp程序[https://www.gimp.org](https://www.gimp.org)）中检查。
- en: '![Identifying overdraw](img/B05061_9_7.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![识别过度绘制](img/B05061_9_7.jpg)'
- en: Examining the layers of our application in GIMP
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在GIMP中检查应用层
- en: Spend some time exploring the different layers that make up your UI.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 花些时间探索构成您UI的不同层。
- en: 'This PSD document is particularly useful for identifying one of the major causes
    of overdraw: multiple white backgrounds. Multiple white backgrounds can be difficult
    to spot, so one trick is to replace the white backgrounds in your PSD file with
    different images. You can then check what portions of these images are visible
    as you move through the different layers of your UI.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个PSD文档特别有助于识别过度绘制的主要原因之一：多个白色背景。多个白色背景可能难以发现，所以一个技巧是将你的PSD文件中的白色背景替换为不同的图像。然后，你可以检查当你通过UI的不同层移动时，这些图像的哪些部分是可见的。
- en: Simplifying your Hierarchy View
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简化你的层次结构视图
- en: Another common cause of performance problems is your app's **Hierarchy View**.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的性能问题来源是应用程序的**层次结构视图**。
- en: 'When the Android system renders each view, it goes through three stages: measure,
    layout, and draw. The time it takes the system to complete each stage is affected
    by the number of views in your hierarchy, and how these views are arranged.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当Android系统渲染每个视图时，它会经过三个阶段：测量、布局和绘制。系统完成每个阶段所需的时间受你层次结构中视图数量的影响，以及这些视图的排列方式。
- en: Arranging your views in deeper, more complex, hierarchies will have a noticeable
    impact on your app's rendering speed. You should be on the lookout for any opportunities
    to flatten your view hierarchy and remove nested layouts.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的视图安排在更深、更复杂的层次结构中将对你的应用程序的渲染速度产生明显影响。你应该寻找任何简化视图层次结构和移除嵌套布局的机会。
- en: As well as highlighting areas of overdraw, **Hierarchy View** helps you visualize
    your app's view hierarchy and provides some really useful performance information
    about how long each view takes to render.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 除了突出显示过度绘制区域外，**层次结构视图**还帮助你可视化应用程序的视图层次结构，并提供有关每个视图渲染所需时间的非常有用的性能信息。
- en: The **Hierarchy View** tool consists of three different windows.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**层次结构视图**工具由三个不同的窗口组成。'
- en: Tree View
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 树视图
- en: 'This window provides a bird''s eye view of the currently selected Activity''s
    view hierarchy:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此窗口提供了当前所选Activity视图层次结构的鸟瞰图：
- en: '![Tree View](img/B05061_9_8.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![树视图](img/B05061_9_8.jpg)'
- en: 'Each node in Tree View represents a single `View`. When you select a node,
    additional information about that `View` appears in a small window above the node:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 树视图中的每个节点代表一个单独的`View`。当你选择一个节点时，关于该`View`的附加信息会出现在节点上方的小窗口中：
- en: '**View class**: The object''s class'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图类**：对象的类'
- en: '**View object address**: A pointer to the `View` object'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图对象地址**：指向`View`对象的指针'
- en: '**View object ID**: The value of the object''s `android:id` attribute'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图对象ID**：对象的`android:id`属性值'
- en: You'll also see a preview of how this `View` will appear on an Android device.
    By seeing exactly what each `View` is contributing to the final UI, you can decide
    whether this `View` is adding anything of value. If it isn't, then you should
    remove it from your app.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将看到这个`View`在Android设备上的预览。通过确切地了解每个`View`对最终UI的贡献，你可以决定这个`View`是否添加了任何有价值的内容。如果没有，那么你应该从你的应用程序中移除它。
- en: Tree overview
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 树概览
- en: 'This window contains a map representation of the Activity''s entire view hierarchy:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此窗口包含Activity整个视图层次结构的地图表示：
- en: '![Tree overview](img/B05061_9_9.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![树概览](img/B05061_9_9.jpg)'
- en: This high-level view of your hierarchy structure is particularly useful for
    seeing just how complex your view hierarchy really is, as well as helping you
    identify nested layouts and other opportunities to flatten your layout.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这种对层次结构结构的宏观视图特别有助于了解你的视图层次结构实际上有多复杂，同时也有助于你识别嵌套布局和其他简化布局的机会。
- en: Layout View
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布局视图
- en: This window displays a skeleton of your Activity's UI.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此窗口显示你的Activity UI的骨架。
- en: 'When you select a node in either the **Tree View** or **Tree Overview** window,
    the **Layout View** highlights the areas that this `View` paints. Again, this
    helps you weed out redundant `Views`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在**树视图**或**树概览**窗口中选择一个节点时，**布局视图**会突出显示这个`View`所绘制的区域。再次强调，这有助于你剔除冗余的`Views`：
- en: '![Layout View](img/B05061_9_10.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![布局视图](img/B05061_9_10.jpg)'
- en: While **Hierarchy View** is great for spotting nested layouts and redundant
    views, there are some view hierarchy issues that you can't spot just by looking
    at these three windows.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然**层次结构视图**对于发现嵌套布局和冗余视图非常有用，但仅通过查看这三个窗口，你仍然可能无法发现一些视图层次结构的问题。
- en: To help you identify any problems that may be lurking beneath the surface, you
    can use the **Hierarchy View** tool to measure how long it takes each `View` to
    move through each phase of the rendering process (measure, layout, and draw).
    Armed with this information, you'll know exactly what `Views` you need to optimize.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您识别可能隐藏在表面之下的任何问题，您可以使用**层次视图**工具来测量每个`视图`在渲染过程的每个阶段（测量、布局和绘制）中移动所需的时间。有了这些信息，您将确切知道哪些`视图`需要优化。
- en: Hierarchy View's **Tree Overview** doesn't display render times by default.
    To add this information to the **Tree Overview**, you need to select the root
    node of the part of the tree you want to profile. Then click the green, red, and
    purple Venn diagram icon (when you hover over this icon, you'll see an **Obtain
    layout times for tree rooted at selected node** tooltip).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，层次视图的**树概览**不显示渲染时间。要将此信息添加到**树概览**中，您需要选择您想要分析的部分树的根节点。然后点击绿色、红色和紫色维恩图图标（当您悬停在图标上时，您将看到**获取以所选节点为根的树的布局时间**工具提示）。
- en: After a few moments, three colored dots will appear on each node within this
    section of the view hierarchy. These dots indicate the rendering speed of this
    `View` relative to the other profiled `Views`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟后，每个视图层次结构部分的节点上都会出现三个彩色点。这些点表示此`视图`相对于其他已分析`视图`的渲染速度。
- en: 'From left to right, these dots indicate the time it takes to:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从左到右，这些点表示完成以下操作所需的时间：
- en: Measure the view
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量视图
- en: Layout the view
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布局视图
- en: Draw the view
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制视图
- en: 'The color of each dot indicates the time it takes the `View` to move through
    each phase of the rendering process:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 每个点的颜色表示`视图`在渲染过程的每个阶段（测量、布局和绘制）中移动所需的时间：
- en: '**Green**: This view is faster than at least half of the other profiled nodes.
    A green dot in the measure position means that this view has a faster layout time
    than at least 50% of the other profiled nodes.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绿色**：此视图比至少一半的其他已分析节点更快。在测量位置出现的绿色点表示此视图的布局时间比至少50%的其他已分析节点更快。'
- en: '**Yellow**: This view is in the slowest 50% of all the profiled nodes.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**黄色**：此视图位于所有已分析节点中最慢的50%。'
- en: '**Red**: This view is the slowest out of all the profiled nodes.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**红色**：此视图是所有已分析节点中最慢的。'
- en: You can use this information to identify which `Views` are the slowest to measure,
    layout, and draw, so you not only know which `Views` you need to optimize but
    also the part of the rendering process you should be focusing on.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用这些信息来识别哪些`视图`在测量、布局和绘制方面最慢，这样您不仅知道哪些`视图`需要优化，而且也知道您应该关注渲染过程的哪个部分。
- en: When you click a profiled node you'll also see the measure, layout, and draw
    times for that `View`, displayed in milliseconds.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当您点击一个已分析的节点时，您还会看到该`视图`的测量、布局和绘制时间，以毫秒为单位显示。
- en: '![Layout View](img/B05061_9_11.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![布局视图](img/B05061_9_11.jpg)'
- en: Just remember that these performance indicators are relative to one another,
    so your view hierarchy is always going to include some red and yellow nodes.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 只需记住，这些性能指标是相互比较的，所以您的视图层次结构总是包含一些红色和黄色节点。
- en: Before you start looking for ways to optimize `Views` with yellow and red dots,
    ask yourself whether these `Views` have a good reason for rendering more slowly,
    for example views that have more children are always going to lag behind nodes
    that have less children.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在您开始寻找使用黄色和红色点优化`视图`的方法之前，问问自己这些`视图`是否有渲染更慢的合理原因，例如拥有更多子视图的视图总是会比拥有较少子视图的节点落后。
- en: Spotting memory leaks
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找内存泄漏
- en: Android may be a memory-managed environment, but you still need to scrutinize
    how your app is handling memory.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Android可能是一个内存管理的环境，但您仍然需要仔细检查您的应用是如何处理内存的。
- en: '**Garbage collection** (**GC**) can *only* remove objects that it recognizes
    as unreachable. If your app allocates objects that the Android system doesn''t
    identify as unreachable, then those objects are never going to get garbage collected.
    They''re going to hang around, polluting your heap, and taking up valuable space.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**垃圾回收**（**GC**）只能移除它识别为不可达的对象。如果您的应用分配了Android系统不识别为不可达的对象，那么这些对象将永远不会被垃圾回收。它们将悬挂在那里，污染您的堆，并占用宝贵的空间。'
- en: As your app continues to leak objects that the system can't garbage collect,
    the amount of usable space will get smaller and smaller. The Android system will
    try to compensate for this shrinking memory by running longer and more frequent
    GC events.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您的应用继续泄漏系统无法垃圾回收的对象，可用的空间将越来越少。Android系统将通过运行更长和更频繁的GC事件来尝试补偿这种内存减少。
- en: While your typical GC event won't have a noticeable impact on your app's performance,
    as more and longer GC events start occurring in a small space of time, your users
    may notice a drop in performance, and may even encounter an `OutOfMemoryError`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您典型的GC事件不会对您的应用性能产生明显影响，但随着更多更长的GC事件在短时间内发生，您的用户可能会注意到性能下降，甚至可能遇到`OutOfMemoryError`。
- en: Memory leaks can be difficult to detect, but the Android SDK comes with several
    tools that you can use to scour your app for those sometimes subtle signs of memory-management
    problems.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 内存泄漏可能难以检测，但Android SDK附带了一些工具，您可以使用这些工具扫描您的应用，寻找那些有时微妙的内存管理问题迹象。
- en: Memory monitor
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存监控器
- en: Memory monitor tracks your app's memory usage over time. This is another tool
    that can only communicate with a running app, so make sure to install your app
    on a physical device or an emulator before you proceed.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 内存监控器会跟踪您应用随时间变化的内存使用情况。这是另一个只能与运行中的应用程序通信的工具，因此在继续之前，请确保在物理设备或模拟器上安装了您的应用。
- en: You can access memory monitor from the main Android Studio screen by selecting
    the **Android Monitor** tab towards the bottom of the screen, and then selecting
    the **Memory** tab.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过从主Android Studio屏幕中选择屏幕底部的**Android监控器**选项卡，然后选择**内存**选项卡来访问内存监控器。
- en: Make sure the app you want to test is visible onscreen. As soon as memory monitor
    detects your running app, it'll start recording memory usage, displaying the memory
    your app is using in dark blue and the unallocated memory in light blue.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您想要测试的应用程序在屏幕上是可见的。一旦内存监控器检测到您的运行中的应用程序，它就会开始记录内存使用情况，以深蓝色显示您的应用正在使用的内存，以浅蓝色显示未分配的内存。
- en: '![Memory monitor](img/B05061_9_12.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![内存监控器](img/B05061_9_12.jpg)'
- en: Tip
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Troubleshooting**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**故障排除**'
- en: If Memory Monitor displays a **No debuggable applications** message, open Android
    Studio's **Tools** menu, select **Android,** and make sure **Enable adb integration**
    is selected. This feature can be temperamental, so if it doesn't work at first
    then try the *very* high-tech solution of toggling **Enable adb integration**
    on and off a few times. If you're using a physical Android device, it may also
    help to disconnect your device and reconnect it to a different USB port.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果内存监控器显示“**没有可调试的应用程序**”的消息，请打开Android Studio的**工具**菜单，选择**Android**，并确保**启用adb集成**被选中。这个功能可能会有些不可靠，所以如果一开始不起作用，请尝试几次**启用adb集成**的**开启和关闭**。如果您使用的是物理Android设备，断开设备并重新连接到不同的USB端口也可能有所帮助。
- en: Spend some time interacting with your app while keeping an eye on memory monitor.
    Eventually your app's memory usage will swell until there's no unallocated memory
    left. At this point, the system will free up some memory by triggering a GC event,
    causing the allocated memory to drop.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在监控内存的同时，花些时间与您的应用互动。最终，您的应用内存使用量会增加，直到没有未分配的内存。在这种情况下，系统将通过触发GC事件来释放一些内存，导致已分配的内存减少。
- en: Most GC events are perfectly normal, but if you see GC events becoming longer
    and more frequent then this is an indication that a memory leak may be occurring
    in your app.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数垃圾回收（GC）事件都是完全正常的，但如果您发现GC事件变得越来越长且越来越频繁，那么这表明您的应用可能正在发生内存泄漏。
- en: If you track a suspected memory leak over a period of time, you may eventually
    see the Android system try to accommodate your app's insatiable thirst for memory
    by granting it a higher memory ceiling. If you see this happening in memory monitor,
    then this is a sign that a serious memory leak is occurring in your app, and you
    should investigate it in more detail.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在一段时间内跟踪一个疑似内存泄漏，您最终可能会看到Android系统试图通过授予更高的内存上限来满足您应用对内存的无尽渴望。如果在内存监控器中看到这种情况发生，那么这是您的应用中存在严重内存泄漏的迹象，您应该更详细地调查它。
- en: Heap tab
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 堆选项卡
- en: If you spot strange memory usage in the memory monitor, you can use the Android
    Device Monitor's Heap tab to gather more information about how your app is using
    memory.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在内存监控器中看到异常的内存使用情况，您可以使用Android设备监控器的堆选项卡来收集有关您的应用如何使用内存的更多信息。
- en: As the name suggests, this tab provides data about your app's heap usage, including
    the kind of objects your app is allocating, the number of allocated objects, and
    how much space these objects are taking up.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名所示，此选项卡提供了有关您的应用堆内存使用情况的数据，包括您的应用正在分配的对象类型、分配的对象数量以及这些对象占用的空间量。
- en: Android smartphones and tablets have a finite amount of heap space that can
    only accommodate a certain number of objects. As the heap grows, the Android system
    will try to free up memory by triggering a GC event—which we already know is bad
    news for performance.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓智能手机和平板电脑的堆空间是有限的，只能容纳一定数量的对象。随着堆的增长，安卓系统将通过触发GC事件来尝试释放内存——这是我们已知对性能不利的。
- en: 'To access the heap tab, launch the **Android Device Monitor**, select the **DDMS**
    tab, and then select your device or AVD from the **Devices** panel, followed by
    the process you want to examine. Click the **Update heap** button (where the cursor
    is positioned in the following screenshot):'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问堆标签，启动**Android设备监控器**，选择**DDMS**标签，然后从**设备**面板中选择您的设备或AVD，接着选择您想要检查的进程。点击**更新堆**按钮（如下面的截图所示）：
- en: '![Heap tab](img/B05061_9_13.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![堆标签](img/B05061_9_13.jpg)'
- en: Select the **Heap** tab and spend some time interacting with your app.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**堆**标签，并花些时间与您的应用程序进行交互。
- en: The heap output is only displayed after a GC event has occurred, so you'll either
    have to be patient and wait for an organic GC event, or you can force a GC event
    by clicking the **Cause GC** button. Once a GC has occurred, the Heap tab will
    display information about your app's heap usage.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 堆输出仅在垃圾回收（GC）事件发生后才会显示，因此您可能需要耐心等待一个有机的GC事件，或者可以通过点击**触发GC**按钮强制执行GC事件。一旦发生GC，堆标签将显示关于您的应用程序堆使用的详细信息。
- en: '![Heap tab](img/B05061_9_14.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![堆标签](img/B05061_9_14.jpg)'
- en: Spend some time interacting with your app, triggering GC events before *and*
    after you perform different actions so you can compare how these actions impact
    the heap. In this way, you can isolate the actions that are causing the memory
    leak, as well as any other memory-related problems your app is experiencing.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行不同操作之前和之后与您的应用程序进行一些交互，触发GC事件，这样您就可以比较这些操作对堆的影响。通过这种方式，您可以隔离导致内存泄漏的操作，以及您的应用程序可能遇到的任何其他内存相关的问题。
- en: When you're tracking down problems in your app's heap, it may to help to generate
    a HPROF file, which is a snapshot of all the objects in your app's heap plus detailed
    information about the related classes and instances.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在应用程序的堆中追踪问题时，生成一个HPROF文件可能会有所帮助，这是一个包含您应用程序堆中所有对象的快照，以及有关相关类和实例的详细信息。
- en: Once you've generated a HPROF file, you can view it in Android Studio or in
    a separate profiling tool, such as the Eclipse Memory Analyzer ([http://www.eclipse.org/mat](http://www.eclipse.org/mat)).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 生成HPROF文件后，您可以在Android Studio或单独的剖析工具中查看它，例如Eclipse内存分析器([http://www.eclipse.org/mat](http://www.eclipse.org/mat))。
- en: To retrieve a HPROF file, click the **Dump HPROF** icon (next to the **Update
    Heap** icon). Give your file a name and save it.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索HPROF文件，点击**转储HPROF**图标（位于**更新堆**图标旁边）。为您的文件命名并保存。
- en: To analyze your heap dump in Android Studio, open your HPROF file as a new Android
    project. Android Studio will automatically open the file in its Android Memory
    HPROF Viewer, ready for you to analyze in more detail.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Android Studio中分析堆转储，将您的HPROF文件作为一个新的Android项目打开。Android Studio将自动在Android内存HPROF查看器中打开该文件，以便您进行更详细的分析。
- en: '![Heap tab](img/B05061_9_15.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![堆标签](img/B05061_9_15.jpg)'
- en: Object allocation – understanding memory churn
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象分配 – 理解内存碎片
- en: Another common memory problem that you should check for is memory churn.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您还应该检查的另一个常见内存问题是内存碎片。
- en: Memory churn occurs when your app allocates lots of temporary objects in a short
    period of time, which can quickly gobble up a device's available memory, triggering
    those performance-sapping GC events.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的应用程序在短时间内分配大量临时对象时，就会发生内存碎片，这可能会迅速消耗设备的可用内存，触发那些性能消耗的GC事件。
- en: You can check for memory churn using the Android SDK's **Allocation Tracker**,
    which lists all the objects your app is allocating to memory when you perform
    different actions. If you spot any suspicious-looking allocations, you can then
    use **Allocation Tracker** to inspect the classes and threads that are responsible
    for allocating these objects.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Android SDK的**分配跟踪器**来检查内存碎片，该跟踪器列出了您在执行不同操作时应用程序分配到内存的所有对象。如果您发现任何可疑的分配，您可以使用**分配跟踪器**来检查负责分配这些对象的类和线程。
- en: Inside the Android Device Monitor, select the **DDMS** tab and then open the **Allocation
    Tracker** tab. Select your device or AVD from the **Devices** tab, followed by
    the process you want to examine.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android设备监控器中，选择**DDMS**标签，然后打开**分配跟踪器**标签。从**设备**标签中选择您的设备或AVD，接着选择您想要检查的进程。
- en: In the **Allocation Tracker** tab, click the **Start Tracking** button and spend
    some time interacting with your app. To see a list of all the objects that have
    been allocated since you started tracking, click the **Get Allocation**s button.
    Android Studio will then open a tab that displays all the allocations that occurred
    during this sampling period.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **Allocation Tracker** 选项卡中，点击 **Start Tracking** 按钮，并花一些时间与你的应用交互。要查看自开始跟踪以来已分配的所有对象的列表，请点击
    **Get Allocations** 按钮。Android Studio 将打开一个选项卡，显示在此采样期间发生的所有分配。
- en: 'Click on any allocated object to see more information about that object:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 点击任何已分配的对象，以查看该对象更多信息：
- en: '![Object allocation – understanding memory churn](img/B05061_9_16.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![对象分配 – 理解内存波动](img/B05061_9_16.jpg)'
- en: When you're ready to stop collecting data, click the **Stop Tracking** button.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备好停止收集数据时，点击 **Stop Tracking** 按钮。
- en: 'Each row in the **Allocation Tracking** tab represents a specific allocation,
    and provides the following information for that allocation:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**Allocation Tracking** 选项卡中的每一行代表一个特定的分配，并为该分配提供以下信息：'
- en: Allocation order
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配顺序
- en: Allocation size
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配大小
- en: Allocated class
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配的类
- en: Thread ID. This is the thread that made the allocation
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程 ID。这是进行分配的线程
- en: Allocated In. This is the function in your code that's responsible for this
    allocation
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配位置。这是你的代码中负责此分配的函数
- en: Debugging your project
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试你的项目
- en: It's crucial that you thoroughly test your app for bugs before releasing it.
    Android Studio provides a range of tools that you can use to debug an app running
    on an emulator or a physical Android device, although these tools can only test
    a debuggable version of your app, which means you'll need to run your app in debug
    mode.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布应用之前，彻底测试你的应用以查找错误至关重要。Android Studio 提供了一系列工具，你可以使用这些工具在模拟器或物理 Android 设备上调试应用，尽管这些工具只能测试你的可调试版本的应用，这意味着你需要以调试模式运行你的应用。
- en: 'To run your app in debug mode, open your project''s module-level `build.gradle`
    file and add the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要以调试模式运行你的应用，打开你的项目模块级别的 `build.gradle` 文件，并添加以下内容：
- en: '[PRE0]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After editing your Gradle build file, make sure you sync your project. Next,
    click the **Debug** icon or select **Run** from the Android Studio toolbar, followed
    by **Debug**.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑你的 Gradle 构建文件后，确保同步你的项目。接下来，点击 **Debug** 图标或从 Android Studio 工具栏中选择 **Run**，然后选择
    **Debug**。
- en: Select the AVD or physical Android device where you want to install and test
    the debuggable version of your app. Once your app has loaded, Android Studio's
    **Debug** perspective should open automatically.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 选择你想要安装和测试可调试版本应用的 AVD 或物理 Android 设备。一旦你的应用加载完毕，Android Studio 的 **Debug**
    视角应该会自动打开。
- en: Note
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the **Debug** perspective doesn't open automatically, select **View** from
    the Android Studio toolbar, followed by **Tool window** and **Debug**.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调试视角没有自动打开，请从 Android Studio 工具栏中选择 **View**，然后选择 **Tool window** 和 **Debug**。
- en: 'The Debug perspective consists of:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 调试视角包括：
- en: '**Debugger**: Displays threads and variables'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试器**：显示线程和变量'
- en: '**Console**: Displays the device status'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制台**：显示设备状态'
- en: To debug an app that's already running, click **Attach debugger to Android process**.
    In the **Choose Process** window, select the device and the app you want to attach
    the debugger to and then click **OK**.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要调试已运行的应用，点击 **Attach debugger to Android process**。在 **Choose Process** 窗口中，选择你想要附加调试器的设备和应用，然后点击
    **OK**。
- en: 'Once you have a debuggable version of your app up and running, you can view
    the log messages related to your application. To view these messages, select the
    **Android Monitor** tab that appears along the bottom of the Android Studio screen
    and then select the l**ogcat** tab:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的应用调试版本运行起来，你就可以查看与应用程序相关的日志消息。要查看这些消息，请选择位于 Android Studio 屏幕底部的 **Android
    Monitor** 选项卡，然后选择 **logcat** 选项卡：
- en: '![Debugging your project](img/B05061_9_17.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![调试你的项目](img/B05061_9_17.jpg)'
- en: 'Logcat can sometimes be a case of information overload, so Android Studio provides
    several ways of filtering the logcat output. One method is to use the **Log Level**
    drop-down menu. By default, this menu is set to **Verbose**, which displays all
    log messages, but there are several more specific options you can choose from:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Logcat 有时可能会出现信息过载的情况，因此 Android Studio 提供了多种过滤 logcat 输出的方式。一种方法是使用 **Log Level**
    下拉菜单。默认情况下，此菜单设置为 **Verbose**，显示所有日志消息，但你还可以选择其他几个更具体的选项：
- en: '**Debug**: Displays log messages that are useful during development, plus message
    levels lower in this list'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试**：显示在开发期间有用的日志消息，以及列表中较低的消息级别'
- en: '**Info**:Displays expected log messages for regular usage, plus message levels
    lower in this list'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信息**：显示常规使用中的预期日志消息，以及列表中更低的消息级别'
- en: '**Warn**:Displays possible issues that are not yet errors, plus message levels
    lower in this list'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**警告**：显示尚未成为错误的问题，以及列表中更低的消息级别'
- en: '**Error**: Displays issues that have caused errors, plus message levels lower
    in this list'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误**：显示导致错误的问题，以及列表中更低的消息级别'
- en: '**Assert**: Displays issues that should *never* happen'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断言**：显示永远不会发生的问题'
- en: If none of these filters meet your debugging needs, you can create custom filters.
    Open the **Show only selected application** dropdown (towards the right side of
    the **logcat** panel) and then select **Edit Filter Configuration**.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些过滤器中没有任何一个满足你的调试需求，你可以创建自定义过滤器。打开**仅显示所选应用程序**下拉菜单（位于**日志输出**面板的右侧），然后选择**编辑过滤器配置**。
- en: 'This opens a **Create New LogCat Filter** window, where you can craft a new
    filter by providing the following information:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开一个**创建新LogCat过滤器**窗口，你可以通过提供以下信息来创建一个新的过滤器：
- en: '**Filter name**: If you''re creating a new filter, you should give this filter
    a unique name. If you''re modifying an existing filter, select it from the left-hand
    pane and its name will appear in this field.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过滤器名称**：如果你正在创建一个新的过滤器，你应该给这个过滤器一个独特的名称。如果你正在修改现有的过滤器，请从左侧窗格中选择它，其名称将出现在此字段中。'
- en: '**Log Tag**: Every log message has a tag associated with it, which indicates
    the system component the message originated from. If you want to see messages
    that originate from a certain system component only, you can enter that component''s
    tag here.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志标签**：每个日志消息都与一个标签相关联，该标签指示消息源自哪个系统组件。如果你只想看到来自特定系统组件的消息，你可以在此处输入该组件的标签。'
- en: '**Log Message**: If you only want to see messages that contain certain elements
    or character strings, specify them in the **Log Message** field.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志消息**：如果你只想看到包含某些元素或字符字符串的消息，请在**日志消息**字段中指定它们。'
- en: '**Package Name**: If you want your filter to display messages that relate to
    a certain package only, enter this package name here.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包名**：如果你想让你的过滤器仅显示与特定包相关的消息，请在此处输入此包名。'
- en: '**PID**: If you only want to see messages that refer to a specific process,
    enter that process ID here.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进程ID**：如果你只想看到引用特定进程的消息，请在此处输入该进程ID。'
- en: '**Log Level**: To filter based on log level, open this dropdown and select
    anything other than the default **Verbose** option.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志级别**：要基于日志级别进行筛选，请打开此下拉菜单并选择除默认**详细**选项之外的内容。'
- en: Working with breakpoints
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与断点一起工作
- en: Having trouble working out where an error is originating from? You can use breakpoints
    to pause the execution of your app at a particular line of code. By creating multiple
    breakpoints and scrutinizing your app every time it comes to a stop, you can gradually
    isolate the portion of code that's responsible for the error.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 难以确定错误来源？你可以使用断点在特定的代码行暂停你的应用程序的执行。通过创建多个断点并在每次停止时仔细检查你的应用程序，你可以逐步隔离出导致错误的代码部分。
- en: 'To set a breakpoint:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置断点：
- en: Open the file where you want to create your breakpoint.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你想要创建断点的文件。
- en: Locate the line where you want to set your breakpoint and click on this line.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位到你想要设置断点的行，并点击该行。
- en: Click the yellow portion that appears in the left-hand sidebar. A red dot will
    appear, indicating that you've successfully created a breakpoint.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左侧侧边栏中出现的黄色部分。会出现一个红色点，表示你已经成功创建了一个断点。
- en: '![Working with breakpoints](img/B05061_9_18.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![与断点一起工作](img/B05061_9_18.jpg)'
- en: After creating your breakpoints, click the Rerun app icon (the green **Play**
    icon along the left-hand toolbar).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 创建断点后，点击重运行应用程序图标（位于左侧工具栏上的绿色**播放**图标）。
- en: Every time Android Studio reaches a breakpoint, it'll pause the execution of
    your app and highlight the triggered breakpoint in your code. You can then open
    the **Debug** window (by selecting the **Debug** tab in the bottom toolbar) and
    use the debugger and console to gather more information about what's going on
    in your app at this exact point in the execution of your code. You may also want
    to take a look at the **logcat** output. Repeat this process until you've isolated
    the code that's causing the problem.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 每当Android Studio达到断点时，它将暂停你的应用程序的执行，并在你的代码中突出显示触发的断点。然后你可以打开**调试**窗口（通过在底部工具栏中选择**调试**选项卡），并使用调试器和控制台收集有关你的应用程序在代码执行此特定点的更多信息。你可能还想查看**日志输出**。重复此过程，直到你隔离出导致问题的代码。
- en: Configuring your breakpoints
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置您的断点
- en: 'If you have a very specific kind of breakpoint in mind, you can make some changes
    to your breakpoint settings. Start by clicking the **View Breakpoints** icon (where
    the cursor is positioned in the following screenshot):'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您心中有一个非常具体的断点类型，您可以对断点设置进行一些修改。首先，点击**查看断点**图标（如下截图中的光标位置）：
- en: '![Configuring your breakpoints](img/B05061_9_19.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![配置您的断点](img/B05061_9_19.jpg)'
- en: The Breakpoint window appears and lists all the breakpoints you've created in
    the current project. To see what changes you can make to a breakpoint, select
    that breakpoint from the left-hand list.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 断点窗口出现，并列出当前项目中创建的所有断点。要查看您可以对断点进行哪些更改，请从左侧列表中选择该断点。
- en: '![Configuring your breakpoints](img/B05061_9_20.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![配置您的断点](img/B05061_9_20.jpg)'
- en: 'This window gives you lots of different options for configuring the selected
    breakpoint:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 此窗口为您提供了配置所选断点的许多不同选项：
- en: '**Suspend**: Select this checkbox to enable a suspend policy for this breakpoint,
    then choose from **All** (when a breakpoint is hit, all threads are suspended)
    or **Thread** (when a breakpoint is hit, only the thread where the breakpoint
    is hit is suspended).'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**挂起**：选择此复选框以为此断点启用挂起策略，然后从**所有**（当断点被触发时，所有线程都会挂起）或**线程**（当断点被触发时，只有断点所在的线程会挂起）中选择。'
- en: '**Condition**: Select this checkbox, then in the accompanying textbox specify
    a condition for hitting this breakpoint. The condition must be a Java Boolean
    expression with a `true/false` value. This condition is evaluated each time the
    breakpoint is reached, and if the result is true the specified action is performed.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**条件**：选择此复选框，然后在相应的文本框中指定达到此断点的条件。该条件必须是一个具有`true/false`值的Java布尔表达式。每次达到断点时都会评估此条件，如果结果为true，则执行指定的操作。'
- en: '**Log message to console**: Select this checkbox to display a log message in
    the console when this breakpoint is hit.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将日志消息记录到控制台**：选择此复选框以在达到此断点时在控制台中显示日志消息。'
- en: '**Log evaluated expression**: Select this checkbox to evaluate an expression
    when this breakpoint is hit and display the results in Android Studio''s console.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**记录评估表达式**：选择此复选框以在达到此断点时评估一个表达式，并在Android Studio的控制台中显示结果。'
- en: '**Remove once hit**: When enabled, this breakpoint will be triggered once and
    then removed.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一旦触发即删除**：当启用时，此断点将触发一次然后被删除。'
- en: '**Disabled until the selected breakpoint is hit**: This breakpoint is dependent
    on another breakpoint, and will only be enabled once the specified breakpoint
    has been triggered.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**禁用直到所选断点被触发**：此断点依赖于另一个断点，并且只有在指定的断点被触发后才会启用。'
- en: '**Instance filters**: To limit breakpoint hits to instances of a particular
    object, select this checkbox and then provide the ID value of the instance you
    want to use.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实例过滤器**：为了将断点命中限制为特定对象的实例，选择此复选框，然后提供您想要使用的实例的ID值。'
- en: '**Class filters**: Select this checkbox to have this breakpoint behave differently
    in reaction to different classes. Then, specify the classes that''ll trigger the
    breakpoint in the accompanying textbox. To define classes where the breakpoint *shouldn''t*
    be triggered, add these classes to the textbox but preface them with a minus symbol.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类过滤器**：选择此复选框以使此断点对不同的类有不同的行为。然后，在相应的文本框中指定将触发断点的类。要定义不应触发断点的类，将这些类添加到文本框中，但要在前面加上减号符号。'
- en: '**Pass count**: Define the number of times a breakpoint should be reached,
    but ignored, by selecting this checkbox and then specifying the number of times
    the breakpoint should be skipped. After the specified number of passes, the breakpoint
    will be triggered as normal.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过计数**：通过选择此复选框并指定断点应跳过的次数来定义断点应达到但忽略的次数。在指定的次数通过之后，断点将正常触发。'
- en: Examining your code with Lint
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Lint检查您的代码
- en: It's important to check that there are no problems with the structural quality
    of your code, as these can cause errors and have a negative impact on your app's
    performance. Conveniently, the Android SDK comes with Lint, a static code-scanning
    tool that's *perfect* for identifying and correcting structural problems with
    your code.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 检查您的代码的结构质量是否存在问题非常重要，因为这些可能会引起错误并对您的应用程序性能产生负面影响。方便的是，Android SDK附带了一个名为Lint的静态代码扫描工具，它非常适合识别和纠正您代码中的结构问题。
- en: In Android Studio, the configured Lint expressions run every time you build
    your app and print the output to Android Studio's **Events log**, which you can
    access by selecting the **Events log** tab.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中，配置的 Lint 表达式会在每次构建应用时运行，并将输出打印到 Android Studio 的 **事件日志**
    中，您可以通过选择 **事件日志** 选项卡来访问它。
- en: However, you can also run Lint on a specific module at any time, by right-clicking
    on that module's file or folder and then selecting **Analyze** **| ** **Inspect
    code,** followed by the area you want to inspect (**Whole project, ** **Module**,
    or **Custom Scope**). Make your selection, and Android Studio automatically opens
    a new **Inspection** tab where you can view the Lint output.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您也可以在任何时候通过右键单击特定模块的文件或文件夹，然后选择 **分析** **|** **检查代码**，接着选择您想要检查的区域（**整个项目**、**模块**或**自定义范围**）来运行
    Lint。做出选择后，Android Studio 会自动打开一个新的 **检查** 选项卡，您可以在其中查看 Lint 输出。
- en: To help you zero in on critical problems, Lint provides a description and a
    severity level for every issue it reports.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您聚焦于关键问题，Lint 为它报告的每个问题都提供了描述和严重程度级别。
- en: '![Examining your code with Lint](img/B05061_9_21.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Lint 检查您的代码](img/B05061_9_21.jpg)'
- en: Make sure you correct *all* errors that Lint detects before you release your
    app.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布应用之前，请确保您已纠正 Lint 检测到的 **所有** 错误。
- en: If you need to make some changes to the default Lint settings, select **Android
    Studio** from the toolbar, followed by **Preferences**. In the window that appears,
    double-click **Editor** and select **Inspections**.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要修改默认的 Lint 设置，请从工具栏中选择 **Android Studio**，然后选择 **首选项**。在出现的窗口中，双击 **编辑器**
    并选择 **检查**。
- en: This opens the **Inspection Configuration** page, which lists all the supported
    Lint profiles and inspections.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开 **检查配置** 页面，其中列出了所有支持的 Lint 配置文件和检查。
- en: '![Examining your code with Lint](img/B05061_9_22.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Lint 检查您的代码](img/B05061_9_22.jpg)'
- en: Here, you can explore the different inspections and make edits such as changing
    their severity level and scope.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以探索不同的检查，并进行诸如更改它们的严重程度级别和范围等编辑。
- en: 'You can also run Lint inspections for a specific build variant or for all build
    variants, by adding the `lintOptions` property to your project''s module-level `build.gradle`
    file. For example, if you wanted to set your Lint''s `abortOnError` option to `false`,
    you''d need to add the following to your `build.gradle` file:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过将 `lintOptions` 属性添加到项目的模块级 `build.gradle` 文件中，为特定的构建变体或所有构建变体运行 Lint
    检查。例如，如果您想将 Lint 的 `abortOnError` 选项设置为 `false`，您需要将以下内容添加到您的 `build.gradle` 文件中：
- en: '[PRE1]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can find a complete list of all your Lint configuration options at Google's
    GitHub ([http://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.LintOptions.html#com.android.build.gradle.internal.dsl.LintOptions](http://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.LintOptions.html#com.android.build.gradle.internal.dsl.LintOptions)).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 Google 的 GitHub 上找到所有 Lint 配置选项的完整列表（[http://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.LintOptions.html#com.android.build.gradle.internal.dsl.LintOptions](http://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.LintOptions.html#com.android.build.gradle.internal.dsl.LintOptions))。
- en: Optimizing your code with ProGuard
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ProGuard 优化您的代码
- en: The ProGuard tool shrinks and optimizes your code by removing unused code and
    renaming classes, fields, and methods with semantically obscure names. The end
    result is a smaller `APK` that's more difficult to reverse engineer, something
    that's particularly important if your app has access to sensitive information.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ProGuard 工具通过删除未使用的代码和将类、字段和方法重命名为语义上模糊的名称来缩小和优化您的代码。最终结果是更小的 `APK` 文件，更难进行逆向工程，这对于您的应用可以访问敏感信息尤其重要。
- en: 'ProGuard runs automatically when you build your app in release mode. To build
    a release version of your app, you need to enable the `minifyEnabled` property
    in your project''s module-level `build.gradle` file and make sure `buildTypes`
    is set to `release`. For example:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ProGuard 在您以发布模式构建应用时会自动运行。要构建应用的发布版本，您需要在项目的模块级 `build.gradle` 文件中启用 `minifyEnabled`
    属性，并确保 `buildTypes` 设置为 `release`。例如：
- en: '[PRE2]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `getDefaultProguardFile` attribute obtains the default ProGuard settings
    specified in the `Android/sdk/tools/proguard/proguard-android.txt` file that you
    downloaded as part of the Android SDK. Alternatively, you can use the `proguard-android-optimize.txt`
    file, which contains the same rules but has optimization enabled.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`getDefaultProguardFile`属性获取在下载的Android SDK中指定的默认ProGuard设置，该设置位于`Android/sdk/tools/proguard/proguard-android.txt`文件中。或者，你可以使用`proguard-android-optimize.txt`文件，它包含相同的规则，但启用了优化。'
- en: If you want to add some project-specific options to the default ProGuard settings,
    open your project's `Gradle Scripts/proguard-rules.pro` file and add your new
    rules.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想向默认ProGuard设置中添加一些项目特定的选项，请打开你的项目的`Gradle Scripts/proguard-rules.pro`文件并添加你的新规则。
- en: For more information about the different ProGuard settings that you can add
    to this file, check out the ProGuard manual ( [https://stuff.mit.edu/afs/sipb/project/android/sdk/android-sdk-linux/tools/proguard/docs/index.html#manual/retrace/examples.html](https://stuff.mit.edu/afs/sipb/project/android/sdk/android-sdk-linux/tools/proguard/docs/index.html#manual/retrace/examples.html)
    ).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 有关可以添加到此文件的不同ProGuard设置的更多信息，请参阅ProGuard手册（[https://stuff.mit.edu/afs/sipb/project/android/sdk/android-sdk-linux/tools/proguard/docs/index.html#manual/retrace/examples.html](https://stuff.mit.edu/afs/sipb/project/android/sdk/android-sdk-linux/tools/proguard/docs/index.html#manual/retrace/examples.html)）。
- en: Scrutinize each pixel
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仔细检查每个像素
- en: Another tool you may want to explore is **Pixel Perfect**.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还想探索另一个工具，即**像素完美**。
- en: The **Pixel Perfect** window displays a magnified version of the screen that's
    currently visible on the attached Android device or emulator, and lets you scrutinize
    the individual pixels that make up your UI. You can also use it to overlay an
    image over your UI, which is handy for checking how your UI compares to your digital
    wireframes.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**像素完美**窗口显示连接的Android设备或模拟器上当前可见的屏幕的放大版本，并允许你检查构成你的UI的各个像素。你还可以用它来在你的UI上叠加图像，这对于检查你的UI与你的数字线框图相比如何非常有用。'
- en: '**Pixel Perfect** is integrated into the **Android Device Monitor**. To launch
    **Pixel Perfect**, select **Window** from the **Android Device Monitor** toolbar,
    followed by **Open Perspective**, **Pixel Perfect,** and **OK**.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**像素完美**集成到**Android设备监控器**中。要启动**像素完美**，从**Android设备监控器**工具栏中选择**窗口**，然后选择**打开视角**、**像素完美**，最后选择**确定**。'
- en: '![Scrutinize each pixel](img/B05061_9_23.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![仔细检查每个像素](img/B05061_9_23.jpg)'
- en: The **Pixel Perfect** window contains the following areas.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**像素完美**窗口包含以下区域。'
- en: Pixel Perfect pane
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 像素完美面板
- en: This window displays a magnified version of the UI that's currently visible
    on the connected Android device or AVD.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 此窗口显示连接的Android设备或AVD上当前可见的UI的放大版本。
- en: By default, Pixel Perfect doesn't update automatically to reflect changes that
    occur on screen, so you'll need to keep clicking this pane's **Refresh Screenshot**
    icon. Alternatively, if you want Pixel Perfect to update automatically, then select
    the **Automatically Refresh the screenshot** icon.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，像素完美不会自动更新以反映屏幕上的变化，因此你需要不断点击此面板的**刷新截图**图标。或者，如果你想使像素完美自动更新，请选择**自动刷新截图**图标。
- en: One of Pixel Perfect's most useful features is the ability to load `jpg`, `jpeg`, `png`, `gif`,
    or `bmp` images as an overlay. This is particularly useful if you want to take
    stock of how the current screen compares to your original design, as you can load
    a digital wireframe (or any other digital design docs you have to hand) as an
    overlay.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 像素完美最有用的功能之一是能够将`jpg`、`jpeg`、`png`、`gif`或`bmp`图像作为叠加层加载。如果你想要比较当前屏幕与你的原始设计，这特别有用，因为你可以加载一个数字线框图（或你手头上的任何其他数字设计文档）作为叠加层。
- en: To load an image as an overlay, navigate to the screen you want to work with
    and make sure it's being displayed in the Pixel Perfect window. Select the **Load
    an image to overlay the screenshot** icon, and then select the image you want
    to use as your overlay.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图像作为叠加层加载，导航到你要工作的屏幕，并确保它在像素完美窗口中显示。选择**加载图像以叠加截图**图标，然后选择你想要用作叠加层的图像。
- en: Pixel Perfect tree
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 像素完美树
- en: This is a hierarchical list of all the `View` objects that are currently visible.
    Just be aware that system objects also appear in this list.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个当前可见的所有`View`对象的分层列表。只需注意，系统对象也会出现在此列表中。
- en: Pixel Perfect Loupe pane
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 像素完美放大镜面板
- en: 'This pane contains the magnified screen image, overlaid by a grid where one
    square represents one pixel. To see more information about a particular pixel,
    select it and the Loupe pane will display the following:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 此面板包含放大的屏幕图像，上面覆盖了一个网格，其中每个方格代表一个像素。要查看特定像素的更多信息，请选择它，放大镜面板将显示以下内容：
- en: '**Pixel swatch**: A rectangle filled with the same color as the selected pixel'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**像素色块**：填充与所选像素相同颜色的矩形'
- en: '**HTML color code**: The pixel''s corresponding hexadecimal RGB code'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTML颜色代码**：像素对应的十六进制RGB代码'
- en: '**RGB color values**: The pixel''s R, G, and B color values'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RGB颜色值**：像素的R、G和B颜色值'
- en: '**X and Y coordinates**: The pixel''s coordinates, as a px value'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**X和Y坐标**：像素的坐标，以px值表示'
- en: Processes and threads
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程和线程
- en: How your app handles threads and processes has a significant impact on your
    app's performance. By default, when the user launches an app, the Android system
    creates a single thread of execution for that application. All components run
    in this single thread, which is known as the *main* thread or the *UI* thread.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用如何处理线程和进程对您的应用性能有重大影响。默认情况下，当用户启动一个应用时，Android系统为该应用创建一个执行线程。所有组件都在这个单线程上运行，这个线程被称为**主线程**或**UI线程**。
- en: Unless you specify otherwise, most of the operations you perform in your app
    run in the foreground on this main thread. Most of the time this single-thread
    model works fine, but if your app needs to perform particularly intensive work
    or long-running operations, then the main thread can become blocked. This can
    cause your app to freeze, display system errors, and potentially even crash.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 除非您另有指定，否则您在应用中执行的大多数操作都在主线程上以前台运行。大多数情况下，这种单线程模型运行良好，但如果您的应用需要执行特别密集的工作或长时间运行的操作，那么主线程可能会变得阻塞。这可能导致您的应用冻结、显示系统错误，甚至可能崩溃。
- en: If you're going to deliver a good user experience, then it's vital you don't
    block the UI thread with intensive or long-running operations. If you do need
    to run demanding processes, then you should create additional threads.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要提供良好的用户体验，那么您绝对不要使用密集或长时间运行的操作来阻塞UI线程。如果您确实需要运行要求高的进程，那么您应该创建额外的线程。
- en: This involves specifying which process a certain component belongs to in your
    project's `Manifest` file. The `Manifest` entry for each type of component (activity,
    service, receiver, or provider) includes an `android:process` attribute that specifies
    the process where this component should run. If you want the system to create
    a new process for this component, preface the `android:process` value with a colon,
    for example `android:process=":myprocess"`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这涉及到在项目的`Manifest`文件中指定某个组件属于哪个进程。每种类型的组件（活动、服务、接收器或提供者）的`Manifest`条目都包含一个`android:process`属性，该属性指定了此组件应运行的进程。如果您希望系统为此组件创建一个新的进程，请在`android:process`值前加冒号，例如`android:process=":myprocess"`。
- en: If you need to handle more complex interactions, you may want to consider using
    a `Handler` to process messages delivered from the main thread, or you could use
    the `AsyncTask` class to simplify the execution of worker thread tasks that need
    to interact with your UI.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要处理更复杂的交互，您可能希望考虑使用`Handler`来处理从主线程传递的消息，或者您可以使用`AsyncTask`类来简化需要与您的UI交互的工作线程任务的执行。
- en: Tip
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Using AsyncTask**'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用AsyncTask**'
- en: '`AsyncTask` provides you with an easy way of performing synchronous work on
    your user interface without blocking the main thread. Using `AsyncTask`, you can
    separate tasks into the work that should be performed on the main thread and operations
    that should be performed on a separate worker thread. In this way, `AsyncTask`
    is a way of executing some work in a background thread and then publishing the
    results back to the main thread.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncTask`为您提供了一个在用户界面中执行同步工作而不阻塞主线程的简单方法。使用`AsyncTask`，您可以分离任务为主线程上应执行的工作和应在单独的工作线程上执行的操作。这样，`AsyncTask`是一种在后台线程中执行一些工作然后将结果发布回主线程的方法。'
- en: To use `AsyncTask`, you need to subclass `AsyncTask` and then implement the `doInBackground()`
    callback method, which executes automatically on a worker thread and performs
    background operations. The value returned by `doInBackground()` is then sent to `onPostExecute()`,
    and from here you can run the task by calling `execute()` on the main thread.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`AsyncTask`，您需要继承`AsyncTask`并实现`doInBackground()`回调方法，该方法在工作线程上自动执行并执行后台操作。`doInBackground()`返回的值随后发送到`onPostExecute()`，从这里您可以通过在主线程上调用`execute()`来运行任务。
- en: Ideally, you should only use `AsyncTasks` for short operations. If you need
    to keep threads running for more than a few seconds, it's recommended that you
    use APIs such as `Executor`, `ThreadPoolExecutor,` and `FutureTask`, which are
    provided as part of the `java.util.concurrent` package.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，你应该只为短操作使用`AsyncTasks`。如果你需要保持线程运行超过几秒钟，建议使用`Executor`、`ThreadPoolExecutor`和`FutureTask`等API，这些API作为`java.util.concurrent`包的一部分提供。
- en: Terminating processes
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 终止进程
- en: When deciding how your application should handle processes, it's worth bearing
    in mind that even though the Android system will try and maintain all processes
    for as long as possible, it will kill off processes if memory starts getting low.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定你的应用程序应该如何处理进程时，值得记住的是，尽管Android系统会尽可能长时间地维护所有进程，但如果内存开始变低，它将终止进程。
- en: When deciding what processes to keep alive and which processes to terminate,
    the system decides how important each process is to the user by placing these
    processes in an **importance hierarchy**. Processes with the lowest importance
    are the first to go, while processes at the top of the importance hierarchy are
    rarely killed off.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定保留哪些进程和终止哪些进程时，系统通过将这些进程放入一个**重要性层次结构**中来决定每个进程对用户的重要性。重要性最低的进程首先被终止，而重要性层次结构顶部的进程很少被终止。
- en: Note
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Android system will increase the ranking of a process if another, more important,
    process depends on it. A process that's supporting another process can *never *be
    ranked lower than the most important process it's supporting.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果另一个更重要进程依赖于它，Android系统将提高进程的排名。支持另一个进程的进程*永远*不能排名低于它所支持的最重要进程。
- en: Ranked from most important to least important, the different levels of Android's
    importance hierarchy are detailed in the following sections.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 从最重要的到最不重要的，Android的重要性层次结构的不同级别在以下章节中详细说明。
- en: Foreground processes
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 前台进程
- en: 'This is a process that''s essential for the actions the user is currently performing.
    The Android system assigns a process this ranking if it hosts either:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个对用户当前执行的操作至关重要的进程。如果进程托管以下任一内容，Android系统将分配此排名：
- en: An `Activity` that the user is interacting with
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户正在与之交互的活动`Activity`
- en: A `Service` that's running in the foreground
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正在前台运行的服务`Service`
- en: A `Service` that's bound to the activity the user is currently interacting with
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定到用户当前交互活动的服务`Service`
- en: A `Service` that's executing one of its lifecycle callbacks (`onCreate`, `onStart`,
    or `onDestroy`)
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行其生命周期回调（`onCreate`、`onStart`或`onDestroy`）的服务`Service`
- en: A `BroadcastReceiver` that's executing its `onReceive()` method
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正在执行其`onReceive()`方法广播接收器`BroadcastReceiver`
- en: If any of these conditions are true, that process is considered a foreground
    process. The Android system only kills foreground processes as a very last resort.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些条件中的任何一个成立，该进程被视为前台进程。Android系统只有在万不得已的情况下才会终止前台进程。
- en: Visible processes
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可见进程
- en: This is a process that doesn't have any foreground components but may still
    affect what the user is seeing on screen. The Android system assigns this ranking
    if the process hosts a `Service` that's bound to a visible Activity, or an Activity
    that's not in the foreground but is still visible to the user, for example an
    Activity where the `onPause()` method has been called.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个没有前台组件但可能仍然影响用户在屏幕上看到的进程。如果进程托管一个绑定到可见活动`Activity`的服务，或者一个不在前台但仍然对用户可见的活动（例如，在`onPause()`方法已被调用的活动），Android系统将分配此排名。
- en: The Android system will only kill a visible process if there's not enough memory
    to support all foreground processes.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有足够的内存来支持所有前台进程，Android系统将只终止可见进程。
- en: Service processes
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务进程
- en: This is a process that's running a `Service`, but doesn't fall into either of
    the two higher categories.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个运行服务`Service`的进程，但不属于上述两个更高类别。
- en: Although service processes are not directly related to anything the user sees,
    they usually perform actions that the user cares about. The system will avoid
    killing service processes unless doing so is the only way to keep all foreground
    and visible processes running.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然服务进程与用户看到的任何内容没有直接关系，但它们通常执行用户关心的操作。除非这样做是保持所有前台和可见进程运行的唯一方法，否则系统将避免终止服务进程。
- en: Background processes
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 后台进程
- en: Background processes hold an Activity that's not currently visible to the user.
    Since background processes don't have a direct impact on the user experience,
    the system may kill background processes off at any time if it needs to reclaim
    memory for foreground, visible, or service processes.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 后台进程持有当前对用户不可见的Activity。由于后台进程不会直接影响用户体验，如果系统需要为前台、可见或服务进程回收内存，它可以在任何时候终止后台进程。
- en: Empty processes
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空进程
- en: This is a process that doesn't hold any active components. The system may keep
    empty processes alive for caching purposes, but make no mistake, they're the first
    to go if the system needs to free up some memory.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个不包含任何活动组件的过程。系统可能会为了缓存目的保留空进程，但请记住，如果系统需要释放内存，它们将是第一个被终止的。
- en: Re-using layouts with > and <merge/>
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用>和<merge/>重用布局
- en: The Android platform provides a range of simple, reusable UI components known
    as widgets, but sometimes there may be larger or more complex UI components that
    you need to reuse across multiple screens, such as a panel containing a progress
    bar and a **Cancel** button, or a user profile consisting of a username and an
    avatar.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: Android平台提供了一系列简单、可重用的UI组件，称为小部件，但有时可能需要跨多个屏幕重用更大或更复杂的UI组件，例如包含进度条和**取消**按钮的面板，或者由用户名和头像组成的用户资料。
- en: If your project features elements that you want to use multiple times, you can
    save yourself time and effort by implementing these elements as a reusable layout.
    You can then import these reusable elements into as many layout files as you want,
    using Android's `>` and `<merge/>` tags.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的项目包含您想要多次使用的元素，您可以通过将这些元素实现为可重用布局来节省时间和精力。然后，您可以使用Android的`>`和`<merge/>`标签将这些可重用元素导入到您想要的任何布局文件中。
- en: To extract common elements into a reusable layout, create a new XML layout resource
    file and then define the UI elements you want to reuse. Pay special attention
    to the file's root view as this will also be included every time you embed this
    component in other layouts.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将常用元素提取到可重用的布局中，创建一个新的XML布局资源文件，然后定义您想要重用的UI元素。请注意文件的根视图，因为每次您将此组件嵌入其他布局时，它也将被包含在内。
- en: 'To import your reusable component into a layout resource file, just add the
    `include` tag and reference the layout file you want to import. For example, if
    you''d created a reusable layout called `contactslist` and wanted to import this
    component into another layout, you''d use the following:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 要将您的可重用组件导入到布局资源文件中，只需添加`include`标签并引用您想要导入的布局文件。例如，如果您创建了一个名为`contactslist`的可重用布局，并希望将其组件导入到另一个布局中，您将使用以下方法：
- en: '[PRE3]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: However, be aware that using the `include` tag can introduce redundant `ViewGroups`
    into your view hierarchy.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，使用`include`标签可能会将冗余的`ViewGroups`引入到您的视图层次结构中。
- en: Imagine you have a layout called `main_layout.xml` that uses a vertical `LinearLayout`
    as its root view. You have a re-usable `contactslist_layout.xml` component that
    you want to include in this `main_layout` file, but the `contactslist_layout`
    also uses a vertical `LinearLayout` as its root view.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一个名为`main_layout.xml`的布局，它使用一个垂直的`LinearLayout`作为其根视图。您有一个可重用的`contactslist_layout.xml`组件，您希望将其包含在`main_layout`文件中，但`contactslist_layout`也使用一个垂直的`LinearLayout`作为其根视图。
- en: If you include `contactslist_layout.xml` in your main layout, you're going to
    end up with a vertical `LinearLayout` inside a vertical `LinearLayout`. This duplicate
    vertical layout isn't contributing anything to the UI, but it *is* making your
    view hierarchy more complex and potentially slowing down your app. So how do we
    get rid of this duplicate `LinearLayout`? The answer is by using the `merge` tag.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在主布局中包含`contactslist_layout.xml`，您最终会在一个垂直的`LinearLayout`内部得到一个垂直的`LinearLayout`。这个重复的垂直布局对UI没有任何贡献，但它确实使您的视图层次结构更加复杂，并可能减慢您的应用程序。那么我们如何去除这个重复的`LinearLayout`呢？答案是使用`merge`标签。
- en: The `merge` element helps to eliminate the redundant `ViewGroups` that can work
    their way into your view hierarchy when you include reusable layouts.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`merge`元素有助于消除在包含可重用布局时可能进入您的视图层次结构的冗余`ViewGroups`。'
- en: When you use the `merge` element as the root view of a reusable layout, the `LayoutInflator`
    skips the `merge` tag and inserts the reusable views into the `main_layout` as
    though they've always been part of that layout. As a result, your view hierarchy
    is simpler—which is nothing but good news for your app's performance!
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将 `merge` 元素用作可复用布局的根视图时，`LayoutInflator` 会跳过 `merge` 标签，并将可复用视图插入到 `main_layout`
    中，就像它们一直是该布局的一部分一样。因此，你的视图层次结构更简单——这对你的应用性能来说是个好消息！
- en: Loading views only when needed
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 只在需要时加载视图
- en: Depending on your app, you may find yourself with a user interface that contains
    a large number of complex views that you rarely use, such as pop-ups and progress
    indicators.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的应用，你可能会发现自己有一个包含大量复杂视图的用户界面，这些视图你很少使用，例如弹出窗口和进度指示器。
- en: One possible solution to this problem is to add some of these complex `Views`
    via a `ViewStub`, which is a variation of the `include` tag. A `ViewStub` is a
    lightweight view that isn't included in your layout directly, so it's very cheap
    to keep in your view hierarchy.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的可能方法之一是通过 `ViewStub` 添加一些这些复杂的 `Views`，它是 `include` 标签的一种变体。`ViewStub`
    是一个轻量级视图，它不会直接包含在你的布局中，因此它在视图层次结构中保持成本低廉。
- en: When you add a `View` via a `ViewStub`, the `ViewStub` only loads the `View`
    as and when it's needed. This allows you to create complex layouts consisting
    of lots of small views, and your UI will still render quickly and smoothly as
    you're not immediately populating your user interface with lots of complex `Views`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 当你通过 `ViewStub` 添加一个 `View` 时，`ViewStub` 只在需要时加载 `View`。这允许你创建由许多小视图组成的复杂布局，而且你的
    UI 仍然可以快速、平滑地渲染，因为你没有立即用大量的复杂 `Views` 填充你的用户界面。
- en: 'To use a `ViewStub`, you need to specify the layout you want to inflate using
    the `android:id` attribute, for example:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `ViewStub`，你需要使用 `android:id` 属性指定要膨胀的布局，例如：
- en: '[PRE4]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When it''s time to load your `ViewStub''s` layout, you just need to set the `ViewStub`
    to visible. To do this, either change the visibility of the stub by calling `setVisibility(View.VISIBLE)`:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要加载 `ViewStub` 的布局时，你只需将 `ViewStub` 设置为可见。为此，可以通过调用 `setVisibility(View.VISIBLE)`
    来更改 stub 的可见性：
- en: '[PRE5]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Or invoke the `inflate()` method:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 或者调用 `inflate()` 方法：
- en: '[PRE6]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The inflated layout replaces the `ViewStub`, and at this point the `ViewStub`
    element is no longer part of your view hierarchy.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 膨胀的布局替换了 `ViewStub`，此时 `ViewStub` 元素就不再是你的视图层次结构的一部分了。
- en: Note
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`ViewStub` currently doesn''t support the `merge` tag in the layouts to be
    inflated.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewStub` 目前不支持在要膨胀的布局中使用 `merge` 标签。'
- en: Summary
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, I covered some of the most common performance problems you
    need to be aware of when developing Android apps, including overdraw, memory leaks,
    and complex view hierarchies.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我介绍了一些在开发 Android 应用时需要了解的常见性能问题，包括过度绘制、内存泄漏和复杂的视图层次结构。
- en: We took an in-depth look at numerous tools you can use to check whether some
    of the most common performance problems are affecting your Android projects. We
    also looked at how to gather more information about any problems you *do* diagnose,
    so you're in a better position to fix them.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们深入探讨了你可以用来检查一些最常见性能问题是否影响你的 Android 项目的众多工具。我们还探讨了如何收集有关任何诊断出的问题的更多信息，这样你就能更好地解决问题。
- en: There's just one chapter left to go! In the final chapter, I'm going to cover
    all the best practices and guidelines that didn't fit neatly into any of the previous
    chapters. And since security is such a big concern for mobile users and developers
    at the moment, I'll also show you how to lock down your UI (and your app in general)
    so you can be confident that your app isn't leaving users open to security vulnerabilities.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下最后一章了！在最后一章中，我将涵盖所有那些没有很好地融入前几章的最佳实践和指南。鉴于安全问题是当前移动用户和开发者的一大关注点，我还会向你展示如何锁定你的
    UI（以及你的应用总体上）以确保你的应用不会让用户暴露在安全漏洞之下。
