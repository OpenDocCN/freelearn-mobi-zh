- en: Chapter 2. OpenGL ES 3.0 Essentials
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 2 章：OpenGL ES 3.0 基础
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下小节：
- en: Building prototypes using the GLPI framework
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GLPI 框架构建原型
- en: Implementing touch events
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现触摸事件
- en: Rendering primitives with vertex arrays
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用顶点数组渲染原语
- en: Drawing APIs in OpenGL ES 3.0
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL ES 3.0 中的绘图 API
- en: Efficient rendering with Vertex Buffer Object
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用顶点缓冲对象进行高效渲染
- en: Transformations with the model, view, and projection analogies
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模型、视图和投影类比进行变换
- en: Understanding the projection system in GLPI
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 GLPI 中理解投影系统
- en: Culling in OpenGL ES 3.0
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL ES 3.0 中的剔除
- en: Depth testing in OpenGL ES 3.0
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL ES 3.0 中的深度测试
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter will provide a detailed description of the basic concepts that
    are required to understand 3D graphics and implement them using OpenGL ES 3.0\.
    In the beginning of this chapter, we will build a mini portable 3D engine that
    will be helpful in creating small prototype-based projects quickly. It manages
    the code effortlessly in the OpenGL ES 3.0 programmable pipeline. You will learn
    event handling to manage gestures on the screen surface under Android and iOS
    platforms. These will be helpful in implementing gesture-based applications.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将详细描述理解 3D 图形并使用 OpenGL ES 3.0 实现它们所需的基本概念。在本章的开始，我们将构建一个迷你便携式 3D 引擎，这将有助于快速创建基于原型的项目。它在
    OpenGL ES 3.0 可编程管道中轻松管理代码。您将学习事件处理，以在 Android 和 iOS 平台上管理屏幕表面的手势。这些将有助于实现基于手势的应用程序。
- en: As we move on, we will discuss the fundamental transformation in the 3D graphics
    with the help of the model, view, and projection analogy. At the core side, we
    will look at the different types of available primitives to render a given geometry
    in OpenGL ES 3.0 and discuss optimization techniques that could increase rendering
    performance using **Vertex Buffer Object** (**VBO**). As we approach the end,
    we will understand geometry culling. It controls the rendering of front or back
    faces of an object. The last recipe of the chapter will implement depth testing,
    which is a very important aspect of computational graphics.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续前进，我们将借助模型、视图和投影的类比来讨论 3D 图形中的基本变换。在核心方面，我们将探讨在 OpenGL ES 3.0 中渲染给定几何形状的不同原语类型，并讨论使用
    **顶点缓冲对象**（**VBO**）可能提高渲染性能的优化技术。随着接近尾声，我们将了解几何剔除。它控制着对象的前面或后面的渲染。本章的最后一个小节将实现深度测试，这是计算机图形学中的一个非常重要的方面。
- en: Building prototypes using the GLPI framework
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GLPI 框架构建原型
- en: The GLPI is an OpenGL ES platform-independent framework. It is a mini 3D engine
    that is highly useful for developing prototype applications rapidly. It provides
    higher-level utility classes to render engines, shader compilations, 3D transformations,
    mesh management, buffer management, textures, and many more. The framework primarily
    supports Android and iOS platforms and is designed to be easily portable to other
    platforms such as WinCE, Blackberry, Bada, and so on. We will go through each
    module of this framework in detail in this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: GLPI 是一个 OpenGL ES 平台无关的框架。它是一个高度有用的迷你 3D 引擎，可以快速开发原型应用程序。它为渲染引擎、着色器编译、3D 变换、网格管理、缓冲区管理、纹理等提供了高级实用类。该框架主要支持
    Android 和 iOS 平台，并设计为易于移植到其他平台，如 WinCE、Blackberry、Bada 等。在本章中，我们将详细讨论此框架的每个模块。
- en: 'This framework provides dedicated modules for rapid development of the OpenGL
    ES 3.0 prototype applications. It comprises of three main modules, as shown in
    the following figure:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此框架为 OpenGL ES 3.0 原型应用程序的快速开发提供了专用模块。它包括以下三个主要模块，如图所示：
- en: '![Building prototypes using the GLPI framework](img/5527OT_02_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![使用 GLPI 框架构建原型](img/5527OT_02_01.jpg)'
- en: 'Let''s look at each of them in detail:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一详细探讨它们：
- en: '**GLPI module**: This module is the backbone of the GLPI framework. It contains
    the following classes inside it:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GLPI 模块**：此模块是 GLPI 框架的骨干。它包含以下类：'
- en: '| Class | Function |'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 类别 | 功能 |'
- en: '| --- | --- |'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Program Manager` | This class is responsible for creating the shader program
    from program objects. It maintains all the program objects in a single manageable
    piece that other modules can use as and when required. |'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `程序管理器` | 此类负责从程序对象创建着色器程序。它维护所有程序对象在一个可管理的单一组件中，其他模块可以在需要时使用。|'
- en: '| `Shader Manager` | This class is responsible for generating the shader''s
    object. It automates the processes of loading, compiling, and generating the shader
    object for the program manager. |'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `着色器管理器` | 此类负责生成着色器对象。它自动化了为程序管理器加载、编译和生成着色器对象的流程。|'
- en: '| `Transform` | This class provides high-level APIs for 3D transformation operations.
    It also provides wrapper functions to mimic fixed function pipeline APIs, such
    as transformation, model-view-projection matrices, push and pop matrix operation,
    and so on. |'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `变换` | 此类提供用于3D变换操作的高级API。它还提供了包装函数来模拟固定功能管道API，例如变换、模型视图投影矩阵、推和弹出矩阵操作等。|'
- en: '| `GLUtils` | This class provides helper functions for the GLPI module. |'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `GLUtils` | 此类为GLPI模块提供辅助函数。|'
- en: '**Model module**: This module will help us create custom models for our application.
    A `Model` class essentially represents any type of geometric object that we are
    interested in rendering on the device screen. This class provides the model''s
    initialization, state management, processing, and rendering routines. It also
    provides touch events handling within the model.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型模块**：此模块将帮助我们为我们的应用程序创建定制模型。`Model`类本质上代表我们在设备屏幕上感兴趣渲染的任何类型的几何对象。此类提供模型的初始化、状态管理、处理和渲染例程。它还在模型内提供触摸事件处理。'
- en: Note
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `Model` class of the renderer module represents any kind of 3D rendering
    object that we are interested to render on the screen. For example, if we are
    willing to render a triangle, then we should be creating a `Triangle` class that
    must be derived from the `Model` class and should be added to the `Renderer` class
    as a child member.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 渲染模块的`Model`类代表我们在屏幕上感兴趣渲染的任何类型的3D渲染对象。例如，如果我们愿意渲染一个三角形，那么我们应该创建一个`Triangle`类，这个类必须从`Model`类派生，并且应该作为子成员添加到`Renderer`类中。
- en: '**Renderer module**: This is the rendering engine''s manager that acts as an
    interface between the underlying platform (such as Android or iOS) and our platform-independent
    graphics framework. It manages the entire graphics system rendering life cycle.
    In addition to this, the custom models created by us will also be managed by it.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**渲染模块**：这是渲染引擎的管理器，它充当底层平台（如Android或iOS）和我们的平台无关图形框架之间的接口。它管理整个图形系统渲染的生命周期。除此之外，我们创建的定制模型也将由它管理。'
- en: How to do it...
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: In the previous chapter, we implemented the Hello World Triangle recipe for
    Android and iOS platforms. Now, you will learn to use the GLPI framework by reimplementing
    the same recipe in GLPI. You can refer to the source code of this recipe by locating
    `GLPIFrameworkIntro` in the sample code of this chapter. In the following steps,
    we will set up the GLPI framework for Android/iOS platforms and learn to use it.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们为Android和iOS平台实现了Hello World三角形的配方。现在，你将通过在GLPI中重新实现相同的配方来学习使用GLPI框架。你可以通过在本章的示例代码中定位`GLPIFrameworkIntro`来参考此配方的源代码。在以下步骤中，我们将为Android/iOS平台设置GLPI框架，并学习如何使用它。
- en: '**Follow these instructions to set up GLPI for the Android platform**:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**按照以下说明为Android平台设置GLPI**：'
- en: 'Create the `Android.mk` makefile as. The makefile includes the path of the
    `zlib` makefile for compilation purpose. It is used to read/write compressed files.
    The `zlib` file is compiled as a shared library and included in the project. The
    additional libraries include `-lEGL -lGLESv3`, which provides support for EGL,
    and OpenGL ES 3.0 and `-llog`, which allow log information that would be helpful
    in debugging the application:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Android.mk` make文件。make文件包括用于编译目的的`zlib` make文件的路径。它用于读取/写入压缩文件。`zlib`文件被编译为共享库并包含在项目中。附加库包括`-lEGL
    -lGLESv3`，它提供对EGL、OpenGL ES 3.0的支持，以及`-llog`，它允许记录有助于调试应用程序的日志信息：
- en: '[PRE0]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a new make-file `Application.mk` in the same directory and add STL,
    RTTI, and exception support to your project as shown in the following lines of
    code. For OpenGL ES 3.0, the Android platform API level must be 18 or greater:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一目录下创建一个新的`Application.mk` make文件，并将STL、RTTI和异常支持添加到你的项目中，如下面的代码行所示。对于OpenGL
    ES 3.0，Android平台的API级别必须为18或更高：
- en: '[PRE1]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The chapters from now onwards contain two separate sections for Android and
    iOS development. These sections will be identified by folder names called Android
    and iOS. `NativeTemplate.h` and `NativeTemplate.cpp` (as described in the first
    chapter) are placed next to these folders. If we look at these files now, we will
    realize that they are much cleaner and contain lesser code than earlier. We have
    moved the code from these files to other files in the `Scene` folder:![How to
    do it...](img/5527OT_02_02.jpg)
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从现在开始，章节包含两个独立的 Android 和 iOS 开发部分。这些部分将通过名为 Android 和 iOS 的文件夹名称来识别。`NativeTemplate.h`
    和 `NativeTemplate.cpp`（如第一章所述）放置在这些文件夹旁边。如果我们现在查看这些文件，我们会意识到它们比以前更干净，代码也更少。我们已经将这些文件中的代码移动到了
    `Scene` 文件夹中的其他文件中：![如何做...](img/5527OT_02_02.jpg)
- en: The `Scene` folder contains the `Model` and `Renderer` classes that take care
    of generating models and rendering them. Another class that is present in this
    folder is the `Triangle` class. It contains the code to render the blue triangle.
    Make sure that all classes are included in `Android.mk`:![How to do it...](img/5527OT_02_03.jpg)
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Scene` 文件夹包含 `Model` 和 `Renderer` 类，负责生成模型和渲染它们。该文件夹中还存在另一个类，即 `Triangle`
    类。它包含渲染蓝色三角形的代码。确保所有类都包含在 `Android.mk` 中：![如何做...](img/5527OT_02_03.jpg)'
- en: Create a new folder called `Shader` under the `assets` folder and create the
    shader files (`BlueTriangleVertex.glsl` and `BlueTriangleFragment.glsl`) inside
    this folder. Move the shader programs that were earlier present in `NativeTemplate.cpp`
    (in the form of a string) into the newly created `Shader` folder. From now on,
    we will manage our shader programs in this folder.![How to do it...](img/5527OT_02_04.jpg)
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `assets` 文件夹下创建一个名为 `Shader` 的新文件夹，并在该文件夹中创建着色器文件（`BlueTriangleVertex.glsl`
    和 `BlueTriangleFragment.glsl`）。将之前存在于 `NativeTemplate.cpp`（以字符串形式）中的着色器程序移动到新创建的
    `Shader` 文件夹中。从现在开始，我们将在这个文件夹中管理我们的着色器程序：![如何做...](img/5527OT_02_04.jpg)
- en: '**For iOS, the steps to set up the framework are relatively easy and are listed
    here**:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**对于 iOS，设置框架的步骤相对简单，如下所示**：'
- en: Import (**Xcode** | **File** | **Add Files to <Project>**) all the GLPI framework
    contents into your project, except the `zlib` library. This library is only used
    for Android for file management. It is not required by iOS.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有 GLPI 框架内容（除了 `zlib` 库）导入到您的项目中。这个库仅用于 Android 的文件管理。iOS 不需要它。
- en: In the imported contents, go to the `glm` library and remove the `core` folder
    (this folder contains some sample programs that may cause errors in the existing
    project because of the presence of multiple `main()` entries).
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在导入的内容中，转到 `glm` 库并删除 `core` 文件夹（这个文件夹包含一些可能由于存在多个 `main()` 条目而导致现有项目出现错误的示例程序）。
- en: Import the shader files by going to `Android` | `Asset` | `Shader` folder (`BlueTriangleVertex.glsl`
    and `BlueTriangleFragment.glsl` ) into the current project.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到 `Android` | `Asset` | `Shader` 文件夹（`BlueTriangleVertex.glsl` 和 `BlueTriangleFragment.glsl`）将着色器文件导入到当前项目中。
- en: 'Set the `"FILESYSTEM"` environment variable in `main.m`. This will provide
    the current path of the application in the device:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main.m` 中设置 `"FILESYSTEM"` 环境变量。这将提供设备中应用程序的当前路径：
- en: '[PRE2]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![How to do it...](img/5527OT_02_05.jpg)'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做...](img/5527OT_02_05.jpg)'
- en: 'The use of the GLPI framework is very simple. We must follow this set of rules
    in order to render our 3D geometric models:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 GLPI 框架非常简单。我们必须遵循以下规则集来渲染我们的 3D 几何模型：
- en: 'Create a new custom model class that is derived from the `Model` class. For
    example, we have created the `Triangle` class that was derived from the `Model`
    class in `Triangle.h`:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的自定义模型类，该类从 `Model` 类派生。例如，我们在 `Triangle.h` 中创建了从 `Model` 类派生的 `Triangle`
    类：
- en: '[PRE3]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Open `constant.h` and edit enum `ModelType`. Add the enumeration of your choice
    to recognize the model type. For example, there are two enums added for `Triangle`
    and `Cube`. This enumeration will be helpful for the renderer to manage model
    objects:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `constant.h` 并编辑枚举 `ModelType`。添加您选择的枚举以识别模型类型。例如，为 `Triangle` 和 `Cube` 添加了两个枚举。这个枚举将有助于渲染器管理模型对象：
- en: '[PRE4]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the constructor of `Triangle`, define `ModelType`. Each model contains the
    renderer object as its parent. It also contains reference to `ProgramManager`
    and `Transform`:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Triangle` 的构造函数中定义 `ModelType`。每个模型都包含渲染对象作为其父对象。它还包含对 `ProgramManager` 和
    `Transform` 的引用：
- en: '[PRE5]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create the `VERTEX_SHADER_PRG` and `FRAGMENT_SHADER_PRG` macros in `Triangle.cpp`
    to define the relative path of the shader files in the iOS and Android platforms.
    These macros provides a platform-independent way to access the shader source code
    files from the project solution:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Triangle.cpp` 中创建 `VERTEX_SHADER_PRG` 和 `FRAGMENT_SHADER_PRG` 宏，以定义 iOS 和
    Android 平台上的着色器文件相对路径。这些宏提供了一种平台无关的方式来从项目解决方案中访问着色器源代码文件：
- en: '[PRE6]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Override the `InitModel()` function. Here, we need to compile our shader and
    register it with `ProgramManager` for the future use. `ProgramManager` stores
    the compiled shaders in an optimal way to provide quick access to the queried
    attributes. Always provide a name to the shader (in our case, `Triangle`). `ProgramManager`
    uses it as a handle, which will be helpful to retrieve the shader from any type
    of model class:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写 `InitModel()` 函数。在这里，我们需要编译我们的着色器并将其注册到 `ProgramManager` 以供将来使用。`ProgramManager`
    以最优方式存储编译后的着色器，以便快速访问查询到的属性。始终为着色器提供一个名称（在我们的例子中，为 `Triangle`）。`ProgramManager`
    使用它作为句柄，这将有助于从任何类型的模型类中检索着色器：
- en: '[PRE7]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Override the `Render()` function. It is responsible for rendering the colored
    triangle on the screen surface. In this function, first, the shader program is
    used to query the respective attributes. These attributes are used to send the
    data to the shader. Each frame of the triangle is rotated by 1 degree and updated
    in the shader:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写 `Render()` 函数。它负责在屏幕表面上渲染彩色三角形。在这个函数中，首先使用着色器程序查询相应的属性。这些属性用于将数据发送到着色器。三角形的每一帧都会旋转
    1 度并在着色器中更新：
- en: '[PRE8]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Destroy the shaders when they are not required. For this recipe, we will use
    the destructor:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当不再需要着色器时，销毁它们。对于这个示例，我们将使用析构函数：
- en: '[PRE9]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The shader created in our class is publicly accessible to other models in our
    rendering engine. Therefore, it is completely up to us whether to destroy it or
    to keep it in the rendering engine.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在类中创建的着色器对渲染引擎中的其他模型是公开可访问的。因此，是否销毁它或将其保留在渲染引擎中完全取决于我们。
- en: 'Inside `Renderer.cpp`, add the `Triangle` model in `Renderer::createModels()`
    after the `clearModels()` function:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Renderer.cpp` 文件中，在 `clearModels()` 函数之后，将 `Triangle` 模型添加到 `Renderer::createModels()`
    中：
- en: '[PRE10]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `clearModels()` ensures that there is no conflict in the rendering engine
    for the `Model` object and shaders. Therefore, it provides a clean approach to
    avoid any redundancy in OpenGL ES shaders.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`clearModels()` 确保渲染引擎中 `Model` 对象和着色器之间没有冲突。因此，它提供了一种干净的方法来避免 OpenGL ES 着色器中的任何冗余。'
- en: Override the `Render()` function. This function is responsible for making the
    rendering model to appear on the screen.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写 `Render()` 函数。这个函数负责使渲染模型出现在屏幕上。
- en: How it works...
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `Renderer` class is the manager of the rendering system. Each custom model
    defined in the GLPI framework acts as a registered member of `Renderer` and is
    recognized by its unique model type. `Renderer` provides services to the registered
    components through utility and helper classes such as `Transform` and `ProgramManager`
    interfaces. The rendering engine iterates through the entire registered models
    to define their life cycles. It ensures that the initialization, rendering, and
    destruction of the models takes place at the right time and in the right order.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`Renderer` 类是渲染系统的管理者。在 GLPI 框架中定义的每个自定义模型都作为 `Renderer` 的注册成员，并通过其独特的模型类型被识别。`Renderer`
    通过 `Transform` 和 `ProgramManager` 接口等实用程序和辅助类为注册组件提供服务。渲染引擎遍历整个注册模型以定义它们的生命周期。它确保模型的初始化、渲染和销毁在正确的时间以正确的顺序发生。'
- en: The `ProgramManager` is responsible for compiling the shader and caches it for
    later use. Transform plays a vital role in the geometric transformation operations.
    For example, it helps in placing models in the 3D space using rotation, translation,
    and scaling operations.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProgramManager` 负责编译着色器并将其缓存以供以后使用。变换在几何变换操作中起着至关重要的作用。例如，它通过旋转、平移和缩放操作帮助将模型放置在
    3D 空间中。'
- en: For more information on the internals of the 3D transformation, you can refer
    to *Understanding transformation in 3D graphics* in [Appendix](apa.html "Appendix A. Supplementary
    Information on OpenGL ES 3.0"), *Supplementary Information on OpenGL ES 3.0*.
    This topic covers types of transformation, transformation matrix conventions,
    homogenous coordinates, and transformation operations such as translation, scaling,
    and rotation.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 关于3D变换内部机制的更多信息，您可以参考[附录](apa.html "附录 A. OpenGL ES 3.0补充信息")中的*理解3D图形中的变换*，*OpenGL
    ES 3.0补充信息*。本主题涵盖了变换类型、变换矩阵约定、齐次坐标以及变换操作，如平移、缩放和旋转。
- en: There's more...
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Inside the `Renderer` class, the scene's projection can be adjusted using the
    `setUpProjection()` function. This function is responsible for setting the view
    clipping planes. The clipping plane can be defined in the form of frustum (perspective)
    or cuboid (orthographic) shape. We will discuss more about projections later in
    this chapter in the *Understanding the projection system in GLPI* recipe.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Renderer`类内部，可以使用`setUpProjection()`函数调整场景的投影。此函数负责设置视图剪切平面。剪切平面可以定义为截锥体（透视）或长方体（正交）形状。我们将在本章后面的*理解GLPI中的投影系统*配方中进一步讨论投影。
- en: See also
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: Refer to the *Developing an Android OpenGL ES 3.0 application* and *Developing
    an iOS OpenGL ES 3.0 application* recipes in [Chapter 1](ch01.html "Chapter 1. OpenGL
    ES 3.0 on Android/iOS"), *OpenGL ES 3.0 on Android/iOS*
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考第1章中的*开发Android OpenGL ES 3.0应用程序*和*开发iOS OpenGL ES 3.0应用程序*配方，[第1章](ch01.html
    "第1章. Android/iOS上的OpenGL ES 3.0")，*Android/iOS上的OpenGL ES 3.0*
- en: Implementing touch events
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现触摸事件
- en: Today's smartphones are capable of interacting with applications through gestures.
    These gestures are made on the surface of the touch-sensitive device screen. When
    the device senses these gesture inputs, it reports the touch events to the corresponding
    application handler. The application handler receives these events and filters
    them out, according to the application's requirement. In this recipe, we will
    implement the touch events using OpenGL ES 3.0 on iOS and Android platforms. You
    will learn to receive the events and handle them in a platform-independent way.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的智能手机能够通过手势与应用程序交互。这些手势是在触摸敏感设备屏幕表面进行的。当设备检测到这些手势输入时，它会将这些触摸事件报告给相应的事件处理器。应用程序处理器接收这些事件并根据应用程序的要求过滤它们。在本配方中，我们将使用iOS和Android平台上的OpenGL
    ES 3.0实现触摸事件。您将学习如何以平台无关的方式接收和处理事件。
- en: Getting ready
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `GLSurfaceView` class in Android and `GLKViewController` in iOS provide
    the necessary APIs to implement touch events. These APIs report the nature of
    detected touch events, such as if the user has tapped or moved their figure on
    the device screen. These APIs are exposed to the GLPI framework through common
    touch event interfaces. These interfaces are responsible for reporting and propagating
    the touch events to the registered members. The base class of the registered member
    (`Model`) contains all the touch event interfaces that can be handled by the derived
    versions. Since these are the only interfaces, the registered members need to
    override them in order to use them according to their custom needs.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Android中的`GLSurfaceView`类和iOS中的`GLKViewController`提供了实现触摸事件所需的API。这些API报告检测到的触摸事件性质，例如用户是否在设备屏幕上点击或移动了他们的手势。这些API通过常见的触摸事件接口暴露给GLPI框架。这些接口负责报告和传播触摸事件到已注册的成员。已注册成员的基础类（`Model`）包含所有可以由派生版本处理的触摸事件接口。由于这些是唯一的接口，因此已注册成员需要根据其自定义需求重写它们。
- en: How to do it...
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: This section will provide a detailed description of how to set up and implement
    touch events on the Android and iOS platforms.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将详细描述如何在Android和iOS平台上设置和实现触摸事件。
- en: First, implement the common interfaces in the `NativeTemple` and `Renderer`
    classes that can receive the touch events in a common fashion, irrespective of
    the platform implementation.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`NativeTemple`和`Renderer`类中实现通用的接口，这些接口可以以通用的方式接收触摸事件，无论平台实现如何。
- en: 'Declare and define the touch event interface in the `Renderer` class. For example,
    the following code shows the tap event implementation:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Renderer`类中声明和定义触摸事件接口。例如，以下代码展示了点击事件实现：
- en: '[PRE11]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In `NativeTemple.h`/`.cpp`, call the renderer''s touch events from the globally
    declared and defined wrapper functions:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`NativeTemple.h`/`.cpp`中，从全局声明和定义的包装函数中调用渲染器的触摸事件：
- en: '[PRE12]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'On the Android platform, we need to define new JNI native methods in `NativeTemplate.h`/`.cpp`
    that can communication with the Android framework in order to retrieve the touch
    events. For this, define the following interface for tap events in the `GLESNativeLib`
    Java class:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android平台上，我们需要在`NativeTemplate.h`/`.cpp`中定义新的JNI本地方法，以便与Android框架通信以检索触摸事件。为此，在`GLESNativeLib`
    Java类中为触摸事件定义以下接口：
- en: '[PRE13]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In `NativeTemplate`, declare and define the JNI interface for the tap event
    declared earlier:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`NativeTemplate`中声明并定义之前声明的触摸事件的JNI接口：
- en: '[PRE14]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Repeat steps 1 to 4 to implement the move and release touch events.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤1到4以实现移动和释放触摸事件。
- en: 'Override `onTouchEvent()` of the `GLSurfaceView` class. This function provides
    various types of touch events. For example, the tap, move, single/multi touch,
    and so on are some of the important events. These events needs to be filtered
    in order that they can be used:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖`GLSurfaceView`类的`onTouchEvent()`。此函数提供了各种类型的触摸事件。例如，点击、移动、单点/多点触摸等是一些重要的事件。这些事件需要过滤，以便它们可以使用：
- en: '[PRE15]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'On the iOS platform, the GLKit''s `GLKViewController` class provides touch
    functions that need to be overridden in order that they can be used in our application.
    For example, have a look at the following code. It implements the tap, move, and
    release events similar to the Android case. Each of the definitions calls the
    global wrapper functions of `NativeTemplate.h`/`.cpp`:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在iOS平台上，GLKit的`GLKViewController`类提供了需要覆盖的触摸函数，以便它们可以在我们的应用程序中使用。例如，看一下以下代码。它实现了类似于Android情况的点击、移动和释放事件。每个定义都调用了`NativeTemplate.h`/`.cpp`的全局包装函数：
- en: '[PRE16]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'When an Android or iOS application receives the touch event from the device,
    it is the responsibility of `GLSurfaceView` and `GLKViewController` to convey
    these touch events to the external world. These classes report the touch events
    to the global wrapper function that is defined in the `NativeTemple`. This file
    provides higher level cross-platform functions for touch events such as tap, move,
    and release. These functions are internally interfaced with the corresponding
    touch event interfaces of the `Renderer` class. The `Renderer` class provides
    the interface to handle touch events in an abstracted way in which it works seamlessly
    on either platform. These functions or interfaces are called from the Android
    or iOS platform through `NativeTemplates` global methods and propagated to all
    the registered models. For instance, the following example shows the handling
    of the move event:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当Android或iOS应用程序从设备接收到触摸事件时，将触摸事件传达给外部世界的责任在于`GLSurfaceView`和`GLKViewController`。这些类将触摸事件报告给定义在`NativeTemple`中的全局包装函数。此文件提供了触摸事件（如点击、移动和释放）的高级跨平台函数。这些函数在内部与`Renderer`类的相应触摸事件接口接口。`Renderer`类提供了一个接口，以抽象的方式处理触摸事件，使其在任一平台上都能无缝工作。这些函数或接口通过`NativeTemplates`全局方法从Android或iOS平台调用，并传播到所有已注册的模型。例如，以下示例显示了移动事件的处理：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: See also
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Depth testing in OpenGL ES 3.0*'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*OpenGL ES 3.0中的深度测试*'
- en: Rendering primitives with vertex arrays
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用顶点数组的渲染原语
- en: 'In OpenGL ES 3.0, the vertex array is a simplest mean to draw the objects in
    the 3D space. The objects are drawn with the help of vertices, which are arranged
    in a specific order guided by the rendering primitives. The rendering primitives
    represent how an individual or a set of vertices can assemble to draw a geometry.
    For example, four vertices can be represented by a point, line, or triangle, as
    shown here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenGL ES 3.0中，顶点数组是绘制3D空间中对象的简单方法。对象通过顶点绘制，顶点按照由渲染原语指定的特定顺序排列。渲染原语表示单个或一组顶点如何组合以绘制几何图形。例如，四个顶点可以表示为一个点、一条线或一个三角形，如下所示：
- en: '![Rendering primitives with vertex arrays](img/5527OT_02_06.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![使用顶点数组的渲染原语](img/5527OT_02_06.jpg)'
- en: The vertex array is the way in which the geometric data, such as vertex coordinates,
    normal coordinates, color information, and texture coordinates, are specified
    in the form of arrays. In this recipe, you will learn to program a vertex array
    in the GLPI framework. In addition to this, we will also demonstrate various available
    rendering primitives in OpenGL ES 3.0.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点数组是几何数据（如顶点坐标、法线坐标、颜色信息和纹理坐标）以数组形式指定的方式。在本教程中，你将学习如何在GLPI框架中编程顶点数组。此外，我们还将演示OpenGL
    ES 3.0中可用的各种渲染原语。
- en: How to do it...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a new class called `Primitive` derived from the `Model` class and follow
    this step-by-step procedure to implement the rendering primitive with the vertex
    array:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `Primitive` 的新类，它从 `Model` 类派生，并按照以下步骤逐步实现使用顶点数组的渲染原语：
- en: 'Create `PrimitiveVertex.glsl` and `PrimitiveFragment.glsl` and use the following
    code for the vertex and fragment shaders:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `PrimitiveVertex.glsl` 和 `PrimitiveFragment.glsl`，并使用以下代码作为顶点和片段着色器：
- en: '[PRE18]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Create a set of 10 vertices, as shown in the following figure. Then, store the
    information into the vertices array and assign colors to each vertex. The color
    information is stored in the form of RGB in the colors array.![How to do it...](img/5527OT_02_07.jpg)
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 10 个顶点，如图所示。然后，将信息存储到顶点数组中，并为每个顶点分配颜色。颜色信息以 RGB 的形式存储在颜色数组中。![如何做...](img/5527OT_02_07.jpg)
- en: 'In the `initModel` function, compile and link the vertex and fragment shaders.
    On successful creation of the shader program object, query the vertex attributes
    `VertexPosition` and `VertexColor` using a GLPI wrapper function called `ProgramGetVertexAttribLocation`.
    This function internally uses OpenGL ES 3.0 generic vertex attribute query APIs.
    Using the wrapper APIs decreases the chances of errors and increases the performance,
    as these queries are optimized:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `initModel` 函数中，编译和链接顶点和片段着色器。在成功创建着色器程序对象后，使用名为 `ProgramGetVertexAttribLocation`
    的 GLPI 包装函数查询顶点属性 `VertexPosition` 和 `VertexColor`。此函数内部使用 OpenGL ES 3.0 通用顶点属性查询
    API。使用包装 API 可以降低错误发生的概率并提高性能，因为这些查询已进行了优化：
- en: '[PRE19]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`ProgramGetVertexAttribLocation` returns the generic attribute location ID.
    A negative value of the location ID specifies that no attribute with that name
    exists in the shader.'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ProgramGetVertexAttribLocation` 返回通用属性位置 ID。位置 ID 的负值指定在着色器中不存在具有该名称的属性。'
- en: '**Syntax**:'
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语法**:'
- en: '[PRE20]'
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '| Variable | Description |'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `program` | This is the GLPI program object containing shader''s information
    |'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `program` | 这是包含着色器信息的 GLPI 程序对象 |'
- en: '| `name` | This is the name of the attribute in the shader source program |'
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `name` | 这是着色器源程序中属性的名称 |'
- en: 'Within the same `initModel` function, query the uniform using another wrapper
    API from the GLPI framework:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个 `initModel` 函数内，使用 GLPI 框架的另一个包装 API 查询统一变量：
- en: '[PRE21]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`ProgramManager` in the GLPI framework provides a high-level wrapper function
    `ProgramGetUniformLocation` to query any uniform type variable from the shader
    program.'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: GLPI 框架中的 `ProgramManager` 提供了一个高级包装函数 `ProgramGetUniformLocation`，用于从着色器程序中查询任何统一类型变量。
- en: '**Syntax**:'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语法**:'
- en: '[PRE22]'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '| Variable | Description |'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `program` | This is the GLPI program object containing shader''s information
    |'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `program` | 这是包含着色器信息的 GLPI 程序对象 |'
- en: '| `name` | This is the name of the uniform object in the shader source program
    |'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `name` | 这是着色器源程序中统一对象的名字 |'
- en: 'Create a `RenderPrimitive` function and call it inside `Render`. Inside this
    function, send the uniform and per-vertex attribute data to the shader:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `RenderPrimitive` 函数，并在 `Render` 函数内部调用它。在这个函数中，将统一变量和每个顶点的属性数据发送到着色器：
- en: '[PRE23]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Enable the vertex and color-generic attributes and draw various primitives
    using switch case statements:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用顶点和颜色通用属性，并使用 switch case 语句绘制各种原语：
- en: '[PRE24]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works...
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: This recipe has two arrays, vertices, and colors, which contains the vertex
    information and color information. There are 10 vertices, and each vertex stores
    an `X`, `Y` component. The color information also contains 10 different colors
    for each vertex. The color information is specified in the RGB color space in
    the range of 0.0 to 1.0.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方有两个数组，顶点和颜色，它们包含顶点信息和颜色信息。有 10 个顶点，每个顶点存储一个 `X`、`Y` 分量。颜色信息还包含每个顶点的 10 种不同的颜色。颜色信息以
    RGB 颜色空间指定，范围为 0.0 到 1.0。
- en: The vertex shader contains two per-vertex attributes, `VertexPosition` and `VertexColor`.
    These attributes are uniquely recognized in the program via the attribute location.
    This location is queried using the `ProgramGetVertexAttribLocation` function.
    The queried attribute serves the purpose of binding vertex array information to
    the per-vertex attributes. The vertex attribute data is sent using `glVertexAttribPointer`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器包含两个每个顶点的属性，`VertexPosition` 和 `VertexColor`。这些属性通过属性位置在程序中被唯一识别。此位置是通过
    `ProgramGetVertexAttribLocation` 函数查询的。查询到的属性用于将顶点数组信息绑定到每个顶点的属性。顶点属性数据是通过 `glVertexAttribPointer`
    发送的。
- en: Similarly, the uniform variable is also queried in the same fashion using a
    separate function called `ProgramGetUniformLocation`. The uniform variable is
    a 4 x 4 matrix of `ModelViewProjection`. Therefore, the data is sent to the shader
    using `glUniformMatrix4fv`. The `glLineWidth` function is meant for the `GL_LINE`
    variant primitives to define the width of the line as 10 pixels wide.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，使用名为`ProgramGetUniformLocation`的单独函数以相同的方式查询统一变量。统一变量是一个4 x 4的`ModelViewProjection`矩阵。因此，数据通过`glUniformMatrix4fv`发送到着色器。`glLineWidth`函数用于`GL_LINE`变体原语，以定义线的宽度为10像素。
- en: 'Finally, the OpenGL ES 3.0 primitives are rendered using `glDrawArrays`. Various
    primitive rendering can be seen in action by a simple tap on the screen. Upon
    tapping, the tap event will invoke the `TouchEventDown` function of the `Primitive`
    class, which is responsible for changing the current primitive type for rendering:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用`glDrawArrays`渲染OpenGL ES 3.0原语。通过简单的屏幕点击可以看到各种原语渲染的实际效果。点击时，点击事件将调用`Primitive`类的`TouchEventDown`函数，该函数负责更改当前渲染的原语类型：
- en: '![How it works...](img/5527OT_02_08.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/5527OT_02_08.jpg)'
- en: In computer 3D graphics, the polygon shapes are rendered using the triangle
    primitives. Using `GL_TRIANGLE_STRIP`, as compared to `GL_TRIANGLES`, is preferred
    because the number of vertices needed to specify the shape of the triangle is
    lesser when compared to `GL_TRIANGLES`. In the latter case, more data has to be
    sent from the CPU to the GPU, as adjacent edges share common vertices. In the
    former case, the vertices are arranged in a special order in which duplicate vertices
    from the shared edges are avoided. Hence, it requires less data. It is true that
    `GL_TRIANGLE_STRIP` may be better in certain cases due to lesser data needed to
    be defined. However, this needs to be considered on a case-by-case basis, depending
    on the 3D model format.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机3D图形中，多边形形状是通过三角形原语进行渲染的。与`GL_TRIANGLES`相比，`GL_TRIANGLE_STRIP`更受欢迎，因为指定三角形形状所需的顶点数更少。在后一种情况下，需要从CPU发送更多数据到GPU，因为相邻边共享公共顶点。在前一种情况下，顶点以特殊顺序排列，从而避免了共享边上的重复顶点。因此，它需要更少的数据。确实，在某些情况下，`GL_TRIANGLE_STRIP`可能更好，因为需要定义的数据更少。然而，这需要根据3D模型格式逐个案例考虑。
- en: There are plenty of tools available that can be used to convert the geometry
    information in the triangle-strip form. For example, nVIDIA's `NvTriStrip` library
    generates triangle strips from an arbitrary 3D geometry. For more information,
    visit [http://www.nvidia.com/object/nvtristrip_library.html](http://www.nvidia.com/object/nvtristrip_library.html).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多工具可用于将三角形带形式的几何信息进行转换。例如，nVIDIA的`NvTriStrip`库可以从任意3D几何中生成三角形带。更多信息，请访问[http://www.nvidia.com/object/nvtristrip_library.html](http://www.nvidia.com/object/nvtristrip_library.html)。
- en: Note
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on the drawing APIs, refer to the *Drawing APIs in OpenGL
    ES 3.0* recipe. It demonstrates `glDrawArrays` and `glDrawElements`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 关于绘图API的更多信息，请参考*OpenGL ES 3.0中的绘图API*配方。它演示了`glDrawArrays`和`glDrawElements`。
- en: There's more…
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有更多内容...
- en: 'This section will focus on the basic rendering primitives available in OpenGL
    ES 3.0\. Primitives are the simplest shapes that can be used to generate any complex
    shape in 3D graphics. The OpenGL ES 3.0 primitives can be categorized into three
    basic types: point, line and triangle. The rest are variations of these.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将重点介绍OpenGL ES 3.0中可用的基本渲染原语。原语是用于生成3D图形中任何复杂形状的最简单形状。OpenGL ES 3.0的原语可以分为三种基本类型：点、线和三角形。其余的都是这些类型的变体。
- en: 'The following table describes all the variant primitives of point, line, and
    triangle available in OpenGL ES 3.0:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 下表描述了OpenGL ES 3.0中所有可用的点、线和三角形变体原语：
- en: '| Primitive types | Input vertex | Output shape | Description |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 原语类型 | 输入顶点 | 输出形状 | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `GL_POINTS` | ![There''s more…](img/5527OT_02_09.jpg) | ![There''s more…](img/5527OT_02_10.jpg)
    | A point on the screen that represents each vertex. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `GL_POINTS` | ![有更多内容...](img/5527OT_02_09.jpg) | ![有更多内容...](img/5527OT_02_10.jpg)
    | 屏幕上的点代表每个顶点。 |'
- en: '| `GL_LINES` | ![There''s more…](img/5527OT_02_11.jpg) | ![There''s more…](img/5527OT_02_12.jpg)
    | Each pair of vertices is used to render a line between them. We can use the
    `glLineWidth()` API to control the width of the line rendering. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `GL_LINES` | ![有更多内容...](img/5527OT_02_11.jpg) | ![有更多内容...](img/5527OT_02_12.jpg)
    | 每对顶点用于渲染它们之间的一条线。我们可以使用`glLineWidth()` API来控制线渲染的宽度。 |'
- en: '| `GL_LINE_LOOP` | ![There''s more…](img/5527OT_02_13.jpg) | ![There''s more…](img/5527OT_02_14.jpg)
    | Each vertex makes a line between itself and the vertex preceding it. The last
    vertex always joins the first vertex to form a closed loop. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `GL_LINE_LOOP` | ![还有更多…](img/5527OT_02_13.jpg) | ![还有更多…](img/5527OT_02_14.jpg)
    | 每个顶点与其前一个顶点之间画一条线。最后一个顶点始终与第一个顶点相连，形成一个闭合环。 |'
- en: '| `GL_LINE_STRIP` | ![There''s more…](img/5527OT_02_15.jpg) | ![There''s more…](img/5527OT_02_16.jpg)
    | Each vertex makes a line between itself and the vertex preceding it. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `GL_LINE_STRIP` | ![还有更多…](img/5527OT_02_15.jpg) | ![还有更多…](img/5527OT_02_16.jpg)
    | 每个顶点与其前一个顶点之间画一条线。 |'
- en: '| `GL_TRIANGLES` | ![There''s more…](img/5527OT_02_17.jpg) | ![There''s more…](img/5527OT_02_18.jpg)
    | A set of three vertices is used to form a filled triangle. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `GL_TRIANGLES` | ![还有更多…](img/5527OT_02_17.jpg) | ![还有更多…](img/5527OT_02_18.jpg)
    | 使用三个顶点形成一个填充三角形。 |'
- en: '| `GL_TRIANGLE_STRIP` | ![There''s more…](img/5527OT_02_19.jpg) | ![There''s
    more…](img/5527OT_02_20.jpg) | Every vertex makes a triangle with the preceding
    two vertices. |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `GL_TRIANGLE_STRIP` | ![还有更多…](img/5527OT_02_19.jpg) | ![还有更多…](img/5527OT_02_20.jpg)
    | 每个顶点都与前两个顶点形成一个三角形。 |'
- en: '| `GL_TRIANGLE_FAN` | ![There''s more…](img/5527OT_02_21.jpg) | ![There''s
    more…](img/5527OT_02_22.jpg) | Every vertex makes a triangle with the first vertex
    and the vertex preceding it. This generates a fan-like pattern. |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `GL_TRIANGLE_FAN` | ![还有更多…](img/5527OT_02_21.jpg) | ![还有更多…](img/5527OT_02_22.jpg)
    | 每个顶点都与第一个顶点和前一个顶点形成一个三角形。这生成一个类似扇形的图案。 |'
- en: See also
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the *Using uniform* *variables to send data to a* *shader* and *Using
    per-vertex attribute to send data to a shader* recipes in [Chapter 1](ch01.html
    "Chapter 1. OpenGL ES 3.0 on Android/iOS"), *OpenGL ES 3.0 on Android/iOS*
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考第1章中的*使用统一变量将数据发送到着色器*和*使用顶点属性将数据发送到着色器*食谱，*OpenGL ES 3.0 on Android/iOS*，[第1章](ch01.html
    "第1章。Android/iOS上的OpenGL ES 3.0")
- en: Drawing APIs in OpenGL ES 3.0
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenGL ES 3.0中的绘图API
- en: 'OpenGL ES 3.0 provides two types of rendering APIs: `glDrawArrays` and `glDrawElements`.
    These APIs allows us to render the geometric data on the screen in the form of
    primitives. In this recipe, you will learn how these APIs are used in programming
    and understand the difference between them.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL ES 3.0提供了两种渲染API：`glDrawArrays`和`glDrawElements`。这些API允许我们将几何数据以原语的形式渲染到屏幕上。在本食谱中，你将学习这些API在编程中的应用，并了解它们之间的区别。
- en: This recipe will render a cube by using the two different rendering APIs mentioned
    earlier. The datasets used by these APIs are entirely different. Tap on the screen
    to see the difference between the two APIs.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将通过使用前面提到的两种不同的渲染API来渲染一个立方体。这些API使用的数据集完全不同。点击屏幕以查看两个API之间的区别。
- en: Getting ready
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `glDrawArray` API reads the vertex information in the form of an array in
    sequential order, starting from the first index to total number of indexes specified
    by the count. The `glDrawArray` API renders primitives specified by the mode argument
    using vertex array data information.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`glDrawArray` API按顺序读取数组形式的顶点信息，从第一个索引开始，到由count指定的总数。`glDrawArray` API使用顶点数组数据信息渲染由mode参数指定的原语。'
- en: '**Syntax**:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**:'
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '| Variable | Description |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `mode` | This specifies the type of OpenGL ES primitive that needs to be
    rendered |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `mode` | 这指定了需要渲染的OpenGL ES原语类型 |'
- en: '| `first` | This is the start index of the data array |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `first` | 这是数据数组的起始索引 |'
- en: '| `count` | This denotes the total number of indices to be rendered |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `count` | 这表示要渲染的总索引数 |'
- en: 'For example, a square can be rendered as a set of two triangles:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个正方形可以渲染为两个三角形的集合：
- en: '[PRE26]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In contrast, the `glDrawElement` API maps each vertex using an index similar
    to the one that accesses elements in an array using C++/Java. This method of rendering
    consumes less memory compared to `glDrawArray`, where each redundant vertex needs
    to be mentioned with its `X`, `Y`, and `Z` components. For example, take a case
    of regular cube geometry and calculate the memory saving offered by `glDrawElement`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`glDrawElement` API使用一个类似于使用C++/Java访问数组元素的索引来映射每个顶点。与`glDrawArray`相比，这种方法在渲染时消耗的内存更少，因为在`glDrawArray`中，每个多余的顶点都需要用其`X`、`Y`和`Z`分量来提及。例如，考虑一个规则立方体几何形状的案例，并计算`glDrawElement`提供的内存节省量。
- en: '**Syntax**:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**:'
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '| Variable | Description |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `mode` | This specifies the primitive type as described in the preceding
    table |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `mode` | 这指定了前面表格中描述的原生类型 |'
- en: '| `count` | This specifies the number of elements to be rendered |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `count` | 这指定了要渲染的元素数量 |'
- en: '| `type` | This specifies the data type of indices |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `type` | 这指定了索引的数据类型 |'
- en: '| `indices` | This specifies the order of indices for vertex arrangement in
    an array form |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `indices` | 这指定了顶点在数组形式中排列的索引顺序 |'
- en: 'For example, the same square can be represented as follows using this API:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用此 API 可以如下表示相同的正方形：
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How to do it...
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following instructions will provide a step-by-step procedure to demonstrate
    the use of the `glDrawArrays` and `glDrawElements` APIs:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下指令将提供逐步过程，以演示 `glDrawArrays` 和 `glDrawElements` API 的使用：
- en: Create a `Cube` class derived from `Model`. There is no change required in the
    vertex and fragment shaders. `Shaders` from the previous recipe can be reused.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个从 `Model` 派生的 `Cube` 类。不需要在顶点和片段着色器中进行任何更改。可以重用之前菜谱中的 `Shaders`。
- en: Define the vertex and color dataset for the `glDrawArray` API:![How to do it...](img/5527OT_02_23.jpg)
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `glDrawArray` API 的顶点和颜色数据集：![如何做...](img/5527OT_02_23.jpg)
- en: Similarly, define the dataset for the `glDrawElement` API:![How to do it...](img/5527OT_02_24.jpg)
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，定义 `glDrawElement` API 的数据集：![如何做...](img/5527OT_02_24.jpg)
- en: 'In `InitModel`, compile and link the shaders. On successful compilation, query
    `ModelViewProjectionMatrix`, `VertexPosition`, `VertexColor` and store them into
    `MVP`, `attribVertex`, `attribColor`, respectively. Enable vertex and color-generic
    attributes:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `InitModel` 中，编译并链接着色器。在成功编译后，查询 `ModelViewProjectionMatrix`、`VertexPosition`、`VertexColor`
    并分别将它们存储到 `MVP`、`attribVertex`、`attribColor` 中。启用顶点和颜色通用属性：
- en: '[PRE29]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Inside the render function, implement the following code to demonstrate both
    APIs in action:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在渲染函数内部，实现以下代码以演示这两个 API 的实际操作：
- en: '[PRE30]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works...
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `glDrawArray` rendering API uses vertex attributes, such as vertex coordinates,
    color information, and texture coordinate, in the form of a continuous data array
    in which the data reading cannot be skipped or hopped. The information is highly
    redundant, as the same vertices share among the different face are repeatedly
    written. In this recipe, `vertexBuffer` and `colorBufferData` store vertex coordinates
    and color information. This information is sent to the vertex shader using `attribVertex`
    and `attribColor`. Finally, the `glDrawArray` call is made with parameters specifying
    the type of primitive and index of the vertices that need to go for rendering
    (the start and end index).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`glDrawArray` 渲染 API 使用顶点属性，如顶点坐标、颜色信息和纹理坐标，以连续数据数组的形式发送到顶点着色器，其中数据读取不能跳过或跳跃。信息高度冗余，因为相同的顶点在不同的面之间重复写入。在这个菜谱中，`vertexBuffer`
    和 `colorBufferData` 存储顶点坐标和颜色信息。这些信息通过 `attribVertex` 和 `attribColor` 发送到顶点着色器。最后，使用指定原始类型和需要渲染的顶点索引（起始和结束索引）的参数调用
    `glDrawArray`。'
- en: In contrast, `glDrawElement` uses `cubeVert` and `cubeColors`, which contain
    the nonredundant vertex and color information. It uses an additional array that
    contains the indices of the vertex information. Using this array, the primitives
    are rendered by hopping around the vertex arrays. Unlike `glDrawArray`, which
    works on the continuous set of vertex data, `glDrawElement` can jump from one
    vertex to another using the index information provided to it in the last parameter.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`glDrawElement` 使用 `cubeVert` 和 `cubeColors`，它们包含非冗余的顶点和颜色信息。它使用一个包含顶点信息索引的额外数组。使用这个数组，通过在顶点数组中跳跃来渲染原始数据。与
    `glDrawArray` 不同，后者在连续的顶点数据集上工作，`glDrawElement` 可以使用最后提供的索引信息从一个顶点跳到另一个顶点。
- en: There's more...
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: 'In OpenGL ES 3.0, the polygons are drawn as a set of triangles. Each of these
    triangles has two faces: a front face and back face. For example, the following
    image represents a square geometry with vertices v0, v1, v2, and v3\. It is made
    up of two triangles. The order of vertex winding (clockwise or anticlockwise)
    is used by OpenGL ES 3.0 to determine whether the triangle is front facing or
    back facing. In this case, the vertices are winded in an anticlockwise direction.
    By default, OpenGL ES 3.0 considers the anticlockwise windings as front facing.
    This convention can be changed by setting `glFrontFace` (counter clockwise) as
    `GL_CW` or `GL_CCW` (counter clockwise).'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OpenGL ES 3.0 中，多边形作为一组三角形绘制。每个三角形都有两个面：一个前表面和一个后表面。例如，以下图像表示由顶点 v0、v1、v2
    和 v3 组成的正方形几何形状。它由两个三角形组成。顶点绕序（顺时针或逆时针）由 OpenGL ES 3.0 用于确定三角形是前向还是后向。在这种情况下，顶点是逆时针绕序的。默认情况下，OpenGL
    ES 3.0 将逆时针绕序视为前向。可以通过将 `glFrontFace`（顺时针）设置为 `GL_CW` 或 `GL_CCW`（顺时针）来更改此约定。
- en: The winding order is always specified from the user's visualization point of
    view. The OpenGL ES pipeline takes care of this winding and displays them correctly
    from the camera's point of view. For example, when we specify the vertices of
    a cube geometry, it should be in the counter-clockwise order as per the default
    convention. However, we know very well that the faces that are parallel to each
    other have opposite winding orders when viewed from the camera's point of view,
    as shown in the following figure. OpenGL ES automatically generates the correct
    winding order from the camera's point of view.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 顺时针方向始终从用户的可视化点视图指定。OpenGL ES 管道负责此顺时针方向，并从摄像机的视角正确显示它们。例如，当我们指定一个立方体几何体的顶点时，它应该按照默认约定逆时针顺序排列。然而，我们知道，从摄像机的视角看，平行于彼此的面在摄像机视角下具有相反的顺时针方向，如下面的图所示。OpenGL
    ES 会自动从摄像机的视角生成正确的顺时针方向。
- en: The front and back faces are used in geometry culling. For more information
    on geometry culling and front/back face definitions, refer to the *Culling in
    OpenGL ES 3.0* recipe later in this chapter.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 前面和后面面用于几何剔除。有关几何剔除和前后面定义的更多信息，请参阅本章后面的 *OpenGL ES 3.0 中的剔除* 菜谱。
- en: '![There''s more...](img/5527OT_02_25.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/5527OT_02_25.jpg)'
- en: See also
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Drawing* *APIs in OpenGL ES 3.0*'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*OpenGL ES 3.0 中的绘图 API*'
- en: '*Culling in OpenGL ES 3.0*'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*OpenGL ES 3.0 中的剔除*'
- en: Efficient rendering with Vertex Buffer Object
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用顶点缓冲对象进行高效渲染
- en: The vertex information comprises of geometric coordinates, color information,
    texture coordinates, and normal vectors. This information is stored in the form
    of an array and always resides in the local memory (RAM, which is accessible by
    the CPU) of the device. Each frame when rendering command is executed. This information
    is copied from the local memory and sent to the GPU. This vertex information is
    sent over the data bus, which has a slower speed compared to the GPU's processing
    speed. Additionally, the latency time on the local memory also adds a slight delay.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点信息包括几何坐标、颜色信息、纹理坐标和法向量。这些信息以数组的形式存储，并且始终位于设备的本地内存（RAM，CPU可访问）中。每当执行渲染命令时，这些信息就会从本地内存复制到
    GPU。这些顶点信息通过数据总线发送，其速度比 GPU 的处理速度慢。此外，本地内存上的延迟时间也会增加一点延迟。
- en: VBO is a faster way to render 3D objects. The VBO uses the full advantage of
    **Graphics Processor Unit** (**GPU**) and store the geometric data on GPU's memory
    instead of storing it on the local RAM memory. This helps OpenGL ES to avoid continuous
    sending of data from local memory to the GPU each time a draw call is made.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: VBO 是渲染 3D 对象的一种更快的方式。VBO 充分利用 **图形处理器单元** (**GPU**)，并将几何数据存储在 GPU 的内存中，而不是存储在本地
    RAM 内存中。这有助于 OpenGL ES 避免每次绘制调用时从本地内存向 GPU 不断发送数据。
- en: 'The implementation of the VBO can be divided into four steps:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: VBO 的实现可以分为四个步骤：
- en: Create a new buffer object using `glGenBuffers()`.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `glGenBuffers()` 创建一个新的缓冲对象。
- en: Bind this buffer object to pipeline with `glBindBuffer()`.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `glBindBuffer()` 将此缓冲对象绑定到管道。
- en: Allocate memory to store data using `glBufferData()`.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `glBufferData()` 分配内存以存储数据。
- en: Store/modify the data into portions of the allocated buffer object with `glBufferSubData()`.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `glBufferSubData()` 将数据存储/修改到分配的缓冲对象的部分。
- en: How to do it...
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow this step-by-step procedure to implement the VBO recipe:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下分步流程来实施 VBO 菜谱：
- en: First, create a vertex buffer object using the `glGenBuffers` API. This API
    generates n number of vertex buffer objects, where each vertex buffer object is
    recognized by a unique name or handle returned by this API. This handle is an
    unsigned `int` ID that is used to perform various operations on the VBO.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用 `glGenBuffers` API 创建一个顶点缓冲对象。此 API 生成 n 个顶点缓冲对象，其中每个顶点缓冲对象都由此 API 返回的唯一名称或句柄识别。此句柄是一个无符号
    `int` ID，用于对 VBO 执行各种操作。
- en: '**Syntax**:'
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语法**:'
- en: '[PRE31]'
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '| Variable | Description |'
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `N` | This is a number of buffer object names that need to be generated |'
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `N` | 这是指需要生成的缓冲对象名称的数量 |'
- en: '| `buffers` | This specifies an array that contains buffer objects on successful
    creation |'
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `buffers` | 这指定了一个包含缓冲对象的数组，在成功创建后 |'
- en: Bind the created vertex buffer object IDs to the underlying pipeline with the
    `glBindBuffer` API.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `glBindBuffer` API 将创建的顶点缓冲对象 ID 绑定到底层管道。
- en: '**Syntax**:'
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语法**:'
- en: '[PRE32]'
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '| Variable | Description |'
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `target` | This specifies the symbolic constant target to which the buffer
    object name needs to be bound. It could accept `GL_ARRAY_BUFFER`, `GL_ELEMENT_ARRAY_BUFFER`,
    `GL_UNIFORM_BUFFER`, `GL_TRANSFORM_FEEDBACK_BUFFER`, and so on. |'
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `target` | 这指定了需要绑定缓冲区对象名称的符号常量目标。它可以接受`GL_ARRAY_BUFFER`、`GL_ELEMENT_ARRAY_BUFFER`、`GL_UNIFORM_BUFFER`、`GL_TRANSFORM_FEEDBACK_BUFFER`等。
    |'
- en: '| `buffers` | This is the name of the buffer object that we created using `glGenBuffer`.
    |'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `buffers` | 这是使用`glGenBuffer`创建的缓冲区对象的名称。 |'
- en: Allocate and initialize the memory by specifying the size of the geometric arrays,
    such as vertex, color, normal, and so on, with `glBufferData`.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '通过指定几何数组（如顶点、颜色、法线等）的大小，使用`glBufferData`分配和初始化内存。 '
- en: '**Syntax**:'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语法**:'
- en: '[PRE33]'
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '| Variable | Description |'
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `target` | This parameter is similar to what is defined in `glBindBuffer`,
    as described earlier. |'
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `target` | 此参数类似于前面描述的`glBindBuffer`中定义的内容。 |'
- en: '| `size` | The size of the buffer needs to be allocated in bytes. |'
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `size` | 需要分配的缓冲区大小（以字节为单位）。 |'
- en: '| `data` | This is a pointer to the data array that contains geometry information.
    If this is `NULL`, then no data would be copied. The data can be copied later
    using the `glBufferSubData` API. |'
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `data` | 这是一个指向包含几何信息的数组数据的指针。如果这是`NULL`，则不会复制任何数据。可以使用`glBufferSubData`
    API稍后复制数据。 |'
- en: '| `usage` | This is the expected type of pattern used for data store. |'
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `usage` | 这是预期用于数据存储的模式类型。 |'
- en: 'The `usage` parameter provides hints to the OpenGL ES system about how the
    data is patterned, so that it can be handled intelligently and efficiently when
    it comes to storing or accessing the data. This parameter can accept one of the
    following types:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`usage`参数为OpenGL ES系统提供有关数据模式的提示，以便在存储或访问数据时能够智能且高效地处理。此参数可以接受以下类型之一：'
- en: '| Types | Meaning |'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 类型 | 含义 |'
- en: '| --- | --- |'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `GL_STREAM_DRAW` | This type of vertex buffer data is rendered for a small
    number of times and then discarded |'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `GL_STREAM_DRAW` | 此类型的顶点缓冲区数据仅渲染少量次数，然后被丢弃 |'
- en: '| `GL_STATIC_DRAW` | This is a type of buffer data that is rendered many times,
    and its contents never changes |'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `GL_STATIC_DRAW` | 这是一种缓冲区数据类型，它被渲染多次，其内容永远不会改变 |'
- en: '| `GL_DYNAMIC_DRAW` | This type of buffer data is rendered many times, and
    its content changes during rendering |'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `GL_DYNAMIC_DRAW` | 此类型的缓冲区数据被渲染多次，其内容在渲染过程中会发生变化 |'
- en: The `glBufferData` creates the buffer data store for the current bound target
    with the required size. If the data parameter is initialized with `NULL`, then
    the buffer remains uninitialized. This VBO can be initialized later using the
    `glBufferSubData` API.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`glBufferData`为当前绑定的目标创建具有所需大小的缓冲区数据存储。如果数据参数使用`NULL`初始化，则缓冲区保持未初始化状态。此VBO可以使用`glBufferSubData`
    API稍后初始化。'
- en: '**Syntax**:'
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语法**:'
- en: '[PRE34]'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '| Variable | Description |'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `target` | This parameter is similar to what is defined in the `glBindBuffer`
    as described earlier |'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `target` | 此参数类似于前面描述的`glBindBuffer`中定义的内容 |'
- en: '| `offset` | This is the index on the buffer store, specifying the start location
    from where the data will be written |'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `offset` | 这是缓冲区存储上的索引，指定从哪里开始写入数据 |'
- en: '| `size` | This is the data size in bytes that needs to be filled in the buffer
    store, starting from the offset position |'
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `size` | 这是需要填充到缓冲区存储中的数据大小（以字节为单位），从偏移位置开始 |'
- en: '| `data` | This is a pointer to the new data that will be copied into the data
    store |'
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `data` | 这是一个指向将被复制到数据存储中的新数据的指针 |'
- en: 'The following program implements the VBO with all the APIs discussed earlier:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下程序实现了前面讨论的所有API的VBO：
- en: '[PRE35]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, the rendering will be performed by binding the VBO and specifying
    the generic attribute data in terms of offset in the buffer object, as shown here:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过绑定VBO并指定缓冲对象中的偏移量来表示通用属性数据，渲染将按如下方式执行：
- en: '[PRE36]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How it works...
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `glGenBuffers` API creates a number of vertex buffer objects specified by
    the first parameter `n`. It returns the VBO ID (handle) array if the vertex buffer
    objects are successfully created.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`glGenBuffers` API创建由第一个参数`n`指定的多个顶点缓冲对象。如果顶点缓冲对象成功创建，则返回VBO ID（句柄）数组。'
- en: Once the VBO are created, they need to bind to the target with the `glBindBuffer`
    API. Basically, the target tells the VBO what type of vertex data it can store.
    This data can be either a vertex array or an index array data. The vertex array
    data contains vertex information, such as position, color, texture coordinate,
    and so on. However, the index array contains the order vertex index information.
    Therefore, the target could be specified as `GL_ARRAY_BUFFER` or `GL_ELEMENT_ARRAY_BUFFER`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了VBO（顶点缓冲对象），它们需要通过`glBindBuffer` API绑定到目标。基本上，目标告诉VBO它可以存储哪种类型的顶点数据。这些数据可以是顶点数组或索引数组数据。顶点数组数据包含顶点信息，如位置、颜色、纹理坐标等。然而，索引数组包含顶点索引的顺序信息。因此，目标可以指定为`GL_ARRAY_BUFFER`或`GL_ELEMENT_ARRAY_BUFFER`。
- en: The data size required to fill into the bound vertex buffer object is specified
    using `glBufferData`. We also need to specify the nature of data the VBO is going
    to store. The final `step` is to fill in the buffer object with data. We can use
    `glBufferSubData` to fill the vertex data. The VBO allows us to specify multiple
    arrays in the same buffer object. We can use offset and size one after the other.
    Make sure that you bind the buffer object to the current rendering state before
    rendering with the `glBindBuffer` API. The VBO can be deleted using `glDeleteBuffers`
    as per the program requirement.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`glBufferData`指定填充到已绑定顶点缓冲对象中的数据大小。我们还需要指定VBO将要存储的数据的性质。最后的`步骤`是将数据填充到缓冲对象中。我们可以使用`glBufferSubData`来填充顶点数据。VBO允许我们在同一个缓冲对象中指定多个数组。我们可以依次使用偏移量和大小。确保在用`glBindBuffer`
    API渲染之前，将缓冲对象绑定到当前渲染状态。根据程序要求，可以使用`glDeleteBuffers`删除VBO。
- en: Note
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If an application uses multiple VBO, then it is advisable to bind the VBO to
    `0` after rendering of the model. This way, the original states remain preserved.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序使用多个VBO，那么在模型渲染后将其绑定到`0`是明智的。这样，原始状态得以保留。
- en: Transformations with the model, view, and projection analogies
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模型、视图和投影类比进行变换
- en: To define a rendering scene in computer 3D graphics, model, view, and projection
    is the cleanest approach. It dissects a scene into these three logical concepts
    that helps us visualize the scene clearly before it appears on paper or in the
    form of a program. It will not be wrong to say that it is a modular approach to
    scene visualization.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机3D图形中定义渲染场景，模型、视图和投影是最干净利落的方法。它将场景分解为这三个逻辑概念，帮助我们清晰地可视化场景，在它以纸张或程序形式出现之前。可以说，这是一种模块化的场景可视化方法。
- en: '**Object**: An object is a defined by a set of vertices in the 3D space. Each
    object has its own origin. For example, a cube contains eight vertices with respect
    to the origin at the center. The vertices used to define the object are called
    object coordinates:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象**：一个对象是由3D空间中的一组顶点定义的。每个对象都有自己的原点。例如，一个立方体相对于中心原点包含八个顶点。用于定义对象的顶点称为对象坐标：'
- en: '![Transformations with the model, view, and projection analogies](img/5527OT_02_26.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![使用模型、视图和投影类比进行变换](img/5527OT_02_26.jpg)'
- en: '**Model**: Modeling in 3D graphics is a transformation process where an object
    is displaced to an arbitrary position in the 3D space. This 3D space is called
    world space (also known as model space). For example, we can use several instances
    of our cube object and place them in the 3D space so that they form the English
    alphabet **T**.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型**：在3D图形中建模是一个变换过程，其中对象被移动到3D空间中的任意位置。这个3D空间被称为世界空间（也称为模型空间）。例如，我们可以使用我们立方体对象的几个实例，并将它们放置在3D空间中，以便它们形成英文字母**T**。'
- en: Note
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Modeling is achievable by a 4 x 4 matrix called the Model Matrix. Programmatically,
    an identity matrix, which is multiplied by transformation matrices, contains scale,
    translation, and rotation information. The resultant is the Model Matrix.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 建模可以通过一个4x4的矩阵实现，称为模型矩阵。从程序的角度来看，一个单位矩阵，它与变换矩阵相乘，包含缩放、平移和旋转信息。结果是模型矩阵。
- en: '**Viewing**: In simpler terms, we can say that the view is a position in the
    3D space from which the model needs to be viewed. For example, in engineering
    drawing, there are three types of views: the top, front, and side views. These
    are produced by moving the camera in the *x*, *y*, and *z* axes and looking towards
    the origin of the viewing object. The viewing is a transformation that applies
    on the world coordinates to produce eye coordinates.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**观察**：用更简单的话来说，我们可以这样说，视图是在三维空间中的一个位置，从该位置需要观察模型。例如，在工程制图中，有三种类型的视图：俯视图、正视图和侧视图。这些是通过在*x*、*y*和*z*轴上移动相机并朝向观察对象的起点来产生的。观察是一个变换，它应用于世界坐标以产生眼睛坐标。'
- en: '![Transformations with the model, view, and projection analogies](img/5527OT_02_27.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![使用模型、视图和投影类比进行变换](img/5527OT_02_27.jpg)'
- en: Note
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Model-view analogy: The model and view concepts we discussed earlier are completely
    interchangeable. This means that we can do all the view transformations with model
    transformation and vice versa. For example, we can make the object scale by viewing
    it closer or placing it near the viewing location. Similarly, translation and
    rotation operations can also be performed on this object. Therefore, many books
    represent it as a model-view approach, so don''t get confused with this term.
    Mathematically, model view is just another 4 x 4 matrix that is achieved by multiplying
    view matrix and the model matrix.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 模型-视图类比：我们之前讨论的模型和视图概念是完全可互换的。这意味着我们可以使用模型变换来完成所有视图变换，反之亦然。例如，我们可以通过靠近观察对象或将其放置在观察位置附近来调整对象的缩放。同样，也可以对这个对象执行平移和旋转操作。因此，许多书籍将其表示为模型-视图方法，所以不要对这个术语感到困惑。从数学上讲，模型视图只是通过乘以视图矩阵和模型矩阵而得到的另一个4x4矩阵。
- en: '**Projection**: Projection transformation is the process where a scene is restricted
    by a clipping region in the form of a frustum or cuboidal. Both forms have six
    clipping planes that are helpful in restricting the objects, by clipping the objects
    present outside these clipping planes. This stage helps the graphics system increase
    the performance by considering only a finite set of objects within the frustum
    box. The following figure shows the role of frustum clipping planes. The result
    of the eye coordinates on projection system is clip coordinates:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '**投影**：投影变换是将场景限制在以截锥体或立方体形式存在的裁剪区域内的过程。这两种形式都有六个裁剪平面，有助于通过裁剪位于这些裁剪平面之外的对象来限制对象。这一阶段通过只考虑截锥体框内的有限对象集来帮助图形系统提高性能。以下图显示了截锥裁剪平面的作用。投影系统上眼睛坐标的结果是裁剪坐标：'
- en: '![Transformations with the model, view, and projection analogies](img/5527OT_02_28.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![使用模型、视图和投影类比进行变换](img/5527OT_02_28.jpg)'
- en: '**Normalize view**: The clip coordinates are used to create normalize device
    coordinates that shrink the clipped view to a unity range by dividing it by **W**,
    where W is the constant used to create homogenous coordinates.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '**归一化视图**：裁剪坐标用于创建归一化设备坐标，通过除以**W**来缩小裁剪视图到单位范围，其中W是用于创建齐次坐标的常数。'
- en: '**Viewport transformation**: This is the final transformation in which the
    normalize device coordinates are converted into screen coordinates system (that
    is, window coordinates):'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**视口变换**：这是最终的变换，其中归一化设备坐标被转换为屏幕坐标系（即窗口坐标）：'
- en: '![Transformations with the model, view, and projection analogies](img/5527OT_02_29.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![使用模型、视图和投影类比进行变换](img/5527OT_02_29.jpg)'
- en: The preceding figure shows how the vertex processing takes place in 3D graphics
    that is transformed from object-coordinate system to appear onto the physical
    screen in the window-coordinate system.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图显示了3D图形中的顶点处理过程，它从对象坐标系变换到窗口坐标系中物理屏幕上的显示。
- en: Getting ready
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The model-view-projection is purely a mathematical transformation concept. This
    is not a part of OpenGL ES 3.0; it's entirely up to an end user to implement these
    transformations in its own way. This book uses transformations through an open
    source `maths` library called `glm` and uses the 0.9.4 version of this library.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 模型-视图-投影纯粹是一个数学变换概念。这不是OpenGL ES 3.0的一部分；完全由最终用户根据自己的方式实现这些变换。本书通过一个名为`glm`的开源`maths`库来实现变换，并使用该库的0.9.4版本。
- en: Note
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**OpenGL Mathematics** (**GLM**) is a header only C++ mathematics library for
    graphics software based on the **OpenGL Shading Language** (**GLSL**) specification.
    You can download this library at [http://glm.g-truc.net](http://glm.g-truc.net).'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '**OpenGL数学**（**GLM**）是一个基于**OpenGL着色语言**（**GLSL**）规范的仅头文件C++数学库，用于图形软件。您可以从[http://glm.g-truc.net](http://glm.g-truc.net)下载此库。'
- en: The transformation-based function of the GLM library is wrapped under a higher-level
    class called `Transform` in the GLPI framework.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: GLM库的基于变换的功能在GLPI框架中封装在一个称为`Transform`的高级类中。
- en: '**Overview of transformation**:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '**变换概述**：'
- en: 'Transformation is a process by which one coordinate space is converted to another
    coordinate space, for example, translation, rotation, and scaling. There are two
    types of transformations:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 变换是将一个坐标空间转换为另一个坐标空间的过程，例如平移、旋转和缩放。有两种类型的变换：
- en: '**Geometric transformation**: This specifies when an object undergoes the transformation
    relative to the coordinate system.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**几何变换**：这指定了对象相对于坐标系进行变换的时间。'
- en: '**Coordinate transformation**: This specifies when the coordinate system undergoes
    the transformation and the object remains still.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**坐标变换**：这指定了坐标系进行变换的时间，而对象保持静止。'
- en: On the computer, these transformations are stored in the form of 4 x 4 transformation
    matrices. The transformation matrix used for 3D systems contain 16 elements in
    a continuous memory location. There are two ways in which multidimensional arrays
    can be represented in the memory.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机中，这些变换以4x4变换矩阵的形式存储。用于3D系统的变换矩阵在连续的内存位置中包含16个元素。在内存中，多维数组可以有两种表示方式。
- en: '**Row Major**: The element in the memory location is stored row-wise'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行主序**：内存位置中的元素按行存储'
- en: '**Column Major**: The element in the memory location is stored column-wise![Getting
    ready](img/5527OT_02_37.jpg)'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列主序**：内存位置中的元素按列存储![准备中](img/5527OT_02_37.jpg)'
- en: 'Logical representation of matrix in **Row Major** (**RM**) and **Column Major**
    (**CM**):'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**行主序**（**RM**）和**列主序**（**CM**）的矩阵逻辑表示：'
- en: '| Offset | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 |
    15 |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| Offset | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 |
    15 |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    | --- | --- | --- | --- |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    | --- | --- | --- | --- |'
- en: '| RM | e1 | e5 | e9 | e13 | e2 | e6 | e10 | e14 | e3 | e7 | e11 | e15 | e4
    | e8 | e12 | e16 |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| RM | e1 | e5 | e9 | e13 | e2 | e6 | e10 | e14 | e3 | e7 | e11 | e15 | e4
    | e8 | e12 | e16 |'
- en: '| CM | e1 | e2 | e3 | e4 | e5 | e6 | e7 | e8 | e9 | e10 | e11 | e12 | e13 |
    e14 | e15 | e16 |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| CM | e1 | e2 | e3 | e4 | e5 | e6 | e7 | e8 | e9 | e10 | e11 | e12 | e13 |
    e14 | e15 | e16 |'
- en: In order to fix the pipeline OpenGL ES, the convention used for matrices is
    column major. Programmers have to abide by this convention. However, there is
    no restriction in the programmable pipeline to use either the row major or column
    major convention because all matrixes are managed by programmers themselves. It's
    advisable to stick to the column matrix representation as a convention to avoid
    any confusion.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复OpenGL ES的管线，矩阵使用的约定是列主序。程序员必须遵守这一约定。然而，在可编程管线中，没有限制使用行主序或列主序约定，因为所有矩阵都由程序员自己管理。坚持使用列矩阵表示法作为约定以避免任何混淆是明智的。
- en: '**Vertex representation in the matrix form**: A vertex in 3D space is represented
    by three coordinates (x, y, and z). However, in reality, it''s represented by
    four tuples(x, y, z, and w) instead of three. The forth tuple is called as homogeneous
    coordinate. In OpenGL ES, all three-dimensional coordinates and vectors use homogenous
    coordinates.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**矩阵形式的顶点表示**：三维空间中的顶点由三个坐标（x、y和z）表示。然而，在现实中，它由四个元组（x、y、z和w）表示，而不是三个。第四个元组称为齐次坐标。在OpenGL
    ES中，所有三维坐标和向量都使用齐次坐标。'
- en: '**Homogenous coordinates**: In homogenous coordinates, one set of coordinates
    can be represented by different types of coordinates. For example, for 1, 2, and
    3, the various homogenous representations can be 5, 10, 15, and 5 or 4, 8, 12,
    and 4 because they can be simplified in a general form:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '**齐次坐标**：在齐次坐标中，一组坐标可以用不同类型的坐标表示。例如，对于1、2和3，不同的齐次表示可以是5、10、15和5或4、8、12和4，因为它们可以简化为一般形式：'
- en: '[PRE37]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Therefore, the preceding two coordinates can be deduced as 5/5, 10/5, 15/5,
    and 5/5 or 4/4, 8/4, 12/4, and 4/4\. This is logically equal to 1, 2, 3, and 1.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，前面的两个坐标可以推断为5/5、10/5、15/5和5/5或4/4、8/4、12/4和4/4。这在逻辑上等于1、2、3和1。
- en: The perspective division stage in the fixed/programmable pipeline uses the `w`
    component of clip coordinates to normalize them. For translation purposes, always
    use the `w` component as 1\. Therefore, any 3D vertex (x, y, and z) is represented
    as (x, y, z, and 1).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在固定/可编程管道中的透视除法阶段，使用裁剪坐标的`w`分量来规范化它们。为了平移的目的，始终使用`w`分量为1。因此，任何3D顶点（x，y和z）表示为（x，y，z，1）。
- en: How to do it...
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following procedure to implement the model-view-projection paradigm
    with the help of various mathematical transformation operations:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤，在数学变换操作的帮助下实现模型-视图-投影范式：
- en: Note
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on the internals of the 3D transformation, you can refer
    to the *There's more…* section in this recipe. This section covers transformation
    operations, such as translation, scaling, and rotation.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 关于3D变换的内部信息，您可以参考此配方中的*更多内容…*部分。本节涵盖了变换操作，如平移、缩放和旋转。
- en: When a scene is rendered to the model-view-project information stored in the
    model, view, and projection matrices. In order to use any of these matrices, use
    the `TransformSetMatrixMode` function from the `Transform` class. This class allows
    you to set the relevant matrix as per the requirement of the application. This
    API accepts one parameter called mode, which tells the GLPI framework what kind
    of operation it is presently in; the accepted values of this parameter will be
    `MODEL_MATRIX` (modeling), `VIEW_MATRIX` (viewing), or `PROJECTION_MATRIX` (projection).
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当场景渲染到存储在模型、视图和投影矩阵中的模型-视图-投影信息时。为了使用这些矩阵中的任何一个，请使用`TransformSetMatrixMode`函数从`Transform`类。此类允许您根据应用程序的要求设置相关矩阵。此API接受一个名为mode的参数，它告诉GLPI框架当前正在执行哪种操作；此参数的接受值将是`MODEL_MATRIX`（建模）、`VIEW_MATRIX`（查看）或`PROJECTION_MATRIX`（投影）。
- en: '**Syntax**:'
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语法**：'
- en: '[PRE38]'
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can manipulate these matrices in any arbitrary order before executing the
    drawing command. This book follows the convention of first processing the projection
    matrix, which is followed by view and model matrix operations.
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在执行绘图命令之前，您可以以任意顺序操纵这些矩阵。本书遵循先处理投影矩阵的惯例，然后是视图和模型矩阵操作。
- en: 'The projection information is computed in the `Renderer::setupProjection` function.
    For this, the projection matrix needs to be activated first. For more information
    on projection systems and the working logic under this function, refer to the
    *Understanding the projection system in GLPI* recipe. This function is responsible
    for defining the clipping planes for projection frustum; any object that stays
    in this frustum box will be visible:'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 投影信息在`Renderer::setupProjection`函数中计算。为此，首先需要激活投影矩阵。有关投影系统和该函数下的工作逻辑的更多信息，请参阅*理解GLPI中的投影系统*配方。此函数负责定义投影视锥体的裁剪平面；任何保持在视锥体框内的对象都将可见：
- en: '[PRE39]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Whenever the current matrix is switched, it may contain some garbage or old
    transformation values. These values can be cleaned by setting the matrix as an
    identity matrix. This can be done using the `TransformLoadIdentity()` function
    from the `Transform` class.
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当切换当前矩阵时，它可能包含一些垃圾或旧变换值。可以通过将矩阵设置为单位矩阵来清理这些值。这可以通过使用`TransformLoadIdentity()`函数从`Transform`类来完成。
- en: 'Activate the view matrix in the `Renderer::setupView` function. This function
    is responsible for viewing information. For example, in this recipe, the viewer
    is `-2` and `-15` units away from the origin (`0.0f`, `0.0f`, and `0.0f`):'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Renderer::setupView`函数中激活视图矩阵。此函数负责视图信息。例如，在此配方中，观察者距离原点（`0.0f`，`0.0f`，`0.0f`）为`-2`和`-15`单位：
- en: '[PRE40]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, we are good to go; the rendering where the modeling transformation is
    preserved. The model matrix is activated in the `Renderer::setupModel`. From now
    on, any modeling transformation is always applied to the model matrix because
    it''s the most recent activated matrix:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好进行渲染；在建模变换被保留的情况下进行渲染。在`Renderer::setupModel`中激活模型矩阵。从现在起，任何建模变换都将始终应用于模型矩阵，因为它是最最近激活的矩阵：
- en: '[PRE41]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Render the drawing objects; the transformation applied to these objects will
    affect the model matrix.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染绘图对象；应用于这些对象的变换将影响模型矩阵。
- en: Create eight simple 3D cubes, such as C1, C2, C3, C4, C5, C6, C7, and C8 each
    with a dimension of 2 x 2 x 2 logical units (length x breadth x height). Note
    that units in OpenGL ES are logical.
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建八个简单的3D立方体，例如C1、C2、C3、C4、C5、C6、C7和C8，每个立方体的尺寸为2 x 2 x 2逻辑单位（长度 x 宽度 x 高度）。请注意，OpenGL
    ES中的单位是逻辑单位。
- en: Keep the C1 at origin. Displace C2 by 2 units, C3 by 4 units, and C4 by 6 units
    along positive *y* axis.
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持C1在原点。将C2沿正*y*轴移动2个单位，C3沿正*y*轴移动4个单位，C4沿正*y*轴移动6个单位。
- en: Displace C5 by 6 units in the positive *y* axis and 2 units in the negative
    *x* axis. Displace C6 by 6 units in the positive *y* axis and 2 units in the positive
    *x* axis.
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将C5沿正*y*轴移动6个单位，沿负*x*轴移动2个单位。将C6沿正*y*轴移动6个单位，沿正*x*轴移动2个单位。
- en: Displace C7 by 6 units in the positive *y* axis and 6 units in the negative
    *x* axis.
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将C7沿正*y*轴移动6个单位，沿负*x*轴移动6个单位。
- en: 'Displace C8 by 6 units in the positive *y* axis and 6 units in the positive
    *x* axis:'
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将C8沿正*y*轴移动6个单位，沿正*x*轴移动6个单位：
- en: '[PRE42]'
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '![How to do it...](img/5527OT_02_30.jpg)'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/5527OT_02_30.jpg)'
- en: How it works...
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A scene is a composition of model, view, and projection. Each of these has a
    specific responsibility. Model stores the modeling transformation that is applied
    to the rendering items, such as rotation or translation. The model matrix (`MODEL_MATRIX`)
    is activated in the `setupModel` function. From here on, any kind of model rendering
    transformation is applied to the model matrix. For example, in the present recipe,
    various transformations (such as rotation and translation) are applied to a simple
    3D cube to render it to different spatial positions. When object coordinates of
    the cube geometry are applied to model transformations, it yields world coordinates.
    The selection of the required matrix (model, view, and projection) can be done
    using `TransformSetMatrixMode`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 场景是模型、视图和投影的组合。每个都有特定的职责。模型存储应用于渲染项（如旋转或平移）的建模变换。模型矩阵（`MODEL_MATRIX`）在`setupModel`函数中被激活。从现在开始，任何类型的模型渲染变换都应用于模型矩阵。例如，在当前的配方中，对简单的3D立方体应用了各种变换（如旋转和平移），以将其渲染到不同的空间位置。当立方体几何体的对象坐标应用于模型变换时，它产生世界坐标。可以使用`TransformSetMatrixMode`选择所需的矩阵（模型、视图和投影）。
- en: The viewing transformation is the middle stage in the scene construction, which
    is responsible for setting up the view or camera in the 3D space. In other words,
    it tells you how a scene will be viewed in a 3D space. In the present recipe,
    the scene is viewed from a position 15 units away from the origin on the *z* axis
    and `-2` units away from the *y* axis. The view transformation is carried out
    in the `setupView` function and it affects the view matrix (`VIEW_MATRIX`). The
    view matrix is applied to world coordinates in order to produce eye coordinates.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 视觉变换是场景构建的中间阶段，负责在3D空间中设置视图或相机。换句话说，它告诉你一个场景在3D空间中是如何被观察的。在当前的配方中，场景是从距离原点15个单位的位置在*z*轴上和距离*y*轴`-2`个单位的位置观察的。视图变换在`setupView`函数中执行，并影响视图矩阵（`VIEW_MATRIX`）。视图矩阵应用于世界坐标以产生视点坐标。
- en: The projection system defines a view volume and keeps track of all objects that
    falls in it. Only these objects will be rendered. The viewing volume or the frustum
    consists of six clipping planes. These are constructed in the `setupProject` function.
    Here, the transformation is carried out on the projection matrix (`PROJECTION_MATRIX`).
    This projection matrix uses eye coordinates and converts them to clipping coordinates.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 投影系统定义了一个视锥体并跟踪所有落在其中的对象。只有这些对象将被渲染。视锥体或截锥体由六个裁剪平面组成。这些平面在`setupProject`函数中构建。在这里，对投影矩阵（`PROJECTION_MATRIX`）进行变换。这个投影矩阵使用视点坐标并将它们转换为裁剪坐标。
- en: 'The following diagram shows the complete process of the vertex life cycle for
    transformation purposes:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了用于变换目的的顶点生命周期的完整过程：
- en: '![How it works...](img/5527OT_02_31.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/5527OT_02_31.jpg)'
- en: There's more...
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: '**Transformation operation**: There are mainly three types of transformations
    that are majorly used. Each of these transformations is stored in the mathematical
    column major matrix form under the OpenGL ES convention. These transformations
    are represented by a 4 x 4 matrix.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '**变换操作**：主要使用三种类型的变换。这些变换在OpenGL ES约定下以数学列主矩阵形式存储。这些变换由一个4x4矩阵表示。'
- en: '**Translation**: This translation operation occupies the 13th, 14th, and the
    15th position in the 4 x 4 transformation matrix or in the row-column format,
    that is, [0, 3], [1, 3], and [2, 3]. The P vertex (Vx, Vy, and Vz) with T translation
    (Tx, Ty, and Tz) can be represented in a general form: *P'' = T.P*.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平移**: 这种平移操作占据了 4x4 变换矩阵或行列格式中的第 13、14 和第 15 个位置，即 [0, 3]、[1, 3] 和 [2, 3]。具有
    T 平移（Tx、Ty 和 Tz）的 P 顶点（Vx、Vy 和 Vz）可以表示为一般形式：*P'' = T.P*。'
- en: Note
  id: totrans-334
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The `Transform` class provides the `TransformTranslate` API for the translation
    operation.
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Transform` 类提供了 `TransformTranslate` API 用于平移操作。'
- en: '**Syntax**:'
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语法**:'
- en: '[PRE43]'
  id: totrans-337
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '| Variables | Description |'
  id: totrans-338
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-339
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Tx | This specifies the translation distance in a logical unit along the
    *x* axis |'
  id: totrans-340
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| Tx | 这指定了沿 *x* 轴的逻辑单位中的平移距离 |'
- en: '| Ty | This specifies the translation distance in a logical unit along the
    *y* axis |'
  id: totrans-341
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| Ty | 这指定了沿 *y* 轴的逻辑单位中的平移距离 |'
- en: '| Tz | This specifies the translation distance in a logical unit along the
    *z* axis |'
  id: totrans-342
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| Tz | 这指定了沿 *z* 轴的逻辑单位中的平移距离 |'
- en: '**Scale**: Scale components along *x*, *y*, and *z* components in matrices
    are represented using diagonal elements. The P vertex (Vx, Vy, and Vz) scaled
    by the S factor (Sx, Sy, and Sz) can be generalized, as shown in the following
    figure:![There''s more...](img/5527OT_02_38.jpg)'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缩放**: 矩阵中沿 *x*、*y* 和 *z* 分量的缩放分量使用对角线元素表示。P顶点（Vx、Vy 和 Vz）通过 S 因子（Sx、Sy 和
    Sz）缩放可以概括，如下图中所示：![更多内容...](img/5527OT_02_38.jpg)'
- en: Note
  id: totrans-344
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The `Transform` class provides the `TransformScale` API for the scale operation.
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Transform` 类提供了 `TransformScale` API 用于缩放操作。'
- en: '**Syntax**:'
  id: totrans-346
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语法**:'
- en: '[PRE44]'
  id: totrans-347
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '| **Sx** | **This denotes scaling along the x axis** |'
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| **Sx** | **这表示沿 x 轴缩放** |'
- en: '| **Sy** | **This denotes scaling along the y axis** |'
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| **Sy** | **这表示沿 y 轴缩放** |'
- en: '| **Sz** | **This denotes scaling along the z axis** |'
  id: totrans-350
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| **Sz** | **这表示沿 z 轴缩放** |'
- en: '**Rotation**: This transformation along the *x*, *y*, and *z* axis through
    zero degree can be represented in the matrix form, as given in the following diagram:'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**旋转**: 沿 *x*、*y* 和 *z* 轴通过零度进行的这种变换可以用矩阵形式表示，如下图中所示：'
- en: Assume, cos (θ) = C and sin (θ) = S.
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假设，cos (θ) = C 和 sin (θ) = S。
- en: '![There''s more...](img/5527OT_02_39.jpg)'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![更多内容...](img/5527OT_02_39.jpg)'
- en: Note
  id: totrans-354
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The `Transform` class provides the `TransformRotate` API for the rotation operation.
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Transform` 类提供了 `TransformRotate` API 用于旋转操作。'
- en: '**Syntax**:'
  id: totrans-356
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语法**:'
- en: '[PRE45]'
  id: totrans-357
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '| Variable | Description |'
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-359
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `angle` | This indicates the degree of rotation |'
  id: totrans-360
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `angle` | 这表示旋转的角度 |'
- en: '| `Rx` | This indicates the degree of rotation along the *x* axis |'
  id: totrans-361
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `Rx` | 这表示沿 *x* 轴旋转的角度 |'
- en: '| `Ry` | This indicates the degree of rotation along the *y* axis |'
  id: totrans-362
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `Ry` | 这表示沿 *y* 轴旋转的角度 |'
- en: '| `Rz` | This indicates the degree of rotation along the *z* axis |'
  id: totrans-363
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `Rz` | 这表示沿 *z* 轴旋转的角度 |'
- en: See also
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Understanding the projection system in GLPI* recipe in [Appendix](apa.html
    "Appendix A. Supplementary Information on OpenGL ES 3.0"), *Supplementary Information
    on OpenGL ES 3.0*'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*理解 GLPI 中的投影系统* 菜谱在 [附录](apa.html "附录 A. OpenGL ES 3.0 补充信息")，*OpenGL ES 3.0
    补充信息*'
- en: Understanding the projection system in GLPI
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 GLPI 中的投影系统
- en: 'In this recipe, we will understand two types of projection systems that are
    very commonly used in 3D graphics: perspective projection system and orthographic
    projection system:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将了解在 3D 图形中非常常用的两种投影系统：透视投影系统和正交投影系统：
- en: '**Perspective projection system**: This type of projection system creates a
    view that is similar to how our eyes view the objects. This means that the objects
    that are near to us will appear bigger when compared to the far off objects. This
    type of projection system uses a frustum-clipping region, as shown on the left-hand
    side of the next figure.'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**透视投影系统**: 这种投影系统创建的视图类似于我们的眼睛观察物体时的视角。这意味着，相对于远离我们的物体，靠近我们的物体会显得更大。这种投影系统使用一个截锥剪切区域，如图中左侧所示。'
- en: In the GLPI framework, the `Transform::TransformSetPerspective()` function can
    be used to create a perspective view.
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 GLPI 框架中，可以使用 `Transform::TransformSetPerspective()` 函数来创建透视视图。
- en: '**Syntax**:'
  id: totrans-370
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语法**:'
- en: '[PRE46]'
  id: totrans-371
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '| Variable | Description |'
  id: totrans-372
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-373
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `fov` | This defines the field of view |'
  id: totrans-374
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `fov` | 这定义了视场 |'
- en: '| `aspect_ratio` | This is the rendering aspect ratio (width/height) |'
  id: totrans-375
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `aspect_ratio` | 这是渲染的宽高比（宽度/高度） |'
- en: '| `clip_start` and `clip_end` | These are the near and far clipping planes
    |'
  id: totrans-376
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `clip_start` 和 `clip_end` | 这些是近裁剪平面和远裁剪平面 |'
- en: '| `screen_orientation` | These are the vertical or horizontal orientation for
    scene rendering |'
  id: totrans-377
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `screen_orientation` | 这些是场景渲染的垂直或水平方向 |'
- en: '**Orthographic projection system**: This type of projection system is specially
    used in engineering applications where near and far objects always appear with
    the same dimensions. Therefore, the orthographic projection system retains the
    geometric dimensions. This projection system uses a clipping region in the cuboidal
    shape, as shown in the next figure.'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正交投影系统**：这种投影系统特别用于工程应用，其中近处和远处的物体总是以相同的尺寸出现。因此，正交投影系统保留了几何尺寸。此投影系统使用如图所示的立方体形状的裁剪区域。'
- en: The GLPI framework provides orthographic projection with the `TransformOrtho()`
    function. Any model rendered within this clipping plane range will be displayed
    on the screen, and the rest will be clipped out.
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: GLPI 框架通过 `TransformOrtho()` 函数提供正交投影。任何在此裁剪平面范围内渲染的模型都将显示在屏幕上，其余的将被裁剪掉。
- en: '**Syntax**:'
  id: totrans-380
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语法**:'
- en: '[PRE47]'
  id: totrans-381
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '| Variable | Description |'
  id: totrans-382
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-383
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `left` and `right` | These are the left and right range of the clipping planes
    |'
  id: totrans-384
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `left` 和 `right` | 这些是裁剪平面的左右范围 |'
- en: '| `bottom` and `top` | These are the bottom and top range of clipping planes
    |'
  id: totrans-385
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `bottom` 和 `top` | 这些是裁剪平面的底部和顶部范围 |'
- en: '| `clip_start` and `clip_end` | These are the near and far clipping planes
    |'
  id: totrans-386
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `clip_start` 和 `clip_end` | 这些是近裁剪平面和远裁剪平面 |'
- en: 'The following figure shows that the cubes nearer to the camera are appearing
    bigger compared to others placed at far distance. On the right-hand side, the
    projection generated by this is displayed. This projection clearly shows that
    irrespective of the distance of the cube from the camera, they all appear with
    same dimensions:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示，靠近摄像机的立方体与其他放置在较远距离的立方体相比显得更大。在右侧，显示了由此产生的投影。这种投影清楚地表明，无论立方体与摄像机的距离如何，它们都以相同的尺寸出现：
- en: '![Understanding the projection system in GLPI](img/5527OT_02_32.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![理解 GLPI 中的投影系统](img/5527OT_02_32.jpg)'
- en: How to do it...
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Here are the steps to implement the perspective and orthographic projection
    systems:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 实现透视和正交投影系统的步骤如下：
- en: In order to apply a specific projection onto the scene, we will use the setup
    `Projection()` function in the `Renderer` class. This will be the first function
    that gets called before rendering each frame. It is very important to set the
    current matrix as the projection matrix using the `TransformSetMatrixMode` (`PROJECTION_MATRIX`)
    function. This will ensure that the projection matrix will be in current use.
    Now, the orthographic or perspective projection systems can be applied using the
    `TransformOrtho()` or `TransformSetPerspective()` function.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将特定的投影应用到场景中，我们将在 `Renderer` 类中使用 `setup Projection()` 函数。这将是在渲染每一帧之前被调用的第一个函数。使用
    `TransformSetMatrixMode` (`PROJECTION_MATRIX`) 函数将当前矩阵设置为投影矩阵非常重要。这将确保投影矩阵正在使用中。现在，可以使用
    `TransformOrtho()` 或 `TransformSetPerspective()` 函数应用正交或透视投影系统。
- en: After setting the projection system, it is important to set the current matrix
    as `VIEW_MATRIX` in order to set the camera position in the 3D space. Finally,
    before rendering the object's models, set the current matrix as `MODEL_MATRIX`,
    using `TransformSetMatrixMode`.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置投影系统后，将当前矩阵设置为 `VIEW_MATRIX` 以在 3D 空间中设置摄像机位置非常重要。最后，在渲染对象的模型之前，使用 `TransformSetMatrixMode`
    将当前矩阵设置为 `MODEL_MATRIX`。
- en: Note
  id: totrans-393
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Whenever the current matrix is switched, it may contain some garbage or old
    transformation values. These values can be cleaned by setting the matrix as identity
    matrix. This can be done using the `TransformLoadIdentity()` function.
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当切换当前矩阵时，它可能包含一些垃圾或旧变换值。这些值可以通过将矩阵设置为单位矩阵来清理。这可以通过使用 `TransformLoadIdentity()`
    函数来完成。
- en: '[PRE48]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: How it works...
  id: totrans-396
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe renders a few cubes arranged in a linear manner in the perspective
    and orthographic projection systems. The projection systems can be switched on
    by a single tap on the screen.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方在透视和正交投影系统中渲染几个线性排列的立方体。可以通过单次点击屏幕来切换投影系统。
- en: This recipe first defines a 3D space volume (frustum or cuboid) using the projection
    system with the projection matrix. This 3D space volume consists of six planes
    that are responsible for displaying the object contents that are falling under
    this volume. The objects outside of this 3D volume will be clipped off. The view
    matrix is responsible for setting the eye or camera in the 3D space. In our recipe,
    the camera is 10 units away from the origin. Finally, set the model matrix to
    render the objects in the 3D space.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方首先使用投影矩阵和投影系统定义一个三维空间体积（视锥体或长方体）。这个三维空间体积由六个平面组成，负责显示属于此体积内的对象内容。此三维体积之外的对象将被裁剪掉。视图矩阵负责在三维空间中设置眼睛或摄像机。在我们的配方中，摄像机距离原点10个单位。最后，设置模型矩阵以在三维空间中渲染对象。
- en: Culling in OpenGL ES 3.0
  id: totrans-399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenGL ES 3.0 中的裁剪
- en: 'Culling is an important technique in 3D graphics. It is used to discard the
    faces that are not visible to the user. In an enclosed geometry, the faces pointing
    towards the camera hide the faces behind it, either partially or completely. These
    faces can be easily avoided during rendering by the culling technique. This is
    an easier way to speed up the performance in OpenGL ES graphics. There are two
    types of faces:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 裁剪是三维图形中的重要技术。它用于丢弃用户不可见的面。在一个封闭的几何体中，指向摄像机的面会隐藏其后的面，部分或全部。这些面可以通过裁剪技术轻松避免。这是在
    OpenGL ES 图形中加快性能的简单方法。有两种类型的面：
- en: '**Front face**: The face in an enclosed 3D object that points outward are considered
    to be the front face'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前表面**：在一个封闭的三维物体中，指向外部的面被认为是前表面'
- en: '**Back face**: The face in an enclosed 3D object that points inside of these
    faces are considered as to be the back face'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**背面**：在一个封闭的三维物体中，指向这些面的面被认为是背面'
- en: How to do it...
  id: totrans-403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Culling can be enabled in OpenGL ES 3.0 using the `glenable` API with `GL_CULL_FACE`
    as state flag. By default, OpenGL ES 3.0 culls the back face. This can be changed
    using the `glCullFace` API. Tap on the screen to switch between the front and
    back culling modes. This recipe will display the outside faces of the cube when
    back face culling is set; otherwise, it displays the inside faces when front face
    culling is enabled:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OpenGL ES 3.0 中，可以使用 `glenable` API 并将 `GL_CULL_FACE` 作为状态标志来启用裁剪。默认情况下，OpenGL
    ES 3.0 裁剪背面。这可以通过 `glCullFace` API 来更改。轻触屏幕以在前后裁剪模式之间切换。当设置背面裁剪时，此配方将显示立方体的外部面；否则，当启用正面裁剪时，它将显示内部面：
- en: '**Syntax**:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**:'
- en: '[PRE49]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '| Variable | Description |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `mode` | This is the mode argument parameter accepts symbolic constant `GL_FRONT`
    (front faces are discarded), `GL_BACK` (back faces are discarded), and `GL_FRONT_AND_BACK`
    (no facets are drawn) |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: '| `mode` | 这是模式参数，接受符号常量 `GL_FRONT`（丢弃前表面），`GL_BACK`（丢弃后表面），以及 `GL_FRONT_AND_BACK`（不绘制任何面）|'
- en: 'Depending on the application requirement, culling can be applied during initialization
    of the graphics engine or before rendering the primitives:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 根据应用需求，裁剪可以在图形引擎初始化期间或渲染原语之前应用：
- en: '[PRE50]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The following figure shows the back-face culling and front-face culling:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了背面裁剪和正面裁剪：
- en: '![How to do it...](img/5527OT_02_33.jpg)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/5527OT_02_33.jpg)'
- en: How it works...
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Unlike human eyes, the computer recognizes the front face and back face of
    an object from the order of the vertices winding. There are two ways in which
    these vertices can be arranged: clockwise and anticlockwise. In the following
    figure, the rectangle is comprised of two triangles whose vertices are specified
    in a counterclockwise direction:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 与人眼不同，计算机通过顶点环绕的顺序来识别物体的前表面和后表面。这些顶点可以有两种排列方式：顺时针和逆时针。在下图中，矩形由两个三角形组成，其顶点按逆时针方向指定：
- en: '![How it works...](img/5527OT_02_34.jpg)'
  id: totrans-416
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/5527OT_02_34.jpg)'
- en: When culling is enabled using the `glEnable` API, then the order of arrangement
    of vertices in the array data defines the orientation of vertices in a face. This
    orientation plays an important role in defining the front and back faces. Using
    `glCullFaces` APIs, the OpenGL ES knows which all faces can be discarded. All
    the faces that satisfy culling rules are discarded. By convention, the default
    way of orientation is counterclockwise. We can change this using the `glFrontFace`
    API by specifying the argument as `GL_CCW` (counter clockwise) or `GL_CW` (clockwise).
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`glEnable` API启用剔除时，数组数据中顶点的排列顺序定义了面中顶点的方向。这种方向在定义前后面时起着重要作用。使用`glCullFaces`
    API，OpenGL ES知道哪些面可以被丢弃。所有满足剔除规则的面都被丢弃。按照惯例，默认的排列方向是逆时针。我们可以通过使用`glFrontFace`
    API并指定参数为`GL_CCW`（逆时针）或`GL_CW`（顺时针）来改变这种方向。
- en: Depth testing in OpenGL ES 3.0
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenGL ES 3.0中的深度测试
- en: Depth testing allows us to render the object in the order of distance from the
    viewer. Without depth testing the rendering of the objects is similar to the painter's
    algorithm on the device screen. It will render the object on first-come-first-draw
    basis. For example, if there are three different colored triangles rendered in
    the order of, say, red, green, and blue, then as per painter's algorithm, it draws
    red first, green second, and blue at last. The result will appear on the screen
    in an opposite order, with blue on the top, green in the middle, and red at the
    bottom. This type of rendering does not take the distance of the triangle objects
    from the camera into consideration. In real life, the object closer to the camera
    hides the objects behind them. In order to deal with such real-time scenarios,
    depth testing is used. It renders the objects based on the depth of the distance
    from the camera, instead of using the drawing order (painter's algorithm).
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 深度测试使我们能够按照从观察者到物体的距离顺序渲染物体。如果没有深度测试，物体的渲染类似于设备屏幕上的画家算法。它将根据先来先画的原则渲染物体。例如，如果有三个不同颜色的三角形按照红色、绿色和蓝色的顺序渲染，那么根据画家算法，它首先绘制红色，然后是绿色，最后是蓝色。结果将在屏幕上以相反的顺序显示，蓝色在最上面，绿色在中间，红色在最下面。这种渲染方式没有考虑三角形物体与摄像机的距离。在现实生活中，靠近摄像机的物体将隐藏其后面的物体。为了处理这种实时场景，我们使用深度测试。它根据物体与摄像机的距离深度来渲染物体，而不是使用绘制顺序（画家算法）。
- en: In depth testing, each fragment's depth is stored in a special buffer called
    depth buffer. Unlike the color buffer that stores the color information, the depth
    buffer stores depth information of the primitive's corresponding fragment from
    the camera view. The depth buffer's dimension is usually the same as the color
    buffer. The depth buffer stores the depth information as 16-, 24-, or 32-bit float
    values.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在深度测试中，每个片段的深度被存储在一个称为深度缓冲区的特殊缓冲区中。与存储颜色信息的颜色缓冲区不同，深度缓冲区存储了从摄像机视图到原始片段的深度信息。深度缓冲区的维度通常与颜色缓冲区相同。深度缓冲区以16位、24位或32位浮点值的形式存储深度信息。
- en: Apart from rendering the objects in the correct depth order, there are many
    other applications in which the depth buffer is used. One of the most common use
    of depth buffer is to produce real-time shadows with the shadow-mapping technique.
    For more information, refer to the *Creating shadows with shadow mapping* recipe
    in [Chapter 11](ch11.html "Chapter 11. Anti-aliasing Techniques"), *Anti-aliasing
    Techniques*.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 除了以正确的深度顺序渲染物体之外，深度缓冲区还有许多其他应用。深度缓冲区最常见的一种用途是使用阴影映射技术产生实时阴影。有关更多信息，请参阅第11章中关于*使用阴影映射创建阴影*的配方，*抗锯齿技术*。
- en: '![Depth testing in OpenGL ES 3.0](img/5527OT_02_35.jpg)'
  id: totrans-422
  prefs: []
  type: TYPE_IMG
  zh: '![OpenGL ES 3.0中的深度测试](img/5527OT_02_35.jpg)'
- en: Getting ready
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will render three objects and apply depth testing in the
    toggle fashion (enable/disable) to see the effect of depth test in rendering the
    scene. In order to toggle the behavior, single tap on the screen.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们将渲染三个物体，并使用切换方式（启用/禁用）应用深度测试，以查看深度测试在渲染场景中的效果。为了切换行为，在屏幕上轻触一次。
- en: How to do it...
  id: totrans-425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In this recipe, the triangle object is in the center, and two cubes are revolving
    around the triangle object. The depth testing is disabled by default in OpenGL
    ES 3.0\. It needs to be enabled by using the `glEnable` API with the `GL_DEPTH_TEST`
    as symbolic constant. Once depth testing is enabled, then behind the curtains,
    OpenGL ES creates a depth buffer. This depth buffer is used during the rendering
    of scenes to predict the correct order of the appearance of model objects. Make
    sure that you clear the depth buffer before rendering each frame with `glClear(GL_DEPTH_BUFFER_BIT)`:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，三角形对象位于中心，两个立方体围绕三角形对象旋转。在OpenGL ES 3.0中，默认禁用深度测试。需要使用带有`GL_DEPTH_TEST`符号常量的`glEnable`
    API来启用它。一旦启用深度测试，OpenGL ES就会在幕后创建一个深度缓冲区。这个深度缓冲区在渲染场景时用于预测模型对象出现的正确顺序。确保在用`glClear(GL_DEPTH_BUFFER_BIT)`渲染每一帧之前清除深度缓冲区：
- en: '[PRE51]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: How it works...
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The depth buffer is a kind of buffer that contains the depth information of
    all the fragments on the window screen. The depth buffer contains `z` (depth)
    values that range between 0.0 and 1.0\. The depth buffer compares its content
    with `z` value of all the objects in the scene, as seen from the camera view.
    When the `glClear(GL_DEPTH_BUFFER_BIT)` function is called, it sets the `z` values
    of all fragments with the depth value as 1.0\. Depth buffer with pixel value 0.0
    is considered to be the closest to the camera position (at near plane), whereas
    a fragment value of 1.0 is considered to be the farthest (at far plane). When
    an object is rendered, the associated fragment depth is compared to the corresponding
    value already present in the depth buffer. This comparison is based on the `glDepthFunction`
    depth API.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 深度缓冲区是一种包含窗口屏幕上所有片段深度信息的缓冲区。深度缓冲区包含介于0.0和1.0之间的`z`（深度）值。深度缓冲区将其内容与从摄像机视图看到的场景中所有对象的`z`值进行比较。当调用`glClear(GL_DEPTH_BUFFER_BIT)`函数时，它将所有具有深度值的片段的`z`值设置为1.0。像素值为0.0的深度缓冲区被认为是离摄像机位置最近的（在近平面），而像素值为1.0的片段被认为是距离最远的（在远平面）。当渲染对象时，相关的片段深度将与深度缓冲区中已存在的相应值进行比较。这种比较基于`glDepthFunction`深度API。
- en: Note
  id: totrans-430
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The depth test always passes if the depth test is disabled or no depth buffer
    exists.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 如果禁用深度测试或不存在深度缓冲区，则深度测试总是通过。
- en: The depth value can be controlled by the `glDepthFunction` API. This API specifies
    how the incoming depth values will be compared with the values already present
    in the depth buffer.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 深度值可以通过`glDepthFunction` API来控制。此API指定传入的深度值将如何与深度缓冲区中已存在的值进行比较。
- en: '**Syntax**:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**:'
- en: '[PRE52]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '| Variable | Description |'
  id: totrans-435
  prefs: []
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `func` | This indicates the condition under which the pixel will be drawn
    |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
  zh: '| `func` | 这表示绘制像素的条件 |'
- en: 'The following table specifies the conditional checks that can be used to pass
    or fail the depth test. Here are the defined meanings of the symbolic constants:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格指定了可以用于通过或失败深度测试的条件检查。以下是符号常量的定义含义：
- en: '| Symbolic constant | Meaning |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
  zh: '| 符号常量 | 含义 |'
- en: '| --- | --- |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `GL_NEVER` | Never passes |'
  id: totrans-441
  prefs: []
  type: TYPE_TB
  zh: '| `GL_NEVER` | 从不通过 |'
- en: '| `GL_LESS` | Passes if the incoming depth value is less than the stored value
    |'
  id: totrans-442
  prefs: []
  type: TYPE_TB
  zh: '| `GL_LESS` | 如果传入的深度值小于存储的值，则通过 |'
- en: '| `GL_EQUAL` | Passes if the incoming depth value is equal to the stored value
    |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
  zh: '| `GL_EQUAL` | 如果传入的深度值等于存储的值，则通过 |'
- en: '| `GL_LEQUAL` | Passes if the incoming depth value is less than or equal to
    the stored value |'
  id: totrans-444
  prefs: []
  type: TYPE_TB
  zh: '| `GL_LEQUAL` | 如果传入的深度值小于或等于存储的值，则通过 |'
- en: '| `GL_GREATER` | Passes if the incoming depth value is greater than the stored
    value |'
  id: totrans-445
  prefs: []
  type: TYPE_TB
  zh: '| `GL_GREATER` | 如果传入的深度值大于存储的值，则通过 |'
- en: '| `GL_NOTEQUAL` | Passes if the incoming depth value is not equal to the stored
    value |'
  id: totrans-446
  prefs: []
  type: TYPE_TB
  zh: '| `GL_NOTEQUAL` | 如果传入的深度值不等于存储的值，则通过 |'
- en: '| `GL_GEQUAL` | Passes if the incoming depth value is greater than or equal
    to the stored value |'
  id: totrans-447
  prefs: []
  type: TYPE_TB
  zh: '| `GL_GEQUAL` | 如果传入的深度值大于或等于存储的值，则通过 |'
- en: '| `GL_ALWAYS` | Always passes |'
  id: totrans-448
  prefs: []
  type: TYPE_TB
  zh: '| `GL_ALWAYS` | 总是通过 |'
- en: There's more...
  id: totrans-449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `z` value of an object in the view space could be any value in between frustum's
    near and far planes. Therefore, we need some conversion formulas to produce `z`
    values in the range 0.0 and 1.0\. The following image shows the mathematical formula
    to calculate the depth of an object inside the frustum using a linear transformation.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 视图空间中对象的`z`值可以是视锥体近平面和远平面之间的任何值。因此，我们需要一些转换公式来生成范围在0.0和1.0之间的`z`值。以下图像显示了使用线性变换计算视锥体内对象深度的数学公式。
- en: 'In reality, the linear transformation to calculate the `z` value is hardly
    used because it gives constant precision at all depths. However, we need more
    precision for items that are closer to the viewer''s eyes and less precision that
    are farther. For this purpose, a nonlinear function is used that is proportional
    to `1/z` to calculate the depth. Clearly in the second image, the nonlinear function
    produces an enormous precision at the near plane for the objects falling in the
    range `[1, 20]`. In contrast, the farther object has less precision that is fulfilling
    the ideal requirements:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实中，用于计算`z`值的线性变换几乎不被使用，因为它在所有深度上提供的是恒定的精度。然而，对于靠近观察者眼睛的物品，我们需要更高的精度，而对于远离观察者的物品，则需要较低的精度。为此，使用了一个与`1/z`成比例的非线性函数来计算深度。显然，在第二幅图像中，非线性函数在范围
    `[1, 20]` 内的对象在近平面产生了巨大的精度。相比之下，远处的物体精度较低，这满足了理想的要求：
- en: '![There''s more...](img/5527OT_02_36.jpg)'
  id: totrans-452
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/5527OT_02_36.jpg)'
