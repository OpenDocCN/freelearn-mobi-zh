- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Principles of Software Architecture
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件架构原则
- en: In this chapter, we are going to cover the fundamental principles of software
    architecture. They are vitally important to every part of software architecture.
    We should constantly remind ourselves of these, just like professional pianists
    practice scales every day.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍软件架构的基本原则。它们对软件架构的每个部分都至关重要。我们应该不断提醒自己这些原则，就像专业钢琴家每天练习音阶一样。
- en: We’ll go through different ways to describe and view software architecture first.
    Then we’ll cover a few important principles that will be referenced in later chapters.
    It is intended that you might go back to this chapter anytime and contemplate
    again some of these key concepts.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先介绍描述和查看软件架构的不同方法。然后，我们将介绍一些在后续章节中会引用的重要原则。目的是你可能随时回到这一章，再次思考这些关键概念。
- en: Perspectives, dimensions, and qualities
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视角、维度和品质
- en: Separation of concerns, cohesiveness, and coupling
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关注点分离、内聚性和耦合性
- en: SOLID principles
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SOLID 原则
- en: YAGNI and future-proof architecture
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: YAGNI 和未来证明的架构
- en: The Law of Demeter
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Demeter 法则
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术需求
- en: 'You can find all the code files used in this chapter on GitHub: [https://github.com/Packt
    Publishing/Software-Architecture-with-Kotlin/tree/main/chapter-2](https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-2%0D)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上找到本章使用的所有代码文件：[https://github.com/Packt Publishing/Software-Architecture-with-Kotlin/tree/main/chapter-2](https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-2%0D)
- en: Perspectives, dimensions, and qualities
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视角、维度和品质
- en: Software systems are not physical objects that we can easily see or touch. At
    their roots, they are instructions that are interpreted by a machine. So, we will
    need to visualize software systems in other ways.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 软件系统不是我们可以轻易看到或触摸的物理对象。在它们的根源上，它们是由机器解释的指令。因此，我们需要以其他方式可视化软件系统。
- en: The major purpose of visualizing software systems is to demonstrate how stakeholder
    concerns are addressed. There is usually a lengthy list of concerns. Each stakeholder
    usually has multiple concerns at various levels of abstraction. It is not possible
    to address all concerns from all angles in one visual representation.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化软件系统的主要目的是展示如何解决利益相关者的关注点。通常有一个长长的关注点列表。每个利益相关者通常在多个抽象级别上有多个关注点。不可能在一个视觉表示中从所有角度解决所有关注点。
- en: The concept of **View** was introduced in the 1970s to describe software architecture.
    Since then, there have been numerous efforts to codify and standardize methods
    in describing software architecture. **ISO/IEC/IEEE 42010:2022** is the current
    standard in specifying software architecture, by which the architectural concepts,
    structure, and language are defined.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**视图**的概念在 20 世纪 70 年代被引入，用于描述软件架构。从那时起，已经有许多努力来规范和标准化描述软件架构的方法。**ISO/IEC/IEEE
    42010:2022** 是目前指定软件架构的标准，通过该标准定义了架构概念、结构和语言。'
- en: In a View, only selected perspectives of software architecture are portrayed.
    The selection aims at addressing certain stakeholder concerns. Moreover, there
    are multiple Views so each View can target specific concerns and specific stakeholders.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个视图中，只描绘了软件架构的选定视角。选择旨在解决某些利益相关者的关注点。此外，存在多个视图，因此每个视图可以针对特定的关注点和特定的利益相关者。
- en: A **View Model** is a collection of Views wherein each View has a dedicated
    focus, purpose, and language for visualization.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**视图模型**是一组视图的集合，其中每个视图都有专门的焦点、目的和可视化语言。'
- en: The **4+1 architecture view model** was created by Philippe Kruchten in 1995\.
    It includes four views of a software system, plus selected scenarios that help
    different stakeholders understand the software system from the perspectives of
    other stakeholders.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**4+1 架构视图模型**由 Philippe Kruchten 在 1995 年创建。它包括软件系统的四个视图，以及帮助不同利益相关者从其他利益相关者视角理解软件系统的选定场景。'
- en: '![Figure 2.1 – A 4+1 architecture view model](img/B21737_02_1.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – 4+1 架构视图模型](img/B21737_02_1.jpg)'
- en: Figure 2.1 – A 4+1 architecture view model
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 4+1 架构视图模型
- en: Let’s look at each view from the 4+1 architecture view model in the upcoming
    sections.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将从 4+1 架构视图模型的角度逐一查看每个视图。
- en: Logical view
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑视图
- en: The **logical view** focuses on the business functionality of the system and
    how it is implemented. It is agnostic to the technical concerns. It is an abstract
    view of how a business feature works without involving technical terms, using
    the language that both technical and non-technical stakeholders understand. It
    is suitable for communication with non-technical stakeholders.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**逻辑视图**关注系统的业务功能及其实现方式。它对技术问题无关紧要。它是一个抽象视图，描述了业务功能如何工作，而不涉及技术术语，使用的是技术和非技术利益相关者都能理解的语言。它适合与非技术利益相关者进行沟通。'
- en: 'In the example of the state transition of a service exchange contract between
    households, the logical view is expressed in the UML state diagram that follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在家庭之间服务交换合同状态转换的例子中，逻辑视图如下所示的表达在 UML 状态图中：
- en: '![Figure 2.2 – A 4+1 architecture view model – logical view](img/B21737_02_2.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – 4+1 架构视图模型 – 逻辑视图](img/B21737_02_2.jpg)'
- en: Figure 2.2 – A 4+1 architecture view model – logical view
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – 4+1 架构视图模型 – 逻辑视图
- en: A service contract between two households is first drafted by one household.
    The contract is of the **Drafted** state. Once the draft is complete, the household
    submits the contract to be reviewed by the other household.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 两个家庭之间的服务合同首先由一个家庭起草。合同处于**草稿**状态。一旦草案完成，家庭将合同提交给另一个家庭进行审查。
- en: The contract could be amended by both households before they reach an agreement.
    Both households must agree to the terms before going further. However, in some
    cases, the contract may be rejected by a household and thus enter the **Rejected**
    terminal state.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在双方家庭达成协议之前，合同可以由双方家庭进行修改。在继续之前，双方家庭必须同意条款。然而，在某些情况下，合同可能被一个家庭拒绝，从而进入**拒绝**的终端状态。
- en: Assuming that both households agreed to the terms, there is still a chance that
    the contract could be withdrawn due to other circumstances. Assuming that the
    contract goes ahead, both households then exercise and fulfill the terms of the
    contract. This concludes the contract and reaches the end of its life cycle.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 假设双方家庭都同意了条款，合同仍有可能因其他情况而被撤回。假设合同继续进行，双方家庭随后行使并履行合同的条款。这标志着合同的结束，并结束了其生命周期。
- en: Physical view
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 物理视图
- en: The **physical view** focuses on the deployable software components and the
    interconnections between them. It is also called the **deployment view**. It is
    suitable for communication with system engineers, platform engineers, and infrastructure
    engineers.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**物理视图**关注可部署的软件组件及其之间的互连。它也被称为**部署视图**。它适合与系统工程师、平台工程师和基础设施工程师进行沟通。'
- en: 'Imagine that the ADR example we demonstrated in the previous chapter was approved.
    There is a central service to keep the master records of service exchange contracts.
    The physical view may look something like the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们在上一章中展示的 ADR 示例被批准了。有一个中心服务来保存服务交换合同的原始记录。物理视图可能看起来如下所示：
- en: '![Figure 2.3 – A 4+1 architecture view model – physical view](img/B21737_02_3.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – 4+1 架构视图模型 – 物理视图](img/B21737_02_3.jpg)'
- en: Figure 2.3 – A 4+1 architecture view model – physical view
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 4+1 架构视图模型 – 物理视图
- en: The software has been moved to a browser-based web application. Users access
    the system via a web browser as a client and submit requests for service. The
    load balancer is the first component to receive these requests and distribute
    them to the appropriate instance of the **Exchange service** based on the load
    of each instance. Any static content such as images is fetched from a web server.
    The **Exchange service** processes the request and persists the result in the
    **Relational database**.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 该软件已被移至基于浏览器的网络应用程序。用户通过网页浏览器作为客户端访问系统，并提交服务请求。负载均衡器是第一个接收这些请求并将它们根据每个实例的负载分配到适当的**交换服务**实例的组件。任何静态内容，如图像，都是从网络服务器获取的。**交换服务**处理请求并将结果持久化到**关系数据库**。
- en: Process View
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过程视图
- en: The **process view** focuses on the real-time behaviors of the system. It is
    usually close to the system’s operation, where internal employees or other systems
    are involved. It is useful in showcasing issues involving concurrency, performance,
    and scalability. This view facilitates communication among technical stakeholders.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程视图**关注系统的实时行为。它通常接近系统的操作，涉及内部员工或其他系统。它在展示涉及并发、性能和可扩展性的问题时很有用。这种视图促进了技术利益相关者之间的沟通。'
- en: UML diagrams such as sequence diagrams, interaction diagrams, activity diagrams,
    communication diagrams, and timing diagrams are useful to represent a process
    view. **Business Process Modeling and Notation** (**BPMN**) diagrams are also
    useful in describing how the system behaves in the context of business processes.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: UML图，如序列图、交互图、活动图、通信图和时序图，有助于表示过程视图。**业务流程建模与符号**（**BPMN**）图在描述系统在业务流程上下文中的行为时也非常有用。
- en: 'If the service contract exchange system has an email notification function,
    it may look like the figure that follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务合同交换系统具有电子邮件通知功能，它可能看起来像下面的图：
- en: '![Figure 2.4 – A 4+1 architecture view model – process view](img/B21737_02_4.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图2.4 – 4+1架构视图模型 – 流程视图](img/B21737_02_4.jpg)'
- en: Figure 2.4 – A 4+1 architecture view model – process view
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 – 4+1架构视图模型 – 流程视图
- en: When **Household A** submits a draft contract, the **Exchange service** validates
    the request and updates the corresponding records in the **Relational database**.
    Afterward, the **Exchange service** makes a call to the **Email service** to send
    an email notification to **Household B** for the service contract submitted by
    **Household A**.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当**家庭A**提交一份草稿合同时，**交易所服务**验证请求并更新**关系数据库**中相应的记录。之后，**交易所服务**调用**电子邮件服务**向**家庭B**发送关于由**家庭A**提交的服务合同的电子邮件通知。
- en: '**Household B**, in this case, is notified of the service contract in the email.
    Then **Household B** submits a request to agree to the contract terms to the **Exchange
    service**. The **Exchange service** then updates the records in the **Relational
    database**.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，**家庭B**通过电子邮件通知服务合同。然后**家庭B**向**交易所服务**提交请求，同意合同条款。随后，**交易所服务**更新**关系数据库**中的记录。
- en: Development view
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发视图
- en: The **development view** concentrates on software management. The target audience
    is programmers who are coding hands-on in the system.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**开发视图**专注于软件管理。目标受众是实际在系统中编码的程序员。'
- en: The view focuses on the static organization of the software in the development
    environment. This includes how multiple components collaborate to form a software
    system at various levels, such as packages of source code, call hierarchies from
    higher-order business functions to lower-level utility functions, inheritance
    hierarchies of classes, and dependency trees of software artifacts. The details
    of this view can be found in the source code repository.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 该视图侧重于开发环境中软件的静态组织。这包括多个组件如何在不同级别上协作形成一个软件系统，例如源代码包、从高级业务功能到低级实用功能的调用层次结构、类的继承层次结构和软件工件之间的依赖树。该视图的详细信息可以在源代码库中找到。
- en: UML package and component diagrams can be used to represent this view. An organized
    source code repository may find these diagrams redundant. However, these diagrams
    are good at highlighting any dependency issues between packages and modules.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: UML包和组件图可以用来表示这个视图。一个有组织的源代码库可能会发现这些图是多余的。然而，这些图擅长突出显示包和模块之间的任何依赖问题。
- en: 'The **Exchange service** in the service contract exchange system may be expressed
    in a UML package diagram, as in the figure that follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 服务合同交换系统中的**交易所服务**可能用UML包图表示，如下面的图所示：
- en: '![Figure 2.5 – A 4+1 architecture view model – development view](img/B21737_02_5.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5 – 4+1架构视图模型 – 开发视图](img/B21737_02_5.jpg)'
- en: Figure 2.5 – A 4+1 architecture view model – development view
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 – 4+1架构视图模型 – 开发视图
- en: 'The **Exchange service** has a business package that includes the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**交易所服务**有一个包含以下内容的业务包：'
- en: A module that controls the workflow of a service contract
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个控制服务合同工作流程的模块
- en: A module that master’s the records of households
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个掌握家庭记录的模块
- en: A module that searches the history of service contracts
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个搜索服务合同历史的模块
- en: The **Business** package uses the **Persistence** package to perform the actual
    relational database operations for service contracts and households.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**业务**包使用**持久化**包来执行服务合同和家庭的实际关系数据库操作。'
- en: The **Business** package has a dependency on the **Validation** package, which
    contains a few standalone validators for addresses, emails, dates, and service
    contracts.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**业务**包依赖于**验证**包，该包包含一些用于地址、电子邮件、日期和服务合同的独立验证器。'
- en: The **Integration** module is responsible for communicating with other services
    such as the **Email service**. This module is used by the **Business** module
    to notify households.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**集成**模块负责与其他服务（如**电子邮件服务**）进行通信。该模块由**业务**模块用于通知家庭。'
- en: Scenarios
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 场景
- en: In the 4+1 architecture view model, scenarios are represented by the *+1* because
    only important scenarios would be chosen to be documented. It focuses on user-system
    interactions and on how the system facilitates users in their workflow. It is
    often used in communication with users, both internal and external.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在4+1架构视图模型中，场景由*+1*表示，因为只有重要的场景会被选择进行文档记录。它侧重于用户与系统的交互以及系统如何帮助用户在他们的工作流程中。它通常用于与内部和外部用户的沟通。
- en: UML use case diagrams are used for scenarios. In the example of the service
    contract exchange system, the drafting and exercising of the service contract
    are selected use cases.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: UML用例图用于场景。在服务合同交换系统的例子中，选择了服务合同的起草和执行作为用例。
- en: '![Figure 2.6 – A 4+1 architecture view model – scenario](img/B21737_02_6.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图2.6 – 4+1架构视图模型 – 场景](img/B21737_02_6.jpg)'
- en: Figure 2.6 – A 4+1 architecture view model – scenario
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 – 4+1架构视图模型 – 场景
- en: '**Household A** submits a drafted contract to be reviewed by **Household B**.
    The contract can be amended before it is agreed to. Once the households agree
    to the contract terms, they exercise the service contract to completion.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**家庭A**提交一份待**家庭B**审查的合同。在达成一致之前，合同可以进行修改。一旦家庭就合同条款达成一致，他们就会执行服务合同直至完成。'
- en: We have discussed the 4+1 architecture view model, which visualizes the architecture
    of a system from at least five perspectives. Each perspective visualizes the system
    using different dimensions to highlight certain aspects at a time. Each view is
    useful in communicating with its own audience.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了4+1架构视图模型，该模型从至少五个角度可视化系统的架构。每个角度都使用不同的维度来突出显示一次的某些方面。每个视图都有其自身的受众，在沟通时非常有用。
- en: Next, we are going to explore system quality attributes, which can be used to
    describe, measure, and predict how well a system can perform.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨系统质量属性，这些属性可以用来描述、衡量和预测系统性能的好坏。
- en: System quality attributes
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 系统质量属性
- en: If there are two functionally identical systems, how might we compare and evaluate
    which system performs better? We can use system quality attributes to measure
    and compare the two systems.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有两个功能上完全相同的系统，我们如何比较和评估哪个系统表现更好？我们可以使用系统质量属性来衡量和比较这两个系统。
- en: System quality attributes exist independently of the business functions that
    the system provides. They are purely technical attributes that determine whether
    a system runs smoothly or not. The requirements to have certain system quality
    attributes are called **Non-Functional Requirements** (**NFRs**) or **Cross-Functional**
    **Requirements** (**CFRs**).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 系统质量属性独立于系统提供的业务功能存在。它们是纯粹的技术属性，决定了系统是否能够平稳运行。要求具有某些系统质量属性被称为**非功能性需求**（NFRs）或**跨功能需求**（CFRs）。
- en: It is important to differentiate between functional requirements and NFRs. Functional
    requirements define what the system does, while NFRs define how the requirements
    are fulfilled. Functional requirements specify the features of a system, while
    NFRs define its qualities, behaviors, and performance characteristics.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 区分功能需求和NFRs（非功能性需求）很重要。功能需求定义了系统做什么，而NFRs定义了如何满足这些需求。功能需求指定了系统的功能，而NFRs定义了其质量、行为和性能特征。
- en: 'There are many dimensions for system quality attributes. Here we will highlight
    several system quality attributes that we will cover in later chapters:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 系统质量属性有许多维度。在这里，我们将突出一些将在后续章节中涵盖的系统质量属性：
- en: '**Correctness**: This measures whether the system behaves as described in the
    specifications. This could be referred to as **Application Programming Interface**
    (**API**) documentation, operation manuals, or simply function contracts.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正确性**：这衡量系统是否按规格描述的行为。这可以被称为**应用程序编程接口**（API）文档、操作手册，或者简单地称为功能合同。'
- en: '**Availability**: This measures the uptime of the system or the time when it
    can operate and serve its purpose.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性**：这衡量的是系统的正常运行时间或它能够运行并执行其目的的时间。'
- en: '**Robustness**: This refers to the level of service the system can provide
    when the system has faulty parts and/or is under heavy traffic.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**鲁棒性**：这指的是系统在存在故障部分和/或面临重压时可以提供的服务水平。'
- en: '**Resilience**: This refers to how quickly the system can recover from faults,
    continue to operate, and bounce back from unexpected disruption to a fully functional
    state.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：这指的是系统从故障中恢复、继续运行并从意外中断中恢复到完全功能状态的速度。'
- en: '**Performance**: This measures how quickly the system can respond to requests
    and how many requests the system can process at a time.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：这衡量了系统响应请求的速度以及系统一次可以处理多少请求。'
- en: '**Scalability**: This measures how flexibly the system can scale to cope with
    changing the volume and latency requirements. It is the ability of the system
    to expand or shrink.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可伸缩性**：这衡量了系统如何灵活地扩展以应对变化的数据量和延迟要求。这是系统扩展或缩小的能力。'
- en: '**Observability**: This refers to how well the external view of the system
    helps us determine its internal state. The external view can be represented by
    log messages, charts, alerts, files, or the payload of a system remote call.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可观察性**：这指的是系统的外部视图如何帮助我们确定其内部状态。外部视图可以由日志消息、图表、警报、文件或系统远程调用的有效载荷表示。'
- en: '**Manageability**: This measures how easy it is to manage and control a system
    in terms of operations, monitoring, configuration, and administration.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可管理性**：这衡量了在操作、监控、配置和管理方面管理和控制系统的容易程度。'
- en: '**Maintainability**: This measures how easy it is to maintain a working system.
    This can include source code, updating infrastructure, modifying build pipelines,
    and tweaking environments.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可维护性**：这衡量了维护一个运行系统有多容易。这可能包括源代码、更新基础设施、修改构建管道和调整环境。'
- en: '**Extensibility**: This measures the ease of extending the current capability
    of the system to include new functions as the business grows. It includes the
    time, complexity, and effort required to modify and enhance the current system.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：这衡量了随着业务的增长，扩展当前系统功能以包括新功能的容易程度。它包括修改和增强当前系统所需的时间、复杂性和努力。'
- en: '**Testability**: This measures the extent to which tests can cover the functionality
    of the system. It is not limited to the business functions to be tested but also
    includes the assessment of other system quality attributes.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可测试性**：这衡量了测试可以覆盖系统功能程度的范围。它不仅限于要测试的业务功能，还包括对其他系统质量属性的评估。'
- en: '**Reusability**: This refers to the extent to which the individual components
    of the system can be reused for other purposes. This includes not only the software
    modules and source code but also the business functions and processes.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重用性**：这指的是系统的各个组件可以用于其他目的的程度。这不仅包括软件模块和源代码，还包括业务功能和流程。'
- en: '**Usability**: This translates to how good the user experience is while working
    with the system. It is not limited to end users who treat the system as a black
    box but also includes other stakeholders such as internal users, system operators,
    administrators, and programmers.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性**：这转化为与系统一起工作时用户体验有多好。它不仅限于将系统视为黑盒的最终用户，还包括其他利益相关者，如内部用户、系统操作员、管理员和程序员。'
- en: We have covered a few important system quality attributes that we will mention
    in later chapters. We are going to discuss the fundamental architecture principles
    that drive modern software architecture and help us improve current systems.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了一些重要的系统质量属性，这些属性将在后面的章节中提到。我们将讨论推动现代软件架构和帮助我们改进现有系统的基本架构原则。
- en: Separation of concerns, cohesiveness, and coupling
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**关注点分离**、**内聚性**和**耦合**'
- en: A system is composed of many components and the interconnections among them.
    The ability to group and separate elements in the system has become a crucial
    factor in ensuring it is maintainable, reusable, and extendable. We are going
    to cover three fundamental concepts that will help us group and separate elements
    appropriately, namely **separation of concerns**, **cohesiveness**, and **coupling**.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一个系统由许多组件及其相互之间的连接组成。在系统中分组和分离元素的能力已成为确保其可维护性、可重用性和可扩展性的关键因素。我们将介绍三个基本概念，这些概念将帮助我们适当地分组和分离元素，即**关注点分离**、**内聚性**和**耦合**。
- en: Separation of concerns
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**关注点分离**'
- en: Separation of concerns is a fundamental principle that we should apply in every
    corner of the system. It is a principle that advocates segregating the system
    into independent components and having each component address a specific concern.
    Separation of concerns aims at creating a system that is easier to maintain, reason,
    and update, and which can adapt to changes in requirements over time.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 关注点分离是一个我们应该在系统每个角落应用的基本原则。这是一个主张将系统分割成独立的组件，并让每个组件处理特定关注点的原则。关注点分离旨在创建一个更容易维护、推理和更新，并且能够适应随时间变化的需求的系统。
- en: 'Let us take the following scenario as an example: the submission of a draft
    service exchange contract from a household’s browser to **Exchange service** via
    **Representational State Transfer** (**REST**) with payload in the **JavaScript
    Object Notation** (**JSON**) format.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以以下场景为例：从家庭的浏览器提交草拟服务交换合同到**交换服务**，通过**表示状态转移**（**REST**）进行，有效载荷以**JavaScript对象表示法**（**JSON**）格式。
- en: The first concern will likely be to ensure that **Exchange service** only takes
    the correct information to create a draft service in the **Relational database**.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 首要关注点可能是确保**交换服务**只获取正确信息以在**关系数据库**中创建草拟服务。
- en: 'Within the correctness category, there are multiple levels:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在正确性类别中，存在多个级别：
- en: The request payload needs to conform to the agreed structure; otherwise, an
    HTTP `400` (Bad request) status should be returned.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求有效载荷需要符合约定的结构；否则，应返回 HTTP `400`（错误请求）状态。
- en: The services to be exchanged must not be empty; otherwise, an HTTP `400` (Bad
    request) status should be returned.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要交换的服务不能为空；否则，应返回 HTTP `400`（错误请求）状态。
- en: The households in the contract must already exist in the system records; otherwise,
    an HTTP `404` (Not found) status should be returned.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 合同中的家庭必须在系统记录中已存在；否则，应返回 HTTP `404`（未找到）状态。
- en: The household that submitted the draft contract must already have logged on;
    otherwise, an HTTP `401` (Unauthorized) status should be returned.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交草拟合同的该家庭必须已经登录；否则，应返回 HTTP `401`（未授权）状态。
- en: The household that submitted the draft contract must already have been verified;
    otherwise, an HTTP `403` (Forbidden) status should be returned.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交草拟合同的该家庭必须已经经过验证；否则，应返回 HTTP `403`（禁止）状态。
- en: If the request passes all validation checks and the contract persists, an HTTP
    `200` (OK) status should be returned with the payload of the persisted record.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果请求通过所有验证检查并且合同持续存在，则应返回带有持久化记录的有效载荷的 HTTP `200`（OK）状态。
- en: If the request passes all validation and the contract persists, the contract
    should be in the **Drafted** state.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果请求通过所有验证并且合同持续存在，则合同应处于**草拟**状态。
- en: The list goes on. However, we could see that, for example, the payload is at
    the syntactical level. Returned HTTP statuses, on the other hand, are at the contractual
    communication level, while being in the correct state is at a semantic level.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 列表还在继续。然而，我们可以看到，例如，有效载荷在句法层面。另一方面，返回的HTTP状态在合同通信层面，而处于正确状态是在语义层面。
- en: If a change addressing one concern for a part of the system is made without
    affecting the other concerns, then this change is aligned with the separation
    of concerns principle.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对系统某一部分的一个关注点的更改没有影响到其他关注点，那么这个更改与关注点分离原则是一致的。
- en: To be able to separate concerns when modifying a system, some parts of the system
    will need to be grouped together and other parts need to be separated.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要在修改系统时分离关注点，系统的一些部分需要分组在一起，而其他部分则需要分离。
- en: The degree to which the software elements within a component are closely related
    can be measured by cohesiveness. The degree of independence of each component
    can be measured by coupling.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一个组件内软件元素之间紧密相关的程度可以通过内聚性来衡量。每个组件的独立程度可以通过耦合度来衡量。
- en: Cohesiveness
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内聚性
- en: Software components that are strongly related to each other have a few properties.
    Firstly, they share similar responsibilities and most likely have a common objective.
    Secondly, if you change one component, it is likely that the rest of the components
    will require changes as well. Finally, they coordinate and cooperate in at least
    one manner. Chained function calls are examples of cohesive components.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与彼此紧密相关的软件组件具有一些属性。首先，它们承担相似的责任，并且很可能有一个共同的目标。其次，如果你更改一个组件，其余的组件可能也需要更改。最后，它们至少以一种方式协调和合作。链式函数调用是内聚组件的例子。
- en: Software components can be cohesive in the following ways.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 软件组件可以通过以下方式实现内聚。
- en: Horizontal cohesiveness
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 水平内聚
- en: Horizontally cohesive components are grouped together to provide features related
    to a certain implementation. For example, components related to integration with
    a particular external system are grouped together to separate the concerns of
    vendor-specific implementation from the functional behaviors that the system provides.
    In the case of reviewing vendor choices, engineers can replace this group of components
    with another group that targets a different vendor system. This cohesive approach
    supports a plug-and-play structure that is easy to maintain and understand.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 水平内聚组件被分组在一起，以提供与特定实现相关的功能。例如，与特定外部系统集成相关的组件被分组在一起，以将特定供应商的实现关注点与系统提供的功能行为分开。在审查供应商选择的情况下，工程师可以用针对不同供应商系统的另一组组件替换这个组件组。这种内聚方法支持易于维护和理解的即插即用结构。
- en: Vertical cohesiveness
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 垂直内聚
- en: Vertically cohesive components are grouped together based on the functional
    behaviors that they collectively provide. Vertical cohesiveness usually involves
    **encapsulation** of data and behaviors shared among components in the group.
    For example, components responsible for providing **Create, Read, Update, Delete**
    (**CRUD**) operations for managing households can be grouped together. This grouping
    provides clarity on how the system behaves. When the behaviors must be modified,
    engineers can focus on a small area and lower the risk of change.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直内聚组件根据它们共同提供的功能行为进行分组。垂直内聚通常涉及对组内组件共享的数据和行为进行**封装**。例如，负责为管理家庭提供**创建、读取、更新、删除**（**CRUD**）操作的组件可以分组在一起。这种分组清晰地说明了系统的行为。当必须修改行为时，工程师可以专注于一个小区域，从而降低更改的风险。
- en: Linear cohesiveness
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线性内聚
- en: Linearly cohesive components are grouped together due to the sequence of their
    execution or the flow of control. This could be manifested by chains of function
    calls or by a chained reaction of event communication. This grouping provides
    clarity and visibility for how smaller tasks or processes emerge into a larger
    workflow.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 线性内聚组件由于执行顺序或控制流的顺序而被分组在一起。这可以通过函数调用的链或事件通信的连锁反应来体现。这种分组为较小的任务或过程如何融入更大的工作流程提供了清晰性和可见性。
- en: Interactive cohesiveness
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 交互内聚
- en: Interactively cohesive components are grouped based on the frequency of communication
    and interaction patterns among them. For example, the HTTP service and the client
    library of a certain function are grouped under a project of different modules.
    When there is a change in communication protocol, engineers can find most of the
    necessary changes in one project. This reduces the cost and effort of making a
    change. It also keeps the change contained in one area.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 交互内聚组件根据它们之间通信和交互模式的频率进行分组。例如，某个函数的HTTP服务和客户端库被分组在具有不同模块的项目下。当通信协议发生变化时，工程师可以在一个项目中找到大部分必要的更改。这减少了更改的成本和努力。同时，它也确保更改被限制在一个区域内。
- en: 'Look at the example of household validation that follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个家庭验证的示例：
- en: '[PRE0]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A household has a name and a list of members. Each member has a few basic fields
    such as first and last names. A basic household validation would involve ensuring
    that the household name is not empty; moreover, it also requires that each person
    in the household passes the validation. For example, age cannot be a negative
    number.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一个家庭有一个名称和成员列表。每个成员都有一些基本字段，如名和姓。基本的家庭验证将涉及确保家庭名称不为空；此外，还需要确保家庭中的每个人都能通过验证。例如，年龄不能是负数。
- en: In this example, the validation of a household depends on the validation of
    a person in that household. The functions to validate both the household and the
    person are vertically cohesive because they behave as a validation feature in
    the form of a higher-order function. They are also linearly cohesive because the
    validation function of a household invokes the validation function of a person.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，一个家庭的验证依赖于该家庭中一个人的验证。验证家庭和个人的功能是垂直内聚的，因为它们以高阶函数的形式作为验证功能。它们也是线性内聚的，因为家庭的验证函数调用了个人的验证函数。
- en: High cohesiveness concentrates related components in one place. This illustrates
    the overall behavior of the components and makes the behavior easier to understand.
    It also promotes better testability as engineers can test the components’ overall
    behavior in one place. Keeping related components in one place also means fewer
    moving parts when making a change, which lowers risk. The overall behavior can
    be treated as one unit that other parts of the system can reuse.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 高内聚性将相关组件集中在一个地方。这说明了组件的整体行为，使得行为更容易理解。它还促进了更好的可测试性，因为工程师可以在一个地方测试组件的整体行为。将相关组件保持在同一个地方也意味着在做出更改时移动部件更少，这降低了风险。整体行为可以被视为一个单元，系统的其他部分可以重用它。
- en: On the other hand, low cohesiveness results in related components being scattered
    around, making them difficult to understand, modify, and maintain. It creates
    inappropriate coupling between components, making it riskier to make changes without
    affecting unrelated parts of the system. Attempting to modify one system quality
    attribute can result in the unintended effect of changing the others. You are
    also more likely to create bugs when making a change. It then becomes difficult
    to reuse the component as it brings dependencies that are unlikely to be suitable
    for the use case.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，低内聚性导致相关组件散布在各个地方，使得它们难以理解、修改和维护。它会在组件之间创建不适当的耦合，使得在不影响系统其他无关部分的情况下进行更改变得更加危险。试图修改一个系统的质量属性可能会意外地改变其他属性。在做出更改时，也更有可能创建错误。由于它带来了不太可能适合用例的依赖，因此修改组件变得难以重用。
- en: Coupling
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 耦合
- en: Coupling is a bad idea in the context of cohesiveness, but the measurement of
    coupling is not bad at all. It provides a view of how interdependent the software
    components in the system are.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在内聚性的背景下，耦合是一个坏主意，但耦合的测量却一点也不坏。它提供了系统中的软件组件之间相互依赖性的视图。
- en: Coupling is inevitable, but it can be minimized in a way that promotes better
    maintainability, reusability, and understanding. It is preferable to limit the
    interactions among components as much as possible.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 耦合是不可避免的，但可以通过一种促进更好的可维护性、可重用性和理解性的方式来最小化。尽可能限制组件之间的交互是更好的选择。
- en: Functional coupling
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 功能耦合
- en: To limit the interactions among components, we must separate what needs to be
    done from how to do it. In the previous example, the “what” is the validation
    of households including their members; the “how” is that the validation functions
    run through each field and add violated conditions to a list to be returned. The
    household is valid if the returned list is empty.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了限制组件之间的交互，我们必须区分需要做什么和如何做。在先前的例子中，“需要做什么”是验证包括其成员的家庭；“如何做”是验证函数通过每个字段运行，并将违反的条件添加到要返回的列表中。如果返回的列表为空，则家庭是有效的。
- en: The definition of the work performed by a software component is a contract between
    the provider and the invoker. It typically consists of an input, an optional state,
    and an output. The invoker is concerned with the input to supply and the output
    to receive, but not with what happens internally within the software component.
    On the other hand, the provider is concerned with how to compute the output and
    optionally update the state based on the given input.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 软件组件执行的工作的定义是提供者和调用者之间的合同。它通常包括一个输入、可选状态和一个输出。调用者关心提供输入和接收输出，但不关心软件组件内部发生的事情。另一方面，提供者关心如何根据给定的输入计算输出，并可选地更新状态。
- en: This contract is often referred to as an interface between the provider and
    the invoker. It gives a good foundation for loosely coupled software components.
    With the interaction of both parties centered around the interfaces, the invoker
    now has the flexibility to switch to a different provider who can fulfill the
    contract. The provider need not do anything extra for another invoker who wants
    to reuse this functionality.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这份合同通常被称为提供者和调用者之间的接口。它为松散耦合的软件组件提供了一个良好的基础。当双方的交互都围绕接口进行时，调用者现在可以灵活地切换到另一个能够履行合同的提供者。提供者无需为想要重用此功能的另一个调用者做任何额外的工作。
- en: This type of coupling is called **functional coupling**. It is based on the
    contracts or interfaces among software components.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这种耦合类型被称为**功能耦合**。它基于软件组件之间的合同或接口。
- en: Data coupling
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据耦合
- en: A software component may require the data that it shares with another to function
    properly. The ownership of data is a topic in itself. However, in a simple sense,
    if there is only one component that creates, updates, or deletes a category of
    data, then that component owns the data.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 软件组件可能需要与另一个组件共享的数据才能正常工作。数据所有权是一个独立的话题。然而，从简单意义上讲，如果只有一个组件创建、更新或删除一类数据，那么该组件就拥有这些数据。
- en: It is almost guaranteed that if more than one component owns the same piece
    of data, there will be a big problem in keeping the data reliable and consistent.
    In this situation, it is better for the two components to truly own their data.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎可以肯定，如果多个组件拥有相同的数据，那么在保持数据可靠性和一致性方面将出现重大问题。在这种情况下，两个组件真正拥有自己的数据会更好。
- en: 'There are several options to consider:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个选项可以考虑：
- en: Should the components that share the same data be merged into one component?
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否应该将共享相同数据的组件合并为一个组件？
- en: Can the ownership of the data be split among the components so they no longer
    share the same data?
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据的所有权是否可以分散到各个组件中，使它们不再共享相同的数据？
- en: Can a new component be extracted to own the data, while other components become
    the listeners of the data change?
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否可以提取一个新的组件来拥有数据，而其他组件成为数据变化的监听者？
- en: Should one of the components take all the responsibility of creating, updating,
    and deleting the data, effectively becoming the owner of the data? This would
    mean that the other components become the listeners of the data change.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否应该由一个组件承担创建、更新和删除数据的全部责任，从而成为数据的所有者？这将意味着其他组件成为数据变化的监听者。
- en: Should each component own a copy of the data and let each copy be diverse in
    each component?
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否每个组件都应该拥有数据的副本，并让每个副本在每个组件中都是多样化的？
- en: Can each component keep a separate copy of the data owned by another component
    while there are reconciliation processes in place to process the difference?
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在有差异处理流程的情况下，每个组件是否可以保留另一个组件拥有的数据的独立副本？
- en: Given that a software component can own the data, it is important for the component
    to decide how much of the data should be exposed externally. The component should
    encapsulate the data to hide any internal data and only expose the fields that
    are related to the interface to other components.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于软件组件可以拥有数据，因此对于组件来说，决定应该对外暴露多少数据非常重要。组件应该封装数据以隐藏任何内部数据，并且只向其他组件暴露与接口相关的字段。
- en: Moreover, it is often useful to separate the internal and external representations
    of the data. For instance, a list of internal error enumeration values may contain
    information that exposes the internal state of the component unintentionally.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通常很有必要将数据的内部和外部表示分开。例如，一个包含内部错误枚举值的列表可能包含无意中暴露组件内部状态的信息。
- en: 'For example, given that there are several internal error enumeration values
    for a log-on operation, then the Kotlin enum class would look like the following
    code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设有一个登录操作有多个内部错误枚举值，那么 Kotlin 枚举类将如下所示：
- en: '[PRE1]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If we expose all these values externally, the invoker of the component will
    be able to understand whether a username exists even if the log-on operation failed,
    or if both were valid but failed the captcha challenge. These are unnecessary
    details to the outside of the component and should be hidden. This is without
    mentioning the obvious security concern that is also at play. So, we could create
    a list of external error enumeration values to only show what is of interest to
    the invoker:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们公开所有这些值，组件的调用者将能够理解即使登录操作失败，用户名是否存在，或者两者都有效但验证码挑战失败。这些对于组件的外部来说是不必要的细节，应该被隐藏。这还不包括显然的安全问题。因此，我们可以创建一个外部错误枚举值列表，只显示对调用者感兴趣的内容：
- en: '[PRE2]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Temporal coupling
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时间耦合
- en: 'Two software components can be temporally coupled if they both need to be available
    for the whole operation to run through. Component A might need to invoke a synchronous
    remote call to component B to continue to handle its incoming requests, for example.
    An even worse situation would be a chain of multiple remote cascading calls to
    multiple components. An example of temporally coupled components is described
    in the UML sequence diagram that follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个软件组件都需要在整个操作过程中都可用，它们就可以在时间上耦合。例如，组件 A 可能需要调用组件 B 的同步远程调用来继续处理其传入的请求。更糟糕的情况是多个组件之间的多个远程级联调用链。以下
    UML 时序图中描述了时间耦合组件的例子：
- en: '![Figure 2.7 – A Synchronous pull interaction](img/B21737_02_7.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.7 – 同步拉取交互](img/B21737_02_7.jpg)'
- en: Figure 2.7 – A Synchronous pull interaction
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 – 同步拉取交互
- en: Each time a synchronous call is made, it blocks the thread until there is an
    answer returned or until it times out. This is also called the **pull-based**
    approach. If we had multiple of these calls, it would be quite easy to cause a
    timed-out error to the original request.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 每次进行同步调用时，它都会阻塞线程，直到返回答案或超时。这也被称为**基于拉取**的方法。如果我们有多个这样的调用，很容易导致原始请求超时错误。
- en: Synchronous remote calls have the nature of blocking the thread, pulling data,
    and depending on the component’s availability. There are cases where synchronous
    remote calls may be necessary due to time sensitivity, such as when the service
    must authenticate a user within a given number of seconds or time out.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 同步远程调用具有阻塞线程、拉取数据和依赖于组件可用性的特性。在某些情况下，由于时间敏感性，同步远程调用可能是必要的，例如当服务必须在给定秒数或超时时间内验证用户时。
- en: 'If all the synchronous remote calls are only there to provide data, then we
    can consider an asynchronous and **push-based** approach. Using this approach,
    component A subscribes to a topic whereby component B publishes an event when
    the data changes. Component A then keeps a copy of the data locally. Then component
    A no longer requires component B to be available to handle requests; component
    A uses the last known value instead. An example of asynchronous push interactions
    among components is illustrated as a UML sequence diagram in *Figure 2**.8*:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有的同步远程调用只是为了提供数据，那么我们可以考虑异步和**基于推送**的方法。使用这种方法，组件 A 订阅了一个主题，当数据发生变化时，组件 B
    会发布一个事件。然后组件 A 在本地保留数据的副本。这样，组件 A 就不再需要组件 B 可用来处理请求；组件 A 使用最后已知的值。组件之间异步推送交互的例子如图
    *图 2.8* 所示：
- en: '![Figure 2.8 – An asynchronous push interaction](img/B21737_02_8.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.8 – 异步推送交互](img/B21737_02_8.jpg)'
- en: Figure 2.8 – An asynchronous push interaction
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8 – 异步推送交互
- en: 'If the interaction between components A and B is more procedural and sequential,
    then the components can still be loosely coupled by being reactive and asynchronous
    using events. In this scenario, component A has processed up to the point where
    it needs component B, so component A sends an event, and component B receives
    it. Then component B performs the work. When component B finishes its part, it
    sends an event that component A receives. Component A then continues the rest
    of the work. An example of the asynchronous reactive event-driven interaction
    among components can be expressed by a UML sequence diagram as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果组件 A 和 B 之间的交互更程序化和顺序化，那么通过使用事件进行反应性和异步操作，组件仍然可以松散耦合。在这种情况下，组件 A 已经处理到需要组件
    B 的点，因此组件 A 发送一个事件，组件 B 接收它。然后组件 B 执行工作。当组件 B 完成其部分时，它发送一个事件，组件 A 接收。然后组件 A 继续剩余的工作。组件之间异步反应事件驱动的交互可以通过以下
    UML 时序图表示：
- en: '![Figure 2.9 – An asynchronous reactive event-driven interaction](img/B21737_02_9.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图2.9 – 异步反应式事件驱动交互](img/B21737_02_9.jpg)'
- en: Figure 2.9 – An asynchronous reactive event-driven interaction
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 – 异步反应式事件驱动交互
- en: We have discussed the principles of separation of concerns, cohesiveness, and
    coupling. We went through why they are important and how the application of these
    concepts affects system quality attributes. We also covered the sub-categories
    of cohesiveness and coupling with real-time world examples. They are three different
    concepts but relate to each other often.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了关注点分离、内聚性和耦合性的原则。我们探讨了它们为什么重要以及这些概念的应用如何影响系统质量属性。我们还通过实时世界的实例介绍了内聚性和耦合性的子类别。它们是三个不同的概念，但常常相互关联。
- en: Next, we are going to cover the **SOLID principles**. These principles encourage
    software architecture with separate concerns, highly cohesive components, and
    low coupling between components.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍**SOLID原则**。这些原则鼓励具有分离关注点、高度内聚组件和组件之间低耦合的软件架构。
- en: SOLID principles
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOLID原则
- en: The SOLID principles are a set of five software architecture principles that
    advocate for creating maintainable, understandable, flexible, and modular software.
    Though they were originally targeted at object-oriented software, the concepts
    behind them are useful and can be applied to systems other than object orientation.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID原则是一组五个软件架构原则，主张创建可维护、可理解、灵活和模块化的软件。尽管它们最初是针对面向对象软件的，但它们背后的概念是有用的，并且可以应用于除面向对象以外的系统。
- en: These concepts were first introduced by Robert J. Martin in his *Design Principles
    and Design Patterns* paper in 2000\. However, the SOLID acronym was introduced
    later by Michael Feathers.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这些概念最初由Robert J. Martin在2000年的论文《设计原则和设计模式》中提出。然而，SOLID缩写是由Michael Feathers后来引入的。
- en: 'The acronym SOLID stands for the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 缩写SOLID代表以下内容：
- en: '**Single Responsibility** **Principle** (**SRP**)'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一职责** **原则** （**SRP**）'
- en: '**Open-Closed** **Principle** (**OCP**)'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开闭** **原则** （**OCP**）'
- en: '**Liskov Substitution** **Principle** (**LSP**)'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**里氏替换** **原则** （**LSP**）'
- en: '**Interface Segregation** **Principle** (**ISP**)'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口隔离** **原则** （**ISP**）'
- en: '**Dependency Inversion** **Principle** (**DIP**)'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖倒置** **原则** （**DIP**）'
- en: We will walk through each of them and use the concepts that we have covered
    for discussion.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐一介绍它们，并使用我们已讨论的概念进行讨论。
- en: SRP
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SRP
- en: The SRP states that a class should have one responsibility or concern, and only
    one. There is only one reason to change. If a class conforming to this principle
    has a clear and well-defined purpose and it is then easier to understand, test,
    and maintain, it can be counted as an exception.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: SRP指出，一个类应该有一个责任或关注点，只有一个。只有一个变化的原因。如果一个符合这个原则的类有一个清晰和明确的目的，那么它更容易理解、测试和维护，这可以被视为一个例外。
- en: 'Let us have a look at a class that violates the SRP:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个违反SRP的类：
- en: '[PRE3]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `HouseholdService` interface is responsible for creating a household, drafting
    a contract, and notifying the households involved in a contract. This class can
    change due to a change in any one of these operations.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`HouseholdService`接口负责创建家庭、起草合同以及通知参与合同的家庭。这个类可能会因为这些操作中的任何一个发生变化而改变。'
- en: 'We can refactor the example to conform to SRP:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将示例重构以符合SRP：
- en: '[PRE4]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now `HouseholdService` is only responsible for managing households. The `ContractService`
    interface is solely responsible for drafting a contract. `NotificationService`
    only aims to notify the households involved in a contract. Now each class only
    has one responsibility and one reason to change.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`HouseholdService`只负责管理家庭。`ContractService`接口仅负责起草合同。`NotificationService`仅旨在通知参与合同的家庭。现在每个类只有一个责任和一个变化的原因。
- en: There are a few more benefits that come with this change. Each class is now
    more testable, easier to understand, and easier to maintain. Each class can evolve
    and extend its functions independently. A concern in a single class can be addressed
    without impacting the others. Other classes can also reuse one of these classes
    easily without pulling in some never-to-be-used functions.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这种变化带来了一些额外的益处。现在每个类都更容易测试、更容易理解和维护。每个类可以独立地发展和扩展其功能。单个类中的一个关注点可以解决，而不会影响其他类。其他类也可以轻松地重用这些类中的一个，而不会引入一些永远不会使用的功能。
- en: OCP
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OCP
- en: The OCP states that software components such as classes, modules, and functions
    should be open for extension but closed for modification.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: OCP 声明，软件组件如类、模块和函数应该是可扩展的，但对修改是封闭的。
- en: A component is *open* if its behaviors can be extended without modifying the
    existing code. A highly cohesive component already contains all strongly related
    elements, so an extension of the behavior only needs to use what is already provided
    and does not need to modify the code inside.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一个组件是*开放的*，如果其行为可以在不修改现有代码的情况下进行扩展。一个高度内聚的组件已经包含了所有紧密相关的元素，因此行为的扩展只需要使用已经提供的内容，而不需要修改内部的代码。
- en: A component is *closed* if it can be used by other components. We should be
    able to modify the implementation without changing the behaviors. A loosely coupled
    component offers a simple and straightforward way for it to be used by other components
    without pulling in dependencies that others may not wish to include.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一个组件是*封闭的*，如果它可以被其他组件使用。我们应该能够修改实现而不改变行为。一个松耦合的组件提供了一个简单直接的方式，使其可以被其他组件使用，而不会引入其他可能不希望包含的依赖项。
- en: 'In the following example, there is a `NotificationService` that notifies households
    of the status of the contract in which they are involved:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，存在一个`NotificationService`，它会通知涉及合同的住户合同的状态：
- en: '[PRE5]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We have an interface that defines a `notifyHouseholds(contract: Contract)`
    function. `SmsNotificationService` and `EmailNotificationService` are concrete
    implementations of the interface.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '我们有一个定义了`notifyHouseholds(contract: Contract)`函数的接口。`SmsNotificationService`和`EmailNotificationService`是这个接口的具体实现。'
- en: If we want to extend the behavior by adding a new medium of communication, such
    as phone app notifications, we can create a new concrete implementation without
    modifying any existing code. This interface is *open* for extension.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要通过添加新的通信方式来扩展行为，例如电话应用通知，我们可以创建一个新的具体实现，而不需要修改任何现有代码。此接口对扩展是*开放的*。
- en: We can reuse this interface in other situations where we need to notify households
    about their contract. We can update the way in which `EmailNotificationService`
    is authenticated with the **Simple Mail Transfer Protocol** (**SMTP**) server
    without changing the interface. This interface is *closed* for modification.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在其他需要通知住户关于其合同的情况中重用此接口。我们可以更新`EmailNotificationService`与**简单邮件传输协议**（**SMTP**）服务器的认证方式，而不改变接口。此接口对修改是*封闭的*。
- en: LSP
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LSP
- en: The LSP states that the objects of a superclass can be replaced by objects of
    its subclasses with no change in the correction of the system.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: LSP 声明，超类中的对象可以被其子类的对象替换，而不会改变系统的修正。
- en: In other words, all subclasses should behave functionally identically to their
    superclasses.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，所有子类都应该在功能上与其超类行为相同。
- en: From the previous example, `NotificationService` specifies that the `notifyHouseholds`
    function would notify the households involved in the given contract. From a behavioral
    function point of view, it can do this via emails, text messages, or any other
    ways of communication. However, all these subclasses should notify the households
    that are involved in the given contract.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的示例中，`NotificationService`指定了`notifyHouseholds`函数将通知给定合同中的住户。从行为函数的角度来看，它可以通过电子邮件、短信或任何其他通信方式来完成。然而，所有这些子类都应该通知给定合同中的住户。
- en: 'On the contrary, if there is a `PhoneNotificationService` that not only notifies
    households involved in a contract but also updates the contract status to `UNDER_REVIEW`,
    it would violate the LSP. This is because if `EmailNotificationService` is replaced
    by `PhoneNotificationService`, the contract status will be updated, which would
    not happen before the replacement:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果存在一个`PhoneNotificationService`，它不仅通知参与合同的住户，还将合同状态更新为`UNDER_REVIEW`，这将违反LSP。这是因为如果用`PhoneNotificationService`替换`EmailNotificationService`，合同状态将被更新，而这种情况在替换之前是不会发生的：
- en: '[PRE6]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If we adhere to the LSP, then we will have classes that are highly cohesive,
    as it only focuses on classes being behaviorally equivalent to their superclasses
    and nothing else.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们遵守LSP，那么我们将拥有高度内聚的类，因为它只关注类在行为上与其超类等效，而不关注其他方面。
- en: ISP
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ISP
- en: The ISP states that clients should not be forced to depend upon interfaces that
    they do not use.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ISP 声明，客户端不应该被迫依赖于他们不使用的接口。
- en: 'This principle promotes that interfaces should be designed to be specific to
    the needs of the clients that use them. This could result in a few outcomes:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则提倡接口应该针对使用它们的客户端的需求进行设计。这可能导致以下几种结果：
- en: '**Small and numerous interfaces**: The interface is small, so the clients do
    not need to depend on functions from an interface that they do not use. Since
    each interface is smaller, there are likely to be more interfaces to cover the
    same scope of functionalities.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**小而多的接口**：接口很小，因此客户端不需要依赖于他们未使用的接口中的功能。由于每个接口都较小，因此可能存在更多的接口来覆盖相同的功能范围。'
- en: '**Relevance**: The interface is relevant and specific to the needs of the clients.
    Different clients may have unique needs. Therefore, there may be a few specific
    interfaces for different clients. There may be an overlap of functionalities and
    some clients may want unique behaviors that are only relevant to them for different
    clients.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**相关性**：接口是相关且针对客户端需求的。不同的客户端可能有独特的需求。因此，可能存在几个特定于不同客户端的特定接口。可能存在功能重叠，并且一些客户端可能希望有独特的行为，这些行为只与他们相关。'
- en: '**Higher cohesiveness**: Each interface shall contain only related functions
    and ideally focus on one responsibility.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更高的内聚性**：每个接口应只包含相关的功能，并且理想情况下专注于一个职责。'
- en: '**Looser coupling**: Since the interfaces are smaller, the coupling with other
    components is also looser.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**松耦合**：由于接口较小，与其他组件的耦合也更松。'
- en: 'This is an example of a violation of the ISP:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个违反ISP的例子：
- en: '[PRE7]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `Human` interface has two functions: `logOn` and `exerciseContract`. There
    are two concrete implementations: `User` and `HouseholdMember`. While both users
    and household members are human, they have nothing in common functionally. Both
    subclasses were forced to implement functions that they had no use for. The interface
    should be segregated so that they are specifically targeted toward the functions
    for users and household members.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`Human`接口有两个功能：`logOn`和`exerciseContract`。有两个具体的实现：`User`和`HouseholdMember`。虽然用户和家庭成员都是人类，但在功能上他们没有任何共同点。这两个子类被迫实现了他们不需要的功能。接口应该被分离，以便它们专门针对用户和家庭成员的功能。'
- en: DIP
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DIP
- en: 'The DIP consists of two parts:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: DIP包含两个部分：
- en: High-level components should not depend on low-level components directly. Both
    should depend on abstractions.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 高级组件不应该直接依赖于低级组件。两者都应依赖于抽象。
- en: Abstractions should not depend on details; details should depend on abstractions.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 抽象不应当依赖于细节；细节应当依赖于抽象。
- en: Abstractions can be referred to as interfaces and details can be referred to
    as concrete implementations. The rationale behind the principle is that the user
    of a component should only care about the behaviors of the component, not its
    implementation.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象可以指代接口，而细节可以指代具体的实现。这个原则背后的逻辑是，组件的使用者应该只关心组件的行为，而不是其实现。
- en: For example, if we want to reuse the component that notifies the households
    involved in a contract in a workflow, then the principle suggests that we reference
    the component as the `NotificationService` type, even if we know that `EmailNotificationService`
    is the concrete implementation.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想在工作流中重用通知参与合同的家庭的组件，那么这个原则建议我们将该组件引用为`NotificationService`类型，即使我们知道`EmailNotificationService`是具体的实现。
- en: 'This approach brings a few benefits:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法带来了一些好处：
- en: The `NotificationService` interface can be mocked or replaced by a `EmailNotificationService`.
    Our unit tests focus on how to interact with `NotificationService`, handling several
    types of outcomes from the `notifyHouseholds` function.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NotificationService`接口可以被模拟或替换为`EmailNotificationService`。我们的单元测试关注的是如何与`NotificationService`交互，处理`notifyHouseholds`函数的几种类型的输出。'
- en: The dependency on `NotificationService` can be injected or looked up at runtime.
    This gives us the flexibility to swap it with a different concrete implementation
    and have the function still run correctly. An **Inversion of Control** (**IoC**)
    container framework can support the implementation of the injection.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`NotificationService`的依赖可以在运行时注入或查找。这给了我们灵活性，可以将其与不同的具体实现交换，并且功能仍然可以正确运行。一个**控制反转**（**IoC**）容器框架可以支持注入的实现。
- en: Coupling with `NotificationService` is loosened to only care about the behaviors.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与`NotificationService`的耦合被放松，只关注行为。
- en: The code is easier to maintain as swapping the concrete implementation of `NotificationService`
    requires no code changes.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于交换`NotificationService`的具体实现不需要代码更改，代码更容易维护。
- en: It is easier to extend `NotificationService` by providing a different concrete
    implementation.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过提供不同的具体实现，更容易扩展`NotificationService`。
- en: 'Let us look at the ensuing example and see whether it adheres to the DIP:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看接下来的例子，看看它是否遵循DIP：
- en: '[PRE8]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`ContractWorkflowService` has a function to mark a contract as `agreed`. After
    the contract is agreed to, it invokes `EmailNotificationService` to notify households
    about the agreement. However, `ContractWorkflowService` uses the function from
    the interface `NotificationService` and not the subclass.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContractWorkflowService`有一个标记合同为`agreed`的函数。合同达成一致后，它调用`EmailNotificationService`通知家庭关于协议。然而，`ContractWorkflowService`使用接口`NotificationService`的函数，而不是子类。'
- en: There is no need for `ContractWorkflowService` to reference the concrete implementation
    as the service does not concern itself with whether the notification is sent via
    email or another channel. This is a violation of the DIP.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 没有必要让`ContractWorkflowService`引用具体实现，因为该服务不关心通知是通过电子邮件还是其他渠道发送。这是违反DIP的。
- en: The Law of Demeter
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**迪米特法则**'
- en: The **Law of Demeter**, or the principle of least knowledge, states that a software
    component should have limited knowledge about the inner details of other components.
    More specifically, a component should not know about the internal details of another
    component.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**迪米特法则**，或最小知识原则，指出软件组件应该对其他组件的内部细节了解有限。更具体地说，一个组件不应该了解另一个组件的内部细节。'
- en: 'Let us say there is a function that returns the city in the address of a person:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个函数返回人的地址中的城市：
- en: '[PRE9]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `Person` class directly accesses the `city` property inside the `Address`
    class. The `Person` class should not have this knowledge, as this is a violation
    of the **Law** **of Demeter**.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person`类直接访问`Address`类内部的`city`属性。`Person`类不应该拥有这种知识，因为这违反了**迪米特法则**。'
- en: This creates a coupling between `Person` and `Address`. The coupling dictates
    that if the `city` property changes its data type, then both classes will need
    to change. It also means that the code change is bigger than it needs to be, hence
    making it less maintainable and testable.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这在`Person`和`Address`之间创建了一种耦合。耦合规定，如果`city`属性的数据类型发生变化，那么两个类都需要更改。这也意味着代码更改比必要的更大，因此使其更难以维护和测试。
- en: To conform to the Law of Demeter, the `getAddressCity` function should be provided
    by the `Address` class. This reduces the responsibility of the `Person` class
    for getting the city of an address and thereby reduces the complexity of the code
    base.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了符合迪米特法则，`getAddressCity`函数应由`Address`类提供。这减少了`Person`类获取地址城市的责任，从而降低了代码库的复杂性。
- en: YAGNI and future-proof architecture
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: YAGNI和未来证明架构
- en: '**You Ain’t Gonna Need It** **(YAGNI**) is a principle that states that functionalities
    should not be implemented until they are needed. This principle came from **Extreme
    Programming** (**XP**) as an approach to improve software quality and respond
    to changing business requirements.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**YAGNI（你不会需要它）**是一个原则，它指出功能不应该在需要之前实现。这个原则来源于**极限编程（XP**）作为提高软件质量和应对不断变化业务需求的方法。'
- en: This principle is also related to the idea of minimalism in software development,
    which states that we should avoid unnecessary code and complexity in exchange
    for clean, easy-to-understand, and extensible software.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则也与软件开发中的极简主义思想相关，它指出我们应该避免不必要的代码和复杂性，以换取干净、易于理解且可扩展的软件。
- en: Another way to describe YAGNI is as the imperative to do the simplest thing
    that works. This is by no means an incomplete design or unfulfilled user requirement.
    It still promotes complete and functional software that satisfies user requirements
    with the simplest design available.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种描述YAGNI的方式是作为执行最简单可行事情的命令。这绝对不是不完整的设计或未满足的用户需求。它仍然促进完整且功能齐全的软件，以最简单的可用设计满足用户需求。
- en: 'YAGNI aims at a few practices:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: YAGNI旨在以下实践：
- en: '**Simple and lean code base**: By implementing only what is necessary now,
    a lot of complexity can be avoided. As a result, the code base is simple, clean,
    and maintainable.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单且精简的代码库**：通过只实现当前必要的功能，可以避免很多复杂性。因此，代码库简单、干净且易于维护。'
- en: '**Prevention of over-engineering**: Over-engineering happens when an engineer
    anticipates future requirements and includes unused features in the system. It
    not only results in wasted time on unnecessary work but also becomes a dead weight
    in the code base, which is then made harder to maintain. Over-engineered code
    also implies a design choice made before there is sufficient information to make
    that choice, locking in the approach prematurely.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过度工程预防**：过度工程发生在工程师预测未来需求并在系统中包含未使用的功能时。这不仅导致在非必要工作上浪费了时间，而且成为代码库中的累赘，使得维护变得更加困难。过度设计的代码还意味着在做出选择之前，没有足够的信息来做出那个选择，过早地锁定了一种方法。'
- en: '**Adaptive and flexible implementation**: By delaying the implementation of
    a feature until it is needed, engineers have more options to adapt to changes
    when the feature is finally needed. It also encourages a more organic evolution
    of the system whereby engineers respond more effectively to changing requirements.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自适应和灵活的实施**：通过推迟功能的实施直到需要时，工程师在功能最终需要时有了更多的选择来适应变化。这也鼓励系统进行更有机的进化，工程师能够更有效地响应不断变化的需求。'
- en: '**Productivity**: By focusing on the absolute must-have requirements, engineers
    can deliver changes more quickly and efficiently. Any unnecessary features can
    be postponed, saving time and resources.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生产力**：通过关注绝对必需的需求，工程师可以更快、更有效地交付变更。任何不必要的功能都可以推迟，节省时间和资源。'
- en: 'There is also an opposite idea though: **future-proof architecture**. It aims
    at creating systems that are unlikely to be obsolete or to fail in the future.
    This sounds very appealing. If we can build a system that can fulfill future requirements,
    we will have saved time and effort that would otherwise be spent continuously
    evolving it.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然也有相反的观点：**未来证明的架构**。它旨在创建不太可能在未来过时或失败的系统。这听起来非常吸引人。如果我们能够构建一个能够满足未来需求系统，我们将节省那些本可以用来不断进化系统的宝贵时间和精力。
- en: However, there is an assumption behind this. You need to predict the new requirements
    and you need to be right. That is equivalent to knowing the future. It rarely
    happens.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这背后有一个假设。你需要预测新的需求，并且你需要预测正确。这相当于知道未来。这种情况很少发生。
- en: If you are certain about requiring a feature in the future, then it is neither
    a prediction nor a future requirement. It is simply a requirement now.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确信将来需要某个功能，那么这既不是预测也不是未来的需求。这只是一个现在的需求。
- en: This does not mean that we should build systems based on short-term objectives
    or take shortcuts. Instead, we should build systems that are ready to adapt to
    new requirements but not have these implemented.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着我们应该基于短期目标或走捷径来构建系统。相反，我们应该构建能够适应新需求的系统，但不要立即实现这些需求。
- en: '**Capacity planning** should not be mistaken for future-proof architecture.
    Capacity planning is an operational concern related to deployment and physical
    resources. For instance, building a road to handle twice the current traffic is
    different from building a branch of the road that goes nowhere. Leaving headroom
    for expansion, extra volume, and extra traffic is part of the readiness for evolution.
    Capacity planning is an NFR, not a future requirement. We would not want the system
    to run on edges that may collapse in response to a fluctuation in the volume of
    requests.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**容量规划**不应被误解为未来证明的架构。容量规划是与部署和物理资源相关的运营问题。例如，建造一条可以处理当前交通量两倍的道路与建造一条没有去处的道路分支不同。为扩展、额外容量和额外交通留出空间是进化准备的一部分。容量规划是一个非功能性需求（NFR），而不是未来的需求。我们不希望系统在可能因请求量波动而崩溃的边缘运行。'
- en: This mindset leads to a few outcomes. The software architecture aims for modular,
    extensible, and flexible components that are ready to make changes when they become
    necessary.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这种心态导致了一些结果。软件架构旨在实现模块化、可扩展和灵活的组件，这些组件在必要时可以做出改变。
- en: It implies that each component is highly cohesive but loosely coupled. It means
    that interfaces are small and specific. It also means that interactions among
    components are based on abstract interfaces and not concrete implementations.
    It further means that subclasses conform to the behaviors of their superclasses
    and are ready to be extended. Furthermore, it means that each component has only
    one reason to change. It also means that modifying a component does not require
    recompiling the entire system. It also means that concerns are separated so that
    when we want to adjust system quality attributes, we can address the particular
    concern in isolation.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着每个组件具有高度的内聚性但耦合性较弱。这意味着接口小且具体。这也意味着组件之间的交互基于抽象接口而不是具体实现。进一步来说，这意味着子类符合其超类的行为，并准备好进行扩展。此外，这意味着每个组件只有一个改变的理由。这也意味着修改组件不需要重新编译整个系统。这也意味着关注点被分离，这样当我们想要调整系统质量属性时，我们可以单独处理特定的关注点。
- en: Summary
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have covered the 4+1 architecture view model, as well as system quality attributes,
    separation of concerns, cohesiveness, coupling, the SOLID principles, and the
    Law of Demeter. We have demonstrated them with code examples. These demonstrated
    that adhering to these principles lets the code become modular, flexible, maintainable,
    extensible, and easy to understand.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了4+1架构视图模型，以及系统质量属性、关注点分离、内聚性、耦合性、SOLID原则和迪米特法则。我们通过代码示例演示了这些原则。这些示例表明，遵循这些原则可以使代码变得模块化、灵活、易于维护、可扩展且易于理解。
- en: We have also discussed the conflicting concepts of the YAGNI principle and future-proof
    architecture. We clarified what future-proofing is and how it is different from
    capacity planning.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了YAGNI原则和未来兼容架构的冲突概念。我们阐明了什么是未来兼容性以及它与容量规划的差异。
- en: In the next chapter, we will explore polymorphism and its alternative approaches.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨多态及其替代方法。
