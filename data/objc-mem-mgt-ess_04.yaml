- en: Chapter 4. Object Creation and Storage
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：对象创建和存储
- en: In this chapter, we will cover objects and classes in more depth, showing the
    mechanisms behind their creation, handling, and customization.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更深入地探讨对象和类，展示它们创建、处理和定制的机制。
- en: 'We will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Object creation and initialization
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象创建和初始化
- en: Object immutability
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象不可变性
- en: Object mutability
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象可变性
- en: Object inheritance
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象继承
- en: Convenience initializers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 便利初始化器
- en: The singleton pattern
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例模式
- en: Using @property
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 @property
- en: Types of classes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类的类型
- en: Custom methods
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义方法
- en: Format specifiers
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式说明符
- en: Creation and initialization of objects
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象的创建和初始化
- en: For a developer, building iOS and OS X applications requires a lot of time in
    creating and handling objects. In Objective-C, like any other object-oriented
    programming language, the object acts like a data package with predefined behaviors.
    We can think about an application as an environment containing objects that connect
    with each other, passing and receiving information such as how to build a graphical
    interface, how to proceed with user interactions, how and where to store and take
    data from, how to perform calculations, and much more. The complexity of tasks
    that can be performed by an object can be very large, but it's not reflected on
    the complexity to create an object.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发者来说，构建 iOS 和 OS X 应用程序需要在创建和处理对象上花费大量时间。在 Objective-C 中，像任何其他面向对象编程语言一样，对象就像一个具有预定义行为的数据包。我们可以将应用程序视为一个包含对象的
    环境，这些对象相互连接，传递和接收信息，例如如何构建图形界面、如何处理用户交互、如何以及在哪里存储和获取数据、如何执行计算等等。对象可以执行的任务的复杂性可能非常大，但这并不反映在创建对象的复杂性上。
- en: Cocoa (for OS X) and Cocoa Touch (iOS) already provide a library containing
    an extensive list of objects for you to use as they are or create your own objects
    based on them—we call it code reuse.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Cocoa（用于 OS X）和 Cocoa Touch（iOS）已经提供了一个库，其中包含了一个广泛的对象列表，您可以将其直接使用或基于它们创建自己的对象——我们称之为代码重用。
- en: One of the most important development processes is thinking about the app base
    structure, when you decide which object to use, combine, customize, how they will
    communicate in order to generate the expected output, and so on. Some of them
    are provided by Cocoa and Cocoa Touch for immediate use such as NSString, NSArray,
    NSDictionary, UIView, and UILabel, but such importance is due to others who might
    need customization to act as required and/or in order to create an unique framework—features
    for your application.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的发展过程之一是思考应用程序的基本结构，当你决定使用哪个对象、如何组合、定制，以及它们如何通信以生成预期的输出等。其中一些由 Cocoa 和 Cocoa
    Touch 提供供即时使用，如 NSString、NSArray、NSDictionary、UIView 和 UILabel，但这种重要性归因于其他人可能需要定制以执行所需操作，或者为了创建独特的框架——为您的应用程序提供功能。
- en: What is a class?
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是类？
- en: In object-oriented programming approaches, an object is an instance of a class.
    The class will determine the behavior of the object, the messages (methods) it
    receives, and sometimes who has access to send these messages in order to obtain
    a response.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程方法中，对象是类的实例。类将确定对象的行为，它接收的消息（方法），有时以及谁有权发送这些消息以获得响应。
- en: A class describes the properties and behaviors of a specified object, just like
    the blueprint of a house will describe the properties of the house, such as the
    number of doors in the house. Similarly, for a number, an instance of a class
    named `NSNumber`, its class provides many ways to obtain, analyze, compare, and
    convert the object's internal numeric value.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类描述了指定对象的属性和行为，就像房子的蓝图会描述房子的属性，例如房子里的门数。同样，对于一个数字，名为 `NSNumber` 的类的实例，其类提供了许多获取、分析、比较和转换对象内部数值的方法。
- en: 'Except the internal contents stored in multiple instances of a class, all the
    properties and actions behave identically. Check out the following example:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 除了存储在类多个实例中的内部内容外，所有属性和行为表现相同。查看以下示例：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Our numeric object, `firstNumber`, now has the numeric value `3`, which is an
    integer, after sending the message `intValue`, which is predefined in the `NSNumber`
    class. The object will behave as expected by converting its value to an integer.
    Any object instance of the class will act in the same way.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数值对象 `firstNumber` 现在具有数值 `3`，这是一个整数，在发送了 `NSNumber` 类中预定义的 `intValue` 消息之后。对象将按照预期行为，将其值转换为整数。该类的任何对象实例都将以相同的方式行事。
- en: 'Objects are created to be used in different expected ways, but it''s not a
    requirement for you to know how the internal mechanisms of their behavior happens,
    which is also known as encapsulation. Instead, the single requirement is to know
    how to handle the objects in order to behave in the way you want. It means you
    need to know the predefined messages to send to your object. If you have a string,
    an instance of the `NSString` class containing six uppercase characters, and you
    want them to be lowercase, all you have to know is the message to be sent:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对象被创建出来是为了以不同的预期方式使用，但您不需要知道它们行为内部机制是如何发生的，这也就是封装。相反，唯一的要求是知道如何处理对象以实现您想要的行为。这意味着您需要知道发送给对象的预定义消息。如果您有一个包含六个大写字母的`NSString`类的字符串实例，并且希望它们变为小写，您只需要知道要发送的消息：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To specify how an object is intended to be used, we use the class interface.
    It defines a public interface to be used in other parts of your code, outside
    the class itself.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了指定对象的使用意图，我们使用类接口。它定义了一个公共接口，用于在代码的其他部分使用，而不仅仅是类本身。
- en: Classes
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类
- en: In order to create your own class, go to **File** | **New** in the menu bar
    or just click *Command* + *N*, select **iOS** or **OS X** based on your project
    and select **Cocoa Class** or **Cocoa Touch Class**. After this, you can name
    your class and select its super class (from which it will inherit). Xcode will
    automatically create a header and an implementation file for you, `.h` and `.m`.
    As in other programming languages, the header file is kind of a summary, a quick
    view about the contents in the class, what will be used, and so on.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建自己的类，请转到菜单栏中的**文件** | **新建**，或者直接点击 *Command* + *N*，根据您的项目选择**iOS**或**OS
    X**，然后选择**Cocoa类**或**Cocoa Touch类**。之后，您可以命名您的类并选择其超类（它将从中继承）。Xcode将自动为您创建一个头文件和一个实现文件，`.h`和`.m`。与其他编程语言一样，头文件相当于一个摘要，快速查看类中的内容，将要使用的内容，等等。
- en: 'Your public methods and properties will be declared in the header file. Here,
    you can see a sample of a newly created header file (`mySpecialTableViewController.h`):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您的公共方法和属性将在头文件中声明。在这里，您可以看到一个新创建的头文件示例（`mySpecialTableViewController.h`）：
- en: '![Classes](img/00006.jpeg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![类](img/00006.jpeg)'
- en: Our class is named `mySpecialTableViewController`, a subclass of `UITableViewController`.
    It creates a UI element, as its name suggests, a table view, which is very common
    in iOS applications.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的这个类名为`mySpecialTableViewController`，是`UITableViewController`的一个子类。它创建了一个UI元素，正如其名所示，一个表格视图，这在iOS应用中非常常见。
- en: 'Still in our header file, we will create a public property, `NSArray`, to receive
    and hold the data that will be shown on each `UITableViewCell`. Our table view
    will show a list of programming languages:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然在我们的头文件中，我们将创建一个公共属性`NSArray`，用于接收和存储将在每个`UITableViewCell`上显示的数据。我们的表格视图将显示编程语言列表：
- en: '![Classes](img/00007.jpeg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![类](img/00007.jpeg)'
- en: 'By specifying the superclass during the creation, Xcode already prepared your
    class with the built-in methods available/required to run it. As we can see in
    our implementation file (`mySpecialTableViewController.m`), we just need to implement
    our code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在创建时指定超类，Xcode已经为您准备好了内置的可用/必需方法，以便运行它。正如我们在实现文件（`mySpecialTableViewController.m`）中看到的那样，我们只需要实现我们的代码：
- en: '![Classes](img/00008.jpeg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![类](img/00008.jpeg)'
- en: 'Our table view will be simple, only showing each programming language stored
    in the `myProgrammingLanguages` array on a different cell. It will only have one
    section, which means we are free to return this number in the `numberOfSectionsInTableView:`
    method:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的表格视图将很简单，只显示存储在`myProgrammingLanguages`数组中的不同单元格上的编程语言。它将只有一个部分，这意味着我们可以在`numberOfSectionsInTableView:`方法中自由返回这个数字：
- en: '![Classes](img/00009.jpeg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![类](img/00009.jpeg)'
- en: 'The next modification is to specify the number of rows, which means the number
    of cells. If it relies on a property where this number might be different, we
    can''t hardcode it as we did with the number of sections; instead, we return the
    number of objects our array is holding:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个修改是指定行数，也就是单元格的数量。如果这个数字依赖于可能不同的属性，我们就不能像处理部分数量那样硬编码它；相反，我们返回我们的数组所持有的对象数量：
- en: '![Classes](img/00010.jpeg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![类](img/00010.jpeg)'
- en: 'The next step when creating a table view in Objective-C is to set the content
    of the cells. We use the `tableView:cellForRowAtIndexPath:` method (already provided
    in the implementation file). By default, it comes commented. Uncomment the method
    in order to use it:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在Objective-C中创建表格视图的下一步是设置单元格的内容。我们使用`tableView:cellForRowAtIndexPath:`方法（已在实现文件中提供）。默认情况下，它是注释掉的。取消注释该方法以便使用它：
- en: '![Classes](img/00011.jpeg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![类](img/00011.jpeg)'
- en: The first thing you should notice is that it creates `UITableViewCell` and returns
    it to be seen on the table view. It is between these two steps that we will configure
    our cell.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先应该注意到的第一件事是，它创建了`UITableViewCell`并将其返回以在表格视图中显示。这两个步骤之间是我们配置单元格的地方。
- en: 'The `UITableViewCell` class already comes with a property called `textLabel`.
    We will use it to show the values stored in the `myProgrammingLanguages` array.
    Once the `tableView:numberOfRowsInSection:` method returns the number of elements
    in the array, for each iteration, it configures and returns a cell for the respective
    item in the array. The first cell is for the first item, the second cell for second
    item, and so on. Inside this method, the current cell is already the correct cell
    for `indexPath`, but in order to get the correct value set to it, we use `indexPath.row`
    to select the proper item in the array:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`UITableViewCell`类已经包含一个名为`textLabel`的属性。我们将使用它来显示存储在`myProgrammingLanguages`数组中的值。一旦`tableView:numberOfRowsInSection:`方法返回数组中的元素数量，对于每次迭代，它都会配置并返回数组中相应项的单元格。第一个单元格是第一个项，第二个单元格是第二个项，依此类推。在这个方法中，当前单元格已经是`indexPath`的正确单元格，但为了获取正确的值设置给它，我们使用`indexPath.row`来选择数组中的正确项：'
- en: '![Classes](img/00012.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![类](img/00012.jpeg)'
- en: The preceding code sets the first item in the `myProgrammingLanguages` array
    to the `textLabel` property of the first cell and so on until it reaches the number
    of rows in the table view (the number of the elements in the array).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将`myProgrammingLanguages`数组中的第一个元素设置为第一个单元格的`textLabel`属性，依此类推，直到达到表格视图中的行数（数组中元素的数量）。
- en: 'By hardcoding our array, setting the items of `myProgrammingLanguages` inside
    the `viewDidLoad` method, and building our project, we are able to see a table
    view with the items of the array on each cell:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`viewDidLoad`方法中硬编码我们的数组，设置`myProgrammingLanguages`的项，并构建我们的项目，我们能够看到表格视图中每个单元格上的数组项：
- en: '![Classes](img/00013.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![类](img/00013.jpeg)'
- en: 'Here, you can see our custom `UITableViewController` with three `UITableViewCell`
    classes, the items of the `myProgrammingLanguages` array:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你可以看到我们的自定义`UITableViewController`，包含三个`UITableViewCell`类，以及`myProgrammingLanguages`数组中的项：
- en: '![Classes](img/00014.jpeg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![类](img/00014.jpeg)'
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Creating a cell with `[tableView:dequeueReusableCellWithIdentifier:@"anyReusableIdentifier"
    forIndexPath:indexPath]` sets an identifier to the cell in order to reuse it with
    other content when it's no longer visible on the screen.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`[tableView dequeueReusableCellWithIdentifier:@"anyReusableIdentifier" forIndexPath:indexPath]`创建单元格时，为单元格设置一个标识符，以便在它不再可见于屏幕上时与其他内容一起重用。
- en: For example, if there is a table view with 15 elements, and in your iOS device,
    there are 12 cells visible in the screen, when you scroll up to see the other
    3 elements, there will still be 12 cells visible. In this case, using reuse identifiers,
    instead of creating 15 `UITableViewCells`, it will create at least 13 different
    cells (11 fully visible cells and 2 partially visible cells), and when a cell
    disappears from the screen (scroll up), it is reused to load the newest visible
    element, appearing at the bottom.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果一个表格视图有15个元素，在你的iOS设备上，屏幕上可以看到12个单元格，当你向上滚动以查看其他3个元素时，仍然会有12个单元格可见。在这种情况下，使用重用标识符，而不是创建15个`UITableViewCells`，它至少会创建13个不同的单元格（11个完全可见的单元格和2个部分可见的单元格），当一个单元格从屏幕上消失（向上滚动）时，它会被重用来加载最新的可见元素，出现在底部。
- en: Object immutability
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象不可变性
- en: Most of the classes provided by Cocoa and Cocoa Touch create objects with immutable
    values. In short, an immutable object has its contents set only once, and can
    never modify its values after that. These objects have their contents specified
    during their creation. The object's creation might occur in the initialization
    process or later, but it happens once.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数由Cocoa和Cocoa Touch提供的类都使用不可变值创建对象。简而言之，一个不可变对象的内容只设置一次，之后永远不能修改其值。这些对象的内容在创建时指定。对象的创建可能发生在初始化过程中或之后，但只发生一次。
- en: 'Here, we can see an array that is initialized and created at the same time.
    Its contents are immutable:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们可以看到一个初始化和创建的同时进行的数组。其内容是不可变的：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding line of code, `[sampleArray addObject:@"Item 3"];` will show
    you a compile time error as `sampleArray` is declared as an `NSArray` and not
    as an `NSMutableArray`, so `sampleArray` cannot have any objects added to it after
    it is initialized.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一行代码中，`[sampleArray addObject:@"Item 3"];`将显示一个编译时错误，因为`sampleArray`被声明为`NSArray`而不是`NSMutableArray`，所以`sampleArray`在初始化后不能添加任何对象。
- en: 'Now, we create another array, firstly initializing it before its creation,
    which might happen somewhere later in the code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们创建另一个数组，首先在创建之前初始化它，这可能在代码的某个地方稍后发生：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can see that we set `secondSampleArray` to `nil`, and in Objective-C, `nil`
    means that `secondSampleArray` has no value or an address. It is only later that
    we insert the two NSStrings `"Item 1"` and `"Item 2"` into `secondSampleArray`
    to make the size of the array 2.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们将`secondSampleArray`设置为`nil`，在Objective-C中，`nil`表示`secondSampleArray`没有值或地址。只有在之后我们才将两个`NSString`字符串`"Item
    1"`和`"Item 2"`插入到`secondSampleArray`中，使数组的大小变为2。
- en: Object mutability
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象可变性
- en: 'Cocoa and Cocoa Touch also provide some mutable versions of its immutable classes.
    Once a mutable object is created, its contents can be partially or completely
    removed or modified. As we saw immutable array objects—an instance of NSArray—in
    the previous topic, I will now show you its mutable version, the `NSMutableArray`
    class, from which we will create our objects as an instance, as you can see in
    the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Cocoa和Cocoa Touch还为其不可变类提供了一些可变版本。一旦创建了一个可变对象，其内容可以被部分或完全删除或修改。正如我们在前一个主题中看到的不变数组对象——`NSArray`的一个实例——现在我将向你展示它的可变版本，即`NSMutableArray`类，我们将从这个类创建对象，如以下代码所示：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The mutable versions of a class (in our example, `NSMutableArray`) have many
    similarities with the original immutable version, `NSArray`; however, they are
    different classes. Intending to use methods from one that is not available for
    the other will generate compilation errors. Generally, immutability is what you
    should try to use as immutability provides a guarantee that an object won't have
    its value changed while you are using it. Immutability also brings performance
    benefits when used in things such as strings and dictionaries as mutability will
    bring some overhead due to the need to allocate and deallocate chunks of memory
    when the string or dictionary is modified.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 类的可变版本（在我们的例子中是`NSMutableArray`）与原始不可变版本`NSArray`有许多相似之处；然而，它们是不同的类。试图使用一个不可用于另一个的方法将生成编译错误。通常，不可变性是你应该尝试使用的，因为不可变性提供了一个保证，即在使用对象时其值不会改变。不可变性在字符串和字典等使用时也会带来性能优势，因为可变性在修改字符串或字典时需要分配和释放内存块，这会带来一些开销。
- en: In the case of `NSArray` and `NSMutableArray`, `NSMutableArray` is not thread-safe
    and can present weird bugs if you use multithreading. So, generally, try to use
    `NSArray` as the de facto array to use unless you really need `NSMutableArray`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在`NSArray`和`NSMutableArray`的情况下，`NSMutableArray`不是线程安全的，如果在多线程中使用可能会出现奇怪的bug。因此，通常情况下，除非你确实需要`NSMutableArray`，否则尽量使用`NSArray`作为默认的数组。
- en: Inheritance
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: To understand inheritance, think about it as a perfect biological tree, where
    you have inherited some behavioral traits from your father, but more than that
    you have your own. Something like this happens in Objective-C when a class is
    inherited from another.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解继承，可以将其想象成一个完美的生物树，你从父亲那里继承了一些行为特征，但不仅如此，你还有自己的。在Objective-C中，当一个类从另一个类继承时，就会发生类似的事情。
- en: 'Basic samples are the classes whose names start with `NS` provided by Cocoa
    and Cocoa Touch, such as `NSString`, `NSArray`, and `NSDictionary`. They are all
    inherited from `NSObject`. Each of them has their particular methods to handle
    the different types of contents they hold, but everyone shares methods such as
    `alloc` and `init`. These two class methods, inherited from `NSObject`, respectively
    allocate memory and initialize the object:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 基本样本是Cocoa和Cocoa Touch提供的以`NS`开头命名的类，例如`NSString`、`NSArray`和`NSDictionary`。它们都继承自`NSObject`。每个类都有它们特有的方法来处理它们所持有的不同类型的内容，但它们都共享如`alloc`和`init`这样的方法。这两个从`NSObject`继承来的类方法分别分配内存和初始化对象：
- en: '![Inheritance](img/00015.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![继承](img/00015.jpeg)'
- en: 'The `alloc` method will rarely be overridden, performing a single task and
    allocating memory to the object being created. However, another inheritance example
    is the `init` method, which is also inherited from `NSObject`. It received modifications
    in each child class, creating other initialization methods to quickly assign content
    to the object. These new `init` methods are inherited from the original `init`
    method. This is an example for `NSString`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`alloc`方法很少被覆盖，执行单一任务并为创建的对象分配内存。然而，另一个继承示例是`init`方法，它也是从`NSObject`继承的。它在每个子类中进行了修改，创建了其他初始化方法以快速分配内容给对象。这些新的`init`方法是从原始的`init`方法继承的。这是一个`NSString`的例子：'
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![Inheritance](img/00016.jpeg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![继承](img/00016.jpeg)'
- en: Convenience initializers
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 便利初始化器
- en: 'The allocation and initialization methods will allocate a chunk of memory to
    hold the object''s content and set an empty value to it, until you assign a value
    yourself. The empty value differs depending on the object''s type: Boolean (BOOL)
    objects receive the value `NO`, integers (int) receive `0`, float numbers (float)
    receive `0.0`, and the rest of the objects receive `nil`.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 分配和初始化方法将为对象的内容分配一块内存，并将其设置为空值，直到你分配自己的值。空值取决于对象的类型：布尔（BOOL）对象接收值`NO`，整数（int）接收`0`，浮点数（float）接收`0.0`，其余对象接收`nil`。
- en: It's possible to first allocate memory for your object, and later in the code,
    initialize it, but it's not recommended at all.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以先为你的对象分配内存，然后在代码中稍后初始化它，但这根本不推荐。
- en: On the other hand, you can use or even create what we call convenience initializers,
    which are initialization methods that receive arguments to assign different and/or
    additional values for instance variables.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，你可以使用甚至创建我们所说的便利初始化器，这些初始化方法接收参数以分配不同和/或额外的值给实例变量。
- en: 'For a better understanding, we will now create our own object class and create
    convenience initializers to be used in different scenarios. First, we will create
    a class, inherited from `NSObject`. It will return a float number, which is a
    result of a fraction of a multiplication; we will call it `MultiFraction`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解，我们现在将创建我们自己的对象类，并创建便利初始化器以用于不同的场景。首先，我们将创建一个从`NSObject`继承的类。它将返回一个浮点数，这是乘法分数的结果；我们将称之为`MultiFraction`：
- en: '![Convenience initializers](img/00017.jpeg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![便利初始化器](img/00017.jpeg)'
- en: 'In our header file, `MultiFraction.h`, we will specify the instance variables
    to be included in our object. It will have three values and we will use the `property`
    keyword to define the information that the `MultiFraction` class intends to encapsulate,
    which in this case are the objects of the type `NSInteger`, which are named `firstNumerator`,
    `secondNumerator`, and `denominator` respectively:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的头文件`MultiFraction.h`中，我们将指定要包含在我们对象中的实例变量。它将包含三个值，我们将使用`property`关键字来定义`MultiFraction`类打算封装的信息，在这种情况下是类型为`NSInteger`的对象，分别命名为`firstNumerator`、`secondNumerator`和`denominator`：
- en: '![Convenience initializers](img/00018.jpeg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![便利初始化器](img/00018.jpeg)'
- en: 'In the implementation file, `MultiFraction.m`, by omitting the `init` method,
    it will use the inherited initialization method from the superclass, in our case,
    `NSObject`, which will return a `nil` value. However, we want to implement a convenience
    initializer to take three arguments, save the values to be used by another method
    in order to perform a calculation, and return its result. Our initialization method
    will be named `initWithFirstNumerator:`, `secondNumerator:`, `denominator:`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现文件`MultiFraction.m`中，通过省略`init`方法，它将使用从超类继承的初始化方法，在我们的例子中是`NSObject`，这将返回一个`nil`值。然而，我们想要实现一个便利初始化器，接受三个参数，将值保存以便其他方法使用以执行计算，并返回其结果。我们的初始化方法将被命名为`initWithFirstNumerator:`、`secondNumerator:`、`denominator:`：
- en: '![Convenience initializers](img/00019.jpeg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![便利初始化器](img/00019.jpeg)'
- en: 'Inside our initialization method, we will store the arguments passed to our
    object on its respective instance variables in case we want to access any of these
    values in the future, instead of calculating the result directly:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的初始化方法内部，我们将存储传递给我们的对象的参数到各自的实例变量中，以防我们将来想要访问这些值中的任何一个，而不是直接计算结果：
- en: '![Convenience initializers](img/00020.jpeg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![便利初始化器](img/00020.jpeg)'
- en: 'Now, we can create our object elsewhere in our Xcode project, by importing
    our header file:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在我们的Xcode项目中其他地方创建我们的对象，通过导入我们的头文件：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: An Objective-C programmer's responsibility
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Objective-C程序员的职责
- en: 'If you have experience in other programming languages, such as Java, and are
    coming to Objective-C now, forget about constructors, they don''t exist in Objective-C.
    Constructors are language-level constructs that merge the allocation and initialization
    actions, but they have restrictions:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在其他编程语言（如Java）中有所经验，现在正在转向Objective-C，请忘记构造函数，它们在Objective-C中不存在。构造函数是语言级别的结构，它合并了分配和初始化操作，但它们有约束：
- en: They don't return anything. While the Objective-C class initialization method,
    + (`void`) initialize, does not return anything, the default—(`id`) `init` method
    of an Objective-C class returns an object of the type `id`.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不返回任何内容。虽然Objective-C类的初始化方法`+ (`void`) `initialize`不返回任何内容，但Objective-C类的默认`(`id`)
    `init`方法返回一个`id`类型的对象。
- en: The constructor's name must be identical with the class.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数的名称必须与类名相同。
- en: When you call the superclass, being the first statement is a must.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您调用超类时，作为第一条语句是必须的。
- en: The last point ensures you won't deal with garbage data, but this is a restriction.
    In Objective-C, as in C, without this restriction, you, the programmer, have more
    flexibility and power, but it is also your responsibility to deal with garbage
    data.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点确保您不会处理垃圾数据，但这是一个限制。在Objective-C中，就像在C中一样，如果没有这个限制，您，作为程序员，将有更多的灵活性和能力，但这也意味着您需要负责处理垃圾数据。
- en: The singleton pattern
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例模式
- en: Besides taking responsibility for garbage management, a good programmer should
    also be aware of programming design patterns. Design patterns are solutions, mostly
    reusable code solutions, to solve and prevent common issues. It makes a developer's
    life easier. In this section, I'll show you the singleton pattern. Singletons
    are useful if you need a single instance and need to manage that single instance
    such as writing to a log file. However, singletons can be misused as global variables,
    which makes for bad programming practice. Singletons are also implemented using
    static methods, which is not good for unit testing as they cannot be mocked or
    stubbed. So, only use a singleton in the correct context and not in every situation
    that you encounter.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 除了负责垃圾回收外，一个优秀的程序员还应该了解编程设计模式。设计模式是解决常见问题的解决方案，通常是可重用的代码解决方案，使开发者的生活更加轻松。在本节中，我将向您展示单例模式。单例在您需要一个单一实例并需要管理该单一实例（如写入日志文件）时非常有用。然而，单例可能会被误用为全局变量，这会导致不良的编程实践。单例也是通过静态方法实现的，这对单元测试来说并不好，因为它们不能被模拟或存根。因此，仅在正确的上下文中使用单例，而不是在遇到每个情况时都使用。
- en: In Objective-C, it's completely possible to have more than one instance of a
    class (objects) at a time. However, what if you don't need it? What if, for some
    reason, you need only one instance and nothing more and want to avoid multiple
    instances for that class? In this case, you use the singleton pattern. It ensures
    that there is only a single instance of a class and there is a method globally
    available for it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在Objective-C中，一次可以有多个类的实例（对象）。然而，如果您不需要呢？如果您出于某种原因只需要一个实例，而不需要更多，并希望避免该类的多个实例，在这种情况下，您使用单例模式。它确保只有一个类的实例，并且有一个全局方法可用于它。
- en: 'An example already implemented by Apple in the `UIScreen` class is the `mainScreen`
    method. It''s globally available and returns a instance of its class, ensuring
    it''s the only one. The reason is obvious, we don''t need more than one main screen.
    It''s called from anywhere in your project, as shown here:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果公司在`UIScreen`类中已经实现的一个例子是`mainScreen`方法。它是全局可用的，并返回其类的一个实例，确保它是唯一的。原因很明显，我们不需要超过一个主屏幕。它可以从项目的任何地方调用，如下所示：
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When you first call the method, the instance is not created yet. It will then
    be initialized and returned as expected; however, from the second time the method
    is called, it doesn''t create a new instance but returns the existing one. That''s
    how it ensures only one instance exists. Let''s go through the following sample
    code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当您第一次调用该方法时，实例尚未创建。它将被初始化并按预期返回；然而，从第二次调用该方法开始，它不会创建一个新的实例，而是返回现有的一个。这就是它确保只有一个实例存在的方式。让我们通过以下示例代码来了解：
- en: 'In the header file, we will first create a global method to access its instance:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在头文件中，我们首先创建一个全局方法来访问其实例：
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, in your implementation file, implement the method, as shown here:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在你的实现文件中，实现这个方法，如下所示：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, you can initialize and access this instance from anywhere in your code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以从代码的任何地方初始化和访问这个实例：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Creating @property
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建`@property`
- en: There are two ways to store data in objects, they are properties and instance
    variables. The latter should be used just for objects and values exclusively handled
    by the class itself, not from outside. Properties, on the other hand, for objects
    and values are accessible from outside (by other classes).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象中存储数据有两种方式，它们是属性和实例变量。后者应仅用于对象和由类本身独家处理的数据，而不是来自外部。另一方面，属性和值对于对象和值是可从外部（由其他类）访问的。
- en: 'While using instance variables, you can create public or private ones. The
    difference is basically where you declare them as sometimes you need them to be
    accessible by other classes, while in other situations, there is no need to expose
    them to other classes. If they are declared in the header file as part of the
    `@interface` block, they have public scope and if declared in the implementation
    file as part of the `@implementation` block, they have private scope. Generally,
    they should be private:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用实例变量时，你可以创建公开或私有的实例变量。区别基本上在于你声明它们的位置，有时你需要它们可以被其他类访问，而在其他情况下，没有必要将它们暴露给其他类。如果它们在头文件中作为`@interface`块的一部分声明，则具有公共作用域，如果它们在实现文件中作为`@implementation`块的一部分声明，则具有私有作用域。通常，它们应该是私有的：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To easily understand your code, instance variable starts with an underscore;
    it doesn't affect the way they work, but it's a convention highly recommended
    to be followed.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更容易理解你的代码，实例变量以一个下划线开头；这不会影响它们的工作方式，但它是一个高度推荐的约定。
- en: 'Instance variables are private and accessible only by the class or subclass,
    plus it is encapsulated by the class, which contains it, while a property is public
    and can be accessed by other classes. Properties can also be private when declared
    as part of the class extension, but they are often public since you want to access
    them from the outside. By accessing, there are two options, get or set their content.
    Objective-C automatically generates getters and setters for each declared property.
    In order to declare a property with public scope, do it in your header file as
    shown here:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 实例变量是私有的，只能由类或子类访问，并且它被包含它的类封装，而属性是公开的，可以被其他类访问。属性在作为类扩展的一部分声明时也可以是私有的，但它们通常是公开的，因为你想从外部访问它们。通过访问，有两种选项，获取或设置其内容。Objective-C会自动为每个声明的属性生成获取器和设置器。为了声明具有公共作用域的属性，请在你的头文件中按照以下方式操作：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding code mostly tells other classes that the `Book` class has a public
    property, which can be accessed by `chapterNote`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码主要告诉其他类`Book`类有一个公开属性，可以通过`chapterNote`访问：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Creating custom methods
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义方法
- en: In Objective-C, methods when declared start with `–` or `+`, as you will see
    in this section. The latter declares a static method, while the former, `–` ,
    declares instance methods. As a developer, you won't declare static methods (starting
    with `+`) regularly.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在Objective-C中，声明方法时以`-`或`+`开头，正如你将在本节中看到的那样。后者声明了一个静态方法，而前者`-`声明了实例方法。作为开发者，你不会经常声明静态方法（以`+`开头）。
- en: Static methods are generally used if you don't need an instance of a class in
    that method, while instance methods are used when you need that instance to modify
    its state. Instance methods are more commonly used as instance methods give you
    access to a class instance variables.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法通常用于你不需要在该方法中创建类的实例时，而实例方法用于你需要该实例来修改其状态时。实例方法更常用，因为实例方法让你可以访问类的实例变量。
- en: 'To declare a method, you follow a syntax. You will need the following entities:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个方法，你需要遵循一种语法。你需要以下实体：
- en: The symbol to specify the type of the method
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定方法类型的符号
- en: The type of the data it will return
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将返回的数据类型
- en: The method's name
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法名称
- en: 'For each parameter:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个参数：
- en: The type of parameter
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数类型
- en: The name of parameter
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数的名称
- en: Your code inside the method
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法内的代码
- en: Following our example, in `mySpecialTableViewController`, let's declare an instance
    method that will take one parameter, a string (`NSString`). Our method will return
    the content of the `myProgrammingLanguages` array as a single string. Each object
    will be followed by the parameter given. Our method will be called `convertToStringWith`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 按照我们的示例，在`mySpecialTableViewController`中，让我们声明一个实例方法，它将接受一个参数，一个字符串（`NSString`）。我们的方法将返回`myProgrammingLanguages`数组的内容作为一个单独的字符串。每个对象都将跟随提供的参数。我们的方法将被命名为`convertToStringWith`。
- en: Before we go to the implementation file, the method must be declared in the
    header file, not doing this may cause errors when calling the method because the
    header file defines what methods are exposed to the outside.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们转到实现文件之前，必须在头文件中声明该方法，不这样做可能会导致调用方法时出错，因为头文件定义了暴露给外部的哪些方法。
- en: '![Creating custom methods](img/00021.jpeg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![创建自定义方法](img/00021.jpeg)'
- en: 'Now, move to the implementation file and implement the method:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到实现文件并实现该方法：
- en: '![Creating custom methods](img/00022.jpeg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![创建自定义方法](img/00022.jpeg)'
- en: 'In this case, when calling the method, if the `myProgrammingLanguages` array
    contains the string values: `"Objective-C", "Swift", and "PHP"`, the result would
    be a unique string with the passed parameter between the values, as shown in the
    following examples:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在此情况下，当调用方法时，如果 `myProgrammingLanguages` 数组包含以下字符串值："Objective-C", "Swift",
    和 "PHP"，结果将是一个包含传递参数的唯一的字符串，如下面的示例所示：
- en: '![Creating custom methods](img/00023.jpeg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![创建自定义方法](img/00023.jpeg)'
- en: 'There are occasions when you don''t want to pass any parameter to a method.
    It''s possible; you just need the type of the data returned and the name of the
    method:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你不想向方法传递任何参数。这是可能的；你只需要知道返回的数据类型和方法名称：
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'There are two special cases about the type of the data retuned by a method,
    when you don''t know it and when you won''t return anything. In the first case,
    you should use `id`, as shown here:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 关于方法返回的数据类型有两个特殊情况，当你不知道它时和当你不会返回任何内容时。在第一种情况下，你应该使用 `id`，如下所示：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: On the other hand, if you don't want to return nothing, use `void`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你不想返回任何内容，使用 `void`。
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: String formatting
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串格式化
- en: 'When dealing with different types of objects, especially inserting/appending
    them into a string, you need to specify their types inside the string, for which
    we use format specifiers. Printing to the console, for example, requires a string
    to be printed; it''s the only accepted format. Let''s see how to insert different
    objects inside it, to be properly printed to the console:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理不同类型的对象时，特别是将它们插入/附加到字符串中，你需要在字符串中指定它们的类型，为此我们使用格式说明符。例如，打印到控制台需要打印一个字符串；这是唯一接受的格式。让我们看看如何将不同的对象插入其中，以便正确打印到控制台：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'However, if you want to print a value stored in a property or instance variable,
    you should specify its type inside in order to properly replace it with the value
    outside:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你想打印存储在属性或实例变量中的值，你应该在内部指定其类型，以便正确地用外部的值替换它：
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice `%@` inside the message. It specifies that the value is a string. This
    is how we can specify the object's type, using a percentage sign, `%`, followed
    by a specific keyword (conversion specifier). Using a different conversion specifier
    for a string will result in compilation error.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意消息中的 `%@`。它指定值是一个字符串。这就是我们如何使用百分号 `%` 后跟一个特定的关键字（转换说明符）来指定对象的类型。为字符串使用不同的转换说明符会导致编译错误。
- en: 'Mostly, specifiers support more than one data type:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数说明符支持多种数据类型：
- en: '| The format specifier | Supported object''s type |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 格式说明符 | 支持的对象类型 |'
- en: '| --- | --- |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `%d` | Integer (signed int), 32-bit |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `%d` | 整数（有符号整型），32位 |'
- en: '| `%u` | Integer (unsigned int), 32-bit |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `%u` | 整数（无符号整型），32位 |'
- en: '| `%x` | Integer (unsigned int) as hexadecimal value, 32-bit |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `%x` | 以十六进制值表示的整数（无符号整型），32位 |'
- en: '| `%o` | Integer (unsigned int) as octal value, 32-bit |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `%o` | 以八进制值表示的整数（无符号整型），32位 |'
- en: '| `%%` | `print "%"` |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `%%` | 打印 `%` |'
- en: '| `%f` | Float, double (point float number), 64-bit |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `%f` | 浮点数，双精度浮点数（点浮点数），64位 |'
- en: '| `%e` | Float, double (point float number) in scientific notation, 64-bit
    |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `%e` | 浮点数，双精度浮点数（点浮点数）以科学记数法表示，64位 |'
- en: '| `%g` | Float, double (point float number) as `%e` if the exponent is less
    than –4, otherwise as `%f`, 64 bit |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `%g` | 浮点数，双精度浮点数（点浮点数）如果指数小于-4，则按 `%e` 格式，否则按 `%f` 格式，64位 |'
- en: '| `%c` | Unsigned character (unsigned char), 8 bit |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `%c` | 无符号字符（无符号字符），8位 |'
- en: '| `%S` | An array of 16-bit Unicode characters, which terminates with a null
    pointer |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `%S` | 以空指针结尾的16位Unicode字符数组 |'
- en: '| `%p` | A void pointer character (`void *`) in hexadecimal, starting with
    0x |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `%p` | 以十六进制表示的空指针字符（`void *`），以0x开头 |'
- en: '| `%a` | Double (point float number) in scientific notation, starting with
    0x and one hexadecimal digit before the decimal point using a lowercase `p` to
    introduce the exponent, 64 bit |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `%a` | 以科学记数法表示的双精度浮点数（点浮点数），以0x开头，小数点前有一个十六进制数字，使用小写的 `p` 来引入指数，64位 |'
- en: '| `%F` | Double (point float number) in decimal notation |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `%F` | 以十进制表示的双精度浮点数（点浮点数） |'
- en: '| `%hhd` | BOOL |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `%hhd` | BOOL |'
- en: Summary
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we were able to see objects in detail, how inheritance works
    and how you can use it to create even more powerful classes. You learned about
    an object's mutability and immutability, how instance variables and property work,
    what they are, and how to create them besides allocation, initialization, and
    custom methods, and how to create your own. In the next chapter, we will cover
    application data management such as resource optimization, caching, and data saving.
    So, see you in the next chapter.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们能够详细地看到对象，了解继承的工作原理以及如何利用它来创建更强大的类。你学习了关于对象的可变性和不可变性，实例变量和属性的工作方式，它们是什么，以及除了分配、初始化和自定义方法之外如何创建它们，以及如何创建自己的对象。在下一章中，我们将涵盖应用数据管理，例如资源优化、缓存和数据保存。所以，我们下一章见。
