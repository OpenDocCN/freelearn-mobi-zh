- en: Chapter 13. Using Mix and Match
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 13 章。使用混合匹配
- en: When Apple first introduced Swift at WWDC 2014, my first thought was how much
    work it would be for developers to rewrite their apps, which were already written
    in Objective-C, in Swift. I also wondered why a developer would rewrite their
    apps in Swift. A lot of these applications are pretty complex and would take a
    pretty large effort to rewrite them. Somewhere in the Swift presentation, Apple
    spoke about mix and match, which allows Swift and Objective-C to interact within
    the same project. Mix and match sure sounded like an ideal solution because developers
    could rewrite sections of their code in Swift as they needed to do updates, instead
    of having to rewrite their whole application. My big question was how well mix
    and match would actually work, and I was very surprised; not only does it work
    well but it is also easy to implement.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当苹果在 2014 年的 WWDC 上首次介绍 Swift 时，我的第一个想法是开发者需要花费多少工作量来将已经用 Objective-C 编写的应用程序重写为
    Swift。我也想知道为什么开发者会重写他们的应用程序为 Swift。这些应用程序相当复杂，重写它们需要相当大的努力。在 Swift 的某个演示中，苹果提到了混合匹配，它允许
    Swift 和 Objective-C 在同一项目中交互。混合匹配听起来确实像是一个理想的解决方案，因为开发者可以在需要更新时，用 Swift 重写代码的某些部分，而不是不得不重写整个应用程序。我最大的问题是混合匹配实际上会工作得有多好，我非常惊讶；它不仅工作得很好，而且实现起来也很简单。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is mix and match
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是混合匹配
- en: How to use Swift and Objective-C together in the same project
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在同一项目中同时使用 Swift 和 Objective-C
- en: How to add Swift to an Objective-C project
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将 Swift 添加到 Objective-C 项目中
- en: How to use Objective-C in a Swift project
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 Swift 项目中使用 Objective-C
- en: What is mix and match
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是混合匹配
- en: Swift's compatibility with Objective-C allows us to create a project in either
    language and include files written in the other language. This feature is called
    **mix and match**. It was arguably one of the most important features that came
    out with Swift.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 与 Objective-C 的兼容性允许我们创建一个项目，并包含用另一种语言编写的文件。这个特性被称为 **混合匹配**。这可能是 Swift
    诞生时最重要的特性之一。
- en: The reason why this feature is so important is that there are, well, over a
    million apps written in Objective-C in Apple's App Store, and it would not be
    feasible for developers to spend the resources required for converting those apps
    from Objective-C to Swift. Without mix and match, the adaptation of the Swift
    language would be very slow. With mix and match, developers can begin to use Swift
    in their present apps that are written in Objective-C without having to convert
    the entire code base to Swift.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性之所以如此重要，是因为在苹果的 App Store 中，有超过一百万个用 Objective-C 编写的应用程序，开发者花费资源将这些应用程序从
    Objective-C 转换为 Swift 是不可行的。没有混合匹配，Swift 语言的适应速度将会非常缓慢。有了混合匹配，开发者可以在不将整个代码库转换为
    Swift 的情况下，开始在他们用 Objective-C 编写的现有应用程序中使用 Swift。
- en: With mix and match, we can update our current Objective-C project using Swift.
    We can also use any framework written in Objective-C within our Swift projects
    and use newer frameworks written in Swift in our Objective-C projects.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用混合匹配，我们可以使用 Swift 更新我们的当前 Objective-C 项目。我们还可以在我们的 Swift 项目中使用用 Objective-C
    编写的任何框架，并在我们的 Objective-C 项目中使用用 Swift 编写的较新框架。
- en: For developers that have been using Apple products for a long time, they might
    find a similarity between mix and match and Rosetta, which Apple started including
    with OS X 10.4.4 Tiger. OS X 10.4.4 was the first version of Apple's operating
    system that was released with Apple's first Intel-based machines. Rosetta was
    written to allow many PowerPC applications to run seamlessly on the new Intel-based
    machines.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于长时间使用苹果产品的开发者来说，他们可能会发现混合匹配和苹果从 OS X 10.4.4 Tiger 开始包含的 Rosetta 之间存在相似之处。OS
    X 10.4.4 是苹果操作系统首次与苹果的第一款基于英特尔的处理器的机器一同发布的版本。Rosetta 的编写是为了允许许多 PowerPC 应用程序在新基于英特尔的处理器的机器上无缝运行。
- en: For those developers who are new to Apple products, you might not have heard
    of Rosetta. This is because Rosetta was not included or supported as of OS X 10.7
    Lion. The reason this is mentioned is because if mix and match takes a similar
    path as Rosetta, it might not be a part of the language forever and from what
    Apple has said, Swift is the future. It also makes sense from a technological
    standpoint that as the Swift language evolves and matures, Apple will not want
    to maintain compatibility with Objective-C.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些刚开始接触苹果产品的开发者来说，你可能没有听说过Rosetta。这是因为Rosetta自OS X 10.7 Lion以来就没有被包含或支持。之所以提到这一点，是因为如果混合匹配采取与Rosetta相似的道路，它可能永远不再是语言的一部分，并且根据苹果的说法，Swift是未来。从技术角度来看，随着Swift语言的演变和成熟，苹果可能不会希望与Objective-C保持兼容性。
- en: If you maintain legacy apps written in Objective-C, it might be a good idea
    to take advantage of mix and match to slowly upgrade your code base to Swift.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你维护的是用Objective-C编写的遗留应用程序，利用混合匹配慢慢将你的代码库升级到Swift可能是个好主意。
- en: Let's look at how Swift and Objective-C can interact together. For this, we
    will be creating a very basic iOS project whose language will be Objective-C,
    and then we will add some Swift code for the project to use. In the downloadable
    code for this book, we have included an Objective-C project that consists of Swift
    code and a Swift project that includes Objective-C code. One thing to keep in
    mind is that it does not matter if our project is an Objective-C or a Swift project;
    interaction between Swift and Objective-C works the same way.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Swift和Objective-C如何相互交互。为此，我们将创建一个非常基本的iOS项目，其语言将是Objective-C，然后我们将为该项目添加一些Swift代码。在本书的下载代码中，我们包含了一个包含Swift代码的Objective-C项目和一个包含Objective-C代码的Swift项目。需要注意的是，无论我们的项目是Objective-C还是Swift项目，Swift和Objective-C之间的交互方式都是相同的。
- en: Using Swift and Objective-C together in the same project
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在同一项目中使用Swift和Objective-C
- en: In this section, we will be walking through how to add Swift to an Objective-C
    project. The same steps can also be used to add the Objective-C code to a Swift
    project. In the downloadable code for this book, you will find both Objective-C
    and Swift projects. These projects demonstrate how to add the Swift code to an
    Objective-C project and how to add Objective-C code to a Swift project. In those
    projects, we can see that mix and match functions exactly the same, no matter
    what type of project we are using.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何将Swift添加到Objective-C项目中。同样的步骤也可以用来将Objective-C代码添加到Swift项目中。在本书的下载代码中，你可以找到Objective-C和Swift项目。这些项目展示了如何将Swift代码添加到Objective-C项目中，以及如何将Objective-C代码添加到Swift项目中。在这些项目中，我们可以看到无论使用什么类型的项目，混合匹配功能都是完全相同的。
- en: Creating the project
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建项目
- en: 'Let''s begin by creating an iOS project to work with. When we first start Xcode,
    we should see a screen that looks similar to the following screenshot:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个用于工作的iOS项目开始。当我们第一次启动Xcode时，我们应该会看到一个类似于以下截图的屏幕：
- en: '![Creating the project](img/B05115_13_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![创建项目](img/B05115_13_01.jpg)'
- en: 'From this menu, we will want to select the **Create a new Xcode project** option.
    This option will walk us though creating a new Xcode project. Once this option
    is selected, Xcode will start up and we will see the following menu. As a shortcut,
    if we do not see this menu, we can also navigate to **File** | **New** | **Project**
    in the top menu bar, which will display the following screen:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个菜单中，我们将想要选择**创建一个新的Xcode项目**选项。这个选项将引导我们创建一个新的Xcode项目。一旦选择了这个选项，Xcode将启动，我们会看到以下菜单。作为一个快捷方式，如果我们没有看到这个菜单，我们也可以在顶部的菜单栏中导航到**文件**
    | **新建** | **项目**，这将显示以下屏幕：
- en: '![Creating the project](img/B05115_13_02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![创建项目](img/B05115_13_02.jpg)'
- en: 'This menu lets us select the type of project we will be creating and also what
    platform we are targeting (iOS or OS X). For this example, we will be targeting
    the iOS platform and creating a simple Single View Application. Once we make our
    selection, we should see the following menu:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜单允许我们选择将要创建的项目类型以及我们针对的平台（iOS或OS X）。在这个例子中，我们将针对iOS平台创建一个简单的单视图应用程序。一旦我们做出选择，我们应该会看到以下菜单：
- en: '![Creating the project](img/B05115_13_03.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![创建项目](img/B05115_13_03.jpg)'
- en: On this menu, we will define several properties about our project. The two properties
    we need to focus on are the language of the project and product name. For this
    particular project, we will select Objective-C as the language and name it `ObjectiveCProject`.
    Once we have all of the properties defined, we can click on the **Next** button.
    On the last menu, we select where we wish to save the project files, and once
    we have done that, Xcode creates the project template files for us, and we can
    begin.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在此菜单上，我们将定义有关项目的一些属性。我们需要关注的两个属性是项目的语言和产品名称。对于这个特定的项目，我们将选择 Objective-C 作为语言，并将其命名为
    `ObjectiveCProject`。一旦我们定义了所有属性，我们可以点击 **下一步** 按钮。在最后一个菜单上，我们选择希望保存项目文件的路径，一旦完成，Xcode
    将为我们创建项目模板文件，然后我们可以开始。
- en: The application that we will be creating will let the user enter a name and
    will then respond with a personal message to them. The user interface will consist
    of a `UITextField` field that the user can enter their name into, a `UIButton`
    that the user will press after they have entered their name, and a `UITextView`
    that will display the personalized message. Since this book is about Swift programming,
    we will not go into how the user interface is laid out. Full working applications
    are available as part of the book's downloadable source code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要创建的应用程序将允许用户输入一个名字，然后向他们发送一个个性化的消息。用户界面将包括一个用户可以输入名字的 `UITextField` 字段，一个用户输入名字后需要按下的
    `UIButton`，以及一个将显示个性化消息的 `UITextView`。由于这本书是关于 Swift 编程的，我们不会深入讲解用户界面的布局。完整的可工作应用程序作为本书可下载源代码的一部分提供。
- en: Since we are walking through the Objective-C project, the user interface and
    the `Messages` class, which will generate a message, will be written in Objective-C.
    The message builder, which will personalize the message, will be written in Swift.
    This will show us how to access a Swift class from the Objective-C code as well
    as Objective-C resources from our Swift code within an Objective-C project.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在逐步分析 Objective-C 项目，用户界面和将生成消息的 `Messages` 类将用 Objective-C 编写。将个性化消息的消息构建器将用
    Swift 编写。这将展示我们如何在 Objective-C 项目中从 Objective-C 代码访问 Swift 类以及从 Swift 代码访问 Objective-C
    资源。
- en: Let's summarize the Objective-C to Swift interaction. The backend for the user
    interface, which is written in Objective-C, will call the `getPersonalizedMessage()`
    method of the `MessageBuilder` class written in Swift. The `getPersonalizedMessage()`
    method of the `MessageBuilder` class will call the `getMessage()` function of
    the `Messages` class written in Objective-C.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下 Objective-C 到 Swift 的交互。用户界面后端是用 Objective-C 编写的，将调用 Swift 编写的 `MessageBuilder`
    类的 `getPersonalizedMessage()` 方法。`MessageBuilder` 类的 `getPersonalizedMessage()`
    方法将调用 Objective-C 编写的 `Messages` 类的 `getMessage()` 函数。
- en: Adding Swift file to the Objective-C project
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 Swift 文件添加到 Objective-C 项目中
- en: 'Let''s begin by creating the Swift `MessageBuilder` class. This class will
    be used to build the personalized message for the user. Within Objective-C projects,
    I usually create a separate group called `SwiftFiles` to hold the Swift files
    in. This allows me to very easily see what files are written in Swift and what
    are written in Objective-C. To add a Swift file to our project, right-click on
    the group icon that we want to add the file to and we should see the following
    menu:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建 Swift 的 `MessageBuilder` 类。这个类将用于构建用户的个性化消息。在 Objective-C 项目中，我通常创建一个名为
    `SwiftFiles` 的单独组来存放 Swift 文件。这使我能够很容易地看到哪些文件是用 Swift 编写的，哪些是用 Objective-C 编写的。要将
    Swift 文件添加到我们的项目中，右键单击我们想要添加文件的组图标，我们应该会看到以下菜单：
- en: '![Adding Swift file to the Objective-C project](img/B05115_13_04.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![将 Swift 文件添加到 Objective-C 项目中](img/B05115_13_04.jpg)'
- en: 'From this menu, select the **New File…** option. This option will walk us through
    creating a new file for our project. Once you select that option, you should see
    the following menu:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 从此菜单中选择 **新建文件…** 选项。此选项将引导我们创建项目的新文件。一旦选择该选项，你应该会看到以下菜单：
- en: '![Adding Swift file to the Objective-C project](img/B05115_13_05.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![将 Swift 文件添加到 Objective-C 项目中](img/B05115_13_05.jpg)'
- en: 'This menu lets us choose what type of file we will be adding to our project.
    In this case, we will want to add a Swift file to our project; therefore, we will
    select the **Swift File** option. Once we select this option, we should see the
    following menu:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜单允许我们选择要添加到项目中的文件类型。在这种情况下，我们希望将 Swift 文件添加到项目中；因此，我们将选择 **Swift 文件** 选项。一旦我们选择了此选项，我们应该会看到以下菜单：
- en: '![Adding Swift file to the Objective-C project](img/B05115_13_06.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![将 Swift 文件添加到 Objective-C 项目](img/B05115_13_06.jpg)'
- en: 'This menu lets us name the file and define some of the properties, such as
    where we will save the file and what group it will be in. In this case, we name
    the file `MessageBuilder`. Once we have finished, we will click on the **Create**
    button. If this is the first Swift file added to an Objective-C project (or the
    first Objective-C file added to a Swift project), we should see the following
    menu pop up:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜单允许我们命名文件并定义一些属性，例如我们将保存文件的位置以及它将属于哪个组。在这种情况下，我们命名文件为 `MessageBuilder`。一旦完成，我们将点击
    **创建** 按钮。如果这是第一次将 Swift 文件添加到 Objective-C 项目（或第一次将 Objective-C 文件添加到 Swift 项目），我们应该会看到一个以下菜单弹出：
- en: '![Adding Swift file to the Objective-C project](img/B05115_13_07.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![将 Swift 文件添加到 Objective-C 项目](img/B05115_13_07.jpg)'
- en: This popup offers to create the bridging header file for use. Select **Create
    Bridging Header** to create the file.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个弹出窗口提供创建桥接头文件供使用的选项。选择 **创建桥接头** 以创建文件。
- en: The Objective-C bridging header file – part 1
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Objective-C 桥接头文件 – 第1部分
- en: In order to expose our Objective-C files to our Swift code, we rely on an Objective-C
    header file. The first time we add an Objective-C file to a Swift project or a
    Swift file to an Objective-C project, Xcode offers to create this file for us.
    It is easier to let Xcode create and configure this file rather than doing it
    manually, so it is recommended to select **Yes** when Xcode offers to create it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的 Objective-C 文件暴露给 Swift 代码，我们依赖于一个 Objective-C 头文件。当我们第一次将 Objective-C
    文件添加到 Swift 项目或 Swift 文件添加到 Objective-C 项目时，Xcode 会为我们创建这个文件。让 Xcode 创建和配置这个文件比手动操作更容易，因此建议当
    Xcode 提供创建它时选择 **是**。
- en: 'If for some reason we need to create the Objective-C bridging header file manually,
    the following steps show how we would do this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因我们需要手动创建 Objective-C 桥接头文件，以下步骤显示了我们将如何进行：
- en: Create an Objective-C header file in our project using the **New File…** option
    we saw earlier. The recommended naming convention for this file is `[MyProjectName]-Bridging-Header.h`,
    where `[MyProjectName]` is the name of our project. This will be the header file
    where we import any Objective-C header files for any Objective-C classes that
    we want our Swift code to access.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们之前看到的 **新建文件…** 选项在我们的项目中创建一个 Objective-C 头文件。这个文件的推荐命名约定是 `[MyProjectName]-Bridging-Header.h`，其中
    `[MyProjectName]` 是我们项目的名称。这将是我们导入任何 Objective-C 头文件的文件，这些头文件是我们想要我们的 Swift 代码访问的
    Objective-C 类。
- en: In the project's **Build Settings**, find the **Swift Compiler – Code Generation**
    section. In this section, locate the setting, titled **Objective-C Bridging Header**.
    We will want to set this to the path for the bridging header we created in step
    1\. The path will be from the project root.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的 **构建设置** 中，找到 **Swift 编译器 - 代码生成** 部分。在这个部分中，找到标题为 **Objective-C 桥接头**
    的设置。我们将希望将其设置为我们在步骤1中创建的桥接头文件的路径。路径将从项目根目录开始。
- en: 'The **Objective-C Bridging Header** setting for the present project that we
    are working on looks similar to the following screenshot:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在工作的当前项目的 **Objective-C 桥接头** 设置看起来类似于以下截图：
- en: '![The Objective-C bridging header file – part 1](img/B05115_13_08.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![Objective-C 桥接头文件 – 第1部分](img/B05115_13_08.jpg)'
- en: Even though the bridging header is located in the `SwiftFiles` group, we can
    see in the settings that the file itself is located at the root of the project.
    If we want to put the header file in another directory within the project, all
    we would need to do is change the path in this setting.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 即使桥接头位于 `SwiftFiles` 组中，我们也可以在设置中看到文件本身位于项目的根目录。如果我们想要将头文件放在项目中的另一个目录中，我们只需要更改这个设置中的路径。
- en: Adding the Objective-C file to the project
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 Objective-C 文件添加到项目中
- en: 'Now that we have our Objective-C bridging header file and the `MessageBuilder`
    Swift file, let''s create the Objective-C class that will generate a generic message
    to the user. We will name this class `Messages`. To create this file, right-click
    on the group folder that we want to add the file to, and we should see the following
    menu:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了 Objective-C 的桥接头文件和 `MessageBuilder` Swift 文件，让我们创建一个 Objective-C 类，该类将向用户生成一个通用的消息。我们将把这个类命名为
    `Messages`。为了创建这个文件，右键点击我们想要添加文件的组文件夹，我们应该会看到以下菜单：
- en: '![Adding the Objective-C file to the project](img/B05115_13_08a.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![将 Objective-C 文件添加到项目中](img/B05115_13_08a.jpg)'
- en: 'From this menu, select the **New File…** option. This option will walk us through
    creating a new file for our project. Once you select that option, you should see
    the following menu:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 从此菜单中选择 **New File…** 选项。此选项将引导我们创建一个新文件用于我们的项目。一旦选择该选项，你应该会看到以下菜单：
- en: '![Adding the Objective-C file to the project](img/B05115_13_09.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![将 Objective-C 文件添加到项目中](img/B05115_13_09.jpg)'
- en: 'Previously, when we added the `MessageBuilder` Swift file, we selected **Swift
    File** on this menu. This time, we will be adding an Objective-C file, so we will
    select the **Cocoa Touch Class** option. Once we select that option, we should
    see a screen similar to this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前添加 `MessageBuilder` Swift 文件时，我们在该菜单上选择了 **Swift File**。这次，我们将添加一个 Objective-C
    文件，因此我们将选择 **Cocoa Touch Class** 选项。一旦选择该选项，我们应该会看到一个类似于下面的屏幕：
- en: '![Adding the Objective-C file to the project](img/B05115_13_10.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![将 Objective-C 文件添加到项目中](img/B05115_13_10.jpg)'
- en: On this menu, we can enter the class name and also the language for the class.
    Make sure that the language is set to Objective-C. Finally, we click on the **Next**
    button, which will take us to a menu that will let us select where we want to
    save our Objective-C files. Once we select the location to save our files, both
    the header and implementation files will be added to our project.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在此菜单中，我们可以输入类名，还可以为类设置语言。确保语言设置为 Objective-C。最后，我们点击 **Next** 按钮，这将带我们到一个菜单，允许我们选择保存
    Objective-C 文件的位置。一旦我们选择了保存文件的位置，头文件和实现文件都将添加到我们的项目中。
- en: Now that all of our files have been created, let's begin writing our code and
    getting Swift and Objective-C to work together. We will begin by adding the code
    to the Objective-C **Messages** header and implementation files.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了所有文件，让我们开始编写代码，让 Swift 和 Objective-C 一起工作。我们将首先向 Objective-C 的 **Messages**
    头文件和实现文件中添加代码。
- en: The Messages Objective-C class
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Messages` Objective-C 类'
- en: The `Messages` Objective-C class will contain an array of messages and will
    expose one method named `getMessage`, which will return one randomly picked message
    from the array.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`Messages` Objective-C 类将包含一个消息数组，并公开一个名为 `getMessage` 的方法，该方法将从数组中随机选择一条消息并返回。'
- en: 'The following code shows the `Messages` header file:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了 `Messages` 头文件：
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this header file, we expose one method named `getMessage` that will return
    a message when called. The following code shows the implementation file for the
    `Messages` class:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在此头文件中，我们公开了一个名为 `getMessage` 的方法，当被调用时会返回一条消息。以下代码显示了 `Messages` 类的实现文件：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this code, we created the `NSArray` object that contains a number of messages.
    We also created the `getMessage` method that randomly picks one of the messages
    from the `NSArray` object and returns it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们创建了一个包含多个消息的 `NSArray` 对象。我们还创建了一个 `getMessage` 方法，该方法从 `NSArray` 对象中随机选择一条消息并返回它。
- en: The `Messages` class that we just created in Objective-C will need to be accessed
    by the `MessageBuilder` class that we are going to write in Swift. To access an
    Objective-C class from the Swift code, we need to edit the `Objective-C Bridging
    Header` file.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚在 Objective-C 中创建的 `Messages` 类将需要被我们将要编写的 Swift 中的 `MessageBuilder` 类访问。要从
    Swift 代码中访问 Objective-C 类，我们需要编辑 `Objective-C Bridging Header` 文件。
- en: The Objective-C bridging header file – part 2
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Objective-C bridging header 文件 – 第 2 部分
- en: 'Now that we have created the `Messages` Objective-C class, we will need to
    expose it to our Swift code. Those who are familiar with Objective-C (or any C-based
    language), will know that we need to import the class header using the `#import`
    or `#include` directive, prior to using it within another class. In that same
    context, we need to import the header file of any Objective-C class, in the Objective-C
    header file, prior to using that class in our Swift code. Therefore, to allow
    our Swift code to access the `Messages` Objective-C class, we need to add the
    following line to the Objective-C bridging header file that Xcode created for
    us:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了 `Messages` Objective-C 类，我们需要将其公开给我们的 Swift 代码。熟悉 Objective-C（或任何基于
    C 的语言）的人会知道，在使用它之前，我们需要使用 `#import` 或 `#include` 指令导入类头文件。在相同的情况下，我们还需要在 Objective-C
    头文件中导入任何 Objective-C 类的头文件，以便在 Swift 代码中使用该类。因此，为了允许我们的 Swift 代码访问 `Messages`
    Objective-C 类，我们需要将以下行添加到 Xcode 为我们创建的 Objective-C bridging header 文件中：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Yep, that is it. Pretty simple. Now, let's look at how we would write the `MessageBuilder`
    Swift class that will use the `Messages` Objective-C class.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，就是这样。很简单。现在，让我们看看我们如何编写将使用 `Messages` Objective-C 类的 `MessageBuilder` Swift
    类。
- en: The MessageBuilder Swift class – accessing Objective-C code from Swift
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`MessageBuilder` Swift类 – 从Swift访问Objective-C代码'
- en: 'The `MessageBuilder` Swift class will contain one method named `getPersonalizedMessage()`.
    This method will use the `getMessage()` method from the `Messages` Objective-C
    class to retrieve a message and will then customize that message prior to returning
    it to the function that called it. Here is the code for the `MessageBuiler` Swift
    class:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageBuilder` Swift类将包含一个名为`getPersonalizedMessage()`的方法。这个方法将使用`Messages`
    Objective-C类中的`getMessage()`方法来检索一条消息，然后在将其返回给调用它的函数之前对这条消息进行定制。以下是`MessageBuiler`
    Swift类的代码：'
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When we define this class, we create it as a subclass of the `NSObject` class.
    If a Swift class will be accessed from the Objective-C code, that class needs
    to be a subclass of the `NSObject` class. If we forget to do this, we will receive
    the `Use of undeclared identifier'{Class Name}` error when we try to access the
    class in the Objective-C code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义这个类时，我们将其创建为`NSObject`类的子类。如果Swift类将从Objective-C代码中访问，那么这个类需要是`NSObject`类的子类。如果我们忘记这样做，当我们尝试在Objective-C代码中访问该类时，我们将收到`Use
    of undeclared identifier '{Class Name}'`错误。
- en: Now, let's look at how we created an instance of the `Messages` Objective-C
    class in our Swift code. The following line creates the instances, `let messages
    = Messages()`. As we can see, we create the instance of the `Messages` Objective-C
    class, exactly as we would create an instance of any Swift class. We then access
    the `getMessages()` method of the `Messages` class like we would access a method
    of any Swift class.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何在Swift代码中创建`Messages` Objective-C类的实例。以下行创建了实例，`let messages = Messages()`。正如我们所看到的，我们创建`Messages`
    Objective-C类的实例，就像我们创建任何Swift类的实例一样。然后我们像访问任何Swift类的属性一样访问`Messages`类的`getMessages()`方法。
- en: As we can see from this code, Objective-C classes are both initiated and used
    as if they were written in Swift when we access them from a class written in Swift.
    This allows us to access our Objective-C and Swift types in a consistent way.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从这段代码中可以看到，当我们从用Swift编写的类中访问Objective-C类时，Objective-C类既被初始化也被使用，就像它们是用Swift编写的。这使我们能够以一致的方式访问我们的Objective-C和Swift类型。
- en: Now that we have created the `MessageBuilder` Swift class, we need a way to
    call the `getPersonalizedMessage()` method, from the `ViewController` Objective-C
    class.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了`MessageBuilder` Swift类，我们需要一种方法来从Objective-C的`ViewController`类中调用`getPersonalizedMessage()`方法。
- en: The Objective-C class – accessing Swift code from Objective-C
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Objective-C类 – 从Objective-C访问Swift代码
- en: Once the user enters their name and presses the **Get Message** button, we will
    create an instance of the `MessageBuilder` Swift class, in Objective-C, and call
    the `getPersonlizedMessage()` method to generate the message to be displayed.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户输入他们的名字并按下**获取消息**按钮，我们将创建一个`MessageBuilder` Swift类的实例，在Objective-C中，并调用`getPersonlizedMessage()`方法来生成要显示的消息。
- en: 'When we access Swift code from Objective-C, we rely on an Xcode-generated header
    file to expose the Swift classes. This automatically generated header file declares
    the interface for the Swift classes. The name for this header file is the name
    of your project, followed by `–Swift.h`. So, the name of the header file for our
    project is `ObjectiveCProject-Swift.h`. Therefore, the first step to access the
    Swift code from Objective-C is to import this header file, as shown in the following
    line of code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从Objective-C访问Swift代码时，我们依赖于Xcode生成的头文件来公开Swift类。这个自动生成的头文件声明了Swift类的接口。这个头文件的名称是项目名称，后跟`–Swift.h`。因此，我们项目的头文件名称是`ObjectiveCProject-Swift.h`。因此，从Objective-C访问Swift代码的第一步是导入这个头文件，如下面的代码行所示：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now that we have imported the header file to expose our Swift classes, we can
    use the `MessageBuilder` Swift class within the Objective-C code. We create an
    instance of the `MessageBuilder` Swift class exactly like we would create an instance
    of any standard Objective-C class. We also call the method and properties of a
    Swift class exactly like we would call the method and properties from an Objective-C
    class. The following example shows how we would create an instance of the `MessageBuilder`
    Swift class, and also how we would call the `getPersonalizedMessage()` method
    of that class:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经导入了头文件以公开我们的Swift类，我们可以在Objective-C代码中使用`MessageBuilder` Swift类。我们创建`MessageBuilder`
    Swift类的实例的方式，就像我们创建任何标准Objective-C类的实例一样。我们也会像调用Objective-C类的属性和方法一样调用Swift类的属性和方法。以下示例显示了我们将如何创建`MessageBuilder`
    Swift类的实例，以及我们将如何调用该类的`getPersonalizedMessage()`方法：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As we can see from this code sample, Swift classes are treated as if they were
    Objective-C classes when we access them from Objective-C. Once again, this allows
    us to access both our Objective-C and Swift types in a consistent manner.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个代码示例中我们可以看出，当我们从 Objective-C 访问 Swift 类时，Swift 类被当作 Objective-C 类来处理。再次强调，这使我们能够以一致的方式访问我们的
    Objective-C 和 Swift 类型。
- en: Summary
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As we saw in this chapter, Apple has made mix and match very easy and convenient
    to use. In order to access Swift classes from our Objective-C code, all we need
    to do is import the Xcode-generated header file that exposes the Swift classes.
    While we do not see this header file as part of our code, Xcode automatically
    creates it for mixed language projects. The name of this header file takes the
    format of `{Project Name}-Swift.h`, where `{Project Name}` is the name of our
    project.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章中看到的，Apple 使混合匹配变得非常容易和方便使用。为了从我们的 Objective-C 代码中访问 Swift 类，我们只需要导入
    Xcode 生成的暴露 Swift 类的头文件。虽然我们不会将这个头文件视为代码的一部分，但 Xcode 会自动为混合语言项目创建它。这个头文件的名称采用格式
    `{Project Name}-Swift.h`，其中 `{Project Name}` 是我们项目的名称。
- en: It is also very easy to use Objective-C classes within our Swift code. To expose
    Objective-C classes to our Swift code, all we need to do is add the Objective-C
    header file to the Objective-C bridging header file. Xcode can create this bridging
    header file for us the first time we add an Objective-C file to a Swift project,
    or the first time we add a Swift file to an Objective-C project.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 Swift 代码中使用 Objective-C 类也非常简单。为了将 Objective-C 类暴露给我们的 Swift 代码，我们只需要将
    Objective-C 头文件添加到 Objective-C 桥接头文件中。Xcode 在我们第一次将 Objective-C 文件添加到 Swift 项目中，或者第一次将
    Swift 文件添加到 Objective-C 项目中时，会为我们创建这个桥接头文件。
- en: While Apple has said that the future of application development for iOS and
    OS X platforms is in Swift, mix and match can be used to slowly migrate our current
    Objective-C code base to Swift. Mix and match also lets us use Objective-C frameworks
    in our Swift projects or Swift frameworks in our Objective-C projects.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Apple 表示 iOS 和 OS X 平台的应用程序开发未来将采用 Swift，但我们可以使用混合匹配来逐步将当前的 Objective-C 代码库迁移到
    Swift。混合匹配还允许我们在 Swift 项目中使用 Objective-C 框架，或者在 Objective-C 项目中使用 Swift 框架。
