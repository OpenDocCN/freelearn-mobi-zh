- en: Adding an Explosion and Creating a UI
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加爆炸和创建UI
- en: 'Congratulations on having made it so far! By now, you must be equipped with
    almost all of the basics needed for you to get started on your journey of game
    development. This chapter will serve as a finishing touch for our game, and we
    will complete our explosion part by adding an explosion to our game scene. Once
    we are done with that, we will create a simple UI for our game that will include
    displaying our score and distance on the screen. So, buckle up! You are about
    to finish the game we started. We will be learning the following in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你走到了这一步！到现在为止，你必须已经装备了几乎所有的基本知识，以便你开始你的游戏开发之旅。这一章将作为我们游戏的收尾，我们将通过向游戏场景添加爆炸来完成我们的爆炸部分。一旦我们完成了这个，我们将为我们的游戏创建一个简单的UI，它将在屏幕上显示我们的分数和距离。所以，系好安全带！你即将完成我们开始的游戏。在本章中，我们将学习以下内容：
- en: Adding an explosion to our game
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将爆炸添加到我们的游戏中
- en: Creating a tutorial with instructions for the player
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个带有玩家操作说明的教程
- en: Displaying the score on the screen with our UI
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用我们的UI在屏幕上显示分数
- en: However, before we move on to our UI, let's first finish up with our explosion
    effect.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们继续到我们的UI之前，让我们首先完成我们的爆炸效果。
- en: Adding an explosion to our game
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将爆炸添加到我们的游戏中
- en: 'In [*Chapter 7*](f605aac3-7f23-4895-b920-90515cff2b48.xhtml), *Adding Boundaries
    and Using Sprites to Create Explosions*, we have already created our `ExplosionEffect.java`
    class file. Now, we are left with just one task: to spawn our explosion on the
    screen. Now, just for reference, we will take a look at the image we will use
    for our explosion file:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第7章*](f605aac3-7f23-4895-b920-90515cff2b48.xhtml)，*添加边界和使用精灵创建爆炸*中，我们已经创建了我们的`ExplosionEffect.java`类文件。现在，我们只剩下最后一个任务：在屏幕上生成我们的爆炸。现在，仅作参考，我们将查看我们将用于爆炸文件的图像：
- en: '![](img/B05066_08_01.png)`Explosion.png` file sprite sheet'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/B05066_08_01.png)`Explosion.png`文件精灵图集'
- en: Note that the last frame of our explosion has almost no image in it. This is
    because we are not going to destroy this object; we are simply going to spawn
    it and let it play its animation for now.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们爆炸的最后几帧几乎没有任何图像。这是因为我们不会销毁这个对象；我们只是简单地生成它，并让它现在播放其动画。
- en: Let's proceed and get our explosion running on our game screen. Again, here
    we will break down our process into simple steps.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前进，让我们的爆炸在游戏屏幕上运行。同样，我们将我们的过程分解成简单的步骤。
- en: Creating variables
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建变量
- en: 'As you should be aware by now, we will work on our `GameView.java` file to
    display our explosion. So, open up your `GameView.java` file. We will start by
    creating a few variables, as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如您现在所知，我们将处理我们的`GameView.java`文件来显示爆炸。所以打开你的`GameView.java`文件。我们将首先创建一些变量，如下所示：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We created the `explosionEffect` variable to get a reference to our `ExplosionEffect`
    class and the other variables we have created in order to make our player reset
    after it collides. So, basically, what we will do is that once the player collides
    with a rock, an explosion animation will play and the player will get reset to
    the initial state.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了`explosionEffect`变量来获取对`ExplosionEffect`类以及其他我们创建的变量的引用，以便在玩家碰撞后重置玩家。所以，基本上，我们将要做的是一旦玩家与一块石头碰撞，就会播放爆炸动画，并且玩家将重置到初始状态。
- en: Some optimizations and improvements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些优化和改进
- en: 'We will do some optimizations to our game by shifting our `mainThread` after
    our surface has been created. So, we will remove `mainThread = new MainGameThread(getHolder(),
    this);` from our constructor and write it just above the place where we start
    running it in our `surfaceCreated()` method, as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过在创建表面后移动`mainThread`来对我们的游戏进行一些优化。因此，我们将从构造函数中移除`mainThread = new MainGameThread(getHolder(),
    this);`并将其写入我们在`surfaceCreated()`方法中开始运行它的地方，如下所示：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Looks neat! Now, we will also need to make a few improvements to our touch
    events because we will be resetting our game to its initial state if our player
    collides with a rock. So, we need to make sure that we can play only if our game is
    in a play mode or if a new game has been created or reset. So, we will modify
    our `onTouchEvent()` to look somewhat like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很整洁！现在，我们还需要对我们的触摸事件做一些改进，因为如果我们的玩家与一块石头碰撞，我们将重置游戏到初始状态。所以，我们需要确保只有在游戏处于播放模式或创建或重置了新游戏时才能播放。因此，我们将修改我们的`onTouchEvent()`，使其看起来如下：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we are simply setting up a few parameters for getting more control over
    our player movement. As you can see from our first `if` block, if `getPlaying()`,
    `newGameCreated` , and `reset` return a `false` value, then we will `setPlaying`
    to `true` and `setUp` to `true`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是设置了一些参数，以便更好地控制玩家移动。正如您从我们的第一个`if`块中可以看到，如果`getPlaying()`、`newGameCreated`和`reset`返回一个`false`值，那么我们将`setPlaying`设置为`true`，并将`setUp`设置为`true`。
- en: Also, if our `getPlaying()` is already `true`, then we will check whether the
    game has started; if not, we will set our `started` variable to `true`, `reset`
    to `false`, and `setUp()` to true.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们的`getPlaying()`已经是`true`，那么我们将检查游戏是否已经开始；如果没有，我们将`started`变量设置为`true`，`reset`设置为`false`，并将`setUp()`设置为`true`。
- en: Now, we are set with our new game, playing, and reset logic for playing the
    game. We handle our reset variables here, but we also have to handle them in the
    `newGame()` function that we created earlier. However, before we do that, let's
    reference our explosion effect and tell it exactly where and when to spawn.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经设置了新游戏、游戏和重置逻辑，以便玩游戏。我们在这里处理重置变量，但还必须在之前创建的`newGame()`函数中处理它们。然而，在我们这样做之前，让我们引用我们的爆炸效果并确切地告诉它在哪里以及何时生成。
- en: Spawning our explosion
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成我们的爆炸效果
- en: 'We need our explosion to spawn after our player has collided with our rocks.
    Once our player collides with a rock, the game is over. So, all of that is handled
    in our `update()` function wherein we have already created an else block for our
    `newGame()` function to be called. Let''s utilize that and write our logic to
    spawn an explosion. Our objective here is as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要爆炸在玩家与我们的岩石碰撞后生成。一旦玩家与岩石碰撞，游戏就结束了。所以，所有这些都已经在我们的`update()`函数中处理，其中我们已经为`newGame()`函数创建了一个else块。让我们利用这个块并编写我们的生成爆炸的逻辑。我们的目标是以下内容：
- en: Spawn the explosion effect
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成爆炸效果
- en: Start a counter to wait for a certain time after a collision
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在碰撞后启动计时器等待一段时间
- en: Reset the game after a certain time
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一定时间后重置游戏
- en: Note here that the dimensions of our image are 500 x 500, so we will be splitting
    our image into equal parts for each of our frames, thereby giving us 25 parts,
    which are 100 x 100 in dimension. We will pass each into our constructor as width,
    height, and number of frames. If the dimensions of the image that you are using
    for your game are different, then you need to calculate your dimensions and then
    use the values as per your image size.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的图像尺寸是500 x 500，因此我们将把我们的图像分成每个帧的相等部分，从而得到25个部分，每个部分尺寸为100 x 100。我们将每个部分传递给我们的构造函数作为宽度、高度和帧数。如果您用于游戏的图像尺寸不同，那么您需要计算您的尺寸，然后使用与您的图像尺寸相应的值。
- en: 'We will go to our `else` block of the `update()` function and modify our previously
    written code to look like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将进入`update()`函数的`else`块并修改我们之前编写的代码，使其看起来像这样：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So, here we are resetting our player's `y` acceleration and spawning our explosion.
    Then, after waiting for a certain period of time, we call in the function to reset
    our game.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在正在重置玩家的`y`加速度并生成我们的爆炸。然后，在等待一段时间后，我们调用函数来重置我们的游戏。
- en: Drawing the explosion on the screen
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在屏幕上绘制爆炸效果
- en: 'We still have to draw our explosion effect on the screen, and yes, you are
    right! We will do so in our `draw()` method. We also have to make sure that we
    draw our explosion only once, that is, at the start of the game, and so we will
    use our started variable to keep track of it:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要在屏幕上绘制我们的爆炸效果，是的，您说得对！我们将在我们的`draw()`方法中这样做。我们还必须确保我们只绘制一次爆炸，即在游戏开始时，因此我们将使用我们的`started`变量来跟踪它：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We''re all set with our draw logic as well. We''re done with the entire logic
    for our explosion effect, and now your entire code for the `GameView.java` file
    should look somewhat like the following; all the changes done in this chapter
    are marked in bold:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了我们的绘制逻辑。我们已经完成了爆炸效果的整个逻辑，现在您的`GameView.java`文件的整个代码应该看起来像以下这样；本章所做的所有更改都以粗体标注：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'So, now you can test your explosion in the game by playing it on your device!:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在您可以通过在您的设备上玩游戏来测试您的爆炸效果！
- en: '![](img/B05066_08_02.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B05066_08_02.png)'
- en: Our explosion effect in action
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的爆炸效果正在发挥作用
- en: Kaboom! We're now done with our sprite explosion effect! Now, we will move on
    to the final part of this game-- the UI.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 咔嚓！我们现在完成了我们的精灵爆炸效果！现在，我们将继续进行这个游戏的最后一部分——UI。
- en: Creating the UI for our game
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的游戏创建UI
- en: 'If you are not familiar with the term the UI, you must be wondering what the
    heck is it? UI is an abbreviation for User Interface. To put simply, a UI can
    consist of all the information you need to display on your game screen or your
    onscreen controls. Common elements of a UI include the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉UI这个术语，你一定想知道这是什么？UI是用户界面的缩写。简单来说，UI可以包括你需要在游戏屏幕或屏幕控制上显示的所有信息。UI的常见元素包括以下内容：
- en: Text displayed on the screen
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 屏幕上显示的文本
- en: Buttons
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮
- en: Joystick pad
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操控盘
- en: Tutorial instructions
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指导说明
- en: 'In this part of our chapter, we will learn how to display text on the screen.
    We will also instruct the player how to play the game. We will display the following
    on our screen:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的这一部分，我们将学习如何在屏幕上显示文本。我们还将指导玩家如何玩游戏。我们将在屏幕上显示以下内容：
- en: Distance ran
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跑步距离
- en: Best score
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最佳得分
- en: Instructions on how to play
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏玩法说明
- en: 'So, here we have to display the best score. However, we haven''t created our
    best score variable yet. For this part, we will work entirely in our `GameView.java`
    file. So, let''s define our best score variable in this class:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这里我们需要显示最佳得分。然而，我们还没有创建最佳得分变量。对于这部分，我们将完全在我们的`GameView.java`文件中工作。所以，让我们在这个类中定义我们的最佳得分变量：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We're now ready to show our UI data on the screen. Our UI will be entirely based
    on the `draw()` function, and so we will define a method called as `drawText()`,
    which should be called from our `draw()` method in the class. So, before we actually
    call our `drawText()` method, let's write some code for it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好在屏幕上显示我们的UI数据。我们的UI将完全基于`draw()`函数，因此我们将定义一个名为`drawText()`的方法，它应该在我们的类中的`draw()`方法中被调用。所以，在我们实际调用`drawText()`方法之前，让我们为它编写一些代码。
- en: 'Before that, let''s calculate our best score first. Now, obviously, our best
    score will be calculated after our first game is over, so we will put that logic
    into our `newGame()` function. The logic for this is fairly simple. If our current
    score is greater than the `bestScore` that is initialized to `0`, then our `bestScore`
    equals our current score that we get through `playerCharacter.getScore();` and
    that would be in our `newGame()` function:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之前，让我们先计算最佳得分。显然，我们的最佳得分将在第一局游戏结束后计算，所以我们将这个逻辑放入`newGame()`函数中。这个逻辑相当简单。如果当前得分大于初始化为`0`的`bestScore`，那么我们的`bestScore`等于通过`playerCharacter.getScore();`获取的当前得分，这将在`newGame()`函数中：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Alright, that''s sorted, and now we have our `bestScore` variable ready to
    hold our best score; our `newGame()` function would look like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，问题解决了，现在我们有了`bestScore`变量，可以用来存储最佳得分；我们的`newGame()`函数看起来是这样的：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can now write our `drawText()` method. To do so, we will use the help of
    the `Paint` class in Android. The `Paint` class holds the information about style;
    color, and how to draw geometries, texts, and bitmaps. Using this class, we can define
    the color, size, and typeface of our text. Then using our canvas as a reference,
    we can draw text on our canvas. So let''s display our current distance and best
    score on the screen:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以编写我们的`drawText()`方法。为此，我们将使用Android中的`Paint`类。`Paint`类包含有关样式、颜色以及如何绘制几何图形、文本和位图的信息。使用这个类，我们可以定义文本的颜色、大小和字体。然后，以我们的画布作为参考，我们可以在画布上绘制文本。所以，让我们在屏幕上显示当前距离和最佳得分：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Okay, that looks awesome, but hey, we''re still left with one part: the tutorial.
    As soon as the game starts, we need to instruct the player how to play the game.
    So, we will add an `if` statement to control the visibility of our tutorial message.
    We will guide our player to `Tap To Start`, `Keep Pressed To Go Up`, and `Release
    To Go Down`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，看起来很棒，但是嘿，我们还有一个部分没有完成：教程。游戏开始时，我们需要指导玩家如何玩游戏。所以，我们将添加一个`if`语句来控制教程信息的可见性。我们将指导玩家进行“点击开始”、“按住向上移动”和“松开向下移动”：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Alright, we are done with our `drawText()` method, and in its entirety it would
    look like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经完成了`drawText()`方法，整体看起来是这样的：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, there''s one last thing remaining to do. We need to call our `drawText()`
    method. Any guesses where we will do this? We will do so in our `draw()` method
    of our class; let''s do it:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，还有最后一件事要做。我们需要调用我们的`drawText()`方法。你猜我们在哪里做这件事？我们将在我们类中的`draw()`方法中这样做；让我们来做吧：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You are all set with your code for displaying the text components on our screen
    and now have a working game with a UI to display your tutorial message, distance
    covered, and best score on the screen.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经完成了在屏幕上显示文本组件的代码，现在有一个带有UI的运行游戏，可以在屏幕上显示教程信息、已覆盖的距离和最佳得分。
- en: 'Let''s review our code changes that we did in this part of our chapter; code
    changes are marked in bold:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们在本章的这一部分所做的代码更改；代码更改以粗体标注：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you have completed all these steps, then you can go ahead and test your
    game on your device or emulator now. You will get an output like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经完成了所有这些步骤，那么你现在可以继续在你的设备或模拟器上测试你的游戏了。你将得到如下输出：
- en: '![](img/B05066_08_03.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B05066_08_03.png)'
- en: Tutorial displaying our message
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 显示我们信息的教程
- en: 'We can also see our score in the game while playing:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏过程中，我们也可以看到我们的得分：
- en: '![](img/B05066_08_04.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B05066_08_04.png)'
- en: Distance covered and best score updating as we play
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 随着游戏的进行，覆盖的距离和最佳得分更新
- en: So, here we wrap up our 2D game. Now, based on your understanding of the previous
    chapters, you can add in elements to this game such as coins, more obstacles,
    and anything that you can imagine. It is recommended by now that you customize
    this game as much as possible according to your understanding, or alternatively,
    you can also start creating a new game altogether.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们完成了我们的2D游戏。现在，基于你对前几章的理解，你可以向这个游戏中添加元素，比如金币、更多障碍，以及你能想象到的任何东西。现在建议你尽可能根据你的理解来定制这个游戏，或者你也可以完全开始创建一个新的游戏。
- en: Summary
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We created our explosion and displayed our tutorial message, distance covered,
    and best score on the screen.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建并显示了我们教程信息、已覆盖的距离和屏幕上的最佳得分。
- en: We learned how to create texts on the screen that helped us to display our score,
    and finally implemented our explosion logic to make the explosion appear on the
    screen after colliding with rocks. This is it for our 3D game. After this, you
    can build your game, test it on your device, or even tweak it further to add in
    more obstacles or make it as interesting as you want. You are only restricted
    by your imagination.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何在屏幕上创建文本，帮助我们显示得分，并最终实现了爆炸逻辑，使得在撞到岩石后爆炸会在屏幕上显示。这就是我们的3D游戏的全部内容。在此之后，你可以构建你的游戏，在你的设备上测试它，甚至进一步调整以添加更多障碍或使其变得尽可能有趣。你唯一受限制的是你的想象力。
- en: With this, we wrap up our 2D game, and we will take a look at how to make a
    shift into the 3D world in our next chapter.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们完成了我们的2D游戏，我们将在下一章中探讨如何过渡到3D世界。
