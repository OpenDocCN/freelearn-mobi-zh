- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Continuous Integration and Continuous Deployment
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成和持续部署
- en: After we complete the development and first deployment of our app, we must think
    of how to make the process smoother for consecutive deployments, and that’s where
    **Continuous integration/Continuous delivery** (**CI/CD**) comes in.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成应用的开发和首次部署后，我们必须考虑如何使后续部署的过程更加顺畅，这就是 **持续集成/持续交付**（**CI/CD**）的用武之地。
- en: In this chapter, we will learn how to use GitHub Actions to automate some of
    the manual tasks, such as deploying new builds to the Google Play Store. We will
    learn how to run tests on CI/CD pipelines and push builds to the Play Store using
    GitHub Actions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用 GitHub Actions 自动化一些手动任务，例如将新构建部署到 Google Play 商店。我们将学习如何在 CI/CD
    管道中运行测试，并使用 GitHub Actions 将构建推送到 Play Store。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Setting up GitHub Actions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 GitHub Actions
- en: Running lint checks and tests on GitHub Actions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 GitHub Actions 上运行 lint 检查和测试
- en: Deploying to Play Store using GitHub Actions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GitHub Actions 部署到 Play Store
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the instructions in this chapter, you will need to have Android Studio
    Hedgehog or later ([https://developer.android.com/studio](https://developer.android.com/studio))
    downloaded.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章的说明，您需要下载 Android Studio Hedgehog 或更高版本（[https://developer.android.com/studio](https://developer.android.com/studio)）。
- en: You can use the previous chapter’s code to follow the instructions in this chapter.
    You can find the code for this chapter at [https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterfourteen](https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterfourteen).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用上一章的代码来遵循本章的说明。您可以在[https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterfourteen](https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterfourteen)找到本章的代码。
- en: Setting up GitHub Actions
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 GitHub Actions
- en: Before we can understand GitHub Actions, we need to understand what CI/CD is.
    This is a process that allows us to automate the building, testing, and deployment
    of our code to production. CI/CD not only automates these processes but also integrates
    them into a single coherent pipeline. This ensures that code changes are more
    reliable and stable when deployed. The definition should emphasize the role of
    CI/CD in facilitating frequent and reliable updates. This is an especially important
    process as it aims to improve the speed, efficiency, and reliability of how we
    deliver our software.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们理解 GitHub Actions 之前，我们需要了解 CI/CD 是什么。这是一个允许我们自动化代码构建、测试和部署到生产的过程。CI/CD 不仅自动化了这些流程，还将它们整合到一个单一的连贯管道中。这确保了代码更改在部署时更加可靠和稳定。定义应该强调
    CI/CD 在促进频繁和可靠更新方面的作用。这是一个特别重要的过程，因为它旨在提高我们交付软件的速度、效率和可靠性。
- en: Benefits of CI/CD
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CI/CD 的好处
- en: 'Let’s go through some of the benefits of CI/CD:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 CI/CD 的一些好处：
- en: '**Fast release cycles**: CI/CD allows us to release our software faster and
    more frequently. This is because we are automating the process of building, testing,
    and deploying our code.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速发布周期**：CI/CD 允许我们更快、更频繁地发布我们的软件。这是因为我们正在自动化构建、测试和部署代码的过程。'
- en: '**Increased collaboration**: Since a lot of the processes are automated, we
    can focus on the code and the features we are building. This allows us to collaborate
    more effectively with our team.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强协作**：由于许多流程都是自动化的，我们可以专注于代码和正在构建的功能。这使得我们能够更有效地与团队协作。'
- en: '**Less manual work**: We are reducing the amount of manual work we do due to
    automation. This means we can focus on the code and the features we are building.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少手动工作**：由于自动化，我们正在减少所做的大量手动工作。这意味着我们可以专注于代码和正在构建的功能。'
- en: '**Improved quality**: Automating the process allows us to test our code more
    frequently and more effectively. This means we can catch bugs and errors earlier
    in the process.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高质量**：自动化流程使我们能够更频繁、更有效地测试我们的代码。这意味着我们可以在流程的早期阶段捕捉到错误和缺陷。'
- en: Now we have learned about the benefits of CI/CD, let us look at how CI/CD works
    in detail.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 CI/CD 的好处，让我们详细看看 CI/CD 的工作原理。
- en: How CI/CD works
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CI/CD 的工作原理
- en: 'Let us go through how CI/CD works:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 CI/CD 的工作原理：
- en: '**CI**: This is the process of automating the building and testing of our code.
    This is done every time we push our code to our repository. This allows us to
    catch bugs and errors earlier in the process. In this step, once we push or commit
    code to our remote repository, which can be hosted in GitHub, Gitlab, Bitbucket,
    and so on, we run checks and tests against these changes to ensure they are functional
    and meet the code quality standards. If the tests pass, we can merge the code
    into the main branch. If the tests fail, we can fix the code and run the tests
    again.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CI**: 这是自动化构建和测试我们代码的过程。每次我们将代码推送到我们的仓库时，都会执行这个过程。这使我们能够更早地捕捉到过程中的错误和缺陷。在这一步骤中，一旦我们将代码推送到或提交到远程仓库，这些仓库可以托管在GitHub、Gitlab、Bitbucket等，我们将对这些更改运行检查和测试，以确保它们是功能性的并且符合代码质量标准。如果测试通过，我们可以将代码合并到主分支。如果测试失败，我们可以修复代码并再次运行测试。'
- en: '**CD**: This is the process of automating the deployment of our code to production.
    This is done every time we push our code to our repository. This allows us to
    release our software faster and more frequently. This happens after the CI step.
    Once the changes are merged to the main or development branch, we can deploy the
    code to production or whichever environment it needs to be deployed to. This step
    aims at pushing minor changes to production more frequently. This allows us to
    release our software faster and more frequently.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CD**: 这是自动化将我们的代码部署到生产环境的过程。每次我们将代码推送到我们的仓库时，都会执行这个过程。这使我们能够更快、更频繁地发布我们的软件。这个过程发生在CI步骤之后。一旦更改合并到主分支或开发分支，我们就可以将代码部署到生产环境或需要部署到的任何环境。这一步骤旨在更频繁地将小更改推送到生产环境。这使我们能够更快、更频繁地发布我们的软件。'
- en: With this background, we can now look at GitHub Actions ([https://docs.github.com/en/actions](https://docs.github.com/en/actions)).
    GitHub Actions is a CI/CD tool that allows us to automate the building, testing,
    and deployment of our code. It is built into GitHub and is free to use up to certain
    limits. It is also extremely easy to use and set up.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个背景下，我们现在可以查看GitHub Actions ([https://docs.github.com/en/actions](https://docs.github.com/en/actions))。GitHub
    Actions是一个CI/CD工具，允许我们自动化代码的构建、测试和部署。它是GitHub内置的，并且在使用一定限制内是免费的。它也非常容易使用和设置。
- en: 'In the next section, we are going to set up GitHub Actions for our project
    that is in this repository: [https://github.com/PacktPublishing/Mastering-Kotlin-for-Android](https://github.com/PacktPublishing/Mastering-Kotlin-for-Android)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将为存储在本仓库中的项目设置GitHub Actions：[https://github.com/PacktPublishing/Mastering-Kotlin-for-Android](https://github.com/PacktPublishing/Mastering-Kotlin-for-Android)
- en: Setting up GitHub Actions
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置GitHub Actions
- en: 'To enable GitHub Actions in our project, follow these steps:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的项目中启用GitHub Actions，请按照以下步骤操作：
- en: 'Go to the **Actions** tab of our repository, as shown in the following screenshot:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往我们仓库的**操作**标签页，如下截图所示：
- en: '![Figure 14.1 – GitHub Actions tab](img/B19779_14_01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图14.1 – GitHub Actions标签页](img/B19779_14_01.jpg)'
- en: Figure 14.1 – GitHub Actions tab
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1 – GitHub Actions标签页
- en: 'This step will bring us to the GitHub Actions landing page:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤将带我们到GitHub Actions登录页面：
- en: '![Figure 14.2 – GitHub Actions landing page](img/B19779_14_02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图14.2 – GitHub Actions登录页面](img/B19779_14_02.jpg)'
- en: Figure 14.2 – GitHub Actions landing page
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2 – GitHub Actions 登录页面
- en: 'As seen in the preceding image, we have some suggested actions that we can
    use in our repository. For now, we will set the actions by ourselves, so let us
    click on the **set up a workflow yourself** option. This brings us to the following
    page:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前图所示，我们有一些建议的操作，我们可以在我们的仓库中使用。目前，我们将自己设置操作，因此让我们点击**自行设置工作流程**选项。这会带我们到以下页面：
- en: '![Figure 14.3 – New GitHub Action](img/B19779_14_03.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图14.3 – 新的GitHub Action](img/B19779_14_03.jpg)'
- en: Figure 14.3 – New GitHub Action
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3 – 新的GitHub Action
- en: As you can see in the preceding image, we have an editor for writing our workflow.
    Notice at the top we now have a new folder called `.github`. This is where we
    will store our workflow files. The editor saves the workflow file in the `.github/workflows`
    folder. By default, our workflow is named `main.yml`. On the right, we have templates
    that we can use to easily create our workflow.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，我们有一个用于编写工作流程的编辑器。注意，在顶部我们现在有一个名为`.github`的新文件夹。这是我们存储工作流程文件的地方。编辑器将工作流程文件保存在`.github/workflows`文件夹中。默认情况下，我们的工作流程命名为`main.yml`。在右侧，我们有模板，我们可以使用这些模板轻松创建我们的工作流程。
- en: 'For now, we are going to create our own workflow, so let us add the following
    code to our workflow:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建自己的工作流程，因此让我们将以下代码添加到我们的工作流程中：
- en: '[PRE0]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s understand the different fields in the preceding workflow file:'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们了解前面工作流程文件中的不同字段：
- en: '**name**: This is the name of our workflow. This will be displayed on the GitHub
    Actions page.'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**：这是我们工作流程的名称。这将在 GitHub Actions 页面上显示。'
- en: '**on**: This is the event that will trigger our workflow. In our case, we are
    triggering our workflow when we push code to the main branch.'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**触发条件**：这是我们将会触发工作流程的事件。在我们的例子中，当我们向主分支推送代码时，我们将触发工作流程。'
- en: '**workflow_dispatch**: This is a manual trigger that we can use to trigger
    our workflow from the GitHub Actions page. This is useful when we want to trigger
    our workflow manually.'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**workflow_dispatch**：这是一个手动触发器，我们可以用它从 GitHub Actions 页面触发我们的工作流程。当我们想手动触发工作流程时，这很有用。'
- en: '**jobs**: This is the job that will be run when our workflow is triggered.
    In our case, we have a job called **build**. This job will run on the latest version
    of Ubuntu as specified by the **runs-on** field.'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作业**：这是我们工作流程触发时将运行的作业。在我们的例子中，我们有一个名为 **build** 的作业。这个作业将在由 **runs-on**
    字段指定的最新版本的 Ubuntu 上运行。'
- en: '**steps**: This field contains the steps that will be run in our job. In our
    case, we have a single step that will run a command. This command will print out
    the event that triggered our workflow. A step can contain a shell command or an
    action from GitHub Marketplace.'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤**：此字段包含将在我们的作业中运行的步骤。在我们的例子中，我们有一个将运行命令的单个步骤。此命令将打印出触发我们工作流程的事件。步骤可以包含
    shell 命令或来自 GitHub Marketplace 的操作。'
- en: 'Click on the **Commit changes...** button. This will commit our workflow file
    to our repository and trigger our workflow. We can see the workflow running in
    the **Actions** tab, as shown in the following screenshot:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **提交更改...** 按钮。这将把我们的工作流程文件提交到我们的仓库并触发工作流程。我们可以在 **操作** 选项卡中看到工作流程正在运行，如下面的屏幕截图所示：
- en: '![Figure 14.4 – First GitHub Action](img/B19779_14_04.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.4 – 第一个 GitHub Action](img/B19779_14_04.jpg)'
- en: Figure 14.4 – First GitHub Action
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.4 – 第一个 GitHub Action
- en: 'In the preceding image, we can see the commit that triggered the workflow and
    the workflow itself. We can also see the job that was run and the step that was
    run. We can also see the output of the step. Additionally, we can see the time
    it took to run the workflow. If we tap the action, we can see more details:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图像中，我们可以看到触发工作流程的提交和工作流程本身。我们还可以看到运行的工作和运行的步骤。我们还可以看到步骤的输出。此外，我们还可以看到运行工作流程所需的时间。如果我们点击操作，我们可以看到更多详细信息：
- en: '![Figure 14.5 – Github Action details](img/B19779_14_05.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.5 – Github Action 详情](img/B19779_14_05.jpg)'
- en: Figure 14.5 – Github Action details
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.5 – Github Action 详情
- en: This shows the steps that were run and the time the job took to run. It also
    shows the total duration of the workflow.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了运行的步骤和作业运行所需的时间。它还显示了工作流程的总持续时间。
- en: This was a simple workflow that just printed out the event that triggered the
    workflow. We can also do more complex things in our workflow.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的流程，它只是打印出触发流程的事件。我们也可以在我们的流程中做更多复杂的事情。
- en: 'Let us see how we can set up Android-related actions in our workflow:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何在我们的工作流程中设置与 Android 相关的操作：
- en: Head to the newly created **.github/workflows** folder and edit the **main.yml**
    file.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到新创建的 **.github/workflows** 文件夹并编辑 **main.yml** 文件。
- en: 'Let us add the following code to our workflow below the previous command we
    ran in *step 3* of the previous section:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在上一节中 *步骤 3* 运行的命令下面添加以下代码：
- en: '[PRE1]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let us understand the preceding code:'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们了解前面的代码：
- en: We have created another step called `.yml` files are overly sensitive to indentation.
    So, we need to ensure that we indent our code correctly.
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经创建了一个名为 `.yml` 的步骤，这些文件对缩进非常敏感。因此，我们需要确保我们的代码缩进正确。
- en: 'Commit to the changes and the action will automatically run. We can see the
    workflow results and, looking at the job build, we can see all the steps that
    were run, as shown in the following screenshot:'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交更改，操作将自动运行。我们可以看到工作流程的结果，查看作业构建，我们可以看到所有运行的步骤，如下面的屏幕截图所示：
- en: '![Figure 14.6 – GitHub Action steps](img/B19779_14_06.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.6 – GitHub Action 步骤](img/B19779_14_06.jpg)'
- en: Figure 14.6 – GitHub Action steps
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.6 – GitHub Action 步骤
- en: We now know what GitHub Actions are, have created our first action, and have
    seen how we can run Android-specific workflows on GitHub Actions. In the next
    section, we will run lint checks and tests in our workflow.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道了 GitHub Actions 是什么，已经创建了我们的第一个操作，并看到了如何在 GitHub Actions 上运行 Android
    特定的工作流程。在下一节中，我们将在我们的工作流程中运行代码检查和测试。
- en: Running lint checks and tests on GitHub Actions
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 GitHub Actions 上运行代码检查和测试
- en: 'In [*Chapter 11*](B19779_11.xhtml#_idTextAnchor135), we learned how to run
    lint checks on our project using shell commands on the terminal. We have also
    learned how to write tests for our code base. In this section, we are going to
    run the format, lint checks, and tests on our newly created actions and we will
    do all of this step by step:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第11章*](B19779_11.xhtml#_idTextAnchor135)中，我们学习了如何使用终端上的 shell 命令在我们的项目中运行
    lint 检查。我们还学习了如何为我们的代码库编写测试。在本节中，我们将对新建的动作运行格式、lint 检查和测试，并且我们将一步步完成：
- en: 'First, we will add the **ktlintCheck** step:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将添加 **ktlintCheck** 步骤：
- en: '[PRE2]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this code, we have added a step called `Run ktlintCheck`. This step will
    run the `ktlintCheck` command, which will check whether our code is formatted
    correctly. This step fails if our code is not formatted correctly.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此代码中，我们添加了一个名为 `Run ktlintCheck` 的步骤。此步骤将运行 `ktlintCheck` 命令，该命令将检查我们的代码是否格式正确。如果我们的代码格式不正确，此步骤将失败。
- en: 'Next, we add the **detekt** step:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加 **detekt** 步骤：
- en: '[PRE3]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this step, we run the `detekt` command, which will run the detekt checks
    on the code that we set up earlier in [*Chapter 11*](B19779_11.xhtml#_idTextAnchor135).
    This step fails if our code does not pass the detekt checks.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一步，我们运行 `detekt` 命令，它将对我们在[*第11章*](B19779_11.xhtml#_idTextAnchor135)中之前设置的代码执行
    detekt 检查。如果我们的代码未通过 detekt 检查，这一步将失败。
- en: 'Next, we add the test step:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加测试步骤：
- en: '[PRE4]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This step will run all the unit tests in our project. This step fails if any
    of the tests fail.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此步骤将运行我们项目中的所有单元测试。如果任何测试失败，此步骤将失败。
- en: 'Lastly, we add the step to run our instrumented tests:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们添加运行我们的仪器化测试的步骤：
- en: '[PRE5]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This step uses the `android-emulator-runner` action to run our instrumented
    tests on an emulator. This action sets up an emulator to run our instrumented
    tests in the CI environment. In the action configuration, we set up the following:'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这一步使用 `android-emulator-runner` 动作在模拟器上运行我们的仪器化测试。此动作在 CI 环境中设置模拟器以运行我们的仪器化测试。在动作配置中，我们设置了以下内容：
- en: '**working-directory**: This is where our project is located.'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**working-directory**：这是我们的项目所在的位置。'
- en: '**api-level**: This is the API level of the platform system image for our emulator.'
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**api-level**：这是模拟器平台系统镜像的 API 级别。'
- en: '**target**: This is the target for the system image of the emulator.'
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**target**：这是模拟器系统镜像的目标。'
- en: '**architecture**: We specify the architecture of the emulator we want to run
    our tests on.'
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**architecture**：我们指定我们想要在哪个架构上运行测试的模拟器。'
- en: '**disable-animations**: We disable animations in the emulator.'
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**disable-animations**：我们在模拟器中禁用动画。'
- en: Lastly, we specify the command we want to run using the script field. In this
    case, we run the **connectedCheck** task, which will run our instrumented tests.
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们使用脚本字段指定我们想要运行的命令。在这种情况下，我们运行 **connectedCheck** 任务，该任务将运行我们的仪器化测试。
- en: 'After making the preceding changes, commit the changes and the action will
    run. We can see the results of the action in the **Actions** tab, as shown in
    the following screenshot:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在进行上述更改后，提交更改，动作将运行。我们可以在 **Actions** 选项卡中查看动作的结果，如下面的截图所示：
- en: '![Figure 14.7 – More Github Actions steps](img/B19779_14_07.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.7 – 更多 Github Actions 步骤](img/B19779_14_07.jpg)'
- en: Figure 14.7 – More Github Actions steps
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.7 – 更多 Github Actions 步骤
- en: We’ve expanded our workflow by incorporating additional steps to perform lint
    checks and tests. We can see the results of each step. We can also see the time
    it took to run each step. The `Run connected test` step takes the longest time
    to run. This is because it must set up the emulator and run the tests.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过合并额外的步骤来扩展我们的工作流程，以执行 lint 检查和测试。我们可以看到每个步骤的结果。我们还可以看到每个步骤运行所需的时间。`Run connected
    test` 步骤运行时间最长。这是因为它必须设置模拟器并运行测试。
- en: 'We need to modify when the `main.yml` file runs. Currently, our workflow runs
    when we push code to the main branch. We are going to change this to also run
    when we create a pull request to the main branch. This is because we want to run
    our checks before we move our code to the main branch. To do this, we are going
    to add the `pull_request` event just above the `workflow_dispatch` event:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要修改 `main.yml` 文件运行的时间。目前，我们的工作流程在我们向主分支推送代码时运行。我们将将其更改为在创建主分支的 pull request
    时也运行。这是因为我们希望在将代码移动到主分支之前运行我们的检查。为此，我们将在 `workflow_dispatch` 事件之上添加 `pull_request`
    事件：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After making this change, we can commit the changes and the action will run.
    Let us now create a pull request to test the changes. Ensure that you pull all
    the changes that we made in our browser locally before proceeding with the following
    steps:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 进行此更改后，我们可以提交更改，并且操作将运行。现在让我们创建一个拉取请求来测试这些更改。在继续以下步骤之前，请确保您在我们的浏览器中本地拉取了我们所做的所有更改：
- en: First, let us create a new branch called **test**.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个名为**test**的新分支。
- en: 'Open the terminal in Android Studio and run the following command:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android Studio中打开终端并运行以下命令：
- en: '[PRE7]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, let us modify the app’s **versionName** and **versionCode** in our app-level
    **build.gradle.kts** file:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们修改我们的应用级别的**build.gradle.kts**文件中的**versionName**和**versionCode**：
- en: '[PRE8]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Tap **Sync Now** to sync these changes to our project.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**立即同步**以将这些更改同步到我们的项目中。
- en: 'After making the **versionName** and **versionCode** changes, we can commit
    the changes and push them to our remote repository. We can do this by running
    the following command in the terminal:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在对**versionName**和**versionCode**进行更改后，我们可以提交更改并将它们推送到我们的远程仓库。我们可以在终端中运行以下命令来完成此操作：
- en: '[PRE9]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This command stages all the changes we have made.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令将我们所做的所有更改标记为待提交。
- en: 'Next, we run the following command:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们运行以下命令：
- en: '[PRE10]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This command commits the changes we have made.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令提交我们所做的更改。
- en: 'Next, we run the following command:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们运行以下命令：
- en: '[PRE11]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This command pushes the changes to our remote repository.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令将更改推送到我们的远程仓库。
- en: 'Next, head to our repository in a browser, open the **Pull requests** tab,
    and click on the **New pull request** button. This will open the following page:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在浏览器中转到我们的仓库，打开**拉取请求**标签页，并点击**新建拉取请求**按钮。这将打开以下页面：
- en: '![Figure 14.8 – Create a new pull request](img/B19779_14_08.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图14.8 – 创建新的拉取请求](img/B19779_14_08.jpg)'
- en: Figure 14.8 – Create a new pull request
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.8 – 创建新的拉取请求
- en: On this page, we set the `base` branch and the `compare` branch. The `base`
    branch is the branch we want to merge our changes to. In our case, we want to
    merge our changes to the `main` branch. The `compare` branch is the branch that
    has recent changes. In our case, we want to merge changes from the `test` branch
    to the `main` branch. We can see the changes we have made as soon as we set the
    `compare` branch.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在此页面上，我们设置了`base`分支和`compare`分支。`base`分支是我们想要合并更改的分支。在我们的例子中，我们想要将更改合并到`main`分支。`compare`分支是包含最近更改的分支。在我们的例子中，我们想要将`test`分支的更改合并到`main`分支。我们可以在设置`compare`分支后立即看到我们所做的更改。
- en: 'Finalize the pull request by clicking on the **Create pull request** button.
    After creating the pull request, we can review the pull request details:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**创建拉取请求**按钮来最终确定拉取请求。创建拉取请求后，我们可以查看拉取请求的详细信息：
- en: '![Figure 14.9 – Pull request checks](img/B19779_14_09.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图14.9 – 拉取请求检查](img/B19779_14_09.jpg)'
- en: Figure 14.9 – Pull request checks
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.9 – 拉取请求检查
- en: As seen in the preceding image, the workflow checks have started running since
    we created a pull request and we specified that our workflow should run when we
    create a pull request. The **Merge pull request** button is disabled since the
    workflow is still running.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，工作流程检查已经开始运行，因为我们创建了一个拉取请求，并指定了当创建拉取请求时我们的工作流程应该运行。由于工作流程仍在运行，**合并拉取请求**按钮被禁用。
- en: 'Once the workflow is done running, we can merge the pull request. We can enforce
    even further rules per the checks but for now, we are good to go with the default
    behavior. Once the workflow completes and all checks pass, we should see the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦工作流程运行完成，我们就可以合并拉取请求。我们可以根据检查强制执行更进一步的规则，但就目前而言，我们默认的行为就足够了。一旦工作流程完成并且所有检查都通过，我们应该看到以下内容：
- en: '![Figure 14.10 – Pull request checks complete](img/B19779_14_10.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图14.10 – 拉取请求检查完成](img/B19779_14_10.jpg)'
- en: Figure 14.10 – Pull request checks complete
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.10 – 拉取请求检查完成
- en: We have now learned how to run lint checks and tests on GitHub Actions. In the
    next section, we are going to learn how to deploy our app to Google Play Store
    using GitHub Actions.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经学会了如何在GitHub Actions上运行lint检查和测试。在下一节中，我们将学习如何使用GitHub Actions将我们的应用部署到Google
    Play Store。
- en: Deploying to Play Store using GitHub Actions
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GitHub Actions部署到Play Store
- en: In [*Chapter 13*](B19779_13.xhtml#_idTextAnchor175), we learned how to deploy
    our app to Google Play Store using Google Play Console. However, in that chapter,
    we did it manually. In this chapter, we are going to learn how to deploy our app
    to Google Play Store using GitHub Actions. We are going to use the Google Play
    Publisher action to deploy our app to Google Play Store. This action is available
    in GitHub Marketplace.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 13 章*](B19779_13.xhtml#_idTextAnchor175) 中，我们学习了如何使用 Google Play Console
    将我们的应用部署到 Google Play 商店。然而，在第 13 章中，我们是手动完成的。在本章中，我们将学习如何使用 GitHub Actions 将我们的应用部署到
    Google Play 商店。我们将使用 Google Play Publisher 动作将我们的应用部署到 Google Play 商店。此动作可在 GitHub
    市场中找到。
- en: 'Before we can write our workflow, we need to do some setup. We need to create
    a service account on our Google Play Store account. We can do this by following
    these steps:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以编写我们的工作流程之前，我们需要做一些设置。我们需要在我们的 Google Play 商店账户中创建一个服务账户。我们可以通过以下步骤来完成此操作：
- en: 'Configure the service account in Google Cloud Platform by following these steps:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下步骤在 Google Cloud Platform 中配置服务账户：
- en: Navigate to [https://cloud.google.com/gcp](https://cloud.google.com/gcp).
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 [https://cloud.google.com/gcp](https://cloud.google.com/gcp)。
- en: Navigate to **IAM and admin** | **Service accounts** | **Create** **service
    account**.
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 **IAM 和管理员** | **服务账户** | **创建** **服务账户**。
- en: Pick a name and add appropriate permissions, for example, owner permissions.
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个名称并添加适当的权限，例如，所有者权限。
- en: Open the newly created service account, click on the **Keys** tab, and add a
    new JSON type key.
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开新创建的服务账户，点击 **密钥** 选项卡，并添加一个新的 JSON 类型密钥。
- en: When the key is successfully created, a JSON file will be automatically downloaded
    to your machine.
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当密钥成功创建后，一个 JSON 文件将自动下载到您的机器上。
- en: Store the content of this file in your GitHub repository secrets. You can do
    this by going to the **Settings** tab in your repository, clicking on the **Secrets
    and variables** section, and selecting the **Actions** option.
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此文件的内容存储在您的 GitHub 仓库密钥中。您可以通过进入仓库的 **设置** 选项卡，点击 **密钥和变量** 部分，并选择 **操作** 选项来完成此操作。
- en: Create a **New Repository Secret** and upload the JSON file. You can name the
    secret **GOOGLE_SERVICES_JSON**. This is the name we will use in our workflow
    to access the JSON file.
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 **新仓库密钥** 并上传 JSON 文件。您可以将其命名为 **GOOGLE_SERVICES_JSON**。这是我们将在我们的工作流程中使用以访问
    JSON 文件的名字。
- en: 'Add a user to Google Play Console by following these steps:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下步骤在 Google Play Console 中添加用户：
- en: Open [https://play.google.com/console](https://play.google.com/console) and
    pick your developer account.
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 [https://play.google.com/console](https://play.google.com/console) 并选择您的开发者账户。
- en: Open **Users** **and permissions**.
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **用户** **和权限**。
- en: Click on **Invite new user** and add the email of the service account created
    in step 1.
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **邀请新用户** 并添加步骤 1 中创建的服务账户的电子邮件。
- en: Grant permissions to the app to which you want the service account to deploy
    in-app permissions.
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 授予服务账户在应用中部署所需的权限。
- en: 'If you need more details on how to do this, you can check out the following
    link: [https://developers.google.com/android/management/service-account](https://developers.google.com/android/management/service-account)'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您需要更多关于如何操作的详细信息，您可以查看以下链接：[https://developers.google.com/android/management/service-account](https://developers.google.com/android/management/service-account)
- en: 'Like how we created the `GOOGLE_SERVICES_JSON` variable in our repository secrets,
    we need to add the details of our signing certificate to our variables so that
    we can use them on our CI/CD pipeline. The first step is to generate a `base64`-encoded
    version of our signing certificate. We can do this by running the following command
    in the terminal:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在仓库密钥中创建 `GOOGLE_SERVICES_JSON` 变量一样，我们需要将我们的签名证书的详细信息添加到我们的变量中，以便我们可以在
    CI/CD 管道中使用它们。第一步是生成我们的签名证书的 `base64` 编码版本。我们可以在终端中运行以下命令来完成此操作：
- en: '[PRE12]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You should run this command in the directory where you saved your keystore
    file. You could change the name to match the filename of the keystore file if
    you named yours differently. This command will generate a `base64`-encoded version
    of our keystore file. We can then copy the contents of the file and add it to
    our repository secrets. We need to also add the following secrets to our repository:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在保存您的 keystore 文件的目录中运行此命令。如果您将其命名为与 keystore 文件名匹配的名称，则可以进行更改。此命令将生成我们的
    keystore 文件的 `base64` 编码版本。然后我们可以复制文件内容并将其添加到我们的仓库密钥中。我们还需要将以下密钥添加到我们的仓库中：
- en: '![Figure 14.11 – Repository secrets](img/B19779_14_11.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.11 – 仓库密钥](img/B19779_14_11.jpg)'
- en: Figure 14.11 – Repository secrets
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.11 – 仓库密钥
- en: 'The newly created secrets are explained as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 新创建的秘密解释如下：
- en: '**KEYSTORE_PASSWORD**: This is the password of our keystore file'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**KEYSTORE_PASSWORD**：这是我们的密钥库文件的密码'
- en: '**KEY_ALIAS**: This is the alias of our keystore file'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**KEY_ALIAS**：这是我们的密钥库文件的别名'
- en: '**KEY_PASSWORD**: This is the password of our keystore file alias'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**KEY_PASSWORD**：这是我们的密钥库文件别名的密码'
- en: 'All these details should be like the ones we used when we created our keystore
    file. Now, let us write our workflow. Before writing the workflow, ensure that
    you have completed the publishing of our app steps in [*Chapter 13*](B19779_13.xhtml#_idTextAnchor175),
    since this is needed for this action to work. Let us head to the `.github/workflows`
    folder, create a new file called `deploy-to-playstore.yml`, and add the following
    code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些细节都应该与我们创建密钥库文件时使用的相同。现在，让我们编写我们的工作流程。在编写工作流程之前，请确保您已经完成了在[*第 13 章*](B19779_13.xhtml#_idTextAnchor175)中发布我们应用程序的步骤，因为这是此动作正常工作所需的。让我们前往
    `.github/workflows` 文件夹，创建一个名为 `deploy-to-playstore.yml` 的新文件，并添加以下代码：
- en: '[PRE13]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The workflow is remarkably similar to the one we created earlier on in the *Setting
    up GitHub Actions* and *Running lint checks and tests in GitHub Actions* sections
    with only slight differences. We have a step that bumps the `versionName` and
    `versionCode` for us instead of us having to do this manually every time. Versioning
    serves as a structured identifier for different software iterations. Employing
    semantic versioning aids in communicating the impact of changes, distinguishing
    major backward-incompatible updates, minor backward-compatible feature additions,
    and patch-level bug fixes. It plays a crucial role in dependency management, facilitating
    compatibility between different components. Additionally, versioning supports
    rollbacks, hotfixes, and efficient testing, ensuring the stability of the application.
    Release notes and communication are streamlined, providing users and stakeholders
    with clear insights into each release. Ultimately, versioning contributes to a
    reliable and predictable user experience, fostering trust and transparency throughout
    the software development life cycle.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流程与我们在“设置 GitHub Actions”和“在 GitHub Actions 中运行代码检查和测试”部分创建的工作流程非常相似，只有细微的差别。我们有一个步骤可以自动增加
    `versionName` 和 `versionCode`，而不是每次都手动进行。版本号作为不同软件迭代的结构化标识符。采用语义版本控制有助于传达更改的影响，区分主要不兼容更新、次要兼容性功能添加和补丁级别的错误修复。它在依赖关系管理中发挥着关键作用，促进不同组件之间的兼容性。此外，版本控制支持回滚、热修复和高效测试，确保应用程序的稳定性。发布说明和沟通流程简化，为用户和利益相关者提供对每个发布的清晰洞察。最终，版本控制有助于提供可靠和可预测的用户体验，在整个软件开发生命周期中促进信任和透明度。
- en: 'We have another step that builds a signed `upload-google-play` action, which
    automates and makes the process easier. We do the configurations on this action,
    such as specifying our service account, the package name of our app on Play Store,
    the directory where our signed AAB will be found, and lastly, the track that we
    want to deploy to. Pushing the changes to the main branch will trigger the actions
    again and once the `deploy-to-playstore` workflow is complete, we should see a
    new internal testing release on our Play Store page, as shown in the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个步骤构建一个签名的 `upload-google-play` 动作，这自动化并简化了流程。我们在该动作上进行配置，例如指定我们的服务账户、我们在
    Play Store 上的应用程序包名、我们的签名 AAB 将被找到的目录，以及最后，我们想要部署的轨道。将更改推送到主分支将再次触发动作，一旦 `deploy-to-playstore`
    工作流程完成，我们应该在我们的 Play Store 页面上看到一个新内部测试版本，如下所示：
- en: '![Figure 14.12 – New internal testing release](img/B19779_14_12.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.12 – 新内部测试版本](img/B19779_14_12.jpg)'
- en: Figure 14.12 – New internal testing release
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.12 – 新内部测试版本
- en: We have completed putting in place our CI/CD process. We only do this setup
    once and we can always use it to make deployments and automated testing easier,
    faster, and more reliable for us.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了 CI/CD 流程的建立。我们只需设置一次，就可以始终使用它来简化部署和自动化测试，使其对我们来说更加容易、快速和可靠。
- en: Summary
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to use GitHub Actions to automate some manual
    tasks, such as deploying new builds to the Play Store. Additionally, we learned
    how to run lint checks and tests on CI/CD pipelines and push builds to Google
    Play Store using GitHub Actions.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用 GitHub Actions 自动化一些手动任务，例如将新的构建部署到 Play Store。此外，我们还学习了如何在 CI/CD
    管道中运行代码检查和测试，并使用 GitHub Actions 将构建推送到 Google Play Store。
- en: In the next chapter, we will learn about techniques to improve our apps by adding
    analytics, using Firebase Crashlytics, and using cloud messaging to increase user
    engagement in our apps. Additionally, we will learn some tips and tricks for securing
    our apps.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习通过添加分析、使用Firebase Crashlytics以及使用云消息来提高我们应用的用户参与度的技术。此外，我们还将了解一些确保我们应用安全性的技巧和窍门。
