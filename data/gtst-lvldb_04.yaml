- en: Chapter 4. Iteration and Searching Keys
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章. 遍历和搜索键
- en: '[Chapter 3](ch03.html "Chapter 3. Basic Key-value Operations – Creating and
    Deleting Data"), *Basic Key-value Operations Creating and Deleting Data*, found
    that `Put`, `Get`, and `Delete` values by keys was all we needed, but some way
    of getting more than one value back at a time is generally very useful. If you
    don''t know what data may be in your keys, then you need a way to search for partial
    matches or just start from the beginning of the database. This ability to search
    for and iterate through keys in sorted order is what completes LevelDB''s ability
    to be the foundation of a database. The default sorting order is a `BytewiseComparator`,
    effectively ASCII.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[第3章](ch03.html "第3章. 基本键值操作 – 创建和删除数据"), *基本键值操作 创建和删除数据*，发现我们只需要通过键来`Put`、`Get`和`Delete`值，但有时一次获取多个值的方式通常非常有用。如果你不知道你的键中可能包含什么数据，那么你需要一种方法来搜索部分匹配或者从数据库的起始位置开始搜索。这种按顺序搜索和遍历键的能力，使得LevelDB能够成为数据库基础的能力得以完善。默认的排序顺序是`BytewiseComparator`，实际上是ASCII排序。'
- en: Introducing Sample04 to show you loops and searches
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Sample04以展示循环和搜索
- en: '`Sample04` uses the same `LevelDbHelpers.h` as before. Please download the
    entire sample and look at `main04.cpp` to see the code in context. Running `Sample04`
    starts by printing the output from the entire database, as shown in the following
    screenshot:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sample04`使用与之前相同的`LevelDbHelpers.h`。请下载整个示例，查看`main04.cpp`以了解代码的上下文。运行`Sample04`首先会打印出整个数据库的输出，如下面的截图所示：'
- en: '![Introducing Sample04 to show you loops and searches](img/1015OS_04_01.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![介绍Sample04以展示循环和搜索](img/1015OS_04_01.jpg)'
- en: Console output of listing keys
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 列出键的控制台输出
- en: Creating test records with a loop
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用循环创建测试记录
- en: 'The test data being used here was created with a simple loop and forms a linked
    list as well. It is explained in more detail in the Simple Relational Style section.
    The loop creating the test data uses the new C++11 range-based for style of the
    loop:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的测试数据是通过一个简单的循环创建的，形成了一个链表。在简单关系型风格部分有更详细的解释。创建测试数据的循环使用了新的C++11基于范围的循环风格：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note how we're using a `string` to hang onto the `prevKey`. There may be a temptation
    to use a `Slice` here to refer to the previous value of `key`, but remember the
    warning about a `Slice` only having a data pointer. This would be a classic bug
    introduced with a `Slice` pointing to a value that can be changed underneath it!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何使用一个`string`来保留`prevKey`的。这里可能会有使用`Slice`来引用`key`的前一个值的诱惑，但请记住关于`Slice`只有数据指针的警告。这将是一个由`Slice`指向其下可以更改的值的经典错误！
- en: We're adding all the keys using a `WriteBatch` not just for consistency, but
    also so that the storage engine knows it's getting a bunch of updates in one go
    and can optimize the file writing. I will be using the term **Record** regularly
    from now on. It's easier to say than **Key-value Pair** and is also indicative
    of the richer, multi-value data we're storing.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用`WriteBatch`添加所有键，这不仅是为了保持一致性，而且为了让存储引擎知道它正在一次性接收大量的更新，并可以优化文件写入。从现在开始，我将经常使用术语**记录**。它比**键值对**更容易说，也表明了我们正在存储的更丰富、多值数据。
- en: Stepping through all the records with iterators
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用迭代器遍历所有记录
- en: The model for multiple record reading in LevelDB is a simple iteration. Find
    a starting point and then step forwards or backwards.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: LevelDB中多记录读取的模型是一个简单的迭代。找到一个起点，然后向前或向后移动。
- en: This is done with an `Iterator` object that manages the order and starting point
    of your stepping through keys and values. You call methods on `Iterator` to choose
    where to start, to step and to get back the key and value. Each `Iterator` gets
    a consistent snapshot of the database, ignoring updates during iteration. Create
    a new `Iterator` to see changes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过一个管理你遍历键和值的顺序和起点的`Iterator`对象来完成的。你可以在`Iterator`上调用方法来选择开始的位置，移动，并获取键和值。每个`Iterator`都会得到数据库的一致快照，忽略迭代过程中的更新。创建一个新的`Iterator`来查看变化。
- en: If you have used declarative database APIs such as SQL-based databases, you
    would be used to performing a query and then operating on the results. Many of
    these APIs and older, record-oriented databases have a concept of a **cursor**
    which maintains the current position in the results which you can only move forward.
    Some of them allow you to move the cursor to the previous records. Iterating through
    individual records may seem clunky and old-fashioned if you are used to getting
    collections from servers. However, remember LevelDB is a local database. Each
    step doesn't represent a network operation!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用过基于SQL的声明性数据库API，你会习惯于执行查询然后操作结果。许多这些API和较老的、以记录为中心的数据库有一个**游标**的概念，它维护结果中的当前位置，你只能向前移动。其中一些允许你将游标移动到之前的记录。如果你习惯于从服务器获取集合，那么逐个记录迭代可能会显得笨拙且过时。然而，记住LevelDB是一个本地数据库。每一步都不代表一个网络操作！
- en: The **iterable cursor** approach is all that LevelDB offers, called an `Iterator`.
    If you want some way of mapping a collected set of results directly to a **listbox**
    or other containers, you will have to implement it on top of the `Iterator`, as
    we will see later.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**可迭代游标**的方法是LevelDB提供的所有方法，称为`Iterator`。如果你想以某种方式将收集到的结果集直接映射到**列表框**或其他容器，你将不得不在`Iterator`之上实现它，就像我们稍后将要看到的那样。'
- en: 'Iterating forwards, we just get an `Iterator` from our database and jump to
    the first record with `SeekToFirst()`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 向前迭代时，我们只需从数据库中获取一个`Iterator`并使用`SeekToFirst()`跳转到第一个记录：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Going backwards is very similar, but inherently less efficient as a storage
    trade-off:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 向后搜索非常相似，但作为存储权衡，本质上效率较低：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you wanted to see the value as well as the keys, just use the `value()`
    method on the iterator (the test data in `Sample04` would make it look a bit confusing
    so it isn''t being done here):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想同时看到值和键，只需在迭代器上使用`value()`方法（`Sample04`中的测试数据可能会让它看起来有些混乱，所以这里没有这样做）：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Unlike some other programming iterators, there's no concept of a special forward
    or backward iterator and no obligation to keep going in the same direction. Consider
    searching an HR database for the ten highest-paid managers. With a key of *Job+Salary*,
    you would iterate through a range until you know you have hit the end of the managers,
    then iterate backwards to get the last ten.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 与一些其他编程迭代器不同，没有特殊的前向或后向迭代器的概念，也没有义务保持相同方向继续。考虑搜索一个HR数据库中薪酬最高的十位经理。使用*Job+Salary*作为键，你会迭代一个范围，直到你知道已经到达了经理的末尾，然后向后迭代以获取最后十位。
- en: An iterator is created by `NewIterator()`, so you have to remember to delete
    it or it will leak memory. Iteration is over a consistent snapshot of the data,
    and any data changes through `Put`, `Get`, or `Delete` operations won't show until
    another `NewIterator()` is created.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`NewIterator()`创建迭代器，所以你必须记得删除它，否则会导致内存泄漏。迭代是在数据的一致快照上进行的，并且通过`Put`、`Get`或`Delete`操作所做的任何数据更改都不会显示，直到创建另一个`NewIterator()`。
- en: Searching for ranges of keys
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索键的范围
- en: The second half of the console output is from our examples of iterating through
    partial keys, which are case-sensitive by default, with the default `BytewiseComparator`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出的后半部分是我们迭代部分键的示例，这些键默认是区分大小写的，使用默认的`BytewiseComparator`。
- en: '![Searching for ranges of keys](img/1015OS_04_02.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![搜索键的范围](img/1015OS_04_02.jpg)'
- en: Console output of searches
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索的控制台输出
- en: As we've seen many times, the `Get` function looks for an **exact** match for
    a key. However, if you have an `Iterator`, you can use `Seek` and it will jump
    to the first key that either matches exactly or is immediately after the partial
    key you specify.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们多次看到的，`Get`函数寻找键的**精确**匹配。然而，如果你有一个`Iterator`，你可以使用`Seek`，它会跳转到第一个与指定的部分键完全匹配或紧随其后的键。
- en: 'If we are just looking for keys with a common prefix, the optimal comparison
    is using the `starts_with` method of the `Slice` class:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只是寻找具有公共前缀的键，最优的比较方法是使用`Slice`类的`starts_with`方法：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Going backwards is a little bit more complicated. We use a key that is guaranteed
    to fail. You could think of it as being between the last key starting with our
    prefix and the next key out of the desired range. When we `Seek` to that key,
    we need to step once to the previous key. If that''s valid and matching, it''s
    the last key in our range:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 向后搜索稍微复杂一些。我们使用一个保证失败的键。你可以将其视为位于以我们的前缀开始的最后一个键和所需范围之外的下一个键之间。当我们`Seek`到那个键时，我们需要向前移动一步到前一个键。如果这是有效的并且匹配的，那么它就是我们的范围内的最后一个键：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'What if you want to get keys within a range? For the first time, I disagree
    with the documentation included with LevelDB. Their iteration example shows a
    similar loop to that shown in the following code, but checks the key values with
    `idb->key().ToString() < limit`. That is a more expensive way to iterate keys
    as it''s generating a temporary string object for every key being checked, which
    is expensive if there were thousands in the range:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想获取一个范围内的键？第一次，我不同意LevelDB附带文档中的说明。他们的迭代示例显示了与以下代码中显示的类似循环，但使用`idb->key().ToString()
    < limit`检查键值。这是一个更昂贵的迭代键的方式，因为它为每个被检查的键生成一个临时的字符串对象，如果范围内有数千个键，这将是昂贵的：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can use another built-in method of `Slice`; the `compare()` method, which
    returns a result <0, 0, or >0 to indicate if `Slice` is less than, equal to, or
    greater than the other `Slice` it is being compared to. This is the same semantics
    as the standard C `memcpy`. The code shown in the previous snippet will find keys
    that are the same, or after the `startKey` and are before the `endKey`. If you
    want the range to include the `endKey`, change the comparison to `compare(endKey)
    <= 0`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Slice`的另一个内置方法；`compare()`方法，它返回一个结果<0, 0, 或>0，以指示`Slice`是否小于、等于或大于它正在比较的其他`Slice`。这与标准C的`memcpy`语义相同。前面代码片段中显示的代码将找到与`startKey`相同或之后的键，并且在`endKey`之前。如果你想使范围包括`endKey`，将比较改为`compare(endKey)
    <= 0`。
- en: Linking records in a simple relational style
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以简单关系风格链接记录
- en: 'There are many ways to implement richer relational indexing which will be discussed
    later. This simple example shows the value associated with a key storing both,
    some data and another key value. It is the classic linked list of records:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以实现更丰富的关系索引，这将在稍后讨论。这个简单的例子显示了与一个键关联的值，它存储了数据以及另一个键值。这是经典的记录链表：
- en: '![Linking records in a simple relational style](img/1015OS_04_03.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![以简单关系风格链接记录](img/1015OS_04_03.jpg)'
- en: The chain of keys followed by storing a key in the value
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 键的链随后存储一个键的值
- en: As you can see, each record contains the information to find another related
    record. In this case, the relationship is just that the records were created in
    a particular order but it could be any consistent meaning, for example, a parent-child
    relationship.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，每个记录都包含查找另一个相关记录的信息。在这种情况下，关系仅仅是记录以特定的顺序创建，但它可以是任何一致的意义，例如，父子关系。
- en: 'The loop we saw earlier, creating the records composed the record value by
    storing a combination `prevKey + "\tsome more content` (where "some more content")
    would normally vary per-record. We extract that previous key and use it to navigate
    to another record:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到的循环，创建记录通过存储一个组合`prevKey + "\tsome more content"`（其中"some more content"通常每个记录都不同）来组成记录值。我们提取那个前一个键并使用它来导航到另一个记录：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note how we used a simple tab character as the separator in the record value,
    between the next key to use and the text which was the real content. This principle
    is the same as a relational database; key values for other searches are contained
    in a record. This example only has one kind of a record data. In the next chapter,
    we will use this technique to build a secondary index where phone number keys
    are used to find the main record key. If you need to find data, adding multiple
    keys is the only way to achieve speed.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们在记录值中使用了简单的制表符作为分隔符，在下一个要使用的键和实际内容之间的文本。这个原则与关系数据库相同；其他搜索的键值包含在记录中。这个例子只有一种记录数据。在下一章中，我们将使用这种技术构建一个二级索引，其中使用电话号码键来查找主记录键。如果你需要查找数据，添加多个键是唯一实现速度的方法。
- en: Summary
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned the concept of an iterator in LevelDB as a way to
    step through records sorted by their keys. The database became far more useful
    with searches to get the starting point for the iterator, and samples showing
    how to efficiently check keys as you step through a range. Finally, we went back
    to the simple `Get` for a key lookup to help implement a linked list through the
    database. Now, we will leave C++ behind for the world of Objective-C.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们学习了LevelDB中迭代器的概念，作为按其键排序的记录遍历的方式。数据库通过搜索来获取迭代器的起始点，以及示例展示了如何有效地在遍历范围时检查键。最后，我们回到了简单的`Get`来查找键，以帮助通过数据库实现链表。现在，我们将离开C++，进入Objective-C的世界。
