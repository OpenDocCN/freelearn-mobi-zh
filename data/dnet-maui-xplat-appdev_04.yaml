- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: User Interface Design with XAML
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 XAML 进行用户界面设计
- en: In the previous chapter, we created a new .NET MAUI project named `PassXYZ.Vault`.
    As we progress through this book, we will enhance it with the skills and knowledge
    we acquire. In the last chapter, we got a glimpse of user interface implementation
    in XAML. In this chapter, we will delve deeper into creating user interfaces using
    XAML.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了一个名为 `PassXYZ.Vault` 的新 .NET MAUI 项目。随着我们阅读本书的进展，我们将使用所获得的技术和知识对其进行增强。在上一章中，我们简要了解了
    XAML 中用户界面的实现。在本章中，我们将更深入地探讨使用 XAML 创建用户界面。
- en: The **eXtensible Application Markup Language (XAML)** is an XML-based language
    that is used to define user interfaces for **Windows Presentation Foundation (WPF)**,
    **Universal Windows Platform (UWP)**, Xamarin.Forms, and .NET MAUI. The XAML dialects
    in these platforms share the same syntax but differ in their vocabularies.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**可扩展应用程序标记语言 (XAML)** 是一种基于 XML 的语言，用于定义 **Windows Presentation Foundation
    (WPF)**、**通用 Windows 平台 (UWP)**、Xamarin.Forms 和 .NET MAUI 的用户界面。这些平台中的 XAML 语法相同，但词汇不同。'
- en: XAML allows developers to define user interfaces in XML-based *markup language*
    rather than in any *programming language*. It is possible to write all our user
    interfaces in code, but user interface design with XAML will be more succinct
    and more visually coherent. Because XAML does not use a programming language,
    it cannot contain code. This is a disadvantage, but it is also an advantage as
    it forces the developer to separate the logic from the user interface design.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: XAML 允许开发者在基于 XML 的 *标记语言* 中而不是任何 *编程语言* 中定义用户界面。我们可以在代码中编写所有用户界面，但使用 XAML 进行用户界面设计将更加简洁且视觉上更连贯。由于
    XAML 不使用编程语言，因此它不能包含代码。这是一个缺点，但也是一个优点，因为它迫使开发者将逻辑与用户界面设计分离。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: How to create a XAML page
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建 XAML 页面
- en: Basic XAML syntax
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本XAML语法
- en: XAML markup extension
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XAML 标记扩展
- en: How to design user interfaces with the master-detail pattern
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用主-详细信息模式设计用户界面
- en: Localization of .NET MAUI apps
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET MAUI应用的本地化
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To test and debug the source code in this chapter, you need to have Visual Studio
    2022 installed on your PC. Please refer to the *Development environment setup*
    section in *Chapter 1*, *Getting Started with .NET MAUI*, for the details.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试和调试本章中的源代码，您需要在您的电脑上安装 Visual Studio 2022。请参阅 *第 1 章*，*开始使用 .NET MAUI* 中的
    *开发环境设置* 部分，以获取详细信息。
- en: 'The source code for this chapter is available in the following GitHub repository:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可在以下 GitHub 仓库中找到：
- en: '[https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/2nd/chapter03](https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/2nd/chapter03)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/2nd/chapter03](https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/2nd/chapter03)'
- en: 'To check out the source code of this chapter, we can use the following command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看本章的源代码，我们可以使用以下命令：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To find out more about the source code in this book, please refer to the *Managing
    the source code in this book* section in *Chapter 2*, *Building Our First .NET
    MAUI App*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本书中源代码的信息，请参阅 *第 2 章*，*构建我们的第一个 .NET MAUI 应用* 中的 *管理本书中的源代码* 部分。
- en: Creating a XAML page
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 XAML 页面
- en: Before we delve into XAML syntax, let’s first understand how to create a XAML
    page in Visual Studio and through the **dotnet** command line.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨 XAML 语法之前，让我们首先了解如何在 Visual Studio 中以及通过 **dotnet** 命令行创建 XAML 页面。
- en: 'To create a XAML page using Visual Studio, right-click on the project node,
    then select **Add > New Item…**. This will bring up the dialog box shown in *Figure
    3.1*:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Visual Studio 创建 XAML 页面，请右键单击项目节点，然后选择 **添加 > 新项…**。这将弹出如图 3.1 所示的对话框：
- en: '![](img/B21554_03_01.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21554_03_01.png)'
- en: 'Figure 3.1: Adding a XAML page'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1：添加 XAML 页面
- en: On this screen, select **Content Page** from the templates and click **Add**.
    This action will generate a pair of files – a XAML file and a C# code-behind file.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在此屏幕上，从模板中选择 **内容页面** 并点击 **添加**。此操作将生成一对文件——一个 XAML 文件和一个 C# 后置代码文件。
- en: 'The same can be achieved using a `dotnet` command. To locate all .NET MAUI
    templates, we can use the following `dotnet` command in the PowerShell console:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 同样可以使用 `dotnet` 命令实现。为了定位所有 .NET MAUI 模板，我们可以在 PowerShell 控制台中使用以下 `dotnet`
    命令：
- en: '![](img/B21554_03_02.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21554_03_02.png)'
- en: 'Figure 3.2: dotnet command for listing templates'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2：列出模板的 dotnet 命令
- en: 'From the preceding output, we can observe that the short name of the XAML content
    page is `maui-page-xaml`. We can create a XAML page using the following command:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，我们可以观察到 XAML 内容页的短名为 `maui-page-xaml`。我们可以使用以下命令创建一个 XAML 页面：
- en: '![](img/B21554_03_03.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21554_03_03.png)'
- en: 'Figure 3.3: Creating a XAML page'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3：创建 XAML 页面
- en: The preceding command will generate two files named `ItemsPage.xaml` and `ItemsPage.xaml.cs`.
    You may notice a warning message about post-creation actions. This is a known
    issue, and you can find more information about it at [https://github.com/dotnet/maui/issues/4994](https://github.com/dotnet/maui/issues/4994).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个命令将生成两个名为 `ItemsPage.xaml` 和 `ItemsPage.xaml.cs` 的文件。你可能注意到了关于创建后操作的警告信息。这是一个已知问题，你可以在[https://github.com/dotnet/maui/issues/4994](https://github.com/dotnet/maui/issues/4994)找到更多关于它的信息。
- en: However, this is not something we need to worry about.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是我们需要担心的事情。
- en: '**What is the “code-behind”?**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是“后台代码”？**'
- en: In .NET MAUI, the term **code-behind** refers to the code file associated with
    a **user interface (UI)** definition file, typically a XAML file. The code-behind
    file contains the logic for handling UI events, data binding, and other app functionality
    related to the UI. The code-behind file is a C# (.cs) file with the same name
    as the related XAML file. For example, if we have an `ItemsPage.xaml` file, the
    code-behind file will be named `ItemsPage.xaml.cs`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET MAUI 中，术语 **后台代码** 指的是与 **用户界面（UI）** 定义文件关联的代码文件，通常是 XAML 文件。后台代码文件包含处理
    UI 事件、数据绑定和其他与 UI 相关的应用功能逻辑。后台代码文件是与相关 XAML 文件同名的 C# (.cs) 文件。例如，如果我们有一个 `ItemsPage.xaml`
    文件，后台代码文件将被命名为 `ItemsPage.xaml.cs`。
- en: The code-behind file includes a class that inherits from a .NET MAUI base page
    type, usually `ContentPage`, `NavigationPage`, or `TabbedPage`. The class declaration
    is marked as a partial class that matches the class definition in the XAML file,
    allowing for seamless integration between the XAML UI definition and its corresponding
    code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 后台代码文件包含一个从 .NET MAUI 基础页面类型继承的类，通常是 `ContentPage`、`NavigationPage` 或 `TabbedPage`。类声明被标记为与
    XAML 文件中的类定义匹配的部分类，这允许 XAML UI 定义与其对应的代码无缝集成。
- en: XAML syntax
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XAML 语法
- en: Since XAML is an XML-based language, to understand it better, we need to understand
    basic XML syntax first. In an XML file, it starts with an XML declaration or prolog.
    The content of XML or XAML files includes a hierarchy of elements. Each element
    may have attributes associated with it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 XAML 是一种基于 XML 的语言，为了更好地理解它，我们首先需要了解基本的 XML 语法。在 XML 文件中，它以一个 XML 声明或序言开始。XML
    或 XAML 文件的内容包括一系列元素。每个元素都可能与其关联一些属性。
- en: 'Let’s review `App.xaml` in the project that we created in *Chapter 2*, *Building
    Our First .NET MAUI App*, as an example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以我们在 *第 2 章* 中创建的项目为例，回顾 `App.xaml`，作为例子：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 3.1: `App.xaml` ([https://epa.ms/App3-1](https://epa.ms/App3-1))'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3.1: `App.xaml` ([https://epa.ms/App3-1](https://epa.ms/App3-1))'
- en: XML declaration
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XML 声明
- en: 'At the start of `App.xaml`, we can see the following XML declaration:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `App.xaml` 的开头，我们可以看到以下 XML 声明：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This declaration specifies the version of XML being used and the character encoding.
    In `App.xaml`, XML version 1.0 is used and the character encoding is set to UTF-8.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个声明指定了正在使用的 XML 版本和字符编码。在 `App.xaml` 中，使用了 XML 版本 1.0，并将字符编码设置为 UTF-8。
- en: Element
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元素
- en: In *Listing 3.1*, the content of `App.xaml` begins with the `Application` root
    element. Every XML document must contain a single root element that encompasses
    all other elements. Elements can have child elements, also known as nested elements,
    such as `ResourceDictionary`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *Listing 3.1* 中，`App.xaml` 的内容从 `Application` 根元素开始。每个 XML 文档必须包含一个根元素，它包含所有其他元素。元素可以有子元素，也称为嵌套元素，例如
    `ResourceDictionary`。
- en: 'Elements are composed of a start tag, the content, and an end tag, as seen
    in the `Application` tag:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 元素由开始标签、内容和结束标签组成，如 `Application` 标签所示：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The start tag is enclosed in angle brackets (e.g., `<Application>`), and the
    end tag includes a forward slash before the element name (e.g., `</Application>`).
    The content can be any text or nested elements.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 开始标签被括号（例如，`<Application>`）包围，结束标签在元素名称之前包含一个反斜杠（例如，`</Application>`）。内容可以是任何文本或嵌套元素。
- en: 'For an empty element, the end tag can be omitted by adding a forward slash
    at the end of the start tag, like so:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于空元素，可以在开始标签的末尾添加一个反斜杠来省略结束标签，如下所示：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When discussing an XML element, we may use the terms **element**, **node**,
    and **tag**. **Element** refers to the start and end tag of that element together.
    **Tag** refers to either the start or end tag of the element. **Node** refers
    to an element and all its inner content, including all child elements.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论 XML 元素时，我们可能会使用术语 **元素**、**节点** 和 **标签**。**元素**指的是该元素的开始和结束标签一起。**标签**指的是元素的开始或结束标签。**节点**指的是一个元素及其所有内部内容，包括所有子元素。
- en: A XAML document consists of many nested elements, with only one top element,
    known as the root element. In .NET MAUI, the root element is usually `Application`,
    `ContentPage`, `Shell`, or `ResourceDictionary`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 XAML 文档由许多嵌套元素组成，只有一个顶级元素，称为根元素。在 .NET MAUI 中，根元素通常是 `Application`、`ContentPage`、`Shell`
    或 `ResourceDictionary`。
- en: 'For each XAML file, we typically have a corresponding C# code-behind file.
    Let’s review the code-behind file in *Listing 3.2*:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个 XAML 文件，我们通常都有一个对应的 C# 代码隐藏文件。让我们回顾一下 *清单 3.2* 中的代码隐藏文件：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 3.2: `App.xaml.cs` ([https://epa.ms/App3-2](https://epa.ms/App3-2))'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '清单 3.2: `App.xaml.cs` ([https://epa.ms/App3-2](https://epa.ms/App3-2))'
- en: In XAML, elements usually represent actual C# classes that are instantiated
    to objects at runtime. Together, the XAML and code-behind files define a complete
    class. For example, `App.xaml` (*Listing 3.1*) and `App.xaml.cs` (*Listing 3.2*)
    define the `App` class, which is a sub-class of `Application`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在 XAML 中，元素通常代表实际在运行时实例化的 C# 类。XAML 和代码隐藏文件一起定义了一个完整的类。例如，`App.xaml` (*清单 3.1*)
    和 `App.xaml.cs` (*清单 3.2*) 定义了 `App` 类，它是 `Application` 的子类。
- en: '**(1)** The `App` class, whose full name is `PassXYZ.Vault.App`, is the same
    as the one defined in the XAML file using the `x:Class` attribute:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**(1**) `App` 类的全名是 `PassXYZ.Vault.App`，与使用 `x:Class` 属性在 XAML 文件中定义的相同：'
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**(2)** In the constructor of the `App` class, the `InitializeComponent` method
    is called to load the XAML and parse it. UI elements defined in the XAML file
    are created at this point. We can access these UI elements by the name defined
    with the `x:Name` attribute, as we’ll see shortly.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**(2**) 在 `App` 类的构造函数中，调用 `InitializeComponent` 方法来加载 XAML 并解析它。此时创建 XAML
    文件中定义的 UI 元素。我们可以通过 `x:Name` 属性定义的名称访问这些 UI 元素，正如我们很快将看到的。'
- en: Attribute
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性
- en: 'An element can have multiple unique attributes. An attribute provides additional
    information about XML elements. An XML attribute is a name-value pair attached
    to an element. In XAML, an element represents a C# class and the attributes represent
    the members of this class:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一个元素可以有多个唯一的属性。属性提供了关于 XML 元素额外信息。XML 属性是一个附加到元素上的名称-值对。在 XAML 中，一个元素代表一个 C#
    类，而属性代表这个类的成员：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As we can see in the above, four attributes – `x:Name`, `VerticalOptions`, `IsEnabled`,
    and `Text` – are defined for the `Button` element. To define an attribute, we
    need to specify the attribute’s name and value with an equal sign. The attribute
    value should be enclosed in double or single quotes. For example, `IsEnabled`
    is the attribute name and `"True"` is the attribute value.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所示，为 `Button` 元素定义了四个属性 – `x:Name`、`VerticalOptions`、`IsEnabled` 和 `Text`。要定义一个属性，我们需要使用等号指定属性名称和值。属性值应使用双引号或单引号括起来。例如，`IsEnabled`
    是属性名称，`"True"` 是属性值。
- en: In this example, the `x:Name` attribute is a special one. It does not refer
    to a member of the `Button` class, but rather refers to the variable holding the
    instance of the `Button` class. Without the `x:Name` attribute, an anonymous instance
    of the `Button` class will be created. With the `x:Name` attribute declared, we
    can refer to the instance of the `Button` class using the `loginButton` variable
    in the code-behind file.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`x:Name` 属性是一个特殊的属性。它并不指向 `Button` 类的成员，而是指向持有 `Button` 类实例的变量。如果没有 `x:Name`
    属性，将创建一个匿名的 `Button` 类实例。声明了 `x:Name` 属性后，我们可以通过代码隐藏文件中的 `loginButton` 变量来引用 `Button`
    类的实例。
- en: XML and XAML namespaces
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XML 和 XAML 命名空间
- en: 'In XML or XAML, we can declare namespaces just like we do in C#. Namespaces
    help to group elements and attributes to avoid name conflicts when the same name
    is used in a different scope. Namespaces can be defined using the `xmlns` attribute
    with the following syntax:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 XML 或 XAML 中，我们可以像在 C# 中一样声明命名空间。命名空间有助于将元素和属性分组，以避免在不同作用域中使用相同名称时的名称冲突。命名空间可以使用
    `xmlns` 属性和以下语法定义：
- en: 'The XAML namespace definition has two components: a prefix and an identifier.
    Both the prefix and the identifier can be any string, as allowed by the W3C namespaces
    in the XML 1.0 specification. If the prefix is omitted, the namespace becomes
    the default namespace.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: XAML 命名空间定义有两个组成部分：一个前缀和一个标识符。前缀和标识符可以是任何字符串，这由 XML 1.0 规范中允许的 W3C 命名空间所决定。如果省略前缀，则命名空间成为默认命名空间。
- en: 'In *Listing 3.1*, the following namespace is the default one:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *清单 3.1* 中，以下命名空间是默认的：
- en: This default namespace allows us to refer to .NET MAUI classes without a prefix,
    such as `ContentPage`, `Label`, or `Button`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个默认命名空间允许我们无需前缀即可引用 .NET MAUI 类，例如 `ContentPage`、`Label` 或 `Button`。
- en: 'For the namespace declaration, the `x` prefix is used, like so:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于命名空间声明，使用前缀 `x`，如下所示：
- en: The `xmlns:x` namespace declaration specifies elements and attributes that are
    intrinsic to XAML. This namespace is one of the most important ones that we will
    use in the UI design with XAML. To comprehend its usage, we can create a content
    page with an identical structure using both C# and XAML in the subsequent sections.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`xmlns:x` 命名空间声明指定了 XAML 内在的元素和属性。这是我们将在使用 XAML 进行 UI 设计时使用的重要命名空间之一。为了理解其用法，我们可以在后续章节中使用
    C# 和 XAML 创建具有相同结构的相同内容页面。'
- en: Creating a new page using XAML
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 XAML 创建一个新的页面
- en: 'First, let’s create a new page using XAML. To create a content page in XAML,
    we can use the `dotnet` command, as we have done previously:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用 XAML 创建一个新的页面。要创建 XAML 中的内容页面，我们可以使用 `dotnet` 命令，就像我们之前做的那样：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding command generates a XAML file (`NewPage1.xaml`) and a C# code-behind
    file (`NewPage1.xaml.cs`). We can update the XAML file to the following. Since
    we aren’t adding any logic, we can ignore the code-behind file (`NewPage1.xaml.cs`)
    in this example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令生成了一个 XAML 文件 (`NewPage1.xaml`) 和一个 C# 代码隐藏文件 (`NewPage1.xaml.cs`)。我们可以更新
    XAML 文件，如下所示。由于我们未添加任何逻辑，我们可以忽略此示例中的代码隐藏文件 (`NewPage1.xaml.cs`)：
- en: '`NewPage1.xaml`'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewPage1.xaml`'
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`NewPage1.xaml.cs`'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewPage1.xaml.cs`'
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For comparison purposes with the XAML version we just created, let’s create
    the same content page using C# only in the next section. Then we will have a look
    at the lines numbered in the preceding code.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与刚刚创建的 XAML 版本进行比较，让我们在下一节中仅使用 C# 创建相同的内容页面。然后我们将查看前面代码中编号的行。
- en: Creating the same new page using C#
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 C# 创建相同的新的页面
- en: 'To create the same content page using only C# code, let’s use the following
    command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要仅使用 C# 代码创建相同的内容页面，请使用以下命令：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding command generates a content page in the `NewPage1.cs` C# file.
    We can implement the same logic in C# like so:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令在 `NewPage1.cs` C# 文件中生成一个内容页面。我们可以在 C# 中像这样实现相同的逻辑：
- en: '`NewPage1.cs`'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewPage1.cs`'
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, we have created the same content page (`NewPage1`) twice in both XAML
    and C#. XAML cannot contain programming logic, but it can be used to declare user
    interface elements and put the logic in the C# code-behind file. Within both versions
    of `NewPage1`, we created a content page that contains `Label` and `BoxView` elements.
    In the XAML version, we used attributes defined in the `xmlns:x` namespace to
    specify the UI elements:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在 XAML 和 C# 中都创建了相同的内容页面 (`NewPage1`) 两次。XAML 不能包含编程逻辑，但它可以用来声明用户界面元素，并将逻辑放在
    C# 代码隐藏文件中。在 `NewPage1` 的两个版本中，我们创建了一个包含 `Label` 和 `BoxView` 元素的内容页面。在 XAML 版本中，我们使用了
    `xmlns:x` 命名空间中定义的属性来指定 UI 元素：
- en: '**(1)** A content page called `NewPage1` is created in XAML. The `x:Class`
    attribute specifies the class name – that is, `NewPage1`. In the C# code-behind
    file, a partial class of `NewPage1` is defined. In the constructor, the `InitializeComponent`
    method is invoked to load the UI defined in XAML.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**(1)** 在 XAML 中创建了一个名为 `NewPage1` 的内容页面。`x:Class` 属性指定了类名——即 `NewPage1`。在
    C# 代码隐藏文件中，定义了一个 `NewPage1` 的部分类。在构造函数中，调用 `InitializeComponent` 方法来加载 XAML 中定义的
    UI。'
- en: '**[1]** We can create the same content page, `NewPage1`, using C# directly
    as a derived class of `ContentPage`.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**[1]** 我们可以直接使用 C# 并作为 `ContentPage` 的派生类来创建相同的内容页面 `NewPage1`。'
- en: 'We defined a `StackLayout` in the content page and the variable name used to
    refer to it is **layout** in both the XAML and C# versions:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在内容页面中定义了一个 `StackLayout`，并且用于引用它的变量名在 XAML 和 C# 版本中都是 `layout`：
- en: '**(2)** In XAML, `x:Name` specifies the variable name of `StackLayout`.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**(2)** 在 XAML 中，`x:Name` 指定了 `StackLayout` 的变量名。'
- en: '**[2]** In C#, we can declare the variable as `layout`.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**[2]** 在 C# 中，我们可以将变量声明为 `layout`。'
- en: '**(3)** `x:FactoryMethod` specifies a factory method that can be used to initialize
    an object.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**(3)** `x:FactoryMethod` 指定了一个可以用来初始化对象的工厂方法。'
- en: '**[3]** In C# code, we can call the `Color.FromRgba` function directly, but
    we have to use the `x:FactoryMethod` attribute in XAML to do the same.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**[3]** 在 C# 代码中，我们可以直接调用 `Color.FromRgba` 函数，但在 XAML 中我们必须使用 `x:FactoryMethod`
    属性来完成同样的操作。'
- en: '**(4)** `x:Arguments` is used to specify arguments when we call `Color.FromRgba`
    in XAML.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**(4)** `x:Arguments` 用于在 XAML 中调用 `Color.FromRgba` 时指定参数。'
- en: '**(5)** `x:Int` is used to specify integer arguments. For other data types,
    we can use `x:Double`, `xChar`, or `x:Boolean`.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**(5)** `x:Int` 用于指定整数参数。对于其他数据类型，我们可以使用 `x:Double`、`xChar` 或 `x:Boolean`。'
- en: For more information about the `xmlns:x` namespace, please refer to the Microsoft
    documentation at [https://learn.microsoft.com/en-us/dotnet/maui/xaml/namespaces/](https://learn.microsoft.com/en-us/dotnet/maui/xaml/namespaces/).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 `xmlns:x` 命名空间的更多信息，请参阅 Microsoft 文档：[https://learn.microsoft.com/en-us/dotnet/maui/xaml/namespaces/](https://learn.microsoft.com/en-us/dotnet/maui/xaml/namespaces/)。
- en: '**Common Language Runtime (CLR)** types can be referenced in XAML by declaring
    a XAML namespace with a prefix. As shown in *Listing 3.1*, we can refer to our
    C# namespace, `PassXYZ.Vault`, like so:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**公共语言运行时 (CLR) 类型可以通过声明带有前缀的 XAML 命名空间在 XAML 中引用。如 *清单 3.1* 所示，我们可以像这样引用我们的
    C# 命名空间 `PassXYZ.Vault`：'
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To declare a CLR namespace, we can use `clr-namespace:` or `using:`. If the
    CLR namespace is defined in a different assembly, `assembly=` is used to specify
    the assembly that contains the referenced CLR namespace. The value is the name
    of the assembly without the file extension. In our case, it has been omitted since
    the `PassXYZ.Vault` namespace is within the same assembly as our application code.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明 CLR 命名空间，我们可以使用 `clr-namespace:` 或 `using:`。如果 CLR 命名空间定义在不同的程序集，则使用 `assembly=`
    来指定包含引用 CLR 命名空间的程序集。值是程序集的名称，不带文件扩展名。在我们的例子中，它已被省略，因为 `PassXYZ.Vault` 命名空间位于我们的应用程序代码相同的程序集中。
- en: We will see more uses of namespaces later in this chapter.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的后面部分看到更多命名空间的使用。
- en: XAML markup extensions
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XAML 标记扩展
- en: Even though we can initialize class instances using XAML elements and set class
    members using XAML attributes, we can only set them as predefined constants in
    a XAML document.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以使用 XAML 元素初始化类实例，并使用 XAML 属性设置类成员，但我们只能将它们设置为 XAML 文档中的预定义常量。
- en: To enhance the power and flexibility of XAML by allowing element attributes
    to be set from a variety of sources, we can use XAML markup extensions. With XAML
    markup extensions, we can set an attribute to values defined somewhere else, or
    a result processed by code at runtime.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过允许从各种来源设置元素属性来增强 XAML 的功能和灵活性，我们可以使用 XAML 标记扩展。使用 XAML 标记扩展，我们可以将属性设置为在别处定义的值，或者是在运行时由代码处理的结果。
- en: 'XAML markup extensions can be specified in curly braces, as shown here:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: XAML 标记扩展可以指定在大括号中，如下所示：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code, both the `BackgroundColor` and `Command` attributes have
    been set to markup extensions. `BackgroundColor` has been set to `DynamicResource`
    and `Command` has been set to the `OpenWebCommand` method defined in the view
    model.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`BackgroundColor` 和 `Command` 属性都已设置为标记扩展。`BackgroundColor` 已设置为 `DynamicResource`，而
    `Command` 已设置为在视图模型中定义的 `OpenWebCommand` 方法。
- en: Here, we’ve provided a brief introduction to markup extensions, so don’t concern
    yourself with the usage of markup extensions for now. We will delve deeper into
    markup extensions when we use them later. In the next chapter, *Chapter 4*, *Exploring
    MVVM and Data Binding*, we will detail the usage of data binding.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们提供了对标记扩展的简要介绍，所以现在不必担心标记扩展的用法。当我们稍后使用它们时，我们将更深入地探讨标记扩展。在下一章，*第 4 章*，*探索
    MVVM 和数据绑定*中，我们将详细说明数据绑定的用法。
- en: 'Please refer to the following Microsoft documentation to find out more information
    about markup extensions: [https://learn.microsoft.com/en-us/dotnet/maui/xaml/markup-extensions/consume](https://learn.microsoft.com/en-us/dotnet/maui/xaml/markup-extensions/consume).'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下 Microsoft 文档以获取有关标记扩展的更多信息：[https://learn.microsoft.com/en-us/dotnet/maui/xaml/markup-extensions/consume](https://learn.microsoft.com/en-us/dotnet/maui/xaml/markup-extensions/consume)。
- en: Now that we’ve learned the basics about XAML, we can use it to work on our user
    interface design.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 XAML 的基础知识，我们可以用它来工作于我们的用户界面设计。
- en: Building a user interface
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建用户界面
- en: Equipped with basic knowledge of XAML, let’s take a bird’s-eye view of the .NET
    MAUI user interface building blocks. We will explore them in greater depth as
    we encounter them in subsequent chapters.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在具备基本的 XAML 知识后，让我们从宏观的角度看一下 .NET MAUI 用户界面构建块。随着我们在后续章节中遇到它们，我们将更深入地探讨它们。
- en: A page is the top-level user interface element that typically occupies all the
    screens or windows. We introduced how to create pages using the Visual Studio
    template or `dotnet` command at the beginning of this chapter. Each page generally
    contains at least one layout element, which is used to organize the design of
    controls on a page. Examples of pages are `ContentPage`, `NavigationPage`, `TabbedPage`,
    `FlyoutPage`, and `Shell`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 页面是顶级用户界面元素，通常占据所有屏幕或窗口。我们在本章开头介绍了如何使用 Visual Studio 模板或 `dotnet` 命令创建页面。每个页面通常至少包含一个布局元素，用于组织页面上的控件设计。页面的例子包括
    `ContentPage`、`NavigationPage`、`TabbedPage`、`FlyoutPage` 和 `Shell`。
- en: Within a content page, we utilize views (or controls) as the building blocks
    of the user interface. To organize views into groups, we can use layout components
    as containers for the views.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在内容页面中，我们利用视图（或控件）作为用户界面的构建块。为了将视图组织成组，我们可以使用布局组件作为视图的容器。
- en: Layouts
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布局
- en: '**Layouts** are container components that help organize and arrange UI elements
    (or views) within your app. They control the position, size, and alignment of
    the UI components based on specific rules.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**布局**是容器组件，有助于在您的应用中组织和排列 UI 元素（或视图）。它们根据特定规则控制 UI 组件的位置、大小和对齐。'
- en: Layouts allow you to create consistent and adaptive user interfaces that work
    on different screen sizes and device orientations. Examples include `StackLayout`,
    `Grid`, `FlexLayout`, `RelativeLayout`, and `AbsoluteLayout`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 布局允许您创建一致且适应不同屏幕尺寸和设备方向的用户界面。例子包括 `StackLayout`、`Grid`、`FlexLayout`、`RelativeLayout`
    和 `AbsoluteLayout`。
- en: StackLayout
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: StackLayout
- en: '`StackLayout` organizes elements in a one-dimensional stack, either horizontally
    or vertically. It is often used as a parent layout, which contains other child
    layouts. The default orientation is vertical. However, we should not use `StackLayout`
    to generate a layout similar to a table by using nested `StackLayout` horizontally
    and vertically. The following code shows an example of bad practice:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`StackLayout` 以一维堆栈的形式组织元素，无论是水平还是垂直。它通常用作父布局，包含其他子布局。默认方向是垂直。然而，我们不应使用嵌套的
    `StackLayout` 水平和垂直地生成类似于表格的布局。以下代码展示了不良实践的例子：'
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding code, we employed a `StackLayout` as the parent layout, where
    the default orientation is vertical. Then, we nested multiple `StackLayout` controls
    with a horizontal orientation to generate a form for data entry.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了一个默认方向为垂直的 `StackLayout` 作为父布局。然后，我们嵌套了多个具有水平方向的 `StackLayout`
    控件，以生成数据输入表单。
- en: However, using nested `StackLayouts` to create a layout similar to a table is
    not optimized for such scenarios, and it might lead to performance and layout
    issues. In this situation, we should utilize the `Grid` control.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用嵌套的 `StackLayout` 创建类似于表格的布局并不优化此类场景，并且可能会导致性能和布局问题。在这种情况下，我们应该使用 `Grid`
    控件。
- en: '`StackLayout` is a frequently used layout control. There are two sub-types
    of `StackLayout` that help us directly design the layout horizontally or vertically.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`StackLayout` 是一个常用的布局控件。`StackLayout` 有两种子类型，帮助我们直接水平或垂直设计布局。'
- en: HorizontalStackLayout
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: HorizontalStackLayout
- en: '`HorizontalStackLayout` is a one-dimensional horizontal stack. For example,
    we can generate a row like so:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`HorizontalStackLayout` 是一个一维的水平堆栈。例如，我们可以生成如下行：'
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: VerticalStackLayout
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: VerticalStackLayout
- en: '`VerticalStackLayout` is a one-dimensional vertical stack. For example, we
    can display an error message after a form is submitted with an error like so:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`VerticalStackLayout` 是一个一维的垂直堆栈。例如，我们可以在表单提交后显示错误信息，如下所示：'
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Grid
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Grid
- en: '`Grid` organizes elements in rows and columns. We can specify rows and columns
    with the `RowDefinitions` and `ColumnDefinitions` properties. In the previous
    example, we created a form where the user can enter their name, age, and address
    using a nested `StackLayout`. We can do this in the `Grid` layout like so:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`Grid` 以行和列的形式组织元素。我们可以使用 `RowDefinitions` 和 `ColumnDefinitions` 属性来指定行和列。在先前的例子中，我们创建了一个表单，用户可以使用嵌套的
    `StackLayout` 输入他们的姓名、年龄和地址。我们可以在 `Grid` 布局中这样做：'
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding example, we created a `Grid` layout with two columns and three
    rows.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个有两列和三行的 `Grid` 布局。
- en: FlexLayout
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FlexLayout
- en: '`FlexLayout` is similar to a `StackLayout` in that it displays child elements
    either horizontally or vertically in a stack. The difference is a `FlexLayout`
    can also wrap its children if there are too many to fit in a single row or column.
    As an example, we can create a `FlexLayout` with five labels in a row. If we specify
    the `Direction` property as `Row`, these labels will be displayed in one row.
    We can also specify the `Wrap` property, which can cause the items to wrap to
    the next row if there are too many items to fit in a row:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`FlexLayout` 与 `StackLayout` 类似，它将子元素水平或垂直地堆叠显示。区别在于，如果子元素太多无法适应一行或一列，`FlexLayout`
    还可以自动换行。例如，我们可以创建一个包含五个标签的 `FlexLayout` 行。如果我们指定 `Direction` 属性为 `Row`，这些标签将显示在一行中。我们还可以指定
    `Wrap` 属性，如果行中元素过多，它会导致项目换行到下一行：'
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: AbsoluteLayout
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AbsoluteLayout
- en: '`AbsoluteLayout` is a layout control that enables you to position and size
    child elements based on X and Y coordinates in addition to width and height. It
    is particularly useful in scenarios where you need fine-grained control over the
    exact position and size of your UI elements.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbsoluteLayout` 是一种布局控制，它允许您根据 X 和 Y 坐标以及宽度和高度定位和调整子元素的大小。它在需要精细控制 UI 元素精确位置和大小的场景中特别有用。'
- en: 'Here are some common use cases for `AbsoluteLayout`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `AbsoluteLayout` 的常见用例：
- en: '**Overlap UI elements**: `AbsoluteLayout` allows you to position elements on
    top of others, which can create some effective visuals or display content over
    a background image.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重叠 UI 元素**：`AbsoluteLayout` 允许您将元素放置在其他元素之上，这可以创建一些有效的视觉效果或将内容显示在背景图像之上。'
- en: '**Custom controls**: If you are developing custom controls that require precise
    control over the layout of their components, `AbsoluteLayout` should be your go-to
    choice.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义控件**：如果您正在开发需要精确控制组件布局的自定义控件，`AbsoluteLayout` 应该是您的首选选择。'
- en: '**Complex UI presentation**: You may need to create intricate UIs that don’t
    fit within a standard grid or stack layout. In such scenarios, `AbsoluteLayout`
    gives you the control required to position items accurately.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂的 UI 展示**：您可能需要创建复杂的 UI，这些 UI 不适合标准的网格或堆叠布局。在这种情况下，`AbsoluteLayout` 提供了您所需的控制，以精确地定位项目。'
- en: '**Positioning based on the parent size**: `AbsoluteLayout` allows you to position
    children relative to the bounds of their parent. This makes it easier to place
    elements at specific positions or in response to certain events.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于父大小的定位**：`AbsoluteLayout` 允许您根据父元素的边界定位子元素。这使得放置元素在特定位置或响应某些事件变得更容易。'
- en: '**Animations**: If you need to animate elements, such as moving them around
    the screen or resizing them, `AbsoluteLayout` can simplify this process by providing
    direct access to the location, width, and height properties of child elements.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动画**：如果您需要动画元素，例如在屏幕上移动它们或调整它们的大小，`AbsoluteLayout` 可以通过直接访问子元素的位置、宽度和高度属性来简化此过程。'
- en: 'Generally speaking, there are three benefits of using `AbsoluteLayout` for
    building layouts:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，使用 `AbsoluteLayout` 构建布局有三个好处：
- en: '**Precise control**: `AbsoluteLayout` provides control over the position, size,
    and layering of child elements, which can be beneficial when working on custom
    or complex UI designs.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**精确控制**：`AbsoluteLayout` 提供了对子元素的位置、大小和层级的控制，这在处理自定义或复杂的 UI 设计时非常有用。'
- en: '**Performance**: Since `AbsoluteLayout` doesn’t require complex calculations
    to arrange elements, it can offer better performance compared to other layout
    types, especially when dealing with a large number of child elements.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：由于 `AbsoluteLayout` 不需要复杂的计算来排列元素，因此与其他布局类型相比，它可以提供更好的性能，尤其是在处理大量子元素时。'
- en: '**Responsive layouts**: With the support of proportional values, `AbsoluteLayout`
    can help create responsive designs that can scale with different screen sizes
    and orientations.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应式布局**：由于 `AbsoluteLayout` 支持比例值，它可以帮助创建可以适应不同屏幕尺寸和方向的响应式设计。'
- en: However, it’s important to note that using `AbsoluteLayout` everywhere is not
    recommended. It is better suited for specific scenarios where other layouts cannot
    meet the required design or functionality requirements. The disadvantages of `AbsoluteLayout`
    include the difficulty of maintaining the responsive behavior of the UI and the
    potential for unexpected behavior when there are changes to the parent or child
    elements. Instead, you should use other layouts (e.g., `Grid`, `StackLayout`,
    or `FlexLayout`) whenever their features are adequate for your design needs.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，需要注意的是，在所有地方都使用`AbsoluteLayout`并不推荐。它更适合那些其他布局无法满足所需的设计或功能要求的特定场景。`AbsoluteLayout`的缺点包括难以维护UI的响应性以及当父元素或子元素发生变化时可能出现意外行为。相反，当其他布局（例如`Grid`、`StackLayout`或`FlexLayout`）的功能足以满足您的需求时，您应该使用这些布局。
- en: 'In the following example, we are creating a `BoxView` control in the layout
    at (0, 0) with both width and height equal to `10`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们在布局中的（0，0）位置创建了一个`BoxView`控件，其宽度和高度都等于`10`：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We have provided an overview of layout controls. For more detailed information,
    please refer to the following Microsoft documentation: [https://learn.microsoft.com/en-us/dotnet/maui/user-interface/layouts/](https://learn.microsoft.com/en-us/dotnet/maui/user-interface/layouts/).'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已提供了布局控件的概述。有关更详细的信息，请参阅以下Microsoft文档：[https://learn.microsoft.com/en-us/dotnet/maui/user-interface/layouts/](https://learn.microsoft.com/en-us/dotnet/maui/user-interface/layouts/)。
- en: Views
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图
- en: '**Views** (also known as controls) are the individual UI elements that users
    interact with or that display content on a screen. They are placed within layouts
    and, in turn, on pages. Views include basic UI controls like `Label`, `Button`,
    `Entry`, and `Image`, as well as more advanced UI controls, such as `CollectionView`,
    `ListView`, and `WebView`.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**视图**（也称为控件）是用户与之交互或显示屏幕上内容的单个UI元素。它们被放置在布局中，然后放置在页面上。视图包括基本的UI控件，如`Label`、`Button`、`Entry`和`Image`，以及更高级的UI控件，如`CollectionView`、`ListView`和`WebView`。'
- en: 'Please refer to the following Microsoft document about the controls in .NET
    MAUI: [https://learn.microsoft.com/en-us/dotnet/maui/user-interface/controls/](https://learn.microsoft.com/en-us/dotnet/maui/user-interface/controls/).'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅以下关于.NET MAUI控件的相关Microsoft文档：[https://learn.microsoft.com/en-us/dotnet/maui/user-interface/controls/](https://learn.microsoft.com/en-us/dotnet/maui/user-interface/controls/)。
- en: In this section, we’ll go through some controls that will be frequently used
    in this book.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍一些在这本书中会频繁使用的控件。
- en: Label
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标签
- en: '`Label` is used to display single-line or multi-line text. It can display text
    with a certain format, such as color, space, text decorations, and even HTML text.
    To create a `Label`, we can use the simplest format, like so:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`Label`用于显示单行或多行文本。它可以显示具有特定格式的文本，例如颜色、间距、文本装饰，甚至HTML文本。要创建一个`Label`，我们可以使用最简单的格式，如下所示：'
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Image
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图片
- en: 'In the user interface design, we usually use icons to decorate other controls
    or display images as backgrounds. The `Image` control can display an image from
    a local file, a URI, an embedded resource, or a stream. The following code shows
    an example of how to create an `Image` control in the simplest form:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户界面设计中，我们通常使用图标来装饰其他控件或显示图像作为背景。`Image`控件可以显示来自本地文件、URI、嵌入资源或流的图像。以下代码展示了如何以最简单的方式创建一个`Image`控件：
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Editor
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编辑器
- en: 'In our app, the users need to enter or edit a single line of text or multiple
    lines of text. We have two controls to serve this purpose: `Editor` and `Entry`.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，用户需要输入或编辑单行文本或多行文本。为此，我们提供了两个控件：`Editor`和`Entry`。
- en: '`Editor` can be used to enter or edit multiple lines of text. The following
    is an example of the `Editor` control:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`Editor`可用于输入或编辑多行文本。以下是一个`Editor`控件的示例：'
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Entry
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输入框
- en: '`Entry` can be used to enter or edit a single line of text. To design a login
    page, we can use `Entry` controls to enter a username and password. When users
    interact with an `Entry`, the behavior of the keyboard can be customized through
    the `Keyboard` property.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`Entry`可用于输入或编辑单行文本。为了设计登录页面，我们可以使用`Entry`控件输入用户名和密码。当用户与`Entry`交互时，可以通过`Keyboard`属性自定义键盘的行为。'
- en: 'When users enter their passwords, the `IsPassword` property can be set to reflect
    the typical behavior on a login page. The following is an example of a password
    entry:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户输入密码时，可以将`IsPassword`属性设置为反映登录页面上的典型行为。以下是一个密码输入的示例：
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ListView
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ListView
- en: In user interface design, a common use case involves displaying a collection
    of data. In .NET MAUI, several controls can be utilized to display a collection
    of data, such as `CollectionView`, `ListView`, and `CarouselView`. In our app,
    we will employ `ListView` to display password entries, groups, and the contents
    of an entry. We will introduce the usage of `ListView` when introducing `ItemsPage`
    and `ItemDetailPage` in *Chapter 4*, *Exploring MVVM and Data Binding*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户界面设计中，一个常见的用例是显示一组数据。在 .NET MAUI 中，可以使用多个控件来显示数据集合，例如 `CollectionView`、`ListView`
    和 `CarouselView`。在我们的应用中，我们将使用 `ListView` 来显示密码条目、组和条目的内容。我们将在 *第 4 章*，*探索 MVVM
    和数据绑定* 中介绍 `ListView` 的使用。
- en: With all these building blocks in place, we can construct a content page. Typically,
    an application consists of multiple pages implementing different functionalities.
    To create a functional app, we need to navigate between these pages.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些构建块就绪后，我们可以构建一个内容页面。通常，一个应用程序由多个实现不同功能的页面组成。为了创建一个功能齐全的应用，我们需要在这些页面之间进行导航。
- en: Navigation refers to the process of moving between various pages or views within
    your app, enabling users to interact with multiple screens and access a range
    of features. Navigation is a crucial aspect of app design, as it determines the
    user’s journey through the app and assists them in finding the information they
    require. In .NET MAUI, navigation management is handled using `NavigationPage`,
    `TabbedPage`, `Shell`, or custom navigation if necessary.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 导航指的是在您的应用中在不同页面或视图之间移动的过程，使用户能够与多个屏幕交互并访问一系列功能。导航是应用设计的一个关键方面，因为它决定了用户的旅程以及帮助他们找到所需信息的途径。在
    .NET MAUI 中，使用 `NavigationPage`、`TabbedPage`、`Shell` 或必要时自定义导航来处理导航管理。
- en: Master-detail UI design
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主从 UI 设计
- en: There are various ways to implement navigation within an app. In our app’s navigation
    design, we employ the master-detail pattern.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用内实现导航有多种方式。在我们的应用导航设计中，我们采用了主从模式。
- en: 'The master-detail pattern is a widely utilized user interface design approach.
    Many examples of it can be found in frequently used apps. For instance, in the
    Mail app on Windows, a list of emails is displayed in the master view along with
    the details of the selected email:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 主从模式是一种广泛使用的用户界面设计方法。在常用应用中可以找到许多它的例子。例如，在 Windows 的邮件应用中，主视图中显示了一封封电子邮件的列表，以及所选电子邮件的详细信息：
- en: '![Figure 3.2: Mail in Windows](img/B21554_03_04.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2：Windows 中的邮件](img/B21554_03_04.png)'
- en: 'Figure 3.4: Mail in Windows'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4：Windows 中的邮件
- en: In *Figure 3.4*, three panels are present in the design. The left panel resembles
    a navigation drawer. When selecting a folder from the left panel, a list of emails
    is shown in the middle panel. The currently selected email is displayed in the
    right panel.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 3.4* 中，设计中包含三个面板。左侧面板类似于导航抽屉。当从左侧面板选择一个文件夹时，中间面板会显示一封封电子邮件。当前选中的电子邮件在右侧面板中显示。
- en: '**Note**'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '**Navigation drawers** provide access to destinations and app functionality,
    such as the menu in the desktop environment. It typically slides in from the left
    and is triggered by tapping an icon in the top-left corner of the screen. It displays
    a list of choices to navigate to and is widely used in mobile and web user interface
    design. Xamarin.Forms and .NET MAUI `Shell` use navigation drawers as their top-level
    navigation methods.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**导航抽屉**提供了访问目的地和应用功能的方式，例如桌面环境中的菜单。它通常从左侧滑入，并通过在屏幕左上角轻触图标来触发。它显示一个选择列表以进行导航，并在移动和网页用户界面设计中广泛使用。Xamarin.Forms
    和 .NET MAUI `Shell` 使用导航抽屉作为它们的高级导航方法。'
- en: 'The original KeePass UI design, shown in *Figure 3.5*, also uses three panels
    (left, right, and bottom) on the main page. The left panel is a classic tree view
    that acts like a navigation drawer. The right panel is used to display the list
    of password entries, while the bottom panel serves to exhibit the details of an
    entry:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的 KeePass UI 设计，如 *图 3.5* 所示，在主页上也使用了三个面板（左侧、右侧和底部）。左侧面板是一个经典的树形视图，类似于导航抽屉。右侧面板用于显示密码条目列表，而底部面板用于展示条目的详细信息：
- en: '![Figure 3.3: KeePass UI design](img/B21554_03_05.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3：KeePass UI 设计](img/B21554_03_05.png)'
- en: 'Figure 3.5: KeePass UI design'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5：KeePass UI 设计
- en: The master-detail pattern works well on a wide range of device types and display
    sizes.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 主从模式在各种设备类型和显示尺寸上都表现良好。
- en: 'Considering different display sizes, two popular modes can be used:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到不同的显示尺寸，可以使用两种流行的模式：
- en: Side-by-side
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并排
- en: Stacked
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆叠
- en: Side-by-side
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并排
- en: When ample horizontal space is available on a large display, the side-by-side
    approach tends to be a sensible choice. The Mail app in *Figure 3.4* and the KeePass
    app in *Figure 3.5* serve as good examples. In this mode, both the master view
    and the detail view can be seen simultaneously.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当在大屏幕上有足够的水平空间时，并排方法通常是一个明智的选择。*图 3.4* 中的邮件应用和 *图 3.5* 中的 KeePass 应用是很好的例子。在这种模式下，主视图和详细视图可以同时看到。
- en: Stacked
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 堆叠
- en: When using a mobile device, the screen size is typically smaller, with the vertical
    space being larger than the horizontal one. In such instances, the stacked approach
    is more suitable.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用移动设备时，屏幕尺寸通常较小，垂直空间大于水平空间。在这种情况下，堆叠方法更为合适。
- en: 'In the stacked mode, the master view occupies the entire screen space. Upon
    making a selection, the detail view then takes up the full screen space:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在堆叠模式下，主视图占据整个屏幕空间。在选择后，详细视图随后占据整个屏幕空间：
- en: '![](img/B21554_03_06.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21554_03_06.png)'
- en: 'Figure 3.6: PassXYZ.Vault'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '图 3.6: PassXYZ.Vault'
- en: 'In *Figure 3.6*, we can observe the app navigation from the user’s perspective.
    We have a list of flyout items to choose from:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 3.6* 中，我们可以从用户的角度观察应用导航。我们有多个飞出项可供选择：
- en: '**About**'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关于**'
- en: '**Browse**'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浏览**'
- en: '**Logout**'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注销**'
- en: Upon selecting **Browse**, we view the list of items on the master page (`ItemsPage`).
    From this page, if we choose an item, we will go to the item’s detail page (`ItemDetailPage`).
    If we want to select another item, we must return to the master page and make
    another selection.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 **浏览** 后，我们查看主页面 (`ItemsPage`) 上的项目列表。从该页面，如果我们选择一个项目，我们将转到项目的详情页面 (`ItemDetailPage`)。如果我们想选择另一个项目，我们必须返回主页面并再次选择。
- en: We will discuss flyout items in *Chapter 5*, *Navigation Using .NET MAUI Shell
    and NavigationPage*. In this section, we will examine the implementation of `ItemsPage`
    and `ItemDetailPage`. However, before delving into the specifics, let’s explore
    layouts, which serve as containers for user interface elements.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 *第 5 章*，*使用 .NET MAUI Shell 和 NavigationPage 进行导航* 中讨论飞出项。在本节中，我们将检查 `ItemsPage`
    和 `ItemDetailPage` 的实现。然而，在深入具体细节之前，让我们先探讨布局，它们作为用户界面元素的容器。
- en: Navigation in the master-detail UI design
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主从 UI 设计中的导航
- en: As shown in *Figure 3.6*, we employ a stacked master-detail pattern in our navigation
    scheme. There is a flyout menu to display a list of pages. Within this list of
    pages, a page of the `ItemsPage` type is utilized to display a list of password
    entries. When users select an entry, details about the password entry are shown
    in `ItemDetailPage`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 3.6* 所示，我们在导航方案中采用了堆叠的主从模式。有一个飞出菜单来显示页面列表。在这个页面列表中，使用 `ItemsPage` 类型的页面来显示密码条目列表。当用户选择一个条目时，`ItemDetailPage`
    会显示密码条目的详细信息。
- en: Let’s review the implementation of `ItemsPage` and `ItemDetailPage`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾 `ItemsPage` 和 `ItemDetailPage` 的实现。
- en: ItemDetailPage
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ItemDetailPage
- en: 'In our app, `ItemDetailPage` serves as the detail page of the master-detail
    pattern, displaying an item’s content. In `ItemDetailPage`, we essentially present
    the `Item` data model. Although it appears quite simple for now, we will gradually
    enhance it throughout this book:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用中，`ItemDetailPage` 作为主从模式中的详情页面，显示项目的内容。在 `ItemDetailPage` 中，我们基本上展示了
    `Item` 数据模型。虽然现在看起来很简单，但我们将在这本书中逐步增强它：
- en: '[PRE25]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 3.3: `Item.cs` ([https://epa.ms/Item3-3](https://epa.ms/Item3-3))'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3.3: `Item.cs` ([https://epa.ms/Item3-3](https://epa.ms/Item3-3))'
- en: 'As shown in *Listing 3.3*, the `Item` class includes three properties: `ID`,
    `Text`, and `Description`. The `Item` instance is loaded by the `LoadItemId` function
    in `ItemDetailViewModel`, as shown here:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *列表 3.3* 所示，`Item` 类包括三个属性：`ID`、`Text` 和 `Description`。`Item` 实例由 `ItemDetailViewModel`
    中的 `LoadItemId` 函数加载，如下所示：
- en: '[PRE26]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In `LoadItemId`, the `GetItemAsync` method of the `IDataStore` interface is
    invoked to obtain the item by its ID.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `LoadItemId` 中，调用 `IDataStore` 接口的 `GetItemAsync` 方法通过其 ID 获取项目。
- en: 'After loading the item, we can present the data to the user in `ItemDetailPage.xaml`,
    as shown in *Listing 3.4*:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载项目后，我们可以在 `ItemDetailPage.xaml` 中向用户展示数据，如 *列表 3.4* 所示：
- en: '[PRE27]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 3.4: `ItemDetailPage.xaml` ([https://epa.ms/ItemDetailPage3-4](https://epa.ms/ItemDetailPage3-4))'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3.4: `ItemDetailPage.xaml` ([https://epa.ms/ItemDetailPage3-4](https://epa.ms/ItemDetailPage3-4))'
- en: '*Listing 3.4* represents the XAML file of `ItemDetailPage`. The item detail
    content page includes an instance of `StackLayout` and four instances of `Label`.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3.4* 表示 `ItemDetailPage` 的 XAML 文件。项目详情内容页面包含一个 `StackLayout` 实例和四个 `Label`
    实例。'
- en: Within `StackLayout`, the default orientation is `Vertical`, causing the `Label`
    controls to be arranged vertically on the item detail page (refer to *Figure 3.4*).
    Both `Name` and `Description` are linked to the model data in the view model through
    data binding, which will be introduced in the next chapter.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `StackLayout` 中，默认方向是 `Vertical`，导致 `Label` 控件在项目详情页上垂直排列（参见图 3.4）。`Name`
    和 `Description` 都通过数据绑定与视图模型中的模型数据相关联，这将在下一章中介绍。
- en: ItemsPage
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ItemsPage
- en: '`ItemsPage` serves as the master page of the master-detail pattern in our app,
    presenting a list of items that users can browse.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`ItemsPage` 在我们的应用中充当主从模式的主页，展示用户可以浏览的项目列表。'
- en: '*Listing 3.5* showcases the implementation of `ItemsPage`. To display a list
    of items, a `ListView` control is employed. `ListView` is a control designed for
    displaying a scrollable vertical list of selectable data items:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3.5* 展示了 `ItemsPage` 的实现。为了显示项目列表，使用了 `ListView` 控件。`ListView` 是一个用于显示可滚动垂直列表的可选择数据项的控件：'
- en: '[PRE28]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 3.5: `ItemsPage.xaml` ([https://epa.ms/ItemsPage3-5](https://epa.ms/ItemsPage3-5))'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3.5：`ItemsPage.xaml` ([https://epa.ms/ItemsPage3-5](https://epa.ms/ItemsPage3-5))
- en: 'Let’s examine this code in greater detail:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地检查这段代码：
- en: '**(1)** `x:Class`: This is utilized to define the class name of a partial class
    shared between the markup and code-behind file. `PassXYZ.Vault.Views.ItemsPage`
    is the class name defined here.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**(1)** `x:Class`：这用于定义在标记和代码后文件之间共享的部分类名称。`PassXYZ.Vault.Views.ItemsPage`
    是在此定义的类名。'
- en: '**(3)** `x:Name`: While `x:Class` defines the class name in XAML, `x:Name`
    defines the instance name. We can refer to the `BrowseItemsPage` instance name
    in the code-behind file.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**(3)** `x:Name`：虽然 `x:Class` 在 XAML 中定义了类名，但 `x:Name` 定义了实例名称。我们可以在代码后文件中引用
    `BrowseItemsPage` 实例名称。'
- en: '**(2)** `x:DataType`: Setting `x:DataType` to the appropriate type defined
    in the view model enables compiled binding, which can significantly improve performance.
    The view model referred to here is `ItemsViewModel`.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**(2)** `x:DataType`：将 `x:DataType` 设置为在视图模型中定义的适当类型可以启用编译绑定，这可以显著提高性能。此处引用的视图模型是
    `ItemsViewModel`。'
- en: In addition to the standard namespace, we have defined two more namespaces so
    that we can reference the objects in the view model **(5)** and model **(6)**.
    We will discuss the view model and model in the next chapter.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标准命名空间外，我们还定义了另外两个命名空间，这样我们就可以引用视图模型中的对象 **(5)** 和模型 **(6)**。我们将在下一章中讨论视图模型和模型。
- en: '**(4)** We define a `ListView` control for displaying the list of items. The
    `ListView` control comprises numerous properties. The following properties must
    be defined when using the `ListView` control:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**(4)** 我们定义了一个 `ListView` 控件来显示项目列表。`ListView` 控件包含许多属性。当使用 `ListView` 控件时，以下属性必须被定义：'
- en: '`ItemsSource`, of the `IEnumerable` type, specifies the collection of items
    to display. It binds to `Items`, which is defined in the view model.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ItemsSource`，是 `IEnumerable` 类型，指定要显示的项目集合。它绑定到在视图模型中定义的 `Items`。'
- en: '`ItemTemplate`, of the `DataTemplate` type, specifies the template to apply
    to each item in the collection of items to be displayed.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ItemTemplate`，是 `DataTemplate` 类型，指定应用于要显示的项目集合中每个项目的模板。'
- en: 'In *Listing 3.5*, `DataTemplate` is collapsed. Upon expanding it, we will see
    the following code snippet. This default implementation comes from the Visual
    Studio template. The appearance of this data template is inadequate, and we will
    enhance it later:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *清单 3.5* 中，`DataTemplate` 被折叠。展开它后，我们将看到以下代码片段。这个默认实现来自 Visual Studio 模板。这个数据模板的外观不够理想，我们将在稍后进行改进：
- en: '[PRE29]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This `DataTemplate` implementation comprises a `ViewCell` consisting of a `StackLayout`
    with two `Label` controls, as seen in the preview in *Figure 3.6*.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `DataTemplate` 实现包含一个 `ViewCell`，它由一个包含两个 `Label` 控件的 `StackLayout` 组成，如
    *图 3.6* 预览中所示。
- en: 'The `DataTemplate` implementation must reference a `Cell` class to display
    items. There are built-in cells available, as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataTemplate` 实现必须引用一个 `Cell` 类来显示项目。以下是一些内置的单元格：'
- en: '`TextCell`, which displays primary and secondary text on separate lines.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TextCell`，在单独的行上显示主要和次要文本。'
- en: '`ImageCell`, which exhibits an image alongside primary and secondary text on
    separate lines.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ImageCell`，在单独的行上展示图像以及主要和次要文本。'
- en: '`SwitchCell`, which showcases text and a switch that can be switched on or
    off.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SwitchCell`，展示了文本和一个可以打开或关闭的开关。'
- en: '`EntryCell`, which presents a label and text that’s editable.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EntryCell`，展示一个标签和可编辑的文本。'
- en: '`ViewCell`, which is a custom cell with an appearance defined by a `View`.
    This cell type should be utilized when fully customizing the appearance of each
    item in a `ListView`.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewCell`，这是一个由 `View` 定义的样式的自定义单元格。当需要完全自定义 `ListView` 中每个项目的外观时，应使用此单元格类型。'
- en: Typically, `SwitchCell` and `EntryCell` are only used in a `TableView` and can’t
    be employed in a `ListView`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`SwitchCell` 和 `EntryCell` 只在 `TableView` 中使用，不能在 `ListView` 中使用。
- en: '[PRE30]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let’s examine this code in more detail:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地检查这段代码：
- en: '**(1)** To improve `ViewCell`''s appearance, we replaced the `StackLayout`
    with `Grid` as the layout class. `Grid` is a layout that organizes its children
    into rows and columns.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**(1)** 为了改善 `ViewCell` 的外观，我们将 `StackLayout` 替换为 `Grid` 作为布局类。`Grid` 是一种布局，它将子项组织成行和列。'
- en: '**(2)** Since we want to display two rows with an icon on the left, we created
    a grid containing two columns and two rows, as shown here:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**(2)** 由于我们想要显示带有左侧图标的两行，因此我们创建了一个包含两列和两行的网格，如图所示：'
- en: '![](img/B21554_03_07.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21554_03_07.png)'
- en: 'Figure 3.7: Layout of an entry or a group'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7：条目或组的布局
- en: We can use different font styles for `Name` and `Description` so that users
    can easily differentiate them visually.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为 `Name` 和 `Description` 使用不同的字体样式，这样用户可以轻松地通过视觉来区分它们。
- en: '**(3)** To center the icon within the first two columns, we merged the two
    rows into a `Grid` control. The attached `Grid.RowSpan` property can be used to
    merge rows.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**(3)** 为了在第一个两列中居中图标，我们将两行合并到一个 `Grid` 控件中。可以通过 `Grid.RowSpan` 属性来合并行。'
- en: A `Grid` can function as a parent layout containing other child layouts. To
    maintain a specific size for the icon and position it at the center of the merged
    cell, we can use another `Grid` as the parent of the `Image` control. This child
    `Grid` contains only one row and one column with a specific size.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `Grid` 可以作为一个包含其他子布局的父布局。为了保持图标的具体大小并将其定位在合并单元格的中心，我们可以使用另一个 `Grid` 作为 `Image`
    控件的父布局。这个子 `Grid` 只包含一个具有特定大小的行和列。
- en: In the `Image` control, we can use a default image (`icon.png`) from the resource.
    Customization can be applied once we introduce our model in the next chapter.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Image` 控件中，我们可以使用资源中的默认图像（`icon.png`）。一旦我们在下一章介绍我们的模型，就可以进行自定义。
- en: In the customized `ViewCell`, we can display a key-value pair of data with an
    associated icon.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在自定义的 `ViewCell` 中，我们可以显示与相关图标关联的数据键值对。
- en: 'Refer to *Figure 3.8* for the improved preview:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 参考图 3.8 查看改进的预览：
- en: '![](img/B21554_03_08.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21554_03_08.png)'
- en: 'Figure 3.8: Improved ItemsPage'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8：改进的 ItemsPage
- en: With this knowledge, we’ve covered the fundamentals of user interface design
    using XAML. A common challenge in user interface design is providing support for
    multiple languages. In the remainder of this chapter, we will learn how to support
    multiple languages when designing user interfaces in XAML.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些知识，我们已经涵盖了使用 XAML 进行用户界面设计的 fundamentals。用户界面设计中的一个常见挑战是提供对多种语言的支持。在本章的剩余部分，我们将学习如何在
    XAML 中设计用户界面时支持多种语言。
- en: Supporting multiple languages – localization
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持多种语言 - 本地化
- en: To accommodate multiple languages, we can utilize the .NET built-in mechanism
    for localizing applications. In .NET, resources files can be used to support localization
    by consolidating all text and other resources required for an application’s user
    interface in one location. In a XAML file, we can use the `x:Static` markup extension
    to access the string defined in resources files.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应多种语言，我们可以利用 .NET 内置的应用程序本地化机制。在 .NET 中，资源文件可以用于支持本地化，通过将应用程序用户界面所需的所有文本和其他资源集中在一个位置。在
    XAML 文件中，我们可以使用 `x:Static` 标记扩展来访问资源文件中定义的字符串。
- en: Creating a .resx file
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 .resx 文件
- en: 'We can generate a resources file for each supported language. Resources files
    are XML files with a `.resx` extension, which are compiled into binary resources
    files during the build process. To add a resources file, right-click the project
    node and select **Add > New Item... > Resources File**, as shown in *Figure 3.9*:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为每种支持的语言生成一个资源文件。资源文件是具有 `.resx` 扩展名的 XML 文件，在构建过程中编译成二进制资源文件。要添加资源文件，右键单击项目节点，然后选择
    **添加 > 新项... > 资源文件**，如图 3.9 所示：
- en: '![Figure 3.7: Creating a Resources File](img/B21554_03_09.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.7：创建资源文件](img/B21554_03_09.png)'
- en: 'Figure 3.9: Creating a resources file'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9：创建资源文件
- en: We can create the `Resources.resx` resources file in the `Properties` folder.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `Properties` 文件夹中创建 `Resources.resx` 资源文件。
- en: 'To support different cultures, we can add additional resources files with cultural
    information as part of the resources file’s name:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持不同的文化，我们可以在资源文件名中添加包含文化信息的附加资源文件：
- en: '`Resources.resx`: The resources file for the default culture, which we will
    set to **en-US** (US English).'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Resources.resx`：为默认文化提供的资源文件，我们将将其设置为**en-US**（美国英语）。'
- en: '`Resources.zh-Hans.resx`: The resources file for the **zh-Hans** culture, which
    is simplified Chinese.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Resources.zh-Hans.resx`：为**zh-Hans**文化提供的资源文件，即简体中文。'
- en: '`Resources.zh-Hant.resx`: The resources file for the **zh-Hant** culture, which
    is traditional Chinese.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Resources.zh-Hant.resx`：为**zh-Hant**文化提供的资源文件，即繁体中文。'
- en: 'Upon creating the resources file, the following `ItemGroup` will be added to
    the project file:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 创建资源文件后，以下`ItemGroup`将被添加到项目文件中：
- en: '[PRE32]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To edit a resources file, click on the resources file and edit it in the resource
    editor, as shown in *Figure 3.10*:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 要编辑资源文件，请单击资源文件，并在资源编辑器中编辑它，如图**3.10**所示：
- en: '![Figure 3.8: Resource editor](img/B21554_03_10.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![图3.8：资源编辑器](img/B21554_03_10.png)'
- en: 'Figure 3.10: Resource editor'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10：资源编辑器
- en: 'The resources file includes a list of key-value pairs for different languages:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 资源文件包括不同语言的键值对列表：
- en: The `Name` field represents the string name that can be referenced in both XAML
    and C# files.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Name`字段代表可以在XAML和C#文件中引用的字符串名称。'
- en: The `Value` field contains the language-specific string that will be used according
    to the system language settings.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Value`字段包含将根据系统语言设置使用的特定语言的字符串。'
- en: The `Comment` field is employed as a remark for the key-value pair.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Comment`字段被用作键值对的备注。'
- en: 'To specify the default language, we need to set the value of `NeutralLanguage`
    in `<PropertyGroup>` in the project file, as shown here:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定默认语言，我们需要在项目文件中的`<PropertyGroup>`中设置`NeutralLanguage`的值，如下所示：
- en: '[PRE33]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In our project, we will use US English as the default culture, so `NeutralLanguage`
    is set to `en-US`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中，我们将使用美国英语作为默认文化，因此将`NeutralLanguage`设置为`en-US`。
- en: Localizing text
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地化文本
- en: 'Once the resources files have been configured, we can use localized content
    in our XAML file or C# files. Currently, our project contains five content pages.
    Let’s modify `AboutPage` to support localization, as shown in *Listing 3.6*:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置了资源文件，我们就可以在我们的XAML文件或C#文件中使用本地化内容。目前，我们的项目包含五个内容页面。让我们修改`AboutPage`以支持本地化，如图**列表3.6**所示：
- en: '[PRE34]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Listing 3.6: `AboutPage.xaml` ([https://epa.ms/AboutPage3-6](https://epa.ms/AboutPage3-6))'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表3.6**：`AboutPage.xaml` ([https://epa.ms/AboutPage3-6](https://epa.ms/AboutPage3-6))'
- en: 'Text localization is done using the generated `Resources` class. This class
    is named based on the default resources file name. In *Listing 3.6* `AboutPage.xaml`,
    we added a new namespace **(1)** for the `Resources` class:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 文本本地化是通过生成的`Resources`类完成的。这个类的命名基于默认资源文件名。在**图3.6**的`AboutPage.xaml`中，我们为`Resources`类添加了一个新的命名空间**（1**）：
- en: '[PRE35]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the `Label` control **(2)**, to display our application name, we can refer
    to the resource string using the `x:Static` XAML markup extension, as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Label`控件**（2**）中，为了显示我们的应用程序名称，我们可以使用`x:Static` XAML标记扩展来引用资源字符串，如下所示：
- en: '[PRE36]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In *Listing 3.6*, we collapsed most of the source code for conciseness. Please
    refer to the short URL of this book’s GitHub repository to review the full source
    code.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在**列表3.6**中，我们为了简洁起见折叠了大部分源代码。请参考本书GitHub仓库的短URL来查看完整的源代码。
- en: 'Localized text can be used in both XAML and C#. To use a resource string in
    C#, we can examine the `Title` property in *Listing 3.6*. The `Title` property
    of `AboutPage` is connected to the `Title` property in the `AboutViewModel` class.
    Let’s see how we can use a resource string in *Listing 3.7*:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 本地化文本可以在XAML和C#中使用。要在C#中使用资源字符串，我们可以查看**列表3.6**中的`Title`属性。`AboutPage`的`Title`属性连接到`AboutViewModel`类中的`Title`属性。让我们看看我们如何在**列表3.7**中使用资源字符串：
- en: '[PRE37]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Listing 3.7: `AboutViewModel.cs` ([https://epa.ms/AboutViewModel3-7](https://epa.ms/AboutViewModel3-7))'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表3.7**：`AboutViewModel.cs` ([https://epa.ms/AboutViewModel3-7](https://epa.ms/AboutViewModel3-7))'
- en: As shown in *Listing 3.7*, **(1)** we added the `PassXYZ.Vault.Properties` namespace
    first. **(2)** We refer to the resource string as `Properties.Resources.About`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如**图3.7**所示，**(1**) 我们首先添加了`PassXYZ.Vault.Properties`命名空间。**(2**) 我们将资源字符串称为`Properties.Resources.About`。
- en: 'After we update `AboutPage` with localization support, we can test it in the
    supported languages, as shown in *Figure 3.11*:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们更新`AboutPage`以支持本地化后，我们可以在支持的语言中进行测试，如图**3.11**所示：
- en: '![](img/B21554_03_11.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21554_03_11.png)'
- en: 'Figure 3.11: AboutPage in different languages'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11：不同语言中的AboutPage
- en: In `AboutPage`, many resource strings are used for localization. In *Listing
    3.6* and *Listing 3.7*, we collapsed most of the code; you can refer to the short
    URL for this book’s GitHub repository to review the source code online.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `AboutPage` 中，许多资源字符串被用于本地化。在 *清单 3.6* 和 *清单 3.7* 中，我们折叠了大部分代码；你可以通过这本书的 GitHub
    仓库的短网址来在线查看源代码。
- en: '**.NET MVVM Community Toolkit**'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '**.NET MVVM 社区工具包**'
- en: The .NET MVVM Community Toolkit is a comprehensive collection of helpers and
    tools aimed at simplifying the development process of applications following the
    **Model-View-View-Model** (**MVVM**) pattern based on .NET libraries.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MVVM 社区工具包是一个旨在简化基于 .NET 库的 **模型-视图-视图模型**（**MVVM**）模式应用程序开发过程的辅助工具和工具集。
- en: The toolkit provides a wide array of features aimed at reducing boilerplate
    code, including converters, helpers, behaviors, commands, and services aimed at
    facilitating communication between classes in the MVVM pattern.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 工具包提供了一系列旨在减少样板代码的功能，包括转换器、辅助工具、行为、命令和服务，旨在促进 MVVM 模式中类之间的通信。
- en: More details about the .NET MVVM Community Toolkit will be introduced in the
    next chapter.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍更多关于 .NET MVVM 社区工具包的详细信息。
- en: Summary
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored XAML syntax and applied the knowledge we gained
    to enhance the appearance of `ItemsPage`. We will persist in refining the user
    interface of other pages throughout this book. To support multiple languages,
    we delved into .NET localization and created multiple resources files for the
    `US-en`, `zh-Hans`, and `zh-Hant` languages. Additionally, we discovered how to
    access strings in the resources files using the XAML markup extension. Lastly,
    we utilized `AboutPage` as an example to demonstrate the use of localized text
    in both XAML and C#.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 XAML 语法，并将我们所获得的知识应用于增强 `ItemsPage` 的外观。我们将在整本书中持续改进其他页面的用户界面。为了支持多语言，我们深入研究了
    .NET 本地化，并为 `US-en`、`zh-Hans` 和 `zh-Hant` 语言创建了多个资源文件。此外，我们还发现了如何使用 XAML 标记扩展访问资源文件中的字符串。最后，我们以
    `AboutPage` 为例，展示了在 XAML 和 C# 中使用本地化文本的方法。
- en: In the next chapter, we will continue improving our app by introducing MVVM
    and data binding.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过介绍 MVVM 和数据绑定来继续改进我们的应用程序。
- en: Further reading
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '.NET Multi-platform App UI documentation: [https://learn.microsoft.com/en-us/dotnet/maui/](https://learn.microsoft.com/en-us/dotnet/maui/)'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 多平台应用 UI 文档：[https://learn.microsoft.com/en-us/dotnet/maui/](https://learn.microsoft.com/en-us/dotnet/maui/)
- en: 'XAML - .NET MAUI: [https://learn.microsoft.com/en-us/dotnet/maui/xaml/](https://learn.microsoft.com/en-us/dotnet/maui/xaml/)'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XAML - .NET MAUI：[https://learn.microsoft.com/en-us/dotnet/maui/xaml/](https://learn.microsoft.com/en-us/dotnet/maui/xaml/)
- en: 'XAML markup extensions: [https://learn.microsoft.com/en-us/dotnet/maui/xaml/fundamentals/markup-extensions](https://learn.microsoft.com/en-us/dotnet/maui/xaml/fundamentals/markup-extensions)'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XAML 标记扩展：[https://learn.microsoft.com/en-us/dotnet/maui/xaml/fundamentals/markup-extensions](https://learn.microsoft.com/en-us/dotnet/maui/xaml/fundamentals/markup-extensions)
- en: 'KeePass – An open-source password manager: [https://keepass.info/](https://keepass.info/)'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: KeePass – 一个开源密码管理器：[https://keepass.info/](https://keepass.info/)
- en: Leave a review!
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 留下评论！
- en: '*Enjoying this book? Help readers like you by leaving an Amazon review. Scan
    the QR code below for a 40% discount code.*'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '*喜欢这本书吗？通过留下亚马逊评论帮助像你一样的读者。扫描下面的二维码获取 40% 的折扣码。*'
- en: '![](img/Leave_a_review_QR.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Leave_a_review_QR.png)'
- en: '**Limited Offer*'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '**限时优惠*'
