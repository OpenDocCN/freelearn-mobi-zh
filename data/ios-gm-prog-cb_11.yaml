- en: Chapter 11. Getting Started with Multiplayer Games
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。开始多人游戏
- en: 'In this chapter, we will be focusing on the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将关注以下食谱：
- en: Anatomy of multiplayer games
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多人游戏的结构
- en: Setup for a multiplayer game
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多人游戏的设置
- en: Assigning roles to players
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为玩家分配角色
- en: Introduction
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'So far in the book, we have done a lot of cool game-related stuff, such as
    SpriteKit, parallax scrolling background, physics simulation with autonomous moving
    agents, three-dimensional game programming using OpenGL, and much more. All these
    were done to make a single-player game, meaning only one person can play it at
    a time. But now, we will be moving forward to make a multiplayer game, which engages
    more than one person at the same time. Multiplayer is, in itself, more engaging
    and fun for the user, as live competition gets into the picture, making the gaming
    experience a lot more enjoyable for the users. So, it''s time to understand things
    related to multiplayer games. In [Chapter 12](part0069_split_000.html#page "Chapter 12. Implementing
    Multiplayer Games"), *Implementing Multiplayer Games*, we will be creating a multiplayer
    game. For taking a tour of multiplayer game development, the overall agenda will
    be divided into the following sections:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中，我们已经做了很多与游戏相关酷炫的事情，例如SpriteKit、视差滚动背景、使用自主移动代理的物理模拟、使用OpenGL进行三维游戏编程等等。所有这些都是为了制作单人游戏，意味着一次只能有一个人玩。但现在，我们将向前迈进，制作一个多人游戏，这个游戏可以同时吸引多个人。多人游戏本身对用户来说就更有吸引力、更有趣，因为实时竞争加入了进来，使得游戏体验对用户来说更加愉快。所以，现在是时候了解与多人游戏相关的内容了。在[第12章](part0069_split_000.html#page
    "第12章。实现多人游戏")《实现多人游戏》中，我们将创建一个多人游戏。为了游览多人游戏开发，整体议程将分为以下部分：
- en: Creating a sample multiplayer game to understand the anatomy and various states
    of a multiplayer game.
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个示例多人游戏以了解多人游戏的结构和各种状态。
- en: Doing the setup for the same multiplayer game using SpriteKit and Apple's Multipeer
    Connectivity framework. After that, handshaking or connection establishment between
    players using `MCBrowserViewController` of the same framework.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用SpriteKit和苹果的Multipeer Connectivity框架设置相同的多人游戏。之后，使用同一框架的`MCBrowserViewController`进行玩家之间的握手或连接建立。
- en: Assigning roles to players by sending and receiving network packets.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过发送和接收网络数据包为玩家分配角色。
- en: Anatomy of multiplayer games
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多人游戏的结构
- en: In a single-player game, there is only one player, so talking about the game
    as an object that maintains all of the game behavior, whereas if we understand
    the anatomy of multiplayer games, we'll see that it's totally different. In multiplayer
    games, there are multiple players playing the same game, so technically for every
    device, there is a player who is actively driving the game on that device. This
    is called the local player, and all other players are treated as remotes players
    for that device. The local player's activities should ideally be updated on the
    remote players' devices, which is the foremost challenge in multiplayer development.
    The update of the local player is called syncing the game on some other device,
    and is done by the game object that resides in the game. It's the responsibility
    of the game object (that is, the instance of game running on the device) to make
    the game look the same on all devices as a live game is played.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在单人游戏中，只有一个玩家，所以谈论游戏作为一个维护所有游戏行为的对象，而如果我们理解多人游戏的结构，我们会看到它完全不同。在多人游戏中，有多个玩家在玩同一款游戏，所以从技术上讲，对于每个设备，都有一个玩家正在积极驱动该设备上的游戏。这被称为本地玩家，而所有其他玩家都被视为该设备的远程玩家。理想情况下，本地玩家的活动应该更新在远程玩家的设备上，这是多人开发中最主要的挑战。本地玩家的更新被称为在其他设备上同步游戏，这是由游戏对象完成的，该游戏对象位于游戏中。游戏对象（即运行在设备上的游戏实例）的责任是使所有设备上的游戏看起来与实时游戏一样。
- en: So, moving further in this section, we will be creating a fresh multiplayer
    game, called TankRace, using SpriteKit, in which game sessions will be instantiated.
    We will incorporate multiplayer game states with their explanation and essentiality.
    All the session and multiplayer related processes will be done using the Multipeer
    Connectivity framework introduced in iOS 7, which was a part of GameKit in iOS
    6.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在接下来的这一节中，我们将创建一个全新的多人游戏，名为TankRace，使用SpriteKit，其中将实例化游戏会话。我们将结合多人游戏状态及其解释和必要性。所有会话和多人相关的过程都将使用iOS
    7中引入的Multipeer Connectivity框架完成，该框架是iOS 6中GameKit的一部分。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To develop the TankRace multiplayer game using SpriteKit, start by creating
    a new project. Open Xcode and go to **File** | **New** | **Project** | **iOS**
    | **Application** | **SpriteKit Game**. In the pop-up, type the **Product Name**
    as `TankRace`, go to **Devices** | **iPhone**, and click on **Next**, as shown
    in the following screenshot:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用SpriteKit开发坦克大战多人游戏，首先创建一个新的项目。打开Xcode，转到**文件** | **新建** | **项目** | **iOS**
    | **应用程序** | **SpriteKit游戏**。在弹出的窗口中，将**产品名称**输入为`TankRace`，转到**设备** | **iPhone**，然后点击**下一步**，如下截图所示：
- en: '![Getting ready](img/00165.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/00165.jpeg)'
- en: Click on **Next** and save the project on your hard drive.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**下一步**，并将项目保存在你的硬盘上。
- en: Once the project is saved, you should be able to see the project settings. On
    the project settings page, just check in the **Portrait** from the **Device Orientation**
    section and uncheck all others, as we are supporting only the portrait mode for
    this game. Also set the deployment target to 7.0 so that a range of devices can
    be supported.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦项目保存，你应该能够看到项目设置。在项目设置页面，只需从**设备方向**部分勾选**纵向**，并取消勾选所有其他选项，因为我们只支持这款游戏的纵向模式。同时将部署目标设置为7.0，以便支持一系列设备。
- en: 'The changes are shown here:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 变化如下所示：
- en: '![Getting ready](img/00166.jpeg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/00166.jpeg)'
- en: 'Let''s take a closer view at what structure SpriteKit has provided:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看SpriteKit提供的是什么结构：
- en: '![Getting ready](img/00167.jpeg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/00167.jpeg)'
- en: 'In the `viewDidLoad` method of `GameViewController` a piece of code is written
    that converts its view to `SKView` and a scene that is, `GameScene` is presented
    on the `SKView` as shown below. The `unarchiveFromFile` method is implemented
    by the project itself to fetch the `GameScene.sks` file, which we can see in the
    project created. For not showing the FPS and nodes, comment both the lines as
    shown in the following code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GameViewController`的`viewDidLoad`方法中，编写了一段代码，将其视图转换为`SKView`，并在`SKView`上呈现一个场景，即`GameScene`，如下所示。项目本身实现了`unarchiveFromFile`方法来获取`GameScene.sks`文件，我们可以在创建的项目中看到它。为了不显示FPS和节点，注释掉以下代码中的两行：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How to do it...
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Before starting with the multiplayer code we should make the game ready for
    it. First, go in to the `GameScene` class and remove the sample `SKLabelNode`
    addition code in the overridden method `didMoveToView` of `GameScene` where we
    usually set up the scene. Secondly, remove the `for` loop of touches from the
    `touchesBegan:withEvent` method, which does the addition of `SKSpriteNode` and
    its action.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始多人游戏代码之前，我们应该让游戏为多人游戏做好准备。首先，进入`GameScene`类，并在通常设置场景的覆盖方法`didMoveToView`中删除示例`SKLabelNode`添加代码。其次，从`touchesBegan:withEvent`方法中删除`for`循环，该方法负责添加`SKSpriteNode`及其动作。
- en: 'Our project is now ready to start with the multiplayer. Multiplayer games can
    be developed in several ways. They can be either played using Bluetooth, Wifi,
    Internet, or GameCenter. All these techniques allow us to interconnect devices
    and share data across devices. This allows us to show the movement of players
    in real time. You might have seen the responsiveness in multiplayer games. They
    are really seamless. In this section we will explore more about multiplayer games
    and their implementation in iOS. Here we will be instantiating a session (that
    is, MCSession) for the local player, which will further connect to another player
    in this recipe. Also, to instruct the user to touch we will add an info label
    saying `Tap to connect` and further will implement the delegates of MCSession
    following with the explanation of Multiplayer Game States. Stated below are the
    steps to accomplish this task:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目现在可以开始多人游戏了。多人游戏可以通过多种方式开发。它们可以通过蓝牙、Wi-Fi、互联网或GameCenter进行游戏。所有这些技术都允许我们互联设备并在设备之间共享数据。这使我们能够实时显示玩家的移动。你可能已经看到了多人游戏中的响应速度。它们非常流畅。在本节中，我们将探讨更多关于多人游戏及其在iOS中的实现。在这里，我们将为本地玩家实例化一个会话（即MCSession），该会话将进一步连接到本食谱中的另一个玩家。此外，为了指导用户触摸，我们将添加一个信息标签，显示“点击连接”，并进一步实现MCSession的代理，随后将解释多人游戏状态。以下是实现此任务的步骤：
- en: 'Open `GameScene.m` file, and create an interface with properties of `InfoLabel`
    and all related session stuff. Also make `GameScene` follow `MCSessionDelegate`
    and the interface will look like this:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`GameScene.m`文件，创建一个具有`InfoLabel`属性和所有相关会话内容的接口。同时让`GameScene`遵循`MCSessionDelegate`，接口看起来如下：
- en: '[PRE1]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here `gameSession` is the session that will be created for playing a multiplayer
    game, `gamePeerID` is the unique ID for the local player of this `gameSession`,
    which will be in future acting as the unique ID of the remote player to whom this
    device will be connected to. This is why it is called peerID. `ServiceType` is
    the unique ID assigned particularly to the game; here, the service type will be
    TankRace and advertiser is a class that handles all incoming invitations to the
    user and handles all user responses. A `gameInfoLabel` property is declared, which
    will be created to instruct the user to connect with other players.
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，`gameSession`是用于玩多人游戏的会话，`gamePeerID`是本地玩家的唯一ID，在将来将作为连接到此设备的远程玩家的唯一ID。这就是为什么它被称为peerID。`ServiceType`是特别分配给游戏的唯一ID；在这里，服务类型将是TankRace，而广告商是一个处理所有传入邀请给用户的类，并处理所有用户响应的类。声明了一个`gameInfoLabel`属性，它将被创建来指导用户与其他玩家连接。
- en: Add a method called `addGameInfoLabelWithText`, which can be used to show any
    GameInfo with `pragma` mark.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`addGameInfoLabelWithText`的方法，它可以用来显示任何带有`pragma`标记的GameInfo。
- en: '[PRE2]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Declare hash defines for different GameInfo texts.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为不同的GameInfo文本声明哈希定义。
- en: '[PRE3]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Call `addGameInfoLabelWithText` from the `didMoveToView` method of `GameScene`.
    With text hash define `kConnectingDevicesText` and `pragma` mark as depicted below.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`GameScene`的`didMoveToView`方法中调用`addGameInfoLabelWithText`。使用文本哈希定义`kConnectingDevicesText`和`pragma`标记，如下所示。
- en: '[PRE4]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Declare an `enum`, `GameState`, and a property corresponding to it in the private
    interface of `GameScene`. Also, set the initial state of game as `kGameStatePlayerToConnect`,
    as, to start a multiplayer game, players need to be connected first to play. Add
    these lines just above the hash defines:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GameScene`的私有接口中声明一个`enum`，`GameState`，以及与之对应的属性。同时，将游戏初始状态设置为`kGameStatePlayerToConnect`，因为要开始多人游戏，玩家首先需要连接才能玩游戏。将这些行添加到哈希定义之上：
- en: '[PRE5]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add this property of `gameState` in the private interface of `GameScene`:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GameScene`的私有接口中添加此`gameState`属性：
- en: '[PRE6]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Assign `gameState` to `kGameStatePlayerToConnect` in `didMoveToView` of `GameScene`:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GameScene`的`didMoveToView`中将`gameState`赋值为`kGameStatePlayerToConnect`：
- en: '[PRE7]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create a method called `instantiateMCSession` and add the `pragma` mark as
    shown in the following code:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`instantiateMCSession`的方法，并添加如下代码中的`pragma`标记：
- en: '[PRE8]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Implement all delegates `MCSessionDelegate` with the `pragma` mark as shown
    below:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现所有具有以下`pragma`标记的`MCSessionDelegate`：
- en: '[PRE10]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: These all are the delegate methods of `MCSession` implemented in the `GameScene`
    class, amongst which the former two are mostly used. The first one is used to
    determine the state of game changes, like, whether it is connected, connecting
    or not connected. And the latter one is used to receive data, hence to process
    that data under an operation queue block as shown in the above implementation.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些都是在`GameScene`类中实现的`MCSession`的代理方法，其中前两种使用得最多。第一个用于确定游戏状态的变化，例如，是否已连接、正在连接或未连接。后者用于接收数据，因此可以在上述实现中的操作队列块中处理这些数据。
- en: Now add `instantiateMCSession` in `touchBegan:withEvent` according to `gameState`
    of `GameScene` with `pragma` mark.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在根据`GameScene`的`gameState`，在`touchBegan:withEvent`中添加`instantiateMCSession`，并使用`pragma`标记。
- en: '[PRE11]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the `touchesBegan` method if the state is `kGameStatePlayerToConnect` then
    it means that the user has touched to start the game that is, technically connecting
    of players to be done and in other states of game the handling would be done accordingly
    on touches.
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`touchesBegan`方法中，如果状态是`kGameStatePlayerToConnect`，则表示用户已触摸以开始游戏，即技术上需要完成玩家的连接，而在游戏的其他状态下，将根据触摸相应地处理。
- en: After all these steps an initial session of game set up has been accomplished
    with an understanding of multiplayer games' architecture.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 经过所有这些步骤，已经完成了游戏初始会话的设置，并理解了多人游戏架构。
- en: How it works...
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the preceding setup we used the Multipeer Connectivity framework for setting
    up a structure of a multiplayer game with an instance of `MCSession` to be there
    in every device that will be used to play the game. We also implemented all its
    delegate methods, which informs the `GameScene` about the changing of game states
    and will also be used for receiving data when incoming sections from some network
    packets are sent. For now, in this section, we have put a label `Tap to connect`
    and on clicking the screen a session is instantiated. Now build the project. First
    you will see the following launch screen and then the initial `GameScene` with
    a label **Tap to connect**:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的设置中，我们使用了 Multipeer Connectivity 框架，通过 `MCSession` 实例来设置一个多人游戏的结构，这个实例将存在于每个用于玩游戏设备上。我们还实现了所有其代理方法，这些方法会通知
    `GameScene` 游戏状态的变化，也将在接收来自某些网络数据包的传入部分时使用。现在，在这一节中，我们放置了一个标签 `Tap to connect`，点击屏幕时将实例化一个会话。现在构建项目。首先你会看到以下启动屏幕，然后是带有标签
    **Tap to connect** 的初始 `GameScene`：
- en: '![How it works...](img/00168.jpeg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/00168.jpeg)'
- en: Setup for a multiplayer game
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多人游戏的设置
- en: In this recipe, we will write the code for setting up our multiplayer game.
    All the configurations and session managers will be the part of this section.
    We will dig into the various concepts of creating and maintaining sessions.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将编写设置我们的多人游戏的代码。所有配置和会话管理器都将包含在本节中。我们将深入研究创建和维护会话的各种概念。
- en: Getting ready
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before starting this recipe, MCSession, MCPeerId, advertiser and service type
    terms of Multipeer Connectivity framework should be known to us. In this recipe
    we will be establishing the connection between players, thereby, they can communicate
    in future, making the players play a game, which we will be doing in the next
    chapter.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始这个菜谱之前，我们应该了解 Multipeer Connectivity 框架中的 MCSession、MCPeerId、广告商和服务类型术语。在这个菜谱中，我们将建立玩家之间的连接，从而他们可以在未来进行通信，让玩家玩游戏，我们将在下一章中这样做。
- en: How to do it
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Now, on tapping the screen, a MCSession with a service type has been instantiated;
    we can use this session and service type to present a `MCBrowserViewController`
    and establish connection between players (that is, devices). `MCBrowserViewController`
    is fully equipped and designed for connecting multiple players for a session provided
    in the Multipeer Connectivity framework. These are the steps involved:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击屏幕后，已经实例化了一个具有服务类型的 MCSession；我们可以使用这个会话和服务类型来展示 `MCBrowserViewController`
    并在玩家（即设备）之间建立连接。`MCBrowserViewController` 是完全配备和设计用于连接 Multipeer Connectivity
    框架中提供的会话的多个玩家。以下是涉及的步骤：
- en: 'First of all, create a protocol of `GameScene` as `GameSceneDelegate` and its
    delegate object in `GameScene`, which will be set as `GameViewController` so that
    it uses its delegate method when the user touches the screen. `GameViewController`
    can be informed to present `MCBrowserViewController`. Declare the protocol code
    and `GameSceneDelegate` object, as follows:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个 `GameScene` 的协议 `GameSceneDelegate` 和其在 `GameScene` 中的代理对象，该对象将被设置为
    `GameViewController` 以便在用户触摸屏幕时使用其代理方法。`GameViewController` 可以被通知展示 `MCBrowserViewController`。声明协议代码和
    `GameSceneDelegate` 对象，如下所示：
- en: '[PRE12]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When the user touches the screen that has the `gameState` as `kGameStatePlayerToConnect`,
    where we are calling the method, `instantiateMCSession`, which also informs `gameSceneDelegate`
    to show `MCBrowserViewController` by passing `gameSession` that was created and
    the `serviceType` property:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户触摸的屏幕上的 `gameState` 为 `kGameStatePlayerToConnect` 时，我们调用 `instantiateMCSession`
    方法，该方法还通知 `gameSceneDelegate` 通过传递创建的 `gameSession` 和 `serviceType` 属性来展示 `MCBrowserViewController`：
- en: '[PRE13]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The delegate method has to be called by `GameViewController`, and on the same
    controller, `MCBrowserViewController` has to be presented, which will also have
    its own delegate methods. Now, it''s time to declare the private interface of
    `GameViewController` and follow both `MCBrowserViewControllerDelegate` and `GameSceneDelegate`
    as shown in this snippet:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代理方法必须由 `GameViewController` 调用，在同一个控制器上，`MCBrowserViewController` 也必须展示，它也将有自己的代理方法。现在，是时候声明
    `GameViewController` 的私有接口，并遵循 `MCBrowserViewControllerDelegate` 和 `GameSceneDelegate`，如下代码片段所示：
- en: '[PRE14]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In `viewDidLoad` of `GameViewController`, replace the local scene object with
    `self.gameScene` and assign the `gameSceneDelegate` property of the `GameScene`
    object as the `GameViewController`, as shown here:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `GameViewController` 的 `viewDidLoad` 方法中，将本地场景对象替换为 `self.gameScene`，并将 `GameScene`
    对象的 `gameSceneDelegate` 属性设置为 `GameViewController`，如下所示：
- en: '[PRE15]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Implement the delegate method of `GameSceneDelegate`, like this:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现如下 `GameSceneDelegate` 的代理方法：
- en: '[PRE16]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this method, `MCBrowserViewController` is presented on `GameViewController`
    with its delegate set and restricted the peers to `2`.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个方法中，`MCBrowserViewController` 在 `GameViewController` 上呈现，并设置了其代理，并将对等体限制为
    `2`。
- en: Add two public methods to `GameScene`, to be called the cancel and done actions
    of `MCBrowserViewController`.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `GameScene` 添加两个公共方法，用于调用 `MCBrowserViewController` 的取消和完成操作。
- en: 'In `GameScene.h`, declare the public methods, as follows:'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `GameScene.h` 文件中，声明公共方法，如下所示：
- en: '[PRE17]'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In `GameScene.m`, define the public methods, like this:'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `GameScene.m` 文件中，定义公共方法，例如：
- en: '[PRE18]'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now we will add two public methods in the `GameScene` file. These methods will
    be invoked on the cancel and done actions of `MCBrowserViewControllerDelegate`
    respectively:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将在 `GameScene` 文件中添加两个公共方法。这些方法将分别在 `MCBrowserViewControllerDelegate` 的取消和完成操作中调用：
- en: '[PRE19]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In both the delegate methods, first the `MCBrowserViewController` is dismissed
    and `GameScene` is informed to change accordingly.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这两个代理方法中，首先关闭 `MCBrowserViewController`，并通知 `GameScene` 适当更改。
- en: Now when both the device players click on the screen, `MCBrowserViewController`
    opens and the players try to connect to each other using the default behavior
    provided by this controller, and when done we show the appropriate text to the
    player. Hence this entire implementation accomplishes our starter kit of this
    chapter.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当两位设备玩家点击屏幕时，`MCBrowserViewController` 打开，玩家尝试使用此控制器提供的默认行为相互连接，完成后向玩家显示相应的文本。因此，这个整个实现完成了本章的入门套件。
- en: How it works
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'Now we will understand how the connection using the `MCBrowserViewController`
    is established in the following steps (in the snapshots shown below, the left
    side is the simulator device and right side is iPhone 5s):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将了解如何使用 `MCBrowserViewController` 建立连接，以下步骤（在下图中，左侧是模拟器设备，右侧是iPhone 5s）：
- en: Both the players click on the screen and `MCBrowserViewController` opens, searching
    for peers nearby, with cancel and done buttons placed on the navigation bar. Here
    the done button is disabled, as initially no one is connected to the device.![How
    it works](img/00169.jpeg)
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两位玩家点击屏幕，打开 `MCBrowserViewController`，搜索附近的对等体，取消和完成按钮放置在导航栏上。在这里，完成按钮是禁用的，因为最初没有人连接到设备。![工作原理](img/00169.jpeg)
- en: Once a peer is detected, it shows the name of the devices in the list.![How
    it works](img/00170.jpeg)
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦检测到对等体，它会在列表中显示设备的名称。![工作原理](img/00170.jpeg)
- en: After that both the players press the device name with which they want to connect
    and the search of peers stop. Hence following this selection of device a request
    is sent to connect to it.![How it works](img/00171.jpeg)
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，两位玩家都按下他们想要连接的设备名称，搜索对等体的操作停止。因此，根据这个设备选择，发送一个连接到它的请求。![工作原理](img/00171.jpeg)
- en: Depending on the reply of the other user the status of the peer at the right
    text of table row is updated; it can be **Connecting**, **Connected**. And when
    the devices are connected the status is changed to **Connected** and the **Done**
    button is enabled.![How it works](img/00172.jpeg)
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据另一用户的回复，更新表格行右侧的对等体状态；它可以是**连接中**，**已连接**。当设备连接时，状态变为**已连接**，并且**完成**按钮被启用。![工作原理](img/00172.jpeg)
- en: When the player selects **Done** or **Cancel**, we show them the appropriate
    text, **Devices Connected** on clicking on the **Done** button and **Tap to connect**
    on clicking the **Cancel** button. Now, the devices are logically connected to
    each other and are sharing the same session. This session will be used further
    in the multiplayer game by the user to play.![How it works](img/00173.jpeg)
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当玩家选择**完成**或**取消**时，我们显示相应的文本，点击**完成**按钮显示**设备已连接**，点击**取消**按钮显示**点击连接**。现在，设备在逻辑上是连接的，并且共享相同的会话。这个会话将由用户在多人游戏中进一步使用来玩游戏。![工作原理](img/00173.jpeg)
- en: Here, in all this process, we will see some network lagging also, so if the
    devices are not connecting, try to reconnect by cancelling the controller and
    again clicking on the screen to refresh the controller again.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们还将看到一些网络延迟，所以如果设备没有连接，尝试通过取消控制器并再次点击屏幕来刷新控制器以重新连接。
- en: Assigning roles to players
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分配玩家角色
- en: In this recipe, we will take our game template to the next step by assigning
    the roles to our players. This means we will be logically dividing the users and
    assigning roles to them. This will provide an individual identity to the players.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将通过为玩家分配角色，将我们的游戏模板提升到下一个步骤。这意味着我们将从逻辑上划分用户并为他们分配角色。这将为玩家提供个体身份。
- en: Getting ready
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before starting with assigning or as we can also call it, an allotment of players
    identity (which is first player and second player), we should be familiar with
    the Multipeer Connectivity framework. We must also have a basic knowledge of network
    packet sending and receiving. In this section we will be assigning the first and
    second player identities to the players once they are connected using the `MCBrowserViewController`
    having just described it in the preceding recipe by pressing the **Done** button.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始分配或我们也可以称之为玩家身份的分配之前（即第一位玩家和第二位玩家），我们应该熟悉多对等连接框架。我们还必须具备网络数据包发送和接收的基本知识。在本节中，一旦使用前面配方中描述的`MCBrowserViewController`连接，我们将为玩家分配第一位和第二位玩家的身份。
- en: How to do it
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'To accomplish the assignment of players, following are the steps to be followed:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成玩家的分配，以下是需要遵循的步骤：
- en: 'For a set up purpose for this add some enums, hash define constants and properties
    as shown below:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了设置这个目的，添加一些枚举、哈希定义常量和属性，如下所示：
- en: Declare an `enum` called `NetworkPacketCode` in which we add only the `KNetworkPacketCodePlayerAllotment`
    packet code for now, and in the future more packet codes can be added for sending
    and receiving packets from the game.
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明一个名为`NetworkPacketCode`的`enum`，目前我们只添加了`KNetworkPacketCodePlayerAllotment`数据包代码，未来可以添加更多数据包代码，用于从游戏中发送和接收数据包。
- en: '[PRE20]'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Add texts to be shown to players when the player roles are being decided.
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加在玩家角色正在决定时显示给玩家的文本。
- en: '[PRE21]'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Add the max packet size constant and some properties like `gamePacketNumber`,
    `gameUniqueIdForPlayerAllocation` in `GameScene.m` to be used while sending packets.
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`GameScene.m`中添加最大数据包大小常量以及一些属性，如`gamePacketNumber`、`gameUniqueIdForPlayerAllocation`，以便在发送数据包时使用。
- en: '[PRE22]'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now to send data from one device to another, we have an encapsulated data container,
    which is called a packet. Now this packet is sent over the network and the other
    player's device will update the view and position accordingly. For this, create
    a method to send the packet with a header `NetworkPacketCode` and data specifying
    `peerId` to which the data packet has to be sent and whether the packet should
    be sent with a reliable service or not.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在为了从一个设备向另一个设备发送数据，我们有一个封装的数据容器，称为数据包。现在这个数据包通过网络发送，其他玩家的设备将相应地更新视图和位置。为此，创建一个方法来发送带有头部`NetworkPacketCode`和数据的数据包，指定要发送数据包的`peerId`以及数据包是否应该使用可靠服务发送。
- en: '[PRE23]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here `networkPacket` is created with a header and data. A variable `pIntData`
    is declared, which is the header containing the `NetworkPacketCode` and a `gamePacketNumber`
    so that a unique number is assigned to a packet to serialize the network packets
    to be used to sync or update the game properly. Once the packet is created, a
    method called `sendData` of `MCSession` is called with the packet to be sent,
    `peerID` to which the packet has to be sent, the mode, which can be `MCSessionSendDataUnreliable`
    or `MCSessionSendDataReliable` and `error` to check whether an error has occurred
    while sending the packet.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，`networkPacket`通过一个头部和数据创建。声明了一个变量`pIntData`，它是包含`NetworkPacketCode`和`gamePacketNumber`的头部，以便为数据包分配一个唯一的数字，以序列化网络数据包，用于同步或正确更新游戏。一旦创建数据包，就调用`MCSession`的`sendData`方法，传递要发送的数据包，`peerID`数据包需要发送到的对等方，模式可以是`MCSessionSendDataUnreliable`或`MCSessionSendDataReliable`，以及`error`来检查在发送数据包时是否发生错误。
- en: This method will be reused everywhere in the game to send packets to peers of
    the same game.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法将在游戏中各个地方重复使用，以向相同游戏的对等方发送数据包。
- en: Generate a random number and store it in the variable `gameUniqueIdForPlayerAllocation`
    declared above, which will help to decide which will be the first and second player.
    Add this line in the `didMoveToView` method of `GameScene`.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成一个随机数并将其存储在上述声明的变量`gameUniqueIdForPlayerAllocation`中，这将有助于决定哪位是第一位和第二位玩家。在`GameScene`的`didMoveToView`方法中添加此行。
- en: '[PRE24]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Add the following code to receiving data delegate method of `MCSession` for
    handling of received packets based on their `NetworkPacketCode` as shown in the
    following code:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`MCSession`的接收数据代理方法中，根据其`NetworkPacketCode`处理接收到的数据包，如下所示：
- en: '[PRE25]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: While receiving the data, it should be processed on a `mainQueue` operation
    block. In this block, we will remove the header in the `pIntData` pointer variable
    and get the `NetworkPacketCode` sent in the packet. In this code, we will check
    the type of packet which is sent. Then we will parse the packet based on its type.
    In this, a player allotment packet type named `KNetworkPacketCodePlayerAllotment`
    is passed, hence the data retrieved is `gameUniqueId`. As discussed above, in
    `didMoveToView`, we assigned a random number to a variable named `gameUniqueIdForPlayerAllocation`
    for both the devices. Hence for both devices, different numbers are generated
    & while sending the allotment packet from both devices, this is passed as the
    data (the allotment packet to be sent would be discussed in next point). Finally
    to decide which is first and second player, the local value of `gameUniqueIdForPlayerAllocation`
    would be compared with the value sent in the packet, on this comparison one would
    be assigned as the first player and other as the second player, informing the
    users by changing appropriate text of `gameInfoLabel` as shown in the delegate
    method.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在接收数据时，应在`mainQueue`操作块中处理。在这个块中，我们将从`pIntData`指针变量中移除头部并获取数据包中发送的`NetworkPacketCode`。在这个代码中，我们将检查发送的包的类型。然后我们将根据其类型解析数据包。在这里，一个名为`KNetworkPacketCodePlayerAllotment`的玩家分配包类型被传递，因此检索到的数据是`gameUniqueId`。如前所述，在`didMoveToView`中，我们为两个设备分配了一个随机数给变量`gameUniqueIdForPlayerAllocation`。因此，对于两个设备，生成了不同的数字，并且在从两个设备发送分配数据包时，这作为数据（将在下一点讨论要发送的分配数据包）传递。最后，为了决定哪个是第一和第二玩家，将比较本地`gameUniqueIdForPlayerAllocation`的值和包中发送的值，在这个比较中，一个将被分配为第一玩家，另一个将被分配为第二玩家，通过更改`gameInfoLabel`的适当文本来通知用户，如代理方法中所示。
- en: Remove the following written line from the public method `startGame` of `GameScene`
    as now, the `gameInfoLabel` will be set according to the packet received.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请从`GameScene`的公共方法`startGame`中删除以下写有内容的行，因为现在`gameInfoLabel`将根据接收到的数据包设置。
- en: '[PRE26]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'All these earlier processes start when the user clicks on the done button.
    This button is an indication that the players have been connected and a delegate
    method `didChangeState` of `MCSession` will be called with a `MCSessionState`
    called `MCSessionStateConnected`, and as a checking protocol is already in-built
    in this method of connected state, add the following code in the `if` statement:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有这些早期过程都是在用户点击完成按钮时开始的。这个按钮是玩家已经连接的指示，并且将调用`MCSession`的代理方法`didChangeState`，并带有名为`MCSessionStateConnected`的`MCSessionState`，并且由于连接状态的方法中已经内置了检查协议，所以在`if`语句中添加以下代码：
- en: '[PRE27]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, in this method, set all properties that come from the method, as it is
    the remote player information, and set the game state to `kGameStatePlayerAllotment`
    locally. Then, we send the packet of the allotment of the player to `peerID`,
    for which the connection has been established with a `NetworkPacketCode` and a
    data part, which would be received at the remote end as discussed previously.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '在这个方法中，设置所有来自该方法的属性，因为它是远程玩家信息，并将游戏状态本地设置为`kGameStatePlayerAllotment`。然后，我们将分配玩家的数据包发送到`peerID`，对于该ID已经建立了连接，使用`NetworkPacketCode`和数据部分，这将如之前讨论的那样在远程端接收。 '
- en: Finally, we are done with connecting two players for a multiplayer game and
    assigning them a unique identity for further identification to build the game.
    This recipe acts as the solution kit for this chapter.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们完成了为多人游戏连接两个玩家并为他们分配唯一身份以进一步识别以构建游戏的工作。这个方法作为本章的解决方案集。
- en: How it works
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作
- en: The entire assignment of players depends on what action and data the packet
    is sent with, and how it is parsed at the receiver's end according to the convention
    set by the sender. To accomplish the allotment of the player's identity, we used
    a random number variable, which is locally generated and passed in the allotment
    packet. At the receiving end, the logic of allotment is written, checking the
    locally set and remotely passed random number. Based on this comparison, the first
    and second players are decided.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家的整个分配取决于数据包中发送的动作和数据，以及接收端根据发送端设定的规范如何解析。为了完成玩家身份的分配，我们使用了一个随机数变量，该变量是本地生成的并在分配数据包中传递。在接收端，编写了分配逻辑，检查本地设置的随机数和远程传递的随机数。基于这个比较，确定了第一和第二玩家。
- en: 'Some text is shown on both the devices, informing the players about their identity,
    as shown here:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个设备上显示了一些文本，告知玩家他们的身份，如下所示：
- en: '![How it works](img/00174.jpeg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作](img/00174.jpeg)'
- en: There's more
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多
- en: In the preceding section, we have used the Multipeer Connectivity framework.
    We can also use the GameKit framework. For more information on this take a look
    at [https://developer.apple.com/library/ios/documentation/GameKit/Reference/GameKit_Collection/index.html](https://developer.apple.com/library/ios/documentation/GameKit/Reference/GameKit_Collection/index.html).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们使用了多对等连接框架。我们还可以使用GameKit框架。有关更多信息，请参阅[https://developer.apple.com/library/ios/documentation/GameKit/Reference/GameKit_Collection/index.html](https://developer.apple.com/library/ios/documentation/GameKit/Reference/GameKit_Collection/index.html)。
- en: See also
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: For better understanding and learning the Multipeer Connectivity framework,
    visit [https://developer.apple.com/library/prerelease/ios/documentation/MultipeerConnectivity/Reference/MultipeerConnectivityFramework/index.html](https://developer.apple.com/library/prerelease/ios/documentation/MultipeerConnectivity/Reference/MultipeerConnectivityFramework/index.html).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解和学习多对等连接框架，请访问[https://developer.apple.com/library/prerelease/ios/documentation/MultipeerConnectivity/Reference/MultipeerConnectivityFramework/index.html](https://developer.apple.com/library/prerelease/ios/documentation/MultipeerConnectivity/Reference/MultipeerConnectivityFramework/index.html)。
