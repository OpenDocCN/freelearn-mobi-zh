- en: Chapter 5. Generics and Associated Type Protocols
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章：泛型和关联类型协议
- en: Generics enable us to write flexible reusable functions, methods, and types
    that can work with any type. This chapter explains how to define and use generics
    and introduces the problems that can be solved with generics in the Swift programming
    language with examples.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型使我们能够编写灵活、可重用的函数、方法和类型，它们可以与任何类型一起工作。本章解释了如何定义和使用泛型，并通过示例介绍了Swift编程语言中泛型可以解决的问题。
- en: 'This chapter will cover the following topics with coding examples:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将通过代码示例涵盖以下主题：
- en: Generic functions and methods
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型函数和方法
- en: Generic parameters
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型参数
- en: Generic type constraints and where clauses
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型类型约束和where子句
- en: Generic data structures
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型数据结构
- en: Associated type protocols
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关联类型协议
- en: Extending generic types
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展泛型类型
- en: Subclassing generic classes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子类化泛型类
- en: What are generics and what kind of problems do they solve?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型是什么，它们解决了哪些问题？
- en: Swift is a type-safe language. Whenever we work with types, we need to specify
    them. For instance, a function can have specific parameters and return types.
    We cannot pass any type but the ones that are specified. What if we need a function
    that can handle more than one type?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Swift是一种类型安全的语言。每次我们与类型一起工作时，我们都需要指定它们。例如，一个函数可以有特定的参数和返回类型。我们不能传递任何类型，而只能是指定的类型。如果我们需要一个可以处理多种类型的函数怎么办？
- en: 'We already know that Swift provides `Any` and `AnyObject` but it is not a good
    practice to use them unless we have to. Using `Any` and `AnyObject` will make
    our code fragile as we will not be able to catch type mismatching during compile
    time. Generics are the solution to our requirement. Let''s examine an example
    first. The following function simply swaps two values (`a` and `b`). The values
    `a` and `b` are of the `Int` type. We have to pass only `Int` values to this function
    to be able to compile the application:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道Swift提供了 `Any` 和 `AnyObject`，但除非我们不得不使用它们，否则这不是一个好的实践。使用 `Any` 和 `AnyObject`
    将使我们的代码变得脆弱，因为我们无法在编译时捕获类型不匹配。泛型是我们需求的解决方案。让我们先看一个例子。以下函数简单地交换两个值（`a` 和 `b`）。`a`
    和 `b` 的类型是 `Int`。我们必须只传递 `Int` 类型的值来编译应用程序：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Type safety is supposed to be a good thing but it makes our code less generic
    in this case. What if we want to swap two `Strings`? Should we duplicate this
    function with a new one?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 类型安全本应是一件好事，但在这个情况下它让我们的代码变得不那么通用。如果我们想交换两个 `Strings` 呢？我们应该为这个函数创建一个新的副本吗？
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The bodies of these two functions are identical. The only difference relies
    on the function signature, more specifically, parameter types. Some may think
    it is a good idea to change these parameters'' type to `Any` or `AnyObject`. Remembering
    that `AnyObject` can represent an instance of any class type and `Any` can represent
    an instance of any type, excluding function types, let''s assume that we change
    the types to `Any`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数的主体是相同的。唯一的区别在于函数签名，更具体地说，是参数类型。有些人可能会认为将这些参数的类型更改为 `Any` 或 `AnyObject`
    是一个好主意。记住 `AnyObject` 可以代表任何类类型的实例，而 `Any` 可以代表任何类型的实例，除了函数类型，让我们假设我们将类型更改为 `Any`：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Our API user can go ahead and send any types as parameters. They may not match.
    The compiler is not going to complain. Let''s examine the following example:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的API用户可以继续发送任何类型的参数。它们可能不匹配。编译器不会抱怨。让我们检查以下示例：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Our function is called by `String` and `Int` parameters. Our function swaps
    two values so the returned `a` becomes `Int` and `b` becomes `String`. This will
    make our code easily breakable and very hard to follow.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的功能是通过 `String` 和 `Int` 参数调用的。我们的函数交换两个值，所以返回的 `a` 变成了 `Int`，而 `b` 变成了 `String`。这将使我们的代码容易出错，并且很难跟踪。
- en: 'We do not want to be that flexible. We do not want to use `Any` and `AnyObject`
    but we still need some level of flexibility. Generics are the solution to our
    problem. We can make this function generic and robust using generics. Let''s examine
    the following example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望那么灵活。我们不希望使用 `Any` 和 `AnyObject`，但我们仍然需要一定程度的灵活性。泛型是我们问题的解决方案。我们可以使用泛型使这个函数通用且健壮。让我们先看以下例子：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this example, we replaced `Any` with `T`. It could be anything that is not
    defined already in our code or not a part of SDK. We put this type inside `<>`
    after the function name and before its parameters. Then we use this type in the
    parameter or return type. This way, we tell the compiler that our function accepts
    a generic type. Any type can be passed to this function but both parameters and
    return types have to be of the same type. So, our API user is not going to be
    able to pass `String` and `Int` as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将 `Any` 替换为 `T`。它可以是代码中未定义的任何东西，或者不是 SDK 的一部分。我们在函数名之后和参数之前将此类型放入 `<>`
    中。然后我们在参数或返回类型中使用此类型。这样，我们告诉编译器我们的函数接受一个泛型类型。任何类型都可以传递给此函数，但参数和返回类型都必须是同一类型。因此，我们的
    API 用户将无法像以下这样传递 `String` 和 `Int`：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The compiler will complain about the type mismatch. This way, our code is type-safe
    and flexible so that we can use it for different types without worrying about
    type mismatching problems.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会抱怨类型不匹配。这样，我们的代码是类型安全的且灵活的，因此我们可以用于不同类型而不用担心类型不匹配问题。
- en: Generics are great tools in functional programming because with them, we are
    able to develop powerful, multipurpose, and generic functions. Let's examine a
    functional example of generics usage.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型是函数式编程中的伟大工具，因为有了它们，我们能够开发出强大、多用途和通用的函数。让我们考察一个泛型使用的函数式示例。
- en: In [Chapter 2](ch02.html "Chapter 2. Functions and Closures") , *Functions and
    Closures*, we had an example such as the following one.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 2 章](ch02.html "第 2 章。函数和闭包") 中，*函数和闭包*，我们有一个如下示例。
- en: 'Suppose that we need to develop a function that adds two `Int` values, as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要开发一个函数来添加两个 `Int` 值，如下所示：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Also, we need to develop a function to calculate the square of an `Int` value:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要开发一个函数来计算 `Int` 值的平方：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Suppose that we need to add two squared values:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要添加两个平方值：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: What if we needed to develop functions to multiply, subtract, or divide two
    squared values?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要开发乘法、减法或除法两个平方值的函数怎么办？
- en: 'The answer was using higher-order functions to write a flexible function, as
    follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是使用高阶函数来编写一个灵活的函数，如下所示：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This higher-order function takes two other functions as parameters and uses
    them. We can call it for different scenarios such as the following one:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个高阶函数接受两个其他函数作为参数并使用它们。我们可以为不同的场景调用它，如下所示：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Using higher-order functions made them flexible and more generic but still
    not that generic. These functions work only with `Int` values. Using generics,
    we can make them work with any numerical type. Let''s make our calculate function
    even more generic:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用高阶函数使它们更加灵活和通用，但仍然不是那么通用。这些函数仅与 `Int` 值一起工作。使用泛型，我们可以使它们与任何数值类型一起工作。让我们使我们的
    `calculate` 函数更加通用：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `calculate` function accepts two values of the same type (`T`) and two functions.
    The `funcA` function accepts two values of the `T` type and returns a value of
    the `T` type. The `funcB` function accepts one value of the `T` type and returns
    a value of the same `T` type.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`calculate` 函数接受两个相同类型（`T`）的值和两个函数。`funcA` 函数接受两个 `T` 类型的值并返回一个 `T` 类型的值。`funcB`
    函数接受一个 `T` 类型的值并返回相同类型的 `T` 值。'
- en: We can use the `calculate` function with any type now. For instance, we can
    pass any numeric number and the function will calculate it for that specific type.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 `calculate` 函数处理任何类型。例如，我们可以传递任何数值并让函数为该特定类型计算它。
- en: 'There are two things to notice here. First of all, the same techniques can
    be applied to methods, and secondly, we cannot define `typealiases` with generic
    types directly in pre-Swift 3.0\. Swift 3.0 introduces generic `typealiases` such
    as the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个需要注意的地方。首先，相同的技巧可以应用于方法，其次，在 Swift 3.0 之前，我们无法直接在泛型类型中定义 `typealiases`。Swift
    3.0 引入了如下泛型 `typealiases`：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Type constraints
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型约束
- en: It is great that our function works with any type, but what if our API user
    tries to use the `calculate` function on types that cannot be used in arithmetic
    calculations?
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的函数可以处理任何类型真是太好了，但如果我们 API 用户尝试在无法用于算术计算的类型上使用 `calculate` 函数怎么办？
- en: To mitigate this problem, we can use type constraints. Using type constraints,
    we will be able to enforce the usage of a certain type. Type constraints specify
    that a type parameter must inherit from a specific class or conform to a particular
    protocol or protocol composition. Collections are examples of type constraints
    that we are already familiar with in the Swift programming language. Collections
    are generics in Swift, so we can have arrays of `Int`, `Double`, `String`, and
    so on.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻这个问题，我们可以使用类型约束。使用类型约束，我们将能够强制使用某种类型。类型约束指定类型参数必须继承自特定类或符合特定协议或协议组合。集合是我们已经在
    Swift 编程语言中熟悉的类型约束的例子。集合是 Swift 中的泛型，因此我们可以有 `Int`、`Double`、`String` 等数组的数组。
- en: Unlike Objective-C, where we could have different types in a collection, in
    Swift we need to have the same type that complies to the type constraint. For
    instance, the keys of a `dictionary` must conform to the `Hashable` protocol.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Objective-C 不同，在 Objective-C 中我们可以在集合中使用不同类型，而在 Swift 中我们需要具有符合类型约束的相同类型。例如，`dictionary`
    的键必须符合 `Hashable` 协议。
- en: 'We can specify type constraints with either of the following two syntaxes:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下两种语法中的任何一种来指定类型约束：
- en: '`<T: Class>` or `<T: Protocol>`'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`<T: Class>` 或 `<T: Protocol>`'
- en: 'Let''s go back to our `calculate` example and define a numerical type constraint.
    There are different protocols such as `Hashable` and `Equatable`. However, none
    of these protocols are going to solve our problem. The easiest solution would
    be defining our protocol and extending the types that we want to use by conforming
    to our protocol. This is a generic approach that can be used to solve similar
    problems:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的 `calculate` 示例并定义一个数值类型约束。有如 `Hashable` 和 `Equatable` 这样的不同协议。然而，这些协议中的任何一个都无法解决我们的问题。最简单的解决方案是定义我们的协议并通过符合我们的协议来扩展我们想要使用的类型。这是一个可以用来解决类似问题的通用方法：
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We define a protocol for numeric types with related basic math operators. We
    will require the types that we want to use to conform to our protocol. So we extend
    them as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为数值类型定义了一个包含相关基本数学运算符的协议。我们将要求我们想要使用的类型符合我们的协议。因此，我们按照以下方式扩展它们：
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, we need to define the type constraint in our function as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在我们的函数中定义类型约束，如下所示：
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As a result, we have a function that accepts only numerical types.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有一个只接受数值类型的函数。
- en: 'Let''s test it with a non-numeric type to ensure its correctness:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个非数值类型来测试它，以确保其正确性：
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This code example does not compile because of our type constraint, which can
    be seen in the following screenshot:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码示例由于我们的类型约束无法编译，这可以在以下屏幕截图中看到：
- en: '![Type constraints](img/B05092_05_01_new.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![类型约束](img/B05092_05_01_new.jpg)'
- en: Where clauses
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`where` 子句'
- en: The `where` clauses can be used to define more complex type constraints, for
    instance, to conform to more than one protocol with some constraints.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`where` 子句可以用来定义更复杂类型约束，例如，符合多个协议并带有一些约束。'
- en: We can specify additional requirements on type parameters and their associated
    types by including a `where` clause after the generic parameter list. A `where`
    clause consists of the `where` keyword, followed by a comma-separated list of
    one or more requirements.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在泛型参数列表之后包含一个 `where` 子句来指定类型参数及其关联类型的附加要求。`where` 子句由 `where` 关键字后跟一个逗号分隔的要求列表组成。
- en: 'For instance, we can express the constraints that a generic type `T` inherits
    from a `C` class and conforms to a `V` protocol as `<T where T: C, T: V>`.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，我们可以表达泛型类型 `T` 继承自 `C` 类并符合 `V` 协议的约束，表示为 `<T where T: C, T: V>`。'
- en: 'We can constrain the associated types of type parameters to conform to protocols.
    Let''s consider the following generic parameter clause:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以约束类型参数的关联类型符合协议。让我们考虑以下泛型参数子句：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, it specifies that `Seq` conforms to the `SequenceType` protocol and the
    associated `Seq.Generator.Element` type conforms to the `Equatable` protocol.
    This constraint ensures that each element of the sequence is `Equatable`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，它指定了 `Seq` 符合 `SequenceType` 协议，并且关联的 `Seq.Generator.Element` 类型符合 `Equatable`
    协议。这个约束确保序列中的每个元素都是 `Equatable`。
- en: 'We can also specify that two types should be identical using the `==` operator.
    Let''s consider the following generic parameter clause:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `==` 运算符指定两个类型应该是相同的。让我们考虑以下泛型参数子句：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, it expresses the constraints that `Seq1` and `Seq2` conform to the `SequenceType`
    protocol and the elements of both sequences must be of the same type.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，它表达了 `Seq1` 和 `Seq2` 符合 `SequenceType` 协议，并且两个序列的元素必须是同一类型的约束。
- en: Any type argument substituted for a type parameter must meet all the constraints
    and requirements placed on the type parameter.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 替换为类型参数的任何类型参数都必须满足对类型参数放置的所有约束和要求。
- en: We can overload a generic function or initializer by providing different constraints,
    requirements, or both on the type parameters in the generic parameter clause.
    When we call an overloaded generic function or initializer, the compiler uses
    these constraints to resolve which overloaded function or initializer to invoke.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在泛型参数子句中提供不同的约束、要求或两者来重载泛型函数或初始化器。当我们调用重载的泛型函数或初始化器时，编译器使用这些约束来解决调用哪个重载函数或初始化器。
- en: Generic data structures
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型数据结构
- en: 'In addition to generic functions, Swift empowers us to define our own generic
    types and data structures. In [Chapter 4](ch04.html "Chapter 4. Enumerations and
    Pattern Matching") , *Enumerations and Pattern Matching*, we developed a simple
    tree with enumeration. Let''s make it generic so that it can take different types
    as its leaf and node:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 除了泛型函数之外，Swift 还允许我们定义自己的泛型类型和数据结构。在第 4 章，*枚举和模式匹配*中，我们使用枚举开发了一个简单的树。让我们使其泛型化，以便它可以接受不同的类型作为其叶子和节点：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With generics, our tree, which could accept only `Int` as a leaf, became a generic
    tree that can accept any type.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用泛型后，我们的树从只能接受 `Int` 作为叶子的树变成了可以接受任何类型的泛型树。
- en: Using generics, it is possible to develop simple and generic types or data structures
    such as graphs, linked lists, stacks, and queues.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用泛型，可以开发简单且通用的类型或数据结构，例如图、链表、栈和队列。
- en: Let's examine a queue data structure example by making a `struct` generic. Queue
    is a well-known data structure in computer science that provides a mean to store
    items in the **First In First Out** (**FIFO**) order. A generic queue will be
    able to store any type in the FIFO order. The following example is not a complete
    implementation of a queue but it gives an idea about how generics can help develop
    generic data structures. Also, it is not a functional data structure as it has
    mutable variables and functions. In Chapter 8, *Functional Data Structures*, we
    will explore the functional data structure in detail.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个泛型 `struct` 来检查一个队列数据结构的示例。队列是计算机科学中一个众所周知的数据结构，它提供了一种按 **先进先出**（**FIFO**）顺序存储项的方法。一个泛型队列将能够按
    FIFO 顺序存储任何类型。以下示例并不是一个完整的队列实现，但它给出了泛型如何帮助开发泛型数据结构的一些想法。此外，它不是一个函数式数据结构，因为它有可变变量和函数。在第
    8 章，*函数式数据结构*中，我们将详细探讨函数式数据结构。
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Associated type protocols
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关联类型协议
- en: 'So far we were able to make functions, methods, and types generic. Can we make
    protocols generic too? The answer is no, we cannot, but protocols support a similar
    feature named associated types. Associated types give placeholder names or aliases
    to types that are used as part of the protocol. The actual type to use for an
    associated type is not specified until the protocol is adopted. Associated types
    are specified with the `associatedtype` keyword. Let''s examine an example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们能够使函数、方法和类型泛型化。我们能否使协议泛型化呢？答案是，我们不能，但是协议支持一个名为关联类型的类似功能。关联类型为用作协议一部分的类型提供占位符名称或别名。实际用于关联类型的类型直到协议采用时才指定。关联类型使用
    `associatedtype` 关键字指定。让我们通过一个示例来检查：
- en: '[PRE21]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This protocol defines an `append` function that takes any item of the `ItemType`
    type. This protocol does not specify how the items in the container should be
    stored or what type they should be. The protocol only specifies an `append` function
    that any type must provide in order to be considered a `Container`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此协议定义了一个 `append` 函数，该函数接受 `ItemType` 类型的任何项。此协议没有指定容器中项的存储方式或它们的类型。该协议仅指定了一个任何类型都必须提供的
    `append` 函数，以便被认为是 `Container`。
- en: Any type that conforms to the `Container` protocol should be able to specify
    the type of values that it stores. Specifically, it must ensure that only items
    of the right type are added to the container.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 任何符合 `Container` 协议的类型都应该能够指定它存储的值的类型。具体来说，它必须确保只有正确类型的项被添加到容器中。
- en: To define these requirements, the `Container` protocol requires a placeholder
    to refer to the type of elements that a container will contain, without knowing
    what that type is for a specific container. The `Container` protocol needs to
    specify that any value passed to the `append` method must have the same type as
    the container's element type.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定义这些要求，`Container`协议需要一个占位符来引用容器将包含的元素类型，而不需要知道对于特定容器这个类型是什么。`Container`协议需要指定传递给`append`方法的任何值必须与容器的元素类型相同。
- en: To achieve this, the `Container` protocol declares an associated type called
    `ItemType`, written as `associatedtype ItemType`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，`Container`协议声明了一个名为`ItemType`的相关类型，写作`associatedtype ItemType`。
- en: The protocol does not define what `ItemType` is an `associatedtype` for, and
    this information is left for any conforming type to provide. Nonetheless, `ItemType`
    `associatedtype` provides you with a way to refer to the type of the items in
    a `Container` and define a type to use with `append`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 协议没有定义`ItemType`作为`associatedtype`的类型是什么，并且这个信息留给了任何遵守的类型去提供。尽管如此，`ItemType`
    `associatedtype`为你提供了一种方式来引用`Container`中项的类型，并定义一个用于`append`的类型。
- en: 'The following example shows how we will conform to a protocol with an associated
    type:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了我们将如何遵守一个带有相关类型的协议：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we define a new `struct` that conforms to the `Container` protocol and
    takes `Int` as `ItemType`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个新的`struct`，它遵守`Container`协议并使用`Int`作为`ItemType`。
- en: Extending generic types
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展泛型类型
- en: 'In Swift, it is possible to extend a generic type. For instance, we can extend
    our `Queue` example `struct` and add new behaviors to it:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，可以对泛型类型进行扩展。例如，我们可以扩展我们的`Queue`示例`struct`并为其添加新的行为：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As seen in this example, we were able to use the generic `Element` type in the
    extension.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如此例所示，我们能够在扩展中使用通用的`Element`类型。
- en: Subclassing generic classes
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型类的子类化
- en: 'In Swift, it is possible to subclass a generic class. Suppose that we have
    a generic `Container` class. There are two different ways to subclass it. In our
    first example, `GenericContainer` subclasses the `Container` class and stays as
    a generic class. In our second example, `SpecificContainer` subclasses `Container`
    and becomes a `Container` of `Int`, therefore, it is not generic anymore:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，可以对泛型类进行子类化。假设我们有一个泛型`Container`类。有两种不同的方式可以对其子类化。在我们的第一个例子中，`GenericContainer`子类化`Container`类并保持为泛型类。在我们的第二个例子中，`SpecificContainer`子类化`Container`并成为`Int`的`Container`，因此它不再泛型：
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Summary
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we understood how to define and use generics. We also understood
    what type of problems generics solve. Then we explored type constraints, generic
    data structures, and associated type protocols with examples. Generics are great
    tools that, when accustomed to, make our code more flexible, useful, and robust,
    so we will use them a lot in the rest of our book.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了如何定义和使用泛型。我们还了解了泛型解决的问题类型。然后我们通过示例探讨了类型约束、泛型数据结构和相关类型协议。泛型是伟大的工具，一旦习惯使用，可以使我们的代码更加灵活、有用和健壮，因此我们将在本书的其余部分大量使用它们。
- en: In the following chapter, we will be introduced to some category theory concepts
    such as functors, applicative functors, and monads. We will also explore higher-order
    functions such as map, filter, and reduce.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍一些范畴论概念，例如函子、应用函子和单子。我们还将探索高阶函数，如`map`、`filter`和`reduce`。
