- en: Implementing Tetris Logic and Functionality
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现俄罗斯方块逻辑和功能
- en: 'In the previous chapter, we embarked on the development of the classic game
    *Tetris*. We determined the layout requirements of our application and implemented
    the layout elements we identified. In the process, we created two activities for
    the application: `MainActivity` and `GameActivity`. We also implemented the basic
    characteristics and behaviors of the views, but nothing pertaining to the core
    gameplay of the app was done. In this chapter, we are going to implement this
    gameplay. Over the course of this chapter, you will learn about the following
    topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们开始了经典游戏*俄罗斯方块*的开发。我们确定了应用程序的布局要求并实现了我们确定的布局元素。在这个过程中，我们为应用程序创建了两个活动：`MainActivity`和`GameActivity`。我们还实现了视图的基本特性和行为，但没有任何关于应用程序核心游戏玩法的内容。在本章中，我们将实现这个游戏玩法。在本章的进程中，你将了解以下主题：
- en: Exception handling
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常处理
- en: The Model-View-Presenter pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型-视图-表示器模式
- en: Implementing the Tetris gameplay
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现俄罗斯方块游戏玩法
- en: 'As we are concerned with implementing gameplay, the activity that we will focus
    on developing further in this chapter is `GameActivity`. The following screenshot
    shows the final product of all the development done in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们关注实现游戏玩法，在本章中我们将进一步开发的活动是`GameActivity`。以下截图显示了本章所有开发工作的最终产品：
- en: '![](img/e6aba391-1b5b-4a5f-afb3-2d658b51b417.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e6aba391-1b5b-4a5f-afb3-2d658b51b417.jpg)'
- en: Now that we have an idea of what the final game is going to look like, let's
    get going with its development.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经对最终游戏的外观有了概念，让我们开始其开发。
- en: Under the section *Understanding Tetris* in [Chapter 2](kt-prog-ex_ch02.html), *Building
    an Android Application – Tetris* we got to understand that Tetris is a puzzle-matching
    game that makes use of tiles. These tiles combine to form bigger shapes called
    tetrominoes. As a reminder, a tetromino is a geometric shape composed of four
    squares connected orthogonally.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](kt-prog-ex_ch02.html)的*理解俄罗斯方块*部分，我们在*构建Android应用程序 - 俄罗斯方块*中了解到，俄罗斯方块是一种使用瓦片的拼图匹配游戏。这些瓦片组合成更大的形状，称为四元形。作为提醒，四元形是由四个正交连接的正方形组成的几何形状。
- en: Modeling a tetromino
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟四元形
- en: As tetrominoes are very crucial to the gameplay of Tetris, we must properly
    model these elements programmatically. In order to do this, let's think of every
    tetromino piece as a building block. Building blocks have a set of features that
    they possess. These features can be categorized into characteristics and behaviors.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 由于四元形对于俄罗斯方块的游戏玩法至关重要，我们必须正确地通过编程来模拟这些元素。为了做到这一点，让我们将每个四元形单元视为一个构建块。构建块具有它们所拥有的特征。这些特征可以分为特性和行为。
- en: Characteristics of a block
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 块的特性
- en: 'The following are some characteristics that a block possesses:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些方块所具有的特性：
- en: '**Shape**: A block has a fixed shape that cannot be changed.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**形状**：一个方块具有固定的形状，不能改变。'
- en: '**Dimensions**: A block possesses dimensional characteristics. These characteristics
    are height and width.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**尺寸**：一个方块具有尺寸特性。这些特性是高度和宽度。'
- en: '**Color**: A block always possesses a color. The color a block possesses is
    fixed and is maintained throughout the course of its existence.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**颜色**：一个方块始终具有一种颜色。方块所具有的颜色是固定的，并且在其存在的过程中保持不变。'
- en: '**Spatial characteristic**: A block takes up a fixed amount of space.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**空间特性**：一个方块占据固定量的空间。'
- en: '**Positional characteristic**: At any given point in time, a block has a position
    that exists in along two axes, – *X* and *Y*.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位置特性**：在任何给定的时间点，一个方块在两个轴上都有一个位置，即*X*轴和*Y*轴。'
- en: Behaviors of a block
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 块的行为
- en: The main behavior of a block is its ability to experience distinct motions.
    These motions are translational motion and rotational motion. Translational motion
    is a type of motion in which a body shifts from one point in space to another.
    In Tetris, a block can experience leftward, rightward, and downward translational
    motions. Rotational motion is a type of motion that exists in rigid bodies and
    follows a curved path. In other words, rotational motion involves the rotation
    of an object in free space. All blocks in Tetris can be rotated.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 块的主要行为是其体验不同运动的能力。这些运动包括平移运动和旋转运动。平移运动是一种运动，其中物体从一个空间点移动到另一个空间点。在俄罗斯方块游戏中，一个方块可以体验到向左、向右和向下的平移运动。旋转运动是一种存在于刚体中并遵循曲线路径的运动。换句话说，旋转运动涉及物体在自由空间中的旋转。俄罗斯方块中的所有方块都可以旋转。
- en: 'Now that we understand the basic characteristics and behaviors of a block,
    you may be wondering how we can translate them to be relevant to tetrominoes.
    The truth is no translation of these characteristic features is necessary. All
    characteristics of a block apply to a tetromino. The only two things to keep in
    mind are:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了方块的基本特性和行为，你可能想知道我们如何将它们转化为与四联体相关的内容。事实是，对这些特征特征的转换并不必要。方块的所有特性都适用于四联体。需要注意的是只有两件事：
- en: Tetrominoes are made up of four tiles
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 四联体由四个方块组成
- en: All tiles in a tetromino are orthogonally arranged
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 四联体中的所有方块都是正交排列的
- en: Having said that, let's get to translating these characteristics into programmatic
    models. We will start with modeling shape.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们将这些特性转化为程序模型。我们将从建模形状开始。
- en: Modeling block shape
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建模方块形状
- en: 'The approach used to modeling shape varies depending on numerous variables,
    such as the kind of shape that must be measured and in what spacial dimension
    the shape is to be modeled. Modeling three-dimensional shapes—all things being
    equal—is more difficult than modeling two-dimensional shapes. Lucky for us, tetrominoes
    are two-dimensional in nature. Before we start modeling our shapes programmatically,
    it is important we know the exact shapes we are attempting to model. There are
    seven fundamental tetromino pieces that exist in Tetris. These pieces are the
    O, I, T, L, J, S and Z tetrominos. The following image shows the fundamental tetromino
    shapes that exist in Tetris:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 用于建模形状的方法取决于许多变量，例如必须测量的形状类型以及形状要建模的空间维度。在所有条件相同的情况下，建模三维形状比建模二维形状更困难。幸运的是，四联体在本质上来说是二维的。在我们开始以编程方式建模形状之前，了解我们试图建模的确切形状是非常重要的。俄罗斯方块中有七个基本的四联体方块。这些方块是O、I、T、L、J、S和Z四联体。以下图片显示了俄罗斯方块中存在的四联体基本形状：
- en: '![](img/6c708a0f-28ff-409d-afa6-0cb42c2882e2.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6c708a0f-28ff-409d-afa6-0cb42c2882e2.jpg)'
- en: All preceding shapes take up space within the confines of their edges. The area
    of space covered by a shape can be seen as an outline or a frame. This is similar
    to how a picture is held within a frame. We need to model this frame that will
    contain individual shapes. As the shapes being held within the frame are two-dimensional
    in nature, we will utilize a two-dimensional byte array to hold frame-specific
    information. A byte is a digital unit of information that generally consists of
    eight bits. A bit is a binary digit. It is the smallest unit of data in a computer
    and has a value of either 1 or 0.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的先前形状都在其边缘范围内占据空间。形状覆盖的空间区域可以看作是一个轮廓或框架。这与图片被框架所包含的方式相似。我们需要建模这个将包含单个形状的框架。由于框架内持有的形状在本质上来说是二维的，我们将利用一个二维字节数组来保存框架特定的信息。字节是信息的一个数字单位，通常由八个比特组成。比特是二进制数字。它是计算机中最小的数据单位，其值为1或0。
- en: 'The idea is to model the frame of a shape with a two-dimensional array by representing
    areas covered by the frame with a byte value of 1 and those not covered by it
    with a value of 0. Take the following frame, for example:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是通过用二维数组表示框架覆盖的区域，用字节的值为1表示，而用字节的值为0表示未被覆盖的区域来建模形状的框架。以下框架为例：
- en: '![](img/72cbf058-414b-432d-ae4c-4c861b69d2aa.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/72cbf058-414b-432d-ae4c-4c861b69d2aa.jpg)'
- en: 'Instead of visualizing it as a whole shape, we can visualize it as a two-dimensional
    array of bytes possessing two rows and three columns:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其视为一个整体形状，也可以将其视为一个具有两行三列的字节二维数组：
- en: '![](img/cf833d5a-b988-4f3e-985e-eb02c07a211c.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cf833d5a-b988-4f3e-985e-eb02c07a211c.jpg)'
- en: 'A byte value of 1 is assigned to cells in the array that make up the frame''s
    shape. On the other hand, a byte value of 0 is assigned to cells that are not
    part of the frame''s shape. Modeling this with a class is fairly easy. Firstly,
    we will need a function that generates the required byte array structure we will
    use for storing frame bytes. Create a new package within your source package and
    give it the name `helpers`. Within this package, create a `HelperFunctions.kt` file.
    This file will contain all helper functions used in the course of the development
    of this app. Open `HelperFunctions.kt` and type the following code into the file:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 将字节的值为1分配给组成框架形状的数组中的单元格。另一方面，将字节的值为0分配给不是框架形状一部分的单元格。用类来建模这一点相当简单。首先，我们需要一个函数来生成我们将用于存储框架字节的所需字节数组结构。在你的源包内创建一个新的包，并将其命名为`helpers`。在这个包内创建一个`HelperFunctions.kt`文件。这个文件将包含在开发此应用过程中使用的所有辅助函数。打开`HelperFunctions.kt`并在文件中输入以下代码：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding code defines a `array2dOfByte()` function, which takes two arguments.
    The first argument is the desired row number of the array to be generated and
    the second is the desired column number of the generated byte array. The `array2dOFByte()` method
    generates and returns a new array with the specified properties. Now that we have
    our byte array generating helper function set up, let''s go ahead and create the
    `Frame` class. Create a new package within your source package and give it the
    name `models`. All object models will be packaged within this created package.
    Within the `models` package, create a `Frame` class in the `Frame.kt` file and
    type the following code into the file:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码定义了一个 `array2dOfByte()` 函数，它接受两个参数。第一个参数是要生成的数组的期望行数，第二个参数是要生成的字节数组的期望列数。`array2dOFByte()`
    方法生成并返回一个具有指定属性的新数组。现在我们已经设置了我们的字节数组生成辅助函数，让我们继续创建 `Frame` 类。在您的源包中创建一个新的包，并将其命名为
    `models`。所有对象模型都将包含在这个创建的包中。在 `models` 包中，在 `Frame.kt` 文件中创建一个 `Frame` 类，并将以下代码输入到文件中：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `Frame` class has two properties: `width` and `data`. Width is an integer
    property that holds the desired width of the frame to be generated (the number
    of columns in the frame''s byte array). The data property holds an array list
    of elements in the `ByteArray` value space. We declare two distinct functions,
    `addRow()` and `get()`. `addRow()` takes a string, converts each individual character
    of the string into a byte representation, and adds the byte representation into
    a byte array, after which it adds the byte array to the data list. `get()` converts
    the data array list into a byte array and returns the array.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`Frame` 类有两个属性：`width` 和 `data`。宽度是一个整数属性，用于保存要生成的框架的期望宽度（框架字节数组的列数）。`data`
    属性保存了一个元素在 `ByteArray` 值空间中的数组列表。我们声明了两个不同的函数，`addRow()` 和 `get()`。`addRow()`
    接受一个字符串，将字符串的每个单独字符转换为字节表示，然后将字节表示添加到字节数组中，之后将字节数组添加到数据列表中。`get()` 将数据数组列表转换为字节数组并返回该数组。'
- en: 'Having modeled a suitable frame to hold our block, we can go ahead and model
    the distinct shapes of possible tetrominoes in the game. In order to do this,
    we will make use of an `enum` class.  Create a `Shape.kt` file in the models package
    before proceeding. We will start by modeling the following simple tetromino shape:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在为我们的方块建模了一个合适的框架之后，我们可以继续建模游戏中可能出现的独特四元形的形状。为了做到这一点，我们将使用一个 `enum` 类。在继续之前，在
    `models` 包中创建一个 `Shape.kt` 文件。我们将从建模以下简单的四元形形状开始：
- en: '![](img/18286cf8-7f71-4e2f-9bf2-7288fa033d5b.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/18286cf8-7f71-4e2f-9bf2-7288fa033d5b.jpg)'
- en: 'Applying the concept of envisioning frames as a two-dimensional array of bytes,
    we can envision the frame of the preceding shape as a two-dimensional array of
    bytes with four rows and a single column with each cell filled with the byte value
    of `1`. With this in mind, let''s model the shape. In `Shape.kt`, create a `Shape`
    enum class, as shown in the following code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将框架视为字节的二维数组的概念应用于，我们可以将前一个形状的框架视为一个具有四行和单列的二维字节数组，每个单元格都填充了字节值 `1`。考虑到这一点，让我们建模这个形状。在
    `Shape.kt` 中，创建一个 `Shape` 枚举类，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'An `enum` class is declared by placing the `enum` keyword before the `class`
    keyword. The primary constructor of the preceding `Shape` enum class takes two
    arguments. The first argument is `frameCount`, which is an integer variable that
    specifies the number of possible frames a shape can be in. The second argument
    is `startPosition`, which specifies the intended start position of the shape along
    the *X* axis within the gameplay field. Further down the `enum` class file, a
    `getFrame()` function is declared. There''s a notable difference between this
    function and the functions we have declared until now. `getFrame()` has been declared
    with the abstract keyword. An abstract function possesses no implementation (thus
    no body) and is used to abstract a behavior that must be implemented by an extending
    class. Let''s scrutinize the following lines of code within the `enum` class:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum` 类是通过在 `class` 关键字之前放置 `enum` 关键字来声明的。前一个 `Shape` 枚举类的构造函数主要接受两个参数。第一个参数是
    `frameCount`，它是一个整数变量，用于指定形状可以处于的可能帧的数量。第二个参数是 `startPosition`，它指定了形状在游戏场中沿 *X*
    轴的预期起始位置。在 `enum` 类文件的下文中，声明了一个 `getFrame()` 函数。这个函数与我们之前声明的函数有一个显著的区别。`getFrame()`
    是用抽象关键字声明的。抽象函数没有实现（因此没有主体）并且用于抽象一个必须由扩展类实现的行为。让我们仔细审查 `enum` 类中的以下代码行：'
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding code block, an instance of the `enum` that provides an implementation
    of the declared abstract function is being created. The instance''s identifier
    is `Tetromino`. We passed the integer value `2` as the argument for both the `frameCount`
    and `startPosition` properties of the `Tetromino`''s constructor. In addition,
    `Tetromino` provides an implementation for the `getFrame()` function in its corresponding
    block by overriding the `getFrame()` function declared in `Shape`. Functions are
    overriden with the `override` keyword. The implementation of `getFrame()` in `Tetromino`
    takes a `frameNumber` integer. This frame number determines the frame of `Tetromino`
    that will be returned. You may be asking at this point why `Tetromino` possesses
    more than one frame. This is simply a result of the possibility of rotation of
    a tetromino. The single-column tetromino we previously looked at can be rotated
    either leftwards or rightwards to take the form shown in the following diagram:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，正在创建一个`enum`实例，该实例提供了声明的抽象函数的实现。实例的标识符是`Tetromino`。我们将整数值`2`作为`frameCount`和`startPosition`属性的参数传递给`Tetromino`的构造函数。此外，`Tetromino`通过覆盖在`Shape`中声明的`getFrame()`函数在其对应的块中提供了`getFrame()`函数的实现。函数通过`override`关键字进行覆盖。`Tetromino`中`getFrame()`的实现接受一个`frameNumber`整数。这个框架数决定了将返回的`tetromino`框架。此时你可能想知道为什么`tetromino`具有多个框架。这仅仅是`tetromino`旋转可能性的结果。我们之前看到的单列`tetromino`可以左右旋转，以形成以下图示中的形状：
- en: '![](img/5004bafa-4a1f-4859-9f68-379817672dfe.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5004bafa-4a1f-4859-9f68-379817672dfe.jpg)'
- en: When `frameNumber` passed to `getFrame()` is `0`, `getFrame()` returns a `Frame`
    object that models the frame for the `Tetromino` in its horizontal state, as shown
    earlier. When `frameNumber` is `1`, it returns a frame object modeling the shape
    in its vertical state.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当将`frameNumber`传递给`getFrame()`时，如果`frameNumber`为`0`，`getFrame()`将返回一个`Frame`对象，该对象模拟了`Tetromino`在其水平状态下的框架，如之前所示。当`frameNumber`为`1`时，它返回一个模拟形状在其垂直状态下的框架对象。
- en: In the case that `frameNumber` is neither `0` nor `1`, an `IllegalArgumentException`
    is thrown by the function.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`frameNumber`既不是`0`也不是`1`，函数将抛出`IllegalArgumentException`异常。
- en: It is important to note that along with being an object, `Tetromino` is a constant.
    Generally, `enum` classes are used to create constants. An `enum` class is a perfect
    choice for modeling our tetromino shapes because we have a fixed set of shapes
    that we need to implement.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，`Tetromino`不仅是一个对象，还是一个常量。通常，使用`enum`类来创建常量。`enum`类是模拟我们的`tetromino`形状的完美选择，因为我们需要实现一组固定的形状。
- en: 'Having understood how the `Shape` enum class works, we can model the rest of
    the possible tetromino shapes as shown in the following code block:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解了`Shape`枚举类的工作原理之后，我们可以根据以下代码块模拟其他可能的`tetromino`形状：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Let's create a tetromino shape with one frame and a start position of 1\. The
    tetromino modeled here is the square or 'O' shaped tetromino.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个具有一个框架和起始位置为1的`tetromino`形状。这里模拟的`tetromino`是正方形或'O'形状的`tetromino`。
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let's create a tetromino shape with two frames and a start position of 1\. The
    tetromino modeled here is the 'Z' shaped tetromino.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个具有两个框架和起始位置为1的`tetromino`形状。这里模拟的`tetromino`是'Z'形状的`tetromino`。
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let's create a tetromino shape with two frames and a start position of `1`.
    The tetromino modeled here is the 'S' shaped tetromino.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个具有两个框架和起始位置为`1`的`tetromino`形状。这里模拟的`tetromino`是'S'形状的`tetromino`。
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let's create a tetromino shape with two frames and a start position of 2\. The
    tetromino modeled here is the 'I' shaped tetromino.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个具有两个框架和起始位置为2的`tetromino`形状。这里模拟的`tetromino`是'I'形状的`tetromino`。
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Let's create a tetromino shape with four frames and a start position of 1\.
    The tetromino modeled here is the 'T' shaped tetromino.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个具有四个框架和起始位置为1的`tetromino`形状。这里模拟的`tetromino`是'T'形状的`tetromino`。
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Let's create a tetromino shape with four frames and a start position of 1. The
    tetromino modeled here is the 'J' shaped tetromino.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个具有四个框架和起始位置为1的`tetromino`形状。这里模拟的`tetromino`是'J'形状的`tetromino`。
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Let's create a tetromino shape with four frames and a start position of 1\.
    The tetromino modeled here is the 'L' shaped tetromino.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个具有四个框架和起始位置为1的`tetromino`形状。这里模拟的`tetromino`是'L'形状的`tetromino`。
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Having modeled both the block frame and shape, the next thing we must model
    programmatically is the block itself. We will use this as an opportunity to demonstrate
    Kotlin''s seamless interoperability with Java by implementing the model with Java.
    Create a new Java class in the `models` directory (models | New | Java Class)
    with the name `Block`. We will start the modeling process by adding instance variables
    that represent the characteristics of a block. Consider the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在对块框架和形状建模之后，下一步我们必须通过编程方式对块本身进行建模。我们将利用这个机会通过使用Java实现模型来展示Kotlin与Java的无缝互操作性。在`models`目录中（models
    | New | Java Class）创建一个新的Java类，命名为`Block`。我们将通过添加代表块特征的实例变量来开始建模过程。考虑以下代码：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the preceding code block, we add four instance variables: `shapeIndex`,
    `frameNumber`, `color`, and `position`. `shapeIndex` will hold the index of the
    shape of the block, `frameNumber` will keep track of the number of frames the
    block''s shape has, `color` will hold the color characteristic of the block, and
    `position` will be used to keep track of the block''s current spatial position
    in the gaming field.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们添加了四个实例变量：`shapeIndex`、`frameNumber`、`color`和`position`。`shapeIndex`将保存块形状的索引，`frameNumber`将跟踪块形状的帧数，`color`将保存块的颜色特征，而`position`将用于跟踪块在游戏场中的当前空间位置。
- en: An `enum` template, `BlockColor`, is added within the `Block` class. This `enum`
    creates a constant set of `BlockColor` instances, with each possessing `rgbValue`
    and `byteValue` properties. `rgbValue` is an integer that uniquely identifies
    an RGB color specified with the `Color.rgb()` method. `Color` is a class provided
    by the Android application framework and `rgb()` is a class method defined within
    the `Color` class. The five `Colour.rgb()` calls specify the colors pink, green,
    orange, yellow, and cyan, respectively.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Block`类中添加了一个`enum`模板，名为`BlockColor`。这个`enum`创建了一个`BlockColor`实例的常量集合，每个实例都拥有`rgbValue`和`byteValue`属性。`rgbValue`是一个整数，用于唯一标识使用`Color.rgb()`方法指定的RGB颜色。`Color`是由Android应用程序框架提供的一个类，`rgb()`是定义在`Color`类中的一个类方法。五个`Colour.rgb()`调用分别指定了粉红色、绿色、橙色、黄色和青色。
- en: In `Block`, we made use of the `private` and `public` keywords. These were not
    added for eye candy; they each have a use. These two keywords, along with the
    `protected` keyword, are called access modifiers.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Block`类中，我们使用了`private`和`public`关键字。这些关键字并非仅仅为了美观；它们各自都有用途。这两个关键字，连同`protected`关键字，被称为访问修饰符。
- en: 'Access modifiers are keywords used to specify access restrictions on classes,
    methods, functions, variables, and structures. Java has three access modifiers:
    `private`, `public`, and `protected`. In Kotlin, access modifiers are called visibility
    modifiers. The available visibility modifiers in Kotlin are `public`, `protected`,
    `private`, and `internal`.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 访问修饰符是用于指定类、方法、函数、变量和结构访问限制的关键字。Java有三种访问修饰符：`private`、`public`和`protected`。在Kotlin中，访问修饰符被称为可见性修饰符。Kotlin中可用的可见性修饰符有`public`、`protected`、`private`和`internal`。
- en: Private access modifier (private)
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 私有访问修饰符（private）
- en: 'Methods, variables, constructors, and structures that are declared private
    can only be accessed within the declaring class. This is with the exception of
    private top-level functions and properties that are visible to all members of
    the same file. Private variables within a class can be accessed from outside the
    class be declaring getter and setter methods that permit access. Defining setter
    and getter methods in Java is shown in the following code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 声明为私有的方法、变量、构造函数和结构只能在声明类内部访问。这有一个例外，即私有顶层函数和属性对所有同一文件成员都是可见的。类内部的私有变量可以通过声明允许访问的getter和setter方法从类外部访问。以下代码展示了在Java中定义setter和getter方法：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In Kotlin, setter and getter creation is as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，setter和getter的创建方式如下：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Using the private access modifier is the main means of information hiding within
    programs. Information hiding is also known as encapsulation.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用私有访问修饰符是程序中信息隐藏的主要手段。信息隐藏也称为封装。
- en: Public access modifier (public)
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 公共访问修饰符（public）
- en: 'Methods, variables, constructors, and structures declared public can be accessed
    freely from outside the declaring class. A public class existing in a different
    package from an accessing class must be imported before it can be used. The following
    class makes use of the public access modifier:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 声明为公共的方法、变量、构造函数和结构可以在声明类的外部自由访问。存在于访问类不同包中的公共类在使用之前必须导入。以下类使用了公共访问修饰符：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Protected access modifier (protected)
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 受保护的访问修饰符（protected）
- en: 'Variables, methods, functions, and structures declared protected can be accessed
    only by classes in the same package as the defining class or by subclasses of
    their defining class that exist in a separate package:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 声明为受保护的变量、方法、函数和结构只能由与定义类在同一包中的类或存在于单独包中的定义类的子类访问：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Internal visibility modifier (internal)
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内部可见性修饰符（internal）
- en: 'The internal visibility modifier is used to declare a member visible within
    the same module. A module is a collection of Kotlin files compiled together. 
    A module may be a Maven project, a Gradle source set, and IntelliJ IDEA module,
    or a set of files compiled with an Ant task invocation. Using the internal modifier
    is similar to using other visibility modifiers:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 内部可见性修饰符用于声明一个成员在同一模块内可见。模块是一组编译在一起的 Kotlin 文件。模块可能是一个 Maven 项目、一个 Gradle 源集、一个
    IntelliJ IDEA 模块，或者是一组使用 Ant 任务调用编译的文件集。使用内部修饰符与使用其他可见性修饰符类似：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Having understood access and visibility modifiers, we can continue with the
    implementation of the `Block` class. The next thing we need to do is create a
    constructor for the class that initializes the instance variables we have created
    to their initial states. Constructor definitions in Java are syntactically different
    from Kotlin constructor definitions:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解了访问和可见性修饰符之后，我们可以继续 `Block` 类的实现。接下来我们需要做的是为类创建一个构造函数，该构造函数将初始化我们创建的实例变量到其初始状态。Java
    中的构造函数定义在语法上与 Kotlin 构造函数定义不同：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s see the constructor definition:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看构造函数的定义：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Notice that the preceding constructor definition has been given private access.
    We did this because we do not want this constructor to be accessed outside of `Block`.
    As we still want other classes to have a means of creating a block instance, we
    have to define a static method that permits this. We will call this method `createBlock`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到前面的构造函数定义已被赋予私有访问权限。我们这样做是因为我们不希望这个构造函数在 `Block` 之外被访问。由于我们仍然希望其他类有创建块实例的手段，我们必须定义一个允许这样做的方法。我们将把这个方法命名为
    `createBlock`：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s see the Constructor definition:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看构造函数的定义：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`createBlock()` randomly selects the index of a tetromino shape in the `Shape`
    enum class and a `BlockColor` and assigns two randomly selected values to `shapeIndex`
    and `blockColor`. A new `Block` instance is created with the two values passed
    as arguments and the position of the block along the *X* axis is set. Lastly,
    `createBlock()` returns the created and initialized block.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`createBlock()` 随机选择 `Shape` 枚举类中一个四联体形状的索引以及一个 `BlockColor`，并将两个随机选择的值分配给
    `shapeIndex` 和 `blockColor`。使用这两个值作为参数创建一个新的 `Block` 实例，并设置块沿 *X* 轴的位置。最后，`createBlock()`
    返回创建并初始化的块。'
- en: 'We need to add a few getter and setter methods to `Block`. These methods will
    give access to crucial properties of instances of the block. Add the following
    methods to the `Block` class:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要向 `Block` 添加一些获取器和设置器方法。这些方法将提供对块实例关键属性的访问。将以下方法添加到 `Block` 类中：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`@NonNull` is an annotation provided by the Android application framework that
    denotes that a field, parameter, or method return can never be null. In the preceding
    code snippet, it is used in the line prior to the `getShape()` method definition
    to denote that the method cannot return a null value.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`@NonNull` 是 Android 应用程序框架提供的一个注解，表示一个字段、参数或方法返回值永远不会为 null。在上面的代码片段中，它在 `getShape()`
    方法定义之前的行中使用，表示该方法不能返回 null 值。'
- en: In Java, an annotation is a form of metadata that can be added to Java source
    code. Annotations can be used on classes, methods, variables, parameters, and
    packages. Annotations can also be declared and used in Kotlin.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，注解是一种可以添加到 Java 源代码的元数据形式。注解可以用于类、方法、变量、参数和包。注解也可以在 Kotlin 中声明和使用。
- en: 'The `@NotNull` annotation exists in the `android.support.annotation` package.
    Add the package import to the package imports at the top of `Block.java`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`@NotNull` 注解存在于 `android.support.annotation` 包中。将包导入添加到 `Block.java` 顶部的包导入中：'
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'There''s one last thing we should take care of in the `Block` class before
    moving on. In the final line of the `Block` constructor, the position of the current
    block instance''s position instance variable is set as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续前进之前，我们应在 `Block` 类中注意最后一件事。在 `Block` 构造函数的最后一行，当前块实例的位置实例变量被设置为以下内容：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `10` is the column count of the field in which the tetrominoes will be
    generated. This is a constant value that will be used several times within the
    code for this application, and as such, is best declared as a constant. Create
    a package named constants in the base application source package and add a new
    Kotlin file with the name `FieldConstants` to the package. Next, add constants
    for the number of columns and rows that the playing field will possess. The field
    should possess ten columns and twenty rows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`10` 是将要生成俄罗斯方块的场地的列数。这是一个将在代码中多次使用的常量值，因此最好将其声明为常量。在基础应用程序源包中创建一个名为 `constants`
    的包，并向该包中添加一个名为 `FieldConstants` 的新 Kotlin 文件。接下来，添加表示游戏场地将拥有的列数和行数的常量。场地应该有十列和二十行：'
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Import the package with the `FieldConstants` enum class into `Block.java` and
    replace the `10` integer with the constant value of the `COLUMN_COUNT`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 将带有 `FieldConstants` 枚举类的包导入 `Block.java`，并将 `10` 整数替换为 `COLUMN_COUNT` 的常量值：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: That's it! We are done with the programmatic modeling of the `Block` class.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们已经完成了 `Block` 类的程序化建模。
- en: Creating the application model
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建应用程序模型
- en: Until now, we have been concerned with modeling specific components that make
    up tetromino blocks. Now it is time to concern ourselves with defining application
    logic. We will create an application model to implement the necessary Tetris gameplay
    logic, as well as to serve as an intermediary interface between views and the
    block components we have created.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直关注于建模组成俄罗斯方块块的特定组件。现在是我们关注定义应用程序逻辑的时候了。我们将创建一个应用程序模型来实现必要的俄罗斯方块游戏逻辑，并作为视图和我们所创建的方块组件之间的中介接口。
- en: '![](img/9ec55ffe-9589-494a-8b13-8f99d41bd288.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9ec55ffe-9589-494a-8b13-8f99d41bd288.jpg)'
- en: 'A view will send a request for the performance to the application model, and
    the model will execute the action if it is valid and send feedback to the view.
    Similar to the models we have created so far, we need a separate class file for
    the application model. Go ahead and create a new Kotlin file named `AppModel.kt`
    and add a class named `AppModel` to the file with imports for `Point`, `FieldConstants`,
    `array2dOfByte`, and `AppPreferences`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 视图将向应用程序模型发送性能请求，如果操作有效，模型将执行操作并向视图发送反馈。类似于我们迄今为止创建的模型，我们需要为应用程序模型创建一个单独的类文件。继续创建一个名为
    `AppModel.kt` 的新 Kotlin 文件，并在文件中添加一个名为 `AppModel` 的类，包含对 `Point`、`FieldConstants`、`array2dOfByte`
    和 `AppPreferences` 的导入：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Some functions of `AppModel` are to keep track of the current score, the `tetris`
    gameplay field state, the current block, the current state of the game, the current
    status of the game, and the motions being experienced by the current block. `AppModel`
    must also have direct access to values stored within the application's `SharedPreferences`
    file via the `AppPreferences` class we created. Catering to these different demands
    may seem daunting at first, but is easy as pie.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppModel` 的某些功能是跟踪当前分数、俄罗斯方块游戏场地的状态、当前方块、游戏当前状态、游戏当前状态以及当前方块所经历的运动。`AppModel`
    还必须通过我们创建的 `AppPreferences` 类直接访问应用程序的 `SharedPreferences` 文件中的值。满足这些不同的需求可能一开始看起来令人畏惧，但实际上就像做饼一样简单。'
- en: 'The first thing we must do is add the necessary constants that will be utilized
    by `AppModel`. We will need to create constants for the possible game statuses
    and the possible motions that can occur during gameplay. These constants are created
    with ease with the use of `enum` classes:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须做的第一件事是添加 `AppModel` 将要使用的必要常量。我们需要为可能的游戏状态和游戏过程中可能发生的运动创建常量。这些常量可以通过使用
    `enum` 类轻松创建：
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We created four status constants earlier. `AWAITING_START` is the status of
    the game before the game has been started. `ACTIVE` is the status in which the
    game exists when gameplay is currently in progress. `OVER` is the status that
    the game takes when the game ends.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前创建了四个状态常量。`AWAITING_START` 是游戏开始之前游戏的状态。`ACTIVE` 是游戏在进行游戏时存在的状态。`OVER` 是游戏结束时游戏的状态。
- en: Earlier in this chapter, it was stated that four distinct motions can occur
    on a block. Blocks can be moved to the right, to the left, up, down, and rotated.
    `LEFT`, `RIGHT`, `UP`, `DOWN`, and `ROTATE` are defined in the `Motions` enum
    class to represent these distinct motions.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期，提到一个方块上可以发生四种不同的运动。方块可以被移动到右边、左边、向上、向下，以及旋转。`LEFT`、`RIGHT`、`UP`、`DOWN`
    和 `ROTATE` 在 `Motions` 枚举类中被定义为表示这些不同的运动。
- en: 'Having added the constants required, we can proceed by adding the necessary
    class properties of `AppModel`, which are as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了所需的常量后，我们可以继续添加`AppModel`所需的类属性，如下所示：
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`score` is an integer property that will be used to hold the current score
    of the player within a gaming session. `preferences` is a private property that
    will hold an `AppPreferences` object to provide direct access to the application''s
    `SharedPreferences` file. `currentBlock` is a property that will hold the current
    block translating across the play field. `currentState` holds the state of the
    game. `Statuses.AWAITING_START.name` returns the name of `Statuses.AWAITING_START`
    in the form of an `AWAITING_START` string. The current state of the game is initialized
    to `AWAITING_START` immediately because this is the first state that `GameActivity`
    must transition into upon launch. Lastly, `field` is a two-dimensional array that
    will be used as the playing field for the game.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`score`是一个整数属性，将用于在游戏会话中保存玩家的当前分数。`preferences`是一个私有属性，将保存一个`AppPreferences`对象，以提供对应用程序的`SharedPreferences`文件的直接访问。`currentBlock`是一个属性，将保存当前正在游戏场中转换的块。`currentState`保存游戏的状态。`Statuses.AWAITING_START.name`以`AWAITING_START`字符串的形式返回`Statuses.AWAITING_START`的名称。游戏的状态立即初始化为`AWAITING_START`，因为这是`GameActivity`在启动时必须过渡到的第一个状态。最后，`field`是一个二维数组，将用作游戏的比赛场。'
- en: 'Next we must add a few setter and getter functions. These functions are `setPreferences()`,
    `setCellStatus()`, and `getCellStatus()`. Add the following functions to `AppModel`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须添加一些设置器和获取器函数。这些函数是`setPreferences()`、`setCellStatus()`和`getCellStatus()`。将以下函数添加到`AppModel`中：
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `setPreferences()` method sets the preferences property of `AppModel` to
    the `AppPreferences` instance passed as an argument to the function. The `getCellStatus()`
    method returns the status of a cell existing in a specified row-column position
    within the field's two-dimensional array. The `setCellStatus()` method sets the
    status of a cell existing in the field to a specified byte.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`setPreferences()`方法将`AppModel`的偏好属性设置为传递给函数的`AppPreferences`实例。`getCellStatus()`方法返回在字段二维数组中指定行-列位置存在的单元格的状态。`setCellStatus()`方法将字段中存在的单元格的状态设置为指定的字节。'
- en: 'Functions for checking state are necessary in the model as well. These will
    serve as a medium to assert the state that the game is currently in. As we have
    three possible game statuses corresponding to three possible game states, three
    functions are required for each individual game state. These methods are `isGameAwaitingStart()`,
    `isGameActive()`, and `isGameOver()`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在模型中也需要检查状态的函数。这些将作为断言游戏当前状态的媒介。由于有三个可能的游戏状态对应于三个可能的游戏状态，因此每个游戏状态都需要三个函数。这些方法是`isGameAwaitingStart()`、`isGameActive()`和`isGameOver()`：
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: All three methods return Boolean values of either `true` or `false` depending
    on whether the game is existing in their respective states. So far, we have not
    made use of the `score` in `AppModel`. Let's add a function that can be used to
    increase the score value held by the `score`. We will name the function `boostScore()`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三种方法都返回布尔值，要么是`true`要么是`false`，这取决于游戏是否存在于它们各自的状态中。到目前为止，我们还没有在`AppModel`中使用`score`。让我们添加一个可以用来增加`score`所持有的分数值的函数。我们将把这个函数命名为`boostScore()`。
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: When called, `boostScore()` increases the current score of the player by 10
    points, after which it checks whether the current score of the player is greater
    than the high score recorded in the preferences file. If the current score is
    greater than the saved high score, the high score is overwritten with the current
    score.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当被调用时，`boostScore()`将玩家的当前分数增加10分，之后它会检查玩家的当前分数是否大于记录在偏好文件中的高分。如果当前分数高于保存的高分，则高分将被当前分数覆盖。
- en: 'Having gotten the basic functions and fields up and running, we can progress
    to creating slightly more complicated functions. The first of these functions
    is `generateNextBlock()`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本函数和字段运行起来之后，我们可以继续创建稍微复杂一些的函数。这些函数中的第一个是`generateNextBlock()`：
- en: '[PRE33]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `generateNextBlock()` function creates a new block instance and sets `currentBlock`
    to the newly created instance.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`generateNextBlock()`函数创建一个新的块实例，并将`currentBlock`设置为新创建的实例。'
- en: 'Before going any further with method definitions, let''s create one more `enum`
    class to hold constant cell values. Create a `CellConstants.kt` file in the constants
    package and add the following source code to it:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在进一步定义方法之前，让我们创建一个额外的 `enum` 类来存储常量单元格值。在常量包中创建一个 `CellConstants.kt` 文件，并将以下源代码添加到其中：
- en: '[PRE34]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You may be wondering what these constants are for. Recall when we created the
    `Frame` class to model a blocks frame, we defined `addRow()`, which took a string
    of 1s and 0s as its argument—with 1 representing cells that made up the frame
    and 0 representing cells excluded from the frame—and converted these 1s and 0s
    to byte representations. We are going to be manipulating these bytes in upcoming
    functions and we need to have corresponding constants for them.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道这些常量是用来做什么的。回想一下，当我们创建 `Frame` 类来模拟块框架时，我们定义了 `addRow()`，它接受一个由 1 和 0
    组成的字符串作为其参数——其中 1 代表组成框架的单元格，0 代表从框架中排除的单元格——并将这些 1 和 0 转换为字节表示。我们将在未来的函数中操作这些字节，并且我们需要为它们提供相应的常量。
- en: 'Import the newly created `enum` class into `AppModel`. We will make use of
    it in the upcoming function:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 将新创建的 `enum` 类导入到 `AppModel` 中。我们将在即将到来的函数中使用它。
- en: '[PRE35]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Add the preceding `validTranslation()` method to `AppModel`. As the name implies,
    this function is used to check whether a translational motion of a tetromino in
    the playing field is valid based on a set of conditions. It returns a `true` 
    Boolean value if the translation is valid, and `false` otherwise. The first three
    conditionals test whether the position the tetromino is being translated in the
    field to is a valid one. The `else` block checks whether the cells the tetromino
    is attempting to translate into are empty. If they are not, `false` is returned.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的 `validTranslation()` 方法添加到 `AppModel` 中。正如其名称所暗示的，此函数用于根据一组条件检查玩场中四元形的平移运动是否有效。如果平移有效，则返回
    `true` 布尔值，否则返回 `false`。前三个条件检查四元形正在平移到的场中的位置是否有效。`else` 块检查四元形试图平移到的单元格是否为空。如果不为空，则返回
    `false`。
- en: 'We need a calling function for `validTranslation()`. We will declare `moveValid()`
    to serve this purpose. Add the following function to `AppModel`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个用于 `validTranslation()` 的调用函数。我们将声明 `moveValid()` 来完成这个任务。将以下函数添加到 `AppModel`
    中。
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`moveValid()` utilizes `validTranslation()` to check whether a move performed
    by the player is permitted. If the move is permitted, it returns `true`, otherwise `false`
    is returned. We need to create a few other important methods. These are `generateField()`,
    `resetField()`, `persistCellData()`, `assessField()`, `translateBlock()`, `blockAdditionPossible()`,
    `shiftRows()`, `startGame()`, `restartGame()`, `endGame()`, and `resetModel()`.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`moveValid()` 使用 `validTranslation()` 检查玩家执行的运动是否被允许。如果运动被允许，则返回 `true`，否则返回
    `false`。我们需要创建一些其他重要方法。这些方法是 `generateField()`、`resetField()`、`persistCellData()`、`assessField()`、`translateBlock()`、`blockAdditionPossible()`、`shiftRows()`、`startGame()`、`restartGame()`、`endGame()`
    和 `resetModel()`。'
- en: We will firstly work on the `generateField()` method. Add the code shown below
    to `AppModel`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将专注于 `generateField()` 方法。将以下代码添加到 `AppModel` 中。
- en: '[PRE37]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`generateField()` generates a refresh of the field. This field refresh is determined
    by the action that is passed as the argument of `generateField()`.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`generateField()` 生成字段的刷新。这种字段刷新由传递给 `generateField()` 的动作参数确定。'
- en: First, `generateField()` checks whether the game is currently in its active
    state when called. If the game is active, the frame number and coordinates of
    the block are retrieved. The action requested is then determined via the `when` expression.
    Having determined the requested action, the coordinates of the block are changed
    appropriately if the action requested is a leftward, rightward, or downward motion.
    If a rotational motion is requested, `frameNumber` is changed to an appropriate
    number of a frame that represents the tetromino in the rotation exerted.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`generateField()` 检查在调用时游戏是否处于活动状态。如果游戏处于活动状态，则检索框架编号和块的坐标。然后通过 `when` 表达式确定请求的动作。确定了请求的动作后，如果请求的动作是向左、向右或向下移动，则相应地更改块的坐标。如果请求的是旋转运动，则
    `frameNumber` 被更改为表示旋转中四元形的适当帧编号。
- en: The `generateField()` method then checks whether the motion requested is a valid
    motion via `moveValid()`. If the move is not valid, the current block is fixed
    in the field to its current position with the use of `translateBlock()`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`generateField()` 方法通过 `moveValid()` 检查请求的运动是否是有效的运动。如果运动无效，则使用 `translateBlock()`
    将当前块固定在字段中的当前位置。
- en: 'The `resetField()`, `persistCellData()` and `assessField()` methods invoked
    by `generateField()` are given below. Add them to `AppModel`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`resetField()`、`persistCellData()`和`assessField()`方法由`generateField()`调用，如下所示。将它们添加到`AppModel`中：'
- en: '[PRE38]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As you may have noticed, `translateBlock()` has not been implemented. Go ahead
    and add this method along with `blockAdditionPossible()`, `shiftRows()`, `startGame()`,
    `restartGame()`, `endGame()`, and `resetModel()` to `AppModel` is as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经注意到的，`translateBlock()`尚未实现。继续添加此方法以及`blockAdditionPossible()`、`shiftRows()`、`startGame()`、`restartGame()`、`endGame()`和`resetModel()`到`AppModel`中，如下所示：
- en: '[PRE39]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In a scenario where the requested move is a downward motion and the move is
    not valid, it implies that the block has reached the bottom of the field. In this
    case, the player''s score is boosted via `boostScore()` and the states of all
    cells in the field are persisted via `persistCellData()`. The `assessField()` method
    is then called to scan through the field row by row and check whether all cells
    in a row have been filled up:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在请求的移动是向下移动且移动无效的情况下，这意味着方块已经到达了场地的底部。在这种情况下，玩家的分数通过`boostScore()`提升，并且通过`persistCellData()`将场地中所有单元格的状态持久化。然后调用`assessField()`方法逐行扫描场地，检查一行中的所有单元格是否都已填满：
- en: '[PRE40]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the case where all cells in a row are filled up, the row is cleared and
    shifted by `shiftRow()`. After the assessment of the field is complete, a new
    block is generated with `generateNextBlock()`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在一行中的所有单元格都填满的情况下，该行通过`shiftRow()`被清除并移动。在完成场地的评估后，通过`generateNextBlock()`生成一个新的方块：
- en: '[PRE41]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Before the newly generated block can be pushed to the field, `AppModel` makes
    sure that the field is not already filled up and the block can be moved into the
    field with `blockAdditionPossible()`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在新产生的方块可以推入场地之前，`AppModel`确保场地尚未填满，并且可以通过`blockAdditionPossible()`将方块移动到场地中：
- en: '[PRE42]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If block addition is not possible, that means all blocks have been stacked to
    the top edge of the field. This results in a game over. As a result, the current
    state of the game is set to `Statuses.OVER` and the `currentBlock` is set to `null`.
    Lastly, the field is cleared.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果方块添加不可行，这意味着所有方块都已堆叠到场地的顶部边缘。这导致游戏结束。因此，将当前游戏状态设置为`Statuses.OVER`，并将`currentBlock`设置为`null`。最后，清除场地。
- en: On the other hand, if the move was valid from the start, the block is translated
    to its new coordinates via `translateBlock()` and the state of the current block
    is set to its new coordinates and `frameNumber`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果移动从一开始就是有效的，则通过`translateBlock()`将方块转换到新的坐标，并将当前方块的状态设置为新的坐标和`frameNumber`。
- en: With those additions in place, we have been able to successfully create the
    application model to handle the gameplay logic. Now we have to create a view that
    exploits `AppModel`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些添加到位之后，我们已经成功创建了处理游戏逻辑的应用程序模型。现在我们必须创建一个利用`AppModel`的视图。
- en: Creating TetrisView
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建TetrisView
- en: So far, so good. We have successfully implemented classes to model blocks, frames,
    and shapes of different tetrominoes that will be used within the application,
    as well as implemented an `AppModel` class to coordinate all the interactions
    between views and these programmatic components created. Without this view existing,
    there is no means by which a user can interact with `AppModel`. If a user cannot
    interact with the game, the game might as well not exist. In this section, we
    will implement `TetrisView`, the user interface by which a user will play Tetris.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。我们已经成功实现了用于在应用程序中建模不同四元形块的类，以及实现了`AppModel`类来协调视图和这些程序组件之间的所有交互。如果没有这个视图存在，用户就无法与`AppModel`进行交互。如果用户无法与游戏交互，那么游戏几乎可以不存在。在本节中，我们将实现`TetrisView`，这是用户将通过它来玩俄罗斯方块的界面。
- en: Create a package named `view` in your source package and add a `TetrisView.kt`
    file in it. As we want `TestrisView` to be a `View`, we must declare it to extend
    the View class. Add the code below to `TetrisView.kt`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的源包中创建一个名为`view`的包，并在其中添加一个`TetrisView.kt`文件。由于我们希望`TetrisView`是一个`View`，我们必须声明它扩展`View`类。将以下代码添加到`TetrisView.kt`中。
- en: '[PRE43]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `TetrisView` class is declared to extend `View`. `View` is a class that
    all application view elements must extend. As the `View` type has a constructor
    that must be initialized, we are declaring two secondary constructors for `TetrisView`
    that initialize two distinct constructors of the view class, depending on which
    secondary constructor is called.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`TetrisView` 类被声明为扩展 `View`。`View` 是所有应用程序视图元素必须扩展的类。由于 `View` 类型有一个必须初始化的构造函数，我们为
    `TetrisView` 声明两个二级构造函数，以初始化视图类的两个不同的构造函数，具体取决于调用哪个二级构造函数。'
- en: The `paint` property is an instance of `android.graphics.Paint`. The `Paint`
    class holds style and color information concerning how to draw texts, bitmaps,
    and geometries. `lastMove` will be used to keep track of the last time in milliseconds
    that a move was made. The `model` instance will be used to hold an `AppModel`
    instance that will be interacted with by `TetrisView` to control gameplay. Activity
    is an instance of the `GameActivity` class we created. The `cellSize` and `frameOffset`
    are properties that will hold dimensions for the size of cells in the game and
    the frame offset, respectively.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`paint` 属性是 `android.graphics.Paint` 的一个实例。`Paint` 类包含有关如何绘制文本、位图和几何形状的样式和颜色信息。`lastMove`
    将用于跟踪最后一次移动的时间（以毫秒为单位）。`model` 实例将用于保存 `AppModel` 实例，该实例将由 `TetrisView` 交互以控制游戏玩法。`Activity`
    是我们创建的 `GameActivity` 类的一个实例。`cellSize` 和 `frameOffset` 是将分别持有游戏单元格大小和框架偏移量的属性。'
- en: Neither `ViewHandler` nor `Dimension` is a class provided to us by the Android
    application framework. We must implement these two classes.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewHandler` 和 `Dimension` 都不是Android应用程序框架为我们提供的类。我们必须实现这两个类。'
- en: Implementing ViewHandler
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 `ViewHandler`
- en: As blocks will be moving along the fields in intervals with a constant time
    delay, we need a means of putting the thread that handles the movement of blocks
    to sleep and waking the thread to make a block motion after a period of time.
    A good way to take care of this requirement is to use a handler to process message
    delay requests and continue message handling after the delay has completed. Putting
    this in more direct terms, according to Android's documentation, *the handler
    allows you to send and process Message objects associated with a thread's MessageQueue*.
    Every handler instance is associated with a thread and the thread's message queue.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于方块将在间隔固定的时间延迟下沿着字段移动，我们需要一种方法来使处理方块移动的线程休眠，并在一段时间后唤醒线程以使方块移动。满足这一需求的一个好方法是使用处理器来处理消息延迟请求，并在延迟完成后继续消息处理。用更直接的话来说，根据Android的文档，*处理器允许你向线程的消息队列发送和处理与线程相关的消息对象*。每个处理器实例都与一个线程及其消息队列相关联。
- en: '`ViewHandler` is a custom handler we will implement for `TetrisView` that caters
    to the view’s message-sending and processing needs. As `ViewHandler` is subclass
    of `Handler`, we must extend `Handler` and add our necessary behavior to the `ViewHandler`
    class.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewHandler` 是我们将为 `TetrisView` 实现的自定义处理器，以满足视图的消息发送和处理需求。由于 `ViewHandler`
    是 `Handler` 的子类，我们必须扩展 `Handler` 并将必要的操作添加到 `ViewHandler` 类中。'
- en: 'Add the following `VieHandler` class as a private class within `TetrisView`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `TetrisView` 中添加以下 `ViewHandler` 类作为私有类：
- en: '[PRE44]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `ViewHandler` class takes an instance of `TetrisView` as an argument in
    its constructor. `ViewHandler` overrides the `handleMessage()` function existing
    in its superclass class. `handleMessage()` checks that the what message was sent.
    The `what` is an integer value denoting the message sent. If `what` is equal to
    `0`, and the instance—owner—of `TetrisView` passed possesses a model that is not
    equal to `0`, some statuses of the game are checked. If the game is over, it will
    call `endGame()` of `AppModel` function and show a popup alerting the player that
    the game is over. If the game is in its active state, a down motion is fired.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewHandler` 类在其构造函数中接受一个 `TetrisView` 实例作为参数。`ViewHandler` 重写了其超类中存在的 `handleMessage()`
    函数。`handleMessage()` 检查发送了什么消息。`what` 是一个表示发送的消息的整数值。如果 `what` 等于 `0`，并且 `TetrisView`
    的实例（所有者）传递的模型不等于 `0`，则检查一些游戏状态。如果游戏结束，它将调用 `AppModel` 函数的 `endGame()` 并向玩家显示一个弹出警告，告知游戏已结束。如果游戏处于活动状态，则触发一个向下移动。'
- en: The `sleep()` method simply removes any previously sent message and sends a
    new message with a delay specified by the delay argument.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`sleep()` 方法简单地移除之前发送的消息，并使用延迟参数指定的延迟发送一个新的消息。'
- en: Implementing Dimension
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 `Dimension`
- en: '`Dimension` only needs to be able to hold two properties: width and height.
    As such, it is a perfect candidate for the utilization of a data class. Add the
    following private class to the `TetrisView` class:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dimension` 只需要能够持有两个属性：宽度和高度。因此，它是一个使用数据类的完美候选。将以下私有类添加到 `TetrisView` 类中：'
- en: '[PRE45]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The preceding one-liner provides us with the properties, as well as the setter
    and getters we need for them.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的单行代码为我们提供了所需的属性，以及它们的设置器和获取器。
- en: Implementing TetrisView
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 TetrisView
- en: As you may have guessed, at this point `TetrisView` is far from completion.
    First and foremost we must implement a few setter methods for the `model` and
    `activity` properties of the view. These methods are shown below. Make sure to
    add them to your `TetrisView` class.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所猜想的，到目前为止，`TetrisView` 还远未完成。首先，我们必须实现一些用于视图的 `model` 和 `activity` 属性的设置方法。这些方法如下所示。请确保将它们添加到您的
    `TetrisView` 类中。
- en: '[PRE46]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`setModel()` and `setActivity()` are setter functions for the model and activity
    instance properties. As the names imply, `setModel()` sets the current model in
    use by the view and `setActivity()` sets the activity in use. Now, let us add
    three additional methods `setGameCommand()`, `setGameCommandWithDelay()` and `updateScore()`.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`setModel()` 和 `setActivity()` 是模型和活动实例属性的设置函数。正如其名称所暗示的，`setModel()` 设置视图当前使用的模型，而
    `setActivity()` 设置正在使用的活动。现在，让我们添加三个额外的方法 `setGameCommand()`、`setGameCommandWithDelay()`
    和 `updateScore()`。'
- en: '[PRE47]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '`setGameCommand()` sets the current motion command being executed by the game.
    If a `DOWN` motion command is in execution, the application model generates the
    field for a block experiencing a downward motion. The `invalidate()` method being
    called within `setGameCommand()` can be taken as a request to draw a change on
    the screen. `invalidate()` ultimately results in a call to `onDraw()`.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`setGameCommand()` 设置游戏正在执行的运动命令。如果一个 `DOWN` 运动命令正在执行，应用程序模型会为经历向下运动的方块生成字段。在
    `setGameCommand()` 中被调用的 `invalidate()` 方法可以被视为在屏幕上绘制更改的请求。`invalidate()` 最终会导致调用
    `onDraw()`。'
- en: '`onDraw()` is a method that is inherited from the `View` class. It is called
    when a view should render its content. We will need to provide a custom implementation
    of this for our view. Add the code below to your `TetrisView` class.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`onDraw()` 是从 `View` 类继承的方法。当视图需要渲染其内容时会被调用。我们需要为我们的视图提供一个自定义的实现。将以下代码添加到您的
    `TetrisView` 类中。'
- en: '[PRE48]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `onDraw()` method in `TetrisView` overrides the `onDraw()` in its superclass.
    `onDraw()`, takes a canvas object as its only argument and must call the `onDraw()`
    function in its superclass. This is done by invoking `super.onDraw()` and passing
    the canvas instance as an argument.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`TetrisView` 中的 `onDraw()` 方法覆盖了其超类的 `onDraw()` 方法。`onDraw()` 方法接受一个画布对象作为其唯一参数，并且必须调用其超类的
    `onDraw()` 函数。这是通过调用 `super.onDraw()` 并传递画布实例作为参数来实现的。'
- en: After invoking `super.onDraw()`, `onDraw()` in `TetrisView` invokes `drawFrame()`,
    which draws the frame for `TetrisView`. After which, individual cells are drawn
    within the canvas by utilizing the `drawCell()` functions we created.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `super.onDraw()` 之后，`TetrisView` 中的 `onDraw()` 会调用 `drawFrame()`，这会为 `TetrisView`
    绘制框架。之后，通过使用我们创建的 `drawCell()` 函数，在画布中绘制单个单元格。
- en: The `setGameCommandWithDelay()` works similarly to `setGameCommand()` with the
    exception that updates the game score and it puts `viewHandler` to sleep after
    executing the game command. The `updateScore()` function is used to update the
    current score and high score text views in game activity.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`setGameCommandWithDelay()` 与 `setGameCommand()` 类似，但更新游戏分数，并在执行游戏命令后将 `viewHandler`
    置于休眠状态。`updateScore()` 函数用于更新游戏活动中的当前分数和最高分文本视图。'
- en: The `onSizeChanged()` is a function that is called when the size of a view has
    changed. The function provides access to the current width and height of the view,
    as well as its former width and height. As with other overriden functions we have
    used, we invoke its counterpart function in its super class. We use the width
    and height arguments provided to us to calculate and set dimensions for the size
    of each cell—`cellSize`. Finally, in `onSizeChanged()`, the `offsetX` and `offsetY`
    are calculated and used to set `frameOffset`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当视图的大小发生变化时，会调用 `onSizeChanged()` 函数。该函数提供了访问视图当前宽度和高度以及其之前宽度和高度的方法。与其他我们使用过的覆盖函数一样，我们调用其超类中的对应函数。我们使用提供的宽度和高度参数来计算和设置每个单元格的大小——`cellSize`。最后，在
    `onSizeChanged()` 中，`offsetX` 和 `offsetY` 被计算并用于设置 `frameOffset`。
- en: Finishing up GameActivity
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成游戏活动
- en: 'So far, you have successfully implemented the views, handlers, helper functions,
    classes, and models necessary to put the Tetris game together. Now we are going
    to finish up the work we started by putting it all together in `GameActivity`.
    The first thing on our agenda is to add the newly created `tetris` view to the
    game activity''s layout. We can easily add `TetrisView` as a child element anywhere
    within a layout file by utilizing the `<com.mydomain.tetris.views.TetrisView>`
    layout tag:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经成功实现了构建俄罗斯方块游戏所需的视图、处理程序、辅助函数、类和模型。现在我们将通过在 `GameActivity` 中将所有这些放在一起来完成我们开始的工作。我们首要任务是向游戏活动的布局中添加新创建的
    `tetris` 视图。我们可以通过使用 `<com.mydomain.tetris.views.TetrisView>` 布局标签，轻松地将 `TetrisView`
    作为子元素添加到布局文件中的任何位置：
- en: '[PRE49]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Once you have added the `tetris` view to `activity_game.xml`, open the `GameActivity`
    class and employ the changes to the class shown in the following code block:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将 `tetris` 视图添加到 `activity_game.xml` 中，打开 `GameActivity` 类并应用以下代码块中显示的类更改：
- en: '[PRE50]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We added an object reference to the `tetris` view layout element in `activity_game.xml`
    in the form of the `tetrisView` property; we also created an instance of `AppModel`
    that will be used by `GameActivity`. In `oncreate()`, we set the activity in use
    by `tetrisView` to the current instance of the `GameActivity` and set the model
    in use by `tetrisView` to `appModel` – the `AppModel` instance property we created.
    In addition, the on-touch listener for `tetrisView` was set to the `onTetrisViewTouch()`
    function.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `activity_game.xml` 中将 `tetris` 视图布局元素添加为一个对象引用，形式为 `tetrisView` 属性；我们还创建了一个
    `AppModel` 实例，该实例将被 `GameActivity` 使用。在 `oncreate()` 方法中，我们将 `tetrisView` 使用的活动设置为当前
    `GameActivity` 实例，并将 `tetrisView` 使用的模型设置为 `appModel` – 我们创建的 `AppModel` 实例属性。此外，`tetrisView`
    的触摸监听器被设置为 `onTetrisViewTouch()` 函数。
- en: If `tetrisView` is touched and the game is in an `AWAITING_START` or `OVER`
    state, a new game is started. If `tetrisView` is touched and the game is in its
    `ACTIVE` state, the direction in which the touch on `tetrisView` occurred is resolved
    with the help of `resolveTouchDirection()`. `moveTetromino()` is used to move
    a tetromino block based on the action passed to it. If a left touch occurred,
    `moveTetromino()` is called with `AppModel.Motions.LEFT` set as its argument.
    This results in the movement of the tetromino to the left on the field. Right,
    down, and up touches on `tetrisView` result in rightward, downward, and rotational
    motions.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果触摸 `tetrisView` 并且游戏处于 `AWAITING_START` 或 `OVER` 状态，则会启动新游戏。如果触摸 `tetrisView`
    并且游戏处于其 `ACTIVE` 状态，则使用 `resolveTouchDirection()` 函数确定 `tetrisView` 上触摸的方向。`moveTetromino()`
    用于根据传递给它的操作移动一个俄罗斯方块块。如果发生了左触摸，则使用 `AppModel.Motions.LEFT` 作为参数调用 `moveTetromino()`。这会导致俄罗斯方块块在场上向左移动。在
    `tetrisView` 上的右、下和上触摸会导致向右、向下和旋转动作。
- en: 'Having made all the additions, build and run the project. Once the project
    launches on your desired device, navigate to game activity and touch the `tetris`
    view to the right of the screen. The game will start:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加所有这些之后，构建并运行项目。一旦项目在你的目标设备上启动，导航到游戏活动并触摸屏幕右侧的 `tetris` 视图。游戏将开始：
- en: '![](img/47512283-ebce-429b-aa3c-9014c625a66d.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/47512283-ebce-429b-aa3c-9014c625a66d.jpg)'
- en: Feel free to play around with the game you created. You deserve it!
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 随意玩玩你创建的游戏吧。你应得的！
- en: Introduction to Model-View-Presenter (MVP)
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVP 模式介绍
- en: Over the course of developing the Tetris application, we attempted to add structure
    across our code base by separating out program files into different packages based
    on the tasks they performed. We tried to abstract application logic into the `AppModel`
    class, and user interactions related to gameplay to be handled by the `TetrisView`
    view class. This certainly brought some order into our code base in contrast with,
    say, putting all logic into one big class file.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发俄罗斯方块应用程序的过程中，我们试图通过根据它们执行的任务将程序文件分离到不同的包中来在我们的代码库中添加结构。我们试图将应用程序逻辑抽象到 `AppModel`
    类中，并将与游戏玩法相关的用户交互由 `TetrisView` 视图类处理。这当然在我们的代码库中带来了一些秩序，与将所有逻辑放入一个大类文件相比。
- en: Needless to say, there are better ways to separate concerns within an Android
    application. One way is the MVP pattern.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 不言而喻，在 Android 应用程序中分离关注点有更好的方法。一种方法是 MVP 模式。
- en: What is MVP?
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 MVP？
- en: 'MVP is a common pattern in Android that is derived from the **Model-View-Controller** (**MVC**)
    pattern. MVP attempts to view related concerns from application logic. There are
    many reasons for which this is done, such as:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: MVP 是 Android 中的一种常见模式，它源自 **模型-视图-控制器**（**MVC**）模式。MVP 试图从应用程序逻辑的角度看待与视图相关的问题。这样做的原因有很多，例如：
- en: To increase the maintainability of a code base
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了提高代码库的可维护性
- en: To improve application reliability
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了提高应用程序的可靠性
- en: '![](img/c1c00988-da9a-422a-80ae-784431176d2f.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1c00988-da9a-422a-80ae-784431176d2f.jpg)'
- en: Let's familiarize ourselves with the actors in the MVP pattern.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们熟悉 MVP 模式中的参与者。
- en: Model
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型
- en: In MVP, models are interfaces that have the task of managing data. The responsibilities
    of models include interacting with databases, making API calls, communicating
    over networks, and coordinating objects and other programmatic components to perform
    specific tasks.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MVP 中，模型是具有管理数据任务的接口。模型的责任包括与数据库交互、进行 API 调用、通过网络通信以及协调对象和其他程序组件以执行特定任务。
- en: View
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图
- en: Views are application entities that display content to users and serve as an
    interface for user input. A view can be an activity, a fragment, or an Android
    widget. A view is responsible for rendering data in a way decided upon by the
    presenter.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 视图是向用户展示内容并作为用户输入接口的应用实体。一个视图可以是一个活动、一个片段或一个 Android 小部件。视图负责以由视图控制器决定的方式渲染数据。
- en: Presenter
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图控制器
- en: A presenter is a layer that acts as a middleman between a view and a model.
    The major responsibility of the presenter is querying the model and updating a
    view. Put simply, presentation logic goes into the presenter. An important thing
    to keep in mind is that a presenter has a one-to-one relationship with a view.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 视图控制器是一个充当视图和模型之间中间人的层。视图控制器的主要职责是查询模型并更新视图。简单来说，展示逻辑会放入视图控制器中。需要记住的一个重要事情是，视图控制器与视图之间有一个一对一的关系。
- en: Varying implementations of MVP
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVP 的不同实现
- en: The MVP pattern has varying means by which it is implemented in practice. For
    example, some implementations of MVP utilize a *contract* to describe the interaction
    between the view and presenter.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: MVP 模式在实践中有多种实现方式。例如，一些 MVP 实现使用 *合约* 来描述视图和视图控制器之间的交互。
- en: In addition, there are implementations of MVP that utilize lifecycle callbacks
    within the presenter, such as `onCreate()`. This is in an attempt to mirror callbacks
    existing in the activity lifecycle. Other implementations discard the implementation
    of these callbacks entirely.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些 MVP 的实现利用了在视图中的生命周期回调，例如 `onCreate()`。这是试图模仿活动生命周期中存在的回调。其他实现则完全放弃了这些回调的实现。
- en: In reality, there is no one true implementation of MVP in Android applications,
    but there are best practices that can be followed while implementing MVP. You
    will learn about these best practices and have hands-on experience with developing
    an MVP application with Kotlin in [Chapter 5](kt-prog-ex_ch05.html), *Building
    the Messenger Android App*.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在 Android 应用程序中并没有一个真正的 MVP 实现，但在实现 MVP 时可以遵循一些最佳实践。你将在第 5 章 [构建 Messenger
    Android 应用](kt-prog-ex_ch05.html)中了解这些最佳实践，并通过使用 Kotlin 开发 MVP 应用程序获得实践经验。
- en: Summary
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we got down and dirty with Kotlin by implementing a classic
    game, *Tetris*. Over the course of this chapter, we learned about a vast array
    of things, such as how to model logical components of an application with classes,
    access and visibility modifiers, how to create views and handlers in Android applications,
    the utilization of data classes to easily create data models, and the MVP pattern.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过实现经典的游戏 *俄罗斯方块* 来深入研究了 Kotlin。在本章的整个过程中，我们学习了大量内容，例如如何使用类来建模应用程序的逻辑组件、访问和可见性修饰符、如何在
    Android 应用程序中创建视图和处理程序、如何使用数据类轻松创建数据模型，以及 MVP 模式。
- en: In the next chapter, we will apply our knowledge of Kotlin to the web domain
    by implementing the backend of a messenger application.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过实现一个消息应用的后端来将我们对 Kotlin 的知识应用到网络领域。
