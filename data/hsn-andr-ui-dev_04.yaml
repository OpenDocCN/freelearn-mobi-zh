- en: Composing User Interfaces
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建用户界面
- en: Mobile apps seem like simple systems, but they are often actually quite deep
    and complex systems, with many different parts that help them keep the appearance
    of being simple. The user interfaces of applications are the same; they may appear
    simple, but they are often complex arrangements of screens and dialogs designed
    to hide the complexities of the application from the user and provide a smoother
    experience. The easiest way to think about this is that traditional desktop applications
    and websites tend to be *wide*, while mobile applications tend to be *deep*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 移动应用看起来像是简单的系统，但实际上它们往往是相当深奥和复杂的系统，由许多不同的部分组成，这些部分帮助它们保持简单的外观。应用程序的用户界面也是如此；它们可能看起来简单，但通常是复杂的屏幕和对话框的排列，旨在隐藏应用程序的复杂性并向用户提供更流畅的体验。最容易想到的是，传统的桌面应用程序和网站往往更“宽”，而移动应用程序则更“深”。
- en: This comment applies (on the surface at least) to the navigation of applications.
    Desktop applications tend to have a central *control* area where most of the work
    is done. Think of a document editor--the application centers around the document
    being written, and you never really *leave* that area. Instead of navigating away,
    dialogs pop up to fulfill a single task, which alters the document before they
    disappear. There are many variations on this theme, but desktop applications tend
    to follow the same pattern.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这个评论（至少表面上）适用于应用程序的导航。桌面应用程序往往有一个中央**控制**区域，大部分工作都在这里完成。想想文档编辑器——应用程序围绕正在编写的文档展开，你永远不会真正**离开**这个区域。而不是导航离开，对话框会弹出以完成单个任务，在它们消失之前会改变文档。这个主题有很多变体，但桌面应用程序往往遵循相同的模式。
- en: Mobile applications, on the other hand, tend to start at an *overview* screen
    of some sort, or launch directly into an *action* screen. The user then navigates
    *downward* into a task or item before either returning to the overview screen,
    or completing their task and being presented with a *result* of some sort (for
    example, booking a flight). Achieving a goal by navigating away from the overview
    screen, rather than simply opening a dialog on top of the content, requires a
    different approach to your application's design. As there is no central screen
    always available to the user, you often need to remind them of where they are,
    and what they are doing. This sort of repetition will be unthinkable on a desktop
    application where the information is always available in another window or panel
    of the application; however, on the limited space offered by a mobile phone, this
    becomes an essential tool to keep the user on track, and help them complete the
    task they are trying to fulfill.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，移动应用程序往往从一个某种形式的**概览**屏幕开始，或者直接进入一个**操作**屏幕。然后用户会向下导航到一个任务或项目，之后要么返回到概览屏幕，要么完成任务并得到某种类型的**结果**（例如，预订航班）。通过从概览屏幕导航离开来实现目标，而不是简单地打开内容上方的对话框，这要求您对应用程序的设计采取不同的方法。由于没有中央屏幕始终可用，您通常需要提醒用户他们在哪里，以及他们在做什么。这种重复在桌面应用程序中是不可想象的，因为在另一个窗口或应用程序的面板中总是可以找到信息；然而，在移动手机提供的有限空间中，这成为了一个保持用户在正确轨道上并帮助他们完成他们试图完成的任务的必要工具。
- en: This change in how the user navigates, requires that screens often present the
    same data, or have elements that are repeated all over the application. These
    elements are best encapsulated so that they can be easily reused throughout the
    application. Android offers the perfect way to encapsulate these groups of widgets
    in a way that can be more aware than a simple layout component--fragments. A **Fragment**
    is like a *miniature* `Activity`; each Fragment has a full life cycle, just like
    `Activity`, except that they are always contained within an `Activity` (refer
    to [Appendix A](8b58d03e-232e-49ec-8aba-344b3ed81d2d.xhtml) for details of the
    `Activity` life cycle). Using fragments allows your application to more easily
    adapt to various screen sizes. We'll be taking a closer look at fragments later
    in this chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这种用户导航方式的变化要求屏幕通常展示相同的数据，或者有在应用程序中重复出现的元素。这些元素最好被封装起来，以便在应用程序中轻松重用。Android提供了封装这些小部件组的方法，使其比简单的布局组件更具有感知能力——片段。**片段**就像一个**微型**的`Activity`；每个片段都有一个完整的生命周期，就像`Activity`一样，只是它们总是包含在一个`Activity`中（有关`Activity`生命周期的详细信息，请参阅[附录A](8b58d03e-232e-49ec-8aba-344b3ed81d2d.xhtml)）。使用片段可以让您的应用程序更容易适应各种屏幕尺寸。我们将在本章后面更详细地探讨片段。
- en: 'In this chapter, we''ll look at various ways to break up a user interface,
    building modules that can be layered and reused to form complex behaviors without
    requiring complex code and wiring. We''ll be looking at the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨各种分解用户界面的方法，构建可以分层和重用的模块，以形成复杂的行为，而无需编写复杂的代码和连接。我们将探讨以下内容：
- en: How to build custom groups of widgets that can be directly included in layouts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何构建可以直接包含在布局中的自定义小部件组
- en: How to build Fragments that expose common functionality with a complete life
    cycle of their own
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何构建具有自身完整生命周期的Fragment以暴露常用功能
- en: How to use ViewPager to display pages or tabs of widgets
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用ViewPager显示页面或小部件标签页
- en: Designing a modular layout
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模块化布局
- en: 'So far, you''ve built a single `Activity` class with a layout composed out
    of two layout files containing widgets. This is a pretty normal state of affairs,
    but it''s not the best situation. Like in most user interfaces, the claim capturing
    screen can be divided into a range of very logical areas:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经构建了一个包含两个布局文件（包含小部件）的布局的单一`Activity`类。这是一个相当正常的状态，但并不是最佳情况。像大多数用户界面一样，捕获屏幕可以被划分为一系列非常逻辑的区域：
- en: '![](img/5f60df92-53cd-4554-9ba7-4e31ce4b843a.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5f60df92-53cd-4554-9ba7-4e31ce4b843a.jpg)'
- en: 'In an Android user interface, you always have the individual widgets (such
    as `Button`, `TextView`, `ImageView`, and friends) at the bottom level, and `Activity`
    at the top level, but when you look at that screen mockup, you can instantly see
    that the screen can be divided into other layers in between `Activity` and widget.
    You can, of course, take each of the `CardView` layouts from this screen and place
    them in their own layout XML files, and then import them:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android用户界面中，你总是将单个小部件（如`Button`、`TextView`、`ImageView`等）放在底层，而`Activity`位于顶层，但当你查看那个屏幕原型时，你可以立即看到屏幕可以被分成在`Activity`和小部件之间的其他层。当然，你可以从这个屏幕中取出每个`CardView`布局，并将它们放置在自己的布局XML文件中，然后导入：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can use the `<include>` element to include one layout file into another,
    like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`<include>`元素将一个布局文件包含到另一个文件中，如下所示：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This nicely separates out the layout for this part of the screen, allowing you
    to reuse it in layouts for larger physical screens or even in other `Activity`
    classes in the application. The problem is that every screen that wants to use
    this layout will need to also duplicate all the logic associated with it. While
    the logical decoupling of the logic and the layout is mostly a good thing (especially
    when you can overlay the logic on multiple different layouts), their coupling
    is normally quite tight.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就很好地分离了屏幕这一部分的布局，允许你在更大物理屏幕的布局中或是在应用程序中的其他`Activity`类中重用它。问题是，每个想要使用这个布局的屏幕都需要复制与之相关的所有逻辑。虽然逻辑解耦逻辑和布局大多数情况下是好事（尤其是当你可以在多个不同的布局上叠加逻辑时），但它们的耦合通常非常紧密。
- en: Creating the DatePickerLayout
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建DatePickerLayout
- en: Each of these areas can easily be encapsulated in a Java class and reused elsewhere
    in your application. In [Chapter 3](75335d7f-3cda-4985-b992-965f46adc335.xhtml),
    *Taking Actions*, you wrote the `DatePickerWrapper` class, which can turn any
    `TextView` widget into a date selection widget. However, `DatePickerWrapper` doesn't
    create the `TextView` label or change the styling of the widgets to look like
    `TextInputLayout`. This means that you need to copy that styling into each layout
    where you want a date-picker, which can quickly lead to inconsistencies in your
    user interface. While it's good to have the events and state decoupled from the
    display logic, it would also be nice to have them grouped together in a single
    structure that can be reused without every layout having to specify the date picker
    widgets by hand, and then bind them to the `DatePickerWrapper` in its code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这些区域中的每一个都可以轻松封装在Java类中，并在你的应用程序的其他地方重用。在[第3章](75335d7f-3cda-4985-b992-965f46adc335.xhtml)“执行操作”中，你编写了`DatePickerWrapper`类，该类可以将任何`TextView`小部件转换为日期选择小部件。然而，`DatePickerWrapper`不会创建`TextView`标签或更改小部件的样式以看起来像`TextInputLayout`。这意味着你需要将这种样式复制到每个你想要日期选择器的布局中，这可能导致你的用户界面出现不一致。虽然将事件和状态与显示逻辑解耦是好事，但将它们组合在一起在一个可以重用的单一结构中也会很好，这样就不需要每个布局都手动指定日期选择器小部件，然后在代码中将它们绑定到`DatePickerWrapper`。
- en: 'While it''s not obvious at first, the Android layout XML files can reference
    any `View` class and not just those defined in the core and support packages,
    and it can do so without any special tricks. All you need to do is reference the
    `View` class by its fully-qualified name, much like you''ve already done for several
    widgets:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一开始并不明显，但 Android 布局 XML 文件可以引用任何 `View` 类，而不仅仅是核心和支持包中定义的类，并且它可以不使用任何特殊技巧做到这一点。您需要做的只是通过其完全限定名引用
    `View` 类，就像您已经为几个小部件所做的那样：
- en: '`android.support.constraint.ConstraintLayout`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android.support.constraint.ConstraintLayout`'
- en: '`android.support.v7.widget.CardView`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android.support.v7.widget.CardView`'
- en: '`android.support.design.widget.TextInputLayout`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android.support.design.widget.TextInputLayout`'
- en: 'All the preceding are classes that you can look up in Android Studio, and even
    read their code if you like. Let''s get started by writing a `DatePickerLayout`
    to couple the layout XML with the `DatePickerWrapper`, and make the date picker
    reusable from any layout XML file in your application:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的这些都是在 Android Studio 中可以查找的类，如果您喜欢，甚至可以阅读它们的代码。让我们开始编写一个 `DatePickerLayout`，将布局
    XML 与 `DatePickerWrapper` 相结合，并使日期选择器可以从应用程序中的任何布局 XML 文件中重用：
- en: 'In the Android panel of Android Studio, right-click on the layout directory
    under res:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Android Studio 的 Android 面板中，右键单击 `res` 下的布局目录：
- en: '![](img/ee95da20-5eb2-40a0-a6b4-b86b058794d8.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ee95da20-5eb2-40a0-a6b4-b86b058794d8.png)'
- en: Select New | Layout resource file.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“新建 | 布局资源文件”。
- en: Name the new layout file as `widget_date_picker`.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的布局文件命名为 `widget_date_picker`.
- en: 'Change the Root element field to `merge`:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将根元素字段更改为 `merge`：
- en: '![](img/0fb35182-414c-430f-8a77-159e36ca6774.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0fb35182-414c-430f-8a77-159e36ca6774.png)'
- en: '`merge` is a special root element for layout files. Normally, the root element
    of a layout file is a `View` class that results in the file having a root widget
    when it''s inflated. The `merge` element doesn''t create a root widget; instead,
    it''s effectively skipped when the file is loaded, and its children are inflated
    directly. This makes it ideal for creating layout widgets, or reusable bits of
    layout, while also keeping the layout hierarchy flat and helping improve your
    application''s performance.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`merge` 是布局文件的特殊根元素。通常，布局文件的根元素是一个 `View` 类，当文件被填充时，它会在文件中产生一个根小部件。`merge`
    元素不会创建根小部件；相反，当文件被加载时，它会有效地被跳过，并且其子元素会直接被填充。这使得它非常适合创建布局小部件或可重用的布局片段，同时保持布局层次结构扁平，并有助于提高应用程序的性能。'
- en: Change the editor mode to Text instead of Design.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将编辑模式更改为文本而不是设计。
- en: Remove the `layout_width` and `layout_height` attributes from the `merge` element.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `merge` 元素中移除 `layout_width` 和 `layout_height` 属性。
- en: 'Write the following two `TextView` widgets into the merge element:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下两个 `TextView` 小部件写入 `merge` 元素中：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding file, there are no `id` attributes set; this is because any
    layout the new widget is used in will be polluted with those `id` attributes,
    and `findViewById` can easily start returning unexpected results. When encapsulating
    parts of your layout, always consider what `id` values will appear in the layout,
    and where they might be used in code. `findViewById` simply finds the *first*
    matching `View` object in the layout and returns it, and doesn''t consider where
    that `View` might have come from (that is: an `<include>`, or special `View` class).'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的文件中，没有设置 `id` 属性；这是因为任何使用新小部件的布局都会被这些 `id` 属性污染，并且 `findViewById` 很容易返回意外的结果。在封装布局的各个部分时，始终考虑新布局中会出现的
    `id` 值，以及它们可能在代码中的使用位置。`findViewById` 仅查找布局中的第一个匹配的 `View` 对象，并返回它，而不考虑该 `View`
    可能来自何处（即：`<include>` 或特殊 `View` 类）。
- en: 'In the Android panel of Android Studio, right-click on your `base` package
    (that is, `com.packtpub.claim`):'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在 Android Studio 的 Android 面板中，右键单击您的 `base` 包（即 `com.packtpub.claim`）:'
- en: '![](img/1b9d0772-6c90-47e1-9fa4-79f2067ac612.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1b9d0772-6c90-47e1-9fa4-79f2067ac612.png)'
- en: Select New and Java Class.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“新建”和“Java 类”。
- en: Name the new class `widget.DatePickerLayout`.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新类命名为 `widget.DatePickerLayout`。
- en: Change the Superclass to `android.widget.LinearLayout`.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将超级类更改为 `android.widget.LinearLayout`。
- en: Click OK to create the new package and class.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“确定”以创建新的包和类。
- en: 'Declare fields in the `DatePickerLayout` for to reference a `TextView` label,
    and the `DatePickerWrapper` :'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在 `DatePickerLayout` 中声明字段以引用 `TextView` 标签和 `DatePickerWrapper` :'
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Any class accessible from a layout XML requires several constructor overloads,
    so it''s best to create a single `initialize` method that can be reused for all
    of them:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何可以从布局 XML 访问的类都需要几个构造函数重载，因此最好创建一个可以重用于所有这些的单一 `initialize` 方法：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Still within the `initialize` method, use `LayoutInflator` to load the layout
    XML file you wrote, adding its contents as elements to the `DatePickerLayout`
    object:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在 `initialize` 方法中，使用 `LayoutInflator` 加载您编写的布局 XML 文件，将其内容作为元素添加到 `DatePickerLayout`
    对象中：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The parameters for the inflate method are the layout resource, the `ViewGroup`
    (in this case, `DatePickerLayout`) that will contain the layout, and whether or
    not to actually attach the elements of the layout resource to the `ViewGroup`.
    As you are using a merge element in the layout resource, the third parameter must
    be `true`, because otherwise the contents of the layout will be lost.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`inflate` 方法的参数是布局资源、将包含布局的 `ViewGroup`（在这种情况下，`DatePickerLayout`），以及是否实际将布局资源的元素附加到
    `ViewGroup`。由于您在布局资源中使用了一个合并元素，第三个参数必须是 `true`，否则布局的内容将会丢失。'
- en: 'Use `getChildAt` to retrieve the new `TextView` elements that have been loaded
    by the `LayoutInflator`, and assign the fields of the `DatePickerLayout`:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `getChildAt` 来检索由 `LayoutInflator` 加载的新 `TextView` 元素，并将 `DatePickerLayout`
    的字段赋值：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Overload the constructors and invoke the `initialize` method in each of them:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重载构造函数并在每个构造函数中调用 `initialize` 方法：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create getters and setters to make the `DatePickerLayout` usable from the `Activity`
    classes:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建获取器和设置器，以便从 `Activity` 类中使用 `DatePickerLayout`：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As the `DatePickerLayout` contains some of the user-interface state (the currently
    selected date), it''s expected to keep track of this through possible `Activity`
    restarts, if required (an `Activity` is recreated every time the user changes
    between portrait and landscape, as these are considered *configuration* changes).
    This will involve saving its state to a `Parcel`, and restoring it from a `Parcel`
    when requested to (a `Parcel` is a bit like a `byte[]` of `Serialized` objects,
    except that all the marshaling work needs to be implemented). You''ll need an
    inner class that can hold the state of the `DatePickerLayout` (and it''s parent
    class--`LinearLayout`). For convenience, the `View` class provides a `BaseSavedState`
    abstract class to take care of some of the implementation for you, so extend `BaseSavedState`
    in a static inner class named `SavedState`:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于 `DatePickerLayout` 包含一些用户界面状态（当前选定的日期），因此它需要通过可能的 `Activity` 重新启动来跟踪这些状态，如果需要的话（每次用户在横屏和竖屏之间切换时，都会重新创建
    `Activity`，因为这些被认为是 *配置* 变化）。这将涉及将其状态保存到 `Parcel` 中，并在请求时从 `Parcel` 中恢复（`Parcel`
    类似于 `Serialized` 对象的 `byte[]`，但所有序列化工作都需要实现）。您需要一个内部类来保存 `DatePickerLayout` 的状态（及其父类--`LinearLayout`）。为了方便，`View`
    类提供了一个 `BaseSavedState` 抽象类来为您处理一些实现，因此在一个名为 `SavedState` 的静态内部类中扩展 `BaseSavedState`：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Objects crossing between `Activity` instances need to be `Parcelable`, because
    Android may need to store the objects temporarily through the `Activity` life
    cycle. Being able to store just the important bits of data and state, instead
    of the entire widget tree, is very useful for conserving memory when the user
    has a lot of applications running. `BaseSavedState` implements `Parcelable` and
    will allow the `DatePickerLayout` to remember its state when the `Activity` is
    destroyed and recreated by the system.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Activity` 实例之间传递的对象需要是 `Parcelable`，因为 Android 可能需要通过 `Activity` 生命周期临时存储对象。能够只存储重要的数据和方法状态，而不是整个小部件树，对于在用户运行大量应用程序时节省内存非常有用。`BaseSavedState`
    实现 `Parcelable` 并允许 `DatePickerLayout` 在 `Activity` 被系统销毁和重新创建时记住其状态。
- en: '`SavedState` will also need a constructor to load its fields from a `Parcel`
    object; a `CharSequence` cannot be read directly from a `Parcel`, but fortunately,
    `TextUtils` has a nice helper for reading `CharSequence` objects from `Parcel`
    objects for you:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SavedState` 也需要一个构造函数来从 `Parcel` 对象中加载其字段；`CharSequence` 不能直接从 `Parcel` 中读取，但幸运的是，`TextUtils`
    为您提供了一个读取 `Parcel` 对象中的 `CharSequence` 对象的便捷助手：'
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, `SavedState` needs the `writeToParcel` method implemented in order to
    actually write those fields to a `Parcel`; part of this is delegated to the `BaseSavedState`
    class:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，`SavedState` 需要实现 `writeToParcel` 方法，以便实际上将这些字段写入 `Parcel`；其中一部分委托给了 `BaseSavedState`
    类：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Every `Parcelable` implementation requires a special `public static final`
    field called `CREATOR`, which will be used by the `Parcel` system to create instances
    and arrays of the `Parcelable` objects. This also applies for every subclass,
    so write the following static final into the `SavedState` class:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个 `Parcelable` 实现都需要一个特殊的 `public static final` 字段，称为 `CREATOR`，它将被 `Parcel`
    系统用于创建 `Parcelable` 对象的实例和数组。这也适用于每个子类，因此将以下静态最终字段写入 `SavedState` 类：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When implementing a vanilla `Parcelable` class, Android Studio has a nice generator
    that can be triggered from the class declaration hints (look for "Add Parcelable
    Implementation") that will write a simple `writeToParcel` method, `Parcel` handling
    constructor, and the `CREATOR` field. Check whether it's working though; it skips
    any field it doesn't know how to handle.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当实现一个普通的 `Parcelable` 类时，Android Studio 有一个很好的生成器，可以从类声明提示中触发（查找“添加 Parcelable
    实现”），这将写入一个简单的 `writeToParcel` 方法、`Parcel` 处理构造函数和 `CREATOR` 字段。不过，检查它是否正常工作；它会跳过任何不知道如何处理的字段。
- en: 'In the `DatePickerLayout` class, you need to override the `onSaveInstanceState`
    method and create the `SavedState` object that will be recorded:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `DatePickerLayout` 类中，你需要重写 `onSaveInstanceState` 方法并创建将被记录的 `SavedState`
    对象：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You''ll also need to restore the state from a `SavedState` object, which requires
    overriding `onRestoreInstanceState`:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还需要从 `SavedState` 对象中恢复状态，这需要重写 `onRestoreInstanceState`：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Open the `content_capture_claim.xml` layout file in Android Studio.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Android Studio 中打开 `content_capture_claim.xml` 布局文件。
- en: Change to the Text editor, if required.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如有需要，切换到文本编辑器。
- en: 'Find the two `TextView` elements that describe the date-picker, and replace
    them with the following snippet:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到描述日期选择器的两个 `TextView` 元素，并用以下代码片段替换它们：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Open the `CaptureClaimActivity` class in Android Studio.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Android Studio 中打开 `CaptureClaimActivity` 类。
- en: 'Replace the references to `DatePickerWrapper` with `DatePickerLayout`:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将对 `DatePickerWrapper` 的引用替换为 `DatePickerLayout`：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This new `DatePickerLayout` class allows you to reuse the same label and editor
    in any layout XML file in your application, while also coupling the required events
    in a single class. Any time you have a layout with `TextViewLayout` widgets, the
    new `DatePickerLayout` will fit right into the style and allow for safe date selection.
    It's also very important to implement the `onSaveInstanceState`/`onRestoreInstanceState`
    method on `View` subclasses if you intend to carry any state. These classes are
    marshaled, and new instances of the `View` are created every time a configuration
    state changes, which includes actions such as the user rotating the device (refer
    to [Appendix A](192d8c3c-7167-43cf-ae76-9c841f4ec1d2.xhtml) for more information
    on `Activity` life cycle).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的 `DatePickerLayout` 类允许你在应用程序中的任何布局 XML 文件中重用相同的标签和编辑器，同时也在一个类中耦合所需的事件。每次你有带有
    `TextViewLayout` 小部件的布局时，新的 `DatePickerLayout` 将完美融入样式，并允许安全地选择日期。如果你打算携带任何状态，实现
    `onSaveInstanceState`/`onRestoreInstanceState` 方法在 `View` 子类上也非常重要。这些类是 marshaled
    的，每次配置状态改变时都会创建新的 `View` 实例，这包括用户旋转设备等动作（有关 `Activity` 生命周期的更多信息，请参阅[附录 A](192d8c3c-7167-43cf-ae76-9c841f4ec1d2.xhtml)）。
- en: Creating the data model
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建数据模型
- en: At this point in the application, it's time to build a simple data model that
    the user interface will back onto. Each claim will be represented by a `ClaimItem`
    object, and will contain any number of `Attachment` objects, each of which will
    reference the `File` that was attached, and have a marker to help decide how the
    attachment should be previewed. All these classes will need to be `Parcelable`,
    because they need to be saved in the `CaptureClaimActivity`. The `CaptureClaimActivity`
    will also use them as input and output parameters, and any time an object needs
    to be passed as a parameter to or from an `Activity`, it needs to be `Parcelable`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的这个阶段，是时候构建一个简单的数据模型，用户界面将基于此模型。每个索赔将由一个 `ClaimItem` 对象表示，并将包含任意数量的 `Attachment`
    对象，每个对象都将引用附加的 `File`，并有一个标记来帮助决定如何预览附件。所有这些类都需要实现 `Parcelable` 接口，因为它们需要在 `CaptureClaimActivity`
    中保存。`CaptureClaimActivity` 还将使用它们作为输入和输出参数，并且每次需要将对象作为参数传递给或从 `Activity` 中取出时，它需要实现
    `Parcelable`。
- en: You'll also be creating a `Category` enum that links the Android IDs to an internal
    model that can be stored without having to worry about the Android IDs changing
    their values as the application evolves.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将创建一个 `Category` 枚举，将 Android ID 链接到一个内部模型，这样就可以在不担心 Android ID 随着应用程序的发展而改变值的情况下进行存储。
- en: Creating the Attachment class
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建附件类
- en: 'The `Attachment` class represents files that have been attached to a `ClaimItem`
    by the user. These should always be files accessible by the application, and later
    on, we''ll take steps to ensure this by copying all the attachments into a private
    space before attaching them to a claim item. For now, follow these steps to create
    the `Attachment` class:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`Attachment` 类代表用户附加到 `ClaimItem` 的文件。这些文件应该始终是应用程序可访问的，稍后我们将采取措施确保这一点，即在将附件附加到索赔项目之前，将所有附件复制到私有空间中。现在，按照以下步骤创建
    `Attachment` 类：'
- en: In the Android panel, right-click on your default package (that is, `com.packtpub.claim`)
    and select New| Java Class.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Android 面板中，右键单击你的默认包（即 `com.packtpub.claim`），然后选择 New| Java Class。
- en: 'Name the new class as `model.Attachment`, and in the Interface(s) box, add
    `Parcelable`:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新类命名为 `model.Attachment`，并在接口（s）框中添加 `Parcelable`：
- en: '![](img/47ff5cc6-2cfe-4906-bb56-d25f03734c85.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/47ff5cc6-2cfe-4906-bb56-d25f03734c85.png)'
- en: Click OK to create the new package and class.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 OK 创建新的包和类。
- en: 'Attachments have different types, which can affect how they are previewed;
    for now, you''ll just have images and unknown types. Inside the new `Attachment`
    class, create an `enum` to represent these types:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 附件有不同的类型，这可能会影响它们的预览方式；目前，你将只有图像和未知类型。在新的 `Attachment` 类中，创建一个 `enum` 来表示这些类型：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the `Attachment` class, declare its fields, a constructor, and getters and
    setters:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Attachment` 类中，声明其字段、构造函数以及获取器和设置器：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, create the `Parcelable` implementation for the `Attachment` class. This
    is best done by hand in this case, as neither `File` nor the `Type` `enum` will
    be understood by Android Studio''s `Parcelable` generator:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为 `Attachment` 类创建 `Parcelable` 实现。在这种情况下，最好手动完成，因为 `File` 和 `Type` `enum`
    都不会被 Android Studio 的 `Parcelable` 生成器理解：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, at the top of the `Attachment` class, add its `Parcelable.Creator`
    instance:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 `Attachment` 类的顶部，添加其 `Parcelable.Creator` 实例：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Creating the Category enum
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 `Category` 枚举
- en: 'The next part of the model is the `Category` enumeration. This will serve a
    double purpose--when you change the list of available resources in your application,
    their IDs can all change. This makes these IDs unsuited to long-term identification
    of items; however, they are very useful as identifiers while the application is
    running:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 模型的下一部分是 `Category` 枚举。这将起到双重作用--当你更改应用程序中可用的资源列表时，它们的 ID 都会发生变化。这使得这些 ID 不适合长期识别项目；然而，在应用程序运行时，它们作为标识符非常有用：
- en: They are unique within the application
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们在应用程序内是唯一的
- en: They are integer types, which are very fast for comparisons
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是整数类型，在比较时非常快
- en: They can be used to directly identify user-interface components
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以直接用来识别用户界面组件
- en: 'The `Category` enum will serve as a way to bind between a long-term stable
    identifier (the enum name), and the potentially unstable (but often much faster)
    Android resource ID. Follow these quick steps to create the `Category` enum:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`Category` 枚举将作为将长期稳定的标识符（枚举名称）与可能不稳定（但通常要快得多）的 Android 资源 ID 之间绑定的一种方式。按照以下快速步骤创建
    `Category` 枚举：'
- en: Right-click on the `model` package, and select New | Java Class.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 `model` 包，然后选择 New | Java Class。
- en: Name the class `Category`.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类命名为 `Category`。
- en: Change the Kind field to Enum.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Kind 字段更改为 Enum。
- en: Click OK to create the new enum file.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 OK 创建新的枚举文件。
- en: 'Declare the enum constants, and map them to their appropriate Android resource
    IDs:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明枚举常量，并将它们映射到相应的 Android 资源 ID：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Declare the ID integer, private constructor, and getter method for the ID.
    Note the use of the `@IdRes` annotation, which indicates what should be used for
    these specific integers; attempting to pass anything other than an ID resource
    in here will result in a lint error in Android Studio:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明 ID 整数、私有构造函数和 ID 获取器方法。注意使用 `@IdRes` 注解，它指示应使用哪些特定整数；在此处尝试传递除 ID 资源以外的任何内容都将导致
    Android Studio 中出现 lint 错误：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: There are annotations similar to `@IdRes` for all of the different resource
    types available on Android. They are located in the `android.support.annotation`
    package. Use them wherever you expect an integer value to reference an Android
    resource of some type.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Android 上所有不同的资源类型，都有类似于 `@IdRes` 的注解。它们位于 `android.support.annotation` 包中。在预期整数值引用
    Android 类型资源的地方使用它们。
- en: 'Finally, create a method to look up a `Category` enum constant from its Android
    ID resource:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一个方法来从其 Android ID 资源查找 `Category` 枚举常量：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Creating the ClaimItem class
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 `ClaimItem` 类
- en: 'The **ClaimItem** is the heart of this application''s object model. Each claim
    the user collects is represented in memory as a single `ClaimItem` instance. Here
    are the steps required to build the `ClaimItem` class:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**ClaimItem** 是这个应用程序对象模型的核心。用户收集的每个索赔在内存中都被表示为一个单独的 `ClaimItem` 实例。以下是构建 `ClaimItem`
    类所需的步骤：'
- en: Right-click on the `model` package, and select New | Java Class.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 `model` 包，然后选择 New | Java Class。
- en: Name the class `ClaimItem`, and in the Interface(s) box, add `Parcelable`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类命名为 `ClaimItem`，并在接口（s）框中添加 `Parcelable`。
- en: Click OK to create the new class file.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 OK 创建新的类文件。
- en: 'Declare the fields of the `ClaimItem` type, and a `public` default constructor:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明 `ClaimItem` 类型的字段，以及一个 `public` 默认构造函数：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Use Android Studio to generate getter and setter methods for all the fields,
    except the attachments field:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Android Studio 为所有字段生成 getter 和 setter 方法，除了附件字段：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create methods to add, remove, and list the `Attachment` objects for the `ClaimItem`:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `ClaimItem` 创建添加、删除和列出 `Attachment` 对象的方法：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Implement the `Parcelable` methods for the `ClaimItem` class; again, this is
    more complex than the Android Studio generator can typically handle:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `ClaimItem` 类的 `Parcelable` 方法；这比 Android Studio 生成器通常能处理的情况要复杂：
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Excellent! With the formality of an object model out of the way, you can continue
    building the user interface. The next stage will involve building `Fragment` classes
    that will help modularize the capturing of the `ClaimItem` data.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！在对象模型的正式性处理完毕后，你可以继续构建用户界面。下一阶段将涉及构建帮助模块化 `ClaimItem` 数据捕获的 `Fragment` 类。
- en: Wrapping up the category picker
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成分类选择器
- en: The category picker you created for the `CaptureClaimActivity` is just a group
    of widgets in a card right now, and while it's one of the simplest cards to use
    on the screen, it's also one of the largest by the amount of code written for
    it. The best way to encapsulate this part of the screen is to move the layout
    that appears inside the `CardView` into a `Fragment` class.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你为 `CaptureClaimActivity` 创建的分类选择器目前只是一个卡片中的小部件组，虽然它是屏幕上使用最简单的卡片之一，但就编写的代码量而言，它也是最大的。将这部分屏幕封装起来的最佳方式是将出现在
    `CardView` 内部的布局移动到一个 `Fragment` 类中。
- en: 'However, why a `Fragment` class, and why not write another `Layout` class?
    `Fragment` classes are self-contained systems, and have their own life cycle within
    the context of their parent `Activity`. This means they can contain significantly
    more application logic, and can be reused more easily in other parts of the application.
    It''s also because in this case, we rely on the IDs of the radio buttons to know
    what has been checked by the user, which means that we can very easily start polluting
    layouts with IDs specific to this specific widget. Fragment classes don''t stop
    this from happening, but it''s expected behavior. You don''t expect ID pollution
    from `View` classes, but from a `Fragment`, it''s okay. Follow these simple steps
    to encapsulate the category picker in a new `Fragment` class:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为什么是 `Fragment` 类，而不是编写另一个 `Layout` 类？`Fragment` 类是自包含的系统，在它们的父 `Activity`
    上下文中有自己的生命周期。这意味着它们可以包含更多的应用程序逻辑，并且可以更容易地在应用程序的其他部分重用。这也因为在这种情况下，我们依赖于单选按钮的 ID
    来知道用户检查了什么，这意味着我们可以非常容易地开始用特定于这个特定小部件的 ID 污染布局。`Fragment` 类不会阻止这种情况发生，但这是一种预期行为。你不期望从
    `View` 类中污染 ID，但从 `Fragment` 类中，这是可以接受的。按照以下简单步骤将分类选择器封装到新的 `Fragment` 类中：
- en: Right-click on the `ui` package in your project and select New| Fragment | Fragment
    (Blank).
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的项目中右键单击 `ui` 包，然后选择 New| Fragment | Fragment (Blank)。
- en: Name the new `Fragment` class `CategoryPickerFragment`.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的 `Fragment` 类命名为 `CategoryPickerFragment`。
- en: 'Turn off Include fragment factory methods? and Include interface callbacks:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭 Include fragment factory 方法？和 Include 接口回调：
- en: '![](img/56299f89-cc3c-4035-a157-319351dc8804.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/56299f89-cc3c-4035-a157-319351dc8804.png)'
- en: Click on Finish to create your new `Fragment` and its layout file.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击完成以创建你的新 `Fragment` 及其布局文件。
- en: Open the new `fragment_category_picker.xml` file, and change the editor view
    to Text mode.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开新的 `fragment_category_picker.xml` 文件，并将编辑视图更改为文本模式。
- en: 'Change the root node of the layout from `FrameLayout` to `LinearLayout`, and
    make it a `vertical` orientation:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将布局的根节点从 `FrameLayout` 更改为 `LinearLayout`，并使其为 `vertical` 方向：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Remove any contents of the `LinearLayout` placed there by the Android Studio
    template.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除由 Android Studio 模板放置在 `LinearLayout` 中的任何内容。
- en: Open the `content_capture_claim.xml` layout file, and change the editor view
    to Text mode.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `content_capture_claim.xml` 布局文件，并将编辑视图更改为文本模式。
- en: Cut the contents of the `LinearLayout` containing the existing category picker,
    the entire `RadioGroup` and `TextView` used as their label.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除包含现有类别选择器的`LinearLayout`的内容，以及用作标签的整个`RadioGroup`和`TextView`。
- en: 'Paste this as the content of the `LinearLayout` in the `fragment_category_picker.xml`
    file:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容粘贴到`fragment_category_picker.xml`文件中的`LinearLayout`内容：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the `content_capture_claim.xml` layout file, you can now remove the `LinearLayout`
    for the category picker and replace it with a reference to the `Fragment` class:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`content_capture_claim.xml`布局文件中，你现在可以删除类别选择器的`LinearLayout`，并用对`Fragment`类的引用替换它：
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, open the `CategoryPickerFragment` class in Android Studio, and at the
    top of the class, declare the fields for the `RadioGroup` and `TextView` that
    you''ll use to track and update the user''s selection:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在Android Studio中打开`CategoryPickerFragment`类，并在类的顶部声明你将用于跟踪和更新用户选择的`RadioGroup`和`TextView`字段：
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now in the `onCreateView`, you''ll need to change how the `View` is inflated,
    because you need to capture the fields and set up the event listeners. Note the
    use of the `IconPickerWrapper` as the event listener:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`onCreateView`中，你需要更改`View`的填充方式，因为你需要捕获字段并设置事件监听器。注意使用`IconPickerWrapper`作为事件监听器：
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, create a simple getter and setter method to retrieve and alter state using
    the `Category` enum:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个简单的getter和setter方法来使用`Category`枚举检索和修改状态：
- en: '[PRE33]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Open the `CaptureClaimActivity` in Android Studio.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android Studio中打开`CaptureClaimActivity`。
- en: 'Change the categories field to use `CategoryPickerFragment`, instead of a `RadioGroup`:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类别字段更改为使用`CategoryPickerFragment`，而不是`RadioGroup`：
- en: '[PRE34]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the `onCreate` method, remove the code that initialized the category picker:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate`方法中，删除初始化类别选择器的代码：
- en: '[PRE35]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Use `FragmentManager` to retrieve the new `CategoryPickerFragment` from the
    layout:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`FragmentManager`从布局中检索新的`CategoryPickerFragment`：
- en: '[PRE36]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note that you're using the `getSupportFragmentManager` method, and not `getFragmentManager`.
    This is because `CategoryPickerFragment` is built on top of the support APIs and
    is backwards compatible all the way to API level 4 (Android 1.6). Android Studio
    typically prefers the support APIs when generating code as it offers a very simple
    and stable target, since your application links against a static target, and you
    are in control of which version to link against and when to upgrade. You can reuse
    `CategoryPickerFragment` anywhere in the application, just as you would a custom
    `View` implementation.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意你正在使用`getSupportFragmentManager`方法，而不是`getFragmentManager`。这是因为`CategoryPickerFragment`建立在支持API之上，并且向后兼容性一直达到API级别4（Android
    1.6）。Android Studio通常在生成代码时更喜欢支持API，因为它提供了一个非常简单且稳定的靶标，因为你的应用程序链接到一个静态靶标，并且你可以控制链接哪个版本以及何时升级。你可以在应用程序的任何地方重用`CategoryPickerFragment`，就像你会重用自定义`View`实现一样。
- en: Linking against the platform APIs (instead of the equivalent support) reduces
    backward compatibility and requires more testing since your application may behave
    slightly differently on different versions of the platform. However, platform
    versions may be slightly faster, and will result in smaller applications.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 链接平台API（而不是等效的支持）会降低向后兼容性，并需要更多的测试，因为你的应用程序可能在平台的不同版本上表现略有不同。然而，平台版本可能稍微快一些，并且将导致应用程序体积更小。
- en: Creating the Attachment Pager
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建附件翻页器
- en: Having modularized the category picker, it's time to turn your attention to
    the attachments. When you implemented the file selection, you left a `Toast` in
    place to show where the code would normally attach the selected file to the `ClaimItem`
    being captured. This next stage will be to create a `Fragment` that will encapsulate
    the previewing of the `Attachment` objects. You'll also move much of the attachment
    logic into this `Fragment`. Although the code to connect to other applications
    and request permissions is commonly placed in an `Activity` class, `Fragment`
    classes are also capable of performing the same actions, and the attachment pager
    is a perfect opportunity to show this off.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 将类别选择器模块化后，现在是时候将注意力转向附件了。在你实现了文件选择功能时，你留下了一个`Toast`来显示代码通常会将选定的文件附加到正在捕获的`ClaimItem`的位置。下一阶段将创建一个`Fragment`来封装`Attachment`对象的预览。你还将将大部分附件逻辑移动到这个`Fragment`中。尽管连接到其他应用程序和请求权限的代码通常放置在`Activity`类中，但`Fragment`类也能够执行相同的操作，附件翻页器是展示这一点的绝佳机会。
- en: 'This `Fragment` will show a pattern where the `Fragment` interacts with the
    `Activity` that it belongs to without directly sending events upward. The instinct
    of most developers when encountering a `Fragment` for the first time is to use
    the pattern in the template where the `Fragment` can send events upward to its
    `Activity`, as shown:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Fragment`将展示一个模式，其中`Fragment`与其所属的`Activity`交互，而不直接向上发送事件。大多数开发者第一次遇到`Fragment`时的本能是使用模板中的模式，其中`Fragment`可以向其`Activity`发送事件，如图所示：
- en: '![](img/159c0075-e9be-4b03-8dfc-1cbdca5ac4ed.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/159c0075-e9be-4b03-8dfc-1cbdca5ac4ed.jpg)'
- en: 'However, this is often not desirable. It''s generally a much better idea to
    push changes through the data model, and have it deliver the events to areas that
    are interested in the changes. This is part of a unidirectional event flow, and
    serves to keep the application much easier to maintain and debug, because the
    data model always represents the *authority* for all information and state within
    the application, as illustrated here:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这通常不是理想的做法。通常，通过数据模型推动更改，并将其事件传递给对更改感兴趣的区域，这是一个单向事件流的一部分，有助于使应用程序更容易维护和调试，因为数据模型始终代表应用程序中所有信息和状态的*权威*，如图所示：
- en: '>![](img/f6a7e4d3-8802-46f7-ba1e-eee6ba32b4e4.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/f6a7e4d3-8802-46f7-ba1e-eee6ba32b4e4.jpg)'
- en: Creating the Attachment preview widget
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建附件预览小部件
- en: 'The first part of the attachments will be a `View` implementation, to allow
    attachments to be previewed within the pager. This class will need an area where
    the attachment can be previewed if it''s an image, or a placeholder icon can be
    displayed if it''s a file the application cannot read. Follow these steps to create
    the new widget and it''s layout XML file:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 附件的第一部分将是一个`View`实现，允许在翻页器内预览附件。如果附件是图像，则需要一个区域来预览它；如果附件是应用程序无法读取的文件，则可以显示占位图标。按照以下步骤创建新的小部件及其布局XML文件：
- en: Right-click on the layout directory under res, and select New | Layout resource
    file.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在res下的布局目录中右键点击，然后选择New | Layout resource file。
- en: Name the new file `widget_attachment_preview`.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新文件命名为`widget_attachment_preview`。
- en: Change the Root element field to `merge`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将根元素字段更改为`merge`。
- en: Click OK to create the new layout file.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击OK创建新布局文件。
- en: 'Within the `merge` element, create an `ImageView` that can carry the preview
    of the attachment file. The `ImageView` will need a margin to automatically scale
    the image to its size on the screen (while maintaining the image''s proportions):'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`merge`元素内部，创建一个`ImageView`，它可以携带附件文件的预览。`ImageView`需要一个边距来自动调整图像大小以适应屏幕（同时保持图像比例）：
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Right-click on the drawable resource directory, and select New, Vector Asset.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在drawable资源目录上右键点击，然后选择New, Vector Asset。
- en: Using the Icon button, search for the `insert drive file` icon and select it.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用图标按钮，搜索`insert drive file`图标并选择它。
- en: Name the new resource `ic_unknown_file_type`.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新资源命名为`ic_unknown_file_type`。
- en: Click on Next and then on Finish to create the new resource.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击Next然后点击Finish创建新资源。
- en: Open the `ic_unknown_file_type.xml` file in Android Studio.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android Studio中打开`ic_unknown_file_type.xml`文件。
- en: Change the `fillColor` attribute of the path to `#FFBAB5AB`, and save and close
    the file.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将路径的`fillColor`属性更改为`#FFBAB5AB`，并保存并关闭文件。
- en: Right-click on the `widget` package in your project, and select New | Java Class.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的项目中右键点击`widget`包，然后选择New | Java Class。
- en: Name the new class `AttachmentPreview`.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新类命名为`AttachmentPreview`。
- en: Change the Superclass field to `android.support.v7.widget.CardView`.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Superclass字段更改为`android.support.v7.widget.CardView`。
- en: Click OK to create the new class.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击OK创建新类。
- en: 'Create fields to reference the `Attachment` object and the `ImageView` that
    will render its preview onto the screen:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建字段以引用`Attachment`对象和将预览渲染到屏幕上的`ImageView`：
- en: '[PRE38]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Create the standard `View` subclass constructors and an `initialize` method
    that inflates the layout XML and captures the `ImageView`:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建标准的`View`子类构造函数和一个`initialize`方法，该方法填充布局XML并捕获`ImageView`：
- en: '[PRE39]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Create a simple getter for the `Attachment` field:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`Attachment`字段创建一个简单的getter方法：
- en: '[PRE40]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Create a setter to update the `Attachment` field, and also start the update
    of the preview on-screen. You''ll also create an inner class using the `ActionCommand`
    class you wrote in [Chapter 3](75335d7f-3cda-4985-b992-965f46adc335.xhtml), *Taking
    Actions*, which will attempt to load the actual images on a background thread
    before updating the widget on the screen:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个setter来更新`Attachment`字段，并启动屏幕上预览的更新。你还会创建一个使用你在[第3章](75335d7f-3cda-4985-b992-965f46adc335.xhtml)，“执行操作”中编写的`ActionCommand`类编写的内部类，该类将尝试在更新屏幕上的小部件之前在后台线程中加载实际图像：
- en: '[PRE41]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The preceding code is a great example of using an `ActionCommand` object to
    improve the user experience. When the `Attachment` is actually specified on the
    `AttachmentPreview` widget, the onscreen preview is instantly queued, and the
    loading of the actual preview (which may take a second or two on a slower device)
    takes place in the background. This frees the main thread to continue processing
    events from the user, or start the loading of other previews that may be required.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是使用`ActionCommand`对象来提升用户体验的一个绝佳示例。当在`AttachmentPreview`小部件上实际指定了`Attachment`时，屏幕上的预览会立即排队，而实际预览的加载（在较慢的设备上可能需要一秒钟或两秒钟）则在后台进行。这使主线程可以继续处理来自用户的事件，或者开始加载可能需要的其他预览。
- en: Creating the Attachment Pager Adapter
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建附件翻页适配器
- en: 'The `ViewPager` class is a special type of Android widget called an adapter
    view (although some, such as `ViewPager`, don''t actually inherit from `AdapterView`,
    it shares much of the concepts). An `AdapterView` is used when it potentially
    needs to display more data than will fit on the screen at once, but maintain excellent
    performance. They do this by maintaining a small selection of widgets that will
    be displayed on the screen, and an `Adapter` that will populate the widgets with
    the data to display. Examples of `Adapter` widgets are as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewPager`类是Android中一种特殊类型的widget，称为适配器视图（尽管一些，如`ViewPager`实际上并不继承自`AdapterView`，但它共享许多概念）。当可能需要显示比一次屏幕能容纳的数据更多时，会使用`AdapterView`，但它们会保持出色的性能。它们通过维护将在屏幕上显示的小部件的小选择，以及一个将数据填充到小部件中的`Adapter`来实现这一点。以下是一些`Adapter`小部件的示例：'
- en: '`ListView`: A simple vertical scrolling list of similar items, such as phone
    contacts'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ListView`：一个简单的垂直滚动类似项目列表，例如电话联系人'
- en: '`GridView`: A vertical scrolling grid of similar items, such as photos'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GridView`：一个垂直滚动的类似项目网格，例如照片'
- en: '`StackView`: A three-dimensional stack of items great for presenting media'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StackView`：一个三维的项目堆叠，非常适合展示媒体'
- en: '`RecyclerView`: A powerful all-purpose pooling view, originally added to replace
    `ListView`'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RecyclerView`：一个功能强大的通用池化视图，最初被添加来替代`ListView`'
- en: 'If you wanted to display a scrolling list of images, for example, you would
    use a `RecyclerView` and provide it with an `Adapter` that could load previews
    of image files into `ImageView` widgets (much the same way as the `AttachmentPreview`
    class does):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要显示一个滚动图像列表，例如，你会使用`RecyclerView`并为其提供一个`Adapter`，该`Adapter`可以将图像文件的预览加载到`ImageView`小部件中（与`AttachmentPreview`类所做的方式非常相似）：
- en: '![](img/26b634a8-dfa9-4b58-95ff-c18b6b7b25d0.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/26b634a8-dfa9-4b58-95ff-c18b6b7b25d0.jpg)'
- en: '`ViewPager` is a little different from the `AdapterView` classes described
    here; all of them only maintain as many widgets as what can fit on the screen
    at once. The normal `AdapterView` classes and `RecyclerView` all *recycle* their
    pool of widgets. When one widget is scrolled off the screen, it''s resized, populated
    with new data, and scrolled into view looking like a new widget. `ViewPager` doesn''t
    stop you from doing this, but it doesn''t do it for you. This is because `ViewPager`
    often contains large and complex tab layouts, which would be too expensive to
    try and recycle (or simply don''t repeat at all, in which case, recycling is useless).'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewPager`与这里描述的`AdapterView`类略有不同；所有这些类一次只能维护屏幕上能容纳的那么多小部件。正常的`AdapterView`类和`RecyclerView`都会*回收*它们的池化小部件。当一个小部件被滚动出屏幕时，它会调整大小，用新数据填充，并滚动到视图中，看起来像一个新的小部件。`ViewPager`不会阻止你这样做，但它也不会为你这样做。这是因为`ViewPager`通常包含大型且复杂的标签布局，尝试回收（或者根本不重复，在这种情况下，回收是无效的）会非常昂贵。'
- en: 'For this application, the user is unlikely to have many attachments, so you
    can get away with simply creating an `AttachmentPreview` instance for each of
    the attachments when they are displayed, which keeps the steps for implementing
    the `Adapter` much simpler and to the point:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个应用程序，用户不太可能有多个附件，因此你可以在显示附件时为每个附件简单地创建一个`AttachmentPreview`实例，这会使实现`Adapter`的步骤更加简单和直接：
- en: Right-click on your default package (that is, `com.packtpub.claim`) and select
    New | Java Class.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击您的默认包（即 `com.packtpub.claim`），然后选择新建 | Java 类。
- en: Name the new class `ui.attachments.AttachmentPreviewAdapter`.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新类命名为 `ui.attachments.AttachmentPreviewAdapter`。
- en: Make its Superclass `android.support.v4.view.PagerAdapter`.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其超类设置为 `android.support.v4.view.PagerAdapter`。
- en: Click OK to create the new class.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“确定”以创建新类。
- en: 'This class will need a `List` of the `Attachment` objects it''s expected to
    translate into widgets for previewing, and it''ll need a setter to change what
    will be displayed:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个类需要一个 `List` 来存储它预期将其转换为预览小部件的 `Attachment` 对象，并且需要一个设置器来更改将要显示的内容：
- en: '[PRE42]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: After changing the `List` of attachments, `AttachmentPreviewAdapter` is wrapping;
    it invokes `notifyDataSetChanged()`, which informs the `ViewPager` it's attached
    to things that have changed, and some rerendering may be required. This sort of
    functionality can be found in all the `Adapter` classes, and allows for the reactive
    behavior that users expect from their apps. When a new email arrives, it can just
    appear on the list they're looking at. As a developer, this system is nice because
    the events can bubble up from the data model rather than being tied to the user
    interface.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在更改附件的 `List` 之后，`AttachmentPreviewAdapter` 会进行包装；它调用 `notifyDataSetChanged()`，通知它附加的
    `ViewPager` 有变化，可能需要进行一些重新渲染。这种功能可以在所有的 `Adapter` 类中找到，并允许用户从他们的应用中期望的响应式行为。当一封新邮件到达时，它可以直接出现在他们正在查看的列表中。作为一个开发者，这个系统很棒，因为事件可以从数据模型中冒泡出来，而不是绑定到用户界面。
- en: 'The `ViewPager` maintains separate lists of the widgets used to display data
    on the screen and the object model being displayed. The `ViewPager` creates the
    widgets by invoking `instantiateItem` on the `PagerAdapter` object, which is expected
    to add the widget to the `ViewPager` and return the data model object that it''s
    displaying:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ViewPager` 维护着用于在屏幕上显示数据的 widgets 和正在显示的对象模型之间的单独列表。`ViewPager` 通过在 `PagerAdapter`
    对象上调用 `instantiateItem` 来创建 widgets，预期它会将 widget 添加到 `ViewPager` 并返回它所显示的数据模型对象：'
- en: '[PRE43]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `ViewPager` may also ask `PagerAdapter` to remove the widgets that are
    not visible to the user. This is typically when a view is not visible, and cannot
    be directly scrolled into view by the user (that is, it''s not directly to the
    left or right of the current view). The position argument passed to `destroyItem`
    is the position in the data model, not the index of the widget within the `ViewPager`,
    so you need a way to figure out which widget in the `ViewPager` actually needs
    to be removed. Here, we do it by simply iterating over all the child widgets in
    the `ViewPager` since there will never be many of them:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ViewPager` 也可能要求 `PagerAdapter` 移除用户看不到的小部件。这通常发生在视图不可见时，用户无法直接将其滚动到视图中（也就是说，它不是直接在当前视图的左侧或右侧）。传递给
    `destroyItem` 的位置参数是数据模型中的位置，而不是小部件在 `ViewPager` 中的索引，因此你需要一种方法来确定 `ViewPager`
    中哪个小部件实际上需要被移除。在这里，我们通过简单地遍历 `ViewPager` 中的所有子小部件来实现，因为它们永远不会很多：'
- en: '[PRE44]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, the `ViewPager` needs a way to know which widget child of its is associated
    with which part of the data model; this is really easy for you in this class,
    because the `AttachmentPreview` class directly references the `Attachment` objects:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`ViewPager` 需要一种方式来知道其哪个小部件子类与数据模型的哪个部分相关联；在这个类中，这对你来说非常简单，因为 `AttachmentPreview`
    类直接引用了 `Attachment` 对象：
- en: '[PRE45]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This implementation of `PagerAdapter` is very naive and simple, but shows more
    of how the `Adapter` views work. They track their onscreen views completely independently
    of the dataset, and the order in which the child widgets appear on the screen
    doesn't have any direct relationship to the order in which the data model is presented.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `PagerAdapter` 的实现非常简单，但展示了 `Adapter` 视图是如何工作的。它们完全独立于数据集跟踪其屏幕视图，子小部件在屏幕上出现的顺序与数据模型展示的顺序没有直接关系。
- en: The next step is to create another `ActionCommand` class that will create the
    `Attachment` objects when the user selects an external file to attach to the claims.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建另一个 `ActionCommand` 类，当用户选择一个外部文件附加到索赔时，该类将创建 `Attachment` 对象。
- en: Creating the Create Attachment Command
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建创建附件命令
- en: 'When the user selects a file to attach to the claim, you''ll need to ensure
    that your application can always access the file. This means copying the file
    into your application''s private space, which can take a second or two. You also
    need to know what type of file it is, otherwise your application won''t know if
    it can render a preview of the attachment. For both of these, you''ll need an
    `ActionCommand` implementation that does the work:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择一个文件附加到索赔时，您需要确保您的应用程序始终可以访问该文件。这意味着将文件复制到应用程序的私有空间，这可能需要一秒钟或两秒钟。您还需要知道文件类型，否则您的应用程序将不知道是否可以渲染附件的预览。对于这两者，您都需要一个执行工作的
    `ActionCommand` 实现：
- en: Right-click on the `model` package, and select New | Java Class.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 `model` 包，选择 New | Java Class。
- en: Name the new class `commands.CreateAttachmentCommand`.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新类命名为 `commands.CreateAttachmentCommand`。
- en: Make the class Abstract.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使该类成为抽象类。
- en: Click OK to create the new package and class.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 OK 创建新的包和类。
- en: 'Change the class declaration to extend `ActionCommand<Uri, Attachment>`:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类声明改为扩展 `ActionCommand<Uri, Attachment>`：
- en: '[PRE46]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Declare a directory to write the local files to, and a `ContentResolver` that
    can be used to read the files that the user selects:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个目录用于写入本地文件，以及一个可以用于读取用户选择的文件的 `ContentResolver`：
- en: '[PRE47]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: A `ContentResolver` allows applications to read each other's data, if they choose
    to expose it. In this case, you'll be using `content://` URIs that are commonly
    used in Android when data needs to be exposed safely between applications. A `ContentResolver`
    counterpart is a `ContentProvider` that exposes the data for other applications
    to access.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContentResolver` 允许应用程序在它们选择公开数据的情况下读取彼此的数据。在这种情况下，您将使用在 Android 中数据需要在应用程序之间安全公开时常用的
    `content://` URI。`ContentResolver` 的对应物是 `ContentProvider`，它公开数据供其他应用程序访问。'
- en: 'Create a simple utility method to copy the file from a `Uri` into a new, randomly
    named file. The file is randomly named so that no two files are likely to collide
    in name:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个简单的实用方法，将文件从 `Uri` 复制到一个新命名的文件中。文件是随机命名的，这样就不太可能有两个文件在名称上发生冲突：
- en: '[PRE48]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Override the `onBackground` method to copy the file using the preceding utility
    method:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖 `onBackground` 方法，使用前面的实用方法来复制文件：
- en: '[PRE49]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, check the type of the file your command just created, and if it looks
    like an image, ensure that you can read it before returning. This avoids the application
    having to do the same check every time it wants to preview the attachment. We
    check whether the image is readable by attempting to read it using the `BitmapFactory`
    class:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，检查您刚刚创建的文件类型，如果它看起来像一张图片，确保在返回之前您能够读取它。这避免了应用程序每次想要预览附件时都需要进行相同的检查。我们通过尝试使用
    `BitmapFactory` 类读取图片来检查图片是否可读：
- en: '[PRE50]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This simple command class doesn't have any foreground work, and has been left
    abstract. Instead, it assumes that the work of handling the `Attachment` will
    be done elsewhere. The next part is the `AttachmentPagerFragment` class that will
    handle the `Attachment` objects created here by attaching them to the `ClaimItem`,
    and notifying the `AttachmentPreviewAdapter` that there is a new attachment to
    render.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的命令类没有任何前台工作，并且被保留为抽象类。相反，它假设处理 `Attachment` 的工作将在其他地方完成。下一部分是 `AttachmentPagerFragment`
    类，它将处理在这里创建的 `Attachment` 对象，通过将它们附加到 `ClaimItem` 上，并通知 `AttachmentPreviewAdapter`
    有新的附件需要渲染。
- en: Creating the Attachment Pager Fragment
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建附件页面片段
- en: 'Now that you''ve assembled all of the parts required for the attachments to
    be created and previewed, you need to actually populate the area where they will
    be previewed. The `AttachmentPagerFragment` class will not only serve to encapsulate
    the `ViewPager` used to preview the attachments, but will also encapsulate the
    logic required to add new attachments to the user''s claim. This will be done
    by moving the `onRequestPermissionsResult` and `onActivityResult` from the `CaptureClaimActivity`
    to the new `AttachmentPagerFragment` class. This process will require moving some
    of the code out of `CaptureClaimActivity` and into the `Fragment` class, so you''ll
    be in for some cutting and pasting. Let''s get started:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经组装好了创建和预览附件所需的所有部分，您需要实际填充它们将被预览的区域。`AttachmentPagerFragment` 类不仅将用于封装预览附件所用的
    `ViewPager`，还将封装添加新附件到用户索赔所需的逻辑。这将通过将 `onRequestPermissionsResult` 和 `onActivityResult`
    从 `CaptureClaimActivity` 移动到新的 `AttachmentPagerFragment` 类来实现。这个过程将需要将一些代码从 `CaptureClaimActivity`
    移动到 `Fragment` 类中，因此您将需要进行一些剪切和粘贴。让我们开始吧：
- en: Create a new layout resource named `fragment_attachment_pager`.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`fragment_attachment_pager`的新布局资源。
- en: Open the `content_capture_claim.xml` layout file.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`content_capture_claim.xml`布局文件。
- en: 'Cut and paste the `ViewPager` from the bottom of `content_capture_claim.xml`
    into the `fragment_attachment_pager` layout file, overwriting all the content
    of the file. You''ll need to define the XML namespaces (the `xmlns` attributes)
    on the `ViewPager` element, so that the `fragment_attachment_pager.xml` file reads
    like this:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`content_capture_claim.xml`文件底部的`ViewPager`剪切并粘贴到`fragment_attachment_pager`布局文件中，覆盖文件中的所有内容。您需要在`ViewPager`元素上定义XML命名空间（`xmlns`属性），以便`fragment_attachment_pager.xml`文件看起来像这样：
- en: '[PRE51]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Create a New, Java Class in the `ui.attachments` package.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ui.attachments`包中创建一个新的Java类。
- en: Name the class `AttachmentPagerFragment`.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类命名为`AttachmentPagerFragment`。
- en: Make its Superclass `android.support.v4.app.Fragment`.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其超类设置为`android.support.v4.app.Fragment`。
- en: Open the `CaptureClaimActivity` class.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`CaptureClaimActivity`类。
- en: 'Cut the `REQUEST_ATTACH_FILE` and `REQUEST_ATTACH_PERMISSION` constants from
    the `CaptureClaimActivity` and paste them in `AttachmentPagerFragment`:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`CaptureClaimActivity`中剪切`REQUEST_ATTACH_FILE`和`REQUEST_ATTACH_PERMISSION`常量，并将它们粘贴到`AttachmentPagerFragment`中：
- en: '[PRE52]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Create an instance of `AttachmentPagerAdapter` to help with rendering the attachment
    previews. As the `AttachmentPagerAdapter` can handle its list of `Attachment`
    object changing completely, you''ll only ever need one in each `AttachmentPagerFragment`:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`AttachmentPagerAdapter`的实例，以帮助渲染附件预览。由于`AttachmentPagerAdapter`可以完全处理其`Attachment`对象列表的变化，因此每个`AttachmentPagerFragment`中只需要一个：
- en: '[PRE53]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Create fields for the `ActionCommand` you''ll use to attach the files, and
    another to hold a reference to the `ViewPager` object:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您将要用来附加文件的`ActionCommand`创建字段，并另一个用于持有`ViewPager`对象的引用：
- en: '[PRE54]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Your `AttachmentPagerFragment` needs a reference to the `ClaimItem` it is previewing
    `Attachment` for. This will also allow it to add new `Attachment` objects to the
    claim without invoking its `Activity` to do so. The `Fragment` will also expose
    a method that can be called to notify it that the list of attachments on the `ClaimItem`
    has changed. This can be invoked by the `ClaimItem` itself later on, or through
    an event-bus:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的`AttachmentPagerFragment`需要对其预览的`Attachment`的`ClaimItem`的引用。这将允许它在不需要调用其`Activity`的情况下向索赔添加新的`Attachment`对象。`Fragment`还将公开一个可以被调用的方法，以通知它`ClaimItem`上的附件列表已更改。这可以通过`ClaimItem`本身稍后调用，或通过事件总线进行调用。
- en: '[PRE55]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Override the `Fragment` `onCreate` method. This looks just like the `onCreate`
    method of an `Activity`, and is called after your `Fragment` has been attached
    to its context (in this case, to its `Activity` object). `AttachmentPagerFragment`
    will use `onCreate` to instantiate the `attachFileCommand` for later use, and
    it''ll do so using an anonymous inner class, inheriting from the `CreateAttachmentCommand`
    class that you just wrote:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`Fragment`的`onCreate`方法。这看起来就像`Activity`的`onCreate`方法一样，在您的`Fragment`被附加到其上下文（在这种情况下，是`Activity`对象）之后被调用。`AttachmentPagerFragment`将使用`onCreate`来实例化用于后续使用的`attachFileCommand`，它将使用一个匿名内部类来实现，该类继承自您刚刚编写的`CreateAttachmentCommand`类：
- en: '[PRE56]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In any task that takes place in the background and then jumps back to the foreground,
    it's a good idea to check your context before running any code. In the preceding
    snippet, this takes the form of the `claimItem != null` check. If the command
    was started, and the user left the `Activity` (or similar), the foreground code
    could trigger errors by trying to alter variables that are invalid or `null`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何在后台执行然后跳回前台的任务中，在运行任何代码之前检查上下文是一个好主意。在前面的代码片段中，这表现为`claimItem != null`检查。如果命令已启动，并且用户离开了`Activity`（或类似情况），前台代码可能会通过尝试更改无效或`null`的变量来触发错误。
- en: 'When the `Fragment` is released completely (with no chance of a later restart),
    its `onDestroy` method is called. Use this method to release the `claimItem`,
    stopping any background tasks from modifying it when they get back to the foreground:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`Fragment`完全释放（没有后续重启的机会）时，其`onDestroy`方法会被调用。使用此方法来释放`claimItem`，防止后台任务在它们返回前台时修改它：
- en: '[PRE57]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Just like the `CategoryPickerFragment` you wrote earlier, `AttachmentPagerFragment`
    needs a `View` that will display when it''s inflated into a layout XML. In this
    case, you also need to adjust the `ViewPager` slightly, as the page margin is
    not exposed as an XML attribute:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像您之前编写的`CategoryPickerFragment`一样，`AttachmentPagerFragment`需要一个在将其填充到布局XML时将显示的`View`。在这种情况下，您还需要稍微调整`ViewPager`，因为页面边距不是作为XML属性公开的：
- en: '[PRE58]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, cut and paste the `onAttachClick` method from `CaptureClaimActivity` into
    `AttachmentPagerFragment`. This will immediately cause errors, because `onAttachClick`
    uses the fact that an `Activity` is also a `Context`; so, `ContextCompat.checkSelfPermission`
    can use the `CaptureClaimAcitvity` as the `Context` to check. `Fragment` doesn''t
    inherit from `Context`, but it does expose the `getContext()` and `getActivity()`
    methods to retrieve the environment that it''s attached to:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将 `CaptureClaimActivity` 中的 `onAttachClick` 方法复制并粘贴到 `AttachmentPagerFragment`
    中。这将立即引发错误，因为 `onAttachClick` 使用了 `Activity` 也是一个 `Context` 的事实；因此，`ContextCompat.checkSelfPermission`
    可以使用 `CaptureClaimAcitvity` 作为 `Context` 来检查。`Fragment` 不继承自 `Context`，但它确实暴露了
    `getContext()` 和 `getActivity()` 方法来检索它附加的环境：
- en: '[PRE59]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Now cut and paste the `onRequestPermissionsResult`, `onAttachFileResult`, and
    `onActivityResult` methods over as well. These should copy over without any errors.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，也将 `onRequestPermissionsResult`、`onAttachFileResult` 和 `onActivityResult`
    方法复制粘贴过来。这些应该没有错误地复制过来。
- en: 'In the `onAttachFileResult` method, you can now remove the `Toast` you put
    in as a placeholder. Instead, invoke the `attachFileCommand` with the selected
    file; this will automatically result in the previews also being updated:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onAttachFileResult` 方法中，你现在可以移除作为占位符添加的 `Toast`。相反，使用所选文件调用 `attachFileCommand`；这将自动更新预览：
- en: '[PRE60]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In the `content_capture_claim.xml` layout file, include the new `AttachmentPagerFragment`
    where the `ViewPager` used to be:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `content_capture_claim.xml` 布局文件中，包括新的 `AttachmentPagerFragment`，它原本是 `ViewPager`
    的位置：
- en: '[PRE61]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In the `CaptureClaimActivity`, create a new field for the `AttachmentPagerFragment`,
    and in `onCreate`, capture the field from the `FragmentManager`:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `CaptureClaimActivity` 中，为 `AttachmentPagerFragment` 创建一个新的字段，并在 `onCreate`
    中从 `FragmentManager` 捕获该字段：
- en: '[PRE62]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Finally, change the `onClick` method in `CaptureClaimActivity` to invoke `onAttachClick`
    on the `AttachmentPagerFragment`:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将 `CaptureClaimActivity` 中的 `onClick` 方法更改为在 `AttachmentPagerFragment` 上调用
    `onAttachClick`：
- en: '[PRE63]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `AttachmentPagerFragment` is a multipurpose `Fragment`. Although it has
    all the logic required to attach files to a `ClaimItem`, it doesn't attempt to
    hook them up to any event listeners itself. As a result, you can easily use it
    as a read-only preview of attachments if (for example) the current user was reviewing
    someone else's travel expenses (in which case, they shouldn't be editing the data).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`AttachmentPagerFragment` 是一个多功能的 `Fragment`。尽管它具有将文件附加到 `ClaimItem` 所需的所有逻辑，但它并不尝试将其与任何事件监听器连接起来。因此，你可以轻松地将其用作只读预览附件，例如，如果当前用户正在审查他人的差旅费用（在这种情况下，他们不应该编辑数据）。'
- en: It's always a good idea to consider how a `Fragment` might be reused in different
    situations, and to rather push data and events down into them rather than having
    them making call upward to their `Activity` to know what should be done (which
    forces every `Activity` wanting to use the `Fragment` to provide that information).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 总是考虑一个 `Fragment` 在不同情况下可能如何被重用是个好主意，并且应该将数据和事件推入它们，而不是让它们向上调用 `Activity` 来知道应该做什么（这迫使每个想要使用
    `Fragment` 的 `Activity` 都必须提供这些信息）。
- en: Capturing the ClaimItem data
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获 ClaimItem 数据
- en: 'While you''ve linked the new `Fragment` classes to the `CaptureClaimAcitvity`,
    things aren''t quite finished yet. The `CaptureClaimActivity` doesn''t actually
    have a `ClaimItem` to capture and modify. For this, you''ll not only need to hold
    a reference to a `ClaimItem` in the `CaptureClaimActivity`, you''ll need to ensure
    that it is saved and restored through life cycle changes for the `Activity` as
    well. Fortunately, your model is all `Parcelable`, which keeps this easy. It''s
    time to capture a `ClaimItem`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你已经将新的 `Fragment` 类链接到 `CaptureClaimAcitvity`，但事情还没有完全完成。`CaptureClaimActivity`
    实际上没有要捕获和修改的 `ClaimItem`。为此，你不仅需要在 `CaptureClaimActivity` 中保留对 `ClaimItem` 的引用，还需要确保它在
    `Activity` 的生命周期变化中也被保存和恢复。幸运的是，你的模型都是 `Parcelable`，这使得这变得容易。现在是捕获 `ClaimItem`
    的时候了：
- en: Open the `CaptureClaimActivity` class.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `CaptureClaimActivity` 类。
- en: 'First, you''ll need a way that a `ClaimItem` can be passed into the `CaptureClaimActivity`
    for editing. To keep this simple and flexible, you''ll allow them to be passed
    as an "extra" field on the `Intent`. When you use `extras` in an `Intent`, it''s
    a good idea to expose the name as a public constant so that they can be accessed
    by outside classes when creating the `Intent` objects:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你需要一种方法可以将 `ClaimItem` 传递到 `CaptureClaimActivity` 以进行编辑。为了保持简单和灵活，你将允许它们作为
    "extra" 字段在 `Intent` 中传递。当你在 `Intent` 中使用 `extras` 时，将名称公开为公共常量是个好主意，这样它们就可以在外部类创建
    `Intent` 对象时访问：
- en: '[PRE64]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'You''ll also need to save and restore the `ClaimItem` while it''s being edited,
    and for this, you''ll also need a key for the `Bundle`:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑 `ClaimItem` 的过程中，你还需要保存和恢复 `ClaimItem`，为此，你还需要一个 `Bundle` 的键：
- en: '[PRE65]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Then, create a `private` field to reference the `ClaimItem` being edited, and
    you''ll also need to reference all the inputs and `Fragment` objects on the screen;
    `CaptureClaimActivity` should have `private` fields looking like this:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个 `private` 字段来引用正在编辑的 `ClaimItem`，你还需要引用屏幕上的所有输入和 `Fragment` 对象；`CaptureClaimActivity`
    应该有类似这样的 `private` 字段：
- en: '[PRE66]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In the `onCreate` method, ensure that you capture all the preceding fields
    after the call to `setContentView`:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onCreate` 方法中，确保在调用 `setContentView` 之后捕获所有前面的字段：
- en: '[PRE67]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Then, you''ll need to check whether a `ClaimItem` has been passed in, either
    in the `savedInstanceState` `Bundle` (which will be populated if the `Activity`
    is being restarted due to a configuration change), or is being passed as an extra
    parameter on the `Intent` (a bit like a constructor argument):'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你需要检查是否有一个 `ClaimItem` 被传递进来，无论是通过 `savedInstanceState` `Bundle`（如果 `Activity`
    由于配置更改而重新启动，它将被填充），还是作为 `Intent` 上的一个额外参数传递（有点像构造函数参数）：
- en: '[PRE68]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'If a `ClaimItem` wasn''t passed in through either of these mechanisms, you''ll
    want to create a new, empty `ClaimItem` to be edited by the user. On the other
    hand, if one was passed in, you''ll need to populate the user interface with its
    data:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果通过这些机制中的任何一个都没有传递 `ClaimItem`，你将想要创建一个新的、空的 `ClaimItem` 以供用户编辑。另一方面，如果已经传递了一个，你需要用其数据填充用户界面：
- en: '[PRE69]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now, write a `utility` method to copy the data from the user interface widgets
    back into the `ClaimItem` object:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编写一个 `utility` 方法，将用户界面小部件中的数据复制回 `ClaimItem` 对象：
- en: '[PRE70]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'When the `Activity` is shutdown in ways that can result in it being restarted
    at a later time (and as a new instance), the `onSaveInstanceState` method is invoked
    with a `Bundle` where your `Activity` can save any state it needs to restore later
    (in this case, it''ll be the `ClaimItem` being edited). This will happen if your
    `Activity` is in the background and the OS needs to reclaim memory, or if the
    `Activity` restarts due to a configuration change (such as the user changing between
    the portrait and landscape modes). This is where you set up the contents of the
    `Bundle` that gets passed into `onCreate`:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 `Activity` 以可能导致稍后重新启动的方式关闭时（作为一个新实例），`onSaveInstanceState` 方法会调用一个 `Bundle`，其中你的
    `Activity` 可以保存任何需要稍后恢复的状态（在这种情况下，它将是正在编辑的 `ClaimItem`）。这会在你的 `Activity` 处于后台且操作系统需要回收内存时发生，或者如果
    `Activity` 由于配置更改（如用户在纵向和横向模式之间切换）而重新启动。这就是你设置传递到 `onCreate` 的 `Bundle` 内容的地方：
- en: '[PRE71]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We also want to ensure that when the `CaptureClaimActivity` is closed, it returns
    the edited `ClaimItem` to the `Activity` that started it. This can be done by
    overloading the `finish()` method, which is invoked to close an `Activity`:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还希望确保当 `CaptureClaimActivity` 关闭时，它将编辑后的 `ClaimItem` 返回到启动它的 `Activity`。这可以通过重载
    `finish()` 方法来实现，该方法被调用以关闭 `Activity`：
- en: '[PRE72]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '`CaptureClaimActivity` will always return a `ClaimItem` object; there is no
    notion of saving the `ClaimItem` or canceling its creation (although a calling
    `Activity` may choose to ignore the `ClaimItem` if it''s empty). The idea is to
    assume that the user knows what they are doing, and rather offer them a way to
    undo their changes once they''ve been made. This is much less disruptive to the
    user than always asking them "are you sure" questions.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`CaptureClaimActivity` 总是返回一个 `ClaimItem` 对象；没有保存 `ClaimItem` 或取消其创建的概念（尽管调用
    `Activity` 可能会选择忽略空的 `ClaimItem`）。想法是假设用户知道他们在做什么，并且提供一种方法，一旦他们做出更改，就可以撤销更改。这比总是询问他们“你确定”要少得多干扰。'
- en: 'Finally, it''s important that we give the user a visual method to exit the
    screen without using the Android back button. We''ll do this by putting a *back*
    navigation arrow on the `Toolbar`. First, write a handler that listens for the
    *home* button being selected:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们还需要确保用户有一个视觉方法可以退出屏幕，而不用按 Android 返回按钮。我们将通过在 `Toolbar` 上放置一个 *返回* 导航箭头来做到这一点。首先，编写一个处理程序，监听
    *主页* 按钮被选中：
- en: '[PRE73]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Now, right-click on the drawable resource directory and choose New| Vector Asset.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在可绘制资源目录上右键单击并选择“新建|矢量资产”。
- en: Using the Icon selector, search for `arrow back`.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用图标选择器，搜索 `arrow back`。
- en: Name the new Icon `ic_arrow_back_white_24dp`.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的图标命名为 `ic_arrow_back_white_24dp`。
- en: Click on Next and then on Finish to complete the wizard and create the new asset.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“下一步”然后点击“完成”以完成向导并创建新的资产。
- en: Open the `ic_arrow_back_white_24dp.xml` resource file.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`ic_arrow_back_white_24dp.xml`资源文件。
- en: 'Change the path `android:fillColor` attribute to white:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将路径`android:fillColor`属性更改为白色：
- en: '[PRE74]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Open the `activity_capture_claim.xml` layout resource in Design mode.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设计模式下打开`activity_capture_claim.xml`布局资源。
- en: Select the toolbar in the Component Tree panel:![](img/caab850f-21b9-4f23-ad79-e530047331a2.png)
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件树面板中选择工具栏！[](img/caab850f-21b9-4f23-ad79-e530047331a2.png)
- en: In the Attributes panel, toggle to the View all attributes view.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在属性面板中，切换到查看所有属性视图。
- en: Search for navigationIcon, and use the resource selector to pick the `ic_arrow_back_white_24dp`
    icon resource.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索`navigationIcon`，并使用资源选择器选择`ic_arrow_back_white_24dp`图标资源。
- en: If you run the application now, you'll see that you can capture attachments
    for a claim, and when the device is rotated, or you navigate away using the home
    button, any data you've changed will remain the same when you return to the application.
    It's always important to consider what state you will need to maintain when navigating
    away from an `Activity`, as the `Activity` itself may need to be reclaimed.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行应用程序，你会看到你可以捕获索赔的附件，并且当设备旋转，或者你使用主页按钮导航离开时，当你返回到应用程序时，你更改的任何数据都将保持不变。在导航离开`Activity`时始终考虑你需要维护什么状态是很重要的，因为`Activity`本身可能需要被回收。
- en: It's also a good idea to separate the state of an `Activity` from the state
    of the application. While an `Activity` is busy editing a record, that record's
    data should remain encapsulated within the `Activity`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Activity`的状态与应用程序的状态分开也是一个好主意。当一个`Activity`忙于编辑记录时，该记录的数据应该封装在`Activity`内部。
- en: Try it yourself
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 试试你自己
- en: You've isolated the category picker and the attachment logic into `Fragment`
    classes in this chapter; now try writing a Fragment to encapsulate the contents
    of the first `CardView` on the screen. Remember to rather push the `ClaimItem`
    down into the `Fragment` instead of having the `Fragment` push the change events
    up to the `Activity`. Name the new `Fragment` class `CaptureClaimDetailsFragment`
    and name its layout resource `fragment_capture_claim_details.xml`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本章中将类别选择器和附件逻辑隔离到`Fragment`类中；现在尝试编写一个`Fragment`来封装屏幕上第一个`CardView`的内容。记住，最好是把`ClaimItem`推入`Fragment`而不是让`Fragment`将更改事件推送到`Activity`。将新的`Fragment`类命名为`CaptureClaimDetailsFragment`，并将其布局资源命名为`fragment_capture_claim_details.xml`。
- en: You can also try pushing the logic to change the `Category` of the `ClaimItem`
    down into the `CategoryPickerFragment` in a way similar to how the `AttachmentPagerFragment`
    automatically adds new `Attachments` to the `ClaimItem`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以尝试将逻辑推入`CategoryPickerFragment`以更改`ClaimItem`的`Category`，方式类似于`AttachmentPagerFragment`自动向`ClaimItem`添加新的`Attachments`。
- en: Test your knowledge
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: When developing a layout subclass, which of the following options is the best?
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开发布局子类时，以下哪个选项是最好的？
- en: Programmatically instantiating its child widgets
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以编程方式实例化其子小部件
- en: Only having ID attributes in nested child widgets
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅在嵌套子小部件中拥有ID属性
- en: Avoiding assigning ID attributes to child widgets
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免将ID属性分配给子小部件
- en: Which of these applies to the `Bundle` passed at an `Activity` in `onCreate`?
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个适用于在`onCreate`中传递给`Activity`的`Bundle`？
- en: It is populated in the `onSaveInstanceState` method
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在`onSaveInstanceState`方法中被填充
- en: It is populated automatically by the platform
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它由平台自动填充
- en: It is never null
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它永远不会为null
- en: When the data for an `Adapter` changes, which of the mentioned happens?
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`Adapter`的数据发生变化时，以下哪个情况会发生？
- en: It will be detected by the `View` automatically
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将被`View`自动检测
- en: It should be replaced by a new `Adapter` to reflect the changes
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该被一个新的`Adapter`替换以反映变化
- en: It should notify any attached listeners
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该通知任何附加的监听器
- en: Fragments and `View` classes should meet which of the following condition?
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Fragments`和`View`类应该满足以下哪个条件？'
- en: They should have their data and state pushed into them from the `Activity`
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们应该从`Activity`中推入它们的数据和状态
- en: They should expose listener interfaces that their `Activity` implements to receive
    events
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们应该暴露它们的`Activity`实现的监听器接口以接收事件
- en: They should directly call event methods on their `Activity` by casting it to
    the correct class
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们应该通过将其转换为正确的类直接在它们的`Activity`上调用事件方法
- en: Summary
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned some of the practical techniques for breaking your
    user interface and application into modular components that can be reused. It's
    always a good idea to start with the finished user interface and break it up,
    preferably from the mockup stage. It's also good to identify where some parts
    of the system can serve multiple roles, for example, being both a read-only display
    and an editor. It's also a good idea to wrap components within other components,
    even if it's just conceptually. Keeping certain types of event handlers as their
    own modules makes them reusable over screens that don't share exactly the same
    widgets, but need to reuse the same logic.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了一些将用户界面和应用程序分解成可重用模块组件的实用技术。始终从完成后的用户界面开始，并对其进行拆分是一个好主意，最好是从小样阶段开始。识别系统中某些部分可以扮演多个角色也很好，例如，既是只读显示又是编辑器。将组件包装在其他组件中也是一个好主意，即使只是从概念上讲。将某些类型的事件处理器作为它们自己的模块来保持，使得它们可以在不共享完全相同的小部件但需要重用相同逻辑的屏幕上重用。
- en: When building user interfaces, it's a good idea to use an `Activity` to just
    wrap a collection of `Fragment` rather than nesting the screen logic in the `Activity`.
    This will allow the `Fragment` to take on specific responsibilities (such as attachments),
    making them more reusable elsewhere in your application. It also allows you far
    more flexibility when providing different layouts for different screen sizes.
    Devices with large screens might actually have more `Fragment` on the screen than
    smaller devices.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建用户界面时，使用`Activity`仅封装一组`Fragment`而不是在`Activity`中嵌套屏幕逻辑是一个好主意。这将允许`Fragment`承担特定的责任（例如附件），使它们在应用程序的其他地方更具可重用性。这也使得为不同屏幕尺寸提供不同布局时具有更大的灵活性。具有大屏幕的设备实际上可能比小屏幕设备在屏幕上拥有更多的`Fragment`。
- en: As a general best practice, always try and contain data and state by pushing
    it downward (as you do when you pass parameters to a method). This avoids `View`
    classes and `Fragment` from needing to be placed within specific parts of your
    application, just like a method doesn't need to know where it is being invoked
    from to do its job. This approach makes it much easier to move parts of the application
    around later on.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项通用的最佳实践，始终尝试通过向下推送数据状态（就像你向方法传递参数时那样）来包含数据和状态。这避免了`View`类和`Fragment`需要放置在应用程序的特定部分，就像方法不需要知道它从哪里被调用以完成其工作一样。这种方法使得以后移动应用程序的各个部分变得更加容易。
- en: In the next chapter, we'll look at an Android system that makes this sort of
    modularization easier, and even more flexible. The data binding system is an incredibly
    powerful system that takes care of keeping user interfaces populated with data,
    and allows much of the presentation work to be bound directly to the layout XML
    files.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨一个使这种模块化更容易、更灵活的Android系统。数据绑定系统是一个功能强大的系统，负责保持用户界面充满数据，并允许将大部分表示工作直接绑定到布局XML文件。
