- en: Enabling the ARM Translator and Introducing Native Bridge
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用 ARM 翻译器和介绍原生桥接
- en: 'We created a new x86emu device in the last chapter. This is the foundation
    of further customization and extension. As we know, if the application includes
    native libraries, it cannot run on a different processor architecture. Most Android
    applications are built for the ARM platform. We usually have problems with running
    these applications with ARM native libraries on Intel x86 platform. However, Google
    provides a solution for this situation from Android 5 and above called **Native
    Bridge**. We will delve into the Native Bridge and Intel Houdini implementation
    to extend x86emu to support the ARM native application in this chapter. In this
    chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章中创建了一个新的 x86emu 设备。这是进一步定制和扩展的基础。正如我们所知，如果应用程序包含原生库，则无法在不同的处理器架构上运行。大多数
    Android 应用程序是为 ARM 平台构建的。我们通常在 Intel x86 平台上运行这些带有 ARM 原生库的应用程序时遇到问题。然而，从 Android
    5 及以上版本开始，Google 为此情况提供了一个名为 **原生桥接** 的解决方案。在本章中，我们将深入研究原生桥接和 Intel Houdini 的实现，以扩展
    x86emu 以支持 ARM 原生应用程序。在本章中，我们将涵盖以下主题：
- en: Introducing Native Bridge
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍原生桥接
- en: Integrating the Houdini library to the x86emu device
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Houdini 库集成到 x86emu 设备中
- en: Building and testing the image with Houdini integration
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Houdini 集成构建和测试图像
- en: Introducing Native Bridge
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍原生桥接
- en: 'Native Bridge is implemented as a part of **Android Runtime** (**ART**) in
    the Android architecture. It is used to support running native libraries in a
    different processor architecture so that an application with native libraries
    can run on a broader range of devices. The Intel ARM translator called Houdini
    is one of the use cases of Native Bridge. In ART, there are two stages for the
    Native Bridge to be initialized:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 架构中，原生桥接作为 Android Runtime（**ART**）的一部分实现。它用于支持在不同的处理器架构上运行原生库，以便具有原生库的应用程序可以在更广泛的设备上运行。名为
    Houdini 的 Intel ARM 翻译器是原生桥接的一个用例。在 ART 中，原生桥接的初始化有两个阶段：
- en: In the first stage, the Native Bridge is loaded in the system as part of the
    ART initialization process. This is common for all applications.
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一阶段，原生桥接作为 ART 初始化过程的一部分加载到系统中。这对于所有应用程序都是常见的。
- en: In the second stage, when an application with native libraries is started, it
    will be forked from Zygote. At this time, the Native Bridge will be initialized
    and ready to be used for the application. This is a process that is specific for
    individual applications. For example, if there are no native libraries being used,
    Native Bridge won't be initialized for this application.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二阶段，当启动具有原生库的应用程序时，它将从 Zygote 中 fork。此时，原生桥接将被初始化并准备好供应用程序使用。这是一个针对单个应用程序的特定过程。例如，如果没有使用原生库，则不会为此应用程序初始化原生桥接。
- en: '**Zygote** Android at its core has a process they call the Zygote, which starts
    up at init. This process is a "warmed-up" process, which means it''s a process
    that''s been initialized and has all the core libraries linked in. When you start
    an application, the Zygote is forked to create the new process. The real speedup
    is achieved by *not* copying the shared libraries. This memory will only be copied
    if the new process tries to modify it. This means that all of the core libraries
    can exist in a single place because they are read-only.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**Zygote** Android 在其核心有一个名为 Zygote 的进程，它在 init 时启动。此进程是一个“预热”进程，这意味着它是一个已经初始化并且所有核心库都已链接的进程。当你启动一个应用程序时，Zygote
    将被 fork 以创建新的进程。真正的加速是通过*不*复制共享库来实现的。只有当新进程尝试修改它时，此内存才会被复制。这意味着所有核心库都可以存在于一个地方，因为它们是只读的。'
- en: When the application starts to load a native library from a different processor
    architecture, the Native Bridge will help to resolve the loading of this library.
    For example, when we load an ARM library on Intel the x86 architecture, the Native
    Bridge will use Houdini to load and execute this ARM library in the Intel x86
    environment.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序开始从不同的处理器架构加载原生库时，原生桥接将帮助解决此库的加载。例如，当我们加载 ARM 库在 Intel 的 x86 架构上时，原生桥接将使用
    Houdini 在 Intel x86 环境中加载和执行此 ARM 库。
- en: '![](img/image_05_001.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_001.png)'
- en: Native Bridge in Android architecture
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 原生桥接在 Android 架构中
- en: 'Native Bridge is built as a `libnativebridge.so` shared library as part of
    the Android system libraries, as shown in the preceding diagram. The implementation
    can be found at `$AOSP/system/core/libnativebridge`. Within the Native Bridge
    implementation, it has five states defined in `native_bridge.cc`, as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Native Bridge作为Android系统库的一部分构建为一个`libnativebridge.so`共享库，如图所示。实现可以在`$AOSP/system/core/libnativebridge`中找到。在Native
    Bridge实现中，它在`native_bridge.cc`中定义了五个状态，如下所示：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When the Android system has just started, Native Bridge is in a `kNotSetup`
    state. During the initialization of ART, it will be loaded into the system and
    the stage changes to `kOpened`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当Android系统刚刚启动时，Native Bridge处于`kNotSetup`状态。在ART的初始化过程中，它将被加载到系统中，阶段变为`kOpened`。
- en: These two states are in the first stage of the Native Bridge initialization.
    When the user starts an application with native libraries, the system will fork
    a new process from Zygote. At this time, the system will do some pre-initialization
    work for Native Bridge, and we will see this later in this chapter. The state
    changes to `kPreInitialized` at this time. After the process is forked from Zygote,
    Native Bridge is initialized as part of the process creation and its state becomes
    `kInitialized`. The `kClosed` state is usually not used unless there is an error
    and Native Bridge is closed. These three states fall into the second stage of
    the Native Bridge initialization.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个状态是Native Bridge初始化的第一阶段。当用户启动带有本地库的应用程序时，系统将从Zygote中fork一个新的进程。此时，系统将为Native
    Bridge做一些预初始化工作，我们将在本章后面看到这一点。此时状态变为`kPreInitialized`。从Zygote fork进程后，Native Bridge作为进程创建的一部分被初始化，其状态变为`kInitialized`。`kClosed`状态通常不使用，除非出现错误并且关闭Native
    Bridge。这三个状态属于Native Bridge初始化的第二阶段。
- en: With the overview about Native Bridge in Android system architecture, we will
    have to delve into the details of each stage about Native Bridge used at runtime.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了Android系统架构中关于Native Bridge的概述之后，我们将不得不深入了解运行时使用的Native Bridge的每个阶段的细节。
- en: Setting up Native Bridge as part of the ART initialization
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Native Bridge作为ART初始化的一部分设置起来
- en: First of all, let's take a look at how Native Bridge is loaded in the system.
    Native Bridge is loaded as part of the initialization of ART. As shown in the
    following diagram, it includes function calls from **ART** to the **Native Bridge**
    implementation. At the end of this stage, the state of **Native Bridge** will
    be set to `kOpened`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看Native Bridge如何在系统中加载。Native Bridge作为ART初始化的一部分被加载。如图所示，它包括从**ART**到**Native
    Bridge**实现的函数调用。在这个阶段结束时，**Native Bridge**的状态将被设置为`kOpened`。
- en: '![](img/image_05_002.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_05_002.png)'
- en: Loading Native Bridge
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 加载Native Bridge
- en: 'When the system is initializing ART, the `Runtime::Init` function is called.
    Inside `Runtime::Init`, a `LoadNativeBridge` function is invoked to load the Native
    Bridge shared library. We can see this in the following code snippet:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统初始化ART时，会调用`Runtime::Init`函数。在`Runtime::Init`内部，会调用`LoadNativeBridge`函数来加载Native
    Bridge共享库。我们可以在下面的代码片段中看到这一点：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This `LoadNativeBridge` function is part of ART and it is implemented in the
    `native_bridge_art_interface.cc` file, as shown in the following snippet. This
    function simply calls to another function, `android::LoadNativeBridge`, in the
    namespace `android`, while it itself is in the namespace of `art`. The functions
    in the namespace of `android` are part of the Native Bridge implementation, as
    shown in the preceding diagram, and we will see more of this later in this chapter.
    We can see the implementation of `LoadNativeBridge` in the following code snippet:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`LoadNativeBridge`函数是ART的一部分，它在`native_bridge_art_interface.cc`文件中实现，如图所示。这个函数简单地调用在`android`命名空间中的另一个函数`android::LoadNativeBridge`，而它本身在`art`命名空间中。`android`命名空间中的函数是Native
    Bridge实现的一部分，如图所示，我们将在本章后面看到更多关于这一点。我们可以在下面的代码片段中看到`LoadNativeBridge`的实现：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `android::LoadNativeBridge` function in the `android` namespace has an
    extra `native_bridge_art_callbacks` parameter compared to the `art:LoadNativeBridge`
    function in the `art` namespace. The type of this parameter is a pointer of `struct
    NativeBridgeRuntimeCallbacks`, which is defined in `native_bridge.h`. In `struct
    NativeBridgeRuntimeCallbacks`, it defines three callback methods as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`android`命名空间中的`android::LoadNativeBridge`函数与`art`命名空间中的`art:LoadNativeBridge`函数相比，有一个额外的`native_bridge_art_callbacks`参数。这个参数的类型是`struct
    NativeBridgeRuntimeCallbacks`的指针，它在`native_bridge.h`中定义。在`struct NativeBridgeRuntimeCallbacks`中，它定义了以下三个回调方法：'
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: These three callback functions that are part of ART are implemented in the `native_bridge_art_interface.cc`
    file. These callback functions provide a way for native methods to call JNI native
    functions. We will see how this callback data structure is passed to the actual
    Native Bridge implementation later. In our case, the actual implementation is
    the Houdini library.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这些作为ART一部分的三个回调函数在`native_bridge_art_interface.cc`文件中实现。这些回调函数为原生方法调用JNI原生函数提供了一种方式。我们将在稍后看到这种回调数据结构是如何传递给实际的Native
    Bridge实现的。在我们的例子中，实际的实现是Houdini库。
- en: 'The `native_bridge.h` file defines another callback function data structure,
    `NativeBridgeCallbacks`, which is used as the Native Bridge interface of its actual
    implementation. In our case, this implementation is the Houdini library. The Houdini
    library needs to implement these callback functions and pass the pointers to Native
    Bridge so that ART can use them. The following figure depicts the relationship
    between these two groups of callback functions:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`native_bridge.h`文件定义了另一个回调函数数据结构，`NativeBridgeCallbacks`，它用作其实际实现的Native Bridge接口。在我们的例子中，这个实现是Houdini库。Houdini库需要实现这些回调函数并将指针传递给Native
    Bridge，以便ART可以使用它们。以下图显示了这两组回调函数之间的关系：'
- en: '![](img/image_05_003.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_05_003.png)'
- en: ART, Native Bridge, and Houdini
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ART、Native Bridge和Houdini
- en: In the preceding figure, we can see that **ART** calls **Native Bridge** functions
    to load and initialize the **Native Bridge** module. The **Native Bridge** module
    invokes the callback functions registered by **Houdini** to handle all ARM native
    binary translations. During the initialization of **Native Bridge**, **NativeBridgeRuntimeCallbacks**
    are passed to the **Houdini** library so that the methods in the **Houdini** library
    can call JNI native functions.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到**ART**调用**Native Bridge**函数来加载和初始化**Native Bridge**模块。**Native
    Bridge**模块调用由**Houdini**注册的回调函数来处理所有ARM原生二进制翻译。在**Native Bridge**初始化期间，**NativeBridgeRuntimeCallbacks**传递给**Houdini**库，以便**Houdini**库中的方法可以调用JNI原生函数。
- en: 'Now let''s take a look at the implementation of `android::LoadNativeBridge`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看`android::LoadNativeBridge`的实现：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As we can see from the preceding code snippet, `android::LoadNativeBridge` checks
    the state first. It should be in a `kNotSetup` state. Otherwise, it will report
    an error and return.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码片段中我们可以看到，`android::LoadNativeBridge`首先检查状态。它应该处于`kNotSetup`状态。否则，它将报告错误并返回。
- en: 'To be convenient, we will refer to the function in the Android namespace as
    `LoadNativeBridge` instead of `android::LoadNativeBridge` in the next few paragraphs.
    The files that will be discussed can be found at:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，在接下来的几段中，我们将把Android命名空间中的函数称为`LoadNativeBridge`，而不是`android::LoadNativeBridge`。将要讨论的文件可以在以下位置找到：
- en: '`$AOSP/art/runtime/runtime.c`'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`$AOSP/art/runtime/runtime.c`'
- en: '`$AOSP/art/runtime/native_bridge_art_interface.c`'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`$AOSP/art/runtime/native_bridge_art_interface.c`'
- en: '`$AOSP/system/core/libnativebridge/native_bridge.cc`'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`$AOSP/system/core/libnativebridge/native_bridge.cc`'
- en: After that, it will check whether the first parameter is `NULL` and the filename
    is good to use or not. If everything is good, it will open the library through
    `dlopen` using the filename `nb_library_filename`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，它将检查第一个参数是否为`NULL`以及文件名是否可以使用。如果一切正常，它将通过`dlopen`使用文件名`nb_library_filename`打开库。
- en: 'So what is the content of the `nb_library_filename` filename? As we can see
    from the `Runtime::Init` function, the first parameter of `LoadNativeBridge` is
    initialized using a `Opt::NativeBridge` property:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 那么`nb_library_filename`文件名的内容是什么呢？从`Runtime::Init`函数中我们可以看到，`LoadNativeBridge`的第一个参数使用`Opt::NativeBridge`属性初始化：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This property is initialized from the default property `ro.dalvik.vm.native.bridge`,
    which is defined in the `default.prop` file of the Android system. This is done
    in the `AndroidRuntime::startVm` function, as you can see in the following snippet.
    This function is defined in the `$AOSP/frameworks/base/core/jni/AndroidRuntime.cpp`
    file:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性是从默认属性`ro.dalvik.vm.native.bridge`初始化的，该属性定义在Android系统的`default.prop`文件中。这是在`AndroidRuntime::startVm`函数中完成的，如以下片段所示。此函数定义在`$AOSP/frameworks/base/core/jni/AndroidRuntime.cpp`文件中：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When Native Bridge is enabled, the `ro.dalvik.vm.native.bridge` property usually
    includes a shared library filename. In our case, it is `libhoudini.so` for Intel
    devices or `libnb.so` for Android-x86\. If Native Bridge is disabled, its value
    is 0\. Once the library is loaded successfully, it will use the `kNativeBridgeInterfaceSymbol`
    symbol to get the memory location and cast the location to a pointer of `NativeBridgeCallbacks`.
    This means that the Houdini library provides an implementation of `NativeBridgeCallbacks`.
    Let''s look at what it is inside `NativeBridgeCallbacks`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当启用原生桥接时，`ro.dalvik.vm.native.bridge` 属性通常包含一个共享库文件名。在我们的例子中，对于英特尔设备是 `libhoudini.so`，对于
    Android-x86 是 `libnb.so`。如果禁用原生桥接，其值是 0。一旦库加载成功，它将使用 `kNativeBridgeInterfaceSymbol`
    符号来获取内存位置，并将位置转换为 `NativeBridgeCallbacks` 的指针。这意味着 Houdini 库提供了一个 `NativeBridgeCallbacks`
    的实现。让我们看看 `NativeBridgeCallbacks` 中都有什么：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'From the preceding code snippet, we can see that `NativeBridgeCallbacks` includes
    a variable and seven callback functions:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码片段中，我们可以看到 `NativeBridgeCallbacks` 包含一个变量和七个回调函数：
- en: '`version`: This is the version number of the interface. So far, there are two
    versions. Version 1 defines the first five callback functions and version 2 adds
    another two new functions, which we will see very shortly.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`version`：这是接口的版本号。到目前为止，有两个版本。版本 1 定义了前五个回调函数，版本 2 增加了另外两个新函数，我们很快就会看到。'
- en: '`initialize`: This function initializes an instance of Native Bridge. Native
    Bridge''s internal implementation must ensure multithread safety and Native Bridge
    is initialized only once.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initialize`：这个函数初始化 Native Bridge 的一个实例。Native Bridge 的内部实现必须确保多线程安全，并且 Native
    Bridge 只初始化一次。'
- en: '`loadLibrary` : This function loads a shared library that is supported by the
    Native Bridge.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loadLibrary`：这个函数加载 Native Bridge 支持的共享库。'
- en: '`getTrampoline` : This function gets a Native Bridge trampoline for the specified
    native method.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getTrampoline`：这个函数获取指定原生方法的 Native Bridge 跳转函数。'
- en: '`isSupported` : This function checks whether the instance of Native Bridge
    is valid and whether it is for an ABI that is supported by Native Bridge.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isSupported`：这个函数检查 Native Bridge 的实例是否有效，以及它是否为 Native Bridge 支持的 ABI。'
- en: 'In version 2, the following two functions are added:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在版本 2 中，增加了以下两个函数：
- en: '`isCompatibleWith`: This function checks whether the bridge is compatible with
    the given version of library. A bridge may decide not to be forward- or backward-compatible,
    and `libnativebridge` will then stop using it.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isCompatibleWith`：这个函数检查桥接是否与给定的库版本兼容。桥接可能决定不向前或向后兼容，此时 `libnativebridge`
    将停止使用它。'
- en: '`getSignalHandler`: A callback function to retrieve a Native Bridge''s signal
    handler for the specified signal. The runtime will ensure that the signal handler
    is being called after the runtime''s own handler, but before all chained handlers.
    The native bridge should not try to install the handler by itself, as that will
    potentially lead to cycles.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getSignalHandler`：一个回调函数，用于检索指定信号的 Native Bridge 信号处理器。运行时会确保在运行时自己的处理器之后、所有链式处理器之前调用信号处理器。原生桥接不应尝试自行安装处理器，因为这可能导致循环。'
- en: Now we have concluded the first stage of the Native Bridge initialization. As
    we can see from the preceding lists, Native Bridge is loaded at the startup of
    ART. At this stage, the initialization is not process-specific. The library name
    is defined in the `ro.dalvik.vm.native.bridge` property. In our case, ART loads
    the `libhoudini.so` library through the `LoadNativeBridge` function defined in
    `libnativebridge.so`. After Native Bridge is loaded successfully, the state is
    set to `kOpened`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了 Native Bridge 初始化的第一阶段。从前面的列表中我们可以看到，Native Bridge 在 ART 启动时加载。在这个阶段，初始化不是进程特定的。库名在
    `ro.dalvik.vm.native.bridge` 属性中定义。在我们的例子中，ART 通过在 `libnativebridge.so` 中定义的 `LoadNativeBridge`
    函数加载 `libhoudini.so` 库。一旦 Native Bridge 加载成功，状态设置为 `kOpened`。
- en: Pre-initializing Native Bridge
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预初始化 Native Bridge
- en: 'In the second stage of Native Bridge initialization, it becomes process-specific.
    Native Bridge can be used by an Android application to load a native library in
    a different processor architecture than the current device. The other two states,
    `kPreInitialized` and `kInitialized`, are related to the creation of Android applications,
    as we know that all applications are forked from Zygote in Android. Let''s look
    at the pre-initialization of Native Bridge first, as shown in the following diagram:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Native Bridge 初始化的第二阶段，它变得与进程相关。Android 应用可以通过 Native Bridge 在不同于当前设备处理器架构的情况下加载本地库。其他两个状态，`kPreInitialized`
    和 `kInitialized`，与 Android 应用程序的创建有关，因为我们知道在 Android 中所有应用程序都是从 Zygote 分叉出来的。让我们首先看看
    Native Bridge 的预初始化，如下面的图所示：
- en: '![](img/image_05_004.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_004.png)'
- en: Pre-initialization of Native Bridge
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Native Bridge 的预初始化
- en: 'During the creation of an application, the `ForkAndSpecializeCommon` function
    is called. The pre-initialization of Native Bridge is done in this function. This
    function is defined in the `$AOSP/frameworks/base/core/jni/com_android_internal_os_Zygote.cpp`
    file:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建应用程序的过程中，会调用 `ForkAndSpecializeCommon` 函数。Native Bridge 的预初始化就在这个函数中完成。这个函数定义在
    `$AOSP/frameworks/base/core/jni/com_android_internal_os_Zygote.cpp` 文件中：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this `ForkAndSpecializeCommon` function, it checks whether the current process
    is not a SystemServer process and if the Native Bridge is ready to use. After
    that, it calls the `NeedsNativeBridge` function to check whether the current process
    needs to use Native Bridge or not:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 `ForkAndSpecializeCommon` 函数中，它检查当前进程是否不是 SystemServer 进程，以及 Native Bridge
    是否准备好使用。之后，它调用 `NeedsNativeBridge` 函数来检查当前进程是否需要使用 Native Bridge：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `NeedsNativeBridge` function compares `instruction_set` with the current
    Android platform instruction set. If these two instruction sets are different,
    then we need to use Native Bridge; otherwise, we don't. The `NeedsNativeBridge`
    function is implemented in `native_bridge.cc`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`NeedsNativeBridge` 函数将 `instruction_set` 与当前 Android 平台的指令集进行比较。如果这两个指令集不同，那么我们需要使用
    Native Bridge；否则，我们不需要。`NeedsNativeBridge` 函数在 `native_bridge.cc` 文件中实现。'
- en: 'If Native Bridge is needed by the application, then `PreInitializeNativeBridge`,
    which is also implemented in `native_bridge.cc`, is going to be called with two
    parameters, `app_data_dir_in` and `instruction_set`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序需要 Native Bridge，那么 `PreInitializeNativeBridge` 函数将被调用，该函数也实现于 `native_bridge.cc`，并带有两个参数，`app_data_dir_in`
    和 `instruction_set`：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: From the preceding code snippet, we can see that it will check whether the state
    is `kOpened` or not. Then `PreInitializeNativeBridge` will do two things. Firstly,
    it creates a code cache directory using the first parameter, `app_data_dir_in`,
    for Native Bridge in the `data` folder of the application. Next, it uses the second
    parameter, `instruction_set`, to find the `/system/lib/<isa>/cpuinfo` path and
    it does a bind-mount of it to `/proc/cpuinfo`. If Houdini is available in the
    device, you can find the `/system/lib/arm/cpuinfo` file in the `system` folder.
    Once the preceding two tasks are completed, the state of Native Bridge will be
    set to `kPreInitialized`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码片段中，我们可以看到它会检查状态是否为 `kOpened`。然后 `PreInitializeNativeBridge` 将执行两件事。首先，它使用第一个参数
    `app_data_dir_in` 在应用程序的 `data` 文件夹中为 Native Bridge 创建一个代码缓存目录。接下来，它使用第二个参数 `instruction_set`
    来查找 `/system/lib/<isa>/cpuinfo` 路径，并将其绑定挂载到 `/proc/cpuinfo`。如果设备上可用 Houdini，你可以在
    `system` 文件夹中找到 `/system/lib/arm/cpuinfo` 文件。一旦完成前面的两项任务，Native Bridge 的状态将被设置为
    `kPreInitialized`。
- en: Initializing Native Bridge
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化 Native Bridge
- en: 'After the state is changed to `kPreInitialized`, the creation of the new Android
    application will continue in the `ForkAndSpecializeCommon` function. At the end
    of this function, it calls a `callPostForkChildHooks` registered function through
    a global variable, `gCallPostForkChildHooks`. The call stack will eventually go
    to a `ZygoteHooks_nativePostForkChild` function, which is the JNI implementation
    of the `postForkChild` Java method. The `postForkChild` function is called by
    Zygote in the child process after every fork. The following table is a summary
    of the call stack:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 状态变为 `kPreInitialized` 后，新的 Android 应用程序将在 `ForkAndSpecializeCommon` 函数中继续创建。在这个函数的末尾，它通过一个全局变量
    `gCallPostForkChildHooks` 调用一个已注册的 `callPostForkChildHooks` 函数。调用栈最终会进入 `ZygoteHooks_nativePostForkChild`
    函数，这是 `postForkChild` Java 方法的 JNI 实现。`postForkChild` 函数在每次分叉后由 Zygote 在子进程中调用。以下表格是对调用栈的总结：
- en: '| **Function** | **Class** | **Language** |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **类** | **语言** |'
- en: '| `ForkAndSpecializeCommon` |  | C++ |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `ForkAndSpecializeCommon` |  | C++ |'
- en: '| `gCallPostForkChildHooks` |  | C++ |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `gCallPostForkChildHooks` |  | C++ |'
- en: '| `callPostForkChildHooks` | Zygote | Java |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `callPostForkChildHooks` | Zygote | Java |'
- en: '| `postForkChild` | ZygoteHooks | Java |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `postForkChild` | ZygoteHooks | Java |'
- en: '| `ZygoteHooks_nativePostForkChild` | JNI (postForkChild) | C++ |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `ZygoteHooks_nativePostForkChild` | JNI (postForkChild) | C++ |'
- en: The `ZygoteHooks_nativePostForkChild` function is implemented in the `$AOSP/
    art/runtime/native/dalvik_system_ZygotHooks.cc` file. The `DidForkFromZygote`
    function is implemented in the `$AOSP/art/runtime/runtime.cc` file.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`ZygoteHooks_nativePostForkChild` 函数在 `$AOSP/ art/runtime/native/dalvik_system_ZygotHooks.cc`
    文件中实现。`DidForkFromZygote` 函数在 `$AOSP/art/runtime/runtime.cc` 文件中实现。'
- en: 'The following diagram is a summary of functions involved in the second stage
    of the initialization of Native Bridge. Be aware that we are in the child process
    now. We can see that the **Runtime::DidForkFromZygote** function in **ART** will
    call the following Native Bridge interface functions: **InitializeNativeBridge**
    and **SetupEnvironment**. The Native Bridge interface functions will eventually
    call the registered callback functions in the Houdini library.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表是涉及 Native Bridge 初始化第二阶段函数的总结。请注意，我们现在处于子进程中。我们可以看到，**ART** 中的 **Runtime::DidForkFromZygote**
    函数将调用以下 Native Bridge 接口函数：**InitializeNativeBridge** 和 **SetupEnvironment**。Native
    Bridge 接口函数最终将调用 Houdini 库中注册的回调函数。
- en: '![](img/image_05_005.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_005.png)'
- en: Initialization of Native Bridge
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Native Bridge 的初始化
- en: 'Let''s look at the JNI implementation of `postForkChild`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `postForkChild` 的 JNI 实现：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, it checks the instruction set again to decide whether we need Native
    Bridge for the application. Then it calls the `Runtime::DidForkFromZygote` function
    to initialize Native Bridge in the new process:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，它再次检查指令集以决定我们是否需要为应用程序使用 Native Bridge。然后它调用 `Runtime::DidForkFromZygote`
    函数以在新进程中初始化 Native Bridge：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As we can see, `Runtime::DidForkFromZygote` calls the `InitializeNativeBridge`
    based on the action. Now let''s dive into the `InitializeNativeBridge` function,
    which is implemented in `native_bridge.cc`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，`Runtime::DidForkFromZygote` 根据操作调用 `InitializeNativeBridge`。现在让我们深入了解
    `InitializeNativeBridge` 函数，该函数在 `native_bridge.cc` 中实现：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the `InitializeNativeBridge` function, it creates the folder for the code
    cache first. Then, it invokes the `initialize` function, implemented by the Houdini
    library in our case.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `InitializeNativeBridge` 函数中，它首先创建代码缓存的文件夹。然后，它调用由我们案例中的 Houdini 库实现的 `initialize`
    函数。
- en: The shared library is `libhoudini.so` in Intel devices. If you run Android-x86
    on an Intel device, the shared library is `libnb.so`. We will discuss `libnb.so`
    later in this chapter.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在英特尔设备上，共享库是 `libhoudini.so`。如果您在英特尔设备上运行 Android-x86，共享库是 `libnb.so`。我们将在本章后面讨论
    `libnb.so`。
- en: After that, it calls another `SetupEnvironment` function in `native_bridge.cc`
    to set up the environment for the Native Bridge in the current application. Finally,
    it sets the state to `kInitialized`. Now Native Bridge is ready for the current
    application to use.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，它会在 `native_bridge.cc` 中调用另一个 `SetupEnvironment` 函数，为当前应用程序中的 Native Bridge
    设置环境。最后，它将状态设置为 `kInitialized`。现在 Native Bridge 已准备好供当前应用程序使用。
- en: Loading a native library
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载本地库
- en: Once Native Bridge is ready to use, we can have a look at what happens when
    an application loads a native library in a different processor architecture.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Native Bridge 准备好使用，我们可以看看当应用程序在不同的处理器架构中加载本地库时会发生什么。
- en: 'We know that, if we implement a native method in a shared library, we need
    to implement a `JNI_OnLoad` entry point, which is used to register native methods.
    The Java code needs to make a call to either `System.load` or `System.loadLibrary`
    to load this shared library. In the following table, it is the call stack from
    `System.loadLibrary` to `JNI_OnLoad`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，如果我们在一个共享库中实现原生方法，我们需要实现一个 `JNI_OnLoad` 入口点，用于注册原生方法。Java 代码需要调用 `System.load`
    或 `System.loadLibrary` 来加载这个共享库。在以下表中，这是从 `System.loadLibrary` 到 `JNI_OnLoad`
    的调用栈：
- en: '| **Function** | **Class** | **Language** |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **类** | **语言** |'
- en: '| `System.loadLibrary` | Runtime | Java |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `System.loadLibrary` | Runtime | Java |'
- en: '| `doLoad` | Runtime | Java |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `doLoad` | Runtime | Java |'
- en: '| `nativeLoad` | Runtime | JNI |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `nativeLoad` | Runtime | JNI |'
- en: '| `Runtime_nativeLoad` | Runtime | C++ |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `Runtime_nativeLoad` | Runtime | C++ |'
- en: '| `LoadNativeLibrary` | JavaVMExt | C++ |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `LoadNativeLibrary` | JavaVMExt | C++ |'
- en: '| `JNI_OnLoad` |  | C++ |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `JNI_OnLoad` |  | C++ |'
- en: 'Let''s look into the details of `JavaVMExt::LoadNativeLibrary`. This function
    is defined in `$AOSP/art/runtime/jni_internal.cc`. The following diagram is the
    part of `JavaVMExt::LoadNativeLibrary` related to Native Bridge:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解`JavaVMExt::LoadNativeLibrary`的细节。此函数定义在`$AOSP/art/runtime/jni_internal.cc`中。以下图是`JavaVMExt::LoadNativeLibrary`与Native
    Bridge相关部分：
- en: '![](img/image_05_006.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_006.png)'
- en: Loading native library
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 加载本地库
- en: 'Android applications call to this function when they load native libraries.
    Usually, we refer to the native library in the same processor architecture here.
    With Native Bridge, we can load supported native libraries in a different processor
    architecture with this function as well:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当Android应用程序加载本地库时，会调用此函数。通常，我们在这里指的是相同处理器架构下的本地库。通过Native Bridge，我们也可以使用此函数加载支持的不同处理器架构的本地库：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `LoadNativeLibrary` function will call to `dlopen` to load the shared library
    first. If it is a shared library in a different processor architecture, such as
    an open ARM library on an Intel x86 platform, the `dlopen` call should fail. In
    this case, it will try to load the library again using Native Bridge instead of
    returning an error.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoadNativeLibrary`函数首先调用`dlopen`来加载共享库。如果它是在不同处理器架构上的共享库，例如在Intel x86平台上的ARM库，`dlopen`调用应该失败。在这种情况下，它将尝试使用Native
    Bridge而不是返回错误来重新加载库。'
- en: 'To use Native Bridge, it calls to the `NativeBridgeIsSupported` function first
    to check whether Native Bridge is supported or not. The `NativeBridgeIsSupported`
    function calls to the Houdini callback function, `isSupported`, to check whether
    the given shared library can be supported by Native Bridge or not:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Native Bridge，它首先调用`NativeBridgeIsSupported`函数来检查Native Bridge是否受支持。`NativeBridgeIsSupported`函数调用Houdini回调函数`isSupported`来检查给定的共享库是否可以通过Native
    Bridge支持：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If the library can be supported by Native Bridge, `LoadNativeLibrary` will
    call another Native Bridge function, `android::NativeBridgeLoadLibrary`, to load
    the library:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果库可以通过Native Bridge支持，`LoadNativeLibrary`将调用另一个Native Bridge函数，`android::NativeBridgeLoadLibrary`来加载库：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The Native Bridge `NativeBridgeLoadLibrary` function will make a call to the
    Houdini callback function `loadLibrary` to load the library. After the native
    library is loaded successfully, the `JNI_OnLoad` entry point will be found in
    the library and the system will call it to register the native methods registered
    by the native library. For a normal native library, the system function `dlsym`
    is used to get the `JNI_OnLoad` method, but the `FindSymbolWithNativeBridge` function
    is used to get `JNI_OnLoad` from the Houdini library:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Native Bridge的`NativeBridgeLoadLibrary`函数将调用Houdini回调函数`loadLibrary`来加载库。本地库加载成功后，库中的`JNI_OnLoad`入口点将被找到，系统将调用它来注册本地库注册的本地方法。对于正常的本地库，系统函数`dlsym`用于获取`JNI_OnLoad`方法，但`FindSymbolWithNativeBridge`函数用于从Houdini库中获取`JNI_OnLoad`：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`FindSymbolWithNativeBridge` calls to the `NativeBridgeGetTrampoline` Native
    Bridge function, while `NativeBridgeGetTrampoline` calls to the `getTrampoline`
    Houdini callback function to do the actual work:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`FindSymbolWithNativeBridge`调用`NativeBridgeGetTrampoline` Native Bridge函数，而`NativeBridgeGetTrampoline`调用`getTrampoline`
    Houdini回调函数来完成实际工作：'
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: From the preceding analysis, we can see that the ARM translator library Houdini
    uses the Native Bridge in Android to support ARM binary translation. The interfaces
    between the Houdini library and the system are two sets of callback functions.
    The callback functions defined in `NativeBridgeCallbacks` are used by the system
    to perform the function calls to the ARM native library, while the callback functions
    defined in `NativeBridgeRuntimeCallbacks` can be used by the functions in the
    Houdini library to call JNI functions in the system.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的分析中，我们可以看出Houdini使用的ARM翻译库在Android中通过Native Bridge支持ARM二进制翻译。Houdini库与系统之间的接口是两套回调函数。在`NativeBridgeCallbacks`中定义的回调函数被系统用来对ARM本地库进行函数调用，而定义在`NativeBridgeRuntimeCallbacks`中的回调函数可以被Houdini库中的函数用来调用系统中的JNI函数。
- en: Integrating Houdini to the x86emu device
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Houdini集成到x86emu设备中
- en: The goal of this chapter is to support Houdini ARM binary translation in Android
    emulator. After we have an overview of the internals of Native Bridge, which is
    the foundation of the Houdini library, we can work on Houdini support for our
    x86emu device.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是在Android模拟器中支持Houdini ARM二进制翻译。在了解Native Bridge的内部原理之后，它是Houdini库的基础，我们可以着手为我们的x86emu设备提供Houdini支持。
- en: Since the Houdini library is an Intel proprietary library, it is not available
    publicly. For those people who want to add Houdini to a new device, such as an
    Android emulator that is not supported by Intel, the only possible way is to copy
    the Houdini library from a supported device and add it to the unsupported device.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Houdini 库是英特尔专有库，因此它不可公开获取。对于那些想要将 Houdini 添加到新设备（如不受英特尔支持的 Android 模拟器）的人，唯一可能的方法是从受支持的设备复制
    Houdini 库并将其添加到不受支持的设备。
- en: Fortunately, the open source project Android-x86 provides basic support for
    Houdini to any Intel devices, which we can use as a reference in this book. In
    this chapter, we will add Houdini to an Android emulator based on the Android-x86
    project.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，开源项目 Android-x86 为任何英特尔设备提供了对 Houdini 的基本支持，我们可以将其作为本书的参考。在本章中，我们将基于 Android-x86
    项目将 Houdini 添加到 Android 模拟器。
- en: Changing the configuration of the x86emu build
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改 x86emu 构建配置
- en: 'The basic steps to support Houdini on a new device are:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在新设备上支持 Houdini 的基本步骤是：
- en: Change the device configurations according to what we have discussed in [Chapter
    4](f69f330a-932c-4a32-bb78-e427c860b65e.xhtml), *Customizing the Android Emulator*,
    in the *Why* c*ustomize the Android emulator?* section
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据我们在 [第 4 章](f69f330a-932c-4a32-bb78-e427c860b65e.xhtml)，*自定义 Android 模拟器*
    中 *为什么要自定义 Android 模拟器？* 部分讨论的内容，更改设备配置
- en: Copy a suitable version of the Houdini library to the `system` folder
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将适合版本的 Houdini 库复制到 `system` 文件夹
- en: To work on the preceding two steps, let's start with the changes to the x86emu
    device configurations first. What we will do for this is that we will use the
    source code in [Chapter 4](f69f330a-932c-4a32-bb78-e427c860b65e.xhtml), *Customizing
    the Android Emulator* as the baseline and make changes on top of it. This is also
    the approach that we will use in most of the chapters in this book. We will make
    independent changes based on the simplest code base for each topic. What I mean
    is that the source code for x86emu in [Chapter 4](f69f330a-932c-4a32-bb78-e427c860b65e.xhtml),
    *Customizing the Android Emulator* is the simplest code base for the x86emu device.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理前两个步骤，我们首先从修改 x86emu 设备配置开始。我们将为此使用 [第 4 章](f69f330a-932c-4a32-bb78-e427c860b65e.xhtml)，*自定义
    Android 模拟器* 中的源代码作为基准，并在其基础上进行修改。这也是本书大多数章节中我们将采用的方法。我们将根据每个主题最简单的代码库进行独立修改。我的意思是，[第
    4 章](f69f330a-932c-4a32-bb78-e427c860b65e.xhtml)，*自定义 Android 模拟器* 中 x86emu 的源代码是这个设备的最简单代码库。
- en: 'Given that we already have a working copy of the AOSP source code for x86emu,
    we can make changes for this chapter in a new branch:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有了一份 x86emu 的 AOSP 源代码的工作副本，我们可以在一个新分支中为本章进行修改：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: I created a tag for each chapter and we can use that as the start for the new
    development. The `android-7.1.1_r4_x86emu_ch04_r1` tag is the baseline for [Chapter
    4](f69f330a-932c-4a32-bb78-e427c860b65e.xhtml), *Customizing the Android Emulator*.
    From the preceding commands, we create a new branch, `android-7.1.1_r4_ch05`,
    for the development work in this chapter. I didn't push the development branches
    to GitHub, but I pushed all the tags to GitHub. After we complete all the changes
    in this chapter, we will create a new tag, `android-7.1.1_r4_x86emu_ch05_r1`,
    for this chapter.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我为每个章节创建了一个标签，我们可以将其作为新开发的起点。`android-7.1.1_r4_x86emu_ch04_r1` 标签是 [第 4 章](f69f330a-932c-4a32-bb78-e427c860b65e.xhtml)，*自定义
    Android 模拟器* 的基准。从前面的命令中，我们创建了一个新的分支，`android-7.1.1_r4_ch05`，用于本章的开发工作。我没有将开发分支推送到
    GitHub，但我将所有标签推送到 GitHub。在我们完成本章的所有更改后，我们将为这一章创建一个新的标签，`android-7.1.1_r4_x86emu_ch05_r1`。
- en: 'After we make all the changes, we also need to update the manifest file so
    that we can have a manifest to download the code for this chapter. Instead of
    using tags, I use branches to manage manifests. The branch for this chapter''s
    manifests is `android-7.1.1_r4_ch05_aosp`. We can use the following command to
    download the source code of:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成所有修改后，我们还需要更新清单文件，以便我们可以有一个清单来下载本章的代码。我不用标签，而是用分支来管理清单。本章清单的分支是 `android-7.1.1_r4_ch05_aosp`。我们可以使用以下命令下载以下内容的源代码：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you set up the local mirror as we discussed in [Chapter 2](984e0cef-7bf6-4454-bede-bb34c553be12.xhtml),
    *Setting Up the Development Environment*, you can check out the source code as
    follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已按照我们在 [第 2 章](984e0cef-7bf6-4454-bede-bb34c553be12.xhtml)，*设置开发环境* 中讨论的方式设置了本地镜像，你可以按照以下方式检出源代码：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You need to create an `android-7.1.1_r4_ch05` branch for your own local mirror
    referring to the `android-7.1.1_r4_ch05_aosp` branch.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要为你的本地镜像创建一个 `android-7.1.1_r4_ch05` 分支，它引用了 `android-7.1.1_r4_ch05_aosp`
    分支。
- en: 'After we create a working copy of the source code using the preceding manifest,
    we can look at the `.repo/manifest.xml` file:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的清单创建源代码的工作副本后，我们可以查看 `.repo/manifest.xml` 文件：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding manifest file, we use the `android-7.1.1_r4_x86emu_ch05_r1`
    tag to tag all projects that are not in AOSP projects. The `device/generic/common`
    project is duplicated from Android-x86 and the `device/generic/goldfish` project
    is duplicated from AOSP. Besides `kernel` and `device/generic/x86emu`, these are
    the two projects that we need to change in this chapter.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的清单文件中，我们使用 `android-7.1.1_r4_x86emu_ch05_r1` 标签标记所有不在 AOSP 项目中的项目。`device/generic/common`
    项目是从 Android-x86 复制的，而 `device/generic/goldfish` 项目是从 AOSP 复制的。除了 `kernel` 和 `device/generic/x86emu`，这些是我们本章需要更改的两个项目。
- en: Extending the x86emu device
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展 x86emu 设备
- en: Once we have done all the changes for the source code configuration, we can
    start to extend the x86emu device to support Houdini now. What are the changes
    that we have to make? Since I have done all the changes before I explained them
    here, let's use a tool to compare the difference between the source code in [Chapter
    4](f69f330a-932c-4a32-bb78-e427c860b65e.xhtml), *Customizing the Android Emulator*
    and this chapter's code.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们对源代码配置的所有更改都完成了，我们现在就可以开始扩展 x86emu 设备以支持 Houdini。我们需要做出哪些更改？由于我在解释之前已经做了所有更改，让我们使用一个工具来比较
    [第 4 章](f69f330a-932c-4a32-bb78-e427c860b65e.xhtml) 中 *自定义 Android 模拟器* 和本章代码的源代码之间的差异。
- en: '![](img/image_05_007.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_007.png)'
- en: Changes to support Houdini
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 支持Houdini的更改
- en: As we can see in the preceding screenshot, we added a `system` folder and we
    modified four Makefiles. We can ignore the `x86emu_x86_64.mk` Makefile, since
    we won't discuss 64-bit builds in this book. The changes to `x86emu_x86_64.mk`
    are similar to those for `x86emu_x86.mk`, so we save ourselves the effort of discussing
    similar things twice. It won't be a significant effort for you to enable a 64-bit
    build for x86emu by yourself. The other two files, `.cproject` and `.project`,
    are generated due to Eclipse integration and we can ignore them too. Let's look
    at `BoardConfig.mk`, `x86emu_x86.mk`, and `device.mk` one by one.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图所示，我们添加了一个 `system` 文件夹，并修改了四个 Makefile。我们可以忽略 `x86emu_x86_64.mk` Makefile，因为我们不会在本书中讨论
    64 位构建。`x86emu_x86_64.mk` 的更改与 `x86emu_x86.mk` 的更改类似，所以我们省去了重复讨论类似内容的麻烦。你自己启用
    x86emu 的 64 位构建不会是一个很大的工作量。其他两个文件，`.cproject` 和 `.project`，是由于 Eclipse 集成而生成的，我们也可以忽略它们。让我们逐一查看
    `BoardConfig.mk`、`x86emu_x86.mk` 和 `device.mk`。
- en: Changes to BoardConfig.mk
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对 BoardConfig.mk 的更改
- en: 'In the board configuration file, we need to add an ARM instruction set to the
    CPU ABI list so that the program can detect support for the ARM instruction set
    as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在板配置文件中，我们需要将 ARM 指令集添加到 CPU ABI 列表中，以便程序可以检测对 ARM 指令集的支持，如下所示：
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You may have noticed the `BUILD_ARM_FOR_X86` macro. This macro is used by Android-x86
    Houdini support and we will discuss it later.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了 `BUILD_ARM_FOR_X86` 宏。这个宏被 Android-x86 Houdini 支持使用，我们将在稍后讨论它。
- en: Changes to x86emu_x86.mk
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对 x86emu_x86.mk 的更改
- en: 'In the product definition Makefile, `x86emu_x86.mk`, we set the `persist.sys.nativebridge`
    property to `1`. Then we copy all files under the `$AOSP/device/generic/x86emu/system`
    folder to the `$OUT/system` image. All the files under the `$AOSP/device/generic/x86emu/system/lib/arm`
    folder are a copy of the Houdini libraries:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在产品定义的 Makefile 中，`x86emu_x86.mk`，我们将 `persist.sys.nativebridge` 属性设置为 `1`。然后我们将
    `$AOSP/device/generic/x86emu/system` 文件夹下的所有文件复制到 `$OUT/system` 映像中。`$AOSP/device/generic/x86emu/system/lib/arm`
    文件夹下的所有文件都是 Houdini 库的副本：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Changes to device.mk
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对 device.mk 的更改
- en: 'In the device Makefile `device.mk`, we only added one line to include another
    Makefile, `nativebridge.mk`, in the `device/generic/common/nativebridge` directory.
    As we discussed in the section on source configuration, we use the one from Android-x86
    to support Houdini integration. We will analyze the `nativebridge.mk` Makefile
    in the next section:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在设备 Makefile `device.mk` 中，我们只添加了一行来包含另一个 Makefile，`nativebridge.mk`，在 `device/generic/common/nativebridge`
    目录下。正如我们在源配置章节中讨论的那样，我们使用 Android-x86 的版本来支持 Houdini 集成。我们将在下一节分析 `nativebridge.mk`
    Makefile：
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Using the Android-x86 implementation
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Android-x86 实现
- en: Since we use Houdini support from the Android-x86 project, we can see that we
    only need to make very minor changes to the x86emu Makefiles.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用 Android-x86 项目的 Houdini 支持，我们可以看到我们只需要对 x86emu Makefile 进行非常小的修改。
- en: 'Now let''s look at `nativebridge.mk` in Android-x86:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看 Android-x86 中的 `nativebridge.mk`：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`nativebridge.mk` copies an `enable_nativebridge` script to the `system` folder
    first. After that, it sets the `ro.dalvik.vm.isa.arm` and `ro.enable.native.bridge.exec`
    properties. These two properties will be added to `system/build.prop` in the system
    image. It also sets the default property `ro.dalvik.vm.native.bridge` to `libnb.so`.
    This property is used by ART to find the Houdini library. Android-x86 uses the
    `libnb.so` library instead of `libhoudini.so`, which all supported Intel devices
    use. The `libnb.so` library is a wrapper of `libhoudini.so`. Since we use `libnb.so`
    as the ARM binary translation library, we need to add this package to the build.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`nativebridge.mk` 首先将 `enable_nativebridge` 脚本复制到 `system` 文件夹。之后，它设置 `ro.dalvik.vm.isa.arm`
    和 `ro.enable.native.bridge.exec` 属性。这两个属性将被添加到系统镜像中的 `system/build.prop` 文件中。它还设置了默认属性
    `ro.dalvik.vm.native.bridge` 为 `libnb.so`。此属性由 ART 用于查找 Houdini 库。Android-x86
    使用 `libnb.so` 库而不是所有支持英特尔设备都使用的 `libhoudini.so`。`libnb.so` 库是 `libhoudini.so`
    的包装器。由于我们使用 `libnb.so` 作为 ARM 二进制翻译库，我们需要将此包添加到构建中。'
- en: Analyzing libnb.so
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析 libnb.so
- en: 'Since the `libnb.so` library is the key starting point for Native Bridge support
    in Android-x86, we will dive into the details of it now. The Makefile to build
    `libnb.so` can be found at `device/generic/common/nativebridge/Android.mk`. The
    source code for `libnb.so` includes only one file, `libnb.cpp`, as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `libnb.so` 库是 Android-x86 中 Native Bridge 支持的关键起点，我们现在将深入探讨其细节。构建 `libnb.so`
    的 Makefile 可以在 `device/generic/common/nativebridge/Android.mk` 中找到。`libnb.so`
    的源代码仅包含一个文件，即 `libnb.cpp`，如下所示：
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In `libnb.cpp`, we can see that it loads the `libhoudini.so` library, which
    is the original Houdini library from Intel, and it makes only two changes. It
    checks the `persist.sys.nativebridge` property before it does the initialization.
    The rest of the code provides a wrapper of `NativeBridgeCallbacks` and the wrapper
    functions call the one in the Houdini library directly.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `libnb.cpp` 中，我们可以看到它加载了 `libhoudini.so` 库，这是英特尔提供的原始 Houdini 库，并且它只做了两个修改。在初始化之前，它检查
    `persist.sys.nativebridge` 属性。其余的代码提供了一个 `NativeBridgeCallbacks` 的包装器，包装器函数直接调用
    Houdini 库中的函数。
- en: Using binfmt_misc
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 binfmt_misc
- en: Up to now, what we have discussed is how to load an ARM shared library in the
    Intel x86 architecture. Houdini can also support running standalone ARM applications
    on Intel devices as well. To do this, it uses a mechanism called `binfmt_misc`.
    `binfmt_misc`, which is a capability of the Linux kernel that allows arbitrary
    executable file formats to be recognized and passed to certain user space applications,
    such as emulators and virtual machines.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所讨论的是如何在英特尔 x86 架构中加载 ARM 共享库。Houdini 还可以支持在英特尔设备上运行独立的 ARM 应用程序。为此，它使用了一种称为
    `binfmt_misc` 的机制。`binfmt_misc` 是 Linux 内核的一种功能，允许识别任意可执行文件格式并将其传递给某些用户空间应用程序，例如模拟器和虚拟机。
- en: According to the Linux kernel documentation, this kernel feature allows you
    to invoke almost every program by simply typing its name in the shell. This includes,
    for example, compiled Java (TM), Python, or Emacs. To achieve this, you must tell
    `binfmt_misc` which interpreter should be invoked with which binary. `binfmt_misc`
    recognizes the binary-type by matching some bytes at the beginning of the file
    with a magic byte sequence (masking out specified bits) that you have supplied.
    `binfmt_misc` can also recognize a filename extension such as `.com` or `.exe`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Linux内核文档，此内核功能允许您通过在shell中简单地键入程序名称来调用几乎每个程序。例如，这包括编译的Java (TM)、Python或Emacs。为了实现这一点，您必须告诉
    `binfmt_misc` 应该使用哪个解释器调用哪个二进制文件。`binfmt_misc` 通过匹配您提供的魔字节序列（屏蔽指定的位）与文件开头的某些字节来识别二进制类型。`binfmt_misc`
    还可以识别文件扩展名，如 `.com` 或 `.exe`。
- en: 'To use this method, first we must mount `binfmt_misc`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此方法，首先我们必须挂载 `binfmt_misc`：
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To register a new binary type, we must set up a string that looks as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要注册新的二进制类型，我们必须设置一个看起来如下所示的字符串：
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Then we need to add it to `/proc/sys/fs/binfmt_misc/register`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要将其添加到 `/proc/sys/fs/binfmt_misc/register`。
- en: 'Here is what the fields mean:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这些字段的意义：
- en: '`name` is an identifier string. A new `/proc` file will be created with this
    name below the `/proc/sys/fs/binfmt_misc` directory.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name` 是一个标识符字符串。在 `/proc/sys/fs/binfmt_misc` 目录下将创建一个以该名称命名的新 `/proc` 文件。'
- en: '`type` is the type of recognition. It gives `M` for magic and `E` for extension.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type` 是识别类型。它给出 `M` 表示 magic 和 `E` 表示扩展。'
- en: '`offset` is the offset of the magic/mask in the file, counted in bytes. This
    defaults to 0 if you omit it (that is, you write `:name:type::magic...`).'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`offset` 是文件中 magic/mask 的偏移量，按字节计算。如果你省略它（即，你写入 `:name:type::magic...`），则默认为
    0。'
- en: '`magic` is the byte sequence that `binfmt_misc` is matching for. The magic
    string may contain hex-encoded characters such as `\x0a` or `\xA4`. In a shell
    environment, you should write `\\x0a` to prevent the shell from eating your `\`.
    If you chose the matching filename extension, this is the extension to be recognized
    (without the `.`, the `\x0a` specials are not allowed). Extension matching is
    case-sensitive.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`magic` 是 `binfmt_misc` 匹配的字节序列。magic 字符串可能包含十六进制编码的字符，如 `\x0a` 或 `\xA4`。在
    shell 环境中，你应该写 `\\x0a` 以防止 shell 吃掉你的 `\`。如果你选择了匹配的文件名扩展名，这是要识别的扩展名（不带 `.`，不允许
    `\x0a` 特殊字符）。扩展名匹配是区分大小写的。'
- en: '`mask` is a (optional, defaults to all `0xff`) mask. You can mask out some
    bits from matching by supplying a string like magic.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mask` 是一个（可选，默认为所有 `0xff`）掩码。你可以通过提供一个类似于 magic 的字符串来屏蔽匹配的一些位。'
- en: '`interpreter` is the program that should be invoked with the binary as the
    first argument (specify the full path).'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`interpreter` 是应该用二进制文件作为第一个参数调用的程序（指定完整路径）。'
- en: '`flags` is an optional field that controls several aspects of the invocation
    of the interpreter. It is a string of capital letters and each controls a certain
    aspect.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags` 是一个可选字段，它控制解释器调用的几个方面。它是一个大写字母的字符串，每个字母控制一个特定的方面。'
- en: 'In `nativebridge.mk`, it copies an `enable_nativebridge` script to the `system`
    folder. This file is used to enable Houdini in Android-x86\. In Android-x86, Houdini
    is not enabled by default. This can be turned on at any time using an option in
    Settings app of Android-x86\. Of course, this is not supported in the AOSP source
    code. When you turn on Houdini in Android-x86, it calls the `enable_nativebridge`
    script. This script does two things:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `nativebridge.mk` 中，它将 `enable_nativebridge` 脚本复制到 `system` 文件夹。此文件用于在 Android-x86
    中启用 Houdini。在 Android-x86 中，Houdini 默认未启用。这可以通过在 Android-x86 设置应用中的选项随时打开。当然，这不在
    AOSP 源代码中得到支持。当你打开 Android-x86 中的 Houdini 时，它会调用 `enable_nativebridge` 脚本。此脚本执行两件事：
- en: It downloads Houdini from the third-party project repository to the local repository
    and installs it in the `/system/lib/arm` system directory. It also sets the `persist.sys.nativebridge`
    property to `1`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它从第三方项目仓库下载 Houdini 到本地仓库，并将其安装到 `/system/lib/arm` 系统目录中。它还设置 `persist.sys.nativebridge`
    属性为 `1`。
- en: In the second part of this script, it creates the `binfmt_misc` files in the
    `/proc` directory.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此脚本的第二部分，它会在 `/proc` 目录中创建 `binfmt_misc` 文件。
- en: 'We won''t use the `enable_nativebridge` script directly, but we want to run
    the second part of `enable_nativebridge` at the system start. With the second
    part, Houdini is enabled in the Android emulator by default. This can be done
    by adding the second part of `enable_nativebridge` to `device/generic/goldfish/init.goldfish.sh`.
    The following is the code snippet that we added to the end of `init.goldfish.sh`.
    This is the script that is used to set up the environment for the Android emulator
    during system startup:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会直接使用 `enable_nativebridge` 脚本，但希望在系统启动时运行 `enable_nativebridge` 的第二部分。通过第二部分，Houdini
    在 Android 模拟器中默认启用。这可以通过将 `enable_nativebridge` 的第二部分添加到 `device/generic/goldfish/init.goldfish.sh`
    来完成。以下是我们添加到 `init.goldfish.sh` 结尾的代码片段。这是在系统启动时用于设置 Android 模拟器环境的脚本：
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After we rebuild the image and start the emulator, we can verify the changes
    using the following command:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们重新构建镜像并启动模拟器后，我们可以使用以下命令验证更改：
- en: '[PRE31]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can see that we registered two `binfmt_misc` types: `arm_dyn` and `arm_exe`.
    The `/proc` file `arm_dyn` is used to load the shared library and `arm_exe` is
    used to load the ARM executable:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们注册了两个 `binfmt_misc` 类型：`arm_dyn` 和 `arm_exe`。`/proc` 文件 `arm_dyn` 用于加载共享库，而
    `arm_exe` 用于加载 ARM 可执行文件：
- en: '[PRE32]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If we look at the content of `arm_exe`, from the preceding output we can see
    that the `/system/lib/arm/houdini` interpreter is used to interpret ARM binaries.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看 `arm_exe` 的内容，从前面的输出中我们可以看到，`/system/lib/arm/houdini` 解释器用于解释 ARM 二进制文件。
- en: Building and testing
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和测试
- en: 'We have made all the code changes to enable Houdini now. We can build the system
    image using the following commands:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经对代码进行了所有更改，以启用 Houdini。我们可以使用以下命令构建系统镜像：
- en: '[PRE33]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: After we build the system image, we can test it. Of course, we can test the
    images using any Android application that can run on the ARM architecture. However,
    in order to get details about the test targets, we will use two unit test applications
    to verify our work in this chapter. The first one is a standalone ARM application
    that can be run from the command line. The second one is an Android application
    with a JNI shared library for ARM only. The Android emulator images and test binaries
    in this chapter can be downloaded from [https://sourceforge.net/projects/android-system-programming/files/android-7/ch05/ch05.zip/download](https://sourceforge.net/projects/android-system-programming/files/android-7/ch05/ch05.zip/download).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们构建系统镜像之后，我们可以对其进行测试。当然，我们可以使用任何可以在 ARM 架构上运行的 Android 应用程序来测试镜像。然而，为了获取有关测试目标的详细信息，我们将使用两个单元测试应用程序来验证本章中的工作。第一个是一个独立的
    ARM 应用程序，可以从命令行运行。第二个是一个仅针对 ARM 的 JNI 共享库的 Android 应用程序。本章中的 Android 模拟器镜像和测试二进制文件可以从
    [https://sourceforge.net/projects/android-system-programming/files/android-7/ch05/ch05.zip/download](https://sourceforge.net/projects/android-system-programming/files/android-7/ch05/ch05.zip/download)
    下载。
- en: The source code for these two test applications is hosted on GitHub. You can
    get the source code at [https://github.com/shugaoye/asp-sample/tree/master/ch05](https://github.com/shugaoye/asp-sample/tree/master/ch05).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个测试应用程序的源代码托管在 GitHub 上。您可以从 [https://github.com/shugaoye/asp-sample/tree/master/ch05](https://github.com/shugaoye/asp-sample/tree/master/ch05)
    获取源代码。
- en: To build the test applications, you need to have both Android SDK and NDK so
    that you can build both Android applications and native applications.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建测试应用程序，您需要同时拥有 Android SDK 和 NDK，这样您就可以构建 Android 应用程序和本地应用程序。
- en: Testing the command-line application
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试命令行应用程序
- en: 'After you clone the preceding Git repository for test applications, you can
    build and test them. Let''s test the command-line application first. It is a very
    simple "hello world" application to print just one line message to standard output
    as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在您克隆了测试应用程序的先前 Git 仓库之后，您可以构建和测试它们。让我们首先测试命令行应用程序。这是一个非常简单的“hello world”应用程序，它将一行消息打印到标准输出，如下所示：
- en: '[PRE34]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You can build it and test it in the emulator as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在模拟器中按照以下方式构建和测试它：
- en: '[PRE35]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: After you build it, you can check the file format using the `file` command.
    You can see that the output is a 32-bit ARM ELF file. You can push this binary
    to the emulator using `adb` and run it. You will see that it can print the output
    message to standard output correctly.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建完成后，您可以使用 `file` 命令检查文件格式。您可以看到输出是一个32位的ARM ELF文件。您可以使用 `adb` 将此二进制文件推送到模拟器并运行它。您将看到它可以将输出消息正确地打印到标准输出。
- en: Testing the Android JNI application
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 Android JNI 应用程序
- en: Next, let's test the Android application with the ARM JNI library.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们测试带有 ARM JNI 库的 Android 应用程序。
- en: 'The JNI library can be found at `ch05/test2/jni`. The processor architecture
    that can be supported is defined in `Application.mk` as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: JNI 库位于 `ch05/test2/jni`。支持的处理器架构在 `Application.mk` 中定义如下：
- en: '[PRE36]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can see that we build the JNI library for `armeabi` and `armeabi-v7a`. Let''s
    build the JNI library using NDK first:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们为 `armeabi` 和 `armeabi-v7a` 构建了 JNI 库。让我们首先使用 NDK 构建JNI库：
- en: '[PRE37]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'After we build the JNI library, we can import the Android source code to Eclipse
    or Android Studio to build the application itself. We won''t explain the details
    of importing and building Android applications. You can read books on how to develop
    an Android application and how to develop a JNI library to find out more. What
    we want to investigate here is the test result. After we have the APK file, we
    can install it in the emulator and run it. At the same time, we can catch the
    debug log using logcat. Here is the log from my environment:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们构建 JNI 库之后，我们可以将 Android 源代码导入到 Eclipse 或 Android Studio 中来构建应用程序本身。我们不会解释导入和构建
    Android 应用程序的详细步骤。您可以通过阅读关于如何开发 Android 应用程序和如何开发 JNI 库的书籍来了解更多信息。我们在这里想要调查的是测试结果。在我们获得
    APK 文件后，我们可以在模拟器中安装并运行它。同时，我们可以使用 logcat 捕获调试日志。以下是我环境的日志：
- en: '[PRE38]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We can see from the preceding log message that Houdini is initialized successfully
    and that the `libHelloJNI.so` JNI library is loaded by Native Bridge.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的日志消息中我们可以看到 Houdini 已成功初始化，并且 `libHelloJNI.so` JNI 库已被 Native Bridge 加载。
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we introduced Native Bridge in Android architecture first
    so that we can understand how it works. Based on our understanding of Native Bridge,
    we extended the x86emu device with Houdini support. We changed the Makefiles of
    the x86emu device and we also utilized the open source project Android-x86 to
    save the effort of integration. After we integrated Houdini in x86emu, we tested
    two scenarios of Houdini use:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先介绍了 Android 架构中的 Native Bridge，以便我们了解其工作原理。基于我们对 Native Bridge 的理解，我们扩展了
    x86emu 设备以支持 Houdini。我们修改了 x86emu 设备的 Makefiles，并且还利用了开源项目 Android-x86 来节省集成工作。在我们将
    Houdini 集成到 x86emu 之后，我们测试了两种 Houdini 的使用场景：
- en: A standalone command-line application
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个独立的命令行应用程序
- en: An Android application with a native shared library built with JNI
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个使用 JNI 构建的本地共享库的 Android 应用程序
- en: In the next chapter, we will explore more about the x86emu start up process
    and we will learn how to debug the start up process using a customized ramdisk
    image.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨更多关于 x86emu 启动过程的内容，并且我们将学习如何使用定制的 ramdisk 图像来调试启动过程。
