- en: Building iOS Apps with Swift
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Swift 构建 iOS 应用
- en: In this chapter, we'll be building our very own iOS app using Swift and the
    Xcode IDE. Once we've built our app, we'll look at how we can incorporate unit
    tests and **user interface** (**UI**) tests. Finally, we'll take a look at backward
    compatibility in Swift and iOS development.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 Swift 和 Xcode IDE 构建我们自己的 iOS 应用。一旦我们构建了我们的应用，我们将探讨如何集成单元测试和 **用户界面**（**UI**）测试。最后，我们将探讨
    Swift 和 iOS 开发中的向后兼容性。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Building an iOS App using Cocoa Touch
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Cocoa Touch 构建 iOS 应用
- en: Unit and integration testing with XCTest
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 XCTest 进行单元和集成测试
- en: User interface testing with XCUITest
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 XCUITest 进行用户界面测试
- en: Backward compatibility
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向后兼容性
- en: Let's get started!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you'll need the latest version of Xcode from the Mac App Store.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您需要从 Mac App Store 获取 Xcode 的最新版本。
- en: All the code for this chapter can be found in this book's GitHub repository
    at [https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter06](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter06)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码都可以在本书的 GitHub 仓库中找到，地址为 [https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter06](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter06)
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3pMG44r](https://bit.ly/3pMG44r)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码的实际应用：[https://bit.ly/3pMG44r](https://bit.ly/3pMG44r)
- en: Building an iOS App using Cocoa Touch
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Cocoa Touch 构建 iOS 应用
- en: The focus of this book is ultimately on the Swift programming language itself,
    as opposed to the use of the language to produce apps for Apple platforms or to
    build server-side services. That being said, it can't be ignored that the vast
    majority of the Swift code being written is to build, or build upon, iOS and iPadOS
    apps.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的核心重点是 Swift 编程语言本身，而不是使用该语言为 Apple 平台生成应用或构建服务器端服务。尽管如此，不能忽视的是，绝大多数正在编写的
    Swift 代码是用来构建或基于 iOS 和 iPadOS 应用构建的。
- en: In this recipe, we will take a brief look at how we can interact with Apple's
    Cocoa Touch frameworks using Swift and begin to build and create our very own
    iOS app.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将简要了解如何使用 Swift 与 Apple 的 Cocoa Touch 框架交互，并开始构建和创建我们自己的 iOS 应用。
- en: '**Cocoa Touch** is a name given to the collection of UI frameworks available
    as part of the iOS SDK. Its name derives from the Cocoa framework on macOS, which
    provides UI elements for macOS apps. While Cocoa on macOS is a framework in its
    own right, Cocoa Touch is a collection of frameworks that provide UI elements
    for iOS apps and handle the app''s life cycle; the core of these frameworks is
    **UIKit**.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**Cocoa Touch** 是指作为 iOS SDK 部分提供的 UI 框架集合的名称。其名称来源于 macOS 上的 Cocoa 框架，它为 macOS
    应用提供 UI 元素。虽然 macOS 上的 Cocoa 是一个独立的框架，但 Cocoa Touch 是一组提供 iOS 应用 UI 元素并处理应用生命周期的框架；这些框架的核心是
    **UIKit**。'
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'First, we''ll need to create a new iOS app project:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个新的 iOS 应用项目：
- en: From the Xcode menu, choose File, then New.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Xcode 菜单中选择文件，然后新建。
- en: 'From the dialog box that opens, choose App from the iOS tab:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在打开的对话框中，从 iOS 选项卡中选择 App：
- en: '![](img/9d0443fb-bcc3-4271-8a5b-f29776d14047.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9d0443fb-bcc3-4271-8a5b-f29776d14047.png)'
- en: Figure 6.1 – Choosing a template
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 选择模板
- en: The next dialog box asks you to enter details about your app, pick a product
    name and organization name, and add an organization identifier in reverse DNS
    style.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个对话框会要求您输入有关您应用的详细信息，选择产品名称和组织名称，并添加以反向 DNS 风格的组织标识符。
- en: 'Reverse DNS style means to take a website that you or your company owns and
    reverse the order of the domain name components. So, for example, [http://maps.google.com](http://maps.google.com)
    becomes `com.google.maps`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 反向 DNS 风格意味着取一个你或你的公司拥有的网站，并反转域名组件的顺序。例如，[http://maps.google.com](http://maps.google.com)
    变为 `com.google.maps`：
- en: '![](img/e9408b6c-f725-42c2-819e-38505ba39b10.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e9408b6c-f725-42c2-819e-38505ba39b10.png)'
- en: Figure 6.2 – Options for a new project
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – 新项目的选项
- en: Pay attention to the preceding choices as not all of them may be selected by
    default. For this recipe, the ones that are important to us are **Interface**
    and **Include Tests**, both of which we'll cover later on this in the chapter
    when we look at unit testing with XCTest and user interface testing with XCUITest.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意前面的选择，因为并非所有选项都默认选中。对于这个食谱，对我们来说重要的是**界面**和**包含测试**，这两个我们将在本章后面讨论，当我们查看使用
    XCTest 进行单元测试和 XCUITest 进行用户界面测试时。
- en: 'Once you''ve chosen a save location on your Mac, you will be presented with
    the following Xcode layout:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你在Mac上选择了保存位置，你将看到以下Xcode布局：
- en: '![](img/5faac001-b8c2-4ba1-8e15-2c701e61a944.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5faac001-b8c2-4ba1-8e15-2c701e61a944.png)'
- en: Figure 6.3 – New project template
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – 新项目模板
- en: Here, we have the start of our project – it's not much, but it's where all new
    iOS apps begin.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们开始了我们的项目——它并不多，但这是所有新的iOS应用开始的地方。
- en: From this menu, press **Product** | **Run**. Xcode will now compile and run
    your app in a simulator.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个菜单中，按**产品** | **运行**。Xcode现在将在模拟器中编译并运行你的应用。
- en: How to do it...
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Continuing from a previous recipe, we''ll build our app based on data that
    is returned from the Public GitHub API:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前的食谱继续，我们将基于从Public GitHub API返回的数据构建我们的应用：
- en: In the File Explorer, click on Main.storyboard; this view is a representation
    of what the app will look like and is called Interface Builder. At the moment,
    there is only one blank screen visible, which matches what the app looked like
    when we ran it earlier. This screen represents a `View Controller` object; as
    the name suggests, this is an object that controls views.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件资源管理器中，点击Main.storyboard；这个视图是应用外观的表示，被称为界面构建器。目前，只有一个空白屏幕可见，这与我们之前运行应用时的外观相匹配。这个屏幕代表一个`View
    Controller`对象；正如其名所示，这是一个控制视图的对象。
- en: 'We will display our list of repositories in a table. We actually want to create
    a view controller class that is a subclass of `UITableViewController`. So, from
    the menu, choose File, then New, and select a Cocoa Touch Class template:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在表格中显示我们的存储库列表。实际上，我们想要创建一个视图控制器类，它是`UITableViewController`的子类。因此，从菜单中选择文件，然后选择新建，并选择Cocoa
    Touch类模板：
- en: '![](img/d3b6cd05-c7f8-45d7-84dc-41449151fb0f.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d3b6cd05-c7f8-45d7-84dc-41449151fb0f.png)'
- en: Figure 6.4 – New file template
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – 新文件模板
- en: 'We will be displaying repositories in this view controller, so let''s call
    it `ReposTableViewController`. Specify that it''s a subclass of `UITableViewController`
    and ensure that the language is Swift:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在这个视图控制器中显示存储库，所以让我们称它为`ReposTableViewController`。指定它是`UITableViewController`的子类，并确保语言是Swift：
- en: '![](img/5f93a8a2-25f9-4865-9869-05a4e38af8b6.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5f93a8a2-25f9-4865-9869-05a4e38af8b6.png)'
- en: Figure 6.5 – New filename and subclass
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 – 新的文件名和子类
- en: Now that we have created our view controller class, let's switch back to `Main.storyboard`
    and delete the blank view controller that was created for us.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了我们的视图控制器类，让我们切换回`Main.storyboard`并删除为我们创建的空白视图控制器。
- en: 'From the object library, find the Table View Controller option and drag it
    into the Interface Builder editor:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从对象库中找到表格视图控制器选项，并将其拖入界面构建器编辑器：
- en: '![](img/a7c67a2b-ea93-4e2a-ab48-86624c08414d.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a7c67a2b-ea93-4e2a-ab48-86624c08414d.png)'
- en: Figure 6.6 – Object library
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 – 对象库
- en: 'Now that we have a table view controller, we want this controller to be part
    of our custom subclass. To do this, select the controller, go into the class inspector,
    enter `ReposTableViewController` as the Class type, and press *Enter*:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有一个表格视图控制器，我们希望这个控制器成为我们自定义子类的一部分。要做到这一点，选择控制器，进入类检查器，将类类型输入为`ReposTableViewController`，然后按*Enter*：
- en: '![](img/e95442cb-b8d9-4c44-966f-872d167a4451.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e95442cb-b8d9-4c44-966f-872d167a4451.png)'
- en: 'Figure 6.7: Custom class inspector'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7：自定义类检查器
- en: Although we have the view controller that will be displaying the repository
    names, when a user selects a repository, we want to present a new view controller
    that will show details about that particular repo. We will cover what type of
    view controller that is and how we present it shortly, but first, we need a mechanism
    for navigating between view controllers.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们有将显示存储库名称的视图控制器，但当用户选择一个存储库时，我们希望展示一个新的视图控制器来显示该特定存储库的详细信息。我们将很快介绍这种类型的视图控制器以及如何展示它，但首先，我们需要一种在视图控制器之间导航的机制。
- en: 'If you have ever used an iOS app, you will be familiar with the standard ***push***
    and ***pop*** way of navigating between views. The following screenshot shows
    an app in the middle of that transition:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用过iOS应用，你将熟悉在视图之间导航的标准***推送***和***弹出***方式。以下截图显示了应用在过渡过程中的中间状态：
- en: '![](img/5200aebe-b4c3-4185-85a2-be040038a1a7.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5200aebe-b4c3-4185-85a2-be040038a1a7.png)'
- en: Figure 6.8 – Push and pop view controller
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8 – 推送和弹出视图控制器
- en: 'The management of these view controllers, as well as their presentation and
    dismissal transitions, are handled by a navigation controller, which is provided
    by Cocoa Touch in the form of `UINavigationController`. Let''s take a look:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这些视图控制器的管理，以及它们的展示和消失转换，由一个导航控制器处理，这是Cocoa Touch以`UINavigationController`的形式提供的。让我们看看：
- en: To place our view controller inside a navigation controller, select `ReposTableViewController`
    in Interface Builder. Then, from the Xcode menu, go to Editor and then Embed In
    and choose Navigation Controller.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将我们的视图控制器放入导航控制器中，在Interface Builder中选择`ReposTableViewController`。然后，从Xcode菜单中，转到编辑，然后嵌入，并选择导航控制器。
- en: This will add a navigation controller to the storyboard and set the selected
    view controller as its root view controller (*if there is an existing v**iew con**troller*
    *already inside the storyboard from the initial project we created, this can be
    highlighted and deleted*).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在故事板中添加一个导航控制器，并将选定的视图控制器设置为它的根视图控制器（*如果故事板中已经存在一个从最初创建的项目中导入的视图控制器，可以将其突出显示并删除*）。
- en: Next, we need to define which view controller is initially on the screen when
    the app starts. Select Navigation Controller on the left-hand side of the screen
    and within the property inspector, select Is Initial View Controller. You will
    see that an entry arrow will point toward the navigation controller on the left,
    indicating that it will be shown initially.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义当应用启动时屏幕上最初显示哪个视图控制器。在屏幕左侧选择导航控制器，然后在属性检查器中选择“是否为初始视图控制器”。你会看到一条箭头指向左侧的导航控制器，表示它将最初显示。
- en: With this set up, we can start working on our `ReposTableViewController` by
    selecting it from the File navigator menu.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这个设置，我们可以通过从文件导航菜单中选择它来开始工作我们的`ReposTableViewController`。
- en: When we created our view controller, the template gave us a bunch of code, with
    some of it commented out. The first method that the template provides is `viewDidLoad`.
    This is part of a set of methods that cover the life cycle of the root view that
    the view controller is managing. Full details about the view life cycle and its
    relevant method calls can be found at [http://swiftbook.link/docs/vc-lifecycle](http://swiftbook.link/docs/vc-lifecycle).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建视图控制器时，模板给我们提供了一堆代码，其中一些是注释掉的。模板提供的第一个方法是`viewDidLoad`。这是覆盖视图控制器管理的根视图生命周期的方法集的一部分。关于视图生命周期及其相关方法调用的完整详细信息，可以在[http://swiftbook.link/docs/vc-lifecycle](http://swiftbook.link/docs/vc-lifecycle)找到。
- en: '`viewDidLoad` is fired quite early on in the view controller''s life cycle
    but before the view controller is visible to the user. Due to this, it is a good
    place to configure the view and retrieve any information that you want to present
    to the user.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`viewDidLoad`在视图控制器生命周期中非常早的时候被触发，但在视图控制器对用户可见之前。由于这个原因，这是一个配置视图和检索任何你想要向用户展示的信息的好地方。'
- en: 'Let''s give the view controller a title:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们给视图控制器一个标题：
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, if you Build and Run the app, you'll see a navigation bar with the title
    we just added programmatically.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你构建并运行应用，你会看到一个带有我们刚刚通过编程添加的标题的导航栏。
- en: 'Next, we''ll fetch and display a list of GitHub repositories. Implement the
    following snippet of code in order to fetch a list of repos for a specific user:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将获取并显示GitHub仓库列表。为了获取特定用户的仓库列表，实现以下代码片段：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s add the following highlighted code to the top of the file, before the
    start of the class definition. We will also add a session property to the view
    controller, which is needed for the network request:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在文件的顶部添加以下突出显示的代码，在类定义之前。我们还将向视图控制器添加一个会话属性，这是网络请求所需的：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You may notice something a little different about the preceding functions since
    we're now making full use of Swift's **Codable** protocol. With Codable, we can
    map the JSON response from our API straight to our struct models, without the
    need to convert this into a dictionary and then iterate each key-value pair to
    a property.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到前面的函数有一些不同，因为我们现在正在充分利用Swift的**Codable**协议。使用Codable，我们可以将API的JSON响应直接映射到我们的结构模型，而无需将其转换为字典，然后迭代每个键值对到一个属性。
- en: 'Next, in our table view, each row of the table view will display the name of
    one of the repositories that we retrieve from the GitHub API. We need a place
    to store the repositories that we retrieve from the API:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在我们的表格视图中，表格的每一行将显示我们从GitHub API检索到的其中一个仓库的名称。我们需要一个地方来存储我们从API检索到的仓库：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `repos` array has an initially empty array value, but we will use this property
    to hold the fetched results from the API.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`repos` 数组有一个初始为空的数组值，但我们将使用这个属性来存储从 API 获取的结果。'
- en: 'We don''t need to fetch the repository data right now. So, instead, we''ll
    learn how to provide data to be used in the table view. Let''s get started:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在不需要获取仓库数据。因此，我们将学习如何提供用于表格视图的数据。让我们开始吧：
- en: 'Let''s create a couple of fake repositories so that we can temporarily populate
    our table view:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一些假仓库，这样我们就可以暂时填充我们的表格视图：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The information in a table view is populated from the table view's data source,
    which can be any object that conforms to the `UITableViewDataSource`
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 表格视图中的信息是从表格视图的数据源中填充的，这个数据源可以是任何符合 `UITableViewDataSource` 协议的对象。
- en: protocol.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 协议。
- en: When the table view is displayed and the user interacts with it, the table view
    will ask the data source for the information it needs to populate the table view.
    For simple table view implementations, it is often the view controller that controls
    the table view that acts as the data source. In fact, when you create a subclass
    of `UITableViewController`, as we have, the view controller already conforms to
    `UITableViewDataSource` and is assigned as the table view's data source.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当表格视图显示并且用户与之交互时，表格视图将要求数据源提供它需要的信息以填充表格视图。对于简单的表格视图实现，通常控制表格视图的视图控制器充当数据源。实际上，当你创建
    `UITableViewController` 的子类时，正如我们所做的那样，视图控制器已经符合 `UITableViewDataSource` 协议，并被分配为表格视图的数据源。
- en: 'Some of the methods defined in `UITableViewDataSource` were created as part
    of the `UITableViewController` template; the three we will take a look at are
    as follows:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `UITableViewDataSource` 中定义的一些方法是在 `UITableViewController` 模板中创建的；我们将查看的三个如下：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Data in a table view can be divided into sections, and information is presented
    in rows within those sections; information is referenced through an `IndexPath`
    that consists of a section integer value and a row integer value.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 表格视图中的数据可以分成多个部分，信息在这些部分中以行形式呈现；信息通过一个由部分整数值和行整数值组成的 `IndexPath` 来引用。
- en: 'The first thing that the data source methods ask us to provide is the number
    of sections that the table view will have. Our app will only be displaying a simple
    list of repositories, and as such, we only need one section, so we will return
    `1` from this method:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据源方法首先要求我们提供表格视图将拥有的部分数量。我们的应用将只显示一个简单的仓库列表，因此我们只需要一个部分，所以我们将从这个方法中返回 `1`：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The next thing we have to provide is the number of rows the table view should
    have for a given section. If we had multiple sections, we could examine the provided
    section index and return the right number of rows, but since we only have one
    section, we can return the same number in all scenarios.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接下来必须提供的是表格视图在给定部分中应该有的行数。如果我们有多个部分，我们可以检查提供的部分索引并返回正确的行数，但由于我们只有一个部分，我们可以在所有情况下返回相同的数字。
- en: 'We are displaying all the repositories we have retrieved, so the number of
    rows is simply the number of repositories in the `repos` array:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在显示我们检索到的所有仓库，所以行数简单地就是 `repos` 数组中仓库的数量：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice that in the preceding two functions, we no longer use the `return` keyword.
    This is because, starting with Swift 5.1, you can now use ***implicit returns***
    in functions. As long as your function doesn't carry ambiguity about what should
    and should not be returned, the compiler can work this out for you. This allows
    for more streamlined syntax.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面的两个函数中，我们不再使用 `return` 关键字。这是因为，从 Swift 5.1 开始，你现在可以在函数中使用 ***隐式返回***。只要你的函数没有关于应该返回什么或不应该返回什么的歧义，编译器就可以为你解决这个问题。这允许有更简洁的语法。
- en: Now that we have told the table view how many pieces of information to display,
    we must be able to display that information. A table view displays information
    in a type of view called `UITableViewCell`, and this cell is what we have to provide
    next.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经告诉了表格视图要显示多少条信息，我们必须能够显示这些信息。表格视图通过一种称为 `UITableViewCell` 的视图类型来显示信息，而这个单元格就是我们接下来需要提供的。
- en: 'For each index path within the section and row bounds that we have provided,
    we will be asked to provide a cell that will be displayed by the table view. A
    table view can be very large in size as it may need to represent a large amount
    of data. However, there are only a handful of cells that can be displayed to the
    user at any one time. This is because only a portion of the table view can be
    visible at any one time:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们提供的每个索引路径，包括节和行范围，我们都会被要求提供一个表格视图将要显示的单元格。表格视图可能非常大，因为它可能需要表示大量数据。然而，在任何时候只能向用户显示少量单元格。这是因为表格视图的只有一部分在任何时候是可见的：
- en: '![](img/380b9e3e-deeb-4714-8450-b1c62318e33c.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/380b9e3e-deeb-4714-8450-b1c62318e33c.png)'
- en: Figure 6.9 – Table view cell overview
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9 – 表格视图单元格概述
- en: 'In order to be efficient and prevent your app from slowing down as the user
    scrolls, the table view can reuse cells that have already been created but have
    since moved off-screen. Implementing cell reuse happens in two stages:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高效率并防止用户滚动时应用变慢，表格视图可以重用已经创建但随后移出屏幕的单元格。实现单元格重用分为两个阶段：
- en: Registering the cell's type with the table view with a reuse identifier.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用重用标识符将单元格的类型注册到表格视图中。
- en: Dequeuing a cell for a given reuse identifier. This will return a cell that
    has moved off-screen or create a new cell if none are available for reuse.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为给定的重用标识符出列单元格。这将返回一个已移出屏幕的单元格，如果没有可重用的单元格，则创建一个新的单元格。
- en: 'How a cell is registered will depend on how it has been created. If the cell
    has been created and its subviews have also been laid out in the code, then the
    cell''s class is registered with the table view through this method on `UITableView`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 单元格的注册方式取决于其创建方式。如果单元格已创建，并且其子视图也在代码中布局，则通过 `UITableView` 上的此方法将单元格的类注册到表格视图中：
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If the cell has been laid out in `.xib` (usually called a "nib" for historical
    reasons), which is a visual layout file for views that''s similar to a storyboard,
    then the cell''s nib is registered with the table view through this method on
    `UITableView`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果单元格已在 `.xib` 中布局（通常由于历史原因称为“nib”），这是一个类似于故事板的视图视觉布局文件，则通过 `UITableView` 上的此方法将单元格的
    nib 注册到表格视图中：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Lastly, cells can be defined and laid out within the table view in a storyboard.
    One advantage of this approach is that there is no need to manually register the
    cell, as with the previous two approaches; registering with the table view is
    free. However, one disadvantage of this approach is that the cell layout is tied
    to the table view, so it can't be reused in other table views, unlike the previous
    two implementations.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可以在表格视图中通过故事板定义和布局单元格。这种方法的优点是不需要像前两种方法那样手动注册单元格；与表格视图注册是免费的。然而，这种方法的缺点是单元格布局与表格视图绑定，因此不能像前两种实现那样在其他表格视图中重用。
- en: 'Let''s layout our cell in the Storyboard since we will only be using it with
    one table view:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在故事板中布局我们的单元格，因为我们只会用它与一个表格视图一起使用：
- en: Switch to our Main.storyboard file and select the table view in our `ReposTableViewController`.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到我们的 `Main.storyboard` 文件，并选择 `ReposTableViewController` 中的表格视图。
- en: In the attributes inspector, change the number of prototype cells to `1`; this
    will add a cell to the table view in the main window. This cell will define the
    layout of all the cells that will be displayed in our table view. You should create
    a prototype cell for each type of cell layout you will need; we are only displaying
    one piece of information in our table view, so all our cells will be of the same
    type.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在属性检查器中，将原型单元格的数量更改为 `1`；这将向主窗口中的表格视图添加一个单元格。这个单元格将定义将在我们的表格视图中显示的所有单元格的布局。你应该为每种类型的单元格布局创建一个原型单元格；在我们的表格视图中，我们只显示一条信息，所以所有单元格都将具有相同的类型。
- en: Select a cell in the storyboard. The attributes inspector will switch to showing
    the attributes for the cell. The cell style will be set to custom, and often,
    this will be what you want it to be. When you are displaying multiple pieces of
    information in a cell, you will usually want to create a subclass of `UITableViewCell`,
    set this to be the cell's class in the class inspector, and then lay out subviews
    in this custom cell type. However, for this example, we just want to show the
    name of the repository. Due to this, we can use a basic cell style that just has
    one text label, without a custom subclass, so choose basic from the style dropdown.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在故事板中选择一个单元格。属性检查器将切换到显示单元格的属性。单元格样式将被设置为自定义，通常这正是你想要的。当你想在单元格中显示多个信息时，你通常会创建`UITableViewCell`的子类，在类检查器中将此设置为单元格的类，然后在自定义单元格类型中布局子视图。然而，对于这个例子，我们只想显示仓库的名称。因此，我们可以使用一个基本的单元格样式，它只有一个文本标签，没有自定义子类，所以从样式下拉菜单中选择基本样式。
- en: 'We need to set the reuse identifier that we will use to dequeue the cell later,
    so type an appropriate string, such as `RepoCell`, into the reuse identifier box
    of the attributes inspector:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要设置我们将用于稍后从队列中提取单元格的复用标识符，所以将适当的字符串，例如`RepoCell`，输入到属性检查器的复用标识符框中：
- en: '![](img/55156d4f-12b9-418f-806a-243ffe8ef104.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/55156d4f-12b9-418f-806a-243ffe8ef104.png)'
- en: Figure 6.10 – Table view cell identifier
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10 – 表格视图单元格标识符
- en: Now that we have a cell that is registered for reuse with the table view, we
    can go back to our view controller and complete our conformance with `UITableViewDataSource`.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有一个已注册用于与表格视图重用的单元格，我们可以回到我们的视图控制器，并完成对`UITableViewDataSource`的遵守。
- en: 'Our `ReposTableViewController` contains some commented code that was created
    as part of the template:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`ReposTableViewController`包含一些作为模板一部分创建的注释代码：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: At this point, you can remove the `/* */` comment signifiers as we are ready
    to implement this method.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，你可以移除`/* */`注释标记，因为我们已经准备好实现这个方法。
- en: This data source method will be called every time the table view needs to place
    a cell on-screen; this will happen the first time the table is displayed as it
    needs cells to fill the visible part of the table view. It will also be called
    when the user scrolls the table view in a way that will reveal a new cell so that
    it becomes visible.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 每次表格视图需要将单元格放置在屏幕上时，都会调用此数据源方法；当表格第一次显示时，这就会发生，因为它需要单元格来填充表格视图的可见部分。当用户以某种方式滚动表格视图，从而揭示一个新单元格使其可见时，也会调用此方法。
- en: 'Regarding the method''s definition, we can see that we are provided with the
    table view in question and the index path of the cell that is needed, and we are
    expected to return a `UITableViewCell`. The code provided by the template actually
    does most of the work for us; we just need to provide the reuse identifier that
    we set in the storyboard and set the title label of the cell so that we have the
    name of the correct repository:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关于方法定义，我们可以看到我们提供了相关的表格视图和所需单元格的索引路径，我们预计将返回一个`UITableViewCell`。模板提供的代码实际上为我们做了大部分工作；我们只需要提供在故事板中设置的复用标识符，并设置单元格的标题标签，以便我们得到正确的仓库名称：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The cell's `textLabel` property is optional because it only exists when the
    cell's style is not custom.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 单元的`textLabel`属性是可选的，因为它仅在单元格的样式不是自定义时存在。
- en: 'Since we''ve now provided everything the table view needs to display our repository
    information, let''s click on Build and Run and take a look:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们现在已经提供了表格视图显示我们的仓库信息所需的一切，让我们点击构建和运行，看看效果：
- en: '![](img/5b43b056-b1b4-4e3f-a5d1-f10e2c7be73a.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5b43b056-b1b4-4e3f-a5d1-f10e2c7be73a.png)'
- en: Figure 6.11 – Our app's first run
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11 – 我们应用的第一次运行
- en: Great! Now that we have our two test repositories displayed in our table view,
    let's replace our test data with real repositories from the GitHub API.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在我们已经在我们的表格视图中显示了两个测试仓库，让我们用GitHub API的实际仓库替换我们的测试数据。
- en: 'We added our `fetchRepos` method earlier, so all we need to do is call this
    method, set the results to our `repos` property, and tell our table view that
    it needs to reload since the data has changed:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前添加了`fetchRepos`方法，所以我们只需要调用这个方法，将结果设置到我们的`repos`属性中，并告诉表格视图由于数据已更改，它需要重新加载：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As we did in the previous recipes, we fetched the repositories from the GitHub
    API and received a result enum informing us of whether this was a success or a
    failure. If it was successful, we store the resulting repository array in our
    `repos` property. Once we have handled the response, we call the `reloadData`
    method on `UITableView`, which instructs the table view to requery its source
    for cells to display.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的食谱中所做的那样，我们从GitHub API获取了仓库，并收到了一个枚举结果，告诉我们这是成功还是失败。如果是成功的，我们将结果仓库数组存储在我们的`repos`属性中。一旦我们处理了响应，我们就在`UITableView`上调用`reloadData`方法，这指示表格视图重新查询其源以获取要显示的单元格。
- en: We also provided a weak reference to `self` in our closure's capture list to
    prevent a retain cycle. You can find out more about why this is important in the
    *Closures* recipe of [Chapter 1](f9d48715-ffca-464f-95bf-722958f02e72.xhtml),
    *Swift Building Blocks*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在闭包的捕获列表中提供了一个对`self`的弱引用，以防止保留周期。你可以在第1章[Swift构建块](f9d48715-ffca-464f-95bf-722958f02e72.xhtml)的*闭包*食谱中了解更多为什么这很重要。
- en: At this point, there is an important consideration that needs to be addressed.
    The iOS platform is a multithreaded environment, which means that it can do more
    than one thing at once. This is critical to being able to maintain a responsive
    user interface, while also being able to process data and perform long-running
    tasks. The iOS system uses queues to manage this work and reserves the "main"
    queue for any work involving the user interface. Therefore, any time you need
    to interact with the user interface, it is important that this work is done from
    the main queue.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，有一个重要的考虑因素需要解决。iOS平台是一个多线程环境，这意味着它可以同时做很多事情。这对于保持响应式用户界面，同时能够处理数据和执行长时间运行的任务至关重要。iOS系统使用队列来管理这项工作，并为涉及用户界面的任何工作保留“主”队列。因此，每次你需要与用户界面交互时，确保这项工作是在主队列中完成的是非常重要的。
- en: 'Our `fetchRepos` method presents a situation where this might not be true.
    Our `fetchRepos` method performs networking, and we provide closure to `URLSession`
    as part of creating a `URLSessionDataTask`, but there is no guarantee that this
    closure will be executed on the main thread. Therefore, when we receive a response
    from `fetchRepos`, we need to "dispatch" the work of handling that response to
    the main queue to ensure that our updates to the UI happen on the main queue.
    We can do this using the `Dispatch` framework, so we need to import that at the
    top of the file:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`fetchRepos`方法展示了这种情况可能并不总是成立。我们的`fetchRepos`方法执行网络操作，我们在创建`URLSessionDataTask`时向`URLSession`提供了一个闭包，但无法保证这个闭包将在主线程上执行。因此，当我们从`fetchRepos`收到响应时，我们需要将处理该响应的工作“调度”到主队列，以确保我们的UI更新发生在主队列上。我们可以使用`Dispatch`框架来做这件事，所以我们需要在文件顶部导入它：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We will be discussing multithreading and the `Dispatch` framework in greater
    depth in [Chapter 9](f9e2c873-c2b2-4d40-9b02-5d884006d1a5.xhtml), *Performance
    and Responsiveness in Swift*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第9章[性能和响应性](f9e2c873-c2b2-4d40-9b02-5d884006d1a5.xhtml)中更深入地讨论多线程和`Dispatch`框架。
- en: Click on Build and Run. After a few seconds, the table view will be filled with
    the names of various repositories from the GitHub API.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击构建和运行。几秒钟后，表格视图将填充来自GitHub API的各种仓库的名称。
- en: Now that we have repositories being displayed to the user, the next piece of
    functionality we'll implement for our app is the ability to tap on a cell and
    have it display the repository's GitHub page in a WebView.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经向用户展示了仓库，我们将在我们的应用中实现的功能的下一部分是能够点击一个单元格，并在WebView中显示仓库的GitHub页面。
- en: Actions triggered by the table view, such as when a user taps on a cell, are
    provided to the table view's delegate, which can be anything that conforms to
    `UITableViewDelegate`. As was the case with the table view's data source, our
    `ReposTableViewController` already conforms to `UITableViewDelegate` because it
    is a subclass of `UITableViewController`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由表格视图触发的操作，例如当用户点击一个单元格时，会提供给表格视图的代理，这可以是任何符合`UITableViewDelegate`的任何东西。正如表格视图的数据源一样，我们的`ReposTableViewController`已经符合`UITableViewDelegate`，因为它是一个`UITableViewController`的子类。
- en: 'If you take a look at the documentation for the `UITableViewDelegate` protocol,
    you will see a lot of optional methods; this documentation can be found at [https://developer.apple.com/reference/uikit/uitableviewdelegate](https://developer.apple.com/reference/uikit/uitableviewdelegate).
    The one that''s relevant for our purposes is as follows:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你查看`UITableViewDelegate`协议的文档，你会看到很多可选方法；该文档可以在[https://developer.apple.com/reference/uikit/uitableviewdelegate](https://developer.apple.com/reference/uikit/uitableviewdelegate)找到。与我们目的相关的一个如下：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will be called on the table view''s delegate whenever a cell is selected
    by the user, so let''s implement this in our view controller:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将在用户选择表格视图中的单元格时在表格视图的代理上被调用，所以让我们在我们的视图控制器中实现这个功能：
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For the functionality it provides, we will use `SFSafariViewController`, passing
    it the repository''s URL. Then, we will pass that view controller to the `show`
    method, which will present the view controller in the most appropriate way:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于它提供的功能，我们将使用`SFSafariViewController`，传递给它存储库的URL。然后，我们将该视图控制器传递给`show`方法，该方法将以最合适的方式显示视图控制器：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Don't forget to `import SafariServices` at the top of the file.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要忘记在文件顶部导入`SafariServices`。
- en: Click on Build and Run, and once the repositories are loaded, tap on one of
    the cells. A new view controller will be pushed onto the screen, and the relevant
    repository web page will load.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击构建和运行，一旦加载了存储库，点击其中一个单元格。一个新的视图控制器将被推送到屏幕上，并加载相关的存储库网页。
- en: Congratulations – you've just built your first app and it looks great!
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你——你刚刚构建了你的第一个应用程序，它看起来很棒！
- en: How it works...
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Currently, our app fetches repositories from a specific, hardcoded GitHub username.
    It would be great if, rather than hardcoding the username, the user of the app
    could enter the GitHub username that the repositories will be retrieved for. So,
    let''s add this functionality:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的应用程序从特定的硬编码GitHub用户名获取存储库。如果用户能够输入将要检索存储库的GitHub用户名而不是硬编码用户名，那就太好了。所以，让我们添加这个功能：
- en: First, we need a way for the user to enter their GitHub username; the most appropriate
    way to allow a user to enter a small amount of text is through the use of `UITextField`.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要一种方式让用户输入他们的GitHub用户名；允许用户输入少量文本的最合适方式是通过使用`UITextField`。
- en: 'In the main storyboard, find Text Field in the object library, drag it over
    to the main window, and drop it on the navigation bar of our `ReposTableViewController`.
    Now, you need to increase the width of the Text Field. For now, just hard code
    this to around 300px by highlighting the respective Text Field and selecting the
    Size Inspector option:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主故事板中，在对象库中找到文本字段，将其拖动到主窗口，并将其放在我们的`ReposTableViewController`的导航栏上。现在，你需要增加文本字段的宽度。目前，只需通过突出显示相应的文本字段并选择大小检查器选项将其硬编码为大约300px：
- en: '![](img/c8836cdf-8f9e-4a45-8790-756f56c5b899.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c8836cdf-8f9e-4a45-8790-756f56c5b899.png)'
- en: Figure 6.12 – Adding a UITextField
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12 – 添加`UITextField`
- en: Like a table view, `UITextField` communicates user events through a delegate,
    which needs to conform to `UITextFieldDelegate`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 与表格视图一样，`UITextField`通过代理与用户事件通信，该代理需要遵守`UITextFieldDelegate`。
- en: 'Let''s switch back to `ReposTableViewController` and add conformance to `UITextFieldDelegate`;
    it is a common practice to add protocol conformance to an extension, so add the
    following at the bottom of `ReposTableViewController`:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们切换回`ReposTableViewController`并添加对`UITextFieldDelegate`的遵守；将协议遵守添加到扩展中是一种常见做法，所以在`ReposTableViewController`的底部添加以下内容：
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With this conformance in place, we need to set our view controller to be the
    delegate of `UITextField`. Head back over to the main storyboard and select the
    text field, and then open the Connections Inspector. You will see that the text
    field has an outlet for its delegate property. Now, click, hold, and drag from
    the circle next to our delegate over to the symbol representing our Repos Table
    View Controller:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此一致性设置完成后，我们需要将我们的视图控制器设置为`UITextField`的代理。回到主故事板，选择文本字段，然后打开连接检查器。你会看到文本字段有一个用于其代理属性的输出。现在，点击、按住并从代表我们的`ReposTableViewController`的代理旁边的圆圈拖动到符号：
- en: '![](img/75b53f88-549f-4969-a485-95fbee819449.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/75b53f88-549f-4969-a485-95fbee819449.png)'
- en: Figure 6.13 – UITextField with IBOutlet
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.13 – 带有IBOutlet的`UITextField`
- en: 'The delegate outlet should now have a value:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在代理输出应该有一个值：
- en: '![](img/8f9c8af2-5e15-471b-89ba-69cdbc7ee805.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8f9c8af2-5e15-471b-89ba-69cdbc7ee805.png)'
- en: Figure 6.14 – UITextField delegate outlet
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.14 – `UITextField`代理输出
- en: By taking a look at the documentation for `UITextFieldDelegate`, we can see
    that the `textFieldShouldReturn` method is called when the user presses the *Return*
    button on their keyboard after entering text, so this is the method we will implement.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看`UITextFieldDelegate`的文档，我们可以看到当用户在输入文本后按下键盘上的*Return*按钮时，会调用`textFieldShouldReturn`方法，因此这是我们将会实现的方法。
- en: 'Let''s switch back to our `ReposViewController` and implement this method in
    our extension:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们回到我们的`ReposViewController`，并在我们的扩展中实现这个方法：
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Since repositories will be fetched here instead of when the view is loaded,
    let''s move the code from `viewDidLoad` to this method:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于仓库将在这里而不是在视图加载时获取，所以让我们将代码从`viewDidLoad`移动到这个方法中：
- en: '[PRE19]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Cocoa Touch implements the programming design pattern **MVC**, which stands
    for **Model View Controller**; it is a way of structuring your code to keep its
    elements reusable, with well-defined responsibilities. In the MVC pattern, all
    code related to displaying information falls broadly into three areas of responsibility:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Cocoa Touch实现了编程设计模式**MVC**，代表**模型-视图-控制器**；这是一种结构化代码的方式，以保持其元素的复用性，并具有明确的职责。在MVC模式中，所有与显示信息相关的代码大致分为三个责任区域：
- en: '**Model** objects hold the data that will eventually be displayed on the screen;
    this might be data that was retrieved from the network or device, or that was
    generated when the app was running. These objects may be used in multiple places
    in the app, where different view representations of the same data may be required.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**对象持有最终将在屏幕上显示的数据；这可能是从网络或设备检索的数据，或者是在应用运行时生成的数据。这些对象可以在应用中的多个地方使用，可能需要不同的视图表示同一数据。'
- en: '**View** objects represent the UI elements that are displayed on the screen;
    these may just display information that they are provided, or capture input from
    the user. View objects can be used in multiple places where the same visual element
    is needed, even if it is showing different data.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**对象代表屏幕上显示的UI元素；这些元素可能只是显示提供的信息，或者从用户那里捕获输入。视图对象可以在需要相同视觉元素的多处使用，即使它们显示的是不同的数据。'
- en: '**Controller** objects act as bridges between the models and the views; they
    are responsible for obtaining the relevant model objects and for providing the
    data to be displayed to the right view objects at the right time. Controller objects
    are also responsible for handling user input from the views and updating the model
    objects as needed:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**对象在模型和视图之间充当桥梁；它们负责获取相关的模型对象，并在正确的时间将数据提供给正确的视图对象。控制器对象还负责处理来自视图的用户输入，并根据需要更新模型对象：'
- en: '![](img/c2ca3f73-1840-4f2a-b193-94407bbf5319.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c2ca3f73-1840-4f2a-b193-94407bbf5319.jpg)'
- en: Figure 6.15 – MVC overview
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.15 – MVC概述
- en: 'With regards to displaying web content, our app provides us with a number of
    options for presenting web content:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 关于显示网页内容，我们的应用为我们提供了许多显示网页内容的选择：
- en: '`WKWebView`, provided by the WebKit framework, is a view that uses the latest
    rendering and JavaScript engine for loading and displaying web content. While
    it is newer, it is less mature in some respects and has issues with caching content.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由WebKit框架提供的`WKWebView`是一个使用最新渲染和JavaScript引擎来加载和显示网页内容的视图。虽然它较新，但在某些方面还不够成熟，并且存在缓存内容的问题。
- en: '`SFSafariViewController`, provided by the `SafariServices` framework, is a
    view controller that displays web content, and also provides many of the features
    that are available in Mobile Safari, including sharing and adding to reading lists
    and bookmarks. It also provides a convenient button for opening the current site
    in Mobile Safari.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由`SafariServices`框架提供的`SFSafariViewController`是一个显示网页内容的视图控制器，它还提供了许多在Mobile
    Safari中可用的功能，包括分享、添加到阅读列表和书签。它还提供了一个方便的按钮，用于在Mobile Safari中打开当前网站。
- en: There's more...
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The last thing we need to do is dismiss the keyboard. Cocoa Touch refers to
    the object that is currently receiving user events as the first responder. Currently,
    this is the text field.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是关闭键盘。Cocoa Touch将当前接收用户事件的对象称为第一响应者。目前，这个对象是文本框。
- en: 'It''s the act of the text field becoming the first responder that caused the
    keyboard to appear on-screen. Therefore, to dismiss the keyboard, the text field
    just needs to resign its place as first responder:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 文本框变为第一响应者这一行为导致了屏幕上键盘的出现。因此，要关闭键盘，文本框只需要放弃其第一响应者的位置：
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, click on Build and Run. At this point, you can enter any GitHub account
    name in the text field to retrieve a list of its public repositories. Note that
    if your Xcode simulator doesn't have the "soft keyboard" enabled, you can just
    press *Enter* on your physical keyboard to search for the repo.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击“构建和运行”。在这个阶段，你可以在文本框中输入任何GitHub账户名称以检索其公共仓库列表。请注意，如果你的Xcode模拟器没有启用“软键盘”，你只需在物理键盘上按*Enter*键即可搜索仓库。
- en: See also
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'For more information regarding what was covered in this recipe, please refer
    to the following links:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 有关本菜谱中涵盖内容的更多信息，请参阅以下链接：
- en: '**Apple Documentation for GCD**: [https://developer.apple.com/documentation/dispatch](https://developer.apple.com/documentation/dispatch)'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Apple Documentation for GCD**：[https://developer.apple.com/documentation/dispatch](https://developer.apple.com/documentation/dispatch)'
- en: '**Apple Documentation UIKit**: [https://developer.apple.com/documentation/uikit](https://developer.apple.com/documentation/uikit)'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Apple Documentation UIKit**：[https://developer.apple.com/documentation/uikit](https://developer.apple.com/documentation/uikit)'
- en: Unit and integration testing with XCTest
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用XCTest进行单元和集成测试
- en: It goes without saying that testing plays a massive part of the software development
    life cycle. Primarily, a lot of the focus is on physical user testing – putting
    your piece of code in the hands of those using it day in day out. To a degree,
    this should be one of our main focuses, but what about testing what **we**, as
    software developers do? How do we test and check the integrity of our codebase?
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 不言而喻，测试在软件开发生命周期中扮演着重要角色。主要来说，很多关注点都集中在物理用户测试上——将你的代码放入那些日复一日使用它的人手中。在某种程度上，这应该是我们的主要关注点之一，但作为软件开发者，我们如何测试和检查我们的代码库的完整性呢？
- en: This is where unit and integration testing comes in. In this recipe, we'll cook
    up a unit and integration test for our previously written Cocoa Touch app. This
    will be written entirely in Swift using the Xcode IDE.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是单元和集成测试发挥作用的地方。在这个菜谱中，我们将为之前编写的Cocoa Touch应用编写单元和集成测试。这将完全使用Swift语言和Xcode
    IDE编写。
- en: Getting ready
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Back in our existing CocoaTouch project, in the **File inspector**, look for
    a folder called `CocoaTouchTest`. Expand this and select the `CocoaTouchTests.swift`
    file.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们现有的CocoaTouch项目中，在**文件检查器**中查找名为`CocoaTouchTest`的文件夹。展开此文件夹并选择`CocoaTouchTests.swift`文件。
- en: Inside this file, you'll notice a class named `CocoaTouchTests`, which, in turn,
    inherits from the `XCTestCase` class. `XCTestCase` offers a suite of functions
    that we can use when writing out our unit tests.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件中，你会注意到一个名为`CocoaTouchTests`的类，它继承自`XCTestCase`类。`XCTestCase`提供了一系列函数，我们可以在编写单元测试时使用。
- en: So, what exactly is a unit test? Well, it's a test (or in our case, just a function)
    that checks that another function is doing what it's supposed to be doing. Writing
    tests or functions using XCTestCase allows us to not only use the previously mentioned
    suite of helpers but also allows Xcode to visualize and report on metrics such
    as test coverage.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，单元测试究竟是什么呢？嗯，它是一个测试（或者在我们的情况下，只是一个函数），用于检查另一个函数是否正在执行其应有的操作。使用`XCTestCase`编写的测试或函数不仅允许我们使用之前提到的辅助工具套件，还允许Xcode可视化和报告测试覆盖率等指标。
- en: With that, let's get stuck into cooking up our first unit test! In the `CocoaTouchTests.swift`
    file, you'll see some override functions that have already been generated by Xcode.
    Just ignore these for now; we'll work on them as/when we need to.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，让我们开始编写我们的第一个单元测试！在`CocoaTouchTests.swift`文件中，你会看到一些已经被Xcode生成的覆盖函数。现在先忽略这些；当我们需要时再处理它们。
- en: How to do it...
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s start by creating the following function:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建以下函数：
- en: '[PRE21]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: So, let's go through this one bit at a time. We'll start with the `testThatRepoIsNotNil`
    function. The common practice when naming a unit test is for the name to be as
    descriptive as possible. Depending on your coding standard, you can choose to
    either camel case these or snake case them (I much prefer camel case), but when
    writing tests with Xcode, you always have to prefix these with the word "test".
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地来分析这个问题。我们将从`testThatRepoIsNotNil`函数开始。在命名单元测试时，通常要求名称尽可能描述性。根据你的编码标准，你可以选择使用驼峰式命名法或蛇形命名法（我更偏爱驼峰式命名法），但当你使用Xcode编写测试时，你总是必须在这些名称前加上“test”这个词。
- en: So, what are we testing? Here, we're checking that our repo array is not nil.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们在测试什么呢？在这里，我们正在检查我们的仓库数组是否不为空。
- en: 'Looking back at our `ReposTableViewController`, you''ll remember that we instantiated
    our "repo" model where the variable was declared, so this is a great test to start
    with. Let''s say someone tries to change this to an optional, like this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们的 `ReposTableViewController`，你会记得我们在变量声明的地方实例化了我们的 "repo" 模型，所以这是一个很好的测试开始。假设有人试图将其更改为可选的，就像这样：
- en: '[PRE22]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If this happens, the code in our CocoaTouch App will compile, but the test will
    fail.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生这种情况，我们的 CocoaTouch App 中的代码将编译，但测试将失败。
- en: 'Let''s take another look at our test. Note that the function we''re calling
    to check our repo model is `viewControllerUnderTest`. This is how we access our
    `RepoTableViewContoller`. We can achieve this by adding the following class-level
    variable to our file:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看我们的测试。注意，我们用来检查我们的仓库模型的函数是 `viewControllerUnderTest`。这是我们访问我们的 `RepoTableViewContoller`
    的方式。我们可以通过在我们的文件中添加以下类级别变量来实现这一点：
- en: '[PRE23]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, we need to instantiate this. Add the following override method from `XCTestCase`
    to your class:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要实例化这个。将以下来自 `XCTestCase` 的覆盖方法添加到你的类中：
- en: '[PRE24]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When running your unit test for this particular class, `setUp()` will run prior
    to any of your test cases running, allowing you to prep anything you may need,
    such as instantiating a class. Once the tests are complete and you want to free
    anything up or close anything down, you can simply do this with the `tearDown()`
    function.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行这个特定类的单元测试时，`setUp()` 将在运行任何测试用例之前执行，这允许你准备你可能需要的东西，比如实例化一个类。一旦测试完成，你想要释放任何东西或关闭任何东西，你只需使用
    `tearDown()` 函数来做这件事。
- en: This was and is a very basic test, but the main purpose here was not necessarily
    to look at testing practice, but how we'd do that in Swift. However, before we
    go any further, let's take a look at the `Assert` options that are available to
    us.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常基础的测试，但在这里的主要目的并不是看测试实践，而是看我们如何在 Swift 中做到这一点。然而，在我们继续之前，让我们看看我们可用的 `Assert`
    选项。
- en: 'Previously, we used `XCTAssertNotNil`, which worked perfectly for our scenario.
    However, the following options are also available:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们使用了 `XCTAssertNotNil`，这对于我们的场景来说效果完美。然而，以下选项也是可用的：
- en: '[PRE25]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: These are just a handful of the common ones and they are pretty self-explanatory
    – an added bonus is that each one has an optional parameter of "message", which
    allows you to add a custom string. This allows you to be more specific about the
    assertion that took place (ideal for reporting in a CI/CD world).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是常见的一些，它们相当直观——一个额外的优点是，每个都有一个可选的 "message" 参数，这允许你添加一个自定义字符串。这允许你更具体地说明发生了什么断言（在
    CI/CD 世界中报告时理想）。
- en: 'Now that we understand the basics of how to write tests in Swift, we need to
    learn how to run them. There are two ways we can achieve this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何在 Swift 中编写测试的基础知识，我们需要学习如何运行它们。有两种方法可以实现这一点：
- en: 'First, we can run all the tests in our class in one go. We can do this by simply
    clicking on the diamond to the left of the class''s declaration:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们可以一次性运行我们班级中的所有测试。我们可以通过简单地点击类声明左侧的菱形来实现这一点：
- en: '![](img/dc143851-1a69-4c14-b320-93d3c37b6ef1.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc143851-1a69-4c14-b320-93d3c37b6ef1.png)'
- en: Figure 6.16 – Class test case
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.16 – 类测试用例
- en: 'If we want to run tests individually, then we can simply select the icon next
    to our individual test case, like this:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想单独运行测试，我们只需选择我们单个测试用例旁边的图标，就像这样：
- en: '![](img/4ff0c578-0aab-4e37-b46e-94bb1a3c9b71.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4ff0c578-0aab-4e37-b46e-94bb1a3c9b71.png)'
- en: Figure 6.17 – Method test case
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.17 – 方法测试用例
- en: 'If everything goes to plan and our tests pass, we''ll see the icon turn green:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切按计划进行并且测试通过，我们会看到图标变成绿色：
- en: '![](img/eeda5573-4e31-4556-adf9-05c74b748c63.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eeda5573-4e31-4556-adf9-05c74b748c63.png)'
- en: Figure 6.18 – Method passed test case
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.18 – 方法通过测试用例
- en: 'However, if one or more of the tests in our class fail, we''ll see the icon
    turn red:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们的班级中有一个或多个测试失败，我们会看到图标变成红色：
- en: '![](img/4fb7bb17-8232-46b9-b085-5a13e08034d4.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4fb7bb17-8232-46b9-b085-5a13e08034d4.png)'
- en: Figure 6.19 – Method failed test case
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.19 – 方法失败测试用例
- en: Alternatively, the keyboard shortcut of *CMD* + *U* will also get Xcode to run
    any tests associated with the main project. Remember, only functions that start
    with the word `test` will be treated as a test case (excluding the class name),
    so feel free to add a private function in your test case should you need to.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，*CMD* + *U* 的快捷键也会让 Xcode 运行与主项目关联的任何测试。记住，只有以单词 `test` 开头的函数才会被视为测试用例（不包括类名），所以如果你需要，可以在测试用例中添加一个私有函数。
- en: 'Next, let''s take a look at how we would test networking logic in Swift using
    mock data to help us out:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何使用模拟数据在 Swift 中测试网络逻辑，以帮助我们：
- en: 'We''ll start by creating the following test function:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将开始创建以下测试函数：
- en: '[PRE26]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s start by figuring out how we are going to call this. Once again, we''ll
    take advantage of our `viewControllerUnderTest` variable:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先弄清楚我们将如何调用它。再一次，我们将利用我们的 `viewControllerUnderTest` 变量：
- en: '[PRE27]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This works as expected, but unfortunately, it's not that simple – this will
    simply call the API just like our app would. If we were to add any XCAsserts inside
    our code, they wouldn't be executed as our test and function will have finished
    and been torn down before the API has a chance to respond.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这按预期工作，但不幸的是，这并不简单——这会像我们的应用一样调用 API。如果我们想在代码中添加任何 XCAsserts，它们将不会被执行，因为我们的测试和函数已经完成并被拆解，而
    API 没有机会响应。
- en: 'To do this, we need to mock some objects in our `viewControllerUnderTest`,
    starting with **URLSession** and **URLSessionDataTask**. So, why do we need to
    mock these two? Let''s start by taking a look at where we use them in our CocoaTouch
    app:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要在我们的 `viewControllerUnderTest` 中模拟一些对象，从 `URLSession` 和 `URLSessionDataTask`
    开始。那么，为什么我们需要模拟这两个呢？让我们先看看我们在 CocoaTouch 应用中使用它们的地方：
- en: '[PRE28]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we are using **URLSession** and one of its functions, **URLSessionDataTask**,
    by mocking URLSession. We're creating our own local session here that we can then
    use to call our `MockURLSessionDataTask`. So, the real question here is, what
    is our `MockURLSessionDataTask` doing? We're using this to pass in some mock data
    – data that we should expect from the API – and then running this through our
    logic. This guarantees the integrity of our tests every time!
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过模拟 `URLSession` 并使用其一个函数 `URLSessionDataTask` 来使用 `URLSession`。我们在这里创建了一个本地会话，然后可以使用它来调用我们的
    `MockURLSessionDataTask`。所以，这里真正的疑问是，我们的 `MockURLSessionDataTask` 在做什么？我们使用这个来传递一些模拟数据——我们期望从
    API 获得的数据——然后通过我们的逻辑运行这些数据。这保证了每次测试的完整性！
- en: 'We could create the following input in our own files, but for now, we''ll just
    append them to the bottom of our `CocoaTouchTests.swift` file. First, let''s look
    at our `MockURLSession`:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在自己的文件中创建以下输入，但为了现在，我们只需将其追加到我们的 `CocoaTouchTests.swift` 文件底部。首先，让我们看看我们的
    `MockURLSession`：
- en: '[PRE29]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The preceding function is pretty self-explanatory – we simply override the
    `dataTask()` function with the following `MockURLSessionDataTask`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数相当直观——我们只是用以下 `MockURLSessionDataTask` 覆盖了 `dataTask()` 函数：
- en: '[PRE30]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: At first glance, this looks a little complex, but all we are really doing here
    is adding our own `completionHandler`. This will allow it to be called synchronously
    from our test (stopping our test from running away with us).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这似乎有点复杂，但我们在这里真正做的只是添加我们自己的 `completionHandler`。这将允许它从我们的测试中同步调用（阻止我们的测试失控）。
- en: 'Let''s put this all together and head back over to our new test:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把所有这些都放在一起，然后回到我们的新测试中：
- en: 'Let''s start by setting our `MockURLSession` for our `viewControllerUnderTest`.
    This is nice and simple. Now, line by line, add the following:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先为我们的 `viewControllerUnderTest` 设置 `MockURLSession`。这是很棒且简单。现在，逐行添加以下内容：
- en: '[PRE31]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let''s start by adding in our main `responseObject`. This is what we are going
    to perform our XCAsserts against. Declare this as an optional variable:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们添加我们的主要 `responseObject`。这是我们将要对其执行 XCAsserts 的内容。将其声明为一个可选变量：
- en: '[PRE32]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, we can call our function, much like we tried to earlier in this section.
    However, this time, we''ll assign the result to a variable and cast this as a
    `MockURLSessionDataTask`:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以调用我们的函数，就像我们在本节前面尝试做的那样。然而，这次，我们将结果赋给一个变量，并将其转换为 `MockURLSessionDataTask`：
- en: '[PRE33]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Remember that we can pass in anything we want for the `userName` variable as
    we''re not going to be calling the API. Now, let''s fire the completion handler
    we created and force through our `mockData`:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记住，我们可以为 `userName` 变量传递任何我们想要的内容，因为我们不会调用 API。现在，让我们触发我们创建的完成处理程序，并强制通过我们的
    `mockData`：
- en: '[PRE34]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'I''ve highlighted the `mockData` variable in the preceding code as we''ll need
    to add this to the JSON response we want to test against. You can get this by
    simply visiting the GitHub URL and copying this into a new, **empty** file in
    the project. I did this for my username and created a file called `mock_Data.json`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我在前面代码中突出显示了 `mockData` 变量，因为我们需要将其添加到我们想要测试的 JSON 响应中。你可以通过简单地访问 GitHub URL
    并将其复制到项目中一个新的、**空**文件中来实现这一点。我为我的用户名做了这件事，创建了一个名为 `mock_Data.json` 的文件：
- en: '![](img/b4c007ba-be6e-4948-8499-23dbba2adc0d.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b4c007ba-be6e-4948-8499-23dbba2adc0d.png)'
- en: Figure 6.20 – Adding an empty file
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.20 – 添加空文件
- en: Remember to select the CocoaTouch target when you're saving the file to disk;
    otherwise, the following steps won't work.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当你将文件保存到磁盘时，请选择CocoaTouch目标；否则，以下步骤将无法工作。
- en: 'Now, create a computed property in our `Test` class that simply reads in the
    file and spits out the `Data()` object:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在我们的`Test`类中创建一个计算属性，它简单地读取文件并输出`Data()`对象：
- en: '[PRE35]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'At this point, we can successfully pass our mock data through our `fetchRepos`
    function without the need to call the API. All we need to do now is write some
    asserts:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以成功地将模拟数据通过我们的`fetchRepos`函数传递，而不需要调用API。我们现在需要做的就是编写一些断言：
- en: '[PRE36]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: What you test for here is really up to you – it's all based on the test cases
    you choose. Sometimes, thinking about what to test when you've already written
    a function can be a hard task. As a developer, it is easy for you to get "too
    close" to the project. This is where **test-driven development** (**TDD**) comes
    in, a methodology for writing tests prior to writing any code at all. Let's take
    a look at this and what we can achieve with it.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里要测试的内容完全取决于你——它完全基于你选择的测试用例。有时，当你已经编写了一个函数时，思考要测试什么可能是一项艰巨的任务。作为一个开发者，你很容易对项目“过于亲近”。这就是**测试驱动开发**（**TDD**）发挥作用的地方，这是一种在编写任何代码之前先编写测试的方法。让我们看看这个，以及我们可以用它实现什么。
- en: How it works...
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Testing networking logic can be troublesome. I find that questions always arise,
    such as, what should you test? What exactly is being tested? However, if you can
    get your head around this, then you're well on your way to understanding the core
    fundamentals of unit testing.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 测试网络逻辑可能会很麻烦。我发现问题总是出现，比如，你应该测试什么？到底在测试什么？然而，如果你能理解这一点，那么你就已经走上了理解单元测试核心基础的良好道路。
- en: Let's try and break this down. The logic we want to test is our `fetchRepos()`
    function. This is easy – we just call it with a repository username that we know
    and write some XCAsserts against the list of repos that come back.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试将其分解。我们想要测试的逻辑是我们的`fetchRepos()`函数。这很简单——我们只需用我们知道的一个仓库用户名调用它，并对返回的仓库列表编写一些XCAsserts。
- en: While that will work for now, what happens when the user removes a repo? Your
    test will fail. This isn't good because your logic is not actually flawed – it's
    just the data that is wrong, much like if the API decided to return some malformed
    JSON due to an internal server error. This isn't your code's fault – it's the
    API's fault, and it's the API's job to make sure that it works.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这现在会工作，但当用户删除一个仓库时会发生什么？你的测试将失败。这不是好事，因为你的逻辑实际上并没有错误——只是数据是错误的，就像如果API因为内部服务器错误而返回一些格式不正确的JSON一样。这不是你代码的错——这是API的错，API有责任确保它能够正常工作。
- en: All you want to do is check that if the server gives you a specific response,
    with a specific piece of data, your logic does what it says it should do. So,
    how can we guarantee the integrity of the data coming back from an API? We can't
    – that's why we mock the data ourselves and, in turn, don't actually call the
    service at all.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你所想要做的只是检查如果服务器给你一个特定的响应，包含特定的数据，你的逻辑会按照它所说的那样去做。那么，我们如何保证从API返回的数据的完整性？我们不能——这就是为什么我们模拟数据，并且实际上根本不调用服务。
- en: There's more...
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: TDD is a methodology that includes writing your unit test first, prior to actually
    writing your desired function. Some believe this is the only way to write code,
    while others preach about its usage when – and only when – necessary. For the
    record, I do the latter, but we're not here to get into the theory – we'll here
    to learn how to achieve this in Swift using XCTest.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: TDD是一种方法，包括在实际上编写你想要的函数之前先编写单元测试。有些人认为这是编写代码的唯一方法，而有些人则宣传在何时以及仅在必要时使用它。据记录，我属于后者，但我们不是来讨论理论的——我们在这里是为了学习如何使用XCTest在Swift中实现这一点。
- en: 'Going back to our CocoaTouch app, let''s say we''d like to write a function
    that validates UITextField for whitespaces. Perform the following steps to achieve
    this:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的CocoaTouch应用，假设我们想要编写一个验证UITextField中空白字符的函数。执行以下步骤以实现这一点：
- en: 'We''ll start by writing out the stub function, which will look something like
    this:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先编写一个存根函数，它看起来可能像这样：
- en: '[PRE37]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Normally, here, I would litter my function with comments about what I'd like
    to achieve, but for TDD, we're going to do this the other way around.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在这里，我会在我的函数中添加关于我想实现什么的注释，但为了TDD，我们将采取相反的方式。
- en: 'Back inside the `CocoaTouchTests.swift` file, add the following test:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CocoaTouchTests.swift`文件内部，添加以下测试：
- en: '[PRE38]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Again, taking the name of our test as a literal description, we're going to
    check that our function correctly detects whitespaces in the middle of a `String()`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，以测试名称的字面描述为依据，我们将检查我们的函数是否正确地检测到 `String()` 中间的空白字符。
- en: 'So, let''s write a test against the current function:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 那么，让我们为当前函数编写一个测试：
- en: '[PRE39]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: With that, we're happy we've asserted everything we set out to do in our test
    cases. Now, we can go ahead and run our test.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了这些，我们很高兴地确认我们在测试用例中设定的所有内容都已得到断言。现在，我们可以继续运行我们的测试。
- en: As expected, our test failed, which is obvious for two reasons. First, we didn't
    really write up our function, and second, we hardcoded the return type as **false**.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，我们的测试失败了，这有两个明显的原因。首先，我们并没有真正编写我们的函数，其次，我们将返回类型硬编码为 **false**。
- en: 'We actually hardcoded the return type as false on purpose – we did this as
    the TDD methodology is done in three stages:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上故意将返回类型硬编码为 `false`，我们这样做是因为 TDD 方法论分为三个阶段：
- en: '**Fail test**: *Done, we did that.*'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**失败测试**：*完成了，我们做到了。*'
- en: '**Pass test**: *Can be as messy as you like.*'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通过测试**：*可以像你喜欢的样子一样混乱。*'
- en: '**Refactor cod**e: *We can do this with the utmost confidence.*'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**重构代码**：*我们可以非常有信心地做到这一点。*'
- en: The idea is to write your unit test while covering all the scenarios and asserts
    that may be required for that test case and make it fail (like we did).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是在编写单元测试的同时，涵盖所有可能需要的场景和断言，并使其失败（就像我们做的那样）。
- en: 'With the foundation set up, we can now confidently move over to our function
    and code away, safe in the knowledge that we''ll be able to run our test to check
    if our function is broken or not:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在基础设置完成后，我们现在可以自信地转向我们的函数并编写代码，放心地知道我们能够运行测试来检查我们的函数是否损坏：
- en: '[PRE40]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This is nothing special, but for the purpose of this section, it doesn't need
    to be. TDD with Swift doesn't have to be daunting. After all, it's just a methodology
    that works perfectly well with XCTest.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这没有什么特别的，但为了本节的目的，它不需要特别处理。使用 Swift 进行 TDD 不必令人畏惧。毕竟，它只是与 XCTest 完美结合的方法论。
- en: See also
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: You can find out more information about **unit testing** at [https://developer.apple.com/documentation/xctest](https://developer.apple.com/documentation/xctest).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://developer.apple.com/documentation/xctest](https://developer.apple.com/documentation/xctest)
    找到更多关于**单元测试**的信息。
- en: User interface testing with XCUITest
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 XCUITest 进行用户界面测试
- en: '**User interface** (**UI**) testing has been around for a while. In theory,
    it''s done every day by any one person who is using, testing, or checking an app,
    but in terms of automation, it''s had its fair share of critics.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户界面**（**UI**）测试已经存在了一段时间。从理论上讲，任何使用、测试或检查应用的人每天都在进行，但在自动化方面，它也受到了不少批评。'
- en: However, with Swift and XCTest, this has never been easier, and the beauty regarding
    how we will implement this has an amazing hidden benefit.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用 Swift 和 XCTest，这从未如此简单，而且关于我们将如何实现这一点有一个惊人的隐藏好处。
- en: Getting ready
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Unlike unit testing, when we are testing against a function, piece of logic,
    or algorithm, user interface tests are exactly what they say on the tin. They
    are a way for us to test the UI and UX of the app – things that might not have
    necessarily been generated programmatically.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 与单元测试不同，当我们测试一个函数、一段逻辑或算法时，用户界面测试正是其字面意义。这是我们测试应用 UI 和 UX 的方式——这些可能并不一定是由程序生成的。
- en: Head on over to the `CocoaTouchUITests.swift` file that was automatically generated
    when we created our project. Again, much like the unit tests, you'll notice some
    placeholder functions in there. We'll start by taking a look at one called `testExample()`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 直接前往在创建项目时自动生成的 `CocoaTouchUITests.swift` 文件。同样，就像单元测试一样，你会在其中注意到一些占位符函数。我们将首先查看一个名为
    `testExample()` 的函数。
- en: How to do it...
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'With what we mentioned in the *Getting ready* section in mind, let''s take
    a look at our app and see what we would like to test. The first thing that comes
    to my mind is the search bar:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们在“准备”部分中提到的内容，让我们看看我们的应用并看看我们想测试什么。首先出现在我脑海中的是搜索栏：
- en: '![](img/1926f57d-e978-4082-8a62-618bcb28b18a.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1926f57d-e978-4082-8a62-618bcb28b18a.png)'
- en: Figure 6.21 – Search bar selected
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.21 – 搜索栏已选中
- en: 'Now that we''ve made this mandatory to populate in order for our app to work,
    we want to make sure this is here all the time, so let''s write a UI test for
    this:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经强制要求填充以使我们的应用工作，我们想确保这一点始终存在，所以让我们为这个编写一个 UI 测试：
- en: '[PRE41]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As the comment correctly states, in order for the tests to be successful, the
    app needs to be launched, which is taken care of by the `launch()` function. However,
    once our app has been launched, how do we tell it to check for a UITextField and,
    more importantly, a specific one (in the future, we could have multiple on our
    screen)?
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 正如注释正确指出的那样，为了使测试成功，应用程序需要启动，这是由`launch()`函数处理的。然而，一旦我们的应用程序启动，我们如何让它检查UITextField，更重要的是，一个特定的UITextField（将来，我们可以在屏幕上有多个）？
- en: 'To do this, we must start with the basics:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们必须从基础开始：
- en: 'I''ve edited the name of the function to make it more applicable to what we
    are testing here. As you can see from the following highlighted code, we''ve told
    our test to select the `textFields` element and tap it:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我已经编辑了函数的名称，使其更适用于我们在这里进行的测试。正如以下高亮代码所示，我们告诉测试选择`textFields`元素并点击它：
- en: '[PRE42]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Go ahead and run the test by clicking on the diamond to the left to watch your
    app come to life in the simulator. If you're quick enough, you'll see the cursor
    enter the text box just before the app closes.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左边的菱形来运行测试，看看你的应用程序在模拟器中如何生动起来。如果你够快，你会在应用程序关闭前看到光标进入文本框。
- en: Great work! The test passed, which means you've written your first UI test.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！测试通过了，这意味着你已经编写了你的第一个UI测试。
- en: 'Regarding our previous test, we weren''t specific about the element being identified.
    For now, this is okay, but building a much bigger and complex app may require
    that you test certain aspects of specific elements. Let''s take a look at how
    we could achieve this:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们之前的测试，我们没有具体说明要识别的元素。目前来说，这没问题，但构建一个更大、更复杂的应用程序可能需要你测试特定元素的某些方面。让我们看看我们如何实现这一点：
- en: One way would be to set an accessibility identifier for our UITextField – a
    specific identifier that's required for accessibility purposes that, in turn,
    will allow our UI test to identify the control we want to test.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一种方法是为我们的UITextField设置一个可访问性标识符——一个用于可访问性目的的特定标识符，反过来，这将允许我们的UI测试识别我们想要测试的控制项。
- en: 'Back over in our `RepoTableViewController.swift` file, create an `IBOutlet`
    for the `UITextField` object in question and add the following code, remembering
    to hook up the outlet to your ViewController:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到我们的`RepoTableViewController.swift`文件，为相关的UITextField对象创建一个`IBOutlet`，并添加以下代码，记得将出口连接到你的ViewController：
- en: '[PRE43]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'With that in place, comment out or replace our generic `UTextField` tap test
    with the following:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置好这些之后，将我们的通用`UTextField`点击测试注释掉或替换为以下内容：
- en: '[PRE44]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now, run your test and watch it pass. Great stuff!
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行你的测试并观察它通过。太棒了！
- en: 'Notice that we are identifying a `textField` and then matching a control type
    from `textField`. This approach will work wonders when we''re testing for nested
    components in specific views of your app. For example, you might want to search
    and match for a specific UIButton that you know is embedded within a specific
    UIScrollView:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们正在识别一个`textField`，然后从`textField`中匹配一个控件类型。当我们在应用程序的特定视图中测试嵌套组件时，这种方法将非常有效。例如，你可能想要搜索并匹配一个你知道嵌入在特定的UIScrollView中的特定UIButton：
- en: '[PRE45]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'With that done, let''s take our test a little further. Notice the **`.tap()`**
    function we''re calling at the end of our element identification. There''s plenty
    more options to choose from, but we''ll start by splitting the element into its
    own variable:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这些后，让我们将测试再进一步。注意我们在元素识别的末尾调用的**`.tap()`**函数。有更多选项可供选择，但我们将从将元素拆分为其自己的变量开始：
- en: '[PRE46]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Notice that''s we''ve removed the **`.tap()`** function. Now, we can simply
    call this and any other available function via our `textField` variable:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意我们已经移除了**`.tap()`**函数。现在，我们可以通过`textField`变量简单地调用这个函数和其他任何可用的函数：
- en: '[PRE47]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Run this to see it in action for yourself. Now, what if we go a little further?
    Add the following line and run the code once more:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行这个命令，自己看看效果。现在，如果我们再进一步呢？添加以下行，然后再次运行代码：
- en: '[PRE48]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Hopefully, at this point, you can see where we are going. One thing to bear
    in mind is that, since we are not mocking data here, we're making a live, asynchronous
    API call, which, depending on your connection speed or the API, could vary from
    test to test.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 希望到这一点，你能够看到我们的方向。需要注意的是，由于我们这里没有模拟数据，我们正在进行一个实时、异步的API调用，这取决于你的连接速度或API，可能会因测试而异。
- en: 'To check the results, we need our UI test to "wait" for a specific element
    to come into view. By design, we know that we are expecting a `UITableView` with
    populated cells, so let''s write our test based on that:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了检查结果，我们需要我们的UI测试“等待”一个特定元素进入视图。按照设计，我们知道我们期望的是一个带有填充单元格的`UITableView`，因此让我们基于这一点编写我们的测试：
- en: '[PRE49]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Line 1 of the preceding code should now be all but familiar to us – we're building
    an element based on cells within a UITableView (we're not being specific at the
    time) to look for a specific cell with a label of `XcodeValidateJson`.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码的第一行现在应该对我们来说已经很熟悉了——我们正在基于UITableView中的单元格构建一个元素（当时我们没有具体指定）来查找具有`XcodeValidateJson`标签的特定单元格。
- en: Then, we're doing an XCAssert against this element. Allow for a timeout of 5
    seconds for this to appear. If it appears beforehand, the test will pass; if not,
    it will fail.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们对这个元素执行XCAssert。为此，我们允许有5秒的超时时间来等待这个元素出现。如果它提前出现，测试将通过；如果没有，测试将失败。
- en: There's more...
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: So far, we've seen how functions such as `.tap()` and **`.typeText()`** can
    be used when we're interacting with our app. However, these are not standard functions
    of a `UIButton` to `UITextField`. When we're identifying our controls, the return
    type we get back is that of an `XCUIElement()`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何在与应用交互时使用`.tap()`和**`.typeText()`**等函数。然而，这些并不是`UIButton`到`UITextField`的标准函数。当我们识别控件时，我们得到的返回类型是`XCUIElement()`。
- en: 'There are more options available that we can use to enhance our UI tests, thus
    allowing for an intricate yet worthy automated test. Let''s take a look at some
    of the additional options available to us:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有更多选项可以使用来增强我们的UI测试，从而允许进行复杂而有价值的自动化测试。让我们看看我们可用的额外选项：
- en: '[PRE50]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Each comes with additional parameters that allow you to be specific and cover
    all the aspects of your user experience in the app (for example, `press()` has
    a duration parameter).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试都带有额外的参数，允许你具体化并覆盖应用中用户体验的所有方面（例如，`press()`有一个持续时间参数）。
- en: 'At the beginning of this section, I mentioned that UI tests come with a great
    additional benefit, and this is something we have seen already: accessibility.
    Accessibility is an important factor when building mobile apps, and Apple gives
    us the best possible tools to do this with Xcode and the Swift programming languages.
    However, from a theory perspective, if you take the time to build our accessibility
    into your app, you''re indirectly making it much easier to build and shape the
    UI test around these identifiers – almost doing a good 50% of the work for you
    – while including an amazing feature.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的开头，我提到UI测试带来了一个很大的额外好处，这是我们之前已经看到的东西：可访问性。可访问性是构建移动应用时的重要因素，苹果通过Xcode和Swift编程语言为我们提供了最好的工具来做这件事。然而，从理论的角度来看，如果你花时间将我们的可访问性构建到你的应用中，你间接地使构建和调整UI测试围绕这些标识符变得容易得多——几乎为你完成了50%的工作——同时包括一个惊人的功能。
- en: Alternatively, writing a good UI test can lead to improved accessibility in
    your app, making it really easy to have one complement the other when building
    your app.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，编写一个好的UI测试可以提高你应用的可访问性，使你在构建应用时一个可以很好地补充另一个变得非常容易。
- en: See also
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: You can find more information about **XCUITest** at [https://developer.apple.com/documentation/xctest/xcuielement](https://developer.apple.com/documentation/xctest/xcuielement).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://developer.apple.com/documentation/xctest/xcuielement](https://developer.apple.com/documentation/xctest/xcuielement)找到更多关于**XCUITest**的信息。
- en: Backward compatibility
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向后兼容性
- en: Backward compatibility is inevitable. Unless you build an app for the latest
    version of iOS and plan to support that – and only that – version of iOS, you're
    going to have to handle backward compatibility at some point. In this recipe,
    we'll take a look at what Apple offers in terms of building for APIs that have
    been built with older versions of Swift.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 向后兼容性是不可避免的。除非你为iOS的最新版本构建应用并计划只支持那个版本，否则你将不得不在某个时候处理向后兼容性。在这个菜谱中，我们将看看苹果为构建使用旧版Swift构建的API提供了什么。
- en: We'll also take a look at migration options from previous versions of Swift
    and if and how legacy projects can be updated to their latest versions.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将探讨从Swift的先前版本迁移的选项，以及是否以及如何将遗留项目更新到最新版本。
- en: How to do it...
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We all want to use the latest shiny features in our app. Luckily, Apple makes
    this relatively easy for us to handle with the use of the **#available** check.
    So, how does this work? Well, primarily, it can work in three ways: at the function
    level, at the class level, and at the inline API level.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都希望在我们的应用程序中使用最新的闪亮功能。幸运的是，苹果通过使用 **#available** 检查使我们能够相对容易地处理这个问题。那么，这是怎么工作的呢？好吧，主要来说，它可以在三个层面上工作：在函数级别、在类级别和在内联
    API 级别。
- en: 'Let''s start with the latter and have a look at how we would do this at the
    API level:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从后者开始，看看我们如何在 API 级别做这件事：
- en: 'Here is an example of setting `maskedCorners` on a layer in `UIView()`:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是一个在 `UIView()` 中设置 `maskedCorners` 的示例：
- en: '[PRE51]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This is standard for APIs with iOS 11 and above, but what happens if your app
    supports iOS? In an ideal world, you only want to support two versions of iOS
    (including the current one), but that's not always possible. For example, in some
    retail apps, you may have an existing percentage of customers who you need to
    support. This also happens in the real world.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于 iOS 11 及以上版本的 API 是标准的，但如果你支持 iOS 会怎样呢？在一个理想的世界里，你可能只想支持两个 iOS 版本（包括当前版本），但这并不总是可能的。例如，在一些零售应用程序中，你可能需要支持一定比例的现有客户。这种情况在现实世界中也会发生。
- en: 'So, if your Xcode project has been set up to support iOS 10, you''ll actually
    get a generated error, similar to the following:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你的 Xcode 项目已经设置为支持 iOS 10，你实际上会得到一个生成的错误，类似于以下内容：
- en: '![](img/d93f73b2-3623-41bb-ac6c-7ada401eab53.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d93f73b2-3623-41bb-ac6c-7ada401eab53.png)'
- en: Figure 6.22 – Available API error
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.22 – 可用 API 错误
- en: 'Click the red indicator to the left and you''ll see the following options:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左侧的红色指示器，你会看到以下选项：
- en: '![](img/f0e79776-f5e0-4b63-9b2c-7958b90f4898.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f0e79776-f5e0-4b63-9b2c-7958b90f4898.png)'
- en: Figure 6.23 – Available API error options
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.23 – 可用 API 错误选项
- en: 'As we mentioned previously we''ve got three options here: add a version check
    against the API itself, add a check against the method, or enclose the entire
    class.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，这里有三种选择：对 API 本身添加版本检查、对方法添加检查，或者封装整个类。
- en: 'Go ahead and click Fix for the first option. You''ll see the following:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击第一个选项的“修复”。你会看到以下内容：
- en: '[PRE52]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, we're given the option to compile the API for a specific version of iOS,
    allowing us to make use of the API and use a fallback or contingency API, should
    we want to.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们被赋予了编译针对特定 iOS 版本的 API 的选项，允许我们使用该 API，并在需要时使用回退或应急 API。
- en: This is a great way to keep up to date with the latest changes that are being
    made to iOS and keep your code base fresh. However, this can come with some downsides.
    For example, if the API you've targeted is for a specific feature, you may find
    yourself struggling to find a suitable fallback (or worse, having to depend on
    a third-party library). You must also think about testing – you're potentially
    doubling your testing efforts when they may have only required a light regression
    test for earlier versions of iOS. Now, you'll have to make sure certain features
    are tested on multiple versions.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种很好的方式，可以了解 iOS 所做的最新更改，并保持你的代码库新鲜。然而，这也可能带来一些缺点。例如，如果你针对的 API 是针对特定功能的，你可能会发现自己很难找到一个合适的回退方案（或者更糟，不得不依赖第三方库）。你还必须考虑测试——当你可能只需要对
    iOS 的早期版本进行轻量级回归测试时，你实际上可能需要加倍测试努力。现在，你必须确保某些功能在多个版本上进行测试。
- en: 'Next, let''s take a look at the **enclosing instance method**, which allows
    us to wrap a whole function around a specific version check:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们看看**封装实例方法**，它允许我们将整个函数围绕特定的版本检查进行包装：
- en: '[PRE53]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As we can see, our function and its contents stay intact – we just decorate
    the function with the highlighted change.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们的函数及其内容保持不变——我们只是用高亮显示的更改装饰了函数。
- en: 'This is all well and good, but let''s try calling this function from somewhere
    else:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这一切都很不错，但让我们尝试从其他地方调用这个函数：
- en: '![](img/75b04ffa-7b06-4ad0-96a5-b415a0e61feb.png)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![](img/75b04ffa-7b06-4ad0-96a5-b415a0e61feb.png)'
- en: Figure 6.24 – Available method error options
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.24 – 可用方法错误选项
- en: That's right – we're met with the same problem that we came across earlier,
    but this does have some advantages. For example, if your function relies on a
    lot of code that has a higher API level – which would be a great way to maintain
    and manage your codebase – when the time comes to move up to higher SDK support,
    refactoring doesn't become a mammoth job.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 对了——我们遇到了之前遇到过的同样的问题，但这确实有一些优点。例如，如果你的函数依赖于大量具有较高 API 级别的代码——这将是一个维护和管理代码库的好方法——当需要升级到更高
    SDK 支持时，重构就不会成为一项艰巨的任务。
- en: 'The final "enclosing class" option follows a similar approach to the method
    approach, except this occurs at the class level. Your class is simply decorated
    like so:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后的“封装类”选项遵循与方法类似的方法，但这是在类级别发生的。你的类只是这样装饰的：
- en: '[PRE54]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: There's more...
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Swift has come in many shapes and sizes since its release in 2013, with each
    new version offering a wider range of APIs and stability. The move to open source
    has had a massive part to play in that too, but moving from one version to another
    with each release has often been aided with the help of Xcode's migration tool.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 自从2013年发布以来，Swift已经以多种形态和大小出现，每个新版本都提供了更广泛的API和稳定性。向开源的转变也在其中发挥了巨大作用，但每次发布从一个版本迁移到另一个版本通常都得到了Xcode迁移工具的帮助。
- en: 'But be warned: you can''t simply take an app build in Swift 1.1 and migrate
    this to Swift 5.3 with Xcode 12 (as nice as that would be...).'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 但要小心：你不能简单地拿一个用Swift 1.1构建的应用程序，并使用Xcode 12将其迁移到Swift 5.3（尽管这听起来很美好...）。
- en: Each release, from Swift 3.0 onward, allows you to migrate via the migration
    tool. For example, Xcode 9 would let you go from **Swift 2.2** to **Swift 3**,
    Xcode 10 would let you go from **Swift 3** to **Swift 4**, and so on.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 从Swift 3.0开始的每个版本，都允许你通过迁移工具进行迁移。例如，Xcode 9会让你从**Swift 2.2**迁移到**Swift 3**，Xcode
    10会让你从**Swift 3**迁移到**Swift 4**，依此类推。
- en: This doesn't mean you have to support the latest version of Swift with the latest
    version of Xcode – the upgrade options are backward compatible too.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着你必须使用最新版本的Xcode来支持Swift的最新版本——升级选项也具有向后兼容性。
- en: 'For example, our CocoaTouch project uses **Swift 5**, but options to use **Swift
    4.2** and **Swift 4** are available via Xcode''s Build Settings:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们的CocoaTouch项目使用**Swift 5**，但通过Xcode的构建设置，可以使用**Swift 4.2**和**Swift 4**的选项：
- en: '![](img/39949859-68a5-4454-894a-1ce3fb79915e.png)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/39949859-68a5-4454-894a-1ce3fb79915e.png)'
- en: Figure 6.25 – Select Swift Language Version option
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.25 – 选择Swift语言版本选项
- en: If you need to go back any further, you'll have to download a previous version
    of Xcode from the Apple Developer portal. More often than not, multiple versions
    of Xcode can play nicely together, although this was only really supported from
    Xcode 9 onward – you've been warned.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要回溯到更早的版本，你将不得不从苹果开发者门户下载Xcode的早期版本。通常情况下，多个版本的Xcode可以很好地协同工作，尽管这只有在Xcode
    9及以后的版本中才真正得到支持——你已经收到警告了。
- en: See also
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: You can find more information about **Swift Version History** at [https://www.javatpoint.com/history-of-swift](https://www.javatpoint.com/history-of-swift).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://www.javatpoint.com/history-of-swift](https://www.javatpoint.com/history-of-swift)找到有关**Swift版本历史**的更多信息。
