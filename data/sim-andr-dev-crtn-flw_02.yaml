- en: '*Chapter 1*: Introduction to Asynchronous Programming in Android'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第一章*：Android 异步编程简介'
- en: There are Android applications that work on their own. But most apps retrieve
    data from or send data to a local database or a backend server. Examples of these
    include fetching posts from a social network, saving your favorites from a list,
    uploading an image, or updating your profile information. These tasks and other
    resource-intensive computations may happen instantly or take a while to finish.
    Factors such as internet connection, device specifications, and server settings
    affect how long these operations take.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 有些 Android 应用程序可以独立工作。但大多数应用程序从本地数据库或后端服务器检索数据或发送数据。这些例子包括从社交网络获取帖子、保存列表中的收藏、上传图片或更新个人资料信息。这些任务和其他资源密集型计算可能立即完成或需要一段时间才能完成。诸如互联网连接、设备规格和服务器设置等因素会影响这些操作所需的时间。
- en: Long-running operations must not be performed on the main UI thread as the application
    will be blocked until they are completed. The application might become unresponsive
    to the users. Users may not be aware of what’s happening, and this might prompt
    them to close the app and reopen it (canceling the original task or doing it again).
    The app can also suddenly crash. Some users might even stop using your app if
    this happens frequently.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 长时间运行的操作不应在主UI线程上执行，因为应用程序将在它们完成之前被阻塞。应用程序可能会对用户无响应。用户可能不知道发生了什么，这可能会促使他们关闭应用程序并重新打开它（取消原始任务或重新执行）。应用程序也可能突然崩溃。如果这种情况频繁发生，一些用户甚至可能停止使用你的应用程序。
- en: To prevent this from happening, you need to use asynchronous programming. Tasks
    that can take an indefinite amount of time must be done asynchronously. They must
    run in the background, parallel to other tasks. For example, while posting information
    to your backend server, the app displays the UI, which the users can interact
    with. When the operation finishes, you can then update the UI or notify the users
    (with a dialog or a snackbar message).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种情况发生，你需要使用异步编程。可能需要不定时长的任务必须异步执行。它们必须在后台运行，与其他任务并行。例如，当向你的后端服务器发送信息时，应用程序显示用户界面，用户可以与之交互。当操作完成时，你可以更新用户界面或通知用户（通过对话框或Snackbar消息）。
- en: With this book, you will learn how to simplify asynchronous programming in Android
    using Kotlin coroutines and flows.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这本书，你将学习如何使用 Kotlin 协程和流简化 Android 中的异步编程。
- en: 'In this chapter, you will first start by revisiting the concept of asynchronous
    programming. After that, you will look into the various ways it is being done
    now in Android and how they may no longer be the best way moving forward. Then,
    you will be introduced to the new, recommended way of performing asynchronous
    programming in Android: coroutines and flows.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将首先回顾异步编程的概念。然后，你将了解现在在 Android 中正在进行的各种方式，以及它们可能不再是未来最佳的方式。接着，你将介绍 Android
    中执行异步编程的新、推荐方式：协程和流。
- en: 'This chapter covers three main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖三个主要主题：
- en: Asynchronous programming
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步编程
- en: Threads, AsyncTasks, and `Executors`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程、AsyncTasks 和 `Executors`
- en: The new way to do it – coroutines and flows
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的方法——协程和流
- en: By the end of this chapter, you will have a basic understanding of asynchronous
    programming, and know how to do it in Android using threads, AsyncTasks, and `Executors`.
    Finally, you will discover Kotlin coroutines and flows as these are the recommended
    ways of doing asynchronous programming in Android.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将基本了解异步编程，并知道如何在 Android 中使用线程、AsyncTasks 和 `Executors` 来实现它。最后，你将发现
    Kotlin 协程和流，因为这些是 Android 中推荐进行异步编程的方式。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will need to download and install the latest version of Android Studio.
    You can find the latest version at [https://developer.android.com/studio](https://developer.android.com/studio).
    For an optimal learning experience, a computer with the following specifications
    is recommended: Intel Core i5 or equivalent or higher, 4 GB RAM minimum, and 4
    GB available space.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要下载并安装 Android Studio 的最新版本。你可以在 [https://developer.android.com/studio](https://developer.android.com/studio)
    找到最新版本。为了获得最佳学习体验，建议使用以下规格的计算机：Intel Core i5 或更高版本，至少 4 GB RAM，以及 4 GB 可用空间。
- en: 'The code examples for this book can be found on GitHub at https: [github.com/PacktPublishing/Simplifying-Android-Development-with-Coroutines-and-Flows](http://github.com/PacktPublishing/Simplifying-Android-Development-with-Coroutines-and-Flows).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '本书中的代码示例可以在GitHub上找到，网址为 https: [github.com/PacktPublishing/Simplifying-Android-Development-with-Coroutines-and-Flows](http://github.com/PacktPublishing/Simplifying-Android-Development-with-Coroutines-and-Flows)。'
- en: Understanding asynchronous programming
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解异步编程
- en: In this section, we will start by looking at asynchronous programming. Asynchronous
    programming is a programming method that allows work to be done independently
    of the main application thread.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将首先探讨异步编程。异步编程是一种编程方法，允许工作独立于主应用程序线程进行。
- en: 'A normal program will run sequentially. It will perform one task and move to
    the next task after the previous one has finished. For simple operations, this
    is fine. However, there are some tasks that might take a long time to finish,
    such as the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个正常的程序将按顺序运行。它将执行一个任务，并在前一个任务完成后移动到下一个任务。对于简单的操作，这是可以的。然而，有些任务可能需要很长时间才能完成，例如以下任务：
- en: Fetching data from or saving data to a database
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从数据库中获取数据或将数据保存到数据库
- en: Getting, adding, or updating data to a network
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从网络获取、添加或更新数据
- en: Processing text, images, videos, or other files
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理文本、图像、视频或其他文件
- en: Complicated computations
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂的计算
- en: The app will look frozen and unresponsive to the users while it is performing
    these tasks. They won’t be able to do anything else in the app until the tasks
    are finished.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序执行这些任务时，它将看起来冻结且对用户无响应。它们将无法在应用程序中执行其他任何操作，直到任务完成。
- en: Asynchronous programming solves this problem. You can run a task that may be
    processed indefinitely on a background thread (in parallel to the main thread)
    without freezing the app. This will allow the users to still interact with the
    app or the UI while the original task is running. When the task has finished or
    if an error was encountered, you can then inform the user using the main thread.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程解决了这个问题。您可以在后台线程（与主线程并行）上运行可能无限期处理的任务，而不会冻结应用程序。这将使用户在原始任务运行时仍然可以与应用程序或用户界面进行交互。当任务完成或遇到错误时，您可以使用主线程通知用户。
- en: 'A visual representation of asynchronous programming is shown in the following
    figure:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程的视觉表示如下所示：
- en: '![Figure 1.1 – Asynchronous programming'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.1 – 异步编程'
- en: '](img/Figure_1.01_B17773.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.01_B17773.jpg)'
- en: Figure 1.1 – Asynchronous programming
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – 异步编程
- en: '**Task 1** and **Task 2** are running on the main thread. **Task 2** starts
    **Task 3** on the background thread. While **Task 3** is running, the main thread
    can continue to perform other tasks, such as **Task 4**. After **Task 3** is done,
    it will return to the main thread.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**任务1** 和 **任务2** 在主线程上运行。**任务2** 在后台线程上启动 **任务3**。当 **任务3** 运行时，主线程可以继续执行其他任务，例如
    **任务4**。当 **任务3** 完成后，它将返回主线程。'
- en: Asynchronous programming is an important skill for developers to have, especially
    for mobile app development. Mobile devices have limited capabilities and not all
    locations have a stable network connection.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程是开发人员必须掌握的重要技能，尤其是对于移动应用程序开发。移动设备功能有限，并非所有位置都有稳定的网络连接。
- en: 'In Android, if you run a task on the main thread and it takes too long, the
    app can become unresponsive or look frozen. The app can also crash unexpectedly.
    You will likely get an **Application Not Responding** (**ANR**) error, as shown
    in the following screenshot:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，如果您在主线程上运行一个任务并且它花费了太长时间，应用程序可能会变得无响应或看起来冻结。应用程序也可能意外崩溃。您可能会遇到**应用程序无响应**（**ANR**）错误，如下面的截图所示：
- en: '![Figure 1.2 – An ANR dialog'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.2 – ANR对话框'
- en: '](img/Figure_1.02_B17773.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.02_B17773.jpg)'
- en: Figure 1.2 – An ANR dialog
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 – ANR对话框
- en: Starting with Android 3.0 (Honeycomb), running a network operation on the main
    thread will cause `android.os.NetworkOnMainThreadException`, which will crash
    your app.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 从Android 3.0（蜂巢）开始，在主线程上运行网络操作将导致 `android.os.NetworkOnMainThreadException`，这将使您的应用程序崩溃。
- en: ANR dialogs and crashes can annoy your users. If they happen all the time, they
    might stop using your app altogether and choose another app. To prevent them in
    your app, you must run tasks that can take a long period of time on the background
    thread.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ANR对话框和崩溃可能会让您的用户感到烦恼。如果它们经常发生，他们可能会完全停止使用您的应用程序，并选择另一个应用程序。为了防止它们在您的应用程序中发生，您必须在后台线程上运行可能需要很长时间的任务。
- en: In this section, you revisited the concept of asynchronous programming and how
    you can use it to run long-running tasks without freezing the app. You will explore
    various approaches for using asynchronous programming in Android in the next section.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你回顾了异步编程的概念以及如何使用它来运行长时间运行的任务而不会冻结应用程序。你将在下一节中探索在Android中使用异步编程的各种方法。
- en: Exploring threads, AsyncTasks, and Executors
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索线程、AsyncTasks和Executors
- en: There are many ways you can run tasks on the background thread in Android. In
    this section, you are going to explore various ways of doing asynchronous programming
    in Android, including using threads, AsyncTask, and `Executors`. You will learn
    how to start a task on the background thread and then update the main thread with
    the result.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，你可以通过多种方式在后台线程上运行任务。在本节中，你将探索在Android中进行异步编程的各种方法，包括使用线程、AsyncTask和`Executors`。你将学习如何在后台线程上启动任务，然后使用结果更新主线程。
- en: Threads
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程
- en: 'A thread is a unit of execution that runs code concurrently. In Android, the
    UI thread is the main thread. You can perform a task on another thread by using
    the `java.lang.Thread` class:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 线程是并发运行代码的执行单元。在Android中，UI线程是主线程。你可以使用`java.lang.Thread`类在另一个线程上执行任务：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To run the thread, call `Thread.start()`. Everything that is inside the braces
    will be performed on another thread. You can do any operation here, except updating
    the UI, as you will encounter `NetworkOnMainThreadException`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行线程，调用`Thread.start()`。大括号内的所有内容将在另一个线程上执行。你可以在这里执行任何操作，但不能更新UI，因为你将遇到`NetworkOnMainThreadException`。
- en: 'To update the UI, such as displaying the text fetched in a `TextView` from
    the network, you would need to use `Activity.runOnUiThread()`. The code inside
    `runOnUIThread` will be executed in the main thread, as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新UI，例如从网络中获取并显示在`TextView`中的文本，你需要使用`Activity.runOnUiThread()`。`runOnUIThread`内部的代码将在主线程上执行，如下所示：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`runOnUIThread` will perform the `displayText(text)` function on the main UI
    thread.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`runOnUIThread`将在主UI线程上执行`displayText(text)`函数。'
- en: 'If you are not starting the thread from an activity, you can use handlers instead
    of `runOnUiThread` to update the UI, as seen in *Figure 1.3*:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不是从活动启动线程，你可以使用处理器而不是`runOnUiThread`来更新UI，如图*1.3*所示：
- en: '![ Figure 1.3 – Threads and a handler'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.3 – 线程和处理器'
- en: '](img/Figure_1.03_B17773.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 1.03](img/Figure_1.03_B17773.jpg)'
- en: Figure 1.3 – Threads and a handler
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – 线程和处理器
- en: A handler (`android.os.Handler`) allows you to communicate between threads,
    such as from the background thread to the main thread, as shown in the preceding
    figure. You can pass a looper into the Handler constructor to specify the thread
    where the task will be run. A looper is an object that runs the messages in the
    thread’s queue.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一个处理器（`android.os.Handler`）允许你在线程之间进行通信，例如从后台线程到主线程，如图所示。你可以将一个循环器传递给处理器构造函数以指定任务将在哪个线程上运行。循环器是一个在线程队列中运行消息的对象。
- en: 'To attach the handler to the main thread, you should use `Looper.getMainLooper()`,
    like in the following example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要将处理器附加到主线程，你应该使用`Looper.getMainLooper()`，如下例所示：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`Handler(Looper.getMainLooper())` creates a handler tied to the main thread
    and posts the `displayText()` runnable function on the main thread.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`Handler(Looper.getMainLooper())`创建一个与主线程绑定的处理器，并在主线程上发布`displayText()`可运行函数。'
- en: The `Handler.post (Runnable)` function enqueues the runnable function to be
    executed on the specified thread. Other variants of the post function include
    `postAtTime(Runnable)` and `postDelayed (Runnable, uptimeMillis)`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`Handler.post (Runnable)`函数将可运行的函数入队到指定线程上执行。post函数的其他变体包括`postAtTime(Runnable)`和`postDelayed
    (Runnable, uptimeMillis)`。'
- en: 'Alternatively, you can also send an `android.os.Message` object with your handler,
    as shown in *Figure 1.4*:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以使用处理器发送一个`android.os.Message`对象，如图*1.4*所示：
- en: '![Figure 1.4 – Threads, handlers, and messages'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.4 – 线程、处理器和消息'
- en: '](img/Figure_1.04_B17773.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 1.04](img/Figure_1.04_B17773.jpg)'
- en: Figure 1.4 – Threads, handlers, and messages
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – 线程、处理器和消息
- en: A thread’s handler allows you to send a message to the thread’s message queue.
    The handler’s looper will execute the messages in the queue.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一个线程的处理器允许你向线程的消息队列发送消息。处理器的循环器将执行队列中的消息。
- en: To include the actual messages you want to send in your Message object, you
    can use `setData(Bundle)` to pass a single bundle of data. You can also use the
    public fields of the message `class` (`arg1, arg2, and` `what` for integer values,
    and `obj` for an object value).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的 `Message` 对象中包含您想要发送的实际消息，您可以使用 `setData(Bundle)` 来传递一个包含数据的单个数据包。您还可以使用消息
    `class` 的公共字段（`arg1`、`arg2` 和 `what` 用于整数值，以及 `obj` 用于对象值）。
- en: You must then create a subclass of Handler and override the `handleMessage(Message)`
    function. There, you can then get the data from the message and process it in
    the handler’s thread.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须然后创建 `Handler` 的子类并重写 `handleMessage(Message)` 函数。在那里，您可以从消息中获取数据并在处理程序的线程中处理它。
- en: 'You can use the following functions to send a message: `sendMessage(Message)`,
    `sendMessageAtTime(Message, uptimeMillis)`, and `sendMessageDelayed(Message, delayMillis)`.
    The following code shows the use of the `sendMessage` function to send a message
    with a data bundle:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下函数来发送消息：`sendMessage(Message)`、`sendMessageAtTime(Message, uptimeMillis)`
    和 `sendMessageDelayed(Message, delayMillis)`。以下代码显示了使用 `sendMessage` 函数发送包含数据包的消息的用法：
- en: '[PRE26]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here, `fetchTextWithHandlerMessage()` gets the text from the network in a background
    thread. It then creates a message with a bundle object containing a string with
    a key of `key` to send that text. The handler can then, through the `handleMessage()`
    function, get the message’s bundle and get the string from the bundle using the
    same key.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`fetchTextWithHandlerMessage()` 在后台线程中从网络获取文本。然后它创建一个包含具有 `key` 键的字符串的数据包对象的
    `Message`，以发送该文本。然后处理程序可以通过 `handleMessage()` 函数获取消息的数据包，并使用相同的键从数据包中获取字符串。
- en: You can also send empty messages with an integer value (the what) that you can
    use in your `handleMessage` function to identify what message was received. These
    send empty functions are `sendEmptyMessage(int)`, `sendEmptyMessageAtTime(int,
    long)`, and `sendEmptyMessageDelayed(int, long)`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以发送具有整数值（即 `what`）的空消息，您可以在 `handleMessage` 函数中使用这些空消息来识别接收到的消息。这些发送空消息的函数是
    `sendEmptyMessage(int)`、`sendEmptyMessageAtTime(int, long)` 和 `sendEmptyMessageDelayed(int,
    long)`。
- en: 'This example uses `0` and `1` as values for what (“what” is a field of the
    `Message` class that is a user-defined message code so that the recipient can
    identify what this message is about): `1` for the case when the background task
    succeeded and `0` for the failure case:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用 `0` 和 `1` 作为值来表示什么（“what” 是 `Message` 类的一个字段，它是一个用户定义的消息代码，以便接收者可以识别这条消息的内容）：`1`
    表示后台任务成功的情况，`0` 表示失败的情况：
- en: '[PRE47]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: In the preceding code snippet, the background thread fetches the text from the
    network. It then sends an empty message of `1` if the operation succeeded and
    `0` if not. The handler, through the `handleMessage()` function, gets the `what`
    integer value of the message, which corresponds to the `0` or `1` empty message.
    Depending on this value, it can either update the UI or show an error to the main
    thread.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，后台线程从网络获取文本。如果操作成功，则发送一个空的 `1` 消息，如果不成功，则发送 `0`。处理程序通过 `handleMessage()`
    函数获取消息的 `what` 整数值，这对应于 `0` 或 `1` 的空消息。根据此值，它可以选择更新 UI 或向主线程显示错误。
- en: 'Using threads and handlers works for background processing, but they have the
    following disadvantages:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用线程和处理程序适用于后台处理，但它们有以下缺点：
- en: Every time you need to run a task in the background, you should create a new
    thread and use `runOnUiThread` or a new handler to post back to the main thread.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次您需要在后台运行任务时，都应该创建一个新的线程并使用 `runOnUiThread` 或一个新的处理程序来将消息回发到主线程。
- en: Creating threads can consume a lot of memory and resources.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建线程可能会消耗大量的内存和资源。
- en: It can also slow down your app.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它也可能减慢您的应用程序。
- en: Multiple threads make your code harder to debug and test.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个线程会使您的代码更难调试和测试。
- en: Code can become complicated to read and maintain.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码可能变得难以阅读和维护。
- en: Using threads makes it difficult to handle exceptions, which can lead to crashes.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用线程会使处理异常变得困难，这可能导致崩溃。
- en: As a thread is a low-level API for asynchronous programming, it is better to
    use the ones that are built on top of threads, such as executors and, until it
    was deprecated, `AsyncTask`. You can avoid it altogether by using Kotlin coroutines,
    which you will learn more about later in this chapter.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于线程是异步编程的低级 API，因此最好使用建立在线程之上的 API，例如 executors 和，直到它被弃用之前的 `AsyncTask`。您可以通过使用
    Kotlin 协程来完全避免它，您将在本章后面了解更多关于 Kotlin 协程的内容。
- en: In the next section, you will explore callbacks, another approach to asynchronous
    Android programming.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将探索回调，这是另一种异步 Android 编程的方法。
- en: Callbacks
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回调
- en: Another common approach to asynchronous programming in Android is using callbacks.
    A callback is a function that will be run when the asynchronous code has finished
    executing. Some libraries offer callback functions that developers can use in
    their projects.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 中进行异步编程的另一种常见方法是使用回调。回调是一个在异步代码执行完成后将运行的函数。一些库提供了回调函数，开发者可以在他们的项目中使用。
- en: 'The following is a simple example of a callback:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的回调示例：
- en: '[PRE68]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: In the preceding example, after fetching the text in the background, the `onSuccess`
    callback will be called and will display the text on the UI thread.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，在后台获取文本后，将调用 `onSuccess` 回调，并在 UI 线程上显示文本。
- en: Callbacks work fine for simple asynchronous tasks. They can, however, become
    complicated easily, especially when nesting callback functions and handling errors.
    This makes it hard to read and test. You can avoid this by avoiding nesting callbacks
    and splitting functions into subfunctions. It is better to use coroutines, which
    you will learn more about shortly in this chapter.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 回调对于简单的异步任务工作得很好。然而，它们很容易变得复杂，尤其是在嵌套回调函数和处理错误时。这使得阅读和测试变得困难。你可以通过避免嵌套回调并将函数拆分为子函数来避免这种情况。在本章的稍后部分，你将了解更多关于协程的内容。
- en: AsyncTask
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AsyncTask
- en: '`AsyncTask`, you don’t have to manually handle threads.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `AsyncTask`，你不需要手动处理线程。
- en: 'To use `AsyncTask`, you have to create a subclass of it with three generic
    types:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `AsyncTask`，你必须创建一个具有三个泛型类型的子类：
- en: '[PRE80]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'These types are as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型如下：
- en: '`Params`: This is the type of input for `AsyncTask` or is void if there’s no
    input needed.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Params`: 这是 `AsyncTask` 的输入类型，如果没有输入则需要，则为空。'
- en: '`Progress`: This argument is used to specify the progress of the background
    operation or Void if there’s no need to track the progress.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Progress`: 此参数用于指定后台操作的进度，如果没有需要跟踪进度，则为 `Void`。'
- en: '`Result`: This is the type of output of `AsyncTask` or is void if there’s no
    output to be displayed.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Result`: 这是 `AsyncTask` 的输出类型，如果没有输出要显示，则为空。'
- en: 'For example, if you are going to create `AsyncTask` to download text from a
    specific endpoint, your `Params` will be the URL (`String`) and `Result` will
    be the text output (`String`). If you want to track the percentage of time remaining
    to download the text, you can use `Integer` for `Progress`. Your class declaration
    would look like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你要创建用于从特定端点下载文本的 `AsyncTask`，你的 `Params` 将是 URL (`String`)，而 `Result` 将是文本输出
    (`String`)。如果你想跟踪下载文本剩余时间的百分比，你可以使用 `Integer` 作为 `Progress`。你的类声明可能如下所示：
- en: '[PRE81]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'You can then start `AsyncTask` with the following code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下代码启动 `AsyncTask`：
- en: '[PRE83]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '`AsyncTask` has four events that you can override for your background processing:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncTask` 有四个事件可以用于你的后台处理：'
- en: '`doInBackground`: This event specifies the actual task that will be run in
    the background, such as fetching/saving data to a remote server. This is the only
    event that you are required to override.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doInBackground`: 此事件指定将在后台运行的实际任务，例如从远程服务器获取/保存数据。这是唯一一个你必须重写的事件。'
- en: '`onPostExecute`: This event specifies the tasks that will be run in the UI
    thread after the background operation finishes, such as displaying the result.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onPostExecute`: 此事件指定在后台操作完成后在 UI 线程上运行的任务，例如显示结果。'
- en: '`onPreExecute`: This event runs on the UI thread before doing the actual task,
    usually displaying a progress loading indicator.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onPreExecute`: 此事件在执行实际任务之前在 UI 线程上运行，通常显示进度加载指示器。'
- en: '`onProgressUpdate`: This event runs in the UI thread to denote progress on
    the background process, such as displaying the amount of time remaining to finish
    the task.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onProgressUpdate`: 此事件在 UI 线程上运行，表示后台进程的进度，例如显示完成任务剩余的时间。'
- en: 'The diagram in *Figure 1.5* visualizes these `AsyncTask` events and in what
    threads they are run:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1.5* 中的图表可视化了这些 `AsyncTask` 事件以及它们在哪些线程上运行：'
- en: '![Figure 1.5 – AsyncTask events in main and background threads'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.5 – 主线程和后台线程中的 AsyncTask 事件'
- en: '](img/Figure_1.05_B17773.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.05_B17773.jpg)'
- en: Figure 1.5 – AsyncTask events in main and background threads
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5 – 主线程和后台线程中的 AsyncTask 事件
- en: The `onPreExecute`, `onProgressUpdate`, and `onPostExecute` functions will run
    on the main thread, while `doInBackground` executes on the background thread.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`onPreExecute`、`onProgressUpdate` 和 `onPostExecute` 函数将在主线程上运行，而 `doInBackground`
    在后台线程上执行。'
- en: 'Coming back to our example, your `DownloadTextAsync` class could look like
    the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的例子，你的 `DownloadTextAsync` 类可能如下所示：
- en: '[PRE84]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: In `DownloadTextAsync`, `doInBackground` fetches the text from the network and
    returns it as a string. `onPostExecute` will then be called with that string that
    can be displayed in the UI thread.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在`DownloadTextAsync`中，`doInBackground`从网络获取文本并将其作为字符串返回。然后`onPostExecute`将被调用，并带有可以显示在UI线程中的字符串。
- en: '`AsyncTask` can cause context leaks, missed callbacks, or crashes on configuration
    changes. For example, if you rotate the screen, the activity will be recreated
    and another `AsyncTask` instance can be created. The original instance won’t be
    automatically canceled and when it finishes and returns to `onPostExecute()`,
    the original activity is already gone.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncTask`可能导致上下文泄露、错过回调或配置更改时崩溃。例如，如果你旋转屏幕，活动将被重新创建，并且可以创建另一个`AsyncTask`实例。原始实例不会自动取消，当它完成并返回`onPostExecute()`时，原始活动已经不存在了。'
- en: Using `AsyncTask` also makes your code more complicated and less readable. As
    of Android 11, `AsyncTask` has been deprecated. It is recommended to use `java.util.concurrent`
    or Kotlin coroutines instead.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`AsyncTask`也会使你的代码更加复杂，可读性降低。截至Android 11，`AsyncTask`已被弃用。建议使用`java.util.concurrent`或Kotlin协程。
- en: In the next section, you will explore one of the `java.util.concurrent` classes
    for asynchronous programming, `Executors`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将探索用于异步编程的`java.util.concurrent`类之一，即`Executors`。
- en: Executors
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行器
- en: One of the classes in the `java.util.concurrent` package that you can use for
    asynchronous programming is `java.util.concurrent.Executor`. An executor is a
    high-level Java API for managing threads. It is an interface that has a single
    function, `execute(Runnable)`, for performing tasks.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在`java.util.concurrent`包中，你可以使用`java.util.concurrent.Executor`类进行异步编程。执行器是一个高级Java
    API，用于管理线程。它是一个接口，具有一个单一的功能，即`execute(Runnable)`，用于执行任务。
- en: To create an executor, you can use the utility methods from the `java.util.concurrent.Executors`
    class. `Executors.newSingleThreadExecutor()` creates an executor with a single
    thread.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建执行器，你可以使用`java.util.concurrent.Executors`类中的实用方法。`Executors.newSingleThreadExecutor()`创建一个具有单个线程的执行器。
- en: 'Your asynchronous code with `Executor` will look like the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Executor`的异步代码将如下所示：
- en: '[PRE96]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: The handler with `Looper.getMainLooper()` allows you to communicate back to
    the main thread so you can update the UI after your background task has been done.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Looper.getMainLooper()`的处理器允许你在后台任务完成后与主线程通信，以便更新UI。
- en: '`ExecutorService` is an executor that can do more than just `execute(Runnable)`.
    One of its subclasses is `ThreadPoolExecutor`, an `ExecutorService` class that
    implements a thread pool that you can customize.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExecutorService`是一个可以执行更多操作的执行器，其子类之一是`ThreadPoolExecutor`，这是一个实现了线程池的`ExecutorService`类，你可以自定义它。'
- en: '`ExecutorService` has `submit(Runnable)` and `submit(Callable)` functions,
    which can execute a background task. They both return a `Future` object that represents
    the result.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExecutorService`有`submit(Runnable)`和`submit(Callable)`函数，可以执行后台任务。它们都返回一个表示结果的`Future`对象。'
- en: 'The `Future` object has two functions you can use, `Future.isDone()` to check
    whether the executor has finished the task and `Future.get()` to get the results
    of the task, as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`Future`对象有两个你可以使用的功能，`Future.isDone()`用于检查执行器是否已完成任务，`Future.get()`用于获取任务的结果，如下所示：'
- en: '[PRE107]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: In the preceding code, the executor created with a new single thread executor
    was used to submit the runnable function to get and display text from the network.
    The `submit` function returns a `Future` object, which you can later use to fetch
    the result with `Future.get()`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，使用新的单线程执行器创建的执行器被用来提交可运行函数以从网络获取并显示文本。`submit`函数返回一个`Future`对象，你可以稍后使用`Future.get()`来获取结果。
- en: In this section, you learned some of the methods that you can use for asynchronous
    programming in Android. While they do work and you can still use them (except
    for the now-deprecated `AsyncTask`), nowadays, they are not the best method to
    use moving forward.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了可以在Android中进行异步编程的一些方法。虽然它们仍然有效，你仍然可以使用它们（除了现在已弃用的`AsyncTask`），但如今，它们并不是最佳的选择。
- en: 'In the next section, you will learn the new, recommended way of asynchronous
    programming in Android: using Kotlin coroutines and flows.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将学习Android中异步编程的新推荐方法：使用Kotlin协程和流。
- en: The new way to do it – coroutines and flows
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新的方法——协程和流
- en: 'In this section, you will learn about the recommended approach for Android
    asynchronous programming: using coroutines and flows. Coroutines is a Kotlin library
    you can use in Android to perform asynchronous tasks. Coroutines is a library
    for managing background tasks that return a single value. Flows are built on top
    of coroutines that can return multiple values.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将了解 Android 异步编程的推荐方法：使用协程和流。协程是 Kotlin 库，你可以在 Android 中使用它来执行异步任务。协程是一个用于管理返回单个值的后台任务的库。流是在协程之上构建的，可以返回多个值。
- en: Kotlin coroutines
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kotlin 协程
- en: Coroutines is a Kotlin library for managing background tasks, such as making
    network calls and accessing files or databases, or performing long-running background
    tasks. Using Kotlin coroutines is Google’s official recommendation for asynchronous
    programming on Android. Their Android Jetpack libraries, such as Lifecycle, WorkManager,
    and Room-KTX, now include support for coroutines. Other Android libraries, such
    as Retrofit, Ktor, and Coil, provide first-class support for Kotlin coroutines.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 协程是 Kotlin 库，用于管理后台任务，例如进行网络调用、访问文件或数据库，或执行长时间运行的后台任务。使用 Kotlin 协程是 Google 对
    Android 异步编程的官方推荐。他们的 Android Jetpack 库，如 Lifecycle、WorkManager 和 Room-KTX，现在都支持协程。其他
    Android 库，如 Retrofit、Ktor 和 Coil，为 Kotlin 协程提供了一级支持。
- en: With Kotlin coroutines, you can write your code in a sequential way. A long-running
    task can be made into a `suspend` function. A `suspend` function is a function
    that can perform its task by suspending the thread without blocking it, so the
    thread can still run other tasks. When the suspending function is done, the current
    thread will resume execution. This makes the code easier to read, debug, and test.
    Coroutines follow a principle of structured concurrency.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Kotlin 协程，你可以以顺序方式编写代码。可以将长时间运行的任务制作成 `suspend` 函数。挂起函数是一种可以暂停线程而不阻塞它的函数，因此线程可以继续运行其他任务。当挂起函数完成后，当前线程将恢复执行。这使得代码更容易阅读、调试和测试。协程遵循结构化并发原则。
- en: 'You can add coroutines to your Android project by adding the following lines
    to your `app/build.gradle` file dependencies:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在 `app/build.gradle` 文件依赖项中添加以下行来将协程添加到你的 Android 项目中：
- en: '[PRE116]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '`kotlinx-coroutines-core` is the main library for Kotlin coroutines, while
    `kotlinx-coroutines-android` adds support for the main Android thread (`Dispatchers.Main`).'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`kotlinx-coroutines-core` 是 Kotlin 协程的主要库，而 `kotlinx-coroutines-android` 添加了对主
    Android 线程（`Dispatchers.Main`）的支持。'
- en: 'To mark a function as a suspending function, you can add the `suspend` keyword
    to it; for example, here we have a function that calls the `fetchText()` function,
    which retrieves text from an endpoint and then displays it in the UI thread:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 要将一个函数标记为挂起函数，你可以向它添加 `suspend` 关键字；例如，这里有一个调用 `fetchText()` 函数的函数，它从端点检索文本，然后在
    UI 线程中显示它：
- en: '[PRE120]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'You can make the `fetchText()` function a suspending function by prefixing
    the `suspend` keyword, as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在 `suspend` 关键字前缀来将 `fetchText()` 函数制作成挂起函数，如下所示：
- en: '[PRE123]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Then, you can create a coroutine that will call the `fetchText()` suspending
    function and display the list, as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以创建一个协程，该协程将调用 `fetchText()` 挂起函数并显示列表，如下所示：
- en: '[PRE124]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '`lifecycleScope` is the scope with which the coroutine will run. `launch` creates
    a coroutine to run in `Dispatchers.IO`, which is a thread for I/O or network operations.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`lifecycleScope` 是协程将运行的上下文。`launch` 创建一个在 `Dispatchers.IO` 中运行的协程，这是一个用于 I/O
    或网络操作的线程。'
- en: The `fetchText()` function will suspend the coroutine before it starts the network
    request. While the coroutine is suspended, the main thread can do other work.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetchText()` 函数将在开始网络请求之前暂停协程。在协程暂停期间，主线程可以执行其他工作。'
- en: After getting the text, it will resume the coroutine. `withContext(Dispatchers.Main)`
    will switch the coroutine context to the main thread, where the `displayText(text)`
    function will be executed (`Dispatchers.Main`).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 获取文本后，它将恢复协程。`withContext(Dispatchers.Main)` 将协程上下文切换到主线程，其中 `displayText(text)`
    函数将被执行（`Dispatchers.Main`）。
- en: 'In Android Studio, the `suspend` function calls in your code with a gutter
    icon next to the line number. As shown in lines `fetchText()` and `withContext()`
    lines have the `suspend` function call gutter icon:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中，你的代码中的 `suspend` 函数调用会显示在行号旁边的横幅图标。如图所示，`fetchText()` 和 `withContext()`
    行旁边有 `suspend` 函数调用的横幅图标：
- en: '![Figure 1.6 – Android Studio suspend function call gutter icon'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.6 – Android Studio 暂停功能调用行号旁的图标'
- en: '](img/Figure_1.06_B17773.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.06_B17773.jpg)'
- en: Figure 1.6 – Android Studio suspend function call gutter icon
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6 – Android Studio 暂停功能调用凹槽图标
- en: You can learn more about Kotlin coroutines in [*Chapter 2*](B17773_02_Epub.xhtml#_idTextAnchor029),
    *Understanding Kotlin Coroutines*.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [*第 2 章*](B17773_02_Epub.xhtml#_idTextAnchor029)，*理解 Kotlin 协程* 中了解更多关于
    Kotlin 协程的信息。
- en: In the next section, you will learn about Kotlin Flows, built on top of coroutines,
    which can return multiple sequences of values.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将了解基于协程构建的 Kotlin Flows，它可以返回多个值序列。
- en: Kotlin Flows
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kotlin Flows
- en: Flow is a new Kotlin asynchronous stream library that is built on top of Kotlin
    coroutines. A flow can emit multiple values instead of a single value and over
    a period of time. Kotlin Flow is ideal to use when you need to return multiple
    values asynchronously, such as automatic updates from your data source.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Flow 是一个基于 Kotlin 协程构建的新 Kotlin 异步流库。Flow 可以发出多个值，而不是单个值，并在一段时间内发出。当需要异步返回多个值时，例如从数据源自动更新，Kotlin
    Flow 是理想的选择。
- en: Flow is now used in Jetpack libraries such as Room-KTX and Android developers
    are already using Flow in their applications.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: Flow 现在已用于 Jetpack 库如 Room-KTX，Android 开发者已经在他们的应用程序中使用 Flow。
- en: To use Kotlin Flows in your Android project, you have to add coroutines. An
    easy way to create a flow of objects is to use the `flow{}` builder. With the
    `flow{}` builder function, you can add values to the stream by calling emit.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 要在你的 Android 项目中使用 Kotlin Flows，你必须添加协程。创建对象流的一个简单方法就是使用 `flow{}` 构建器。使用 `flow{}`
    构建器函数，你可以通过调用 emit 向流中添加值。
- en: 'Let’s say in your Android app you have a `getTextFromNetwork` function that
    fetches text from a network endpoint and returns it as a `String` object:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在你的 Android 应用中，你有一个 `getTextFromNetwork` 函数，它从网络端点获取文本并将其作为 `String` 对象返回：
- en: '[PRE130]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'If we want to create a flow of each word of the text, we can do it with the
    following code:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要创建一个包含文本中每个单词的流，我们可以用以下代码实现：
- en: '[PRE131]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Flow does not run or emit values until the flow is collected with any terminal
    operators, such as `collect`, `launchIn`, or `single`. You can use the `collect()`
    function to start the flow and process each value, as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Flow 不会运行或发出值，直到使用任何终端操作符（如 `collect`、`launchIn` 或 `single`）收集流。你可以使用 `collect()`
    函数启动流并处理每个值，如下所示：
- en: '[PRE137]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'A visual representation of this flow is shown in the following figure:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图中展示了该流的可视化表示：
- en: '![Figure 1.7 – Kotlin Flow visual representation'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.7 – Kotlin Flow 的可视化表示'
- en: '](img/Figure_1.07_B17773.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.7 – Kotlin Flow 的可视化表示](img/Figure_1.07_B17773.jpg)'
- en: Figure 1.7 – Kotlin Flow visual representation
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7 – Kotlin Flow 的可视化表示
- en: As you can see in *Figure 1.7*, as soon as the `getWords()` flow emits a string,
    the `displayWords` function collects the string and displays it immediately on
    the logs.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在 *图 1.7* 中所见，一旦 `getWords()` 流发出字符串，`displayWords` 函数就会收集该字符串并立即在日志中显示。
- en: You will learn more about Kotlin Flows in [*Chapter 5*](B17773_05_Epub.xhtml#_idTextAnchor062),
    *Using Kotlin Flows*.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在 [*第 5 章*](B17773_05_Epub.xhtml#_idTextAnchor062)，*使用 Kotlin Flows* 中了解更多关于
    Kotlin Flows 的信息。
- en: In this section, you learned about Kotlin coroutines and flows, the recommended
    way to carry out asynchronous programming in Android. Coroutines is a Kotlin library
    for managing long-running tasks in the background. Flow is a new Kotlin asynchronous
    stream library, built on top of coroutines, that can emit multiple values over
    a period of time.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了 Kotlin 协程和 Flows，这是在 Android 中执行异步编程的推荐方式。协程是 Kotlin 用于管理后台长时间运行任务的库。Flow
    是一个基于协程构建的新 Kotlin 异步流库，可以在一段时间内发出多个值。
- en: Summary
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you revisited the concept of asynchronous programming. We learned
    that asynchronous programming helps you execute long-running tasks in the background
    without freezing the app and annoying your users.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你重新回顾了异步编程的概念。我们了解到异步编程可以帮助你在后台执行长时间运行的任务，而不会冻结应用并烦扰用户。
- en: You then learned about various ways you can do asynchronous programming in Android,
    including with threads, AsyncTask, and `Executors`. We also learned that they
    allow you to perform tasks in the background and update the main thread. AsyncTask
    is already deprecated, and threads and `Executors` are not the best ways to carry
    out asynchronous programming in Android.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你学习了在 Android 中进行异步编程的各种方法，包括使用线程、AsyncTask 和 `Executors`。我们还了解到，它们允许你在后台执行任务并更新主线程。AsyncTask
    已经被弃用，而线程和 `Executors` 并不是在 Android 中执行异步编程的最佳方式。
- en: 'Finally, you were introduced to the new, recommended way to carry out asynchronous
    programming in Android: with Kotlin’s Coroutines and Flow. We learned that Coroutines
    is a Kotlin library that you can use to easily perform asynchronous, non-blocking,
    and long-running tasks in the background. Flow, built on top of Coroutines, allows
    you to handle functions that return multiple values over time.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你被介绍到了在 Android 中执行异步编程的新推荐方法：使用 Kotlin 的协程和 Flow。我们了解到协程是一个 Kotlin 库，你可以用它轻松地在后台执行异步、非阻塞和长时间运行的任务。建立在协程之上的
    Flow 允许你处理随时间返回多个值的函数。
- en: In the next chapter, you will dive deeper into Kotlin coroutines and learn how
    to use them in your Android project.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将更深入地了解 Kotlin 协程，并学习如何在你的 Android 项目中使用它们。
- en: Further reading
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: This book assumes that you have experience and skills in Android development
    with Kotlin. If you would like to learn more about this, you can read the book
    *How to Build Android Apps with Kotlin* (*Packt Publishing, 2021, ISBN 9781838984113*).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 本书假设你具有使用 Kotlin 进行 Android 开发的经验和技能。如果你想了解更多关于这方面的内容，你可以阅读书籍《如何使用 Kotlin 构建安卓应用》（Packt
    Publishing，2021，ISBN 9781838984113）。
