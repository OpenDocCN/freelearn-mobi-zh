- en: Chapter 3. Managing Dependencies
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 管理依赖项
- en: Dependency management is one of the areas where Gradle really shines. In the
    best case scenario, all you need to do is add one line to your build file, and
    Gradle will download the dependency from a remote repository and make sure its
    classes are available to your project. Gradle even goes a step further. In case
    a dependency for your project has dependencies of its own, Gradle will resolve
    those, and take care of everything. These dependencies of dependencies are called
    **transitive dependencies**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖管理是Gradle真正发光的领域之一。在最佳情况下，您只需在构建文件中添加一行，Gradle就会从远程仓库下载依赖项，并确保其类对您的项目可用。Gradle甚至更进一步。如果您的项目依赖项有自己的依赖项，Gradle将解决这些依赖项，并处理一切。这些依赖项的依赖项被称为**传递依赖项**。
- en: 'This chapter introduces the concepts of dependency management, and explains
    the multiple ways of adding dependencies to Android projects. These are the main
    topics we will be talking about:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了依赖管理的概念，并解释了将依赖项添加到Android项目的多种方式。以下是我们将要讨论的主要主题：
- en: Repositories
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仓库
- en: Local dependencies
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地依赖项
- en: Dependency concepts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖概念
- en: Repositories
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仓库
- en: When we discuss dependencies, we usually mean external dependencies, such as
    libraries that are provided by other developers. Manually managing dependencies
    can be a big hassle. You have to locate the library, download the JAR file, copy
    it into your project, and reference it. Often these JAR files have no version
    in their name, so you need to remember to add it yourself, in order to know when
    to update. You also need to make sure the libraries are stored in a source control
    system, so that the team members can work with the code base without manually
    downloading the dependencies themselves.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论依赖项时，通常指的是外部依赖项，例如由其他开发者提供的库。手动管理依赖项可能是一项繁琐的工作。您需要找到库，下载JAR文件，将其复制到您的项目中，并引用它。通常这些JAR文件在其名称中没有版本号，因此您需要记住自己添加它，以便知道何时更新。您还需要确保库存储在源控制系统中，这样团队成员就可以在没有手动下载依赖项的情况下与代码库一起工作。
- en: 'Using repositories can solve these issues. A repository can be seen as a collection
    of files. Gradle does not define any repositories for your project by default,
    so you need to add them to the `repositories` block. If you use Android Studio,
    this is done for you. We have mentioned the `repositories` block briefly in the
    previous chapters; it looks like this:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 使用仓库可以解决这些问题。仓库可以看作是一组文件的集合。Gradle默认不会为您的项目定义任何仓库，因此您需要将它们添加到`repositories`块中。如果您使用Android
    Studio，这会为您完成。我们在前面的章节中简要提到了`repositories`块；它看起来像这样：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Gradle supports three different kinds of repositories: Maven, Ivy, and static
    files or directories. Dependencies are fetched from the repositories during the
    execution phase of the build. Gradle also keeps a local cache, so a particular
    version of a dependency only needs to be downloaded to your machine once.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle支持三种不同类型的仓库：Maven、Ivy和静态文件或目录。依赖项在构建执行阶段从仓库中检索。Gradle还保留了一个本地缓存，因此特定版本的依赖项只需下载到您的机器一次。
- en: 'A dependency is identified by three elements: group, name, and version. The
    group specifies the organization that created the library and is usually a reverse
    domain name. The name is a unique identifier for the library. The version specifies
    which version of the library you want to use. Using these three elements, a dependency
    can be declared in the `dependencies` block with the following structure:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项由三个元素标识：组、名称和版本。组指定了创建库的组织，通常是一个反向域名。名称是库的唯一标识符。版本指定了您想要使用的库版本。使用这三个元素，可以在`dependencies`块中使用以下结构声明依赖项：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is shorthand for the full Groovy map notation, which looks like this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种简写形式，完整的Groovy映射表示法看起来像这样：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The only required field for a dependency is the name. Group and version are
    optional elements. Nonetheless, it is recommended to add the group for clarity,
    and the version in order to make sure libraries are not updated automatically,
    which could cause a build to break.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项的唯一必需字段是名称。组和版本是可选元素。尽管如此，建议添加组以提高清晰度，并添加版本以确保库不会自动更新，这可能会导致构建失败。
- en: Preconfigured repositories
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预配置的仓库
- en: 'For your convenience, Gradle has preconfigured three Maven repositories: JCenter,
    Maven Central, and the local Maven repository. To include them in your build script,
    you need to include these lines:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，Gradle已经预配置了三个Maven仓库：JCenter、Maven Central和本地Maven仓库。要将它们包含到你的构建脚本中，你需要包含以下这些行：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Maven Central and JCenter are two well-known online repositories. There is no
    reason to use both of them at the same time, and it is always recommended to use
    JCenter, which is also the default repository in Android projects created with
    Android Studio. JCenter is a superset of Maven Central, so when you make the switch,
    you can leave your already defined dependencies intact. On top of that, it supports
    HTTPS, unlike Maven Central.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Maven Central和JCenter是两个知名的在线仓库。没有理由同时使用它们，并且始终建议使用JCenter，这也是使用Android Studio创建的Android项目的默认仓库。JCenter是Maven
    Central的超集，所以当你切换时，你可以保留已经定义的依赖项不变。此外，它支持HTTPS，而Maven Central不支持。
- en: The local Maven repository is a local cache of all the dependencies you have
    used, and you can add your own dependencies as well. By default, the repository
    can be found in the home directory in a folder called `.m2`. On Linux or Mac OS
    X, the path is `~/.m2`. On Microsoft Windows, it is `%UserProfile%\.m2`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本地Maven仓库是你使用过的所有依赖项的本地缓存，你也可以添加自己的依赖项。默认情况下，仓库可以在主目录下的一个名为`.m2`的文件夹中找到。在Linux或Mac
    OS X上，路径是`~/.m2`。在Microsoft Windows上，它是`%UserProfile%\.m2`。
- en: Besides these preconfigured repositories, you can also add other public, or
    even private repositories.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些预配置的仓库外，你还可以添加其他公共的，甚至是私有的仓库。
- en: Remote repositories
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 远程仓库
- en: Some organizations create interesting plugins or libraries, and prefer to host
    them on their own Maven or Ivy server, instead of publishing them to Maven Central
    or JCenter. To add those repositories to your build, all you need to do is to
    add the URL to a `maven` block.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一些组织创建了有趣的插件或库，并倾向于将它们托管在自己的Maven或Ivy服务器上，而不是发布到Maven Central或JCenter。要将这些仓库添加到你的构建中，你只需要将URL添加到一个`maven`块中。
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The same goes for Ivy repositories. Apache Ivy is a dependency manager that
    is popular in the Ant world. Gradle supports these repositories in a format that
    is identical to the one that is used for Maven repositories. Add the repository
    URL to an `ivy` block, and you are good to go:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Ivy仓库也是如此。Apache Ivy是Ant世界中流行的依赖管理器。Gradle支持这些仓库的格式与Maven仓库使用的格式相同。将仓库URL添加到`ivy`块中，你就可以开始了：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If your organization is running its own repository, chances are that it is
    secured, and you need credentials to access it. This is how you add credentials
    for a repository:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的组织运行自己的仓库，那么它很可能是受保护的，并且你需要凭证来访问它。这是为仓库添加凭证的方法：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The approach for Maven and Ivy is the same here as well. You can add a `credentials`
    block with the same format to the configuration of your Ivy repository.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Maven和Ivy的方法在这里也是一样的。你可以在Ivy仓库的配置中添加一个格式相同的`credentials`块。
- en: Tip
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Storing credentials**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**存储凭证**'
- en: It is not a good idea to store your credentials in the build configuration file.
    The build configuration file is plain text, and is checked into the source control
    system. A better idea would be to use a separate Gradle properties file, as we
    have seen in [Chapter 2](ch02.html "Chapter 2. Basic Build Customization"), *Basic
    Build Customization*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 将凭证存储在构建配置文件中不是一个好主意。构建配置文件是纯文本，并且会被提交到源代码控制系统中。一个更好的主意是使用一个单独的Gradle属性文件，正如我们在[第2章](ch02.html
    "第2章。基本构建自定义")中看到的，*基本构建自定义*。
- en: Local repositories
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地仓库
- en: 'It is possible to run Maven and Ivy repositories on your own hard drive or
    a network drive. To add these to the build, you just need to configure the URL
    to a relative or absolute path to the location on the drive:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在自己的硬盘或网络驱动器上运行Maven和Ivy仓库。要将这些添加到构建中，你只需要配置到驱动器上位置的相对或绝对路径的URL：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: New Android projects have a dependency on the Android Support Library by default.
    When installing the Google repositories using the SDK manager, two Maven repositories
    are created on your hard drive `ANDROID_SDK/extras/google/m2repository` and `ANDROID_SDK/extras/android/m2repository`.
    This is where Gradle gets the libraries provided by Google, such as the Android
    Support Library and Google Play Services.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 新的Android项目默认依赖于Android Support Library。当使用SDK管理器安装Google仓库时，会在你的硬盘上创建两个Maven仓库`ANDROID_SDK/extras/google/m2repository`和`ANDROID_SDK/extras/android/m2repository`。这就是Gradle获取Google提供的库的地方，例如Android
    Support Library和Google Play Services。
- en: You can add a regular directory as a repository as well, using `flatDirs`. This
    enables you to add files from that directory in the `dependency` block.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 `flatDirs` 将常规目录作为存储库添加，这使您能够在 `dependency` 块中添加该目录中的文件。
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Later in this chapter, when we talk about library projects, we will look at
    an example of how this can be used.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，当我们讨论库项目时，我们将查看一个示例，说明如何使用它。
- en: Local dependencies
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地依赖
- en: In some cases, you might still need to manually download a JAR file or a native
    library. Perhaps you want to create your own library that you can reuse in several
    projects, without publishing it to a public or private repository. In those cases,
    it is impossible to use any of the online resources, and you will have to use
    different ways to add the dependencies. We will describe how to use file dependencies,
    how to include native libraries, and how you can include library projects in your
    project.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能仍然需要手动下载 JAR 文件或本地库。也许您想创建自己的库，您可以在几个项目中重复使用它，而无需将其发布到公共或私有仓库。在这些情况下，无法使用任何在线资源，您将不得不使用不同的方式来添加依赖项。我们将描述如何使用文件依赖项，如何包含本地库，以及如何在您的项目中包含库项目。
- en: File dependencies
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件依赖
- en: 'To add a JAR file as a dependency, you can use the `files` method that Gradle
    provides. This is what it looks like:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 JAR 文件作为依赖项添加，您可以使用 Gradle 提供的 `files` 方法。它看起来是这样的：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This can get tedious if you have a lot of JAR files, so it might be easier
    to add an entire folder at once:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有很多 JAR 文件，这可能会变得很繁琐，所以一次性添加整个文件夹可能更容易：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'By default, a newly created Android project will have a libs folder, and declare
    it to be used for dependencies. Instead of simply depending on all files in the
    folder, there is a filter that makes sure that only JAR files are used:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，新创建的 Android 项目将有一个名为 libs 的文件夹，并声明它用于依赖项。而不是简单地依赖文件夹中的所有文件，这里有一个过滤器确保只使用
    JAR 文件：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This means that in any Android project that is created in Android Studio, you
    can drop a JAR in the libs folder, and it will automatically be included in the
    compile classpath and the final APK.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在 Android Studio 中创建的任何 Android 项目中，您可以将 JAR 文件放入 libs 文件夹，它将自动包含在编译类路径和最终的
    APK 中。
- en: Native libraries
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原生库
- en: Libraries written in C or C++ can be compiled to platform-specific native code.
    These libraries typically consist of several `.so` files, one for every platform.
    The Android plugin supports native libraries by default, all you need to do is
    create a directory called `jniLibs` on the module level, and create subdirectories
    for each platform. Drop the `.so` files in the applicable directory, and you are
    good to go.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 用 C 或 C++ 编写的库可以编译成特定平台的本地代码。这些库通常由几个 `.so` 文件组成，每个平台一个。Android 插件默认支持本地库，您需要做的只是在该模块级别创建一个名为
    `jniLibs` 的目录，并为每个平台创建子目录。将 `.so` 文件放入相应的目录，然后您就可以使用了。
- en: 'Your structure should look like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您的结构应该如下所示：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If this convention does not work for you, you can just set the location yourself
    in the build file:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个约定不适合您，您可以直接在构建文件中设置位置：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Library projects
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 库项目
- en: If you want to share a library that uses Android APIs, or includes Android resources,
    you need to create a library project. Library projects generally behave the same
    as application projects. You can use the same tasks to build and test library
    projects, and they can have different build variants. The difference is in the
    output. Where an application project generates an APK that can be installed and
    run on an Android device, a library project generates a `.aar` file. This file
    can be used as a library for Android application projects.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想共享一个使用 Android API 或包含 Android 资源的库，您需要创建一个库项目。库项目通常与应用程序项目表现相同。您可以使用相同的任务来构建和测试库项目，并且它们可以有不同的构建变体。区别在于输出。应用程序项目生成一个可以在
    Android 设备上安装和运行的 APK，而库项目生成一个 `.aar` 文件。这个文件可以用作 Android 应用程序项目的库。
- en: Creating and using library project modules
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建和使用库项目模块
- en: 'Instead of applying the Android application plugin, the build script applies
    the Android library plugin:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 与应用 Android 应用程序插件不同，构建脚本应用 Android 库插件：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There are two ways to include a library project in your application. One is
    to have it as a module inside your project; another is to create a `.aar` file,
    which can be reused in multiple applications.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的应用程序中包含库项目有两种方式。一种是将它作为项目内部的一个模块；另一种是创建一个 `.aar` 文件，该文件可以在多个应用程序中重复使用。
- en: 'If you set up a library project as a module in your project, you need to add
    the module to `settings.gradle` and add it as a dependency to the application
    module. The settings file should look like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将库项目作为你的项目中的一个模块设置，你需要将模块添加到 `settings.gradle` 中，并将其作为依赖项添加到应用程序模块中。设置文件应该看起来像这样：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this case, the library module is called `library`, and this corresponds
    to a folder with the same name. To use the library in the Android module, a dependency
    needs to be added to the `build.gradle` file of the Android module:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，库模块被命名为 `library`，这对应于一个具有相同名称的文件夹。要在 Android 模块中使用库，需要在 Android 模块的
    `build.gradle` 文件中添加一个依赖项：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This will include the output of the library in the classpath of the application
    module. We will look at this approach in more detail in [Chapter 5](ch05.html
    "Chapter 5. Managing Multimodule Builds"), *Managing Multimodule Builds*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把库的输出包含在应用程序模块的类路径中。我们将在第 5 章 [管理多模块构建](ch05.html "Chapter 5. Managing Multimodule
    Builds") 中更详细地探讨这种方法。
- en: Using .aar files
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `.aar` 文件
- en: 'If you create a library that you want to reuse in different Android applications,
    you can build a `.aar` file, and add it to your project as a dependency. The `.aar`
    file will be generated in the `build/output/aar/` folder of the module''s directory
    when building the library. To add the `.aar` file as a dependency, you need to
    create a folder in the application module, copy the `.aar` file to it, and add
    the folder as a repository:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你创建了一个你希望在多个 Android 应用程序中重用的库，你可以构建一个 `.aar` 文件，并将其作为依赖项添加到你的项目中。当构建库时，`.aar`
    文件将生成在模块目录的 `build/output/aar/` 文件夹中。要将 `.aar` 文件作为依赖项添加，你需要在应用程序模块中创建一个文件夹，将
    `.aar` 文件复制到其中，并将该文件夹作为仓库添加：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This will make it possible to add any file inside that folder as a dependency.
    You can reference the dependency as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使得可以添加该文件夹内的任何文件作为依赖项。你可以按照以下方式引用依赖项：
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This tells Gradle to look for a library with a certain name that has the `.aar`
    extension.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉 Gradle 查找具有特定名称且具有 `.aar` 扩展名的库。
- en: Dependency concepts
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖项概念
- en: There are a few dependency-related concepts that are interesting to understand,
    even if you might not need to use them today. One of them is the concept of configurations,
    which explains the `compile` keyword that we have been using for dependencies
    throughout this chapter.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你可能今天不需要使用它们，也有一些与依赖项相关的概念值得理解。其中之一是配置的概念，它解释了我们在这章中一直使用的用于依赖项的 `compile`
    关键字。
- en: Configurations
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置
- en: Sometimes you might have to work with an SDK that is only present on certain
    devices, like a Bluetooth SDK from a specific vendor, for example. In order to
    be able to compile the code, you need to add the SDK to your compile classpath.
    You do not need to include the SDK in your APK though, because it is already on
    the device. This is where dependency configurations come in.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能需要与仅在某些设备上存在的 SDK 一起工作，例如，一个特定供应商的蓝牙 SDK。为了能够编译代码，你需要将 SDK 添加到你的编译类路径中。不过，你不需要将
    SDK 包含在 APK 中，因为它已经存在于设备上了。这就是依赖配置发挥作用的地方。
- en: 'Gradle groups dependencies into configurations, which are just named sets of
    files. These are the standard configurations for an Android app or library:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle 将依赖项分组到配置中，这些配置只是命名文件集。这些是 Android 应用程序或库的标准配置：
- en: '`compile`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compile`'
- en: '`apk`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apk`'
- en: '`provided`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`provided`'
- en: '`testCompile`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testCompile`'
- en: '`androidTestCompile`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`androidTestCompile`'
- en: The `compile` configuration is the default one and contains all dependencies
    required to compile the main application. Everything in this configuration is
    not only added to the classpath, but also to the generated APK.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`compile` 配置是默认配置，包含编译主应用程序所需的所有依赖项。此配置中的所有内容不仅被添加到类路径中，还被添加到生成的 APK 中。'
- en: The dependencies in the `apk` configuration will only be added to the package,
    and are not added to the compilation classpath. The `provided` configuration does
    the exact opposite, and its dependencies will not be packaged. These two configurations
    only take JAR dependencies. Trying to add library projects to them will result
    in an error.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`apk` 配置中的依赖项只会添加到包中，而不会添加到编译类路径中。`provided` 配置则相反，其依赖项不会被打包。这两个配置仅接受 JAR 依赖项。尝试将库项目添加到它们中会导致错误。'
- en: Finally, the `testCompile` and `androidTestCompile` configurations add extra
    libraries specifically for testing. These configurations are used when running
    test-related tasks, which can be useful when adding a testing framework such as
    JUnit or Espresso. You only want these frameworks to be present in the test APK,
    not in the release APK.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`testCompile` 和 `androidTestCompile` 配置添加了专门用于测试的额外库。这些配置在运行与测试相关的任务时使用，当添加测试框架如
    JUnit 或 Espresso 时非常有用。你只希望这些框架存在于测试 APK 中，而不是发布 APK 中。
- en: Besides those standard configurations, the Android plugin also generates configurations
    for every build variant, making it possible to add dependencies to configurations
    such as `debugCompile`, `releaseProvided`, and so on. This can be useful if you
    want to add a logging framework to only your debug builds, for example. You can
    find more information on this in [Chapter 4](ch04.html "Chapter 4. Creating Build
    Variants"), *Creating Build Variants*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些标准配置之外，Android 插件还为每个构建变体生成配置，使得可以将依赖项添加到 `debugCompile`、`releaseProvided`
    等配置中。如果你只想将日志框架添加到调试构建中，这非常有用。你可以在[第 4 章](ch04.html "第 4 章。创建构建变体") *创建构建变体* 中找到更多相关信息。
- en: Semantic versioning
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语义版本控制
- en: 'Versioning is an important aspect of dependency management. Dependencies added
    to repositories such as JCenter are assumed to follow a set of rules for versioning,
    called semantic versioning. With semantic versioning, a version number always
    has the format `major.minor.patch`, and the numbers are incremented according
    to the following rules:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制是依赖项管理的重要方面。添加到 JCenter 等仓库的依赖项假定遵循一组版本控制规则，称为语义版本控制。在语义版本控制中，版本号始终具有 `major.minor.patch`
    的格式，并且数字根据以下规则递增：
- en: A major version goes up when you make incompatible API changes
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你进行不兼容的 API 变更时，主版本号会上升
- en: A minor version gets updated when you add functionality in a backwards-compatible
    manner
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你以向后兼容的方式添加功能时，次要版本会更新
- en: A patch is incremented when you make bug fixes
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你进行错误修复时，补丁版本会增加
- en: Dynamic versions
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态版本
- en: 'In some situations, you might want to get the latest version of a dependency
    every time you build your app or library. The best way to accomplish this is by
    using dynamic versions. There are several ways to apply dynamic versions, here
    are some examples:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能希望在构建你的应用程序或库时每次都获取依赖项的最新版本。实现这一目标的最佳方式是使用动态版本。应用动态版本有几种方法，以下是一些示例：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the first line, we tell Gradle to get the latest patch release. In line two,
    we specify that we want to get every new minor version, and it has to be at least
    minor version 2\. In the last line, we tell Gradle always to get the newest version
    of the library.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们告诉 Gradle 获取最新的补丁版本。在第二行，我们指定我们想要获取每个新的次要版本，并且它至少要是次要版本 2。在最后一行，我们告诉
    Gradle 总是获取库的最新版本。
- en: You should be careful with using dynamic versions. If you allow Gradle to pick
    up the latest version, it might pick up a dependency version that is unstable,
    causing the build to break. Even worse, you could end up with different versions
    of a dependency on the build server and on your personal machine, causing your
    application's behavior to be inconsistent.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用动态版本时应该小心。如果你允许 Gradle 选择最新版本，它可能会选择一个不稳定的依赖项版本，导致构建失败。更糟糕的是，你可能会在构建服务器和个人机器上得到依赖项的不同版本，导致你的应用程序行为不一致。
- en: 'Android Studio will warn you about the possible problems with dynamic versions
    when you try to use it in your build file, as you can see in the following screenshot:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在构建文件中尝试使用动态版本时，Android Studio 会警告你有关动态版本可能存在的问题，如以下截图所示：
- en: '![Dynamic versions](img/B01061_03_01.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![动态版本](img/B01061_03_01.jpg)'
- en: Inside Android Studio
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android Studio 内部
- en: 'The easiest way to add new dependencies is to use Android Studio''s **Project
    Structure** dialog. Open the dialog from the **File** menu and navigate to the
    **Dependencies** tab to get an overview of your current dependencies:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新依赖项最简单的方法是使用 Android Studio 的 **项目结构** 对话框。从 **文件** 菜单打开对话框，并导航到 **依赖项**
    选项卡以查看当前依赖项的概述：
- en: '![Inside Android Studio](img/B01061_03_02.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![Android Studio 内部](img/B01061_03_02.jpg)'
- en: 'From this dialog, you can add new dependencies by clicking on the green plus
    icon. You can add other modules, files, and you can even search JCenter for libraries:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 从此对话框，你可以通过点击绿色加号图标添加新的依赖项。你可以添加其他模块、文件，甚至可以在 JCenter 中搜索库：
- en: '![Inside Android Studio](img/B01061_03_03.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![Android Studio 内部](img/B01061_03_03.jpg)'
- en: Using the Android Studio dialog makes it easy to get an overview of the dependencies
    in your project, and to add new libraries. You do not need to manually add lines
    to the `build.gradle` file, and it is easy to search JCenter straight from the
    IDE.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Android Studio 对话框可以轻松地查看项目中依赖项的概览，并添加新的库。你不需要手动向 `build.gradle` 文件中添加行，并且可以直接从
    IDE 中搜索 JCenter。
- en: Summary
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at several ways to add dependencies to an Android
    project. We learned about repositories, all the forms they can come in, and how
    we can depend on files without using repositories.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了向 Android 项目添加依赖项的几种方法。我们学习了仓库、它们可能出现的所有形式，以及我们如何在不需要使用仓库的情况下依赖文件。
- en: You now also know about some important concepts regarding dependencies, namely
    configurations, semantic versioning, and dynamic versions.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你也已经了解了一些关于依赖项的重要概念，即配置、语义版本和动态版本。
- en: We have mentioned build variants on several occasions already, and in the next
    chapter, we will finally explain what build variants are, and why they are useful.
    Build variants can make it easier to develop, test, and distribute apps. Understanding
    how variants work can significantly speed up your development and distribution
    process.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次提到构建变体，在下一章中，我们将最终解释什么是构建变体，以及它们为什么有用。构建变体可以使开发、测试和分发应用变得更加容易。了解变体的工作原理可以显著加快你的开发和分发过程。
