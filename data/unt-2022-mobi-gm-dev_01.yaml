- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Building Your Game
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建你的游戏
- en: As we start on our journey of building mobile games using the Unity game engine,
    it’s important that you are familiar with the engine itself before we dive into
    the specifics of building things for mobile platforms. Although there is a chance
    that you’ve already built a game and want to transition it to mobile, there will
    also be those of you who haven’t touched **Unity** before or may not have used
    it in a long time. This chapter will act as an introduction to newcomers and a
    refresher for those coming back, and it will provide some best practices for those
    who are already familiar with Unity. While you may skip this chapter if you’re
    already familiar with Unity, I think it’s also a good idea to go through the project
    so that you know the thought processes behind why the project is made in the way
    that it is, so that you can keep it in mind for your own future titles.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始使用 Unity 游戏引擎构建移动游戏时，在深入探讨移动平台构建细节之前，熟悉引擎本身是很重要的。虽然有可能你已经构建了一个游戏并希望将其迁移到移动平台，但也会有那些之前从未接触过
    **Unity** 或许很久没有使用过它的人。本章将为新来者提供一个介绍，并为回归者提供一个复习，同时为已经熟悉 Unity 的人提供一些最佳实践。虽然如果你已经熟悉
    Unity，可以跳过这一章，但我认为了解项目背后的思考过程也很重要，这样你就可以在未来的作品中记住这些思考，以便为你的未来作品做好准备。
- en: In this chapter, we will build a 3D endless runner game in the same vein as
    *Imangi Studios LLC’s* *Temple Run* series. In our case, we will have a player
    who will run continuously in a certain direction and dodge the obstacles that
    are in their way. We can also add additional features to the game easily, as the
    game will endlessly have new things added to it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个类似于 *Imangi Studios LLC 的 *Temple Run* 系列的 3D 无尽跑酷游戏。在我们的案例中，玩家将连续向某个方向奔跑并躲避挡在他们路上的障碍物。我们还可以轻松地为游戏添加额外功能，因为游戏将不断添加新内容。
- en: 'This chapter will be split into several topics. It will contain simple, step-by-step
    processes for you to follow. Here is an outline of our tasks:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将分为几个主题。它将包含简单的、逐步的过程供你遵循。以下是我们的任务概述：
- en: Setting up the project
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置项目
- en: Creating the player
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建玩家
- en: Moving the player through a C# script
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 C# 脚本移动玩家
- en: Improving scripts using attributes and XML comments
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用属性和 XML 注释改进脚本
- en: Update function versus FixedUpdate function
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Update 函数与 FixedUpdate 函数
- en: Having the camera follow our player
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让摄像机跟随我们的玩家
- en: Creating a basic tile
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建基本瓦片
- en: Making the game endless
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使游戏无限
- en: Creating obstacles
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建障碍物
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This book utilizes *Unity 2022.1.0b14* and *Unity Hub 3.3.1*, but the steps
    should work with minimal changes in future versions of the editor. If you would
    like to download the exact version used in this book, and there is a new version
    out, you can visit Unity’s download archive at [https://unity3d.com/get-unity/download/archive](https://unity3d.com/get-unity/download/archive).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用 *Unity 2022.1.0b14* 和 *Unity Hub 3.3.1*，但步骤应该在未来版本的编辑器中只需做最小改动即可。如果你想要下载本书中使用的确切版本，并且有新版本发布，你可以访问
    Unity 的下载存档 [https://unity3d.com/get-unity/download/archive](https://unity3d.com/get-unity/download/archive)。
- en: You can also find the system requirements for Unity at [https://docs.unity3d.com/2022.1/Documentation/Manual/system-requirements.html](https://docs.unity3d.com/2022.1/Documentation/Manual/system-requirements.html)
    in the *Unity Editor system* *requirements* section.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在 *Unity 编辑器系统* *要求* 部分的 [https://docs.unity3d.com/2022.1/Documentation/Manual/system-requirements.html](https://docs.unity3d.com/2022.1/Documentation/Manual/system-requirements.html)
    找到 Unity 的系统要求。
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Unity-2022-Mobile-Game-Development-3rd-Edition/tree/main/Chapter01](https://github.com/PacktPublishing/Unity-2022-Mobile-Game-Development-3rd-Edition/tree/main/Chapter01).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上找到本章的代码文件，地址为 [https://github.com/PacktPublishing/Unity-2022-Mobile-Game-Development-3rd-Edition/tree/main/Chapter01](https://github.com/PacktPublishing/Unity-2022-Mobile-Game-Development-3rd-Edition/tree/main/Chapter01)。
- en: Setting up the project
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置项目
- en: 'Now that we have our goals in mind, let’s start building our project:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经明确了目标，让我们开始构建我们的项目：
- en: To get started, open Unity Hub on your computer.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始，请在你的电脑上打开 Unity Hub。
- en: From startup, we’ll opt to create a new project by clicking on the **New** button.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从启动开始，我们将通过点击 **新建** 按钮来创建一个新的项目。
- en: 'Next, under `MobileDev`), and under **Templates**, make sure that **3D** is
    selected. Afterward, click on **CREATE** and wait for Unity to load up:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在 `MobileDev` 下，并在 **模板** 中，确保 **3D** 已被选中。之后，点击 **创建** 并等待 Unity 加载：
- en: '![Figure 1.1 – Creating a 3D project](img/B18868_01_01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1 – 创建 3D 项目](img/B18868_01_01.jpg)'
- en: Figure 1.1 – Creating a 3D project
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – 创建 3D 项目
- en: 'After it’s finished, you’ll see the Unity Editor pop up for the first time:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，你将看到 Unity 编辑器首次弹出：
- en: '![Figure 1.2 – The Unity Editor](img/B18868_01_02.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – Unity 编辑器](img/B18868_01_02.jpg)'
- en: Figure 1.2 – The Unity Editor
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – Unity 编辑器
- en: 'If your layout doesn’t look the same as in the preceding screenshot, go to
    the top-right section of the toolbar and select the drop-down menu there that
    reads **Layout**. From there, select **Default** from the options presented:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你的布局看起来与前面的截图不同，请转到工具栏的右上角部分，并选择那里的下拉菜单，该菜单显示为 **Layout**。从那里，从提供的选项中选择 **Default**：
- en: '![Figure 1.3 – The Layout button](img/B18868_01_03.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3 – 布局按钮](img/B18868_01_03.jpg)'
- en: Figure 1.3 – The Layout button
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – 布局按钮
- en: We now have opened Unity for the first time and have the default layout displayed!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经首次打开 Unity，并显示了默认布局！
- en: Tip
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: If this is your first time working with Unity, then I highly recommend that
    you read the *Unity’s interface* section of the *Unity Manual*, which you can
    access at [https://docs.unity3d.com/Manual/UsingTheEditor.html](https://docs.unity3d.com/Manual/UsingTheEditor.html).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是你第一次使用 Unity，那么我强烈建议你阅读 *Unity 用户手册* 中的 *Unity 的界面* 部分，你可以通过 [https://docs.unity3d.com/Manual/UsingTheEditor.html](https://docs.unity3d.com/Manual/UsingTheEditor.html)
    访问。
- en: Now that we have Unity open, we can actually start building our project.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经打开了 Unity，我们实际上可以开始构建我们的项目了。
- en: Creating the player
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建玩家
- en: 'To get started, we’ll build a player that will always move forward. Let’s start
    with that now:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们将构建一个始终向前移动的玩家。现在让我们开始吧：
- en: To get started, we will create some ground for our player to walk on. To do
    that, go to the top menu and select **GameObject** | **3D Object** | **Cube**.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始，我们将为玩家创建一些可以行走的地面。为此，转到顶部菜单并选择 **GameObject** | **3D Object** | **Cube**。
- en: From there, we’ll move over to the `Floor`. Then, for the `0`, `0`, `0`). This
    can be done by either typing the values in or right-clicking on the **Transform**
    component and then selecting the **Reset** **Position** option.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从那里，我们将移动到 `Floor`。然后，对于 `0`, `0`, `0`)。这可以通过输入值或右键单击 **Transform** 组件然后选择 **Reset**
    **Position** 选项来完成。
- en: 'Then, we will set the `7`, `0.1`, `10`):'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '然后，我们将设置 `7`, `0.1`, `10`):'
- en: '![Figure 1.4 – Creating the ground](img/B18868_01_04.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.4 – 创建地面](img/B18868_01_04.jpg)'
- en: Figure 1.4 – Creating the ground
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – 创建地面
- en: In Unity, by default, `1` unit of space is representative of 1 meter in real
    life. So, our **Scale** values will make the floor longer than it is wide (**X**
    and **Z**), and we have some size on the ground (**Y**), so the player will collide
    and land on it because we have a **Box Collider** component attached to it by
    default.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 中，默认情况下，`1` 单位空间代表现实生活中的 `1` 米。因此，我们的 **Scale** 值将使地面比它宽（**X** 和 **Z**）更长，我们在地面上有一些大小（**Y**），所以玩家会与之碰撞并落在上面，因为我们默认附加了一个
    **Box Collider** 组件。
- en: Note
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The **Box Collider** component is added automatically when creating a **Cube**
    object and is required to have objects collide with it. For more information on
    the **Box Collider** component, check out [https://docs.unity3d.com/Manual/class-BoxCollider.html](https://docs.unity3d.com/Manual/class-BoxCollider.html).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建 **Cube** 对象时，会自动添加 **Box Collider** 组件，并且需要将其附加到对象上以进行碰撞。有关 **Box Collider**
    组件的更多信息，请参阅 [https://docs.unity3d.com/Manual/class-BoxCollider.html](https://docs.unity3d.com/Manual/class-BoxCollider.html)。
- en: Next, we will create our player, which will be a sphere. To do this, we will
    go to **GameObject** | **3D Object** | **Sphere**.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建我们的玩家，它将是一个球体。为此，我们将转到 **GameObject** | **3D Object** | **Sphere**。
- en: 'Rename the sphere to `Player` and set the `0`, `1`, `-4`):'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '将球体重命名为 `Player` 并设置 `0`, `1`, `-4`):'
- en: '![Figure 1.5 – Positioning the player](img/B18868_01_05.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.5 – 定位玩家](img/B18868_01_05.jpg)'
- en: Figure 1.5 – Positioning the player
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5 – 定位玩家
- en: This places the ball slightly above the ground and shifts it back to near the
    starting point. Note that the camera object (see the camera icon) is pointing
    toward the ball by default because it is positioned at (`0`, `1`, `-10`).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这将球体略微抬离地面并将其移回到接近起点。注意，相机对象（见相机图标）默认指向球体，因为它位于 (`0`, `1`, `-10`）的位置。
- en: 'We want the ball to move, so we will need to tell the physics engine that we
    want to have this object react to forces, so we will need to add a **Rigidbody**
    component. To do so, with the **Player** object selected, go to the menu and select
    **Component** | **Physics** | **Rigidbody**. To see what happens now, let’s click
    on the **Play** button, which can be seen in the middle of the first toolbar:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望球体移动，因此需要通知物理引擎我们希望这个物体对力做出反应，所以我们需要添加一个**Rigidbody**组件。要做到这一点，在**Player**对象被选中时，进入菜单并选择**Component**
    | **Physics** | **Rigidbody**。为了查看现在会发生什么，让我们点击中间第一个工具栏上的**Play**按钮：
- en: '![Figure 1.6 – Current state of the game](img/B18868_01_06.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图1.6 – 游戏当前状态](img/B18868_01_06.jpg)'
- en: Figure 1.6 – Current state of the game
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6 – 游戏当前状态
- en: As in the preceding screenshot, you should see the ball fall down onto the ground
    when we play the game.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一张截图所示，当我们在游戏中播放时，应该看到球体掉到地面上。
- en: Tip
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can disable/enable having the **Game** tab take up the entire screen when
    being played by clicking on the **Maximize On Play** button at the top, or by
    right-clicking on the **Game** tab and then selecting **Maximize**.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过单击顶部的**Maximize On Play**按钮或右键单击**Game**标签并选择**Maximize**来启用/禁用在播放时占用整个屏幕的**Game**标签。
- en: Click on the **Play** button again to turn the game off and go back to the **Scene**
    tab, if it doesn’t happen automatically.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次点击**Play**按钮以关闭游戏并返回到**Scene**标签，如果它没有自动发生。
- en: We now have the objects for both the floor and the player in the game and have
    told the player to react to physics! Next, we will add interactivity to the player
    through the use of code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在游戏中有了地板和玩家的对象，并且已经告诉玩家要响应物理！接下来，我们将通过代码的使用为玩家添加交互性。
- en: Moving the player through a C# script
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过C#脚本移动玩家
- en: 'We want the player to move, so in order to do that, we will create our own
    piece of functionality in a script, effectively creating our own custom component
    in the process:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望玩家能够移动，因此为了实现这一点，我们将在脚本中创建我们自己的功能，实际上在这个过程中创建我们自己的自定义组件：
- en: 'To create a script, we will go to the **Project** window and select the **Create**
    button in the top-left corner of the menu by clicking on the **+** icon, and then
    we will select **Folder**:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个脚本，我们将进入**Project**窗口，并单击菜单左上角的**Create**按钮，点击**+**图标，然后选择**Folder**：
- en: '![Figure 1.7 – Location of the + icon](img/B18868_01_07.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图1.7 – + 图标的定位](img/B18868_01_07.jpg)'
- en: Figure 1.7 – Location of the + icon
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7 – + 图标的定位
- en: Tip
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can also access the **Create** menu by right-clicking on the right-hand
    side of the **Project** window. With this method, you can right-click and then
    select **Create** | **Folder**.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过在**Project**窗口的右侧单击右键来访问**Create**菜单。使用此方法，您可以右键单击并选择**Create** | **Folder**。
- en: From there, we’ll name this folder `Scripts`. It’s always a good idea to organize
    our projects, so this will help with that.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从那里，我们将这个文件夹命名为`Scripts`。始终组织我们的项目是个好主意，这样有助于项目组织。
- en: Tip
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you happen to misspell the name of an item in the **Project** window, you
    can rename it by either right-clicking and selecting the **Rename** option or
    selecting the object and then single-clicking on the name.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在**Project**窗口中不小心拼错了某个项目的名称，你可以通过右键单击并选择**Rename**选项，或者选择对象然后单击名称来重命名它。
- en: Double-click on the folder to enter it, create a script by going to `PlayerBehaviour`
    (no spaces).
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击文件夹进入，在`PlayerBehaviour`（没有空格）处创建一个脚本。
- en: Note
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The reason I’m using the *behaviour* spelling instead of *behavior* is that
    all components in Unity are children of another class called `MonoBehaviour`,
    and I’m following Unity’s lead in that regard.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我之所以使用*behaviour*而不是*behavior*，是因为Unity中的所有组件都是另一个名为`MonoBehaviour`的类的子类，我在这方面遵循Unity的指导。
- en: 'Double-click on the script to open up the script editor (IDE) of your choice
    and add the following code to it:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击脚本以打开您选择的脚本编辑器（IDE），并向其中添加以下代码：
- en: '[PRE0]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, we have a couple of variables that we will be working
    with. The `rb` variable is a reference to the GameObject’s `Rigidbody` component
    that we added previously. It gives us the ability to make the object move, which
    we will use in the `Update` function. We also have two variables, `dodgeSpeed`
    and `rollSpeed`, which dictate how quickly the player will move when moving left/right
    or when moving forward, respectively.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有一些将要使用的变量。`rb`变量是对我们之前添加的GameObject的`Rigidbody`组件的引用。它使我们能够使对象移动，我们将在`Update`函数中使用它。我们还有两个变量，`dodgeSpeed`和`rollSpeed`，分别决定了玩家在左右移动或向前移动时移动的速度。
- en: Since our object has only one `Rigidbody` component, we assign `rb` once in
    the `Start` function, which is called when the GameObject is loaded into the scene
    at the beginning of the game.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的对象只有一个`Rigidbody`组件，我们在`Start`函数中将其分配一次，该函数在游戏开始时将GameObject加载到场景中时被调用。
- en: Then, we use the `Update` function to check whether our player is pressing keys
    to move left or right based on Unity’s `Input.GetAxis` function will return to
    us a negative value, moving to `-1` if we press *A* or the left arrow. If we press
    the right arrow or *D*, we will get a positive value up to `1` returned to us,
    and the input will move toward `0` if nothing is pressed. We then multiply this
    by `dodgeSpeed` in order to increase the speed so that the movement of the object
    is easier to see.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`Update`函数来检查我们的玩家是否按下了按键以根据Unity的`Input.GetAxis`函数返回的负值来移动左右。如果我们按下“A”键或左箭头，它将返回`-1`。如果我们按下右箭头或“D”键，我们将得到一个返回的正值，直到`1`，如果没有按键，输入将移动到`0`。然后我们将其乘以`dodgeSpeed`以增加速度，以便更容易看到对象的移动。
- en: Note
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on the Input Manager, check out [https://docs.unity3d.com/Manual/class-InputManager.html](https://docs.unity3d.com/Manual/class-InputManager.html).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有关输入管理器的更多信息，请参阅[https://docs.unity3d.com/Manual/class-InputManager.html](https://docs.unity3d.com/Manual/class-InputManager.html)。
- en: Finally, once we have that value, we will apply a force to our ball’s `horizontalSpeed`
    units on the *X* axis and `rollSpeed` on the *Z* axis.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一旦我们有了这个值，我们将对球在X轴上的`horizontalSpeed`单位以及Z轴上的`rollSpeed`应用一个力。
- en: Save your script and return to the Unity Editor.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的脚本并返回到Unity编辑器。
- en: We will now need to assign this script to our player by selecting the `Player`
    object in the `PlayerBehaviour` script from the `Player` object.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要通过从`Player`对象中选择`PlayerBehaviour`脚本中的`Player`对象来将此脚本分配给我们的玩家。
- en: Note
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Note that when writing scripts, if we declare a variable as `public`, it will
    show up in the `public` when we want designers to tweak the values for gameplay
    purposes, but it also allows other scripts to access the property in code. By
    default, variables and methods are `private`, which means they can only be used
    within the class. For more information on access modifiers, check out [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/access-modifiers](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/access-modifiers).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当编写脚本时，如果我们将一个变量声明为`public`，它将在我们希望设计师为了游戏玩法目的调整值时显示在`public`中，但它也允许其他脚本在代码中访问该属性。默认情况下，变量和方法是`private`的，这意味着它们只能在类内部使用。有关访问修饰符的更多信息，请参阅[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/access-modifiers](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/access-modifiers)。
- en: 'If all goes well, we should see the script appear on our object, as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们应该在我们的对象上看到脚本，如下所示：
- en: "![Figure 1.8 – The PlayerBehaviour co\uFEFFmponent added](img/B18868_01_08.jpg)"
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图1.8 – 添加的PlayerBehaviour组件](img/B18868_01_08.jpg)'
- en: Figure 1.8 – The PlayerBehaviour component added
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8 – 添加的PlayerBehaviour组件
- en: 'Save your scene by going to **File** | **Save**. Afterward, play the game and
    use the left and right arrows to see the player moving according to your input,
    but no matter what, moving forward by default:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到**文件** | **保存**来保存你的场景。之后，玩游戏并使用左右箭头查看玩家根据你的输入移动，但无论如何，默认情况下向前移动：
- en: '![Figure 1.9 – The current state of the game](img/B18868_01_09.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图1.9 – 游戏当前状态](img/B18868_01_09.jpg)'
- en: Figure 1.9 – The current state of the game
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.9 – 游戏当前状态
- en: Now you can see that the ball moves automatically, and our input is received
    correctly!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以看到球会自动移动，并且我们的输入被正确接收！
- en: Improving our scripts with attributes and XML comments
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用属性和XML注释改进我们的脚本
- en: We could stop working with the `PlayerBehaviour` class script here, but I want
    to touch on a couple of things that we can use in order to improve the quality
    and style of our code. This becomes especially useful when you start building
    projects in teams. As you’ll be working with other people, some of them will be
    working on code with you. Then, there will be designers and artists who will not
    be working on code with you but will still need to use the things that you’ve
    programmed.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以停止使用 `PlayerBehaviour` 类脚本，但我想要提及一些我们可以用来提高代码质量和风格的事情。当你开始以团队形式构建项目时，这变得特别有用。因为你将与其他人一起工作，其中一些人将与你一起编写代码。然后，将会有设计师和艺术家，他们不会与你一起编写代码，但仍然需要使用你编写的程序。
- en: When writing scripts, we want them to be as error-proof as possible. Making
    the `rb` variable `private` starts that process, as now the user will not be able
    to modify that anywhere outside of this class. We want our teammates to modify
    `dodgeSpeed` and `rollSpeed`, but we may want to give them some advice as to what
    it is and/or how it will be used. To do this in the **Inspector** window, we can
    make use of something called an **attribute**.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写脚本时，我们希望它们尽可能没有错误。将 `rb` 变量设置为 `private` 开始了这个过程，因为现在用户将无法在这个类之外修改它。我们希望我们的队友修改
    `dodgeSpeed` 和 `rollSpeed`，但我们可能希望给他们一些关于它是什么以及/或如何使用的建议。要在 **检查器** 窗口中这样做，我们可以使用一种称为
    **属性** 的东西。
- en: Using attributes
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用属性
- en: Attributes are things we can add to the beginning of a variable, class, or function
    declaration, which allow us to attach additional functionality to them. There
    are many of them that exist inside Unity, and you can write your very own attributes
    as well, but right now, we’ll talk about the ones that I use most often.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 属性是我们可以在变量、类或函数声明开头添加的东西，它允许我们附加额外的功能。Unity 中存在许多这样的属性，你也可以编写你自己的属性，但现在是时候谈谈我使用最频繁的属性了。
- en: The Tooltip attribute
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工具提示属性
- en: 'If you’ve used Unity for a period of time, you may have noted that some components
    in the `Rigidbody`, have a nice feature—if you move your mouse over a variable
    name, you’ll see a description of what the variables are and/or how to use them.
    The first thing you’ll learn is how we can get the same effect in our own components
    by making use of the `Tooltip` attribute. If we do this for the `dodgeSpeed` and
    `rollSpeed` variables, it will look something like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经使用 Unity 一段时间了，你可能已经注意到 `Rigidbody` 中的一些组件有一个很好的功能——如果你将鼠标移到变量名上，你会看到变量是什么以及如何使用它们的描述。你首先会学到的是，我们可以通过使用
    `Tooltip` 属性在我们的组件中实现相同的效果。如果我们对 `dodgeSpeed` 和 `rollSpeed` 变量这样做，它看起来可能就像这样：
- en: '[PRE1]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Save the preceding script and return to the editor:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 保存前面的脚本并返回到编辑器：
- en: '![Figure 1.10 – Tooltip attribute example](img/B18868_01_10.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.10 – 工具提示属性示例](img/B18868_01_10.jpg)'
- en: Figure 1.10 – Tooltip attribute example
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.10 – 工具提示属性示例
- en: Now, when we highlight the variable using the mouse and leave it there, the
    text we placed will be displayed. This is a great habit to get into, as your teammates
    can always tell what it is that your variables are being used for without having
    to actually look at the script itself.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们使用鼠标突出显示变量并保持在那里时，我们将显示放置的文本。这是一个非常好的习惯，因为你的队友可以始终知道你的变量被用于什么，而无需实际查看脚本本身。
- en: Note
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on the `Tooltip` attribute, check out [https://docs.unity3d.com/ScriptReference/TooltipAttribute.html](https://docs.unity3d.com/ScriptReference/TooltipAttribute.html).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 `Tooltip` 属性的信息，请查看 [https://docs.unity3d.com/ScriptReference/TooltipAttribute.html](https://docs.unity3d.com/ScriptReference/TooltipAttribute.html)。
- en: The Range attribute
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 范围属性
- en: 'Another thing that we can use to protect our code is the `Range` attribute.
    This will allow us to specify a minimum and maximum value for a variable. Since
    we want the player to always be moving forward, we may want to restrict the player
    from moving backward. To do that, we can add the following highlighted line of
    code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以用来保护我们的代码的是 `Range` 属性。这将允许我们为变量指定一个最小值和最大值。由于我们希望玩家始终向前移动，我们可能希望限制玩家向后移动。为此，我们可以添加以下突出显示的代码行：
- en: '[PRE2]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Save your script, and return to the editor:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 保存你的脚本，并返回到编辑器：
- en: "![Figure 1.11 – R\uFEFFange attribute example](img/B18868_01_11.jpg)"
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.11 – 范围属性示例](img/B18868_01_11.jpg)'
- en: Figure 1.11 – Range attribute example
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.11 – 范围属性示例
- en: We have now added a slider beside our value, and we can drag it to adjust between
    our minimum and maximum values. Not only does this protect our variable from being
    changed to an invalid state but also makes it so that our designers can tweak
    things easily by just dragging them around.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在我们的值旁边添加了一个滑动条，我们可以拖动它来调整我们的最小值和最大值之间。这不仅保护我们的变量不被改变为无效状态，还使得我们的设计师可以通过简单地拖动它们来轻松调整事物。
- en: The RequireComponent attribute
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`RequireComponent` 属性'
- en: Currently, we are using the `Rigidbody` component in order to create our script.
    When working as a team member, others may not be reading your scripts but are
    still expected to use them when creating gameplay. Unfortunately, this means that
    they may do things that have unintended results, such as removing the `Rigidbody`
    component, which will cause errors when our script is run. Thankfully, we also
    have the `RequireComponent` attribute, which we can use to fix this.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们正在使用 `Rigidbody` 组件来创建我们的脚本。当作为团队成员工作时，其他人可能不会阅读你的脚本，但仍然期望他们在创建游戏玩法时使用它们。不幸的是，这意味着他们可能会做一些意想不到的事情，例如移除
    `Rigidbody` 组件，这将在我们的脚本运行时导致错误。幸运的是，我们还有 `RequireComponent` 属性，我们可以用它来解决这个问题。
- en: 'It looks something like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来像这样：
- en: '[PRE3]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: By adding this attribute, we state that when we include this component in a
    GameObject and it doesn’t have a `Rigidbody` component attached to its GameObject,
    the component will be added automatically. It also makes it so that if we were
    to try to remove the `Rigidbody` component from this object, the editor will warn
    us that we can’t, unless we remove the `PlayerBehaviour` component first. Note
    that this works for any class extended from `MonoBehaviour`; just replace `Rigidbody`
    with whatever it is that you wish to keep.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加此属性，我们声明，当我们将此组件包含在 GameObject 中且其 GameObject 没有附加 `Rigidbody` 组件时，组件将被自动添加。这也使得如果我们尝试从该对象中移除
    `Rigidbody` 组件，编辑器将警告我们无法这样做，除非我们首先移除 `PlayerBehaviour` 组件。请注意，这适用于从 `MonoBehaviour`
    扩展的任何类；只需将 `Rigidbody` 替换为你希望保留的内容即可。
- en: 'Now, if we go into the Unity Editor and try to remove the `Rigidbody` component
    by right-clicking on it in **Inspector** and selecting **Remove Component**, the
    following message will be seen:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们进入 Unity 编辑器，并尝试通过在 **检查器** 中右键单击它并选择 **移除组件** 来移除 `Rigidbody` 组件，将会看到以下消息：
- en: '![Figure 1.12 – Can’t remove component window](img/B18868_01_12.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.12 – 无法移除组件窗口](img/B18868_01_12.jpg)'
- en: Figure 1.12 – Can’t remove component window
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.12 – 无法移除组件窗口
- en: This is exactly what we want, and this ensures that the component will be there,
    allowing us not to have to include `if` checks every time we want to use a component.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们想要的，这确保了组件将存在，使我们不必每次想要使用组件时都包含 `if` 检查。
- en: 'Note that, previously, we did not use a `Tooltip` attribute on the private
    `rb` variable. Since it’s not being displayed in the editor, it’s not really needed.
    However, there is a way that we can enhance that as well: using XML comments.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，之前我们没有在私有变量 `rb` 上使用 `Tooltip` 属性。由于它不会在编辑器中显示，所以实际上并不需要。然而，我们也可以通过使用 XML
    注释来增强这一点：使用 XML 注释。
- en: XML comments
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XML 注释
- en: We can achieve a couple of nice things with XML comments that we otherwise couldn’t
    with traditional comments, which we were using previously. When using variables/functions
    instead of code in Visual Studio, we will now see a comment about it. This will
    help other coders on your team with additional information and details to ensure
    that they are using your code correctly.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 XML 注释实现一些我们之前使用传统注释无法实现的好事情。当我们在 Visual Studio 中使用变量/函数而不是代码时，现在我们将看到关于它的注释。这将帮助团队中的其他开发者通过额外的信息和细节确保他们正确地使用你的代码。
- en: 'XML comments look something like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: XML 注释看起来像这样：
- en: '[PRE4]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It may appear that a lot more writing is needed to use this format, but I did
    not actually type the entire thing out. XML comments are a fairly standard C#
    feature, so if you are using MonoDevelop or Visual Studio and type `///`, the
    action will automatically generate the summary blocks for you (and the `param`
    tags needed, if there are parameters needed for something such as a function).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 可能看起来需要更多的写作才能使用这种格式，但实际上我并没有全部打出来。XML 注释是 C# 的一个相当标准的特性，所以如果你使用 MonoDevelop
    或 Visual Studio 并输入 `///`，动作将自动为你生成摘要块（以及如果需要参数，如函数所需的 `param` 标签）。
- en: 'Now, why would we want to do this? Well, if you select the variable in IntelliSense,
    it will display the following information to us:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们为什么要这样做呢？好吧，如果你在 IntelliSense 中选择变量，它将显示以下信息给我们：
- en: '![Figure 1.13 – An example of tooltips from XML comments](img/B18868_01_13.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.13 – XML 注释中的工具提示示例](img/B18868_01_13.jpg)'
- en: Figure 1.13 – An example of tooltips from XML comments
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.13 – XML 注释中的工具提示示例
- en: This is a great help when other people are trying to use your code and it is
    how Unity’s staff write their code. We can also extend this to functions and classes
    to ensure that our code is more self-documented.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当其他人试图使用你的代码时，这是一个很大的帮助，这也是 Unity 员工编写代码的方式。我们还可以将此扩展到函数和类，以确保我们的代码更具自文档化。
- en: Unfortunately, XML comments do not show up in the Inspector, and the `Tooltip`
    attribute can’t be used for some aspects of projects such as functions. With that
    in mind, I use `Tooltip` for public instructions and/or things that will show
    up in the **Inspector** window and XML comments for everything else.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，XML 注释在检查器中不会显示，并且 `Tooltip` 属性不能用于项目的一些方面，如函数。考虑到这一点，我使用 `Tooltip` 用于公共说明和/或将在
    **检查器** 窗口中显示的内容，而将 XML 注释用于其他所有内容。
- en: Note
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you’re interested in looking into XML comments more, feel free to check out
    [https://msdn.microsoft.com/en-us/library/b2s063f7.aspx](https://msdn.microsoft.com/en-us/library/b2s063f7.aspx).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要更深入地了解 XML 注释，请随时查看 [https://msdn.microsoft.com/en-us/library/b2s063f7.aspx](https://msdn.microsoft.com/en-us/library/b2s063f7.aspx)。
- en: Now that we have looked at ways of improving the formatting of our code; let’s
    look at how we can improve the performance by looking at some of the different
    `Update` functions Unity provides.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了改进代码格式的几种方法；让我们看看如何通过查看 Unity 提供的一些不同的 `Update` 函数来提高性能。
- en: Update function versus FixedUpdate function
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Update 函数与 FixedUpdate 函数
- en: The next thing to look at is our movement code. You may have noticed that we
    are currently using the `Update` function in order to move our player. As the
    comment above it states, the `Update` function is called once per frame that the
    game is running. One thing to consider is that the frequency of `Update` being
    called is variable, meaning that it can change over time. This is dependent on
    a number of factors, including the hardware that is being used. This means that
    the more times the `Update` function is called, the better the computer is. We
    want a consistent experience for all of our players, and one of the ways that
    we can do that is by using the `FixedUpdate` function.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要查看的是我们的移动代码。你可能已经注意到，我们目前正在使用 `Update` 函数来移动我们的玩家。正如上面的注释所述，`Update` 函数在游戏运行时每帧被调用一次。需要考虑的一点是，`Update`
    被调用的频率是可变的，这意味着它可能会随时间变化。这取决于许多因素，包括所使用的硬件。这意味着 `Update` 函数被调用得越多，计算机的性能就越好。我们希望所有玩家都能获得一致的经验，而我们可以通过使用
    `FixedUpdate` 函数来实现这一点。
- en: '`FixedUpdate` is similar to `Update` with some key differences. The first is
    that it is called at fixed timesteps, meaning the same time between calls. It’s
    also important to note that physics calculations are done after `FixedUpdate`
    is called. This means code-modifying physics-based objects should be executed
    within the `FixedUpdate` function generally, apart from one-off events such as
    jumping:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`FixedUpdate` 与 `Update` 类似，但有一些关键区别。首先，它是在固定时间步长被调用，这意味着调用之间的时间相同。还重要的是要注意，在调用
    `FixedUpdate` 之后才会进行物理计算。这意味着通常应该在 `FixedUpdate` 函数中执行基于物理的对象代码修改，除了像跳跃这样的单次事件：'
- en: '[PRE5]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: By adjusting the code to use `FixedUpdate`, the ball should be much more consistent
    in its movement speed.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调整代码以使用 `FixedUpdate`，球的运动速度应该更加一致。
- en: Note
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on `FixedUpdate`, check out [https://docs.unity3d.com/ScriptReference/MonoBehaviour.FixedUpdate.html](https://docs.unity3d.com/ScriptReference/MonoBehaviour.FixedUpdate.html).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 `FixedUpdate` 的信息，请查看 [https://docs.unity3d.com/ScriptReference/MonoBehaviour.FixedUpdate.html](https://docs.unity3d.com/ScriptReference/MonoBehaviour.FixedUpdate.html)。
- en: Putting it all together
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将所有内容整合在一起
- en: 'With all of the stuff we’ve been talking about, we can now have the final version
    of the script, which looks like the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了所有这些内容之后，我们现在可以拥有脚本的最终版本，其外观如下：
- en: '[PRE6]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: I hope that you also agree that this makes the code easier to understand and
    better to work with. Now, we can move on to additional features in the game!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你们也同意，这样做可以使代码更容易理解，并且更容易使用。现在，我们可以继续探讨游戏中的其他功能！
- en: Having the camera following our player
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让摄像机跟随我们的玩家
- en: 'Currently, our camera stays in the same spot while the game is going on. This
    does not work very well for this game, as the player will be moving while the
    game is going on. There are two main ways that we can move our camera. We can
    just move the camera and make it a child of the player, but that will not work
    due to the fact that the camera would have the same rotation as the ball, which
    would cause the camera to spin around constantly and likely cause dizziness and
    disorientation for the players. Due to that, we will likely want to use a script
    to move it instead. Thankfully, we can modify how our camera looks at things fairly
    easily, so let’s go ahead and fix that next:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的摄像机在游戏进行时保持同一位置。这对这个游戏来说效果不佳，因为玩家在游戏进行时会移动。我们可以通过两种主要方式移动我们的摄像机。我们可以直接移动摄像机并使其成为玩家的子对象，但这不会起作用，因为摄像机将具有与球相同的旋转，这会导致摄像机不断旋转，可能会让玩家感到头晕目眩。因此，我们可能希望使用脚本来移动它。幸运的是，我们可以相当容易地修改摄像机观察事物的方式，所以让我们继续修复它：
- en: 'Go to the Project window and create a new C# script called `CameraBehaviour`.
    From there, use the following code:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往项目窗口并创建一个新的 C# 脚本，命名为 `CameraBehaviour`。从那里，使用以下代码：
- en: '[PRE7]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This script will set the position of the object it is attached to to the position
    of a target with an offset. Afterward, it will change the rotation of the object
    to face the target. Both of the parameters are marked as `public`, so they can
    be tweaked in the **Inspector** window.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本将设置附加到其上的对象的位置为目标位置加上偏移量。之后，它将改变对象的方向以面对目标。这两个参数都被标记为 `public`，因此可以在 **检查器**
    窗口中进行调整。
- en: Save the script and dive back into the Unity Editor. Select the `CameraBehaviour`
    component to it. You may do this by dragging and dropping the script from the
    **Project** window onto the GameObject or by clicking on the **Add Component**
    button at the bottom of the **Inspector** window, typing in the name of our component,
    and then hitting *Enter* to confirm once it is highlighted.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本并返回 Unity 编辑器。选择 `CameraBehaviour` 组件。您可以通过将脚本从 **项目** 窗口拖放到 GameObject
    上，或者通过在 **检查器** 窗口的底部点击 **添加组件** 按钮来实现，输入我们组件的名称，然后点击 *Enter* 确认。
- en: 'Afterward, drag and drop the `Player` object from the **Hierarchy** window
    into the **Target** property of the script in the **Inspector** window:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，将 `Player` 对象从 **层次结构** 窗口拖放到 **检查器** 窗口中脚本的 **目标** 属性：
- en: "![Figure 1\uFEFF.14 – CameraBehaviour component setup](img/B18868_01_14.jpg)"
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.14 – CameraBehaviour 组件设置](img/B18868_01_14.jpg)'
- en: Figure 1.14 – CameraBehaviour component setup
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.14 – CameraBehaviour 组件设置
- en: 'Save the scene and play the game:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存场景并播放游戏：
- en: '![Figure 1.15 – The current state of the game](img/B18868_01_15.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.15 – 游戏当前状态](img/B18868_01_15.jpg)'
- en: Figure 1.15 – The current state of the game
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.15 – 游戏当前状态
- en: The camera now follows the player as it moves. Feel free to tweak the variables
    and see how it affects the look of the camera to get the feeling you’d like best
    for the project. After this, we can have a place for the ball to move toward,
    which we will be covering in the next section.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在摄像机跟随玩家移动。您可以随意调整变量，看看它如何影响摄像机的视觉效果，以获得您最喜欢的项目感觉。在此之后，我们可以为球设置一个移动的目标，我们将在下一节中介绍。
- en: Creating a basic tile
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建基本瓦片
- en: 'We want our game to be endless, but in order to achieve that, we will need
    to have pieces that we can spawn to build our environment; let’s do that now:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的游戏是无限的，但为了实现这一点，我们需要有可以生成来构建我们环境的部件；让我们现在就做吧：
- en: To get started, we will first need to create a single repeatable piece for our
    runner game. To do that, we’ll add some walls to the floor we already have. From
    the `Left Wall`.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始，我们首先需要为我们的跑步游戏创建一个可重复的单个部件。为此，我们将在已有的地板上添加一些墙壁。从 `Left Wall`。
- en: Change the `1`, `2`, `10`). From there, select the **Move** tool by clicking
    on the button with arrows on the tools overlay or by pressing the *W* key.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `1`、`2`、`10`）。从那里，通过点击工具覆盖层上的带有箭头的按钮或按 *W* 键来选择 **移动** 工具。
- en: Note
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A recent addition to Unity is the concept of **Overlays**, which have replaced
    the original toolbar. For more information about them and how to use them, check
    out [https://docs.unity3d.com/2022.1/Documentation/Manual/overlays.html](https://docs.unity3d.com/2022.1/Documentation/Manual/overlays.html).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 最近的添加是 **叠加层** 的概念，它已经取代了原始的工具栏。有关它们的信息以及如何使用它们，请查看 [https://docs.unity3d.com/2022.1/Documentation/Manual/overlays.html](https://docs.unity3d.com/2022.1/Documentation/Manual/overlays.html)。
- en: For more information on Unity’s built-in shortcuts, check out [https://docs.unity3d.com/Manual/UnityHotkeys.html](https://docs.unity3d.com/Manual/UnityHotkeys.html).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Unity 内置快捷键的更多信息，请查看[https://docs.unity3d.com/Manual/UnityHotkeys.html](https://docs.unity3d.com/Manual/UnityHotkeys.html)。
- en: We want this wall to match up with the floor, so hold down the *V* key to enter
    *Vertex Snap* mode. In Vertex Snap mode, we can select any of the vertices on
    a mesh and move them to the same position as another vertex on a different object.
    This is really useful for making sure that objects don’t have holes between them.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望这堵墙与地板匹配，所以按住 *V* 键进入 *顶点吸附* 模式。在顶点吸附模式下，我们可以选择网格上的任何顶点，并将其移动到另一个对象上的另一个顶点的相同位置。这对于确保物体之间没有空洞非常有用。
- en: 'With Vertex Snap mode on, select the inner edge and drag it until it hits the
    edge of the floor. Alternatively, you can set the `3`, `0.95`, `0`):'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开启顶点吸附模式的情况下，选择内边缘并拖动，直到它碰到地板的边缘。或者，你可以设置（`3`，`0.95`，`0`）：
- en: '![Figure 1.16 – Left Wall setup](img/B18868_01_16.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.16 – 左墙设置](img/B18868_01_16.jpg)'
- en: Figure 1.16 – Left Wall setup
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.16 – 左墙设置
- en: Note
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on moving objects through the scene, including more details
    on Vertex Snap mode, check out [https://docs.unity3d.com/Manual/PositioningGameObjects.html](https://docs.unity3d.com/Manual/PositioningGameObjects.html).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 关于在场景中移动对象的信息，包括更多关于顶点吸附模式的细节，请查看[https://docs.unity3d.com/Manual/PositioningGameObjects.html](https://docs.unity3d.com/Manual/PositioningGameObjects.html)。
- en: 'Then, duplicate this wall and put the other object on the other side (`-3`,
    `0.95`, `0`), naming it `Right Wall`:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，复制这个墙壁，并将另一个对象放在另一边（`-3`，`0.95`，`0`），命名为`Right Wall`：
- en: '![Figure 1.17 – Right Wall setup](img/B18868_01_17.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.17 – 右墙设置](img/B18868_01_17.jpg)'
- en: Figure 1.17 – Right Wall setup
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.17 – 右墙设置
- en: As you can see in the preceding screenshot, we now protect the player from falling
    off the left and right edges of the play area. Due to how the walls are set up,
    if we move the `Floor` object, the walls will move as well.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一张截图所示，我们现在保护玩家不会从游戏区域的左右边缘掉落。由于墙壁的设置方式，如果我们移动`Floor`对象，墙壁也会移动。
- en: Note
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For information on moving Unity’s camera or navigating to the **Scene** view,
    check out [https://docs.unity3d.com/Manual/SceneViewNavigation.html](https://docs.unity3d.com/Manual/SceneViewNavigation.html).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 关于移动 Unity 相机或导航到**场景视图**的信息，请查看[https://docs.unity3d.com/Manual/SceneViewNavigation.html](https://docs.unity3d.com/Manual/SceneViewNavigation.html)。
- en: The way this game is designed, after the ball rolls past a single tile, we will
    no longer need it to be there anymore. If we just leave it there, the game will
    get slower over time due to us having so many things in the game environment using
    memory, so it’s a good idea to remove assets we are no longer using. We also need
    to have some way to figure out when we should spawn new tiles to continue the
    path the player can take.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏设计的方式是，球滚过单个瓦片后，我们就不再需要它在那里了。如果我们只是让它留在那里，由于游戏环境中使用了这么多需要内存的东西，游戏的速度会随着时间的推移而变慢，所以移除不再使用的资源是个好主意。我们还需要有某种方法来确定何时生成新的瓦片以继续玩家可以走的路径。
- en: Now, we also want to know where this piece ends, so we’ll add an object with
    a trigger collider in it. Select `Tile End`.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们还想知道这个部分在哪里结束，所以我们将添加一个带有触发碰撞器的对象。选择`Tile End`。
- en: 'Then, we will add a `7`, `2`, `1`) to fit the size of the space the player
    can walk in. Note that there is a green box around that space showing where collisions
    can take place. Set the `0`, `1`, `10`) to reach past the end of our tile. Finally,
    check the **Is Trigger** property so that the collision engine will turn the collider
    into a trigger, which will be able to run code events when it is hit, but will
    not prevent the player from moving through it:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将添加一个（`7`，`2`，`1`）以适应玩家可以行走的区域的大小。注意，有一个绿色框围绕该空间，显示碰撞可以发生的位置。将（`0`，`1`，`10`）设置为超过瓦片的末端。最后，检查**触发器**属性，以便碰撞引擎将碰撞器转换为触发器，这样当它被击中时可以运行代码事件，但不会阻止玩家通过它：
- en: '![Figure 1.18 – Caption](img/B18868_01_18.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.18 – 标题](img/B18868_01_18.jpg)'
- en: Figure 1.18 – Caption
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.18 – 标题
- en: As I mentioned briefly before, this trigger will be used to tell the game that
    our player has finished walking over this tile. This is positioned past the tile
    due to the fact that we want to still see tiles until they pass what the camera
    can see. We’ll tell the engine to remove this tile from the game, but we will
    dive more into that later on in the chapter.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前简要提到的，这个触发器将被用来告诉游戏我们的玩家已经走过了这个方块。由于我们希望在玩家通过摄像机所能看到的范围之前仍然能看到方块，所以这个触发器被放置在方块之后。我们将告诉引擎从游戏中移除这个方块，但关于这一点我们将在本章后面详细讨论。
- en: Now that we have all of the objects created, we want to group our objects together
    as one piece that we can create duplicates of. To do this, let’s create an empty
    GameObject instance by going to `Basic Tile`. Set the `0`, `0`, `0`).
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经创建了所有对象，我们希望将我们的对象组合在一起作为一个可以创建副本的整体。为此，让我们通过访问`Basic Tile`创建一个空的GameObject实例。设置`0`、`0`、`0`）。
- en: Then, go to the **Hierarchy** window and drag and drop the **Floor**, **Tile
    End**, **Left Wall**, and **Right Wall** objects on top of it to make them children
    of the **Basic** **Tile** object.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，转到**层次结构**窗口，将**地板**、**方块末端**、**左墙**和**右墙**对象拖放到其上方，使它们成为**基本** **方块**对象的子对象。
- en: 'Currently, the camera can see the start of the tiles, so to fix that, let’s
    set the `0`, `0`, `-5`). As you can see in the following screenshot, now the entire
    tile will shift back:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，摄像机可以看到方块的开始，为了解决这个问题，让我们将`0`、`0`、`-5`）设置为。如您在下面的屏幕截图中所见，现在整个方块将移回：
- en: '![Figure 1.19 – Shifting the tile back](img/B18868_01_19.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.19 – 将方块移回](img/B18868_01_19.jpg)'
- en: Figure 1.19 – Shifting the tile back
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.19 – 将方块移回
- en: Finally, we will need to know at what position we should spawn the next piece,
    so create another empty GameObject by going to `Next Spawn Point`, and set its
    `0`, `0`, `5`).
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要知道应该在什么位置生成下一个部件，因此通过访问`Next Spawn Point`创建另一个空的GameObject，并设置其`0`、`0`、`5`）。
- en: Note
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Note that when we modify an object that has a parent, the position is relative
    to the parent, not its world position.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们修改一个有父对象的对象时，位置是相对于父对象，而不是其世界位置。
- en: 'As you can see, the spawn point position will now be on the edge of our current
    title:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，生成点位置现在将在我们当前标题的边缘：
- en: '![Figure 1.20 – Next Spawn Point position](img/B18868_01_20.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.20 – 下一个生成点位置](img/B18868_01_20.jpg)'
- en: Figure 1.20 – Next Spawn Point position
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.20 – 下一个生成点位置
- en: Now we have a single tile that is fully completed. Instead of duplicating this
    a number of times by hand, we will make use of Unity’s concept of **Prefabs**.
    Prefabs, or prefabricated objects, are blueprints of GameObjects and components
    that we can turn into files, which can be duplicated. There are other interesting
    features that Prefabs have, but we will discuss them as we make use of them.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有一个完全完成的单个方块。而不是手动多次复制它，我们将利用Unity的**预制件**概念。预制件，或预制对象，是GameObject和组件的蓝图，我们可以将其转换为文件，从而可以复制。预制件还有其他一些有趣的功能，但我们将随着使用它们来讨论它们。
- en: 'From the `Prefabs`. Then, drag and drop the **Basic Tile** object from the
    **Hierarchy** window to the **Project** window inside the **Prefabs** folder.
    If the text for the **Basic Tile** name in the **Hierarchy** window becomes blue,
    we will know that it was made correctly:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 从**预制件**。然后，将**基本方块**对象从**层次结构**窗口拖放到**预制件**文件夹内的**项目**窗口中。如果**基本方块**名称在**层次结构**窗口中的文本变为蓝色，我们将知道它已经被正确创建：
- en: '![Figure 1.21 – Basic Tile Prefab created](img/B18868_01_21.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.21 – 基本方块预制件创建](img/B18868_01_21.jpg)'
- en: Figure 1.21 – Basic Tile Prefab created
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.21 – 基本方块预制件创建
- en: We now have a tile prefab that we can create duplicates of through code to extend
    our environment.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个可以创建副本以扩展我们的环境的方块预制件。
- en: Making it endless
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使其无限
- en: 'Now that we have a foundation, let’s make it so that we can continue running
    instead of stopping after a short time by spawning copies of this basic tile in
    front of each other:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经打下基础，让我们这样设置，以便我们可以继续运行而不是在短时间内停止，通过在彼此前面生成这个基本方块的副本：
- en: To start off with, we have our prefab, so we can delete the original **Basic
    Tile** in the **Hierarchy** window by selecting it and then pressing the *Delete*
    key.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们有我们的预制件，因此我们可以通过选择它并按*删除*键来删除**基本方块**在**层次结构**窗口中的原始**基本方块**。
- en: We need to have a place to create all of these tiles and potentially manage
    information for the game, such as the player’s score. In Unity, this is typically
    referred to as a `GameManager`. From the `GameManager`.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个地方来创建所有这些地砖，并可能管理游戏的信息，例如玩家的分数。在 Unity 中，这通常被称为 `GameManager`。从 `GameManager`。
- en: 'Open the script in your IDE and use the following code:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 IDE 中打开脚本并使用以下代码：
- en: '[PRE8]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This script will spawn a number of tiles, one after another, based on the `tile`
    and `initSpawnNum` properties.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本将根据 `tile` 和 `initSpawnNum` 属性生成一系列地砖。
- en: 'Save your script and dive back into Unity. From there, create a new `empty
    GameObject` and name it `Game Controller`, optionally resetting the position if
    wanted for organizational purposes. Drag and drop it at the top of the **Hierarchy**
    window. For clarity’s sake, go ahead and reset the position if you want to. Then,
    attach the **Game Manager** script to the object and then set the **Tile** property
    by dragging and dropping the **Basic Tile** prefab from the **Project** window
    into the **Tile** slot:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的脚本并回到 Unity。从那里，创建一个新的空 GameObject 并命名为 `Game Controller`，如果需要的话，为了组织目的可以重置位置。将其拖放到
    **Hierarchy** 窗口的顶部。为了清晰起见，如果你想的话，可以重置位置。然后，将 **Game Manager** 脚本附加到对象上，并通过拖放从
    **Project** 窗口中的 **Basic Tile** 预制件到 **Tile** 槽来设置 **Tile** 属性：
- en: '![Figure 1.22 – Assigning the Tile property](img/B18868_01_22.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.22 – 分配 Tile 属性](img/B18868_01_22.jpg)'
- en: Figure 1.22 – Assigning the Tile property
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.22 – 分配 Tile 属性
- en: 'Save your scene and run the project:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的场景并运行项目：
- en: '![Figure 1.23 – The current state of the game](img/B18868_01_23.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.23 – 游戏的当前状态](img/B18868_01_23.jpg)'
- en: Figure 1.23 – The current state of the game
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.23 – 游戏的当前状态
- en: Great, but now we will need to create new objects after these, and we don’t
    want to spawn a crazy number of these at once. It’s better that once we reach
    the end of a tile, we create a new tile and remove it. We’ll work on optimizing
    this more later, but that way, we always have about the same number of tiles in
    the game at any given time.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，但现在我们将在这些之后创建新的对象，我们不想一次性创建大量的这些对象。一旦我们到达地砖的尽头，最好是创建一个新的地砖并移除它。我们稍后会进一步优化这一点，但这样，在任何给定时间内，游戏中总是有大约相同数量的地砖。
- en: 'Go into the `TileEndBehaviour`, using the following code:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入 `TileEndBehaviour`，使用以下代码：
- en: '[PRE9]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, to assign it to the prefab, we can go to the **Project** window and then
    go into the **Prefabs** folder. From there, double-click on the **Basic Tile**
    object to open up its editor. From the **Hierarchy** tab, select the **Tile End**
    object and then add a **Tile End Behaviour** component to it:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了将其分配给预制件，我们可以转到 **Project** 窗口，然后进入 **Prefabs** 文件夹。从那里，双击 **Basic Tile**
    对象以打开其编辑器。从 **Hierarchy** 选项卡，选择 **Tile End** 对象，然后向其添加一个 **Tile End Behaviour**
    组件：
- en: '![Figure 1.24 – Adding the Tile End Behaviour](img/B18868_01_24.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.24 – 添加 Tile End Behaviour](img/B18868_01_24.jpg)'
- en: Figure 1.24 – Adding the Tile End Behaviour
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.24 – 添加 Tile End Behaviour
- en: 'Click on the left arrow next to the prefab name to return to the basic scene:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击预制件名称旁边的左箭头以返回基本场景：
- en: '![Figure 1.25 – Left Arrow location](img/B18868_01_25.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.25 – 左箭头位置](img/B18868_01_25.jpg)'
- en: Figure 1.25 – Left Arrow location
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.25 – 左箭头位置
- en: Tip
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: You can also open the prefab editor by selecting a prefab object from the **Project**
    window, going to the **Inspector** tab, and clicking the **Open** **Prefab** button.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过从 **Project** 窗口选择预制件对象，转到 **Inspector** 选项卡，并点击 **Open** **Prefab** 按钮来打开预制件编辑器。
- en: 'Save your scene and play. You’ll now note that as the player continues to move,
    new tiles will spawn as you go; if you switch to the **Scene** tab while playing,
    you’ll see that as the ball passes the tiles, they will destroy themselves:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的场景并播放。现在你会注意到，随着玩家继续移动，新的地砖会随着你的移动而生成；如果你在播放时切换到 **Scene** 选项卡，你会看到球通过地砖时，它们会自行销毁：
- en: "![Fig\uFEFFure 1.26 – Tiles automatically being destroyed](img/B18868_01_26.jpg)"
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: "![图\uFEFF1.26 – 地砖自动被销毁](img/B18868_01_26.jpg)"
- en: Figure 1.26 – Tiles automatically being destroyed
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.26 – 地砖自动被销毁
- en: This will ensure that there will be tiles in front of the player to visit! But
    of course, this is just an endless straight line. In the next section, we will
    see how to make the game much more interesting.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以确保玩家面前有地砖可以访问！但当然，这只是一个无休止的直线。在下一节中，我们将看到如何使游戏变得更加有趣。
- en: Creating obstacles
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建障碍物
- en: 'It’s great that we have some basic tiles, but it’s a good idea to give the
    player something to do, or in our case, something to avoid. This will provide
    the player with some kind of challenge and a basic gameplay goal, which is avoiding
    obstacles here. In this section, you’ll learn how to customize your tiles to add
    obstacles for your player to avoid. So, let’s look at the steps:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一些基本的瓦片是很好的，但给玩家一些事情做，或者在我们的案例中，一些需要避免的事情是个好主意。这将给玩家提供某种挑战和基本的游戏目标，即避免这里的障碍物。在本节中，你将学习如何自定义你的瓦片，为玩家添加需要避免的障碍物。所以，让我们看看步骤：
- en: Just like we created a prefab for our basic tile, we will create a single obstacle
    through code. I want to make it easy to see what the obstacle will look like in
    the world and make sure that it’s not too large, so I’ll drag and drop a **Basic
    Tile** prefab back into the world.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像我们为基本瓦片创建预制体一样，我们将通过代码创建一个单独的障碍物。我想让它容易看到障碍物在世界上看起来是什么样子，并确保它不是太大，所以我将再次将**基本瓦片**预制体拖回到世界中。
- en: 'Next, we will create a cube by going to `Obstacle`. Change the `2` and position
    it above the platform at (`0`, `1`, `0.25`):'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将通过访问`Obstacle`来创建一个立方体。将`2`改为`1`，并将其放置在平台上方（`0`，`1`，`0.25`）：
- en: '![Figure 1.27 – Adding obstacles](img/B18868_01_27.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图1.27 – 添加障碍物](img/B18868_01_27.jpg)'
- en: Figure 1.27 – Adding obstacles
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.27 – 添加障碍物
- en: 'We can then play the game to see how that’ll work:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以玩游戏来查看它的工作方式：
- en: '![Figure 1.28 – Obstacles stop the player](img/B18868_01_28.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图1.28 – 障碍物阻止玩家](img/B18868_01_28.jpg)'
- en: Figure 1.28 – Obstacles stop the player
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.28 – 障碍物阻止玩家
- en: 'As you can see in the preceding screenshot, the player gets stopped, but nothing
    really happens. In this instance, we want the player to lose when they hit this
    obstacle and then restart the game; to do that, we’ll need to write a script.
    From the `ObstacleBehaviour`. We’ll use the following code:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前一个屏幕截图所示，玩家被阻止，但并没有真正发生什么。在这种情况下，我们希望玩家在碰到这个障碍物时失去游戏，然后重新开始游戏；为此，我们需要编写一个脚本。从`ObstacleBehaviour`中，我们将使用以下代码：
- en: '[PRE10]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Save the script and return to the editor, attaching the script to the `Obstacle`
    GameObject we just created.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本并返回到编辑器，将脚本附加到我们刚刚创建的`Obstacle`游戏对象。
- en: 'Save your scene and try the game:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的场景并尝试游戏：
- en: '![Figure 1.29 – Obstacles destroy the player](img/B18868_01_29.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图1.29 – 障碍物摧毁玩家](img/B18868_01_29.jpg)'
- en: Figure 1.29 – Obstacles destroy the player
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.29 – 障碍物摧毁玩家
- en: As you can see in the preceding screenshot, once we hit the obstacle, the player
    gets destroyed, and then after a few seconds, the game starts up again. You’ll
    learn how to use particle systems and other things to polish this up, but at this
    point, it’s functional, which is what we want.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个屏幕截图所示，一旦我们碰到障碍物，玩家就会被摧毁，然后几秒钟后，游戏重新开始。你将学习如何使用粒子系统和其他东西来完善它，但到目前为止，它已经可以正常工作，这正是我们想要的。
- en: 'Now that we know it works correctly, we can make it a prefab. Just as we did
    with the original tile, go ahead and drag and drop the **Obstacle** object from
    **Hierarchy** into the **Project** tab and into the **Prefabs** folder:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们知道它工作得很好，我们可以将其制作成一个预制体。就像我们最初创建瓦片一样，将**障碍物**对象从**层次结构**拖放到**项目**选项卡中的**预制体**文件夹：
- en: "![Figure 1.30 – Creating the Obstacle \uFEFFprefab](img/B18868_01_30.jpg)"
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图1.30 – 创建障碍物预制体](img/B18868_01_30.jpg)'
- en: Figure 1.30 – Creating the Obstacle prefab
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.30 – 创建障碍物预制体
- en: Next, we will remove the **Obstacle** object, as we’ll spawn it upon creating
    the tile. To do so, select the **Obstacle** object in the **Hierarchy** window
    and then press the *Delete* key.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将移除**障碍物**对象，因为我们将在创建瓦片时生成它。为此，在**层次结构**窗口中选择**障碍物**对象，然后按*删除*键。
- en: We will make markers to indicate where we would possibly like to spawn our obstacles.
    Expand the `Next Spawn Point``0`, `1`, `4`). We will then rename the object `Center`.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将制作标记来指示我们可能希望生成障碍物的地方。展开`Next Spawn Point`（`0`，`1`，`4`）。然后我们将对象重命名为`Center`。
- en: 'Afterward, to help see the objects within the **Scene** window, go to the **Inspector**
    window and click on the *gray cube* icon, and then on the **Select Icon** menu,
    select whichever of the color options you’d like (I went with blue). Upon doing
    this, you’ll see that we can see the text inside the editor if we are close to
    the object (but it won’t show up in the **Game** tab by default):'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，为了帮助在**场景**窗口中看到对象，转到**检查器**窗口，点击*灰色立方体*图标，然后在**选择图标**菜单中，选择你想要的任何颜色选项（我选择了蓝色）。完成此操作后，你会发现如果我们靠近对象，我们可以在编辑器中看到文本（但默认情况下它不会在**游戏**选项卡中显示）：
- en: '![Figure 1.31 – Creating a Center marker](img/B18868_01_31.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![图1.31 – 创建中心标记](img/B18868_01_31.jpg)'
- en: Figure 1.31 – Creating a Center marker
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.31 – 创建中心标记
- en: 'We want a way to get all of the potential spawn points we will want in case
    we decide to extend the project in the future, so we will assign a tag as a reference
    to make those objects easier to find. To do that, at the top of the `ObstacleSpawn`:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望有一种方法来获取我们将来可能需要的所有潜在生成点，以防我们决定扩展项目，因此我们将分配一个标签作为引用，以便更容易找到这些对象。为此，在`ObstacleSpawn`的顶部：
- en: '![Figure 1.32 – Creating the ObstacleSpawn tag](img/B18868_01_32.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图1.32 – 创建障碍物生成标签](img/B18868_01_32.jpg)'
- en: Figure 1.32 – Creating the ObstacleSpawn tag
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.32 – 创建障碍物生成标签
- en: 'Go back and select the **Center** object and assign the **Tag** property to
    **ObstacleSpawn**:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回并选择**中心**对象，将**标签**属性分配给**障碍物生成**：
- en: '![Figure 1.33 – Assigning the tag to the Center object](img/B18868_01_33.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![图1.33 – 为中心对象分配标签](img/B18868_01_33.jpg)'
- en: Figure 1.33 – Assigning the tag to the Center object
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.33 – 为中心对象分配标签
- en: Note
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on tags and why we’d want to use them, check out [https://docs.unity3d.com/Manual/Tags.html](https://docs.unity3d.com/Manual/Tags.html).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 有关标签及其使用原因的更多信息，请参阅[https://docs.unity3d.com/Manual/Tags.html](https://docs.unity3d.com/Manual/Tags.html)。
- en: 'Go ahead and duplicate this twice and name the others `Left` and `Right`, moving
    them two units to the left and right of the center to become other possible obstacle
    points:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续复制两次，并将其他名称分别改为`Left`和`Right`，将它们移动到中心左侧和右侧两个单位，以成为其他可能的障碍物点：
- en: '![Figure 1.34 – Creating the Left and Right markers](img/B18868_01_34.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![图1.34 – 创建左右标记](img/B18868_01_34.jpg)'
- en: Figure 1.34 – Creating the Left and Right markers
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.34 – 创建左右标记
- en: 'Note that these changes don’t affect the original prefab, by default; that’s
    why the objects are currently black text. To make this happen, select **Basic
    Tile**, and then in the **Inspector** window under the **Prefab** section, click
    on **Overrides** and select **Apply All**:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，默认情况下，这些更改不会影响原始预制件；这就是为什么对象目前显示为黑色文本。要实现这一点，请选择**基本瓦片**，然后在**检查器**窗口下的**预制件**部分，点击**覆盖**并选择**应用全部**：
- en: "![\uFEFFFigure 1.35 – Applying changes to the prefab](img/B18868_01_35.jpg)"
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图1.35 – 应用预制件更改](img/B18868_01_35.jpg)'
- en: Figure 1.35 – Applying changes to the prefab
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.35 – 应用预制件更改
- en: Now that the prefab is set up correctly, we can go ahead and remove it by selecting
    it in the **Hierarchy** window and pressing *Delete*.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在预制件设置正确后，我们可以通过在**层次**窗口中选择它并按下*Delete*键来继续移除它。
- en: 'We then need to go into the `GameManager` script and make some modifications.
    To start with, we will need to introduce some new variables:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要进入`GameManager`脚本并做一些修改。首先，我们需要引入一些新变量：
- en: '[PRE11]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first of these variables is a reference to the obstacle that we will be
    creating copies of. The second is a parameter of how many tiles should be spawned
    before spawning obstacles. This is to ensure that the player can see the obstacles
    before they need to avoid them.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量中的第一个是我们将要创建副本的障碍物的引用。第二个是生成障碍物前应该生成多少个瓦片的参数。这是为了确保玩家在需要躲避之前可以看到障碍物。
- en: 'Then, we need to modify the `SpawnNextTile` function in order to spawn obstacles
    as well:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要修改`SpawnNextTile`函数以生成障碍物：
- en: '[PRE12]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that we modified the `SpawnNextTile` function to now have a default parameter
    set to `true`, which will tell us whether we want to spawn obstacles or not. At
    the beginning of the game, we may not want the player to have to start dodging
    immediately, but we can tweak the value to increase or decrease the number we
    are using. Because it has a default value of `true`, the original version of calling
    this in the `Start` function will still work without an error, but we will be
    modifying it later on.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们修改了`SpawnNextTile`函数，现在它有一个默认参数设置为`true`，这将告诉我们是否想要生成障碍物。在游戏开始时，我们可能不希望玩家立即开始躲避，但我们可以调整这个值来增加或减少我们使用的数量。因为它有一个默认值`true`，所以在`Start`函数中调用它的原始版本仍然可以正常工作而不会出错，但稍后我们将对其进行修改。
- en: 'Here, we ask whether the value is `true` to call a function called `SpawnObstacle`,
    but that isn’t written yet. We will add that next, but first, we will be making
    use of the `List` class and we want to make sure that the compiler knows which
    `List` class we are referring to, so we need to add a `using` statement at the
    top of the file:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们询问值是否为`true`以调用名为`SpawnObstacle`的函数，但这个函数还没有编写。我们将在下一部分添加它，但首先，我们将使用`List`类，并确保编译器知道我们指的是哪个`List`类，因此需要在文件顶部添加一个`using`语句：
- en: '[PRE13]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now we can write the `SpawnObstacle` function. Add the following function to
    the script:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以编写`SpawnObstacle`函数。将以下函数添加到脚本中：
- en: '[PRE14]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Lastly, let’s update the `Start` function:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们更新`Start`函数：
- en: '[PRE15]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, as long as `i` is less than the value of `initNoObstacles`, it will not
    spawn a variable, effectively giving us a buffer of four tiles that can be adjusted
    by changing the `initNoObstacles` variable.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只要`i`小于`initNoObstacles`变量的值，就不会生成变量，实际上为我们提供了一个可以调整四个格子的缓冲区，通过更改`initNoObstacles`变量来调整。
- en: 'Save the script and go back to the Unity Editor. Then, assign the `Obstacle`
    variable of the **Game Manager (Script)** component in the **Inspector** window
    with the **Obstacle** prefab we created previously:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本并返回Unity编辑器。然后，在**检查器**窗口中将**游戏管理器（脚本）**组件的`Obstacle`变量分配为我们之前创建的**障碍物**预制件：
- en: '![Figure 1.36 – Assigning the Obstacle property](img/B18868_01_36.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![图1.36 – 分配障碍物属性](img/B18868_01_36.jpg)'
- en: Figure 1.36 – Assigning the Obstacle property
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.36 – 分配障碍物属性
- en: It’s a bit hard to see things currently due to the default light settings, so
    let’s go to the **Hierarchy** window and select the **Directional Light** object.
    A directional light acts similar to how the Sun works on Earth, shining everywhere
    from a certain position.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于默认的光照设置，目前很难看清东西，所以让我们转到**层次结构**窗口并选择**方向光**对象。方向光的作用类似于地球上的太阳，从某个位置向四面八方发光。
- en: 'With the default settings, the light is a bit too bright and the shadows are
    too dark by default, so in the `0.5` and then the `0.5`:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用默认设置时，灯光有点太亮，阴影默认太暗，所以先调整到`0.5`，然后再次调整到`0.5`：
- en: '![Figure 1.37 – Adjusting the Directional Light](img/B18868_01_37.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图1.37 – 调整方向光](img/B18868_01_37.jpg)'
- en: Figure 1.37 – Adjusting the Directional Light
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.37 – 调整方向光
- en: 'Save your scene and play the game:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的场景并玩游戏：
- en: '![Figure 1.38 – The current state of the game](img/B18868_01_38.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![图1.38 – 游戏当前状态](img/B18868_01_38.jpg)'
- en: Figure 1.38 – The current state of the game
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.38 – 游戏当前状态
- en: As you can see in the preceding screenshot, we now have a number of obstacles
    for our player to avoid!
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图所示，我们现在有了一些玩家需要避免的障碍物！
- en: Note
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on directional lights and the other lighting types that
    Unity has, check out [https://unity3d.com/learn/tutorials/topics/graphics/light-types?playlist=17102](https://unity3d.com/learn/tutorials/topics/graphics/light-types?playlist=17102).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 关于方向光和Unity拥有的其他光照类型的信息，请查看[https://unity3d.com/learn/tutorials/topics/graphics/light-types?playlist=17102](https://unity3d.com/learn/tutorials/topics/graphics/light-types?playlist=17102)。
- en: Summary
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: There you have it! A solid foundation – but just that, a foundation. However,
    that being said, we covered a lot of content in this chapter. We discussed how
    to create a new project in Unity, and we built a player that will move continuously,
    as well as take inputs to move horizontally. We then discussed how we can use
    Unity’s attributes and XML comments to improve our code quality and help us when
    working in teams. We also covered how to have a moving camera. We created a tile-based
    level design system where we created new tiles as the game continued, randomly
    spawning obstacles for the player to avoid.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是了！一个坚实的基础——但仅仅是基础。然而，话虽如此，我们在本章中讨论了大量的内容。我们讨论了如何在Unity中创建新项目，并构建了一个可以持续移动并接受水平移动输入的玩家。然后，我们讨论了如何使用Unity的属性和XML注释来提高我们的代码质量并帮助我们团队合作。我们还介绍了如何拥有移动的摄像头。我们创建了一个基于瓦片的关卡设计系统，在游戏进行中创建新的瓦片，随机生成玩家需要避免的障碍物。
- en: Throughout this book, we will explore more that we can do to improve this project
    and polish it while changing it to make for the best experience possible on mobile
    platforms. However, before we get to that, we’ll actually need to figure out how
    to deploy our projects, which is what we will be working on in the next chapter.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将探讨更多可以用来改进这个项目并使其更加完善的方法，同时将其改为在移动平台上提供最佳体验。然而，在我们到达那里之前，我们实际上需要弄清楚如何部署我们的项目，这就是我们在下一章将要工作的内容。
