- en: Appendix A. Supplementary Information on OpenGL ES 3.0
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录A. OpenGL ES 3.0补充信息
- en: 'In this appendix, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本附录中，我们将涵盖以下配方：
- en: The fixed function and programmable pipeline architecture
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 固定功能管线和可编程管线架构
- en: Software requirements for OpenGL ES 3.0 – Android ADT
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL ES 3.0的软件要求 – Android ADT
- en: Developing Hello World Triangle application on Android Studio with OpenGL ES
    3.0
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Android Studio中使用OpenGL ES 3.0开发Hello World三角形应用程序
- en: Software requirements for OpenGL ES 3.0 – iOS
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL ES 3.0的软件要求 – iOS
- en: Opening a sample project in Android and iOS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Android和iOS中打开示例项目
- en: Application of the Lambert's cosine law
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拉姆伯特余弦定律的应用
- en: Calculating cosine between two vectors
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算两个向量之间的余弦值
- en: Swizzling
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swizzling
- en: The fixed function and programmable pipeline architecture
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 固定功能管线和可编程管线架构
- en: 'Before we dive into OpenGL ES programming, it''s very important to understand
    how the underlying architecture is stacked. There are two types of OpenGL ES architectures:
    fixed and programmable pipelines. This section will provide you a simple overview
    of these architectures; this overview will also help us to grasp the technical
    jargon of computer graphics terminology.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究OpenGL ES编程之前，了解底层架构是如何堆叠的非常重要。OpenGL ES有两种类型的架构：固定管线和可编程管线。本节将为您提供一个这些架构的简单概述；这个概述也将帮助我们掌握计算机图形术语的技术术语。
- en: Fixed pipeline architecture
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 固定管线架构
- en: The following image shows the OpenGL ES 1.1 fixed function pipeline architecture.
    It also provides the sequence of events from the moment input data is sent to
    the rendering engine to output an image generated on the screen.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了OpenGL ES 1.1固定功能管线架构。它还提供了从输入数据发送到渲染引擎以在屏幕上生成图像的事件序列。
- en: '![Fixed pipeline architecture](img/5527OT_A_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![固定管线架构](img/5527OT_A_01.jpg)'
- en: The **Input** refers to the supply of raw data and drawing information required
    by the rendering engine to draw an object on the screen. For example, the preceding
    image shows three vertices, and three color data are provided to the graphics
    engine as raw data. In addition, we specified the engine that will draw this raw
    data in the form of a triangle.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入**指的是渲染引擎绘制屏幕上的对象所需的原始数据和绘图信息。例如，前面的图像显示了三个顶点，并提供了三个颜色数据作为原始数据提供给图形引擎。此外，我们还指定了将此原始数据以三角形形式绘制的引擎。'
- en: In **Per Vertex Operation**, transformations on input vertex coordinates are
    performed. Each geometrical input vertex is transformed on the basis of the camera
    view or object translation.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在**顶点操作**中，对输入顶点坐标进行变换。每个几何输入顶点基于相机视图或对象平移进行变换。
- en: More specifically, at this stage, the modeling transformation is performed to
    convert object coordinates to world space coordinates. Further, these coordinates
    are converted to eye space coordinates by view transformation. Light information
    and texture coordinates are also calculated according to these transformations
    for all vertices. The second chapter, OpenGL ES 3.0 essentials, covers all the
    technical jargon that we have used for transformation in this section under *Transformation
    with the model, view, and projection analogies* recipe.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，在这个阶段，执行建模变换以将对象坐标转换为世界空间坐标。进一步，这些坐标通过视图变换转换为视点空间坐标。对于所有顶点，根据这些变换计算光信息和纹理坐标。第二章，OpenGL
    ES 3.0基础知识，涵盖了我们在“使用模型、视图和投影类比进行变换”配方中使用的所有技术术语。
- en: 'The **Primitive** assembly takes all the transformed coordinates from the previous
    stage and arranges them as per the specified draw or the primitive type (point,
    line, triangle) information provided at the input stage. For example, we supplied
    three vertices and instructed the engine to render them as a triangle. There are
    basically three types of primitives available in OpenGL ES: point, line, and triangle
    (also the variants of line and triangle). These basic three primitives can be
    used to render any complex geometry.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**原始**装配从前一阶段的变换坐标中获取所有坐标，并根据输入阶段提供的指定绘制或原始类型（点、线、三角形）信息进行排列。例如，我们提供了三个顶点，并指示引擎将它们渲染为三角形。OpenGL
    ES中基本上有三种原始类型可用：点、线和三角形（以及线和三角形的变体）。这三种基本原始类型可以用来渲染任何复杂的几何形状。'
- en: In the **Clip**, **Viewport**, and **Culling** stages, the projection transformation
    is applied to generate clip space coordinates. In this, vertices that are outside
    the camera viewing volume are discarded. The resultant vertex coordinates are
    treated with the perspective division where normalize device coordinates are generated.
    Finally, viewport transformation is applied to normalize device coordinates to
    form screen space pixel coordinates. Faces are culled on the basis of the direction
    of the face, as specified to the graphics engine.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在**裁剪**、**视口**和**剔除**阶段，应用投影变换以生成裁剪空间坐标。在这里，位于相机视锥体外的顶点被丢弃。结果顶点坐标经过透视除法处理，生成归一化设备坐标。最后，应用视口变换将归一化设备坐标归一化，形成屏幕空间像素坐标。基于面方向（如指定给图形引擎的方向），进行面剔除。
- en: Rasterization is the process of converting transformed screen space primitives
    (point, line, and triangle) to discrete elements called fragments. The output
    of each fragment are screen coordinates and related attributes, such as color,
    texture coordinates, depth, and stencil.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 光栅化是将变换后的屏幕空间原语（点、线和三角形）转换为称为片段的离散元素的过程。每个片段的输出是屏幕坐标和相关属性，如颜色、纹理坐标、深度和模板。
- en: The fragment processing stage processes each fragment generated in the rasterization
    stage. This stage processes the fragment appearance information using the color
    or texture information.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 片段处理阶段处理光栅化阶段生成的每个片段。此阶段使用颜色或纹理信息处理片段的外观信息。
- en: 'The **per-fragment operations** stage performs some important tests before
    rendering images on screen. It consists of:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**每片段操作**阶段在屏幕上渲染图像之前执行一些重要的测试。它包括：'
- en: '**The pixel ownership test**: This is a test where pixel screen coordinates
    generated by the rasterization stage are tested to see whether they belong to
    the OpenGL ES context. For example, it may be possible that the rendering screen
    is overlaid with some text messages or obscured by other windows.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**像素所有权测试**：这是一个测试，用于检查光栅化阶段生成的像素屏幕坐标是否属于OpenGL ES上下文。例如，渲染屏幕可能被一些文本消息覆盖或被其他窗口遮挡。'
- en: '**The scissor test**: This stage ensures that fragments that are present outside
    the rectangle formed by four values of the scissor rectangle region should not
    be considered in rendering.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**剪刀测试**：此阶段确保剪刀矩形区域四个值形成的矩形外的片段在渲染时不应被考虑。'
- en: '**The stencil and depth test**: This test checks the stencil and depth value
    to see whether the fragment needs to be discarded or not. For example, if two
    primitives are obscuring each other, the primitive fragment on top is kept by
    the OpenGL ES state. However, fragments belonging to the behind one will be discarded,
    irrespective of the rendering order.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板和深度测试**：此测试检查模板和深度值，以确定片段是否需要被丢弃。例如，如果有两个原语相互遮挡，OpenGL ES状态将保留顶部的原语片段。然而，属于后面的片段将被丢弃，无论渲染顺序如何。'
- en: '**Blending**: This is a process of generating new color information, using
    the previous color specified earlier in the same color buffer location.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混合**：这是一个生成新颜色信息的过程，使用之前在同一颜色缓冲区位置指定的颜色。'
- en: '**Dithering**: This technique uses existing colors to create effects of other
    colors. For example, various shades of gray color can be produced using various
    patterns generated by white and black colors.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抖动**：这项技术使用现有颜色来创建其他颜色的效果。例如，可以使用白色和黑色生成的各种图案来产生各种灰度色调。'
- en: The programmable pipeline architecture
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 程序化管道架构
- en: Unlike the fixed function pipeline, the programmable pipeline architecture provides
    the flexibility to modify some stages of the graphics pipeline. OpenGL ES 2.0
    and 3.0 follows the programmable pipeline architecture. These stages are modified
    using special programs called shaders. The following image shows the programmable
    pipeline architecture for OpenGL ES 3.0\. The architecture for 2.0 is also similar
    to the following image, except that it does not support a special stage called
    the Transform feedback. Transform feedback is a new stage introduced in OpenGL
    ES 3.0\. This stage is responsible for capturing the processed vertex data buffer
    after the geometric shading stage. These programmable stages can be seen in the
    following figure with green boxes. Developers need to program the shader to render
    object using OpenGL ES 3.0.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 与固定功能管道不同，可编程管道架构提供了修改图形管道某些阶段的灵活性。OpenGL ES 2.0和3.0遵循可编程管道架构。这些阶段是通过称为着色器的特殊程序进行修改的。以下图像显示了OpenGL
    ES 3.0的可编程管道架构。2.0的架构也与以下图像相似，只是它不支持一个称为变换反馈的特殊阶段。变换反馈是OpenGL ES 3.0中引入的新阶段。这个阶段负责在几何着色阶段之后捕获处理过的顶点数据缓冲区。以下图像中用绿色框表示的这些可编程阶段。开发者需要编写着色器来使用OpenGL
    ES 3.0渲染对象。
- en: The programmable pipeline architecture requires at least two shaders, namely,
    the vertex shader and the fragment shader to render geometry on screen. Without
    these shaders, rendering is not possible.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 可编程管道架构需要至少两个着色器，即顶点着色器和片段着色器，以在屏幕上渲染几何图形。没有这些着色器，渲染是不可能的。
- en: 'The vertex shader is the first shader in the programmable pipeline architecture.
    Its responsibility is to perform processing on vertex coordinates to produce coordinate
    transformations. In most cases, it''s used to calculate clipped coordinates from
    the model, view, and projection information. An example of the vertex shader is
    as follows:'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶点着色器是可编程管道架构中的第一个着色器。它的职责是对顶点坐标进行处理以产生坐标变换。在大多数情况下，它用于从模型、视图和投影信息中计算裁剪坐标。以下是一个顶点着色器的示例：
- en: '[PRE0]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The fragment shader is the last shader that works on the pixel level; it uses
    the output data from the rasterization stage, which generates primitive fragments.
    This shader is responsible for calculating colors for each and every fragment
    rendering object on screen. The fragment shader is also capable of applying textures
    on the fragment shader. Here is an example of the fragment shader:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 片段着色器是最后一个在像素级别工作的着色器；它使用光栅化阶段的输出数据，该阶段生成基本片段。这个着色器负责计算屏幕上每个渲染对象的每个片段的颜色。片段着色器还能够将纹理应用于片段着色器。以下是一个片段着色器的示例：
- en: '[PRE1]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![The programmable pipeline architecture](img/5527OT_A_02.jpg)'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![可编程管道架构](img/5527OT_A_02.jpg)'
- en: The programmable pipeline architecture needs a special type of language to program
    shaders. This language is called the OpenGL ES Shading Language. In this book,
    we will use specifications of OpenGL ES Shading Language 3.0.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 可编程管道架构需要一种特殊的语言来编写着色器。这种语言被称为OpenGL ES着色语言。在这本书中，我们将使用OpenGL ES着色语言3.0的规范。
- en: Software requirements for OpenGL ES 3.0 – Android ADT
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenGL ES 3.0的软件要求 – Android ADT
- en: In the previous section, we have implemented the source code for our first simple
    program in OpenGL ES 3.0\. We will use the same program to render the output on
    the Android and iOS platforms. This section will cover all the basic requirements
    that we need to develop OpenGL ES 3.0 applications on the Android platform.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们已经实现了OpenGL ES 3.0中我们的第一个简单程序源代码。我们将使用相同的程序在Android和iOS平台上渲染输出。本节将涵盖我们在Android平台上开发OpenGL
    ES 3.0应用程序所需的所有基本要求。
- en: Android is a Linux-based operating system; therefore, most of its development
    and configuration requires UNIX-based tools. This section discusses all the prerequisites
    for OpenGL ES 3.0's development on Android.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Android是一个基于Linux的操作系统；因此，其大部分开发和配置都需要基于UNIX的工具。本节讨论了在Android上开发OpenGL ES 3.0的所有先决条件。
- en: 'Android supports the OpenGL ES application development in two ways: the Java
    framework API and **Native Development Kit** (**NDK**). The Java framework APIs
    for OpenGL ES 3.0 focuses on the Java code style of development. Therefore, if
    you are developing an application purely in Java code, you can build the OpenGL
    ES 3.0 code within the Java-based application framework. In contrast, the NDK
    uses the C/C++ language to build the OpenGL ES 3.0 application. This is more suitable
    for developers who are interested to develop OpenGL ES applications in the C/C++
    language. The additional benefit is that the same code can be used across different
    platforms, which support the C/C++ language, such as iOS, Blackberry, Windows,
    and so on. JNI works as an interface between the core Java application framework
    and the NDK C/C++ code.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Android支持两种方式开发OpenGL ES应用程序：Java框架API和**本地开发工具包**（**NDK**）。OpenGL ES 3.0的Java框架API专注于Java代码风格开发。因此，如果您完全使用Java代码开发应用程序，您可以在基于Java的应用程序框架内构建OpenGL
    ES 3.0代码。相比之下，NDK使用C/C++语言构建OpenGL ES 3.0应用程序。这对于有兴趣使用C/C++语言开发OpenGL ES应用程序的开发者来说更为合适。额外的优势是，相同的代码可以在支持C/C++语言的多个平台上使用，例如iOS、BlackBerry、Windows等。JNI作为核心Java应用程序框架和NDK
    C/C++代码之间的接口。
- en: This book focuses on the native development of the OpenGL ES application through
    NDK. We will also see the advantages of using NDK over Java framework APIs.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 本书侧重于通过NDK进行OpenGL ES应用程序的本地开发。我们还将看到使用NDK相对于Java框架API的优势。
- en: Getting ready
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For Android development, you must ensure the following prerequisites are fulfilled
    on your machine (Window/Linux/Mac) before starting the development sessions. Download
    the following packages and proceed to the next section:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始开发会话之前，您必须确保您的机器（Windows/Linux/Mac）满足以下先决条件。下载以下包，然后进入下一节：
- en: '**ADT bundle**: [https://developer.android.com/sdk/index.html](https://developer.android.com/sdk/index.html)'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ADT包**: [https://developer.android.com/sdk/index.html](https://developer.android.com/sdk/index.html)'
- en: '**Android** **NDK**: [http://developer.android.com/tools/sdk/ndk/index.html](http://developer.android.com/tools/sdk/ndk/index.html)'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Android** **NDK**: [http://developer.android.com/tools/sdk/ndk/index.html](http://developer.android.com/tools/sdk/ndk/index.html)'
- en: '**Cygwin**: [http://www.cygwin.com/install.html](http://www.cygwin.com/install.html)
    (only for Windows users)'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cygwin**: [http://www.cygwin.com/install.html](http://www.cygwin.com/install.html)
    (仅适用于Windows用户)'
- en: How to do it...
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: '**ADT bundle**: Android Developer Tools (ADT) are a combo set of the Android
    software development kit. This provides us all necessary APIs, debugger, and test
    applications to build Android apps. It contains a variety of other tools that
    help us in profiling apps and provides an emulation support to run apps on an
    emulator.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**ADT包**：Android开发者工具（ADT）是Android软件开发工具包的组合集。它为我们提供了构建Android应用程序所需的所有API、调试器和测试应用程序。它包含各种其他工具，帮助我们分析应用程序，并提供在模拟器上运行应用程序的仿真支持。'
- en: 'Download the ADT bundle according to your operating system. The downloaded
    package will be in ZIP form; unzip it. This will extract a folder with the `adt-bundle-xxxxx`
    name. The name is dependent on the operating system and its version type: 32/64
    bit.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的操作系统下载ADT包。下载的包将以ZIP格式存在；解压缩它。这将提取一个名为`adt-bundle-xxxxx`的文件夹。名称取决于操作系统及其版本类型：32/64位。
- en: 'This extracted ADT bundle contains the following important folders:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此提取的ADT包包含以下重要文件夹：
- en: '**Eclipse folder**: This folder contains the Eclipse IDE, which is an integrated
    environment to develop Android applications. This special Eclipse lets users to
    quickly set up new Android projects, add framework packages, create UI, export
    `.apk`, and provide many more features.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Eclipse文件夹**：此文件夹包含Eclipse IDE，这是一个用于开发Android应用程序的集成环境。这个特殊的Eclipse允许用户快速设置新的Android项目，添加框架包，创建UI，导出`.apk`，并提供许多其他功能。'
- en: '**SDK folder**: This folder contains tools to develop and debug your app; tools
    to support new features on the Android platform, sample apps, documentation, system
    images; and SDK dependent tools that are available when new platforms are released.
    For more information on the SDK, refer to [https://developer.android.com/sdk/exploring.html](https://developer.android.com/sdk/exploring.html).'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SDK文件夹**：此文件夹包含用于开发和调试您的应用程序的工具；支持Android平台新特性的工具，示例应用程序，文档，系统映像；以及在新平台发布时可用依赖于SDK的工具。有关SDK的更多信息，请参阅[https://developer.android.com/sdk/exploring.html](https://developer.android.com/sdk/exploring.html)。'
- en: Note
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For the sake of better project management, keep your installation in the central
    location. We have created a folder called Android and extracted the ADT bundle
    within this folder. The folder name and location can be as per your personal choice.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了更好地进行项目管理，请将您的安装保持在中央位置。我们已创建一个名为 Android 的文件夹，并将 ADT 套件提取到该文件夹中。文件夹名称和位置可以根据您的个人喜好设置。
- en: '**JDK**: Depending on the ADT''s requirements, you may need to update the Java
    Development kit. JDK contains tools to develop, debug, and monitor Java applications.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JDK**: 根据 ADT 的要求，您可能需要更新 Java 开发工具包（Java Development Kit）。JDK 包含用于开发、调试和监控
    Java 应用程序的工具。'
- en: Go to the previously mentioned URL and download the JDK. The minimum requirement
    is JDK 6.0\. However, higher versions must be workable. Download the installer
    and install it on your machine. JDK automatically contains the **Java Runtime
    Environment** (**JRE**), which contains everything required to run Java applications
    on your system. Therefore, there is no need to install any other software package.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前往之前提到的网址，下载 JDK。最低要求是 JDK 6.0。然而，更高版本也必须能够使用。下载安装程序，并在您的计算机上安装它。JDK 自动包含 **Java
    运行环境**（**JRE**），它包含在您的系统上运行 Java 应用程序所需的所有内容。因此，无需安装任何其他软件包。
- en: '**NDK**: The Native Development Kit is a toolset that helps to develop some
    parts of the Android application in the C/C++ language. It provides an interface
    between the Java and C++ code to communicate with each other. Download the latest
    NDK package and uncompress it into our Android folder.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NDK**: 本地开发工具包（Native Development Kit）是一组工具，它帮助开发者使用 C/C++ 语言开发 Android 应用程序的部分功能。它提供了一个接口，使
    Java 和 C++ 代码能够相互通信。下载最新的 NDK 软件包，并将其解压缩到我们的 Android 文件夹中。'
- en: '**Environment variables**: Make sure that you define the system environment
    variable path to locate your NDK, SDK, and platform tools. This will be helpful
    in running executables from command-line terminals. Additionally, we need to define
    `ANDROID_HOME` to locate the SDK folder in the ADT bundle. The following sample
    shows the definition of these environment variables in the `.bash_profile` file
    under the Mac operating system. Similarly, these need to be defined in other operating
    systems, according to their way of defining environment variables:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境变量**：请确保您定义了系统环境变量路径以定位您的 NDK、SDK 和平台工具。这将有助于从命令行终端运行可执行文件。此外，我们还需要定义 `ANDROID_HOME`
    以定位 ADT 套件中的 SDK 文件夹。以下示例显示了在 Mac 操作系统下 `.bash_profile` 文件中定义这些环境变量的方法。同样，这些需要在其他操作系统中根据它们定义环境变量的方式来定义：'
- en: '[PRE2]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Android SDK Manager**: In the ADT bundle folder, open Eclipse IDE and navigate
    to **Window** | **Android SDK Manager**. Install Android 4.3 and its related subcomponents,
    as shown in the following screenshot:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Android SDK 管理器**：在 ADT 套件文件夹中打开 Eclipse IDE，导航到 **窗口** | **Android SDK 管理器**。安装
    Android 4.3 及其相关子组件，如以下截图所示：'
- en: Note
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For OpenGL ES 3.0, we need Android 4.3 (the Level 18 API) or higher versions.
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于 OpenGL ES 3.0，我们需要 Android 4.3（第 18 级 API）或更高版本。
- en: '![How to do it...](img/5527OT_A_03.jpg)'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/5527OT_A_03.jpg)'
- en: '**Cygwin**: Cygwin is a UNIX-based command-line terminal application that allows
    Windows users to compile and debug Unix-based applications.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cygwin**: Cygwin 是一个基于 UNIX 的命令行终端应用程序，它允许 Windows 用户编译和调试基于 UNIX 的应用程序。'
- en: Download the `setup.exe` from the URL mentioned in the previous section and
    execute it. This will open the installation interface for the app. Click on default
    selection on each window and click on the **Next** button until the list of packages
    needed to be installed does not appear.
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从之前章节中提到的网址下载 `setup.exe` 并执行它。这将打开应用程序的安装界面。在每个窗口上点击默认选择，然后点击 **下一步** 按钮，直到不再出现需要安装的软件包列表。
- en: 'Search for make and select **Devel/make**. Similarly, search shell, select
    Shells/bash, click on next and then click on **Finish**. This will install a Cygwin
    Terminal in your Windows program list. Make a shortcut on your desktop for quick
    launch. Refer to the following screenshot for assistance:'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索 make 并选择 **Devel/make**。同样，搜索 shell，选择 Shells/bash，点击“下一步”，然后点击 **完成**。这将安装一个
    Cygwin 终端到您的 Windows 程序列表中。在桌面上创建一个快捷方式以快速启动。请参考以下截图以获取帮助：
- en: '![How to do it...](img/5527OT_A_04.jpg)'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/5527OT_A_04.jpg)'
- en: How it works...
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The Android SDK provides a beautiful modular package that contains all required
    tools that are necessary to build an Android application. SDK and platform tools
    in conjunction with the SDK platform act as a backbone of the Android application
    development. These provide services to debug, manage, and deploy Android applications.
    They manage various Android platforms and related SDK APIs. This package also
    contains a customized eclipse for Android development; it helps to build the applications
    UI quickly. IDE provides special tools (such as the Android SDK Manager) that
    allow you to install new Android platforms and many other helper tools.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Android SDK提供了一个美丽的模块化包，其中包含构建Android应用程序所需的所有工具。SDK和平台工具与SDK平台结合使用，作为Android应用程序开发的骨架。它们提供调试、管理和部署Android应用程序的服务。它们管理各种Android平台和相关SDK
    API。此包还包含一个定制的Android开发Eclipse；它有助于快速构建应用程序的用户界面。IDE提供特殊工具（如Android SDK Manager），允许您安装新的Android平台和许多其他辅助工具。
- en: Android supports the development of some portions of its application in the
    C/C++ language. This kind of development is supported through the NDK tool; this
    tool offers an interface called Java Native Interface (JNI) that helps to set
    up communication between the Java framework and native code to communicate with
    each other. NDK needs a Unix-based command-line terminal to build C/C++ libraries.
    This command-line terminal is built in under UNIX-based operating systems. On
    Windows, it's provided by the Cygwin application. Developers build the code and
    export the native code functionality through libraries (`.so`/`.dll`/`.a`). The
    Android application uses these libraries in static or uses the shared form to
    integrate it into the application.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Android支持使用C/C++语言开发其应用程序的部分功能。这种开发方式通过NDK工具得到支持；该工具提供了一个名为Java Native Interface
    (JNI)的接口，它有助于建立Java框架和本地代码之间的通信。NDK需要基于Unix的命令行终端来构建C/C++库。这种命令行终端在基于UNIX的操作系统内是内置的。在Windows上，它由Cygwin应用程序提供。开发者通过库（`.so`/`.dll`/`.a`）构建代码并导出本地代码功能。Android应用程序使用这些库以静态形式或以共享形式将其集成到应用程序中。
- en: Developing the Hello World Triangle application on Android Studio with OpenGL
    ES 3.0
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OpenGL ES 3.0在Android Studio上开发Hello World Triangle应用程序
- en: Android Studio is another new **Integrated Development Environment** (**IDE**)
    for the Android application development; the community is rapidly migrating to
    it. Unlike the other recipes in this book that are based on Android ADT, you can
    also use the Android studio to develop OpenGL ES 3.0 applications. It uses the
    Gradle build system to create scalable applications. The template-based wizard
    helps in designing common components and layouts quickly. This IDE has many other
    cool features to make the development quicker, robust, and reliable.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio是另一个用于Android应用程序开发的**集成开发环境**（**IDE**）；社区正在迅速迁移到它。与本书中基于Android
    ADT的其他食谱不同，您还可以使用Android Studio开发OpenGL ES 3.0应用程序。它使用Gradle构建系统创建可扩展的应用程序。基于模板的向导有助于快速设计常见组件和布局。这个IDE还有许多其他酷炫功能，可以使开发更快、更健壮、更可靠。
- en: 'The previous recipe, *Software requirements for OpenGL ES 3.0 – Android ADT,*
    uses the **Android development tool** (**ADT**) and Eclipse ADT plugin to build
    Android-based OpenGL ES applications. All the recipes implemented in the book
    uses the ADT-based development system to program OpenGL ES 3.0 applications. However,
    we also want to provide an option to our readers to develop their recipes using
    Android Studio. Android Studio is very easy to use and set up. Unlike the ADT,
    it provides a rich interface and built-in support for NDK build. In this recipe,
    we will reuse the Android ADT-based first recipe: `HelloWorldTriangle` and create
    a new recipe using Android Studio.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个食谱，*OpenGL ES 3.0的软件要求 – Android ADT*，使用**Android开发工具**（**ADT**）和Eclipse
    ADT插件来构建基于Android的OpenGL ES应用程序。本书中实现的所有食谱都使用基于ADT的开发系统来编程OpenGL ES 3.0应用程序。然而，我们还想为读者提供一个选项，让他们使用Android
    Studio开发自己的食谱。Android Studio非常易于使用和设置。与ADT不同，它提供了一个丰富的界面和内置的NDK构建支持。在这个食谱中，我们将重用基于Android
    ADT的第一个食谱：`HelloWorldTriangle`，并使用Android Studio创建一个新的食谱。
- en: Getting ready
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Follow these steps to get and install Android Studio:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤获取和安装Android Studio：
- en: Go to [https://developer.android.com/sdk/installing/index.html?pkg=studio](https://developer.android.com/sdk/installing/index.html?pkg=studio)
    to get the latest Android studio.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往[https://developer.android.com/sdk/installing/index.html?pkg=studio](https://developer.android.com/sdk/installing/index.html?pkg=studio)获取最新的Android
    Studio。
- en: Download the latest SDK tools and platforms using the SDK Manager at [https://developer.android.com/tools/help/sdk-manager.html](https://developer.android.com/tools/help/sdk-manager.html).
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用SDK Manager在[https://developer.android.com/tools/help/sdk-manager.html](https://developer.android.com/tools/help/sdk-manager.html)下载最新的SDK工具和平台。
- en: You can learn to install the SDK package at [https://developer.android.com/sdk/installing/adding-packages.html](https://developer.android.com/sdk/installing/adding-packages.html).
    For Android OpenGL ES 3.0, any API level greater than 18 will work completely
    fine.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以在[https://developer.android.com/sdk/installing/adding-packages.html](https://developer.android.com/sdk/installing/adding-packages.html)学习如何安装SDK包。对于Android
    OpenGL ES 3.0，任何大于18的API级别都可以完全正常工作。
- en: Read the overview of the Android Studio at [https://developer.android.com/tools/studio/index.html](https://developer.android.com/tools/studio/index.html)
    to know more about it.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有关Android Studio的概述，请参阅[https://developer.android.com/tools/studio/index.html](https://developer.android.com/tools/studio/index.html)以了解更多信息。
- en: Do not forget to set the Android SDK path; the setup will automatically ask
    you to provide the directory path for the Android SDK.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要忘记设置Android SDK路径；设置程序将自动提示您提供Android SDK的目录路径。
- en: How to do it...
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Follow the given steps to create the first Android Hello World application on
    Android Studio. I hope that after learning this, you can port the rest of the
    chapters recipe as per your need.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 按照给定的步骤在Android Studio上创建第一个Android Hello World应用程序。希望学习之后，您可以根据自己的需求将其他章节的食谱移植过来。
- en: Create a new Android application project by navigating to **New** | **New Project**.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到**新建** | **新建项目**来创建一个新的Android应用程序项目。
- en: Set **Application name** as `HelloWorldTriangle` and **Company Domain** as `cookbook.gles`,
    as shown in the following screenshot:![How to do it...](img/5527OT_A_08.jpg)
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**应用程序名称**设置为`HelloWorldTriangle`，并将**公司域名**设置为`cookbook.gles`，如图所示：![如何操作...](img/5527OT_A_08.jpg)
- en: 'Select the target platform SDK''s; we will use **API 18: Android 4.3 (Jelly
    Bean)**. Refer to the following screenshot for more information:![How to do it...](img/5527OT_A_09.jpg)'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '选择目标平台SDK；我们将使用**API 18: Android 4.3 (Jelly Bean**)。有关更多信息，请参考以下截图：![如何操作...](img/5527OT_A_09.jpg)'
- en: Create the **Blank Activity**, change **Activity Name** to `GLESActivity`, and
    click on **Finish**. This will create the project solution, as shown in the following
    screenshot:![How to do it...](img/5527OT_A_11.jpg)
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建**空白活动**，将**活动名称**更改为`GLESActivity`，然后点击**完成**。这将创建项目解决方案，如图所示：![如何操作...](img/5527OT_A_11.jpg)
- en: Select the current `java` folder or package name and select **File** | **New**
    | **Java Class**. Add two new classes called `GLESView` and `GLESNativeLib`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择当前的`java`文件夹或包名，然后选择**文件** | **新建** | **Java类**。添加两个新类，分别命名为`GLESView`和`GLESNativeLib`。
- en: Use the *Programming OpenGL ES 3.0 Hello World Triangle* recipe from [Chapter
    1](ch01.html "Chapter 1. OpenGL ES 3.0 on Android/iOS"), *OpenGL ES 3.0 on Android/iOS,*
    and copy its `JNI` folder to the `<ProjectLocation>\HelloWorldTriangle\app\src\main`
    location. This folder contains `Android.mk`, `Application.mk`, `NativeTemplate.h`,
    and `NativeTemplate.cpp`. The following screenshot shows the folder structure:![How
    to do it...](img/5527OT_A_13.jpg)
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用[第1章](ch01.html "第1章. OpenGL ES 3.0 on Android/iOS")中的*Programming OpenGL
    ES 3.0 Hello World Triangle*食谱，将其`JNI`文件夹复制到`<ProjectLocation>\HelloWorldTriangle\app\src\main`位置。此文件夹包含`Android.mk`、`Application.mk`、`NativeTemplate.h`和`NativeTemplate.cpp`。以下截图显示了文件夹结构：![如何操作...](img/5527OT_A_13.jpg)
- en: Similarly, use the *Programming OpenGL ES 3.0 Hello World Triangle* recipe from
    [Chapter 1](ch01.html "Chapter 1. OpenGL ES 3.0 on Android/iOS"), *OpenGL ES 3.0
    on Android/iOS,* and reuse the contents of `GLESActivity.java`, `GLESView.java,`
    and `GLESNativeLib.java` to the respective files of this project. Make sure that
    the package name should not be replaced because this project has different package
    name compared to the *Programming OpenGL ES 3.0 Hello World Triangle* recipe from
    [Chapter 1](ch01.html "Chapter 1. OpenGL ES 3.0 on Android/iOS"), *OpenGL ES 3.0
    in Android/iOS*. For more information, you can refer to the `HelloWorldTriangleAndroidStudio`
    example recipe provided with the sample code of this appendix.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，使用[第1章](ch01.html "第1章. OpenGL ES 3.0 on Android/iOS")中的*Programming OpenGL
    ES 3.0 Hello World Triangle*食谱，并将`GLESActivity.java`、`GLESView.java`和`GLESNativeLib.java`的内容重用到本项目的相应文件中。请确保不要替换包名，因为本项目与[第1章](ch01.html
    "第1章. OpenGL ES 3.0 on Android/iOS")中的*Programming OpenGL ES 3.0 Hello World Triangle*食谱有不同的包名。有关更多信息，您可以参考附录样本代码中提供的`HelloWorldTriangleAndroidStudio`示例食谱。
- en: 'Go to `NativeTemplate.h`/`.cpp` and correct the JNI interface declaration and
    definition. Replace the old package name with the new one. The following example
    shows the change we made in the `init()` function with respect to the new package
    name in the current recipe:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`NativeTemplate.h`/`.cpp`并修正JNI接口的声明和定义。将旧包名替换为新包名。以下示例显示了我们在当前食谱中针对新包名在`init()`函数中做出的更改：
- en: 'The original declaration is as follows:'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始声明如下：
- en: '[PRE3]'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The new declaration with the new package name is shown in the following code:'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的声明与新的包名如下所示：
- en: '[PRE4]'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Navigate to `Application.mk` and declare the build variant and version of the
    SDK to be used for compilation. The `APP_ABI` tells the NDK compiler to build
    shared libraries for every possible target. The `APP_PLATFORM` informs the compiler
    to use a specified platform for compilation. For example, as we are using API
    level 18; therefore, for OpenGL ES, the EGL and GLESv3 libraries will be referenced
    from the platform API level 18:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`Application.mk`并声明用于编译的SDK的构建变体和版本。`APP_ABI`告诉NDK编译器为每个可能的目标构建共享库。`APP_PLATFORM`通知编译器使用指定的平台进行编译。例如，因为我们使用API级别18；因此，对于OpenGL
    ES，EGL和GLESv3库将从平台API级别18引用：
- en: '[PRE5]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Go to `build.gradle` present in the `<ProjectLocation>\HelloWorldTriangle \app\build.gradle4`
    and make the following two changes:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`<ProjectLocation>\HelloWorldTriangle\app\build.gradle4`中的`build.gradle`并做出以下两个更改：
- en: '**The Module name**: This informs the native code module name to Gradle system;
    this must be the same as the module name specified in the `Android.mk`:'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块名称**：这告诉Gradle系统本地代码模块的名称；这必须与`Android.mk`中指定的模块名称相同：'
- en: '[PRE6]'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**The NDK external build**: This compiles the makefile manually using the `ndk-build`
    command as we performed this for all other Android recipes. For this, we need
    to inform the Gradle build system not to prebuild the NDK. The `jni.srcDirs` tells
    the build system not to use the `ndk-build` command from the Android Studio. The
    `jniLibs.srcDir` gives the location of the build libraries for different targets
    using the external NDK compilation:'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NDK外部构建**：这通过使用`ndk-build`命令手动编译makefile，正如我们在所有其他Android食谱中执行的那样。为此，我们需要通知Gradle构建系统不要预构建NDK。`jni.srcDirs`告诉构建系统不要使用Android
    Studio中的`ndk-build`命令。`jniLibs.srcDir`给出了使用外部NDK编译的不同目标的构建库的位置：'
- en: '[PRE7]'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Refer to the following screenshot for the two changes we made in the `build.gradle`:'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参考以下截图，了解我们在`build.gradle`中做出的两个更改：
- en: '![How to do it...](img/5527OT_A_14.jpg)'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/5527OT_A_14.jpg)'
- en: Open the command-line terminal. Navigate to the current `JNI` folder path and
    execute `ndk-build`. This command compiles source files and generates the shared
    library in the `<Project>\app\src\main\libs \<targetplatform>` folder path with
    the help of `Android.mk`.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令行终端。导航到当前`JNI`文件夹路径并执行`ndk-build`。此命令在`<Project>\app\src\main\libs\<targetplatform>`文件夹路径下编译源文件并生成共享库，这是通过`Android.mk`帮助完成的。
- en: After building the library, use Android Studio and click on the **Project Execute**
    button to view the output on the device or emulator. The following is the output
    of the Hello World Triangle:![How to do it...](img/5527OT_A_15.jpg)
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建库之后，使用Android Studio并点击**项目执行**按钮以在设备或模拟器上查看输出。以下是在Hello World三角形上的输出：![如何操作...](img/5527OT_A_15.jpg)
- en: How it works...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The working of this recipe is the same as we implemented in [Chapter 1](ch01.html
    "Chapter 1. OpenGL ES 3.0 on Android/iOS"), *OpenGL ES 3.0 on Android/iOS* except
    the fact that we will now use Android Studio to build the project. Refer to the
    *Developing the Hello World Triangle application on Android Studio with OpenGL
    ES 3.0* recipe and look for the *How it works…* section. This section will provide
    the necessary details of the working of OpenGL ES along with Android Java and
    native interfaces for the OpenGL ES 3.0 application development.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的工作原理与我们在[第1章](ch01.html "第1章. 在Android/iOS上使用OpenGL ES 3.0")中实现的方式相同，即*在Android/iOS上使用OpenGL
    ES 3.0*，除了我们现在将使用Android Studio来构建项目。请参考*使用OpenGL ES 3.0在Android Studio上开发Hello
    World三角形应用程序*食谱，并查找*工作原理…*部分。本部分将提供OpenGL ES工作所需的必要细节，以及用于OpenGL ES 3.0应用程序开发的Android
    Java和本地接口。
- en: See also
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the *Using JNI on Android to communicate with C/C++* and *Developing
    an Android OpenGL ES 3.0 application* recipes in [Chapter 1](ch01.html "Chapter 1. OpenGL
    ES 3.0 on Android/iOS"), *OpenGL ES 3.0 on Android/iOS.*
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考第1章*OpenGL ES 3.0 on Android/iOS*中的*在Android上使用JNI与C/C++通信*和*开发Android OpenGL
    ES 3.0应用程序*食谱。
- en: Software requirements for OpenGL ES 3.0 – iOS
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenGL ES 3.0 – iOS的软件要求
- en: The specifications of OpenGL ES 3.0 are fully supported by iOS 7 and later versions.
    iPhone 5s, along with Apple's A7 GPU supports OpenGL ES 3.0 and the earlier version
    of OpenGL ES 2.0 and 1.1\. Apple A7 GPU, provides the accessibility of all new
    features of OpenGL ES 3.0\. It also has a larger pool of rendering resources.
    The shaders capability in 3.0 to access texture resource is twice as compared
    to OpenGL ES 2.0.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL ES 3.0的规范在iOS 7及更高版本中得到完全支持。iPhone 5s以及苹果的A7 GPU支持OpenGL ES 3.0以及更早版本的OpenGL
    ES 2.0和1.1。苹果A7 GPU提供了OpenGL ES 3.0所有新特性的可访问性。它还具有更大的渲染资源池。3.0中的着色器能力在访问纹理资源方面是OpenGL
    ES 2.0的两倍。
- en: Getting ready
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: MAC provides the Xcode IDE for development of iOS applications, which targets
    iPhone, iPad, and iPod. The minimum requirements to support OpenGL ES 3.0 is version
    5.0; all versions of Xcode beyond 5.0 supports iOS 7 build targets. This book
    will use the Xcode 5.2 version for its sample recipes.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: MAC为iOS应用程序的开发提供了Xcode IDE，它针对iPhone、iPad和iPod。支持OpenGL ES 3.0的最低要求是版本5.0；5.0以上的所有Xcode版本都支持iOS
    7构建目标。本书将使用Xcode 5.2版本进行其示例食谱。
- en: How to do it...
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: OpenGL ES 3.0 is supported by the iOS 7 SDK on Xcode 5.0 and higher versions.
    The Xcode 5.0 version contains the iOS 7 SDK. If you are a new user, you can install
    it using your App store application. If you are using an older version of Xcode,
    you must update it to at least 5.0\. The iOS 7 SDK and higher versions support
    OpenGL ES 3.0 through iOS 7 target devices.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL ES 3.0在Xcode 5.0及更高版本上由iOS 7 SDK支持。Xcode 5.0版本包含iOS 7 SDK。如果您是新手用户，您可以通过您的App
    Store应用程序安装它。如果您正在使用较旧的Xcode版本，您必须将其更新到至少5.0版本。iOS 7 SDK及更高版本通过iOS 7目标设备支持OpenGL
    ES 3.0。
- en: How it works...
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: OpenGL ES 3.0 on the iOS7 with powerful GPU can perform sophisticated graphics
    rendering. The GPU is capable of high complex calculations in shaders for every
    pixel on the screen. OpenGL ES 3.0 is a C-based API seamlessly integrated into
    Object or C/C++. The OpenGL ES specification does not define the Windowing layer
    because the windowing mechanisms for all operating systems are very different
    from each other. Therefore, the underlying operating system is responsible for
    generating the rendering context to provide the windowing layer. In addition to
    this, the operating system must also provide a presentation layer where OpenGL
    ES can be rendered. iOS provides GLKit, which gives the presentation layer by
    providing the draw surface. GLKit was introduced in iOS 5 for the development
    of OpenGL ES. This is a 3D graphics development kit for OpenGL ES 2.0/3.0 using
    objective C/C++. This kit makes the programming job easier for the programmable
    pipeline architecture. For more information, refer to the Apple developer site
    at [https://developer.apple.com/library/ios/documentation/GLkit/Reference/GLKit_Collection/index.html](https://developer.apple.com/library/ios/documentation/GLkit/Reference/GLKit_Collection/index.html).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS7上使用具有强大GPU的OpenGL ES 3.0可以执行复杂的图形渲染。GPU能够对屏幕上每个像素的着色器进行高复杂度的计算。OpenGL ES
    3.0是一个基于C的API，无缝集成到Objective或C/C++中。OpenGL ES规范没有定义窗口层，因为所有操作系统的窗口机制彼此之间非常不同。因此，底层操作系统负责生成渲染上下文以提供窗口层。此外，操作系统还必须提供一个OpenGL
    ES可以渲染的展示层。iOS提供了GLKit，通过提供绘制表面来提供展示层。GLKit是在iOS 5中引入的，用于OpenGL ES的开发。这是一个用于OpenGL
    ES 2.0/3.0的3D图形开发工具包，使用Objective C/C++编写。这个工具包使得可编程管道架构的编程工作更加容易。更多信息，请参考Apple开发者网站[https://developer.apple.com/library/ios/documentation/GLkit/Reference/GLKit_Collection/index.html](https://developer.apple.com/library/ios/documentation/GLkit/Reference/GLKit_Collection/index.html)。
- en: There's more...
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: GLKit is developed using the C/C++ objective language. This language is only
    supported in Mac and iOS-based applications. Therefore, if we want our code to
    be portable across platforms, we need to program it in C/C++. The Objective C
    language supports the C/C++ language seamlessly within its framework.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: GLKit使用C/C++ Objective语言开发。这种语言仅在Mac和iOS应用程序中得到支持。因此，如果我们希望我们的代码能够在不同平台上移植，我们需要用C/C++来编程。Objective
    C语言在其框架中无缝支持C/C++语言。
- en: The game engines, which work beautifully across platforms, actually use their
    own platform-independent frameworks for OpenGL ES programming. These frameworks
    are similar to GLKit, or even more powerful. In our approach, we will develop
    our own engine from scratch in C/C++ in order to build an acceptable cross-platform
    3D graphics framework for Android and iOS.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在跨平台中表现良好的游戏引擎实际上使用它们自己的平台无关的框架进行OpenGL ES编程。这些框架类似于GLKit，甚至更强大。在我们的方法中，我们将从头开始使用C/C++开发自己的引擎，以便为Android和iOS构建一个可接受的跨平台3D图形框架。
- en: See also
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Apple provides special references to develop OpenGL ES applications on iOS.
    These references cover various aspects of OpenGL ES with respect to iOS. For more
    information, visit [https://developer.apple.com/library/ios/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/Introduction/Introduction.html](https://developer.apple.com/library/ios/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/Introduction/Introduction.html).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果为在iOS上开发OpenGL ES应用程序提供了特殊参考。这些参考涵盖了OpenGL ES在iOS方面的各个方面。更多信息，请访问[https://developer.apple.com/library/ios/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/Introduction/Introduction.html](https://developer.apple.com/library/ios/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/Introduction/Introduction.html)。
- en: Opening a sample project on Android ADT and iOS
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Android ADT和iOS上打开示例项目
- en: '**Opening the sample** **source for the Android platform**:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**打开Android平台的示例源代码**：'
- en: In the Eclipse ID, navigate to **New** | **Project** | **Android Project from
    Existing Code**. Click on **Next** and specify the path of the folder that contains
    `Android.xml`. Open the command-line terminal, change the directory path to the
    `JNI` folder, and execute the `ndk-build` command in the terminal. Launch application
    from Eclipse using **Run** or (*Ctrl* + *F11*) as the shortcut key.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在Eclipse ID中，导航到**新建** | **项目** | **从现有代码创建Android项目**。点击**下一步**并指定包含`Android.xml`的文件夹路径。打开命令行终端，更改目录路径到`JNI`文件夹，并在终端中执行`ndk-build`命令。使用**运行**或(*Ctrl*
    + *F11*)作为快捷键从Eclipse启动应用程序。
- en: Note
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The path of the project should be the directory name that contains `Android.xml`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 项目的路径应该是包含`Android.xml`的目录名。
- en: '**Opening the sample source for the iOS platform**:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**打开iOS平台的示例源代码**：'
- en: Open the recipe folder and locate **<Project Name>.xcodeproj**, double-click
    on to open the project in the Xcode editor. Launch the application using **Product**
    | **Run** or (*Command* + *R*).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 打开配方文件夹，找到**<项目名称>.xcodeproj**，双击以在Xcode编辑器中打开项目。使用**产品** | **运行**或(*Command*
    + *R*)启动应用程序。
- en: Application of the Lambert's cosine law
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拉姆伯特余弦定律的应用
- en: 'Let''s understand how the cosine angle is calculated mathematically in order
    to implement Lambert''s cosine law in our diffuse light shading recipe. The cosine
    angle between two vectors can be calculated using the dot product between them:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解如何从数学上计算余弦角，以便在我们的漫反射光照着色方案中实现拉姆伯特余弦定律。两个向量之间的余弦角可以通过它们之间的点积来计算：
- en: '**Dot product**:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**点积**：'
- en: Dot product between the two vectors P (ai, bj, cz) and O (di, ej, fk) can be
    defined as the product of the magnitudes of the two vector and the cosine angle
    between them.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 两个向量P (ai, bj, cz) 和 O (di, ej, fk)的点积可以定义为两个向量的模长乘积以及它们之间的余弦角。
- en: '*P.Q = |P|*|Q|*cos(θ)…………Equation 1*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*P.Q = |P|*|Q|*cos(θ)………公式1*'
- en: 'Where |P| and |Q| are magnitude of P and Q, which can be calculated as:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 其中|P|和|Q|是P和Q的模，可以计算为：
- en: '|*P| = √(a*a) +(b*b) +(c*c) and |Q| = √(d*d) +(e*e) +(f*f)*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '|*P| = √(a*a) +(b*b) +(c*c) 和 |Q| = √(d*d) +(e*e) +(f*f)*'
- en: 'Alternatively, it is the product of respective components along x, y and z
    components:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，它是x、y和z分量各自分量的乘积：
- en: '*P.Q = (ai, bj, cz) * (di, ej, fk) => (ai*di)+ (bi*ei) +(ci*fi)*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*P.Q = (ai, bj, cz) * (di, ej, fk) => (ai*di)+ (bi*ei) +(ci*fi)*'
- en: '*P.Q = (a*d)*(i*i) + (b*e)*(j*j) +(c*f)*(k*k) = ad + be + ef*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*P.Q = (a*d)*(i*i) + (b*e)*(j*j) +(c*f)*(k*k) = ad + be + ef*'
- en: '*P.Q = ad + be + ef…………Equation 2*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*P.Q = ad + be + ef………公式2*'
- en: 'Equate Equation 1 and Equation 2:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 将公式1和公式2相等：
- en: '*ad + be + ef = |P|*|Q|*cos(θ)*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*ad + be + ef = |P|*|Q|*cos(θ)*'
- en: 'If P and Q are units vectors, then Equation 1 can be deduced as:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果P和Q是单位向量，那么公式1可以推导为：
- en: '*P.Q = cos(θ)…………Equation 3*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*P.Q = cos(θ)………公式3*'
- en: 'We can also find the cosine angle by dividing |P|*|Q| both sides:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过将|P|*|Q|两边除以来找到余弦角：
- en: '*cos(θ) = ( P.Q )/( |P|*|Q| )…………Equation 4*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*cos(θ) = ( P.Q )/( |P|*|Q| )………公式4*'
- en: Calculating cosine between two vectors
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算两个向量之间的余弦
- en: 'This is an illustration of how to calculate the cosine angle between two vectors
    formed by the **0**, **20**, and **0** points on a flat *x-z* plane surface and
    the light source situated at **20**, **20**, and **40**, as shown in the following
    figure:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个如何计算由平面*x-z*平面上的**0**、**20**和**0**点形成的两个向量之间的余弦角度的示例，以及位于**20**、**20**和**40**的光源，如图所示：
- en: '![Calculating cosine between two vectors](img/5527OT_A_05.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![计算两个向量之间的余弦值](img/5527OT_A_05.jpg)'
- en: 'Calculate ON and OL vectors, as shown in the following code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 计算ON和OL向量，如下所示：
- en: '[PRE8]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The dot product between OL and ON is as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: OL和ON的点积如下：
- en: '[PRE9]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Using *Equation 1*:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*方程1*：
- en: '[PRE10]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Using *Equation 2*:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*方程2*：
- en: '[PRE11]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Equating both equations, the result is shown in the following code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 将两个方程相等，结果如下所示：
- en: '[PRE12]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, `cos(`θ`) = 0.40` implies that the `θ` is `65.90` degrees.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`cos(θ) = 0.40`意味着θ是`65.90`度。
- en: Swizzling
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swizzling
- en: 'Swizzling is a new GL shading language feature that allows you to rearrange
    components of a vector. For example:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Swizzling是GL着色语言的一个新特性，允许你重新排列向量的组件。例如：
- en: '[PRE13]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here, `vec4` is represented by the x, y, z, and w component. The result is
    as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`vec4`由x、y、z和w组件表示。结果如下：
- en: '[PRE14]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, B is equivalent to {1.0, 1.0, 2.0, 2.0}
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，B等价于{1.0, 1.0, 2.0, 2.0}
- en: Getting ready
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The component access of the vec2/3/4s data type in the shading language can
    be considered either as vector, color, or texture coordinates or an array:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 着色语言中vec2/3/4s数据类型的组件访问可以被视为向量、颜色、纹理坐标或数组：
- en: '| Form type | Components | Example: vec4(1.1, 2.2, 3.3, 4.4 ); |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 形状类型 | 组件 | 示例：vec4(1.1, 2.2, 3.3, 4.4 ); |'
- en: '| --- | --- | --- |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Vector | `{x, y, z, w}` | `float a = v.x;``float b= v.y;` |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 向量 | `{x, y, z, w}` | `float a = v.x;` `float b= v.y;` |'
- en: '| Color | `{r, g, b, a}` | `float a = v.r;``float b= v.g;` |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 颜色 | `{r, g, b, a}` | `float a = v.r;` `float b= v.g;` |'
- en: '| Texture coordinates | `{s, t, p, q}` | `float a = v.s;``float b= v.t;` |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| 纹理坐标 | `{s, t, p, q}` | `float a = v.s;` `float b= v.t;` |'
- en: '| Array | `[0, 1, 2, 3]` | `float a = v[0];``float b= v[1];` |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| 数组 | `[0, 1, 2, 3]` | `float a = v[0];` `float b= v[1];` |'
- en: How to do it...
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Swizzling is a mechanism of accessing a component directly using component
    names. For example:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Swizzling是一种通过使用组件名称直接访问组件的机制。例如：
- en: '![How to do it...](img/5527OT_A_06.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![如何做到这一点...](img/5527OT_A_06.jpg)'
- en: There's more...
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In preceding cases, swizzling occurs on the right-hand side of assignments.
    However, swizzling may occur on the left-hand side of assignments as well:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，swizzling发生在赋值的右侧。然而，swizzling也可能发生在赋值的左侧：
- en: '![There''s more...](img/5527OT_A_07.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/5527OT_A_07.jpg)'
