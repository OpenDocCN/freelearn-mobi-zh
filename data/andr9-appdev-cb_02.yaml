- en: Layouts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Defining and inflating a layout
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义和展开布局
- en: Using `RelativeLayout`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `RelativeLayout`
- en: Using `LinearLayout`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `LinearLayout`
- en: Creating tables—`TableLayout` and `GridLayout`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建表格——`TableLayout` 和 `GridLayout`
- en: '`RecyclerView` replaces `ListView`'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RecyclerView` 替代 `ListView`'
- en: Changing layout properties during runtime
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时更改布局属性
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'In Android, the user interface is defined in a **layout**. A layout can be
    declared in XML or created dynamically in code. (It''s recommended to declare
    the layout in XML rather than in code to keep the presentation layer separate
    from the implementation layer.) A layout can define an individual `ListItem`,
    a fragment, or even the entire activity. Layout files are stored in the `/res/layout`
    folder and referenced in code with the following identifier: `R.layout.<filename_without_extension>`.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 中，用户界面是在一个 **布局** 中定义的。布局可以在 XML 中声明或在代码中动态创建。（建议在 XML 中声明布局，而不是在代码中，以保持表示层与实现层的分离。）布局可以定义单个
    `ListItem`、一个片段，甚至整个活动。布局文件存储在 `/res/layout` 文件夹中，并在代码中使用以下标识符引用：`R.layout.<filename_without_extension>`。
- en: Android provides a useful variety of `Layout` classes that contain and organize
    individual elements of an activity (such as buttons, checkboxes, and other Views).
    The `ViewGroup` object is a container object that serves as the base class for
    Android's family of `Layout` classes. The Views placed in a layout form a hierarchy,
    with the topmost layout being the parent.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Android 提供了多种有用的 `Layout` 类，用于包含和组织活动（如按钮、复选框和其他视图）的各个元素。`ViewGroup` 对象是一个容器对象，作为
    Android `Layout` 类家族的基类。放置在布局中的视图形成一个层次结构，最顶层的布局是父布局。
- en: Android provides several built-in layout types designed for specific purposes,
    such as `RelativeLayout`, which allows Views to be positioned with respect to
    other elements. The `LinearLayout` can stack Views or align them horizontally,
    depending on the orientation specified. The `TableLayout` can be used for laying
    out a grid of Views. Within various layouts, we can also justify Views with `Gravity`
    and provide proportional size with `Weight` control. Layouts and `ViewGroups`
    can be nested within each other to create complex configurations. Over a dozen
    different Layout objects are provided for managing widgets, lists, tables, galleries,
    and other display formats, plus you can always derive from base classes to create
    your own custom layouts.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Android 提供了多种内置布局类型，专为特定目的设计，例如 `RelativeLayout`，它允许视图相对于其他元素定位。`LinearLayout`
    可以堆叠视图或根据指定的方向水平对齐视图。`TableLayout` 可以用于布局视图网格。在各种布局中，我们还可以使用 `Gravity` 来对齐视图，并使用
    `Weight` 控制提供比例大小。布局和 `ViewGroups` 可以嵌套在彼此内部以创建复杂的配置。提供了十几种不同的布局对象来管理小部件、列表、表格、画廊和其他显示格式，并且您还可以从基类派生来自定义布局。
- en: Google has released a new layout called `ConstraintLayout`. This layout is similar
    to `ReleativeLayout` in that Views are positioned relative to each other and to
    the parent, as well as a new element called guidelines. The focus of the layout
    is to keep the layout itself as flat as possible (deeply nested layouts can cause
    performance issues) and for a visual layout editor. Giving the best visual editing
    experience while keeping the editor in sync with the underlying class is such
    a priority for Google, that the same team develops both. `ConstraintLayout` is
    now the default layout created when using the Android Studio and is the basis
    for most of the examples in this book. (The other layouts are still available
    and are used when their layout provides the cleanest XML.) Here's the link to
    the `ConstraintLayout` class, but for the best experience, it's recommended to
    use the visual editor in Android Studio: [https://developer.android.com/reference/android/support/constraint/ConstraintLayout](https://developer.android.com/reference/android/support/constraint/ConstraintLayout).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Google 发布了一种名为 `ConstraintLayout` 的新布局。这个布局与 `RelativeLayout` 类似，因为视图是相对于彼此和父视图定位的，还有一个新元素称为指南。布局的重点是尽可能保持布局本身尽可能平坦（深度嵌套的布局可能导致性能问题）以及视觉布局编辑器。在保持编辑器与底层类同步的同时提供最佳的视觉编辑体验，这对
    Google 来说是如此重要，以至于同一个团队开发了这两个。`ConstraintLayout` 现在是使用 Android Studio 创建的默认布局，也是本书中大多数示例的基础。（其他布局仍然可用，并在它们的布局提供最干净的
    XML 时使用。）以下是 `ConstraintLayout` 类的链接，但为了获得最佳体验，建议使用 Android Studio 中的视觉编辑器：[https://developer.android.com/reference/android/support/constraint/ConstraintLayout](https://developer.android.com/reference/android/support/constraint/ConstraintLayout)。
- en: Defining and inflating a layout
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义和填充布局
- en: 'When using the Android Studio wizard to create a new project, it automatically
    creates the `res/layout/activity_main.xml` file (as shown in the following screenshot).
    It then inflates the XML file in the `onCreate()` callback with `setContentView(R.layout.activity_main)`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Android Studio向导创建新项目时，它会自动创建`res/layout/activity_main.xml`文件（如下面的截图所示）。然后，它使用`setContentView(R.layout.activity_main)`在`onCreate()`回调中填充XML文件：
- en: '![](img/b1287040-1470-4e57-99f6-72b7def8a274.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b1287040-1470-4e57-99f6-72b7def8a274.png)'
- en: For this recipe, we will create two slightly different layouts and switch between
    them with a button.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们将创建两个略有不同的布局，并通过按钮在它们之间切换。
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in Android Studio and call it `InflateLayout`. Once the
    project is created, expand the `res/layout` folder so we can edit the `activity_main.xml`
    file. Use the default Phone & Tablet settings on the Target Android devices and
    select Empty Activity on the Add an Activity to Mobile dialog.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中创建一个新项目并命名为`InflateLayout`。一旦项目创建完成，展开`res/layout`文件夹，以便我们可以编辑`activity_main.xml`文件。在`Target
    Android devices`上使用默认的`Phone & Tablet`设置，并在`Add an Activity to Mobile`对话框中选择`Empty
    Activity`。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Edit the `res/layout/activity_main.xml` file so it includes a button as defined
    here:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`res/layout/activity_main.xml`文件，使其包含以下按钮定义：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now make a copy of `activity_main.xml` and call it `activity_main2.xml`. Change
    the button so it matches the following:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将`activity_main.xml`的副本复制并命名为`activity_main2.xml`。更改按钮以匹配以下内容：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Open `MainActivity.java` and add the following two methods to handle the button
    clicks:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainActivity.java`并添加以下两个方法来处理按钮点击：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Run this application on a device or emulator to see it in action.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备或模拟器上运行此应用程序以查看其效果。
- en: How it works...
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The key here is the call to `setContentView()`, which we have come across before
    in the autogenerated `onCreate()` code. Just pass a layout ID to `setContentView()`
    and it automatically inflates the layout.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于对`setContentView()`的调用，我们之前在自动生成的`onCreate()`代码中已经遇到过。只需将布局ID传递给`setContentView()`，它就会自动填充布局。
- en: This code is meant to make the concept easy to understand but would be overkill
    for simply changing the property of a button (in this example, we could just change
    the alignment on the button click). Inflating the layout is usually needed once,
    in the `onCreate()` method, but there are times when you may want to manually
    inflate a layout, as we did here. (If you were manually handling orientation changes,
    it would be a good example.)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的目的是使概念易于理解，但仅用于更改按钮属性（在这个例子中，我们可以在按钮点击时更改对齐方式）可能过于冗余。通常，在`onCreate()`方法中只需要填充布局一次，但有时你可能需要手动填充布局，就像我们在这里做的那样。（如果你手动处理方向变化，这将是一个很好的例子。）
- en: There's more...
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'As well as identifying a layout using a resource ID, as we did here, `setContentView()` can
    also take a View as an argument, for example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像我们这里一样使用资源ID标识布局之外，`setContentView()`还可以接受一个View作为参数，例如：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: See also
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: As mentioned previously, read about *Fragments*in [Chapter 5](ca4c7951-15e6-409d-a157-dd154977ef69.xhtml),
    *Fragments*, for creating reusable screen components for your activities.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在[第5章](ca4c7951-15e6-409d-a157-dd154977ef69.xhtml)中了解有关*片段*的信息，用于为你的活动创建可重用的屏幕组件。
- en: Using RelativeLayout
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RelativeLayout
- en: As mentioned in the *Introduction* section, `RelativeLayout` allows Views to
    be position-relative to each other and the parent. `RelativeLayout` is particularly
    useful for reducing the number of nested layouts, which is very important for
    reducing memory and processing requirements.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在*简介*部分所述，`RelativeLayout`允许视图相对于彼此和父视图进行定位。`RelativeLayout`特别适用于减少嵌套布局的数量，这对于减少内存和处理需求非常重要。
- en: Getting ready
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project and call it `RelativeLayout`. Android Studio defaults to
    using a `ConstraintLayout` , which we will replace with a `RelativeLayout` for
    this example. Use the default Phone & Tablet settings on the Target Android devices and
    select Empty Activity on the Add an Activity to Mobile dialog.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新项目并命名为`RelativeLayout`。Android Studio默认使用`ConstraintLayout`，但在这个例子中，我们将用`RelativeLayout`替换它。在`Target
    Android devices`上使用默认的`Phone & Tablet`设置，并在`Add an Activity to Mobile`对话框中选择`Empty
    Activity`。
- en: How to do it...
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Open the `res/layout/activity_main.xml` file and change it as follows:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`res/layout/activity_main.xml`文件并按以下方式更改它：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Run the code, or view the layout in the Design tab
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，或在设计选项卡中查看布局
- en: How it works...
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'This is a very straightforward exercise but it demonstrates several of the
    `RelativeLayout` options: `layout_centerVertical`, `layout_centerHorizontal`,
    `layout_below`, `layout_alignParentBottom`, and so on.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常直接的练习，但它演示了`RelativeLayout`的几个选项：`layout_centerVertical`、`layout_centerHorizontal`、`layout_below`、`layout_alignParentBottom`等。
- en: 'The most commonly used `RelativeLayout` layout attributes include the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的`RelativeLayout`布局属性包括以下内容：
- en: '`layout_below`: This View should be below the View specified.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout_below`: 此视图应位于指定的视图之下。'
- en: '`layout_above`: This View should be above the View specified.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout_above`: 此视图应位于指定的视图之上。'
- en: '`layout_alignParentTop`: Align this View to the top edge of the parent.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout_alignParentTop`: 将此视图与父视图的顶部边缘对齐。'
- en: '`layout_alignParentBottom`: Align this View to the bottom edge of the parent.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout_alignParentBottom`: 将此视图与父视图的底部边缘对齐。'
- en: '`layout_alignParentLeft`: Align this View to the left edge of the parent.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout_alignParentLeft`: 将此视图与父视图的左侧边缘对齐。'
- en: '`layout_alignParentRight`: Align this View to the right edge of the parent.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout_alignParentRight`: 将此视图与父视图的右侧边缘对齐。'
- en: '`layout_centerVertical`: Center this View vertically within the parent.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout_centerVertical`: 在父元素中垂直居中此视图。'
- en: '`layout_centerHorizontal`: Center this View horizontally within the parent.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout_centerHorizontal`: 在父元素中水平居中此视图。'
- en: '`layout_center`: Center this View both horizontally and vertically within the
    parent.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout_center`: 在父元素中水平和垂直居中此视图。'
- en: For the complete list of `RelativeLayout` parameters, visit [http://developer.android.com/reference/android/widget/RelativeLayout.LayoutParams.html](http://developer.android.com/reference/android/widget/RelativeLayout.LayoutParams.html).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取`RelativeLayout`参数的完整列表，请访问[http://developer.android.com/reference/android/widget/RelativeLayout.LayoutParams.html](http://developer.android.com/reference/android/widget/RelativeLayout.LayoutParams.html)。
- en: There's more...
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In contrast to what we saw earlier, here is an example using `LinearLayout`
    just to center `TextView` (creating the same effect as the `layout_center` parameter
    of `RelativeLayout`):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前看到的相反，这里是一个使用`LinearLayout`仅用于居中`TextView`的示例（产生与`RelativeLayout`的`layout_center`参数相同的效果）：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice this layout is one level deeper than the equivalent `RelativeLayout`
    (which is `LinearLayout` nested within the parent `LinearLayout`.) Though a simple
    example, it's a good idea to avoid unnecessary nesting as it can impact performance,
    especially when a layout is being repeatedly inflated (such as `ListItem`).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此布局比等效的`RelativeLayout`（嵌套在父`LinearLayout`中的`LinearLayout`）深一级。虽然这是一个简单的示例，但避免不必要的嵌套是一个好主意，因为它可能会影响性能，尤其是在布局被反复填充时（例如`ListItem`）。
- en: See also
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The next recipe, *Using LinearLayout*, will give you an alternative layout.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个菜谱，*使用LinearLayout*，将为您提供另一种布局。
- en: See the *Optimizing layouts with the Hierarchy Viewer* recipe for more information
    on efficient layout design.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅*使用层次查看器优化布局*菜谱，以获取有关高效布局设计的更多信息。
- en: Using LinearLayout
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用LinearLayout
- en: Another common layout option is `LinearLayout`, which arranges the child Views
    in a single column or single row, depending on the orientation specified. The
    default orientation (if not specified) is vertical, which aligns the Views in
    a single column.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的布局选项是`LinearLayout`，它根据指定的方向将子视图排列成单列或单行。默认方向（如果未指定）是垂直的，它将视图对齐在单列中。
- en: '`LinearLayout` has a key feature not offered in `RelativeLayout`—the `weight`
    attribute. We can specify a `layout_weight` parameter when defining a View to
    allow the View to dynamically size based on the available space. Options include
    having a View fill all the remaining space (if a View has a higher weight), having
    multiple Views fit within the given space (if all have the same weight), or spacing
    the Views proportionally by their weight.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinearLayout`有一个`RelativeLayout`中没有的关键特性——`weight`属性。在定义视图时，我们可以指定`layout_weight`参数，以允许视图根据可用空间动态调整大小。选项包括让视图填充所有剩余空间（如果视图具有更高的权重），让多个视图适应给定空间（如果所有视图都具有相同的权重），或者按权重成比例地分配视图间距。'
- en: We will create `LinearLayout` with three `EditText` Views to demonstrate how
    the `weight` attribute can be used. For this example, we will use three `EditText`
    Views-one to enter a `To Address` parameter, another to enter `Subject`, and the
    third to enter `Message`. The `To` and `Subject` Views will be a single line each,
    with the remaining space given to the `Message` View.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建包含三个`EditText`视图的`LinearLayout`来演示如何使用`weight`属性。对于此示例，我们将使用三个`EditText`视图——一个用于输入`To
    Address`参数，另一个用于输入`Subject`，第三个用于输入`Message`。`To`和`Subject`视图将各占一行，剩余空间将分配给`Message`视图。
- en: Getting ready
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project and call it `LinearLayout`. We will replace the default
    `RelativeLayout` created in `activity_main.xml` with `LinearLayout`. Use the default Phone
    & Tablet settings on the Target Android devices and select Empty Activity on the Add
    an Activity to Mobile dialog.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的项目，并将其命名为`LinearLayout`。我们将用`LinearLayout`替换在`activity_main.xml`中创建的默认`RelativeLayout`。使用默认的“手机和平板”设置在“目标Android设备”上，并在“添加活动到移动设备”对话框中选择“空活动”。
- en: How to do it...
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Open the `res/layout/activity_main.xml` file and replace it as follows:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`res/layout/activity_main.xml`文件，并按照以下方式替换：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Run the code, or view the layout in the Design tab.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，或在“设计”选项卡中查看布局。
- en: How it works...
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'When using vertical orientation with `LinearLayout`, the child Views are created
    in a single column (stacked on top of each other). The first two Views use the
    `android:layout_height="wrap_content"` attribute, giving them a single line each.
    To specify the height, `editTextMessage` uses the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`LinearLayout`的垂直方向时，子视图将创建在单列中（堆叠在彼此之上）。前两个视图使用`android:layout_height="wrap_content"`属性，每个视图只有一行。要指定高度，`editTextMessage`使用以下方式：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When using `LinearLayout`, it tells Android to calculate the height based on
    the weight. A weight of 0 (the default if not specified) indicates the View should
    not expand. In this example, `editTextMessage` is the only View defined with a
    weight, so it alone will expand to fill any remaining space in the parent layout.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`LinearLayout`时，它告诉Android根据权重计算高度。权重为0（如果未指定则为默认值）表示视图不应扩展。在这个例子中，`editTextMessage`是唯一一个定义了权重的视图，因此它将独自扩展以填充父布局中的任何剩余空间。
- en: When using the horizontal orientation, specify `android:layout_height="0dp"`
    (along with the weight) to have Android calculate the width.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用水平方向时，指定`android:layout_height="0dp"`（连同权重）以让Android计算宽度。
- en: It might be helpful to think of the weight attribute as a percentage. In this
    case, the total weight defined is 1, so this View gets 100 percent of the remaining
    space. If we assigned a weight of 1 to another View, the total would be 2, so
    this View would get 50 percent of the space. Try adding a weight to one of the
    other Views (make sure to change the height to `0dp` as well) to see it in action.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有助于将权重属性视为百分比。在这种情况下，定义的总权重是1，因此此视图获得剩余空间的100%。如果我们给另一个视图分配权重1，总数将是2，因此此视图将获得50%的空间。尝试给其他视图之一添加权重（确保同时将高度更改为`0dp`）以查看其效果。
- en: If you added a weight to one (or both) of the other Views, did you notice the
    text position? Without specifying a value for `gravity`, the text just remains
    in the center of the View space. The `editTextMessage` View specifies `android:gravity="top"`,
    which forces the text to the top of the View.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你给其他一个（或两个）视图添加了权重，你是否注意到了文本位置？如果没有指定`gravity`的值，文本将仅保持在视图空间中心。`editTextMessage`视图指定了`android:gravity="top"`，这会将文本强制推到视图顶部。
- en: There's more...
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Multiple attribute options can be combined using bitwise `OR`. (Java uses the
    pipe character (|) for `OR`). For example, we could combine two gravity options
    to both align along the top of the parent and center within the available space:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用位运算符`OR`组合多个属性选项。（Java使用管道字符(|)表示`OR`）。例如，我们可以组合两个重力选项，使它们既沿父视图顶部对齐，又在其可用空间内居中：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It should be noted that the `layout_gravity` and `gravity` tags are not the
    same thing. Where `layout_gravity` dictates where in its parent a View should
    lie, `gravity` controls the positioning of the contents within a View, for example,
    the alignment of text on a button.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，`layout_gravity`和`gravity`标签不是同一回事。`layout_gravity`指定视图在其父视图中的位置，而`gravity`控制视图内内容的定位，例如按钮上文本的对齐方式。
- en: See also
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The previous recipe, *Using RelativeLayout*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的配方，*使用RelativeLayout*。
- en: Creating tables – TableLayout and GridLayout
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建表格 – TableLayout和GridLayout
- en: 'When you need to create a table in your UI, Android provides two convenient
    layout options: `TableLayout` (along with `TableRow`) and `GridLayout` (added
    in API 14). Both layout options can create similar-looking tables, but each using
    a different approach. With `TableLayout`, rows and columns are added dynamically
    as you build the table. With `GridLayout`, row and column sizes are defined in
    the layout definition.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要在UI中创建表格时，Android提供了两个方便的布局选项：`TableLayout`（连同`TableRow`）和`GridLayout`（在API
    14中添加）。这两个布局选项都可以创建类似外观的表格，但使用不同的方法。使用`TableLayout`时，随着你构建表格，行和列会动态添加。使用`GridLayout`时，行和列的大小在布局定义中定义。
- en: Neither layout is better, it's just a matter of using the best layout for your
    needs. We'll create a 3 x 3 grid using each layout to give a comparison, as you
    could easily find yourself using both layouts, even within the same application.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 两种布局都没有更好，这只是使用最适合您需求的最佳布局。我们将使用每种布局创建一个 3 x 3 网格以进行比较，因为您可能会很容易地在同一应用程序中使用这两种布局。
- en: Getting ready
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To stay focused on the layouts and offer an easier comparison, we will create
    two separate applications for this recipe. Create two new Android projects, the
    first called `TableLayout` and the other called `GridLayout`.  Use the default Phone
    & Tablet settings on the Target Android devices and select Empty Activity on the Add
    an Activity to Mobile dialog.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了专注于布局并提供更易于比较的体验，我们将为这个食谱创建两个独立的应用程序。创建两个新的 Android 项目，第一个称为 `TableLayout`，另一个称为
    `GridLayout`。在 `Target Android devices` 上使用默认的 `Phone & Tablet` 设置，并在 `Add an
    Activity to Mobile` 对话框中选择 `Empty Activity`。
- en: How to do it...
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Starting with the `TableLayout` project, open `activity_main.xml`. Change the
    root layout to `TableLayout`.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `TableLayout` 项目开始，打开 `activity_main.xml`。将根布局更改为 `TableLayout`。
- en: 'Add three `TableRow` objects with three sets of `TextView` objects to each
    `TableRow` to create a 3 x 3 matrix. For demonstration purposes, the columns are
    labeled A-C and the rows 1-3, so the first row of `TextView` objects will be A1,
    B1, and C1\. The final result will look like this:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向每个 `TableRow` 添加三个 `TextView` 对象的三个集合，以创建一个 3 x 3 矩阵。为了演示目的，列被标记为 A-C，行标记为
    1-3，因此 `TextView` 对象的第一行将是 A1、B1 和 C1。最终结果将如下所示：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, open the `GridLayout` project to edit `activity_main.xml`. Change the root
    layout to `GridLayout`. Add the `columnCount=3` and `rowCount=3` attributes to
    the `GridLayout` element.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开 `GridLayout` 项目以编辑 `activity_main.xml`。将根布局更改为 `GridLayout`。向 `GridLayout`
    元素添加 `columnCount=3` 和 `rowCount=3` 属性。
- en: 'Now, add nine `TextView` objects to `GridLayout`. We will use the same text
    as the preceding `TableLayout` for a consistent comparison. Since `GridView` does
    not use `TableRow` objects, the first three `TextView` objects are in row 1, the
    next three are in row 2, and so on. The final result will look like this:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，向 `GridLayout` 添加九个 `TextView` 对象。我们将使用与前面的 `TableLayout` 相同的文本，以便进行一致的比较。由于
    `GridView` 不使用 `TableRow` 对象，前三个 `TextView` 对象位于第 1 行，接下来的三个位于第 2 行，以此类推。最终结果将如下所示：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can either run the application or use the Design tab to see the results.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以运行应用程序或使用设计选项卡来查看结果。
- en: How it works...
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As you can see when viewing the tables created, the tables basically look the
    same on screen. The main difference is the code to create them.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在查看创建的表格时所见，表格在屏幕上基本上看起来相同。主要区别在于创建它们的代码。
- en: In the `TableLayout` XML, each row is added to the table using `TableRow`. Each
    View becomes a column. This is not a requirement as cells can be skipped or left
    empty. (See how to specify the cell location in `TableRow` in the following section.)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `TableLayout` XML 中，每个行都是通过 `TableRow` 添加到表格中的。每个视图成为一个列。这不是一个要求，因为单元格可以省略或留空。（参见下一节中如何指定
    `TableRow` 中的单元格位置。）
- en: '`GridLayout` uses the opposite approach. The number of rows and columns are
    specified when creating the table. We don''t have to specify the row or column
    information (though we can, as discussed later). Android will automatically add
    each View to the cells in order.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`GridLayout` 使用相反的方法。在创建表格时指定行数和列数。我们不需要指定行或列信息（尽管我们可以，如后文所述）。Android 将自动按顺序将每个视图添加到单元格中。'
- en: There's more...
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'First, let''s see more similarities between the layouts. Both layouts have
    the ability to stretch columns to use the remaining screen space. For `TableLayout`,
    add the following attribute to the XML declaration:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看布局之间的更多相似之处。两种布局都具有拉伸列以使用剩余屏幕空间的能力。对于 `TableLayout`，在 XML 声明中添加以下属性：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `stretchColumns` attribute specifies the (zero-based) index of the columns
    to stretch (`android:shrinkColumns` is a zero-based index of columns that can
    shrink, so the table can fit the screen).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`stretchColumns` 属性指定要拉伸的列的（零基）索引（`android:shrinkColumns` 是可以收缩的列的零基索引，因此表格可以适应屏幕）。'
- en: 'To achieve the same effect with `GridLayout`, add the following attribute to
    all the Views in the B column (`textView2`, `textView5`, and `textView8`):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `GridLayout` 实现相同的效果，向 B 列中的所有视图（`textView2`、`textView5` 和 `textView8`）添加以下属性：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: All cells in a given column must define the weight or it will not stretch.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 给定列中的所有单元格都必须定义权重，否则将不会拉伸。
- en: Now, let's look at some of the differences, as this is really the key to determining
    which layout to use for a given task. The first item to note is how the columns
    and rows are actually defined. In `TableLayout`, the rows are specifically defined,
    using `TableRow`. (Android will determine the number of columns in the table based
    on the row with the most cells.) Use the `android:layoutColumn` attribute when
    defining the View to specify the column.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一些差异，因为这确实是确定给定任务使用哪种布局的关键。首先要注意的是列和行是如何实际定义的。在 `TableLayout` 中，行是专门定义的，使用
    `TableRow`。 （Android 将根据具有最多单元格的行来确定表格中的列数。）在定义视图时使用 `android:layoutColumn` 属性来指定列。
- en: In contrast, with `GridLayout`, the row and column counts are specified when
    defining the table (using `columnCount` and `rowCount` as shown previously).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`GridLayout` 在定义表格时（使用前面显示的 `columnCount` 和 `rowCount`）指定行和列的数量。
- en: 'In the preceding example, we just added `TextView` objects to `GridLayout`
    and let the system position them automatically. We can alter this behavior by
    specifying the row and column position when defining the View, such as the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们只是向 `GridLayout` 添加了 `TextView` 对象，并让系统自动定位它们。我们可以通过在定义视图时指定行和列位置来改变这种行为，如下所示：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Android automatically increments the cell counter after adding each View, so
    the *next *View should also specify the row and column, otherwise, you may not
    get the intended result.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Android 在添加每个视图后自动增加单元格计数器，因此下一个视图也应该指定行和列，否则，你可能不会得到预期的结果。
- en: Like `LinearLayout`, shown in the *Using LinearLayout* recipe, `GridLayout`
    also offers the orientation attribute of supporting both horizontal (the default)
    and vertical. The orientation determines how the cells are placed. (Horizontal
    fills the columns first, then moves down to the next row. Vertical fills the first
    column on each row, then moves to the next column.)
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 与在 *使用 `LinearLayout`* 烹饪法中展示的 `LinearLayout` 一样，`GridLayout` 也提供了支持水平（默认）和垂直（*Using
    GridLayout*）方向的定位属性。方向决定了单元格的放置方式。（水平首先填充列，然后移动到下一行。垂直首先填充每行的第一列，然后移动到下一列。）
- en: RecyclerView replaces ListView
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`RecyclerView` 替代 `ListView`'
- en: As the name implies, `ListView` is designed for displaying lists of information. 
    If you have prior experience on Android, you’ve probably come across the `ListView`
    and possibly `GridView` controls before. If not while coding, most likely you’ve
    used it as an app, as it’s one of the most commonly used controls available. For
    most applications and users, the old `ListView` was probably sufficient and didn’t
    pose any problems. As an example, most users could probably see their list of
    emails in their inbox without any problems.  But for some, they might have so
    many emails in their inbox that when scrolling through their list, their device
    would stutter (slight pauses when scrolling). Unfortunately, `ListView` has many
    such performance problems.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，`ListView` 是为显示信息列表而设计的。如果你在 Android 上有先前的经验，你可能之前已经遇到过 `ListView` 和可能
    `GridView` 控件。如果不是在编码时，你很可能已经作为应用程序使用过它，因为它是可用控件中最常用的之一。对于大多数应用程序和用户来说，旧的 `ListView`
    可能已经足够，并且没有引起任何问题。例如，大多数用户可能能够在他们的收件箱中无任何问题地看到他们的电子邮件列表。但对于一些人来说，他们收件箱中的电子邮件可能如此之多，以至于在滚动列表时，他们的设备会卡顿（滚动时的轻微暂停）。不幸的是，`ListView`
    有许多这样的性能问题。
- en: The most significant performance issue with `ListView` is caused by creating
    new item objects for each item when scrolling. Though much of the performance
    problem could be eliminated with a properly implemented data adapter, the implementation
    was optional. As the name implies, `RecyclerView` is based on recycling the list
    items (the part that was optional in the `ListView` adapter). There are other
    changes to the control as well. Whereas `ListView` has many features built-in,
    `RecyclerView` is very basic and relies on additional helper classes to achieve
    the same functionality. For some, this feels like a step backward with the new
    control but this design allows it to be expanded much easier.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListView` 的最显著性能问题是由在滚动时为每个项目创建新项目对象引起的。尽管通过正确实现数据适配器可以消除大部分性能问题，但实现是可选的。正如其名所示，`RecyclerView`
    基于回收列表项（在 `ListView` 适配器中是可选的部分）。控制还有其他变化。`ListView` 有许多内置功能，而 `RecyclerView`
    非常基础，依赖于额外的辅助类来实现相同的功能。对于一些人来说，这感觉像是新控制的一个倒退，但这种设计使得它更容易扩展。'
- en: Where `RecylerView` really shines is with the flexibility when extending it
    and animations. Our example here uses a static list so it doesn’t show off the
    built-in animations, but with dynamic data, your list will take advantage of the
    Material Design look and feel. Though `ListView` is not officially deprecated,
    it is recommended to use `RecyclerView` for new projects.  It’s a bit more work
    to get started, but this recipe will give you all the code to get set up.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`RecyclerView` 真正发光的地方在于其扩展性和动画的灵活性。我们这里的示例使用了一个静态列表，因此没有展示内置的动画，但使用动态数据时，你的列表将利用到
    Material Design 的外观和感觉。尽管 `ListView` 并未官方弃用，但推荐对于新项目使用 `RecyclerView`。开始时可能需要做更多的工作，但这个食谱将为你提供所有设置所需的代码。'
- en: Getting ready
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in Android Studio called `RecyclerView`.  Use the default
    Phone & Tablet settings on the Target Android devices and select Empty Activity on
    the Add an Activity to Mobile dialog.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建一个名为 `RecyclerView` 的新项目。在 `Target Android devices` 上使用默认的
    Phone & Tablet 设置，并在“Add an Activity to Mobile”对话框中选择 Empty Activity。
- en: How to do it...
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Creating `RecyclerView` is as simple as placing the control on the screen. 
    Most of the work is with the adapter, which we''ll create from a static list.
    `RecyclerView` is distributed in a separate library so it needs to be added to
    the project as a dependency.  The steps are as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `RecyclerView` 与在屏幕上放置控件一样简单。大部分工作都与适配器有关，我们将从一个静态列表创建适配器。`RecyclerView`
    是作为一个单独的库分发的，因此需要将其作为依赖项添加到项目中。步骤如下：
- en: 'Either add the dependency through the Android Studio UI or add the following
    code to the `dependencies` section of the `build.gradle (Module: app)` file:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '你可以通过 Android Studio UI 添加依赖项，或者将以下代码添加到 `build.gradle (Module: app)` 文件的 `dependencies`
    部分中：'
- en: '`implementation ''com.android.support:recyclerview-v7:27.1`'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`实现 ''com.android.support:recyclerview-v7:27.1''`'
- en: 'NOTE: v7:27.1 is current at the time of this writing, but should be updated
    to the latest version.  (The IDE will likely give you a warning if you''re not
    using the latest version.)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：v7:27.1 在撰写本文时是当前的版本，但应更新到最新版本。（如果你的 IDE 没有使用最新版本，可能会给出警告。）
- en: 'Open `activity_main.xml` and replace the existing `<TextView />` block with
    the following `RecyclerView` widget:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `activity_main.xml` 并将现有的 `<TextView />` 块替换为以下 `RecyclerView` 小部件：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We need another layout for the adapter to create the individual items in the
    list. To do this, create a new file in the `res\layout` folder called `item.xml`
    as follows:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为适配器创建列表中的单个项的另一个布局。为此，在 `res\layout` 文件夹中创建一个名为 `item.xml` 的新文件，如下所示：
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now comes the heart of `RecyclerView` – the adapter. Create a new Java file
    called `MyAdapter.java`. Our new class will extend from the `RecylerView.Adapter`
    class so there are several key methods we need to override. We’ll discuss the
    details of this class later, but the full code is as follows:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，来到 `RecyclerView` 的核心——适配器。创建一个名为 `MyAdapter.java` 的新 Java 文件。我们的新类将扩展 `RecyclerView.Adapter`
    类，因此我们需要重写几个关键方法。我们将在稍后讨论这个类的细节，但完整的代码如下：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With all the pieces set up, the final step is to put it all together. Open
    the `MainActivity.java` file and add the following code to the existing `onCreate()`
    method:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在所有组件设置完毕后，最后一步是将它们全部组合起来。打开 `MainActivity.java` 文件，并将以下代码添加到现有的 `onCreate()`
    方法中：
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works…
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We’ve purposely kept this recipe basic, but as you can see, there are still
    many steps even for this basic implementation.  The good news is, with this foundation
    set, you can easily expand and modify `RecyclerView` as needed. Want your list
    to scroll sideways instead?  You can easily accomplish this by using `LinearLayoutManager.HORIZONTAL`
    in the `setOrientation()` call.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意保持这个食谱的基础性，但正如你所见，即使是这个基本实现也有许多步骤。好消息是，有了这个基础，你可以轻松地根据需要扩展和修改 `RecyclerView`。想要你的列表水平滚动吗？你可以通过在
    `setOrientation()` 调用中使用 `LinearLayoutManager.HORIZONTAL` 实现这一点。
- en: 'If you have ever worked with Android `ListView` before, then the preceding
    steps will look very familiar.  The concept is the same: we create an adapter
    to hold a list of items.  Steps 1 and 2 set up `RecyclerView` on the activity.
    In step 3,  we specify the visual layout and pass it to the adapter. In step 4,
    we created the adapter by extending the `RecycerView.Adapter` class.  As you can
    see from the code, there are three methods we need to override: `onCreateViewHolder()`,
     `onBindViewHolder()`, and `getItemCount()`.  The key concept behind `RecylerView`
    is to recycle or reuse the item Views.  This means, when you have a very large
    list of items, instead of creating a new view object for each item (which is very
    costly in terms of performance and memory usage), the item Views are reused. 
    So as a user scrolls through a long list, as a view goes off the screen, it''s
    reused for the next item being shown.  Even if we added all the countries in the
    world to our list, there wouldn''t be enough items to see the performance difference,
    but when you’re working with a list of thousands of items, especially if those
    items include images, the performance when scrolling will be noticeable.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前曾经使用过Android `ListView`，那么前面的步骤看起来会非常熟悉。概念是相同的：我们创建一个适配器来持有项目列表。步骤1和2在活动中设置了`RecyclerView`。在步骤3中，我们指定了视觉布局并将其传递给适配器。在步骤4中，我们通过扩展`RecyclerView.Adapter`类创建了适配器。从代码中可以看出，我们需要重写三个方法：`onCreateViewHolder()`、`onBindViewHolder()`和`getItemCount()`。`RecyclerView`背后的关键概念是回收或重用项目视图。这意味着，当你有一个非常大的项目列表时，你不需要为每个项目创建一个新的视图对象（这在性能和内存使用方面成本很高），而是重用项目视图。所以当用户滚动浏览长列表时，当一个视图离开屏幕，它将被重用于下一个显示的项目。即使我们把我们列表中的所有国家都添加进去，也不会有足够的项目来看到性能差异，但当你处理包含数千个项目的列表时，尤其是如果这些项目包括图片，滚动时的性能差异将是明显的。
- en: Now that you understand the concept behind `RecyclerView`, hopefully the methods
    we need to override are self-explanatory.  The adapter only calls `onCreateViewHolder()`
    to create enough items to show on the screen (plus a few extra for scrolling),
    whereas `onBindViewHolder()` is called for each item as it’s displayed.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了`RecyclerView`背后的概念，希望我们需要的重写方法都是不言自明的。适配器只调用`onCreateViewHolder()`来创建足够多的项目以显示在屏幕上（以及一些额外的项目用于滚动），而`onBindViewHolder()`则会在每个项目显示时被调用。
- en: There’s more…
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If you ran the code, then you saw it’s a very simple app. In fact, it doesn’t
    do anything more than just display the list in a scrollable container. Most apps
    will require some interaction with the list so how do we respond to click events?
    Unlike the older `ListView`, `RecyclerView` does not have any click events built-in.
    It's up to you, the programmer, to create the events you need. (For basic items
    like in our example, this may seem like more work for the programmer, but when
    you get to complex list items with buttons and other interactive controls, `ListView`
    would often get in your way and you’d need to implement custom events anyway.)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行了代码，那么你看到它是一个非常简单的应用。实际上，它并没有做任何比在可滚动的容器中显示列表更多的事情。大多数应用都需要与列表进行一些交互，那么我们如何响应点击事件？与较老的`ListView`不同，`RecyclerView`没有内置任何点击事件。这取决于你，程序员，来创建你需要的事件。（对于像我们例子中的基本项目，这可能看起来对程序员来说工作量更大，但当你处理带有按钮和其他交互控件复杂列表项时，`ListView`经常会阻碍你，你仍然需要实现自定义事件。）
- en: 'To respond to item clicks, add the following code to the `MyAdapter` class:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要响应项目点击，请将以下代码添加到`MyAdapter`类中：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then add the following code to the `onBindViewHolder()` method created in step
    4:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在步骤4中创建的`onBindViewHolder()`方法中添加以下代码：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, when you run the code, the app will respond to the click event by removing
    the clicked item.  You may also notice the smooth animation when removing the
    item.  By calling the `notifyItemRemoved()` and `notifyItemInserted()` methods
    of `RecyclerView`, we can take advantage of the widget’s built-in Material Design
    animations.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你运行代码时，应用将响应点击事件，通过移除被点击的项目。你也许还会注意到移除项目时的平滑动画。通过调用`RecyclerView`的`notifyItemRemoved()`和`notifyItemInserted()`方法，我们可以利用小部件内置的Material
    Design动画。
- en: Changing layout properties during runtime
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在运行时更改布局属性
- en: In Android development, it's generally the preferred practice to define the
    UI with XML and the application code in Java, keeping the user interface code
    separate from the application code. There are times where it is much easier or
    more efficient, to alter (or even build) the UI from the Java code. Fortunately,
    this is easily supported in Android.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android开发中，通常首选的做法是用XML定义UI，用Java定义应用程序代码，将用户界面代码与应用程序代码分开。有时，从Java代码中更改（甚至构建）UI要容易得多或更高效。幸运的是，这在Android中很容易实现。
- en: In this recipe, we will obtain a reference to the `LayoutParams` object to change
    the margin during runtime.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将获取`LayoutParams`对象的引用，以便在运行时更改边距。
- en: Getting ready
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Here, we will set up a simple layout with XML and use a `LinearLayout.LayoutParams`
    object to change the margins of a View during runtime.  Create a new project using
    with an Empty Activity called `RuntimeProperties`. Use the default Phone & Tablet settings
    on the Target Android devices and select Empty Activity on the Add an Activity
    to Mobile dialog.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用XML设置一个简单的布局，并使用`LinearLayout.LayoutParams`对象在运行时更改视图的边距。使用带有名为`RuntimeProperties`的空活动的项目。在`目标Android设备`上使用默认的`手机和平板`设置，并在`添加活动到移动设备`对话框中选择`空活动`。
- en: How to do it...
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'We can create or manipulate any of the standard layouts or controls through
    code. For this example, we will work with `LinearLayout`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过代码创建或操作任何标准布局或控件。在这个例子中，我们将使用`LinearLayout`：
- en: 'Open the `activity_main.xml` file and change the layout as follows:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`activity_main.xml`文件，并按如下方式更改布局：
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add `TextView` with an ID value of `textView`, as follows:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个ID值为`textView`的`TextView`，如下所示：
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add `Button` with an ID value of `button`, as follows:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个ID值为`button`的`Button`，如下所示：
- en: '[PRE22]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Open `MainActivity.java` and add the following code to the `onCreate()` method
    to respond to the button click:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainActivity.java`文件，并在`onCreate()`方法中添加以下代码以响应用户点击：
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Run the program on a device or emulator.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备或模拟器上运行程序。
- en: How it works...
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Every View (and therefore `ViewGroup`) has a set of layout parameters associated
    with it. In particular, all Views have parameters to inform their parent of their
    desired height and width. These are defined with the `layout_height` and `layout_width`
    parameters. We can access this layout information from the code with the `getLayoutParams()`
    method. The layout information includes the layout height, width, margins, and
    any class-specific parameters.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 每个视图（以及因此`ViewGroup`）都有一组与之关联的布局参数。特别是，所有视图都有参数来通知其父视图它们期望的高度和宽度。这些参数由`layout_height`和`layout_width`参数定义。我们可以通过`getLayoutParams()`方法从代码中访问这些布局信息。布局信息包括布局高度、宽度、边距以及任何类特定的参数。
- en: In this example, we moved the button on each click by obtaining the current
    button `LayoutParams` and increasing the margin.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们通过获取当前按钮的`LayoutParams`并增加边距来在每次点击时移动按钮。
