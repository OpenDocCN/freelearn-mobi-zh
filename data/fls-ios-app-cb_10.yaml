- en: Chapter 10. Camera and Microphone Support
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章。相机和麦克风支持
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍：
- en: Saving to the camera roll
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存到相机胶卷
- en: Reading from the camera roll
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从相机胶卷读取
- en: Capturing with the default camera app
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用默认相机应用进行捕获
- en: Working with the built-in cameras
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内置相机
- en: Recording microphone audio
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 录制麦克风音频
- en: Playing recorded audio
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放录制的音频
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: The camera and microphone are possibly the two most popular sensors built into
    iOS devices. In fact, iPhone owners rely on the microphone on a daily basis when
    making calls. Those who use Apple's FaceTime depend on both the microphone and
    the camera to keep in touch. And of course, everyone has taken a photo or shot
    a video from time-to-time.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 相机和麦克风可能是 iOS 设备中内置的最受欢迎的两个传感器。实际上，iPhone 用户在打电话时每天都会依赖麦克风。使用 Apple 的 FaceTime
    的人依赖于麦克风和相机来保持联系。当然，每个人都会时不时地拍照或拍摄视频。
- en: Developers are finding increasingly sophisticated uses for both sensors that
    extend far beyond the functionality provided by Apple's pre-installed applications.
    Image and voice recognition, augmented reality, language translation, and voice
    distortion are just a handful.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者正在发现越来越复杂的传感器用途，这些用途远远超出了 Apple 预装应用程序的功能。图像和语音识别、增强现实、语言翻译和语音扭曲只是其中的一小部分。
- en: Adobe introduced camera and microphone support in AIR 2.6, allowing Flash developers
    to take advantage of both sensors within their apps. While you can work through
    all of this chapter's recipes using Flash Professional CS5.5, those with Flash
    Professional CS5 will be limited to the first recipe, *Saving to the camera roll*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Adobe 在 AIR 2.6 中引入了对相机和麦克风的支持，允许 Flash 开发者在其应用程序中利用这两个传感器。虽然您可以使用 Flash Professional
    CS5.5 完成本章的所有食谱，但使用 Flash Professional CS5 的用户将仅限于第一个食谱，*保存到相机胶卷*。
- en: Saving to the camera roll
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存到相机胶卷
- en: Many iOS applications allow the user to save an image to the camera roll. Drawing
    tools and avatar creators are popular examples, where the user can easily show
    off their creation to friends and family from the device's native photo gallery.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 iOS 应用程序允许用户将图像保存到相机胶卷。绘图工具和头像创建者是流行的例子，用户可以轻松地从设备的原生照片库中向朋友和家人展示他们的创作。
- en: This recipe will show you how to save a snapshot of the stage to the device's
    camera roll.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱将向您展示如何将舞台的快照保存到设备的相机胶卷。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: From the book's accompanying code bundle, open `chapter10\recipe1\recipe.fla`
    into Flash Professional.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从本书的配套代码包中，将 `chapter10\recipe1\recipe.fla` 打开到 Flash Professional 中。
- en: You will find two bitmaps and a movie clip sitting on the stage. The bitmaps
    have been composited to produce a background image, which we will save to the
    camera roll. The movie clip represents a button and will initiate the save when
    pressed.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在舞台上找到两个位图和一个动画剪辑。这些位图已被合成为背景图像，我们将将其保存到相机胶卷。动画剪辑代表一个按钮，当按下时将启动保存操作。
- en: The button movie clip has an instance name of `saveBtn` and its library symbol
    is linked to a class named `Button`. This class was introduced in the *Handling
    user interaction* recipe from [Chapter 4](ch04.html "Chapter 4. Porting Flash
    Projects to iOS").
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮动画剪辑的实例名称为 `saveBtn`，其库符号链接到一个名为 `Button` 的类。这个类是在 [第 4 章](ch04.html "第 4
    章。将 Flash 项目移植到 iOS") 的 *处理用户交互* 食谱中引入的。
- en: Okay, let us write some code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们编写一些代码。
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We will make use of AIR's `CameraRoll` class for this recipe.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 AIR 的 `CameraRoll` 类来完成这个食谱。
- en: Create a document class and name it `Main`.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个文档类并命名为 `Main`。
- en: Add the following import statements and a member variable of type `CameraRoll:`
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下导入语句和一个类型为 `CameraRoll:` 的成员变量：
- en: '[PRE0]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Within the constructor, create a `CameraRoll` object and listen for it dispatching
    `Event.COMPLETE`. Also listen for `MouseEvent.MOUSE_UP` being dispatched from
    the `saveBtn` movie clip:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，创建一个 `CameraRoll` 对象并监听它分发 `Event.COMPLETE`。同时监听从 `saveBtn` 动画剪辑分发的 `MouseEvent.MOUSE_UP`：
- en: '[PRE1]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When the save button is pressed, we will add a bitmap image of the stage to
    the camera roll. To prevent the button appearing in the captured bitmap image,
    we will hide it from view first. Add a `pressed()` event handler:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当按下保存按钮时，我们将把舞台的位图图像添加到相机胶卷。为了防止按钮出现在捕获的位图图像中，我们首先将其隐藏。添加一个 `pressed()` 事件处理程序：
- en: '[PRE2]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once the bitmap has been successfully added to the camera roll, we will make
    the button visible again. Write a `saved()` event handler for this:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦位图成功添加到相机胶卷，我们将再次使按钮可见。为此编写一个 `saved()` 事件处理程序：
- en: '[PRE3]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Save the class, and when prompted name the file `Main.as`.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存类，并在提示时将文件命名为 `Main.as`。
- en: Move back to your FLA.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到您的 FLA。
- en: Publish the app and deploy it to your device.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布应用并将其部署到您的设备上。
- en: 'Launch the app and press the **SAVE** button. Go to the Photos app where you
    will see your image saved to the camera roll as shown in the following screenshot:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动应用并按**保存**按钮。转到照片应用，您将看到您的图片已保存到相册中，如下面的截图所示：
- en: '![How to do it...](img/1383_10_01.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/1383_10_01.jpg)'
- en: How it works...
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `CameraRoll` class allows access to the device's photo library and belongs
    to the `flash.media` package.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`CameraRoll` 类允许访问设备的照片库，属于 `flash.media` 包。'
- en: Calling the `CameraRoll.addBitmapData()` method will save a specified bitmap
    to the device. Upon a successful save, `Event.COMPLETE` is dispatched.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `CameraRoll.addBitmapData()` 方法会将指定的位图保存到设备上。在保存成功后，会分发 `Event.COMPLETE`
    事件。
- en: For this recipe, we created and passed a `BitmapData` object to the `addBitmapData()`
    method. The `BitmapData` object contained a bitmap representation of the stage,
    which was created by calling the `BitmapData.draw()` method and passing the `stage`
    property to it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们创建并传递了一个 `BitmapData` 对象到 `addBitmapData()` 方法。`BitmapData` 对象包含了一个由调用
    `BitmapData.draw()` 方法并传递 `stage` 属性给它创建的舞台位图表示。
- en: The static `CameraRoll.supportsAddBitmapData` property was also used. It determines
    whether or not saving bitmap data to the device's camera roll is supported for
    your target platform. Although this property returns `true` for all iOS devices,
    it is wise to check if you are writing cross-platform code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 静态属性 `CameraRoll.supportsAddBitmapData` 也被使用了。它决定了是否支持将位图数据保存到目标平台的设备相册中。尽管这个属性对所有
    iOS 设备都返回 `true`，但在编写跨平台代码时进行检查是明智的。
- en: There's more...
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The following information will be of use to you when saving to the camera roll.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在保存到相册时，以下信息将对您有所帮助。
- en: Handling a failed save
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理保存失败
- en: Don't assume that a bitmap will always successfully save to the camera roll.
    For example, the device may not have the required storage space available.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 不要假设位图总是会成功保存到相册中。例如，设备可能没有足够的存储空间。
- en: When a bitmap cannot be added, the `CameraRoll` object will dispatch `ErrorEvent.ERROR`.
    Querying the `ErrorEvent` object's `text` property retrieves a message associated
    with the error.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当无法添加位图时，`CameraRoll` 对象将分发 `ErrorEvent.ERROR`。查询 `ErrorEvent` 对象的 `text` 属性可以检索与错误相关的消息。
- en: Your code should listen for this event and handle any failed attempts at adding
    bitmap data. Perform a search for `flash.media.CameraRoll` within Adobe Community
    Help for a full list of possible errors.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码应该监听此事件并处理任何添加位图数据失败的尝试。在 Adobe Community Help 中搜索 `flash.media.CameraRoll`
    以获取可能的错误列表。
- en: Saving specific display objects
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保存特定显示对象
- en: Although we grabbed the entire stage for this recipe, you can create a bitmap
    image of any display object and add it to the camera roll. Simply create a `BitmapData`
    object and call its `draw()` method, passing your target display object as an
    argument. The `BitmapData` object's dimensions should be made to match that of
    your display object.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在这个菜谱中抓取了整个舞台，但您也可以创建任何显示对象的位图图像并将其添加到相册中。只需创建一个 `BitmapData` 对象并调用它的 `draw()`
    方法，将您的目标显示对象作为参数传递。`BitmapData` 对象的尺寸应与您的显示对象相匹配。
- en: Video and the camera roll
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 视频和相册
- en: At present, the AIR SDK does not provide support for adding video content to
    the camera roll.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，AIR SDK 不提供将视频内容添加到相册的支持。
- en: See also
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Reading from the camera roll*'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从相册读取*'
- en: Reading from the camera roll
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从相册读取
- en: Depending on the version of the AIR SDK you are using, it is possible to load
    an image from the device's camera roll. AIR for iOS facilitates this by launching
    the native Photos application and allowing the user to select an image. The image
    can then be loaded and added to your display list.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您使用的 AIR SDK 版本，您可能可以从设备的相册中加载图片。AIR for iOS 通过启动原生照片应用并允许用户选择图片来简化这一过程。然后，图片可以被加载并添加到您的显示列表中。
- en: Let us see how to write a simple app that loads an image selected from the camera
    roll.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何编写一个简单的应用程序，该程序可以加载从相册中选择的图片。
- en: The steps covered here are applicable only to those using Flash Professional
    CS5.5\. The AIR 2.0 SDK used by Flash Professional CS5 does not feature an API
    for loading images from the camera roll.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里介绍的方法仅适用于使用 Flash Professional CS5.5 的用户。Flash Professional CS5 使用的 AIR 2.0
    SDK 没有提供从相册加载图片的 API。
- en: Getting ready
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: An FLA has been provided as a starting point for this recipe. From the book's
    accompanying code bundle, open `chapter10\recipe2\recipe.fla` into Flash Professional
    CS5.5.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 已提供一个 FLA 作为此菜谱的起点。从本书的配套代码包中，打开 `chapter10\recipe2\recipe.fla` 到 Flash Professional
    CS5.5。
- en: A movie clip with an instance name of `browseBtn` can be found on the stage.
    The clip's library symbol is linked to a class named `Button`, which was introduced
    in the *Handling user interaction* recipe from [Chapter 4](ch04.html "Chapter 4. Porting
    Flash Projects to iOS").
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在舞台上可以找到一个实例名为 `browseBtn` 的动画剪辑。该剪辑的库符号链接到一个名为 `Button` 的类，该类在第四章的 *处理用户交互*
    菜谱中介绍。
- en: '![Getting ready](img/1383_10_02.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/1383_10_02.jpg)'
- en: Let us write some code to let the user browse for, and load an image from the
    camera roll after pressing the `browseBtn` movie clip.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码，以便在按下 `browseBtn` 动画剪辑后让用户浏览并从相册中加载图片。
- en: How to do it...
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We will make use of several classes, including `CameraRoll, Loader`, and `MediaPromise`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用几个类，包括 `CameraRoll, Loader` 和 `MediaPromise`。
- en: Create a document class and name it `Main`.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个文档类，并将其命名为 `Main`。
- en: Import the required classes and add two member variables—one of type `CameraRoll`
    and the other of type `Loader:`
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的类并添加两个成员变量——一个为 `CameraRoll` 类型，另一个为 `Loader` 类型：
- en: '[PRE4]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Instantiate a `CameraRoll` object and listen for it dispatching `MediaEvent.SELECT`
    and `Event.CANCEL`. Also, listen for the `browseBtn` movie clip being pressed:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化一个 `CameraRoll` 对象，并监听它分发 `MediaEvent.SELECT` 和 `Event.CANCEL` 事件。同时，监听 `browseBtn`
    动画剪辑被按下：
- en: '[PRE5]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When the `browseBtn` movie clip is pressed, we will hide it from view and also
    launch the native Photos application. Add the following method to handle this:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当按下 `browseBtn` 动画剪辑时，我们将将其从视图中隐藏，并启动原生的照片应用。添加以下方法来处理此操作：
- en: '[PRE6]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We will make the `browseBtn` movie clip visible again if the user cancels from
    the Photos application:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户从照片应用中取消，我们将再次使 `browseBtn` 动画剪辑可见：
- en: '[PRE7]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If the user makes a selection, then we will create a `Loader` object and start
    loading the photo. Add the `photoSelected()` method to handle this:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户做出选择，则我们将创建一个 `Loader` 对象并开始加载照片。添加 `photoSelected()` 方法来处理此操作：
- en: '[PRE8]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, write the `photoLoaded()` event handler, which will be called when
    the photo''s image has successfully loaded. This method will re-size and orientate
    the image before adding it to the display list:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，编写 `photoLoaded()` 事件处理程序，当照片的图像成功加载时将被调用。此方法将在将图像添加到显示列表之前调整图像大小和方向：
- en: '[PRE9]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Save the class and name the file `Main.as` when prompted.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存类并在提示时将文件命名为 `Main.as`。
- en: Also, move back to your FLA and save it too.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，返回到您的 FLA 并保存它。
- en: Publish the FLA and deploy the resultant `.ipa` file to your device.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布 FLA 并将生成的 `.ipa` 文件部署到您的设备。
- en: Launch the app, tap the **BROWSE** button, and then select an image from the
    camera roll. Your app will load and display the image.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动应用程序，点击 **BROWSE** 按钮，然后从相册中选择一张图片。您的应用程序将加载并显示该图片。
- en: How it works...
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `flash.media.CameraRoll` class allows access to the device's photo library.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`flash.media.CameraRoll` 类允许访问设备的照片库。'
- en: Its `browseForImage()` method opens the native Photos application, allowing
    the user to select an image from the device's camera roll. At this point, your
    application will lose focus and will wait in the background.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 它的 `browseForImage()` 方法打开原生的照片应用，允许用户从设备的相册中选择一张图片。在此点，您的应用程序将失去焦点并在后台等待。
- en: When a selection is made by the user, your application will regain focus and
    the `CameraRoll` object will dispatch `MediaEvent.SELECT`. If however, the user
    cancels out of the Photos app, then `Event.CANCEL` is dispatched instead.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户做出选择时，您的应用程序将重新获得焦点，并且 `CameraRoll` 对象将分发 `MediaEvent.SELECT` 事件。然而，如果用户从照片应用中取消，则将分发
    `Event.CANCEL` 事件。
- en: In this recipe, the `browseForImage()` method is called in response to the user
    pressing the **BROWSE** button. However, just before the call is made, the static
    `CameraRoll.supportsBrowseForImage` property is checked. This determines whether
    or not browsing for an image is supported by your target platform. Although the
    property returns `true` for all iOS devices, it is useful when targeting multiple
    platforms.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在此菜谱中，当用户按下 **BROWSE** 按钮时调用 `browseForImage()` 方法。然而，在调用之前，将检查静态 `CameraRoll.supportsBrowseForImage`
    属性。这决定了目标平台是否支持浏览图片。尽管该属性对所有 iOS 设备返回 `true`，但在针对多个平台时很有用。
- en: Once the user has selected an image, the `photoSelected()` event handler is
    called and a `MediaEvent` object is passed to it. From the `MediaEvent` object,
    we retrieve information regarding the selected image by querying its `data` property.
    This returns a `MediaPromise` object, which we pass to a `Loader` object's `loadFilePromise()`
    method to actually load the image. Once complete, the `Loader` object will dispatch
    `Event.COMPLETE`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户选择了图像，`photoSelected()` 事件处理器就会被调用，并将一个 `MediaEvent` 对象传递给它。从 `MediaEvent`
    对象中，我们通过查询其 `data` 属性来检索有关所选图像的信息。这返回一个 `MediaPromise` 对象，我们将其传递给 `Loader` 对象的
    `loadFilePromise()` 方法以实际加载图像。一旦完成，`Loader` 对象将派发 `Event.COMPLETE` 事件。
- en: The `photoLoaded()` handler captures the `Loader` object's `COMPLETE` event
    and displays the actual image on screen. Images saved to the camera roll can be
    of a much higher resolution than the stage's dimensions and can be either portrait
    or landscape orientation. The `photoLoaded()` method scales the image to fit the
    stage and if it has a landscape aspect ratio, rotates it by 90 degrees.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`photoLoaded()` 处理器捕获 `Loader` 对象的 `COMPLETE` 事件并在屏幕上显示实际图像。保存到相册的图像分辨率可能远高于舞台尺寸，可以是纵向或横向。`photoLoaded()`
    方法将图像缩放到适合舞台大小，如果它具有横向宽高比，则将其旋转 90 度。'
- en: Tip
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `MediaPromise` class also provides a `file` property, which can be used
    to obtain a URL to the selected camera roll image. While this property will be
    valid for certain platforms, such as Android, it will always return `null` on
    iOS. When writing cross-platform code, use `Loader.loadFilePromise()` rather than
    attempting to obtain and pass a URL to `Loader.load()`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`MediaPromise` 类还提供了一个 `file` 属性，可以用来获取所选相册图像的 URL。虽然这个属性在某些平台（如 Android）上是有效的，但在
    iOS 上它始终返回 `null`。在编写跨平台代码时，使用 `Loader.loadFilePromise()` 而不是尝试获取并传递 URL 到 `Loader.load()`。'
- en: You can obtain more information regarding `flash.media.CameraRoll` and `flash.media.MediaPromise`
    from Adobe Community Help.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 Adobe 社区帮助中获取有关 `flash.media.CameraRoll` 和 `flash.media.MediaPromise` 的更多信息。
- en: There's more...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多信息...
- en: When saving photos to a device, iOS embeds additional metadata with the image.
    Depending on the application you are writing, the following information may be
    useful.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当将照片保存到设备时，iOS 会将额外的元数据嵌入到图片中。根据你正在编写的应用程序，以下信息可能有用。
- en: Parsing Exif data
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解析 Exif 数据
- en: Photos taken on iOS devices adhere to the **Exchangeable image file (Exif)**
    format and can contain thumbnail data and tags of additional information. These
    tags can describe anything ranging from the GPS coordinates associated with the
    image to its orientation.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在 iOS 设备上拍摄的照片遵循 **可交换图像文件 (Exif**) 格式，并可以包含缩略图数据和附加信息的标签。这些标签可以描述从与图像关联的 GPS
    坐标到其方向等任何内容。
- en: Although the AIR SDK does not directly provide support for these tags, there
    are some third-party parsers available. Take a look at [http://code.shichiseki.jp/as3/ExifInfo](http://code.shichiseki.jp/as3/ExifInfo)
    and [www.mxml.it/index.php/2010/01/04/reading-exif-data-with-actionscript-30](http://www.mxml.it/index.php/2010/01/04/reading-exif-data-with-actionscript-30).
    Additionally, the Exif specification can be found at [www.exif.org/exif2-2.pdf](http://www.exif.org/exif2-2.pdf).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然AIR SDK 并不直接提供对这些标签的支持，但有一些第三方解析器可用。请参阅 [http://code.shichiseki.jp/as3/ExifInfo](http://code.shichiseki.jp/as3/ExifInfo)
    和 [www.mxml.it/index.php/2010/01/04/reading-exif-data-with-actionscript-30](http://www.mxml.it/index.php/2010/01/04/reading-exif-data-with-actionscript-30)。此外，Exif
    规范可以在 [www.exif.org/exif2-2.pdf](http://www.exif.org/exif2-2.pdf) 找到。
- en: See also
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: '*Saving to the camera roll*'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*保存到相册*'
- en: Capturing with the default camera app
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用默认相机应用捕获
- en: Most iOS devices have a built-in camera. More recent models have two—one mounted
    on the rear and another on the front. Users can capture photos and shoot video
    using the camera app that comes pre-installed. Third-party applications can also
    utilize the camera with many applications simply launching the default camera
    app for this purpose. Once the user has finished with the camera, the third-party
    app is able to access the photo or video that was taken.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 iOS 设备都内置了相机。较新的型号有两个——一个安装在后面，另一个安装在前面。用户可以使用预装的相机应用拍摄照片和录制视频。第三方应用程序也可以使用相机，许多应用程序只是简单地启动默认的相机应用来完成这个目的。一旦用户完成相机操作，第三方应用就能访问所拍摄的照片或视频。
- en: AIR 2.6 and above provides the `CameraUI` class, making it possible to launch
    and use the default camera app. This recipe will show you how to do this from
    Flash Professional CS5.5\. AIR 2.0 and Flash CS5 do not provide camera support.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: AIR 2.6及以上版本提供了`CameraUI`类，使其能够启动并使用默认的相机应用。本教程将向您展示如何从Flash Professional CS5.5中完成此操作。AIR
    2.0和Flash CS5不提供相机支持。
- en: Getting ready
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need a device that features a camera. The fourth-generation iPod touch,
    iPad 2, and all models of iPhone have cameras.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个具有相机的设备。第四代iPod touch、iPad 2以及所有型号的iPhone都配备了相机。
- en: From the book's accompanying code bundle, open `chapter10\recipe3\recipe.fla`
    into Flash Professional CS5.5.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 从本书的配套代码包中，将`chapter10\recipe3\recipe.fla`文件打开到Flash Professional CS5.5中。
- en: You will find a movie clip named `captureBtn` and a dynamic text field named
    `output` positioned on the stage. The button clip's library symbol is linked to
    a class named `Button`, which was introduced in the *Handling user interaction*
    recipe from [Chapter 4](ch04.html "Chapter 4. Porting Flash Projects to iOS").
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在舞台上找到一个名为`captureBtn`的电影剪辑和一个名为`output`的动态文本字段。按钮剪辑的库符号链接到一个名为`Button`的类，该类在第四章的*处理用户交互*教程中介绍过。[第4章](ch04.html
    "第4章。将Flash项目移植到iOS")。
- en: We will create a simple app that launches the default camera app when the button
    is pressed, allowing the user to capture a photo.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的应用，当按钮被按下时启动默认的相机应用，允许用户捕获照片。
- en: How to do it...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Let us write the ActionScript required to do this.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写完成此操作的ActionScript代码。
- en: Create a document class and name it `Main`.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Main`的文档类。
- en: Import the various classes required for this recipe and create a member variable
    of type `CameraUI:`
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入此教程所需的各个类，并创建一个类型为`CameraUI`的成员变量：
- en: '[PRE10]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Within the constructor, instantiate a `CameraUI` object and listen for it dispatching
    `MediaEvent.COMPLETE` and `Event.CANCEL`. Also, listen for the user pressing the
    `captureBtn` movie clip:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，实例化一个`CameraUI`对象，并监听它触发`MediaEvent.COMPLETE`和`Event.CANCEL`事件。同时，监听用户按下`captureBtn`电影剪辑：
- en: '[PRE11]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When the button is pressed, we will launch the camera app allowing the user
    to take a photo. Add a `pressed()` event handler for this:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当按钮被按下时，我们将启动相机应用，允许用户拍照。为此添加一个`pressed()`事件处理程序：
- en: '[PRE12]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When the user returns from the camera app, we will check that the photo was
    successfully obtained and write confirmation to the `output` text field. Handle
    this by adding a `captured()` method to your class:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户从相机应用返回时，我们将检查照片是否成功获取，并将确认信息写入`output`文本字段。通过在您的类中添加一个`captured()`方法来处理此操作：
- en: '[PRE13]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The user can cancel from the default camera app, discarding any photo that
    they may have taken. Add an event handler for this, stating within the `output`
    text field that the operation was cancelled:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户可以从默认的相机应用中取消操作，丢弃他们可能已经拍摄的照片。为此添加一个事件处理程序，在`output`文本字段中说明操作已取消：
- en: '[PRE14]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Save the class and name the file `Main.as` when prompted.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存类并在提示时将文件命名为`Main.as`。
- en: Move back to your FLA and save it too.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到您的FLA文件并保存它。
- en: Publish the app and launch it once you have deployed the IPA to your device.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将IPA部署到您的设备后，发布应用并启动它。
- en: Tap the **CAPTURE** button to launch the default camera app. Take a photo and
    press the **Use** button. A message will be displayed confirming that the photo
    was successfully captured and is now accessible by your app.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**CAPTURE**按钮以启动默认的相机应用。拍照后，点击**Use**按钮。将显示一条消息，确认照片已成功捕获，现在可以通过您的应用访问。
- en: How it works...
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `flash.media.CameraUI` class allows access to the default camera app. Calling
    its `launch()` method will open the camera app and allow the user to capture either
    an image or video. At this point, your application will lose focus and will wait
    in the background. Once the user has finished, your application will regain focus
    and the `CameraUI` object will dispatch `MediaEvent.COMPLETE`. If the user cancels
    out of the camera app, then `Event.CANCEL` will be dispatched instead.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`flash.media.CameraUI`类允许访问默认的相机应用。调用其`launch()`方法将打开相机应用，并允许用户捕获图片或视频。在此阶段，您的应用将失去焦点并等待在后台。一旦用户完成，您的应用将重新获得焦点，`CameraUI`对象将触发`MediaEvent.COMPLETE`事件。如果用户取消相机应用，则将触发`Event.CANCEL`事件。'
- en: When calling `launch()`, you must pass a constant defined by `flash.media.MediaType`,
    specifying whether you wish to take a photo or shoot video. For this recipe, we
    passed `MediaType.IMAGE`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`launch()`时，您必须传递由`flash.media.MediaType`定义的常量，指定您是想拍照还是拍摄视频。在本教程中，我们传递了`MediaType.IMAGE`。
- en: The captured media is accessed using the `data` property of the `COMPLETE` event's
    `MediaEvent` object. This property is an instance of the `MediaPromise` class
    and can be used to load the image or even access its data.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`COMPLETE`事件的`MediaEvent`对象的`data`属性访问捕获的媒体。该属性是`MediaPromise`类的一个实例，可以用来加载图像甚至访问其数据。
- en: Notice the use of the static `isSupported` property within the `pressed()` event
    handler. It determines whether or not access to the default camera app is supported
    by the device that is currently running your app.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在`pressed()`事件处理程序中使用静态`isSupported`属性。它确定当前运行您的应用程序的设备是否支持访问默认相机应用程序。
- en: You can obtain more information regarding `flash.media.CameraUI` and `flash.media.MediaPromise`
    from Adobe Community Help.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从Adobe社区帮助中获取有关`flash.media.CameraUI`和`flash.media.MediaPromise`的更多信息。
- en: There's more...
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The following information will help complete your understanding.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下信息将有助于完善您的理解。
- en: Handling errors
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理错误
- en: A `CameraUI` object will dispatch an error if the default camera app is already
    in use. You can capture this event by listening for `flash.events.ErrorEvent.ERROR`.
    Query the `ErrorEvent` object's `errorID` and `text` properties to discover more
    about the error.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果默认相机应用程序已经在使用中，`CameraUI`对象将派发一个错误。您可以通过监听`flash.events.ErrorEvent.ERROR`来捕获此事件。查询`ErrorEvent`对象的`errorID`和`text`属性以了解更多关于错误的信息。
- en: Displaying the captured image
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示捕获的图像
- en: We didn't go so far as to actually load and display the photo that was taken
    with the default camera app. This can be achieved by creating a `Loader` object
    and passing the photo's `MediaPromise` object to the loader's `loadFilePromise()`
    method. Refer to the previous recipe, *Reading from the camera roll*, for more
    detail.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并没有走那么远，实际上加载并显示使用默认相机应用程序拍摄的照片。这可以通过创建一个`Loader`对象并将照片的`MediaPromise`对象传递给加载器的`loadFilePromise()`方法来实现。有关更多详细信息，请参阅前面的配方，*从相机胶卷读取*。
- en: Saving the captured image to the camera roll
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将捕获的图像保存到相机胶卷
- en: Unlike some other mobile operating systems, the captured photo isn't actually
    stored by iOS in the camera roll. If you want the photo to appear in the camera
    roll, you will need to manually add it yourself. This is done by using a `Loader`
    object to load your `MediaPromise` object's binary data, then writing its bitmap
    data to the camera roll using a `CameraRoll` instance.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 与一些其他移动操作系统不同，iOS实际上并不在相机胶卷中存储捕获的照片。如果您想让照片出现在相机胶卷中，您需要手动添加它。这可以通过使用`Loader`对象来加载您的`MediaPromise`对象的二进制数据，然后使用`CameraRoll`实例将其位图数据写入相机胶卷来实现。
- en: Refer to the *Reading from the camera roll* and the *Saving to the camera roll*
    recipes from earlier in this chapter.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅本章前面部分的*从相机胶卷读取*和*保存到相机胶卷*配方。
- en: Capturing video
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 捕获视频
- en: 'While we captured a photo using the default camera app, a simple code change
    is all that is required to shoot video instead. You can see this in the following
    code snippet where `MediaType.VIDEO` is passed to the `CameraUI` object''s `launch()`
    method:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们使用默认相机应用程序捕获了一张照片，但只需简单的代码更改就可以拍摄视频。您可以在以下代码片段中看到这一点，其中`MediaType.VIDEO`被传递到`CameraUI`对象的`launch()`方法中：
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It is not possible for the user to change between photo and camera mode while
    using the default camera app launched from AIR. You can only use the camera app
    for capturing a single media type at any one time.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用从AIR启动的默认相机应用程序时，用户无法在照片和相机模式之间切换。您只能在任何时候使用相机应用程序捕获单一媒体类型。
- en: Take a look at the *Playing local H.264 video* recipe from [Chapter 12](ch12.html
    "Chapter 12. Working with Video and Audio") to see how to playback your captured
    video.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 查看第12章的*播放本地H.264视频*配方，了解如何播放您捕获的视频。[第12章](ch12.html "第12章。处理视频和音频")。
- en: Reading the captured data
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取捕获的数据
- en: It is also possible to directly access the binary data that represents the image
    or video captured from the camera. This is useful for applications that perhaps
    need to write the media directly to the device's file system, upload the data
    to a server, or to simply parse or alter the data in some way. The `MediaPromise`
    object provides an `open()` method that can be used to access the data. You can
    then read it into a `ByteArray` object.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以直接访问代表从相机捕获的图像或视频的二进制数据。这对于可能需要直接将媒体写入设备文件系统、上传数据到服务器或以某种方式解析或修改数据的应用程序非常有用。`MediaPromise`对象提供了一个`open()`方法，可以用来访问数据。然后你可以将其读入一个`ByteArray`对象中。
- en: 'To do this within this recipe''s example, add the following member variables:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要在这个配方示例中实现这一点，请添加以下成员变量：
- en: '[PRE16]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add the following code snippet at the end of the `captured()` event handler:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在`captured()`事件处理器的末尾添加以下代码片段：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now write an event handler to copy the data into a `ByteArray` object:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在编写一个事件处理程序，将数据复制到`ByteArray`对象中：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Also include the following import statements:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 还需包含以下导入语句：
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You will now have access to the media's binary data within the `dataCaptured()`
    method.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以在`dataCaptured()`方法中访问媒体的二进制数据。
- en: See also
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Saving to the camera roll*'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*保存到相册*'
- en: '*Reading from the camera roll*'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从相册读取*'
- en: '*Working with the built-in cameras*'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用内置摄像头*'
- en: Working with the built-in cameras
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内置摄像头
- en: While launching and using the default camera app provides the user with the
    native camera experience that they are familiar with, it may not be appropriate
    for all types of applications. In addition to `CameraUI`, AIR also provides the
    `Camera` class, which receives the video data captured by the device's on-board
    camera, allowing it to be directly displayed within your app.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然启动和使用默认的摄像头应用为用户提供了一个他们熟悉的原生摄像头体验，但这可能不适合所有类型的应用。除了`CameraUI`之外，AIR还提供了`Camera`类，该类接收设备内置摄像头捕获的视频数据，允许您直接在您的应用中显示。
- en: In this recipe, you will learn how to receive a video stream from the camera
    and display it within your app using Flash Professional CS5.5\. The `Camera` class
    is not supported by Flash CS5 and AIR 2.0 for iOS.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，您将学习如何使用Flash Professional CS5.5从摄像头接收视频流并在您的应用中显示它。`Camera`类在Flash CS5和AIR
    2.0 for iOS中不受支持。
- en: Getting ready
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need a device that features a camera. The fourth generation iPod touch,
    iPad 2, and all models of iPhone have cameras.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个带有摄像头的设备。第四代iPod touch、iPad 2以及所有型号的iPhone都配备了摄像头。
- en: From the book's accompanying code bundle, open `chapter10\recipe4\recipe.fla`
    into Flash Professional CS5.5.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 从书籍的配套代码包中，将`chapter10\recipe4\recipe.fla`文件打开到Flash Professional CS5.5中。
- en: A landscape aspect ratio has been set for the stage and this has also been reflected
    within the FLA's AIR for iOS settings.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 阶段已设置了一个景观宽高比，并且这一设置也反映在FLA的iOS设置中。
- en: How to do it...
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to receive video from the camera and display it on the stage:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤从摄像头接收视频并在舞台上显示：
- en: Create a document class and name it `Main`.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个文档类并命名为`Main`。
- en: Declare two member variables—one of type `Camera` and the other of type `Video:`
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明两个成员变量——一个类型为`Camera`，另一个类型为`Video`：
- en: '[PRE20]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Within the constructor, obtain a reference to the device''s default camera
    and attach it to a `Video` object. Also, add the `Video` object to the stage allowing
    the video data to be viewed by the user:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，获取设备默认摄像头的引用并将其附加到一个`Video`对象上。同时，将`Video`对象添加到舞台上，以便用户可以查看视频数据：
- en: '[PRE21]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Save the class as `Main.as`. Also move back to your FLA and save it too.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类保存为`Main.as`。然后返回到您的FLA并保存它。
- en: Publish the FLA and test it on your device.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布FLA并在您的设备上测试它。
- en: Hold the device in landscape orientation. Video from the rear-facing camera
    will be rendered to the screen.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将设备保持为横屏方向。后置摄像头的视频将被渲染到屏幕上。
- en: How it works...
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `flash.media.Camera` class is a singleton, meaning only one instance of
    it can exist. To guarantee this, the class has no public constructor. Instead,
    access to the camera is obtained by calling the `Camera` class' `getCamera()`
    static method, which returns the `Camera` instance for you to work with.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`flash.media.Camera`类是一个单例，这意味着只能存在一个实例。为了保证这一点，该类没有公共构造函数。相反，通过调用`Camera`类的`getCamera()`静态方法来获取对摄像头的访问，该方法为您返回一个可以与之工作的`Camera`实例。'
- en: Once the `Camera` instance is obtained, the capture mode to be used by the camera
    can be specified. This is done by calling `setMode()` and passing to it a width,
    height, and target frame rate. For this recipe, we passed the stage's dimensions
    and frame rate. If the specified requirements cannot be met by the camera, then
    it will use a mode which is the closest match.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦获取到`Camera`实例，就可以指定摄像头要使用的捕获模式。这是通过调用`setMode()`方法并传递一个宽度、高度和目标帧率来完成的。对于这个配方，我们传递了舞台的尺寸和帧率。如果摄像头无法满足指定的要求，它将使用最接近的模式。
- en: In order to display the live video being streamed from the camera, it must be
    attached to a `Video` object. The `flash.media.Video` class inherits `DisplayObject`
    allowing any `Video` object to be added to the display list. First the `Video`
    object is created and a width and height for it are passed to its constructor—we
    set its dimensions to match those used by the camera. Then a call to `attachCamera()`
    is made, providing the `Video` object with access to the `Camera` object's video
    stream. Finally, the `Video` object is added to the display list by calling `addChild()`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示从摄像头流出的实时视频，它必须附加到一个`Video`对象上。`flash.media.Video`类继承自`DisplayObject`，允许任何`Video`对象被添加到显示列表中。首先创建一个`Video`对象，并将宽度高度传递给其构造函数——我们将其尺寸设置为与摄像头使用的尺寸相匹配。然后调用`attachCamera()`，为`Video`对象提供访问`Camera`对象视频流的权限。最后，通过调用`addChild()`将`Video`对象添加到显示列表中。
- en: Before attempting to connect to a camera, you should first check that one is
    available. The `Camera.names` static property returns an array of available cameras.
    We checked at the beginning of the document class' constructor that the array's
    length was greater than `0` before proceeding. Alternatively, check for `null`
    being returned by `Camera.getCamera()`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试连接到摄像头之前，你应该首先检查是否有一个摄像头可用。`Camera.names`静态属性返回一个可用摄像头的数组。我们在文档类构造函数的开始处检查了数组的长度是否大于`0`，然后才继续。或者，你可以检查`Camera.getCamera()`返回的是否为`null`。
- en: For more information regarding camera support, perform a search for `flash.media.Camera`
    and `flash.media.Video` within Adobe Community Help.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 关于摄像头支持的更多信息，请在Adobe Community Help中搜索`flash.media.Camera`和`flash.media.Video`。
- en: There's more...
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Let us look at some additional options when capturing live video from the camera.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看从摄像头捕获实时视频时的一些附加选项。
- en: Portrait mode
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 肖像模式
- en: 'On iOS, a `Camera` object captures video in landscape orientation. If your
    application uses a portrait aspect ratio, then you will need to swap the camera''s
    capture dimensions and also rotate and re-position the `Video` object. To do this,
    make the following changes to this recipe''s constructor:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS上，`Camera`对象以横向模式捕获视频。如果你的应用程序使用的是纵向宽高比，那么你需要交换摄像头的捕获尺寸，并且旋转和重新定位`Video`对象。为此，你需要对以下构造函数进行以下更改：
- en: '[PRE22]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Remember to change the stage's dimensions and update the AIR for iOS settings
    to use a portrait aspect ratio. There is a performance hit when capturing portrait
    video due to the rotation applied to the `Video` object. Where possible, try to
    use landscape for applications that use the camera.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 记得更改舞台的尺寸并更新AIR for iOS设置以使用纵向宽高比。由于对`Video`对象应用了旋转，捕获纵向视频时会有性能损失。尽可能使用横向模式来处理使用摄像头的应用程序。
- en: Selecting a camera
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择摄像头
- en: 'The `Camera.getCamera()` static method connects to the rear-facing camera by
    default. For devices that support more than one, you can specify a camera by passing
    a string representing the zero-based index position within the array specified
    by `Camera.names`. For example, the following code uses the iPhone 4/4S''s front-facing
    camera:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`Camera.getCamera()`静态方法默认连接到后置摄像头。对于支持多个摄像头的设备，你可以通过传递一个字符串来指定摄像头，该字符串表示`Camera.names`指定的数组中的零基于索引位置。例如，以下代码使用了iPhone
    4/4S的前置摄像头：'
- en: '[PRE23]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It is important that you pass a string rather than an integer when making this
    call.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行此调用时，传递字符串而不是整数是很重要的。
- en: Only one camera can be active at any one time on iOS. If you connect to a second
    camera, then the previous camera's connection will be dropped.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS上，任何时刻只能有一个摄像头处于活动状态。如果你连接到第二个摄像头，则之前摄像头的连接将被断开。
- en: Grabbing a bitmap image
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取位图图像
- en: 'It is possible to capture a bitmap image from the camera''s live video stream.
    The following code extracts the bitmap data from the video''s current frame and
    stores it within a `Bitmap` object:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 从摄像头的实时视频流中捕获位图图像是可能的。以下代码从视频的当前帧中提取位图数据，并将其存储在`Bitmap`对象中：
- en: '[PRE24]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, the `BitmapData` object's dimensions are made to match those
    of the video. The current frame is then drawn into the `BitmapData` object, which
    is used to create the actual bitmap.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`BitmapData`对象的尺寸被设置为与视频相匹配。然后当前帧被绘制到`BitmapData`对象中，该对象用于创建实际的位图。
- en: Live streaming
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实时流
- en: For this recipe, we simply used the camera's video stream locally on the device.
    However, by using the `NetConnection` and `NetStream` classes, it is possible
    to transmit the video stream to a Flash Media Server, where it can be broadcast
    to other clients. This is ideal for live video chat applications or other collaborative
    projects.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们只是在本地上使用了相机的视频流。然而，通过使用 `NetConnection` 和 `NetStream` 类，可以将视频流传输到 Flash
    媒体服务器，在那里它可以被广播到其他客户端。这对于实时视频聊天应用或其他协作项目来说非常理想。
- en: Both classes belong to the `flash.net` package. More detail is available from
    Adobe Community Help.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个类都属于 `flash.net` 包。更多详细信息可在 Adobe 社区帮助中找到。
- en: Using the stage
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用舞台
- en: It is also possible to place and size a `Video` object on the stage using the
    Flash IDE rather than ActionScript. Simply right-click on the **Library** panel
    and select **New Video** from the context menu. From the **Video Properties**
    panel that appears, click on the **Video (ActionScript-controlled)** radio button
    before clicking on **OK**. A video clip will appear in the library, which you
    can drag to the stage and assign an instance name to.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Flash IDE 而不是 ActionScript 也可以在舞台上放置和调整 `视频` 对象的大小。只需在 **库** 面板中右键单击，然后从上下文菜单中选择
    **新建视频**。在出现的 **视频属性** 面板中，点击 **视频（ActionScript 控制）** 单选按钮，然后点击 **确定**。视频剪辑将出现在库中，您可以将其拖动到舞台上，并为其指定一个实例名称。
- en: See also
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: '*Saving to the camera roll*'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*保存到相机胶卷*'
- en: '*Capturing with the default camera app*'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用默认相机应用捕获*'
- en: Recording microphone audio
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 录制麦克风音频
- en: AIR provides an API that enables an application to connect to the built-in microphone.
    The microphone's raw data can be obtained, recorded for later use, processed as
    it is received, or routed to the device's speakers.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: AIR 提供了一个 API，允许应用程序连接到内置麦克风。可以获取麦克风的原始数据，将其记录以供以后使用，在接收时进行处理，或者将其路由到设备的扬声器。
- en: This recipe will show you how to use the `Microphone` and `ByteArray` classes
    to capture and record audio. You will need Flash Professional CS5.5 as microphone
    access for iOS is not supported by CS5 and AIR 2.0.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将向您展示如何使用 `Microphone` 和 `ByteArray` 类来捕获和录制音频。您需要 Flash Professional CS5.5，因为
    CS5 和 AIR 2.0 不支持 iOS 的麦克风访问。
- en: Getting ready
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: While all recent models from the iOS family contain a built-in microphone, previous
    generations of the iPod touch don't. The second and third-generation devices do,
    however, provide support for an external microphone, which can be used for this
    recipe.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然iOS家族的所有最新型号都内置了麦克风，但旧一代的iPod touch没有。然而，第二代和第三代设备确实提供了对外部麦克风的兼容性，这可以用于本食谱。
- en: From the book's accompanying code bundle, open `chapter10\recipe5\recipe.fla`
    into Flash Professional CS5.5.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 从本书的配套代码包中，将 `chapter10\recipe5\recipe.fla` 打开到 Flash Professional CS5.5。
- en: Sitting on the stage you will find a dynamic text field with an instance name
    of `output` and three movie clips. Two of the movie clips represent buttons and
    are named `recordBtn` and `stopBtn` respectively. The `stopBtn` clip is positioned
    directly behind the `recordBtn` clip but sits on its own timeline layer for easy
    access. The third movie clip is named `micStatus` and covers the entire background.
    It is used to indicate when recording is taking place.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在舞台上，您将找到一个名为 `output` 的动态文本字段和三个电影剪辑。其中两个电影剪辑代表按钮，分别命名为 `recordBtn` 和 `stopBtn`。`stopBtn`
    剪辑位于 `recordBtn` 剪辑的直接后方，但位于自己的时间轴层上，以便于访问。第三个电影剪辑名为 `micStatus`，覆盖了整个背景。它用于指示何时正在录音。
- en: The library symbols for `recordBtn` and `stopBtn` are linked to a base class
    named `Button`. This class was introduced in the *Handling user interaction* recipe
    from [Chapter 4](ch04.html "Chapter 4. Porting Flash Projects to iOS").
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`recordBtn` 和 `stopBtn` 的库符号链接到一个名为 `Button` 的基类。这个类是在第 4 章（[第 4 章. 将 Flash
    项目移植到 iOS](ch04.html "Chapter 4. Porting Flash Projects to iOS")）的 *处理用户交互* 食谱中引入的。'
- en: We will add ActionScript to start recording data from the microphone when the
    user taps the `recordBtn` movie clip. Audio capture will end when `stopBtn` is
    pressed. To give feedback to the user that recording is taking place, we will
    move the `micStatus` movie clip's `playhead` to frame `2`. The text field will
    be used to output confirmation that audio was successfully recorded.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击 `recordBtn` 电影剪辑时，我们将添加 ActionScript 以开始从麦克风录制数据。当按下 `stopBtn` 时，音频捕获将结束。为了向用户提供正在录制的反馈，我们将
    `micStatus` 电影剪辑的 `播放头` 移动到帧 `2`。文本字段将用于输出音频成功录制的确认信息。
- en: This recipe will concentrate on the recording of microphone audio. We will cover
    playback of the audio in the next recipe.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方将专注于麦克风音频的录制。我们将在下一个配方中介绍音频的播放。
- en: How to do it...
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Now let us write the ActionScript for this. Follow these steps:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写这个ActionScript。按照以下步骤操作：
- en: Create a document class and name it `Main`.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个文档类并将其命名为`Main`。
- en: 'Import the various classes required for this recipe and create two member variables—one
    to reference the device''s microphone and another to store data captured from
    it:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入此配方所需的各个类，并创建两个成员变量——一个用于引用设备的麦克风，另一个用于存储从它捕获的数据：
- en: '[PRE25]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Within the constructor, set up the movie clips and create a connection to the
    device''s microphone:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，设置电影剪辑并创建与设备麦克风的连接：
- en: '[PRE26]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add a handler for each button being pressed:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个被按下的按钮添加一个处理程序：
- en: '[PRE27]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next add a method that sets up the microphone and starts listening for live
    audio data. We will also instantiate a `ByteArray` object named `soundData`, which
    will be used to store the captured data:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来添加一个设置麦克风并开始监听实时音频数据的方法。我们还将实例化一个名为`soundData`的`ByteArray`对象，它将用于存储捕获的数据：
- en: '[PRE28]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add an event handler that gets called every time audio data is available from
    the microphone. We will write a maximum of 2 MB of this audio data to our `ByteArray`
    object for later use:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个事件处理程序，每当从麦克风获取音频数据时都会被调用。我们将最多写入2 MB的音频数据到我们的`ByteArray`对象中，以供以后使用：
- en: '[PRE29]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally add a method that stops listening for live audio data from the microphone.
    The total number of bytes recorded will be written to the `output` text field:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后添加一个方法，用于停止监听来自麦克风的实时音频数据。记录的总字节数将写入`output`文本字段：
- en: '[PRE30]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Save the class and name its file `Main.as`.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存类并将其文件命名为`Main.as`。
- en: Move back to your FLA and save it.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到你的FLA文件并保存它。
- en: Publish the FLA and deploy the resultant `.ipa` file to your device.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布FLA文件并将生成的`.ipa`文件部署到你的设备上。
- en: Launch the app, tap the **RECORD** button and start speaking into the microphone.
    When you are finished, tap the **STOP** button.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动应用，点击**RECORD**按钮并开始对着麦克风说话。当你完成时，点击**STOP**按钮。
- en: The amount of audio data (in bytes) that was recorded will be written to the
    screen.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 记录的音频数据量（以字节为单位）将写入屏幕。
- en: How it works...
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Microphone support is provided by the `flash.media.Microphone` class. To connect
    to the device's microphone, make a call to the static `Microphone.getMicrophone()`
    method, which will return a new `Microphone` instance. If a microphone can't be
    found, then `null` will be returned instead.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`flash.media.Microphone`类提供了麦克风支持。要连接到设备的麦克风，调用静态`Microphone.getMicrophone()`方法，它将返回一个新的`Microphone`实例。如果找不到麦克风，则返回`null`。'
- en: 'The following code snippet is the call being made from within our document
    class'' constructor:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段是我们文档类构造函数中进行的调用：
- en: '[PRE31]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Once you have a `Microphone` object, you can adjust the audio data that will
    be received. We did this within the `startRecording()` method by setting the `Microphone`
    object's gain and sample rate.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有一个`Microphone`对象，你可以调整将要接收的音频数据。我们通过在`startRecording()`方法中设置`Microphone`对象的增益和采样率来完成此操作。
- en: The gain is used to boost the microphone's signal and is set using the `gain`
    property. A value of `100` was used to maximize its loudness.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 增益用于增强麦克风的信号，并使用`gain`属性设置。使用`100`的值以最大化其响度。
- en: The sample rate dictates the quality of the audio that is captured and is specified
    by the `rate` property. Higher sample rates produce clearer audio but demand more
    from the CPU and require increased space to store. We set the `rate` property
    to `44`, specifying an actual sample frequency of 44 kHz. In other words, we will
    capture sound from the microphone 44,100 times per second! This is the highest
    permitted sample rate and records the clearest sound.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 采样率决定了捕获的音频质量，由`rate`属性指定。较高的采样率产生更清晰的音频，但需要CPU更多的处理，并需要更多的空间来存储。我们将`rate`属性设置为`44`，指定实际的采样频率为44
    kHz。换句话说，我们将每秒从麦克风捕获44,100次声音！这是允许的最高采样率，并记录最清晰的声音。
- en: 'To actually start capturing audio from the microphone, add a `SampleDataEvent.SAMPLE_DATA`
    listener to the `Microphone` object. The `SAMPLE_DATA` event is continually dispatched
    as the microphone''s audio buffer fills. We added the `SAMPLE_DATA` event listener
    within the `startRecording()` method immediately after setting the gain and sample
    rate:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际开始从麦克风捕获音频，请向 `Microphone` 对象添加一个 `SampleDataEvent.SAMPLE_DATA` 监听器。随着麦克风音频缓冲区的填充，`SAMPLE_DATA`
    事件会持续派发。我们在设置增益和采样率后立即在 `startRecording()` 方法中添加了 `SAMPLE_DATA` 事件监听器：
- en: '[PRE32]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Each `SampleDataEvent` object has a `data` property, which is a `ByteArray`
    containing the current audio sampled from the microphone. Recording the audio
    is a simple case of copying this temporary data into a more permanent `ByteArray`
    object. You can see the code for this within the `SampleData()` event handler,
    where a loop is used to extract the sampled data and write it to the `soundData`
    member variable:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `SampleDataEvent` 对象都有一个 `data` 属性，它是一个包含从麦克风当前采样的音频的 `ByteArray`。录制音频就是一个简单地将这个临时数据复制到一个更持久的
    `ByteArray` 对象的过程。您可以在 `SampleData()` 事件处理程序中看到此代码，其中使用循环提取采样数据并将其写入 `soundData`
    成员变量：
- en: '[PRE33]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Each sample is represented by a floating point value. The loop, therefore, reads
    a float from the audio buffer and writes it to the `soundData` member variable.
    This process continues until the data stored within the `SampleDataEvent` object
    is empty.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 每个样本都由一个浮点值表示。因此，循环从音频缓冲区中读取一个浮点数并将其写入 `soundData` 成员变量。这个过程会一直持续到 `SampleDataEvent`
    对象中的数据为空。
- en: To prevent the app from completely exhausting the device's memory, the `sampleData()`
    handler checks the size of the `soundData` member variable. If it exceeds 2 MB
    (2,097,152 bytes) in size, then recording is stopped and the number of recorded
    bytes is written to the `output` text field.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止应用完全耗尽设备的内存，`sampleData()` 处理程序会检查 `soundData` 成员变量的大小。如果它的大小超过 2 MB（2,097,152
    字节），则停止录制并将录制的字节数写入 `output` 文本字段。
- en: Audio capture is stopped by removing the `SAMPLE_DATA` event listener from the
    `Microphone` object. Take a look at the `stopRecording()` method to see this.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从 `Microphone` 对象中移除 `SAMPLE_DATA` 事件监听器来停止音频捕获。查看 `stopRecording()` 方法以了解这一点。
- en: For more information regarding audio capture, perform a search for `flash.media.Microphone,
    flash.events.SampleDataEvent`, and `flash.utils.ByteArray` within Adobe Community
    Help.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 关于音频捕获的更多信息，请在 Adobe Community Help 中搜索 `flash.media.Microphone`、`flash.events.SampleDataEvent`
    和 `flash.utils.ByteArray`。
- en: There's more...
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Following are some additional options open to you when recording from the microphone.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在从麦克风录制时，您还有以下一些额外的选项。
- en: Microphone activity
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 麦克风活动
- en: You can determine the amount of sound that the microphone is detecting by querying
    the `Microphone` object's `activityLevel` property. This will return a value ranging
    from `0` to `100`, with `0` being returned when no sound is detected.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过查询 `Microphone` 对象的 `activityLevel` 属性来确定麦克风检测到的声音量。这将返回一个从 `0` 到 `100`
    的值，当没有检测到声音时返回 `0`。
- en: It is also possible using the `setSilenceLevel()` method to specify an activity
    level threshold that must be met before audio is accepted by the microphone. The
    higher the activity level that is passed as a parameter, the louder an audio source
    must be before it is detected. This method also accepts an optional second parameter,
    which specifies the number of milliseconds of inactivity that must pass before
    sound is considered to have stopped.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `setSilenceLevel()` 方法也可以指定一个活动水平阈值，在音频被麦克风接受之前必须达到这个阈值。传递给参数的活动水平越高，音频源必须越响亮才能被检测到。此方法还接受一个可选的第二个参数，该参数指定在认为声音停止之前必须经过的毫秒数的不活动时间。
- en: 'As an example, add the following to your `startRecording()` method:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，将以下内容添加到您的 `startRecording()` 方法中：
- en: '[PRE34]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now add the following event handler:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在添加以下事件处理程序：
- en: '[PRE35]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, add the following import statement:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加以下导入语句：
- en: '[PRE36]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Test these changes on your device. Your app won't dispatch `SAMPLE_DATA` events
    until the microphone's silence level is exceeded. Also, once activated, the microphone
    will deactivate again if silence occurs for more than two seconds.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的设备上测试这些更改。您的应用将不会派发 `SAMPLE_DATA` 事件，直到麦克风的静音水平被超过。此外，一旦激活，如果静音持续超过两秒钟，麦克风将再次停用。
- en: Live streaming
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实时流
- en: The microphone's audio data was simply used locally in this recipe. However,
    it is possible, using the `NetConnection` and `NetStream` classes, to transmit
    the data to a Flash Media Server for broadcast to other clients. Additional detail
    can be found on Adobe Community Help by searching for both classes, which belong
    to the `flash.net` package.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，麦克风音频数据仅被本地使用。但是，使用`NetConnection`和`NetStream`类，可以将数据传输到Flash Media Server以广播给其他客户端。有关详细信息，请访问Adobe社区帮助，搜索这两个类，它们属于`flash.net`包。
- en: See also
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Playing recorded audio*'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*播放录制的音频*'
- en: Playing recorded audio
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放录制的音频
- en: After capturing the microphone's raw audio data, you will need a means of playing
    it back. This recipe will show you how to send the data to your device's speaker.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在捕获麦克风的原始音频数据后，您需要一种播放它的方法。本配方将向您展示如何将数据发送到您的设备扬声器。
- en: Getting ready
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: If you have completed the *Recording microphone audio* recipe, then you can
    work from the code you wrote for it. Alternatively, from the book's accompanying
    code bundle, open `chapter10\recipe6\recipe.fla` and use it as a starting point.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经完成了**录音麦克风音频**配方，那么您可以从中编写的代码开始工作。或者，从本书的配套代码包中打开`chapter10\recipe6\recipe.fla`，并将其作为起点使用。
- en: Currently the FLA will record audio from the microphone and store it within
    a member variable of type `ByteArray` named `soundData`. We will add code that
    plays back the audio once the user has finished recording it.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，FLA将从麦克风录制音频并将其存储在名为`soundData`的成员变量中，该变量是`ByteArray`类型。我们将添加代码，在用户完成录音后播放音频。
- en: How to do it...
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following changes are required to read and playback the recorded audio:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 需要以下更改来读取和播放录制的音频：
- en: Open `Main.as`.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Main.as`。
- en: 'Import the following three classes:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入以下三个类：
- en: '[PRE37]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Also add a `Sound` and `SoundChannel` member variable:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还需添加一个`Sound`和`SoundChannel`成员变量：
- en: '[PRE38]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `stopRecording()` method will need to make an additional call to initiate
    playback of the recorded audio. Add the following line at the end of the method:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`stopRecording()`方法需要调用以启动录制的音频播放。在方法末尾添加以下行：'
- en: '[PRE39]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now write the `playRecording()` method, which will initiate playback of the
    audio:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在编写`playRecording()`方法，它将启动音频播放：
- en: '[PRE40]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Add a method that periodically pulls data from the `soundData` object for playback:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个方法，该方法定期从`soundData`对象中提取数据以进行播放：
- en: '[PRE41]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, reset the button movie clips once audio playback is complete:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在音频播放完成后重置按钮电影剪辑：
- en: '[PRE42]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Save your changes to the class.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存对类的更改。
- en: Publish the FLA and test it on your device.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布FLA并在您的设备上测试它。
- en: Start recording some audio and when you are finished, tap the **STOP** button.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始录制一些音频，完成后，轻触**停止**按钮。
- en: The recorded audio will be played back through your device's speaker. If you
    don't hear anything then increase your speaker's volume and try again.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 录制的音频将通过您的设备扬声器播放。如果您什么也听不到，请增加扬声器的音量并再次尝试。
- en: How it works...
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Both the `Sound` and `SoundChannel` classes are used for audio playback.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sound`和`SoundChannel`类都用于音频播放。'
- en: 'We create a `Sound` object and add a `SAMPLE_DATA` event listener to it. This
    event is dispatched when there is no more audio data for the `Sound` object to
    play:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个`Sound`对象，并向它添加一个`SAMPLE_DATA`事件监听器。当`Sound`对象没有更多音频数据可播放时，将触发此事件：
- en: '[PRE43]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'A call is also made to the object''s `play()` method, which returns a `SoundChannel`
    instance allowing playback to be monitored. We listen for the `SoundChannel` object
    dispatching `SOUND_COMPLETE` to determine when audio playback has ended:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 还调用了对象的`play()`方法，该方法返回一个`SoundChannel`实例，允许监控播放。我们监听`SoundChannel`对象触发`SOUND_COMPLETE`以确定音频播放何时结束：
- en: '[PRE44]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Initially the `Sound` object doesn't contain any audio data. The data from the
    entire recording is instead held by the `soundData` member variable, which is
    a `ByteArray`. As the `Sound` object has no audio data to play, it immediately
    dispatches a `SAMPLE_DATA` event, which is captured by the `playSampleData()`
    handler.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，`Sound`对象不包含任何音频数据。整个录音的数据由`soundData`成员变量持有，该变量是`ByteArray`类型。由于`Sound`对象没有音频数据可播放，它立即触发一个`SAMPLE_DATA`事件，该事件由`playSampleData()`处理程序捕获。
- en: Within `playSampleData()`, we extract some audio data from the `soundData` member
    variable and feed it to the `Sound` object. This provides the `Sound` object with
    enough data to start playing audio. Each time its buffer runs low, it will dispatch
    another `SAMPLE_DATA` event and we will feed it more data. This process continues
    until the entire recording has been played.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在`playSampleData()`中，我们从`soundData`成员变量中提取一些音频数据并将其馈送到`Sound`对象。这为`Sound`对象提供了足够的数据以开始播放音频。每次其缓冲区变低时，它将派发另一个`SAMPLE_DATA`事件，我们将提供更多数据。这个过程会一直持续到整个录音播放完毕。
- en: 'The following is the code from the `playSampleData()` handler that is responsible
    for writing data to the `Sound` object''s buffer:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从`playSampleData()`处理程序中提取的代码，该处理程序负责将数据写入`Sound`对象的缓冲区：
- en: '[PRE45]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `Sound` object's buffer is accessed through the `SampleDataEvent` parameter's
    `data` property. We, therefore, take a sample from the `soundData` member variable
    and write it to the `data` property's `ByteArray`. The `readFloat()` method is
    used to read a sample from `soundData`, while `writeFloat()` is used to write
    the same sample into the `Sound` object's buffer—each sample is represented by
    a floating point value.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sound`对象的缓冲区通过`SampleDataEvent`参数的`data`属性来访问。因此，我们从`soundData`成员变量中取一个样本并将其写入`data`属性的`ByteArray`。使用`readFloat()`方法从`soundData`中读取样本，而使用`writeFloat()`将相同的样本写入`Sound`对象的缓冲区——每个样本由一个浮点值表示。'
- en: However, we don't just write a single sample to the buffer—it would instantly
    empty again. Instead, we take the opportunity to write 8192 stereo samples, providing
    the object with 64 KB of audio data. Typically you can write between 2048 and
    8192 stereo samples at a time. However, a runtime exception will be thrown if
    you attempt to write more than 64 KB of data to the buffer.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不仅仅是将单个样本写入缓冲区——它很快就会再次清空。相反，我们抓住机会写入8192个立体声样本，为对象提供64 KB的音频数据。通常，你一次可以写入2048到8192个立体声样本。然而，如果你尝试写入超过64
    KB的数据到缓冲区，将会抛出一个运行时异常。
- en: 'To create a stereo sample, we write each recorded sample to the `Sound` object
    twice:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建立体声样本，我们将每个记录的样本写入`Sound`对象两次：
- en: '[PRE46]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: While the microphone records monophonic data, your device is capable of stereo
    output. Therefore, when writing audio data to a `Sound` object, you need to write
    the sample to both the left and right channels. The first call to `writeFloat()`
    sends the sample to the left channel, while the second call sends it to the right.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 当麦克风记录单声道数据时，你的设备能够进行立体声输出。因此，当将音频数据写入`Sound`对象时，你需要将样本写入左右两个通道。`writeFloat()`的第一个调用将样本发送到左通道，而第二个调用将样本发送到右通道。
- en: For more information, perform a search for `flash.media.Sound` and `flash.media.SoundChannel`
    within Adobe Community Help.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请在Adobe社区帮助中搜索`flash.media.Sound`和`flash.media.SoundChannel`。
- en: There's more...
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are a few final pieces of information related to microphone audio playback.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 与麦克风音频播放相关的一些最终信息。
- en: Working with lower sample rates
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理较低的采样率
- en: The `Sound` class uses a sample rate of 44 kHz. If audio from the microphone
    was captured at an alternative frequency, then you will need to upscale it from
    the lower rate to 44 kHz before feeding it to the `Sound` object.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sound`类使用44 kHz的采样率。如果麦克风捕获的音频来自不同的频率，那么在将其馈送到`Sound`对象之前，你需要将其从较低的速率提升到44
    kHz。'
- en: 'For example, if the `Microphone` object''s `rate` property was set to a frequency
    of 22 kHz when recording, you would need to adjust the playback loop within `playSampleData()`
    to the following:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果`Microphone`对象的`rate`属性在录制时被设置为22 kHz的频率，那么你需要在`playSampleData()`中的播放循环中进行调整，如下所示：
- en: '[PRE47]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Essentially the same sample is written to each channel twice, which up-scales
    the 22 kHz recording to 44 kHz. Notice that 4096 iterations of the loop are performed
    compared to 8192 previously. This is to ensure that no more than 64 KB of audio
    data is written to the `Sound` object's buffer, which is its upper limit.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，相同的样本被写入每个通道两次，这会将22 kHz的录音提升到44 kHz。请注意，与之前的8192次迭代相比，这里执行了4096次循环迭代。这是为了确保写入到`Sound`对象缓冲区的音频数据不超过64
    KB，这是它的上限。
- en: The example provided here is somewhat simplistic and not recommended for the
    majority of the sample rates. A more thorough approach is to generate the missing
    data by interpolating between existing samples. In most cases, it is likely that
    you will want to avoid re-sampling your audio in realtime as doing so can be computationally
    expensive.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提供的示例相对简单，不推荐用于大多数采样率。更彻底的方法是通过插值现有样本来生成缺失的数据。在大多数情况下，您可能希望避免在实时中重新采样音频，因为这可能会很耗费计算资源。
- en: 'Additional detail regarding sample rate conversion can be found on Wikipedia:
    [http://en.wikipedia.org/wiki/Sample_rate_conversion](http://en.wikipedia.org/wiki/Sample_rate_conversion).
    Also, take a look at the SoundTouch AS3 library, which allows real time audio
    processing using ActionScript 3.0: [https://github.com/also/soundtouch-as3](http://https://github.com/also/soundtouch-as3).'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 关于采样率转换的更多详细信息可以在维基百科上找到：[http://en.wikipedia.org/wiki/Sample_rate_conversion](http://en.wikipedia.org/wiki/Sample_rate_conversion)。此外，还可以查看
    SoundTouch AS3 库，它允许使用 ActionScript 3.0 进行实时音频处理：[https://github.com/also/soundtouch-as3](http://https://github.com/also/soundtouch-as3).
- en: Saving captured data
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保存捕获的数据
- en: This and the previous recipe have simply held the recorded audio data in memory.
    Your application, however, may require recordings to be persistent. Using the
    classes provided in the `flash.filesystem` package, you can write binary data
    to your device and read it back later.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这和之前的配方只是简单地将记录的音频数据保存在内存中。然而，您的应用程序可能需要记录持久化。使用 `flash.filesystem` 包中提供的类，您可以将二进制数据写入您的设备，并在以后读取它。
- en: 'The following code snippet saves our recorded audio to the device:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段将我们的录音保存到设备上：
- en: '[PRE48]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Retrieving the data is just as easy:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 获取数据同样简单：
- en: '[PRE49]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Data written to the file system can only be accessed by the app that placed
    it there. When the app is uninstalled, any data belonging to it is deleted.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 写入文件系统的数据只能由放置它的应用程序访问。当应用程序被卸载时，任何属于它的数据都将被删除。
- en: Exporting as WAV or MP3
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导出为 WAV 或 MP3
- en: For this and the previous recipe, we have simply worked with the raw PCM data
    captured from the microphone. However, you may want to save your data in common
    audio formats such as MP3 and WAV. Unfortunately, AIR does not provide APIs for
    exporting in either of these formats. Instead, you will need to rely on third-party
    libraries.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个和之前的配方，我们只是处理从麦克风捕获的原始 PCM 数据。然而，您可能希望将数据保存为常见的音频格式，如 MP3 和 WAV。不幸的是，AIR
    不提供导出这些格式的 API。相反，您将需要依赖第三方库。
- en: 'WAV encoding is provided by the `WAVWriter` class, which is available at: [http://code.google.com/p/ghostcat/source/browse/trunk/ghostcatfp10/src/ghostcat/media/WAVWriter.as?spec=svn424&r=424](http://code.google.com/p/ghostcat/source/browse/trunk/ghostcatfp10/src/ghostcat/media/WAVWriter.as?spec=svn424&r=424).'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: WAV 编码由 `WAVWriter` 类提供，该类可在以下位置找到：[http://code.google.com/p/ghostcat/source/browse/trunk/ghostcatfp10/src/ghostcat/media/WAVWriter.as?spec=svn424&r=424](http://code.google.com/p/ghostcat/source/browse/trunk/ghostcatfp10/src/ghostcat/media/WAVWriter.as?spec=svn424&r=424).
- en: 'MP3 encoding can be achieved using the Shine library: [https://github.com/kikko/Shine-MP3-Encoder-on-AS3-Alchemy](http://https://github.com/kikko/Shine-MP3-Encoder-on-AS3-Alchemy).'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Shine 库可以实现 MP3 编码：[https://github.com/kikko/Shine-MP3-Encoder-on-AS3-Alchemy](http://https://github.com/kikko/Shine-MP3-Encoder-on-AS3-Alchemy).
- en: See also
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Recording microphone audio*'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*录制麦克风音频*'
- en: '*Controlling audio playback, [Chapter 12](ch12.html "Chapter 12. Working with
    Video and Audio")*'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*控制音频播放，[第 12 章](ch12.html "第 12 章. 与视频和音频一起工作")*'
- en: '*Referencing an app''s common directories, [Chapter 13](ch13.html "Chapter 13. Connectivity,
    Persistence, and URI Schemes")*'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*引用应用程序的常用目录，[第 13 章](ch13.html "第 13 章. 连接性、持久性和 URI 方案")*'
- en: '*Writing files, [Chapter 13](ch13.html "Chapter 13. Connectivity, Persistence,
    and URI Schemes")*'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*写入文件，[第 13 章](ch13.html "第 13 章. 连接性、持久性和 URI 方案")*'
