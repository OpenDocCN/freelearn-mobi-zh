- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Advanced Mobile UI
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级移动UI
- en: In the last chapter, we were introduced to the Unity UI system and how to build
    resolution-independent UI elements, which are useful for all game projects that
    utilize different aspect ratios and resolutions. In this chapter, we will be exploring
    some mobile-specific aspects of working on a UI, such as requiring on-screen controls
    and adapting our UI to fit devices with notches.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了Unity UI系统以及如何构建分辨率无关的UI元素，这对于利用不同宽高比和分辨率的所有游戏项目都很有用。在本章中，我们将探讨一些与UI相关的特定于移动的方面，例如需要屏幕控制以及将我们的UI适配到带有刘海的设备。
- en: 'This chapter will be split into a number of topics. The chapter is a simple
    step-by-step process from beginning to end. The following is the outline of our
    tasks:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将分为多个主题。本章是一个从开始到结束的简单步骤过程。以下是我们任务的概述：
- en: Adding a pause screen button
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加暂停屏幕按钮
- en: Implementing an on-screen joystick
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现屏幕摇杆
- en: Adapting GUIs for notch devices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配带刘海的设备的GUI
- en: Over the course of this chapter, we will take the pause screen that we implemented
    in the previous chapter and adapt it to work on a mobile device. We will then
    implement an on-screen joystick as an additional movement option, and lastly,
    have our UI automatically adapt to fit mobile devices that have notches.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的整个过程中，我们将把我们在上一章中实现的暂停屏幕适配到移动设备上。然后，我们将实现一个屏幕上的摇杆作为额外的移动选项，最后，让我们的UI自动适应带有刘海的移动设备。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This book utilizes Unity 2022.1.0b16 and Unity Hub 3.3.1, but the steps should
    work with minimal changes in future versions of the editor. If you would like
    to download the exact version used in this book, and there is a new version out,
    you can visit Unity’s download archive at [https://unity3d.com/get-unity/download/archive](https://unity3d.com/get-unity/download/archive).
    You can also find the system requirements for Unity at [https://docs.unity3d.com/2022.1/Documentation/Manual/system-requirements.html](https://docs.unity3d.com/2022.1/Documentation/Manual/system-requirements.html)
    in the **Unity Editor system** **requirements**section.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用Unity 2022.1.0b16和Unity Hub 3.3.1，但步骤应该在未来版本的编辑器中只需进行最小更改即可。如果您想下载本书中使用的确切版本，并且有新版本发布，您可以在Unity的下载存档中找到它，地址为[https://unity3d.com/get-unity/download/archive](https://unity3d.com/get-unity/download/archive)。您还可以在**Unity编辑器系统**
    **要求**部分找到Unity的系统要求[https://docs.unity3d.com/2022.1/Documentation/Manual/system-requirements.html](https://docs.unity3d.com/2022.1/Documentation/Manual/system-requirements.html)。
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Unity-2022-Mobile-Game-Development-3rd-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/Unity-2022-Mobile-Game-Development-3rd-Edition/tree/main/Chapter05).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章中存在的代码文件，地址为[https://github.com/PacktPublishing/Unity-2022-Mobile-Game-Development-3rd-Edition/tree/main/Chapter05](https://github.com/PacktPublishing/Unity-2022-Mobile-Game-Development-3rd-Edition/tree/main/Chapter05)。
- en: Adding a pause screen button
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加暂停屏幕按钮
- en: While many mobile games do support controllers through Bluetooth, most, if not
    all, of them allow the users to control the game via just the device. Increasingly,
    many mobile games will include on-screen buttons or analog sticks that players
    can use to control their avatars. In this section, we will see just how we can
    implement that if we wish.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然许多移动游戏都支持通过蓝牙控制器，但其中大多数，如果不是全部，都允许用户仅通过设备来控制游戏。越来越多的移动游戏将包括屏幕按钮或模拟摇杆，玩家可以使用它们来控制他们的角色。在本节中，我们将看到如果我们希望，我们如何实现这一点。
- en: 'To start off, let’s build a pause menu button:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们构建一个暂停菜单按钮：
- en: Since we are going to be creating multiple types of on-screen controls, let’s
    create a panel to hold them all. From the `On Screen Controls`. From the **Inspector**
    view, remove or disable the **Image** component, as we don’t need to see the image.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将要创建多种类型的屏幕控制，让我们创建一个面板来容纳它们。从“屏幕控制”中，从**检查器**视图中移除或禁用**图像**组件，因为我们不需要看到图像。
- en: For this version of our controls, we will be using some 2D sprites to make it
    easier to tell what the various UI elements are. The sprites are included in the
    example code for this book if you’d like to use the exact ones I’m using.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们控制版本的这一版，我们将使用一些2D精灵来使识别各种UI元素更容易。如果您想使用与我使用的完全相同的精灵，这些精灵包含在本书的示例代码中。
- en: From the `Sprites` and drag and drop the image files into the newly added folder.
    Since our project is a 3D one, Unity assumes we want them to be textures, but
    we want to use them with Unity’s UI system. With that in mind, select all three
    sprites. From the **Inspector**, change **Texture Type** to **Sprite (2D and UI)**,
    then scroll all the way down, and then hit the **Apply** button.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `Sprites` 中拖放图像文件到新添加的文件夹中。由于我们的项目是3D的，Unity假设我们想要它们作为纹理，但我们想使用Unity的UI系统。考虑到这一点，选择所有三个精灵。从
    **Inspector** 中，将 **Texture Type** 改为 **Sprite (2D and UI)**，然后滚动到最底部，然后点击 **Apply**
    按钮。
- en: Note
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: The sprites used here are from *Kenney’s Onscreen Controls* pack. There are
    seven other possible styles that you could use, which are available from [https://kenney.nl/assets/onscreen-controls](https://kenney.nl/assets/onscreen-controls).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的精灵来自 *Kenney的Onscreen Controls* 套件。您还可以使用其他七种可能的样式，这些样式可在[https://kenney.nl/assets/onscreen-controls](https://kenney.nl/assets/onscreen-controls)找到。
- en: Now that we have the sprites, let’s build our first UI element, a pause button.
    From the **Hierarchy** view, right-click on the **On Screen Controls** object
    and select **UI** | **Button -** **TextMeshPro**.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了精灵，让我们构建我们的第一个UI元素，一个暂停按钮。从 **Hierarchy** 视图中，右键单击 **On Screen Controls**
    对象，然后选择 **UI** | **Button -** **TextMeshPro**。
- en: Rename the new object `Show Pause Button` and use the **Anchor Presets** menu
    to place the object at the bottom right of the screen (use *Alt*+ *Shift*to set
    **Pivot** and **Position** as well).
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新对象 `Show Pause Button` 重命名，并使用 **Anchor Presets** 菜单将对象放置在屏幕的右下角（使用 *Alt*+
    *Shift* 设置 **Pivot** 和 **Position**）。
- en: '![Figure 5.1 – Bottom-right option](img/B18868_05_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – 右下角选项](img/B18868_05_01.jpg)'
- en: Figure 5.1 – Bottom-right option
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 右下角选项
- en: Then, from the **Image** component, drag and drop our **pauseButton** sprite
    into the **Source Image** property. You’ll notice it’s stretched out, so click
    on the **Set Native Size** button to have the sprite automatically resize itself
    for us.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，从 **Image** 组件中，将我们的 **pauseButton** 精灵拖放到 **Source Image** 属性中。您会注意到它被拉伸了，所以点击
    **Set Native Size** 按钮让精灵自动调整大小。
- en: We don’t actually need the text object included, so select the **Text (TMP)**
    object and hit the *Delete* key.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们实际上不需要包含文本对象，所以选择 **Text (TMP)** 对象并按 *Delete* 键。
- en: '![Figure 5.2 – Creating the pause button](img/B18868_05_02.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 创建暂停按钮](img/B18868_05_02.jpg)'
- en: Figure 5.2 – Creating the pause button
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 创建暂停按钮
- en: Go back and select the `pause`.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回并选择 `pause`。
- en: Go back to **Resume Button** and add another event to its button to turn the
    **Show Pause Menu** button back on when we leave.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到 **Resume Button** 并为其按钮添加另一个事件，当离开时重新开启 **Show Pause Menu** 按钮。
- en: '![Figure 5.3 – Creating the Resume Button click action](img/B18868_05_03.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – 创建恢复按钮点击动作](img/B18868_05_03.jpg)'
- en: Figure 5.3 – Creating the Resume Button click action
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 创建恢复按钮点击动作
- en: Now, we want to remove our on-screen controls whenever we pause the game. This
    can be done through **Inspector**, but we can also do this through code.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们希望在暂停游戏时移除我们的屏幕控制。这可以通过 **Inspector** 完成，但也可以通过代码完成。
- en: 'Open the `PauseScreenBehaviour` script and add the following property to the
    script:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `PauseScreenBehaviour` 脚本，并将以下属性添加到脚本中：
- en: '[PRE0]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Afterward, update the **SetPauseMenu** function to have the following new line:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，更新 **SetPauseMenu** 函数以包含以下新行：
- en: '[PRE1]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that we are using `!paused` and not `paused` like in the previous line.
    The `!` operator will take something that is `true` and make it `false`, and vice
    versa. This will cause the `onScreenControls` window to turn on when the game
    is not paused and off when it is.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用的是 `!paused` 而不是上一行中的 `paused`。`!` 操作符会将 `true` 的值转换为 `false`，反之亦然。这将导致当游戏未暂停时
    `onScreenControls` 窗口打开，当游戏暂停时关闭。
- en: 'Since we are already in the code editor, we can also use this time to fix something
    that will come up later: as mentioned previously, one problem that won’t be apparent
    now unless you restart the level is the fact that `static` variables will keep
    their values each time we reload the game. In our case, we set `paused`, which
    turns `Time.timeScale` to `0`. Thankfully, we can fix this fairly easily.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在代码编辑器中，我们也可以利用这个时间修复将来可能出现的问题：如前所述，一个现在不明显的问题（除非你重新启动关卡）是 `static` 变量会在每次重新加载游戏时保持其值。在我们的例子中，我们设置了
    `paused`，它将 `Time.timeScale` 设置为 `0`。幸运的是，我们可以相当容易地修复这个问题。
- en: 'Open the `PauseScreenBehaviour` script and update the `Start` function to have
    the following, replacing the original line:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `PauseScreenBehaviour` 脚本，并更新 `Start` 函数，替换原始行：
- en: '[PRE2]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Return to Unity and go to the **Pause Screen Handler** object. From the **Pause
    Screen Behaviour** script, set the **On Screen Controls** property to our **On
    Screen** **Controls** object.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到 Unity 并转到 **Pause Screen Handler** 对象。从 **Pause Screen Behaviour** 脚本中，将
    **On Screen Controls** 属性设置为我们的 **On Screen** **Controls** 对象。
- en: '![Figure 5.4 – Updating Pause Screen Behaviour](img/B18868_05_04.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4 – 更新暂停屏幕行为](img/B18868_05_04.jpg)'
- en: Figure 5.4 – Updating Pause Screen Behaviour
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 更新暂停屏幕行为
- en: 'Save your script and the scene, and then play the game:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的脚本和场景，然后玩游戏：
- en: '![Figure 5.5 – The current state of the game](img/B18868_05_05.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5 – 游戏当前状态](img/B18868_05_05.jpg)'
- en: Figure 5.5 – The current state of the game
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 游戏当前状态
- en: The pause menu now works correctly. This is a simple way to add on-screen controls
    to the screen. A more advanced version would be an analog stick that we can use
    to control the player’s movement. Let’s tackle that next.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 暂停菜单现在工作正常。这是一种简单的方法将屏幕控制添加到屏幕上。更高级的版本将是一个我们可以用来控制玩家移动的模拟摇杆。让我们接下来处理这个问题。
- en: Implementing an on-screen joystick
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现屏幕摇杆
- en: 'To implement this on-screen joystick, we will utilize two images: a background
    image and then a joystick image placed on top of it. We will then write code to
    allow the player to simulate that they are physically moving the joystick. Later,
    we learn how we can have the simulated joystick actually affect the game properly:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个屏幕摇杆，我们将利用两个图像：一个背景图像，然后是一个放置在背景图像上的摇杆图像。然后我们将编写代码，允许玩家模拟他们正在物理移动摇杆。稍后，我们将学习如何让模拟摇杆正确地影响游戏：
- en: Right-click on the `Joystick Background`.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击 `Joystick Background`。
- en: From the `analogStickBackground` sprite and click on the **Set Native** **Size**
    button.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `analogStickBackground` 精灵处点击**设置原生** **大小**按钮。
- en: From the **Rect Transform** component, hold down *Alt* **+** *Shift* and use
    the **Anchor Presets** menu to move **Joystick Background** to the bottom-left
    option.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **Rect Transform** 组件中，按住 *Alt* **+** *Shift* 并使用 **Anchor Presets** 菜单将 **Joystick
    Background** 移动到底部左选项。
- en: Next, right-click on the `Joystick`.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，右键点击 `Joystick`。
- en: From the `analogStick` sprite and click on the **Set Native** **Size** button.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `analogStick` 精灵处点击**设置原生** **大小**按钮。
- en: '![Figure 5.6 – Creating the Joystick UI](img/B18868_05_06.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – 创建摇杆 UI](img/B18868_05_06.jpg)'
- en: Figure 5.6 – Creating the Joystick UI
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 创建摇杆 UI
- en: We want this joystick to move, so to do that, we will create a new script. From
    the `Scripts` folder and create a new C# script called `MobileJoystick`. Then,
    attach the `MobileJoystick` script to the `Joystick` object.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望这个摇杆可以移动，因此为了做到这一点，我们将创建一个新的脚本。从 `Scripts` 文件夹中创建一个新的 C# 脚本，命名为 `MobileJoystick`。然后，将
    `MobileJoystick` 脚本附加到 `Joystick` 对象上。
- en: 'Open your code editor to the `MobileJoystick` script and add the following
    properties and initialization of those properties in the `Start` function:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开代码编辑器，定位到 `MobileJoystick` 脚本，并在 `Start` 函数中添加以下属性及其初始化：
- en: '[PRE3]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To have the joystick do something when we are dragging it, we can add an interface
    to our script for when we are dragging and when we stop. To do so, we need to
    add the following `using` statement to the top of our script:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在拖动摇杆时让摇杆执行某些操作，我们可以在脚本中添加一个接口，用于拖动和停止拖动时。为此，我们需要在脚本顶部添加以下 `using` 语句：
- en: '[PRE4]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After that, we add the following bold code to the class definition:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们在类定义中添加以下加粗代码：
- en: '[PRE5]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we will get some errors because we haven’t actually defined the functions
    given in the interfaces, let’s do that now:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们会得到一些错误，因为我们还没有实际定义接口中给出的函数，让我们现在就定义它们：
- en: '[PRE6]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Save your script and return to the Unity editor. Play the game and try to click
    and drag the analog sticks:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的脚本并返回到 Unity 编辑器。玩游戏并尝试点击并拖动模拟摇杆：
- en: '![Figure 5.7 – Joysticks can now be moved](img/B18868_05_07.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.7 – 摇杆现在可以移动](img/B18868_05_07.jpg)'
- en: Figure 5.7 – Joysticks can now be moved
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 – 摇杆现在可以移动
- en: 'Now that they functionally work, let’s have them actually affect the game.
    We need to have some way to communicate the information that `MobileJoystick`
    has. To do this, let’s add a new property:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在它们功能上已经工作，让我们让它们真正影响游戏。我们需要有一种方式来传达 `MobileJoystick` 的信息。为此，让我们添加一个新的属性：
- en: '[PRE7]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, add the following line to the `OnDrag` function:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将以下行添加到 `OnDrag` 函数中：
- en: '[PRE8]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, add the following line to the `OnEndDrag` function:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将以下行添加到 `OnEndDrag` 函数中：
- en: '[PRE9]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now we need to go to the `PlayerBehaviour` script. From there, we will add
    a new variable to tell us whether we have a `MobileJoystick` or not:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要进入`PlayerBehaviour`脚本。从那里，我们将添加一个新变量来告诉我们是否有`MobileJoystick`：
- en: '[PRE10]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This way, if the player has turned off `MobileJoystick`, we still want the game
    to work.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样，如果玩家已经关闭了`MobileJoystick`，我们仍然希望游戏能够运行。
- en: 'Next, we will need to update the `FixedUpdate` function to have the following
    changes:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新`FixedUpdate`函数，进行以下更改：
- en: '[PRE11]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Save your scripts and return to the Unity editor. Save your scene and then
    play the game:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的脚本并返回到Unity编辑器。保存你的场景然后玩游戏：
- en: '![Figure 5.8 – Joystick moving the player](img/B18868_05_08.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图5.8 – 操纵杆移动玩家](img/B18868_05_08.jpg)'
- en: Figure 5.8 – Joystick moving the player
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8 – 操纵杆移动玩家
- en: In this way, if we have the joystick enabled when the game starts, the game
    will use it to move the player. Alternatively, you can disable the joystick and
    your game will work in the same way as before.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，如果我们游戏开始时启用了操纵杆，游戏将使用它来移动玩家。或者，你也可以禁用操纵杆，你的游戏将和之前一样工作。
- en: At this point, our UI should work for the vast majority of cell phones. However,
    there are certain phones that contain “notches.” We will see how to adjust our
    UI for that in the next section.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们的用户界面应该适用于绝大多数手机。然而，有一些手机含有“刘海”。我们将在下一节中看到如何调整我们的用户界面以适应这种情况。
- en: Adapting GUIs for notch devices
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适应刘海设备GUI
- en: Since the first edition of this book, there have been many phones that have
    come out with sensor housings, more commonly known as “notches.” Made popular
    with the iPhone X, this has grown to be a part of many phones that are out right
    now. While some people online state that entire-screen displays are the future,
    iOS devices, Android devices running 9.0 and above, and Unity have added support
    for notches built into devices, and we can use the `Screen.safeArea`property in
    Unity to ensure that all of our content is visible.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 自从这本书的第一版以来，已经有许多手机推出了传感器外壳，更常见的是“刘海”。随着iPhone X的流行，这已经成为现在许多手机的一部分。尽管有些人在线上声称全面屏显示是未来，但iOS设备、运行9.0及以上版本的Android设备和Unity都添加了对设备内置刘海的支持，我们可以在Unity中使用`Screen.safeArea`属性来确保所有内容都可见。
- en: 'To get started, we will first go to the main menu to tweak the menu text:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们将首先进入主菜单来调整菜单文本：
- en: Go to the `MainMenu` Scene in the `Scenes` folder. In the *Adding a pause menu*section,
    we saw how we can use the **Panel** object in order to hold the contents we want
    to display. We will use this concept to account for the safe area.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`Scenes`文件夹中的`MainMenu`场景。在*添加暂停菜单*部分，我们看到了如何使用**Panel**对象来包含我们想要显示的内容。我们将使用这个概念来处理安全区域。
- en: With the level opened, go to the **Hierarchy** view and create a child panel
    for our title screen to be inside by right-clicking on the **Canvas - Scale w/Screen**
    object and selecting **UI |** **Panel**.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在打开关卡后，转到**层次**视图，通过右键单击**Canvas - Scale w/Screen**对象并选择**UI |** **Panel**来为我们的标题屏幕创建一个子面板。
- en: 'Afterward, make **Title Text** a child of the newly created panel by dragging
    and dropping the object on top of the newly created **Panel** object:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，通过拖放对象到新创建的**Panel**对象上，将**Title Text**设置为新创建面板的子项：
- en: '![Figure 5.9 – SafeArea setup](img/B18868_05_09.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图5.9 – 安全区域设置](img/B18868_05_09.jpg)'
- en: Figure 5.9 – SafeArea setup
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9 – 安全区域设置
- en: 'From the `Scripts``UISafeAreaHandler`. Double-click on it to open your code
    editor and use the following code:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Scripts``UISafeAreaHandler`。双击它以打开你的代码编辑器并使用以下代码：
- en: '[PRE12]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `Screen.safeArea` property returns a variable of the `Rect` type, which
    contains an X and Y position and a width and height, just like the `Screen.safeArea`
    will just return `Rect(0, 0, Screen.width, Screen.height)`, which will work due
    to the lack of a notch.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`Screen.safeArea`属性返回一个`Rect`类型的变量，它包含X和Y位置以及宽度和高度，就像`Screen.safeArea`将只返回`Rect(0,
    0, Screen.width, Screen.height)`，由于没有刘海，这将有效。'
- en: '`Screen.safeArea``Update` function to do modifications.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Screen.safeArea``Update`函数进行修改。
- en: We previously saw that anchors can be used to specify the size of a panel. Anchors
    work in viewport space, which is to say that the values go from `(0, 0)` to `(1,
    1)`. Since the `Rect``Screen.safeArea`is in screen (pixel) space, we divide by
    the screen size in pixels to convert to the points to viewport space.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到锚点可以用来指定面板的大小。锚点在视口空间中工作，也就是说，值从`(0, 0)`到`(1, 1)`。由于`Rect``Screen.safeArea`在屏幕（像素）空间中，我们通过像素屏幕大小来除以转换为视口空间的点。
- en: Save the script and return to the Unity Editor. Then, attach the **UI Safe Area
    Handler** component to the **Panel** object that we just created.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本并返回 Unity 编辑器。然后，将 **UI 安全区域处理器** 组件附加到我们刚刚创建的 **Panel** 对象上。
- en: 'Return to the Unity editor and transition to the `Screen.safeArea` property,
    you should notice the panel tweak its size appropriately to fit everything within
    our screen:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 Unity 编辑器并切换到 `Screen.safeArea` 属性，你应该会注意到面板会相应地调整其大小以适应我们的屏幕：
- en: '![Figure 5.10 – Adjusting the notch value](img/B18868_05_10.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.10 – 调整缺口值](img/B18868_05_10.jpg)'
- en: Figure 5.10 – Adjusting the notch value
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10 – 调整缺口值
- en: The **Device Simulator** is a tool that aims to allow developers to see what
    their game will look like on many devices. For more information on it, check out
    [https://docs.unity3d.com/Manual/device-simulator-view.html](https://docs.unity3d.com/Manual/device-simulator-view.html).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**设备模拟器** 是一个旨在让开发者看到他们的游戏在许多设备上看起来如何的工具。有关更多信息，请参阅 [https://docs.unity3d.com/Manual/device-simulator-view.html](https://docs.unity3d.com/Manual/device-simulator-view.html)。'
- en: 'In portrait mode, the top portion of the screen is cut off for the notch and
    the bottom is cut off for the home button. We can also click on the buttons next
    to the **Rotate** text to see how our game will look on the device facing the
    other direction:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在竖屏模式下，屏幕顶部被切断以适应缺口，底部被切断以适应主页按钮。我们还可以点击 **Rotate** 文字旁边的按钮，看看我们的游戏在另一侧面对的设备上的样子：
- en: '![Figure 5.11 – Landscape mode](img/B18868_05_11.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.11 – 横屏模式](img/B18868_05_11.jpg)'
- en: Figure 5.11 – Landscape mode
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11 – 横屏模式
- en: Switching to landscape mode, we lose the left/right side for the notch, and
    on iOS, it cuts off the other side as well. Just as in portrait mode, the top
    is cut off for the home button.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到横屏模式，我们失去了缺口左右两侧的空间，在 iOS 上，它还会切断另一侧。就像在竖屏模式下一样，顶部会被切断以适应主页按钮。
- en: With this, we see that the menu adjusts itself correctly! However, there is
    a chance that the **Play** button no longer works. This is because both of our
    **Canvas** objects are drawn in the same sorting order, which means either can
    be on top of the other, similar to the concept of Z-fighting that you may know
    of if you’ve worked on 2D games in the past. Thankfully, we can fix that pretty
    easily.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们可以看到菜单正确地调整了自己！然而，有可能 **Play** 按钮不再工作。这是因为我们的两个 **Canvas** 对象都绘制在相同的排序顺序中，这意味着它们可以相互覆盖，类似于如果你过去在
    2D 游戏中工作过的 Z-fighting 概念。幸运的是，我们可以很容易地解决这个问题。
- en: Select the `-1`. The button with a `0` will always be on top of the contents
    of this Canvas.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `-1`。带有 `0` 的按钮将始终位于此 Canvas 内容的顶部。
- en: While the semi-transparent white panel is useful in illustrating the concept,
    we don’t actually want our users to see it when the game is being played. With
    that in mind, let’s turn off the image.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然半透明的白色面板在说明概念时很有用，但我们不希望用户在游戏进行时看到它。考虑到这一点，让我们关闭图像。
- en: Select the **Panel** object. From the **Image** component, uncheck the checkbox
    to the left of the component’s name to disable it.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **Panel** 对象。从 **Image** 组件中，取消勾选组件名称左侧的复选框以禁用它。
- en: Tip
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you wanted to still have the image visible and have the button still work,
    you can instead uncheck the **Raycast** **Target** property.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然希望图像可见并且按钮仍然可以工作，你可以取消勾选 **Raycast** **Target** 属性。
- en: 'Now that the first Canvas is completed, we can now do the same actions for
    the other one:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在第一个 Canvas 已经完成，我们也可以对另一个 Canvas 执行相同的操作：
- en: 'Go to the **Canvas - Scale Physical** component and create another **Panel**
    object with the **UI Safe Area Handler** component attached to it, making sure
    to disable the **Image** component. Next, make the **Play** button a child of
    it:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 **Canvas - Scale Physical** 组件，并创建另一个带有 **UI 安全区域处理器** 组件的 **Panel** 对象，确保禁用
    **Image** 组件。接下来，将 **Play** 按钮设置为它的子对象：
- en: "![Figure 5.12 – Adjusting the\uFEFF Safe Area Handler](img/B18868_05_12.jpg)"
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.12 – 调整安全区域处理器](img/B18868_05_12.jpg)'
- en: Figure 5.12 – Adjusting the Safe Area Handler
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12 – 调整安全区域处理器
- en: Save your Scene. Now that we have the main menu completed, we can tweak the
    `Gameplay` Scene as well.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的场景。现在我们已经完成了主菜单，我们也可以调整 `Gameplay` 场景。
- en: 'Open the `Gameplay` Scene, select the **On Screen Controls** object, and then
    just add the **UI Safe Area Handler** component to it:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Gameplay` 场景，选择 **On Screen Controls** 对象，然后只需将其 **UI 安全区域处理器** 组件添加到它上：
- en: '![Figure 5.13 – Making the On Screen Controls use the UI Safe Area](img/B18868_05_13.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.13 – 使屏幕控制使用 UI 安全区域](img/B18868_05_13.jpg)'
- en: Figure 5.13 – Making the On Screen Controls use the UI Safe Area
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.13 – 使屏幕控制使用UI安全区域
- en: To adjust the **Pause Menu**, we don’t want to change the **Pause Menu** object
    as we want the black screen even in the notch areas. We have previously created
    a panel to hold the contents of the pause menu, but that object is using the **Aspect
    Ratio Fitter**, which will overwrite any anchor changes we would make in the code.
    To keep this functionality as well as **Content Size Fitters** in the child objects,
    we can just create a parent panel to act as a holder.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要调整**暂停菜单**，我们不想改变**暂停菜单**对象，因为我们希望在缺口区域也有黑色屏幕。我们之前创建了一个面板来存放暂停菜单的内容，但该对象正在使用**宽高比适配器**，这将会覆盖我们在代码中做出的任何锚点更改。为了保持这种功能以及子对象中的**内容大小适配器**，我们只需创建一个父面板来充当容器。
- en: 'Make the **Pause Menu** object active again by selecting it in the **Hierarchy**
    window and then clicking on the checkbox by its name in the **Inspector** window.
    Right-click on the **Panel** object and create a **Panel** object by right-clicking
    and selecting **UI | Panel**. In the new panel, add the **UI Safe Area Handler**
    component and disable the **Image** component:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在**层次结构**窗口中选择它并然后在**检查器**窗口中点击其名称旁边的复选框来使**暂停菜单**对象再次激活。在**面板**对象上右键单击，并通过右键单击并选择**UI
    | 面板**来创建一个新的**面板**对象。在新面板中，添加**UI安全区域处理器**组件并禁用**图像**组件：
- en: '![Figure 5.14 – Adjusting the Pause Menu to work with notches](img/B18868_05_14.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图5.14 – 调整暂停菜单以适应缺口](img/B18868_05_14.jpg)'
- en: Figure 5.14 – Adjusting the Pause Menu to work with notches
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.14 – 调整暂停菜单以适应缺口
- en: Finally, since we are not working with the **Pause Menu** object anymore, select
    the **Pause Menu** object from the **Hierarchy** window, and in the **Inspector**
    window, uncheck the checkbox by the name to disable the object.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，由于我们不再与**暂停菜单**对象一起工作，请从**层次结构**窗口中选择**暂停菜单**对象，然后在**检查器**窗口中，取消选中该名称旁边的复选框以禁用对象。
- en: 'Save your Scene and play the game:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存您的场景并播放游戏：
- en: '![Figure 5.15 – UI now responds correctly to notches](img/B18868_05_15.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图5.15 – UI现在正确响应缺口](img/B18868_05_15.jpg)'
- en: Figure 5.15 – UI now responds correctly to notches
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.15 – UI现在正确响应缺口
- en: As you can see, if we hold down the spacebar, we can see both menus working
    correctly!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，如果我们按住空格键，我们可以看到两个菜单都在正确工作！
- en: Summary
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we integrated the pause menu into our game itself and made
    it work with everything in our project. We then saw how we could create on-screen
    controls to give players another way to interact with the game using mobile devices.
    Finally, we saw how to have our game automatically adapt to fit within the allotted
    safe areas to handle the notches on phones. We will be exploring the previous
    concepts more deeply in later chapters, so keep these explanations in mind.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将暂停菜单整合到我们的游戏本身中，并使其与我们的项目中的所有内容协同工作。然后我们看到了如何创建屏幕控制，以便玩家可以使用移动设备以另一种方式与游戏互动。最后，我们看到了如何让我们的游戏自动适应以适应分配的安全区域，以处理手机上的缺口。我们将在后面的章节中更深入地探讨这些概念，所以请记住这些解释。
- en: In the next chapter, we will dive into monetization and take a look at just
    how we can add Unity ads to our project.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨盈利模式，并看看我们如何将Unity广告添加到我们的项目中。
