- en: Chapter 12. Working with Closures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 12 章。使用闭包
- en: Today, most major programming languages have functionalities similar to what
    closures offer. Some of these implementations are really hard to use (Objective-C
    blocks), while others are easy (Java lambda and C# delegates). I found that the
    functionality that closures provide is especially useful when developing frameworks.
    I have also used them extensively when communicating with remote services over
    a network connection. While blocks in Objective-C are incredibly useful (and I
    used them quite a bit), their syntax used to declare a block was absolutely horrible.
    Luckily, when Apple was developing the Swift language, they made the syntax of
    closures much easier to use and understand.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，大多数主要的编程语言都有类似于闭包提供的功能。其中一些实现非常难以使用（Objective-C blocks），而其他则很容易（Java lambda
    和 C# delegates）。我发现闭包提供的功能在开发框架时特别有用。我还在通过网络连接与远程服务通信时广泛使用了它们。虽然 Objective-C 中的
    blocks 非常有用（我相当多地使用了它们），但它们用于声明 block 的语法绝对糟糕。幸运的是，当 Apple 开发 Swift 语言时，他们使闭包的语法更容易使用和理解。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: An introduction to closures
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭包简介
- en: Defining a closure
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义闭包
- en: Using a closure
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用闭包
- en: Several useful examples of closures
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭包的一些有用示例
- en: How to avoid strong reference cycles with closures
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何避免闭包中的强引用循环
- en: An introduction to closures
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 闭包简介
- en: Closures are self-contained blocks of code that can be passed around and used
    throughout our application. We can think of an int type as a type that stores
    an integer and a string type as a type that stores a string. In this context,
    a closure can be thought of as a type that holds a block of code. What this means
    is that we can assign closures to a variable, pass them as arguments to functions,
    and also return functions from them.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包是自包含的代码块，可以在我们的应用程序中传递和使用。我们可以将 int 类型视为存储整数的类型，而将 string 类型视为存储字符串的类型。在这种情况下，闭包可以被视为一个包含代码块的类型。这意味着我们可以将闭包赋值给变量，将它们作为函数的参数传递，也可以从它们中返回函数。
- en: Closures have the ability to capture and store references to any variable or
    constant from the context in which they were defined. This is known as closing
    over the variables or constants, and the best thing is, for the most part, Swift
    will handle the memory management for us. The only exception is when we create
    a strong reference cycle, and we will look at how to resolve this in the *Creating
    strong reference cycles with closures* section of this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包能够捕获并存储它们定义上下文中任何变量或常量的引用。这被称为覆盖变量或常量，最好的是，在大多数情况下，Swift 会为我们处理内存管理。唯一的例外是我们创建强引用循环，我们将在本章的
    *创建闭包中的强引用循环* 部分中探讨如何解决这个问题。
- en: 'Closures in Swift are similar to blocks in Objective-C; however, closures in
    Swift are a lot easier to use and understand. Let''s look at the syntax used to
    define a closure in Swift:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 中的闭包与 Objective-C 中的 blocks 类似；然而，Swift 中的闭包更容易使用和理解。让我们看看定义 Swift 中闭包所使用的语法：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As we can see, the syntax used to create a closure looks very similar to the
    syntax we use to create functions in Swift, and actually, in Swift, global and
    nested functions are closures. The biggest difference in the format between closures
    and functions is the `in` keyword. The `in` keyword is used in place of curly
    brackets to separate the definition of the closure's parameter and return types
    from the body of the closure.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，创建闭包所使用的语法与我们在 Swift 中创建函数所使用的语法非常相似，实际上，在 Swift 中，全局和嵌套函数都是闭包。闭包和函数之间格式上的最大区别是
    `in` 关键字。`in` 关键字用于代替花括号，将闭包的参数和返回类型的定义与闭包体部分隔开。
- en: There are many uses for closures and we will go over a number of them later
    in this chapter, but first we need to understand the basics of closures. Let's
    start by looking at some very basic uses for closures so that we can get a better
    understanding of what they are, how to define them, and how to use them.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包有许多用途，我们将在本章后面详细讨论它们，但首先我们需要了解闭包的基本知识。让我们先看看一些非常基础的闭包用法，以便我们更好地理解它们是什么，如何定义它们，以及如何使用它们。
- en: Simple closures
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单闭包
- en: 'We will begin by creating a very simple closure that does not accept any arguments
    and does not return any value. All it does is print `Hello World` to the console.
    Let''s take a look at the following code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从创建一个非常简单的闭包开始，这个闭包不接受任何参数，也不返回任何值。它所做的只是将 `Hello World` 打印到控制台。让我们看看以下代码：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, we create a closure and assign it to the constant `clos1`.
    Since there are no parameters defined between the parentheses, this closure will
    not accept any parameters. Also, the return type is defined as `Void`; therefore,
    this closure will not return any value. The body of the closure contains one line
    that prints `Hello World` to the console.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个闭包并将其赋值给常量 `clos1`。由于括号之间没有定义任何参数，这个闭包将不接受任何参数。此外，返回类型被定义为 `Void`；因此，这个闭包不会返回任何值。闭包的主体包含一行代码，将
    `Hello World` 打印到控制台。
- en: 'There are many ways to use closures; in this example, all we want to do is
    execute it. We would execute this closure like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用闭包的方法有很多；在这个例子中，我们只想执行它。我们将像这样执行这个闭包：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When we execute the closure, we will see that `Hello World` is printed to the
    console. At this point, closures may not seem that useful, but as we get further
    along in this chapter, we will see how useful and powerful they can be.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行闭包时，我们会看到 `Hello World` 被打印到控制台。在这个时候，闭包可能看起来并不那么有用，但随着我们继续阅读本章，我们将看到它们是多么有用和强大。
- en: 'Let''s look at another simple closure example. This closure will accept one
    string parameter named `name`, but will still not return a value. Within the body
    of the closure, we will print out a greeting to the name passed into the closure
    through the `name` parameter. Here is the code for this second closure:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个简单的闭包示例。这个闭包将接受一个名为 `name` 的字符串参数，但仍然不会返回任何值。在闭包的主体内部，我们将通过 `name` 参数打印出对传递给闭包的名称的问候语。以下是第二个闭包的代码：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The big difference between `clos2` defined in this example and the previous
    `clos1` closure is that we define a single string parameter between the parentheses
    in this closure. As we can see, we define parameters for closures just like we
    define parameters for functions.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 与这个例子中定义的 `clos2` 和之前的 `clos1` 闭包相比，最大的不同之处在于我们在闭包中定义了一个单独的字符串参数。正如我们所看到的，我们定义闭包参数的方式就像定义函数参数一样。
- en: 'We can execute this closure in the same way in which we executed `clos1`. The
    following code shows how this is done:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用执行 `clos1` 的相同方式执行这个闭包。以下代码显示了如何做到这一点：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This example, when executed, will print the message `Hello Jon` to the console.
    Let's look at another way we can use the `clos2` closure.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行这个例子时，它将在控制台打印消息 `Hello Jon`。让我们看看另一种使用 `clos2` 闭包的方法。
- en: 'Our original definition of closures stated, "Closures are self-contained blocks
    of code that can be passed around and used throughout our application code". What
    this tells us is that we can pass our closure from the context that they were
    created in other parts of our code. Let''s look at how to pass our `clos2` closure
    into a function. We will define the function that accepts our `clos2` closure
    like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对闭包的原始定义是，“闭包是自包含的代码块，可以在我们的应用程序代码中传递和使用”。这告诉我们，我们可以将我们的闭包从它们被创建的上下文中传递到代码的其他部分。让我们看看如何将我们的
    `clos2` 闭包传递给一个函数。我们将定义一个接受我们的 `clos2` 闭包的函数，如下所示：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We define the function just like we would any other function; however, in our
    parameter list, we define a parameter named `handler`, and the type defined for
    the handler parameter is `(String)->Void`. If we look closely, we can see that
    the `(String)->Void` definition of the `handler` parameter matches the parameter
    and return types that we defined for `clos2` closure. This means that we can pass
    the `clos2` closure into the function. Let''s look at how to do this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义函数的方式就像定义任何其他函数一样；然而，在我们的参数列表中，我们定义了一个名为 `handler` 的参数，并为 `handler` 参数定义的类型是
    `(String)->Void`。如果我们仔细观察，我们可以看到 `handler` 参数的 `(String)->Void` 定义与为我们定义的 `clos2`
    闭包的参数和返回类型相匹配。这意味着我们可以将 `clos2` 闭包传递给函数。让我们看看如何做到这一点：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We call the `testClosure()` function just like any other function and the closure
    that is being passed in looks like any other variable. Since the `clos2` closure
    executed in the `testClosure()` function, we will see the message, `Hello Dasher`,
    printed to the console when this code is executed.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像调用任何其他函数一样调用 `testClosure()` 函数，传入的闭包看起来就像任何其他变量。由于 `clos2` 闭包在 `testClosure()`
    函数中执行，因此当这段代码执行时，我们将看到消息 `Hello Dasher` 被打印到控制台。
- en: As we will see a little later in this chapter, the ability to pass closures
    to functions is what makes closures so exciting and powerful.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在本章稍后看到的那样，将闭包传递给函数的能力使得闭包变得如此令人兴奋和强大。
- en: 'As the final piece to the closure puzzle, let''s look at how to return a value
    from a closure. The following example shows this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 作为闭包问题的最后一部分，让我们看看如何从闭包中返回一个值。以下示例展示了这一点：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The definition of the `clos3` closure looks very similar to how we defined
    the `clos2` closure. The difference is that we changed the `Void` return type
    to a `String` type. Then, in the body of the closure, instead of printing the
    message to the console, we used the return statement to return the message. We
    can now execute the `clos3` closure just like the previous two closures or pass
    the closure to a function like we did with the `clos2` closure. The following
    example shows how to execute `clos3` closure:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`clos3` 闭包的定义看起来与我们定义 `clos2` 闭包的方式非常相似。区别在于我们将 `Void` 返回类型更改为 `String` 类型。然后，在闭包的主体中，我们不是将消息打印到控制台，而是使用返回语句返回消息。现在我们可以像前两个闭包一样执行
    `clos3` 闭包，或者像 `clos2` 闭包一样将其传递给函数。以下示例展示了如何执行 `clos3` 闭包：'
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After this line of code is executed, the message variable will contain the `Hello
    Buddy` string.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这一行代码后，`message` 变量将包含 `Hello Buddy` 字符串。
- en: The previous three examples of closures demonstrate the format and how to define
    a typical closure. Those who are familiar with Objective-C can see that the format
    of closures in Swift is a lot cleaner and easier to use. The syntax for creating
    closures that we have shown so far in this chapter is pretty short; however, we
    can shorten it even more. In this next section, we will look at how to do this.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的三个闭包示例展示了闭包的格式以及如何定义一个典型的闭包。熟悉 Objective-C 的人可以注意到 Swift 中闭包的格式要干净得多，也更容易使用。在本章中我们展示的创建闭包的语法相当简短；然而，我们还可以进一步缩短它。在接下来的这一节中，我们将探讨如何做到这一点。
- en: Shorthand syntax for closures
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 闭包的简写语法
- en: In this section, we will look at a couple of ways to shorten the definition
    of closures.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨几种缩短闭包定义的方法。
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Using the shorthand syntax for closures is really a matter of personal preference.
    There are a lot of developers that like to make their code as small and compact
    as possible and they take great pride in doing so. However, at times, this can
    make code hard to read and understand by other developers.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用闭包的简写语法完全是个人喜好问题。有很多开发者喜欢把他们的代码写得尽可能小和紧凑，并且为此感到非常自豪。然而，有时这可能会让其他开发者难以阅读和理解代码。
- en: 'The first shorthand syntax for closures that we are going to look at is one
    of the most popular and is the syntax we saw when we were using algorithms with
    arrays in [Chapter 3](ch03.html "Chapter 3. Using Collections and Cocoa Data Types"),
    *Using Collections and Cocoa Data Types*. This format is mainly used when we want
    to send a really small (usually one line) closure to a function, like we did with
    the algorithms for arrays. Before we look at this shorthand syntax, we need to
    write a function that will accept a closure as a parameter:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的第一个闭包简写语法是最受欢迎的，也是我们在使用数组中的算法时看到的语法，即 [第 3 章](ch03.html "第 3 章。使用集合和
    Cocoa 数据类型")，*使用集合和 Cocoa 数据类型*。这种格式主要在我们想要向函数发送一个非常小的闭包（通常是一行）时使用，就像我们使用数组算法那样。在我们查看这种简写语法之前，我们需要编写一个函数，该函数将接受一个闭包作为参数：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This function accepts two parameters—the first parameter is an integer named
    `num`, and the second parameter is a closure named `handler` that does not have
    any parameters and does not return any value. Within the function, we create a
    `for` loop that will use the `num` integer to define how many times it loops.
    Within the `for` loop, we call the `handler` closure that was passed into the
    function.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受两个参数——第一个参数是一个名为 `num` 的整数，第二个参数是一个名为 `handler` 的闭包，该闭包没有参数且不返回任何值。在函数内部，我们创建一个
    `for` 循环，该循环将使用 `num` 整数来定义循环的次数。在 `for` 循环中，我们调用传递给函数的 `handler` 闭包。
- en: 'We can create a closure and pass it to the `testFunction()` like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个闭包，并将其像这样传递给 `testFunction()`：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This code is very easy to read and understand; however, it does take five lines
    of code. Now, let''s look at how to shorten this code by writing the closure inline
    within the function call:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码非常容易阅读和理解；然而，它需要五行代码。现在，让我们看看如何通过在函数调用内编写闭包来缩短这段代码：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, we created the closure inline within the function call using
    the same syntax that we used with the algorithms for arrays. The closure is placed
    in between two curly brackets (`{}`), which means the code to create our closure
    is `{print("Hello from Shorthand closure")}`. When this code is executed, it will
    print out the message, `Hello from Shorthand closure`, five times on the screen.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用与数组算法相同的语法，在函数调用内联创建闭包。闭包放置在两个花括号（`{}`）之间，这意味着创建我们的闭包的代码是 `{print("Hello
    from Shorthand closure")}`。当这段代码执行时，它将在屏幕上打印出消息，`Hello from Shorthand closure`，五次。
- en: 'In [Chapter 3](ch03.html "Chapter 3. Using Collections and Cocoa Data Types"),
    *Using Collections and Cocoa Data Types*, we saw that we were able to pass parameters
    to the array algorithms using the `$0`, `$1`, `$2`, and so on parameters. Let''s
    look at how to use parameters with this shorthand syntax. We will begin by creating
    a new function that will accept a closure with a single parameter. We will name
    this function `testFunction2`. The following example shows what the new `testFunction2`
    function does:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 3 章](ch03.html "第 3 章。使用集合和 Cocoa 数据类型")，*使用集合和 Cocoa 数据类型* 中，我们看到了我们可以使用
    `$0`、`$1`、`$2` 等参数将参数传递给数组算法。让我们看看如何使用简写语法来使用参数。我们将首先创建一个新的函数，该函数将接受一个带有单个参数的闭包。我们将把这个函数命名为
    `testFunction2`。以下示例显示了新的 `testFunction2` 函数的作用：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In `testFunction2`, we define our closure like this: `(name: String)->Void`.
    This definition means that the closure accepts one parameter and does not return
    any value. Now, let''s see how to use the same shorthand syntax to call this function:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '在 `testFunction2` 函数中，我们这样定义我们的闭包：`(name: String)->Void`。这个定义意味着闭包接受一个参数并且不返回任何值。现在，让我们看看如何使用相同的简写语法来调用这个函数：'
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The difference between this closure definition and the previous one is `$0`.
    The `$0` parameter is shorthand for the first parameter passed into the function.
    If we execute this code, it prints out the message, `Hello from Me`, five times.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个闭包定义与上一个定义之间的区别在于 `$0`。`$0` 参数是传递给函数的第一个参数的简写。如果我们执行这段代码，它将打印出消息，`Hello from
    Me`，五次。
- en: 'Using the dollar sign (`$`) followed by a number with inline closures allows
    us to define the closure without having to put a parameter list in the definition.
    The number after the dollar sign defines the position of the parameter in the
    parameter list. Let''s examine this format a bit more because we are not limited
    to only using the dollar sign (`$`) and number shorthand format with inline closures.
    This shorthand syntax can also be used to shorten the closure definition by allowing
    us to leave the parameter names off. The following example demonstrates this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用美元符号（`$`）后跟一个数字的简写语法允许我们在不将参数列表放入定义的情况下定义闭包。美元符号后面的数字定义了参数在参数列表中的位置。让我们更详细地检查这个格式，因为我们不仅限于在简写闭包中使用美元符号（`$`）和数字简写格式。这种简写语法还可以用来缩短闭包定义，允许我们省略参数名称。以下示例演示了这一点：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this example, our closure has two string parameters defined; however, we
    do not give them names. The parameters are defined like this: `(String, String)`.
    We can then access the parameters within the body of the closure using `$0` and
    `$1`. Also, note that closure definition is after the colon (`:`), using the same
    syntax that we use to define a variable type, rather than inside the curly brackets.
    When we use anonymous arguments, this is how we would define the closure. It will
    not be valid to define the closure like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们的闭包定义了两个字符串参数，但我们没有给它们命名。参数的定义如下：`(String, String)`。我们可以在闭包体内部使用 `$0`
    和 `$1` 访问这些参数。此外，请注意，闭包的定义是在冒号（`:`）之后，使用与定义变量类型相同的语法，而不是在花括号内。当我们使用匿名参数时，这就是我们定义闭包的方式。以下定义方式是不正确的：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this example, we will receive the `Anonymous closure arguments cannot be
    used inside a closure that has explicit arguments` error.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将收到 `匿名闭包参数不能在具有显式参数的闭包中使用` 错误。
- en: 'We will use the `clos5` closure like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将像这样使用 `clos5` 闭包：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Since `Hello` is the first string in the parameter list, it is accessed with
    `$0`, and as `Kara` is the second string in the parameter list, it is accessed
    with `$1`. When we execute this code, we will see the message, `Hello Kara`, printed
    to the console.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Hello` 是参数列表中的第一个字符串，因此它使用 `$0` 访问，而 `Kara` 是参数列表中的第二个字符串，因此它使用 `$1` 访问。当我们执行这段代码时，我们将看到消息，`Hello
    Kara`，打印到控制台。
- en: 'This next example is used when the closure doesn''t return any value. Rather
    than defining the return type as `Void`, we can use parentheses, as the following
    example shows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个下一个例子中，当闭包不返回任何值时使用。我们不必将返回类型定义为 `Void`，我们可以使用括号，如下例所示：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In this example, we define the closure as `() -> ()`. This tells Swift that
    the closure does not accept any parameters and also does not return a value. We
    will execute this closure like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们定义闭包为 `() -> ()`。这告诉Swift该闭包不接受任何参数，也不返回任何值。我们将这样执行这个闭包：
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We have one more shorthand closure example to demonstrate before we begin showing
    some useful examples of closures. In this last example, we will demonstrate how
    we can return a value from the closure without the need to include the word, `return`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始展示一些有用的闭包示例之前，我们还有一个简写闭包示例要演示。在这个最后的例子中，我们将演示如何在不需要包含单词“return”的情况下从闭包中返回一个值。
- en: 'If the entire closure body consists of only a single statement, then we can
    omit the `return` keyword, and the results of the statement will be returned.
    Let''s take a look at an example of this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果整个闭包体只包含一个语句，那么我们可以省略 `return` 关键字，并且该语句的结果将被返回。让我们看看一个这样的例子：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this example, the closure accepts two parameters of the `Int` type and will
    return an `Int` type. The only statement within the body of the closure adds the
    first parameter to the second parameter. However, if you notice, we do not include
    the `return` keyword before the addition statement. Swift will see that this is
    a single statement closure and will automatically return the results, just as
    if we put the `return` keyword before the addition statement. We do need to make
    sure the result type of our statement matches the return type of the closure.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，闭包接受两个 `Int` 类型的参数，并将返回 `Int` 类型的值。闭包体内的唯一语句是将第一个参数加到第二个参数上。然而，如果你注意到，我们在加法语句之前没有包含
    `return` 关键字。Swift会看到这是一个单语句闭包，并将自动返回结果，就像我们在加法语句之前放置了 `return` 关键字一样。我们确实需要确保我们语句的结果类型与闭包的返回类型相匹配。
- en: All of the examples that were shown in the previous two sections were designed
    to show how to define and use closures. On their own, these examples did not really
    show off the power of closures and they did not show how incredibly useful closures
    are. The remainder of this chapter is written to demonstrate the power and usefulness
    of closures in Swift.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两个部分中展示的所有示例都是为了展示如何定义和使用闭包。单独来看，这些示例并没有真正展示闭包的力量，也没有展示闭包是多么有用。本章的剩余部分旨在展示Swift中闭包的力量和实用性。
- en: Using closures with Swift's array algorithms
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Swift的数组算法与闭包
- en: In [Chapter 3](ch03.html "Chapter 3. Using Collections and Cocoa Data Types"),
    *Using Collections and Cocoa Data Types*, we looked at several built-in algorithms
    that we could use with Swift's arrays. In that chapter, we briefly saw how to
    add simple rules to each of these algorithms with very basic closures. Now that
    we have a better understanding of closures, let's see how we can expand on these
    algorithms using more advanced closures.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章。使用集合和Cocoa数据类型")中，我们探讨了几个可以与Swift的数组一起使用的内置算法。在第3章中，我们简要地看到了如何使用非常基本的闭包为这些算法中的每一个添加简单的规则。现在，我们对闭包有了更好的理解，让我们看看如何使用更高级的闭包来扩展这些算法。
- en: 'In this section, we will primarily be using the map algorithm for consistency
    purposes; however, we can use the basic ideas demonstrated with any of the algorithms.
    We will start by defining an array to use:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将主要使用 map 算法以保持一致性；然而，我们可以使用任何算法中展示的基本思想。我们将首先定义一个数组来使用：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This array contains a list of names and the array is named `guests`. This array
    will be used for all the examples in this section, except for the very last ones.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数组包含一个名字列表，这个数组被命名为 `guests`。这个数组将在本节的所有示例中使用，除了最后几个。
- en: 'Now that we have our `guests` array, let''s add a closure that will print a
    greeting to each of the names in the `guests` array:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了 `guests` 数组，让我们添加一个闭包，该闭包将打印一个问候语到 `guests` 数组中的每个名字：
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Since the map algorithm applies the closure to each item of the array, this
    example will print out a greeting for each name within the `guests` array. After
    the first section in this chapter, we should have a pretty good understanding
    of how this closure works. Using the shorthand syntax that we saw in the last
    section, we could reduce the preceding example down to the following single line
    of code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于映射算法将闭包应用于数组中的每个项目，因此此示例将为`guests`数组中的每个名称打印一条问候语。在本章的第一部分之后，我们应该对闭包是如何工作的有一个相当好的理解。使用我们在上一节中看到的简写语法，我们可以将前面的示例简化为以下单行代码：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is one of the few times, in my opinion, where the shorthand syntax may
    be easier to read than the standard syntax.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，这可能是少数几个简写语法可能比标准语法更容易阅读的情况之一。
- en: 'Now, let''s say that rather than printing the greeting to the console, we wanted
    to return a new array that contained the greetings. For this, we would have returned
    a string type from our closure, as shown in the following example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们不想将问候语打印到控制台，而是想返回一个包含问候语的新数组。为此，我们将在闭包中返回一个字符串类型，如下面的示例所示：
- en: '[PRE23]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When this code is executed, the `messages` array will contain a greeting to
    each of the names in the `guests` array while the `guests` array will remain unchanged.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当此代码执行时，`messages`数组将包含对`guests`数组中每个名称的问候，而`guests`数组将保持不变。
- en: 'The preceding examples in this section showed how to add a closure to the map
    algorithm inline. This is good if we only had one closure that we wanted to use
    with the map algorithm, but what if we had more than one closure that we wanted
    to use, or if we wanted to use the closure multiple times or reuse them with different
    arrays. For this, we could assign the closure to a constant or variable and then
    pass in the closure, using its constant or variable name, as needed. Let''s see
    how to do this. We will begin by defining two closures. One of the closures will
    print a greeting for each name in the `guests` array, and the other closure will
    print a goodbye message for each name in the `guests` array:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 本节前面的示例展示了如何将闭包内联添加到映射算法中。如果我们只想使用一个闭包与映射算法一起，这是很好的；但如果我们有多个闭包想要使用，或者我们想要多次使用闭包或用不同的数组重用它们，我们应该怎么做呢？为此，我们可以将闭包分配给一个常量或变量，然后根据需要使用其常量或变量名称传递闭包。让我们看看如何做到这一点。我们将首先定义两个闭包。其中一个闭包将为`guests`数组中的每个名称打印一条问候语，另一个闭包将为`guests`数组中的每个名称打印一条告别语：
- en: '[PRE24]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now that we have two closures, we can use them with the map algorithm as needed.
    The following code shows how to use these closures interchangeably with the `guests`
    array:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了两个闭包，我们可以根据需要使用它们与映射算法一起。以下代码显示了如何将这些闭包与`guests`数组交互使用：
- en: '[PRE25]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Whenever we use the `greetGuest` closure with the `guests` array, the greetings
    message is printed to the console, and whenever we use the `sayGoodbye` closure
    with the `guests` array, the goodbye message is printed to the console. If we
    had another array named `guests2`, we could use the same closures for that array,
    as shown in the following example:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时我们使用`greetGuest`闭包与`guests`数组一起，问候消息都会打印到控制台；无论何时我们使用`sayGoodbye`闭包与`guests`数组一起，告别消息都会打印到控制台。如果我们还有一个名为`guests2`的数组，我们可以使用相同的闭包来处理该数组，如下面的示例所示：
- en: '[PRE26]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'All of the examples, in this section, so far have either printed a message
    to the console or returned a new array from the closure. We are not limited to
    such basic functionality in our closures. For example, we can filter the array
    within our closure, as shown in the following example:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，到目前为止的所有示例要么是将消息打印到控制台，要么是从闭包返回一个新数组。我们的闭包并不局限于这样的基本功能。例如，我们可以在闭包内过滤数组，如下面的示例所示：
- en: '[PRE27]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this example, we print out a different message depending on whether the name
    starts with the letter K or not.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们根据名称是否以字母K开头打印不同的消息。
- en: 'As we mentioned earlier in the chapter, closures have the ability to capture
    and store references to any variable or constant from the context in which they
    were defined. Let''s look at an example of this. Let''s say that we have a function
    that contains the highest temperature for the last seven days at a given location
    and this function accepts a closure as a parameter. This function will execute
    the closure on the array of temperature. The function can be written like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们本章前面提到的，闭包具有捕获并存储它们定义的上下文中任何变量或常量的引用的能力。让我们来看一个这样的例子。假设我们有一个函数，它包含了一个特定位置过去七天的最高温度，并且这个函数接受一个闭包作为参数。这个函数将在温度数组上执行闭包。这个函数可以写成这样：
- en: '[PRE28]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This function accepts a closure defined as `(Int)->Void`. We then use the map
    algorithm to execute this closure for each item of the `tempArray` array. The
    key to using a closure correctly in this situation is to understand that the `temperatures`
    function does not know or care what goes on inside the `calculate` closure. Also,
    be aware that the closure is also unable to update or change the items within
    the function's context, which means that the closure cannot change any other variable
    within the temperature's function; however, it can update variables in the context
    that it was created in.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受一个定义为 `(Int)->Void` 的闭包。然后我们使用映射算法为 `tempArray` 数组中的每个项目执行这个闭包。在这种情况下正确使用闭包的关键是理解
    `temperatures` 函数并不知道或关心 `calculate` 闭包内部发生的事情。此外，请注意，闭包也无法更新或更改函数上下文中的项目，这意味着闭包不能更改温度函数中的任何其他变量；然而，它可以更新它在创建的上下文中的变量。
- en: 'Let''s look at the function that we will create the closure in. We will name
    this function `testFunction`. Let''s take a look at the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们将创建闭包的函数。我们将把这个函数命名为 `testFunction`。让我们看一下以下代码：
- en: '[PRE29]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this function, we begin by defining two variables named `total` and `count`,
    where both variables are of the integer type. We then create a closure named `addTemps`
    that will be used to add all of the temperatures from the `temperatures` function
    together. The `addTemps` closure will also count how many temperatures are there
    in the array. To do this, the `addTemps` closure calculates the sum of each item
    in the array and keeps the total in the `total` variable that was defined at the
    beginning of the function. The `addTemps` closure also keeps track of the number
    of items in the array by incrementing the `count` variable for each item. Notice
    that neither the `total` nor `count` variables are defined within the closure;
    however, we are able to use them within the closure because they were defined
    in the same context as the closure.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们首先定义了两个名为 `total` 和 `count` 的变量，这两个变量都是整数类型。然后我们创建了一个名为 `addTemps`
    的闭包，它将被用来将 `temperatures` 函数中的所有温度相加。`addTemps` 闭包还将计算数组中有多少个温度。为此，`addTemps`
    闭包计算数组中每个项目的总和，并将总和保存在函数开头定义的 `total` 变量中。`addTemps` 闭包还通过为每个项目递增 `count` 变量来跟踪数组中的项目数量。请注意，`total`
    和 `count` 变量都不是在闭包内部定义的；然而，我们能够在闭包中使用它们，因为它们是在与闭包相同的上下文中定义的。
- en: 'We then call the `temperatures` function and pass it the `addTemps` closure.
    Finally, we print the total, count, and average temperature to the console. When
    the `testFunction` is executed, we see the following output to the console:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用 `temperatures` 函数，并传递 `addTemps` 闭包。最后，我们将总温度、计数和平均温度打印到控制台。当 `testFunction`
    执行时，我们会在控制台看到以下输出：
- en: '[PRE30]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As we can see from the output, the `addTemps` closure is able to update and
    use items that are defined within the context that it was created in, even when
    the closure is used in a different context.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从输出中可以看到的，`addTemps` 闭包能够在创建它的上下文中更新和使用定义的项目，即使闭包在另一个上下文中使用。
- en: Now that we have looked at using closures with the array map algorithm, let's
    look at using closures by themselves. We will also look at the ways we can clean
    up our code to make it easier to read and use.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了使用闭包与数组映射算法相结合的方法，让我们来看看如何单独使用闭包。我们还将探讨我们可以采取的方法来清理我们的代码，使其更容易阅读和使用。
- en: Standalone closures and good style guidelines
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 独立闭包和良好的风格指南
- en: Closures give us the ability to truly separate the data portions of our code
    from the user interface and business logic portions. This gives us the ability
    to create reusable classes that focus solely on retrieving our data. This is especially
    good for developing classes and frameworks that are designed to retrieve data
    from external services, such as web services, databases, or files. This section
    will show how to develop a class that will execute a closure once our data is
    ready to return.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包让我们能够真正地将代码中的数据部分与用户界面和业务逻辑部分分离。这使我们能够创建仅关注数据检索的可重用类。这对于开发旨在从外部服务（如网络服务、数据库或文件）检索数据的类和框架尤其有用。本节将展示如何开发一个类，当数据准备好返回时，将执行一次闭包。
- en: 'Let''s begin by creating a class that will contain the data portion of our
    code. In this example, the class will be named `Guests` and it will contain an
    array of `guests` names. Let''s take a look at the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个包含代码数据部分的类开始。在这个例子中，这个类将被命名为 `Guests`，它将包含一个嘉宾名字的数组。让我们看一下以下代码：
- en: '[PRE31]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The first line in the `Guests` class defines an array named `guestNames`. The
    `guestNames` array contains seven names. After we define the `guestNames` array,
    we then create a type alias. A type alias defines a named alias for an existing
    type. Just like a function, closures have types that consist of the parameter
    types and return types, which can be aliased. This allows us to define the closure
    once and then use the alias anywhere within our code. Using a type alias can reduce
    the amount of typing we have to do and also prevent errors. Therefore, it is recommended
    that we use them rather than trying to retype the closure definition multiple
    times in our code. It also allows us to change the definition in one location
    and it will then update throughout the code.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`Guests` 类的第一行定义了一个名为 `guestNames` 的数组。`guestNames` 数组包含七个名字。在我们定义 `guestNames`
    数组之后，我们接着创建一个类型别名。类型别名定义了一个现有类型的命名别名。就像函数一样，闭包有由参数类型和返回类型组成的类型，这些类型可以被别命名。这允许我们定义一次闭包，然后在代码的任何地方使用这个别名。使用类型别名可以减少我们需要输入的代码量，并防止错误。因此，建议我们使用它们，而不是在代码中多次重写闭包定义。它还允许我们在一个位置更改定义，然后整个代码将更新。'
- en: In this example, our type alias is named `UseArrayClosure` and is defined as
    a closure that accepts an array of strings as the only parameter and does not
    return a value. We can now use this type alias throughout our code as shorthand
    for the closure definition.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们的类型别名被命名为 `UseArrayClosure`，它被定义为一个接受一个字符串数组作为唯一参数且不返回任何值的闭包。现在我们可以在整个代码中使用这个类型别名作为闭包定义的简写。
- en: Finally, we define a `getGuest()` method that accepts a closure named `handler`
    as its only parameter. Within the `getGuests()` method, the only thing we do is
    execute the handler. Normally, in this method, we will have the logic to retrieve
    the data from our external data source; however, in this example, we have an array
    that is hardcoded with our list of guest names. Therefore, all we need to do is
    to execute the closure with the `guestsNames` array as the only parameter.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义了一个 `getGuest()` 方法，它接受一个名为 `handler` 的闭包作为其唯一参数。在 `getGuests()` 方法内部，我们唯一要做的事情就是执行这个处理器。通常，在这个方法中，我们将有从外部数据源检索数据的逻辑；然而，在这个例子中，我们有一个硬编码的包含嘉宾名单的数组。因此，我们只需要使用
    `guestsNames` 数组作为唯一参数来执行这个闭包。
- en: 'Now, let''s say that we want to display this array of names in a `UITableView`
    view. A `UITableView` is an iOS view that is designed for displaying lists of
    information. In the view controller, we will need to create an array to hold the
    data to display in `UITableView` and a variable that will link to `UITableView`
    in our display. These will both be class variables defined in our view controller
    class, and they are defined like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想在 `UITableView` 视图中显示这个名字数组。`UITableView` 是一个iOS视图，用于显示信息列表。在视图控制器中，我们需要创建一个数组来存储在
    `UITableView` 中显示的数据，以及一个变量来链接到显示中的 `UITableView`。这两个都将是我们视图控制器类中的类变量，并且它们的定义如下：
- en: '[PRE32]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, let''s create a function called `getData()` that will be used to retrieve
    the list of guests and update the table view:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个名为 `getData()` 的函数，它将用于检索嘉宾列表并更新表格视图：
- en: '[PRE33]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We begin the `getData()` function by defining a closure named `dataClosure`.
    This closure uses the `UseArrayClosure` type alias that we defined in the `Guests`
    class for the closure definition. Within the closure definition, we set the `tableData`
    array, which is defined within the view controller itself (not in the closure),
    equal to the string array that is passed into the closure. We then verify whether
    the `tableView` variable contains an instance of the `UITableView` class, and
    if so, we reload its data. Finally, we create an instance of the `Guests` class
    and call the `getGuest()` method passing it the `dataClosure` closure.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从定义一个名为`dataClosure`的闭包开始`getData()`函数。这个闭包使用了我们在`Guests`类中定义的`UseArrayClosure`类型别名来定义闭包。在闭包定义中，我们将定义在视图控制器本身内部（而不是在闭包中）的`tableData`数组设置为传递给闭包的字符串数组。然后我们验证`tableView`变量是否包含`UITableView`类的实例，如果是，我们重新加载数据。最后，我们创建一个`Guests`类的实例，并通过传递`dataClosure`闭包来调用`getGuest()`方法。
- en: Keep in mind that the `guestNames` array, which defines the list of names, is
    defined in the `Guest` class, while the `tableView`, `UITableView`, and `tableData`
    arrays are defined in the view controller class.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，定义名称列表的`guestNames`数组是在`Guest`类中定义的，而`tableView`、`UITableView`和`tableData`数组是在视图控制器类中定义的。
- en: When the `dataClosure` closure is passed to the `getGuests()` method, it will
    load the array of names, from the `Guests` class, into the `tableData` array.
    The `tableData` array is then used within the view controller class as the data
    elements for the `UITableView` array. The key items to note in this example are
    that we are able to load data from one context (the `Guests` class) into a variable
    that was defined within the same context as the closure (the view controller),
    and also have the ability to call methods on instances of classes (`tableView`
    and `UITableView`) defined within the same context as the closure.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当将`dataClosure`闭包传递给`getGuests()`方法时，它将从`Guests`类中加载名称数组到`tableData`数组中。然后`tableData`数组在视图控制器类中使用，作为`UITableView`数组的数据元素。在这个例子中需要注意的关键点是，我们能够将一个上下文（`Guests`类）中的数据加载到与闭包定义相同的上下文（视图控制器）中的变量，并且还有能力在定义在闭包相同上下文中的类的实例上调用方法（`tableView`和`UITableView`）。
- en: We could have very easily created a method in the `Guest` class that returned
    the `guestNames` array. With a hardcoded array, such as the one we have in the
    `Guest` class, this method would have worked very well. However, if we were loading
    the data from a web service that takes a little time to load; this will not work
    as well because our UI will freeze while waiting for the data to load. By using
    a closure, as shown in this example, we can make the web service call asynchronously,
    and then when the data is returned, the closure will be executed and the UI updates
    automatically without our UI freezing.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很容易在`Guest`类中创建一个返回`guestNames`数组的方法。对于像`Guest`类中那样的硬编码数组，这个方法会工作得很好。然而，如果我们从需要一些时间来加载的Web服务加载数据，这将不会很好地工作，因为我们的UI会在等待数据加载时冻结。通过使用本例中所示的方法，我们可以异步调用Web服务，然后当数据返回时，闭包将被执行，UI会自动更新而不会冻结我们的UI。
- en: Note
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This book is primarily written to teach the Swift language and not specifically
    iOS development; therefore, we are not covering how the UI elements from the Cocoa
    Touch framework work in this example. If you want to see the full iOS example,
    download the code samples for this book.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书主要是为了教授Swift语言，而不是专门针对iOS开发；因此，我们在这个例子中不涵盖Cocoa Touch框架中的UI元素是如何工作的。如果您想看到完整的iOS示例，请下载本书的代码示例。
- en: Changing functionality
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能更改
- en: Closures also give us the ability to change the functionality of classes on
    the fly. We saw in [Chapter 11](ch11.html "Chapter 11. Working with Generics"),
    *Working with Generics*, that generics give us the ability to write functions
    that are valid for multiple types. With closures, we are able to write functions
    and classes whose functionality can change, based on the closure that is passed
    into it as a parameter. In this section, we will show how to write a function
    whose functionality can be changed with a closure.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包还赋予我们动态更改类功能的能力。我们在[第11章](ch11.html "第11章。使用泛型")中看到，*使用泛型*，泛型赋予我们编写适用于多种类型的函数的能力。通过闭包，我们能够编写功能和闭包作为参数传递给它时可以改变的功能的函数和类。在本节中，我们将展示如何编写一个可以通过闭包改变功能的函数。
- en: 'Let''s begin by defining a class that will be used to demonstrate how to swap
    out functionality. We will name this class `TestClass`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义一个类，用于演示如何替换功能。我们将这个类命名为 `TestClass`：
- en: '[PRE34]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We begin this class by defining a type alias for our closure that is named `getNumClosure`.
    Any closure that is defined as a `getNumClosure` closure will take two integers
    and return an integer. Within this closure, we assume that it does something with
    the integers that we pass in to get the value to return, but it really doesn't
    have to. To be honest, this class doesn't really care what the closure does as
    long as it conforms to the `getNumClosure` type. Next, we define three integers
    that are named `numOne`, `NumTwo`, and `results`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从这个类开始，定义一个名为 `getNumClosure` 的闭包类型别名。任何定义为 `getNumClosure` 闭包的闭包都将接受两个整数并返回一个整数。在这个闭包中，我们假设它会对我们传入的整数做些处理以得到返回的值，但实际上并不需要。说实话，这个类并不关心闭包做了什么，只要它符合
    `getNumClosure` 类型。接下来，我们定义三个名为 `numOne`、`NumTwo` 和 `results` 的整数。
- en: Finally, we define a method named `getNum()`. This method accepts a closure
    that confirms the `getNumClosure` type as its only parameter. Within the `getNum()`
    method, we execute the closure by passing in the `numOne` and `numTwo` class variables,
    and the integer that is returned is put into the `results` class variable.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义一个名为 `getNum()` 的方法。该方法接受一个确认 `getNumClosure` 类型的闭包作为其唯一参数。在 `getNum()`
    方法中，我们通过传递 `numOne` 和 `numTwo` 类变量以及整数来执行闭包，返回的整数被放入 `results` 类变量中。
- en: 'Now, let''s look at several closures that conform to the `getNumClosure` type
    that we can use with the `getNum()` method:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看几个符合 `getNumClosure` 类型的闭包，我们可以使用这些闭包与 `getNum()` 方法一起使用：
- en: '[PRE35]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In this code, we define five closures that conform to the `getNumClosure` type:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们定义了五个符合 `getNumClosure` 类型的闭包：
- en: '`max`: This returns the maximum value of the two integers that are passed in'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max`: 这返回传入的两个整数的最大值'
- en: '`min`: This returns the minimum value of the two integers that are passed in'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`min`: 这返回传入的两个整数的最小值'
- en: '`multiply`: This multiplies both the values that are passed in and returns
    the product'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`multiply`: 这将传入的两个值相乘并返回乘积'
- en: '`second`: This returns the second parameter that was passed in'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`second`: 这返回传入的第二个参数'
- en: '`answer`: This returns the answer to life, the universe, and everything'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`answer`: 这返回生命、宇宙和万物的答案'
- en: 'In the `answer` closure, we have an extra line that looks like it does not
    have a purpose: `var tmp = $0 + $1`. We do this purposely because the following
    code is not valid:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `answer` 闭包中，有一行看起来好像没有作用：`var tmp = $0 + $1`。我们故意这样做，因为以下代码是不合法的：
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This class gives us the `error: tuple types ''(Int, Int)'' and ''()'' have
    a different number of elements (2 vs. 0)` error. As we can see by the error, Swift
    does not think that our closure accepts any parameters unless we use `$0` and
    `$1` within the body of the closure. In the closure named `second`, Swifts assumes
    that there are two parameters because `$1` specifies the second parameter.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '这个类给我们提供了 `error: tuple types ''(Int, Int)'' and ''()'' have a different number
    of elements (2 vs. 0)` 错误。正如错误所示，Swift 认为除非我们在闭包体中使用 `$0` 和 `$1`，否则我们的闭包不接受任何参数。在名为
    `second` 的闭包中，Swift 假设有两个参数，因为 `$1` 指定了第二个参数。'
- en: 'We can now pass each one of these closures to the `getNum` method of our `TestClass`
    to change the functionality of the function to suit our needs. The following code
    illustrates this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将这些闭包逐个传递给我们的 `TestClass` 的 `getNum` 方法，以改变函数的功能以适应我们的需求。以下代码说明了这一点：
- en: '[PRE37]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'When this code is run, we will receive the following results for each of the
    closures:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行此代码时，我们将为每个闭包收到以下结果：
- en: '`max`: results = 8'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max`: 结果 = 8'
- en: '`min`: results = 5'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`min`: 结果 = 5'
- en: '`multiply`: results = 40'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`multiply`: 结果 = 40'
- en: '`second`: results = 8'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`second`: 结果 = 8'
- en: '`answer`: results = 42'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`answer`: 结果 = 42'
- en: The last example we are going to show you in this chapter is one that is used
    a lot in frameworks, especially the ones that have a functionality that is designed
    to be run asynchronously.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将要展示的最后一个示例是在框架中经常使用的一个，尤其是在那些设计为异步运行的功能中。
- en: Selecting a closure based on results
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根据结果选择闭包
- en: In the final example, we will pass two closures to a method, and then depending
    on some logic, one, or possibly both, of the closures will be executed. Generally,
    one of the closures is called if the method was successfully executed and the
    other closure is called if the method failed.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后的例子中，我们将向一个方法传递两个闭包，然后根据某些逻辑，执行其中一个或两个闭包。通常情况下，如果方法成功执行，则调用其中一个闭包；如果方法失败，则调用另一个闭包。
- en: 'Let''s start off by creating a class that will contain a method that will accept
    two closures and then execute one of the closures based on the defined logic.
    We will name this class `TestClass`. Here is the code for the `TestClass` class:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个类开始，这个类将包含一个方法，该方法将接受两个闭包，并根据定义的逻辑执行其中一个闭包。我们将这个类命名为`TestClass`。以下是`TestClass`类的代码：
- en: '[PRE38]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We begin this class by creating a type alias that defines the closure that we
    will use for both the successful and failure closures. We will name this type
    alias `ResultsClosure`. This example will also illustrate why using a type alias,
    rather than retyping the closure definition, saves us a lot of typing and also
    prevents us from making mistakes. In this example, if we did not use a type alias,
    we would need to retype the closure definition four times, and if we needed to
    change the closure definition, we would need to change it in four spots. With
    the type alias, we only need to type the closure definition once and then use
    the alias throughout the remaining code.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从这个类开始创建一个类型别名，该别名定义了我们将在成功和失败闭包中使用的闭包。我们将这个类型别名命名为`ResultsClosure`。这个例子还将说明为什么使用类型别名而不是重新输入闭包定义可以节省我们大量的输入，并防止我们出错。在这个例子中，如果我们没有使用类型别名，我们就需要四次重新输入闭包定义，如果我们需要更改闭包定义，我们就需要在四个地方进行更改。使用类型别名，我们只需要输入一次闭包定义，然后在剩余的代码中使用别名。
- en: We then create a method named `isGreater` that takes two integers as the first
    two parameters and then two closures as the next two parameters. The first closure
    is named `successHandler`, and the second closure is named `failureHandler`. Within
    the `isGreater` method, we check whether the first integer parameter is greater
    than the second one. If the first integer is greater, the `successHandler` closure
    is executed; otherwise, the `failureHandler` closure is executed.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着创建一个名为`isGreater`的方法，该方法接受两个整数作为前两个参数，然后接受两个闭包作为接下来的两个参数。第一个闭包命名为`successHandler`，第二个闭包命名为`failureHandler`。在`isGreater`方法内部，我们检查第一个整数参数是否大于第二个参数。如果第一个整数大于第二个，则执行`successHandler`闭包；否则，执行`failureHandler`闭包。
- en: 'Now, let''s create two of our closures. The code for these two closures is:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建两个闭包。这两个闭包的代码如下：
- en: '[PRE39]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note that both closures are defined as the `TestClass.ResultsClosure` type.
    In each closure, we simply print a message to the console to let us know which
    closure was executed. Normally, we would put some functionality in the closure.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这两个闭包都被定义为`TestClass.ResultsClosure`类型。在每个闭包中，我们只是简单地打印一条消息到控制台，让我们知道哪个闭包被执行。通常情况下，我们会在闭包中放置一些功能。
- en: 'We will then call the method with both the closures like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将像这样使用两个闭包调用该方法：
- en: '[PRE40]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Note that in the method call, we are sending both the success closure and the
    failure closure. In this example, we will see the message, `Success: 8 is greater
    than 6`. If we reversed the numbers, we would see the message, `Failure: 6 is
    not greater than 8`. This use case is really good when we call asynchronous methods,
    such as loading data from a web service. If the web service call was successful,
    the success closure is called; otherwise, the failure closure is called.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在方法调用中，我们发送了成功闭包和失败闭包。在这个例子中，我们会看到消息，“成功：8大于6”。如果我们反转数字，我们会看到消息，“失败：6不大于8”。这种用法在调用异步方法时非常好，例如从网络服务加载数据。如果网络服务调用成功，则调用成功闭包；否则，调用失败闭包。
- en: 'One big advantage of using closures like this is that the UI does not freeze
    while we wait for the web service call to complete. This also involves a concurrency
    piece, which we will be covering in [Chapter 14](ch14.html "Chapter 14. Concurrency
    and Parallelism in Swift"), *Concurrency and Parallelism in Swift*, later in this
    book. As an example, if we tried to retrieve data from a web service like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种闭包的一个大优点是，在等待网络服务调用完成时，UI不会冻结。这也涉及到并发部分，我们将在本书的[第14章](ch14.html "第14章。Swift中的并发与并行")，*Swift中的并发与并行*中稍后进行介绍。作为一个例子，如果我们尝试以这种方式从网络服务检索数据：
- en: '[PRE41]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Our UI would freeze while we wait for the response to come back, or we would
    have to make the call in a separate thread so that the UI would not hang. With
    closures, we pass the closures to the networking framework and rely on the framework
    to execute the appropriate closure when it is done. This does rely on the framework
    to implement concurrency correctly to make the calls asynchronously, but a decent
    framework should handle that for us.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们等待响应返回时，我们的UI会冻结，或者我们必须在单独的线程中发起调用，这样UI就不会挂起。使用闭包，我们将闭包传递给网络框架，并依赖于框架在完成时执行适当的闭包。这确实依赖于框架正确实现并发来异步调用，但一个不错的框架应该为我们处理这一点。
- en: Creating strong reference cycles with closures
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用闭包创建强引用循环
- en: Earlier in this chapter, we said, "the best thing is, for the most part, Swift
    will handle the memory management for us". The "for the most part" section of
    the quote means that if everything is written in a standard way, Swift will handle
    the memory management of the closures for us. However, just like classes, there
    are times where the memory management fails us. Memory management will work correctly
    for all of the examples that we have seen in this chapter so far. It is possible
    to create a strong reference cycle that would prevent Swift's memory management
    from working correctly. Let's look at what happens if we create a strong reference
    cycle with closures.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期，我们说，“最好的是，大多数情况下，Swift会为我们处理内存管理”。这句话中的“大多数情况下”部分意味着，如果一切按照标准方式编写，Swift会为我们处理闭包的内存管理。然而，就像类一样，有时内存管理会让我们失望。到目前为止，本章中我们看到的所有示例的内存管理都将正常工作。有可能创建一个强引用循环，这将阻止Swift的内存管理正常工作。让我们看看如果我们使用闭包创建强引用循环会发生什么。
- en: A strong reference cycle may happen if we assign a closure to a property of
    a class instance and within that closure, we capture the instance of the class.
    This capture occurs because we access a property of that particular instance using
    `self` like `self.someProperty` or we assign self to a variable or constant like
    `let c = self`. By capturing a property of the instance, we are actually capturing
    the instance itself, thereby creating a strong reference cycle where the memory
    manager will not know when to release the instance. As a result, the memory will
    not be freed correctly.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将一个闭包分配给类实例的一个属性，并在该闭包中捕获该类的实例，可能会发生强引用循环。这种捕获发生是因为我们使用`self`访问该特定实例的属性，例如`self.someProperty`，或者将`self`赋值给一个变量或常量，如`let
    c = self`。通过捕获实例的属性，我们实际上捕获了实例本身，从而创建了一个强引用循环，内存管理器将不知道何时释放实例。结果，内存将无法正确释放。
- en: 'Let''s begin by creating a class that has a closure and an instance of the
    string type as its two properties. We will also create a type alias for the closure
    type in this class and define a `deinit()` method that prints a message to the
    console. The `deinit()` method is called when the class gets released and the
    memory is freed. We will know when the class gets released when the message from
    the `deinit()` method is printed to the console. This class will be named `TestClassOne`.
    Let''s take a look at the following code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个具有闭包和字符串类型实例作为其两个属性的类开始。我们还将在这个类中创建闭包类型的别名，并定义一个`deinit()`方法，该方法将打印一条消息到控制台。`deinit()`方法在类被释放和内存释放时被调用。当`deinit()`方法的消息打印到控制台时，我们将知道类何时被释放。这个类将被命名为`TestClassOne`。让我们看一下以下代码：
- en: '[PRE42]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, let''s create a second class that will contain a method that accepts a
    closure that is of the `nameClosure` type that was defined in the `TestClassOne`
    class. This class will also have a `deinit()` method, so we can also see when
    it gets released. We will name this class `TestClassTwo`. Let''s take a look at
    the following code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建第二个类，该类将包含一个接受`nameClosure`类型闭包的方法，该闭包是在`TestClassOne`类中定义的。这个类也将有一个`deinit()`方法，这样我们也可以看到它何时被释放。我们将这个类命名为`TestClassTwo`。让我们看一下以下代码：
- en: '[PRE43]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, let''s see this code in action by creating instances of each class and
    then trying to manually release the instance by setting them to `nil`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过创建每个类的实例，然后尝试通过将它们设置为`nil`来手动释放实例，来看看这段代码的实际效果：
- en: '[PRE44]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: What we do in this code is create two optionals that may contain an instance
    of our two test classes or nil. We need to create these variables as optionals
    because we will be setting them to `nil` later in the code so that we can see
    whether the instances are released properly.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们创建了两个可选变量，它们可能包含我们的两个测试类的实例或`nil`。我们需要将这些变量创建为可选的，因为我们在代码的后面将它们设置为`nil`，这样我们就可以看到实例是否被正确释放。
- en: We then call the `closureExample()` method of the `TestClassTwo` instance and
    pass it the `myClosure` property from the `TestClassOne` instance. We now try
    to release the `TestClassOne` and `TestClassTwo` instances by setting them to
    `nil`. Keep in mind that when an instance of a class is released, it attempts
    to call the `deinit()` method of the class if it exists. In our case, both classes
    have a `deinit()` method that prints a message to the console, so we know when
    the instances are actually released.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们调用`TestClassTwo`实例的`closureExample()`方法，并将`TestClassOne`实例的`myClosure`属性传递给它。我们现在尝试通过将它们设置为`nil`来释放`TestClassOne`和`TestClassTwo`实例。记住，当一个类的实例被释放时，如果存在，它会尝试调用该类的`deinit()`方法。在我们的例子中，两个类都有一个`deinit()`方法，它会向控制台打印一条消息，这样我们就可以知道实例是否真正被释放了。
- en: 'If we run this project, we will see the following messages printed to the console:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个项目，我们将看到以下消息打印到控制台：
- en: '[PRE45]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As we can see, we do attempt to release the `TestClassOne` instances, but the
    `deinit()` method of the class is never called, indicating that it was not actually
    released; however, the `TestClassTwo` instance was properly released because the
    `deinit()` method of that class was called.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们确实尝试释放`TestClassOne`实例，但类的`deinit()`方法从未被调用，这表明它实际上并没有被释放；然而，`TestClassTwo`实例被正确释放，因为那个类的`deinit()`方法被调用了。
- en: 'To see how this is supposed to work without the strong reference cycle, change
    the `myClosure` closure to return a string type that is defined within the closure
    itself, as shown in the following code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看在没有强引用循环的情况下它是如何工作的，将`myClosure`闭包更改为返回在闭包内部定义的字符串类型，如下所示：
- en: '[PRE46]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, if we run the project, we should see the following output:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行项目，我们应该看到以下输出：
- en: '[PRE47]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This shows that the `deinit()` methods from both the `TestClassOne` and `TestClassTwo`
    instances were properly called, indicating that they were both released properly.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明`TestClassOne`和`TestClassTwo`实例的`deinit()`方法都得到了正确调用，表明它们都被正确释放了。
- en: In the first example, we capture an instance of the `TestClassOne` class within
    the closure because we accessed a property of the `TestClassOne` class using `self.name`.
    This created a strong reference from the closure to the instance of the `TestClassOne`
    class, preventing memory management from releasing the instance.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，我们在闭包中捕获了`TestClassOne`类的一个实例，因为我们使用`self.name`访问了`TestClassOne`类的一个属性。这从闭包到`TestClassOne`类的一个实例创建了一个强引用，阻止了内存管理释放该实例。
- en: Swift does provide a very easy and elegant way to resolve strong reference cycles
    in closures. We simply need to tell Swift not to create a strong reference by
    creating a capture list. A capture list defines the rules to use when capturing
    reference types within a closure. We can declare each reference to be a weak or
    unowned reference rather than a strong reference.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Swift确实提供了一个非常简单且优雅的方式来解决闭包中的强引用循环。我们只需通过创建捕获列表来告诉Swift不要创建强引用。捕获列表定义了在闭包中捕获引用类型时要使用的规则。我们可以声明每个引用为弱引用或`unowned`引用，而不是强引用。
- en: A `weak` keyword is used when there is the possibility that the reference will
    become nil during its lifetime; therefore, the type must be an optional. The `unowned`
    keyword is used when there is not a possibility of the reference becoming nil.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当在引用的生命周期中存在引用可能变为`nil`的可能性时，使用`weak`关键字；因此，类型必须是可选的。当没有引用变为`nil`的可能性时，使用`unowned`关键字。
- en: 'We define the capture list by pairing the `weak` or `unowned` keywords with
    a reference to a class instance. These pairings are written within square brackets
    (`[ ]`). Therefore, if we update the `myClosure` closure and define an `unowned`
    reference to `self`, we should eliminate the strong reference cycle. The following
    code shows what the new `myClosure` closure will look similar to:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将`weak`或`unowned`关键字与一个类实例的引用配对来定义捕获列表。这些配对在方括号`[ ]`内书写。因此，如果我们更新`myClosure`闭包并定义一个指向`self`的`unowned`引用，我们应该消除强引用循环。以下代码显示了新的`myClosure`闭包将类似的样子：
- en: '[PRE48]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Notice the new line—`[unowned self] in`. This line says that we do not want
    to create a strong reference to the instance of `self`. If we run the project
    now, we should see the following output:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 注意新的一行——`[unowned self] in`。这一行表示我们不希望创建对 `self` 实例的强引用。如果我们现在运行项目，我们应该看到以下输出：
- en: '[PRE49]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This shows that both the `TestClassOne` and `TestClassTwo` instances were properly
    released.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明 `TestClassOne` 和 `TestClassTwo` 实例都得到了适当的释放。
- en: Summary
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw that we can define a closure just like we can define
    an int or string type. We can assign closures to a variable, pass them as an argument
    to functions, and also return them from functions.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了我们可以像定义整型或字符串类型一样定义闭包。我们可以将闭包分配给变量，将它们作为函数的参数传递，也可以从函数中返回它们。
- en: Closures capture a store references to any constants or variables from the context
    in which the closure was defined. We do have to be careful with this functionality
    to make sure that we do not create a strong reference cycle, which would lead
    to memory leaks in our applications.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包捕获了从定义闭包的上下文中引用的任何常量或变量的存储引用。我们必须小心使用这个功能，以确保我们不会创建一个强引用循环，这会导致我们的应用程序中出现内存泄漏。
- en: Swift closures are very similar to blocks in Objective-C, but they have a much
    cleaner and eloquent syntax. This makes them a lot easier to use and understand.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 闭包与 Objective-C 中的块非常相似，但它们的语法更加简洁和优雅。这使得它们更容易使用和理解。
- en: Having a good understanding of closures is vital to mastering the Swift programming
    language and will make it easier to develop great applications that are easy to
    maintain for OS X and iOS. It is also essential for creating first class frameworks
    that can be used to create OS X and iOS applications.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 对闭包有良好的理解对于掌握 Swift 编程语言至关重要，这将使开发易于维护的 OS X 和 iOS 应用程序变得更加容易。这对于创建可以用于创建 OS
    X 和 iOS 应用程序的一等框架也是必不可少的。
- en: The three use cases that we saw in this chapter are by no means the only three
    *useful* uses for closures. I can promise you that the more you use closures in
    Swift, the more uses you will find for them. Closures are definitely one of the
    most powerful and useful features of the Swift language, and Apple did a great
    job by implementing them in the language.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们看到的三个用例绝不是闭包的唯一三个*有用*用途。我可以向你保证，你越在 Swift 中使用闭包，你将发现它们的应用越多。闭包无疑是 Swift
    语言中最强大和最有用的特性之一，苹果在语言中实现它们做得非常出色。
