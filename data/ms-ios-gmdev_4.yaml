- en: Chapter 4. Let's Keep Going! Adding More Functionality
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：继续前进！添加更多功能
- en: 'We got a lot accomplished in the last chapter! We figured out level creation,
    importing our levels into Xcode and getting them and our player all showing up
    in our game. Are you well rested and ready to tackle even more programming awesomeness?
    Let''s see what we will do in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们取得了许多成果！我们解决了关卡创建、将关卡导入Xcode以及让我们的关卡和玩家在游戏中显示出来。你休息得很好，准备好应对更多的编程酷炫了吗？让我们看看本章我们将做什么：
- en: Adding awesome sound effects
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加酷炫音效
- en: Character animations
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色动画
- en: Playing with particles
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩转粒子
- en: Menus
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 菜单
- en: Adding some enemies
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一些敌人
- en: Our game looks pretty awesome, but there's still tons of work to be completed
    before we can even remotely consider releasing it!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏看起来相当酷，但在我们甚至可以远程考虑发布它之前，还有很多工作要做！
- en: Let's get into it, shall we?
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨，好吗？
- en: 'First things first, we ended the last chapter we had just discussed winning
    the level, and dying during the level, however if you tested it and you died or
    beat the level and clicked on the replay button, did the game crash? That''s because
    we need to add one final method:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们结束了刚刚讨论的章节，即赢得关卡和关卡中的死亡，然而如果你测试了它，你死亡或通关并点击了重玩按钮，游戏崩溃了吗？这是因为我们需要添加一个最终的方法：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This block of code simply removes the button from the screen and resets the
    game. Let's proceed!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码块简单地从屏幕上移除按钮并重置游戏。让我们继续！
- en: Adding awesome sound effects
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加酷炫音效
- en: Yes! We will give our little guy some sound, specifically, when jumping and
    dying. That's not all though! No no! We will also get some groovy tunes playing
    in our levels.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 是的！我们将给我们的这个小家伙一些声音，特别是跳跃和死亡时的声音。但这还不是全部！不，不！我们还将让一些有趣的旋律在我们的关卡中播放。
- en: 'Let''s open up our `GameLevelScene.m` file and import the SpriteKit Audio framework
    to play sounds! At the top of the file where all our import methods are, add the
    following line:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开我们的`GameLevelScene.m`文件，并导入SpriteKit音频框架来播放声音！在文件顶部，所有我们的导入方法都在那里，添加以下行：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'I''ve included some audio for our use as well, so if you haven''t imported
    them into your project, go ahead and do that now, or you can use your own music
    if you like. Once your file has been imported into the project, back in our `GameLevelScene.m`
    file, within our `-(id)initWithSize` method, we will add the following line of
    code to get our music playing:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我还包含了一些音频供我们使用，所以如果你还没有将它们导入到你的项目中，现在就去做吧，或者如果你喜欢，你可以使用你自己的音乐。一旦你的文件被导入到项目中，回到我们的`GameLevelScene.m`文件，在我们的`-(id)initWithSize`方法中，我们将添加以下代码行以播放音乐：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Test the project and now you should have some rocking tunes playing in the background!
    So cool!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 测试项目，现在你应该在背景中听到一些摇滚乐了！太酷了！
- en: I think we should now create a sound effect for the jump movement, shouldn't
    we?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为我们现在应该为跳跃动作创建一个音效，不是吗？
- en: 'Hopping (no pun intended) on to our `Player.m` file, we will locate the block
    of code where we make our player dance. That method is found in the `update` method,
    and in that method, we will locate the ''`if (self.jumping && self.onGround)`
    statement. In the `if` statement, we will add the following code just after the
    open braces of the `if` statement (That is, `{`):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 跳跃（不是字面意思），转到我们的`Player.m`文件，我们将找到我们让玩家跳舞的代码块。这个方法在`update`方法中，在这个方法中，我们将找到`'if
    (self.jumping && self.onGround)'`语句。在`if`语句中，我们将在语句开大括号（即`{`）之后添加以下代码：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Let's break this function down a little bit. We tell **self** to run an action,
    which self in this case is the player class inherited from SKNode, which is where
    that `runAction` method comes from. Then, we declare that action as a SpriteKit
    action, which is used to play a sound file. We declare the sound file, then we
    tell SpriteKit not to wait for completion.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微分解一下这个函数。我们告诉**self**运行一个动作，这里的**self**是指从SKNode继承的玩家类，这也是`runAction`方法来源的地方。然后，我们声明这个动作为一个SpriteKit动作，用于播放声音文件。我们声明声音文件，然后告诉SpriteKit不要等待完成。
- en: Awesome! Now the character will emit a little blip noise every time the player
    taps the jump button. You can apply these methods to anywhere you want to play
    a sound, be it dying, shooting, walking—you name it!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在，每当玩家点击跳跃按钮时，角色都会发出一点哔哔声。你可以将这些方法应用到你想播放声音的任何地方，无论是死亡、射击、行走——你名字叫什么！
- en: Notice how we used a different method to play the background music then we did
    to play the jumping sound effect? Do you know why we did this?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们使用了一个不同的方法来播放背景音乐，而不是跳跃声音效果，你知道为什么吗？
- en: When you play the game, there will be a bunch of sound effects playing at one
    a time. If we play the sound effects using the same method that we use to play
    our music, it would potentially stop playing the music in order to play a new
    sound effect that has been called, as we can only play one background music file
    at a time. So when we play a sound effect, we will not interfere with our background
    music as it plays on a different channel.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当你玩游戏时，会有很多声音效果同时播放。如果我们使用播放音乐相同的方法来播放声音效果，可能会停止播放音乐，以便播放一个新调用的声音效果，因为我们一次只能播放一个背景音乐文件。所以当我们播放声音效果时，我们不会干扰我们的背景音乐，因为它在不同的频道上播放。
- en: This way, the music will be played without any interruption, unless you get
    a call while playing it, as there's nothing we can do about that.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，音乐将连续播放，除非你在播放时接到电话，对此我们无能为力。
- en: Our game is now coming together, but I don't like how our player just stays
    still when he's walking or jumping. Let's add in some animations!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏现在正在成形，但我不喜欢我们的玩家在行走或跳跃时只是保持静止。让我们添加一些动画！
- en: Character animations
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 角色动画
- en: Almost all games contain character or object animations. They add life to the
    objects or characters, and they make the game look way more appealing. Take the
    game we are making as an example. Say we pushed the game for sale, and the player
    just remained in his idle pose all the time, dying, walking, or jumping—there
    he was just standing as he is.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有游戏都包含角色或对象动画。它们为对象或角色增添了活力，并使游戏看起来更具吸引力。以我们正在制作的游戏为例。假设我们推出游戏进行销售，玩家一直保持他的闲置姿势，无论是死亡、行走还是跳跃——他就这样站着。
- en: Doesn't look proper, does it? We need to change that!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这样看起来不太合适，不是吗？我们需要改变这一点！
- en: We've already imported the Sprite atlas file that contains all the images required
    to create our character animations, so that saves a lot of the work. The Sprite
    atlas is where all the sprites will go for SpriteKit to access. Instead of having
    images randomly imported all over the place in our project, the Sprite atlas organizes
    them all nicely.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经导入了包含创建角色动画所需所有图像的Sprite图集文件，这节省了大量工作。Sprite图集是SpriteKit将所有精灵图像放置的地方。我们项目中不再有图像随机导入各个地方，Sprite图集将它们组织得井井有条。
- en: 'We will go into our `Player.m` class, and just below our `@implementation Player`
    line, add the following line of code so that our implementation looks like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将进入`Player.m`类，并在`@implementation Player`行下方添加以下代码行，使我们的实现看起来如下：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We need to add an array of images that will make up our walking animations or
    any other animations that you would like to create.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加一个图像数组，这些图像将组成我们的行走动画或任何其他您想要创建的动画。
- en: 'Now, in our `initWithImageNamed` method, we need to create the array, locate
    the walking images within the atlas, and then add them to our array. To do this,
    add the following code directly under the opening bracket for our `init` method:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的`initWithImageNamed`方法中，我们需要创建数组，在图集中定位行走图像，然后将它们添加到数组中。为此，将以下代码直接添加到我们的`init`方法的开始括号下：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let's discuss what just happened here because it's a lot of confusing jargon!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下刚才发生的事情，因为这里有很多令人困惑的专业术语！
- en: In the first line, we added sets to an array to hold all the walking images
    within the atlas. Next, we load the texture atlas that contains all our images.
    What's great is that the SpriteKit automatically loads the correct resolution
    for the device we are using, hence the @2x images to make up for the higher resolution
    images used for retina displays.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们将集合添加到数组中，以存储图集中所有的行走图像。接下来，我们加载包含所有图像的纹理图集。很棒的是，SpriteKit会自动加载我们使用的设备的正确分辨率，因此有@2x图像来弥补用于视网膜显示屏的高分辨率图像。
- en: Next, we tell Xcode to search through the atlas for images named `P1Walking`;
    the `%d` automatically searches through all the images named `P1Walking`. So,
    this will start at image `0`, then `1`, `2`, `3`, and so forth. Finally, we add
    the images into our walking animation array.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们告诉Xcode在图集中搜索名为`P1Walking`的图像；`%d`会自动搜索所有名为`P1Walking`的图像。因此，这将从图像`0`开始，然后是`1`、`2`、`3`，以此类推。最后，我们将这些图像添加到我们的行走动画数组中。
- en: 'We now need to add an action that will fire the animation and stop it when
    called. We need to add the following methods into our `Player.m` file:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要添加一个动作来触发动画，并在调用时停止它。我们需要将以下方法添加到我们的`Player.m`文件中：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We add an action key, `PlayerWalking` to be able to stop the animation when
    needed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个动作键`PlayerWalking`，以便在需要时停止动画。
- en: 'We call this method once when the player is touching the walking zones we created
    in the previous chapter. Let''s go over to our `Player.h` file and create another
    property. With all our other properties, add the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在玩家触摸上一章中创建的行走区域时调用此方法一次。让我们转到我们的`Player.h`文件，并创建另一个属性。与我们的其他属性一样，添加以下内容：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, to get our little guy actually animated, we need to jump on to `GameLevelScene.m`
    file. In our `touchesBegan` method, where we call the `walking` and `goingBackwards`
    Booleans, we need to add the following code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了让我们的小家伙真正地动起来，我们需要跳转到`GameLevelScene.m`文件。在我们的`touchesBegan`方法中，当我们调用`walking`和`goingBackwards`布尔值时，我们需要添加以下代码：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'So, now our `touchesBegan` method will look like this (with the new code highlighted):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在我们的`touchesBegan`方法将看起来像这样（新代码被突出显示）：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will now set our Boolean `true` whenever the player touches these walking
    zones. We also need to set them `false` when the touches end, so we will scroll
    down to our `touchesEnded` method and add the following where we turn our walking
    and `goingBackwards` method to `no`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使布尔值`true`在玩家触摸这些行走区域时设置。我们还需要在触摸结束时将它们设置为`false`，因此我们将滚动到我们的`touchesEnded`方法，并添加以下代码，将我们的行走和`goingBackwards`方法设置为`no`：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now let''s go back to our `Player.m` file, and we are going to add the following
    lines of code to our `update` section:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们的`Player.m`文件，并在我们的`update`部分添加以下代码行：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now when the player touches a walking zone, it will set the `animateWalking`
    Boolean to `true`, which will call the `PlayerWalking` action. When that action
    is called, we will then animate the character with a walking animation, and when
    the player removes their fingers from the walking zone, it will stop animating.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当玩家触摸行走区域时，它会将`animateWalking`布尔值设置为`true`，这将调用`PlayerWalking`动作。当这个动作被调用时，我们将使用行走动画来动画化角色，而当玩家从行走区域移开手指时，动画将停止。
- en: Whew! That's a lot of code for something so simple, but the results look great!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 呼！对于这么简单的事情来说，代码确实很多，但结果看起来很棒！
- en: '![Character animations](img/B03553_04_01.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![角色动画](img/B03553_04_01.jpg)'
- en: Bit by bit, our little game is coming together! Let's make this level look a
    little dark and dreary. Let's play with some particles to add depth!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 逐步，我们的小游戏正在逐渐成形！让我们让这个关卡看起来有点阴暗和沉闷。让我们玩一些粒子来增加深度！
- en: Playing with particles
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 玩转粒子
- en: SpriteKit makes particles super easy, so easy that, in fact, a lot of common
    particle effects, such as flames, smoke, and rain are premade templates available
    when creating our particle file.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: SpriteKit让粒子效果变得非常简单，简单到实际上，许多常见的粒子效果，如火焰、烟雾和雨，在创建我们的粒子文件时都是预制的模板。
- en: 'In Xcode, to create a new particle emitter, simply navigate to **File** | **New**
    | **File**. Under the template creator in the **iOS** section (ignore the fact
    that I have OS X selected in the previous screenshot) and under **Resource**,
    select **SpriteKit Particle File**, as shown in the following screenshot:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xcode中，要创建一个新的粒子发射器，只需导航到**文件** | **新建** | **文件**。在**iOS**部分的模板创建器中（忽略我在上一张截图中选择的是OS
    X的事实）和**资源**部分下，选择**SpriteKit粒子文件**，如下面的截图所示：
- en: '![Playing with particles](img/B03553_04_02.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![玩转粒子](img/B03553_04_02.jpg)'
- en: This is where creating the effects are super easy, simply select **Rain** from
    the particle template.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是创建效果非常简单的地方，只需从粒子模板中选择**雨**。
- en: '![Playing with particles](img/B03553_04_03.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![玩转粒子](img/B03553_04_03.jpg)'
- en: Yes, it's that easy to create particles!
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，创建粒子就是这么简单！
- en: 'Now, all that we have to do is save it, which I just did in the `ADESA` project
    folder. Now, you will see our new particle emitter file in the project explorer
    in Xcode. Click on it and you should see something similar to the following screenshot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要保存它，我刚刚在`ADESA`项目文件夹中做了这件事。现在，你将在Xcode的项目资源管理器中看到我们的新粒子发射器文件。点击它，你应该会看到以下类似的截图：
- en: '![Playing with particles](img/B03553_04_04.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![玩转粒子](img/B03553_04_04.jpg)'
- en: Don't worry if you don't exactly like the look of the particle effect, we can
    do a whole bunch of adjustments to it.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对粒子效果的外观不完全满意，我们可以对其进行大量调整。
- en: At the top of the right-hand side bar, click on the **Show SK Node inspector**
    button to see all the adjustments we can make. The only thing I changed here is
    the position range, I changed the value of **X** to **1500** so that it will stretch
    across the whole screen.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧栏的顶部，点击**显示SK节点检查器**按钮，可以看到我们可以做的所有调整。我这里唯一改变的是位置范围，我将**X**的值改为**1500**，以便它横跨整个屏幕。
- en: '![Playing with particles](img/B03553_04_05.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![玩转粒子](img/B03553_04_05.jpg)'
- en: If you want to make other adjustments, let me tell you what all these options
    do.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想进行其他调整，让我告诉您所有这些选项的作用。
- en: Background
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 背景
- en: The background option is provided so you can test the visibility of the particles
    against various colored backgrounds. Changing this option will have no effect
    on the particles.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 提供背景选项，以便您可以测试粒子在各种颜色背景下的可见性。更改此选项对粒子没有影响。
- en: Particle texture
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 粒子纹理
- en: The particle texture is the image file that the emitter will use for the particles.
    The standard provided image is simply a soft white sphere, so you get a nice smooth
    and soft particle. This image is great because it can be used for pretty much
    all types of particles.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子纹理是发射器将用于粒子的图像文件。提供的标准图像只是一个柔软的白色球体，因此您得到一个平滑柔软的粒子。这张图片很棒，因为它可以用于几乎所有类型的粒子。
- en: Particle birthrate
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 粒子出生率
- en: The particle birthrate is the rate at which new particles are emitted by the
    emitter. The higher the value, the faster the new particles are spat out. (Be
    warned, less particles give better performance). The total number of particles
    to be emitted may also be specified. If you set the value to **0**, this will
    cause particles to be emitted indefinitely. If you specify a maximum value, the
    emitter will stop when particles in the scene reach that value.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子出生率是指发射器发射新粒子的速率。值越高，新粒子喷出的速度越快。（警告：粒子越少，性能越好）。还可以指定要发射的粒子总数。如果将值设置为**0**，这将导致粒子无限期地发射。如果指定最大值，当场景中的粒子达到该值时，发射器将停止。
- en: Particle life cycle
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 粒子生命周期
- en: The particle life cycle controls the length of time in seconds for which a particle
    remains alive. The range property can be used to vary the duration of the life
    of particles, for example, if you create an explosion, you can use a larger range
    so you have some particles visible for longer than the others.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子生命周期控制粒子存活的时间长度（以秒为单位）。范围属性可以用来改变粒子生命周期的持续时间，例如，如果您创建一个爆炸，您可以使用更大的范围，以便有一些粒子比其他粒子更长时间可见。
- en: Particle position range
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 粒子位置范围
- en: The particle position range option defines the location from which particles
    are created (self-explanatory, right?). The **X** and **Y** values can be used
    to declare an area around the center of the node location from which particles
    will be created randomly.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子位置范围选项定义了粒子创建的位置（不言而喻，对吧？）。**X**和**Y**值可以用来声明一个区域，该区域位于节点中心，粒子将从该区域随机创建。
- en: Angle
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 角度
- en: The angle option relates to the angle at which a newly emitted particle will
    travel away from the creation point in counterclockwise degrees, where a value
    of **0** degrees equates to rightward movement. When we set a range value, it
    will vary the direction in which the particles are emitted.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 角度选项与粒子从创建点出发沿逆时针方向移动的角度有关，其中**0**度等于向右移动。当我们设置范围值时，它将改变粒子发射的方向。
- en: Particle speed
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 粒子速度
- en: Again, the particle speed option is pretty self-explanatory. It deals with the
    speed at which particles move when they are created. When we set a range value,
    it will vary the direction in which the particles are emitted.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，粒子速度选项相当直观。它涉及粒子在创建时的移动速度。当我们设置范围值时，它将改变粒子发射的方向。
- en: Particle acceleration
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 粒子加速度
- en: The acceleration properties control the speed at which a particle accelerates
    or decelerates after emission. I'll use explosions for an example again, with
    this option, you can have them fly out fast but have the shrapnels slow down.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 加速度属性控制粒子在发射后加速或减速的速度。我再次以爆炸为例，使用此选项，您可以让它们快速飞出，但让碎片减速。
- en: Particle scale
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 粒子尺度
- en: The particle scale option obviously refers to the size of the particles, which
    again can be varied with the range setting.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子尺度选项显然是指粒子的尺寸，这可以通过范围设置进行变化。
- en: Particle rotation
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 粒子旋转
- en: The particle rotation controls the speed at which a particle rotates. Again,
    you can have a shrapnel rotating as it flies from the explosion.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子旋转控制粒子旋转的速度。同样，您可以让碎片在飞行过程中旋转。
- en: Particle color
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 粒子颜色
- en: The particles created by an emitter can change colors during their life. To
    add a new color in the life cycle timeline, click on the color ramp at the location
    where the color is to change and select a new color (think of creating a gradient
    in Photoshop or Illustrator). You can also change an existing color by double-clicking
    on the marker to display the color selection.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 发射器创建的粒子在其生命周期中可以改变颜色。要在生命周期时间轴中添加新颜色，请点击颜色渐变中颜色要改变的位置并选择新颜色（想想在Photoshop或Illustrator中创建渐变）。您也可以通过双击标记来更改现有颜色，以显示颜色选择。
- en: To remove a color from the gradient, click and drag it downward.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要从渐变中移除一种颜色，请点击并向下拖动它。
- en: The color blend option controls how many colors in the particles texture image,
    and how they blend with the main color in the color gradient.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色混合选项控制粒子纹理图像中的颜色数量以及它们如何与颜色渐变中的主颜色混合。
- en: The greater the **Factor** option, the more the colors blend, where **0** causes
    no blending.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**因子**选项越大，颜色混合越多，其中**0**表示不混合。'
- en: Particle blend mode
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 粒子混合模式
- en: 'The blend mode option controls the way in which the particle image blends with
    the scene. The available options are as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 混合模式选项控制粒子图像与场景混合的方式。可用选项如下：
- en: '**Alpha**: This blends transparent backgrounds in the particle image.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Alpha**: 这在粒子图像中混合透明背景。'
- en: '**Add**: This adds the particle pixels to the corresponding background image
    pixels.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加法**: 这将粒子像素添加到相应的背景图像像素。'
- en: '**Subtract**: This subtracts the particle pixels from the corresponding background
    image pixels.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减法**: 这将从相应的背景图像像素中减去粒子像素。'
- en: '**Multiply**: This multiplies the particle pixels by the corresponding background
    image pixels. This results in a darker particle effect.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**乘法**: 这将粒子像素乘以相应的背景图像像素。这导致粒子效果更暗。'
- en: '**MultiplyX2**: This creates a darker particle effect than the standard multiply
    mode.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**乘以2**: 这比标准乘法模式创建的粒子效果更暗。'
- en: '**Screen**: This inverts pixels, then multiplies and inverts them a second
    time. This results in lighter particle effects (great for flame effects or sparks).'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**屏幕**: 这会反转像素，然后乘以并再次反转它们。这导致粒子效果更亮（非常适合火焰效果或火花）。'
- en: '**Replace**: This results in no blending with the background. Only the particle''s
    colors are used.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**替换**: 这导致与背景不混合。仅使用粒子的颜色。'
- en: 'To implement our particles into the scene, let''s go on over to our `GameLevelScene.m`
    file, and in the `initWithSize` method inside the `if (self = [super initWithSize:size])`
    parentheses, add the following block of code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要将我们的粒子实现到场景中，让我们转到我们的`GameLevelScene.m`文件，并在`initWithSize`方法中的`if (self = [super
    initWithSize:size])`括号内添加以下代码块：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Build and run to see the great results!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行以查看出色的结果！
- en: '![Particle blend mode](img/B03553_04_07.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![粒子混合模式](img/B03553_04_07.jpg)'
- en: It looks great, but now that we have it in the scene, I don't quite like the
    look of the rain; I want to tweak it so that it looks a little more realistic.
    Let's go to the particle editor (again, by clicking on the particle file in our
    project explorer) and increase the birthrate of the particles.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很棒，但现在它在场景中，我不太喜欢雨的外观；我想调整它，使其看起来更逼真。让我们回到粒子编辑器（再次，通过点击项目资源管理器中的粒子文件）并增加粒子的出生率。
- en: Currently, the birthrate is at 150, but I want it to be pouring, so I will increase
    it to 2500\. I will also change the scale down from 0.1 to 0.02 because I think
    the raindrops look way too big. I'll also change the speed to 500 so that it looks
    a little more torrential.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，出生率是150，但我想让它汹涌，所以我将把它增加到2500。我还会将比例从0.1减小到0.02，因为我认为雨滴看起来太大。我还会将速度改为500，以便看起来更猛烈。
- en: '![Particle blend mode](img/B03553_04_08.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![粒子混合模式](img/B03553_04_08.jpg)'
- en: That does look a lot better! It's tough to tell on paper but the effect looks
    great on screen.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来确实好多了！虽然纸张上很难看出效果，但屏幕上的效果看起来很棒。
- en: Now that we have the rain looking awesome, let's add in some flames and smoke
    effects to our wrecked ship. Create a new particle file, and instead of selecting
    rain in the template creator, select fire, then save it.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们让雨看起来很棒，让我们在我们的破损船只中添加一些火焰和烟雾效果。创建一个新的粒子文件，在模板创建器中选择雨而不是火焰，然后保存。
- en: Our fire effect will be implemented differently as we want it to scroll with
    the map. With the rain, we added it to the current screen so that it doesn't move
    with the scene but with the fire. If we were to add it to the scene the same way
    we did the rain, the particles would stay in the same position according to the
    screen, not the whole map.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将根据需要以不同的方式实现火焰效果，使其与地图一起滚动。对于雨，我们将其添加到当前屏幕上，这样它就不会随着场景移动，而是与火焰一起移动。如果我们以同样的方式将雨添加到场景中，那么粒子将根据屏幕而不是整个地图保持在同一位置。
- en: 'Back in our `GameLevelScene.m` file, in the same location where we added our
    rain emitter code, add in the following method:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的`GameLevelScene.m`文件，在添加我们的雨发射器代码的同一位置，添加以下方法：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: See the difference in code? Instead of adding the `fireEmitter` as a child to
    `self` or `GameLevelScene` class, we add it directly to the map at `25x` and `50y`,
    so now when the player begins to scroll through the scene, the fire stays put,
    burning away the poor crashed ship.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 看看代码中的区别？我们不是将`fireEmitter`作为`self`或`GameLevelScene`类的子项添加，而是直接将其添加到地图的`25x`和`50y`位置，因此现在当玩家开始滚动场景时，火焰会保持原位，燃烧着那艘不幸坠毁的船只。
- en: '![Particle blend mode](img/B03553_04_09.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![粒子混合模式](img/B03553_04_09.jpg)'
- en: Ignore the extreme drop in frame rate in the screenshot here; whenever I take
    a screenshot, the frame rate plummets, as I am running a slightly older iMac.
    The fire looks good though!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略这里截图中的帧率急剧下降；每次我截图时，帧率都会急剧下降，因为我正在运行一台稍微旧一点的iMac。不过火焰看起来还不错！
- en: I did, however, notice that the frame rate stuck at an almost constant 30fps
    with the flames on the screen. This is where the performance and battery drainage
    comes into play.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我注意到当屏幕上有火焰时，帧率几乎保持在30fps的恒定值。这就是性能和电池消耗开始发挥作用的地方。
- en: I'm running the iPhone 4S simulator in Xcode because it fits properly on my
    screen, which means people with older devices will have difficulty running this
    game, especially when graphic-intensive elements come onto screen like the particle
    effects.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我在Xcode中运行iPhone 4S模拟器，因为它可以适当地显示在我的屏幕上，这意味着拥有较老设备的用户将难以运行这款游戏，尤其是在屏幕上出现图形密集型元素，如粒子效果时。
- en: However, running it on my iPhone 5S, the game hit an average of 60fps. These
    are all the things we have to take into consideration before we publish our game.
    We will discuss this later on in this book.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我的iPhone 5S上运行时，游戏的平均帧率达到了60fps。在我们发布游戏之前，我们必须考虑所有这些因素。我们将在本书的后面讨论这个问题。
- en: Now, let's create a menu system!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个菜单系统！
- en: Creating menus and multiple levels
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建菜单和多个关卡
- en: Our game is looking really good, but instead of simply throwing the player into
    the gameplay, let's talk about menus.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏看起来真的很不错，但与其简单地将玩家投入游戏，让我们来谈谈菜单。
- en: Menus are pretty important (obviously). It's the stepping stone into the gameplay,
    and its absence can leave the players dazed and confused. We don't want that now,
    do we?
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单非常重要（显然）。它是进入游戏玩法的基础，其缺失可能会让玩家感到困惑。我们不想这样，对吧？
- en: As we've been going crazy with our level development, we haven't focused on
    the structure of the game; namely, we've done everything without taking menus
    or any other functionality into consideration.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在关卡开发上已经变得非常疯狂，我们没有关注游戏的结构；也就是说，我们没有考虑菜单或其他任何功能就完成了所有事情。
- en: First off, I've included some more images for your use that need to be imported
    into the project for the following code to work. If you have your own images,
    simply change the name of the button image accordingly.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我为您添加了一些更多需要导入到项目中才能使以下代码正常工作的图片。如果您有自己的图片，只需相应地更改按钮图片的名称即可。
- en: 'Now, we have to make some substantial modifications to our `GameLevelScene.m`
    file. First things first, we need to create a new integer variable. This will
    count our levels, with level `0` being our main menu. So, in the `@interface GameLevelScene
    ()` method where we begin our declarations, let''s add in one more declaration:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须对我们的`GameLevelScene.m`文件进行一些实质性的修改。首先，我们需要创建一个新的整型变量。这个变量将计算我们的关卡数，其中关卡`0`是我们的主菜单。因此，在`@interface
    GameLevelScene ()`方法中，我们开始声明时，让我们添加一个额外的声明：
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, let's do some editing!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进行一些编辑！
- en: 'Let''s start off with the `initWithSize` method. We will edit it so that it
    looks as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`initWithSize`方法开始。我们将编辑它，使其看起来如下：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: All the init code we had in there originally is now gone. We have placed a nice
    little label and a button. We also changed the background to black but that part
    isn't important. Notice how we name the `playButton`? This comes in handy when
    we detect player touches, which you'll see in a moment.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们原本在该处所有的初始化代码现在都不见了。我们放置了一个漂亮的标签和按钮。我们还把背景改成了黑色，但那部分并不重要。注意我们是如何命名`playButton`的？当我们检测到玩家触摸时，这会很有用，你很快就会看到。
- en: 'Now, let''s scroll on down to our `touchesBegan` method and add the following
    code inside the `for` method:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续向下滚动到我们的`touchesBegan`方法，并在`for`方法内添加以下代码：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we add a new SpriteKit node that is created at the location of your touch.
    We then detect whether that node is touching our play button, and then we set
    up all our level 1 stuff.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在触摸的位置创建一个新的SpriteKit节点。然后我们检测该节点是否触摸了我们的播放按钮，然后设置所有关卡1的内容。
- en: I will also change how the game over is handled. As of this moment, when the
    player dies, the screen pops up saying **You have died**, followed by the big
    `replay` button. If we were to leave it as it is, that `replay` button method
    resets the entire game, and I don't think people want to lose their progress when
    they die in a level.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我还会改变游戏结束的处理方式。到目前为止，当玩家死亡时，屏幕会弹出显示**你已死亡**，然后是大的`重放`按钮。如果我们保持原样，那么这个`重放`按钮方法会重置整个游戏，我不认为人们希望在关卡中死亡时丢失他们的进度。
- en: 'Make the following changes to the code. We will delete the highlighted code
    and replace it with this text:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对代码进行以下更改。我们将删除高亮显示的代码并用以下文本替换：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, when you test it and the player dies, he simply teleports to the beginning
    of the level instead of having the `replay` button pop up, which could prove to
    be intrusive after a while.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你测试它并且玩家死亡时，他只是简单地传送到关卡开始处，而不是弹出`重放`按钮，这可能会在一段时间后变得侵扰性。
- en: 'With our menu built, when you build and run the project, the main menu should
    look like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建菜单后，当你构建并运行项目时，主菜单应该看起来像这样：
- en: '![Creating menus and multiple levels](img/B03553_04_10.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![创建菜单和多个关卡](img/B03553_04_10.jpg)'
- en: We will now implement multiple levels, as I'm pretty sure players would get
    bored of playing the same level over and over again. I created a new level for
    you in the resources section of this book. For this level, our player will locate
    his lost equipment, but in order to find it, the player needs to work around a
    little trap in the level.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将实现多个关卡，因为我非常确信玩家会厌倦一遍又一遍地玩同一个关卡。我在这本书的资源部分为你创建了一个新关卡。对于这个关卡，我们的玩家将找到他丢失的装备，但为了找到它，玩家需要在关卡中绕过一个小陷阱。
- en: 'Once you''ve imported the `level2.tmx` file into your project, hop on to `GameLevelScene.m`
    file and scroll down to our `didHeWin` method and edit it to look as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将`level2.tmx`文件导入到你的项目中，打开`GameLevelScene.m`文件并向下滚动到我们的`didHeWin`方法，并编辑它如下所示：
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This new method still detects the player's position, but now we set up a secondary
    `if` statement that detects the level the player is on. In this case, if the level
    is equal to 1, we then remove the current map from the view, and we add the `level2.tmx`
    file to the view as a child. After this, we relocate the player to the beginning
    position in the level and check again for the map layers. Fairly easy, right?
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新方法仍然检测玩家的位置，但现在我们设置了一个二级`if`语句来检测玩家所在的关卡。在这种情况下，如果关卡等于1，我们就从视图中移除当前地图，并将`level2.tmx`文件作为子项添加到视图中。之后，我们将玩家重新定位到关卡的开始位置并再次检查地图层。相当简单，对吧？
- en: Don't forget to reimport the `tileSet.png` and `tileSet@2x.png` files with the
    ones provided for this chapter, as they contain the new tiles. If you don't reimport
    these, Xcode will either throw an error or our new tiles just won't appear!
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记重新导入`tileSet.png`和`tileSet@2x.png`文件，使用本章提供的文件，因为它们包含新的瓦片。如果你不重新导入这些文件，Xcode可能会抛出错误，或者我们的新瓦片根本不会显示出来！
- en: You can now build and run our project; now, when the player reaches the end
    of the level, it should switch over to the next level, which as you can see by
    the following image, looks pretty awesome!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以构建并运行我们的项目；现在，当玩家到达关卡末尾时，它应该切换到下一个关卡，正如你从以下图像中可以看到的，看起来相当酷！
- en: '![Creating menus and multiple levels](img/B03553_04_11.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![创建菜单和多个关卡](img/B03553_04_11.jpg)'
- en: Yes! Our game is coming together more and more! However, as awesome as our game
    looks, it's pretty darn boring without any enemies! Let's give our little spaceman
    some competition.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 是的！我们的游戏越来越有形了！然而，尽管我们的游戏看起来很酷，但没有敌人，它相当无聊！让我们给我们的太空人一些竞争。
- en: Creating enemies
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建敌人
- en: This game isn't simply an exploration game! We need to make this game intense
    and exciting!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这款游戏不仅仅是探险游戏！我们需要让这款游戏变得紧张刺激！
- en: Go ahead and import the Squiggy set of images that I've included, or again you
    can use your own.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，导入我包含的Squiggy图像集，或者你也可以使用你自己的。
- en: '![Creating enemies](img/B03553_04_12.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![创建敌人](img/B03553_04_12.jpg)'
- en: In our `GameLevelScene.m` file, we will add a new method to begin spawning random
    enemies. These ones will start off easy, but we will get into some baddies that
    will actually try to kill you!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`GameLevelScene.m`文件中，我们将添加一个新的方法来开始生成随机的敌人。这些敌人一开始很简单，但我们将遇到一些真正的坏蛋，它们会试图杀死你！
- en: 'Anyways, anywhere within the `GameLevelScene.m` file, add the following method:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，在`GameLevelScene.m`文件中的任何位置，添加以下方法：
- en: '[PRE19]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This method creates the Squiggy sprite node. Then, we create a random *y* axis
    coordinate to spawn our Squiggy. Why a random *y* axis? *y* you ask? (ah, pun
    intended). Our Squiggy is a flying creature, of course! We also spawn him a little
    past the visible edge of the screen so that it looks like he's flying into the
    scene, hence we will add the Squiggy 1000px beyond the position of the player.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法创建了一个Squiggy精灵节点。然后，我们创建一个随机的*y*轴坐标来生成我们的Squiggy。为什么是随机的*y*轴？*y*你问？（啊，双关语）。我们的Squiggy当然是一种飞行生物！我们还让他出现在屏幕可见边缘之外，这样看起来就像他正在飞入场景，因此我们将Squiggy放置在玩家位置1000px之外。
- en: We will add him as a child of the map because we want him to scroll with the
    map, as well as give him a name so that we can do our collision detection.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把他作为地图的子项添加，因为我们希望他随着地图滚动，同时给他一个名字，这样我们就可以进行碰撞检测。
- en: Then, we set a random speed range for our Squiggies to be flying at. Then we
    create the actions for SpriteKit to get them flying.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为Squiggies设置一个随机的速度范围，然后创建SpriteKit的动作来让它们飞行。
- en: 'We now need to implement two new properties in our `GameLevelScene.m` class.
    These new classes will control the spawn rate of our Squiggies. So, at the top
    of the class file, add the following implementations:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要在`GameLevelScene.m`类中实现两个新的属性。这些新类将控制Squiggies的生成速率。因此，在类文件顶部，添加以下实现：
- en: '[PRE20]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We will use the `lastSpawnTimeInterval` method to keep track of the elapsed
    time since we spawned a Squiggy and the `lastUpdateTimeInterval` method to detect
    the time elapsed since the last update.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`lastSpawnTimeInterval`方法来跟踪自我们生成Squiggy以来经过的时间，以及`lastUpdateTimeInterval`方法来检测自上次更新以来经过的时间。
- en: 'We are now going to create a new update method, but don''t worry, it won''t
    interfere with our main `update` method. Go ahead and add this method anywhere
    in the `GameLevelScene.m` file:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将创建一个新的更新方法，但别担心，它不会干扰我们的主要`update`方法。你可以将这个方法添加到`GameLevelScene.m`文件的任何位置：
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Build, run, and forecast calls for scattered showers and Squiggies! The result
    looks pretty cool! We need to make our player get hurt when he touches a Squiggy.
    Hey, they look cute, but they're dangerous!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 构建、运行和预测散布阵雨和Squiggies！结果看起来相当酷！我们需要让玩家在接触Squiggy时受伤。嘿，它们看起来很可爱，但它们很危险！
- en: '![Creating enemies](img/B03553_04_13.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![创建敌人](img/B03553_04_13.jpg)'
- en: We need to do some work with physics here, so bare with me.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里需要做一些与物理相关的工作，所以请耐心等待。
- en: 'At the top of our `GameLevelScene.m` class, between the `@interface` and the
    `#import` section, add the following two lines of code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GameLevelScene.m`类的顶部，在`@interface`和`#import`部分之间，添加以下两行代码：
- en: '[PRE22]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: These lines set up two categories, one for the enemies and one for the players.
    We will later add another category for player and enemy projectiles when we incorporate
    shooting.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行设置了两个类别，一个用于敌人，一个用于玩家。当我们加入射击功能时，我们将为玩家和敌人的弹丸添加另一个类别。
- en: 'We now need to set up the physics of the world, so inside of our `initWithSize`
    method, we need to add the following lines of code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要设置世界的物理，因此在我们`initWithSize`方法内部，我们需要添加以下代码行：
- en: '[PRE23]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding code sets up the world gravity and sets the scene as the delegate
    that will be notified when two objects collide (or physics bodies).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码设置了世界重力，并将场景设置为当两个对象碰撞（或物理体）时将被通知的委托。
- en: Physic body is anything within the level, such as the character, objects, or
    enemies that are controlled by physics.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 物理体是级别内的任何东西，例如由物理控制的角色、对象或敌人。
- en: 'Inside of our `addSquiggy` method, we need to add the following lines of code,
    just after we create the actual Squiggy sprite:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`addSquiggy`方法内部，我们需要在创建实际的Squiggy精灵之后添加以下代码行：
- en: '[PRE24]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: What does this code do, you ask? Well, let me explain!
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你问这段代码是做什么的？好吧，让我来解释一下！
- en: The first line creates a physics body for our Squiggy sprite. The body is the
    rectangle surrounding the sprite. The next line sets the sprite to be dynamic,
    meaning that the SpriteKit physics engine will have no bearing over the movement
    of our Squiggy. The only thing that controls it is our code. The third line puts
    our Squiggy into the `enemyCategory` method.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行为我们的Squiggy精灵创建了一个物理体。这个体是围绕精灵的矩形。下一行将精灵设置为动态，这意味着SpriteKit物理引擎将不会影响我们的Squiggy的运动。唯一控制它的是我们的代码。第三行将我们的Squiggy放入`enemyCategory`方法中。
- en: We then tell the engine which category method, if a collision occurs between
    the two objects, should notify us. Obviously, we selected the `playerCategory`
    method.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们告诉引擎，如果两个对象之间发生碰撞，应该通知我们的类别方法。显然，我们选择了`playerCategory`方法。
- en: The next and final line we added is a bit of a doozy to understand, we set the
    `collisionBitMask` value to `0`. The collision bit mask defines the response of
    each object when a collision occurs. In our case, we set it to `0`, meaning that
    they won't react to each other as far as a ricochet or bounce is concerned.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来和最后的行我们添加的是一个有点难以理解的东西，我们将`collisionBitMask`值设置为`0`。碰撞位掩码定义了每个对象在发生碰撞时的响应。在我们的情况下，我们将其设置为`0`，这意味着它们在反弹或弹跳方面不会相互反应。
- en: 'We need to add similar code for our player when we create it, so let''s create
    a new method that we will call each time our player is created (that is, just
    after he dies, or spawns a new level, and so on):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建玩家时，我们需要添加类似的代码，所以让我们创建一个新的方法，我们将每次我们的玩家被创建时调用它（即在他死后，或者生成新关卡等）：
- en: '[PRE25]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is the same method that we used to set up our enemy's physics; we just
    switched around the categories.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们用来设置敌人物理的方法；我们只是改变了分类。
- en: 'Now, at the bottom of the `didHeWin` method, as well as in the `touchesBegan`
    method where we set up our player after we touch the button, add this line of
    code:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`didHeWin`方法的底部，以及在我们触摸按钮后设置玩家后的`touchesBegan`方法中，添加以下代码行：
- en: '[PRE26]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Super duper easy peasy! Now we need to actually detect the collisions between
    the two objects.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 超级简单！现在我们需要实际检测两个对象之间的碰撞。
- en: 'We need to add the following method anywhere in our `GameLevelScene.m` class
    file:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在我们的`GameLevelScene.m`类文件中的任何地方添加以下方法：
- en: '[PRE27]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We still have to add the `bulletCategory` function, so if you were to build
    the project right now, it would show you an error. Don''t worry, we will add it
    in just a few moments. Finally, we will make some slight adjustments to our `GameOver`
    method:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要添加`bulletCategory`函数，所以如果你现在构建项目，它将显示错误。别担心，我们将在几分钟内添加它。最后，我们将对我们的`GameOver`方法做一些轻微的调整：
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we changed our code so every time our player is killed, he is removed
    from the scene, and a new player is created at the beginning of the level. Also,
    the physics is set up yet again.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们更改了我们的代码，每次我们的玩家被杀死时，他都会从场景中移除，并在关卡开始处创建一个新的玩家。此外，物理设置再次进行。
- en: After testing a few methods, the above method is the one that worked the best.
    I simply teleported our player about 100px ahead of the normal beginning position.
    No idea why. This works though!
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试了几种方法之后，上述方法是效果最好的。我只是将我们的玩家传送到了正常起始位置前方大约100px的位置。不知道为什么。但这确实有效！
- en: Now let's get shooting!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始射击！
- en: 'To begin with, we will add another category like we did earlier; this will
    be as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将添加另一个类别，就像我们之前做的那样；这将如下所示：
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We will now use this for our player''s bullets. Also, we want to add a new
    definition, so just under the `#import` section, add the following line of code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将使用这个方法来处理玩家的子弹。此外，我们还想添加一个新的定义，所以就在`#import`部分下面，添加以下代码行：
- en: '[PRE30]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This definition will assist in creating an array for all our bullets, which
    we will do a little further in just a bit.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义将帮助我们创建一个用于所有子弹的数组，我们将在稍后进行。
- en: 'Just above the `@implementation` line and just before the `@end` line of our
    property declarations, add the following two lines of code:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在`@implementation`行上方和属性声明`@end`行之前，添加以下两行代码：
- en: '[PRE31]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We created the player bullet array that will allow us to create multiple bullets
    at once. We then defined the number of the next bullet within the array.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个玩家子弹数组，这将允许我们一次创建多个子弹。然后我们在数组中定义了下一个子弹的编号。
- en: 'Inside our `setUpPlayerPhysics` method, add the following block of code (don''t
    forget to import all the images located in the resource section of this book):'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`setUpPlayerPhysics`方法内部，添加以下代码块（不要忘记导入本书资源部分中所有位于资源部分的图像）：
- en: '[PRE32]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Welcome to arrays! What does all this mean? Easy! We take the `_playerBullets`
    array, initialize it with a predefined number of bullets in the array; the `kNumBullets`
    variable which was `20`. So now the array has a value of `20`. Then, for every
    entry in the array, from `0`-`20`, add a bullet. It really is that easy.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到数组！这一切意味着什么？简单！我们取`_playerBullets`数组，用预定义的子弹数量初始化它；`kNumBullets`变量，它是`20`。所以现在数组有`20`个值。然后，对于数组中的每个条目，从`0`到`20`，添加一个子弹。这真的很简单。
- en: 'We will create a new method, which will be as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的方法，如下所示：
- en: '[PRE33]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We will call the preceding method when the player presses the play button,
    so in our `touchesBegan` method, at the bottom of the `if ([node.name isEqualToString:@"playButton"])
    {` statement, add the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家按下播放按钮时，我们将调用前面的方法，所以在我们`touchesBegan`方法中，在`if ([node.name isEqualToString:@"playButton"])
    {`语句的底部，添加以下代码：
- en: '[PRE34]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, we need to create a new touch zone. So, in our `touchesBegan` method,
    we need to edit our `if (touchLocation.x > self.size.width / 2.0) {` statement
    to the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个新的触摸区域。所以，在我们的`touchesBegan`方法中，我们需要编辑我们的`if (touchLocation.x > self.size.width
    / 2.0) {`语句，改为以下内容：
- en: '[PRE35]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, we selected one of the bullets within the array. We then set the position
    of that bullet at the player's position. Next, we set the bullet's final position
    off the screen, which is why we added two methods, one if the player presses the
    button when walking backward, and the other going forward.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从数组中选择了其中一个子弹。然后，我们将该子弹的位置设置为玩家的位置。接下来，我们将子弹的最终位置设置在屏幕之外，这就是为什么我们添加了两种方法，一种是在玩家向后走时按按钮，另一种是向前走。
- en: 'Now, when you test it you will see the following output:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你测试它时，你会看到以下输出：
- en: '![Creating enemies](img/B03553_04_14.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![创建敌人](img/B03553_04_14.jpg)'
- en: Lots of pew pew! And it shoots according to the direction you're facing too,
    so that's pretty awesome.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 很多“砰砰”声！它还会根据你面对的方向射击，所以这真的很酷。
- en: 'Now, back in our `setUpPlayerPhysics` method, where we set up the bullets,
    we need to set the `physicsBody` value for each bullet. In the `for` loop, just
    before we add the bullet to the map as a child, add the following code:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到我们的`setUpPlayerPhysics`方法，在那里我们设置子弹，我们需要为每个子弹设置`physicsBody`值。在`for`循环中，在我们将子弹作为子项添加到地图之前，添加以下代码：
- en: '[PRE36]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This is the same as our previous `physicsBody` setup, except we changed the
    bullet's category to the `bulletCategory`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们的之前的`physicsBody`设置相同，只是我们将子弹的分类更改为`bulletCategory`。
- en: Now, when you test your project, you should be shooting, dying, and killing
    without a care in the world! Isn't it great?
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你测试你的项目时，你应该能够射击、死亡和杀戮，而毫不在意！这不是很棒吗？
- en: '![Creating enemies](img/B03553_04_15.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![创建敌人](img/B03553_04_15.jpg)'
- en: If it is working for you, great! I'm happy for you! We've done a lot of work
    in this chapter and our game really isn't even close to finishing. Why not try
    to take what you've learned in this chapter and create your own levels? Spawn
    some new enemies, and maybe try having some shooting baddies? If not, I'll cover
    some crazier baddies later on in this book. For now let's go take a break!
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它对你有效，那就太好了！我很高兴为你感到高兴！我们在本章中做了很多工作，我们的游戏甚至还没有接近完成。为什么不尝试用本章学到的知识创建自己的关卡呢？生成一些新的敌人，也许尝试一些射击的坏蛋？如果不这样做，我会在本书的后面部分介绍一些更疯狂的坏蛋。现在，让我们休息一下！
- en: 'Our game is running efficiently, running at an almost constant 60 fps! Awesome!
    In case you don''t have things working just right, the following is the complete
    source code you should have up until now:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏运行效率很高，几乎以恒定的60 fps运行！太棒了！如果你没有正确设置，以下是你现在应该有的完整源代码：
- en: '[PRE37]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Summary
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Let's recall all that we covered in this chapter. We added some music and cool
    sound effects to our game. Then, we gave our player a proper walking animation
    so that he doesn't look like he's floating in the air! However, if that's not
    an effect you're looking for, you can save yourself a bunch of typing. Next, we
    made some really awesome looking particles! We made it rain, and we made the wrecked
    ship burn in flames!
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下本章中我们所学到的内容。我们在游戏中添加了一些音乐和酷炫的声音效果。然后，我们给玩家添加了一个合适的行走动画，这样他就不会看起来像是在空中漂浮！然而，如果你不想要这种效果，你可以节省很多打字。接下来，我们制作了一些看起来非常酷炫的粒子效果！我们让雨下起来，还让被毁的船只燃烧起来！
- en: We briefly discussed menus, and how we can create a simple main menu. We will
    polish this up later when preparing for publishing.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要讨论了菜单，以及我们如何创建一个简单的主菜单。我们将在准备发布时进一步完善它。
- en: Then, the enemies! We made our Squiggies, those cute yet dangerous enemies in
    our game. Things are going to get scary, so buckle up and enjoy the ride.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，敌人！我们创造了我们的Squiggies，那些既可爱又危险的敌人。事情将会变得可怕，所以系好安全带，享受这段旅程吧。
- en: 'Note: It will only get scary for our player, and not for us because we are
    the ones creating the madness.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：只有我们的玩家会感到可怕，而我们不会，因为我们才是创造混乱的人。
