- en: 2D arrays / matrices
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二维数组/矩阵
- en: A common collection type used in physics calculations, graphics, and game design,
    particularly grid-based puzzle games, is two-dimensional arrays / matrices. 2D
    arrays are simply arrays that have arrays as their members. These arrays can be
    expressed in a rectangular fashion in rows and columns.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在物理学计算、图形设计和游戏设计中，尤其是基于网格的益智游戏中，常用的一个集合类型是二维数组/矩阵。二维数组简单来说就是数组的成员也是数组。这些数组可以以行列的形式以矩形方式表达。
- en: 'For example, the 4x4 (4 rows, 4 columns) tile board in the 15-puzzle game can
    be represented as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，15个拼图游戏中的4x4（4行，4列）拼图板可以表示如下：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the 15 puzzle game, your goal is to shift the tiles using the one empty spot
    (represented with the blank string `""`), to all end up in the 1-15 order as we
    saw. The game would start with the numbers arranged in a random and solvable order,
    and the player would then have to swap the numbers and the blank space.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在15个拼图游戏中，你的目标是使用一个空位（用空字符串`""`表示）移动拼图，使它们最终按照我们看到的1-15的顺序排列。游戏开始时，数字会以随机且可解的顺序排列，然后玩家必须交换数字和空白空间。
- en: Tip
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To better perform various actions on and/or store information about each tile
    in the 15 game (and other games), it'd be better to create a tile object as opposed
    to using raw values seen here. For the sake of understanding what a matrix or
    2D array is, simply make a note of how the array is surrounded by doubly encapsulated
    brackets `[[]]`. We will later use one of our example games, `SwiftSweeper`, to
    better understand how puzzle games use 2D arrays of objects to create a full game.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地执行对15游戏（和其他游戏）中每个拼图的各种操作和/或存储有关每个拼图的信息，最好创建一个拼图对象，而不是使用这里看到的原始值。为了理解矩阵或二维数组是什么，只需注意数组是如何被双重括号`[[]]`包围的。我们将在后面的示例游戏中使用`SwiftSweeper`来更好地理解益智游戏是如何使用对象的二维数组来创建完整游戏的。
- en: 'Here are ways to declare blank 2D arrays with strict types:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些声明空白二维数组的方法，使用严格类型：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The variable `twoDTileArray` uses the double brackets `[[Tiles]]` to declare
    it as a blank 2D array/matrix for the made-up type, tiles. The variable `anotherArray`
    is a rather oddly declared array that uses angle bracket characters `<>` for enclosures.
    It utilizes what's known as **Generics**. Generics is a rather advanced topic
    that we will touch more on later. They allow very flexible functionality among
    a wide array of data types and classes. For the moment, we can think of them as
    a catch-all way of working with objects.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`twoDTileArray`使用双括号`[[Tiles]]`来声明它为一个空白的二维数组/矩阵，用于虚构的类型，即`tiles`。变量`anotherArray`是一个相当奇怪的声明数组，它使用尖括号字符`<>`作为括号。它使用的是所谓的**泛型**。泛型是一个相当高级的话题，我们将在后面更多地讨论。它们允许在广泛的数据类型和类之间实现非常灵活的功能。目前，我们可以将其视为处理对象的一种通用的方法。
- en: To fill in the data for either version of this array, we would then use for-loops.
    More on loops and iterations will be explained later in the chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要填充数组的这两种版本的数据，我们就会使用for循环。关于循环和迭代的更多内容将在本章后面解释。
- en: Sets
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合
- en: 'This is how we would make a set of various game items in Swift:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何在Swift中创建各种游戏物品集合的方法：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This set `keyItems` has various objects and a character `A`. Unlike an array,
    a set is not ordered and contains unique items. So, unlike `stageNames`, attempting
    to get `keyItems[1]` would return an error and `items[1]` might not necessarily
    be the `Holy_Armor` object, as the placement of objects is internally random in
    a set. The advantage sets have over arrays is that sets are great at checking
    for duplicated objects and specific content searching in the collection overall.
    Sets make use of hashing to pinpoint the item in the collections, so checking
    for items in a set's content can be much faster than in an array. In game development,
    a game's key items, which the player may only get once and should never have duplicates
    of, could work great as a set. Using the function `keyItems.contains(Boss_Key)`
    returns the Boolean value of `true` in this case.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`keyItems`集合包含各种对象和一个字符`A`。与数组不同，集合是无序的，包含唯一的项。因此，与`stageNames`不同，尝试获取`keyItems[1]`会返回错误，而`items[1]`可能不一定是`Holy_Armor`对象，因为在集合中对象的放置是内部随机的。集合相对于数组的优势在于，集合非常适合检查集合中的重复对象和特定内容搜索。集合使用散列来定位集合中的项目，因此检查集合内容中的项目可能比在数组中更快。在游戏开发中，游戏的关键物品，玩家可能只能获得一次且不应有重复，可以作为集合使用得很好。使用函数`keyItems.contains(Boss_Key)`在这种情况下返回`true`的布尔值。
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Sets were added in Swift 1.2 and Xcode 6.3\. Their class is represented by the
    generic type `Set<T>`, where `T` is the class type of the collection. In other
    words, the set, `Set([45, 66, 1233, 234])`. would be of the type `Set<Int>`, and
    our example here would be a `Set<NSObject>` instance due to it having a collection
    of various data types.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是在 Swift 1.2 和 Xcode 6.3 中添加的。它们的类由泛型类型 `Set<T>` 表示，其中 `T` 是集合的类类型。换句话说，集合
    `Set([45, 66, 1233, 234])` 将是 `Set<Int>` 类型，而我们的示例将是一个 `Set<NSObject>` 实例，因为它包含各种数据类型的集合。
- en: We will discuss more on Generics and class hierarchy later in this chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面讨论更多关于泛型和类层次的内容。
- en: Dictionaries
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字典
- en: 'A dictionary can be represented this way in Swift:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，字典可以这样表示：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Dictionaries use a `key : value` association, so `playerInventory[22]` returns
    the value `StrengthBooster` based on the key `22`. Both the key and value could
    be initialized to almost any class type***. In addition to the inventory example
    given, we can have the following code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '字典使用 `键 : 值` 关联，因此 `playerInventory[22]` 根据键 `22` 返回值 `StrengthBooster`。键和值都可以初始化为几乎任何类类型***。除了给出的库存示例外，我们还可以有以下的代码：'
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '***The values of a dictionary, though rather flexible in Swift, do have limitations.
    The key must conform to what''s known as the hashable protocol. Basic data types,
    such as `Int` and `String`, already have this functionality. So, if you are to
    make your own classes / data structures that are to be used in dictionaries, say
    mapping a player actions with player input, this protocol must be utilized first.
    We will discuss more about protocols later in this chapter.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '***在 Swift 中，尽管字典的值相当灵活，但确实存在限制。键必须符合所谓的可哈希协议。基本数据类型，如 `Int` 和 `String`，已经具有这种功能。因此，如果你要创建自己的类/数据结构，这些类/数据结构将用于字典，例如将玩家动作与玩家输入映射，必须首先使用此协议。我们将在本章后面讨论更多关于协议的内容。***'
- en: Dictionaries are like sets in that they are unordered but with the additional
    layer of having a key and a value associated with their content instead of just
    the hash key. Like sets, dictionaries are great for quick insertion and retrieval
    of specific data. In iOS apps and in web applications, dictionaries are used to
    parse and select items from JavaScript Object Notation (JSON) data.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 字典类似于集合，因为它们是无序的，但它们还有一个额外的层次，即与内容相关联的键和值，而不是仅仅的哈希键。像集合一样，字典非常适合快速插入和检索特定数据。在
    iOS 应用和 Web 应用中，字典用于解析和选择 JavaScript 对象表示法 (JSON) 数据。
- en: In the realm of game development, dictionaries using JSON or via Apple's internal
    data class, `NSUserDefaults`, can be used to save and load game data, set up game
    configurations, or access specific members of a game's API.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发领域，可以使用 JSON 或通过 Apple 的内部数据类 `NSUserDefaults` 来保存和加载游戏数据、设置游戏配置或访问游戏 API
    的特定成员。
- en: 'For example, here''s one way to save a player''s high score in an iOS game
    using Swift:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是在 iOS 游戏中使用 Swift 保存玩家最高分的其中一种方法：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code comes directly from a published Swift-developed game named PikiPop,
    which we will use from time to time to show code used in actual game applications.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码直接来自一个名为 PikiPop 的已发布的 Swift 开发游戏，我们将不时使用它来展示实际游戏应用中使用的代码。
- en: Again, note that dictionaries are unordered, but Swift has ways to iterate or
    search through an entire dictionary. We will go more in depth in the next section
    and later on when we move on to loops and control flow.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，字典是无序的，但 Swift 有方法遍历或搜索整个字典。我们将在下一节以及后续的循环和控制流部分进行更深入的讨论。
- en: Mutable/immutable collections
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变/不可变集合
- en: One rather important discussion that we've left out is how to subtract, edit,
    or add to arrays, sets, and dictionaries. However, before we do this, you should
    understand the concept of mutable and immutable data/collections.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遗漏的一个重要讨论是如何从数组、集合和字典中减去、编辑或添加内容。然而，在我们这样做之前，你应该理解可变和不可变数据/集合的概念。
- en: A mutable collection is simple data that can be changed, added to, or subtracted
    from, whereas an immutable collection cannot be changed, added to, or subtracted
    from.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 可变集合是简单的数据，可以对其进行更改、添加或减去，而不可变集合则不能进行更改、添加或减去。
- en: To work with mutable and immutable collections efficiently in Objective-C, we
    had to explicitly state the mutability of the collection beforehand. For example,
    an array of the type `NSArray` in Objective-C is always immutable. There are methods
    we can call on `NSArray` that would edit the collection, but behind the scenes,
    this would be creating brand new `NSArray` objects, thus would be rather inefficient
    to do this often in the life of our game. Objective-C has solved this issue with
    the class type, `NSMutableArray`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Objective-C中有效地处理可变和不可变集合，我们必须事先明确声明集合的可变性。例如，Objective-C中类型为`NSArray`的数组始终是不可变的。我们可以调用`NSArray`上的方法来编辑集合，但幕后，这将创建全新的`NSArray`对象，因此在游戏生命周期中经常这样做会相当低效。Objective-C通过类类型`NSMutableArray`解决了这个问题。
- en: Thanks to the flexibility of Swift's type inference, we already know how to
    make a collection mutable or immutable! The concept of constants and variables
    has us covered when it comes to data mutability in Swift. Using the keyword `let`
    when creating a collection will make that collection immutable, while using `var`
    will initialize it as a mutable collection.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了Swift类型推断的灵活性，我们已经知道如何使集合可变或不可变！在Swift中，关于数据可变性的常量和变量概念已经涵盖了。在创建集合时使用关键字`let`将使该集合不可变，而使用`var`将初始化它为可变集合。
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The array of integers, `unlockedLevels`, can be edited simply because it's a
    variable. The immutable dictionary `playersForThisRound` can't be changed since
    it's already been declared as a constant. There is no additional layer of ambiguity
    concerning additional class types.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 整数数组`unlockedLevels`可以简单地编辑，因为它是一个变量。不可变的字典`playersForThisRound`不能更改，因为它已经被声明为常量。关于额外的类类型没有额外的模糊性。
- en: Editing/accessing collection data
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编辑/访问集合数据
- en: 'As long as a collection type is a variable, using the `var` keyword, we can
    do various edits to the data. Let''s go back to our `unlockedLevels` array. Many
    games have the functionality of unlocking levels as the player progresses. Let''s
    say that the player has reached the high score needed to unlock the previously
    locked level 3 (as `3` isn''t a member of the array). We can add `3` to the array
    using the `append` function:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 只要集合类型是变量，使用`var`关键字，我们就可以对数据进行各种编辑。让我们回到我们的`unlockedLevels`数组。许多游戏在玩家进步时都有解锁级别的功能。假设玩家达到了解锁之前被锁定的第3关所需的高分（因为`3`不是数组的成员）。我们可以使用`append`函数将`3`添加到数组中：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Another neat attribute of Swift is that we can add data to an array using the
    `+=` assignment operator:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Swift的另一个巧妙属性是，我们可以使用`+=`赋值运算符向数组添加数据：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Doing it this way however will simply add `3` to the end of the array. So,
    our previous array `[1, 2, 5, 8]` is now `[1, 2, 5, 8, 3]`. This probably isn''t
    a desirable order, so to insert the number `3` in the third spot, `unlockedLevels[2]`,
    we can use the following method:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这样做只会将`3`添加到数组的末尾。所以，我们之前的数组`[1, 2, 5, 8]`现在变成了`[1, 2, 5, 8, 3]`。这可能不是期望的顺序，因此为了在第三个位置插入数字`3`，即`unlockedLevels[2]`，我们可以使用以下方法：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, our array of unlocked levels is ordered to `[1, 2, 3, 5, 8]`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的解锁级别数组已按`[1, 2, 3, 5, 8]`排序。
- en: This is assuming though that we know a member of the array prior to `3` is sorted
    already. There are various sorting functionalities provided by Swift that could
    help keeping an array sorted. We will leave the details of sorting to our discussions
    of loops and control flow later in this chapter.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在假设我们知道数组中索引为`3`之前的元素已经排序。Swift提供了各种排序功能，可以帮助保持数组排序。我们将把排序的细节留到本章后面的循环和控制流讨论中。
- en: 'Removing items from an array is just simple. Let''s again use our `unlockedLevels`
    array. Imagine that our game has an overworld for the player to travel to and
    from and the player has just unlocked a secret that triggered an event that blocked
    off access to level 1\. Level 1 would now have to be removed from the unlocked
    levels. We can do it like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 从数组中移除项目非常简单。让我们再次使用我们的`unlockedLevels`数组。想象一下，我们的游戏有一个玩家可以前往和返回的开放世界，而玩家刚刚解锁了一个触发事件并阻止访问第1关的秘密。现在必须从解锁的级别中移除第1关。我们可以这样做：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Alternately, imagine that the player has lost all of their lives and got a **Game
    Over** message. A penalty for this could be to lock the furthest level. Though
    probably a rather infuriating method and us knowing that level 8 is the furthest
    level in our array, we can remove it using the `.removeLast()` function of array
    types.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，想象一下，玩家已经失去了所有的生命，并得到了一个 **游戏结束** 的消息。对此的惩罚可能是锁定最远的关卡。尽管这可能是一个相当令人愤怒的方法，并且我们知道第
    8 关是我们数组中最远的关卡，但我们可以使用数组类型的 `.removeLast()` 函数将其删除。
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is assuming that we know the exact order of the collection. Sets or dictionaries
    might be better at controlling certain aspects of your game.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这假设我们知道集合的确切顺序。集合或字典可能更适合控制你游戏中的某些方面。
- en: Here are some ways to edit a set or a dictionary as a quick guide.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些编辑集合或字典的快速指南。
- en: '**Set**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**集合**'
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**Dictionary**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**字典**'
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Iterating through collection types
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迭代集合类型
- en: We can't discuss collection types without mentioning how to iterate through
    them en masse.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在讨论集合类型时不能不提如何成批迭代它们。
- en: 'Here''s some way we''d iterate though an array, a set, or a dictionary in Swift:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们在 Swift 中迭代数组、集合或字典的一些方法：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As stated previously, this is done with what's known as a for-loop; with these
    examples, we show how Swift utilizes the for-in variation using the `in` keyword.
    The code will repeat until it reaches the end of the collection in all of these
    examples. In example `(c)`, we also see the use of the Swift function, `enumerate()`.
    This function returns a compound value, `(index,value)`, for each item. This compound
    value is known as a tuple, and Swift's use of tuples makes for a wide variety
    of functionalities for functions, loops, as well as code blocks.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这是通过所谓的 for-loop 实现的；在这些例子中，我们展示了 Swift 如何使用 `in` 关键字利用 for-in 变体。在这些所有例子中，代码将重复，直到达到集合的末尾。在示例（c）中，我们还看到了
    Swift 函数 `enumerate()` 的使用。这个函数为每个项目返回一个复合值，`(index,value)`。这个复合值被称为元组，Swift 对元组的利用为函数、循环以及代码块提供了广泛的功能。
- en: We will delve more into tuples, loops, and blocks later on.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面更深入地探讨元组、循环和代码块。
- en: Objective-C and Swift comparison
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Objective-C 和 Swift 比较
- en: Here's a quick review of our Swift code with a comparison to the Objective-C
    equivalent.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里快速回顾一下我们的 Swift 代码，并与 Objective-C 的等效代码进行比较。
- en: Objective-C
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Objective-C
- en: 'Here''s a sample code in Objective-C:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 Objective-C 的示例代码：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Swift
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Swift
- en: 'Here''s the equivalent code in Swift:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 Swift 中等效的代码：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding code, we used some examples of variables, constants, arrays,
    sets, and dictionaries. First, we see their Objective-C syntax and then the equivalent
    declarations using Swift's syntax. From this example, we can see how compact Swift
    is compared with Objective-C.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了一些变量、常量、数组、集合和字典的例子。首先，我们看到它们的 Objective-C 语法，然后是使用 Swift 语法等效声明的声明。从这个例子中，我们可以看到
    Swift 与 Objective-C 相比是多么紧凑。
- en: Characters and strings
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符和字符串
- en: 'For some time in this chapter, we''ve been mentioning strings. Strings are
    also a collection of data types, but a specially dealt collection of characters,
    of the class type, string. Swift is Unicode-compliant, so we can have strings
    like the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的某些时间里，我们一直在提到字符串。字符串也是一种数据类型集合，但它是专门处理字符的集合，属于字符串类。Swift 是 Unicode 兼容的，因此我们可以有如下字符串：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can have strings with emoji characters like the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以有如下带有表情符号字符的字符串：
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: What we did in the preceding code was create what's known as a string literal.
    A string literal is when we explicitly define a string around two quotes "".
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个所谓的字符串字面量。字符串字面量是我们明确地在两个引号 "" 中定义字符串。
- en: 'We can create empty string variables for later use in our games such as:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为游戏中的后续使用创建空字符串变量，例如：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Both are valid ways to create an empty string "".
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都是创建空字符串 "" 的有效方式。
- en: String Interpolation
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串插值
- en: We can also create a string from a mixture of other data types, known as **String
    Interpolation**. String Interpolation is rather common in game development, debugging,
    and string use in general.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以从其他数据类型的混合中创建字符串，这被称为**字符串插值**。字符串插值在游戏开发、调试以及一般字符串使用中相当常见。
- en: 'The most notable of examples are displaying the player''s score and lives.
    This is how one of our example games, PikiPop, uses String Interpolation to display
    the current player stats:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最显著的例子是显示玩家的得分和生命值。这就是我们其中一个示例游戏 PikiPop 使用字符串插值来显示当前玩家状态的方式：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Take note of the `\(variable_name)` formatting. We've actually seen this before
    in our past code snippets. In the various `print()` outputs, we used this to display
    the variable, collection, and so on we wanted to get information on. In Swift,
    the way to output the value of a data type in a string is by using this formatting.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`\(variable_name)`的格式化。我们实际上在之前的代码片段中已经见过这种格式化。在各种`print()`输出中，我们使用它来显示我们想要获取信息的变量、集合等。在Swift中，要在字符串中输出数据类型的值，可以使用这种格式化。
- en: 'For those of us who came from Objective-C, it''s the same as the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些来自Objective-C的人来说，这与以下内容相同：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note how Swift makes String Interpolation much cleaner and easier to read than
    its Objective-C predecessor.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意Swift如何使字符串插值比其Objective-C前辈更干净、更容易阅读。
- en: Mutating strings
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改字符串
- en: 'There are various ways to change strings, such as adding characters to a string
    as we did to collection objects. Here are some basic examples:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以更改字符串，例如像我们对集合对象所做的那样向字符串中添加字符。以下是一些基本示例：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Since strings are essentially arrays of characters, like arrays, we can use
    the `+=` assignment operator to add to the previous string.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字符串本质上是由字符组成的数组，就像数组一样，我们可以使用`+=`赋值运算符向之前的字符串中添加内容。
- en: Also, akin to arrays, we can use the `append()` function to add a character
    to the end of a string.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，类似于数组，我们可以使用`append()`函数向字符串的末尾添加一个字符。
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here''s how we iterate through the characters in a string, in Swift:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何在Swift中遍历字符串中的字符：
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note how again we use the for-in loop and even have the flexibility of using
    a string literal if we'd so like to be what's iterated through by the loop.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们再次使用了for-in循环，并且甚至有使用字符串字面量作为迭代内容的灵活性。
- en: String indices
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串索引
- en: Another similarity between arrays and strings is the fact that a string's individual
    characters can be located via indices. Unlike arrays, however, since a character
    can be a varying size of data, broken in 21-bit numbers known as Unicode scalars,
    they can not be located in Swift with `Int` type index values.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 数组和字符串之间的另一个相似之处是，可以通过索引找到字符串的各个字符。然而，与数组不同，由于字符可以是不同大小的数据，可以分解为21位的数字，称为Unicode标量，因此它们不能在Swift中使用`Int`类型的索引值来定位。
- en: Instead, we can use the `.startIndex` and `.endIndex` properties of a string
    and move one place ahead or one place behind the index with the `.successor()`
    and `.predecessor()` functions, respectively, to retrieve the needed character
    or characters of a string.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以使用字符串的`.startIndex`和`.endIndex`属性，并通过`.successor()`和`.predecessor()`函数分别向前或向后移动一个位置，以检索所需的字符或字符。
- en: 'Here are some examples that use these properties and functions using our previous
    `gameText` string:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些使用我们之前的`gameText`字符串的这些属性和函数的示例：
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are many ways to manipulate, mix, remove, and retrieve various aspects
    of strings and characters. For more information, be sure to check out the official
    Swift documentation on characters and strings at [https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/StringsAndCharacters.html](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/StringsAndCharacters.html).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以操作、混合、删除和检索字符串和字符的各种方面。有关更多信息，请务必查看官方Swift文档中关于字符和字符串的说明，链接为[https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/StringsAndCharacters.html](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/StringsAndCharacters.html)。
- en: Commenting in Swift
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swift中的注释
- en: In our code snippets thus far, one might note notations with double forward
    slashes `//` or with forward slashes and asterisks `/* */`. These are how we can
    comment or make notations in our Swift code. Anyone who's coded in C++, Java,
    Objective-C, JavaScript, or other languages will see that Swift works practically
    the same.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们迄今为止的代码片段中，可能会注意到带有双斜杠`//`或带有斜杠和星号的`/* */`的注释。这是我们如何在Swift代码中进行注释或标记的方法。任何在C++、Java、Objective-C、JavaScript或其他语言中编码过的人都会看到Swift实际上工作方式相同。
- en: Single-line comments are started with the double forward slashes, `//`, while
    multiline comments or a comment block begins with `/*` and ends with `*/`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 单行注释以双斜杠`//`开始，而多行注释或注释块以`/*`开始，以`*/`结束。
- en: 'Take the following example:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Commenting is used to help navigate your code, understand what it might do,
    and comment out lines of code we might not want to execute, but at the same time
    want to keep for later (that is, `print()` log calls or alternative starting property
    values).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注释用于帮助导航代码、理解代码可能执行的操作，以及注释掉我们可能不想执行但希望保留以备后用的代码行（即，`print()`日志调用或备选的起始属性值）。
- en: Note
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'From Xcode 6 Beta 4 onward, we can also utilize the following comments:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 从Xcode 6 Beta 4开始，我们还可以利用以下注释：
- en: '`// MARK`:, `// TODO:`, and `// FIXME`. `//MARK` is equivalent to Objective-C''s
    `#pragma` mark, which allows the programmer to label a *section* of your code
    that is accessible in Xcode''s top breadcrumb dropdown list. `// TODO:` and `//
    FIXME` give us the ability to section off parts of code that we wish to maybe
    add features to in the future or debug. Even games with well-organized class structuring
    can be daunting to sift through. The addition of these additional mark-up tools
    makes planning and searching through our games'' code that much easier to do.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`// MARK`:, `// TODO:`, 和 `// FIXME`。`//MARK`与Objective-C的`#pragma` mark等效，允许程序员为你的代码中的*部分*添加标签，这些标签可以在Xcode顶部的面包屑下拉列表中访问。`//
    TODO:`和`// FIXME`使我们能够将代码的一部分划分出来，我们希望将来可能添加功能或调试。即使结构良好的游戏类也可以让人难以梳理。这些额外标记工具的添加使得规划和使用我们游戏的代码变得更加容易。'
- en: Boolean
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Boolean
- en: An integral part of all programming, game, or otherwise is the use of **Boolean**
    values. Boolean values typically return either `true` or `false` values, `yes`
    or `no`, or `0` or `1`. In Swift, this is the job of the `Bool` class of objects.
    The use of the function `.isEmpty()` in our past collection data type examples
    returns a Boolean value of `true` or `false` based on whether that collection
    is empty or not.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 所有编程、游戏或其他领域的一个基本组成部分是使用**布尔**值。布尔值通常返回`true`或`false`、`yes`或`no`、`0`或`1`的值。在Swift中，这是`Bool`类对象的工作。在我们过去的集合数据类型示例中使用`.isEmpty()`函数返回一个布尔值`true`或`false`，这取决于该集合是否为空。
- en: In game development, one way we could use Boolean values is to have a global
    variable (a variable accessible in scope throughout our game/app) that checks
    if the game is over.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发中，我们可以使用布尔值的一种方式是有一个全局变量（一个可以在游戏/应用程序范围内访问的变量），用来检查游戏是否结束。
- en: '[PRE27]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This variable, taken from the PikiPop game, starts the game off with a variable
    of type `bool` named `isGameOver` with a starting value of `false`. If the events
    of the game cause this value to change to `true`, then this triggers the events
    associated with the game over state.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变量来自PikiPop游戏，游戏开始时使用一个名为`isGameOver`的布尔类型变量，初始值为`false`。如果游戏事件导致此值变为`true`，则这会触发与游戏结束状态相关的事件。
- en: Note
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Unlike Boolean values in Objective-C, Swift uses only `true` or `false` values
    to represent Boolean variables. *Swift strict type safety* does not allow the
    use of `YES` and `NO` or `0` and `1`, as we have seen in Objective-C and other
    programming languages.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 与Objective-C中的布尔值不同，Swift只使用`true`或`false`值来表示布尔变量。*Swift严格的类型安全*不允许使用`YES`和`NO`或`0`和`1`，正如我们在Objective-C和其他编程语言中看到的那样。
- en: However, reading and controlling this type of information about our game, known
    as the game's state, is best controlled with more than just a single Boolean value.
    This is because your game and the characters in your game could have various states,
    such as *game over*, *paused*, *spawn*, *idle*, *running*, *falling*, and more.
    A special object known as a *state machine* best manages this type of information.
    State machines shall be covered in more detail when we discuss the **GameplayKit**
    framework.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，阅读和控制我们游戏中的此类信息，即所谓的游戏状态，最好使用不止一个布尔值。这是因为你的游戏以及游戏中的角色可能有各种状态，例如*游戏结束*、*暂停*、*生成*、*空闲*、*运行*、*下落*等等。一个称为*状态机*的特殊对象最适合管理此类信息。当讨论**GameplayKit**框架时，我们将更详细地介绍状态机。
- en: Ints, UInts, floats, and doubles
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整数、无符号整数、浮点数和双精度浮点数
- en: In addition to Boolean values, another basic data type we have up to this point
    briefly mentioned is the various numeric objects, such as integers (Ints), unsigned
    integers (UInts), floating point numbers / decimals (floats), and double precision
    floating point numbers / decimals (doubles).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 除了布尔值之外，我们到目前为止简要提到的另一种基本数据类型是各种数值对象，例如整数（Ints）、无符号整数（UInts）、浮点数/小数（floats）和双精度浮点数/小数（doubles）。
- en: Integers and unsigned integers
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整数和无符号整数
- en: Integers represent negative and positive whole numbers, while unsigned integers
    represent positive whole numbers. Like with C and other programming languages,
    Swift lets us create various types of integers and unsigned integers from 8, 16,
    32, and 64 bits. For example, an Int32 type is a 32-bit integer, while a UInt8
    type is an 8-bit unsigned integer. The size of the bits for Ints and UInts represents
    how much space is being allocated to store the values. Using our UInt8 example,
    a number made from this type of unsigned Int can only store the values 0-255 (or
    11111111 in a base-2 system). This is also known as 1 byte (8 bits). If we need
    to store numbers larger than 255 or negative numbers, then maybe an Int16 type
    would suffice as that can store numbers between –32767 and 32767\. Usually, we
    don't have to worry too much about the size allocated by our integer variables
    and constants. So, using just the class name of `Int` will work fine in most cases.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 整数表示负数和正数，而无符号整数表示正数。与 C 和其他编程语言一样，Swift 允许我们创建从 8 位、16 位、32 位和 64 位的各种整数和无符号整数。例如，Int32
    类型是 32 位整数，而 UInt8 类型是 8 位无符号整数。Ints 和 UInts 的位数大小表示分配给存储值的多少空间。以我们的 UInt8 例子来说，由这种无符号
    Int 类型构成的数字只能存储 0-255（或二进制系统中的 11111111）的值。这也被称为 1 字节（8 位）。如果我们需要存储大于 255 或负数，那么可能
    Int16 类型就足够了，因为它可以存储介于 –32767 和 32767 之间的数字。通常，我们不必太担心我们的整数变量和常量分配的大小。因此，在大多数情况下，只需使用
    `Int` 类名即可。
- en: Note
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The size of `Int` will differ depending on the type of system we are working
    on. If we are compiling our code on a 32-bit system, an integer will be equal
    to Int32, while the same integer would be an Int64 on a 64-bit system.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`Int` 的大小将取决于我们正在工作的系统类型。如果我们在一个 32 位系统上编译我们的代码，整数将是 Int32，而在 64 位系统上相同的整数将是
    Int64。'
- en: Swift can let us see what our minimum and maximum values are for an `Int` variable
    with the `.min` or `.max` class variables (that is, `Int16.max = 32767` and `UInt.min
    = 0`).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 允许我们通过 `.min` 或 `.max` 类变量（即 `Int16.max = 32767` 和 `UInt.min = 0`）查看 `Int`
    变量的最小和最大值。
- en: Floats and doubles
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浮点数和双精度浮点数
- en: Floats are 32bit floating point numbers / fractions, such as pi (3.14), or the
    golden ratio, phi (1.61803).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数是 32 位浮点数/分数，例如 π（3.14）或黄金比例 φ（1.61803）。
- en: In game designing, we work with floating point values and ranges rather often,
    be it to determine the CGPoint in *x* and *y* of a 2D sprite, using linear interpolation
    for smoothing a game's camera movement in 3D space, or applying various physics
    forces on an object or 2D/3D vector. The precision needed for each situation will
    determine if a float is needed or if the 64-bit floating point value, the double
    is needed. Doubles can be as precise as 15 decimal places, while a float is six
    decimal places precise.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏设计中，我们经常使用浮点数和范围，无论是确定 2D 精灵的 *x* 和 *y* 坐标点，使用线性插值平滑 3D 空间中游戏的摄像机移动，还是在对象或
    2D/3D 向量上应用各种物理力。每种情况下所需的精度将决定是否需要浮点数或 64 位浮点值，即双精度浮点数。双精度浮点数可以精确到 15 位小数，而浮点数可以精确到
    6 位小数。
- en: Tip
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It's actually best practice to use doubles in situations that would work for
    either floats or doubles.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在可以使用浮点数或双精度浮点数的情况下，使用双精度浮点数是最佳实践。
- en: Objects in Swift
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swift 中的对象
- en: The core aspect of **object-oriented programming** (**OOP**) is of course the
    concept of objects. C++ began this paradigm in programming, while Java, C#, Apple's
    Objective-C, and other languages were all essentially built from this foundation.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）的核心方面当然是对象的概念。C++ 在编程中开启了这种范式，而 Java、C#、苹果的 Objective-C 以及其他语言都基本上是从这个基础上构建的。
- en: Swift is an OOP language with the same dynamic object model as Objective-C,
    but presented in a cleaner, type-safe, and compact way.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 是一种面向对象（OOP）的语言，它具有与 Objective-C 相同的动态对象模型，但以更简洁、类型安全和紧凑的方式呈现。
- en: You can think of an object exactly as it sounds, an abstract *thing* or *container*.
    An object can be something as simple as a string, or something as complex as the
    player object in the latest video game. Technically speaking, an object in a program
    is a *reference* to a set of various data in an allocated chunk of memory, but
    it's sufficient to just understand that an object can be a variable or a reference
    to an instance of a class, Struct, or block of code.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将对象理解为它的字面意思，一个抽象的*事物*或*容器*。一个对象可以像字符串这样简单，也可以像最新视频游戏中的玩家对象那样复杂。从技术角度讲，程序中的对象是对分配的内存块中一组各种数据的*引用*，但只需理解对象可以是变量或类、结构体或代码块的实例的引用即可。
- en: An object can have various data fields/aspects associated with it, such as properties,
    functions, parent objects, child objects, and protocols. In languages such as
    C for example, an integer variable is usually represented as just raw data, but
    the integer type in Swift is actually an object. Thus, we can access extra information
    and perform functions on `Int` objects in our code. We previously saw this with
    the `Int.max` variable, which returns the highest number that can be represented
    by the `Int` class. Again, depending on the machine you are working on, this could
    be the same value as `Int32.max` or `Int64.max`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象可以与各种数据字段/方面相关联，例如属性、函数、父对象、子对象和协议。例如，在 C 语言中，一个整型变量通常只表示为原始数据，但 Swift 中的整型实际上是一个对象。因此，我们可以在代码中对
    `Int` 对象访问额外信息和执行函数。我们之前在 `Int.max` 变量中看到了这一点，它返回 `Int` 类可以表示的最高数值。同样，这取决于你正在工作的机器，这可能是
    `Int32.max` 或 `Int64.max` 的相同值。
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Access to functions and properties of an object uses dot notation, as we saw
    with the previous example. `Int.max` and `Int.min` are actually special properties
    known as **class variables**, which represent all instances of an `Int` type object.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 访问对象的函数和属性使用点符号，正如我们在前面的例子中所看到的。`Int.max` 和 `Int.min` 实际上是称为 **类变量** 的特殊属性，它们代表所有
    `Int` 类型对象的实例。
- en: Let's look at how Swift deals with obtaining properties and functions of an
    instance of an object using a made-up `Player` type object.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Swift 如何通过一个虚构的 `Player` 类型对象来获取对象的属性和函数。
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We'll get back to the second half of line `(a)`, but just understand that it
    creates an instance of an object of the type `Player` named `currentPlayer`. Line
    `(c)` creates a variable named `playerHealth` that's set by the `health` property
    of `currentPlayer`; here with the *dot notation*. Lines `(b)` and `(d)` use the
    dot notation to call the functions `getName()` and `attackEnemy()`. The `getName()`
    function in this case is a function that returns a string that's assigned to the
    constant, `playerName`. Line `(c)` creates a variable named `playerHealth` that
    is created by referencing the health property of `currentPlayer`, also using dot
    notation. Line `(d)` is a direct call to the `Player` class' `attackEnemy()` function,
    which you can imagine for now just performs what would make `currentPlayer` do
    her attack. This function doesn't return a value and thus is what's known as a
    `void` type function.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将回到行 `(a)` 的后半部分，但只需理解它创建了一个名为 `currentPlayer` 的 `Player` 类型对象的实例。行 `(c)`
    创建了一个名为 `playerHealth` 的变量，它通过 `currentPlayer` 的 `health` 属性设置；这里使用的是 *点符号*。行
    `(b)` 和 `(d)` 使用点符号调用 `getName()` 和 `attackEnemy()` 函数。在这个例子中，`getName()` 函数是一个返回字符串并将其分配给常量
    `playerName` 的函数。行 `(c)` 创建了一个名为 `playerHealth` 的变量，它通过引用 `currentPlayer` 的健康属性创建，也使用点符号。行
    `(d)` 是直接调用 `Player` 类的 `attackEnemy()` 函数，你可以想象它现在只是执行 `currentPlayer` 的攻击。这个函数不返回任何值，因此被称为
    `void` 类型函数。
- en: 'As for line `(a)`, one might note that it doesn''t use the dot notation. This
    is how Swift does what''s known as a class initializer; designated by the parenthesis
    `()` after the class name and with the parameter called `name`: that sends a string,
    `Fumi`, to the object''s class initializer.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 至于行 `(a)`，有人可能会注意到它没有使用点符号。这就是 Swift 实现所谓的类初始化器的方式；由类名后面的括号 `()` 和参数 `name`（发送一个字符串，`Fumi`）到对象的类初始化器指定。
- en: We will be diving deeper in to the use of *objects* momentarily as we move on
    to functions and classes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们继续到函数和类时，我们将更深入地探讨 *对象* 的使用。
- en: Type safety and type inference
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型安全和类型推断
- en: Objects and, as we'll see, functions on these objects in Swift are type-safe.
    What this means is that if we perform a function on a string object when the code
    was expecting an integer, then the compiler will warn us early on in the process.
    In the vein of game design, if we were to have the player perform an action only
    an enemy supposed to do, then Swift will know through its inherently type-safe
    nature.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，对象及其函数是类型安全的，正如我们将要看到的。这意味着如果我们对一个字符串对象执行一个预期为整数的函数，编译器将在早期阶段警告我们。在游戏设计的范畴内，如果我们让玩家执行只有敌人应该做的动作，Swift
    将通过其固有的类型安全特性知道这一点。
- en: 'Swift''s type inference is something we''ve mentioned before. Unlike other
    languages where you have to declare the object''s type every time it''s initialized,
    Swift will infer what type you mean. For example, we have the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 的类型推断是我们之前提到过的。与其他语言不同，你每次初始化对象时都必须声明其类型，Swift 会推断你想要什么类型。例如，我们有以下内容：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Optionals
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可选参数
- en: As we stated before, Swift is a type-safe language. Apple also created Swift
    with the intention of keeping as many potential errors and bugs in the compilation
    state of development as opposed to runtime. Though Xcode has some great debugging
    tools, from the use of breaks, logging, and the LLDB debugger, runtime errors,
    particularly in games can be tough to spot, thus bringing the development process
    to a halt. To keep everything type-safe and as bug-free as possible during compilation,
    Swift deals with the concept of **optionals**.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所述，Swift 是一种类型安全的语言。苹果公司创建 Swift 的初衷也是为了将尽可能多的潜在错误和bug保留在开发阶段的编译状态，而不是在运行时。尽管
    Xcode 拥有一些出色的调试工具，如断点、日志和 LLDB 调试器，但运行时错误，尤其是在游戏中，可能很难发现，这可能会导致开发过程停滞。为了在编译期间保持类型安全并尽可能无bug，Swift
    处理了**可选**的概念。
- en: Optionals, in short, are objects that potentially can be or start as nil. Nil,
    of course, is an object that has no reference.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，可选是可能为空或开始为空的对象。当然，nil 是一个没有任何引用的对象。
- en: 'In Objective-C, we could declare the following string variable for a game:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Objective-C 中，我们可以为游戏声明以下字符串变量：
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In Swift, we would write this in the same way, but we''d find out very quickly
    that Xcode would give us a compiler error in doing so:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，我们会以同样的方式编写，但我们会很快发现 Xcode 会因为这样做而给出编译错误：
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Even more confusing for anyone new to Swift, we''d also get an error if we
    did something as simple as this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何刚开始接触 Swift 的人来说，如果我们做了一件像这样简单的事情，我们也会得到一个错误：
- en: '[PRE33]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Creating empty/undeclared objects in our games makes sense and is something
    we'd often want to do at the start of our classes. We want that flexibility to
    assign a value later on based on the events of our game. Swift seems to be making
    such a basic concept impossible to do! No worries; Xcode will inform you in most
    cases to suffix a question mark, `?,` at the end of these `nil` objects. This
    is how you declare an object as an optional.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中创建空/未声明的对象是有意义的，并且这是我们经常想在类开始时想要做的。我们希望有这种灵活性，以便根据游戏事件稍后分配值。Swift 似乎使这样一个基本概念变得不可能实现！不用担心；在大多数情况下，Xcode
    会通知你，在这些`nil`对象末尾添加一个问号`?`。这就是如何声明一个可选对象。
- en: 'So, if we want to plan our game''s properties and objects in Swift, we can
    do the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们想在 Swift 中规划游戏属性和对象，我们可以这样做：
- en: '[PRE34]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Unwrapping optionals
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解包可选
- en: Let's imagine that we want to display what caused a player to lose in the game.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下，我们想在游戏中显示导致玩家失败的原因。
- en: '[PRE35]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Because the string `causedGameOver` is optional, Xcode will give us a compile
    error because we didn't unwrap the optional. To unwrap the value in an optional,
    we suffix an exclamation point `!` at the end of the optional.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 因为字符串`causedGameOver`是可选的，Xcode 会因为我们没有解包可选而给出编译错误。要在可选中解包值，我们在可选末尾添加一个感叹号`!`。
- en: 'Here''s our `Game Over` message code, now fixed using the unwrapped optional:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`Game Over`消息代码，现在使用解包的可选进行了修复：
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We can also force unwrap optionals early at declaration to allow any potential
    errors to be taken care of at runtime instead of when compiling. This happens
    often with `@IBOutlets` and `@IBActions` (objects and functions linked to various
    storyboards and other tools that are based on menu/view tools).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在声明时强制解包可选，以便在运行时而不是在编译时处理任何潜在的错误。这种情况经常发生在`@IBOutlets`和`@IBActions`（与各种基于菜单/视图工具的故事板和其他工具链接的对象和函数）。
- en: '[PRE37]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If possible, though it's recommended to use the basic wrapped optional `?` as
    much as possible to allow the compiler to find any potential errors. Using what's
    known as optional binding and chaining, we can do some great early logic checks
    on optionals that in prior languages would have involved various `if` statements
    / control flow statements to simply check for nil objects.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，如果可能的话，建议尽可能多地使用基本的包装可选`?`，以便让编译器找到任何潜在的错误。通过使用所谓的可选绑定和链式调用，我们可以在可选对象上进行一些早期的逻辑检查，这在之前的语言中可能需要涉及各种`if`语句/控制流语句来简单地检查空对象。
- en: Keeping code clean, safe, and easy to read is what Swift aims to do and why
    Swift goes out of its way sometimes to force many of these rules with optionals.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 保持代码干净、安全且易于阅读是 Swift 的目标，也是为什么 Swift 有时会不遗余力地强制执行许多这些规则，特别是关于可选的。
- en: Optional binding and chaining
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选绑定和链式调用
- en: 'Optional binding is checking whether an optional has a value or not. This is
    done using the very handy if-let or if-var statements. Let''s look back at our
    earlier code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 可选绑定是检查可选是否有值。这是使用非常方便的if-let或if-var语句完成的。让我们回顾一下我们之前的代码：
- en: '[PRE38]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The code block, `if let gotCauseOfDeath = causedGameOver{…}`, does two things.
    First, using the key words, `if let`, it automatically creates a constant named
    `gotCauseOfDeath` and then binds it to the optional `causedGameOver`. This simultaneously
    checks whether `causedGameOver` is `nil` or has a value. If it's not nil, then
    the `if` statement's code block will run; in this case, creating the constant
    `gameOverMessage` that combines the `text` constant with `gotCauseOfDeath`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 代码块 `if let gotCauseOfDeath = causedGameOver{…}` 做了两件事情。首先，使用关键字 `if let`，它自动创建一个名为
    `gotCauseOfDeath` 的常量，并将其绑定到可选的 `causedGameOver`。这同时检查 `causedGameOver` 是否为 `nil`
    或有值。如果不是 `nil`，那么 `if` 语句的代码块将执行；在这种情况下，创建一个名为 `gameOverMessage` 的常量，该常量将 `text`
    常量与 `gotCauseOfDeath` 结合起来。
- en: 'We can use if-var to simplify this even further:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 if-var 进一步简化这一点：
- en: '[PRE39]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The if-var statement creates a temporary variable using our previously used
    optional `causedGameOver` and does a Boolean logic check based on the result of
    `whatKilledPlayer(enemy.recentAttack)`. The statement is true if there's a non-nil
    value returned. Note how we don't have to use either wrapped (`?`) or forced unwrapping
    (`!`) of the optional in such a case.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: if-var 语句使用我们之前使用的可选 `causedGameOver` 创建一个临时变量，并根据 `whatKilledPlayer(enemy.recentAttack)`
    的结果进行布尔逻辑检查。如果返回一个非 `nil` 值，则该语句为真。注意，在这种情况下，我们不必使用可选的包装（`?`）或强制解包（`!`）。
- en: 'Optional chaining is when we query down into the properties of an object using
    the dot operator while also doing a nil/value check as we did with optional binding.
    For example, let''s say that we have a game where certain Enemy types can cause
    a player to lose instantly via an Enemy instance named `currentEnemy`. In this
    example, `currentEnemy.type` would be a string that returns the name of the kind
    of enemy that hit the player. Optional chaining uses the custom dot modifier `?.`
    while accessing a potentially nil check on a property. Here''s the code to get
    a better idea of how this works:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 可选链是在查询对象属性时使用点操作符，同时进行 nil/值检查，就像我们使用可选绑定时做的那样。例如，假设我们有一个游戏，其中某些敌对类型可以通过名为
    `currentEnemy` 的敌对实例立即使玩家失去生命。在这个例子中，`currentEnemy.type` 将是一个返回击中玩家的敌对类型的字符串。可选链使用自定义点修饰符
    `?.` 在访问可能为 `nil` 的属性时进行检查。以下代码可以帮助我们更好地理解它是如何工作的：
- en: '[PRE40]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Chances are that we'd probably not make an enemy without a designated type,
    but for the sake of understanding optional chaining, observe how this checks for
    the possible nil object that'd be returned by `currentEnemy.type` using `currentEnemy?.type`.
    Like how the dot operator functions where you can drill down the properties and
    properties of properties, the same can be done with the recurring `?.per` property
    that is drilled down. In this code, we do a Boolean comparison with `==` to see
    if `enemyType` is the string `OneHitKill`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能我们不会创建一个没有指定类型的敌对者，但为了理解可选链，观察一下这个检查 `currentEnemy.type` 可能返回的 `nil` 对象是如何进行的。就像点操作符的功能一样，你可以深入到属性和属性的属性中，同样的，你也可以使用重复的
    `?.per` 属性进行深入。在这个代码中，我们使用 `==` 进行布尔比较，以查看 `enemyType` 是否是字符串 `OneHitKill`。
- en: Don't worry if the syntax of the `if` statement syntax is a bit of a mystery;
    next, we discuss how Swift uses `if` statements, loops, and other ways we can
    control various object data and their functions.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `if` 语句的语法有点神秘，不要担心；接下来，我们将讨论 Swift 如何使用 `if` 语句、循环以及其他我们可以控制各种对象数据和它们功能的方法。
- en: Control flow in Swift
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Swift 中的控制流
- en: Control flow in any program is simply the order of instructions and logic in
    your code. Swift, like any other programming language, uses various statements
    and blocks of code to loop, change, and/or iterate through your objects and data.
    This includes blocks of code such as `if` statements, for-loops, do-while loops
    and Switch statements. These are contained within functions, which make up larger
    structures like classes.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 任何程序中的控制流只是代码中指令和逻辑的顺序。Swift，就像任何其他编程语言一样，使用各种语句和代码块来循环、更改和/或迭代你的对象和数据。这包括 `if`
    语句、for 循环、do-while 循环和 Switch 语句等代码块。这些包含在函数中，构成了更大的结构，如类。
- en: If statements
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如果语句
- en: 'Before we move on to how Swift handles one of the main topics of OOP, functions
    and classes, let''s quickly run through if-else statements. An `if` statement
    checks whether a Boolean statement is `true` or `false`. We have the example as
    follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续讨论 Swift 如何处理面向对象编程的主要主题之一，即函数和类之前，让我们快速回顾一下 if-else 语句。`if` 语句检查一个布尔语句是
    `true` 还是 `false`。以下是一个示例：
- en: '[PRE41]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This checks whether or not the player''s health is less than or equal to `0`,
    designated by the `<=` operator. Note that Swift is OK with there not being parenthesis,
    but we can use this if we wish or if the statement gets more complicated, as in
    this example:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这检查玩家的健康是否小于或等于 `0`，由 `<=` 运算符表示。注意，Swift 可以接受没有括号，但如果我们愿意或者如果语句变得更复杂，比如这个例子，我们可以使用它：
- en: '[PRE42]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here, we check not just whether the player has lost all of their health, but
    also if all of their lives are gone with the and (`&&`) operator. In Swift, like
    in other languages, we separate out the individual Boolean checks with parentheses,
    and like other languages, we do a logic-or check with two bar keys (`||`).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不仅检查玩家是否失去了所有健康，还检查他们的生命是否全部消失，使用 `&&` 运算符。在 Swift 中，就像在其他语言中一样，我们使用括号将单个布尔检查分开，并且像其他语言一样，我们使用两个竖线键
    (`||`) 进行逻辑或检查。
- en: 'Here are some more ways to write `if` statements in Swift with the added key
    words, else-if and else, as well as how Swift can check if-not a certain statement:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 Swift 中编写 `if` 语句的一些更多方法，包括添加了关键字 else-if 和 else，以及 Swift 如何检查非某条语句：
- en: '[PRE43]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Let''s look at what we put in the code:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们在代码中放入了什么：
- en: '`(a)`: This checks the not / reverse of a statement with the exclamation point,
    `!`, via `!statement`.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(a)`: 这通过 `!statement` 使用感叹号 `!` 检查语句的非 / 反转。'
- en: '`(b)`: This checks whether the player has won or not. Otherwise, the `stageLost()`
    function is called, using the key word `else`.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(b)`: 这检查玩家是否获胜。否则，使用关键字 `else` 调用 `stageLost()` 函数。'
- en: '`(c)`: This checks if an enemy is an angel and sets its aura effect accordingly.
    If this is not, then it will check if it''s a demon using else-if, and if that''s
    not the case, then we catch all other instances with the `else` statement. We
    could have a number of else-if statements one after another, but if we start to
    stack too many, then using for-loops and Switch statements would be a better approach.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(c)`: 这检查一个敌人是否是天使，并相应地设置其光环效果。如果不是，则使用 else-if 检查它是否是恶魔，如果不是，则使用 `else` 语句捕获所有其他实例。我们可以有一系列连续的
    else-if 语句，但如果开始堆叠太多，那么使用 for 循环和 Switch 语句将是一个更好的方法。'
- en: '`(d)`: Using optional chaining, we create an `onlineID` constant based on `if`;
    we are able to get a non-nil `playerID` property using if-let.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(d)`: 使用可选链，我们根据 `if` 创建一个 `onlineID` 常量；我们能够使用 if-let 获取非 nil 的 `playerID`
    属性。'
- en: '`(e)`: This uses if-let, where optional binding became a feature in Swift 1.2\.
    Instead of having nested if-lets and other logic checks, akin to how SQL queries
    are done in backend web development, we can create very compact, powerful early
    logic checking. In the case of example `(e)`, we have an enemy receive an attack
    based on what type of attack it is and the power of the player.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(e)`: 这使用 if-let，在 Swift 1.2 中可选绑定成为了一个特性。与在后端网络开发中如何执行 SQL 查询类似，我们可以创建非常紧凑、强大的早期逻辑检查。在示例
    `(e)` 中，敌人根据攻击类型和玩家的力量接收攻击。'
- en: '`(f)`: This is an example of combining the creation of a constant with the
    keyword `let` and doing a shorthand version of an `if` statement. We shorthen
    an `if` statement in Swift with the question mark `?` and colon `:`. Here is the
    format for short handing an `if` statement: `bool ? trueResult : falseResult`.
    If `isPoweredUp` is `true`, then `playerPower` will equal `basepower + 250`; if
    `false`, then it''s `basepower + 50`.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(f)`: 这是一个将常量的创建与关键字 `let` 结合起来，并执行 `if` 语句的简短版本。在 Swift 中，我们使用问号 `?` 和冒号
    `:` 来缩短 `if` 语句。简短 `if` 语句的格式为：`bool ? trueResult : falseResult`。如果 `isPoweredUp`
    为 `true`，则 `playerPower` 等于 `basepower + 250`；如果为 `false`，则它是 `basepower + 50`。'
- en: For loops
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对于循环
- en: 'We touched on for-in loops before dealing with collections. Here again is a
    for-in loop in Swift that will iterate through a collection object:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理集合之前，我们提到了 for-in 循环。这里再次是 Swift 中的 for-in 循环，它将遍历一个集合对象：
- en: '[PRE44]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'For some of us programmers who are used to the older way of using for-loops,
    don''t worry, Swift lets us write for-loops in the C-style, which many of us are
    probably used to:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些习惯于使用旧方式使用 for 循环的程序员，不用担心，Swift 允许我们以 C 风格编写 for 循环，这是我们大多数人可能习惯的：
- en: '[PRE45]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Here''s another way of using a for-loop without using an index variable, noted
    with the underscore character `_` but of course using a `Range<Int>` object type
    to determine how many times the for-loop iterates:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用 for 循环而不使用索引变量的另一种方法，用下划线字符 `_` 标记，但当然使用 `Range<Int>` 对象类型来确定 for 循环迭代的次数：
- en: '[PRE46]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note the `…` between the `1` and `limit`. This means that this for-in loop will
    iterate from 1-10\. If we wanted it to iterate from `0` to `limit-1` (similar
    to iterating between the bounds of an array's index), we could have instead typed
    `0..<limit` where `limit` is equal to the array's `.count` property.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`1`和`limit`之间的`…`。这意味着这个for-in循环将从1迭代到10。如果我们想让它从`0`迭代到`limit-1`（类似于在数组索引的范围内迭代），我们可以用`0..<limit`代替，其中`limit`等于数组的`.count`属性。
- en: Do-while loops
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: do-while循环
- en: 'Another very common iteration loop in programming is the do-while loop. Many
    times we can just utilize the while portion of this logic, so let''s look into
    how and why we might use a while loop:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，另一个非常常见的迭代循环是do-while循环。很多时候我们可以只利用这个逻辑的while部分，所以让我们来看看我们可能如何和为什么使用while循环：
- en: '[PRE47]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In game development, one use of the while loop (though executed differently
    in a game app, this accommodates iterating once per frame) is for displaying the
    counting up of a player's score from 0 to the score the player reached—a common
    esthetic of many games at the end of a stage. This while loop will iterate until
    it reaches the player's score, displaying on HUD object showing the intermediate
    values up until that score.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发中，while循环的一个用途（尽管在游戏应用中执行方式不同，但这可以适应每帧迭代一次）是显示玩家分数从0增加到玩家达到的分数——这是许多游戏在关卡结束时常见的审美。这个while循环将迭代，直到达到玩家的分数，并在HUD对象上显示直到那个分数的中间值。
- en: 'A do-while loop is practically the same as the while-loop with the extra caveat
    of iterating through the code block at least once. The end-stage score count example
    can also illustrate why we would need such a loop. For example, let''s imagine
    that the player did really bad and got no score when the stage ended. In the while
    loop given, a score of zero won''t let us enter the block of code in the while
    loop since it doesn''t fulfill the logic check of `scoreCountNum < score`. In
    the while loop, we also have code that displays the score text. Though maybe embarrassing
    to the player, we would want to count up to the score and more importantly, still
    display a score. Here''s the same code done with a do-while loop:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: do-while循环实际上与while循环相同，只是额外的一个限制是至少迭代一次代码块。结束阶段的分数计数示例也可以说明为什么我们需要这样的循环。例如，让我们想象玩家在关卡结束时表现真的很糟糕，没有得到任何分数。在给出的while循环中，零分不会让我们进入while循环中的代码块，因为它不满足`scoreCountNum
    < score`的逻辑检查。在while循环中，我们还有显示分数文本的代码。虽然这可能对玩家来说很尴尬，但我们仍然想要计数到分数，更重要的是，仍然显示分数。以下是使用do-while循环完成的相同代码：
- en: '[PRE48]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The switch statement here takes the variable used to count how many times the
    player hit a 6X combo, `comboX6_counter`, and performs different tasks based on
    the value of `comboX6_counter`. For example, when the player has done a 6X Combo
    twice, the Piki_ComboX6 achievement gets 25% fulfilled. The player gets the achievement
    (when at 100%) when the counter hits 10\. The purpose of the keyword `break` is
    to tell the loop to exit at that point; otherwise, the next case block will iterate.
    Sometimes, this might be desired by your game's logic, but keep in mind that Swift,
    like many other languages, will continue through the switch statement without
    `break`. The keyword `default` is the catch-all block and is called when the value
    of the item checked by the switch statement is anything but the various cases.
    It can be thought of as an equivalent to the `else{}` block, while all of the
    cases are similar to `else if(){}`. The difference though is that Swift requires
    all cases of the switch be handled. So, though we can suffice with an `if` without
    an `else`, we have to have a default case for a switch statement. Again, this
    is done to keep Swift code safe and clean earlier in the coding process.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的switch语句使用了一个变量来计数玩家击中了6X连击的次数，即`comboX6_counter`，并根据`comboX6_counter`的值执行不同的任务。例如，当玩家完成了两次6X连击时，Piki_ComboX6成就将完成25%。当计数器达到10时，玩家将获得成就（当达到100%时）。关键字`break`的作用是告诉循环在那个点退出；否则，下一个case块将继续迭代。有时，这可能符合游戏逻辑的需求，但请注意，Swift，像许多其他语言一样，如果没有`break`，将继续通过switch语句。关键字`default`是一个通用的块，当switch语句检查的项的值不是各种情况时被调用。它可以被认为是`else{}`块的等价物，而所有的情况都类似于`else
    if(){}`。然而，不同之处在于Swift要求处理switch的所有情况。因此，尽管我们可以用一个没有`else`的`if`来满足，但我们必须为switch语句提供一个默认情况。再次强调，这是为了在编码过程的早期保持Swift代码的安全和整洁。
- en: Functions and classes
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数和类
- en: Up until this point, we have kept from discussing probably the most important
    aspects of Swift or any OOP languages for that matter—how the language handles
    functions on objects and how it organizes these objects, object properties, and
    functions and performs various object-oriented design concepts, such as polymorphism
    and inheritance with classes, Structs, enums, protocols, and other data structures.
    There is much more to discuss about how Swift utilizes these concepts, more than
    we can fit in this chapter but throughout the course of this book, especially
    as we get into how to use Apple's game-centric SpriteKit and SceneKit frameworks,
    we will flesh out more on these topics.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有讨论 Swift 或任何面向对象编程语言可能最重要的方面——语言如何处理对象上的函数以及如何组织这些对象、对象属性和函数，并执行各种面向对象设计概念，如多态和继承（使用类、Structs、枚举、协议和其他数据结构）。关于
    Swift 如何利用这些概念，有更多内容可以讨论，但超出了本章的范围。但在本书的整个过程中，特别是在我们深入研究如何使用苹果的游戏中心 SpriteKit
    和 SceneKit 框架时，我们将更详细地探讨这些主题。
- en: Functions
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Functions
- en: 'In Objective-C, functions are written the following way:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Objective-C 中，函数的写法如下：
- en: '[PRE51]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This is a simple function that returns the player's health as an integer—the
    `Int` equivalent in Objective-C.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的函数，它返回玩家的生命值作为一个整数——在 Objective-C 中的 `Int` 等价物。
- en: 'The structure of the function/method is as follows in Objective-C:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 函数/方法的结构在 Objective-C 中如下所示：
- en: '[PRE52]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Here''s the same function in Swift:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是相同的函数在 Swift 中的样子：
- en: '[PRE53]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This is how a function is structured in Swift:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 Swift 中函数的结构：
- en: '[PRE54]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Note how we use the keyword `func` to create a function and how the argument/parameter
    names are first with the types second, separated by the colon (`:`) and within
    parenthesis.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何使用关键字 `func` 来创建一个函数，以及参数/参数名称的顺序是先类型后名称，由冒号（`:`）分隔，并放在括号内。
- en: Here's what a typical void function looks like in Swift. A void-type function
    is a function that doesn't return a value.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个典型的 Swift 中 void 函数的例子。void 类型的函数是一个不返回值的函数。
- en: '[PRE55]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In a void function, there's no need to write `->returnType`, but even if there
    are no parameters, we do have to put in the `()` parenthesis at the end of the
    function name.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在 void 函数中，不需要写 `->returnType`，即使没有参数，我们也要在函数名称的末尾放入 `()` 括号。
- en: Tuples
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Tuples
- en: 'A rather powerful aspect of Swift is that function return types (and constants/variables)
    can include a combination of values into a single value. These combinations are
    called **tuples**. Here''s an example of an unnamed tuple:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 的一个相当强大的特性是函数返回类型（以及常量/变量）可以包含值的组合到一个单一值中。这些组合被称为 **元组**。下面是一个未命名的元组示例：
- en: '[PRE56]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Here''s a tuple used as a return type in a function direct from Apple''s Swift
    documentation. Observe how it uses much of what we''ve learned thus far:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个从苹果的 Swift 文档中直接使用的作为函数返回类型的元组示例。注意它使用了我们迄今为止学到的大部分内容：
- en: '[PRE57]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Classes
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Classes
- en: In OOP, classes make up the basic frame of an object, its functionality and
    interactions with other classes, objects, and various data structures, such as
    protocols, Structs, extensions, generics, and enumerations. In the following chapters,
    as we begin to structure our games, we will dive deeper into all of these concepts,
    but for now, let's understand the basics of classes and how they differ in Swift
    from Objective-C and other languages.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程（OOP）中，类构成了对象的基本框架，包括其功能以及与其他类、对象和各种数据结构（如协议、Structs、扩展、泛型和枚举）的交互。在接下来的章节中，当我们开始构建我们的游戏时，我们将更深入地探讨所有这些概念，但就目前而言，让我们先了解类的基本知识以及它们在
    Swift 中与 Objective-C 和其他语言的不同之处。
- en: 'Here''s the basic structure of a class in Swift:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 Swift 中类的基本结构：
- en: '[PRE58]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The Swift class structure works somewhat similar to what we see in C# and Java,
    as opposed to Objective-C''s two files'' (`.h`/`header`, `.m`/`.mm`/ implementation)
    setup:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 的类结构在某种程度上类似于我们在 C# 和 Java 中看到的，而不是 Objective-C 的两个文件（`.h`/`header`，`.m`/`.mm`/实现）的设置：
- en: '`(a)`: We can have properties (like variables, constants, Structs, and enums)
    outside of the class declaration, which would make them global in scope, aka accessible
    throughout the entire project/game/app.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(a)`: 我们可以在类声明之外拥有属性（如变量、常量、Structs 和枚举），这将使它们具有全局作用域，即在整个项目/游戏/应用程序中可访问。'
- en: '`(b)`: This is the actual class represented by what we named our `.swift` file.
    Again, this is different from Objective-C''s `classname.h - classname.m/.mm` dual
    file setup for a single class. A class can be a child class of another class.
    We don''t have to declare a parent/base class in Swift. Classes we make can be
    their own base classes. We can make classes as Objective-C classes by subclassing
    them from NSObject. The benefit of that is getting Objective-C runtime metadata
    and capabilities, but we take a hit in performance from the extra *baggage*. Either
    in the same place as the `parentClass` or after the colon `:` of `parentClass`,
    we can declare which protocols this class will adhere to. We''ll discuss more
    on protocols later in the book, but just think of them as making sure your class
    utilizes the same functions as the protocol dictates.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(b)`: 这是我们命名 `.swift` 文件时所表示的实际类。再次强调，这与 Objective-C 为单个类提供的 `classname.h
    - classname.m/.mm` 双文件设置不同。一个类可以是另一个类的子类。在 Swift 中，我们不必声明父类或基类。我们创建的类可以是它们自己的基类。我们可以通过从
    NSObject 继承来创建类似于 Objective-C 类的类。这样做的好处是获得 Objective-C 运行时元数据和功能，但我们会因为额外的“负担”而牺牲性能。我们可以在
    `parentClass` 的同一位置或 `parentClass` 冒号 `:` 之后声明这个类将遵守哪些协议。我们将在本书的后面部分更详细地讨论协议，但可以简单地将它们视为确保你的类使用与协议规定相同的函数。'
- en: '`(c)`: These are where we''d place variables, constants, Structs, enums, and
    objects that are relevant for use in the scope of the class.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(c)`: 这些是我们将放置变量、常量、结构体、枚举和对象的地方，这些对象对于在类的范围内使用是相关的。'
- en: '`(d)`: Initializers are special functions we use to set up the properties in
    section `(c)` when other classes and data structures use instances of the class
    via `className(initializer parameters)`. We will discuss more on initializers
    more in the next chapter as we structure our games. They don''t have to be at
    the top of the class, but it''s a good practice to do so.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(d)`: 初始化器是我们用来在部分 `(c)` 中设置属性的特殊函数，当其他类和数据结构通过 `className(initializer parameters)`
    使用该类的实例时。在我们构建游戏时，我们将在下一章中更详细地讨论初始化器。它们不必放在类的顶部，但将它们放在那里是一个好的实践。'
- en: '`(e)`: These are where your class functions will be declared and developed.
    We can have functions that are known as class functions. These are designated
    with the keywords `class func`. In short, class functions are part of the class
    as a whole as opposed to an instance of the class. It''s best practice to place
    these above the next, more common type of function, the public functions, that
    can be accessed by other classes and properties via the dot operator (that is,
    `className.function(parameters)`). Using the `private func` keywords, as in C#
    and Java, we can create private functions that are only accessible to the class''s
    own functions and properties.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(e)`: 这些是声明和开发你的类函数的地方。我们可以有被称为类函数的函数。这些函数用关键字 `class func` 标识。简而言之，类函数是类整体的一部分，而不是类的实例。将它们放在下一个更常见的函数类型（即公共函数）之上是一个好的实践，这些公共函数可以通过点操作符（即
    `className.function(parameters)`）被其他类和属性访问。与 C# 和 Java 一样，我们可以使用 `private func`
    关键字创建私有函数，这些函数只能被类的自身函数和属性访问。'
- en: '`(f)`: The `deinit()` function is a special optional function that deals with
    how we clean up the data allocated by our class with memory management and eliminating
    what''s known as memory leaks. Apple''s **ARC** (**Automated Reference Counting**)
    handles most of this, but there are key words, such as weak and unowned, that
    we will at times have to put before various properties to make sure that they
    don''t hang around after use.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(f)`: `deinit()` 函数是一个特殊的可选函数，用于处理我们如何通过内存管理和消除所谓的内存泄漏来清理由我们的类分配的数据。Apple
    的 **ARC** （**自动引用计数**）处理了大部分工作，但有时我们不得不在各个属性前使用诸如 weak 和 unowned 这样的关键字，以确保它们在使用后不会继续存在。'
- en: This is a rather involved topic, but worth looking into to avoid memory leaks
    in your game. ARC does take care of most of this, but there might be objects in
    your game that could potentially hang around. It's highly recommended to read
    Apple's own documentation on this topic, as memory management in iOS is always
    in the evolving stage. You can view the full documentation on ARC and memory management
    in Swift at [https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html).
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个相当复杂的话题，但值得深入研究以避免游戏中的内存泄漏。自动引用计数（ARC）确实负责处理大部分工作，但你的游戏中可能存在一些可能长时间存在的对象。强烈建议阅读苹果公司关于此主题的官方文档，因为
    iOS 中的内存管理始终处于不断发展之中。你可以在 [https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html)
    查看关于 ARC 和 Swift 中内存管理的完整文档。
- en: '`(g)`: If we wish, we can have global properties also at the bottom of our
    `.swift` files, after the end of the class declaration. Apple''s own game example,
    Adventure ([https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html)),
    places global properties in this spot.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(g)`: 如果我们愿意，我们也可以在 `.swift` 文件的底部，在类声明之后，拥有全局属性。苹果自己的游戏示例，冒险 ([https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html))，将全局属性放在了这个位置。'
- en: Summary
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: There's much more about the Swift programming language than we could fit here.
    Throughout the course of this book, we will throw in a few extra tidbits and nuances
    about Swift as it becomes relevant to our upcoming gaming programming needs.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Swift 编程语言的内容远不止这里所能涵盖的。在本书的整个过程中，我们将根据即将到来的游戏编程需求，穿插一些关于 Swift 的额外信息和细微差别。
- en: If you wish to become more versed in the Swift programming language, Apple actually
    provides a wonderful tool in what's known as a **Playground**.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望更精通 Swift 编程语言，苹果实际上提供了一个名为 **游乐场** 的出色工具。
- en: Playgrounds were introduced with the Swift programming language at *WWDC14*
    in June of 2014 and allow us to test various code outputs and syntaxes without
    having to create a project, build it, and run it and repeat again, when in many
    cases we simply needed to tweak a few variables and function loop iterations.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 游乐场是在 2014 年 6 月的 *WWDC14* 上与 Swift 编程语言一起引入的，它允许我们在不创建项目、构建和运行的情况下测试各种代码输出和语法，在很多情况下我们只需要调整几个变量和函数循环迭代。
- en: There are a number of resources to check out on the official Swift developer
    page ([https://developer.apple.com/swift/resources/](https://developer.apple.com/swift/resources/)).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在官方 Swift 开发者页面 ([https://developer.apple.com/swift/resources/](https://developer.apple.com/swift/resources/))
    上有许多资源可以查看。
- en: 'Two highly recommended Playgrounds to check out are as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是两个非常推荐的游乐场：
- en: '**The Guided Tour Playground** ([https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/GuidedTour.playground.zip](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/GuidedTour.playground.zip)):
    This Playground covers many of the topics we mentioned in this chapter and more,
    from **Hello World** all the way to **Generics**.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导游游乐场** ([https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/GuidedTour.playground.zip](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/GuidedTour.playground.zip)):
    这个游乐场涵盖了本章中提到的许多主题以及更多内容，从 **Hello World** 到 **泛型**。'
- en: '**The Balloons Playground** ([https://developer.apple.com/swift/blog/downloads/Balloons.zip](https://developer.apple.com/swift/blog/downloads/Balloons.zip)):
    The Balloons Playground was the keynote Playgrounds demonstration from *WWDC14*
    and shows off many of the features Playgrounds have to offer, particularly to
    make and test games.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**气球游乐场** ([https://developer.apple.com/swift/blog/downloads/Balloons.zip](https://developer.apple.com/swift/blog/downloads/Balloons.zip)):
    气球游乐场是 *WWDC14* 的关键演示游乐场，展示了游乐场提供的许多功能，尤其是制作和测试游戏。'
- en: Sometimes, the best way to learn a programming language is to test live code,
    and that's exactly what Playgrounds allow us to do.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，学习编程语言的最佳方式是测试实时代码，这正是游乐场允许我们做的事情。
- en: In addition to testing snippets of code in our games, iOS 9 also allows us to
    plan and structure our games, which is the topic of the next chapter.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在我们的游戏中测试代码片段之外，iOS 9 还允许我们规划和构建我们的游戏，这是下一章的主题。
