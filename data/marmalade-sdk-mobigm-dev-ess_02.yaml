- en: Chapter 2. Resource Management and 2D Graphics Rendering
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：资源管理和 2D 图形渲染
- en: 'Unless you happen to be writing an old school text adventure game (and perhaps
    even if you are), chances are that you will want more than just text in a simple
    debug font to appear on screen. Drawing nice-looking graphics demands that we
    should also be able to load those graphics into memory in order to display them;
    so in this chapter we will be looking at the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你恰好正在编写一个老式的文本冒险游戏（甚至即使你正在这样做），否则你很可能会希望在屏幕上显示的不仅仅是简单的调试字体中的文本。绘制漂亮的图形要求我们也能够将这些图形加载到内存中以便显示；因此，在本章中，我们将探讨以下内容：
- en: Using Marmalade's resource manager to load games resources
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Marmalade 的资源管理器加载游戏资源
- en: Extending the resource management system with our own custom classes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用我们自己的自定义类扩展资源管理系统
- en: The programming choices we have available to us for rendering purposes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可用于渲染目的的编程选择
- en: How to display a bitmapped image on screen using the IwGx API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 IwGx API 在屏幕上显示位图图像
- en: The Marmalade ITX file format
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Marmalade ITX 文件格式
- en: An ITX file is Marmalade's built-in file format that can be used for loading
    all kinds of data into our program. The extension ITX is short for Ideaworks TeXt;
    Ideaworks being the original name of the company that created the SDK before they
    rebranded themselves as Marmalade.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: ITX 文件是 Marmalade 的内置文件格式，可用于将各种数据加载到我们的程序中。扩展名 ITX 是 Ideaworks TeXt 的缩写；Ideaworks
    是在重新品牌为 Marmalade 之前创建 SDK 的公司的原始名称。
- en: ITX files have a simple text format and are used as the basis for resource loading.
    While it is possible to load resources ourselves, it is a bit like reinventing
    the wheel when Marmalade already provides a great deal of support for this truly
    tedious aspect of coding.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: ITX 文件具有简单的文本格式，并用作资源加载的基础。虽然我们可以自己加载资源，但这样做就像是在重新发明轮子，因为 Marmalade 已经为这一真正繁琐的编码方面提供了大量的支持。
- en: Marmalade has an API called IwUtil that contains a wide range of useful utility
    functions ranging from memory management and debugging through to the serialization
    of objects and random number generation. It also contains a class called `CIwTextParserITX`,
    which allows us to load and process an ITX file.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Marmalade 有一个名为 IwUtil 的 API，它包含了一系列广泛的有用实用函数，从内存管理和调试到对象的序列化和随机数生成。它还包含一个名为
    `CIwTextParserITX` 的类，它允许我们加载和处理 ITX 文件。
- en: To add this functionality to our own project, we just need to add `iwutil` to
    the `subprojects` list of the MKB file and then add a call to `IwUtilInit` at
    the start of our program, and `IwUtilTerminate` in our shutdown code.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此功能添加到我们的项目中，我们只需将 `iwutil` 添加到 MKB 文件的 `subprojects` 列表中，然后在程序开始时添加对 `IwUtilInit`
    的调用，并在关闭代码中添加对 `IwUtilTerminate` 的调用。
- en: 'Before we can use the text parser, we will need to create an instance of it
    by using `new CIwTextParserITX`. This class is a singleton class, so we can create
    an instance of it at the start of our program and then reuse it as much as we
    like in the rest of our code (don''t forget to release it on shutdown!). The instance
    can be accessed using the `IwGetTextParserITX` function, and we can then load
    and parse an ITX file using the following code:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以使用文本解析器之前，我们需要通过使用 `new CIwTextParserITX` 来创建它的一个实例。这个类是一个单例类，因此我们可以在程序开始时创建它的一个实例，然后在代码的其余部分中尽可能多地重用它（不要忘记在关闭时释放它！）。该实例可以通过
    `IwGetTextParserITX` 函数访问，然后我们可以使用以下代码加载和解析 ITX 文件：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'An ITX file is little more than a big collection of class definitions. An instance
    of a class is defined by first putting the name of the class followed by a list
    of parameters for that instance enclosed in curly braces. Let''s say we had a
    class called `WidgetClass` that was defined as follows (don''t worry about the
    `CIwManaged` class and the `IW_MANAGED_DECLARE` macro for now, we''ll come to
    these in a bit):'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: ITX 文件不过是一个由类定义组成的庞大集合。类的实例通过首先写出类的名称，然后跟随着用花括号括起来的该实例的参数列表来定义。假设我们有一个名为 `WidgetClass`
    的类，其定义如下（现在不必担心 `CIwManaged` 类和 `IW_MANAGED_DECLARE` 宏，我们稍后会讨论这些）：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here is an example of how we might instantiate this class from within an ITX
    file:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，说明我们如何在 ITX 文件内部实例化这个类：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This sample declares two instances of `WidgetClass`, and initializes those instances
    with a name, color value, size, and a flag indicating whether the widget in question
    is sparkly or not. Each of these settings is called an attribute, and they can
    be of any type we desire—string, integer, floating point, boolean, or an array
    of values (the `color` attribute provides an example of this).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例声明了两个`WidgetClass`的实例，并用名称、颜色值、大小以及一个标志来初始化这些实例，该标志指示所讨论的小部件是否闪闪发光。每个这些设置都被称为属性，它们可以是任何我们想要的类型——字符串、整数、浮点数、布尔值或值的数组（`color`属性提供了一个例子）。
- en: Hopefully, you are looking at this and thinking how exactly this format can
    be magically loaded and instanced by the Marmalade text parser, since it obviously
    knows nothing about `WidgetClass`. A good question! The answer is that any class
    that you wish to parse from an ITX file must first be derived from the Marmalade
    class `CIwManaged`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您正在查看这个，并思考这个格式是如何被Marmalade文本解析器神奇地加载和实例化的，因为它显然对`WidgetClass`一无所知。这是一个很好的问题！答案是，您希望从ITX文件中解析的任何类都必须首先从Marmalade类`CIwManaged`派生。
- en: The CIwManaged class
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CIwManaged类
- en: The `CIwManaged` class is the base class used throughout the Marmalade SDK and
    by our own classes whenever we want to be able to create instances of them by
    loading from a file.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`CIwManaged`类是在Marmalade SDK中使用的基类，以及我们自己的类，每当我们要能够通过从文件加载来创建它们的实例时。'
- en: The class provides some virtual methods that we can override to allow the parser
    to recognize our own custom classes, and also to serialize them into a binary
    format and resolve any references to other classes or resources. It also provides
    the coding glue required to instantiate copies of our class at runtime.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 该类提供了一些虚拟方法，我们可以覆盖这些方法以允许解析器识别我们自己的自定义类，并将它们序列化为二进制格式，并解决对其他类或资源的引用。它还提供了在运行时实例化我们类副本所需的编码粘合剂。
- en: This facility is really useful for us as it allows us to make our code more
    data-driven. Say we have a class that describes an item that the player can collect.
    We might have lots of different item types in our game, so rather than creating
    instances of them all in the source code, which only a programmer can then change,
    we could instead instantiate them from an ITX file, which a game designer with
    no coding knowledge can then edit.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能对我们来说非常有用，因为它允许我们使我们的代码更加数据驱动。比如说，我们有一个描述玩家可以收集的物品的类。在我们的游戏中可能有多种不同的物品类型，所以我们不必在源代码中创建它们的实例，这只有程序员才能更改，我们反而可以从ITX文件中实例化它们，这样没有编程知识的游戏设计师就可以编辑它们。
- en: Instantiating a class with the class factory
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用类工厂实例化类
- en: The first thing `CIwTextParserITX` will encounter in the ITX file is the class
    name, which it will use to create a brand new instance of our class. It achieves
    this by using the class factory, which is another part of the IwUtil API.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`CIwTextParserITX`在ITX文件中遇到的第一件事是类名，它将使用这个类名来创建我们类的一个全新实例。它是通过使用类工厂来实现的，这是IwUtil
    API的另一个部分。'
- en: A class factory is a programming pattern that allows us to generate new instances
    of objects at runtime by asking another class (the so-called factory) to create
    a relevant class instance for us.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 类工厂是一种编程模式，它允许我们通过要求另一个类（所谓的工厂）为我们创建一个相关的类实例来在运行时生成新对象实例。
- en: The Marmalade class factory system allows us to add our own classes to those
    provided by the SDK itself by registering a unique hash value identifying the
    class and a method that creates a new instance of it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Marmalade类工厂系统允许我们通过注册一个标识类的唯一哈希值和一个创建该类新实例的方法来将我们自己的类添加到SDK本身提供的类中。
- en: The hash value is normally derived by converting the name of the class into
    a number by passing its name as a string to the IwUtil API's function `IwHashString`.
    While this isn't guaranteed to produce a unique number, it is usually good enough
    for our purposes and clashes with hash values from other class names are rare.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希值通常是通过将类名转换为数字来得到的，这是通过将类名作为字符串传递给IwUtil API的函数`IwHashString`来实现的。虽然这并不能保证产生一个唯一的数字，但对于我们的目的来说通常已经足够好了，并且与其他类名的哈希值发生冲突的情况很少。
- en: 'To add our own custom `CIwManaged` derived class to the class factory, we just
    need to do the following (if you want to see a full example of this and indeed
    the things we''ll be covering in the next few sections, take a look at the source
    code for the ITX project that accompanies this chapter):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要将我们自己的自定义`CIwManaged`派生类添加到类工厂中，我们只需执行以下操作（如果您想查看这个完整的示例以及接下来几节将要涉及的内容，请查看本章伴随的ITX项目的源代码）：
- en: Add the `IW_MANAGED_DECLARE(CustomClassName)` macro to the public section of
    the class. This declares a method called `GetClassName`, which will return the
    name of the class as a string, and also adds a couple of type definitions to allow
    the class to be used more easily with the `CIwArray` class, which is yet another
    piece of functionality provided by IwUtil.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将宏 `IW_MANAGED_DECLARE(CustomClassName)` 添加到类的公共部分。此宏声明了一个名为 `GetClassName`
    的方法，它将返回类的名称作为字符串，并添加了一些类型定义，以便更容易地使用 `CIwArray` 类，这是 IwUtil 提供的另一个功能。
- en: Add the macro `IW_MANAGED_IMPLEMENT_FACTORY(CustomClassName)` to the source
    file for the class. This macro implements the `GetClassName` method and also creates
    the necessary class factory function that will be used to create a new instance
    of our class.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将宏 `IW_MANAGED_IMPLEMENT_FACTORY(CustomClassName)` 添加到类的源文件中。此宏实现了 `GetClassName`
    方法，并创建了必要的类工厂函数，该函数将用于创建我们类的新的实例。
- en: Finally, we have to register our class with the class factory itself by adding
    the macro `IW_CLASS_REGISTER(CustomClassName)` somewhere in our initialization
    code.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须通过在初始化代码中添加宏 `IW_CLASS_REGISTER(CustomClassName)` 来将我们的类注册到类工厂本身。
- en: With this done, we can now include our class in an ITX file. The `CIwTextParserITX`
    class can now create a brand new instance of it with a call to the class factory
    function `IwClassFactoryCreate("CustomClassName")`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，我们现在可以将我们的类包含在ITX文件中。`CIwTextParserITX` 类现在可以通过调用类工厂函数 `IwClassFactoryCreate("CustomClassName")`
    来创建它的全新实例。
- en: Parsing a class
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解析一个类
- en: 'With the creation of a new instance of our class taken care of, the next step
    is to allow `CIwTextParserITX` to configure that instance by modifying its members.
    This is done with the following `CIwManaged` class'' virtual methods:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完我们类的新的实例创建后，下一步是允许 `CIwTextParserITX` 通过修改其成员来配置该实例。这是通过以下 `CIwManaged`
    类的虚拟方法完成的：
- en: '| Method | Description |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ParseOpen` | This method gets called when the text parser reaches the open
    curly brace of the class definition. It can be used to initialize anything that
    might be needed internally during the process of parsing an object.It is important
    that you do not use this method to initialize all the member variables of your
    class to some default values. The class constructor is a far better place to do
    this, as it is guaranteed to be called however the instance ends up being created.
    |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `ParseOpen` | 当文本解析器达到类定义的开始花括号时，将调用此方法。它可以用来初始化在解析对象过程中可能需要的任何内部内容。重要的是不要使用此方法将类的所有成员变量初始化为某些默认值。类构造函数是做这件事的更好地方，因为它保证在实例以任何方式创建时都会被调用。
    |'
- en: '| `ParseAttribute` | This method is called whenever an attribute is encountered
    in the object definition. The attribute is passed as a standard C-style string
    to this method, which can then process it as needed.The text parser can be used
    within this method to extract any data elements in a variety of different ways,
    including strings, integers, and Boolean values. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `ParseAttribute` | 当在对象定义中遇到属性时，将调用此方法。该属性作为标准C风格字符串传递给此方法，然后可以按需处理它。文本解析器可以在此方法中使用，以多种不同方式提取任何数据元素，包括字符串、整数和布尔值。
    |'
- en: '| `ParseClose` | This method is called when the closing curly brace of the
    class definition is encountered. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `ParseClose` | 当遇到类定义的结束花括号时，将调用此方法。 |'
- en: '| `ParseCloseChild` | It is possible to embed class definitions inside other
    class definitions in an ITX file. If a class does not implement the `ParseClose`
    method then when its closing curly brace is encountered, the `ParseCloseChild`
    method will be called on the parent class with a pointer to the child class.In
    this case parent and child do not refer to class inheritance hierarchies, but
    rather to how the classes have been defined in the ITX file. For example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '| `ParseCloseChild` | 在ITX文件中，可以在其他类定义内部嵌入类定义。如果一个类没有实现 `ParseClose` 方法，那么当遇到其结束花括号时，将调用父类的
    `ParseCloseChild` 方法，并传递子类的指针。在这种情况下，父类和子类并不指代类继承层次结构，而是指在ITX文件中类的定义方式。例如：'
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '|'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: When overriding any of these methods, you should normally call the version of
    the method from the superclass, be that `CIwManaged` or some other class derived
    from it. For example, the `name` attribute is parsed by `CIwManaged::ParseAttribute`,
    which not only reads the name for the class but also generates a hash value of
    the name. The hash value is very important when it comes to serializing and resolving
    class instances later.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当重写这些方法中的任何一个时，通常应该调用超类中的方法版本，无论是 `CIwManaged` 还是其他从它派生的类。例如，`name` 属性是由 `CIwManaged::ParseAttribute`
    解析的，它不仅读取类的名称，还生成名称的哈希值。当涉及到后续的序列化和解析类实例时，哈希值非常重要。
- en: 'The following diagram shows an example of how an instance of `WidgetClass`
    defined earlier in this chapter would be processed by the ITX parser:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示展示了本章前面定义的 `WidgetClass` 实例如何被 ITX 解析器处理：
- en: '![Parsing a class](img/3363_02_07.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![解析一个类](img/3363_02_07.jpg)'
- en: 'For `WidgetClass` the only method we would definitely need to implement is
    the `ParseAttribute` method, which might look like the following code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `WidgetClass`，我们唯一肯定需要实现的方法是 `ParseAttribute` 方法，它可能看起来像以下代码：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Serializing a class
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 序列化一个类
- en: Serializing an object instance is the process of converting the current state
    of the object into (or from) a binary format.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化对象实例是将对象的当前状态转换为（或从）二进制格式的过程。
- en: While not strictly necessary when parsing an ITX file, it is still very much
    a useful part of the functionality provided by `CIwManaged`, and forms an integral
    part of the resource handling process that we will be seeing later in this chapter.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在解析 ITX 文件时并非绝对必要，但它仍然是 `CIwManaged` 提供的功能中的一个非常有用的部分，并且构成了我们在本章后面将要看到的资源处理过程的一个基本部分。
- en: The serialization functionality can also be useful when it comes to saving out
    things such as current game progress or high score tables, though of course we
    can still use normal file handling operations to do this if we prefer.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当保存当前游戏进度或高分表等数据时，序列化功能也非常有用，尽管当然我们也可以选择使用常规的文件处理操作来完成这项工作。
- en: Serialization of our class is handled by overriding the virtual method `Serialise`.
    This method can then use the serialization functions provided by IwUtil, which
    all start with the prefix `IwSerialise`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们类的序列化是通过重写虚拟方法 `Serialise` 来处理的。然后，该方法可以使用 IwUtil 提供的序列化函数，这些函数都以前缀 `IwSerialise`
    开头。
- en: For example, `IwSerialiseInt32` will serialize an `int32` value. All these functions
    make use of the Marmalade type definitions for the basic variable types, as these
    are far more explicit when it comes to the memory footprint of a variable. Take
    a look at the header files `IwSerialise.h` and `s3eTypes.h` in the Marmalade SDK
    installation for more information on the `IwSerialise` functions and the variable
    types respectively.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`IwSerialiseInt32` 将序列化一个 `int32` 值。所有这些函数都使用了 Marmalade 的基本变量类型定义，因为这些定义在变量的内存占用方面更为明确。有关
    `IwSerialise` 函数和变量类型的信息，请参阅 Marmalade SDK 安装目录中的头文件 `IwSerialise.h` 和 `s3eTypes.h`。
- en: We must make sure to call our superclass implementation of `Serialise` as well
    to ensure every part of the object is serialized. Normally this would be the first
    thing we do in our implementation of `Serialise`, but it does not have to be so
    as long as it is called at some point.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须确保调用我们的超类 `Serialise` 实现以确保对象的每个部分都被序列化。通常，这将是我们在 `Serialise` 实现中做的第一件事，但只要它在某个时候被调用，就不必这样做。
- en: We can serialize our objects to a file of our choosing by calling `IwSerialiseOpen`.
    This allows us to specify the filename and a Boolean flag that indicates whether
    we are reading or writing the file. We then call the `Serialise` method of each
    object we want to serialize, and finally call `IwSerialiseClose` to finish the
    process.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用 `IwSerialiseOpen` 来将我们的对象序列化到我们选择的文件中。这允许我们指定文件名和一个布尔标志，该标志指示我们是在读取还是写入文件。然后我们调用我们想要序列化的每个对象的
    `Serialise` 方法，最后调用 `IwSerialiseClose` 来完成这个过程。
- en: One nice feature of the `IwSerialise` functions is that, in most cases, we do
    not have to worry about whether the `Serialise` method has been called to write
    data to a file or if it has been called to read data from a file. We just call
    the function and it will read or write the value, as appropriate.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`IwSerialise` 函数的一个很好的特性是，在大多数情况下，我们不必担心 `Serialise` 方法是否被调用以将数据写入文件，或者是否被调用以从文件中读取数据。我们只需调用该函数，它就会根据需要读取或写入值。'
- en: There are times that we will care about reading or writing values to a file;
    for example, if we need to allocate a block of memory to read some values into.
    The functions `IwSerialiseIsReading` and `IwSerialiseIsWriting` allow us to make
    the appropriate decisions.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们会关心读取或写入文件中的值；例如，如果我们需要分配一块内存来读取一些值。函数`IwSerialiseIsReading`和`IwSerialiseIsWriting`允许我们做出适当的决定。
- en: 'The following code snippet illustrates how the serialization functions are
    used by showing what the `Serialise` method might look like for `WidgetClass`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段通过展示`Serialise`方法可能的样子来说明序列化函数的使用：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Resolving a class
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解析类
- en: The act of resolving a class instance is to fix up any parts of our class that
    are not initialized correctly when parsing the object from an ITX file or having
    created it from the serialization process.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 解析类实例的行为是在从ITX文件解析对象或从序列化过程中创建它时修复我们类中未正确初始化的任何部分。
- en: When might this happen? The most frequent reason for needing to resolve our
    instances is when the instance requires a pointer to another class that may not
    exist when it is first created.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况可能发生在什么时候？需要解析我们的实例的最常见原因是当实例需要指向另一个类时，而这个类在第一次创建时可能不存在。
- en: This is best illustrated by an example. Let's say our class contains a pointer
    to another instance of our class in order to implement a linked list. When we
    read in our instances, it is possible we might refer to an instance that has not
    yet been created and so we can't create the linked list yet.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点最好通过一个例子来说明。假设我们的类包含指向另一个类实例的指针，以便实现链表。当我们读取实例时，我们可能会引用一个尚未创建的实例，因此我们无法立即创建链表。
- en: To solve this problem we instead store a value in our data that will allow us
    to look up the required instance later. This might be a string representing the
    name of the instance or perhaps a unique identifier number.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以在数据中存储一个值，以便我们稍后查找所需的实例。这可能是一个表示实例名称的字符串，或者可能是一个唯一的标识符号码。
- en: Once all the instances have been read in, we can then call the `CIwManaged`
    class' virtual method `Resolve` on each instance in turn and obtain the required
    pointer to the correct instance using whatever methodology we see fit. For example,
    we might maintain a list of all instances of our class that gets added to whenever
    a new instance is created. We can then use this list to look up the required instance.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有实例都已读取，我们就可以依次调用`CIwManaged`类的虚拟方法`Resolve`，并使用我们认为合适的方法获取指向正确实例的指针。例如，我们可能维护一个所有类实例的列表，每当创建新实例时，都会添加到这个列表中。然后我们可以使用这个列表来查找所需的实例。
- en: It is not always necessary to create our own implementation of `Resolve`, but
    if we do we must be sure to call the inherited version of the method from our
    superclass.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 并非总是需要创建我们自己的`Resolve`实现，但如果我们这样做，我们必须确保从我们的超类中调用方法的重载版本。
- en: We'll take one more look at `WidgetClass` to wrap this all up. You may remember
    that it had a member `mpNextWidget` that points to another instance of `WidgetClass`.
    In the ITX file, we supplied a value for this member by specifying the name of
    another `WidgetClass` instance. In the `ParseAttribute` method, we read in this
    name and calculated a hash value from it which was stored in the `mNextWidgetHash`
    member variable.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次审视`WidgetClass`以总结这一切。你可能记得它有一个成员`mpNextWidget`，它指向另一个`WidgetClass`实例。在ITX文件中，我们通过指定另一个`WidgetClass`实例的名称来为这个成员提供一个值。在`ParseAttribute`方法中，我们读取这个名称并从中计算出一个哈希值，该值存储在`mNextWidgetHash`成员变量中。
- en: 'We can implement the `Resolve` method and look up a pointer to the correct
    instance but we''ll also need to maintain a list of all `WidgetClass` instances
    in order to do this. One way of doing this is to implement `ParseClose` and store
    each instance in a list. The following code shows how this could be achieved:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以实现`Resolve`方法并查找指向正确实例的指针，但我们也需要维护所有`WidgetClass`实例的列表才能做到这一点。一种方法是在实现`ParseClose`时将每个实例存储在列表中。以下代码展示了如何实现这一点：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The Marmalade resource manager
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Marmalade资源管理器
- en: Most bitmap art packages are capable of saving images in a number of different
    file formats, but we really need access to the actual bitmap data itself, which
    may well be stored in a compressed format with any particular file format.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数位图艺术包都能够以多种不同的文件格式保存图像，但我们真正需要的是访问实际的位图数据本身，这很可能是以压缩格式存储的，与任何特定的文件格式无关。
- en: Marmalade makes the task of loading images simple by way of the IwResManager
    API. This API relies upon the ITX file format we have just discussed, and is not
    just limited to loading images. It can also be used to load in data such as 3D
    models and animations, and we can also use it to keep track of our own custom
    classes.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Marmalade 通过 IwResManager API 简化了加载图像的任务。这个 API 依赖于我们刚刚讨论的 ITX 文件格式，并且不仅限于加载图像。它还可以用于加载
    3D 模型和动画等数据，我们还可以用它来跟踪我们自己的自定义类。
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Earlier we had to create our own instance of `CIwTextParserITX` in order to
    parse an ITX file. IwResManager creates its own instance of `CIwTextParserITX`
    when it needs it, so we don't need to worry about creating our own instance.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们必须创建自己的 `CIwTextParserITX` 实例来解析 ITX 文件。当需要时，IwResManager 会创建自己的 `CIwTextParserITX`
    实例，所以我们不需要担心创建自己的实例。
- en: Adding IwResManager to a project
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 IwResManager 添加到项目中
- en: To make the IwResManager API available to a project, all that needs to be done
    is to add `iwresmanager` to the subprojects list in the MKB file.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要使 IwResManager API 可用于项目，所有需要做的只是将 `iwresmanager` 添加到 MKB 文件中的子项目列表中。
- en: To initialize the API just add a call to `IwResManagerInit`, which will create
    a singleton instance of the Marmalade resource manager class `CIwResManager`.
    This class is used to load, free, and of course access our projects resources,
    whatever they may be. The singleton can be accessed using the function `IwGetResManager`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要初始化 API，只需添加对 `IwResManagerInit` 的调用，这将创建 Marmalade 资源管理器类 `CIwResManager`
    的单例实例。这个类用于加载、释放，当然还有访问我们的项目资源，无论它们是什么。可以使用函数 `IwGetResManager` 访问单例。
- en: When our project terminates we should call `IwResManagerTerminate`, which will
    destroy the resource manager singleton and any resources it may still have loaded
    in memory.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的项目终止时，我们应该调用 `IwResManagerTerminate`，这将销毁资源管理器单例以及它可能仍在内存中加载的任何资源。
- en: Specifying resources with a GROUP file
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 GROUP 文件指定资源
- en: Marmalade allows us to collect different types of resources together into a
    resource group. We are free to mix images, sounds, 3D models, and any other data
    types we might need to use.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Marmalade 允许我们将不同类型的资源收集到资源组中。我们可以自由混合图像、声音、3D 模型以及我们可能需要使用的任何其他数据类型。
- en: Why would we want to group resources together? Well, let's say you are writing
    a game with a number of different levels. Each level will have some common resources
    (for example, the player graphics) but might have unique elements specific to
    that level, so it would make sense to only have these resources in memory when
    the level is being played. You could therefore create one resource group for the
    player graphics, and individual ones for each level.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么要将资源分组在一起呢？比如说，你正在编写一个包含多个不同级别的游戏。每个级别将有一些公共资源（例如，玩家图形），但可能还有特定于该级别的独特元素，所以当级别正在播放时，只将这些资源保留在内存中是有意义的。因此，你可以为玩家图形创建一个资源组，并为每个级别创建单独的组。
- en: In order to load a resource group into our program, we first need to create
    a GROUP file. A GROUP file is actually an ITX file with the extension `.group`
    that allows us to list all the resources we want to gather together.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将资源组加载到我们的程序中，我们首先需要创建一个 GROUP 文件。实际上，GROUP 文件是一个扩展名为 `.group` 的 ITX 文件，它允许我们列出我们想要聚集的所有资源。
- en: 'Let''s start by taking a look at a sample GROUP file:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看一个示例 GROUP 文件开始：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first line of this file is defining a new `CIwResGroup` class instance,
    which is the class used to implement a resource group, and the first thing we
    do inside the curly braces of the definition is to give the resource group a name.
    This name will be used later to allow us to access the resource group.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件的 第一行 定义了一个新的 `CIwResGroup` 类实例，这是用于实现资源组的类，我们在定义的大括号内做的第一件事就是给资源组命名。这个名称将用于稍后允许我们访问资源组。
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A GROUP file should only contain a single `CIwResGroup` definition. The Marmalade
    SDK documentation states that behavior is undefined should you specify more than
    one. In practice this is not a problem since the GROUP file is the lowest level
    block of resources that can be loaded at a time, so there would be no real benefit
    in specifying more than one `CIwResGroup` anyway.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: GROUP 文件应只包含一个 `CIwResGroup` 定义。Marmalade SDK 文档指出，如果你指定了多个，行为将是未定义的。实际上这并不是一个问题，因为
    GROUP 文件是可以在一次加载的资源的最底层块，所以指定多个 `CIwResGroup` 实际上也没有真正的益处。
- en: The remaining lines of the example definition specify the resources we want
    to include in this group, and most often these will just be filenames for the
    resources in question. As we progress through this book we will see some extra
    functionality that the group file provides us with, but for now we'll just concentrate
    on the main task of loading resources.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 示例定义的剩余行指定了我们想要包含在此组中的资源，并且通常这些只是相关资源的文件名。随着我们继续阅读本书，我们将看到一些额外的功能，这些功能由组文件提供，但到目前为止，我们将专注于加载资源的主要任务。
- en: In the example, we are specifying three files that we want to be part of this
    resource group. The first is a bitmapped image saved in the PNG file format. The
    next resource is a reference to another GROUP file. When this GROUP file is loaded,
    the `sounds.group` file will be loaded into memory as well.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我们指定了三个我们希望成为此资源组一部分的文件。第一个是一个保存为 PNG 文件格式的位图图像。下一个资源是对另一个 GROUP 文件的引用。当这个
    GROUP 文件被加载时，`sounds.group` 文件也将被加载到内存中。
- en: The final file we are including is `levels.itx`, which is a standard ITX file
    and would be used to create instances of our own classes.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要包含的最后一个文件是 `levels.itx`，这是一个标准的 ITX 文件，将被用来创建我们自己的类的实例。
- en: Loading groups and accessing resources
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载组和访问资源
- en: 'To load a GROUP file in our program, we do the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的程序中加载 GROUP 文件，我们需要做以下操作：
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will look in the project's `data` directory for the specified GROUP file,
    and then load it into memory. The `LoadGroup` method returns a pointer to the
    `CIwResGroup` instance that was created, which we can store away somewhere so
    we can release the resource group and all its resources later.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在项目的 `data` 目录中查找指定的 GROUP 文件，并将其加载到内存中。`LoadGroup` 方法返回创建的 `CIwResGroup`
    实例的指针，我们可以将其存储起来，以便稍后释放资源组及其所有资源。
- en: 'With the resource group in memory, we can access the individual resources in
    one of two ways. The first way is to ask the `CIwResGroup` instance itself to
    locate a particular resource for us. Here''s how we do this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当资源组在内存中时，我们可以通过两种方式访问单个资源。第一种方式是要求 `CIwResGroup` 实例本身为我们定位特定的资源。以下是我们的操作方法：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the call to `GetResNamed`, the `name` parameter is a null terminated string
    containing the name of the resource we want to access. This is the value that
    is specified using the `name` attribute in an ITX file. If no `name` value is
    explicitly specified, the name of the first resource encountered in the GROUP
    file (minus any extension) will be used for the name. In the example GROUP file
    in the previous section this name would become `titlescreen`, since the first
    resource in the file is the `titlescreen.png` file.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `GetResNamed` 调用中，`name` 参数是一个以空字符终止的字符串，包含我们想要访问的资源名称。这是在 ITX 文件中使用 `name`
    属性指定的值。如果没有明确指定 `name` 值，将使用 GROUP 文件中遇到的第一个资源名称（不包括任何扩展名）。在上一个示例的 GROUP 文件中，这个名称将变为
    `titlescreen`，因为文件中的第一个资源是 `titlescreen.png` 文件。
- en: The `type` parameter indicates the class of the resource that we are trying
    to locate. This parameter is also a string and is simply the class name of the
    resource type.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`type` 参数指示我们正在尝试定位的资源类别。此参数也是一个字符串，简单地说就是资源类型的类名。'
- en: Finally there is the `flags` parameter that we can normally leave out entirely
    as it defaults to a value of zero. There are various flags we can use that alter
    the way the search for our resource is performed. For example, `IW_RES_PERMIT_NULL_F`
    will prevent an assert from being fired if the required resource could not be
    found. Check the Marmalade documentation for more information on these flags,
    though in most cases the default value of zero is what we need to use.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后还有 `flags` 参数，我们通常可以完全省略它，因为它默认值为零。我们可以使用各种标志来改变搜索资源的方式。例如，`IW_RES_PERMIT_NULL_F`
    将防止在找不到所需资源时触发断言。不过，有关这些标志的更多信息，请查阅 Marmalade 文档，尽管在大多数情况下，我们需要的默认值是零。
- en: If the resource can't be found, the `GetResNamed` call will return `NULL`, otherwise
    it returns our resource as a pointer to a `CIwResource` instance, which we can
    then cast to the required class type.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到资源，`GetResNamed` 调用将返回 `NULL`，否则它将返回我们的资源，作为一个指向 `CIwResource` 实例的指针，然后我们可以将其转换为所需的类类型。
- en: 'The second way of accessing a resource is to ask the resource manager to find
    it by searching through all the currently loaded groups. This can be very useful
    since it means we don''t have to know exactly which resource group to search in.
    Obviously a full search of all currently loaded resource groups will be slower,
    but it means we don''t have to keep track of every resource group we load. After
    all, that''s what the resource manager is for! The call required to search all
    loaded groups for a particular resource is as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 访问资源的第二种方式是要求资源管理器通过搜索所有当前加载的组来找到它。这可能非常有用，因为它意味着我们不必确切知道要搜索哪个资源组。显然，搜索所有当前加载的资源组将更慢，但这意味着我们不必跟踪我们加载的每个资源组。毕竟，这就是资源管理器的作用！搜索所有加载组以查找特定资源的调用如下：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The parameters are exactly the same as calling the `CIwResGroup::GetResNamed`
    method.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 参数与调用 `CIwResGroup::GetResNamed` 方法的参数完全相同。
- en: 'Finally, we can remove a resource group and everything it contains from memory
    by making the following call:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过以下调用从内存中删除一个资源组和它包含的所有内容：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We should destroy a group whenever we no longer need those resources in memory
    (for example, a group containing resources for a particular level of a game only
    needs to be in memory when playing that level). It isn't strictly necessary to
    destroy all groups on shutdown however, as Marmalade will ensure everything that
    has been allocated will be freed whenever an application is terminated.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们不再需要在内存中保留那些资源时（例如，仅当在玩游戏的一个特定级别时，包含该级别资源的组才需要保留在内存中），我们应该销毁一个组。然而，在关闭时销毁所有组并不是绝对必要的，因为
    Marmalade 将确保在应用程序终止时释放所有已分配的资源。
- en: The CIwResource class
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CIwResource 类
- en: We've already seen how the `CIwManaged` class can be used to allow us to easily
    create instances of our own classes by loading them out of a file. This functionality
    is improved further by the `CIwResource` class, which allows us to include our
    own classes into a resource group.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到 `CIwManaged` 类可以用来通过从文件中加载它们来轻松创建我们自己的类的实例。通过 `CIwResource` 类，这一功能得到了进一步的改进，它允许我们将自己的类包含到资源组中。
- en: In the GROUP file example shown in the previous section, we specified the `levels.itx`
    file that may contain definitions of our own classes. If our custom classes used
    `CIwResource` as their base class (or of course another class that was in turn
    derived from `CIwResource`) then all of our resources can be added to the resource
    group, saving us the bother of keeping track of them ourselves.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个章节中展示的 GROUP 文件示例中，我们指定了 `levels.itx` 文件，该文件可能包含我们自定义类的定义。如果我们的自定义类使用 `CIwResource`
    作为其基类（或者当然，任何从 `CIwResource` 继承而来的类），那么我们所有的资源都可以添加到资源组中，这样我们就无需自己跟踪它们。
- en: GROUP file serialization
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GROUP 文件序列化
- en: 'It is great that we can load different types of resources so easily, but ultimately
    we probably do not want to deploy our application with a collection of easily
    recognized or editable files. There are several reasons for this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松加载不同类型的资源真是太好了，但最终我们可能不希望将我们的应用程序与一组易于识别或编辑的文件一起部署。这有几个原因：
- en: 'Loading speed: Parsing a text file and converting it into a class is a slower
    operation than just loading in a ready parsed serialized version. It is also possible
    that we might need to do some sort of conversion on the original data to make
    it usable in the game, so if we can avoid doing this we will improve the loading
    time of our game.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载速度：解析一个文本文件并将其转换为类是一个比直接加载已解析序列化版本更慢的操作。还可能需要对我们原始数据进行某种转换，以便使其在游戏中可用，因此如果我们能避免这样做，我们将提高我们游戏的加载时间。
- en: 'To prevent hacking: If we ship a collection of text files and common file formats
    such as PNG files, we make it very easy for someone to hack and modify our game
    or make unauthorized use of the game''s resources.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了防止黑客攻击：如果我们分发一组文本文件和常见的文件格式，如 PNG 文件，我们将使某人很容易地黑客攻击并修改我们的游戏或未经授权使用游戏资源。
- en: 'Smaller code size: If we are loading resource data that is already in a form
    that our game code can use directly, there is no need to include any code for
    converting the original data format into our own internal one. This makes the
    code size smaller and also helps guard against hackers a little more.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码大小更小：如果我们正在加载的资源数据已经是我们游戏代码可以直接使用的格式，那么就没有必要包含任何将原始数据格式转换为我们的内部格式的代码。这使得代码大小更小，同时也稍微有助于防止黑客。
- en: 'Deployment size: Text files are often much larger than their serialized binary
    equivalents, so shipping a binary version could reduce the size of our install
    package.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署大小：文本文件通常比它们的序列化二进制等效文件大得多，因此发送二进制版本可以减少我们的安装包大小。
- en: Marmalade tackles all these issues by automatically converting every GROUP file
    we load into its binary equivalent using the serialization functionality provided
    by the `CIwManaged` class.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Marmalade 通过使用 `CIwManaged` 类提供的序列化功能，自动将我们加载的每个 GROUP 文件转换为它的二进制等效文件来解决所有这些问题。
- en: After the resource group has been fully loaded, the resource manager will call
    the `Serialise` method on every instance of every resource contained within the
    group, creating a file with `.bin` added to the original GROUP's filename. For
    example, the resources in a file called `images.group` would be serialized to
    a file called `images.group.bin`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在资源组完全加载后，资源管理器将对组内每个资源的每个实例调用 `Serialise` 方法，创建一个文件，其文件名在原始 GROUP 文件名后添加 `.bin`。例如，名为
    `images.group` 的文件中的资源将被序列化到名为 `images.group.bin` 的文件中。
- en: Once the serialized version of the GROUP file has been created, the resource
    manager destroys the resource group and then recreates it from the newly serialized
    version. This step is present as it makes catching problems, such as forgetting
    to serialize a member variable of a class, easier to spot.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了 GROUP 文件的序列化版本，资源管理器将销毁资源组，然后从新序列化的版本中重新创建它。这一步骤之所以存在，是因为它使得发现问题，例如忘记序列化类的成员变量，变得更加容易。
- en: 'There is a useful ICF setting that controls the resource building process.
    Simply add the following to the ICF file (refer back to [Chapter 1](ch01.html
    "Chapter 1. Getting Started with Marmalade"), *Getting Started with Marmalade*,
    for a discussion of what an ICF file is):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一个有用的 ICF 设置，用于控制资源构建过程。只需将以下内容添加到 ICF 文件中（参考[第1章](ch01.html "第1章. 使用 Marmalade
    入门")，*使用 Marmalade 入门*，以了解 ICF 文件是什么）：
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When set to `1`, the `ResBuild` setting will ensure that the resource manager
    always loads the GROUP file and serializes it. By setting it to `0`, the GROUP
    file parsing stage is skipped and instead any existing serialized version of the
    GROUP file will be loaded directly. This can be very useful during development,
    to both increase application startup time when no resources have been added or
    changed, and also to match more closely the loading process on the device.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当设置为 `1` 时，`ResBuild` 设置将确保资源管理器始终加载 GROUP 文件并将其序列化。将其设置为 `0`，则跳过 GROUP 文件解析阶段，而是直接加载
    GROUP 文件的现有序列化版本。这在开发期间非常有用，既可以增加没有添加或更改资源时的应用程序启动时间，也可以更接近设备上的加载过程。
- en: Note
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you've made changes to the resources for your game but they aren't appearing
    when you run it, the `ResBuild` flag is always a good first port of call. It's
    amazing how easy it is to make a resource change and forget that you've disabled
    resource building!
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经对你的游戏资源进行了更改，但运行时它们没有出现，那么 `ResBuild` 标志始终是一个好的起点。令人惊讶的是，要做出资源更改并忘记你已禁用资源构建是多么容易！
- en: Resource handlers
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源处理器
- en: There is one final part of the IwResManager API that is worth mentioning, and
    this is the concept of **resource handlers**.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，IwResManager API 的最后一个部分，这就是 **资源处理器** 的概念。
- en: You may have wondered how the resource manager is able to load and process files
    of different types. It's great that we can just list a bunch of filenames in a
    GROUP file, but how exactly does a PNG format image file end up being loaded into
    a form that we can use for rendering? Resource handlers, of course!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道资源管理器是如何加载和处理不同类型的文件的。我们可以在 GROUP 文件中列出一些文件名，这很好，但 PNG 格式的图像文件究竟是如何被加载成我们可以用于渲染的形式的呢？当然是通过资源处理器！
- en: A resource handler is a subclass of `CIwResHandler` that is used to load and
    process resources of a particular type, identified by one or more filename extensions.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 资源处理器是 `CIwResHandler` 的子类，用于加载和处理特定类型的资源，该类型由一个或多个文件扩展名标识。
- en: When the text parser comes across a filename in the GROUP file, it looks at
    the file extension and then checks to see if a resource handler has been registered
    for that extension. If no suitable handler is found an error will be raised, otherwise
    the filename is passed to the relevant resource handler class that will then do
    whatever needs to be done to the file to make it usable in our code.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当文本解析器在 GROUP 文件中遇到文件名时，它会查看文件扩展名，然后检查是否已为该扩展名注册了资源处理器。如果没有找到合适的处理器，将引发错误；否则，文件名将被传递给相关的资源处理器类，该类将执行对文件所需的任何操作，使其在我们的代码中可用。
- en: The entire resource manager system in Marmalade relies on resource handlers
    in order to work. GROUP files, ITX files, and bitmapped image files are all processed
    by classes derived from `CIwResHandler`, and we can create our own custom resource
    handlers should we want to make use of some other file type not supported by the
    core Marmalade SDK.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Marmalade 中的整个资源管理系统都依赖于资源处理器才能工作。GROUP 文件、ITX 文件和位图图像文件都由从 `CIwResHandler`
    派生的类处理，如果我们想使用核心 Marmalade SDK 不支持的某些文件类型，我们可以创建自己的自定义资源处理器。
- en: We will be coming back to the subject of resource handlers when we talk about
    implementing sound in [Chapter 7](ch07.html "Chapter 7. Adding Sound and Video"),
    *Adding Sound and Video* of this book, since Marmalade does not have support for
    any sound file formats as part of the core SDK.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈到在 [第 7 章](ch07.html "第 7 章。添加声音和视频") *添加声音和视频* 中实现声音时，我们将再次回到资源处理器的话题，因为
    Marmalade 核心SDK 不支持任何声音文件格式。
- en: Graphics APIs provided by the Marmalade SDK
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Marmalade SDK 提供的图形 API
- en: Now that we are familiar with resource management, we can get on to the more
    interesting task of showing a picture on the display.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了资源管理，我们可以继续进行更有趣的任务，即在显示上显示图片。
- en: Marmalade spoils us by providing several different ways in which we can draw
    graphics on the screen. The following sections provide an overview of the different
    options available to us.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Marmalade 通过提供多种在屏幕上绘制图形的方法来宠坏了我们。以下各节提供了我们可用的不同选项的概述。
- en: The s3eSurface API
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: s3eSurface API
- en: The lowest level of display access is the `s3eSurface` API. This provides access
    to the display by using a memory pointer that you can then use to directly read
    or alter pixels.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 显示访问的最低级别是 `s3eSurface` API。它通过使用内存指针提供对显示的访问，然后您可以使用该指针直接读取或修改像素。
- en: You can discover the width and height of the display in pixels and also the
    pitch, which is the number of bytes that you need to skip through memory to get
    to the next row of the display image.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以找到显示的宽度和高度（以像素为单位），以及步长，即您需要跳过多少字节才能到达显示图像的下一行。
- en: The pitch is affected by the pixel format of the display (16-, 24-, or 32-bit
    displays are all possible) and often extra padding bytes are also added to allow
    each row to begin on a word-aligned memory address, which can improve display
    memory access times.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 音调受显示的像素格式（16 位、24 位或 32 位显示都是可能的）的影响，并且通常还会添加额外的填充字节，以便每行从字对齐的内存地址开始，这可以提高显示内存访问时间。
- en: In practice this API is very rarely used, partly because it provides no support
    for drawing bitmapped images or lines, but mostly because it is incredibly slow
    on many modern devices due to the display being drawn by a **Graphics Processing
    Unit** (**GPU**), which may place restrictions on how and when this memory can
    be accessed by the CPU.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这个 API 很少被使用，部分原因是因为它不提供绘制位图图像或线条的支持，但主要是因为它在许多现代设备上由于显示是由 **图形处理单元**（**GPU**）绘制的而非常慢，这可能会限制
    CPU 如何以及何时访问此内存。
- en: We will not be using this API anywhere in this book, but if you wish to use
    it there is nothing you have to add to your project as it is always available
    in any Marmalade project.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在本书中任何地方使用此 API，但如果您想使用它，您不需要向您的项目添加任何内容，因为它始终在 Marmalade 项目的任何地方可用。
- en: The IwGL API and OpenGL ES
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IwGL API 和 OpenGL ES
- en: As mentioned above, most mobile devices available today contain a GPU that is
    used to speed up drawing operations and free the CPU for other tasks, such as
    updating the current state of a game. The standard API that has been adopted across
    most mobile platforms is OpenGL ES.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，今天大多数移动设备都包含一个用于加速绘图操作并释放 CPU 以执行其他任务的 GPU，例如更新游戏当前状态。在大多数移动平台上采用的标准 API
    是 OpenGL ES。
- en: The OpenGL ES API is a derivative of the OpenGL API, which has been used on
    many desktop systems for many years. OpenGL ES was conceived as a cut-down version
    of OpenGL designed for embedded systems (hence the ES part of the name!).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL ES API 是 OpenGL API 的衍生品，OpenGL API 已经在许多桌面系统上使用了多年。OpenGL ES 被构想为 OpenGL
    的简化版本，专为嵌入式系统设计（因此得名 ES 部分！）。
- en: There are two main versions of the OpenGL ES. The 1.x standard is intended for
    devices that have fixed, function rendering pipelines, which means that while
    control is provided in how a 3D point is transformed to 2D coordinates, and how
    a polygon and its associated textures (if any) are rasterized to the screen, you
    are completely limited to the options provided by the hardware.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL ES 有两个主要版本。1.x 标准是为具有固定、功能渲染管道的设备设计的，这意味着虽然可以控制如何将 3D 点转换成 2D 坐标，以及如何将多边形及其关联的纹理（如果有）光栅化到屏幕上，但你完全受限于硬件提供的选项。
- en: The 2.x standard of OpenGL ES is intended for GPU hardware where the act of
    both transforming 3D points and rasterizing the resultant polygons can be programmed
    by way of **shaders**. A shader is a short program that can be applied very quickly
    to either transform 3D points (a vertex shader) or work out the required color
    of a rendered pixel (a pixel or fragment shader).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL ES 的 2.x 标准是为 GPU 硬件设计的，其中 3D 点的转换和结果多边形的光栅化可以通过 **着色器** 来编程。着色器是一个可以非常快速应用于转换
    3D 点（顶点着色器）或计算渲染像素所需颜色的简短程序（像素或片段着色器）。
- en: In most cases a device supporting OpenGL ES 2.x will also support OpenGL ES
    1.x, but the two cannot be mixed. When initializing OpenGL, you request one or
    the other of these interfaces to be created as the OpenGL context. The context
    is really nothing more than a big structure which stores all the information that
    OpenGL needs in order to operate, such as the current frame buffer, pixel blending
    mode, and available shaders.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，支持 OpenGL ES 2.x 的设备也将支持 OpenGL ES 1.x，但两者不能混合。当初始化 OpenGL 时，您请求创建一个或另一个接口作为
    OpenGL 上下文。上下文实际上不过是一个大结构，它存储了 OpenGL 运作所需的所有信息，例如当前帧缓冲区、像素混合模式以及可用的着色器。
- en: 'So what exactly is the IwGL API? Put simply, it is a wrapper for OpenGL ES
    that allows us to make normal OpenGL ES function calls directly, but it also provides
    some other very useful functionality:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，IwGL API 究竟是什么呢？简单来说，它是对 OpenGL ES 的包装，允许我们直接调用常规的 OpenGL ES 函数调用，但它还提供了一些其他非常有用的功能：
- en: IwGL simplifies the process of initializing OpenGL ES to a single function call—`IwGLInit`.
    This function call will initialize the frame buffer and set up the OpenGL context
    so that it is ready and raring to go, with settings that should be optimal for
    the type of hardware available. Fine control over initialization is also provided
    to allow display and depth buffer formats to be chosen using settings made in
    the application's ICF file.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IwGL 简化了初始化 OpenGL ES 的过程，只需一个函数调用——`IwGLInit`。这个函数调用将初始化帧缓冲区并设置 OpenGL 上下文，使其准备好并准备好运行，使用适合可用硬件的设置。还提供了对初始化的精细控制，允许使用应用程序的
    ICF 文件中设置的设置来选择显示和深度缓冲区格式。
- en: It provides context state caching functions, such as keeping a copy of all textures
    currently uploaded to OpenGL ES. In the event of your application being suspended
    (for example, by an incoming call) all its textures and other resources could
    be lost, and normally it would be your responsibility to reload everything you
    need. IwGL automatically takes care of all this for us.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了上下文状态缓存函数，例如保留所有当前上传到 OpenGL ES 的纹理的副本。在您的应用程序被挂起的情况下（例如，由来电引起）所有纹理和其他资源可能会丢失，通常您需要负责重新加载所有需要的资源。IwGL
    自动为我们处理所有这些。
- en: Any OpenGL ES extension functions (extra functionality that a particular GPU
    may provide over and above the required base level of OpenGL ES) become mapped
    to functions that can be called directly and will not cause an error if that function
    is not actually supported. Normally you would need to specifically check if an
    extension exists before trying to call it.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何 OpenGL ES 扩展函数（特定 GPU 可能提供的超出 OpenGL ES 基础级别要求的功能）都映射到可以直接调用的函数，如果该函数实际上不受支持，则不会引发错误。通常，在尝试调用它之前，您需要专门检查是否存在扩展。
- en: It also provides a Virtual Resolution system that makes it easy to take existing
    code that was hardcoded to a particular resolution or screen orientation and make
    it run at a different resolution or orientation by resizing or rotating the rendered
    image.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它还提供了一个虚拟分辨率系统，这使得将现有代码（这些代码是硬编码到特定分辨率或屏幕方向）调整为不同分辨率或方向变得容易，只需调整或旋转渲染的图像即可。
- en: IwGL is an invaluable part of the Marmalade SDK when you are porting existing
    code written using OpenGL ES, as it allows you to take advantage of Marmalade's
    ability to deploy to multiple platforms without having to completely recode the
    entire project.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当您正在将使用OpenGL ES编写的现有代码移植到Marmalade时，IwGL是Marmalade SDK的一个无价部分，因为它允许您利用Marmalade将项目部署到多个平台的能力，而无需完全重写整个项目。
- en: However, we won't be using IwGL in this book either. While there is nothing
    to stop us from using this API to develop a new project, it does mean we are limited
    to targeting only devices that feature GPUs (or support a software emulated version
    of OpenGL), and we still need to take care of things like loading textures ourselves.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们在这本书中也不会使用IwGL。虽然我们无法阻止自己使用这个API来开发新的项目，但这确实意味着我们只能针对具有GPU（或支持OpenGL软件模拟版本）的设备进行开发，我们仍然需要自己处理诸如加载纹理等问题。
- en: You can use the IwGL API in your own project by adding `iwgl` to the `subprojects`
    section of the MKB file.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在MKB文件的`subprojects`部分添加`iwgl`来在自己的项目中使用IwGL API。
- en: The Iw2D API
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Iw2D API
- en: Given that this is a chapter about 2D graphics rendering, the Iw2D API must
    surely be the way to go, right?
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一章关于2D图形渲染的章节，Iw2D API肯定是我们应该选择的方式，对吧？
- en: 'Well, yes and no. It certainly has a lot going for it, like the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，是的，也不是。它确实有很多优点，如下所示：
- en: It provides us with the ability to render flat shaded primitives such as lines,
    arcs, rectangles, and polygons, either as outlines or filled shapes.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使我们能够渲染平面着色的基本图形，如线条、弧线、矩形和多边形，可以是轮廓或填充形状。
- en: It allows us to easily load bitmapped images and render them on screen and also
    apply scaling or rotational transforms to those images.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使我们能够轻松加载位图图像并在屏幕上渲染它们，还可以对这些图像应用缩放或旋转变换。
- en: It makes it easy for us to draw text on screen that looks substantially better
    than the default debug font we've currently seen.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使我们能够在屏幕上绘制看起来比我们目前看到的默认调试字体好得多的文本。
- en: It provides certain optimizations that allow us to speed up rendering. For example,
    it can batch together several requests to draw a particular image into a single
    call, which can yield good performance increases on many devices.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了一些优化，使我们能够加快渲染速度。例如，它可以将绘制特定图像的多个请求批量处理为单个调用，这在许多设备上可以带来良好的性能提升。
- en: However, as you've probably already inferred from the tone of this section,
    we won't be using Iw2D in this book either.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如你可能已经从本节的语气中推断出的那样，我们在这本书中也不会使用Iw2D。
- en: If you are only interested in rendering 2D graphics, Iw2D may well be perfectly
    adequate for your needs, but if you ever want to make the jump to 3D graphics
    you will eventually find that the Iw2D API just doesn't do everything you need,
    such as rendering textured polygons of any shape, not just rectangular.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只对渲染2D图形感兴趣，Iw2D可能完全能满足您的需求，但如果您将来想要过渡到3D图形，您最终会发现Iw2D API并不能满足您的所有需求，比如渲染任何形状的纹理多边形，而不仅仅是矩形。
- en: Since we will be tackling 3D graphics later in this very book, it makes sense
    for us to begin our journey into rendering with Marmalade by using 3D graphics
    itself.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在本书的后面部分处理3D图形，因此我们使用Marmalade开始我们的渲染之旅，本身使用3D图形是有意义的。
- en: If you want to use this API in your own project, just add `iw2d` to the `subprojects`
    section of the MKB file.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在您的项目中使用这个API，只需在MKB文件的`subprojects`部分添加`iw2d`。
- en: The IwGx API
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IwGx API
- en: Finally we come to the API that we will be using in this book; in fact we have
    already used a very small part of it in the creation of our "Hello World" project.
    Ladies and gentlemen, I give you the IwGx API!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到了本书中将使用的API；实际上，我们在创建我们的“Hello World”项目时已经使用了一小部分。女士们，先生们，我向大家介绍IwGx
    API！
- en: 'This API is extremely flexible and boasts the following functionalities:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 此API非常灵活，并具有以下功能：
- en: It supports both hardware and software rendering pipelines, so your code can
    potentially run unaltered on modern hardware featuring a GPU yet still fall back
    to a software-based renderer for older or less capable hardware. You can even
    mix the two pipelines, so you could use the GPU for rasterization but still use
    the CPU for transform and lighting operations.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持硬件和软件渲染管线，因此您的代码可以在具有 GPU 的现代硬件上未经修改地运行，同时在较老或功能较弱的硬件上回退到基于软件的渲染器。您甚至可以混合这两个管线，例如，您可以使用
    GPU 进行光栅化，但仍然使用 CPU 进行变换和光照操作。
- en: It takes care of the nitty-gritty for us, such as initializing the display and
    texture management, in a similar way to the IwGL API.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为我们处理了一些繁琐的事情，例如初始化显示和纹理管理，这与 IwGL API 类似。
- en: It allows us to use features such as texture mapping and flat or gouraud shading
    on arbitrary polygons.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许我们在任意多边形上使用纹理映射和平滑或高洛德着色等特性。
- en: It provides some debugging functionality, such as simple text rendering (as
    in our "Hello World" project) and rendering shapes like rectangles and circles.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了一些调试功能，例如简单的文本渲染（如我们的“Hello World”项目所示）和渲染形状，如矩形和圆形。
- en: It makes targeting OpenGL ES 2.x devices much easier, as it provides the necessary
    shader programs to emulate the fixed function pipeline of Open GL ES 1.x while
    still allowing us to provide our own custom shaders when we want to.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使得针对 OpenGL ES 2.x 设备变得更容易，因为它提供了必要的着色器程序来模拟 Open GL ES 1.x 的固定功能管线，同时仍然允许我们在需要时提供自己的自定义着色器。
- en: By using IwGx for rendering 2D graphics from the start, we will find it a whole
    lot easier to move on to drawing 3D polygons later, as the techniques involved
    are incredibly similar.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从一开始就使用 IwGx 进行 2D 图形的渲染，我们将发现稍后绘制 3D 多边形要容易得多，因为涉及的技术非常相似。
- en: Note
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: With Version 6.1 of Marmalade, the IwGx API underwent a little modernization
    and standardized using floating point values for specifying polygon information.
    Prior to this version, some information (for example, texture UV values) was specified
    in fixed point integer formats. There was also a software-based rendering engine
    for targeting old devices with no GPU hardware. If you have existing code that
    still needs the old fixed point way of doing things, you can revert back by adding
    `define IW_USE_LEGACY_MODULES` to the project MKB file.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 Marmalade 版本 6.1 的发布，IwGx API 进行了一些现代化改造，并标准化了使用浮点值来指定多边形信息。在此版本之前，一些信息（例如，纹理
    UV 值）是以定点整数格式指定的。还有一个基于软件的渲染引擎，用于针对没有 GPU 硬件的旧设备。如果您有仍然需要旧定点方式执行操作的现有代码，可以通过在项目
    MKB 文件中添加 `define IW_USE_LEGACY_MODULES` 来回退。
- en: It should come as no surprise by now that we can use IwGx in our project simply
    by adding `iwgx` to the `subprojects` section of the MKB file.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该不会让人感到惊讶，我们只需在 MKB 文件的 `subprojects` 部分添加 `iwgx`，就可以在我们的项目中使用 IwGx。
- en: Using IwGx to render 2D graphics
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 IwGx 渲染 2D 图形
- en: Now that we know how to load resources, we can get on with the fun stuff. We're
    going to look at how we can draw a bitmapped image on screen.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何加载资源，我们可以开始做一些有趣的事情。我们将探讨如何在屏幕上绘制位图图像。
- en: IwGx initialization and termination
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IwGx 初始化和终止
- en: We've already seen how to do this in the "Hello World" project of [Chapter 1](ch01.html
    "Chapter 1. Getting Started with Marmalade"), *Getting Started with Marmalade*.
    We just call `IwGxInit` to set up IwGx at the start of our program and `IwGxTerminate`
    to close it down again at the end.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在“第 1 章”的“Hello World”项目中看到了如何做到这一点，即 *Marmalade 入门*。我们只需在程序开始时调用 `IwGxInit`
    来设置 IwGx，并在结束时调用 `IwGxTerminate` 来关闭它。
- en: Rendering a polygon
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染一个多边形
- en: In IwGx, the most commonly used polygon types are lines, triangles, and quads
    (basically two triangles that share a common edge).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IwGx 中，最常用的多边形类型是线条、三角形和四边形（基本上是两个共享公共边的三角形）。
- en: Also supported are sprites, which are always rectangular in shape and do not
    allow any scaling of textures, and n-polys, which can contain up to 63 vertices.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 还支持精灵，它们总是矩形的形状，不允许纹理缩放，以及 n-多边形，可以包含多达 63 个顶点。
- en: Sprites are rarely used since triangles and quads are more flexible, though
    they can be faster to draw especially in software rendering mode. The n-poly can
    also be faster to draw for the software renderer than a series of triangles, but
    they are generally best avoided since they need to be converted into triangles
    on the fly in order to be drawn using hardware rendering.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 由于三角形和四边形更加灵活，精灵很少被使用，尽管在软件渲染模式下它们可以更快地绘制。对于软件渲染器来说，n-多边形也可能比一系列三角形更快地绘制，但它们通常最好避免，因为它们需要即时转换为三角形才能使用硬件渲染进行绘制。
- en: To render a polygon on screen, we at least need to specify where we want it
    to appear on screen and what color we want it to be in. Additionally, we might
    want to draw the polygon using a bitmapped image. The following sections show
    how we can provide this information.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要在屏幕上渲染多边形，我们至少需要指定它想要出现在屏幕上的位置和它想要的颜色。此外，我们可能还想使用位图图像来绘制多边形。以下章节将展示我们如何提供这些信息。
- en: Materials and textures
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 材料和纹理
- en: 'First we let IwGx know what color (or indeed colors) and image we want applied
    to our polygon. We do this by specifying the material we want to use, which is
    an instance of the `CIwMaterial` class that groups together this information.
    To set the material we want to use, we must provide IwGx with a pointer to the
    relevant `CIwMaterial` instance using the following function call:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们让IwGx知道我们想要应用到我们的多边形上的颜色（或者确实是颜色）和图像。我们通过指定我们想要使用的材料来完成这项工作，这是一个`CIwMaterial`类的实例，它将此信息组合在一起。为了设置我们想要使用的材料，我们必须使用以下函数调用向IwGx提供一个指向相关`CIwMaterial`实例的指针：
- en: '[PRE13]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If we are drawing a polygon with no image applied to it, then the very minimum
    information the material will need to provide is the color we want to use.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在绘制一个没有应用图像的多边形，那么材料至少需要提供我们想要使用的颜色信息。
- en: A material actually contains four different colors that, if you are at all familiar
    with 3D graphics rendering, you will probably recognize. They are the ambient,
    diffuse, emissive, and specular colors. For 2D rendering purposes, it is only
    the ambient color that we are concerned with. We'll look into the others when
    we move on to 3D rendering in [Chapter 4](ch04.html "Chapter 4. 3D Graphics Rendering"),
    *3D Graphics Rendering*.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 一种材料实际上包含四种不同的颜色，如果你对3D图形渲染稍有了解，你可能会认出它们。它们是环境色、漫反射色、发射色和镜面色。对于2D渲染目的，我们只关心环境色。当我们进入第4章[3D
    Graphics Rendering](ch04.html "Chapter 4. 3D Graphics Rendering")中的3D渲染时，我们会探讨其他颜色。
- en: The material also specifies the texture we want to apply. A texture specifies
    a bitmapped image that we want to apply to our polygon, and is represented in
    Marmalade by the `CIwTexture` class.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 材料还指定了我们想要应用的纹理。纹理指定了一个我们要应用到我们的多边形上的位图图像，在Marmalade中由`CIwTexture`类表示。
- en: The `CIwTexture` class is actually a wrapper for the `CIwImage` class that actually
    stores the pixel information for an image. `CIwTexture` adds functionality to
    control how the image is actually rendered, with support for enabling and disabling
    features such as bilinear filtering and mipmapping.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`CIwTexture`类实际上是对`CIwImage`类的包装，它实际上存储了图像的像素信息。`CIwTexture`增加了控制图像如何渲染的功能，支持启用和禁用诸如双线性过滤和米波映射等功能。'
- en: Materials also provide control over other polygon rendering features, such as
    whether the polygon is rendered flat or gouraud shaded, and how it should be blended
    with the current screen contents when it is drawn.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 材料还提供了控制其他多边形渲染功能的能力，例如多边形是渲染为平面还是高洛德着色，以及绘制时如何与当前屏幕内容混合。
- en: Materials can either be created in code or they can be instanced by the resource
    manager. The following sections illustrate this.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 材料可以通过代码创建，也可以由资源管理器实例化。以下章节将说明这一点。
- en: Creating materials in code
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在代码中创建材料
- en: 'Creating a material in code requires little more than making a new instance
    of `CIwMaterial` and using the available methods to set the color, textures, and
    other settings. For example, to create a material that will render bright red,
    semi-transparent polygons we could use the following code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中创建材料只需要创建一个新的`CIwMaterial`实例，并使用可用的方法设置颜色、纹理和其他设置。例如，为了创建一个渲染明亮的红色、半透明多边形的材料，我们可以使用以下代码：
- en: '[PRE14]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that Marmalade will raise an assert message if you try to create a local
    `CIwMaterial` instance on the program stack. This happens because rendering does
    not happen the moment you make a drawing function call, so by the time rendering
    does occur, the material data will likely have been trashed by other functions
    reusing the same area of stack space.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你尝试在程序堆栈上创建一个本地的 `CIwMaterial` 实例，Marmalade 会抛出一个断言消息。这是因为渲染并不是在你调用绘图函数的那一刻发生的，所以当渲染真正发生时，材质数据可能会被其他函数重用相同堆栈空间时破坏。
- en: Creating materials using an MTL file
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 MTL 文件创建材质
- en: While creating materials in code is simple enough, there is an easier way, especially
    when it comes to specifying materials with textures. This involves yet another
    use of our friend, the ITX file.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在代码中创建材质很简单，但有一种更简单的方法，尤其是在指定带有纹理的材质时。这涉及到我们朋友 ITX 文件的另一种用途。
- en: A material file has the extension `.mtl` and again uses the same formatting
    rules as an ITX file. We can create any number of `CIwMaterial` instances in an
    MTL file and initialize them with the required colors, textures, and other settings.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 材质文件具有 `.mtl` 扩展名，并且使用与 ITX 文件相同的格式化规则。我们可以在 MTL 文件中创建任意数量的 `CIwMaterial` 实例，并用所需的颜色、纹理和其他设置初始化它们。
- en: As a bonus, any texture we refer to in the MTL file will also be loaded automatically,
    meaning we don't have to list it separately in a GROUP file. In order for this
    to work, all the source image files must reside in a subdirectory named `textures`,
    which is located in the same directory as the MTL file, or alternatively they
    must already have been loaded into memory either from another GROUP file or in
    the same GROUP file prior to referencing the MTL file.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的好处，我们在 MTL 文件中引用的任何纹理也将自动加载，这意味着我们不需要在 GROUP 文件中单独列出它。为了使这一点生效，所有源图像文件必须位于名为
    `textures` 的子目录中，该子目录位于 MTL 文件所在的同一目录中，或者它们必须已经从另一个 GROUP 文件或在同一 GROUP 文件中在引用
    MTL 文件之前加载到内存中。
- en: Note
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Marmalade natively supports the PNG, TGA, GIF, and BMP image file formats. If
    you want to load any other type of bitmap, you will need to provide your own custom
    resource handler to do so.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Marmalade 本地支持 PNG、TGA、GIF 和 BMP 图像文件格式。如果你想要加载任何其他类型的位图，你需要提供自己的自定义资源处理程序来做到这一点。
- en: 'Here is an example of what an MTL file might look like:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个 MTL 文件可能的样子：
- en: '[PRE15]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This example generates a semi-transparent red material equivalent to that created
    in the previous section, and also a material using a texture named `grid.png`,
    which is drawn flat shaded with additive transparency at half the original image
    brightness and without bilinear filtering.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子生成了一种半透明的红色材质，相当于上一节中创建的材质，以及一个使用名为 `grid.png` 的纹理的材质，该材质以平面着色和加性透明度绘制，亮度为原始图像的一半，并且没有双线性过滤。
- en: Note
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may have noticed that the image is specified using an attribute called `texture0`.
    Marmalade materials can actually be assigned two textures that can be blended
    together when rendering a polygon and they are referred to as `texture0` and `texture1`.
    In this book we will only be concerned with single texture materials.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，图片是通过一个名为 `texture0` 的属性来指定的。Marmalade 材质实际上可以分配两个纹理，当渲染多边形时它们可以混合在一起，它们被称为
    `texture0` 和 `texture1`。在这本书中，我们只关注单纹理材质。
- en: There are far too many attribute names to list here, so for a complete list
    take a look at the Marmalade documentation page for the `CIwMaterial` class. This
    page lists all of them.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要列出的属性名称太多，所以为了获得完整的列表，请查看 Marmalade 文档页面中的 `CIwMaterial` 类。该页面列出了所有这些属性。
- en: To make these materials available in our code, we just need to reference the
    MTL file inside a GROUP file that we are loading. We can then get hold of the
    materials by searching for them by name using the resource manager functions described
    earlier in this chapter.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这些材质在我们的代码中可用，我们只需要在加载的 GROUP 文件中引用 MTL 文件。然后我们可以通过使用本章前面描述的资源管理器函数按名称搜索它们来获取材质。
- en: Note
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is recommended that when materials are created using an MTL file, you do
    not modify any of their settings using the methods in the `CIwMaterial` class.
    Instead, make a copy of the material using the `CIwMaterial::Copy` method. While
    it is possible to do so, problems can occur if the same material is used to render
    several different things, since rendering does not occur as soon as a drawing
    function call is made. The end result is therefore unpredictable as it would depend
    on how the `CIwMaterial` happens to be configured when rendering finally occurs.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 建议在创建使用MTL文件的材料时，不要使用`CIwMaterial`类中的方法修改它们的任何设置。相反，使用`CIwMaterial::Copy`方法制作材料的副本。虽然这样做是可能的，但如果相同的材料用于渲染多个不同的事物，可能会出现问题，因为渲染并不在绘制函数调用时立即发生。因此，最终结果是不可预测的，因为它将取决于`CIwMaterial`在最终渲染时如何配置。
- en: Vertex streams
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 顶点流
- en: In order to display a polygon on screen, we need to specify a list of screen
    coordinates that define the corner points. Since we are only rendering in 2D at
    the moment, each coordinate is specified as a `CIwSVec2` instance, which is a
    vector class defined in another Marmalade API called **IwGeom**. Any list of data
    items used when rendering polygons, be it vertices, colors, or whatever, is often
    referred to as a **stream**, so a list of vertices is called a **vertex stream**.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在屏幕上显示多边形，我们需要指定一个定义角点的屏幕坐标列表。由于我们目前只进行2D渲染，每个坐标都指定为一个`CIwSVec2`实例，这是一个在另一个名为**IwGeom**的Marmalade
    API中定义的向量类。在渲染多边形时使用的任何数据项列表，无论是顶点、颜色还是其他，通常被称为**流**，因此顶点列表被称为**顶点流**。
- en: While we can specify this API to be part of our project by adding `iwgeom` to
    the `subprojects` section of the MKB file and calling `IwGeomInit` and `IwGeomTerminate`,
    there isn't actually a need to, since IwGx relies on this API itself.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以通过将`iwgeom`添加到MKB文件的`subprojects`部分并调用`IwGeomInit`和`IwGeomTerminate`来指定此API作为我们项目的一部分，但实际上并不需要这样做，因为IwGx本身依赖于这个API。
- en: The `CIwSVec2` class defines a two-component vector using signed 16-bit integers,
    so it is perfect for specifying screen coordinates.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`CIwSVec2`类使用有符号16位整数定义一个两分量向量，因此非常适合指定屏幕坐标。'
- en: The default screen coordinate system in IwGx places the origin at the top-left
    corner of the screen, with the x component increasing horizontally to the right
    and the y component increasing vertically downwards. It is possible to change
    the position of the origin, however, by passing a `CIwSVec2` instance containing
    the desired position of the origin to the function `IwGxSetScreenSpaceOrg`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: IwGx中的默认屏幕坐标系将原点放置在屏幕的左上角，x分量水平向右增加，y分量垂直向下增加。然而，可以通过传递一个包含原点所需位置的`CIwSVec2`实例到函数`IwGxSetScreenSpaceOrg`来改变原点的位置。
- en: The following diagram illustrates how we could specify the coordinates for a
    triangle on a standard iPhone resolution screen (320 x 480 pixels). The top left
    of the screen is the origin and has a coordinate position of **(0,0)**, while
    the bottom-right corner has a position of **(320,480)**.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了我们如何在标准iPhone分辨率屏幕（320 x 480像素）上指定三角形的坐标。屏幕的左上角是原点，坐标位置为**（0，0**），而右下角的位置为**（320，480**）。
- en: '![Vertex streams](img/3363_02_01.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![顶点流](img/3363_02_01.jpg)'
- en: 'To render this triangle all we have to do is fill in an array of `CIwSVec2`
    with the coordinates and submit them to IwGx, as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 要渲染这个三角形，我们只需填充一个包含坐标的`CIwSVec2`数组的数组，并将其提交给IwGx，如下所示：
- en: '[PRE16]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The function call, `IwGxSetVertStreamScreenSpace`, allows us to specify a list
    of screen space (that is, pixel) coordinates we want to use for rendering, but
    we must also explicitly state how many vertices we are submitting. In the case
    of our triangle, this is three.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用`IwGxSetVertStreamScreenSpace`允许我们指定用于渲染的屏幕空间（即像素）坐标列表，但我们必须明确声明我们提交了多少个顶点。在我们的三角形的情况下，这是三个。
- en: It is also possible to specify our coordinates using sub-pixel positioning with
    the function call `IwGxSetVertStreamScreenSpaceSubPixel`. It may be getting a
    bit on the long side to type, but using sub-pixel positioning does provide the
    advantage of smoother movement on screen, as we are no longer limited to only
    moving things around the screen in terms of whole pixels.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用`IwGxSetVertStreamScreenSpaceSubPixel`函数调用指定我们的坐标，使用子像素定位。虽然输入可能有点长，但使用子像素定位确实提供了屏幕上更平滑移动的优势，因为我们不再仅限于以整个像素为单位在屏幕上移动事物。
- en: Using sub-pixel coordinates can also improve the quality of the final rendered
    image, as slow moving objects won't appear to jump between pixel positions if
    we are rendering using bilinear filtering.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 使用子像素坐标也可以提高最终渲染图像的质量，因为如果我们在使用双线性过滤进行渲染时，缓慢移动的对象不会在像素位置之间跳跃。
- en: IwGx only supports eight sub-pixel positions per pixel; so to convert our coordinates
    to use sub-pixel positioning, all we need to do is multiply the screen coordinates
    by eight or use the bitwise shift operator to shift left by three places.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: IwGx 每个像素只支持八个子像素位置；因此，为了将我们的坐标转换为使用子像素定位，我们只需将屏幕坐标乘以八或使用位运算符将左移三位。
- en: Color streams
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 颜色流
- en: If we want to draw a polygon using flat shading, so that every pixel rendered
    is the same color, we can just set the ambient color of our material and our work
    is done.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用平面着色来绘制多边形，使得渲染的每个像素都是相同的颜色，我们只需设置我们材质的环境颜色，我们的工作就完成了。
- en: However, if we want to render a polygon using gouraud shading, we need to specify
    a color to be used at each vertex. This can't be done with a material, so we need
    to override the material's color information by providing our own color stream.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们想使用高光着色渲染多边形，我们需要指定每个顶点使用的颜色。这不能通过材质来完成，因此我们需要通过提供自己的颜色流来覆盖材质的颜色信息。
- en: We do this by creating an array of `CIwColour` objects, which is Marmalade's
    chosen method of representing a color. This class has four public member variables
    of type `uint8` (an unsigned byte) called `r`, `g`, `b`, and `a`, which (probably
    not surprisingly) represent the red, green, blue, and alpha values of a color.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建一个 `CIwColour` 对象数组来完成这项工作，这是 Marmalade 选择表示颜色的方法。这个类有四个公共成员变量，类型为 `uint8`（一个无符号字节），分别称为
    `r`、`g`、`b` 和 `a`，它们（可能不会令人惊讶）代表颜色的红色、绿色、蓝色和 alpha 值。
- en: Note
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that because Marmalade was developed in the UK, all instances of the word
    *color* in the API will actually be spelled *colour*.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于 Marmalade 是在英国开发的，API 中所有单词 *color* 的实例实际上都会拼写成 *colour*。
- en: '`CIwColour` also provide several methods to make setting and manipulating colors
    easier.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`CIwColour` 还提供了一些方法，使设置和操作颜色更加容易。'
- en: 'Returning to the triangle defined in the earlier diagram, if we wanted to color
    the top of it red, the bottom-right corner green, and the bottom-left corner blue,
    we can use the following code:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到之前图中定义的三角形，如果我们想将其顶部着色为红色，右下角为绿色，左下角为蓝色，我们可以使用以下代码：
- en: '[PRE17]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that `IwGxSetColStream` does not require us to specify the number of colors
    in our stream. This is because IwGx expects to find the same number of colors
    as there are vertices. If we do not want to specify a color stream, we can just
    pass `NULL` into the `IwGxSetColStream` function and the selected material's colors
    will be used instead.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`IwGxSetColStream` 不需要我们指定流中的颜色数量。这是因为 IwGx 预期找到的颜色数量与顶点的数量相同。如果我们不想指定颜色流，我们只需将
    `NULL` 传递给 `IwGxSetColStream` 函数，将使用所选材质的颜色。
- en: UV streams
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UV 流
- en: When rendering a polygon with a texture, we need to somehow indicate how that
    texture should be mapped to the polygon. We do this by specifying a UV stream
    that allows us to state which part of the texture should appear at each vertex.
    The part of the texture required for each rendered pixel can then be worked out
    by the rendering engine by interpolating the UV values across the surface of the
    polygon.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用纹理渲染多边形时，我们需要以某种方式指示该纹理应该如何映射到多边形上。我们通过指定一个 UV 流来完成，这允许我们声明纹理的哪个部分应该出现在每个顶点上。然后，渲染引擎可以通过在多边形表面插值
    UV 值来计算出每个渲染像素所需的纹理部分。
- en: In IwGx, UV coordinates are specified using floating point numbers. An individual
    UV value is often written as (u, v) and is represented in IwGx using the `CIwFVec2`
    class, which is a floating point equivalent of `CIwSVec2` that we came across
    earlier. The x component of the vector represents **u**, and the y component represents
    **v**.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IwGx 中，使用浮点数指定 UV 坐标。单个 UV 值通常写作 (u, v)，在 IwGx 中使用 `CIwFVec2` 类表示，这是我们在之前遇到的
    `CIwSVec2` 的浮点等效类。向量的 x 分量代表 **u**，y 分量代表 **v**。
- en: UV values are mapped to a texture so that **(0.0, 0.0)** is the top left of
    the image and **(1.0, 1.0)** is the bottom-right corner. We can repeatedly tile
    a texture up to a maximum of eight times across our polygon by using values larger
    than one.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: UV 值映射到纹理上，使得 **(0.0, 0.0)** 是图像的左上角，**(1.0, 1.0)** 是右下角。我们可以通过使用大于一的值，将纹理重复平铺到多边形上，最多重复八次。
- en: '![UV streams](img/3363_02_02.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![UV流](img/3363_02_02.jpg)'
- en: Note
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Prior to Marmalade version 6.1, UV values were given as 16-bit signed integers
    using a 12-bit fixed point representation. The value 4096 is equivalent to 1.0,
    8192 is equivalent to 2.0, and 2048 is equivalent to 0.5\. The IwGeom API provides
    us with the define `IW_GEOM_ONE`, which we can use to avoid having nasty-looking
    magic numbers throughout our code. This functionality can still be used by reverting
    to the legacy version of the IwGx API, as detailed earlier in this chapter.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在Marmalade版本6.1之前，UV值以12位定点表示法使用16位有符号整数给出。值4096相当于1.0，8192相当于2.0，而2048相当于0.5。IwGeom
    API为我们提供了定义`IW_GEOM_ONE`，我们可以用它来避免在代码中到处出现难看的魔法数字。通过回滚到本章前面详细说明的IwGx API的旧版本，此功能仍然可以使用。
- en: By mapping UV values in this way, we make them independent of the actual size
    of the texture image. If we change the size of the image for any reason, it won't
    mess up rendering as our UV values do not need to change.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式映射UV值，我们使它们与纹理图像的实际大小无关。如果我们出于任何原因更改图像的大小，它不会破坏渲染，因为我们的UV值不需要更改。
- en: 'As with vertex streams, all we have to do to specify a set of UV values is
    allocate an array of `CIwSVec2`, populate the array, and submit it to IwGx. We
    don''t need to specify the number of UV values we are submitting, as IwGx expects
    to see the same number of UVs as there are vertices. Here is some sample code
    that we might want to use to apply a texture to a triangle:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 与顶点流一样，我们只需分配一个`CIwSVec2`数组，填充该数组，并将其提交给IwGx，就可以指定一组UV值。我们不需要指定我们提交的UV值数量，因为IwGx期望看到与顶点相同的UV数量。以下是一些可能想要使用的示例代码，用于将纹理应用到三角形上：
- en: '[PRE18]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The second parameter of `IwGxSetUVStream` indicates which texture the UV values
    apply to. If the material we are using only has a single texture, we can just
    leave this parameter out entirely as it will default to `0`, but if the material
    does have a second texture, we need to supply a UV stream to be used with it by
    changing the second parameter of `IwGxSetUVStream` to 1\. This UV stream could
    be the same as the stream for the first texture or it could be a completely different
    set of UV values.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`IwGxSetUVStream`的第二个参数指示UV值应用于哪个纹理。如果我们使用的材质只有一个纹理，我们可以完全省略此参数，因为它将默认为`0`，但如果材质确实有第二个纹理，我们需要通过将`IwGxSetUVStream`的第二个参数更改为1来提供用于它的UV流。此UV流可以与第一个纹理的流相同，也可以是完全不同的UV值集。'
- en: If our material does not have a texture applied to it, there is no need to set
    the UV stream to `NULL` as it will be ignored completely.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的材质没有应用纹理，没有必要将UV流设置为`NULL`，因为它将被完全忽略。
- en: Drawing a polygon
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制多边形
- en: 'We''ve now seen how to set just about all the information we need to specify
    how we want our polygon to appear, so we can finally instruct IwGx to draw it.
    To do so, we need to let IwGx know how our various input streams should be interpreted
    by using the following function call:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何设置几乎所有我们需要的信息来指定我们想要的多边形如何出现，因此我们最终可以指示IwGx绘制它。为此，我们需要让IwGx知道我们应该如何使用以下函数调用来解释各种输入流：
- en: '[PRE19]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `polygon_type` parameter indicates whether we are drawing triangles, quads,
    lines, sprites, or n-polys, while the `indices` parameter is an array of `uint16`
    values showing the order in which the elements of our input streams should be
    accessed. This is called an **index stream**. The `num_indices` parameter is just
    a count of how many elements are in the `indices` array.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`polygon_type`参数指示我们是在绘制三角形、四边形、线条、精灵还是n-多边形，而`indices`参数是一个`uint16`值的数组，显示了我们应该按什么顺序访问输入流中的元素。这被称为**索引流**。`num_indices`参数只是`indices`数组中元素数量的计数。'
- en: The following diagram shows the types of polygons supported by IwGx. Note that
    it is possible to draw more than one polygon at a time by providing longer streams
    of data. This is something we should try to do as much as possible, since it prevents
    the GPU from idling while it is waiting to be supplied with new polygon information.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了IwGx支持的多边形类型。请注意，可以通过提供更长的数据流一次绘制多个多边形。这是我们应尽可能尝试做的事情，因为它可以防止GPU在等待提供新的多边形信息时闲置。
- en: '![Drawing a polygon](img/3363_02_03.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![绘制多边形](img/3363_02_03.jpg)'
- en: The numbers labeling the vertices in the diagram correspond to the elements
    of the index stream. When rendering, the `indices` array is traversed in the order
    shown for each polygon type, and the values it contains indicate which element
    of the various input streams should be used to render each vertex.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图中标注顶点的数字对应于索引流中的元素。在渲染时，`indices`数组按照每个多边形类型显示的顺序遍历，它包含的值指示应使用输入流中的哪个元素来渲染每个顶点。
- en: 'To draw the triangle we''ve been building up to, we can use the following code
    snippet:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制我们一直在构建的三角形，我们可以使用以下代码片段：
- en: '[PRE20]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We could simplify this a little more as the index stream isn''t actually necessary
    in this instance since our input streams are accessed one element at a time in
    the order they occur in the stream, so we can just specify `NULL` for the `indices`
    parameter like this:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进一步简化这一点，因为在这个实例中索引流实际上不是必需的，因为我们的输入流是按流中出现的顺序逐个元素访问的，所以我们可以像这样指定`NULL`作为`indices`参数：
- en: '[PRE21]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When creating the index stream there is one other point to bear in mind, which
    is the order in which we supply our vertices. Because IwGx can also be used to
    render 3D polygons on screen, it supports back face culling, which prevents any
    polygon that is facing away from the viewer from being rendered.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建索引流时，还有一个需要注意的点，那就是我们提供顶点的顺序。因为IwGx也可以用于在屏幕上渲染3D多边形，它支持背面裁剪，这可以防止任何朝向观察者远离的多边形被渲染。
- en: 'How is a polygon classified as facing toward or away from the viewer? If we
    label each vertex of a polygon with an incrementing number, starting with zero
    for the first vertex and following around the edges of the polygon from vertex
    to vertex, then a polygon is facing the viewer if its vertices form an anti-clockwise
    pattern when rendered on screen and considered in ascending numerical order. The
    order the vertices are supplied in is called the **winding order**, and the following
    diagram shows this more clearly:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如何将多边形分类为朝向或远离观察者？如果我们给多边形的每个顶点标注一个递增的数字，从第一个顶点的零开始，然后沿着多边形的边缘从顶点到顶点依次标注，那么当在屏幕上渲染并按升序数字顺序考虑时，如果多边形的顶点形成一个逆时针模式，则该多边形朝向观察者。顶点提供的顺序称为**绕行顺序**，以下图表更清楚地说明了这一点：
- en: '![Drawing a polygon](img/3363_02_04.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![绘制多边形](img/3363_02_04.jpg)'
- en: 'Putting the vertices in the correct order is not the only way to solve this
    problem, but it is worth getting in the habit of ordering the vertices in this
    way for when we progress to rendering 3D polygons. We can disable or reverse the
    back face culling operation on a per material basis by calling the `CIwMaterial::SetCullMode`
    method with one of the following enumeration values: `CULL_FRONT`, `CULL_BACK`,
    or `CULL_NONE`. The default is `CULL_BACK`.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 将顶点按正确顺序排列不是解决这个问题的唯一方法，但当我们进步到渲染3D多边形时，养成按这种方式排列顶点的习惯是值得的。我们可以通过调用`CIwMaterial::SetCullMode`方法并使用以下枚举值之一来禁用或反转每个材质的背面裁剪操作：`CULL_FRONT`、`CULL_BACK`或`CULL_NONE`。默认值为`CULL_BACK`。
- en: Note
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are trying to draw a polygon and you just can't get it to appear, the
    first thing to do is double-check the winding order of your vertices. They may
    just be getting culled by the GPU and not being drawn!
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你试图绘制一个多边形，但就是无法显示出来，首先应该检查你的顶点的绕行顺序。它们可能只是被GPU裁剪而没有被绘制出来！
- en: Our polygon information has now been submitted for rendering; but we won't see
    it appear on screen just yet.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的多边形信息现在已经提交用于渲染；但我们还看不到它在屏幕上显示。
- en: Displaying the rendered image
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示渲染的图像
- en: The final step in making something appear on screen is to flush all the drawing
    requests to the screen, and then display the final image.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕上显示某物的最终步骤是将所有绘图请求刷新到屏幕上，然后显示最终图像。
- en: IwGx automatically provides us with a double-buffered display setup. All this
    means is we do all our rendering to an off-screen buffer and then switch to displaying
    this buffer when all the drawing is complete. If we did not do this, we would
    likely see an incomplete, flickering screen display as our graphics could be displayed
    in an incomplete state if we drew straight to the visible display.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: IwGx自动为我们提供了一个双缓冲显示设置。这意味着我们所有的渲染都是在离屏缓冲区完成的，然后在所有绘图完成后切换到显示这个缓冲区。如果我们不这样做，我们可能会看到一个不完整、闪烁的屏幕显示，因为我们的图形可能在不完整的状态下被显示。
- en: 'To complete the cycle of drawing, all we have to do is add the following two
    lines of code:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成绘制周期，我们只需添加以下两行代码：
- en: '[PRE22]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: That's it! We've drawn our first polygon!
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们已经绘制了我们的第一个多边形！
- en: Example code
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例代码
- en: If you download the code package for this chapter, you will find three projects
    that illustrate the use of the Marmalade functionality we have learnt about in
    this chapter.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你下载本章的代码包，你将找到三个项目，它们展示了本章学到的 Marmalade 功能的使用。
- en: The ITX project
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ITX 项目
- en: The ITX project demonstrates use of the ITX text parser and the `CIwManaged`
    class.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: ITX 项目演示了 ITX 文本解析器和 `CIwManaged` 类的使用。
- en: The example first creates custom instances of our own class by parsing an ITX
    file, then serializes those instances out to a file. All the instances are then
    destroyed and re-created by loading the serialized file back in.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 示例首先通过解析 ITX 文件创建我们自己的类的自定义实例，然后将这些实例序列化到文件中。然后，所有实例都被销毁并重新创建，通过重新加载序列化的文件。
- en: The example also demonstrates the use of two more parts of the IwUtil API, which
    we haven't covered in depth, but are very useful to know about. First is the class
    `CIwManagedList`, which is used for maintaining a list of objects derived from
    `CIwManaged`, and the second is the `IwTrace` system that allows us to log information
    to a file (and to the standard output) in order to aid debugging.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 示例还演示了 IwUtil API 的两个更多部分的用法，这些部分我们没有深入探讨，但了解它们是非常有用的。首先是 `CIwManagedList` 类，它用于维护从
    `CIwManaged` 继承的对象列表，其次是 `IwTrace` 系统，它允许我们将信息记录到文件（以及标准输出），以帮助调试。
- en: The Graphics2D project
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Graphics2D 项目
- en: 'The Graphics2D project pulls everything we''ve learnt in this chapter together
    to render a rotating, textured polygon on screen. The following screenshot depicts
    this project in action:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Graphics2D 项目将本章学到的所有内容结合起来，在屏幕上渲染一个旋转的、带纹理的多边形。以下截图展示了这个项目的实际运行情况：
- en: '![The Graphics2D project](img/3363_02_05.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![Graphics2D 项目](img/3363_02_05.jpg)'
- en: The Skiing project
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 滑雪项目
- en: Throughout this book, we will be building up an entire game example that puts
    the things we have learnt into real practice. The game in question will be a simple
    version of that old favorite, the slalom skiing game, where the player guides
    a skier down a mountain, attempting to pass through as many flags as possible
    while avoiding obstacles.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将构建一个完整的游戏示例，将我们学到的知识应用到实际实践中。这个游戏将是那个老牌的简单滑雪游戏的一个版本，玩家引导滑雪者沿着山下滑，试图通过尽可能多的旗帜，同时避开障碍物。
- en: In this chapter we kick things off by having a skier graphic at the top of the
    screen that moves from side to side, while some random trees scroll up the edges
    of the screen.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从屏幕顶部的一个滑雪图形开始，该图形从一侧移动到另一侧，同时一些随机的树木在屏幕边缘向上滚动。
- en: 'The following screenshot shows the project as it currently stands:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了项目当前的状态：
- en: '![The Skiing project](img/3363_02_06.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![滑雪项目](img/3363_02_06.jpg)'
- en: While this book is not intended to teach you the ins and outs of programming
    a game (it's assumed you already know how to do that) it might still be worthwhile
    providing a few notes on how the sample game is put together.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这本书的目的不是教你游戏的编程细节（假设你已经知道如何做），但提供一些关于如何组装示例游戏的笔记可能仍然是有价值的。
- en: The GameObject class
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GameObject 类
- en: The `GameObject` class is the base class for anything that makes up a part of
    the game world. Currently there are two classes which inherit from this class,
    `Skier` and `Tree`. No prizes for guessing what they represent!
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameObject` 类是构成游戏世界任何一部分的基础类。目前有两个类从这个类继承，`Skier` 和 `Tree`。猜猜它们代表什么！'
- en: '`GameObject` provides two virtual methods that can be overridden by child classes
    to implement the behavior of an in-game object. The `GameObject::Update` method
    provides support for changing the position of an object by applying a velocity
    to it, while the `GameObject::Render` method allows a size and a material to be
    defined, and it will draw a textured polygon at the object''s current position
    using this information.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameObject` 提供了两个虚拟方法，这些方法可以被子类覆盖以实现游戏对象的行为。`GameObject::Update` 方法通过向对象应用速度来支持改变对象的位置，而
    `GameObject::Render` 方法允许定义大小和材质，并且它将使用这些信息在对象当前位置绘制一个纹理多边形。'
- en: The ModeManager and Mode classes
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ModeManager 和 Mode 类
- en: The main flow of most games is often represented internally as some kind of
    state machine. Even the simplest game will normally have at least a title screen
    and the main game screen, but add to this things such as pause modes, high score
    tables, options screen, and the like, and you soon end up with a large number
    of states that your game could be in.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数游戏的主要流程通常在内部表示为某种状态机。即使是最简单的游戏通常也至少有一个标题屏幕和主游戏屏幕，但加上暂停模式、高分榜、选项屏幕等，你很快就会拥有大量你的游戏可能处于的状态。
- en: Often these states are completely mutually exclusive, but sometimes we might
    want several states active, or at least visible, at the same time. For example,
    quite often the pause mode will appear on top of the game screen. Only the pause
    mode will be accepting input, but both it and the game screen need to be drawn.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这些状态是完全互斥的，但有时我们可能希望同时有几个状态处于活动状态，或者至少是可见的。例如，暂停模式通常会出现在游戏屏幕上方。只有暂停模式会接受输入，但暂停模式和游戏屏幕都需要被绘制。
- en: One approach (and this is purely my own personal preference; your own may vary
    wildly) is to create a separate class which handles a single part of the game.
    For want of a better word, I represent these using a base class called `Mode`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法（这纯粹是我个人的偏好；你的可能大相径庭）是创建一个单独的类来处理游戏的一个部分。为了更好地描述，我使用一个名为 `Mode` 的基类来表示这些类。
- en: The `Mode` class is similar to the `GameObject` class in that it provides two
    virtual methods called `Update` and `Render`. A mode can be made active, which
    means its `Update` method will be executed in each frame, and it can be visible,
    which means its `Render` method will be called. These two states are completely
    independent of each other.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mode` 类与 `GameObject` 类相似，因为它提供了两个虚拟方法，称为 `Update` 和 `Render`。一个模式可以被激活，这意味着它的
    `Update` 方法将在每一帧执行，并且它可以被可见，这意味着它的 `Render` 方法将被调用。这两个状态完全独立于彼此。'
- en: When a `Mode` instance is created, it is automatically added to a list maintained
    by a singleton class called `ModeManager`. The `ModeManager` class uses the list
    of `Mode` instances to update all active modes and render all visible modes on
    each iteration of the main game loop.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个 `Mode` 实例时，它将自动添加到一个由名为 `ModeManager` 的单例类维护的列表中。`ModeManager` 类使用 `Mode`
    实例的列表来更新所有活动模式，并在主游戏循环的每次迭代中渲染所有可见模式。
- en: Currently the project only consists of a single mode called `ModeGame`, which
    is responsible for loading and freeing the required resources and also initializing,
    updating, and rendering all the `GameObject`s that make up the game world.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，项目只包含一个名为 `ModeGame` 的单个模式，它负责加载和释放所需资源，并初始化、更新和渲染构成游戏世界的所有 `GameObject`。
- en: Summary
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we've learnt about Marmalade's powerful resource management
    system. We know how to use it at a simple level to just load and release resources
    such as bitmapped images or our own custom classes; we also have a good idea of
    how the resource management system is put together, and how we can extend it with
    our own functionality.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 Marmalade 强大的资源管理系统。我们知道如何在其简单层面上使用它来加载和释放资源，例如位图图像或我们自己的自定义类；我们还对资源管理系统是如何构建的，以及我们如何通过自己的功能来扩展它有一个很好的了解。
- en: We've also covered the options available for rendering on-screen images, and
    seen how to use one of these, IwGx, to render polygons on the screen.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了屏幕上渲染图像的选项，并看到了如何使用其中之一，IwGx，来在屏幕上渲染多边形。
- en: In the next chapter we'll be learning how we can start using the various input
    options available on modern mobile devices, since the whole point of games is
    that they are interactive.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何开始使用现代移动设备上可用的各种输入选项，因为游戏的核心就是它们的交互性。
