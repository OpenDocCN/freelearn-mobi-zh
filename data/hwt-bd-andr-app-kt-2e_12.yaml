- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Persisting Data
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久化数据
- en: This chapter goes in depth about data persistence in Android. By the end of
    the chapter, you will know multiple ways to store (persist) data directly on a
    device and the frameworks accessible to do this. When dealing with a filesystem,
    you will know how it’s partitioned and how you can read and write files in different
    locations and use different frameworks.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了Android中的数据持久化。到本章结束时，你将了解多种在设备上直接存储（持久化）数据的方法以及可用于此目的的框架。在处理文件系统时，你将了解其分区方式以及如何在不同的位置读取和写入文件，以及如何使用不同的框架。
- en: In the previous chapter, you learned how to structure your code and save data.
    In the activity, you also had the opportunity to build a repository and use it
    to access and save data through Room. In this chapter, you will learn about alternative
    ways to persist data on a device through the Android filesystem and how it’s structured
    into external and internal memory.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了如何构建代码和保存数据。在活动中，你还有机会构建一个仓库并使用它通过Room访问和保存数据。在本章中，你将了解通过Android文件系统在设备上持久化数据的替代方法以及它的结构如何分为外部和内部内存。
- en: You’ll also develop your understanding of read and write permissions, learn
    how to create the `FileProvider` class to offer other apps access to your files,
    and learn how you can save those files without requesting permissions on external
    drives. You’ll also see how to download files from the internet and save them
    on a filesystem.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将加深对读写权限的理解，学习如何创建`FileProvider`类以允许其他应用访问你的文件，以及如何在不需要请求外部驱动器权限的情况下保存这些文件。你还将了解如何从互联网下载文件并将它们保存到文件系统中。
- en: Another concept that will be explored in this chapter is using the **Camera**
    application to take photos and videos on your application’s behalf and save them
    to external storage using FileProviders.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还将探讨另一个概念，即使用**相机**应用代表你的应用拍照和录制视频，并使用文件提供者将它们保存到外部存储。
- en: 'We will cover the following topics in the chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Preferences and DataStore
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预设和DataStore
- en: Files
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件
- en: Scoped storage
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作用域存储
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The complete code for all the exercises and the activity in this chapter is
    available on GitHub at [https://packt.link/XlTwZ](https://packt.link/XlTwZ)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有练习和活动的完整代码可在GitHub上找到：[https://packt.link/XlTwZ](https://packt.link/XlTwZ)
- en: Preferences and DataStore
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预设和DataStore
- en: Imagine you are tasked with integrating a third-party API that uses something
    such as OAuth to implement logging in with Facebook, Google, and suchlike. The
    way these mechanisms work is as follows – they give you a token that you have
    to store locally and that can then be used to send other requests to access user
    data.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你被分配了一个任务，需要集成一个使用OAuth之类的机制来实现Facebook、Google等登录的第三方API。这些机制的工作方式如下——它们会给你一个令牌，你必须将其存储在本地，然后可以使用该令牌发送其他请求以访问用户数据。
- en: This raises several questions. How can you store that token? Do you use Room
    just for one token? Do you save the token in a separate file and implement methods
    for writing the file? What if that file has to be accessed in multiple places
    at the same time? `SharedPreferences` and `DataStore` are answers to these questions.
    `SharedPreferences` is a functionality that allows you to save Booleans, integers,
    floats, longs, strings, and sets of strings into an XML file.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这引发了一些问题。你该如何存储那个令牌？你是否只为一个令牌使用Room？你是否将令牌保存在单独的文件中并实现写入文件的方法？如果那个文件需要同时从多个地方访问怎么办？`SharedPreferences`和`DataStore`是这些问题的答案。`SharedPreferences`是一种允许你将布尔值、整数、浮点数、长整型、字符串和字符串集合保存到XML文件的功能。
- en: When you want to save new values, you specify what values you want to save for
    the associated keys, and when you are done, you commit the change, which will
    trigger the save to the XML file in an asynchronous way. The `SharedPreferences`
    mappings are also kept in memory so that when you want to read these values, it’s
    instantaneous, thereby removing the need for an asynchronous call to read the
    XML file.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想保存新值时，你指定要为相关键保存哪些值，完成后，你提交更改，这将异步触发将更改保存到XML文件。`SharedPreferences`映射也保存在内存中，这样当你想要读取这些值时，它将瞬间完成，从而消除了读取XML文件的异步调用需求。
- en: We now have two ways to store data in key-value pairs in the form of `SharedPreferences`
    and `DataStore`. We will now look at how each of them works and the benefits each
    one provides.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有两种方式以键值对的形式存储数据，即`SharedPreferences`和`DataStore`。现在我们将探讨每个的工作原理以及它们各自提供的优势。
- en: SharedPreferences
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SharedPreferences
- en: 'The way to access the `SharedPreference` object is through the `Context` object:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 `SharedPreference` 对象的方式是通过 `Context` 对象：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first parameter is where you specify the name of your preferences, and the
    second is how you want to expose a file to other apps. Currently, the best mode
    is the private one. All of the others present potential security risks.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是您指定首选项名称的地方，第二个参数是您希望如何将文件暴露给其他应用程序。目前，最佳模式是私有模式。其他所有模式都存在潜在的安全风险。
- en: If you want to write data into your preferences file, you first need to get
    access to the Preferences editor. The editor will give you access to write the
    data. You can then write your data in it. Once you finish writing, you will have
    to apply the changes that will trigger persistence to the XML file and change
    the in-memory values as well.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想将数据写入首选项文件，您首先需要获取对首选项编辑器的访问权限。编辑器将为您提供写入数据的权限。然后您可以在其中写入数据。一旦完成写入，您将必须应用更改，这将触发对
    XML 文件的持久化并更改内存中的值。
- en: 'You have two choices to apply the changes on your preference file – `apply`
    or `commit`. Choosing `apply` will save your changes in memory instantly, but
    then writing to disk will be asynchronous, which is useful if you want to save
    data from from your app’s main thread. `commit` does everything synchronously
    and gives you a Boolean result, informing you whether the operation was successful
    or not. In practice, `apply` tends to be favored over `commit`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您有两个选择来应用对首选项文件的变化 – `apply` 或 `commit`。选择 `apply` 将立即在内存中保存您的更改，但写入磁盘将是异步的，这在您想从应用程序的主线程保存数据时很有用。`commit`
    会同步执行所有操作，并返回一个布尔结果，告诉您操作是否成功。在实践中，`apply` 通常比 `commit` 更受欢迎：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, you want to clear your entire data. The same principle will apply; you’ll
    need `editor`, `clear`, and `apply`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您想要清除所有数据。相同的原理适用；您将需要 `editor`、`clear` 和 `apply`：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you want to read the values you previously saved, you can use the `SharedPreferences`
    object to read the stored values. If there is no saved value, you can opt for
    a default value to be returned instead:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想读取之前保存的值，您可以使用 `SharedPreferences` 对象来读取存储的值。如果没有保存的值，您可以选择返回默认值：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We should now have an idea about how we can persist data with `SharedPreferences`,
    and we can apply this in an exercise in the following section.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该对如何使用 `SharedPreferences` 持久化数据有一个了解，我们可以在下一节的练习中应用这一点。
- en: Exercise 12.01 – wrapping SharedPreferences
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 12.01 – 包装 SharedPreferences
- en: We’re going to build an application that displays `TextView`, `EditText`, and
    a button. `TextView` will display the previously saved value in `SharedPreferences`.
    The user can type new text, and when the button is clicked, the text will be saved
    in `SharedPreferences` and `TextView` will display the updated text. We will need
    to use `ViewModel` and `LiveData` to make the code more testable.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个应用程序，该程序显示 `TextView`、`EditText` 和一个按钮。`TextView` 将显示在 `SharedPreferences`
    中之前保存的值。用户可以输入新的文本，当按钮被点击时，文本将被保存到 `SharedPreferences` 中，并且 `TextView` 将显示更新后的文本。我们需要使用
    `ViewModel` 和 `LiveData` 来使代码更易于测试。
- en: 'In order to complete this exercise, we will need to create a `Wrapper` class,
    which will be responsible for saving the text. This class will return the value
    of the text as `LiveData`. This will be injected into our `ViewModel`, which will
    be bound to the activity:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个练习，我们需要创建一个 `Wrapper` 类，该类将负责保存文本。这个类将返回文本的值作为 `LiveData`。这将注入到我们的 `ViewModel`
    中，该 `ViewModel` 将绑定到活动：
- en: Create a new Android Studio project with an empty activity.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Android Studio 创建一个新的空活动项目。
- en: 'Let’s begin by adding the appropriate libraries to `app/build.gradle`:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从向 `app/build.gradle` 添加适当的库开始：
- en: '[PRE4]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let’s make our `Wrapper` class in the `main/java` folder in the `root` package,
    which will listen for changes in `SharedPreferences` and update the value of `LiveData`
    when the preferences change. The class will contain methods to save the new text
    and retrieve `LiveData`:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 `main/java` 文件夹中的 `root` 包下创建一个 `Wrapper` 类，该类将监听 `SharedPreferences` 的变化，并在首选项发生变化时更新
    `LiveData` 的值。该类将包含保存新文本和检索 `LiveData` 的方法：
- en: '[PRE5]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The complete code for this step can be found at [https://packt.link/a2RuN](https://packt.link/a2RuN).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤的完整代码可以在 [https://packt.link/a2RuN](https://packt.link/a2RuN) 找到。
- en: Note the top of the file. We’ve added a listener so that when our `SharedPreferences`
    values change, we can look up the new value and update our `LiveData` model. This
    will allow us to observe `LiveData` for any changes and just update the UI.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意文件的顶部。我们添加了一个监听器，以便当我们的 `SharedPreferences` 值发生变化时，我们可以查找新值并更新我们的 `LiveData`
    模型。这将允许我们观察 `LiveData` 的任何更改并仅更新 UI。
- en: The `saveText` method will open the editor, set the new value, and apply the
    changes. The `getText` method will read the last saved value, set it in `LiveData`,
    and return the `LiveData` object. This is helpful in scenarios where the app is
    opened and we want to access the last value prior to the app closing.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`saveText` 方法将打开编辑器，设置新值，并应用更改。`getText` 方法将读取最后保存的值，将其设置在 `LiveData` 中，并返回
    `LiveData` 对象。这在应用打开并希望在应用关闭之前访问最后值的情况下非常有用。'
- en: 'Now, let’s set up the `Application` class with the instance of the preferences
    in the `main/java` folder in the root package:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在根包的 `main/java` 文件夹中设置 `Application` 类的偏好实例：
- en: '[PRE6]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, let’s add the appropriate attributes in the `application` tag to `Android``Manifest.xml`:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在 `AndroidManifest.xml` 的 `application` 标签中添加适当的属性：
- en: '[PRE7]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, let’s build the `ViewModel` component in the `main/java` folder in the
    root package:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们在根包的 `main/java` 文件夹中构建 `ViewModel` 组件：
- en: '[PRE8]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let’s define our `activity_main.xml` layout file in the `res/layout` folder:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在 `res/layout` 文件夹中定义我们的 `activity_main.xml` 布局文件：
- en: '[PRE9]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The complete code for this step can be found at [https://packt.link/2c5Ay](https://packt.link/2c5Ay).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤的完整代码可以在 [https://packt.link/2c5Ay](https://packt.link/2c5Ay) 找到。
- en: 'Finally, in `MainActivity`, perform the following steps:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 `MainActivity` 中执行以下步骤：
- en: '[PRE10]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The complete code for this step can be found at [https://packt.link/ZRWNc](https://packt.link/ZRWNc).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤的完整代码可以在 [https://packt.link/ZRWNc](https://packt.link/ZRWNc) 找到。
- en: 'The preceding code will produce the output presented in *Figure 12**.1*:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将产生 *图 12.1* 中所示的输出：
- en: '![Figure 12.1 – Output of Exercise 12.01](img/B19411_12_01.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.1 – 练习 12.01 的输出](img/B19411_12_01.jpg)'
- en: Figure 12.1 – Output of Exercise 12.01
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1 – 练习 12.01 的输出
- en: Once you insert a value, try closing the application and reopening it. The app
    will display the last persisted value.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你插入了一个值，尝试关闭应用程序并重新打开它。应用程序将显示最后持久化的值。
- en: DataStore
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据存储
- en: The `DataStore` persistence library represents an alternative to `SharedPreferences`
    when we want to store data in key-value pairs through the Preference `DataStore`,
    or if we want to store entire objects through the Proto `DataStore`. Both libraries
    avoid dependencies with the Android framework (unlike `SharedPreferences`, which
    requires a `Context` object to be initialized) and are built using coroutines
    and flows, making them the ideal candidate when coroutines and flows are used
    in your project.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要通过偏好 `DataStore` 以键值对的形式存储数据，或者想要通过 Proto `DataStore` 存储整个对象时，`DataStore`
    持久化库是 `SharedPreferences` 的一个替代方案。这两个库都避免了与 Android 框架的依赖（与需要初始化 `Context` 对象的
    `SharedPreferences` 不同），并且使用协程和流构建，因此在你的项目中使用协程和流时，它们是理想的候选者。
- en: 'This integration allows the `DataStore` to notify subscribers of all changes,
    which means that developers no longer have to concern themselves with handling
    the changes:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这种集成允许 `DataStore` 通知订阅者所有更改，这意味着开发者不再需要担心处理这些更改：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding snippet, we initialize `Context.dataStore` in the top-level
    Kotlin file. We then define three separate keys for separate types we want to
    read from. Inside `MyAppSettings`, we map the values from `context.dataStore.data`
    and extract the values from our keys.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们在顶层 Kotlin 文件中初始化 `Context.dataStore`。然后我们定义了三个不同的键，分别对应我们想要读取的不同类型。在
    `MyAppSettings` 中，我们将 `context.dataStore.data` 中的值映射到我们的键，并从中提取值。
- en: 'If we want to store data in our `DataStore`, then we need to do the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在 `DataStore` 中存储数据，则需要执行以下操作：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `suspend` keyword comes from coroutines, and it signals that we need to
    place the method invocation into an asynchronous call. `context.dataStore.edit`
    will make the preferences in the `DataStore` mutable and allow us to change the
    values.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`suspend` 关键字来自协程，它表示我们需要将方法调用放入异步调用中。`context.dataStore.edit` 将 `DataStore`
    中的偏好设置为可变的，并允许我们更改值。'
- en: Exercise 12.02 – Preference DataStore
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 12.02 – 预设数据存储
- en: We’re going to build an application that displays `TextView`, `EditText`, and
    a button. `TextView` will display the value that was added to `DataStore`. The
    user can type new text, and when the button is clicked, the text will be saved
    in `DataStore` and `TextView` will display the updated text.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个显示 `TextView`、`EditText` 和按钮的应用程序。`TextView` 将显示添加到 `DataStore` 的值。用户可以输入新的文本，当按钮被点击时，文本将被保存到
    `DataStore`，并且 `TextView` 将显示更新的文本。
- en: 'We will need to use `ViewModel` and `LiveData`. In the `ViewModel`, we will
    collect the data coming from `DataStore` and place it in a `LiveData` object:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要使用 `ViewModel` 和 `LiveData`。在 `ViewModel` 中，我们将收集来自 `DataStore` 的数据并将其放置在一个
    `LiveData` 对象中：
- en: Create a new Android Studio project with an empty activity.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有空活动的新的 Android Studio 项目。
- en: 'Let’s begin by adding the appropriate libraries to `app/build.gradle`:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从向 `app/build.gradle` 添加适当的库开始：
- en: '[PRE13]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create a class called `SettingsStore` in the `main/java` folder in the root
    package, which will contain methods to load and save data from `DataStore`:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根包的 `main/java` 文件夹中创建一个名为 `SettingsStore` 的新类，该类将包含从 `DataStore` 加载和保存数据的方法：
- en: '[PRE14]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding snippet, we have defined a key for storing the text, a field
    to retrieve the saved text, and a method to save it.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们定义了一个用于存储文本的键、用于检索已保存文本的字段以及用于保存它的方法。
- en: 'Create a new class called `SettingsViewModel` in the `main/java` folder in
    the root package, which will collect the data from `SettingsStore` in `LiveData`
    and invoke it to save the new text values:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根包的 `main/java` 文件夹中创建一个名为 `SettingsViewModel` 的新类，该类将从 `SettingsStore` 收集数据并将其保存到
    `LiveData` 对象中：
- en: '[PRE15]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding example, `viewModelScope` is an extension of `ViewModel` and
    represents `CoroutineScope`, which ensures that the background work is done while
    `ViewModel` is still active to avoid any possible leaks. Using this, we can collect
    the existing text into `LiveData` when `ViewModel` is initialized and then invoke
    the `saveText` method from `SettingsStore`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`viewModelScope` 是 `ViewModel` 的扩展，代表 `CoroutineScope`，这确保了在 `ViewModel`
    仍然活跃时完成后台工作，以避免任何可能的泄漏。使用这个，我们可以在 `ViewModel` 初始化时收集现有的文本到 `LiveData`，然后从 `SettingsStore`
    调用 `saveText` 方法。
- en: 'Now, let’s set up the `Application` class with the `SettingsStore` instance
    in the `main/java` folder in the root package:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在根包的 `main/java` 文件夹中设置 `Application` 类，并包含 `SettingsStore` 实例：
- en: '[PRE16]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, let’s add the appropriate attributes in the `application` tag to `Android``Manifest.xml`:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们在 `AndroidManifest.xml` 的 `application` 标签中添加适当的属性：
- en: '[PRE17]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, let’s define our `activity_main.xml` layout file in the `res/layout`
    folder:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们在 `res/layout` 文件夹中定义我们的 `activity_main.xml` 布局文件：
- en: '[PRE18]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The complete code for this step can be found at [https://packt.link/8f854](https://packt.link/8f854).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤的完整代码可以在 [https://packt.link/8f854](https://packt.link/8f854) 找到。
- en: 'And finally, in `MainActivity`, perform the following steps:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 `MainActivity` 中执行以下步骤：
- en: '[PRE19]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The complete code for this step can be found at [https://packt.link/gydeC](https://packt.link/gydeC).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤的完整代码可以在 [https://packt.link/gydeC](https://packt.link/gydeC) 找到。
- en: 'If we now run the application, we should see the following screen:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行应用程序，我们应该看到以下屏幕：
- en: '![Figure 12.2 – Output of Exercise 12.02](img/B19411_12_02.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.2 – 练习 12.02 的输出](img/B19411_12_02.jpg)'
- en: Figure 12.2 – Output of Exercise 12.02
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2 – 练习 12.02 的输出
- en: If we enter a new text and click the `DataStore` will emit a new value for each
    change. We will look at flows and other reactive streams in future chapters.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们输入新的文本并点击 `DataStore`，它将为每次更改发出新的值。我们将在未来的章节中查看流和其他响应式流。
- en: In this exercise, we have looked at how the `DataStore` library works and its
    benefits, especially regarding streams of data. In the following chapters, we
    will continue to look at other ways of persisting data, using files.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们探讨了 `DataStore` 库的工作原理及其优势，特别是在数据流方面。在接下来的章节中，我们将继续探讨使用文件持久化数据的其他方法。
- en: Files
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件
- en: We’ve discussed Room, `SharedPreferences`, and `DataStore` and specified how
    the data they store is written to files. You may ask yourself, where are these
    files stored? These particular files are stored in internal storage. Internal
    storage is a dedicated space for every app that other apps are unable to access
    (unless a device is rooted). There is no limit to the amount of storage your app
    can use.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了 Room、`SharedPreferences` 和 `DataStore`，并指定了它们存储的数据是如何写入文件的。你可能想知道，这些文件存储在哪里？这些特定的文件存储在内部存储中。内部存储是每个应用程序的专用空间，其他应用程序无法访问（除非设备已越狱）。你的应用程序可以使用存储空间没有限制。
- en: However, users have the ability to delete their app’s files from the **Settings**
    menu. Internal storage occupies a smaller part of the total available space, which
    means that you should be careful when it comes to storing files there. There is
    also external storage. The files your app stores in external storage are accessible
    to other apps and the files from other apps are accessible to your one.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，用户可以从**设置**菜单中删除他们应用的文件。内部存储只占用总可用空间的一小部分，这意味着在存储文件时应小心。还有外部存储。您的应用存储在外部存储中的文件对其他应用是可访问的，其他应用中的文件对您的应用也是可访问的。
- en: Note
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In Android Studio, you can use the `/data/data/{packageName}`. If you have access
    to this folder, this means that the device is rooted. Using this, you can visualize
    the database files and the `SharedPreferences` files.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中，您可以使用`/data/data/{packageName}`。如果您可以访问此文件夹，这意味着设备已root。使用此方法，您可以可视化数据库文件和`SharedPreferences`文件。
- en: 'An example of how the **Device File Explorer** looks can be viewed in the following
    figure:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**设备文件浏览器**的外观示例可以在以下图中查看：'
- en: "![Figure 12.3 – Android’s Device File Explorer \uFEFFfor an\uFEFF emulated\
    \ device](img/Image100608.jpg)"
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图12.3 – Android的模拟设备文件浏览器](img/Image100608.jpg)'
- en: Figure 12.3 – Android’s Device File Explorer for an emulated device
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 – Android的模拟设备文件浏览器
- en: Internal storage
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内部存储
- en: 'Internal storage requires no permissions from the user. To access the internal
    storage directories, you can use one of the following methods from the `Context`
    object:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 内部存储不需要用户的权限。要访问内部存储目录，您可以使用`Context`对象中的以下方法之一：
- en: '`getDataDir()`: Returns the root folder of your application sandbox.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getDataDir()`: 返回您应用沙盒的根文件夹。'
- en: '`getFilesDir()`: A dedicated folder for application files – recommended for
    usage.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getFilesDir()`: 专门用于应用文件的文件夹——推荐使用。'
- en: '`getCacheDir()`: A dedicated folder where files can be cached. Storing files
    here does not guarantee that you can retrieve them later because the system may
    decide to delete this directory to free up memory. This folder is linked to the
    **Clear Cache** option in **Settings**.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getCacheDir()`: 一个专门用于缓存文件的文件夹。在此处存储文件并不保证您以后可以检索它们，因为系统可能会决定删除此目录以释放内存。此文件夹与**设置**中的**清除缓存**选项相关联。'
- en: '`getDir(name, mode)`: Returns a folder that will be created if it does not
    exist, based on the name specified.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getDir(name, mode)`: 如果不存在，则根据指定的名称创建一个文件夹。'
- en: When users use the **Clear Data** option from **Settings**, most of these folders
    will be deleted, bringing the app to a similar state as a fresh installation.
    When the app is uninstalled, these files will be deleted as well.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户从**设置**中使用**清除数据**选项时，大多数这些文件夹将被删除，使应用的状态与全新安装相似。当应用被卸载时，这些文件也将被删除。
- en: 'A typical example of reading a cache file is as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 读取缓存文件的典型示例如下：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding example will read from `my-file.txt`, located in the `Cache` directory,
    and will create `FileInputStream` for that file. Then, a buffer will be used that
    will collect the bytes from the file. The collected bytes will be placed in the
    `bytes` byte array, which will contain all of the data read from that file. Reading
    will stop when the entire length of the file has been read.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例将从位于`Cache`目录中的`my-file.txt`文件中读取，并为该文件创建`FileInputStream`。然后，将使用一个缓冲区来收集文件中的字节。收集到的字节将被放置在`bytes`字节数组中，该数组将包含从该文件中读取的所有数据。读取将在读取整个文件长度后停止。
- en: 'Writing to the `my-file.txt` file will look something like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 向`my-file.txt`文件写入的内容将类似于以下示例：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: What the preceding example does is take the byte array you want to write, create
    a new `File` object, create the file if it doesn’t exist, and write the bytes
    into the file through `FileOutputStream`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 之前示例所做的是获取您想要写入的字节数组，创建一个新的`File`对象，如果不存在则创建文件，并通过`FileOutputStream`将字节写入文件。
- en: Note
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There are many alternatives to dealing with files. The readers (`StreamReader`,
    `StreamWriter`, and so on) are better equipped for character-based data. There
    are also third-party libraries that help with disk I/O operations. One of the
    most common third parties that help with I/O operations is called `OkHttp` library,
    which is used in combination with Retrofit to make API calls. The methods provided
    by Okio are the same methods it uses to write and read data in HTTP communications.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 处理文件有许多替代方案。读者（`StreamReader`、`StreamWriter`等）更适合处理基于字符的数据。还有第三方库可以帮助处理磁盘I/O操作。其中最常用的第三方库之一是名为`OkHttp`的库，它与Retrofit结合使用以进行API调用。Okio提供的方法与它在HTTP通信中读写数据所使用的方法相同。
- en: External storage
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外部存储
- en: Reading and writing in external storage requires user permission for reading
    and writing. If write permission is granted, then your app has the ability to
    read the external storage. Once these permissions are granted, then your app can
    do whatever it pleases on the external storage.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在外部存储中读取和写入需要用户权限。如果授予写入权限，则您的应用程序具有读取外部存储的能力。一旦这些权限被授予，则您的应用程序可以在外部存储上做任何它想做的事情。
- en: That may present a problem because users may not choose to grant these permissions.
    However, there are specialized methods that offer you the possibility to write
    to the external storage in folders dedicated to your application.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能带来问题，因为用户可能不会选择授予这些权限。然而，有一些专门的方法提供了将数据写入您的应用程序专用文件夹的可能性。
- en: 'Some of the most common ways of accessing external storage are from the `Context`
    and `Environment` objects:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 访问外部存储的最常见方式之一是从`Context`和`Environment`对象：
- en: '`Context.getExternalFilesDir(mode)`: This method will return the path to the
    directory on the external storage dedicated to your application. Specifying different
    modes (pictures, movies, and so on) will create different subfolders, depending
    on how you want your files saved. This method *does not* *require permissions*.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Context.getExternalFilesDir(mode)`：此方法将返回外部存储上为您的应用程序专用的目录路径。指定不同的模式（图片、电影等）将创建不同的子文件夹，具体取决于您希望如何保存文件。此方法*不*需要权限。'
- en: '`Context.getExternalCacheDir()`: This will point toward an application’s cache
    directory on the external storage. The same considerations should be applied to
    this `cache` folder as to the internal storage option. This method *does not*
    *require permissions*.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Context.getExternalCacheDir()`：这将指向外部存储上的应用程序缓存目录。对此`缓存`文件夹应适用与内部存储选项相同的考虑。此方法*不*需要权限。'
- en: The `Environment` class has access to paths of some of the most common folders
    on a device. However, on newer devices, apps may not have access to those files
    and folders.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Environment`类可以访问设备上一些最常见文件夹的路径。然而，在新设备上，应用程序可能无法访问这些文件和文件夹。'
- en: Note
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Avoid using hardcoded paths to files and folders. The Android operating system
    may shift the location of folders around, depending on the device or Android version.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用硬编码的文件和文件夹路径。Android操作系统可能会根据设备或Android版本将文件夹的位置移动。
- en: FileProvider
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件提供者
- en: This represents a specialized implementation of `ContentProviders` that is useful
    in organizing the file and folder structure of your application. It allows you
    to specify an XML file, in which you define how your files should be split between
    internal and external storage if you choose to do so. It also gives you the ability
    to grant access to other apps to your files by hiding the path and generating
    a unique URI to identify and query your file.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这代表了一种专门实现的内容提供者，它有助于组织应用程序的文件和文件夹结构。如果您选择这样做，它允许您指定一个XML文件，在其中定义您的文件应该如何在内部和外部存储之间分割。它还允许您通过隐藏路径并生成一个唯一的URI来识别和查询您的文件，从而授予其他应用程序访问您文件的权限。
- en: '`FileProvider` lets you pick between six different folders, where you can set
    up your folder hierarchies:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileProvider`允许您在六个不同的文件夹中进行选择，您可以在其中设置您的文件夹层次结构：'
- en: '`Context.getFilesDir()` (files-path)'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Context.getFilesDir()`（文件路径）'
- en: '`Context.getCacheDir()` (cache-path)'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Context.getCacheDir()` (缓存路径)'
- en: '`Environment.getExternalStorageDirectory()` (external-path)'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Environment.getExternalStorageDirectory()`（外部路径）'
- en: '`Context.getExternalFilesDir(null)` (external-files-path)'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Context.getExternalFilesDir(null)`（外部文件路径）'
- en: '`Context.getExternalCacheDir()` (external-cache-path)'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Context.getExternalCacheDir()`（外部缓存路径）'
- en: The first result of `Context.getExternalMediaDirs()` (external-media-path)
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Context.getExternalMediaDirs()` 的第一个结果（外部媒体路径）'
- en: The main benefits of `FileProvider` are the abstractions it provides in organizing
    your files while leaving a developer to define the paths in an XML file, and more
    importantly, if you choose to use it to store files in external storage, you do
    not have to ask for permissions from the user.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileProvider`的主要优点是它在组织文件时提供的抽象，同时让开发者可以在XML文件中定义路径，更重要的是，如果您选择使用它来存储外部存储中的文件，您无需请求用户权限。'
- en: Another benefit is the fact that it makes sharing of internal files easier while
    giving a developer control of what files other apps can access without exposing
    their real location.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个好处是它使得内部文件的共享更加容易，同时让开发者控制其他应用可以访问哪些文件，而不必暴露它们的真实位置。
- en: 'Let us understand better through the following example:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下示例更好地理解：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The preceding example will make `FileProvider` use the internal `files` directory
    and create a folder named `my-folder-name`. When the path is converted to a URI,
    then the URI will use `my-visible-name`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例将使`FileProvider`使用内部`files`目录并创建一个名为`my-folder-name`的文件夹。当路径转换为URI时，该URI将使用`my-visible-name`。
- en: The Storage Access Framework (SAF)
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储访问框架（SAF）
- en: 'The SAF is a file picker introduced in Android KitKat that apps can use for
    their users to pick files, with a view to them being processed or uploaded. You
    can use it in your app in the following scenarios:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: SAF是Android KitKat中引入的文件选择器，应用程序可以使用它让用户选择文件，目的是处理或上传文件。您可以在以下场景中使用它：
- en: Your app requires a user to process a file saved on a device by another app
    (photos and videos)
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的应用需要用户处理另一个应用（如照片和视频）保存在设备上的文件
- en: You want to save a file on a device and give a user the choice of where to save
    the file and the name of the file
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您希望在一个设备上保存文件，并让用户选择文件的保存位置和文件名
- en: You want to offer the files your application uses to other apps for scenarios
    similar to the first scenario in this list
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您希望将应用程序使用的文件提供给其他应用，用于与列表中第一个场景类似的情况
- en: This is again useful because your app will avoid read and write permissions
    and still write and access external storage. The way this works is based on intents.
    You can register for an activity result for `GetDocument` or `CreateDocument`.
    Then, in the activity result callback, the system will give you a URI that grants
    you temporary permissions to that file, allowing you to read and write.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这同样很有用，因为您的应用程序将避免读写权限，但仍可以写入和访问外部存储。这种方式是基于意图的。您可以注册`GetDocument`或`CreateDocument`的活动结果。然后，在活动结果回调中，系统将为您提供临时权限的URI，允许您读取和写入该文件。
- en: Another benefit of the SAF is the fact that files don’t have to be on a device.
    Apps such as Google Drive expose their content in the SAF, and when a Google Drive
    file is selected, it will be downloaded to the device and the URI will be sent
    as a result.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: SAF的另一个好处是文件不必在设备上。例如，Google Drive这样的应用通过SAF公开其内容，当选择Google Drive文件时，它将被下载到设备上，并将URI作为结果发送。
- en: Another important thing to mention is the SAF’s support for virtual files, meaning
    that it will expose Google docs, which have their own format, but when those docs
    are downloaded through the SAF, their formats will be converted to a common format
    such as PDF.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要提到的重要事情是SAF对虚拟文件的支持，这意味着它将公开具有自己格式的Google文档，但当这些文档通过SAF下载时，它们的格式将被转换为PDF等通用格式。
- en: Asset files
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资产文件
- en: '`assets` folder inside your project. You can then group your files inside your
    assets using folders.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您项目中的`assets`文件夹。然后您可以使用文件夹在您的资产中分组文件。
- en: 'You can access these files at runtime through the `AssetManager` class, which
    itself can be accessed through the context object. `AssetManager` offers you the
    ability to look up the files and read them, but it does not permit any write operations:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过`AssetManager`类在运行时访问这些文件，该类本身可以通过上下文对象访问。`AssetManager`为您提供查找文件和读取文件的能力，但不允许任何写操作：
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding example lists all files inside the root of the `assets` folder.
    The `open` function returns `inputStream`, which can be used to read the file
    information if necessary.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例列出了`assets`文件夹根目录下的所有文件。`open`函数返回`inputStream`，如果需要，可以使用它来读取文件信息。
- en: One common usage of the `assets` folder is for custom fonts. If your application
    uses custom fonts, then you can use the `assets` folder to store font files.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`assets`文件夹的一个常见用途是自定义字体。如果您的应用程序使用自定义字体，则可以使用`assets`文件夹来存储字体文件。'
- en: Note
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For the following exercise, you will need an emulator. You can do so by selecting
    **Tools** | **AVD Manager** in Android Studio. Then, you can create one with the
    **Create Virtual Device** option, selecting the type of emulator, clicking **Next**,
    and then selecting an x86 image. Any image larger than Lollipop should be acceptable
    for this exercise. Next, you can give your image a name and click **Finish**.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下练习，您需要一个模拟器。您可以在 Android Studio 中通过选择 **工具** | **AVD 管理器** 来这样做。然后，您可以通过选择
    **创建虚拟设备** 选项，选择模拟器类型，点击 **下一步**，然后选择一个 x86 图像来创建一个。任何大于 Lollipop 的图像都适用于此练习。接下来，您可以给您的图像命名并点击
    **完成**。
- en: Exercise 12.03 – copying files
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 12.03 – 复制文件
- en: Let’s create an app that will keep a file named `my-app-file.txt` in the `assets`
    directory. The app will display two buttons called `FileProvider` and `SAF`. When
    the `FileProvider` button is clicked, the file will be saved on the external storage
    inside the app’s external storage dedicated area (`Context.getExternalFilesDir(null)`).
    The `SAF` button will open the SAF and allow a user to indicate where the file
    should be saved.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个应用程序，该应用程序将在 `assets` 目录中保留一个名为 `my-app-file.txt` 的文件。该应用程序将显示两个按钮，分别称为
    `FileProvider` 和 `SAF`。当点击 `FileProvider` 按钮时，文件将被保存在应用程序外部存储的专用区域（`Context.getExternalFilesDir(null)`）中。`SAF`
    按钮将打开 SAF，并允许用户指定文件应保存的位置。
- en: 'In order to implement this exercise, follow these steps:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个练习，请按照以下步骤操作：
- en: Define a file provider that will use the `Context.getExternalFilesDir(null)`
    location.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个文件提供者，它将使用 `Context.getExternalFilesDir(null)` 位置。
- en: Copy `my-app-file.txt` to the preceding location when the `FileProvider` button
    is clicked.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当点击 `FileProvider` 按钮时，将 `my-app-file.txt` 复制到前面的位置。
- en: Use `Intent.ACTION_CREATE_DOCUMENT` when the `SAF` button is clicked and copy
    the file to the location provided.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当点击 `SAF` 按钮时，使用 `Intent.ACTION_CREATE_DOCUMENT` 并将文件复制到提供的位置。
- en: Use a separate thread for the file copy to comply with the Android guidelines.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用单独的线程进行文件复制，以符合 Android 指南。
- en: Use the Apache IO library to help with the file copy functionality, by providing
    methods that allow us to copy data from `InputStream` to `OutputStream`.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Apache IO 库帮助实现文件复制功能，通过提供允许我们从 `InputStream` 复制到 `OutputStream` 的方法。
- en: 'The steps for completion are as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 完成步骤如下：
- en: Create a new Android Studio project with an empty activity.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Android Studio 项目，包含一个空活动。
- en: 'Let’s start with our Gradle configuration:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从我们的 Gradle 配置开始：
- en: '[PRE24]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Create the `my-app-file.txt` file in the `main/assets` folder. Feel free to
    fill it up with the text you want to be read. If the `main/assets` folder doesn’t
    exist, then you can create it. To create the `assets` folder, you can right-click
    on the `main` folder, select `assets`.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main/assets` 文件夹中创建 `my-app-file.txt` 文件。您可以随意填充您想要读取的文本。如果 `main/assets`
    文件夹不存在，您可以创建它。要创建 `assets` 文件夹，您可以在 `main` 文件夹上右键单击，选择 `assets`。
- en: This folder will now be recognized by the build system, and any file inside
    it will also be installed on the device along with the app. You may need to switch
    **Project View** from **Android** to **Project** to be able to view this file
    structure.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，此文件夹将被构建系统识别，并且其中的任何文件也将与应用程序一起安装到设备上。您可能需要将 **项目视图** 从 **Android** 切换到 **项目**，以便能够查看此文件结构。
- en: 'We can also define a class that will wrap `AssetManager` in the `main/java`
    folder in the root package and define a method to access this particular file:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以在根包的 `main/java` 文件夹中定义一个类来包装 `AssetManager`，并定义一个方法来访问这个特定的文件：
- en: '[PRE25]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, let’s work on the `FileProvider` aspect. Create the `xml` folder in the
    `res` folder. Define `file_provider_paths.xml` inside the new folder. We will
    define `external-files-path`, name it `docs`, and place it in the `docs/` folder:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们专注于 `FileProvider` 方面。在 `res` 文件夹中创建 `xml` 文件夹。在新的文件夹中定义 `file_provider_paths.xml`。我们将定义
    `external-files-path`，命名为 `docs`，并将其放置在 `docs/` 文件夹中：
- en: '[PRE26]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, we need to add `FileProvider` to the `AndroidManifest.xml` file and link
    it with the new path we defined inside the `<``application` tag:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要将 `FileProvider` 添加到 `AndroidManifest.xml` 文件中，并将其与 `<application>`
    标签内定义的新路径链接：
- en: '[PRE27]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The name will point to the `FileProvider` path that’s part of the Android Support
    Library. The `authorities` field represents the domain your application has (usually
    the package name of the application).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 名称将指向 Android 支持库中的 `FileProvider` 路径。`authorities` 字段表示您的应用程序域（通常是应用程序的包名）。
- en: The exported field indicates whether we wish to share our provider with other
    apps, and `grantUriPermissions` indicates whether we wish to grant other applications
    access to certain files through the URI. The metadata links the XML file we defined
    previously with `FileProvider`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 导出字段表示我们是否希望与其他应用程序共享我们的提供者，而`grantUriPermissions`表示我们是否希望通过URI授予其他应用程序访问某些文件的权利。元数据将我们之前定义的XML文件与`FileProvider`链接起来。
- en: 'Define the `ProviderFileManager` class in the `main/java` folder in the root
    package, which is responsible for accessing the `docs` folder and writing data
    into the file:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根包的`main/java`文件夹中定义`ProviderFileManager`类，该类负责访问`docs`文件夹并将数据写入文件：
- en: '[PRE28]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The complete code for this step can be found at [https://packt.link/Gp0Ph](https://packt.link/Gp0Ph).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤的完整代码可以在[https://packt.link/Gp0Ph](https://packt.link/Gp0Ph)找到。
- en: '`getDocsFolder` will return the path to the `docs` folder we defined in the
    XML. If the folder does not exist, then it will be created.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`getDocsFolder`将返回我们在XML中定义的`docs`文件夹的路径。如果文件夹不存在，则将其创建。'
- en: The `writeStream` method will extract the URI for the file we wish to save and,
    using the Android `ContentResolver` class, will give us access to the `OutputStream`
    class of the file we will be saving in. Note that `FileToUriMapper` doesn’t exist
    yet. The code is moved into a separate class in order to make this class testable.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`writeStream`方法将提取我们希望保存的文件的URI，并使用Android的`ContentResolver`类，将给我们提供访问我们将要保存的文件的`OutputStream`类的权限。请注意，`FileToUriMapper`尚未存在。代码被移动到一个单独的类中，以便使此类可测试。'
- en: 'Create the `FileToUriMapper` class in the `main/java` folder in the root package:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根包的`main/java`文件夹中创建`FileToUriMapper`类：
- en: '[PRE29]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `getUriForFile` method is part of the `FileProvider` class, and its role
    is to convert the path of a file into a URI that can be used by `ContentProviders`
    and `ContentResolvers` to access data. Because the method is static, it prevents
    us from testing properly.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`getUriForFile`方法是`FileProvider`类的一部分，其作用是将文件的路径转换为`ContentProviders`和`ContentResolvers`可以使用以访问数据的URI。因为此方法是静态的，所以它阻止我们进行适当的测试。'
- en: 'Make sure that the following strings are added to `strings.xml`:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保以下字符串被添加到`strings.xml`中：
- en: '[PRE30]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let’s now move on to defining our UI for the `activity_main.xml` file in the
    `res/layout` folder:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们继续定义我们的`activity_main.xml`文件在`res/layout`文件夹中的UI：
- en: '[PRE31]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The complete code for this step can be found at [https://packt.link/Pw37X](https://packt.link/Pw37X).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤的完整代码可以在[https://packt.link/Pw37X](https://packt.link/Pw37X)找到。
- en: 'Now, let’s define our `MainActivity` class in the `main/java` folder in the
    root package:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在根包的`main/java`文件夹中定义我们的`MainActivity`类：
- en: '[PRE32]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The complete code for this step can be found at [https://packt.link/FBXgY](https://packt.link/FBXgY).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤的完整代码可以在[https://packt.link/FBXgY](https://packt.link/FBXgY)找到。
- en: For this example, we chose `MainActivity` to create our objects and inject data
    into the different classes we have. If we execute this code and click the `FileProvider`
    button, we don’t see an output on the UI.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们选择了`MainActivity`来创建我们的对象并将数据注入到我们拥有的不同类中。如果我们执行此代码并点击`FileProvider`按钮，我们在UI上不会看到输出。
- en: 'However, if we look at Android’s **Device File Explorer**, we can locate where
    the file was saved. The path may be different on different devices and operating
    systems. The paths could be as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们查看Android的**设备文件浏览器**，我们可以找到文件保存的位置。在不同的设备和操作系统上，路径可能不同。路径可能如下所示：
- en: '`mnt/sdcard/Android/data/<package_name>/files/docs`'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mnt/sdcard/Android/data/<package_name>/files/docs`'
- en: '`sdcard/Android/data/<package_name>/files/docs`'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sdcard/Android/data/<package_name>/files/docs`'
- en: '`storage/emulated/0/Android/data/<package_name>/files/docs`'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`storage/emulated/0/Android/data/<package_name>/files/docs`'
- en: 'The output will be as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Figure 12.4 – Output of copy through FileProvider](img/B19411_12_04.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图12.4 – 通过FileProvider的复制输出](img/B19411_12_04.jpg)'
- en: Figure 12.4 – Output of copy through FileProvider
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 – 通过FileProvider的复制输出
- en: Let’s add the logic for the `SAF` button. We will need to start an activity
    pointing toward `SAF` with the `CREATE_DOCUMENT` intent, in which we specify that
    we want to create a text file.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加`SAF`按钮的逻辑。我们需要启动一个指向`SAF`的活动，使用`CREATE_DOCUMENT`意图，其中我们指定我们想要创建一个文本文件。
- en: 'We will then need the result of `SAF` so that we can copy the file to the location
    selected by a user. In `MainActivity` in `onCreate`, we can add the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要`SAF`的结果，以便我们可以将文件复制到用户选择的地点。在`MainActivity`的`onCreate`中，我们可以添加以下内容：
- en: '[PRE33]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: What the preceding code will do is register for an `Activity` result when a
    user creates a new file. We will then invoke `writeStreamFromUri` from `ProviderFileManager`
    to save the contents from the file in the `assets` folder in the file created
    by the user. When the button is clicked, we will then launch the file creation
    screen from the SAF.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将要执行的操作是在用户创建新文件时注册一个 `Activity` 结果。然后，我们将从 `ProviderFileManager` 调用 `writeStreamFromUri`
    来保存用户创建的文件中 `assets` 文件夹的内容。当按钮被点击时，我们将从 SAF 启动文件创建界面。
- en: 'We now have the URI. We can add a method to `ProviderFileManager` that will
    copy our file to a location given by `uri`:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了 URI。我们可以在 `ProviderFileManager` 中添加一个方法，将我们的文件复制到由 `uri` 指定的位置：
- en: '[PRE34]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If we run the preceding code and click on the **SAF** button, we will see the
    output presented in *Figure 12**.5*:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的代码并点击 **SAF** 按钮，我们将看到 *图 12.5* 中展示的输出：
- en: '![Figure 12.5 – Output of copy through the SAF](img/B19411_12_05.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.5 – 通过 SAF 复制的输出](img/B19411_12_05.jpg)'
- en: Figure 12.5 – Output of copy through the SAF
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.5 – 通过 SAF 复制的输出
- en: If you choose to save the file, the SAF will be closed and the callback from
    `registerForActivityResult` will be invoked, which will trigger the file copy.
    Afterward, you can navigate the Android Device File Manager tool to see whether
    the file was saved properly.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择保存文件，SAF 将关闭，并调用 `registerForActivityResult` 的回调，这将触发文件复制。之后，您可以通过 Android
    设备文件管理器工具导航，以查看文件是否已正确保存。
- en: Scoped storage
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 范围存储
- en: Since Android 10 and with further updates in Android 11, the notion of scoped
    storage was introduced. The main idea behind this is to allow apps to gain more
    control of their files in external storage and prevent other apps from accessing
    these files.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Android 10 以来，随着 Android 11 的进一步更新，引入了范围存储的概念。其背后的主要思想是允许应用程序对其外部存储中的文件有更多的控制权，并防止其他应用程序访问这些文件。
- en: The consequences of this mean that `READ_EXTERNAL_STORAGE` and `WRITE_EXTERNAL_STORAGE`
    will only apply to files a user interacts with (such as media files). This discourages
    apps from creating their own directories in external storage, instead sticking
    with the one already provided to them through `Context.getExternalFilesDir`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 `READ_EXTERNAL_STORAGE` 和 `WRITE_EXTERNAL_STORAGE` 只适用于用户交互的文件（如媒体文件）。这会阻止应用程序在外部存储中创建自己的目录，而是坚持使用通过
    `Context.getExternalFilesDir` 提供给它们的目录。
- en: FileProviders and the SAF are a good way of making your app comply with scoped
    storage practices, with one allowing the app to use `Context.getExternalFilesDir`
    and the other using the built-in File Explorer app, which will now avoid files
    from other applications in the `Android/data` and `Android/obb` folders in external
    storage.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 文件提供者和 SAF 是使您的应用程序符合范围存储实践的好方法，一个允许应用程序使用 `Context.getExternalFilesDir`，另一个使用内置的文件浏览器应用程序，现在将避免外部存储中
    `Android/data` 和 `Android/obb` 文件夹中的其他应用程序的文件。
- en: Camera and media storage
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摄像头和媒体存储
- en: Android offers a variety of ways to interact with media on its devices, from
    building your own camera application and controlling how users take photos and
    videos to using an existing camera application and instructing it on how to take
    photos and videos.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Android 提供了多种与其设备上的媒体进行交互的方式，从构建自己的相机应用程序并控制用户如何拍照和录像，到使用现有的相机应用程序并指导其如何拍照和录像。
- en: Android also comes with a `MediaStore` content provider, allowing applications
    to extract information about media files that are set on a device and shared between
    applications.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Android 还附带了一个 `MediaStore` 内容提供者，允许应用程序提取有关设备上设置并应用程序间共享的媒体文件的信息。
- en: This is useful in situations where you want a custom display for media files
    that exist on a device (such as a photo or music player application) and in situations
    where you use the `MediaStore.ACTION_PICK` intent to select a photo from the device
    and want to extract the information about the selected media image (this is usually
    the case for older applications where the SAF cannot be used).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这在需要为设备上存在的媒体文件（如照片或音乐播放器应用程序）提供自定义显示的情况下很有用，以及在您使用 `MediaStore.ACTION_PICK`
    意图从设备中选择照片并希望提取所选媒体图像信息的情况下（这通常是对于无法使用 SAF 的旧应用程序而言）。
- en: 'In order to use an existing camera application, you will need to use the `MediaStore.ACTION_IMAGE_CAPTURE`
    intent to start a camera application for a result and pass the URI of the image
    you wish to save. The user will then go to the camera activity and take the photo,
    and then you handle the result of the operation:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用现有的相机应用程序，您需要使用 `MediaStore.ACTION_IMAGE_CAPTURE` 意图启动一个用于结果的相机应用程序，并传递您希望保存的图像的
    URI。然后用户将进入相机活动并拍照，然后您处理操作的结果：
- en: '[PRE35]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `photoUri` parameter will represent the location of where you want your
    photo to be saved. It should point to an empty file with a JPEG extension. You
    can build this file in two ways:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`photoUri` 参数将代表您希望保存照片的位置。它应该指向一个具有 JPEG 扩展名的空文件。您可以通过两种方式构建此文件：'
- en: Create a file on the external storage using the `File` object (this requires
    the `WRITE_EXTERNAL_STORAGE` permission) and then use the `Uri.fromFile()` method
    to convert it into `URI` (this is no longer applicable on Android 10 and above)
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `File` 对象在外部存储上创建一个文件（这需要 `WRITE_EXTERNAL_STORAGE` 权限），然后使用 `Uri.fromFile()`
    方法将其转换为 `URI`（这在 Android 10 及以上版本中不再适用）
- en: Create a file in a `FileProvider` location using the `File` object, and then
    use the `FileProvider.getUriForFile()` method to obtain the URI and grant it permissions
    if necessary (the recommended approach for when your app targets Android 10 and
    Android 11)
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `File` 对象在 `FileProvider` 位置创建一个文件，然后使用 `FileProvider.getUriForFile()` 方法获取
    URI，并在必要时授予它权限（当您的应用程序针对 Android 10 和 Android 11 时推荐的方法）
- en: Note
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The same mechanism can be applied to videos using `MediaStore.ACTION_VIDEO_CAPTURE`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的机制可以使用 `MediaStore.ACTION_VIDEO_CAPTURE` 用于视频。
- en: If your application relies heavily on camera features, then you can exclude
    the application from users whose devices don’t have cameras by adding the `<uses-feature>`
    tag to the `AndroidManifest.xml` file. You can also specify the camera as non-required
    and query whether the camera is available using the `Context.hasSystemFeature(PackageManager.FEATURE_CAMERA_ANY)`
    method.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序严重依赖相机功能，那么您可以通过在 `AndroidManifest.xml` 文件中添加 `<uses-feature>` 标签来排除没有相机的用户的应用程序。您还可以指定相机为非必需，并使用
    `Context.hasSystemFeature(PackageManager.FEATURE_CAMERA_ANY)` 方法查询相机是否可用。
- en: 'If you wish to have your file saved in `MediaStore`, there are multiple ways
    to achieve this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望文件保存在 `MediaStore` 中，有多种方法可以实现：
- en: 'Send an `ACTION_MEDIA_SCANNER_SCAN_FILE` broadcast with the URI of your media:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您的媒体 URI 发送 `ACTION_MEDIA_SCANNER_SCAN_FILE` 广播：
- en: '[PRE36]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Use the media scanner to scan files directly:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用媒体扫描器直接扫描文件：
- en: '[PRE37]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Insert the media into `ContentProvider` directly using `ContentResolver`:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 直接使用 `ContentResolver` 将媒体插入 `ContentProvider`：
- en: '[PRE38]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `MediaScanner` functionality no longer adds files from `Context.getExternal`
    **FilesDir** in Android 10 and above. Apps should rely on the `insert` method
    instead if they choose to share their media files with other apps.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 10 及以上版本中，`MediaScanner` 功能不再从 `Context.getExternal` **FilesDir**
    添加文件。如果应用程序选择与其他应用程序共享其媒体文件，它们应选择使用 `insert` 方法。
- en: Exercise 12.04 – taking photos
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 12.04 – 拍照
- en: We’re going to build an application that has two buttons; the first button will
    open a camera app to take a photo, and the second button will open the camera
    app to record a video. We will use `FileProvider` to save the photos to external
    storage (external-path) in two folders, `pictures` and `movies`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个具有两个按钮的应用程序；第一个按钮将打开相机应用程序拍照，第二个按钮将打开相机应用程序录制视频。我们将使用 `FileProvider`
    将照片保存到外部存储（external-path）的两个文件夹中，`pictures` 和 `movies`。
- en: 'The photos will be saved using `img_{timestamp}.jpg`, and the videos will be
    saved using `video_{timestamp}.mp4`. After a photo and video have been saved,
    you will copy the file from `FileProvider` into `MediaStore` so that they will
    be visible for other apps:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 照片将使用 `img_{timestamp}.jpg` 保存，视频将使用 `video_{timestamp}.mp4` 保存。在照片和视频保存后，您将把文件从
    `FileProvider` 复制到 `MediaStore`，以便其他应用程序可以看到：
- en: Create a new Android Studio project with an empty activity.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Android Studio 项目，其中包含一个空活动。
- en: 'Let’s add the libraries in `app/build.gradle`:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 `app/build.gradle` 中添加库：
- en: '[PRE39]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We will need to request the `WRITE_EXTERNAL_STORAGE` permission for devices
    that predate Android 10, which means we need the following in `AndroidManifest.xml`
    outside of the `<``application` tag:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为 Android 10 之前的设备请求 `WRITE_EXTERNAL_STORAGE` 权限，这意味着我们需要在 `<application>`
    标签之外 `AndroidManifest.xml` 中包含以下内容：
- en: '[PRE40]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let’s define a `FileHelper` class, which will contain methods that are harder
    to test in the `test` folder in the root package:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在根包的`test`文件夹中定义一个`FileHelper`类，它将包含在`test`文件夹中更难测试的方法：
- en: '[PRE41]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let’s define our `FileProvider` paths in `res/xml/file_provider_paths.xml`.
    Make sure to include the appropriate package name for your application in `FileProvider`:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`res/xml/file_provider_paths.xml`中定义我们的`FileProvider`路径。请确保在`FileProvider`中包含您应用程序的适当包名：
- en: '[PRE42]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Let’s add the file provider paths to the `AndroidManifest.xml` file inside
    the `<``application` tag:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在根包中的`AndroidManifest.xml`文件内的`<application>`标签中添加文件提供者路径：
- en: '[PRE43]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Let’s now define a model that will hold both `Uri` and the associated path
    for a file in the `main/java` folder in the root package:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们定义一个模型，它将包含`Uri`和与根包中`main/java`文件夹中的文件关联的路径：
- en: '[PRE44]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Let’s create a `ContentHelper` class in the `main/java` folder in the root package,
    which will provide us with the data required for `ContentResolver`. We will define
    two methods for accessing the photo and video content URI and two methods that
    will create `ContentValues`.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在根包中的`main/java`文件夹中创建一个`ContentHelper`类，它将为我们提供`ContentResolver`所需的数据。我们将定义两个用于访问照片和视频内容URI的方法，以及两个创建`ContentValues`的方法。
- en: 'We do this because of the static methods required to obtain URIs and create
    `ContentValues`, which makes this functionality hard to test. The following code
    is truncated for space. The full code you need to add can be found via the link
    that follows this code block:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做是因为需要静态方法来获取URI和创建`ContentValues`，这使得此功能难以测试。以下代码为了节省空间而被截断。您需要添加的完整代码可以通过以下代码块后的链接找到：
- en: '[PRE45]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The complete code for this step can be found at [https://packt.link/DhOLR](https://packt.link/DhOLR).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤的完整代码可以在[https://packt.link/DhOLR](https://packt.link/DhOLR)找到。
- en: 'Now, let’s create the `ProviderFileManager` class in the `main/java` folder
    in the root package, where we will define methods to generate files for photos
    and videos that will then be used by the camera and the methods that will save
    to the media store. Again, the code has been truncated for brevity. Please see
    the link that follows this code block for the full code that you need to use:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在根包中的`main/java`文件夹中创建`ProviderFileManager`类，我们将定义用于生成相机将使用的照片和视频文件的方法，以及将文件保存到媒体存储的方法。同样，为了简洁，代码已被截断。请参阅以下代码块后的链接以获取您需要使用的完整代码：
- en: '[PRE46]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The complete code for this step can be found at [https://packt.link/ohv7a](https://packt.link/ohv7a).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤的完整代码可以在[https://packt.link/ohv7a](https://packt.link/ohv7a)找到。
- en: Note how we defined the root folders as `context.getExternalFilesDir(Environment.DIRECTORY_PICTURES)`
    and `context.getExternalFilesDir(Environment.DIRECTORY_MOVIES)`. This connects
    to `file_provider_paths.xml` and it will create a set of folders called `Movies`
    and `Pictures` in the application’s dedicated folder in external storage. The
    `insertToStore` method is where the files will be then copied to the `MediaStore`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何将根文件夹定义为`context.getExternalFilesDir(Environment.DIRECTORY_PICTURES)`和`context.getExternalFilesDir(Environment.DIRECTORY_MOVIES)`。这连接到`file_provider_paths.xml`，它将在应用程序的外部存储专用文件夹中创建一个名为`Movies`和`Pictures`的文件夹集合。`insertToStore`方法是将文件复制到`MediaStore`的地方。
- en: First, we will create an entry into that store that will give us a URI for that
    entry. Next, we copy the contents of the files from the URI generated by `FileProvider`
    into `OutputStream`, pointing to the `MediaStore` entry.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个条目到该存储中，这将给我们一个该条目的URI。接下来，我们将从由`FileProvider`生成的URI中复制文件的 内容到`OutputStream`，指向`MediaStore`条目。
- en: 'Add the following strings to `strings.xml`:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下字符串添加到`strings.xml`中：
- en: '[PRE47]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let’s define the layout for our activity in `res/layout/activity_main.xml`:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`res/layout/activity_main.xml`中定义我们活动的布局：
- en: '[PRE48]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The complete code for this step can be found at [https://packt.link/6iSNp](https://packt.link/6iSNp).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤的完整代码可以在[https://packt.link/6iSNp](https://packt.link/6iSNp)找到。
- en: 'Let’s create the `MainActivity` class in the `main/java` folder in the root
    package, where we will check whether we need to request `WRITE_STORAGE_PERMISSION`,
    request it if we need to, and after it is granted, open the camera to take a photo
    or a video. As before, the code here has been truncated for brevity. You can access
    the full code using the link that follows the code block:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在根包中`main/java`文件夹中创建`MainActivity`类，我们将检查是否需要请求`WRITE_STORAGE_PERMISSION`，如果需要，就请求它，并在它被授权后，打开相机拍照或录像。和之前一样，这里的代码为了简洁而被截断。您可以通过以下链接访问完整的代码：
- en: '[PRE49]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The complete code for this step can be found at [https://packt.link/YeHWC](https://packt.link/YeHWC).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤的完整代码可以在 [https://packt.link/YeHWC](https://packt.link/YeHWC) 找到。
- en: 'If we execute the preceding code, we will see the following:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行前面的代码，我们将看到以下内容：
- en: '![Figure 12.6 – Output of Exercise 12.04](img/B19411_12_06.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.6 – 练习 12.04 的输出](img/B19411_12_06.jpg)'
- en: Figure 12.6 – Output of Exercise 12.04
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.6 – 练习 12.04 的输出
- en: By clicking on either of the buttons, you will be redirected to the camera application,
    where you can take a photo or a video if you are running the example on Android
    10 and above. If you’re running on lower Android versions, then the permissions
    will be asked first.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击任一按钮，你将被重定向到相机应用，在那里如果你在 Android 10 及以上版本上运行示例，你可以拍照或录像。如果你在较低的 Android
    版本上运行，则首先会请求权限。
- en: 'Once you have taken your photo and confirmed it, you will be taken back to
    the application. The photo will be saved in the location you defined in `FileProvider`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你拍摄了照片并确认，你将被带回到应用程序。照片将被保存在你在 `FileProvider` 中定义的位置：
- en: '![Figure 12.7 – The location of the captured files through the camera app](img/B19411_12_07.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.7 – 通过相机应用捕获的文件位置](img/B19411_12_07.jpg)'
- en: Figure 12.7 – The location of the captured files through the camera app
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.7 – 通过相机应用捕获的文件位置
- en: In the preceding screenshot, you can see where the files are located with the
    help of Android Studio’s **Device File Explorer**. If you open any file-exploring
    app, such as the **Files**, **Gallery**, or **Google Photos** app, you will be
    able to see the videos and pictures taken.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，你可以看到文件的位置，这是通过 Android Studio 的**设备文件浏览器**帮助实现的。如果你打开任何文件管理应用，如**文件**、**图库**或**谷歌照片**应用，你将能够看到拍摄的视频和图片。
- en: '![Figure 12.8 – The files from the app present in the File Explorer app](img/B19411_12_08.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.8 – 应用程序在文件浏览器应用中显示的文件](img/B19411_12_08.jpg)'
- en: Figure 12.8 – The files from the app present in the File Explorer app
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.8 – 应用程序在文件浏览器应用中显示的文件
- en: Activity 12.01 – dog downloader
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 12.01 – 狗下载器
- en: You are tasked with building an application that will target Android versions
    above API 21 and display a list of URLs for dog photos. The URL you will connect
    to is `https://dog.ceo/api/breed/hound/images/random/{number}`, where `number`
    will be controlled through a **Settings** screen, where a user can choose the
    number of URLs they want to be displayed.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 你被分配了一个任务，需要构建一个针对 API 21 以上 Android 版本的应用程序，显示狗照片的 URL 列表。你将连接到的 URL 是 `https://dog.ceo/api/breed/hound/images/random/{number}`，其中
    `number` 将通过一个**设置**屏幕进行控制，用户可以在该屏幕中选择他们想要显示的 URL 数量。
- en: The **Settings** screen will be opened through an option presented on the home
    screen. When a user clicks on a URL, an image will be downloaded locally in the
    application’s external cache path. While the image is being downloaded, the user
    will see an indeterminate progress bar. The list of URLs will be persisted locally
    using Room.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '**设置**屏幕将通过主屏幕上的选项打开。当用户点击 URL 时，图像将下载到应用程序的外部缓存路径。在图像下载过程中，用户将看到一个不确定的进度条。URL
    列表将使用 Room 本地持久化。'
- en: 'The technologies that we will use are the following:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下技术：
- en: Retrofit to retrieve the list of URLs and download files
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Retrofit 用于检索 URL 列表和下载文件
- en: Room to persist the list of URLs
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Room 用于持久化 URL 列表
- en: '`SharedPreferences` to store the number of URLs to retrieve'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SharedPreferences` 用于存储要检索的 URL 数量'
- en: '`FileProvider` to store the files in the cache'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileProvider` 用于在缓存中存储文件'
- en: Apache IO to write the files
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache IO 用于写入文件
- en: Repository to combine all the data sources
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仓库来组合所有数据源
- en: '`LiveData` and `ViewModel` to handle the logic from the user'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `LiveData` 和 `ViewModel` 处理来自用户的逻辑
- en: '`RecyclerView` for the list of items'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RecyclerView` 用于项目列表'
- en: 'The response JSON will look similar to this:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 响应的 JSON 将类似于以下内容：
- en: '[PRE50]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Perform the following steps to complete this activity:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此活动的步骤如下：
- en: Create an `api` package that will contain the network-related classes.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含网络相关类的 `api` 包。
- en: Create a data class that will model the response JSON.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个数据类来模拟响应 JSON。
- en: Create a Retrofit `Service` class that will contain two methods. The first method
    will represent the API call to return a list of breeds, and the second method
    will represent the API call to download the file.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 Retrofit `Service` 类，其中将包含两个方法。第一个方法将表示返回品种列表的 API 调用，第二个方法将表示下载文件的 API
    调用。
- en: Create a `storage` package, and inside it, create a `room` package.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `storage` 包，并在其中创建一个 `room` 包。
- en: Create the `Dog` entity, which will contain an autogenerated ID and a URL.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Dog` 的实体，它将包含一个自动生成的 ID 和一个 URL。
- en: Create the `DogDao` class, which will contain methods to insert a list of `Dogs`,
    delete all `Dogs`, and query all `Dogs`. The `delete` method is required because
    the API model does not have any unique identifiers.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含插入 `Dogs` 列表、删除所有 `Dogs` 和查询所有 `Dogs` 方法的 `DogDao` 类。`delete` 方法是必需的，因为
    API 模型没有任何唯一标识符。
- en: Inside the `storage` package, create a `preference` package.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `storage` 包内部，创建一个 `preference` 包。
- en: Inside the `preference` package, create a wrapper class around `SharedPreferences`
    that will return the number of URLs we need to use and set the number. The default
    will be `10`.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `preference` 包内部，创建一个围绕 `SharedPreferences` 的包装类，该类将返回我们需要使用的 URL 数量并设置该数量。默认值为
    `10`。
- en: In `res/xml`, define your folder structure for `FileProvider`. The files should
    be saved in the root folder of the `external-cache-path` tag.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `res/xml` 中，为 `FileProvider` 定义你的文件夹结构。文件应保存在 `external-cache-path` 标签的根文件夹中。
- en: Inside the `storage` package, create a `filesystem` package.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `storage` 包内部，创建一个 `filesystem` 包。
- en: Inside the `filesystem` package, define a class that will be responsible for
    writing `InputStream` into a file in `FileProvider`, using `Context.externalCacheDir`.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `filesystem` 包内部，定义一个类，该类将负责将 `InputStream` 写入 `FileProvider` 中的文件，使用 `Context.externalCacheDir`。
- en: Create a `repository` package.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `repository` 包。
- en: Inside the `repository` package, create a sealed class that will hold the result
    of an API call. The subclasses of the sealed class will be `Success`, `Error`,
    and `Loading`.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `repository` 包内部，创建一个密封类，该类将包含 API 调用的结果。密封类的子类将是 `Success`、`Error` 和 `Loading`。
- en: Define a `Repository` interface that will contain two methods, one to load the
    list of URLs and the other to download a file.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个包含两个方法的 `Repository` 接口，一个用于加载 URL 列表，另一个用于下载文件。
- en: Define a `DogUi` model class that will be used in the UI layer of your application
    and that will be created in your repository.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个 `DogUi` 模型类，它将在应用程序的 UI 层中使用，并在你的仓库中创建。
- en: Define a mapper class that will convert your API models into entities and entities
    into UI models.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个映射类，它将把你的 API 模型转换为实体，并将实体转换为 UI 模型。
- en: Define an implementation for `Repository` that will implement the preceding
    two methods. The repository will hold references to `DogDao`, the Retrofit `Service`
    class, the `Preferences` wrapper class, the class managing the files, the `Dog`
    mapping class, and the `Executor` class for multithreading. When downloading the
    files, we will use the filename extracted from the URL.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个 `Repository` 的实现，该实现将实现前面的两个方法。该仓库将包含对 `DogDao`、Retrofit `Service` 类、`Preferences`
    包装类、管理文件的类、`Dog` 映射类和多线程的 `Executor` 类的引用。在下载文件时，我们将使用从 URL 中提取的文件名。
- en: Create a class that will extend `Application`, which will initialize the repository.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个扩展 `Application` 的类，该类将初始化仓库。
- en: Define the `ViewModel` class used by your UI, which will have a reference to
    `Repository` and call it to load the URL list and download the images.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义你的 UI 使用的 `ViewModel` 类，它将有一个对 `Repository` 的引用，并调用它来加载 URL 列表和下载图片。
- en: 'Define your UI, which will be composed of two activities:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义你的 UI，它将由两个活动组成：
- en: '`MainActivity` which displays the list of URLs and will have a click action
    to start the downloads. This activity will have a progress bar, which will be
    displayed when the download takes place. The screen will also have a `SettingsActivity`.'
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MainActivity`，显示 URL 列表，并具有点击动作以启动下载。此活动将有一个进度条，在下载发生时将显示。屏幕还将有一个 `SettingsActivity`。'
- en: The `SettingsActivity`, which will display `EditText` and `Button` and save
    the number of URLs.
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SettingsActivity`，它将显示 `EditText` 和 `Button` 并保存 URL 的数量。'
- en: Note
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found at [https://packt.link/z6g5j](https://packt.link/z6g5j).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 该活动的解决方案可以在 [https://packt.link/z6g5j](https://packt.link/z6g5j) 找到。
- en: Summary
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we analyzed alternatives to Room when it comes to persisting
    data. We looked first at `SharedPreferences` and how it constitutes a handy solution
    for data persistence when it’s in a key-value format and the amount of data is
    small. We also looked at `DataStore` and how we can use it like `SharedPreferences`
    but with built-in observability, which notifies us when values are changed.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们分析了在持久化数据方面 Room 的替代方案。我们首先看了 `SharedPreferences` 以及它如何构成一种方便的数据持久化解决方案，当数据以键值格式存在且数据量较小时。我们还看了
    `DataStore` 以及我们如何像使用 `SharedPreferences` 一样使用它，但具有内置的可观察性，它会通知我们值何时发生变化。
- en: Next, we looked over something that was continuously changing when it comes
    to the Android framework – the evolution of abstractions regarding a filesystem.
    We started with an overview of the types of storage that Android has and then
    took a more in-depth look at two of the abstractions – `FileProvider`, which your
    app can use to store files on a device and share them with others if necessary,
    and the SAF, which can be used to save files on the device in a location selected
    by a user.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们回顾了在Android框架中持续变化的某个方面——关于文件系统的抽象演变。我们首先概述了Android拥有的存储类型，然后更深入地探讨了其中两种抽象——`FileProvider`，您的应用可以使用它来在设备上存储文件并在必要时与他人共享，以及SAF，它可以用作在用户选择的位置保存设备上的文件。
- en: We also used the benefits of `FileProvider` to generate URIs for files in order
    to use camera applications to take photos and record videos, saving them in the
    application’s files while also adding them to `MediaStore`.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还利用了`FileProvider`的优势来生成文件的URI，以便使用相机应用拍照和录制视频，同时将它们保存在应用文件中，并添加到`MediaStore`中。
- en: The activity performed in this chapter combines all the elements discussed previously
    to illustrate the point that even though you have to balance multiple sources
    inside an application, you can do it in a more readable way.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中执行的活动结合了之前讨论的所有元素，以说明即使在应用内部需要平衡多个来源，也可以以更可读的方式完成。
- en: Note that for the activity and exercises in this chapter and the previous one,
    we kept having to use the `application` class to instantiate the data sources.
    In the next chapter, you will learn how to overcome this through dependency injection
    and see how it can benefit Android applications.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在本章和上一章的活动和练习中，我们不得不一直使用`application`类来实例化数据源。在下一章中，您将学习如何通过依赖注入来克服这一点，并了解它如何使Android应用受益。
