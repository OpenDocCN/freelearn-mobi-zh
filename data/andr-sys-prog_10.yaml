- en: Enabling Graphics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用图形
- en: 'In the last chapter, we learnt how to boot the x86vbox device using PXE and
    NFS. We can boot the device to an embedded Linux environment, which is the first
    stage of the Android-x86 boot. In this stage, we can use a debug console to verify
    the status of the system so that we can make sure everything is right before we
    start the real Android system. In this chapter, we will talk about the first issue
    we meet during Android system boot up. This is about how to enable the Android
    graphics system for the x86vbox device. We will cover the following topics in
    this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用PXE和NFS启动x86vbox设备。我们可以将设备引导到嵌入式Linux环境，这是Android-x86引导的第一阶段。在这个阶段，我们可以使用调试控制台来验证系统的状态，以确保我们在启动真正的Android系统之前一切正常。在本章中，我们将讨论在Android系统启动过程中遇到的第一问题。这是关于如何为x86vbox设备启用Android图形系统。本章将涵盖以下主题：
- en: Overview of Android graphics architecture
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android图形架构概述
- en: Delving into graphics HAL
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入探讨图形HAL
- en: Analyzing the Android emulator graphics HAL for comparison
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析Android模拟器图形HAL进行比较
- en: The graphics system probably is the most complicated software stack in the Android
    system architecture.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 图形系统可能是Android系统架构中最复杂的软件堆栈。
- en: As you will see, the content in this chapter is much longer than the rest. Reading
    and understanding the content in this chapter may be harder. What I suggest is
    that you can open a source code editor and load the relevant source code while
    you read this chapter. This will help you a lot to understand the source code
    and the points that I want to address in this chapter.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您将看到的，本章的内容比其他章节都要长。阅读和理解本章的内容可能更困难。我的建议是，您可以在阅读本章的同时打开源代码编辑器并加载相关源代码。这将极大地帮助您理解源代码以及我在本章中想要阐述的点。
- en: Introduction to the Android graphics architecture
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android图形架构简介
- en: The graphics system in Android is similar to the architecture that we discussed
    in [Chapter 3](e0f861c2-5832-402f-89d3-cfc75785e759.xhtml), *Discovering Kernel,
    HAL, and Virtual Hardware*. There we used goldfish lights HAL as an example to
    do a detailed analysis from the application level to the HAL and device driver
    layer. This analysis helps us to understand the Android architecture vertically.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Android中的图形系统与我们讨论过的架构相似，即[第3章](e0f861c2-5832-402f-89d3-cfc75785e759.xhtml)中提到的*发现内核、HAL和虚拟硬件*。在那里，我们以goldfish
    lights HAL为例，从应用层到HAL和设备驱动层进行了详细分析。这种分析有助于我们垂直理解Android架构。
- en: However, the graphics system could be the most complicated system in the Android
    architecture. It would require another book to give a detailed introduction to
    the Android graphics system. The focus of this book is on how we can port Android
    systems to a new hardware platform. To focus on this goal, we will address the
    graphics HAL in this chapter instead of discussing the entire graphics system.
    The graphics system will work if we can choose the right graphics HAL and configure
    it right.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，图形系统可能是Android架构中最复杂的系统。需要另一本书来详细介绍Android图形系统。本书的重点是如何将Android系统移植到新的硬件平台。为了专注于这个目标，我们将在本章中讨论图形HAL，而不是整个图形系统。如果我们能选择正确的图形HAL并正确配置它，图形系统就能正常工作。
- en: 'According to Google documents about the implementation of graphics, Android
    graphics support requires the following components:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 根据谷歌关于图形实现文档，Android图形支持需要以下组件：
- en: EGL driver
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EGL驱动程序
- en: OpenGL ES 1.x driver
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL ES 1.x驱动程序
- en: OpenGL ES 2.0 driver
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL ES 2.0驱动程序
- en: OpenGL ES 3.x driver (optional)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL ES 3.x驱动程序（可选）
- en: Vulkan (optional)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vulkan（可选）
- en: Gralloc HAL implementation
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gralloc HAL实现
- en: Hardware Composer HAL implementation
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件合成器HAL实现
- en: In the preceding list, OpenGL ES implementation is the most complicated component
    in the graphics system. We will discuss how it is chosen and integrated in an
    Android emulator and Android-x86\. We won't go into the details of how to analyze
    the OpenGL ES implementation, but we will have an overview about the underlying
    OpenGL ES libraries. OpenGL ES 1.x and 2.0 must be supported in an Android system.
    OpenGL ES 3.x is an optional component at the moment. EGL driver is usually implemented
    as part of the OpenGL ES implementation and we will see this when we discuss the
    Android emulator and Android-x86 (x86vbox) graphics system.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的列表中，OpenGL ES实现是图形系统中最复杂的组件。我们将讨论它如何在Android模拟器和Android-x86中选取和集成，但我们不会深入讨论如何分析OpenGL
    ES实现，而是会概述底层的OpenGL ES库。Android系统中必须支持OpenGL ES 1.x和2.0。OpenGL ES 3.x目前是一个可选组件。EGL驱动通常作为OpenGL
    ES实现的一部分实现，我们将在讨论Android模拟器和Android-x86（x86vbox）图形系统时看到这一点。
- en: Vulkan is a new generation of GPU API from Khronos Group. Vulkan is new and
    optional and was only introduced in Android 7\. Covering Vulkan is beyond the
    scope of this book, so we won't discuss it. Gralloc HAL is the one that handles
    the graphics hardware and it is our focus for a deep analysis. In most of the
    porting work of the graphics system, Gralloc HAL is the key to enabling graphics.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Vulkan是Khronos Group新一代GPU API。Vulkan是新的且可选的，仅在Android 7中引入。涵盖Vulkan超出了本书的范围，因此我们不会讨论它。Gralloc
    HAL是处理图形硬件的HAL，是我们深入分析的重点。在大多数图形系统的移植工作中，Gralloc HAL是启用图形的关键。
- en: Hardware composer is part of the graphics HAL. However, it is not a component
    that we must have for Android emulator or Android-x86\. The **Hardware Composer**
    (**HWC**) HAL is used to composite surfaces to the screen. The HWC abstracts objects
    such as overlays and helps offload some work that would normally be done with
    OpenGL.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件合成器是图形HAL的一部分。然而，它不是Android模拟器或Android-x86必须拥有的组件。**硬件合成器**（**HWC**）HAL用于将表面合成到屏幕上。HWC抽象了如叠加层等对象，并帮助卸载一些通常使用OpenGL完成的工作。
- en: '![](img/image_10_001.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片10_001](img/image_10_001.png)'
- en: Android graphics architecture
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Android图形架构
- en: As we can see from the preceding Android graphics architecture diagram, we can
    also divide related components into different layers in the Android architecture
    as we did in previous chapters. This architecture diagram is a simplified view
    of a graphics system. **SurfaceFlinger** is the system service to the application
    layer for graphics-related system support. **SurfaceFlinger** will connect to
    the **OpenGL ES** library and **HAL** layer components to perform the actual work.
    In the **HAL**, we have **HWC**, **gralloc**, and a vender-specific GPU library
    that will talk to the drivers in the kernel space.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的Android图形架构图所示，我们也可以将相关组件在Android架构中划分为不同的层，就像我们在前面的章节中所做的那样。这个架构图是图形系统的一个简化视图。**SurfaceFlinger**是提供图形相关系统支持的系统服务，面向应用层。**SurfaceFlinger**将连接到**OpenGL
    ES**库和**HAL**层组件以执行实际工作。在**HAL**中，我们有**HWC**、**gralloc**以及与内核空间中的驱动程序通信的特定于供应商的GPU库。
- en: Delving into graphics HAL
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入分析图形HAL
- en: 'After we have an overview of graphics system architecture, we will analyze
    the Gralloc module, which is the graphics HAL. In the AOSP source code, the skeleton
    of Gralloc HAL implementation can be found at the following folder:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们了解图形系统架构概述之后，我们将分析Gralloc模块，它是图形HAL。在AOSP源代码中，Gralloc HAL实现的骨架可以在以下文件夹中找到：
- en: '`$AOSP/hardware/libhardware/modules/gralloc`'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`$AOSP/hardware/libhardware/modules/gralloc`'
- en: This is a general implementation that provides a reference for developers to
    create their own Gralloc module. Gralloc will access framebuffer and GPU to provide
    services to the upper layer. In this section, we will analyze this general implementation
    first. After the analysis of this general Gralloc HAL module, we will introduce
    the Gralloc HAL of the Android emulator.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个通用实现，为开发者提供创建他们自己的Gralloc模块的参考。Gralloc将访问帧缓冲区和GPU，为上层提供服务。在本节中，我们将首先分析这个通用实现。在分析完这个通用的Gralloc
    HAL模块之后，我们将介绍Android模拟器的Gralloc HAL。
- en: Loading the Gralloc module
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载Gralloc模块
- en: 'When application developers draw images to the screen, there are two ways to
    do it. They can use Canvas or OpenGL. Beginning in Android 4.0, both methods use
    hardware acceleration by default. To use hardware acceleration, we need to use
    Open GL libraries and eventually the Gralloc module will be loaded as part of
    the graphics system initialization. As we saw in [Chapter 3](e0f861c2-5832-402f-89d3-cfc75785e759.xhtml),
    *Discovering Kernel, HAL, and Virtual Hardware*, each HAL module has a reference
    ID that can be used by the `hw_get_module` function to load it to memory. The
    `hw_get_module` function is defined in the `$AOSP/hardware/libhardware/hardware.c`
    file:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序开发者将图像绘制到屏幕上时，有两种方式可以实现。他们可以使用 Canvas 或 OpenGL。从 Android 4.0 开始，这两种方法默认都使用硬件加速。要使用硬件加速，我们需要使用
    Open GL 库，最终 Gralloc 模块将作为图形系统初始化的一部分被加载。正如我们在[第 3 章](e0f861c2-5832-402f-89d3-cfc75785e759.xhtml)“发现内核、HAL
    和虚拟硬件”中看到的，每个 HAL 模块都有一个引用 ID，该 ID 可以被 `hw_get_module` 函数用来将其加载到内存中。`hw_get_module`
    函数定义在 `$AOSP/hardware/libhardware/hardware.c` 文件中：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In `hw_get_module`, it actually calls another function, `hw_get_module_by_class`,
    to do the work:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `hw_get_module` 中，它实际上调用另一个函数，`hw_get_module_by_class` 来完成工作：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding function, it tries to find the Gralloc module shared library
    using the following names in `/system/lib/hw` or `/vendor/lib/hw`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的函数中，它试图在 `/system/lib/hw` 或 `/vendor/lib/hw` 中使用以下名称查找 Gralloc 模块的共享库：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If any of the preceding files exist, they will call the `load` function to
    load the shared library. If none of them exist, a default shared library, `gralloc.default.so`,
    will be used. The hardware module ID for Gralloc is defined in the `gralloc.h`
    file as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上述文件中的任何一个存在，它们将调用 `load` 函数来加载共享库。如果它们都不存在，将使用默认的共享库 `gralloc.default.so`。Gralloc
    的硬件模块 ID 在 `gralloc.h` 文件中定义如下：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `load` function will call `dlopen` to load the library and will call `dlsym`
    to get the address of the data structure `hw_module_t`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`load` 函数将调用 `dlopen` 来加载库，并调用 `dlsym` 来获取数据结构 `hw_module_t` 的地址：'
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After we get the address of the data structure `hw_module_t`, we can call the
    `open` method defined in Gralloc HAL to initialize the framebuffer and GPU.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们获取到数据结构 `hw_module_t` 的地址后，我们可以调用 Gralloc HAL 中定义的 `open` 方法来初始化帧缓冲区和 GPU。
- en: 'As we discussed in [Chapter 3](e0f861c2-5832-402f-89d3-cfc75785e759.xhtml),
    *Discovering Kernel, HAL, and Virtual Hardware*, the hardware vendor needs to
    implement three HAL data structures as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在[第 3 章](e0f861c2-5832-402f-89d3-cfc75785e759.xhtml)“发现内核、HAL 和虚拟硬件”中讨论的，硬件供应商需要实现以下三个
    HAL 数据结构：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After the HAL shared library is loaded, the data structure `hw_module_t` is
    used to discover the HAL module, as we can see in the preceding code snippet.
    Each HAL module should implement an `open` method in the data structure `hw_module_methods_t`,
    which is responsible for the initialization of hardware. We can see that the `gralloc_device_open`
    function is defined as the `open` method in the following code snippet for the
    Gralloc module:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HAL 共享库加载后，数据结构 `hw_module_t` 被用来发现 HAL 模块，正如我们在前面的代码片段中看到的。每个 HAL 模块都应该在数据结构
    `hw_module_methods_t` 中实现一个 `open` 方法，该方法负责硬件的初始化。我们可以看到，在以下代码片段中，`gralloc_device_open`
    函数被定义为 Gralloc 模块的 `open` 方法：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the data structure `hw_module_methods_t`, the `open` method is assigned as
    a static function, `gralloc_device_open`. The `HAL_MODULE_INFO_SYM` symbol is
    defined as `struct private_module_t`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据结构 `hw_module_methods_t` 中，`open` 方法被分配为一个静态函数，`gralloc_device_open`。`HAL_MODULE_INFO_SYM`
    符号定义为 `struct private_module_t`。
- en: You may notice that we actually cast the `HAL_MODULE_INFO_SYM_AS_STR` symbol
    to `hw_module_t`, while we loaded the Gralloc module. In this default Gralloc
    module, the data structure `hw_module_t` is implemented using another two inherited
    data structures, `private_module_t` and `gralloc_module_t`. Let's look at the
    relationship between `private_module_t`, `gralloc_module_t`, and `hw_module_t`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，当我们加载 Gralloc 模块时，实际上是将 `HAL_MODULE_INFO_SYM_AS_STR` 符号映射到 `hw_module_t`，而在默认的
    Gralloc 模块中，数据结构 `hw_module_t` 是通过另外两个继承的数据结构 `private_module_t` 和 `gralloc_module_t`
    实现的。让我们看看 `private_module_t`、`gralloc_module_t` 和 `hw_module_t` 之间的关系。
- en: If you feel a little lost with the analysis, I suggest you look at the source
    code while you read this section. If you don't have the AOSP source code available,
    there is a very good cross-reference site for AOSP code at [http://xref.opersys.com/](http://xref.opersys.com/).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这部分的分析中感到有些困惑，我建议你在阅读这部分内容的同时查看源代码。如果你没有 AOSP 源代码，有一个非常好的 AOSP 代码交叉引用网站
    [http://xref.opersys.com/](http://xref.opersys.com/)。
- en: You can visit this site and search for the data structures that we are discussing.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以访问此网站并搜索我们正在讨论的数据结构。
- en: 'The data structure `private_module_t` is defined in the following file:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构`private_module_t`在以下文件中定义：
- en: '`$AOSP/hardware/libhardware/modules/gralloc/gralloc_priv.h`'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`$AOSP/hardware/libhardware/modules/gralloc/gralloc_priv.h`'
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As we can see, the first base field, or member variable in C++ terms, is the
    data structure `gralloc_module_t`. The second member variable framebuffer is a
    pointer of data type `private_handle_t`. It is a handle pointing to the framebuffer
    and we will explore it later.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，第一个基类字段，或者说在C++术语中的成员变量，是数据结构`gralloc_module_t`。第二个成员变量`framebuffer`是`private_handle_t`数据类型的指针。它是一个指向framebuffer的句柄，我们将在后面探讨它。
- en: The member variable `flags` is used to indicate whether the system can support
    double buffering. If it is supported the `PAGE_FLIP` bit is set to 1; otherwise,
    it is set to 0.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 成员变量`flags`用于指示系统是否支持双缓冲。如果支持，则`PAGE_FLIP`位设置为1；否则，设置为0。
- en: The `numBuffers` member variable indicates the number of buffers in the framebuffer.
    It is related to the visible resolution and virtual resolution. For example, if
    the visible resolution of the display is 800 x 600, the virtual resolution can
    be 1600 x 600\. In this case, the framebuffer can have two buffers for the display
    and the system can support double buffers for the display.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`numBuffers`成员变量表示framebuffer中的缓冲区数量。它与可见分辨率和虚拟分辨率相关。例如，如果显示器的可见分辨率为800 x 600，则虚拟分辨率可以是1600
    x 600。在这种情况下，framebuffer可以为显示器提供两个缓冲区，并且系统可以支持显示器的双缓冲。'
- en: The `bufferMask` member variable is used to mark the use of buffers in a framebuffer
    device. If we assume there are two buffers in the framebuffer, the `bufferMask`
    variable can have four values in binary 00, 01, 10, and 11\. The value 00 indicates
    both buffers are empty. The value 01 means the first buffer is in use and the
    second buffer is empty. The value 10 means the first buffer is empty and the second
    buffer is in use. The value 11 means both buffers are busy.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`bufferMask`成员变量用于标记framebuffer设备中缓冲区的使用情况。如果我们假设framebuffer中有两个缓冲区，则`bufferMask`变量在二进制中可以有四个值：00、01、10和11。值00表示两个缓冲区都为空。值01表示第一个缓冲区正在使用，第二个缓冲区为空。值10表示第一个缓冲区为空，第二个缓冲区正在使用。值11表示两个缓冲区都在使用。'
- en: The `lock` member variable is used to protect access to `private_module_t`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`lock`成员变量用于保护对`private_module_t`的访问。'
- en: The `currentBuffer` member variable is used to track the current buffer for
    rendering.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`currentBuffer`成员变量用于跟踪用于渲染的当前缓冲区。'
- en: The `info` and `finfo` member variables are data types `fb_var_screeninfo` and
    `fb_fix_screeninfo`. They are used to store the properties of the display device.
    The properties in `fb_var_screeninfo` are programmable while the properties in
    `fb_fix_screeninfo` are read-only.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`info`和`finfo`成员变量是数据类型`fb_var_screeninfo`和`fb_fix_screeninfo`。它们用于存储显示设备的属性。`fb_var_screeninfo`中的属性是可编程的，而`fb_fix_screeninfo`中的属性是只读的。'
- en: The `xdpi` and `ydpi` member variables are used to describe the pixel density
    in terms of horizontal and vertical.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`xdpi`和`ydpi`成员变量用于以水平和垂直方向描述像素密度。'
- en: The `fps` member variable is the refresh rate of the display in frames per second.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`fps`成员变量是每秒显示的帧数。'
- en: 'The `gralloc_module_t` data structure is defined in the following file:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`gralloc_module_t`数据结构在以下文件中定义：'
- en: '`$AOSP/hardware/libhardware/include/hardware/gralloc.h`'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`$AOSP/hardware/libhardware/include/hardware/gralloc.h`'
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As we expect, the first field in `gralloc_module_t` is `hw_module_t` from the
    preceding code snippet. The relationship among these three data structures is
    similar to the following UML class diagram in object-oriented notation:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所预期，`gralloc_module_t`中的第一个字段是来自前面代码片段的`hw_module_t`。这三个数据结构之间的关系类似于以下UML类图中的面向对象表示法：
- en: '![](img/image_10_002.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_10_002.png)'
- en: Relationship between Gralloc data structures
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Gralloc数据结构之间的关系
- en: This is the way to simulate inheritance relationships in the C language. In
    this way, we can cast data types of `private_module_t` to `gralloc_module_t` or
    `hw_module_t`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是C语言中模拟继承关系的方式。这样，我们可以将`private_module_t`的数据类型转换为`gralloc_module_t`或`hw_module_t`。
- en: A set of member functions is defined in `gralloc_module_t`. We will look at
    four of them in this chapter.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在`gralloc_module_t`中定义了一组成员函数。在本章中，我们将查看其中的四个。
- en: The `registerBuffer` and `unregisterBuffer` member functions are used to register
    or unregister a buffer. To register a buffer, we map a buffer to the process space
    of the application.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`registerBuffer` 和 `unregisterBuffer` 成员函数用于注册或注销一个缓冲区。要注册一个缓冲区，我们需要将缓冲区映射到应用程序的进程空间。'
- en: The `lock` and `unlock` member functions are used to lock or unlock a buffer.
    The buffer is described using `buffer_handle_t` as a parameter of the function.
    We can use the `l`, `t`, `w`, and `h` parameters to provide the position and the
    size of the buffer. After the buffer is locked, we can get the address of the
    buffer in the `vaddr` output parameter. We should unlock the buffer after use.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`lock` 和 `unlock` 成员函数用于锁定或解锁一个缓冲区。缓冲区使用 `buffer_handle_t` 作为函数的参数进行描述。我们可以使用
    `l`、`t`、`w` 和 `h` 参数来提供缓冲区的位置和大小。缓冲区锁定后，我们可以在 `vaddr` 输出参数中获取缓冲区的地址。使用完毕后，我们应该解锁缓冲区。'
- en: Initializing GPU
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化 GPU
- en: 'We have talked about HAL data structures `hw_module_t` and `hw_module_methods_t`
    for the Gralloc module. The last one, `hw_device_t`, is initialized in the `open`
    method of the Gralloc HAL module. Now we can look at the `open` method of the
    Gralloc module as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了 Gralloc 模块的 HAL 数据结构 `hw_module_t` 和 `hw_module_methods_t`。最后一个，`hw_device_t`，在
    Gralloc HAL 模块的 `open` 方法中初始化。现在我们可以查看 Gralloc 模块的 `open` 方法如下：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As we can see here, the `gralloc_device_open` function can be used to initialize
    two kinds of device, `GRALLOC_HARDWARE_GPU0` and `GRALLOC_HARDWARE_FB0`, according
    to the `name` input parameter.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如此可见，`gralloc_device_open` 函数可以根据输入参数 `name` 初始化两种设备，`GRALLOC_HARDWARE_GPU0`
    和 `GRALLOC_HARDWARE_FB0`。
- en: 'Let''s look at the initialization of the GPU0 device first. The output parameter
    of the `open` method is the address of the `hw_device_t` data structure. After
    the calling applications get an instance of `hw_device_t`, they can use the hardware
    device to do their work. In the `open` method of Gralloc HAL, it allocates the
    memory for the `gralloc_context_t` data structure first. After that, it populates
    its `device` member variable and assigns the output parameter to the address of
    the `dev->device.common` member variable. As we expect, the output is the address
    of an `hw_device_t` instance. Let''s look at the relationship between `gralloc_context_t`,
    `alloc_device_t`, and `hw_device_t`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看 GPU0 设备的初始化。`open` 方法的输出参数是 `hw_device_t` 数据结构的地址。调用应用程序获取 `hw_device_t`
    实例后，可以使用硬件设备来完成它们的工作。在 Gralloc HAL 的 `open` 方法中，它首先为 `gralloc_context_t` 数据结构分配内存。之后，它填充其
    `device` 成员变量并将输出参数赋值给 `dev->device.common` 成员变量的地址。正如我们所期望的，输出是 `hw_device_t`
    实例的地址。让我们看看 `gralloc_context_t`、`alloc_device_t` 和 `hw_device_t` 之间的关系：
- en: '![](img/image_10_003.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_10_003.png)'
- en: 'As we can see from the preceding diagram, the first field or member variable
    of `gralloc_context_t` is `device`, which is data type `alloc_device_t`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，`gralloc_context_t` 的第一个字段或成员变量是 `device`，其数据类型为 `alloc_device_t`：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following is the definition of the `alloc_device_t` data structure. It
    is defined in the `gralloc.h` file:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对 `alloc_device_t` 数据结构的定义。它在 `gralloc.h` 文件中定义：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can see that the data type of the first field of `alloc_device_t` is `hw_device_t`.
    This is the technique for simulating inheritance relationships in the C language
    that we mentioned when we discussed the relationship between `private_module_t`,
    `gralloc_module_t` and `hw_module_t`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 `alloc_device_t` 的第一个字段的数据类型是 `hw_device_t`。这是我们讨论 `private_module_t`、`gralloc_module_t`
    和 `hw_module_t` 之间的关系时提到的 C 语言中模拟继承关系的技巧。
- en: The `alloc` and `free` methods of the Gralloc device are implemented in the
    `gralloc_alloc` and `gralloc_free` functions in the `gralloc.cpp` file.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Gralloc 设备的 `alloc` 和 `free` 方法在 `gralloc.cpp` 文件中的 `gralloc_alloc` 和 `gralloc_free`
    函数中实现。
- en: Initializing framebuffer
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化帧缓冲
- en: 'If we call the `open` method of the Gralloc module with the `name` value as
    `GRALLOC_HARDWARE_FB0`, it will initialize the framebuffer device. The `fb_device_open`
    function is called to open the framebuffer device:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `GRALLOC_HARDWARE_FB0` 作为 `name` 值调用 Gralloc 模块的 `open` 方法，它将初始化帧缓冲设备。调用
    `fb_device_open` 函数来打开帧缓冲设备：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `fb_device_open` function is implemented in the `framebuffer.cpp` file
    as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`fb_device_open` 函数在 `framebuffer.cpp` 文件中实现如下：'
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the `fb_device_open` function, it allocates memory for the `fb_context_t`
    data structure. After that, it populates the fields in the data structure. As
    we discussed in the GPU0 initialization, we expect the output as an instance of
    the `hw_device_t` data structure so that the caller can use the framebuffer device
    through the `hw_device_t` HAL data structure. We have a similar inheritance relationship
    between these three data structures, `fb_context_t`, `framebuffer_device_t`, and
    `hw_device_t`, as shown in the following diagram:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `fb_device_open` 函数中，它为 `fb_context_t` 数据结构分配内存。之后，它填充数据结构中的字段。正如我们在 GPU0
    初始化中讨论的那样，我们期望输出为 `hw_device_t` 数据结构的一个实例，以便调用者可以通过 `hw_device_t` HAL 数据结构使用帧缓冲区设备。这三个数据结构
    `fb_context_t`、`framebuffer_device_t` 和 `hw_device_t` 之间有类似的继承关系，如下面的图所示：
- en: '![](img/image_10_004.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_10_004.png)'
- en: Relationship between fb_context_t, framebuffer_device_t, and hw_device_t
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`fb_context_t`、`framebuffer_device_t` 和 `hw_device_t` 之间的关系'
- en: 'The `fb_context_t` data structure includes `framebuffer_device_t` as the first
    field as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`fb_context_t` 数据结构将 `framebuffer_device_t` 作为第一个字段，如下所示：'
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In turn, the `framebuffer_device_t` data structure includes `hw_device_t` as
    the first field, so `fb_context_t` can be used as either `framebuffer_device_t`
    or `hw_device_t`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 相应地，`framebuffer_device_t` 数据结构将 `hw_device_t` 作为第一个字段，因此 `fb_context_t` 可以用作
    `framebuffer_device_t` 或 `hw_device_t`：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As for the rest of the fields in `framebuffer_device_t`, they are:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `framebuffer_device_t` 中剩余的字段，它们是：
- en: '`flags`: Used to describe some attributes of the framebuffer.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags`: 用于描述帧缓冲区的某些属性。'
- en: '`width` and `height`: Dimensions of the framebuffer in pixels.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`width` 和 `height`：帧缓冲区的像素尺寸。'
- en: '`stride`: Framebuffer stride in pixels or the number of pixels per line.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stride`：帧缓冲区的像素步长或每行的像素数。'
- en: '`format`: Framebuffer pixel format. It can be `HAL_PIXEL_FORMAT_RGBX_8888`,
    `HAL_PIXEL_FORMAT_565`, and so on.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`format`：帧缓冲区像素格式。可以是 `HAL_PIXEL_FORMAT_RGBX_8888`、`HAL_PIXEL_FORMAT_565` 等。'
- en: '`xdpi` and `ydpi`: Resolution of the framebuffer''s display panel in pixels
    per inch.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xdpi` 和 `ydpi`：帧缓冲区显示面板的每英寸像素分辨率。'
- en: '`fps`: Display panel refresh rate in frames per second.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fps`：显示面板的每秒帧数。'
- en: '`minSwapInterval`: Minimum swap interval supported by this framebuffer.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minSwapInterval`：此帧缓冲区支持的最低交换间隔。'
- en: '`maxSwapInterval`: Maximum swap interval supported by this framebuffer.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxSwapInterval`：此帧缓冲区支持的最高交换间隔。'
- en: '`numFramebuffers`: Number of framebuffers supported.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`numFramebuffers`：支持的帧缓冲区数量。'
- en: Before it can fill in all the fields of `framebuffer_device_t`, the `fb_device_open`
    function calls a `mapFrameBuffer` function to get the information about the framebuffer.
    Besides getting framebuffer information, this `mapFrameBuffer` function also maps
    the framebuffer to the current process space so that the current process can use
    it. In Android, the Gralloc module is owned and managed by SurfaceFlinger.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在填充 `framebuffer_device_t` 的所有字段之前，`fb_device_open` 函数调用 `mapFrameBuffer` 函数以获取帧缓冲区信息。除了获取帧缓冲区信息外，此
    `mapFrameBuffer` 函数还将帧缓冲区映射到当前进程空间，以便当前进程可以使用它。在 Android 中，Gralloc 模块由 SurfaceFlinger
    拥有和管理。
- en: 'Let''s have a look at the `mapFrameBuffer` function now:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `mapFrameBuffer` 函数：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As we can see, `mapFrameBuffer` acquires a mutex first and calls another function,
    `mapFrameBufferLocked`, to do the rest of the work:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，`mapFrameBuffer` 首先获取一个互斥锁，然后调用另一个函数 `mapFrameBufferLocked` 来完成剩余的工作：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the `mapFrameBufferLocked` function, it checks whether there is a `/dev/graphics/fb0`
    or `/dev/fb0` device node. If the device node exists, it tries to open it and
    stores the file descriptor in the `fd` variable:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `mapFrameBufferLocked` 函数中，它检查是否存在 `/dev/graphics/fb0` 或 `/dev/fb0` 设备节点。如果设备节点存在，它将尝试打开它并将文件描述符存储在
    `fd` 变量中：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, it will use `ioctl` commands to get framebuffer information. There are
    two framebuffer data structures, `fb_fix_screeninfo` and `fb_var_screeninfo`,
    which can be used to communicate with framebuffer. The `fb_fix_screeninfo` data
    structure stores fixed framebuffer information and the `fb_var_screeninfo` data
    structure stores programmable framebuffer information:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，它将使用 `ioctl` 命令获取帧缓冲区信息。有两个帧缓冲区数据结构，`fb_fix_screeninfo` 和 `fb_var_screeninfo`，可以用来与帧缓冲区通信。`fb_fix_screeninfo`
    数据结构存储固定的帧缓冲区信息，而 `fb_var_screeninfo` 数据结构存储可编程的帧缓冲区信息：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: After it gets the framebuffer information, it tries to set the virtual resolution
    of the framebuffer device. The `xres` and `yres` fields are used to store the
    visible resolution of the framebuffer device while the `xres_virtual` and `yres_virtual`
    fields are used to store the virtual resolution of the framebuffer device.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取到帧缓冲区信息后，它试图设置帧缓冲设备的虚拟分辨率。`xres`和`yres`字段用于存储帧缓冲设备的可见分辨率，而`xres_virtual`和`yres_virtual`字段用于存储帧缓冲设备的虚拟分辨率。
- en: 'To set the virtual resolution, it tries to increase the virtual vertical resolution
    as the `info.yres * NUM_BUFFERS` value. `NUM_BUFFERS` is a macro for the number
    of buffers that can be used in the framebuffer devices. In our case, the `NUM_BUFFERS`
    value is `2`, so we can use the double buffer technology for the display. It sets
    the virtual resolution using the `ioctl` command `FBIOPUT_VSCREENINFO`. If it
    can set the virtual resolution successfully, it will set the `PAGE_FLIP` bit in
    `flags`; otherwise, it will clear the `PAGE_FLIP` bit:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置虚拟分辨率，它试图将虚拟垂直分辨率增加到`info.yres * NUM_BUFFERS`值。`NUM_BUFFERS`是用于帧缓冲设备中可以使用的缓冲区数量的宏。在我们的情况下，`NUM_BUFFERS`的值是`2`，因此我们可以使用双缓冲技术来显示。它使用`ioctl`命令`FBIOPUT_VSCREENINFO`来设置虚拟分辨率。如果它成功设置了虚拟分辨率，它将在`flags`中设置`PAGE_FLIP`位；否则，它将清除`PAGE_FLIP`位：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After it sets the virtual resolution, it will calculate the refresh rate. To
    understand the calculation of the refresh rate, you can refer to the document
    in the Linux kernel source code at `Documentation/fb/framebuffer.txt`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置虚拟分辨率后，它将计算刷新率。要了解刷新率的计算，可以参考Linux内核源代码中的文档`Documentation/fb/framebuffer.txt`：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Next, it will calculate the pixel density for both horizontal and vertical.
    It also converts the refresh rate to frames per second and stores this to `fps`.
    After it has all the information, it will store them to the fields of the data
    structure, `private_module_t`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，它将计算水平和垂直的像素密度。它还将刷新率转换为每秒帧数，并将其存储到`fps`中。在它有了所有信息后，它将它们存储到数据结构`private_module_t`的字段中。
- en: 'Finally, it will map the framebuffer to the process address space:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它将帧缓冲区映射到进程地址空间：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The size of the framebuffer by virtual resolution is `finfo.line_length * info.yres_virtual`.
    The value of `finfo.line_length` is equal to the number of bytes per line and
    the value of `info.yres_virtual` is the number of lines per frame. In order to
    do memory mapping, we have to round the size to the page boundary using the `roundUpToPageSize`
    function.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 按虚拟分辨率计算的帧缓冲区大小是`finfo.line_length * info.yres_virtual`。`finfo.line_length`的值等于每行的字节数，而`info.yres_virtual`的值是每帧的行数。为了进行内存映射，我们必须使用`roundUpToPageSize`函数将大小四舍五入到页面边界。
- en: The actual number of buffers that can be used in the framebuffer device is `info.yres_virtual`
    divided by `info.yres` and it is stored in the `numBuffers` field. The `bufferMask`
    field is set to 0 and this means all buffers are empty and can be used.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在帧缓冲设备中可以使用的实际缓冲区数量是`info.yres_virtual`除以`info.yres`，并存储在`numBuffers`字段中。`bufferMask`字段被设置为0，这意味着所有缓冲区都是空的，可以用来使用。
- en: It calls the `mmap` system call to map the framebuffer to the current process
    address space. The starting address of the framebuffer in the current process
    address space is `vaddr`, which is returned from the `mmap` system call. It is
    stored to the `framebuffer->base` field, so that the Gralloc module can use it
    to allocate buffers for the applications later.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 它调用`mmap`系统调用来将帧缓冲区映射到当前进程地址空间。当前进程地址空间中帧缓冲区的起始地址是`vaddr`，由`mmap`系统调用返回。它被存储到`framebuffer->base`字段中，这样Gralloc模块就可以使用它来为应用程序分配缓冲区。
- en: Up to now, we have completed the analysis of the `mapFrameBuffer` function.
    This function is the one that is responsible for most of the work in initializing
    framebuffer devices in the Gralloc HAL module.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经完成了对`mapFrameBuffer`函数的分析。这个函数负责在Gralloc HAL模块中初始化帧缓冲设备的大部分工作。
- en: Allocating and releasing the graphic buffer
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图形缓冲区的分配和释放
- en: 'So far in this chapter, we have discussed loading the Gralloc module and the
    `open` method provided by the Gralloc module. Let''s now review the points when
    the upper layer loads, initializes, and uses the Gralloc module:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们已经讨论了加载Gralloc模块和Gralloc模块提供的`open`方法。现在让我们回顾上层加载、初始化和使用Gralloc模块时的要点：
- en: For example, the Gralloc module is used mostly by `SurfaceFlinger`. `SurfaceFlinger`
    uses Gralloc; when it creates an instance of `FramebufferNativeWindow`, in the
    `FramebufferNativeWindow` constructor, it will call `hw_get_module` to get an
    instance of `hw_module_t`.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，Gralloc 模块主要被 `SurfaceFlinger` 使用。`SurfaceFlinger` 使用 Gralloc；当它创建 `FramebufferNativeWindow`
    的实例时，在 `FramebufferNativeWindow` 构造函数中，它将调用 `hw_get_module` 来获取 `hw_module_t`
    的实例。
- en: In the `hw_module_t` data structure, it has a field called `methods` with data
    type `hw_module_methods_t`. In `hw_module_methods_t`, it has an `open` method
    that returns a `hw_device_t` data structure.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `hw_module_t` 数据结构中，它有一个名为 `methods` 的字段，其数据类型为 `hw_module_methods_t`。在 `hw_module_methods_t`
    中，它有一个返回 `hw_device_t` 数据结构的 `open` 方法。
- en: With `hw_device_t`, `SurfaceFlinger` can use the `alloc` and `free` methods
    inside `hw_device_t` to allocate or release graphic buffers.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 `hw_device_t`，`SurfaceFlinger` 可以使用 `hw_device_t` 内部的 `alloc` 和 `free` 方法来分配或释放图形缓冲区。
- en: 'Let''s look at how the Gralloc module allocates and releases graphic buffers
    in this section. We will look at the source code of `gralloc_alloc` first:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在本节中看看 Gralloc 模块如何分配和释放图形缓冲区。我们首先查看 `gralloc_alloc` 的源代码：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As we can see in the preceding code snippet, the `alloc` method is implemented
    in the `gralloc_alloc` function. `gralloc_alloc` has the following parameters:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码片段所示，`alloc` 方法是在 `gralloc_alloc` 函数中实现的。`gralloc_alloc` 有以下参数：
- en: '`dev`: It has an `alloc_device` data type that inherits from `hw_device_t`.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dev`: 它具有从 `hw_device_t` 继承的 `alloc_device` 数据类型。'
- en: '`w` : It is the width of the graphic buffer.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`w` : 它是图形缓冲区的宽度。'
- en: '`h`: It is the height of graphic buffer.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`h`: 它是图形缓冲区的高度。'
- en: '`format` : It defines the color format of pixels. For example, the format can
    be `HAL_PIXEL_FORMAT_RGBA_8888`, `HAL_PIXEL_FORMAT_RGB_888`, `HAL_PIXEL_FORMAT_RGB_565`,
    and so on.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`format` : 它定义了像素的颜色格式。例如，格式可以是 `HAL_PIXEL_FORMAT_RGBA_8888`、`HAL_PIXEL_FORMAT_RGB_888`、`HAL_PIXEL_FORMAT_RGB_565`
    等。'
- en: '`usage` : It defines the use of graphic buffer. For example, if the `GRALLOC_USAGE_HW_FB`
    bit is set, the buffer will be allocated from the framebuffer.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`usage` : 它定义了图形缓冲区的用途。例如，如果设置了 `GRALLOC_USAGE_HW_FB` 位，缓冲区将从帧缓冲区分配。'
- en: '`pHandle` : It has a `buffer_handle_t` data type. We will discuss the details
    of this data structure. It is used to store the allocated buffer.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pHandle` : 它具有 `buffer_handle_t` 数据类型。我们将讨论这个数据结构的详细信息。它用于存储分配的缓冲区。'
- en: '`pStride` : The number of pixels per line.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pStride` : 每行的像素数。'
- en: In `gralloc_alloc`, it checks the format of pixels to decide the size of pixels.
    It can be 32 bits, 24 bits, 16 bits, and so on. The size of the pixel is stored
    in the `bpp` variable. The `bpr` variable is the number of bytes per line and
    it is calculated using `w` multiplied by `bpp`. The `bpr` variable needs to be
    aligned to four bytes boundary for memory allocation. The size of the buffer can
    be calculated using `h` multiplied by `bpr`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `gralloc_alloc` 中，它检查像素的格式以决定像素的大小。它可以是以32位、24位、16位等。像素的大小存储在 `bpp` 变量中。`bpr`
    变量是每行的字节数，它是通过 `w` 乘以 `bpp` 计算得出的。`bpr` 变量需要对齐到四个字节的边界以进行内存分配。缓冲区的大小可以通过 `h` 乘以
    `bpr` 来计算。
- en: After the size of the buffer is calculated, it will call the `gralloc_alloc_framebuffer`
    or `gralloc_alloc_buffer` functions according to the `GRALLOC_USAGE_HW_FB` bit.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算缓冲区大小后，它将根据 `GRALLOC_USAGE_HW_FB` 位调用 `gralloc_alloc_framebuffer` 或 `gralloc_alloc_buffer`
    函数。
- en: The graphic buffer that is allocated by `gralloc_alloc` is stored in the `buffer_handle_t`
    data type. `buffer_handle_t` is defined as a pointer of `native_handle`. `native_handle`
    is used as a parent class of `private_handle_t`. `private_handle_t` is the actual
    data type used to manage the graphic buffer and it is a hardware-dependent data
    structure.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由 `gralloc_alloc` 分配的图形缓冲区存储在 `buffer_handle_t` 数据类型中。`buffer_handle_t` 被定义为
    `native_handle` 的指针。`native_handle` 被用作 `private_handle_t` 的父类。`private_handle_t`
    是实际用于管理图形缓冲区的数据类型，它是一个硬件相关的数据结构。
- en: '![](img/image_10_005.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_10_005.png)'
- en: Relationship between private_handle_t and native_handle
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: private_handle_t 和 native_handle 之间的关系
- en: 'The preceding diagram shows the relationship between `private_handle_t` and
    `native_handle`. The following is the definition of `native_handle`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表显示了 `private_handle_t` 和 `native_handle` 之间的关系。以下是对 `native_handle` 的定义：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `version` field is set to the size of `native_handle`. The `numFds` and
    `numInts` fields describe the number of file descriptors and integers in the `data`
    array. The `data` array is used to store hardware-specific information, which
    we can see in the following definition of `private_handle_t`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`version` 字段被设置为 `native_handle` 的大小。`numFds` 和 `numInts` 字段描述了 `data` 数组中的文件描述符和整数的数量。`data`
    数组用于存储特定于硬件的信息，我们可以在以下 `private_handle_t` 的定义中看到：'
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `fd` member variable is a file descriptor that is used to describe a framebuffer
    or shared memory region. The `magic` member variable is stored as a magic number
    defined in the `sMagic` static variable. The `flags` member variable is used to
    describe the type of graphic buffer. For example, if it is equal to `PRIV_FLAGS_FRAMEBUFFER`,
    this buffer is allocated from framebuffer. The `size` member variable is the size
    of the graphic buffer. The `offset` member variable is the offset from the starting
    address in memory. The `base` member variable is the address allocated for the
    buffer. The `pid` member variable is the process ID of the creator of the graphic
    buffer.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`fd` 成员变量是一个文件描述符，用于描述帧缓冲区或共享内存区域。`magic` 成员变量存储为在 `sMagic` 静态变量中定义的魔术数字。`flags`
    成员变量用于描述图形缓冲区的类型。例如，如果它等于 `PRIV_FLAGS_FRAMEBUFFER`，则此缓冲区是从帧缓冲区分配的。`size` 成员变量是图形缓冲区的大小。`offset`
    成员变量是从内存起始地址的偏移量。`base` 成员变量是为缓冲区分配的地址。`pid` 成员变量是图形缓冲区创建者的进程 ID。'
- en: The constructor fills in the member variables of `native_handle`. The `validate`
    member function is used to validate whether the graphic buffer is an instance
    of `private_handle_t` or not.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数填充 `native_handle` 的成员变量。`validate` 成员函数用于验证图形缓冲区是否是 `private_handle_t`
    的实例。
- en: As we mentioned previously, the Gralloc module that we are analyzing is the
    default implementation in AOSP, and is built as `galloc.default.so`. In this implementation,
    GPU is not used and the buffer will be allocated either in the framebuffer or
    shared memory. Even though this is not the ideal case for performance, it has
    the least hardware dependency, which is good as a reference to understand a more
    complicated Gralloc module implementation.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，我们正在分析的 Gralloc 模块是 AOSP 中的默认实现，构建为 `galloc.default.so`。在这个实现中，GPU
    不被使用，缓冲区将分配在帧缓冲区或共享内存中。尽管这不是性能的理想情况，但它具有最少的硬件依赖性，这对于理解更复杂的 Gralloc 模块实现是一个很好的参考。
- en: Allocating from framebuffer
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从帧缓冲区分配
- en: 'As we can see from the `gralloc_alloc` function, when the `usage` bit is set
    to `GRALLOC_USAGE_HW_FB`, the `gralloc_alloc_framebuffer` function is called.
    The `gralloc_alloc_framebuffer` function will allocate the buffer from the framebuffer
    device:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `gralloc_alloc` 函数中我们可以看到，当 `usage` 位设置为 `GRALLOC_USAGE_HW_FB` 时，调用 `gralloc_alloc_framebuffer`
    函数。`gralloc_alloc_framebuffer` 函数将从帧缓冲区设备分配缓冲区：
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`gralloc_alloc_framebuffer` acquires a mutex first and calls to another function,
    `gralloc_alloc_framebuffer_locked`. In the locked version, it calls to a `mapFrameBufferLocked`
    function, which we analyzed before to get the framebuffer information and map
    it to the current process address space.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`gralloc_alloc_framebuffer` 首先获取一个互斥锁，并调用另一个函数，`gralloc_alloc_framebuffer_locked`。在锁定版本中，它调用之前分析的
    `mapFrameBufferLocked` 函数，以获取帧缓冲区信息并将其映射到当前进程地址空间。'
- en: It will check whether the framebuffer device can support double buffering or
    not. If it can support double buffering, it creates a new `private_handle_t` instance
    and fills in the information in this instance and returns to the caller. If the
    buffer is allocated from the framebuffer device, it will mark the `flags` member
    variable of `private_handle_t` to `PRIV_FLAGS_FRAMEBUFFER`. It will also set the
    framebuffer `usage` status in `bufferMask`, which is a member variable of `private_module_t`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 它将检查帧缓冲区设备是否支持双缓冲。如果它支持双缓冲，它将创建一个新的 `private_handle_t` 实例，并填充此实例中的信息，然后返回给调用者。如果缓冲区是从帧缓冲区设备分配的，它将标记
    `private_handle_t` 的 `flags` 成员变量为 `PRIV_FLAGS_FRAMEBUFFER`。它还将设置帧缓冲区的 `usage`
    状态在 `bufferMask` 中，这是 `private_module_t` 的成员变量。
- en: If it cannot support double buffering, it calls to `gralloc_alloc_buffer` to
    allocate a buffer from the system memory and returns to the caller.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它不支持双缓冲，它将调用 `gralloc_alloc_buffer` 从系统内存分配缓冲区并返回给调用者。
- en: Allocating from system memory
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从系统内存分配
- en: 'When the `usage` bit is not set to `GRALLOC_USAGE_HW_FB` or the system cannot
    support double buffering, we have to allocate the buffer from system memory using
    `gralloc_alloc_buffer`. Let''s look at the implementation of `gralloc_alloc_buffer`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `usage` 位未设置为 `GRALLOC_USAGE_HW_FB` 或系统不支持双缓冲时，我们必须使用 `gralloc_alloc_buffer`
    从系统内存分配缓冲区。让我们看看 `gralloc_alloc_buffer` 的实现：
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In `gralloc_alloc_buffer`, it rounds up the buffer size to the page size first.
    Then it creates an anonymous shared memory region using `ashmem_create_region`.
    It creates a new `private_handle_t` instance to represent this shared memory region.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `gralloc_alloc_buffer` 中，它首先将缓冲区大小向上舍入到页面大小。然后使用 `ashmem_create_region` 创建一个匿名共享内存区域。它创建一个新的
    `private_handle_t` 实例来表示这个共享内存区域。
- en: 'This shared memory region is described as a file descriptor. To use it, we
    need to map it to the current process address space. This is done with the `mapBuffer`
    function:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个共享内存区域被描述为一个文件描述符。要使用它，我们需要将其映射到当前进程的地址空间。这是通过 `mapBuffer` 函数完成的：
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`mapBuffer` calls to another function, `gralloc_map`, to do the memory mapping:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`mapBuffer` 调用另一个函数 `gralloc_map` 来进行内存映射：'
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In `grallo_map`, if the file descriptor in `private_handle_t` is a framebuffer
    device, we don't have to do the mapping again, since the framebuffer is initialized
    and mapped to the `SurfaceFlinger` address space in `fb_device_open`, as we analyzed
    before.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `grallo_map` 中，如果 `private_handle_t` 中的文件描述符是帧缓冲设备，我们不需要再次进行映射，因为帧缓冲已经在 `fb_device_open`
    中初始化并映射到 `SurfaceFlinger` 地址空间，正如我们之前分析的。
- en: If it is a shared memory region, it needs to be mapped to the current process
    address space using the `mmap` system function.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是一个共享内存区域，需要使用 `mmap` 系统函数将其映射到当前进程的地址空间。
- en: Releasing graphic buffers
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 释放图形缓冲区
- en: As we mentioned previously, the Gralloc module can be used to allocate and release
    graphic buffers. Now that we have learnt how to allocate buffers from framebuffer
    devices or system memory, let's have a look at how to release graphic buffers.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，Gralloc 模块可以用来分配和释放图形缓冲区。现在我们已经学会了如何从帧缓冲设备或系统内存分配缓冲区，让我们看看如何释放图形缓冲区。
- en: 'To release graphic buffers, the `gralloc_free` function is used:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要释放图形缓冲区，使用 `gralloc_free` 函数：
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: To release a graphic buffer, the buffer is described using `buffer_handle_t`.
    `gralloc_free` will validate the buffer first using the `private_handle_t::validate`
    static function.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要释放一个图形缓冲区，使用 `buffer_handle_t` 描述缓冲区。`gralloc_free` 将首先使用 `private_handle_t::validate`
    静态函数验证缓冲区。
- en: The `handle` parameter can be cast to a pointer of `private_handle_t` as we
    recall from the discussion on `private_handle_t` and `native_handle` previously.
    If the `flags` field of `hnd` is `PRIV_FLAGS_FRAMEBUFFER`, it means the buffer
    is allocated from the framebuffer device. It will update `bufferMask` to release
    it from the framebuffer.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`handle` 参数可以转换为 `private_handle_t` 的指针，正如我们从之前关于 `private_handle_t` 和 `native_handle`
    的讨论中回忆的那样。如果 `hnd` 的 `flags` 字段是 `PRIV_FLAGS_FRAMEBUFFER`，这意味着缓冲区是从帧缓冲设备分配的。它将更新
    `bufferMask` 以从帧缓冲中释放它。'
- en: 'If the buffer is allocated from system memory, it will call the `terminateBuffer`
    function to release the memory:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果缓冲区是从系统内存分配的，它将调用 `terminateBuffer` 函数来释放内存：
- en: '[PRE31]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `terminateBuffer` function calls to another function, `gralloc_unmap`,
    to release the memory:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`terminateBuffer` 函数调用另一个函数 `gralloc_unmap` 来释放内存：'
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In `gralloc_unmap`, again, it checks that this buffer is not from the framebuffer
    and it calls the `munmap` system function to release it.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `gralloc_unmap` 中，它再次检查这个缓冲区不是来自帧缓冲，并调用 `munmap` 系统函数来释放它。
- en: Rendering framebuffer
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染帧缓冲
- en: 'As we discussed previously in this chapter, the Gralloc module can support
    two kinds of device: Gralloc devices and framebuffer devices. In the `open` method
    of the Gralloc device, it creates a device named `GRALLOC_HARDWARE_GPU0` and supports
    two methods, `alloc` and `free`, as we can see in the following snippet. We have
    discussed both methods in detail earlier in this chapter:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章前面讨论的那样，Gralloc 模块可以支持两种类型的设备：Gralloc 设备和帧缓冲设备。在 Gralloc 设备的 `open` 方法中，它创建一个名为
    `GRALLOC_HARDWARE_GPU0` 的设备，并支持两种方法，`alloc` 和 `free`，正如我们可以在下面的代码片段中看到的那样。我们已经在本章前面详细讨论了这两种方法：
- en: '[PRE33]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the `open` method of the framebuffer device, it creates a device named `GRALLOC_HARDWARE_FB0`
    and supports four methods `close`, `setSwapInterval`, `post`, and `setUpdateRect`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在帧缓冲设备 `open` 方法中，它创建一个名为 `GRALLOC_HARDWARE_FB0` 的设备，并支持四种方法 `close`、`setSwapInterval`、`post`
    和 `setUpdateRect`：
- en: '[PRE34]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You can refer to the AOSP source code or the following URL for information
    about the implementation of these methods:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考 AOSP 源代码或以下 URL 获取有关这些方法实现的信息：
- en: '[http://xref.opersys.com/android-7.0.0_r1/xref/hardware/libhardware/modules/gralloc/framebuffer.cpp](http://xref.opersys.com/android-7.0.0_r1/xref/hardware/libhardware/modules/gralloc/framebuffer.cpp)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://xref.opersys.com/android-7.0.0_r1/xref/hardware/libhardware/modules/gralloc/framebuffer.cpp](http://xref.opersys.com/android-7.0.0_r1/xref/hardware/libhardware/modules/gralloc/framebuffer.cpp)'
- en: 'Let''s look at the `post` method, which is implemented in `fb_post`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `post` 方法，它在 `fb_post` 中实现：
- en: '[PRE35]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: After an application has prepared the graphic buffer, it needs to post the buffer
    to the display so that users can see it on the screen. This `fb_post` function
    is used to display the graphic buffer to the screen. It takes two parameters,
    `dev` and `buffer`. The `dev` parameter is the pointer of an instance of the data
    structure of `framebuffer_device_t`, which was discussed previously (refer to
    the diagram about the relationship between `fb_context_t` and `framebuffer_device_t`).
    As per the previous discussion, `dev` can be cast to `ctx`, which is a pointer
    of `fb_context_t`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序准备完图形缓冲区后，它需要将缓冲区发布到显示，以便用户可以在屏幕上看到它。这个 `fb_post` 函数用于将图形缓冲区显示到屏幕上。它接受两个参数，`dev`
    和 `buffer`。`dev` 参数是 `framebuffer_device_t` 数据结构实例的指针，这之前已经讨论过（参考 `fb_context_t`
    和 `framebuffer_device_t` 之间关系的图）。根据之前的讨论，`dev` 可以转换为 `ctx`，它是 `fb_context_t` 指针。
- en: 'After we have an instance of the device, we can get the instance of the Gralloc
    module from it as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们获得设备实例后，我们可以按照以下方式从其中获取 Gralloc 模块的实例：
- en: '[PRE36]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Another parameter is `buffer` and it has a `buffer_handle_t` data type. It includes
    the buffer to be posted. As we discussed previously, it can be cast as a point
    of `private_handle_t` and it is stored in the `hnd` variable. This buffer can
    be a graphic buffer in system memory or it can be part of the framebuffer. Based
    on the value of the `hnd->flags` member variable, we can find out what kind of
    buffer it is.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个参数是 `buffer`，它具有 `buffer_handle_t` 数据类型。它包括要发布的缓冲区。正如我们之前讨论的，它可以转换为 `private_handle_t`
    的指针，并存储在 `hnd` 变量中。这个缓冲区可以是系统内存中的图形缓冲区，也可以是帧缓冲区的一部分。根据 `hnd->flags` 成员变量的值，我们可以确定它是哪种类型的缓冲区。
- en: 'If it is a buffer as part of the framebuffer, we need to activate it as the
    buffer for the display. This can be done using the framebuffer''s `ioctl` function.
    To call the `ioctl` function, we need a data structure of `fb_var_screeninfo`
    and this can be found in `m->info`. To swap the buffer in double buffering, we
    just need to set the vertical offset and activate it as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它是帧缓冲区的一部分，我们需要将其激活为显示的缓冲区。这可以通过使用帧缓冲区的 `ioctl` 函数来完成。要调用 `ioctl` 函数，我们需要一个
    `fb_var_screeninfo` 数据结构，这可以在 `m->info` 中找到。为了在双缓冲中交换缓冲区，我们只需设置垂直偏移并按照以下方式激活它：
- en: '[PRE37]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If it is a buffer allocated in system memory, we need to copy it to the framebuffer.
    In this case, it tries to lock both the graphic buffer and framebuffer first,
    and then it copies the graphic buffer using `memcpy`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它是在系统内存中分配的缓冲区，我们需要将其复制到帧缓冲区。在这种情况下，它首先尝试锁定图形缓冲区和帧缓冲区，然后使用 `memcpy` 复制图形缓冲区：
- en: '[PRE38]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Graphics HAL of the Android emulator
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android 模拟器的图形 HAL
- en: After we have analyzed the default Gralloc module implementation, we want to
    briefly look at another Gralloc module implementation so that we can compare how
    a Gralloc module should be implemented on varying Graphic hardware.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们分析了默认 Gralloc 模块实现之后，我们想简要地看看另一个 Gralloc 模块实现，以便我们可以比较在不同图形硬件上应该如何实现 Gralloc
    模块。
- en: The Gralloc module we will analyze in this section is the Gralloc module used
    by the Android emulator. The default Gralloc module `gralloc.default.so` only
    uses framebuffer devices and it doesn't use GPU. If the default Gralloc module
    is used, OpenGL support has to be implemented in the software layer. This is the
    case with VirtualBox for the time being, since there is no Mesa/DRM-compliant
    implementation in the VirtualBox host side for OpenGL. This doesn't mean VirtualBox
    doesn't support OpenGL. It does support OpenGL and 3D hardware acceleration, but
    the implementation is not compliant with the open source Mesa/DRM architecture.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中我们将要分析的 Gralloc 模块是 Android 模拟器使用的 Gralloc 模块。默认的 Gralloc 模块 `gralloc.default.so`
    只使用帧缓冲区设备，并且不使用 GPU。如果使用默认的 Gralloc 模块，OpenGL 支持必须在软件层中实现。目前的情况是 VirtualBox，因为
    VirtualBox 主机端没有 Mesa/DRM 兼容的 OpenGL 实现。这并不意味着 VirtualBox 不支持 OpenGL。它确实支持 OpenGL
    和 3D 硬件加速，但实现并不符合开源 Mesa/DRM 架构。
- en: 'If you are interested in this topic about OpenGL support on VirtualBox, you
    may read the following threads in the Android-x86 discussion group:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对关于 VirtualBox 上 OpenGL 支持的此主题感兴趣，您可以在 Android-x86 讨论组中阅读以下线程：
- en: '[https://groups.google.com/forum/?hl=en#!starred/android-x86/gZYx6oWx4LI](https://groups.google.com/forum/?hl=en#!starred/android-x86/gZYx6oWx4LI)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://groups.google.com/forum/?hl=en#!starred/android-x86/gZYx6oWx4LI](https://groups.google.com/forum/?hl=en#!starred/android-x86/gZYx6oWx4LI)'
- en: Overview of hardware GLES emulation
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 硬件 GLES 模拟概述
- en: '3D graphics support on Andriod emulator is implemented in different ways as
    follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Android 模拟器上的 3D 图形支持以不同的方式实现，如下所示：
- en: '`host`: This is the default mode. This is also called hardware GLES emulation.
    It uses specific translator libraries to convert guest EGL/GLES commands into
    host GL ones. This requires valid OpenGL drivers installed on the host machine.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`host`：这是默认模式。这也称为硬件 GLES 模拟。它使用特定的翻译库将客户机 EGL/GLES 命令转换为宿主 GL 命令。这需要在宿主机器上安装有效的
    OpenGL 驱动程序。'
- en: '`swiftshader`: This is a software library for high-performance graphics rendering
    on the CPU. It takes advantage of SIMD on modern CPUs to perform graphics rendering.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`swiftshader`：这是一个用于在 CPU 上进行高性能图形渲染的软件库。它利用现代 CPU 上的 SIMD 来执行图形渲染。'
- en: '`mesa`: This is deprecated. It is a software library using the Mesa3D library.
    It is slower than swiftshader mode, and slower than the `host` mode by a large
    margin.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mesa`：这已被弃用。这是一个使用 Mesa3D 库的软件库。它的速度比 swiftshader 模式慢，并且比 `host` 模式慢得多。'
- en: '`guest`: This is a pure software implementation on the guest side.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`guest`：这是在客户机侧的纯软件实现。'
- en: 'To choose a graphic mode in the emulator, you can either specify it on the
    command line with the `-gpu` option or define it in the `config.ini` configuration
    file as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟器中选择图形模式，您可以通过命令行使用 `-gpu` 选项指定，或者在 `config.ini` 配置文件中定义，如下所示：
- en: '[PRE39]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We will look at the Gralloc module implementation in the `host` mode here.
    In the hardware GLES emulation, there are several host "translator" libraries
    implemented: EGL, GLES 1.1, and GLES 2.0 ABIs (Application Binary Interface) defined
    by Khronos. These libraries translate the corresponding function calls into calls
    to the appropriate host OpenGL APIs.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在此处查看 `host` 模式下的 Gralloc 模块实现。在硬件 GLES 模拟中，实现了几个宿主“翻译”库：EGL、GLES 1.1 和 Khronos
    定义的 GLES 2.0 ABIs（应用程序二进制接口）。这些库将相应的函数调用转换为调用适当的宿主 OpenGL API。
- en: There are the same set of system libraries implemented inside the emulated guest
    system for EGL, GLES 1.1, and GLES 2.0 ABIs. They collect the sequence of EGL/GLES
    function calls and translate them into a custom wire protocol stream that is sent
    to the emulator program through a high-speed communication channel called a "QEMU
    pipe." The pipe is implemented with a custom kernel driver and it can provide
    a very fast channel for communication between the host and the guest system. I
    have given a brief introduction about the QEMU pipe in [Chapter 3](e0f861c2-5832-402f-89d3-cfc75785e759.xhtml),
    *Discovering Kernel, HAL, and Virtual Hardware* and you can refer to it for more
    information.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟的客机系统中实现了用于 EGL、GLES 1.1 和 GLES 2.0 ABIs 的相同系统库集合。它们收集 EGL/GLES 函数调用的序列，并将它们转换为发送到模拟器程序的定制线协议流，该流通过称为“QEMU
    管道”的高速通信通道发送。管道使用定制的内核驱动程序实现，它可以提供主机和客机系统之间非常快速的通信通道。我在[第 3 章](e0f861c2-5832-402f-89d3-cfc75785e759.xhtml)“发现内核、HAL
    和虚拟硬件”中简要介绍了 QEMU 管道，您可以参考它以获取更多信息。
- en: '![](img/image_10_006.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_10_006.png)'
- en: Hardware GLES emulation
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件 GLES 模拟
- en: You can find the preceding diagram in the emulator source code at `$AOSP/external/qemu/distrib/android-emugl/DESIGN`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在模拟器源代码的 `$AOSP/external/qemu/distrib/android-emugl/DESIGN` 中找到前面的图表。
- en: 'The emulator source code is not downloaded using the manifest file in this
    chapter. You can refer to the following URL:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，不会使用 manifest 文件下载模拟器源代码。您可以参考以下 URL：
- en: '[https://android.googlesource.com/platform/external/qemu/+/master/distrib/android-emugl/DESIGN](https://android.googlesource.com/platform/external/qemu/+/master/distrib/android-emugl/DESIGN)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://android.googlesource.com/platform/external/qemu/+/master/distrib/android-emugl/DESIGN](https://android.googlesource.com/platform/external/qemu/+/master/distrib/android-emugl/DESIGN)'
- en: 'Or you can get the entire repository using the following command:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用以下命令获取整个仓库：
- en: '[PRE40]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The preceding diagram shows components on both the host (emulator) side and
    the guest side for the GLES emulation. We may treat the host side implementation
    as GPU, and **QEMU PIPE** is the connection between GPU and CPU. There are two
    things that need to access GPU for 3D graphics acceleration: the Gralloc module
    and the vendor library. The vendor library here refers to the hardware GLES emulation
    library for Android emulator. The Gralloc module is the one that we want to explore
    in this section.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图示显示了GLES仿真的主机（模拟器）端和客户机端的组件。我们可以将主机端实现视为GPU，**QEMU PIPE**是GPU和CPU之间的连接。需要访问GPU进行3D图形加速的两个东西是Gralloc模块和供应商库。这里的供应商库是指Android模拟器的硬件GLES仿真库。Gralloc模块是我们本节想要探索的模块。
- en: 'The GLES hardware emulation Gralloc module is very similar to the default Gralloc
    module that we have discussed in this chapter. It needs to implement the following
    three HAL data structures:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: GLES硬件仿真Gralloc模块与我们本章中讨论的默认Gralloc模块非常相似。它需要实现以下三个HAL数据结构：
- en: '[PRE41]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: For the first data structure, `hw_module_t`, both Gralloc modules have their
    own implementation called `private_module_t`, which is inherited from `hw_module_t`,
    but the definitions are different, as we can see in the following snippet.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个数据结构，`hw_module_t`，两个Gralloc模块都有自己的实现，称为`private_module_t`，它继承自`hw_module_t`，但定义不同，如下面的代码片段所示。
- en: 'The `private_module_t` in the default Gralloc module is as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 默认Gralloc模块中的`private_module_t`如下：
- en: '[PRE42]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `private_module_t` in the GLES emulation Gralloc module is as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: GLES仿真Gralloc模块中的`private_module_t`如下：
- en: '[PRE43]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'For the `hw_device_t` data structure implementation, we can get the details
    from the following table. We can create two kinds of devices, `GPU0` and `FB0`,
    using the `open` method in the `hw_module_methods_t` data structure. In both implementations,
    data structures inherited from `hw_device_t` are used:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`hw_device_t`数据结构实现，我们可以从以下表格中获取详细信息。我们可以使用`hw_module_methods_t`数据结构中的`open`方法创建两种设备，`GPU0`和`FB0`。在这两种实现中，都使用了从`hw_device_t`继承的数据结构：
- en: '| **hw_device_t in** **Gralloc module** | **GPU0** | **FB0** |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| **Gralloc模块中的** **hw_device_t** | **GPU0** | **FB0** |'
- en: '| Android emulator | `gralloc_device_t` | `fb_device_t` |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| Android 模拟器 | `gralloc_device_t` | `fb_device_t` |'
- en: '| Default Gralloc | `gralloc_context_t` | `fb_context_t` |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| 默认Gralloc | `gralloc_context_t` | `fb_context_t` |'
- en: 'We have analyzed both `gralloc_context_t` and `fb_context_t` in the *Initializing
    GPU* section. We can look at the definitions of `gralloc_device_t` and `fb_device_t`
    in the following GLES emulation implementation:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*初始化GPU*部分分析了`gralloc_context_t`和`fb_context_t`。我们可以在以下GLES仿真实现中查看`gralloc_device_t`和`fb_device_t`的定义：
- en: '[PRE44]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Initializing GPU0 and FB0 in GLES emulation
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化GLES仿真的GPU0和FB0
- en: 'As we know, device initialization is done in the `open` method defined in the
    `hw_module_methods_t` data structure. Let''s look at the implementation of the
    `open` method in GLES emulation. It is implemented in the `gralloc_device_open`
    function, as we can see in the following snippet:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，设备初始化是在`hw_module_methods_t`数据结构中定义的`open`方法中完成的。让我们看看GLES仿真的`open`方法的实现。它是在`gralloc_device_open`函数中实现的，如下面的代码片段所示：
- en: '[PRE45]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The preceding code snippet is part of the `GPU0` initialization. Before it creates
    the devices for `GPU0` or `FB0`, it will call a `fallback_init` function to check
    the system settings for hardware emulation. In `fallback_init`, it will check
    a `ro.kernel.qemu.gles` system property. If this property is set to 0, the GPU
    emulation will be disabled. The default Gralloc module will be used. In this case,
    the `open` method defined in the default Gralloc module, `sFallback`, will be
    called.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段是`GPU0`初始化的一部分。在它为`GPU0`或`FB0`创建设备之前，它将调用一个`fallback_init`函数来检查系统设置中的硬件仿真。在`fallback_init`中，它将检查一个`ro.kernel.qemu.gles`系统属性。如果这个属性设置为0，则GPU仿真将被禁用。将使用默认的Gralloc模块。在这种情况下，默认Gralloc模块中定义的`open`方法，即`sFallback`，将被调用。
- en: For the `GPU0` initialization, it will check whether the device name is equal
    to `GRALLOC_HARDWARE_GPU0` or not. If it is `GPU0`, it will get the host connection
    first. The host connection is the QEMU pipe link between the host and the guest
    system as we discussed before.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`GPU0`初始化，它将检查设备名称是否等于`GRALLOC_HARDWARE_GPU0`。如果是`GPU0`，它将首先获取主机连接。主机连接是我们之前讨论的主机和客户机系统之间的QEMU
    pipe链接。
- en: After that, it initializes the `GPU0` device as the initialization process that
    we discussed for the default Gralloc module.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，它初始化`GPU0`设备，就像我们为默认Gralloc模块讨论的初始化过程一样。
- en: 'Next, let''s have a look at the `FB0` initialization as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一下以下 `FB0` 的初始化：
- en: '[PRE46]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In the `FB0` initialization, it tries to get the host connection and an `rcEnc`
    pointer, which is an instance of the `renderControl_encoder_context_t` data structure,
    using the `DEFINE_AND_VALIDATE_HOST_CONNECTION` macro. With `rcEnc`, it can get
    the framebuffer attributes (`width`, `height`, `xdpi`, `ydpi`, `fps`, `min_si`,
    and `max_si`) from the host connection. After that, it creates an instance of
    the `fb_device_t` data structure and fills in the framebuffer attributes in this
    instance of `fb_device_t`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `FB0` 初始化中，它尝试使用 `DEFINE_AND_VALIDATE_HOST_CONNECTION` 宏获取主机连接和一个 `rcEnc`
    指针，这是一个 `renderControl_encoder_context_t` 数据结构的实例。有了 `rcEnc`，它可以从主机连接中获取帧缓冲区属性（`width`、`height`、`xdpi`、`ydpi`、`fps`、`min_si`
    和 `max_si`）。之后，它创建了一个 `fb_device_t` 数据结构的实例，并在该实例中填写了帧缓冲区属性。
- en: GPU0 device implementation
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GPU0 设备实现
- en: 'As we did for the default Gralloc module, we will analyze the `alloc` and `free`
    methods in the `GPU0` device. The `alloc` method is implemented in the `gralloc_alloc`
    function. The `gralloc_alloc` function is much longer than the one in the default
    Gralloc module, but it basically does three things:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在默认的 Gralloc 模块中所做的那样，我们将分析 `GPU0` 设备中的 `alloc` 和 `free` 方法。`alloc` 方法实现在
    `gralloc_alloc` 函数中。`gralloc_alloc` 函数比默认 Gralloc 模块中的函数要长得多，但它基本上做了三件事：
- en: Checks the `usage` parameter and decides the pixel format to decide the size
    of the pixel.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查 `usage` 参数并决定像素格式以确定像素的大小。
- en: According to the information provided by the `usage` parameter, `w`, `h`, `format`,
    and `usage` create a shared memory region and allocate buffers in the host side
    (GPU).
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据由 `usage` 参数提供的信息，`w`、`h`、`format` 和 `usage` 创建一个共享内存区域并在主机端（GPU）分配缓冲区。
- en: Stores both the shared memory region and host side (GPU) buffer information
    in the Gralloc device data structure `grdev`.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Gralloc 设备数据结构 `grdev` 中存储共享内存区域和主机端（GPU）缓冲区信息。
- en: 'Now let''s take a look at the code for `gralloc_alloc`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下 `gralloc_alloc` 的代码：
- en: '[PRE47]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In the preceding code of `gralloc_alloc`, it creates an instance of data structure
    `gralloc_device_t` first. After that, it checks the `usage` and `format` parameters
    to decide the size of the pixels and the corresponding GLES color format and pixel
    type to store in the `bpp`, `glFormat`, and `glType` variables. With the necessary
    information, it can calculate the size of the shared memory that needs to be allocated
    for the graphic buffer and stores it in the `ashmem_size` variable:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `gralloc_alloc` 的前面代码中，它首先创建了一个 `gralloc_device_t` 数据结构的实例。之后，它检查 `usage`
    和 `format` 参数以确定像素的大小以及相应的 GLES 颜色格式和像素类型，并将它们存储在 `bpp`、`glFormat` 和 `glType`
    变量中。有了必要的信息，它可以计算出需要为图形缓冲区分配的共享内存的大小，并将其存储在 `ashmem_size` 变量中：
- en: '[PRE48]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'As for the shared memory size `ashmem_size`, it allocates a shared memory region
    using the `ashmem_create_region` function and it obtains the shared memory region
    as an `fd` file descriptor. To store the shared memory region and the GPU buffer
    (the host side buffer), which we will discuss now, it creates an instance of the
    `cb_handle_t` data structure. If we recall, we used the `private_handle_t` data
    structure in the default Gralloc module to represent an allocated graphic buffer.
    Here, `cb_handle_t` is an equivalent of `private_handle_t`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 至于共享内存大小 `ashmem_size`，它使用 `ashmem_create_region` 函数分配一个共享内存区域，并获取共享内存区域作为一个
    `fd` 文件描述符。为了存储共享内存区域和 GPU 缓冲区（我们将讨论的主机端缓冲区），它创建了一个 `cb_handle_t` 数据结构的实例。如果我们回想一下，我们在默认的
    Gralloc 模块中使用了 `private_handle_t` 数据结构来表示分配的图形缓冲区。在这里，`cb_handle_t` 是 `private_handle_t`
    的等价物：
- en: '[PRE49]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Because `cb_handle_t` is a large data structure, in the preceding code snippet
    we did not show all the member functions of `cb_handle_t`. From the member variables,
    we can see that they are similar to `private_handle_t`. You can refer to the section
    on `private_handle_t` for an explanation of most member variables. Pay attention
    to the last member variable, `hostHandle`, which is used to store the buffer allocated
    on GPU (the host side in GLES emulation). If you are interested in host side GLES
    emulation, you can refer to the QEMU source code.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `cb_handle_t` 是一个大型数据结构，所以在前面的代码片段中我们没有展示 `cb_handle_t` 的所有成员函数。从成员变量中我们可以看出，它们与
    `private_handle_t` 类似。您可以参考 `private_handle_t` 的部分来了解大多数成员变量的解释。请注意最后一个成员变量 `hostHandle`，它用于存储在
    GPU 上分配的缓冲区（在 GLES 模拟中的主机端）。如果您对主机端 GLES 模拟感兴趣，可以参考 QEMU 源代码。
- en: 'Let''s look at the last piece of code for `gralloc_alloc`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下 `gralloc_alloc` 的最后一部分代码：
- en: '[PRE50]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: After the buffer is allocated on GPU and the shared memory region is acquired
    from the system memory, they are stored in the `grdev` variable and added to a
    linked list node to the double linked list in `gralloc_device_t`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在缓冲区在GPU上分配并且从系统内存中获取共享内存区域后，它们被存储在`grdev`变量中，并添加到`gralloc_device_t`中的双链表节点。
- en: 'For the `free` method of `gralloc_device_t`, it is much simpler than `alloc`.
    To save space, I won''t list the source code here. The `free` method is implemented
    in the `gralloc_free` function. What it does is:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`gralloc_device_t`的`free`方法，它比`alloc`简单得多。为了节省空间，这里不会列出源代码。`free`方法是在`gralloc_free`函数中实现的。它所做的是：
- en: Validate the `buffer_handle_t` point to a valid `cb_handle_t` data structure.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证`buffer_handle_t`指向有效的`cb_handle_t`数据结构。
- en: Release the buffer on the host side (GPU), calling the `rcCloseColorBuffer`
    function.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主机端（GPU）释放缓冲区，调用`rcCloseColorBuffer`函数。
- en: Un-map the buffer in the shared memory region and release the shared memory.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在共享内存区域取消映射缓冲区并释放共享内存。
- en: Remove the node from the linked list.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从链表中移除节点。
- en: Free the memory used by the `cb_handle_t` data structure.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 释放`cb_handle_t`数据结构使用的内存。
- en: FB0 device implementation
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FB0设备实现
- en: 'For the implementation of the `FB0` device, we will look at the `post` method
    as we did for the default Gralloc module analysis. This is implemented in the
    `fb_post` function and we can look at the implementation as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`FB0`设备的实现，我们将像分析默认的Gralloc模块那样查看`post`方法。这是在`fb_post`函数中实现的，我们可以如下查看其实现：
- en: '[PRE51]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: What it does is very simple; it increases the post count of the buffer and calls
    to the `rcFBpost` function to update the buffer in GPU.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 它所做的是非常简单的；它增加缓冲区的post计数，并调用`rcFBpost`函数来更新GPU中的缓冲区。
- en: We have completed our analysis of Android emulator graphics HAL now. I hope
    the analysis of the generic graphics HAL and Android emulator graphics HAL has
    helped you understand the graphics HAL in your system.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了对Android模拟器图形HAL的分析。希望对通用图形HAL和Android模拟器图形HAL的分析能帮助你理解你系统中的图形HAL。
- en: Summary
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored and reviewed two Gralloc HAL module implementations,
    the default Gralloc module and the one used by Android emulator. The default Gralloc
    HAL uses framebuffer devices only and the OpenGLES support uses a software implementation.
    The one used by Android emulator is a hardware emulation on the host side. The
    implementation is similar to the GPU-based Gralloc module.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了并回顾了两个Gralloc HAL模块的实现，即默认的Gralloc模块和Android模拟器使用的模块。默认的Gralloc HAL仅使用帧缓冲设备，而OpenGLES支持使用软件实现。Android模拟器使用的是主机端的硬件仿真。其实现与基于GPU的Gralloc模块类似。
- en: Since graphics systems are so complex, we will continue exploring this topic
    a little more when looking at VirtualBox-specific implementation in the next chapter.
    We will explain the loading process of Gralloc HAL and OpenGL ES libraries. We
    will build a VirtualBox extension pack for Android so that we can utilize the
    capability provided by VirtualBox.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 由于图形系统非常复杂，我们将在下一章查看VirtualBox特定实现时，继续更深入地探讨这个主题。我们将解释Gralloc HAL和OpenGL ES库的加载过程。我们将为Android构建一个VirtualBox扩展包，以便我们可以利用VirtualBox提供的功能。
