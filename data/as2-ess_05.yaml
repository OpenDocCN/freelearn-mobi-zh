- en: Chapter 5. Creating User Interfaces
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 创建用户界面
- en: Now that we created our first project and have become familiar with the code
    editor and its functionalities, we will begin our application by creating our
    user interface. Is there more than one way to create a user interface using Android
    Studio? How can you add components to your user interface? Have you ever wondered
    how to make your applications support different screen sizes and resolutions?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了第一个项目，并且熟悉了代码编辑器和其功能，我们将通过创建用户界面来开始我们的应用程序。在Android Studio中创建用户界面有不止一种方法吗？你如何向用户界面添加组件？你是否曾经想过如何让你的应用程序支持不同的屏幕尺寸和分辨率？
- en: This chapter focuses on the creation of the user interfaces using layouts. Layouts
    can be created using a graphical view or a text-based view. You will learn how
    to use both of them to create your layout. We will also code a `Hello World` application
    using simple components. Since there are over 18,000 Android device types, you
    will learn about fragmentation on different screen types and we will discuss how
    to prepare our application for this issue. We will end this chapter with basic
    notions of handling events in our application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍使用布局创建用户界面。布局可以通过图形视图或基于文本的视图创建。你将学习如何使用这两种方式来创建你的布局。我们还将使用简单的组件编写一个`Hello
    World`应用程序。由于有超过18,000种Android设备类型，你将了解不同屏幕类型上的碎片化问题，我们将讨论如何为这个问题准备我们的应用程序。我们将以处理我们应用程序中的事件的基本概念结束本章。
- en: 'These are the topics we''ll be covering in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Existing layout editors
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有的布局编辑器
- en: Creating a new layout
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新布局
- en: Adding components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加组件
- en: Supporting different screens
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持不同屏幕
- en: Changing the UI theme
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改UI主题
- en: Handling events
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理事件
- en: The graphical editor
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图形编辑器
- en: 'Open the main layout located at `/src/main/res/layout/activity_main.xml` in
    our project. The graphical editor will be opened by default. The center panel
    of the graphical editor is the **Preview**, where you can examine what your layout
    looks like. From the **Preview** you can see that initially this main layout contains
    just a text view with a **Hello World!** message. To switch between the graphical
    and text editors, click on the **Design** and **Text** tabs at the bottom of the
    screen, as shown in the screenshot:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中打开位于 `/src/main/res/layout/activity_main.xml` 的主布局。图形编辑器将默认打开。图形编辑器的中心面板是**预览**，在这里你可以查看你的布局看起来如何。从**预览**中你可以看到，最初这个主布局只包含一个带有**Hello
    World!**信息的文本视图。要切换图形和文本编辑器，请点击屏幕底部的**设计**和**文本**标签，如图所示：
- en: '![The graphical editor](img/B05459_05_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图形编辑器](img/B05459_05_01.jpg)'
- en: 'The **Toolbar** options contains some options that can be used to change the
    layout style and preview. The **Toolbar** options, which are shown in the following
    screenshot, are explained throughout the chapter:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**工具栏**选项包含一些可以用来更改布局样式和预览的选项。以下截图所示的**工具栏**选项将在本章中解释：'
- en: '![The graphical editor](img/B05459_05_02.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图形编辑器](img/B05459_05_02.jpg)'
- en: 'The **Component Tree** panel displays the components placed in the layout as
    a hierarchy. There are two components in our layout: a **RelativeLayout** as the
    root element, and a **TextView** which is the one displaying the **Hello World!**
    message. When you select one element on the **Component Tree** panel, the element
    is highlighted in **Preview**, and its properties are listed in the **Properties**
    inspector panel. It shows the properties of the selected component from the layout
    and allows us to change them. **Palette** lists the existing **user interface**
    (**UI**) components to place in our layout. It organizes the components in different
    categories. Let''s look at the options available in **Components Palette**:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**组件树**面板显示了布局中放置的组件作为层次结构。在我们的布局中有两个组件：一个作为根元素的**RelativeLayout**，以及一个显示**Hello
    World!**信息的**TextView**。当你选择**组件树**面板上的一个元素时，该元素在**预览**中突出显示，其属性列在**属性**检查器面板中。它显示了从布局中选择的组件的属性，并允许我们更改它们。**调色板**列出了可以放置在我们布局中的现有**用户界面**（**UI**）组件。它将组件组织在不同的类别中。让我们看看**组件调色板**中可用的选项：'
- en: '**Layouts**: A layout is a container object used to distribute the components
    on the screen. The root element of UI is a layout object, but layouts can also
    contain more layouts, creating a hierarchy of components structured in layouts.
    The recommendation is to keep this layout hierarchy as simple as possible. Our
    main layout has **RelativeLayout** as a root element.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**布局**: 布局是一个容器对象，用于在屏幕上分布组件。UI的根元素是一个布局对象，但布局也可以包含更多的布局，从而创建一个由布局结构化的组件层次结构。建议尽可能保持此布局层次结构简单。我们的主布局以**RelativeLayout**作为根元素。'
- en: '**Widgets**: This category contains options for text views, buttons, checkboxes,
    switches, image views, progress bars, seek bars, rating bars, spinners, and web
    views. They are the most commonly used components, and they are used in most layouts.
    Our main layout contains **TextView** inside the root relative layout.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Widgets**: 这个类别包含文本视图、按钮、复选框、开关、图像视图、进度条、滑动条、评分条、旋转器和网页视图等选项。它们是最常用的组件，并且被用于大多数布局中。我们的主布局在根相对布局内包含**TextView**。'
- en: '**Text Fields**: These are editable fields that contain different categories
    of input under which users can type text. The difference between the various options
    is the type of text users can type.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本字段**: 这些是可以编辑的字段，用户可以在其中输入不同类别的文本。不同选项之间的区别在于用户可以输入的文本类型。'
- en: '**Containers**: This category groups components that share a common behavior.
    Radio groups, list views, grid views, scroll views, and tab hosts are some of
    them.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器**: 这个类别将具有共同行为的组件分组。单选按钮组、列表视图、网格视图、滚动视图和标签宿主是一些例子。'
- en: '**Date & Time**: This category holds components related to date and time in
    the form of calendars or clocks.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日期和时间**: 这个类别包含以日历或时钟形式相关的日期和时间组件。'
- en: '**Expert**: The components in this category are not as common as the components
    in the **Widgets** category, but it is worth taking a look at them.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**专家**: 这个类别中的组件不如**Widgets**类别中的组件常见，但值得一看。'
- en: '**Custom**: This category holds components that allow us to include our custom
    components, which are usually other layouts from our project.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义**: 这个类别包含允许我们包含自定义组件的组件，这些组件通常是我们的项目中的其他布局。'
- en: The text-based editor
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于文本的编辑器
- en: 'Change the graphical editor to the text editor by clicking on the **Text**
    tab:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击**文本**选项卡将图形编辑器更改为文本编辑器：
- en: '![The text-based editor](img/B05459_05_03.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![基于文本的编辑器](img/B05459_05_03.jpg)'
- en: 'The **Toolbar** panel is the same as that on the graphical editor. The **Preview**
    window displays the layout, but it cannot be changed. To do that, you should use
    the **Design** tab instead. The components are added to the layout using their
    XML declarations. The properties are also configured using XML declarations. Like
    the graphical editor, the text editor contains two XML elements: a relative layout
    as the root element and the text view element inside the root layout.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**工具栏**面板与图形编辑器上的相同。**预览**窗口显示布局，但不能更改。要更改，您应该使用**设计**选项卡。组件是通过它们的XML声明添加到布局中的。属性也是通过XML声明配置的。与图形编辑器一样，文本编辑器包含两个XML元素：作为根元素的相对布局和根布局内的文本视图元素。'
- en: 'The XML tag names define the type of component that we are declaring. For the
    relative layout, we use the `RelativeLayout` tag, and for the text view, we use
    the `TextView` tag. We can add properties to the elements by including attributes
    in the XML tags. For example, the text view in our main layout has three properties:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: XML标签名称定义了我们声明的组件类型。对于相对布局，我们使用`RelativeLayout`标签，对于文本视图，我们使用`TextView`标签。我们可以通过在XML标签中包含属性来向元素添加属性。例如，我们主布局中的文本视图有三个属性：
- en: '`android:layout_width`, with the `wrap_content` value: This property sets the
    element width inside its parent element. The `wrap_content` value means that the
    element''s width will be determined by the width of its content. The other default
    value that you can set for this property is `match_parent`, which means that the
    element will have the same width as its parent element.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:layout_width`，`wrap_content`值：此属性设置元素在其父元素内部的高度。`wrap_content`值意味着元素的高度将由其内容宽度决定。您可以为此属性设置的另一个默认值是`match_parent`，这意味着元素将具有与其父元素相同的宽度。'
- en: '`android:layout_height`, the `wrap_content` value: This property sets the element
    height inside its parent element. The values behave the same way as the width.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:layout_height`，`wrap_content`值：此属性设置元素在其父元素内部的高度。值的行为与宽度相同。'
- en: '`android:text`, with the `Hello World!` value: This property sets the text
    to be displayed in the text view.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:text`，值为`Hello World!`：此属性设置要在文本视图中显示的文本。'
- en: Creating a new layout
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新布局
- en: When we created our main activity, the associated layout was also created. This
    is a way of creating a layout when creating an activity.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建主活动时，关联的布局也会被创建。这是在创建活动时创建布局的一种方式。
- en: 'To add an independent layout without creating a new activity, right-click on
    the `layout` folder (`res/layout/`) and navigate to **New** | **Layout resource
    file**. You can also create a layout file using the same right-click menu by navigating
    to the **New** | **XML** | **Layout XML file**. You can also navigate to these
    two options using the top **File** menu. The following dialog from the next screenshot
    will be displayed to configure the new layout component:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加一个不创建新活动的独立布局，在`layout`文件夹（`res/layout/`）上右键单击，然后导航到**新建** | **布局资源文件**。你还可以使用相同的右键菜单通过导航到**新建**
    | **XML** | **布局XML文件**来创建布局文件。你还可以使用顶部的**文件**菜单导航到这两个选项。下一个截图将显示以下对话框以配置新的布局组件：
- en: '![Creating a new layout](img/B05459_05_04.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![创建新布局](img/B05459_05_04.jpg)'
- en: 'Type the **Layout File Name** and the **Root Tag**. The root element of our
    main layout was a relative layout, but you can select a different root tag. There
    are five types of layout:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 输入**布局文件名**和**根标签**。我们主布局的根元素是一个相对布局，但你可以选择不同的根标签。布局有五种类型：
- en: '**FrameLayout**: This layout displays usually only one child in an arranged
    area of the screen. If more than one child is added, then the views are displayed
    in a stack.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FrameLayout**：这种布局通常在屏幕的一个安排区域内只显示一个子组件。如果添加了多个子组件，则视图将堆叠显示。'
- en: '**LinearLayout**: This layout displays its children by aligning them, one after
    other, in one direction. There are two types of linear layouts: vertical and horizontal,
    which are identified by the `android:orientation` property of the layout.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LinearLayout**：这种布局通过将子组件一个接一个地排列在一个方向上来显示其子组件。线性布局有两种类型：垂直和水平，这由布局的`android:orientation`属性来识别。'
- en: '**TableLayout**: This layout displays its children by distributing them in
    rows and columns. Along with the table layout, you need to use the **TableRow**
    element to create the distribution in rows and columns.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TableLayout**：这种布局通过在行和列中分配子组件来显示其子组件。除了表格布局外，还需要使用**TableRow**元素来创建行和列的分配。'
- en: '**GridLayout**: This layout displays its children in a rectangular grid. Children
    can fill more than one cell using properties such as `rowSpec` and `columnSpec`.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GridLayout**：这种布局通过在矩形网格中显示其子组件。子组件可以使用`rowSpec`和`columnSpec`等属性填充多个单元格。'
- en: '**RelativeLayout**: This layout displays its children by the relative positions
    between them. You have to use the position properties in the children''s views
    to determine their position. At least one child view needs to have a position
    property relative to the parent view, so that child view, and the ones relative
    to it, can be positioned inside the parent layout. Some of these properties are
    `android:layout_below`, `android:layout_toLeftOf`, or `android:layout_alignBottom`.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RelativeLayout**：这种布局通过子组件之间的相对位置来显示其子组件。你必须使用子视图中的位置属性来确定它们的位置。至少需要一个子视图具有相对于父视图的位置属性，这样该子视图以及相对于它的视图就可以在父布局内定位。这些属性中的一些是`android:layout_below`、`android:layout_toLeftOf`或`android:layout_alignBottom`。'
- en: 'Once the layout is created, the associated activity can be changed to a different
    activity using the editor. If the layout has no activity, any existing one can
    be linked to it from the editor. To accomplish this, search for the **Associate
    with Activity** option in the toolbar of the layout editor, click on it, and select
    the **Associate with other Activity** option, as shown in the following screenshot:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了布局，可以使用编辑器将其关联的活动更改为不同的活动。如果布局没有活动，任何现有的活动都可以从编辑器中链接到它。要完成此操作，在布局编辑器的工具栏中搜索**关联活动**选项，点击它，然后选择**关联到其他活动**选项，如图所示：
- en: '![Creating a new layout](img/B05459_05_05.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![创建新布局](img/B05459_05_05.jpg)'
- en: A dialog box that lists all the activities of your project will open, and you
    can select one of them.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 将打开一个对话框，列出你项目的所有活动，你可以从中选择一个。
- en: Adding components
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加组件
- en: Our main layout is a relative layout and contains a text view saying **Hello
    World!**. Now let's add a new component. The easiest way to do this is using the
    graphical editor, so open the **Design** tab. Select a component and drag it into
    the layout preview; for example, navigate to the **Person Name** component in
    **Text Fields** and place it below the text view.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主要布局是一个相对布局，包含一个显示**Hello World!**的文本视图。现在让我们添加一个新的组件。最简单的方法是使用图形编辑器，所以打开**设计**选项卡。选择一个组件并将其拖动到布局预览中；例如，导航到**文本字段**中的**姓名**组件，并将其放置在文本视图下方。
- en: Since our root layout is a relative layout, as you drag the element in the layout,
    some line guides are displayed. The properties related to the position are also
    shown in the top part of the **Preview** as you try to drag and drop the element
    in the layout. These lines and suggested properties, which are shown in the following
    screenshot, can help you properly align the element in your screen. They also
    help you to set the element position relative to the rest of the elements that
    are already in the layout.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的根布局是相对布局，当你拖动布局中的元素时，会显示一些参考线。当你尝试在布局中拖放元素时，与位置相关的属性也会在**预览**的顶部部分显示。以下截图中的这些线和建议的属性可以帮助你正确地对齐屏幕上的元素。它们还有助于你设置元素相对于布局中已存在的其他元素的位置。
- en: '![Adding components](img/B05459_05_06.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![添加组件](img/B05459_05_06.jpg)'
- en: The properties suggested in the **Preview** panel from the previous screenshot
    align the text field to the left of the parent element (**alignParentLeft**),
    set the text field position below the **Hello World!** text view (**below=textView**),
    and add a margin to the text view of 38 dp (**margin=38 dp**).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 上一截图中的**预览**面板中建议的属性将文本字段对齐到父元素的左侧（**alignParentLeft**），将文本字段的位置设置为在**Hello
    World!**文本视图下方（**below=textView**），并为文本视图添加38 dp的边距（**margin=38 dp**）。
- en: 'In the **Component Tree** view, there is now a new `editText` object. Keep
    the text field selected to examine its properties loaded in the **Properties**
    inspector. Let''s change some of them and observe the differences in the layout
    preview and in **Component Tree**:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在**组件树**视图中，现在有一个新的`editText`对象。保持文本字段选中状态，以检查在**属性**检查器中加载的属性。让我们更改其中一些属性，并观察布局预览和**组件树**中的差异：
- en: '**layout:width**: This option will adapt the width of the field to its content.
    Its current value is `wrap_content`. Change it to `match_parent` to adapt it to
    the parent layout width (the root relative layout).'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**layout:width**：此选项将使字段的宽度适应其内容。其当前值是`wrap_content`。将其更改为`match_parent`以适应父布局的宽度（根相对布局）。'
- en: '**hint**: Type `Enter your name` as the hint of the field. The hint is a text
    shown when the field is empty to indicate the information that should be typed.
    As the field has a default value, `Name`, the hint is not visible.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提示**：将字段的提示信息设置为`Enter your name`。当字段为空时，提示信息会显示出来，以指示应输入的信息。由于字段有一个默认值`Name`，所以提示信息是不可见的。'
- en: '**id**: This has `@+id/editText` as the current ID. The ID will be used from
    the code to get access to this object and is the ID displayed in the component
    tree. This ID can also be used by other elements in the layout to determine their
    relative position to it. Change it to `@+id/editText_name` to distinguish it easily
    from other text fields. Check whether the component ID has also changed in the
    **Component Tree** window, as shown in the following screenshot:![Adding components](img/B05459_05_07.jpg)'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**id**：当前的ID是`@+id/editText`。ID将在代码中使用以获取对对象的访问权限，并在组件树中显示。此ID也可以由布局中的其他元素使用，以确定它们相对于它的相对位置。将其更改为`@+id/editText_name`以方便地从其他文本字段中区分它。检查**组件树**窗口中组件ID是否也已更改，如下面的截图所示：![添加组件](img/B05459_05_07.jpg)'
- en: '**text**: This deletes the value of this field. The hint should now be visible.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**text**：这将删除此字段的值。现在应该可以看到提示信息。'
- en: 'If we switch to the text editor, we can see the XML definition of the text
    field with the properties we edited:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们切换到文本编辑器，我们可以看到我们编辑过的文本字段的XML定义：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There is a recommended order for the properties of the XML definitions. Having
    a specific order helps to understand the code when reading it and makes it easier
    to modify the elements. Select the `EditText` code definition and execute the
    **Reformat Code** action in the **Code** menu. The properties order has now changed,
    placing the `android:id` at the first position:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: XML定义的属性有推荐的顺序。特定的顺序有助于在阅读代码时理解代码，并使修改元素更容易。选择`EditText`代码定义并执行**代码**菜单中的**格式化代码**操作。现在属性顺序已更改，将`android:id`放置在第一个位置：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can check the position properties (`android:layout_marginTop`, `android:layout_below`,
    and `android:layout_alignParentLeft`) that match the properties displayed in the
    graphical editor while you were dragging the edit text in the layout. Note that
    the `android:layout_below` property uses the ID of the text view to identify it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在布局中拖动编辑文本时，你可以检查与图形编辑器中显示的属性相匹配的位置属性（`android:layout_marginTop`、`android:layout_below`和`android:layout_alignParentLeft`）。请注意，`android:layout_below`属性使用文本视图的ID来识别它。
- en: From the text editor, the existing components and their properties can also
    be changed. Modify the text view ID (the `android:id` property) from `@+id/textView`
    to `@+id/textView_greeting`. Having a descriptive ID is important since it will
    be used by our code. Descriptive variable names allow the code to be self-documenting.
    You will need to change all the references to the text view ID to the new ID.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 从文本编辑器，也可以更改现有组件及其属性。将文本视图ID（`android:id`属性）从`@+id/textView`更改为`@+id/textView_greeting`。具有描述性的ID很重要，因为它将被我们的代码使用。描述性变量名允许代码自我说明。您需要将所有对文本视图ID的引用更改为新ID。
- en: 'Let''s add another component using the text editor this time. Press the **Open
    Tag** key and start typing `Button`. A list of suggestions will appear to help
    you with the code completion. Let the list of suggestions appear and select a
    `Button` object. Inside the `Button` tag, add the following properties:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们这次使用文本编辑器添加另一个组件。按**打开标签**键并开始键入`Button`。将出现一个建议列表，以帮助您完成代码。让建议列表出现并选择一个`Button`对象。在`Button`标签内，添加以下属性：
- en: '`android:id`, with the `@+id/button_accept` value: This creates the ID property.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:id`，值为`@+id/button_accept`：这创建了ID属性。'
- en: '`android:layout_width`, with the `wrap_content` value: This lets the width
    adapt to the button content.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:layout_width`，值为`wrap_content`：这使宽度适应按钮内容。'
- en: '`android:layout_height`, with the `wrap_content` value: This lets the height
    adapt to the button content.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:layout_height`，值为`wrap_content`：这使高度适应按钮内容。'
- en: '`android:layout_below`, with the `@id/editText_name` value: This places the
    button below the name text field. We reference the name text field by its ID (`@id/editText_name`).'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:layout_below`，值为`@id/editText_name`：这将在名称文本字段下方放置按钮。我们通过其ID（`@id/editText_name`）引用名称文本字段。'
- en: '`android:layout_centerHorizontal`, with the value `true`: This centers the
    button horizontally in the parent layout.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:layout_centerHorizontal`，值为`true`：这将在父布局中水平居中按钮。'
- en: '`android:text`, with the `Accept` value: This sets the text of the button.
    The recommended way to add a text to a component is by adding it to the `strings.xml`
    file. The component should be configured with the string identifier, instead of
    the string directly. For simplicity, we are adding the string directly to the
    button.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:text`，具有`Accept`值：这设置了按钮的文本。向组件添加文本的推荐方式是将它添加到`strings.xml`文件中。组件应配置为使用字符串标识符，而不是直接使用字符串。为了简单起见，我们直接将字符串添加到按钮中。'
- en: 'The final XML definition for the button is the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮的最终XML定义如下：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The button is displayed in **Preview**. The next screenshot shows that if we
    switch to the graphical editor, the button is displayed in it and also in **Component
    Tree**:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮在**预览**中显示。下一张截图显示，如果我们切换到图形编辑器，按钮将在其中显示，并在**组件树**中显示：
- en: '![Adding components](img/B05459_05_08.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![添加组件](img/B05459_05_08.jpg)'
- en: Component's properties
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件属性
- en: 'The properties that we added or modified in our main layout can also be modified
    by code, and not only using the layout editor. For example, if you have a `Button`
    object in your code, you can change its text using the `setText` method:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在主布局中添加或修改的属性也可以通过代码进行修改，而不仅仅是使用布局编辑器。例如，如果你在代码中有一个`Button`对象，你可以使用`setText`方法来更改其文本：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Some of the properties available for a `View` object are the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 可用于`View`对象的某些属性如下：
- en: '`android:alpha`: This XML property sets the alpha value of the view, between
    `0` and `1`, which represents the opacity of the view. You can also use the `setAlpha`
    method from code.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:alpha`: 这个XML属性设置视图的alpha值，介于`0`和`1`之间，表示视图的不透明度。您也可以使用代码中的`setAlpha`方法。'
- en: '`android:background`: This XML property sets the background of the view. You
    can also use the `setBackground` method from code.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:background`: 这个XML属性设置视图的背景。您也可以使用代码中的`setBackground`方法。'
- en: '`android:clickable`: This XML property sets whether the view is clickable or
    not, receiving the click events or not. You can also use the `setClicklable` method
    from code.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:clickable`: 这个XML属性设置视图是否可点击，是否接收点击事件。您也可以使用代码中的`setClicklable`方法。'
- en: '`android:elevation`: This XML property sets the elevation value of the view,
    its z depth value. You can also use the `setElevation` method from code.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:elevation`: 这个XML属性设置视图的抬升值，即其z深度值。您也可以使用代码中的`setElevation`方法。'
- en: '`android:fadeScrollbars`: This XML property sets whether the scroll bars fade
    out when they are not in use. You can also use the `setScrollbarFadingEnabled`
    method from code.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:fadeScrollbars`: 这个XML属性设置当滚动条未使用时是否淡出。您也可以使用代码中的`setScrollbarFadingEnabled`方法。'
- en: '`android:focusable`: This XML property sets whether the view can take the focus
    or not. You can also use the setFocusable method from code.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:focusable`: 这个XML属性设置视图是否可以获取焦点。您也可以使用代码中的`setFocusable`方法。'
- en: '`android:foreground`: This XML property sets the foreground of the view. You
    can also use the `setForeground` method from code.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:foreground`: 这个XML属性设置视图的前景。您也可以使用代码中的`setForeground`方法。'
- en: '`android:foregroundTint`: This XML property sets the tint color for the foreground
    of the view. You can also use the `setForegroundTintList` method from code.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:foregroundTint`: 这个XML属性设置视图前景的着色颜色。您也可以使用代码中的`setForegroundTintList`方法。'
- en: '`android:id`: This XML property sets the identifier of the view. You can also
    use the `setId` method from code.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:id`: 这个XML属性设置视图的标识符。您也可以使用代码中的`setId`方法。'
- en: '`android:minHeight`: This XML property sets the minimum height that the view
    should have. You can also use the `setMinimumHeight` method from code.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:minHeight`: 这个XML属性设置视图应具有的最小高度。您也可以使用代码中的`setMinimumHeight`方法。'
- en: '`android:minWidth`: This XML property sets the minimum width that the view
    should have. You can also use the `setWidth` method from code.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:minWidth`: 这个XML属性设置视图应具有的最小宽度。您也可以使用代码中的`setWidth`方法。'
- en: '`android:padding`: This XML property sets the padding for the four edges of
    the view. You can also use the `setPadding` method from code. Similar to this
    property are: `android:paddingBottom`, `android:paddingEnd`, `android:paddingLeft`,
    `android:paddingRight`, `android:paddingStart`, and `android:paddingTop`.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:padding`: 这个XML属性设置视图四边的填充。您也可以使用代码中的`setPadding`方法。与此属性类似的还有：`android:paddingBottom`、`android:paddingEnd`、`android:paddingLeft`、`android:paddingRight`、`android:paddingStart`和`android:paddingTop`。'
- en: '`android:scrollIndicators`: This XML property sets whether the scroll indicators
    are shown for the view. You can also use the `setScrollIndicators` method from
    code.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:scrollIndicators`: 这个XML属性设置是否为视图显示滚动指示器。您也可以使用代码中的`setScrollIndicators`方法。'
- en: '`android:textAlignment`: This XML property sets the alignment of the text in
    the view. You can also use the `setTextAlignment` method from code.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:textAlignment`: 这个XML属性设置视图中文本的对齐方式。您也可以使用代码中的`setTextAlignment`方法。'
- en: '`android:visibility`: This XML property sets whether the view is visible or
    not. You can also use the `setVisibility` method from code.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:visibility`: 这个XML属性设置视图是否可见。您也可以使用代码中的`setVisibility`方法。'
- en: 'In addition to the properties of a `View` object, `View` subclasses can provide
    some more specific properties. For example, the `TextView` objects also have these
    properties: `android:editable`, `android:fontFamily`, `android:hint`, `android:text`,
    or `android:textColor`.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`View`对象属性外，`View`子类还可以提供一些更具体的属性。例如，`TextView`对象也有这些属性：`android:editable`、`android:fontFamily`、`android:hint`、`android:text`或`android:textColor`。
- en: Supporting multiple screens
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持多屏幕
- en: When creating Android applications, we have to take into account the existence
    of multiple screen sizes and screen resolutions. It is important to check how
    our layouts are displayed in different screen configurations. To accomplish this,
    Android Studio provides a functionality to change the virtual device that renders
    the layout preview when we are in the **Design** mode.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建Android应用程序时，我们必须考虑到存在多种屏幕尺寸和屏幕分辨率。检查我们的布局在不同屏幕配置中的显示方式非常重要。为了实现这一点，Android
    Studio提供了一个功能，可以在**设计**模式下更改渲染布局预览的虚拟设备。
- en: 'We can find this functionality in the toolbar and click on it to open the list
    of available device definitions, as shown in the following screenshot:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在工具栏中找到这个功能，点击它以打开可用设备定义的列表，如下面的截图所示：
- en: '![Supporting multiple screens](img/B05459_05_09.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![支持多屏幕](img/B05459_05_09.jpg)'
- en: Try some of them. The difference between a tablet device and a device like those
    from the Nexus line is very notable. We should adapt the views to all the screen
    configurations our application supports to ensure that they are displayed optimally.
    Note that there are device definitions for Android Wear (**square**, **round**,
    and **round chin** designs) and for Android TV.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试其中一些。平板设备与Nexus系列设备等之间的差异非常明显。我们应该将视图适配到我们应用程序支持的所有屏幕配置，以确保它们能够最优显示。请注意，Android
    Wear（**方形**、**圆形**和**带下巴的圆形**设计）和Android TV都有设备定义。
- en: 'The device definitions indicate the screen size, resolution, and screen density.
    Android screen densities include ldpi, mdpi, tvdpi, hdpi, xhdpi, and even xxhdpi.
    Let''s see what their values are:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 设备定义指示屏幕尺寸、分辨率和屏幕密度。Android屏幕密度包括ldpi、mdpi、tvdpi、hdpi、xhdpi，甚至xxhdpi。让我们看看它们的值：
- en: '**ldpi** : This is **low-density dots per inch**, and its value is about 120
    dpi'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ldpi**：这是**低密度每英寸点数**，其值约为120 dpi'
- en: '**mdpi**: This is **medium-density dots per inch**, and its values is about
    160 dpi'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**mdpi**：这是**中等密度每英寸点数**，其值约为160 dpi'
- en: '**tvdpi**: This is **medium-density dots per inch**, and its value is about
    213 dpi'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**tvdpi**：这是**中等密度每英寸点数**，其值约为213 dpi'
- en: '**hdpi**: This is **high-density dots per inch**, and its value is about 240
    dpi'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**hdpi**：这是**高密度每英寸点数**，其值约为240 dpi'
- en: '**xhdpi**: This is **extra-high-density dots per inch**, and its value is about
    320 dpi'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**xhdpi**：这是**超高密度每英寸点数**，其值约为320 dpi'
- en: '**xxhdpi**: This is **extra-extra-high-density dots per inch**, and its value
    is about 480 dpi'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**xxhdpi**：这是**超超高密度每英寸点数**，其值约为480 dpi'
- en: '**xxxhdpi**: This is **extra-extra-extra-high-density dots per inch**, and
    its value is about 640 dpi'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**xxxhdpi**：这是**超超超高密度每英寸点数**，其值约为640 dpi'
- en: The last dashboards published by Google show that most devices have high-density
    screens (42.3 percent), followed by xhdpi (24.8 percent) and xxhdpi (15.0 percent).
    Therefore, we can cover 82.1 percent of all the devices by testing our application
    using these three screen densities. If you want to cover a bigger percentage of
    devices, test your application using mdpi screens (12.9 percent) as well so the
    coverage will be 95.0 percent of all devices. The official Android dashboards
    are available at [http://developer.android.com/about/dashboards](http://developer.android.com/about/dashboards).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Google发布的最新仪表板显示，大多数设备具有高密度屏幕（42.3%），其次是xhdpi（24.8%）和xxhdpi（15.0%）。因此，通过使用这三个屏幕密度测试我们的应用程序，我们可以覆盖所有设备的82.1%。如果您想覆盖更多比例的设备，还可以使用mdpi屏幕（12.9%）测试您的应用程序，这样覆盖率将达到所有设备的95.0%。官方Android仪表板可在[http://developer.android.com/about/dashboards](http://developer.android.com/about/dashboards)找到。
- en: Another issue to keep in mind is the **device orientation**. Do we want to support
    the landscape mode in our application? If the answer is yes, then we have to test
    our layouts in landscape orientation. On the toolbar, click on the **layout state**
    option to change the mode either from portrait to landscape or from landscape
    to portrait.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑的问题是**设备方向**。我们想在应用程序中支持横屏模式吗？如果是的话，那么我们必须在横屏方向测试我们的布局。在工具栏上，点击**布局状态**选项以更改模式，从纵向切换到横屏或从横屏切换到纵向。
- en: 'If our application supports landscape mode and the layout does not get displayed
    as expected in this orientation, we might want to create a variation of the layout.
    Click on the first icon of the toolbar, that is, the **Configuration to render
    this layout with inside the IDE** option, and select the **Create Landscape Variation**
    option, as shown in the next screenshot:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的应用程序支持横屏模式，并且布局在此方向上未按预期显示，我们可能需要创建布局的变体。点击工具栏的第一个图标，即 **配置以在 IDE 中渲染此布局**
    选项，并选择 **创建横屏变体** 选项，如图下所示：
- en: '![Supporting multiple screens](img/B05459_05_10.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![支持多屏幕](img/B05459_05_10.jpg)'
- en: A new layout will be opened in the editor. This layout has been created in the
    `resources` folder, under the `layout-land` directory, and it uses the same name
    as the portrait layout - `/src/main/res/layout-land/activity_main.xml`. The Android
    system will decide which version of the layout needs to be used depending on the
    current device orientation. Now, we can edit the new layout variation so that
    it perfectly conforms to landscape mode.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑器中将打开一个新的布局。此布局已在 `resources` 文件夹下的 `layout-land` 目录中创建，并使用与横屏布局相同的名称 - `/src/main/res/layout-land/activity_main.xml`。Android
    系统将根据当前设备方向决定需要使用哪个版本的布局。现在，我们可以编辑新的布局变体，使其完美符合横屏模式。
- en: 'Similarly, we can create a variation of the layout for extra-large screens.
    Select the **Create layout-xlarge Variation** option. The new layout will be created
    in the `layout-xlarge` folder using the same name as the original layout at `/src/main/res/layout-xlarge/activity_main.xml`.
    Android divides into actual screen sizes of small, normal, large, and extra large:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以为超大型屏幕创建布局的变体。选择 **创建 layout-xlarge 变体** 选项。新布局将在 `layout-xlarge` 文件夹中创建，使用与原始布局相同的名称
    - `/src/main/res/layout-xlarge/activity_main.xml`。Android 将分为实际屏幕尺寸的小型、正常、大型和超大型：
- en: '**Small**: Screens classified in this category are at least 426 dp x 320 dp.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**小型**：本类别中的屏幕至少为 426 dp x 320 dp。'
- en: '**Normal**: Screens classified in this category are at least 470 dp x 320 dp.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正常**：本类别中的屏幕至少为 470 dp x 320 dp。'
- en: '**Large**: Screens classified in this category are at least 640 dp x 480 dp.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大型**：本类别中的屏幕至少为 640 dp x 480 dp。'
- en: '**Extra large**: Screens classified in this category are at least 960 dp x
    720 dp.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超大型**：本类别中的屏幕至少为 960 dp x 720 dp。'
- en: A **density-independent pixel** (**dp**) is equivalent to one physical pixel
    on a 160 dpi screen. The latest dashboards published by Google show that most
    devices have a normal screen size (85.1 percent), followed by large screen size
    (8.2 percent). The official Android dashboards are available at [http://developer.android.com/about/dashboards](http://developer.android.com/about/dashboards).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**密度无关像素**（**dp**）相当于在 160 dpi 屏幕上的一个物理像素。谷歌发布的最新仪表板显示，大多数设备具有正常屏幕尺寸（85.1%），其次是大型屏幕尺寸（8.2%）。官方的
    Android 仪表板可在 [http://developer.android.com/about/dashboards](http://developer.android.com/about/dashboards)
    查找。'
- en: 'To display multiple device configurations at the same time, click on the **Configuration
    to render this layout with inside the IDE** option in the toolbar and select the
    **Preview All Screen Sizes** option, or click on the **Preview Representative
    Sample** option to open only the most important screen sizes, as shown in the
    following screenshot. We can also delete any of the samples by right-clicking
    on them and selecting the **Delete** option from the menu. Another useful action
    of this menu is the **Save screenshot** option. It allows us to take a screenshot
    of the layout preview:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要同时显示多个设备配置，请点击工具栏中的 **配置以在 IDE 中渲染此布局** 选项，并选择 **预览所有屏幕尺寸** 选项，或者点击 **预览代表性样本**
    选项以仅打开最重要的屏幕尺寸，如图下所示。我们还可以通过右键单击并从菜单中选择 **删除** 选项来删除任何样本。此菜单的另一个有用操作是 **保存截图**
    选项。它允许我们捕获布局预览的截图：
- en: '![Supporting multiple screens](img/B05459_05_11.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![支持多屏幕](img/B05459_05_11.jpg)'
- en: If we create different layout variations, we can preview all of them by selecting
    the **Preview Layout Versions** option. If we want to preview what the layout
    looks like for different Android versions, we can use the **Preview Android Versions**
    option.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们创建了不同的布局变体，我们可以通过选择 **预览布局版本** 选项来预览所有这些变体。如果我们想预览不同 Android 版本的布局外观，我们可以使用
    **预览 Android 版本** 选项。
- en: Now that we have seen how to add different components and optimize our layout
    for different screens, let's start working with themes.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何添加不同的组件以及如何为不同屏幕优化我们的布局，让我们开始使用主题。
- en: Changing the UI theme
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改 UI 主题
- en: Layouts and widgets are created using the default UI theme of our project. We
    can change the appearance of the elements of the UI by creating styles. Styles
    can be grouped to create a theme, and a theme can be applied to an activity or
    to the whole application. Some themes are provided by default, such as the **Material
    Design** or **Holo** style. Styles and themes are created as resources under the
    `/src/res/values` folder.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 布局和小部件使用我们项目的默认 UI 主题创建。我们可以通过创建样式来更改 UI 元素的外观。样式可以分组以创建主题，主题可以应用于活动或整个应用。一些主题是默认提供的，例如**Material
    Design**或**Holo**样式。样式和主题作为资源创建在`/src/res/values`文件夹下。
- en: To continue our example, we are going to change the default colors of the theme
    that we are using in our app. Using the graphical editor, you can see that the
    selected theme for our layout is shown as **AppTheme** in the toolbar. This theme
    was created for our project and can be found in the `styles` file at `/src/res/values/styles.xml`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续我们的示例，我们将更改我们在应用中使用的主题的默认颜色。使用图形编辑器，您可以看到我们的布局所选的主题在工具栏中显示为**AppTheme**。此主题是为我们的项目创建的，可以在`styles`文件中的`/src/res/values/styles.xml`找到。
- en: 'Open the `styles` file. Android Studio suggests we use the **Theme Editor**.
    You can click on the message link or you can navigate to **Tools** | **Android**
    | **Theme Editor** to open it. You can see the **Theme Editor** in the next screenshot:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`styles`文件。Android Studio 建议我们使用**主题编辑器**。您可以点击消息链接，或者您可以导航到**工具** | **Android**
    | **主题编辑器**来打开它。您可以在下一张屏幕截图中看到**主题编辑器**：
- en: '![Changing the UI theme](img/B05459_05_12.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![更改 UI 主题](img/B05459_05_12.jpg)'
- en: The left panel shows what different UI components look like. For example, you
    can view the appearance of the app bar, different types of buttons, text views,
    or the appearance of the status bar. The right panel of the **Theme Editor** contains
    the settings of the theme. You can change the values from the right panel and
    see how the components change in the left panel of **Theme Editor**.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧面板显示了不同的 UI 组件的外观。例如，您可以查看应用栏、不同类型的按钮、文本视图或状态栏的外观。**主题编辑器**的右侧面板包含主题的设置。您可以从右侧面板更改值，并查看**主题编辑器**左侧面板中的组件如何变化。
- en: In the right-hand configuration panel, you can change the **Theme** to modify,
    you can change the **Theme parent** of the selected theme, and you can change
    the theme colors. You will note that **AppTheme** is by default an extension of
    another theme, `Theme.AppCompat.Light.DarkActionBar`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧配置面板中，您可以更改**主题**以进行修改，您可以更改所选主题的**主题父级**，并且可以更改主题颜色。您会注意到**AppTheme**默认是另一个主题`Theme.AppCompat.Light.DarkActionBar`的扩展。
- en: 'Let''s try to change the main color of our app. Follow the next steps:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试更改我们应用的主颜色。按照以下步骤操作：
- en: Look for the **colorPrimary** property on the right panel of the **Theme Editor**.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**主题编辑器**的右侧面板中查找**colorPrimary**属性。
- en: Click on the color square of the **colorPrimary** property. The color selector
    of the following screenshot will be opened:![Changing the UI theme](img/B05459_05_13.jpg)
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**colorPrimary**属性的彩色方块。以下屏幕截图将打开颜色选择器：![更改 UI 主题](img/B05459_05_13.jpg)
- en: Select a different color and click on the **OK** button. Note that the theme
    has changed and now the app bar has the new color in **Theme Editor**.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择不同的颜色，然后点击**确定**按钮。请注意，主题已更改，现在应用栏在**主题编辑器**中显示新颜色。
- en: Open your main layout file. The preview of the layout has also changed its color.
    This theme primary color will be applied to all our layouts due to the fact that
    we configured it in the theme and not just in the layout.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的主布局文件。布局预览的颜色也发生了变化。由于我们在主题中而不是仅在布局中配置了它，因此此主题主颜色将应用于所有我们的布局。
- en: 'The specification of the colors is saved in the `colors` file at `/src/res/values/colors.xml`.
    This is the current content of the `colors` file:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色的规范保存在`/src/res/values/colors.xml`中的`colors`文件中。这是`colors`文件当前的内容：
- en: '[PRE4]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can also change the colors from this file. Modify the `colorPrimaryDark`,
    save the file, and note that in the **Theme Editor**, the status bar color has
    changed to the new color. Switch to your main layout file and observe that the
    preview of your layout has also changed to show the new color in the status bar.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以从该文件更改颜色。修改`colorPrimaryDark`，保存文件，并注意在**主题编辑器**中，状态栏颜色已更改为新颜色。切换到您的主布局文件，并观察布局预览也已更改为显示状态栏中的新颜色。
- en: 'To change the layout theme completely, click on the theme option from the toolbar
    in the graphical editor. The theme selector dialog is now opened, displaying a
    list of the available themes, as shown in the following screenshot:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全更改布局主题，请在图形编辑器的工具栏中单击主题选项。现在将打开主题选择对话框，显示可用的主题列表，如下面的屏幕截图所示：
- en: '![Changing the UI theme](img/B05459_05_14.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![更改 UI 主题](img/B05459_05_14.jpg)'
- en: The themes created in our own project are listed in the **Project Themes** section.
    The **Manifest Themes** section shows the theme configured in the application
    manifest file (`/src/main/AndroidManifest.xml`). The **All** section lists all
    the available themes.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们自己的项目中创建的主题列在 **项目主题** 部分中。**清单主题** 部分显示了在应用程序清单文件（`/src/main/AndroidManifest.xml`）中配置的主题。**所有**
    部分列出了所有可用的主题。
- en: Handling events
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理事件
- en: 'The user interface would be useless if the rest of the application could not
    interact with it. Events in Android are generated when the user interacts with
    our application. All the UI widgets are children of the `View` class, and they
    share some events handled by the following listeners:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序的其余部分无法与之交互，则用户界面将毫无用处。Android中的事件是在用户与我们的应用程序交互时生成的。所有 UI 小部件都是 `View`
    类的子类，并且它们共享以下监听器处理的一些事件：
- en: '`OnClickListener`: This captures the event when the user clicks on the view
    element. To configure this listener in a view, use the `setOnClickListener` method.
    The `OnClickListener` interface declares the following method to receive the click
    event:'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnClickListener`: 这捕捉了用户点击视图元素时的事件。要在视图中配置此监听器，请使用 `setOnClickListener` 方法。`OnClickListener`
    接口声明以下方法以接收点击事件：'
- en: '[PRE5]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`OnCreateContextMenu`: This captures the event when the user performs a long
    click on the view element and we want to open a context menu. To configure this
    listener in a view, use the `setOnCreateContextMenu` method. The `OnCreateContextMenu`
    interface declares the following method to receive the long-click event:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnCreateContextMenu`: 这捕捉了用户在视图元素上执行长按操作并希望打开上下文菜单时的事件。要在视图中配置此监听器，请使用 `setOnCreateContextMenu`
    方法。`OnCreateContextMenu` 接口声明以下方法以接收长按事件：'
- en: '[PRE6]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`OnDragListener`: This captures the event when the user drags and drops the
    event element. To configure this listener in a view, use the `setOnDragListener`
    method. The `OnDragListener` interface declares the following method to receive
    the drag event:'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnDragListener`: 这捕捉了用户拖动并放下事件元素时的事件。要在视图中配置此监听器，请使用 `setOnDragListener` 方法。`OnDragListener`
    接口声明以下方法以接收拖动事件：'
- en: '[PRE7]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`OnFocusChangedListener`: This captures the event when the user navigates from
    an element to another in the same view. To configure this listener in a view,
    use the `setOnFocusChangedListener` method. The `OnFocusChangedListener` interface
    declares the following method to receive the change of focus event:'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnFocusChangedListener`: 这捕捉了用户在相同视图中从一个元素导航到另一个元素时的事件。要在视图中配置此监听器，请使用 `setOnFocusChangedListener`
    方法。`OnFocusChangedListener` 接口声明以下方法以接收焦点更改事件：'
- en: '[PRE8]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`OnHoverListener`: This captures the event when the user is moving over an
    element. To configure this listener in a view, use the `setOnHoverListener` method.
    The `OnHoverListener` interface declares the following method to receive the hover
    event:'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnHoverListener`: 这捕捉了用户在元素上移动时的事件。要在视图中配置此监听器，请使用 `setOnHoverListener` 方法。`OnHoverListener`
    接口声明以下方法以接收悬停事件：'
- en: '[PRE9]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`OnKeyListener`: This captures the event when the user presses any key while
    the view element has the focus. To configure this listener in a view, use the
    `setOnKeyListener` method. The `OnKeyListener` interface declares the following
    method to receive the key event:'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnKeyListener`: 这捕捉了用户在视图元素具有焦点时按下任何键的事件。要在视图中配置此监听器，请使用 `setOnKeyListener`
    方法。`OnKeyListener` 接口声明以下方法以接收按键事件：'
- en: '[PRE10]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`OnLayoutChangeListener`: This captures the event when the layout of a view
    changes its bounds due to layout processing. To configure this listener in a view,
    use the `setOnLayoutChangeListener` method. The `OnLayoutChangeListener` interface
    declares the following method to receive the layout change event:'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnLayoutChangeListener`: 这捕捉了视图布局因布局处理而更改其边界时的事件。要在视图中配置此监听器，请使用 `setOnLayoutChangeListener`
    方法。`OnLayoutChangeListener` 接口声明以下方法以接收布局更改事件：'
- en: '[PRE11]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`OnLongClickListener`: This captures the event when the user touches the view
    element and holds it. To configure this listener in a view, use the `setOnLongClickListener`
    method. The `OnLongClickListener` interface declares the following method to receive
    the long click event:'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnLongClickListener`：这个监听器捕获用户触摸视图元素并保持触摸的事件。要在视图中配置这个监听器，使用`setOnLongClickListener`方法。`OnLongClickListener`接口声明以下方法来接收长按事件：'
- en: '[PRE12]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`OnScrollChangeListener`: This captures the event when the scroll position
    of a view changes. To configure this listener in a view, use the `setOnScrollChangeListener`
    method. The `OnScrollChangeListener` interface declares the following method to
    receive the scroll change event:'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnScrollChangeListener`：这个监听器捕获视图滚动位置改变的事件。要在视图中配置这个监听器，使用`setOnScrollChangeListener`方法。`OnScrollChangeListener`接口声明以下方法来接收滚动改变事件：'
- en: '[PRE13]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`OnTouchListener`: This captures the event when the user touches the view element.
    To configure this listener in a view, use the `setOnTouchListener` method. The
    `OnTouchListener` interface declares the following method to receive the touch
    event:'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnTouchListener`：这个监听器捕获用户触摸视图元素的事件。要在视图中配置这个监听器，使用`setOnTouchListener`方法。`OnTouchListener`接口声明以下方法来接收触摸事件：'
- en: '[PRE14]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In addition to these standard events and listeners, some UI widgets have some
    more specific events and listeners. Checkboxes can register a listener to capture
    when its state changes (`OnCheckedChangeListener`), and spinners can register
    a listener to capture when an item is clicked (`OnItemClickListener`).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些标准事件和监听器之外，一些UI小部件还有一些更具体的事件和监听器。复选框可以注册一个监听器来捕获其状态改变时的事件（`OnCheckedChangeListener`），而旋转选择器可以注册一个监听器来捕获项目被点击时的事件（`OnItemClickListener`）。
- en: The most common event to capture is when the user clicks on the view elements.
    There is an easy way to handle it—using the view properties. Select the **Accept**
    button in our layout and look for the `onClick` property. This property indicates
    the name of the method that will be executed when the user presses the button.
    This method has to be created in the activity associated with the current layout,
    our main activity (`MainActivity.java`) in this case. Type `onAcceptClick` as
    the value of this property.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的捕获事件是当用户点击视图元素时。有一个简单的方法来处理它——使用视图属性。在我们的布局中选择**接受**按钮，并查找`onClick`属性。这个属性指示当用户按下按钮时将执行的方法的名称。这个方法必须在关联当前布局的活动（在这种情况下是我们的主活动`MainActivity.java`）中创建。将此属性的值设置为`onAcceptClick`。
- en: 'Open the main activity to create the method definition. When a view is clicked,
    the event callback method when has to be public with a `void` return type. It
    receives the view that has been clicked on as parameter. This method will be executed
    every time the user clicks on the button:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 打开主活动以创建方法定义。当视图被点击时，事件回调方法必须是公共的，并具有`void`返回类型。它接收被点击的视图作为参数。此方法将在用户每次点击按钮时执行：
- en: '[PRE15]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: From the main activity, we can interact with all the components of the interface,
    so when the user presses the **Accept** button, our code can read the text from
    the name field and change the greeting to include the name in it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 从主活动，我们可以与界面的所有组件进行交互，所以当用户按下**接受**按钮时，我们的代码可以读取名称字段中的文本，并将问候语更改为包含该名称。
- en: 'To get the reference to a `view` object, use the `findViewById` method inherited
    from the `Activity` class. This method receives the ID of the component and returns
    the `View` object corresponding to that ID. The returned view object has to be
    cast to its specific class in order to use its methods, such as the `getText`
    method of the `EditText` class, to get the name typed by the user:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取`view`对象的引用，使用从`Activity`类继承的`findViewById`方法。此方法接收组件的ID，并返回对应该ID的`View`对象。返回的视图对象必须转换为它的特定类，以便使用其方法，例如`EditText`类的`getText`方法，以获取用户输入的名称：
- en: '[PRE16]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the first two lines of the method, the references to the elements of the
    layout are retrieved: the text view that contains the greeting and the text field
    where the user can type a name. The components are found by their IDs, the same
    ID that we indicated in the properties of the element in the layout file. All
    the IDs of resources are included in the `R` class. The `R` class is autogenerated
    in the build phase and therefore we must not edit it. If this class is not autogenerated,
    then probably some file of our resources contain an error.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法的头两行，获取布局元素的引用：包含问候语的文本视图和用户可以输入名字的文本字段。组件是通过它们的ID找到的，即我们在布局文件中元素属性中指定的相同ID。所有资源ID都包含在`R`类中。`R`类在构建阶段自动生成，因此我们不应该编辑它。如果这个类没有自动生成，那么可能是一些资源文件中存在错误。
- en: The next line is a conditional statement used to check whether the user typed
    a name. If they typed a name, the text will be replaced by a new greeting that
    contains that name. In the coming chapters, you will learn how to execute our
    application in an emulator, and we will be able to test this code.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行是一个条件语句，用于检查用户是否输入了名字。如果他们输入了名字，文本将被替换为包含该名字的新问候语。在接下来的章节中，你将学习如何在模拟器中执行我们的应用程序，我们就能测试这段代码。
- en: 'If the event we want to handle is not the user''s click, then we have to create
    and add the listener by code to the `onCreate` method of the activity. There are
    two ways to do this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要处理的事件不是用户的点击，那么我们必须通过代码在活动的`onCreate`方法中创建并添加监听器。有两种方法可以做到这一点：
- en: Implementing the listener interface in the activity and then adding the unimplemented
    methods. The methods required by the interface are the methods used to receive
    the events.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在活动中实现监听器接口，然后添加未实现的方法。接口所需的方法是用于接收事件的方法。
- en: Creating a private anonymous implementation of the listener in the activity
    file. The methods that receive the events are implemented in this object.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在活动文件中创建一个私有的匿名监听器实现。接收事件的方法在这个对象中实现。
- en: 'Finally, the listener implementation has to be assigned to the view element
    using the setter methods, such as `setOnClickListener`, `setOnCreateContextMenu`,
    `setOnDragListener`, `setOnFocusChange`, `setOnKeyListener`, and so forth. The
    listener assignment is usually included in the `onCreate` method of the activity.
    If the listener is implemented in the same activity, then the parameter indicated
    to the setter method is the own activity using the `this` keyword, as shown in
    the following code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，必须使用设置方法（如`setOnClickListener`、`setOnCreateContextMenu`、`setOnDragListener`、`setOnFocusChange`、`setOnKeyListener`等）将监听器实现分配给视图元素。监听器分配通常包含在活动的`onCreate`方法中。如果监听器在同一个活动中实现，那么传递给设置方法的参数是使用`this`关键字表示的自身活动，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The activity should then implement the listener and the `onClick` method required
    by the listener interface:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 活动应该实现监听器和监听器接口所需的`onClick`方法：
- en: '[PRE18]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If we implement it using a private anonymous class, the code would be the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用一个私有的匿名类来实现它，代码如下所示：
- en: '[PRE19]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Summary
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how to create and edit the user interface layouts using
    both the graphical and the text-based editors. We finished our first small application,
    and we upgraded it with some basic components. You should now be able to create
    a simple layout and test it with different styles, screen sizes, and screen resolutions.
    You also learned about the different available UI themes. Finally, you learned
    about events and learned how to handle them using listeners.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们看到了如何使用图形和基于文本的编辑器创建和编辑用户界面布局。我们完成了我们的第一个小型应用程序，并使用一些基本组件对其进行了升级。你现在应该能够创建一个简单的布局，并使用不同的样式、屏幕尺寸和屏幕分辨率进行测试。你还了解了不同的可用UI主题。最后，你学习了关于事件以及如何使用监听器处理它们的内容。
- en: In the next chapter, you will learn about some useful tools available in the
    Android Studio. We will use the SDK Manager frequently to install different packages.
    You will also learn about the AVD Manager for different virtual devices to test
    your applications on. We will generate Javadoc documentation for our project using
    the Javadoc utility, and you will learn about the version control systems available
    in Android Studio.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将了解Android Studio中一些有用的工具。我们将经常使用SDK Manager来安装不同的包。你还将了解AVD Manager，用于测试不同虚拟设备上的应用程序。我们将使用Javadoc实用工具为我们的项目生成Javadoc文档，你还将了解Android
    Studio中可用的版本控制系统。
