- en: Observables, Observers, and Subjects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可观察的、观察者和主题
- en: 'Observables and subscribers are at the base of reactive programming. We can
    say that they are the building blocks of reactive programming. In the previous
    two chapters, you already got a glimpse of `Observables` and `subject`. We observed
    on data with `observable`/`subject` instances; but that''s not all we want; instead,
    we want to get all the actions and data changes reactively into the `observable`
    instances, making the application completely reactive. Also, while reading the
    previous chapters, you may have wondered how exactly does it operate? In this
    chapter, let''s have a foundation of the pillars of reactive programming—`Observables`,
    `Observers`, and `subjects`:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察的、订阅者和响应式编程的基础。我们可以这样说，它们是响应式编程的构建块。在前两章中，你已经对`Observables`和`subject`有了一定的了解；我们通过`observable`/`subject`实例观察数据；但这并不是我们想要的全部；相反，我们希望将所有操作和数据更改以响应式的方式收集到`observable`实例中，使应用程序完全响应式。此外，在阅读前几章时，你可能想知道它究竟是如何操作的？在这一章中，让我们建立响应式编程支柱的基础——`Observables`、`Observers`和`subjects`：
- en: We will look into details of transforming various data sources to `observable`
    instances
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将深入了解将各种数据源转换为`observable`实例的细节
- en: You will learn about various types of `Observables`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将了解各种类型的`Observables`。
- en: How to use `Observer` instances and subscriptions, and, lastly, `subjects` and
    their various implementations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`Observer`实例和订阅，最后是`subjects`及其各种实现
- en: We will also learn about various factory methods of `Observable`.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将学习`Observable`的各种工厂方法。
- en: There's a lot to understand in this chapter, so let's start with understanding
    `Observables` first.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中有很多东西需要理解，所以让我们首先了解`Observables`。
- en: Observables
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可观察的
- en: 'As we discussed earlier, in reactive programming, `Observable` has an underlying
    computation that produces values that can be consumed by a consumer (`Observer`).
    The most important thing here is that the consumer (`Observer`) doesn''t pull
    values here; rather, `Observable` pushes the value to the consumer. So, we may
    say, an `Observable` is a push-based, composable iterator that emits its items
    through a series of operators to the final `Observer`, which finally consumes
    the items. Let''s now break things sequentially to understand it better:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，在响应式编程中，`Observable`有一个底层计算，它产生可以被消费者（`Observer`）消费的值。这里最重要的一点是，消费者（`Observer`）在这里不是拉取值；相反，`Observable`将值推送到消费者。因此，我们可以说，`Observable`是一个基于推送、可组合的迭代器，它通过一系列操作符将项目发射到最终的`Observer`，最终消费这些项目。现在让我们按顺序逐一分析，以便更好地理解：
- en: '`Observer` subscribes to `Observable`'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Observer`订阅`Observable`'
- en: '`Observable` starts emitting items that it has in it'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Observable`开始发射它内部拥有的项目'
- en: '`Observer` reacts to whatever item `Observable` emits'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Observer`对`Observable`发射的任何项目做出反应'
- en: So, let's delve into how an `Observable` works through its events/methods, namely,
    `onNext`, `onComplete`, and `onError`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们深入了解一个`Observable`是如何通过其事件/方法工作的，即`onNext`、`onComplete`和`onError`。
- en: How Observable works
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可观察是如何工作的
- en: 'As we stated earlier, an `Observable` has three most important events/methods;
    let''s discuss them one by one:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所述，`Observable`有三个最重要的事件/方法；让我们逐一讨论它们：
- en: '`onNext`: `Observable` passes all items one by one to this method.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onNext`：`Observable`逐个将所有项目传递给此方法。'
- en: '`onComplete`: When all items have gone through the `onNext` method, `Observable`
    calls the `onComplete` method.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onComplete`：当所有项目都通过`onNext`方法后，`Observable`调用`onComplete`方法。'
- en: '`onError`: When `Observable` faces any error, it calls the `onError` method
    to deal with the error, if defined. Note that both `onError` and `onComplete`
    are terminal events, and if `onError` is called, then it would never call `onComplete`
    and vice versa.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onError`：当`Observable`遇到任何错误时，它会调用`onError`方法来处理错误，如果已定义。请注意，`onError`和`onComplete`都是终止事件，如果调用`onError`，则永远不会调用`onComplete`，反之亦然。'
- en: One thing to note here, the item in `Observable` that we are talking about can
    be anything; it is defined as `Observable<T>`, where `T` can be any class; even
    an `array`/`list` can be assigned as an `Observable`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的是，我们谈论的`Observable`中的项目可以是任何东西；它定义为`Observable<T>`，其中`T`可以是任何类；甚至可以将`array`/`list`分配为`Observable`。
- en: 'Let''s look at the following image:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下面的图片：
- en: '![](img/919f75a0-7206-483e-aaae-2f3cb15ccda7.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/919f75a0-7206-483e-aaae-2f3cb15ccda7.png)'
- en: 'Let''s look at this code example to understand it better:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下代码示例来更好地理解它：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding example, we declared the `observer` instance of `Any` datatype
    on comment `(1)`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们在注释（1）处声明了`observer`实例的`Any`数据类型。
- en: Here, we are taking benefit of the `Any` datatype. In Kotlin, every class is
    a child class of `Any`. Also, in Kotlin, everything is class and object; there
    is no separate primitive datatype.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在利用 `Any` 数据类型的好处。在 Kotlin 中，每个类都是 `Any` 的子类。此外，在 Kotlin 中，一切都是类和对象；没有单独的原始数据类型。
- en: 'The `observer` interface has four methods declared in it. The `onComplete()`
    method at comment `2` gets called when `Observable` is finished with all its items
    without any error. On comment `3`, we defined the `onNext(item: Any)` function,
    which will be called by `observable` for each item it has to emit. In that method,
    we will print the data to the console. On comment `4`, we defined the `onError(e:
    Throwable)` method, which will be called in case any error is faced by `Observable`.
    On comment `5`, the `onSubscribe(d: Disposable)` method will get called whenever
    `Observer` subscribes to `Observable`. On comment `6`, we will create `Observable`
    from a `list` (`val observable`) and subscribe to `observable` with `observer`
    on comment `7`. On comment `8`, we will create an observable (`val observableOnList`)
    again, this it holds lists as items.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`observer` 接口中有四个声明的方法。注释 `2` 中的 `onComplete()` 方法在 `Observable` 完成所有项目且没有任何错误时被调用。在注释
    `3` 中，我们定义了 `onNext(item: Any)` 函数，该函数将由 `observable` 为其必须发出的每个项目调用。在该方法中，我们将数据打印到控制台。在注释
    `4` 中，我们定义了 `onError(e: Throwable)` 方法，在 `Observable` 遇到任何错误时将被调用。在注释 `5` 中，`onSubscribe(d:
    Disposable)` 方法将在 `Observer` 订阅 `Observable` 时被调用。在注释 `6` 中，我们将从列表创建 `Observable`（`val
    observable`）并使用 `observer` 在注释 `7` 中订阅 `observable`。在注释 `8` 中，我们再次创建一个可观察的（`val
    observableOnList`），它包含列表作为项目。'
- en: 'The output of the program is as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出如下：
- en: '![](img/a506ff43-49cd-4d87-8cae-33bd129186dc.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a506ff43-49cd-4d87-8cae-33bd129186dc.png)'
- en: So, as you can see in the output, for the first subscription (comment `7`),
    when we subscribe to `Observable`, it calls the `onSubscribe` method, and then
    `Observable` starts emitting items as `Observer` starts receiving them on the
    `onNext` method and prints them. When all items are emitted from `Observable`,
    it calls the `onComplete` method to denote that all items have been successfully
    emitted. Same with the second one, except that, here, each item is a list.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在输出中看到的，对于第一次订阅（注释 `7`），当我们订阅 `Observable` 时，它调用 `onSubscribe` 方法，然后 `Observable`
    开始发出项目，当 `Observer` 在 `onNext` 方法中开始接收它们并打印它们时。当 `Observable` 发出所有项目后，它调用 `onComplete`
    方法来表示所有项目都已成功发出。第二个也是一样，只是这里每个项目都是一个列表。
- en: So, as we gained some basis in `Observables`, let's learn various ways to create `Observable`—factory
    methods for `Observable`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，随着我们在 `Observables` 方面获得了一些基础知识，让我们学习创建 `Observable` 的各种方法——`Observable`
    的工厂方法。
- en: Understanding the Observable.create method
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 `Observable.create` 方法
- en: 'You can create your own `Observable` with the `Observable.create` method at
    any time. This method takes an instance of the `ObservableEmitter<T>` interface
    as a source to observe on. So, let''s consider this following example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在任何时间使用 `Observable.create` 方法创建自己的 `Observable`。此方法接受 `ObservableEmitter<T>`
    接口的一个实例作为观察的源。因此，让我们考虑以下示例：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: First, we created an instance of the `Observer` interface as the previous example.
    I will not elaborate on `observer`, as we have already seen an overview in the
    previous example, and we will see it in detail later in this chapter.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个 `Observer` 接口的实例，就像之前的例子一样。我不会详细说明 `observer`，因为我们已经在之前的例子中看到了概述，我们将在本章后面详细讨论。
- en: On comment `1`, we created `Observable` with the `Observable.create` method;
    we emitted four `string` from `Observable` with the help of the `onNext` method,
    and then notified it is complete with the `onComplete` method.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释 `1` 中，我们使用 `Observable.create` 方法创建了 `Observable`；我们通过 `onNext` 方法从 `Observable`
    中发出四个 `string`，然后使用 `onComplete` 方法通知其完成。
- en: On comment `2`, we did almost the same, except here instead of calling `onComplete`,
    we called `onError` with a custom `Exception`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释 `2` 中，我们做了几乎同样的事情，只是这里我们没有调用 `onComplete`，而是使用自定义 `Exception` 调用了 `onError`。
- en: 'Here is the output of the program:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这是程序的输出：
- en: '![](img/d101c509-0137-4601-8a3e-8603ef587d0c.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d101c509-0137-4601-8a3e-8603ef587d0c.png)'
- en: The `Observable.create` method is useful, especially when you are working with
    a custom data structure and want to have control over what values are getting
    emitted. You can also emit values to `Observer` from a different thread.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable.create` 方法很有用，尤其是在您使用自定义数据结构并希望控制要发出的值时。您还可以从不同的线程向 `Observer`
    发送值。'
- en: Note that the `Observable` contract ([http://reactivex.io/documentation/contract.html](http://reactivex.io/documentation/contract.html))
    states that `Observable` must issue notifications to `observers` serially (not
    in parallel). They may issue these notifications from different threads, but there
    must be a formal happens—before relationship between the notifications.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Observable`契约([http://reactivex.io/documentation/contract.html](http://reactivex.io/documentation/contract.html))规定`Observable`必须按顺序（不是并行）向`观察者`发出通知。它们可以从不同的线程发出这些通知，但通知之间必须存在正式的“发生之前”关系。
- en: Understanding the Observable.from methods
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解`Observable.from`方法
- en: The `Observable.from` methods are comparatively simpler than the `Observable.create`
    method. You can create `Observable` instances from nearly every Kotlin structure
    with the help of `from` methods.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable.from`方法相对于`Observable.create`方法来说比较简单。你可以使用`from`方法从几乎任何Kotlin结构创建`Observable`实例。'
- en: Note that in RxKotlin 1, you will have `Observale.from` as a method; however,
    from RxKotlin 2.0 (as with RxJava2.0), operator overloads have been renamed with
    a postfix, such as `fromArray`, `fromIterable`, `fromFuture`, and so on.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在RxKotlin 1中，你将有一个`Observale.from`方法；然而，从RxKotlin 2.0（与RxJava2.0一样），操作符重载已被重命名为后缀，例如`fromArray`、`fromIterable`、`fromFuture`等等。
- en: 'So, let''s take a look at this code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们看看这段代码：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: On comment `1`, I used the `Observable.fromIterable` method to create `Observable`
    from an `Iterable` instance (here, `List`). On comment `2`, I called the `Observable.fromCallable`
    method to create `Observable` from a `Callable` instance, and same for comment
    `3`, where I called the `Observable.fromFuture` method to derive `Observable`
    from a `Future` instance.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释`1`中，我使用了`Observable.fromIterable`方法从`Iterable`实例（这里，`List`）创建`Observable`。在注释`2`中，我调用了`Observable.fromCallable`方法从`Callable`实例创建`Observable`，同样，在注释`3`中，我调用了`Observable.fromFuture`方法从`Future`实例派生出`Observable`。
- en: 'Here is the output:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '![](img/e5892068-ffc1-4437-afeb-5ac26c1c8fb8.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e5892068-ffc1-4437-afeb-5ac26c1c8fb8.png)'
- en: Understanding the toObservable extension function
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解`toObservable`扩展函数
- en: 'Thanks to the extension functions of Kotlin, you can turn any `Iterable` instance,
    such as `List`, to `Observable` without much effort; we have already used this
    method in [Chapter 1](0c50d487-2455-4385-b1c6-822eae0591bf.xhtml), *A Short Introduction
    to Reactive Programming*, however, take a look at this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了Kotlin的扩展函数，你可以轻松地将任何`Iterable`实例，如`List`，转换为`Observable`；我们已经在[第1章](0c50d487-2455-4385-b1c6-822eae0591bf.xhtml)，《反应式编程简介》中使用了这个方法，然而，看看这个：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And the following is the output:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是其输出：
- en: '![](img/355f9436-754f-4a24-bd20-0e71f7c5ac62.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/355f9436-754f-4a24-bd20-0e71f7c5ac62.png)'
- en: 'So, aren''t you curious to look into the `toObservable` method? Let''s do it.
    You can find this method inside the `observable.kt` file provided with the `RxKotlin`
    package:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你难道不好奇想看看`toObservable`方法吗？让我们来看看。你可以在`RxKotlin`包提供的`observable.kt`文件中找到这个方法：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: So, it basically uses the `Observable.from` method internally; thanks again
    to extension functions of Kotlin.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，它基本上内部使用了`Observable.from`方法；再次感谢Kotlin的扩展函数。
- en: Understanding the Observable.just method
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解`Observable.just`方法
- en: Another interesting factory method is `Observable.just`; this method creates
    `Observable` and adds the parameters passed to it as the only items of the `Observable`.
    Note that if you pass an `Iterable` instance to `Observable.just` as a single
    parameter, it will take the entire `list` as a single item, unlike `Observable.from`,
    where it will create items of `Observable` from each item in `Iterable`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的工厂方法是`Observable.just`；此方法创建`Observable`并将传递给它的参数作为`Observable`的唯一项目。请注意，如果您将`Iterable`实例作为单个参数传递给`Observable.just`，它将整个`list`作为一个项目，这与`Observable.from`不同，后者将从`Iterable`中的每个项目创建`Observable`的项目。
- en: 'Here is what happens when you call `Observable.just`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用`Observable.just`时，这是会发生的情况：
- en: You call `Observable.just` with parameters
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你用参数调用`Observable.just`
- en: '`Observable.just` will create `Observable`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Observable.just`将创建`Observable`'
- en: It will emit each of its parameters as the `onNext` notification
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将每个参数作为`onNext`通知发出
- en: When all parameters are emitted successfully, it will emit the `onComplete`
    notification
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当所有参数成功发出后，它将发出`onComplete`通知
- en: 'Let''s look at this code example to understand it better:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过这个代码示例来更好地理解它：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And here is the output:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '![](img/97067b1c-8d93-46a3-9404-c19a85540637.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/97067b1c-8d93-46a3-9404-c19a85540637.png)'
- en: As you can see in the output, lists and maps are also treated as a single item,
    but look at comment `1` in the code where I passed three strings as parameters
    of the `Observable.just` method. `Observable.just` took each of the parameters
    as a separate item and emitted them accordingly (see the output).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在输出中看到的，列表和映射也被视为单个项目，但请看代码中的注释 `1`，我在 `Observable.just` 方法的参数中传递了三个字符串。`Observable.just`
    将每个参数作为单独的项目处理并相应地发出（参见输出）。
- en: Other Observable factory methods
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他 `Observable` 工厂方法
- en: Before moving forward with `Observer`, subscribing, unsubscribing, and `Subjects`,
    let's try our hands on a few other factory methods of `Observable`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续 `Observer`、订阅、取消订阅和 `Subjects` 之前，让我们尝试一些其他的 `Observable` 工厂方法。
- en: 'So, let''s look at this code first, and then we will try to learn it line by
    line:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们首先看看这段代码，然后我们将逐行尝试学习它：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: On comment `(1)`, we created `Observable` with the `Observable.range()` factory
    method. This method creates an `Observable` and emits integers with the supplied
    `start` parameter until it emits a number of integers as per the `count` parameter.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释 `(1)` 中，我们使用 `Observable.range()` 工厂方法创建了 `Observable`。该方法创建一个 `Observable`
    并发出带有 `start` 参数的整数，直到根据 `count` 参数发出指定数量的整数。
- en: On comment `(2)`, we created `Observable` with the `Observable.empty()` method.
    This method creates `Observable` and emits `onComplete()` right away, without
    emitting any items with `onNext()`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释 `(2)` 中，我们使用 `Observable.empty()` 方法创建了 `Observable`。该方法创建 `Observable`
    并立即发出 `onComplete()`，而不使用 `onNext()` 发出任何项目。
- en: On comment `(3)` and comment `(4)`, we used two interesting `Observable` factory
    methods. The method on comment `(3)`, `Observable.interval()`, emits numbers sequentially
    starting from `0`, after each specified interval. It will continue emitting until
    you unsubscribe and until the program runs. Whereas, the method on comment `(4)`,
    `Observable.timer()`, will emit only once with `0` after the specified time elapsed.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释 `(3)` 和注释 `(4)` 中，我们使用了两个有趣的 `Observable` 工厂方法。注释 `(3)` 中的方法 `Observable.interval()`，从
    `0` 开始按顺序发出数字，在每次指定的间隔后继续发出，直到你取消订阅和程序运行。而注释 `(4)` 中的方法 `Observable.timer()`，在指定时间过后只会发出一次
    `0`。
- en: 'Here is the output if you are curious:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您好奇的话，以下是输出：
- en: '![](img/8d2d28f9-914d-4f1b-a1d8-ef3c70ee112e.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8d2d28f9-914d-4f1b-a1d8-ef3c70ee112e.png)'
- en: Subscribers - the Observer interface
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订阅者 - `Observer` 接口
- en: The `Subscriber` from RxKotlin 1.x,  essentially became an `Observer` in RxKotlin
    2.x. There is an `Observer` interface in RxKotlin 1.x, but `Subscriber` is what
    you pass to the `subscribe()` method, and it implements `Observer`. However, In
    RxJava 2.x, `Subscriber` only exists when talking about `Flowables`, which we
    will cover in [Chapter 4](44e60d80-46e4-4b97-a0ad-4047a5d7bfb7.xhtml), *Introduction
    to Backpressure and Flowables*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 RxKotlin 1.x 的 `Subscriber` 在 RxKotlin 2.x 中本质上变成了 `Observer`。在 RxKotlin
    1.x 中有一个 `Observer` 接口，但 `Subscriber` 是传递给 `subscribe()` 方法的，它实现了 `Observer`。然而，在
    RxJava 2.x 中，`Subscriber` 只在谈论 `Flowables` 时存在，我们将在第 4 章 [介绍背压和 `Flowables`](44e60d80-46e4-4b97-a0ad-4047a5d7bfb7.xhtml)
    中介绍。
- en: 'As you can see in the previous examples in this chapter, `Observer` is an interface
    with four methods in it—`onNext(item:T)`, `onError(error:Throwable)`, `onComplete()`,
    and `onSubscribe(d:Disposable)`. As stated earlier, when we connect `Observable`
    to `Observer`, it looks for these four methods in `Observer` and calls them. So,
    the following is a short description of the four methods:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在本章前面的示例中所见，`Observer` 是一个包含四个方法的接口——`onNext(item:T)`、`onError(error:Throwable)`、`onComplete()`
    和 `onSubscribe(d:Disposable)`。如前所述，当我们连接 `Observable` 到 `Observer` 时，它会在 `Observer`
    中寻找这四个方法并调用它们。因此，以下是对这四个方法的简要描述：
- en: '`onNext`: `Observable` calls this method of `Observer` to pass each of the
    items one by one.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onNext`: `Observable` 调用 `Observer` 的此方法来逐个传递每个项目。'
- en: '`onComplete`: When `Observable` wants to denote, it''s done with passing items
    to the `onNext` method, and it calls the `onComplete` method of `Observer`.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onComplete`: 当 `Observable` 想要表示完成时，它通过传递项目到 `onNext` 方法来完成，然后调用 `Observer`
    的 `onComplete` 方法。'
- en: '`onError`: When `Observable` faces any error, it calls the `onError` method
    to deal with the error if defined in the `Observer`, otherwise, it throws the
    exception.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onError`: 当 `Observable` 遇到任何错误时，如果 `Observer` 中定义了 `onError` 方法，它会调用该方法来处理错误，否则，它会抛出异常。'
- en: '`onSubscribe`: This method is called whenever a new `Observable` subscribes
    to the `Observer`.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onSubscribe`: 每当新的 `Observable` 订阅到 `Observer` 时，都会调用此方法。'
- en: Subscribing and disposing
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订阅和取消订阅
- en: So, we have `Observable` (the thing that should be observed upon) and we have `Observer`
    (that should observe); now what? How to connect them? `Observable` and `Observer`
    are like an input device (be it keyboard or mouse) and the computer, we need something
    to connect them (even wireless input devices have some connectivity channels,
    be it Bluetooth or Wi-Fi).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有`Observable`（需要观察的事物）和`Observer`（需要观察者）；现在怎么办？如何将它们连接起来？`Observable`和`Observer`就像输入设备（无论是键盘还是鼠标）和计算机一样，我们需要某种东西来连接它们（即使是无线输入设备也有一些连接通道，无论是蓝牙还是Wi-Fi）。
- en: The `subscribe` operator serves the purpose of the media by connecting an `Observable`
    to `Observer`. We can pass one to three methods (`onNext`, `onComplete`, `onError`)
    to the `subscribe` operator, or we can pass an instance of the `Observer` interface
    to the `subscribe` operator to get the `Observable` connected with an `Observer`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`subscribe`操作符的作用是将`Observable`连接到`Observer`，就像媒体的作用一样。我们可以向`subscribe`操作符传递一到三个方法（`onNext`、`onComplete`、`onError`），或者我们可以向`subscribe`操作符传递`Observer`接口的实例，以获取与`Observer`连接的`Observable`。'
- en: 'So, let''s take a look at the following example now:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看以下示例：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, we have created `Observable` instance (on comment `1`) and
    used it twice with different overload `subscribe` operators. On comment `2`, we
    have passed three methods as arguments to the `subscribe` method. The first parameter
    is the `onNext` method, the second one is the `onError` method, and last, `onComplete`.
    On comment `2`, we have passed an instance of the `Observer` interface.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了`Observable`实例（在注释`1`处），并且两次使用了不同的重载`subscribe`操作符。在注释`2`处，我们将三个方法作为参数传递给了`subscribe`方法。第一个参数是`onNext`方法，第二个是`onError`方法，最后是`onComplete`。在注释`2`处，我们传递了一个`Observer`接口的实例。
- en: 'The output can be easily predicted as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 输出可以很容易地预测如下：
- en: '![](img/14269583-2a72-4485-acb0-aa6c06611a2b.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/14269583-2a72-4485-acb0-aa6c06611a2b.jpg)'
- en: So, we have got the concepts of subscribing, and we can do it now. What if you
    want to stop the emissions after some period of subscription? There must be a
    way, right? So let's inspect this.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经了解了订阅的概念，现在我们可以进行订阅了。如果你想在订阅一段时间后停止发射，那必须有一种方法，对吧？所以让我们来检查一下。
- en: Remember the `onSubscribe` method of `Observer`? There was a parameter on that
    method that we have not talked about yet. While you `subscribe`, if you pass the
    methods instead of the `Observer` instance, then the `subscribe` operator will
    return an instance of `Disposable`, or if you use an instance of `Observer`, then
    you will get the instance of `Disposable` in the parameter of the `onSubscribe`
    method.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 记得`Observer`的`onSubscribe`方法吗？在那个方法中有一个参数我们还没有讨论过。当你`subscribe`时，如果你传递方法而不是`Observer`实例，那么`subscribe`操作符将返回一个`Disposable`实例，或者如果你使用`Observer`的实例，那么你将在`onSubscribe`方法的参数中得到`Disposable`实例。
- en: 'You can use the instance of the `Disposable` interface to stop emissions at
    any given time. Let''s take a look at this example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`Disposable`接口的实例在任何给定时间停止发射。让我们看看这个示例：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: I hope you remember the `Observable.interval` factory method, from just few
    pages ago in this chapter. This method takes two parameters describing the interval
    period and time unit, then, it prints integers sequentially, starting from `0`.
    `Observable` created with interval never completes and never stops until you stop
    them or the program stops execution. I thought it will be the perfect fit in this
    scenario, as here we want to stop the `Observable` midway.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你能记得几页前的这个章节中提到的`Observable.interval`工厂方法。这个方法接受两个参数，描述了间隔期间和时间单位，然后，它按顺序打印整数，从`0`开始。使用间隔创建的`Observable`永远不会完成，也永远不会停止，除非你停止它们或者程序停止执行。我认为它非常适合这个场景，因为我们在这里想要在中间停止`Observable`。
- en: So, in this example on comment `1`, we created an `Observable` with the `Observable.interval`
    factory method that will emit an integer after each `100` millisecond interval.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在这个例子中，在注释`1`处，我们使用`Observable.interval`工厂方法创建了一个`Observable`，该`Observable`将在每个`100`毫秒的间隔后发射一个整数。
- en: On comment `2`, I have declared a `lateinit var disposable` of type `Disposable`
    (`lateinit` means the variable will get initialized at a later point of time).
    On comment `3`, inside the `onSubscribe` method, we will assign the received parameter
    value to the `disposable` variable.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释`2`处，我声明了一个`lateinit var disposable`类型的`Disposable`变量（`lateinit`意味着该变量将在稍后的时间点初始化）。在注释`3`处，在`onSubscribe`方法内部，我们将接收到的参数值赋给`disposable`变量。
- en: We intend to stop the execution after the sequence reaches `10`, that is, after
    `10` is emitted, the emission should be stopped immediately. To achieve that,
    we placed a check inside the `onNext` method, where we are checking if the value
    of the emitted item is equal to or greater than `10`, and if the emission is not
    already stopped (disposed), then we will dispose the emission (comment `5`).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打算在序列达到`10`后停止执行，也就是说，在`10`被发射后，应立即停止发射。为了实现这一点，我们在`onNext`方法内部放置了一个检查，检查发射项的值是否等于或大于`10`，并且如果发射尚未停止（已释放），则我们将释放发射（注释`5`）。
- en: 'Here is the output:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出结果：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: From the output, we can see that no integer got emitted after the `disposable.dispose()`
    method was called, although the execution waited 500 milliseconds more (100*10=1000
    milliseconds to print sequence until `10`, and we called the `delay` method with
    1500, thus 500 milliseconds after emitting `10`).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，我们可以看到在调用`disposable.dispose()`方法后没有发射任何整数，尽管执行等待了500毫秒更多（100*10=1000毫秒来打印序列直到`10`，我们使用1500毫秒调用`delay`方法，因此发射`10`后500毫秒）。
- en: 'If you are curious to know the `Disposable` interface, then the following is
    the definition:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你好奇想了解`Disposable`接口，那么以下是其定义：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It has one property that denotes if the emission is already notified to stop
    (`disposed`) and a method to notify the emission to stop (`dispose`).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一个属性表示是否已经通知停止发射（已释放）以及一个方法来通知停止发射（释放）。
- en: Hot and Cold Observables
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 热和冷可观测对象
- en: So, as we have a grip on the basic concepts of `Observables` and `Observers`
    by now, let's move to something more interesting and advanced. The `Observables`
    that we are talking all about can be categorized into two categories based on
    their behavior. As the heading suggests, the two categories are `Hot Obervables`
    and `Cold Observable`. I can bet that, by now, you are craving to know more about
    `Hot` and `Cold Observables`, aren't you? So, let's dive into it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，既然我们已经掌握了`Observables`和`Observers`的基本概念，让我们转向更有趣和高级的内容。我们一直在谈论的`Observables`可以根据其行为分为两类。正如标题所暗示的，这两类是`Hot
    Observables`和`Cold Observables`。我可以打赌，到现在为止，你一定渴望了解更多关于`Hot`和`Cold Observables`的信息，不是吗？那么，让我们深入探讨吧。
- en: Cold Observables
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 冷可观测对象
- en: 'Take a careful look at all the previous examples. In all the examples, if you
    subscribe to the same `Observable` multiple times, you will get the emissions
    from the beginning for all the subscriptions. Don''t believe it? Take a look at
    the following example:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细查看所有之前的示例。在所有示例中，如果你多次订阅相同的`Observable`，你将获得所有订阅的开始处的发射。不相信？看看下面的示例：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here is its output:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是它的输出结果：
- en: '![](img/ae275fc1-b456-4a0e-9530-2db959bff3fd.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ae275fc1-b456-4a0e-9530-2db959bff3fd.png)'
- en: The program is quite straightforward. Declared an `Observable` on comment `1`,
    subscribed to the `Observable` twice—on comment `2` and `3`. Now, look at the
    output. For both the subscribe calls, you got the exact same emission from the
    first one to the last one.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 程序相当简单。在注释`1`处声明了一个`Observable`，在注释`2`和`3`处两次订阅了`Observable`。现在，看看输出结果。对于两次订阅调用，你从第一个到最后的发射都是完全相同的。
- en: Those `Observables`, which have this particular behavior, that is, emitting
    items from the beginning for each subscription, are called `Cold Observable`.
    To be more specific, `Cold Observables` start running upon subscriptions and `Cold
    Observable` starts pushing items after `subscribe` gets called, and pushes the
    same sequence of items on each subscription.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这些具有这种特定行为的`Observables`，即对每个订阅从开始处发射项目，被称为`Cold Observable`。更具体地说，`Cold Observables`在订阅时开始运行，`Cold
    Observable`在调用`subscribe`后开始推送项目，并在每个订阅上推送相同的项目序列。
- en: All the `Observable` factory methods we have used up until this chapter return
    `Cold Observables`. `Cold Observables` resemble data. When we are working with
    data, for example, say, while working with SQLite or Room database in Android,
    we rely more on `Cold Observables` than `Hot Observables`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中使用的所有`Observable`工厂方法都返回`Cold Observables`。`Cold Observables`类似于数据。当我们处理数据时，例如，在Android中使用SQLite或Room数据库时，我们更依赖于`Cold
    Observables`而不是`Hot Observables`。
- en: Hot Observables
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 热可观测对象
- en: '`Cold Observables` are passive, they don''t emit anything until subscribe is
    called. `Hot Observables` are contrary to `Cold Observables`; it doesn''t need
    subscriptions to start emission. While you can compare `Cold Observables` to CD/DVD
    recordings, `Hot Observables` are like TV channels—they continue broadcasting
    (emitting) their content, irrespective of whether anyone is watching (Observing)
    it or not.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cold Observables` 是被动的，它们在调用 `subscribe` 之前不会发出任何内容。`Hot Observables` 与 `Cold
    Observables` 相反；它不需要订阅就可以开始发射。虽然你可以将 `Cold Observables` 比喻为 CD/DVD 录音，但 `Hot Observables`
    更像电视频道——它们继续广播（发射）其内容，无论是否有观众（观察者）观看。'
- en: '`Hot Observables` resemble events more than data. The events may carry data
    with them, but there is a time-sensitive component where `Observers` that subscribed
    lately can miss out previously emitted data. They are specifically useful for
    UI events while working with Android/JavaFX/Swing. They are also very useful in
    resembling server requests.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hot Observables` 更像事件而不是数据。事件可能携带数据，但存在一个时间敏感的组件，其中最近订阅的 `Observers` 可能会错过之前发出的数据。它们在处理
    Android/JavaFX/Swing 中的 UI 事件时特别有用。它们在模拟服务器请求时也非常有用。'
- en: Introducing the ConnectableObservable object
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 `ConnectableObservable` 对象
- en: A great example of `Hot Observables` is `ConnectableObservable`. It is one of
    the most helpful forms of `Hot Observables` as well. It can turn any `Observable`,
    even a `Cold Observable`, into a `Hot Observable`. It doesn't start emitting on
    the `subscribe` call; instead, it gets activated after you call the `connect`
    method. You have to make the `subscribe` calls before calling `connect`; any `subscribe`
    calls after calling connect will miss the emissions fired previously.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConnectableObservable` 是 `Hot Observables` 的一个很好的例子。它是最有帮助的 `Hot Observables`
    形式之一。它可以将任何 `Observable`，甚至是一个 `Cold Observable`，转换为 `Hot Observable`。它不会在 `subscribe`
    调用时开始发射；相反，它在调用 `connect` 方法后才会激活。您必须在调用 `connect` 之前进行 `subscribe` 调用；任何在调用 `connect`
    之后进行的 `subscribe` 调用都会错过之前发出的发射。'
- en: 'Let''s consider the following code snippet:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下代码片段：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The main purpose of `ConnectableObservable` is for `Observables` with multiple
    subscriptions to connect all subscriptions of an `Observable` together so that
    they can react to a single push; contrary to `Cold Observables` that repeats operations
    for doing the push, and pushes separately for each subscription, thus repeating
    the cycle. `ConnectableObservable` connects all `subscriptions` (`Observers`)
    called before the `connect` method and relays a single push to all `Observers`,
    `Observers` then react to/process that push.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConnectableObservable` 的主要目的是为了具有多个订阅的 `Observables` 将一个 `Observable` 的所有订阅连接起来，以便它们可以响应单个推送；与重复操作以执行推送并针对每个订阅分别推送的
    `Cold Observables` 相反，从而重复循环。`ConnectableObservable` 连接在 `connect` 方法之前调用的所有 `subscriptions`（`Observers`），并将单个推送传递给所有
    `Observers`，然后 `Observers` 对该推送做出反应/处理。'
- en: In the preceding example, we created `Observable` with the `toObservable()`
    method, then, on comment `1`, we used the `publish` operator to convert `Cold
    Observable` into `ConnectableObservable`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用 `toObservable()` 方法创建了 `Observable`，然后在注释 `1` 上，我们使用了 `publish`
    操作符将 `Cold Observable` 转换为 `ConnectableObservable`。
- en: On comment `2`, we subscribed to `connectableObservable`. On comment `3`, we
    used the `map` operator to reverse `String`, and, on comment `4`, we subscribed
    to the mapped `connectableObservable`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释 `2` 上，我们订阅了 `connectableObservable`。在注释 `3` 上，我们使用了 `map` 操作符来反转 `String`，在注释
    `4` 上，我们订阅了映射后的 `connectableObservable`。
- en: On comment `5`, we called `connect` method, and emissions got started to both
    `Observers`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释 `5` 上，我们调用了 `connect` 方法，并且发射开始对两个 `Observers` 进行。
- en: Note that we used the `map` operator in this example on comment `3`. We will
    discuss the `map` operator in detail in [Chapter 5](e395e42a-afc0-4424-9d0f-2de06e19989d.xhtml), *Asynchronous
    Data Operators and Transformations*. However, here is the definition, if you are
    curious. The `map` operator applies a function of your choosing to each item emitted
    by the source `Observable`, and returns an `Observable` that emits the results
    of these function applications.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在示例中的注释 `3` 上使用了 `map` 操作符。我们将在第 5 章[异步数据操作符和转换](e395e42a-afc0-4424-9d0f-2de06e19989d.xhtml)中详细讨论
    `map` 操作符。然而，如果你好奇，这里就是定义：`map` 操作符将你选择的函数应用于源 `Observable` 发出的每个项目，并返回一个发出这些函数应用结果的
    `Observable`。
- en: 'Here is the output:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '![](img/7e4d31f4-e707-4f13-9e93-0f2e7ee48dc0.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7e4d31f4-e707-4f13-9e93-0f2e7ee48dc0.png)'
- en: Note that, as the output suggests, each emission goes to each `Observer` simultaneously,
    and they are processing data in an interleaved fashion.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，正如输出所示，每次发射都会同时发送到每个`Observer`，并且它们以交错的方式处理数据。
- en: This mechanism of emitting from `Observable` once and then relaying the emission
    to all `Subscriptions`/`Observers` is known as **multicasting**.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这种从`Observable`一次发射然后将其发射传递给所有`Subscriptions`/`Observers`的机制被称为**多播**。
- en: Also note that the `subscribe` call on comment `6`, after `connect`, has not
    received any emissions, as `ConnectableObservable` is hot, and any new subscriptions
    occurred after connect will miss out the emissions fired previously (between the
    call of the `connect` method and the new subscription, remember that, within a
    few milliseconds, computers can do a lot of tasks); in this case, it missed all
    the emissions.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，在`connect`之后的注释`6`上的`subscribe`调用没有收到任何发射，因为`ConnectableObservable`是热的，并且任何在连接之后发生的新订阅都会错过之前发射的发射（记住，在`connect`方法的调用和新订阅之间，计算机可以在几毫秒内完成很多任务）；在这种情况下，它错过了所有的发射。
- en: 'The following piece of code is another example to make you understand it better:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段是另一个例子，以使你更好地理解它：
- en: '[PRE13]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This example is almost the same as the previous one, just a few tweaks.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子几乎和上一个例子一样，只是做了一些小的调整。
- en: Here, we used the `Observable.interval` method to create `Observable`; the benefit
    is that, as it takes an interval before each emission, it will give some room
    to the subscription after connect to get a few emissions.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`Observable.interval`方法来创建`Observable`；好处是，由于它在每次发射之前都有一个间隔，因此它会给订阅者在连接后提供一些空间来获取一些发射。
- en: On comment `1`, we converted `Cold Observable` to `ConnectableObservable`, as
    with the previous one, and did two subscriptions and then connected, as in the
    previous example (comment `2`, `3`, `4`).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释`1`上，我们将`Cold Observable`转换为`ConnectableObservable`，就像上一个例子一样，然后进行了两次订阅，然后连接，就像上一个例子中的注释`2`、`3`、`4`一样。
- en: We called delay right after connect on comment `5`, then subscribed again on
    comment `6`, and again a delay on comment `7` to allow the `3`^(rd) subscription
    to print some data.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在注释`5`上直接调用延迟，然后在注释`6`上再次订阅，然后在注释`7`上再次延迟，以允许第`3`次订阅打印一些数据。
- en: 'The following output will allow us to understand better:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出将使我们更好地理解：
- en: '![](img/bcd8f60d-15e5-4168-b18b-6d90822b6a24.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bcd8f60d-15e5-4168-b18b-6d90822b6a24.png)'
- en: Go through the output carefully to note that the `3`^(rd) subscription received
    emissions from sequence `5`, and missed all previous ones (there were `5` emissions
    before the `3rd subscription`—500 millisecond delay/100 millisecond interval).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细查看输出，注意第`3`次订阅收到了序列`5`的发射，并且错过了所有之前的发射（在`3`次订阅之前有`5`次发射——500毫秒延迟/100毫秒间隔）。
- en: Subjects
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主题
- en: Another great way to implement `Hot Observables` is `Subject`. Basically, it
    is a combination of `Observable` and `Observer`, as it has many common behaviors
    to both `Observables` and `Observers`. Like `Hot Observables`, it maintains an
    internal `Observer` `list` and relays a single push to every `Observer` subscribed
    to it at the time of emission.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`Hot Observables`的另一种伟大方式是`Subject`。基本上，它是由`Observable`和`Observer`组合而成的，因为它具有许多与两者都共同的行为。就像`Hot
    Observables`一样，它维护一个内部的`Observer`列表，并在发射时将单个推送传递给当时订阅它的每个`Observer`。
- en: 'So, let''s take a look at what `Subject` has to offer us. And why is it called
    a combination of `Observables` and `Observers`? Please refer to the following
    points:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们来看看`Subject`能为我们提供什么。为什么它被称为`Observables`和`Observers`的组合？请参考以下要点：
- en: It has all the operators that `Observable` should have.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它拥有`Observable`应该拥有的所有操作符。
- en: Like `Observer`, it can listen to any value emitted to it.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就像`Observer`一样，它可以监听发送给它的任何值。
- en: After `Subject` is completed/errored/unsubscribed, it cannot be reused.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`Subject`完成/出错/取消订阅后，它不能被重用。
- en: The most interesting point is that it passes values through itself. As an explanation,
    if you pass a value with `onNext` to a `Subject` (`Observer`) side, it will come
    out of the `Observable` side of it.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最有趣的一点是它通过自己传递值。作为解释，如果你通过`onNext`将一个值传递给`Subject`（`Observer`）一侧，它将从中的一侧`Observable`出来。
- en: 'So, `Subject` is a combination of `Observable` and `Observer`. You have already
    seen the use of `Subject` in the previous chapters, but, to make things clearer,
    let''s take a new example:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`Subject`是`Observable`和`Observer`的组合。您已经在之前的章节中看到了`Subject`的使用，但为了使事情更清晰，让我们举一个新的例子：
- en: '[PRE14]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s check the output first, and then we will explain the code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先检查输出，然后我们将解释代码：
- en: '![](img/5c44c2ba-d572-4d82-8192-fb39bc96079f.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5c44c2ba-d572-4d82-8192-fb39bc96079f.png)'
- en: Now, let's understand the code. In this program, we have used the good old `Observable.interval`
    method. So, on comment `1`, we again created an instance of `Observable` with
    `Observable.interval`, with a 100 millisecond interval.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们理解代码。在这个程序中，我们使用了古老的`Observable.interval`方法。所以，在注释`1`中，我们再次使用`Observable.interval`创建了一个`Observable`实例，间隔为100毫秒。
- en: On comment `2`, we created `Subject` with `PublishSubject.create()`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释`2`中，我们使用`PublishSubject.create()`创建了`Subject`。
- en: There are many types of `Subject` available. `PublishSubject` is one of them.
    `PublishSubject` emits to an `observer` only those items that are emitted by the
    `Observable` sources subsequent to the time of the subscription.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的`Subject`类型有很多。`PublishSubject`就是其中之一。`PublishSubject`只会向`observer`发出那些在订阅时间之后由`Observable`源发出的项目。
- en: We will discuss in detail about the various types of `Subject` in the next section
    in this chapter.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章下一节详细讨论`Subject`的各种类型。
- en: On comment `3`, we used the `Subject` instance just like `Observer`, to subscribe
    to the emissions by the `Observable` instance. On comment `4`, we used the `Subject`
    instance like an `Observable` and subscribed with lambda to listen to the emissions
    by the `Subject` instance.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释`3`中，我们像使用`Observer`一样使用了`Subject`实例，来订阅`Observable`实例的发射。在注释`4`中，我们像使用`Observable`一样使用了`Subject`实例，并用lambda表达式订阅以监听`Subject`实例的发射。
- en: You probably got used to it with the code in comment `5`; if not, then we used
    it to make the program wait for `1100` milliseconds so that we can see the outputs
    made by the interval program. You can think of the `delay` method as similar to
    the `sleep` method in Java, the only difference here is that you must use `delay`
    inside a `Coroutine context`, so, in order to use `delay` method, you have to
    specify and start a `Coroutine context`; this is not quite possible always. The
    `runBlocking` method is there to help you in that scenario; it mocks a `Coroutine
    context` inside the calling thread while blocking that thread until `runBlocking`
    completes executing all its code.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经习惯了注释`5`中的代码；如果没有，那么我们使用它来使程序等待`1100`毫秒，以便我们可以看到由间隔程序产生的输出。你可以将`delay`方法视为类似于Java中的`sleep`方法，唯一的区别在于在这里你必须在一个`Coroutine
    context`中使用`delay`，因此，为了使用`delay`方法，你必须指定并启动一个`Coroutine context`；这并不总是可能的。`runBlocking`方法就是为了帮助你在那种情况下；它在调用线程内部模拟一个`Coroutine
    context`，同时阻塞该线程直到`runBlocking`完成所有代码的执行。
- en: The `Subject` instance listens to the emissions by the `Observable` instance
    and then broadcasts those emissions to its `Observers`, very likely, to a TV Channel
    broadcasting a Film (from a CD/DVD recording).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`Subject`实例监听`Observable`实例的发射，然后将这些发射广播给它的`Observers`，很可能就像一个正在播放电影（从CD/DVD录制）的电视频道。'
- en: 'You are probably thinking, what is the benefit of that? When I can directly
    `subscribe` and `Observer` to `Observable`, why should I use `PublishSubject`
    in between? To find the answers, let''s modify this code a little bit in a way
    that will help us understand it better:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道这有什么好处？当我可以直接将`subscribe`和`Observer`订阅到`Observable`上时，为什么要在中间使用`PublishSubject`？为了找到答案，让我们稍微修改一下这段代码，以便更好地理解它：
- en: '[PRE15]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, the code is almost the same until comment `5` (except on `Subscribe` on
    comment `3`, where I prepended `Subscription` `1` to the `String` output).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，代码直到注释`5`几乎相同（除了注释`3`中的`Subscribe`，我在字符串输出前添加了`Subscription` `1`）。
- en: On comment `6`, we again subscribed to `subject`. As we are subscribing after
    `1100` milliseconds, it should receive emissions after the first 11 emissions.
    On comment `7`, we are again making the program wait by `1100` milliseconds.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释`6`中，我们又订阅了`subject`。由于我们在`1100`毫秒后订阅，它应该会在前11次发射之后接收发射。在注释`7`中，我们再次通过`1100`毫秒使程序等待。
- en: 'Let''s see the output:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看输出：
- en: '[PRE16]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the output, it is printing the second subscription from the `12`^(th) emission
    (sequence `11`). So, `Subject` doesn't replay the actions such as `Cold Observables`,
    it just relays the emission to all `Observers`, turning a `Cold Observable` into `Hot
    Oberservale` one.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，它正在打印从第`12`次发射（序列`11`）开始的第二次订阅。所以，`Subject`不会重放像`Cold Observables`这样的操作，它只是将发射转发给所有`Observers`，将`Cold
    Observable`转换为`Hot Observers`。
- en: Varieties of Subject
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Subject`的多样性'
- en: 'As we mentioned earlier, there are a lot of varieties available for `Subject`s.
    As we have gained some grip in `Subject`, let''s now dive into varieties of `Subject`
    to understand it better. So, these are some of the most useful and important varieties
    of `Subject`, which we will discuss here:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，`Subject`有很多种可用。既然我们在`Subject`上已经有所掌握，现在让我们深入了解`Subject`的各种类型，以更好地理解它。所以，这里是一些最有用和最重要的`Subject`类型，我们将在下面讨论：
- en: '`AsyncSubject`'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AsyncSubject`'
- en: '`PublishSubject`'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PublishSubject`'
- en: '`BehaviorSubject`'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BehaviorSubject`'
- en: '`ReplaySubject`'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReplaySubject`'
- en: Understanding AsyncSubject
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解`AsyncSubject`
- en: '`AsyncSubject` only emits the last value of the source observable (`Observable`
    it listens on), and the last emission only. To say things more clearly, `AsyncSubject`
    will emit the last value it got, and will emit it only one time.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncSubject`只发射源`Observable`（它监听的`Observable`）的最后一个值，并且只发射最后一个发射。为了更清楚地说明，`AsyncSubject`将发射它得到的最后一个值，并且只发射一次。'
- en: 'This is a marble diagram for `AsyncSubject`, which has been taken from ReactiveX
    documentation ([http://reactivex.io/documentation/subject.html](http://reactivex.io/documentation/subject.html)):'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`AsyncSubject`的弹珠图，它来自ReactiveX文档（[http://reactivex.io/documentation/subject.html](http://reactivex.io/documentation/subject.html)）：
- en: '![](img/beb3bc54-c9d7-4e3c-b25c-a102fcb273b3.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/beb3bc54-c9d7-4e3c-b25c-a102fcb273b3.png)'
- en: 'Let''s consider the following code example:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下代码示例：
- en: '[PRE17]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here is the output:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE18]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this example, we created an example with `Observable.just`, with `4` integers
    (on comment `1`). Then, on comment `2`, we created an `AsyncSubject` example.
    After that, on comment `3` and `4`, like the previous example, we subscribed to
    the `observable instance` with `subject` and then subscribed to the `Subject`
    instance with lambda; only this time, we passed all the three methods—`onNext`,
    `onError`, and `onComplete`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`Observable.just`创建了一个示例，包含`4`个整数（在注释`1`处）。然后，在注释`2`处，我们创建了一个`AsyncSubject`示例。之后，在注释`3`和`4`处，就像前面的例子一样，我们用`subject`订阅了`observable
    instance`，然后用lambda订阅了`Subject`实例；只是这次，我们传递了所有三个方法——`onNext`、`onError`和`onComplete`。
- en: On comment `6`, we called `onComplete`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释`6`处，我们调用了`onComplete`。
- en: As the output suggests, `Subject` only emitted the last value it got, that is,
    `4`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如输出所示，`Subject`只发射了它得到的最后一个值，即`4`。
- en: On `Subject` instances, you can pass values directly with the `onNext` method,
    without subscribing to any `Observable`. Recall the examples in the previous chapters
    where we used `Subject` (`PublishSubject`); there, we only used `onNext` to pass
    the values. You can subscribe to another `Observable` with `Subject`, or pass
    values with `onNext`. Basically, when you subscribe to `Observable` with `Subject`, `Subject`
    calls its `onNext` internally upon `Observable`'s value emission.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Subject`实例上，你可以直接通过`onNext`方法传递值，而不需要订阅任何`Observable`。回想一下前几章中的例子，我们使用了`Subject`（`PublishSubject`）；在那里，我们只使用了`onNext`来传递值。你可以用`Subject`订阅另一个`Observable`，或者用`onNext`传递值。基本上，当你用`Subject`订阅`Observable`时，`Subject`会在`Observable`值发射时内部调用其`onNext`。
- en: 'Have doubts? Let''s tweak the code a little. Instead of subscribing to an `Observable`,
    we will call `onNext` only to pass values, and will have another subscription.
    Here is the code, to do so:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 有疑问吗？让我们稍微调整一下代码。我们不会订阅`Observable`，而只会调用`onNext`来传递值，并将有另一个订阅。以下是代码，以这样做：
- en: '[PRE19]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here is the output:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '![](img/05ff90e1-c0fa-442e-9e9a-3daf83c4277d.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/05ff90e1-c0fa-442e-9e9a-3daf83c4277d.jpg)'
- en: Here, we passed all values via `onNext`; it only emitted the last value it got
    (`5`) to both of the subscriptions. Look carefully, the `1`^(st) subscription
    was before passing the last value. As `ConnectableObservable` starts emitting
    on call of `connect`, `AsyncSubject` emits its only value on call of `onComplete`
    only.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过`onNext`传递了所有值；它只将得到的最后一个值（`5`）发射给两个订阅。仔细观察，第一个订阅是在传递最后一个值之前。由于`ConnectableObservable`在调用`connect`时开始发射，`AsyncSubject`只在调用`onComplete`时发射其唯一值。
- en: Note that as the outputs suggest, `AsyncSubject` doesn't in an interleave manner,
    that is, it will replay its action multiple times to emit the value to multiple
    `Observers`, although it is only one value.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，正如输出所示，`AsyncSubject`不是以交错方式发射的，也就是说，它会多次重放其操作以将值发射给多个`Observers`，尽管它只发射一个值。
- en: Understanding PublishSubject
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解`PublishSubject`
- en: '`PublishSubject` emits all subsequent values that it got at the time of subscription,
    whether it got the value via the `onNext` method or through another subscription.
    We have already seen the application of `PublishSubject`, and it is the most commonly
    used `Subject` variant.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`PublishSubject`在订阅时发出它获取的所有后续值，无论它是通过`onNext`方法还是通过另一个订阅获取的。我们已经看到了`PublishSubject`的应用，它是最常见的`Subject`变体。'
- en: 'Here is a graphical representation of `PublishSubject` which has been taken
    from ReactiveX documentation ([http://reactivex.io/documentation/subject.html](http://reactivex.io/documentation/subject.html)):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`PublishSubject`的图形表示，它取自ReactiveX文档（[http://reactivex.io/documentation/subject.html](http://reactivex.io/documentation/subject.html)）：
- en: '![](img/0346f006-649d-4f52-a166-7be1b02c12f0.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0346f006-649d-4f52-a166-7be1b02c12f0.png)'
- en: Understanding BehaviorSubject
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解`BehaviorSubject`
- en: What if we combine `AsyncSubject` and `PublishSubject`? Or mix the benefits
    of both? `BehaviorSubject` emits the last item it got before the subscription
    and all the subsequent items at the time of subscription while working with multicasting,
    that is, it keeps an internal `list` of `Observers` and relays the same emit to
    all of its `Observers` without replaying.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`AsyncSubject`和`PublishSubject`结合起来呢？或者混合两者的优点？在多播工作时，`BehaviorSubject`会发出在订阅之前获取的最后一个项目以及订阅时的所有后续项目，即它保持一个内部的`观察者列表`并将相同的发出传递给所有其`观察者`，而不进行重放。
- en: 'Here is the graphical representation which has been taken from ReactiveX documentation
    ([http://reactivex.io/documentation/subject.html](http://reactivex.io/documentation/subject.html)):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是图形表示，取自ReactiveX文档（[http://reactivex.io/documentation/subject.html](http://reactivex.io/documentation/subject.html)）：
- en: '![](img/f45c48ad-aaa8-4225-8572-7e9ef9f358fd.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f45c48ad-aaa8-4225-8572-7e9ef9f358fd.png)'
- en: 'Let''s modify the last example with `BehaviorSubject` and see what happens:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用`BehaviorSubject`修改最后一个例子，看看会发生什么：
- en: '[PRE20]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here, I took the last example where we worked with `AsyncSubject`, and modified
    it with `BehaviorSubject`. So, let''s see the output and understand `BehaviorSubject`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我选取了上一个例子，其中我们使用了`AsyncSubject`，并用`BehaviorSubject`进行了修改。那么，让我们看看输出并理解`BehaviorSubject`：
- en: '[PRE21]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: While the `1`^(st) subscription gets `4` and `5`; `4` was emitted before its
    subscription and `5` after. For the `2`^(nd) subscription, it only got `5`, which
    was emitted before its subscription.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当第一个订阅获得`4`和`5`时；`4`是在其订阅之前发出的，而`5`是在之后。对于第二个订阅，它只获得了`5`，这是在其订阅之前发出的。
- en: Understanding ReplaySubject
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解`ReplaySubject`
- en: It is more like `Cold Observable`; it will replay all the items it got, regardless
    of when `Observer` subscribes.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 它更像是`冷观察者`；无论`观察者`何时订阅，它都会重新播放它获取的所有项目。
- en: 'Here is the graphical representation:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是图形表示：
- en: '![](img/c7550a0a-2d57-4c56-beca-ce76ce213749.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c7550a0a-2d57-4c56-beca-ce76ce213749.png)'
- en: 'Image credit: [http://reactivex.io/documentation/subject.html](http://reactivex.io/documentation/subject.html)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图片来源：[http://reactivex.io/documentation/subject.html](http://reactivex.io/documentation/subject.html)
- en: 'Let''s modify the previous program with `ReplaySubject`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用`ReplaySubject`修改之前的程序：
- en: '[PRE22]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And, here is the output:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这里是输出：
- en: '[PRE23]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It emitted all of the items for both the subscriptions.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 它为两个订阅都发出了所有项目。
- en: Summary
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about `Observables` and `Observers` and how to use
    them. We worked with several examples to get our grips strong on them. We learned
    that there are two categories of `Observables`—`Hot Observables` and `Cold Observables`.
    We also learned about several `Subject` and its variant. Several `Subject` are
    basically a combination of `Observables` and many `Observer`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了`Observables`和`Observers`以及如何使用它们。我们通过几个例子来加强我们对它们的掌握。我们了解到`Observables`有两种类型——`热Observables`和`冷Observables`。我们还学习了几个`Subject`及其变体。几个`Subject`基本上是`Observables`和许多`Observer`的组合。
- en: While `Observables` provide us with great flexibilities and power, it too has
    some disadvantages, such as backpressure. Curious about it? Want to know more
    about the disadvantages of `Observables` and how to overcome them? Rush to the
    fourth chapter then.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`Observables`为我们提供了极大的灵活性和功能，但它也有一些缺点，比如背压。对此好奇吗？想了解更多关于`Observables`的缺点以及如何克服它们的信息？那么就赶快翻到第四章吧。
