- en: Chapter 3. Sprites
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 精灵
- en: In the previous chapter, we set up our first scene, learned about the rendering
    of nodes in a scene, added multiple scenes in a project, and learned about doing
    transitions from one scene to another.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们设置了我们的第一个场景，学习了场景中节点的渲染，在一个项目中添加了多个场景，并学习了从一个场景到另一个场景的过渡。
- en: In this chapter, we will learn about sprites. A sprite is a two-dimensional
    image, integrated into scene. A collection of sprites is called **sprite sheet**.
    Here we will learn about how to add sprites in a game, positioning a sprite, texture
    atlases, and how to transform a sprite in our game.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习关于精灵的内容。精灵是一个二维图像，集成到场景中。精灵的集合称为**精灵表**。在这里，我们将学习如何在游戏中添加精灵、定位精灵、纹理图集以及如何在我们的游戏中变换精灵。
- en: In Sprite Kit, a game is based on the node tree hierarchy. Scene acts as a root
    node and other nodes added to it are child nodes. Once all nodes are rendered
    into scene, we get the view. Sprites are also added to a game as a node; Sprite
    Kit provide us `SKSpriteNode` class for this purpose. In the previous chapter,
    we added background sprite and play button sprite by making the `SKSpriteNode`
    reference and adding it to the respective scenes. Now we will discover more about
    what Sprite Kit provided us in the `SKSpriteNode` class, and what else we can
    do with it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Sprite Kit 中，游戏基于节点树层次结构。场景作为根节点，其他添加到其中的节点是子节点。一旦所有节点都渲染到场景中，我们就得到了视图。精灵也作为节点添加到游戏中；Sprite
    Kit 为此提供了 `SKSpriteNode` 类。在前一章中，我们通过创建 `SKSpriteNode` 引用并将其添加到相应场景中，添加了背景精灵和播放按钮精灵。现在我们将发现
    Sprite Kit 在 `SKSpriteNode` 类中为我们提供了什么，以及我们可以用它做什么。
- en: SKSpriteNode
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SKSpriteNode
- en: The `SKSpriteNode` class is a root node class which is used to draw texture
    images with many customizations; it is inherited from the `SKNode` class. We can
    simply draw an image, or we can add some effects, such as custom shader or shadows
    to it. For this, we have to first know about the `SKSpriteNode` class and the
    functionality it offers.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`SKSpriteNode` 类是一个根节点类，用于以许多自定义方式绘制纹理图像；它继承自 `SKNode` 类。我们可以简单地绘制一个图像，或者我们可以添加一些效果，例如自定义着色器或阴影。为此，我们首先需要了解
    `SKSpriteNode` 类及其提供的功能。'
- en: Initializing a sprite
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化精灵
- en: 'To make a sprite in a game, we have to make an instance of the `SKSpriteNode`
    class. Sprite Kit provides us with many ways to initialize an instance of the
    `SKSpriteNode` class. Some of them are as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 要在游戏中创建一个精灵，我们必须创建 `SKSpriteNode` 类的一个实例。Sprite Kit 提供了许多初始化 `SKSpriteNode`
    类实例的方法。其中一些如下：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In Swift, one has to initialize a class by making an object of structure. There
    are two initializers provided for this purpose, that is, designated initializers
    and convenience initializers.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，必须通过创建结构体的对象来初始化一个类。为此提供了两个初始化器，即指定初始化器和便利初始化器。
- en: Designated initializers perform actual initialization for class properties.
    Now the question arises, "why convenience initializers are required?" During programming,
    sometimes, convenience initializers are very useful as they require less input
    parameters, and hand over actual initialization to designated initializers.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 指定初始化器为类属性执行实际初始化。现在问题来了，“为什么需要便利初始化器？”在编程过程中，有时便利初始化器非常有用，因为它们需要的输入参数较少，并将实际初始化工作交给指定初始化器。
- en: 'Some examples of initializers in Swift are as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 中初始化器的示例如下：
- en: '`convenience init(color color:UIColor!, size size: CGSize)`: This is used to
    initialize a colored sprite. If you want to make a sprite without using any texture
    and only by color, you can use this. It takes color and size as a parameter and
    returns a newly initialized sprite object.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`convenience init(color color:UIColor!, size size: CGSize)`: 这用于初始化一个彩色精灵。如果您想创建一个不使用任何纹理而仅使用颜色的精灵，可以使用此初始化器。它接受颜色和大小作为参数，并返回一个新初始化的精灵对象。'
- en: '`convenience init(imageNamed name: String)`: This initializer assigns texture
    to sprites. A sprite will be assigned texture from image name, which initializes
    the color of a sprite to white.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`convenience init(imageNamed name: String)`: 这个初始化器将纹理分配给精灵。精灵将从图像名称分配纹理，并将精灵的颜色初始化为白色。'
- en: '`convenience init(texture texture: SKTexture!)`: This initializer takes an
    existing texture sprite and returns a newly initialized sprite. The size of the
    sprite is set to the dimensions of the texture, and the color of the sprite is
    set to white `(1.0, 1.0, 1.0)`.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`convenience init(texture texture: SKTexture!)`: 这个初始化器接受一个现有的纹理精灵并返回一个新初始化的精灵。精灵的大小设置为纹理的尺寸，精灵的颜色设置为白色
    `(1.0, 1.0, 1.0)`。'
- en: '`init(texture texture: SKTexture!,color color: UIColor!,size size: CGSize)`:
    As explained earlier, this initializer requires convenience initializers as its
    parameter, so this is a designated initializer. Now, our *Platformer* game sprite
    will be initialized to the desired texture, color, and size. It returns a newly
    initialized sprite.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init(texture texture: SKTexture!,color color: UIColor!,size size: CGSize)`:
    如前所述，这个初始化器需要一个便利初始化器作为其参数，因此这是一个指定初始化器。现在，我们的*Platformer*游戏精灵将被初始化为所需的纹理、颜色和大小。它返回一个新初始化的精灵。'
- en: '`convenience init(texture texture: SKTexture!,size size: CGSize)`: This takes
    texture and size as parameters and returns a newly initialized sprite.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`convenience init(texture texture: SKTexture!,size size: CGSize)`: 这个初始化方法接受纹理和大小作为参数，并返回一个新初始化的精灵。'
- en: '`convenience init(imageNamed name: String, normalMapped generateNormalMap:
    Bool)`: This takes an image name and a Boolean value as a parameter and returns
    a newly initialized object.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`convenience init(imageNamed name: String, normalMapped generateNormalMap:
    Bool)`: 这个初始化方法接受一个图像名称和一个布尔值作为参数，并返回一个新初始化的对象。'
- en: '`convenience init(texture texture: SKTexture!,normalMap normalMap: SKTexture?)`:
    This takes two textures as parameters, one for sprite drawing and another for
    adding lighting behavior to the sprite. It returns a newly initialized sprite.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`convenience init(texture texture: SKTexture!,normalMap normalMap: SKTexture?)`:
    这个初始化方法接受两个纹理作为参数，一个用于精灵绘制，另一个用于向精灵添加光照行为。它返回一个新初始化的精灵。'
- en: After learning about initialization of `SKSpriteNode`, now it is time to get
    ourselves familiar with some physical properties of `SKSpriteNode`, such as `size`,
    `anchorPoint`, and so on.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了`SKSpriteNode`的初始化之后，现在是时候让我们熟悉一些`SKSpriteNode`的物理属性了，比如`size`、`anchorPoint`等等。
- en: The properties of SKSpriteNode
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`SKSpriteNode`的属性'
- en: Let us discuss the properties of `SKSpriteNode` in the following sections.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在以下章节中讨论`SKSpriteNode`的属性。
- en: Physical
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 物理
- en: 'Let us look at some physical properties of `SKSpriteNode`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`SKSpriteNode`的一些物理属性：
- en: '`size`: This property determines the size of a sprite in points. In our `GameScene`
    and `MenuScene` classes, we use this property in the background sprite to cover
    the screen.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size`: 这个属性决定了精灵在点上的大小。在我们的`GameScene`和`MenuScene`类中，我们使用这个属性在背景精灵上以覆盖屏幕。'
- en: '`AnchorPoint`: An anchor point is a point of co-ordinate related to sprite.
    Say, for example, co-ordinates for each corner of a sprite are `(0,0)`, `(1,0)`,
    `(0,1)`, and `(1,1)` representing corners bottom left, bottom right, top left,
    and top right respectively. These points of reference can be assigned as anchor
    points to draw a sprite on screen in respect. An assigned anchor point will position
    a sprite on screen, accordingly.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AnchorPoint`: 锚点是与精灵相关的坐标点。例如，一个精灵每个角落的坐标是`(0,0)`、`(1,0)`、`(0,1)`和`(1,1)`，分别代表左下角、右下角、左上角和右上角。这些参考点可以被分配为锚点，以便在屏幕上相应地绘制精灵。分配的锚点将根据情况在屏幕上定位精灵。'
- en: For example, assume that our anchor point for a sprite is `(0,0)`. If we position
    this sprite on screen, it will place itself from co-ordinate `(0,0)`, that is,
    bottom left. To position a sprite from the centre, we need to assign the anchor
    point co-ordinate `(0.5, 0.5)`.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，假设我们的精灵锚点是`(0,0)`。如果我们将这个精灵放置在屏幕上，它将从坐标`(0,0)`开始放置，即左下角。要将精灵从中心位置放置，我们需要将锚点坐标设置为`(0.5,
    0.5)`。
- en: But to add another node to this sprite, co-ordinate `(0,0)` of that node will
    be on the sprite's anchor point. What happens when we add scene to the view is
    that, co-ordinate `(0,0)` of scene, becomes the default anchor point.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 但要向这个精灵添加另一个节点，该节点的`(0,0)`坐标将位于精灵的锚点上。当我们向视图中添加场景时，场景的`(0,0)`坐标将成为默认的锚点。
- en: Physical properties of a sprite were well discussed under `size` and `anchorPoint`.
    Now it is time to discuss some properties which are related to texture in a sprite.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在`size`和`anchorPoint`下已经很好地讨论了精灵的物理属性。现在，是时候讨论一些与精灵纹理相关的属性了。
- en: Texture
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纹理
- en: It is an optional property in the `SKSpriteNode` class; that means it can be
    nil or will have texture. If it is nil, then the sprite will be drawn by using
    its `color` property in a rectangular shape, otherwise the sprite will be drawn
    using this texture.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 它是`SKSpriteNode`类中的一个可选属性；这意味着它可以nil或者将具有纹理。如果它是nil，那么精灵将通过使用其`color`属性以矩形形状绘制，否则精灵将通过这个纹理绘制。
- en: centerRect
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: centerRect
- en: This property is a very useful tool for creating rectangular buttons or any
    other fixed size elements in scene. When you use the `centerRect` property, you
    are actually controlling the scaling factor of texture for a rectangular portion
    specified by coordinates.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性是创建矩形按钮或场景中任何其他固定大小元素的一个非常有用的工具。当你使用`centerRect`属性时，你实际上是在控制由坐标指定的矩形部分的纹理缩放因子。
- en: By default, the rectangle covers the whole texture; that's why entire texture
    is stretched. But if this rectangle covers only a portion of the texture, then
    the texture could be visualized in a `3 * 3` grid, accounting this rectangle in
    the middle of the grid and drawing a line from its every edge on each side.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，矩形覆盖整个纹理；这就是为什么整个纹理都会被拉伸。但如果这个矩形只覆盖纹理的一部分，那么纹理就可以在一个`3 * 3`的网格中可视化，将这个矩形放在网格的中间，并在每侧从其每个边缘画一条线。
- en: '![centerRect](img/4201_03_03.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![centerRect](img/4201_03_03.jpg)'
- en: Original image
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 原始图像
- en: 'If we try to stretch the texture in both directions, then it will follow the
    rules given as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试在两个方向上拉伸纹理，那么它将遵循以下规则：
- en: The middle portion of the grid will stretch on each side, horizontally and vertically
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网格的中间部分将在每侧水平垂直拉伸
- en: All 4 corner portions of the grid will not be stretched
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网格的所有四个角落部分都不会被拉伸
- en: The upper and lower middle parts of the grid will be stretched horizontally![centerRect](img/4201_03_05.jpg)
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网格的上下中间部分将水平拉伸![centerRect](img/4201_03_05.jpg)
- en: Image stretched horizontally from the centre
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从中心水平拉伸的图像
- en: The left and right middle parts of the grid will be stretched vertically![centerRect](img/4201_03_04.jpg)
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网格的左右中间部分将垂直拉伸![centerRect](img/4201_03_04.jpg)
- en: Image stretched vertically from the centre
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从中心垂直拉伸的图像
- en: 'And, the following is another case where the image is stretched both vertically
    and horizontally:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以下是一个图像在垂直和水平方向上都被拉伸的情况：
- en: '![centerRect](img/4201_03_06.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![centerRect](img/4201_03_06.jpg)'
- en: Image stretched both vertically and horizontally from the centre
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 从中心垂直和水平拉伸的图像
- en: This is a very useful property to achieve some specific behavior of texture,
    such as making a health bar in the game, where we don't want to stretch the corner
    side of the texture, so that if they are rounded, they should not be deformed.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常有用的属性，可以实现纹理的一些特定行为，例如在游戏中制作生命条，我们不想拉伸纹理的角落部分，所以如果它们是圆角，它们不应该变形。
- en: Color
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 颜色
- en: '`SKSpriteNode` has some color properties too. Let''s read in detail about them:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`SKSpriteNode`也有一些颜色属性。让我们详细了解一下它们：'
- en: '`color`: This property is used to give color to a sprite. For example, you
    need to change the color of your sprite when the health bar is reduced to 50 percent,
    25 percent, and so on.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`color`: 这个属性用于为精灵添加颜色。例如，当生命条减少到50%、25%等时，你需要更改精灵的颜色。'
- en: '`colorBlendFactor`: This is used to control the color blending with the sprite
    texture. It can have a value between `0.0` to `1.0` (inclusive); `0.0` is default.
    If the value is `0.0,` that means the `color` property is ignored and texture
    values are used unmodified. If you increase the value, more color will be added
    to the sprite. For example, we can use this property to blend more color in our
    character with an increasing number of hits to the character:![Color](img/4201_03_07.jpg)'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`colorBlendFactor`: 这个属性用于控制精灵纹理的颜色混合。它可以在`0.0`到`1.0`（包含）之间取值；默认值为`0.0`。如果值为`0.0`，则表示忽略`color`属性，使用未修改的纹理值。如果你增加值，精灵将添加更多颜色。例如，我们可以使用这个属性来随着对角色攻击次数的增加，在我们的角色中混合更多颜色：![Color](img/4201_03_07.jpg)'
- en: Color effects due to change in value for colorBlendFactor
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于colorBlendFactor值的变化而产生的颜色效果
- en: '`blendMode`: This property is used to blend sprites according to scene. Every
    pixel color of a sprite and the color of the corresponding scene pixel under it,
    is compared by Sprite Kit renderer to assign a resulting color to the sprite.
    This property is very useful when you add a lighting effect or flash effect to
    your scene.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blendMode`: 这个属性用于根据场景混合精灵。精灵的每个像素颜色和其下对应场景像素的颜色，将由Sprite Kit渲染器比较，为精灵分配一个结果颜色。当你向场景添加光照效果或闪光效果时，这个属性非常有用。'
- en: 'In iOS 8, some lighting properties were added to generate a light and shadow
    effect on the sprites. Let''s have a look at them:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS 8中，为精灵添加了一些光照属性以生成光和影效果。让我们来看看它们：
- en: '`lightingBitMask`: This property is used to show a lighting effect on the sprite,
    and is tested against light''s `categoryBitMask` property by a logical AND operation.
    If the value is nonzero, the sprite will light up, or else it will remain unaffected
    by the light. Its default value is `0x00000000`.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lightingBitMask`：此属性用于在精灵上显示光照效果，并通过逻辑与操作与光的`categoryBitMask`属性进行测试。如果值为非零，精灵将发光，否则它将不受光的影响。其默认值为`0x00000000`。'
- en: '`shadowedBitMask`: This determines whether the sprite will be affected by the
    shadow generated by the light or not. This property is tested against light''s
    `categoryBitMask` property by a logical AND operation. If the value is nonzero,
    the sprite will the drawn using a shadowed effect, or else it will remain unaffected
    by the light. Its default value is `0x00000000`.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shadowedBitMask`：此属性确定精灵是否会被光照产生的阴影所影响。此属性通过逻辑与操作与光的`categoryBitMask`属性进行测试。如果值为非零，精灵将以阴影效果绘制，否则它将不受光的影响。其默认值为`0x00000000`。'
- en: '`shadowCastBitMask`: This determines whether or not the sprite will block the
    light and cast the shadow. This property is tested against light''s `categoryBitMask`
    property by a logical AND operation. If the value is nonzero, the sprite will
    cast a shadow past itself, or else it will remain unaffected by the light. Its
    default value is `0x00000000`.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shadowCastBitMask`：此属性确定精灵是否会阻挡光线并投射阴影。此属性通过逻辑与操作与光的`categoryBitMask`属性进行测试。如果值为非零，精灵将投射超出自身的阴影，否则它将不受光的影响。其默认值为`0x00000000`。'
- en: '`normalTexture`: A normal map texture is used when a sprite is lit, giving
    it a more realistic look with shadows and spectacular highlights. The texture
    must be a normal map texture.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`normalTexture`：当精灵被照亮时，使用正常贴图纹理，给它带来更逼真的外观，带有阴影和令人惊叹的高光。纹理必须是正常贴图纹理。'
- en: Along with the lighting property, with iOS 8, the shader property was also introduced
    to customize the rendering effects.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 除了光照属性外，iOS 8还引入了着色器属性来定制渲染效果。
- en: Shader
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 着色器
- en: The shader property is exclusively discussed in [Chapter 7](ch07.html "Chapter 7. Particle
    Effects and Shaders"), *Particle Effects and Shaders*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器属性在[第7章](ch07.html "第7章。粒子效果和着色器")中专门讨论，*粒子效果和着色器*。
- en: These are `SKSpriteNode` properties, by which we can use sprites by customizing
    them as we desire. The majority of a game consists of sprites, so it is important
    to know these properties and how we can use them. Now, it is time to use these
    properties in our game and see what effects they produce.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是`SKSpriteNode`属性，通过这些属性，我们可以根据我们的需求自定义精灵来使用。游戏的大部分内容都是由精灵组成的，因此了解这些属性以及我们如何使用它们非常重要。现在，是时候在我们的游戏中使用这些属性并看看它们会产生什么效果了。
- en: Adding a sprite without using textures
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加不带纹理的精灵
- en: 'Mostly in a game, we add texture to our sprite, but we can also make a sprite
    without using textures. A texture property is an optional property in the `SKSpriteNode`
    class. If texture is nil, that means we have no texture to stretch, so the contract
    parameter is ignored. Let''s open our `GameScene.swift` file and make a variable
    of `SKSpriteNode`, just below the `backgroundNode` declaration:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，我们通常会给我们的精灵添加纹理，但也可以不使用纹理来制作精灵。纹理属性是`SKSpriteNode`类中的一个可选属性。如果纹理为nil，这意味着我们没有可拉伸的纹理，因此收缩参数被忽略。让我们打开我们的`GameScene.swift`文件，在`backgroundNode`声明下方创建一个`SKSpriteNode`变量：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, with the preceding declaration, we have declared `spriteWithoutTexture`
    as optional. Since we have declared it optional, texture need not require a value.
    Now under `didMoveToView`, add following function:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有了前面的声明，我们已经将`spriteWithoutTexture`声明为可选的。由于我们已将其声明为可选的，纹理不需要值。现在在`didMoveToView`下添加以下函数：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After that, call this function inside `didMoveToView()`, below the `addBackGround()`
    function:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，在`didMoveToView()`函数中调用此函数，在`addBackGround()`函数下方：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now tap on play and see what happens. In our `GameScene` there is no change.
    Well that''s not what we desire. Actually, we missed the `z` position of our texture.
    That''s why it is rendering behind the background and not showing to us. Add this
    line in our `addSpriteWithoutTexture()` function, before `addChild(spriteWithoutTexture!)`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在点击播放，看看会发生什么。在我们的`GameScene`中没有变化。这不是我们想要的。实际上，我们遗漏了纹理的`z`位置。这就是为什么它渲染在背景后面，没有显示给我们。在我们的`addSpriteWithoutTexture()`函数中添加此行，在`addChild(spriteWithoutTexture!)`之前：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Run it. You will see a red square in the middle of the screen.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 运行它。你会在屏幕中间看到一个红色的正方形。
- en: The code is self-explanatory. We made an instance of `SKSpriteNode` by instantiating
    it. We are passing nil as parameter for texture, meaning we don't want texture
    for this sprite. As we have made this sprite reference optional, we will have
    to unwrap it before using any `SKSpriteNode` properties, and we do so by using
    the `!` mark after `spriteWithoutTexture`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 代码是自解释的。我们通过实例化创建了一个`SKSpriteNode`实例。我们传递nil作为纹理参数，这意味着我们不想为这个精灵添加纹理。由于我们已经使这个精灵引用为可选的，在使用任何`SKSpriteNode`属性之前，我们必须解包它，我们通过在`spriteWithoutTexture`后使用`!`标记来实现这一点。
- en: 'We can also initialize in another way. Delete the `texture` parameter from
    the initialization part:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以用另一种方式初始化。从初始化部分删除`texture`参数：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Change the preceding initialization part as shown in the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的初始化部分更改为如下所示：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Run the code and it will produce the same result as the previous one. It automatically
    assigns nil to texture, and initializes a sprite with a color and the specified
    bounds. Let's do something interesting with it.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码，它会产生与上一个相同的结果。它自动将nil分配给纹理，并初始化一个具有颜色和指定边界的精灵。让我们用它做一些有趣的事情。
- en: Changing the color property
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改颜色属性
- en: 'We are going to use `color` property to change color when a user taps on this
    sprite. For this, first give a name to `spriteWithoutTexture`, so that we can
    recognize a tap on it:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`color`属性在用户点击这个精灵时改变颜色。为此，首先给`spriteWithoutTexture`起一个名字，这样我们就能识别出对其的点击：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the following function in the `GameScene.swift` file to change color, as
    shown in the following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GameScene.swift`文件中添加以下函数以更改颜色，如下所示代码：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we use the `touchesBegan` function to detect touch by a user (as it was
    used previously in the `MenuScene` class):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们使用`touchesBegan`函数来检测用户的触摸（就像之前在`MenuScene`类中使用的那样）：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, after running Xcode, click on the colorful area in `GameScene`. You will
    see that area changing its color.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在运行Xcode后，点击`GameScene`中的彩色区域。你会看到该区域颜色发生变化。
- en: In this code, when a user taps on the sprite, it will add a value to the current
    one and call the `changeColor()` function. In the `changeColor()` function, we
    have taken a `switch` case to determine the color property of `spriteWithoutTexture`.
    In Swift, `switch` case is used as in many other languages. We don't have to use
    the `break` statement. Every `switch` statement must be *exhaustive*. That means,
    we have to make every single case check for switch case. Hence, we have to write
    a `default` value for every switch case.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，当用户点击精灵时，它将向当前值添加一个值并调用`changeColor()`函数。在`changeColor()`函数中，我们使用`switch`语句来确定`spriteWithoutTexture`的颜色属性。在Swift中，`switch`语句的使用方式与许多其他语言类似。我们不需要使用`break`语句。每个`switch`语句都必须是*详尽的*。这意味着我们必须对每个单独的情况进行检查。因此，我们必须为每个`switch`情况编写一个`default`值。
- en: If our texture is not nil, we can use the `colorBlendFactor` property to colorize
    the texture. We can use it for a tinting effect, such as damage taken in the game;
    `colorBlendFactor` is ignored if texture is nil. Its default value is `0.0`, which
    means that the texture should remain unmodified. When we increase the value, texture
    color is replaced with the blended color.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的纹理不是nil，我们可以使用`colorBlendFactor`属性来着色纹理。我们可以用它来实现着色效果，例如游戏中受到的伤害；如果纹理是nil，则忽略`colorBlendFactor`。它的默认值是`0.0`，这意味着纹理应该保持未修改状态。当我们增加值时，纹理颜色将被混合颜色所替代。
- en: Changing colorBlendFactor in MenuScene
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在`MenuScene`中更改`colorBlendFactor`
- en: 'Let''s add a tint to our play button. Open `MenuScene` and define a variable
    named `tintChanger` inside the `MenuScene` class as optional `Float`, so that
    we won''t need to assign a value to it in the initializer:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在播放按钮上添加一些色调。打开`MenuScene`并在`MenuScene`类中定义一个名为`tintChanger`的可选`Float`类型变量，这样我们就不需要在初始化器中为其分配值了：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the following function in the `MenuScene` class:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MenuScene`类中添加以下函数：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Call it from the `update` function:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 从`update`函数中调用它：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now run Xcode. You will see the **Play** button appearing and disappearing respectively.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行Xcode。你会看到**播放**按钮分别出现和消失。
- en: In this code, we just make a `Float` type variable. In our `tintPlayButton`
    function, we check if the value of its `colorBlendFactor` property is between
    `1` to `0`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们只创建了一个`Float`类型的变量。在我们的`tintPlayButton`函数中，我们检查其`colorBlendFactor`属性的值是否在`1`到`0`之间。
- en: 'Now let''s give it a color, inside the `addChildToScene` function:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在`addChildToScene`函数中给它一个颜色：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Run it and you will see the **Play** button changing its color from the original
    one to reddish. Now, it's time to see the position property in action.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 运行它，你会看到**播放**按钮的颜色从原始颜色变为红色。现在，是时候看看位置属性的实际效果了。
- en: Changing the position of a sprite
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改变精灵的位置
- en: 'Now, have a look at the `position` property of `SKSpriteNode`. Let''s open
    `GameScene` again, as we are going to see the `spriteWithoutTexture.position`
    property and the ways we can set it. Add this function below `changeColor`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`SKSpriteNode`的`position`属性。让我们再次打开`GameScene`，因为我们将要查看`spriteWithoutTexture.position`属性以及我们可以如何设置它。在`changeColor`函数下方添加此函数：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: And call it just below the `changeColor()` call.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 并且在`changeColor()`调用下方调用它。
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now if you will run it and tap inside your game scene, you will see `spriteWithoutTexture`
    changing its position and toggling between them.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果你运行它并在游戏场景中点击，你会看到`spriteWithoutTexture`改变位置并在它们之间切换。
- en: The most part of the code is the same as in `changecolor(),` except the position.
    In `case 0`, we set its position to `CGPointZero`. Position is measured in the
    `CGPoint` unit. `CGPointZero` is equivalent to `CGPointMake(0, 0)`. The position
    of a sprite depends on its `anchorPoint` as well as its parent `anchorPoint`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的大部分与`changecolor()`相同，除了位置。在`case 0`中，我们将它的位置设置为`CGPointZero`。位置是以`CGPoint`单位测量的。`CGPointZero`等同于`CGPointMake(0,
    0)`。精灵的位置不仅取决于其`anchorPoint`，还取决于其父`anchorPoint`。
- en: As we define `GameScene` `anchorPoint` to `(0.5 , 0.5)`, it means any other
    node which will be added to `GameScene` will have the starting `position(0,0)`,
    from the middle of the screen. That's why the background and `spriteWithoutTexture
    (0,0)` co-ordinate will be in middle of the screen.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将`GameScene`的`anchorPoint`定义为`(0.5 , 0.5)`，这意味着任何将被添加到`GameScene`的其他节点都将有起始位置`(0,0)`，从屏幕的中间开始。这就是为什么背景和`spriteWithoutTexture
    (0,0)`坐标将在屏幕中间。
- en: Now, as we specified the `anchorPoint` of `spriteWithoutTexture`, it will take
    its default value of `(0.5,0.5)`. This means that its `anchorPoint` will be in
    the center of it. Hence, in `case 0`, it is rendering in the middle of the screen
    symmetrically. In `case 1` and `case 2`, we just moved it to the right middle
    corner and left middle corner of the screen.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如我们指定的`spriteWithoutTexture`的`anchorPoint`，它将采用其默认值`(0.5,0.5)`。这意味着它的`anchorPoint`将位于其中心。因此，在`case
    0`中，它以对称的方式在屏幕中间渲染。在`case 1`和`case 2`中，我们只是将其移动到屏幕的右中角和左中角。
- en: 'Let''s try to change `anchorPoint` and see what happens. Add this line inside
    `addSpriteWithoutTexture`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试改变`anchorPoint`并看看会发生什么。在`addSpriteWithoutTexture`内部添加此行：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now run it.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行它。
- en: '![Changing the position of a sprite](img/4201_03_01.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![改变精灵的位置](img/4201_03_01.jpg)'
- en: Before tap
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Before tap
- en: '![Changing the position of a sprite](img/4201_03_02.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![改变精灵的位置](img/4201_03_02.jpg)'
- en: After tap
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: After tap
- en: You will see that all the positions are not as they were before. Can you guess
    the reason for this?
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现所有位置都不像之前那样了。你能猜出这个原因吗？
- en: In the preceding code line, we assigned the new value `(0,0)` to `spriteWithoutTexture`,
    which will remove its default value `(0.5,0.5)`. This means that its `anchorPoint`
    will not start from its middle. It will start from the bottom left of this. To
    visualize it, consider your sprite's top right corner as `1,1`, and bottom left
    corner as `0,0`. Now if you will set `anchorPoint` to `0,0`,it will be at the
    bottom left of the sprite. If you will take it to `0,1`, it will be at the top
    left. For `1,1`, it will at the top right and for `1,0`, it will at the bottom
    right. You can change it to whatever value you like, such as negative `(-1,-2)`
    and so on.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码行中，我们将新值`(0,0)`赋给了`spriteWithoutTexture`，这将移除其默认值`(0.5,0.5)`。这意味着它的`anchorPoint`将不会从中间开始。它将从这个的左下角开始。为了可视化它，考虑你的精灵的右上角为`1,1`，左下角为`0,0`。现在如果你将`anchorPoint`设置为`0,0`，它将在精灵的左下角。如果你将其设置为`0,1`，它将在左上角。对于`1,1`，它将在右上角，对于`1,0`，它将在右下角。你可以将其更改为任何你喜欢的值，例如负的`(-1,-2)`等等。
- en: 'Now, we can see that setting `anchorPoint` becomes easy once we are familiar
    with co-ordinate numbers on the screen. So, let''s test ourselves by setting the
    `spriteWithoutTexture` position to what it was before, using `0,0` as `anchorPoint`.
    Replace the `changePosition` function from this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到，一旦我们熟悉了屏幕上的坐标数字，设置`anchorPoint`就变得容易了。所以，让我们通过将`spriteWithoutTexture`的位置设置回之前的位置，使用`0,0`作为`anchorPoint`来测试一下。将`changePosition`函数替换为以下内容：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Add the following line inside the `addSpriteWithoutTexture()` function:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在`addSpriteWithoutTexture()`函数内部添加以下行：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now run it. You will see the same result as before, in your `GameScene`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行它。你将在`GameScene`中看到与之前相同的结果。
- en: In this code, we made a little adjustment. We want `spriteWithoutTexture` to
    be positioned in the center. As its `anchorPoint` is `(0,0)`, its bottom left
    corner will be in the middle of the screen. So, to show it in the middle of the
    screen, we have to set its position by subtracting half of each width and height
    with the middle screen points, which are `0,0`. Same goes for the left and right
    position of the `sprite`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们做了一些小的调整。我们希望`spriteWithoutTexture`位于中心。由于它的`anchorPoint`是`(0,0)`，其左下角将位于屏幕中央。因此，为了在屏幕中央显示它，我们必须通过从每个宽度和高度的中间点（`0,0`）减去一半的宽度和高度来设置其位置，这些中间点是屏幕的左上角。同样适用于精灵的左右位置。
- en: 'Now, just try to set `MenuScene anchorPoint` to `(1,1)`, inside the `GameViewController.swift`
    file, and try to adjust the button and background position by yourself. If you
    are unable to do so, just add the following code inside the `addChildToScene`
    function:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只需在`GameViewController.swift`文件中将`MenuScene anchorPoint`设置为`(1,1)`，并尝试自己调整按钮和背景的位置。如果你无法做到这一点，只需在`addChildToScene`函数中添加以下代码：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, if you run this code, you will notice the same result as before. After
    positioning, let's talk about resizing a sprite.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你运行这段代码，你会注意到与之前相同的结果。在定位之后，让我们谈谈调整精灵大小。
- en: Resizing a sprite
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整精灵大小
- en: 'As the `SKSpriteNode` class is inherited from the `SKNode` class, it also inherits
    `xScale` and `yScale` properties from the `SKNode` class. In our scene, we have
    given the background the same width as our view. We will achieve the same result
    as before, if we use its original size and scale its width and height. Open the
    `GameScene` class and update the `addBackGround` function as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`SKSpriteNode`类是从`SKNode`类继承的，它也从`SKNode`类继承了`xScale`和`yScale`属性。在我们的场景中，我们已经将背景的宽度设置为与我们的视图相同。如果我们使用其原始尺寸并缩放其宽度和高度，我们将得到与之前相同的结果。打开`GameScene`类，并更新`addBackGround`函数如下：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We have modified the function, `addBackGround()`. to enable our game to detect
    the screen dimensions of our device. This gives portability to our game (for example,
    the iPhone 5 and iPhone 6 have different screen dimensions). Now this function
    will return two float values as the ratio of screen size and background size in
    both width and height. After setting those to `backgroundNode.xScale` and `backgroundNode.yScale`,
    if you run this code, you will get the same result as before.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经修改了函数`addBackGround()`，以便我们的游戏能够检测设备的屏幕尺寸。这使我们的游戏具有可移植性（例如，iPhone 5和iPhone
    6的屏幕尺寸不同）。现在这个函数将返回两个浮点值，作为屏幕尺寸和背景尺寸在宽度和高度上的比例。在将它们设置为`backgroundNode.xScale`和`backgroundNode.yScale`之后，如果你运行这段代码，你将得到与之前相同的结果。
- en: Working with texture objects
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与纹理对象一起工作
- en: 'When a sprite is created, Sprite Kit creates a texture also. But sometime we
    require texture to do some complex work, such as:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建精灵时，Sprite Kit也会创建一个纹理。但有时我们需要纹理来完成一些复杂的工作，例如：
- en: Changing the sprite
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改精灵
- en: Animation
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画
- en: Using the same texture between multiple sprites
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多个精灵之间使用相同的纹理
- en: Rendering a node tree into a texture like a screen shot
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将节点树渲染成纹理，就像屏幕截图一样
- en: To make this simple, Sprite Kit provides us the `SKTexture` class. We can make
    an object of this class and use it as we want.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，Sprite Kit为我们提供了`SKTexture`类。我们可以创建这个类的对象，并按需使用它。
- en: 'Open your `MenuScene.swift` file and make a reference of `SKTexture`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的`MenuScene.swift`文件，并创建一个`SKTexture`的引用：
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s make a function call, `generateTestTexture`, and call it from `didMoveToView`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个函数调用`generateTestTexture`，并在`didMoveToView`中调用它：
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Run it and you will see many play textures in a sequence. We have made these
    using only one texture. Earlier, we were making the `SKSpriteNode` object from
    an image name, allowing Sprite Kit to create texture. Now we are assigning a texture
    to the `SKNode` object, which was created by us. Now, as we have done many customizations
    with sprites, let's have a look at the texture atlas.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 运行它，你将看到一系列的播放纹理。我们只使用一个纹理就制作了这些纹理。之前，我们是从图像名称创建`SKSpriteNode`对象，允许Sprite Kit创建纹理。现在，我们将纹理分配给由我们创建的`SKNode`对象。现在，由于我们对精灵做了许多自定义，让我们看看纹理图集。
- en: What is a texture atlas?
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是纹理图集？
- en: A game's performance is dependent on the number of sprites used in it. The fewer
    the number of sprites, the more performance it gives. For this purpose, Sprite
    Kit provides texture atlases, which pack our image files automatically into one
    or more large images.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一个游戏的表现取决于其中使用的精灵数量。精灵数量越少，性能越好。为此，Sprite Kit 提供了纹理图集，它自动将我们的图像文件打包到一个或多个大图像中。
- en: It provides us with a way to improve the performance of our game by drawing
    multiple images with a single draw call. When the game is in the development phase,
    compiler goes through every folder to find the folders with the `*.atlas` format.
    When those folders are identified, all of the images inside them are combined
    into one or more large image files. So, if you want to use this, place your images
    inside a folder and then rename it by suffixing `.atlas` to its name.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 它为我们提供了一种通过单次绘制调用绘制多个图像来提高游戏性能的方法。当游戏处于开发阶段时，编译器会遍历每个文件夹以查找具有 `*.atlas` 格式的文件夹。当这些文件夹被识别后，它们内部的全部图像将合并成一个或多个大图像文件。因此，如果你想使用这个功能，请将你的图像放入一个文件夹中，然后通过在其名称后添加
    `.atlas` 后缀来重命名它。
- en: Now, we are going to add a player to `GameScene`. Let's take the player's all
    idle state images to a folder, and name it `idle.atlas`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将向 `GameScene` 添加一个玩家。让我们将玩家的所有空闲状态图像移动到一个文件夹中，并将其命名为 `idle.atlas`。
- en: 'Now in Xcode, in **Project Navigator**, right-click on your project and select
    **Add to Project**:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在 Xcode 中，在 **Project Navigator** 中，右键单击你的项目并选择 **Add to Project**：
- en: '![What is a texture atlas?](img/4201_03_08.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![什么是纹理图集？](img/4201_03_08.jpg)'
- en: Select the directory (not the files) and click on **Add**. Defaults should be
    OK, but make sure it's set to copy.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 选择目录（不是文件），然后点击 **Add**。默认值应该是 OK，但请确保它设置为复制。
- en: '![What is a texture atlas?](img/4201_03_09.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![什么是纹理图集？](img/4201_03_09.jpg)'
- en: 'Now we are going to add a player to our `GameScene`. Open `GameScene` and create
    the function, `addPlayer`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将向我们的 `GameScene` 添加一个玩家。打开 `GameScene` 并创建一个函数，名为 `addPlayer`：
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Comment on the `addSpriteWithoutTexture` function and call the `addPlayer`
    function. Your function will look as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `addSpriteWithoutTexture` 函数上注释并调用 `addPlayer` 函数。你的函数将如下所示：
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Convert to comment tap part from `touchesBegan` in the code. So that we don''t
    get stuck if a touch occurs; otherwise the image of the player may obstruct the
    touch:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码中的 `touchesBegan` 部分转换为注释，这样在发生触摸时我们不会卡住；否则，玩家的图像可能会阻挡触摸：
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, run it and see. You will see the player in the middle of the screen.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行它并查看。你将看到玩家位于屏幕中央。
- en: In this code, we made a `SKSpriteNode` instance by passing an image name inside
    it. It will search for the Atlas for that image. But if we have an identically
    named image inside our project, this image will be loaded instead of the texture
    atlas. You have to use whatever the name of your image is.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们通过传递图像名称来创建一个 `SKSpriteNode` 实例。它将搜索该图像的图集。但如果我们的项目中有一个同名图像，则将加载该图像而不是纹理图集。你必须使用你图像的任何名称。
- en: When we put images inside a folder with `.atlas` extension, Xcode generates
    one or more big images by combining all the images into one.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将图像放入一个以 `.atlas` 扩展名结尾的文件夹中时，Xcode 通过将所有图像合并成一个来生成一个或多个大图像。
- en: To see that packed image, go to your `Products` folder in your project.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看打包的图像，请转到你的项目中的 `Products` 文件夹。
- en: Right-click on the `.app` file there and click on **Show in Finder**, so that
    we can go to its directory.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在那里的 `.app` 文件上右键单击，然后点击 **Show in Finder**，这样我们就可以进入它的目录。
- en: Now, right-click on the `.app` file and select **Show Package Contents**.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `.app` 文件上右键单击并选择 **Show Package Contents**。
- en: After that, go to **Contents** | **Resources** | `*.atlasc`. Here you will see
    two files, an image, and a plist. If you will look at the image, you will find
    that images are combined into a texture, which has its height and width in the
    power of 2\. If you will open the plist, you will see that it contains the position
    of images inside the packed texture, so that we can access them directly using
    Texture Atlas.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，转到 **Contents** | **Resources** | `*.atlasc`。在这里，你会看到两个文件，一个图像和一个 plist。如果你查看图像，你会发现图像被合并成一个纹理，其高度和宽度都是
    2 的幂。如果你打开 plist，你会看到它包含了打包纹理中图像的位置，这样我们就可以直接使用 Texture Atlas 访问它们。
- en: 'You can access texture atlas also. Let''s use `TextureAtlas` and do something
    on tap:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以访问纹理图集。让我们使用 `TextureAtlas` 并在点击时做些事情：
- en: 'First of all make a texture atlas reference in `GameScene`:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在 `GameScene` 中创建一个纹理图集引用：
- en: '[PRE26]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After that, make a player reference outside of function so that we can use
    it in another function too:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，在函数外部创建一个玩家引用，这样我们就可以在另一个函数中使用它：
- en: '[PRE27]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now edit the `addPlayer` function as follows:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在按照以下方式编辑`addPlayer`函数：
- en: '[PRE28]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Make the function, `changeSpriteFromTextureAtlas()`, and call it from `touchesBegan`.
    Now, it should look like the following lines:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建函数`changeSpriteFromTextureAtlas()`，并在`touchesBegan`中调用它。现在，它应该看起来像以下几行：
- en: '[PRE29]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now, run and tap on the player. You will see that the player changes its sprite
    on tap.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行并点击玩家。你会看到玩家在点击时改变了它的精灵。
- en: We have created the `SKTextureAtlas` reference. We named it as `atlas` file
    and added it to project. Now we can fetch the image from the texture atlas file.
    This is the way through which we can directly access the texture atlas. Texture
    atlases are very useful to make animation sequences or level generations from
    tiles. We will talk about animation in further chapters.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了`SKTextureAtlas`引用。我们将其命名为`atlas`文件并将其添加到项目中。现在我们可以从纹理图集文件中获取图像。这是我们可以直接访问纹理图集的方式。纹理图集对于制作动画序列或从瓦片生成关卡非常有用。我们将在后续章节中讨论动画。
- en: Now, as we are using textures to make sprites, sometimes we might need to preload
    textures into memory. Let's discuss this in detail.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于我们正在使用纹理来制作精灵，有时我们可能需要将纹理预加载到内存中。让我们详细讨论这个问题。
- en: Preloading textures into memory
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预加载纹理到内存中
- en: Sprite Kit performs memory management very well. When a texture is needed to
    be rendered in scene, but is not prepared, Sprite Kit loads it into memory, and
    uploads it to the graphics hardware by converting it to a usable form. If many
    unloaded textures are needed at once, it might slow down the game. To avoid this,
    we need to preload textures before using them, especially in larger or more complex
    games.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Sprite Kit在内存管理方面表现良好。当一个纹理需要在场景中渲染，但尚未准备时，Sprite Kit将其加载到内存中，并通过将其转换为可用形式上传到图形硬件。如果需要一次性加载许多未加载的纹理，可能会减慢游戏速度。为了避免这种情况，我们需要在使用之前预加载纹理，尤其是在更大或更复杂的游戏中。
- en: This problem may arise when a user has to go from the level screen to the game
    screen. As the game screen may have many textures, it will need to load and might
    be slow due to the loading of texture. To avoid this, we can use the `SKTexture
    class preloadTextures(_:withCompletionHandler:)` function. It takes an array of
    SKTexture and a block, which is called after all the texture is loaded. So, we
    can use this block to load a scene.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户需要从关卡屏幕转到游戏屏幕时，可能会出现这个问题。由于游戏屏幕可能有多个纹理，它需要加载，并且由于纹理的加载可能会变慢。为了避免这种情况，我们可以使用`SKTexture
    class preloadTextures(_:withCompletionHandler:)`函数。它接受一个`SKTexture`数组和一个块，该块在所有纹理加载完成后被调用。因此，我们可以使用这个块来加载一个场景。
- en: For a small game, we can load all the textures at once, at game launch time.
    For a larger game, we will need to split the textures into different levels according
    to scene and other such criteria. The textures which are not useful to a level
    are discarded to save memory. And if the game is too big, we will need to load
    textures dynamically as the game runs.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个小游戏，我们可以在游戏启动时一次性加载所有纹理。对于一个大游戏，我们需要根据场景和其他标准将纹理分成不同的级别。对于对某个级别没有用的纹理，我们将丢弃它们以节省内存。如果游戏太大，我们还需要在游戏运行时动态加载纹理。
- en: As we load textures, we also need to remove the unnecessary textures from memory
    too. When a texture is loaded into memory, it stays there until its reference
    `SKTexture` object is deleted. To delete an `SKTexture` object, we have to remove
    the reference from it; this will make the texture unload from the memory.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载纹理的同时，我们还需要从内存中删除不必要的纹理。当一个纹理被加载到内存中时，它将保留在那里，直到其引用`SKTexture`对象被删除。要删除`SKTexture`对象，我们必须从它那里移除引用；这将使纹理从内存中卸载。
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we read about sprites in detail. We learned about how to initialize
    a sprite, and about the sizing and positioning of a sprite. We also learned about
    the various color properties of the sprite. The lighting and shader properties
    were also discussed. Finally, we discussed about the `Texture` object, usage of
    the texture atlas, and preloading of the texture into memory.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细了解了精灵。我们学习了如何初始化一个精灵，以及精灵的大小和位置。我们还学习了精灵的各种颜色属性。还讨论了光照和着色器属性。最后，我们讨论了`Texture`对象、纹理图集的使用以及纹理的预加载到内存中。
- en: In the next chapter, we will be learning about nodes and various other concepts
    of the tree node structure.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习关于节点和树节点结构的各种其他概念。
