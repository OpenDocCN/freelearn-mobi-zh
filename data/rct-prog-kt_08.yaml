- en: Testing RxKotlin Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试RxKotlin应用程序
- en: We have covered more than 60% of the book and have learned a lot of concepts.
    From the first chapter, starting with concepts of reactive programming till the
    previous chapter about concurrent execution and parallelism. But we cannot complete
    the application development without introducing a few tests. It is probably the
    most crucial point in the process of application development.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经覆盖了这本书的60%以上，学到了很多概念。从第一章开始，从反应式编程的概念到上一章关于并发执行和并行性的内容。但是，我们无法在不引入一些测试的情况下完成应用程序开发。这可能是应用程序开发过程中最关键的一点。
- en: 'This chapter is dedicated to testing. As Kotlin itself is relatively new, our
    first objective would be to learn testing in Kotlin. We will then proceed with
    testing in RxKotlin. The following are the topics we are going to cover in this
    chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章专门介绍测试。由于Kotlin本身相对较新，我们的第一个目标将是学习在Kotlin中进行测试。然后我们将继续学习在RxKotlin中的测试。以下是本章将要涵盖的主题：
- en: Introduction to unit testing and its importance
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试简介及其重要性
- en: Kotlin and JUnit, Kotlin-test
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin和JUnit，Kotlin-test
- en: Testing tools in RxKotlin
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RxKotlin中的测试工具
- en: Blocking subscribers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阻塞订阅者
- en: Blocking operators
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阻塞操作符
- en: '`TestObserver` and `TestSubscriber`'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TestObserver`和`TestSubscriber`'
- en: So let's get started.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧。
- en: Introduction to unit testing and its importance
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试简介及其重要性
- en: 'While testing is absolute necessary in application development, many novice
    developers get away with a few basic questions regarding testing. They are:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然测试在应用程序开发中是绝对必要的，但许多新手开发者逃避了一些关于测试的基本问题。他们是：
- en: What is unit testing? and why is it a developer's job?
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是单元测试？为什么它是开发者的工作？
- en: Why is unit testing so important?
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么单元测试如此重要？
- en: And, do we need to write unit tests for each section of our programs?
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那么，我们是否需要为程序的每个部分编写单元测试？
- en: We will start this chapter by answering these basic questions. If you would
    like to rather start with testing using RxKotlin directly, you can skip the first
    few sections in this chapter and start from *Testing tools in RxKotlin*. Though
    I would encourage you to read the chapter throughout, even if you have previous
    experience in testing with Kotlin.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个章节的开始就回答这些基本问题。如果你更愿意直接使用RxKotlin进行测试，你可以跳过本章的前几节，从*RxKotlin中的测试工具*开始。尽管我鼓励你通读本章，即使你之前有使用Kotlin进行测试的经验。
- en: Let's start by defining unit testing. Unit testing is a level of software testing
    where  the individual smallest testable components of a software (aka application),
    called **units** are tested. The purpose is to validate that each unit of the
    software performs as it was supposed to.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义一下单元测试。单元测试是软件测试的一个级别，其中软件（即应用程序）的最小可测试组件（称为**单元**）被测试。其目的是验证每个软件单元是否按预期执行。
- en: 'Unit tests can be done manually, but they are often automated. The sole purpose
    of automated unit testing is to reduce human error and eliminate any extra bugs/errors
    caused by them. To explain let''s first remember the proverb:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试可以手动进行，但通常都是自动化的。自动化单元测试的唯一目的是减少人为错误并消除由它们引起的任何额外错误/bug。为了解释这一点，我们首先记住这个谚语：
- en: To err is human
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 人非圣贤，孰能无过
- en: So, if we do the unit tests manually, the chances of additional errors or bugs
    will rise. Automated unit tests can eliminate this risk as they include minimal
    human effort.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们手动进行单元测试，额外的错误或bug的可能性会增加。自动化单元测试可以消除这种风险，因为它们包含最小的人为努力。
- en: Also, we need to document the tests we've performed, and we need to perform
    the same tests again with new ones with each incremental build of our product.
    Automated unit tests eliminate that extra effort, as you would be required to
    write the test once and then you can run them any time in the future. Also, automated
    unit tests also reduce documentation efforts.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们需要记录我们进行的测试，并且我们需要在产品每次增量构建时使用新的测试重新执行相同的测试。自动化单元测试消除了这项额外的工作，因为你只需要编写一次测试，然后你可以在未来的任何时间运行它们。此外，自动化单元测试还可以减少文档工作。
- en: Why is it a developer's job? Who would write the code for automated testing
    other than the developers?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么它是开发者的工作？除了开发者，还有谁会编写自动化测试的代码？
- en: Also, it is not possible for developers to give understanding to tester after
    completing each small units of an application. Even you may have completed some
    module, which is not yet on the GUI, so the tester or anyone else than you may
    not even be able to reach that unit to test. Also, it may not have any direct
    impact or relation with the UI/UX, it may be a small internal code part.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在完成应用程序的每个小单元后，开发者无法向测试者提供理解。即使你可能已经完成了一些模块，这些模块尚未在 GUI 上，因此测试者或其他人可能甚至无法到达该单元进行测试。此外，它可能没有直接的影响或与
    UI/UX 的关系，它可能是一个小的内部代码部分。
- en: To summarize, a developer better understands his code and he knows well what
    exactly he wants from that bunch of code. So the developer is the best person
    to write unit tests on that module.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，开发者更好地理解他的代码，并且他知道他确切地想要从这堆代码中得到什么。因此，开发者是编写该模块单元测试的最佳人选。
- en: Why is unit testing so important?
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么单元测试如此重要？
- en: Let's have a real-life example. Think of an engineer, creating a new motor or
    device. The engineer will test the functionality after completing each unit of
    that motor, rather than testing the whole motor at the end (though he / she will
    test the whole motor at the end, but will also test it repeatedly and incrementally
    while building it). The main reason behind this behavior is that if he / she doesn't
    do that, at the end it would take a lot effort to identify the exact problems
    (if any). While testing incrementally will allow you to fix any problem right
    away as soon as it arises. The same applies for software (applications) as well.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个现实生活中的例子来说明。想象一个工程师，正在创建一个新的电机或设备。工程师将在完成该电机的每个单元后测试其功能，而不是在最后测试整个电机（尽管他/她最终也会测试整个电机，但在构建过程中也会反复和逐步地进行测试）。这种行为的背后主要原因是，如果他/她不这样做，最终将需要大量努力来识别确切的问题（如果有的话）。而逐步测试将允许你在问题出现时立即修复它。同样，这也适用于软件（应用程序）。
- en: You should perform unit tests periodically and repeatedly as you develop each
    module of your application the more you test the better is the out product. And
    yes, **we should write unit tests for each and every functional section of our
    applications**.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该定期和反复地执行单元测试，随着你开发应用程序的每个模块，测试越多，最终产品就越好。是的，**我们应该为应用程序的每个功能部分编写单元测试**。
- en: By **functional section** we mean each section that performs any small operation
    and/or function. We can skip testing a POJO class with just getters and setters,
    but we must test the code which uses that POJO class to accomplish something.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 **功能部分** 我们指的是执行任何小操作和/或功能的每个部分。我们可以跳过测试只有获取器和设置器的 POJO 类，但我们必须测试使用该 POJO
    类来完成某事的代码。
- en: So, as we've understood the importance of testing, let's start by writing JUnit
    tests in Kotlin.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，既然我们已经理解了测试的重要性，让我们从在 Kotlin 中编写 JUnit 测试开始。
- en: Writing JUnit tests in Kotlin
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Kotlin 中编写 JUnit 测试
- en: If you've any experience with Java development, you've heard of or most probably
    worked with JUnit. It is a testing framework, for Java (as well as Kotlin).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有任何 Java 开发的经验，你一定听说过或最可能使用过 JUnit。它是一个用于 Java（以及 Kotlin）的测试框架。
- en: 'Typically unit tests are created in a separate source folder than real source
    codes, to keep it separated. The standard Maven/Gradle convention uses `src/main`
    for real codes (Java/Kotlin files or classes) and `src/test` for test classes.
    The following screenshot shows the structure for the project we''re using in this
    book:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，单元测试是在与实际源代码分开的单独源文件夹中创建的，以保持其分离。标准的 Maven/Gradle 习惯使用 `src/main` 用于实际代码（Java/Kotlin
    文件或类）和 `src/test` 用于测试类。以下截图显示了本书中使用的项目的结构：
- en: '![](img/d1411a8e-1204-4043-b8f0-e45b8c0e3546.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d1411a8e-1204-4043-b8f0-e45b8c0e3546.jpg)'
- en: 'Before beginning to write test cases we''ve to add the following Gradle dependencies:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写测试用例之前，我们必须添加以下 Gradle 依赖项：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We've added a dependency to Mockito as well, which we are going to cover soon.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了对 Mockito 的依赖，我们将在不久的将来介绍它。
- en: 'So, we have got everything ready, let''s write our first test case. Please
    refer to the following code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经准备好了所有东西，让我们编写我们的第一个测试用例。请参考以下代码：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Have a close look at the preceding program. Each JUnit test case should be defined
    as a function inside a class. The class that contains the JUnit test functions
    should only be used for testing purposes and should not serve any other purpose.
    The `test` function should be annotated with the `@Test` annotation, as we did
    in comment `(1)`. This annotation helps JUnit to detect and execute the tests.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看看前面的程序。每个 JUnit 测试用例都应该定义为一个类内的函数。包含 JUnit 测试函数的类应仅用于测试目的，不应具有其他用途。`test`
    函数应使用 `@Test` 注解，就像我们在注释 `(1)` 中做的那样。这个注解帮助 JUnit 识别和执行测试。
- en: Now, give a cautious look at the line containing comment `(2)`. The function
    name is `` `my first test`() ``. Yes, it contains space within the function name.
    That is probably the best thing you can get while writing test cases in Kotlin.
    Kotlin allows you to have functions that have names without spaces, while they
    aren't good practice while writing codes, they are quite a life saver while writing
    tests; as you don't need to call the `test` functions elsewhere, they actually
    serve as readable test names.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，仔细看看包含注释 `(2)` 的那一行。函数名是 `` `my first test`() ``。是的，函数名中包含空格。这可能是你在 Kotlin
    编写测试用例时能得到的最好的东西。Kotlin 允许你拥有没有空格的函数名，虽然这在编写代码时不是好的实践，但在编写测试时它们实际上可以救命；因为你不需要在其他地方调用
    `test` 函数，它们实际上充当了可读的测试名称。
- en: In comment `(3)`, we wrote the actual test. The `assertEquals` test checks for
    equality between `expected` and `actual` values. The first parameter in this test
    is the expected value, and the second one is the actual one, which should be equal
    to the expected one.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释 `(3)` 中，我们编写了实际的测试。`assertEquals` 测试检查 `expected` 和 `actual` 值之间的相等性。此测试的第一个参数是预期值，第二个参数是实际值，它应该与预期值相等。
- en: 'If you run the test, you''ll get the following output:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行测试，您将得到以下输出：
- en: '![](img/3c3bbc91-307a-4ae7-b942-b154be390075.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3c3bbc91-307a-4ae7-b942-b154be390075.jpg)'
- en: 'If we modify the program and pass `2+3` instead of `1+2` as the actual parameter,
    then the test would fail and give the following output:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们修改程序并将 `2+3` 而不是 `1+2` 作为实际参数传递，那么测试将失败，并给出以下输出：
- en: '![](img/8089b0b9-8a7b-4f73-8b6d-edaac8af77b2.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8089b0b9-8a7b-4f73-8b6d-edaac8af77b2.jpg)'
- en: 'You can also pass a failure message, that would be shown in case of failure,
    as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以传递一个错误消息，该消息将在失败时显示，如下所示：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The message would be shown in the error report if the test fails. Have a look
    at the following output:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试失败，错误报告中将显示该消息。请查看以下输出：
- en: '![](img/d5bb218e-b0ed-4a1b-b1fc-67c9a0f6aacb.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d5bb218e-b0ed-4a1b-b1fc-67c9a0f6aacb.jpg)'
- en: Testing your code
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试您的代码
- en: In the earlier section, we learned how to write test cases, but did we test
    our code? No. We did the tests with some oblivious values. And we know that is
    not the purpose of tests. Tests are there to make sure that our functions, classes,
    and code blocks are working as expected.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分，我们学习了如何编写测试用例，但我们测试了我们的代码吗？没有。我们使用一些无意识的值进行了测试。我们知道这不是测试的目的。测试是为了确保我们的函数、类和代码块按预期工作。
- en: We should write the tests on top of our existing code (unless we are following
    **Test-driven development** (**TDD**)).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在现有的代码之上编写测试（除非我们正在遵循**测试驱动开发**（**TDD**））。
- en: Test-driven development is a development methodology where tests are written
    first, and then the actual source code is written that would pass the test cases.
    Test-driven development is hugely popular among developers and architects and
    many companies follow TDD as their development process.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动开发是一种开发方法，其中首先编写测试，然后编写实际的源代码以通过测试用例。测试驱动开发在开发人员和架构师中非常受欢迎，许多公司将其作为其开发流程遵循的
    TDD。
- en: 'The following is a small Kotlin file that contains a few methods for calculations,
    we would perform tests on top of this file:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个包含一些计算方法的 Kotlin 小文件，我们将在该文件上执行测试：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And, following class is with the test cases, go through the code carefully,
    and then we will describe it:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，以下类包含测试用例，仔细查看代码，然后我们将对其进行描述：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Have a look at the package declarations. Both files share the same package name,
    we deliberately did this, so that we would not have to import the functions.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 看看包声明。两个文件共享相同的包名，我们故意这样做，这样我们就不需要导入函数。
- en: We used the simplest functions in the source code so that you can understand
    the code easily. Also notice that we wrote each test case separately, just like
    a function, we can obviously call multiple test functions within a test case,
    though. Confused? Let's elaborate, when you're testing multiple aspects of a single
    function or property you can (and should) group them all inside a test function
    (a function with an `@Test` annotation). Generally, compilers display test results
    as they encounter test functions, irrespective of how many tests each test function
    performs. So rest assured that your tests will be performed if you group them
    inside a single test function, they will however be shown as a single test. However
    when you're writing tests for separate functions or properties you would obviously
    want a separate report for all of them, in that case you should write them separately
    just like the earlier example.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在源代码中使用了最简单的函数，这样你可以轻松理解代码。同时请注意，我们像函数一样单独编写了每个测试用例。虽然显然可以在一个测试用例中调用多个测试函数。困惑吗？让我们详细说明一下，当你测试单个函数或属性的多个方面时，你可以（并且应该）将它们全部组合在一个测试函数（带有`@Test`注解的函数）中。通常，编译器在遇到测试函数时会显示测试结果，而不考虑每个测试函数执行了多少测试。所以请放心，如果你将它们组合在一个单独的测试函数中，你的测试将会被执行，但它们将作为一个单独的测试显示。然而，当你为不同的函数或属性编写测试时，你显然希望为所有这些函数生成单独的报告，在这种情况下，你应该像前面的例子一样单独编写它们。
- en: 'Have a look at the output now:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看输出结果：
- en: '![](img/15b4f905-d6d2-405b-b7fe-863d5ea03638.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/15b4f905-d6d2-405b-b7fe-863d5ea03638.jpg)'
- en: 'But in each of the earlier examples, we used only `assertEquals`; seeing this,
    you may have a question, is `assertEquals` the only test function available? The
    answer is a big no. We''ve plenty of test functions available with Kotlin. The
    following are a few test cases with oblivious values, just to have an idea about
    the most useful test functions in Kotlin. Please refer to the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 但在每个先前的例子中，我们只使用了`assertEquals`；看到这一点，你可能会有疑问，`assertEquals`是唯一的测试函数吗？答案是绝对不是。我们有大量的测试函数可用。以下是一些具有未知值的测试用例，只是为了让你了解Kotlin中最有用的测试函数。请参考以下代码：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Before inspecting the test cases here, let''s have a look at the following
    test output screenshot:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查这里的测试用例之前，让我们看看以下测试输出截图：
- en: '![](img/c134e7e5-4609-4fb6-afe2-41b6282adaba.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c134e7e5-4609-4fb6-afe2-41b6282adaba.jpg)'
- en: Now, let's try to understand the code. We will start with the `` `expected block
    evaluation`() `` test. The `expect` test function takes the expected value as
    the first parameter and a block (lambda) as the second parameter, executes the
    lambda, and checks the return value against the expected value for equality.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试理解代码。我们将从``` `expected block evaluation`() ``测试用例开始。`expect`测试函数将期望值作为第一个参数，将一个块（lambda）作为第二个参数，执行lambda，并检查返回值与期望值是否相等。
- en: The second test case was `` `assert illegal value`() ``, in that test case we
    are using the `assertNotEquals()` test method. This test method does the exact
    opposite than the `assertEquals()`. It fails the test if both parameters are equal.
    The `assertNotEquals()` is especially useful when you've a function that should
    return any value except a particular one.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个测试用例是``` `assert illegal value`() ``，在该测试用例中，我们使用了`assertNotEquals()`测试方法。这个测试方法与`assertEquals()`相反。如果两个参数相等，则测试失败。`assertNotEquals()`在有一个函数应该返回任何值除了特定值时特别有用。
- en: In the `` `assert true boolean value`() `` and `` `assert true boolean value`()
    `` test cases we used `assertTrue()` and `assertFalse()` respectively. Both test
    methods takes a `Boolean` value as parameter. As the name suggests, `assertTrue()`
    expects the value to be `true`, while `assertFalse()` expects to be `false`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在``` `assert true boolean value`() ``和``` `assert true boolean value`() ``测试用例中，我们分别使用了`assertTrue()`和`assertFalse()`。这两个测试方法都接受一个`Boolean`值作为参数。正如其名所示，`assertTrue()`期望值是`true`，而`assertFalse()`期望值是`false`。
- en: The next two test cases are for nulls. The first one `` `assert that passed
    value is null`() `` uses `assertNull()`, which expects the passed value to contain
    `null`. The second one uses `assertNotNull()` in complete opposite way, expects
    the value would not be `null`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个测试用例是针对null值的。第一个``` `assert that passed value is null`() ``使用`assertNull()`，它期望传递的值包含`null`。第二个使用`assertNotNull()`，与`assertNull()`完全相反，它期望值不是`null`。
- en: So, as we got some hands-on idea on writing test cases, let's get started with
    testing in **RxKotlin**.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们对编写测试用例有了实际了解之后，让我们开始使用**RxKotlin**进行测试。
- en: Testing in RxKotlin
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在RxKotlin中进行测试
- en: Now, as you've some hands-on testing in Kotlin and have some idea about RxKotlin
    as well, you may be wondering how to implement test cases in RxKotlin? It is true
    that testing in RxKotlin may not seem straightforward; the reason is that ReactiveX
    defines behavior rather than states, and most testing frameworks, including JUnit
    and kotlin—test are good for testing states.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，既然您在 Kotlin 中有一些实际测试经验，也对 RxKotlin 有了一些了解，您可能想知道如何在 RxKotlin 中实现测试用例？在 RxKotlin
    中进行测试可能看起来并不直接；原因是 ReactiveX 定义的是行为而不是状态，而包括 JUnit 和 kotlin—test 在内的大多数测试框架都适用于测试状态。
- en: To the aid of developers, RxKotlin comes with a set of tools for testing, which
    you can use with your favorite testing frameworks. In this book, we will cover
    testing in RxKotlin with JUnit and Kotlin-test.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助开发者，RxKotlin 附带了一套用于测试的工具，您可以使用您喜欢的测试框架。在这本书中，我们将介绍如何使用 JUnit 和 Kotlin-test
    在 RxKotlin 中进行测试。
- en: So, what are we waiting for? Let's get started.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们在等待什么呢？让我们开始吧。
- en: Blocking subscribers
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阻塞订阅者
- en: 'Try to remember the code blocks from previous chapters, where we used `delay`
    to make the main thread wait whenever we used an `Observable` or `Flowable` that
    operates on a different thread. A perfect example of this scenario is when we
    used `Observable.interval` as a factory method or when we used the `subscribeOn`
    operator. To get you refreshed, following is such a code example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试回忆一下之前章节中的代码块，我们在使用 `delay` 使主线程等待时使用了它，无论我们使用的是在另一个线程上操作的 `Observable` 或
    `Flowable`。一个完美的例子是当我们使用 `Observable.interval` 作为工厂方法或使用 `subscribeOn` 操作符时。为了让您回忆起来，以下是一个这样的代码示例：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this example, we switched to `Schedulers.computation` for the subscription.
    Now let''s see, how we can test this Observable and check that we received exactly
    `10` emissions:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将订阅切换到了 `Schedulers.computation`。现在让我们看看，我们如何测试这个 Observable 并检查我们是否接收到了正好
    `10` 个发射：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s have a look at the testing result first before digging into the code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究代码之前，我们先看看测试结果：
- en: '![](img/01b50387-015c-466c-9a1f-781ddeeee7c0.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/01b50387-015c-466c-9a1f-781ddeeee7c0.jpg)'
- en: There are a few things that need explanations in this code. The first one is
    `AtomicInteger`. `AtomicInteger` is a wrapper around integer in Java, that allows
    an `Int` value to be updated atomically. Though `AtomicInteger` extends `Number`
    to allow uniform access by tools and utilities that deal with numerically-based
    classes, it cannot be used as a replacement of `Integer`. We used `AtomicInteger`
    in this code to ensure atomicity, as the subscription was running in the `computationScheduler`
    (thus in multiple threads).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，有几件事情需要解释。首先是 `AtomicInteger`。`AtomicInteger` 是 Java 中整数的一个包装器，它允许 `Int`
    值原子性地更新。尽管 `AtomicInteger` 扩展了 `Number` 以允许工具和实用程序以统一的方式访问基于数字的类，但它不能作为 `Integer`
    的替代品。我们在代码中使用 `AtomicInteger` 来确保原子性，因为订阅是在 `computationScheduler`（因此是多线程）中运行的。
- en: The line, that demands our attention is where we put comment `(2)`. We used
    `blockingSubscribe` instead of just `subscribe`. When we subscribe to a producer
    with the `subscribe` operator and the subscription is not in the current thread,
    the current thread doesn't wait for the subscription to complete and moves to
    the next line instantly. That's why we used delay to make the current thread wait.
    Using `delay` inside `tests` is troublesome. While `blockingSubscribe` blocks
    the current running thread until the subscription finishes up (even if the subscription
    occurs in a separate thread), that is useful while writing tests.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 需要我们注意的行是我们在其中放置注释 `(2)` 的地方。我们使用了 `blockingSubscribe` 而不是仅仅使用 `subscribe`。当我们使用
    `subscribe` 操作符订阅一个生产者，并且订阅不在当前线程时，当前线程不会等待订阅完成，而是立即移动到下一行。这就是为什么我们使用延迟来使当前线程等待。在
    `tests` 中使用 `delay` 是麻烦的。而 `blockingSubscribe` 会阻塞当前运行的线程直到订阅完成（即使订阅发生在另一个线程），这在编写测试时是有用的。
- en: Blocking operators
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阻塞操作符
- en: While `blockingSubscribe` is useful in testing, it cannot always serve your
    purpose. You might need to test the first, last or all the values of the producer.
    For that purpose you would need the data in its pure imperative nature.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `blockingSubscribe` 在测试中很有用，但它并不总是能满足您的需求。您可能需要测试生产者的第一个、最后一个或所有值。为此，您需要数据以纯命令式的方式。
- en: The set of yet uncovered operators in RxKotlin is at your helm in that scenario.
    The blocking operators serve as an immediate accessible bridge between the reactive
    world and the imperative world. They block the current thread and make it wait
    for the results to be emitted, but returns them in a non-reactive way.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在那种情况下，RxKotlin 中尚未发现的操作符集在你手中。阻塞操作符作为响应式世界和命令式世界之间立即可访问的桥梁。它们阻塞当前线程并使其等待结果被发出，但以非响应式的方式返回它们。
- en: The only similarity between `blockingSubscribe` and blocking operators are that
    both block the declaring thread even if the reactive operations are performed
    in a different thread.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`blockingSubscribe` 和阻塞操作符之间唯一的相似之处在于，即使响应式操作在另一个线程中执行，两者都会阻塞声明线程。'
- en: Other than this one, there are no more similarities. The `blockingSubscribe`
    treats the data as reactive and doesn't return anything. It rather pushes them
    to the subscriber (or lambda) specified. Whereas blocking operators will return
    the data in a non-reactive nature.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个之外，没有更多的相似之处。`blockingSubscribe` 将数据视为响应式，并且不返回任何内容。它而是将它们推送到指定的订阅者（或lambda）那里。而阻塞操作符将以非响应式的方式返回数据。
- en: 'The following list contains the blocking operators we are going to cover:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表包含我们将要介绍的阻塞操作符：
- en: '`blockingFirst()`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blockingFirst()`'
- en: '`blockingGet()`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blockingGet()`'
- en: '`blockingLast()`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blockingLast()`'
- en: '`blockingIterable()`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blockingIterable()`'
- en: '`blockingForEach()`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blockingForEach()`'
- en: Though we should avoid using them in production as they encourage anti-patterns
    and reduce the benefits of reactive programming, however we can surely use them
    for testing purposes.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们应该避免在生产环境中使用它们，因为它们鼓励反模式并减少了响应式编程的好处，但是我们可以肯定地用于测试目的。
- en: Getting the first emitted item – blockingFirst()
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取第一个发出的项 – blockingFirst()
- en: 'The first blocking operator we are going discuss is the `blockingFirst` operator.
    This operator blocks the calling thread until the first item is emitted and returns
    it. The following is an ideal test case for `blockingFirst()`, where we are performing
    a sorting operation on Observable and we are testing it by checking if the first
    emitted item is the smallest. Please refer to the following code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的第一个阻塞操作符是 `blockingFirst` 操作符。此操作符会阻塞调用线程，直到第一个项被发出并返回它。以下是一个理想的 `blockingFirst()`
    测试用例，其中我们在 Observable 上执行排序操作，并通过检查第一个发出的项是否是最小的来测试它。请参考以下代码：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The test result is as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 测试结果如下：
- en: '![](img/0690a3d8-3775-42db-85db-ec9f998ee39f.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0690a3d8-3775-42db-85db-ec9f998ee39f.jpg)'
- en: In the program, we created an unsorted list of integers from `1` to `10` and
    created an Observable with the list, so the smallest item from that Observable
    should be `1`. We obtained the first item and made the thread to wait till we
    get it with the help of the `blockingFirst()` operator.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序中，我们创建了一个从 `1` 到 `10` 的未排序整数列表，并使用该列表创建了一个 Observable，因此从该 Observable 中最小的项应该是
    `1`。我们获取了第一个项，并使用 `blockingFirst()` 操作符使线程等待，直到我们获取到它。
- en: Then used the `assertEquals` testing function to assert that the first emitted
    item is `1`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用 `assertEquals` 测试函数来断言第一个发出的项是 `1`。
- en: Getting the only item from single or maybe - blockingGet
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从单个或 maybe 中获取唯一项 – blockingGet
- en: When you're working with `single` or `maybe`, you just can't use any other blocking
    operator other than `blockingGet()`. The reason is quite simple, both monads can
    contain only one item.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当你与 `single` 或 `maybe` 一起工作时，你只能使用 `blockingGet()` 以外的任何阻塞操作符。原因很简单，这两个单子只能包含一个项。
- en: 'So, let''s create two new test cases by modifying the last test case as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们通过修改最后一个测试用例来创建两个新的测试用例，如下所示：
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the first test case, we used `observable.first()` with a default value, this
    operator returns a `Single`; on the second operator, we used `observable.firstElement()`
    this operator returns a `Maybe`. Then we used `blockingGet` in both test cases
    to get the first element as an `Int` and execute the test function.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个测试用例中，我们使用了 `observable.first()` 并带有默认值，此操作符返回一个 `Single`；在第二个操作符中，我们使用了
    `observable.firstElement()`，此操作符返回一个 `Maybe`。然后我们在两个测试用例中都使用了 `blockingGet` 来获取第一个元素作为
    `Int` 并执行测试函数。
- en: 'So, following screenshot is the test result:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以下截图是测试结果：
- en: '![](img/67e4d586-4e0d-4a4f-ac14-5a24bec75669.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/67e4d586-4e0d-4a4f-ac14-5a24bec75669.jpg)'
- en: Getting the last Item - blockingLast
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取最后一个项 - blockingLast
- en: 'We have `blockingFirst`, so it''s quite obvious that we would have `blockingLast`.
    As expected, it gets you the last emitted item while blocking the thread until
    the source emits it. The following is the code example:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有`blockingFirst`，所以很明显我们会有一个`blockingLast`。正如预期的那样，它会在阻塞线程直到源发出它之前获取最后一个发出项。以下是一个代码示例：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As we are expecting the last emitted item, we are checking equality with `10`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们期望获取最后一个发出项，所以我们正在检查与`10`的等价性。
- en: 'Following is the screenshot of the testing result:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是测试结果的截图：
- en: '![](img/e2f3e782-614c-4c5a-b022-7b33a5d0e0f6.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e2f3e782-614c-4c5a-b022-7b33a5d0e0f6.jpg)'
- en: Getting all emissions as iterable - blockingIterable operator
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有发出项作为可迭代对象获取 - blockingIterable操作符
- en: So, we fetched the first emitted item, we fetched the last emitted item, but
    what if we want all the items emitted for testing? The `blockingIterable` operator
    gets you with the same. The `blockingIterable` operator works in an interesting
    way, it passes an emission to the `Iterable`, then the `Iterable` will keep blocking
    the iterating thread until the next emission is available. This operator queues
    up unconsumed values until the `Iterator` can consume them, and this can cause
    `OutOfMemory` exceptions.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们获取了第一个发出的项目，我们也获取了最后一个发出的项目，但如果我们想获取所有用于测试发出的项目呢？`blockingIterable`操作符可以提供同样的功能。`blockingIterable`操作符以一种有趣的方式工作，它将一个发出项传递给`Iterable`，然后`Iterable`将保持阻塞迭代线程，直到下一个发出项可用。这个操作符将未消费的值排队，直到`Iterator`可以消费它们，这可能会导致`OutOfMemory`异常。
- en: 'So following is an example, where we are obtaining the complete list and then
    we are checking if the emissions were sorted by converting the returned `Iterable`
    to `List` and checking equality with the source `list` after sorting. Please refer
    to the following code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 所以以下是一个示例，其中我们获取了完整的列表，然后我们将返回的`Iterable`转换为`List`，并在排序后与源`list`进行比较以检查等价性。请参考以下代码：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If the emissions were sorted, the `iterable`, when converted to `list`, should
    be equal to `list.sorted()`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发出项是排序的，那么当转换为`list`时，`iterable`应该等于`list.sorted()`。
- en: 'Following is the screenshot of the test result:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是测试结果的截图：
- en: '![](img/9cab01c7-85d6-47f1-a568-5e47dbd1967a.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9cab01c7-85d6-47f1-a568-5e47dbd1967a.jpg)'
- en: Looping through all emissions - blockingForEach
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遍历所有发出项 - blockingForEach
- en: If you want to loop through all the emissions then `blockingForEach` is probably
    a better solution. It's better than `blockingIterable` as it will not queue up
    the emissions. Rather will it block the calling thread and wait for each emission
    to be processed before allowing the thread to continue.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要遍历所有发出项，那么`blockingForEach`可能是一个更好的解决方案。它比`blockingIterable`更好，因为它不会排队发出项。相反，它会阻塞调用线程，等待每个发出项被处理后再允许线程继续。
- en: 'In the following example, we created an `Observable` from a list of `Int`.
    Then applied a filter for even numbers only and then within the `blockingForEach`
    we are testing whether all the received numbers are even:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们从一个`Int`列表创建了一个`Observable`，然后只应用了偶数的过滤器，然后在`blockingForEach`中测试是否所有接收到的数字都是偶数：
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The result of the test is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的结果如下：
- en: '![](img/6a5582fe-8504-46df-a0e2-dec7180b0fd2.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6a5582fe-8504-46df-a0e2-dec7180b0fd2.jpg)'
- en: We covered the most useful blocking operators up until now. They are useful
    for simple assertions and can effectively block the code so that we can perform
    our testing operations.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了到目前为止最有用的阻塞操作符。它们对于简单的断言很有用，并且可以有效地阻塞代码，以便我们可以执行我们的测试操作。
- en: However, using blocking code does no good in production. While it seems that
    using blocking code for testing is ok, but it is actually not. It can do significant
    harm to keep you from the benefits of testing. How? Just think of multiple Observables/Flowables
    are emitting concurrently for your application, if you put them on the blocking
    code their complete behavior may change and as a result you'll be deprived from
    the benefits of unit testing.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在生产中使用阻塞代码并没有好处。虽然看起来在测试中使用阻塞代码是可以的，但实际上并不是这样。它可能会对你从测试中获得的利益造成重大损害。如何？只需想想多个Observables/Flowables并发地向你的应用程序发出，如果你将它们放在阻塞代码上，它们的完整行为可能会改变，结果你将失去单元测试的利益。
- en: So, what is the way out? Let's see.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，出路在哪里呢？让我们看看。
- en: Introducing TestObserver and TestSubscriber
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍TestObserver和TestSubscriber
- en: As you read through this chapter, you may have developed an idea that the only
    way we can perform tests are through blocking the code, either by using `blockingSubscribe`
    or by using blocking operators. *But this is not the case*. In fact, there are
    more comprehensive ways to reactive code, or rather we can say that we can test
    reactive code reactively.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你阅读这一章，你可能已经形成了一个想法，我们只能通过阻塞代码来执行测试，要么使用 `blockingSubscribe`，要么使用阻塞操作符。*但这并不是事实*。实际上，还有更多全面的方法来处理响应式代码，或者说我们可以以响应式的方式测试响应式代码。
- en: To say it more precisely, in a Subscriber we have `onError` and `onComplete`
    that demands testing along with `onNext`, which is not always possible with just
    blocking. Yes some sort of blocking is necessary, but it cannot alone do all the
    things and it also needs to be managed reactively.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 更精确地说，在 Subscriber 中，我们有 `onError` 和 `onComplete`，它们需要与 `onNext` 一起测试，而仅仅使用阻塞并不总是可能的。是的，某种形式的阻塞是必要的，但它不能独自完成所有的事情，它还需要以响应式的方式进行管理。
- en: So, here are your two superheroes to make the developers life easy—`TestObserver`
    and `TestSubscriber`. As with `Subscriber` and `Observer`, you can use `TestSubscriber`
    with `Flowables` and `TestObserver` with `Observables`, everything except that
    is similar between these two.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里有你的两位超级英雄，让开发者的生活变得简单——`TestObserver` 和 `TestSubscriber`。与 `Subscriber`
    和 `Observer` 一样，你可以使用 `TestSubscriber` 与 `Flowables`，使用 `TestObserver` 与 `Observables`，这两者之间除了这一点外，其他都是相似的。
- en: 'So, let''s get started with an example:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们从一个例子开始：
- en: '[PRE13]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'So we did perform the same set of tests with `TestObserver` and `TestSubscriber`.
    The test result is obviously passed:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们确实使用 `TestObserver` 和 `TestSubscriber` 执行了相同的测试集。测试结果显然是通过的：
- en: '![](img/43522289-c0d2-4ebd-8fda-a106f134cf6d.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/43522289-c0d2-4ebd-8fda-a106f134cf6d.jpg)'
- en: Let's now understand the test cases. On comment `(1)`, we are subscribing to
    the Observable/Flowable. On comment `(2)`, we are checking if the Subscription
    was successful and was only one with the help of the `assertSubscribed()` test.
    On comment `(3)`, we are blocking the thread until the Observable/Flowable completes
    its execution with the `awaitTerminalEvent()` method. This terminal event can
    be `onComplete` or `onError` as well. On comments `(4)` and `(5)`, we are checking
    whether the `Observable` and/or `Flowable` has completed successfully without
    any errors, `assertNoErrors()` will test whether the Subscription hasn't received
    any errors and `assertComplete()` will test whether the producer has completed
    successfully . On comment `(6)`, we are testing that the total received emission
    count was `20` (there were 20 items in the list), `assertValuesCount()` helps
    us with this objective. On comment `(6)`, with the help of `assertValues()` we
    are testing the expected and actual values of each of the emissions in its order.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在理解测试用例。在注释 `(1)` 中，我们正在订阅 Observable/Flowable。在注释 `(2)` 中，我们正在检查订阅是否成功，并且只有一个，这是通过
    `assertSubscribed()` 测试来实现的。在注释 `(3)` 中，我们正在使用 `awaitTerminalEvent()` 方法阻塞线程，直到
    Observable/Flowable 完成其执行。这个终端事件可以是 `onComplete` 或 `onError`。在注释 `(4)` 和 `(5)`
    中，我们正在检查 `Observable` 和/或 `Flowable` 是否成功完成而没有错误，`assertNoErrors()` 将测试订阅是否没有收到任何错误，而
    `assertComplete()` 将测试生产者是否成功完成。在注释 `(6)` 中，我们正在测试接收到的总发射计数为 `20`（列表中有20个项目），`assertValuesCount()`
    帮助我们实现这个目标。在注释 `(6)` 中，我们通过 `assertValues()` 测试每个发射的预期和实际值及其顺序。
- en: So it was cool, right? The next thing I'm going to show is probably cooler.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这很酷，对吧？接下来我要展示的可能会更酷。
- en: Understanding TestScheduler
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 TestScheduler
- en: Think of an Observable/Flowable created with the `Observable.interval()` / `Flowable.interval()`
    factory method. If you have given a long interval (say five minutes) in them and
    have tested at least say 100 emissions then it would take a long time for testing
    to complete (500 minutes = 8.3 hours, that is, a complete man-hour just to test
    a single producer). Now if you have more producers like that with a larger interval
    and more emissions to test then it would probably take the whole lifetime to test,
    when would you ship the product then?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下使用 `Observable.interval()` / `Flowable.interval()` 工厂方法创建的 Observable/Flowable。如果你在其中给出了一个较长的间隔（比如说五分钟），并且至少测试了100次发射，那么测试完成将需要很长时间（500分钟
    = 8.3小时，也就是说，仅仅为了测试一个生产者就需要一个完整的人时）。现在，如果你有更多类似这样的生产者，它们有更大的间隔和更多的发射需要测试，那么测试可能需要整个生命周期，那么你什么时候才能发货呢？
- en: '`TestScheduler` is here to save your life. They can effectively simulate time
    with time-driven producers so that we can do assertions by fast-forwarding it
    by a specific amount.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestScheduler` 的存在就是为了拯救你的生命。它们可以通过时间驱动的生产者有效地模拟时间，这样我们就可以通过向前快进特定的时间量来进行断言。'
- en: 'So, the following is the respective implementation:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以下是对应的实现：
- en: '[PRE14]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: So, here we created an `Observable` with `Observable.interval` with a `5` minute
    interval and `TestScheduler` as its `Scheduler`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这里我们使用 `Observable.interval` 创建了一个具有 `5` 分钟间隔的 `Observable`，并将其 `Scheduler`
    设置为 `TestScheduler`。
- en: On comment `(1)`, it should not receive any emissions (as there are still `5` minutes
    before it should receive its first emission) and we are testing it with `assertValuesCount(0)`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在评论 `(1)` 上，它不应该收到任何排放（因为还有 `5` 分钟它才应该收到第一次排放），我们使用 `assertValuesCount(0)` 进行测试。
- en: We then fast-forwarded the time by `100` minutes on comment `(2)`, and tested
    whether we received `20` emissions on comment `(3)`. `TestScheduler` provides
    us with the `advanceTimeBy` method, which takes a timespan and unit as parameters
    and simulates that for us.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后在评论 `(2)` 上快进了 `100` 分钟，并测试了是否在评论 `(3)` 上收到了 `20` 次排放。`TestScheduler` 为我们提供了
    `advanceTimeBy` 方法，该方法接受时间段和单位作为参数，并为我们模拟这一过程。
- en: We then fast-forwarded time by another `400` minutes and tested if we received
    a total of 100 emissions on comment `(4)` and comment `(5)`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后又快进了 `400` 分钟，并测试了是否在评论 `(4)` 和评论 `(5)` 上总共收到了 100 次排放。
- en: As you would expect, the test passes.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所预期，测试通过了。
- en: Summary
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: So, in this chapter, we learned about testing in Kotlin. We started with the
    benefits of testing and then moved on to testing in Kotlin, using JUnit and Kotlin-test.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们学习了 Kotlin 中的测试。我们从测试的好处开始，然后转向 Kotlin 中的测试，使用 JUnit 和 Kotlin-test
    进行测试。
- en: As we got some hands-on testing experience in Kotlin, we gradually moved to
    testing in RxKotlin, we learned a few technique to test RxKotlin and learnt about
    the super-convenient testing tools that RxKotlin provides for us.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在 Kotlin 中获得了一些实际测试经验，我们逐渐转向了 RxKotlin 的测试，我们学习了一些测试 RxKotlin 的技巧，并了解了 RxKotlin
    为我们提供的超级方便的测试工具。
- en: As we have built a strong base of knowledge in RxKotlin, in the next chapter—[Chapter
    9](91fde5b1-29d4-49c0-a7e4-b56db9882d2f.xhtml),
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在 RxKotlin 中建立了坚实的知识基础，在下一章——[第 9 章](91fde5b1-29d4-49c0-a7e4-b56db9882d2f.xhtml)，
- en: '*Resource Management and Extending RxKotlin* we are going to discuss some advanced
    topics. We will discuss managing resources—how to free allocated memory and prevent
    memory leaks. We will also learn to create our own custom operators, which can
    be chained in the RxKotlin logic just like those predefined operators.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *资源管理和扩展 RxKotlin* 中，我们将讨论一些高级主题。我们将讨论如何管理资源——如何释放分配的内存和防止内存泄漏。我们还将学习如何创建自己的自定义操作符，这些操作符可以在
    RxKotlin 逻辑中像预定义的操作符一样链式使用。
- en: So, what are you waiting for? Get started on [Chapter 9](91fde5b1-29d4-49c0-a7e4-b56db9882d2f.xhtml), *Resource
    Management and Extending RxKotlin,* right now, and from now on don't forget to
    test every code you write.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你还在等什么？现在就开始学习 [第 9 章](91fde5b1-29d4-49c0-a7e4-b56db9882d2f.xhtml)，*资源管理和扩展
    RxKotlin*，并且从现在开始，不要忘记测试你写的每一行代码。
