- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: The Swift Programming Language
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swift编程语言
- en: 'As we discussed in [*Chapter 4*](B18653_04.xhtml#_idTextAnchor097), understanding
    data structures is a crucial and complex skill for any developer, regardless of
    the platform or language they work with. Data structures are the foundation of
    computer science programming and algorithms, and mastering them is essential for
    success as a developer. Now that we have a solid understanding of data structures,
    it’s time to move on to another important aspect of iOS development: Swift.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第4章*](B18653_04.xhtml#_idTextAnchor097)中讨论的那样，理解数据结构是任何开发者，无论他们使用的是哪个平台或语言，都至关重要的复杂技能。数据结构是计算机科学编程和算法的基础，掌握它们对于开发者成功至关重要。现在我们已经对数据结构有了坚实的理解，是时候转向iOS开发的重要方面：Swift。
- en: Swift is a highly popular topic in iOS interviews, and it’s not only a programming
    language for iOS developers but also the core foundation of Apple’s new frameworks
    and technologies.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Swift是iOS面试中一个非常热门的话题，它不仅是一种iOS开发者的编程语言，也是苹果公司新框架和技术的核心基础。
- en: Therefore, understanding Swift’s primary features such as structs, property
    wrappers, generics, and more is vital to succeeding in iOS development and passing
    an interview. The close relationship between Swift and Apple’s latest technologies
    makes a deep understanding of the language crucial for any iOS developer.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，理解Swift的主要特性，如结构体、属性包装器、泛型和更多内容，对于在iOS开发中取得成功和通过面试至关重要。Swift与苹果最新技术之间的紧密关系使得对语言的深入理解对任何iOS开发者来说都至关重要。
- en: In this chapter, we will learn about optionals, access levels, and closures.
    We will also review computed and lazy properties, extensions, generics, error
    handling, protocols, and memory management questions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习关于可选类型、访问级别和闭包的内容。我们还将回顾计算属性和懒加载属性、扩展、泛型、错误处理、协议和内存管理问题。
- en: 'To that end, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将涵盖以下主题：
- en: How do we master all Swift features?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何掌握所有Swift特性？
- en: Basic Swift features
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本Swift特性
- en: Advanced Swift language features
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级Swift语言特性
- en: It’s essential to ensure that we have a good grasp of the primary language features
    to excel in the iOS interview process. But how can we ensure that we are fully
    covered in knowledge and understanding? We will see in this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 确保我们对主要语言特性有良好的掌握是iOS面试过程中取得优异成绩的关键。但我们应该如何确保我们在知识和理解上全面覆盖呢？我们将在本章中看到。
- en: How do we master all Swift features?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们如何掌握所有Swift特性？
- en: First, reading this chapter will get us through most of the important Swift
    features interviewers ask about in the iOS technical interviews.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，阅读本章将帮助我们了解iOS技术面试中面试官询问的大多数重要Swift特性。
- en: But that’s not enough.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 但这还不够。
- en: To become a true professional, we must start acting like one.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要成为一名真正的专业人士，我们必须开始像专业人士一样行事。
- en: For example, reading the *official Swift documentation* is an excellent start
    to ensure we are covered with the latest Swift enhancements. We will ensure we
    cover the basics by going over access levels, error handling, and extensions.
    But don’t think of Swift as just a programming language. Some features were developed
    with deep thinking and interesting methodology.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，阅读*官方Swift文档*是确保我们覆盖了最新的Swift增强功能的绝佳开始。我们将通过回顾访问级别、错误处理和扩展来确保我们覆盖了基础知识。但不要将Swift仅仅视为一种编程语言。一些特性是通过深入思考和有趣的方法开发的。
- en: Ideally, we shouldn’t answer Swift interview questions just by memorizing the
    technical documentation – the interviewer would like to hear our thoughts, best
    practices, and recommendations.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们不应该仅仅通过记忆技术文档来回答Swift面试问题——面试官更希望听到我们的思考、最佳实践和建议。
- en: Let’s explain that idea with extensions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用扩展来解释这个想法。
- en: A typical answer to the question “*Can you please tell me about Swift extensions*?”
    would be, “*Swift extensions allow us to add functionality to an existing class*
    *or struct*.”
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于“*你能告诉我关于Swift扩展的内容吗*？”这个问题的一个典型回答可能是，“*Swift扩展允许我们向现有的类* *或结构体* 添加功能。”
- en: 'While this answer is not a mistake, it is still very technical. Try to think
    deeper:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个回答并不算错误，但它仍然非常技术性。试着深入思考：
- en: Why do we need extensions?
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为什么需要扩展？
- en: How do extensions help us to write better code?
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展如何帮助我们编写更好的代码？
- en: What are the use cases that make extensions so powerful?
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些用例使得扩展如此强大？
- en: 'A better answer would be as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的回答可能是以下内容：
- en: '*Swift extensions are a powerful tool that allows developers to add new functionality
    to existing classes, structures, enumerations, and protocols. They enable code
    organization by grouping related functionality together, making it easier to read
    and maintain. They also increase the code reusability, readability,* *and testability.*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*Swift 扩展是一个强大的工具，允许开发者向现有的类、结构体、枚举和协议添加新功能。它们通过将相关功能分组在一起来组织代码，使其更容易阅读和维护。它们还增加了代码的可重用性、可读性和可测试性。*'
- en: Of course, we must ensure we fully understand extensions to phrase this type
    of answer.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们必须确保我们完全理解扩展，以便表达这类答案。
- en: Our next step would be to take what we’ve just learned about extensions and
    implement it on other topics, such as optionals, protocols, generics, and other
    Swift features. That’s precisely what we’re going to do in this chapter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一步将是我们刚刚学到的关于扩展的知识，并将其应用于其他主题，例如可选类型、协议、泛型和 Swift 的其他特性。这正是我们将在本章中做的。
- en: Do we need to know all Swift features? The answer is yes. Do we need to know
    all the features exceptionally well? It’s highly recommended, but we can pass
    some of the interviews without expertise on some of the features.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否需要了解所有 Swift 特性？答案是肯定的。我们是否需要非常出色地了解所有特性？强烈推荐，但我们可以在对某些特性没有专业知识的情况下通过一些面试。
- en: 'That’s why I grouped the Swift features into two levels: basic and advanced.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，我将 Swift 特性分为两个层次：基础和高级。
- en: Let’s start with some basic language features such as optionals, access levels,
    and closures.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些基本语言特性开始，比如可选类型、访问级别和闭包。
- en: Basic Swift features
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础 Swift 特性
- en: Having a solid understanding of Swift’s basic concepts is essential, as a lack
    of knowledge in these areas can cause significant issues for iOS developers, not
    to mention job interviews.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对 Swift 的基本概念有一个扎实的理解是至关重要的，因为这些领域的知识不足可能会给 iOS 开发者带来重大问题，更不用说求职面试了。
- en: Answering optionals questions
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回答可选类型问题
- en: '`?` after the variable type.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 变量类型后的 `?`。
- en: 'Here''s an example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding line of code, `name` can contain a value or nil.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一行代码中，`name` 可以包含一个值或 nil。
- en: 'A simple way to unwrap an optional and extract its value is the `if` `let`
    statement:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 解包可选类型并提取其值的一个简单方法是使用 `if let` 语句：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Notice that since Swift 5.7, it is possible to unwrap more elegantly, keeping
    the optional name as it is:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，自 Swift 5.7 以来，可以更优雅地解包，同时保持可选名称不变：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `if let` shorthand makes it simpler to unwrap as it doesn’t require us to
    create another variable/constant with the same name as the optional.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`if let` 简写使解包变得更加简单，因为它不需要我们创建与可选类型同名的新变量/常量。'
- en: Now, let’s move to some interview questions.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向一些面试问题。
- en: “Can you give an example of a situation where you would use an optional in your
    code?”
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “你能举一个例子说明你会在代码中使用可选类型的情况吗？”
- en: '*Why is this* *question important?*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要？*'
- en: This question tests our practical understanding of Swift optionals. Because
    optionals are a widespread feature that involves API interface design, functions
    declarations, and control flows, the interviewer needs to see if we understand
    correctly how to use it.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题测试了我们对于 Swift 可选类型的实际理解。因为可选类型是一个广泛使用的特性，它涉及到 API 接口设计、函数声明和控制流，面试官需要看到我们是否正确理解了如何使用它。
- en: '*What is* *the answer?*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: 'We can use optionals in our code in a few everyday situations. Here are some
    of them:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在一些日常情况下在我们的代码中使用可选类型。以下是一些例子：
- en: 'An optional parameter in function declarations:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数声明中的可选参数：
- en: '[PRE3]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Handling situations where a function may return null:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理函数可能返回 null 的情况：
- en: '[PRE4]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Handling missing data in JSON response using optionals in a struct:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用结构体中的可选类型处理 JSON 响应中的缺失数据：
- en: '[PRE5]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We should use optionals in every place where we understand that we *may not
    receive a value* and receive nil instead.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在理解我们*可能不会收到值*并收到 nil 的任何地方使用可选类型。
- en: “List all the options you know to unwrap an optional”
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “列出你了解的所有解包可选类型的方法”
- en: '*Why is this* *question important?*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要？*'
- en: There are several ways to unwrap an optional. It doesn’t mean that all of them
    are alternatives to each other – each method solves a different use case. Knowing
    most of the ways and their use cases shows our ability to unwrap optionals in
    our code elegantly and effectively.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 解包可选类型有几种方法。这并不意味着它们都是彼此的替代品——每种方法都解决不同的用例。了解大多数方法和它们的用例显示了我们在代码中优雅且有效地解包可选类型的能力。
- en: '*What is* *the answer?*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: 'Let’s go over some of the ways to unwrap an optional:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看解包可选的一些方法：
- en: 'Use **if let** syntax to perform a code block with an unwrapped value:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**if let**语法来执行带有未包装值的代码块：
- en: '[PRE6]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Use Optional Chaining to avoid multiple **if** **let** statements:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可选链来避免多个**if** **let**语句：
- en: '[PRE7]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Use **guard let** to have a stop condition and exit the scope if the value
    is nil:'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**guard let**来设置停止条件，如果值是nil则退出作用域：
- en: '[PRE8]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Use the **!** operator. Force unwrap if we are certain the optional contains
    a value:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**!**运算符。如果我们确定可选包含一个值，则强制解包：
- en: '[PRE9]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Use nil coalescing (**??**) to provide a default value:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用空合并（**??**）来提供默认值：
- en: '[PRE10]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There is no preferred way to unwrap a value. It all depends on the control flow
    and the situation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一种解包值的首选方法。这完全取决于控制流和情况。
- en: “Using force unwrapping will crash our app in case of nil. So why would we use
    it?”
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “使用强制解包会在nil的情况下崩溃我们的应用。那么我们为什么要使用它？”
- en: '*Why is this* *question important?*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要？*'
- en: 'That’s a tricky question often asked in interviews. Take the following line
    of code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在面试中经常被问到的问题。以下是一段代码：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If `optionalValue` is nil, we’ll get an exception. So, why are we using that
    method?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`optionalValue`为nil，我们会得到一个异常。那么，我们为什么要使用那个方法呢？
- en: This interview question is not really about optionals – it’s about our ability
    to *manage exceptions* in our code and crash the app when needed.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个面试问题实际上并不是关于可选的——它是关于我们管理代码中异常的能力，并在需要时崩溃应用。
- en: '*What is* *the answer?*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: 'The most straightforward answer would be, “When we are certain the value is
    not nil.” Here is an example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最直接的答案可能是，“当我们确定值不是nil时。”以下是一个例子：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: But that answer is not a complete one. Why would we even approach the `maybeString`
    variable, even if we just unwrapped it?
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个答案并不完整。为什么我们甚至要接近`maybeString`变量，即使我们只是解包了它？
- en: As mentioned earlier, this question tests our ability to manage exceptions using
    optionals. There are cases where an optional must contain a value. Otherwise,
    the program cannot continue.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这个问题测试了我们使用可选来管理异常的能力。有些情况下，可选必须包含一个值。否则，程序无法继续。
- en: 'One popular example would be declaring an `IBOutlet` as forced unwrap:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一个流行的例子是将`IBOutlet`声明为强制解包：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We’ll get an exception if the `label` is nil. In general, we don’t want our
    app to crash, but in this case, a crash indicates that *our program setup is broken*
    – we either disconnected that outlet or even removed it from the storyboard.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`label`为nil，我们会得到一个异常。一般来说，我们不希望我们的应用崩溃，但在这个情况下，崩溃表明*我们的程序设置有误*——我们可能断开了那个出口，甚至从故事板中移除了它。
- en: Another good example is force-cast `UITableViewCell` in a `cellForRow` method.
    Even though it’s a casting operation, it is related to optionals because the result
    of casting is an optional value, and we force it to succeed.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个很好的例子是在`cellForRow`方法中强制转换`UITableViewCell`。尽管这是一个转换操作，但它与可选相关，因为转换的结果是一个可选值，我们强制它成功。
- en: 'Our program is not relevant if this casting fails, therefore we will use force-cast
    for that:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个转换失败，我们的程序就不再相关，因此我们将使用强制转换：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In summary, force unwrapping is not a common technique, but it can be helpful
    in certain situations where normal unwrapping is not applicable.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，强制解包不是一个常见的技巧，但在某些情况下，它可能很有帮助。
- en: Solving access-level questions
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决访问级别问题
- en: At first, access-level questions seem like a small topic. Technically speaking,
    it is a small topic. Learning and remembering the different access levels is pretty
    straightforward.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，访问级别问题看起来像是一个小主题。从技术上讲，它确实是一个小主题。学习和记住不同的访问级别相当直接。
- en: The question is always, do we use access levels properly?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 问题始终是，我们是否正确地使用了访问级别？
- en: While a single keyword represents access levels, they influence code encapsulation,
    visibility, project and organization, and readability.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个关键字代表访问级别时，它们会影响代码封装、可见性、项目和组织的可读性。
- en: Access levels also influence how our interfaces between the simple app components
    look.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 访问级别还影响我们简单应用组件之间的接口看起来如何。
- en: We should come to our interview knowing what the different levels represent
    and what they mean to our project structure.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该了解不同的级别代表什么，以及它们对我们项目结构意味着什么。
- en: “What are the different access levels in Swift, and what are their use cases?”
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “Swift中有哪些不同的访问级别，以及它们的用例是什么？”
- en: '*Why is this* *question important?*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要？*'
- en: This question is considered a screening question, and its goal is to ensure
    we understand the basic access levels in Swift before we move on to more advanced
    questions on this topic.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题被认为是一个筛选问题，其目的是确保我们在继续探讨这个主题的更高级问题之前，理解Swift中的基本访问级别。
- en: A screening question
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一个筛选问题
- en: A screening question is a question that the interviewer asks to make sure we
    pass the minimum qualifications for the position and that we have the basic knowledge
    for the role. Experienced developers may find these questions weird – but we should
    remember that the interviewer doesn’t have a previous acquaintance with us. We
    should be careful with these questions and ensure they won’t be a trap in our
    interview. A screening question is also called a “fundamental” or “core” question.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 筛选问题是一个面试官提出的问题，以确保我们符合该职位的最低资格，并且具备该角色的基本知识。经验丰富的开发者可能会觉得这些问题很奇怪——但我们应该记住，面试官之前并不认识我们。我们应该对这些问题保持谨慎，并确保它们不会成为我们面试的陷阱。筛选问题也被称为“基本”或“核心”问题。
- en: '*What is* *the answer?*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: 'There are five different access levels:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有五种不同的访问级别：
- en: '*open* – Entities marked as open can be accessed and subclassed by any other
    module, including other frameworks. This level is used when we want to allow our
    class or method to be subclassed or overridden.'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*公开* —— 被标记为公开的实体可以被任何其他模块，包括其他框架访问和子类化。当我们希望允许我们的类或方法被子类化或重写时，使用此级别。'
- en: '*public* – With public, we allow the entity to be accessible from any other
    module or framework *without subclassing* it. Sometimes, because of backward compatibility
    or security, we don’t want other users to subclass our class, and using public
    is a great way to ensure that.'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*公开* —— 使用公开，我们允许实体可以从任何其他模块或框架访问，而无需子类化它。有时，由于向后兼容性或安全性，我们不希望其他用户子类化我们的类，使用公开是一个确保这一点的绝佳方式。'
- en: '*internal* – We should use the internal access level when we want our entity
    to be accessible *within the same module* but not from the outside. Marking an
    entity as internal is not mandatory – that’s the default access level in case
    we didn’t define it explicitly. But in libraries, it is a best practice to mark
    classes explicitly as internal.'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*内部* —— 当我们希望我们的实体在同一模块内可访问但不在外部时，应使用内部访问级别。将实体标记为内部不是强制性的——如果我们没有明确定义它，这是默认访问级别。但在库中，将类明确标记为内部是一个最佳实践。'
- en: '*fileprivate* – Entities marked as fileprivate are accessible *within the same
    file*. This is used when we have a class named A, and we want to add another class
    relevant only to class A. The **fileprivate** entity will ensure that constraint
    if we write both classes in the same file.'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*fileprivate* —— 被标记为fileprivate的实体在同一文件内可访问。当我们有一个名为A的类，并且我们想要添加另一个仅与类A相关的类时，这被使用。如果我们将这两个类都写在同一个文件中，**fileprivate**实体将确保这个约束。'
- en: '*private* – private methods and variables are accessible only for the *same
    class or struct* (enclosing declaration). With private, we can hide code implementation
    outside the entity.'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*私有* —— 私有方法和变量仅对*同一类或结构体*（封装声明）可访问。使用私有，我们可以隐藏实体外的代码实现。'
- en: “How do access levels affect code organization and readability?”
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “访问级别如何影响代码组织和可读性？”
- en: '*Why is this* *question important?*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要？*'
- en: Just like the previous question, as iOS developers, we shouldn’t look at access
    levels as technical features. Access levels tremendously influence how our code
    is organized and viewed. As a matter of fact, in some way, access levels have
    a part in our code documentation, as it describes what methods are part of the
    interface and what methods are part of the implementation.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 就像上一个问题一样，作为iOS开发者，我们不应该将访问级别视为技术特性。访问级别极大地影响了我们的代码组织和视图。事实上，在某种程度上，访问级别在我们的代码文档中扮演了一定的角色，因为它描述了哪些方法是接口的一部分，哪些方法是实现的一部分。
- en: '*What is* *the answer?*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: 'Access level affects code organization by separating it to interface and implementation.
    For example, let’s take the following `Game` class:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 访问级别通过将其分离为接口和实现来影响代码组织。例如，让我们看看以下`Game`类：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We can see that `Game` has a `gameOver` property which is declared `private`,
    and a `restart()` method, which is `public`. We understand that `gameOver` is
    hidden and cannot be modified directly from outside the class. The only way to
    change it is by using the `restart()` method, and that leads us to my main point
    ‒ readability.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`Game`类有一个`gameOver`属性，它是被声明为`private`的，还有一个`restart()`方法，它是`public`的。我们理解`gameOver`是被隐藏的，不能直接从类外部修改。唯一改变它的方法是通过使用`restart()`方法，这引出了我的主要观点——可读性。
- en: 'By looking at the `Game` class, we can immediately see that there’s only one
    way to stop the game: by calling `restart()`. They can safely ignore any other
    private methods or variables as it is used only for implementation. If `gameOver`
    was not private, it was possible to modify it from the outside without calling
    the necessary steps that are being done in the `restart()` method.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看`Game`类，我们可以立即看到停止游戏只有一个方法：调用`restart()`。它们可以安全地忽略任何其他私有方法或变量，因为它们只用于实现。如果`gameOver`不是私有的，那么从外部修改它是可能的，而不需要调用`restart()`方法中正在进行的必要步骤。
- en: In short – the access level explains how to use the class or struct and separate
    them nicely to interface and implementation.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之——访问级别解释了如何使用类或结构体，并将它们很好地分离为接口和实现。
- en: Handling questions about Closures
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理关于闭包的问题
- en: Closures replaced what used to be Blocks in Objective-C and are widely used
    in Swift development. But the reason I put it under *basic Swift features* is
    because closures became a fundamental part of many advanced Swift features. It
    is used as completion handles, advanced collection type functions, SwiftUI, and
    Combine. Not knowing closures well can affect our ability as iOS developers to
    move fast and implement advanced features.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包取代了Objective-C中曾经使用的Blocks，并且在Swift开发中被广泛使用。但我将其归入*基本Swift特性*，是因为闭包已经成为许多高级Swift特性的基本组成部分。它被用作完成处理程序、高级集合类型函数、SwiftUI和Combine。如果不熟悉闭包，可能会影响我们作为iOS开发者快速移动和实现高级功能的能力。
- en: “How do you use closures to handle callbacks in iOS?”
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “你是如何使用闭包来处理iOS中的回调的？”
- en: '*Why is this* *question important?*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个问题的意义是什么？*'
- en: I chose to start with this question because callbacks and asynchronous operations
    are typical examples of how to use closures in many Swift applications. Unlike
    delegates, closures can make asynchronous tasks look simple and always in context.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择从这个问题开始，因为回调和异步操作是许多Swift应用程序中如何使用闭包的典型例子。与代理不同，闭包可以使异步任务看起来简单，并且始终处于上下文中。
- en: '*What is* *the answer?*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: Closures are passed to a function as a parameter and can be executed later.
    Suppose the asynchronous operation is based on a delegate or any other mechanism
    where the response is out of the function scope. In that case, we can handle that
    dependency by saving the closure to an instance variable and calling the closure
    whenever we finish the task.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包作为参数传递给函数，可以在稍后执行。假设异步操作基于代理或任何其他机制，其响应超出了函数的作用域。在这种情况下，我们可以通过将闭包保存到实例变量中，并在完成任务时调用闭包来处理这个依赖关系。
- en: 'Here’s a code example to explain that:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个代码示例来解释这一点：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And now, let’s see how to use the closure without using any delegate:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用闭包而不使用任何代理：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding code blocks, I demonstrated how to encapsulate the delegate
    inside `SomeClass`, and expose only a closure to be run when the async operation
    ends. This pattern provides a clearer interface to the developer when calling
    `startAsyncOperation`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我演示了如何将代理封装在`SomeClass`中，并仅暴露一个在异步操作结束时运行的闭包。这种模式在调用`startAsyncOperation`时为开发者提供了一个更清晰的接口。
- en: “Can you explain how closure capture semantics in Swift can lead to retain cycles
    and how to avoid them?”
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “你能解释一下Swift中的闭包捕获语义如何导致保留循环以及如何避免它们吗？”
- en: '*Why is this* *question important?*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个问题的意义是什么？*'
- en: This classic interview question is a common pitfall junior developers fall into
    when working with closures.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个经典的面试问题是初级开发者在与闭包一起工作时常见的陷阱。
- en: In iOS development, topics are related to each other, even though we deal with
    closures and not memory management.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS开发中，主题之间相互关联，即使我们处理的是闭包而不是内存管理。
- en: Closures are powerful, but when we don’t use them correctly, they can produce
    memory leaks and affect our app performance.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包很强大，但如果我们使用不当，它们可能会产生内存泄漏并影响我们的应用性能。
- en: This question tests our understanding of how closures work. It checks our knowledge
    of what happens in our app memory when we create and call closure and how scopes
    are handled.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题测试了我们对于闭包工作原理的理解。它检查我们在创建和调用闭包时，在应用程序内存中会发生什么，以及如何处理作用域。
- en: '*What is* *the answer?*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: Closures capture variables and constants from the surrounding scopes with a
    **strong reference**. One of these constants might be the objects that hold the
    closure itself, which can cause a **retain cycle**.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包通过 **强引用** 从周围的作用域捕获变量和常量。这些常量中可能包含持有闭包本身的对象，这可能导致 **保留周期**。
- en: 'Look at the following code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下代码：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can see that `SomeClass` has a strong reference to `closure`, and `closure`
    prints `someProperty`, which requires `closure` to have a strong reference to
    `SomeClass` (aka `self`).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 `SomeClass` 对 `closure` 有一个强引用，`closure` 打印 `someProperty`，这要求 `closure`
    对 `SomeClass`（即 `self`）有一个强引用。
- en: 'The simplest way to avoid a retain cycle is to declare `self` as a `weak` reference
    and, by that, untie the retain cycle:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 避免保留周期的最简单方法是将 `self` 声明为 `weak` 引用，并通过这种方式解开保留周期：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We can also use `unowned` instead of `weak`, but this is a dangerous approach
    – the closure may still be alive while `self` gets deallocated, and that may lead
    to an exception. However, there are cases where using `unowned` instead of `weak`
    is safe, and that can be derived from the relationship between our classes. A
    good example would be the `Country` class and the `CapitalCity` class. A country
    has a reference to its capital city, and the capital city can have an `unowned`
    reference to its country. We understand that the lifetime of a capital city is
    aligned with its country’s lifetime, and therefore, it cannot exist without its
    country. Therefore, using an `unowned` reference in this scenario would be more
    practical, and if an exception occurs, it indicates an error in the code implementation.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用 `unowned` 而不是 `weak`，但这是一种危险的方法 – 闭包可能仍然存在，而 `self` 被释放，这可能导致异常。然而，在某些情况下，使用
    `unowned` 而不是 `weak` 是安全的，并且这可以从我们类之间的关系中推导出来。一个很好的例子是 `Country` 类和 `CapitalCity`
    类。一个国家有一个对其首都城市的引用，而首都城市可以有一个对其国家的 `unowned` 引用。我们理解首都城市的生命周期与其国家的生命周期是一致的，因此，它不能在没有其国家的情况下存在。因此，在这种情况下使用
    `unowned` 引用将更加实用，如果发生异常，则表明代码实现中存在错误。
- en: 'Here’s a code example that demonstrates using `unowned` between a `Country`
    class and a `CapitalCity` class:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个代码示例，演示了在 `Country` 类和 `CapitalCity` 类之间使用 `unowned`：
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Having an `unowned` reference between `CapitalCity` and `Country` ensures that
    we avoid the retain cycle while still maintaining references between our classes.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `CapitalCity` 和 `Country` 之间有一个 `unowned` 引用确保我们避免了保留周期，同时仍然保持类之间的引用。
- en: Now that we have been through the basic Swift features, we are moving to more
    advanced Swift features to ensure we are covered over there.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了基本的 Swift 特性，我们正在转向更高级的 Swift 特性，以确保我们在这方面有所覆盖。
- en: Advanced Swift language features
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级 Swift 语言特性
- en: Generally, interviewers like to start up softly with Swift features, checking
    different language aspects and trying to locate any red flags we might have about
    Swift.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，面试官喜欢用 Swift 特性开始，检查不同的语言方面，并试图找到我们可能对 Swift 存在的任何红旗。
- en: In this section, we will go through more advanced features of Swift, beginning
    with computed and lazy variables.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨 Swift 的更多高级特性，从计算变量和懒变量开始。
- en: Solving computed and lazy variables questions
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决计算变量和懒变量问题
- en: Computed and lazy variables are both advanced features of Swift variables, providing
    efficient ways to improve performance and code readability.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 计算变量和懒变量都是 Swift 变量的高级特性，提供了提高性能和代码可读性的有效方法。
- en: 'First, let’s be aligned about what computed and lazy variables are:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们明确计算变量和懒变量是什么：
- en: '**Computed variable** – a variable that calculates its value *based on other
    properties*, doesn’t store its value in memory, and calculates it every time it’s
    accessed'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计算变量** – 一种根据其他属性计算其值的变量，不将其值存储在内存中，每次访问时都会重新计算'
- en: 'In the following `Rectangle` class, `area` is a computed variable that is based
    on `width` and `height` values:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下 `Rectangle` 类中，`area` 是一个基于 `width` 和 `height` 值的计算变量：
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**Lazy variable** – a variable whose initial value is *calculated once* when
    it’s first accessed'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**懒变量** – 当它首次访问时，其初始值只计算一次的变量'
- en: 'The following code example explains what a lazy variable is:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例解释了什么是懒变量：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `expensiveObject` variable is only initialized when we first access it.
    We can see the `lazy` keyword prefixed the variable declaration, making it lazy.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`expensiveObject`变量只有在第一次访问它时才会初始化。我们可以看到变量声明前缀了`lazy`关键字，使其变为懒加载。'
- en: Many iOS developers make little use of computed and lazy variables, and most
    of the time, the reasons are a lack of understanding and premature optimization.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 许多iOS开发者很少使用计算属性和懒变量，大多数情况下，原因是对其缺乏理解以及过早的优化。
- en: Now, let’s dive into our first question.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入探讨我们的第一个问题。
- en: “When would you use a computed property instead of a stored property, and vice
    versa?”
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “你会在什么情况下使用计算属性而不是存储属性，反之亦然？”
- en: '*Why is this* *question important?*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个问题为什么重要？*'
- en: That’s a thoughtful question, and it helps to test our understanding of how
    to apply the theory in practice. Both computed and stored properties have their
    advantages and disadvantages in terms of performance and accuracy, so the question
    goes beyond just technical considerations.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个深思熟虑的问题，它有助于测试我们如何将理论应用于实践的理解。在性能和准确性方面，计算属性和存储属性都有其优缺点，因此这个问题超出了仅仅技术考虑的范围。
- en: '*What is* *the answer?*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: Computed properties are used when the value needs to be calculated every time
    the property is being accessed. A computed property usually uses other properties
    to calculate its value. Some examples are date formatted, the area of a rectangle,
    or a full name value that is based on other properties such as first and last
    name.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要每次访问属性时都计算值时，会使用计算属性。计算属性通常使用其他属性来计算其值。一些例子包括日期格式化、矩形的面积，或基于其他属性（如名和姓）的全名值。
- en: Stored properties, on the other hand, are stored and changed from the outside
    of the class based on user input or other events — for example, username, configuration
    value, and more.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，存储属性是从类的外部根据用户输入或其他事件存储和更改的——例如，用户名、配置值等。
- en: Computed properties have a more dynamic nature. They are being calculated constantly
    and are, therefore, more accurate. The downside is that they are less efficient
    in many cases, especially when the value tends to change.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 计算属性具有更动态的特性。它们不断被计算，因此更准确。缺点是它们在许多情况下效率较低，尤其是在值倾向于变化时。
- en: There is a tension between computed and stored properties. Stored properties
    are excellent for performance, but we need to maintain their data accuracy. Computed
    properties are the opposite – they are always accurate but are calculated all
    the time.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 计算属性和存储属性之间存在紧张关系。存储属性在性能方面非常出色，但我们需要维护它们的数据准确性。计算属性则相反——它们总是准确的，但需要不断计算。
- en: “How can you use lazy variables to improve the performance of an app that loads
    large amounts of data?”
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “你如何使用懒变量来提高加载大量数据的应用的性能？”
- en: '*Why is this* *question important?*'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个问题为什么重要？*'
- en: Lazy variables are significant for performance and memory consumption. This
    question tests our ability to optimize our app and UI loading using lazy variables.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 懒变量对性能和内存消耗非常重要。这个问题测试了我们使用懒变量优化应用和UI加载的能力。
- en: '*What is* *the answer?*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: Lazy variables can improve our app’s performance by delaying the data’s initialization
    until it is needed. Loading an object is always considered a heavy task, as the
    runtime environment needs to initialize the object and its properties. So, variables
    that need to initialize and load a large amount of data can affect the loading
    time (and the memory consumption) of the object being loaded. If there’s a possibility
    to postpone the data loading for later, it can improve the object loading time.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 懒变量可以通过延迟数据的初始化直到实际需要时来提高我们应用的性能。加载一个对象始终被视为一项繁重的任务，因为运行时环境需要初始化对象及其属性。因此，需要初始化和加载大量数据的变量可能会影响被加载对象的加载时间（以及内存消耗）。如果有可能将数据加载推迟到以后，那么可以提高对象的加载时间。
- en: 'Here’s an example of a lazy loading code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个懒加载代码的例子：
- en: '[PRE23]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We can see from the preceding code that the `largeData` variable can take time
    to be initialized, so we declared it as `lazy`. When we allocate `data`, `largeData`
    is still not allocated, not until we call it using the `print` command.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中我们可以看到，`largeData`变量可能需要一些时间来初始化，所以我们将其声明为`lazy`。当我们分配`data`时，`largeData`还没有被分配，直到我们使用`print`命令调用它。
- en: Solving extensions questions
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决扩展问题
- en: Some of the features we discussed are related to code organization. For example,
    access levels are not just for technical restrictions; they are also part of organizing
    our code and declaring what’s part of the interface and what’s encapsulated.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论的一些特性与代码组织相关。例如，访问级别不仅仅是技术限制；它们也是组织我们的代码和声明接口部分以及封装部分的一部分。
- en: Another important feature in that area is **extensions**.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个领域，另一个重要的特性是**扩展**。
- en: 'Extensions in Swift have several important roles:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 中的扩展有几个重要的角色：
- en: Extensions allow us to *add new functionality to existing classes*, structs,
    and enums without modifying their source code
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展允许我们向现有的类、结构体和枚举添加新功能，而无需修改它们的源代码
- en: Extensions can help us to *group related functionality* and improve our code
    readability and organization
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展可以帮助我们**分组相关功能**，提高我们的代码可读性和组织性
- en: Extensions are used to *add protocol conformance* to types, aligning their interface
    with other types conforming to the same protocol
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展用于向类型添加**协议符合性**，使它们的接口与其他符合同一协议的类型对齐
- en: We can see how many extensions are essential to Swift language, as they are
    widely used in our daily iOS development.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，Swift 语言中有多少扩展是必不可少的，因为它们在我们的日常 iOS 开发中被广泛使用。
- en: Even though extensions are powerful, they are effortless to use and understand.
    That’s why we must be highly prepared for this topic, as any mistake can raise
    a red flag for our interviewer.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管扩展功能强大，但它们的使用和理解却毫不费力。这就是为什么我们必须对这个主题做好充分准备，因为任何错误都可能在我们面试官面前拉响红灯。
- en: Now let’s move to our first question.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转到我们的第一个问题。
- en: “Can you add new properties to a struct or class using an extension?”
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “你能否使用扩展向结构体或类添加新属性？”
- en: '*Why is this* *question important?*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个问题为什么重要？*'
- en: This question seems like a simple yes/no question, but the reality is that it
    hides two more layers of understanding the interviewer wishes to hear.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题看起来像是一个简单的肯定/否定问题，但现实情况是它隐藏了面试官希望听到的两个更深的理解层次。
- en: First, they want to hear the practical layer – what is and is not *possible*
    in extensions (aka the full answer).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，他们想听到实际层面——在扩展中什么可行，什么不可行（即完整答案）。
- en: But second, and this is a bonus, they want to hear *why extensions work the
    way they work*. That will show how deeply we understand Swift memory usage.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 但其次，这是一个额外的要求，他们想听到为什么扩展会以这种方式工作。这将展示我们如何深入理解 Swift 的内存使用。
- en: Don’t worry, we’ll cover both layers in our answer.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 别担心，我们会在答案中涵盖这两个层次。
- en: '*What is* *the answer?*'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: The short answer is “no,” we cannot add stored properties in extensions. But
    it is worth mentioning that it is possible to add computed properties. The reason
    is that we can add new functionality to a type but not its memory layout, which
    can imply to us what can/can’t be added to a type using extensions.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 简短的答案是“不”，我们不能在扩展中添加存储属性。但值得一提的是，我们可以添加计算属性。原因是我们可以向类型添加新功能，但不能修改其内存布局，这可以暗示我们使用扩展可以向类型添加什么/不能添加什么。
- en: There are several workarounds for that – wrapping the original type or using
    a global variable to store the property value, but the idea stays the same.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个问题，有几个解决方案——包装原始类型或使用全局变量来存储属性值，但基本思路是一样的。
- en: 'Now for the “bonus” part of the answer: a type’s memory layout is *determined
    in compile-time* and embedded in the binary. This means that we cannot add new
    stored properties on the fly using extensions, as they will make changes to the
    memory layout set earlier. Adding that fact to the answer would give us additional
    points in the interview!'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是答案的“额外”部分：一个类型的内存布局是在编译时确定的，并嵌入到二进制文件中。这意味着我们不能使用扩展即时添加新的存储属性，因为它们将改变之前设置的内存布局。将这个事实添加到答案中将在面试中给我们额外的分数！
- en: “Can you use an extension to add a method to a protocol? If so, how?”
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “你能否使用扩展向协议添加方法？如果是，怎么做？”
- en: '*Why is this* *question important?*'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个问题为什么重要？*'
- en: This is a tricky question. Protocols are not types. Extending the protocol is
    like adding new functionality to the conforming types. Confused? That’s why this
    question is tricky… Let’s see the answer to clear things up.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个棘手的问题。协议不是类型。扩展协议就像为符合协议的类型添加新功能。困惑吗？这就是为什么这个问题棘手……让我们看看答案来澄清一下。
- en: '*What is* *the answer?*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: Yes, it is possible to extend a protocol. Extending a protocol adds new functionality
    to all types that conform to that protocol, allowing us to add a default implementation
    to protocol methods.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，可以扩展一个协议。扩展协议为所有符合该协议的类型添加了新功能，允许我们为协议方法添加默认实现。
- en: 'Let’s see a code example of extending a protocol:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看扩展协议的代码示例：
- en: '[PRE24]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can see that the `MyProtocol` extension adds a new method: `newMethod()`.
    The new method can be used in all types that conform to `MyProtocol`. Let’s continue
    the code example to explain that:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，`MyProtocol` 扩展添加了一个新方法：`newMethod()`。这个新方法可以在所有符合 `MyProtocol` 的类型中使用。让我们继续代码示例来解释这一点：
- en: '[PRE25]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: I hope it’s clearer now, as `myStruct` can call `newMethod()` even though it
    wasn’t defined in the original protocol declaration.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该更清晰了，因为 `myStruct` 可以调用 `newMethod()`，即使它没有在原始协议声明中定义。
- en: Solving generics questions
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决泛型问题
- en: '**Generics** are Swift features that allow iOS developers to write reusable
    code that can work with any type of data.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**泛型**是 Swift 特性，允许 iOS 开发者编写可重用的代码，这些代码可以与任何类型的数据一起使用。'
- en: For iOS developers, generics are particularly important because they can be
    used to write reusable and type-safe code. This means developers can write code
    used in multiple places within an app without worrying about typecasting or other
    type-related issues. Additionally, generics can help to prevent runtime errors
    and improve performance by allowing the compiler to optimize the code at compile
    time. Overall, generics are powerful tools that can help iOS developers write
    more robust and efficient code.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 iOS 开发者来说，泛型尤为重要，因为它们可以用来编写可重用且类型安全的代码。这意味着开发者可以在应用程序的多个地方使用相同的代码，而无需担心类型转换或其他类型相关的问题。此外，泛型可以帮助防止运行时错误，并通过允许编译器在编译时优化代码来提高性能。总的来说，泛型是强大的工具，可以帮助
    iOS 开发者编写更健壮和高效的代码。
- en: 'Now, let’s see an example of a reverse method for an array that can work with
    any type:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个可以与任何类型一起工作的数组反转方法的例子：
- en: '[PRE26]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The most important thing to understand about that code snippet is this line:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这段代码最重要的地方是这一行：
- en: '[PRE27]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `reverseArray()` method receives an array from a specific type and returns
    an array at the same time. Perhaps that’s the core concept of generics – not just
    creating reusable code but also maintaining type safety and avoiding type-casting
    issues.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`reverseArray()` 方法接收一个特定类型的数组，并返回一个数组。这可能就是泛型的核心概念——不仅仅是创建可重用的代码，而且还要保持类型安全并避免类型转换问题。'
- en: “Can you give an example of a problem that can be solved using generics?”
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “你能给出一个使用泛型解决的问题的例子吗？”
- en: '*Why is this* *question important?*'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要？*'
- en: Like previous questions, this question challenges us by taking a theoretical
    topic and asking for a real-life example of how to use it.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的问题一样，这个问题通过将一个理论话题与如何在实际生活中使用它的例子相结合来挑战我们。
- en: Compared to other Swift features, it is harder to understand generics’ benefits
    without going over real-world problems and solutions.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他 Swift 特性相比，如果不通过实际问题和解决方案来了解，泛型的优势就难以理解。
- en: '*What is* *the answer?*'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: A caching class is an excellent example of a problem that can be solved using
    generics. If we want to cache data, we need to create a separate class for each
    type we want to cache or create a different method in some abstract class.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存类是使用泛型解决问题的一个绝佳例子。如果我们想要缓存数据，我们需要为每种想要缓存的数据类型创建一个单独的类，或者在某个抽象类中创建不同的方法。
- en: 'In this case, generics let us reuse the same code for different types:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，泛型让我们可以为不同类型重用相同的代码：
- en: '[PRE28]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is how we use the `Cache` class with `Int`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何使用 `Cache` 类与 `Int`：
- en: '[PRE29]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: A cache is a good example because it doesn’t require us to cast the returned
    type. We can initialize a new cache instance that works with a different kind
    of data each time.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存是一个很好的例子，因为它不需要我们转换返回的类型。我们可以初始化一个新的缓存实例，每次都使用不同类型的数据。
- en: “How do you use associated types in a generic protocol?”
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “如何在泛型协议中使用关联类型？”
- en: '*Why is this* *question important?*'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要？*'
- en: '**Associated types** are features that iOS developers rarely use, but I still
    want to dedicate one question to them. The reason is that it can give you a better
    picture of generics’ usage and examples in Swift. It is difficult for many iOS
    developers to find practical use cases for generics, so providing an example from
    a different perspective may help your interview readiness.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**关联类型**是 iOS 开发者很少使用的一个特性，但我仍然想为它们专门提出一个问题。原因是它可以给你一个更好的泛型在 Swift 中的使用和示例的概览。许多
    iOS 开发者很难找到泛型的实际用例，所以从一个不同的角度提供一个例子可能会帮助你准备面试。'
- en: '*What is* *the answer?*'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案是什么**？'
- en: Associated types are actually *generics for protocols*. They work the same way
    as classes and structs work with generics.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 关联类型实际上是**协议的泛型**。它们与类和结构体使用泛型的方式相同。
- en: 'To use the associated type, we need to define it in a protocol using the keyword
    `associatedtype`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用关联类型，我们需要在协议中使用关键字 `associatedtype` 来定义它：
- en: '[PRE30]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `DataSource` protocol contains a `Data` `associatedtype`, but it is not
    specified what kind of type it will be used. We do that in the protocol implementation.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataSource` 协议包含一个 `Data` 关联类型，但它没有指定它将使用哪种类型。我们在协议实现中这样做。'
- en: 'For example, this is an implementation of `DataSource` with `Int` as `Data`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是一个使用 `Int` 作为 `Data` 的 `DataSource` 的实现：
- en: '[PRE31]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Of course, other structs or classes can implement the protocol using a different
    type by defining it in the `Data` type alias, which makes this protocol flexible
    and reusable.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，其他结构体或类可以通过在 `Data` 类型别名中定义它来实现该协议，这使得这个协议更加灵活和可重用。
- en: Solving error-handling questions
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决错误处理问题
- en: Error handling is an essential topic in every language and platform. It lets
    us respond to unexpected events or conditions (which makes them “expected” when
    we think of it).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理是每种语言和平台中一个基本的话题。它使我们能够对意外的事件或条件做出响应（当我们这样考虑时，它们就变得“可预期”）。
- en: Error handling and Swift are interesting when we discuss job interviews – first,
    this area *improved tremendously* when we moved from Objective-C to Swift. Still,
    it also improved dramatically between the different Swift versions. Consider that
    by the time you read this book, probably more changes will have been made in error
    handling, so it is worth having a look.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论工作面试时，错误处理和 Swift 是很有趣的——首先，当我们从 Objective-C 转移到 Swift 时，这个领域**有了巨大的改进**。然而，在不同的
    Swift 版本之间，它也发生了巨大的变化。考虑到你阅读这本书的时候，错误处理可能已经发生了更多的变化，所以看看它是值得的。
- en: Moreover, the *increasing popularity of Combine and SwiftUI* made error handling
    even more popular. We can confidently say that error handling is a fundamental
    part of Combine data streams, and if that’s an area we feel insecure about, now
    is the time to catch up!
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，**Combine 和 SwiftUI 的日益流行**使得错误处理变得更加普遍。我们可以有信心地说，错误处理是 Combine 数据流的一个基本部分，如果我们对这个领域感到不安全，现在是赶上来的时候了！
- en: “How do you use the try? and try! operators for error handling in Swift?”
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “你如何在 Swift 中使用 try? 和 try! 操作符进行错误处理？”
- en: '*Why is this* *question important?*'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么这个问题很重要**？'
- en: '`try?` and `try!` are operators that handle errors more concisely.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`try?` 和 `try!` 是处理错误更简洁的操作符。'
- en: It is important to explain the difference between the two operators and implement
    them in our code flow.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 解释这两个操作符之间的区别并在我们的代码流中实现它们是很重要的。
- en: '*What is* *the answer?*'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案是什么**？'
- en: 'Instead of using the `do-catch` flow, we can use the `try?` operator to bypass
    it, similar to how we unwrap an optional:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用 `do-catch` 流，我们可以使用 `try?` 操作符来绕过它，类似于我们解包可选值的方式：
- en: '[PRE32]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this code example, we wrap the call for `someThrowingFunction()` with the
    `try?` operator. The result is an optional value – if the function throws an exception,
    the returned value will be nil.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中，我们使用 `try?` 操作符包裹对 `someThrowingFunction()` 的调用。结果是可选值——如果函数抛出异常，返回的值将是
    nil。
- en: 'However, `try!` is exactly like force unwrapping. If the function throws an
    exception, our program will be terminated:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`try!` 与强制解包非常相似。如果函数抛出异常，我们的程序将被终止：
- en: '[PRE33]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Notice that we should use `try!` with caution and in cases where there’s no
    point in continuing our program if the function throws an exception.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们应该谨慎使用 `try!`，并在函数抛出异常时没有继续程序的意义的情况下使用它。
- en: “Can you explain and give an example of how you would write a function in Swift
    that throws an error?”
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “你能解释并给出一个例子说明你如何在 Swift 中编写一个会抛出错误的函数吗？”
- en: '*Why is this* *question important?*'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么这个问题很重要**？'
- en: Many developers know how to perform a basic `do-catch` block, mainly because
    it is required in many cases.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者都知道如何执行基本的 `do-catch` 块，主要是因为在很多情况下这是必需的。
- en: The natural step forward is to perform the throwing action ourselves. Knowing
    how to write a function that throws an exception shows a good understanding of
    Swift’s error-handling mechanism.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 向前迈出的自然一步是我们自己执行抛出操作。知道如何编写抛出异常的函数表明了对 Swift 的错误处理机制的深刻理解。
- en: '*What is* *the answer?*'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: 'There are three things we need to do to have a throwing function:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现一个抛出异常的函数，我们需要做三件事情：
- en: 'The first thing is to *add the* **throws** *keyword* to its declaration:'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一件事是在其声明中添加 **throws** 关键字：
- en: '[PRE34]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The second thing is having some kind of an *error to throw back* in case of
    a problem:'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二件事是在出现问题时有一个可以 *抛回的错误*：
- en: '[PRE35]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The third will be the implementation and *throwing the error in case of an
    exception* (complete code ahead):'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三件事将是实现并 *在出现异常时抛出错误*（完整的代码如下）：
- en: '[PRE36]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Remembering these three fundamental components of throwing functions will help
    us nail this function efficiently.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 记住抛出函数的这三个基本组成部分将帮助我们有效地掌握这个函数。
- en: If you still feel insecure about error handling, try to return to one of your
    projects and add error handling in places where you think it’s relevant. There’s
    nothing like practical experience to deal with topics with which you don’t feel
    strongly about.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然对错误处理感到不安全，尝试回到你的一个项目中，并在你认为相关的位置添加错误处理。没有什么比实际经验更能处理你不太关心的主题了。
- en: Solving protocol questions
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决协议问题
- en: One of the most important principles in computer science is the **Separation
    of Concerns**. To achieve that, one of the things we want to do is reduce coupling
    between different parts of our code – decoupling objects and classes.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学中最重要的原则之一是 **关注点的分离**。为了实现这一点，我们想要做的事情之一是减少代码不同部分之间的耦合——解耦对象和类。
- en: Protocols play a significant part in this task, making our code more flexible
    and reusable. In modern iOS development, protocols are a fundamental part of the
    development, and we can find them heavily used in almost every API and SDK.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 协议在这个任务中扮演着重要的角色，使我们的代码更加灵活和可重用。在现代 iOS 开发中，协议是开发的基础部分，我们可以在几乎每个 API 和 SDK 中找到它们被大量使用。
- en: “Can you explain the use of protocol-oriented programming in iOS development?”
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “你能解释一下在 iOS 开发中使用协议导向编程的用途吗？”
- en: '*Why is this* *question important?*'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要？*'
- en: Even though that’s an open-ended question, it is common in interviews. Maybe
    because it is an open question, interviewers like to ask it so they can understand
    how candidates think.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是一个开放性问题，但在面试中很常见。也许因为它是一个开放性问题，面试官喜欢问它，这样他们就可以了解候选人的思考方式。
- en: Protocols are like spices in cooking – technically, they are easy to use. The
    problem starts with how much and when.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 协议就像烹饪中的调料——技术上，它们很容易使用。问题始于使用多少和何时。
- en: We should be ready for this question, and it is also a chance to spread our
    methodologic point of view of protocol’s role in our code writing.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该对此问题有所准备，这也是传播我们关于协议在代码编写中作用的观点的机会。
- en: '*What is* *the answer?*'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: The first thing to understand about **Protocol-Oriented Programming** (**POP**)
    is that it’s a programming paradigm. This means that POP is a set of guidelines
    and rules for organizing and structuring our code.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 **协议导向编程**（**Protocol-Oriented Programming**，**POP**）的第一件事是要理解它是一种编程范式。这意味着
    POP 是一组用于组织和结构化我们代码的指南和规则。
- en: The main idea of POP is that objects communicate with each other using protocols.
    This makes our code much more flexible and reusable, as different types can implement
    different behaviors and still work with other objects by conforming to the same
    interface.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: POP 的主要思想是对象通过协议相互通信。这使得我们的代码更加灵活和可重用，因为不同类型可以实施不同的行为，并且通过遵循相同的接口仍然可以与其他对象一起工作。
- en: POP works with **Object-Oriented Programming** (**OOP**) and doesn’t replace
    it.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: POP 与 **面向对象编程**（**Object-Oriented Programming**，**OOP**）一起工作，并不取代它。
- en: “How do you decide when to use a protocol in your iOS app?”
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “你如何在你的 iOS 应用中使用协议？”
- en: '*Why is this* *question important?*'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要？*'
- en: This question takes a theory topic (protocol) and moves it to the practical
    world of considerations and tradeoffs. The interviewer doesn’t want to hear a
    dichotomous answer but rather a more profound solution involving our point of
    view on Swift’s development.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题将理论话题（协议）转移到实际考虑和权衡的世界中。面试官不希望听到二分法答案，而更希望听到一个更深刻的解决方案，涉及我们对Swift开发的看法。
- en: '*What is* *the answer?*'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: 'I’ll start with the bottom line: we shouldn’t always use protocols. We should
    use them only when it is effective and they don’t make our project more cumbersome
    than it is already. We should do that with caution and according to the following
    factors:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我先从底线开始：我们不应该总是使用协议。我们只应该在它有效且不会使我们的项目比现在更复杂时使用它们。我们应该谨慎行事，并根据以下因素：
- en: '*Interface reusability* – if we want to reuse a specific interface between
    different types.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*接口可重用性* – 如果我们想在不同的类型之间重用特定的接口。'
- en: '*Abstraction* – A protocol provides another level of abstraction to our code
    by defining a set of methods and properties used by different objects.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*抽象* – 协议通过定义一组由不同对象使用的方法和属性，为我们代码提供了另一层抽象。'
- en: '*Dependency injection* – We can use protocols to inject dependencies into a
    class and, by that, make it more flexible and testable.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*依赖注入* – 我们可以使用协议将依赖项注入到类中，从而使其更具灵活性和可测试性。'
- en: To summarize, protocols are a great solution whenever we need more flexibility
    and decreased coupling in our code.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，当我们需要更多灵活性和减少代码耦合时，协议是一个很好的解决方案。
- en: On the other hand, protocols can add a layer of complexity to our code, adding
    a virtual layer between classes. And that’s an expected trade-off in programming
    – *complexity* *versus coupling*.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，协议可以为我们的代码增加一层复杂性，在类之间添加一个虚拟层。这在编程中是一个预期的权衡 – *复杂性* 与 *耦合性*。
- en: Solving memory management questions
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决内存管理问题
- en: Memory management for iOS developers has been a critical issue from the beginning
    days of iOS development.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 对于iOS开发者来说，内存管理自iOS开发初期以来一直是一个关键问题。
- en: I must say that things have become better over the years – Apple added **Automatic
    Reference Counting** (**ARC**), debug tools became better, and the hardware has
    evolved dramatically.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须说，随着时间的推移，事情变得更好了——苹果增加了**自动引用计数**（**ARC**），调试工具变得更好，硬件也发生了巨大变化。
- en: Having said that, efficiency is still essential when discussing resource management.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，在讨论资源管理时，效率仍然是至关重要的。
- en: Be prepared for some questions on that topic in your next iOS technical interview.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好在你下一次iOS技术面试中回答有关该主题的一些问题。
- en: “What is the difference between a strong and a weak reference in iOS?”
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “iOS中强引用和弱引用的区别是什么？”
- en: '*Why is this* *question important?*'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个问题为什么重要？*'
- en: '**Strong** and **weak** references are the core components of the memory ownership
    concept we have in Swift.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**强**和**弱**引用是我们在Swift中内存所有权概念的核心组成部分。'
- en: Ownership is the key to ARC, which is the basis of the memory management mechanism
    in iOS, and if we don’t understand how that mechanism works, we are on the path
    of creating **memory leaks** and **retaining cycles**.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 所有权是ARC的关键，这是iOS中内存管理机制的基础，如果我们不了解该机制的工作原理，我们就会走上创建**内存泄漏**和**保留循环**的道路。
- en: '*What is* *the answer?*'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: 'The answer is fairly simple: a strong reference (which is the default reference
    unless defined otherwise) is a way to indicate an object is being held in memory
    by one or more elements. In contrast, a weak reference allows the object to be
    deallocated when it is no longer needed.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 答案相当简单：强引用（除非另有定义，否则默认为强引用）是一种指示一个对象被一个或多个元素在内存中持有的方式。相比之下，弱引用允许对象在不再需要时被释放。
- en: A strong reference *increases* the reference counting by one, while a weak reference
    *doesn’t change* the reference counting at all.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 强引用会将引用计数增加一，而弱引用则完全不改变引用计数。
- en: A good example of weak reference usage is **a** **delegate pattern**.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 弱引用的一个很好的例子是**一个** **委托模式**。
- en: 'Let’s see an example:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子：
- en: '[PRE37]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this code example, we can see that the `ViewController` has a strong reference
    to its `delegate` object, while the `delegate` object has a weak reference to
    its `ViewController`. The reason for this arrangement is to avoid a retain cycle
    and, as a result, increase our app memory usage.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中，我们可以看到`ViewController`对其`delegate`对象有强引用，而`delegate`对象对其`ViewController`有弱引用。这种安排的原因是为了避免保留循环，从而增加我们的应用内存使用。
- en: “How do you handle low memory warnings in iOS?”
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “如何在 iOS 中处理低内存警告？”
- en: '*Why is this* *question important?*'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题重要？*'
- en: This question is designed to assess our understanding of managing resources.
    There are situations where it is acceptable to receive low memory warnings, but
    the question is how we should handle it when it occurs. Having control over the
    resources in our app allows us to manage and respond to these situations appropriately.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题旨在评估我们对资源管理的理解。有些情况下，收到低内存警告是可以接受的，但问题是当它发生时我们应该如何处理。控制我们应用中的资源使我们能够适当地管理和应对这些情况。
- en: '*What is* *the answer?*'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: One thing we need to do when we get a low memory warning is to release any unnecessary
    resources and reduce the app’s memory footprint.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们收到低内存警告时，我们需要做的一件事是释放任何不必要的资源并减少应用的内存占用。
- en: 'Here are some examples of how to reduce our app’s memory footprint:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些减少我们应用内存占用的例子：
- en: Release cache data
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 释放缓存数据
- en: Use autorelease pools
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 autorelease pools
- en: Use weak references
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用弱引用
- en: Release unused resources such as off-screen views
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 释放未使用的资源，例如屏幕外的视图
- en: Use NSCache
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 NSCache
- en: That’s the time to dig in our memory from past projects and try to remember
    resources we could have released when we get low memory warnings.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是深入挖掘我们过去项目的内存，并尝试回忆起在收到低内存警告时可以释放的资源。
- en: Summary
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed the many topics in Swift development, both basic
    and advanced. We covered optionals, access levels, closures, computed and lazy
    variables, extensions, generics, error handling, protocols, and memory management.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们讨论了 Swift 开发中的许多主题，包括基础和高级内容。我们涵盖了可选类型、访问级别、闭包、计算属性和懒加载属性、扩展、泛型、错误处理、协议和内存管理。
- en: These are a lot of topics! But on the other hand, we are experienced Swift developers,
    and these all need to be familiar.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这些有很多主题！但另一方面，我们是有经验的 Swift 开发者，所有这些都需要熟悉。
- en: As I said earlier, we are good iOS developers and know the job well. We just
    need to organize our knowledge to be prepared for our interview.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所说，我们是优秀的 iOS 开发者，并且对工作非常了解。我们只需要组织我们的知识，以便为我们的面试做好准备。
- en: Our next chapter deals with something different than just Swift – we will talk
    about code management.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的章节将讨论不仅仅是 Swift 的内容——我们将讨论代码管理。
