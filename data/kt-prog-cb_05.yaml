- en: Object-Oriented Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象编程
- en: 'The following recipes will be covered in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Working with interfaces in Kotlin
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Kotlin中使用接口
- en: How to implement complicated interfaces with multiple overridden methods in
    Kotlin
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin中如何实现具有多个重写方法复杂接口
- en: How to extend a class in Kotlin (Inheritance and Extension functions)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin中如何扩展类（继承和扩展函数）
- en: How to work with Generics in Kotlin
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin中如何使用泛型
- en: How to implement polymorphism in Kotlin
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin中如何实现多态
- en: Restricting class hierarchies
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制类层次结构
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: '**Object-Oriented Programming**, also known as **OOP**, is a programming paradigm
    based on objects. In this programming paradigm, objects contain data in the form
    of fields and code in the form of methods, which can be used to modify the data
    of the same object. In some object-oriented languages, objects are instances of
    classes (for example, Java and Kotlin). In object-oriented programming, our code
    is made up of objects that interact with each other. In this chapter, we will
    learn about some key components of OOPs, such as interfaces, classes, class hierarchies,
    and Generics.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向对象编程**，也称为**OOP**，是一种基于对象的编程范式。在这个编程范式中，对象以字段的形式包含数据，以方法的形式包含代码，这些代码可以用来修改同一对象的数据。在某些面向对象的语言中，对象是类的实例（例如Java和Kotlin）。在面向对象编程中，我们的代码由相互交互的对象组成。在本章中，我们将学习OOPs的一些关键组件，例如接口、类、类层次结构和泛型。'
- en: Working with interfaces in Kotlin
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Kotlin中使用接口
- en: '**Interfaces** in OOP are like the *contract*. They define the behavior or
    rules. The classes that implement them need to do so in order to conform to the
    behavior defined by interfaces. However, that''s not it. Interfaces in Kotlin
    provide much more. Prior to Java 8, we couldn''t have the implementation of methods
    in the interfaces, but in Kotlin, we can have that too! In this recipe, we will
    see how to deal with interfaces in Kotlin.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向对象编程**中的**接口**就像**合同**。它们定义了行为或规则。实现它们的类需要这样做，以便符合接口定义的行为。然而，这还不是全部。Kotlin中的接口提供了更多。在Java
    8之前，我们无法在接口中实现方法，但在Kotlin中，我们也可以这样做！在这个菜谱中，我们将了解如何处理Kotlin中的接口。'
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: I'll be using IntelliJ IDEA for writing and executing code. You are free to
    use any IDE where you can run the Kotlin code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用IntelliJ IDEA来编写和执行代码。你可以自由地使用任何可以运行Kotlin代码的IDE。
- en: How to do it…
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'As we have just discussed, interfaces in Kotlin can have the implementation
    of methods; let''s follow these mentioned steps to check that out:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才讨论的，Kotlin中的接口可以有方法实现；让我们按照以下步骤来验证这一点：
- en: 'Let''s create an interface named `DemoInterface`:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`DemoInterface`的接口：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Defining a method with implementation in the interface is just like you would
    do inside a class.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在接口中定义带有实现的方法就像在类内部做的那样。
- en: 'Now, let''s see a class that has implemented the preceding interface:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个实现了前面接口的类：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, you can call the method like this:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你可以这样调用方法：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here''s the output:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A key benefit to this new type of interface is that you can have the behavior
    of multiple interfaces since it allows method implementation:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这种新型接口的一个关键好处是，你可以拥有多个接口的行为，因为它允许方法实现：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see in the preceding code, using multiple interfaces, we have the
    behavior of two entities. Yes, this may sound like multiple inheritance.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的代码所示，使用多个接口，我们拥有了两个实体的行为。是的，这听起来可能像是多重继承。
- en: 'Suppose you have two types of interfaces, and both have the methods with the
    same name, as follows:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你有两种类型的接口，并且它们都有相同名称的方法，如下所示：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, if you try to implement both interfaces to a class, the compiler will
    throw an error:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果你尝试将两个接口都实现到一个类中，编译器将会抛出一个错误：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The reason is intuitive, as it brings ambiguity of which method to call. Hence,
    Kotlin will require you to implement that method and call the desired method inside
    it, something like this:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原因是直观的，因为它带来了调用哪个方法的歧义。因此，Kotlin将要求你实现该方法，并在其中调用所需的方法，类似于以下这样：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, you will simply call the `foo` method, as earlier:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你将简单地调用`foo`方法，就像之前一样：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is the output:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Interfaces in Kotlin can have the implementation of methods, but can't have
    states. This means you can't declare a property in the interface and store the
    state in it. Either the class implementing it needs to override it, or you need
    to implement its accessor also.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin中的接口可以有方法实现，但不能有状态。这意味着你无法在接口中声明一个属性并将其用于存储状态。要么实现它的类需要覆盖它，要么你需要实现它的访问器。
- en: 'For example, you can''t have `val a=23` in an interface, though you can have
    something like the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你无法在接口中拥有`val a=23`这样的声明，尽管你可以有类似以下的内容：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Alternatively, simply define it in the interface and override it in the implementing class,
    like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，简单地定义它在接口中，并在实现类中覆盖它，如下所示：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we will look at interfaces delegation in Kotlin:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨Kotlin中的接口委托：
- en: 'A delegation pattern, an object ( [https://en.wikipedia.org/wiki/Object_(computer_science)](https://en.wikipedia.org/wiki/Object_(computer_science)))
    handles a request by delegating to a second object. Let''s take a look at the
    following code:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 委托模式，一个对象（[https://en.wikipedia.org/wiki/Object_(computer_science)](https://en.wikipedia.org/wiki/Object_(computer_science)))通过将请求委托给第二个对象来处理。让我们看看以下代码：
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the preceding example, we are delegating the call to the `foo` method, to
    the object that has implemented the interface A. While the preceding code is perfectly
    fine, Kotlin allows us to use the function directly. Look at this code:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们将`foo`方法的调用委托给了实现了接口A的对象。虽然前面的代码是完美的，但Kotlin允许我们直接使用该函数。看看这段代码：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, the `InterfaceImplementation` class is implementing `A` but
    is delegating the implementation to the objects that it is receiving as parameters.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所见，`InterfaceImplementation`类实现了`A`，但它将实现委托给接收到的作为参数的对象。
- en: There's more…
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容…
- en: Now that Kotlin supports the implementation of methods in interfaces, you might
    be thinking what's the difference between an `interface` and `abstract` methods.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Kotlin支持在接口中实现方法，你可能会想，`interface`和`abstract`方法之间有什么区别。
- en: In interfaces, you can only define the property, which needs to be overridden
    by implementing class. However, in an abstract class, you can have an implementation
    that works with the state so that it cannot be overridden in the derived classes.
    In an abstract class, you can define some states and methods that will be the
    same in the derived class.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在接口中，你只能定义需要由实现类覆盖的属性。然而，在抽象类中，你可以有一个与状态一起工作的实现，这样它就不能在派生类中被覆盖。在抽象类中，你可以定义一些在派生类中将相同的状态和方法。
- en: Another key difference is that you can have final members in an abstract class,
    but not in interfaces. Also, interfaces don't support `protected` and `internal` modifiers.
    It only supports `private`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个关键的区别是，你可以在抽象类中拥有最终成员，但不能在接口中。此外，接口不支持`protected`和`internal`修饰符。它只支持`private`。
- en: How to implement complicated interfaces with multiple overridden methods in
    Kotlin
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何在Kotlin中实现具有多个覆盖方法的复杂接口
- en: '**SOLID **is a mnemonic acronym that is used to define the five basic **object-oriented
    design** principles:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**SOLID**是一个记忆法缩写，用于定义五个基本的**面向对象设计**原则：'
- en: Single Responsibility Principle
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: Open-Closed Principle
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开放封闭原则
- en: Liskov Substitution Principle
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 李斯克代换原则
- en: Interface Segregation Principle
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口分离原则
- en: Dependency Inversion Principle
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖倒置原则
- en: The **Interface Segregation Principle**(**ISP**) states that if an interface
    becomes too long, it is better to split it into smaller pieces (interfaces) so
    that the client doesn't need to implement the ones in which they are not interested.
    In this recipe, we will understand what and why this is important.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**接口分离原则**（**ISP**）指出，如果一个接口变得太长，最好是将其拆分成更小的部分（接口），这样客户端就不需要实现他们不感兴趣的接口。在这个菜谱中，我们将了解为什么这是重要的。'
- en: Getting ready
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will be using Android Studio 3.0\. Ensure that you have its latest version.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Android Studio 3.0。请确保你有其最新版本。
- en: How to do it…
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何去做…
- en: 'Let''s see an example where ISP can help us:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看ISP如何能帮到我们的一个例子：
- en: 'This is a simple example of a "fat" interface:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个“胖”接口的简单例子：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, the problem of a big interface is that we are forced to implement
    the methods even if we don't have anything to do it in there.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所见，大接口的问题在于我们被迫实现方法，即使我们那里没有任何事情要做。
- en: 'A simple solution is to break that interface into smaller interfaces, like
    the following code:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个简单的解决方案是将该接口拆分成更小的接口，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that now we have divided the one big interface into smaller ones, which
    can be implemented independently.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，现在我们已经将一个大接口分解成更小的接口，这些接口可以独立实现。
- en: 'Kotlin also has a powerful feature that allows you to write full implementation
    of methods in the interfaces itself. Let''s take a look at the following code
    to understand it:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kotlin 还有一个强大的功能，允许你在接口本身编写方法的完整实现。让我们看一下以下代码来理解它：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, we implemented the whole method in the interface, and we were
    able to call it from the class that implemented that interface.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，我们在接口中实现了整个方法，并且能够从实现了该接口的类中调用它。
- en: This feature can also be used to follow the ISP principle, as we can put a commonly
    used method in the interfaces itself; as a result, we will not need to implement
    it every time we implement that interface.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此功能还可以用于遵循 ISP 原则，因为我们可以在接口本身放置一个常用方法；因此，我们不需要每次实现该接口时都实现它。
- en: How to extend a class in Kotlin (Inheritance and Extension functions)
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何在 Kotlin 中扩展类（继承和扩展函数）
- en: In this recipe, we will learn how to extend a class (Inheritance) and how to
    extend the functionality of a class using Kotlin's Extension functions.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何扩展类（继承）以及如何使用 Kotlin 的扩展函数扩展类的功能。
- en: '**Inheritance** is probably the first concept you learn in object-oriented
    programming. It is a mechanism where a new class is derived from an existing class.
    Via this, the classes may inherit or acquire the properties and methods of other
    classes. **Extension functions**, on the other hand, let us skip creating wrapper
    for functionality and enable us to add extra functions to the classes. Let''s
    see both of them now.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**继承**可能是你在面向对象编程中学习的第一个概念。它是一种机制，其中新类从现有类派生出来。通过这种方式，类可以继承或获取其他类的属性和方法。另一方面，**扩展函数**允许我们跳过创建功能包装器，并能够向类添加额外的函数。现在让我们看看这两个概念。'
- en: Getting ready
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Since we will be dealing with Android code, it is recommended that you use Android
    Studio as IDE. The source code can be found in the 1-recycler-view-in-kotlin branch of
    the [https://gitlab.com/aanandshekharroy/kotlin-cookbook](https://gitlab.com/aanandshekharroy/kotlin-cookbook)
    repository.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将处理 Android 代码，建议您使用 Android Studio 作为 IDE。源代码可以在 [https://gitlab.com/aanandshekharroy/kotlin-cookbook](https://gitlab.com/aanandshekharroy/kotlin-cookbook)
    仓库的 1-recycler-view-in-kotlin 分支中找到。
- en: How to do it…
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做……
- en: 'A class derived from another class is called a subclass, whereas the class
    from which a subclass is derived is called a superclass. In this example, we will
    create a superclass A and a subclass B. To extend class B, we need to use `:` in
    the class declaration, and then add the superclass name with its primary constructor.
    Let''s take a look at the following steps:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 从另一个类派生出来的类称为子类，而派生子类的类称为超类。在这个例子中，我们将创建一个超类 A 和一个子类 B。要扩展类 B，我们需要在类声明中使用 `:`，然后添加超类名称及其主构造函数。让我们看看以下步骤：
- en: 'A key thing to remember is that classes in Kotlin are *closed* for extension
    by default, so we need to open them by adding the *open* keyword before the class
    declaration. So our superclass A looks like this:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要记住的关键一点是，Kotlin 中的类默认是 *封闭* 的，不允许扩展，因此我们需要在类声明前添加 *open* 关键字来打开它们。所以我们的超类
    A 看起来是这样的：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, we can extend our class B, as follows:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以按照以下方式扩展我们的类 B：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, suppose our class A has a primary constructor that takes in a `String`
    variable, such as this:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，假设我们的类 A 有一个接受 `String` 变量的主构造函数，如下所示：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, if we wish to extend B with A, there are two ways to do so:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想用 A 扩展 B，有两种方法可以实现：
- en: 'Initialize A in B''s primary constructor. In this approach, we will initialize
    A by passing arguments from B''s primary constructor. Consider this example:'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 B 的主构造函数中初始化 A。在这种方法中，我们将通过从 B 的主构造函数传递参数来初始化 A。考虑以下示例：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If B, or any class, doesn''t have a primary constructor, then each secondary
    class of the extending class needs to initialize the superclass using the `super`
    keyword. Consider the given example:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 B 或任何类没有主构造函数，那么扩展类的每个次级类都需要使用 `super` 关键字来初始化超类。考虑以下示例：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We generally extend a class to import the functionalities from a superclass
    and sometimes, we might also like to override them to have our own implementation.
    Similar to classes, methods are also closed by default, and we need to "open"
    them with the open modifier:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通常通过扩展一个类来导入超类的功能，有时我们可能还想覆盖它们以实现自己的版本。与类类似，方法默认也是封闭的，我们需要使用 open 修饰符来“打开”它们：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can also mark a method "final" to prevent any other subclass from overriding
    it. Take this example into consideration:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以将一个方法标记为“final”，以防止任何其他子类覆盖它。考虑以下示例：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you extend your class with an abstract class, you need to implement all
    the methods defined as abstract in the abstract class. Note that you don''t need
    to mark them open in order for them to be overridden by the extending class. Making
    them abstract does the job itself, as shown in this example:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你用一个抽象类扩展你的类，你需要实现抽象类中定义的所有抽象方法。请注意，你不需要将它们标记为公开，以便扩展类可以覆盖它们。将它们设置为抽象本身就完成了这项工作，如下例所示：
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Extension functions
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展函数
- en: '**Extension functions** are useful, as they allow us to extend the functionality
    of a class without actually touching it. For example, if you''ve used Glide or
    Picasso library for placing an image inside the `Imageview`, you must be familiar
    with the following code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**扩展函数**很有用，因为它们允许我们扩展类的功能，而不必实际修改它。例如，如果你使用 Glide 或 Picasso 库在 `Imageview`
    中放置图像，你一定熟悉以下代码：'
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can make this look much better using an extension function. Let''s call
    the `loadImage(imageUrl)` function on `imageView`. If you do it, you will see
    an error—Unresolved reference- loadImage:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用扩展函数使这个看起来更好。让我们在 `imageView` 上调用 `loadImage(imageUrl)` 函数。如果你这样做，你会看到一个错误——未解析的引用-
    loadImage：
- en: '![](img/e3ed60f9-8df2-4d3b-a1d5-b7bdd7467c4c.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e3ed60f9-8df2-4d3b-a1d5-b7bdd7467c4c.png)'
- en: 'You will also see two suggestions, one of which is Create extension function:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会看到两个建议，其中一个就是创建扩展函数：
- en: '![](img/b442b29a-96fb-4153-9db2-6ba84378122f.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b442b29a-96fb-4153-9db2-6ba84378122f.png)'
- en: 'If you click on Create extension function, you''ll be provided with some choices,
    as in the this screenshot:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击创建扩展函数，你会得到一些选择，就像这个截图所示：
- en: '![](img/3066a626-c699-4ad2-b9c5-cdc6f9c24305.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3066a626-c699-4ad2-b9c5-cdc6f9c24305.png)'
- en: Click on ImageView, because we want to create an extension function on it.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 ImageView，因为我们想在它上面创建一个扩展函数。
- en: 'When you click on it, an extension function is created in the same file, which
    looks like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击它时，在同一文件中创建了一个扩展函数，看起来像这样：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here, we can place our Glide/Picasso code for image loading:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以放置我们的 Glide/Picasso 图像加载代码：
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: So, even if the `loadImage` function was not present in the `ImageView` class,
    we were able to extend it and use it as if this function was part of `ImageView`,
    and we didn't even have to touch the `ImageView` class. The extension function
    extended the functionality of `ImageView` externally.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，即使 `loadImage` 函数不在 `ImageView` 类中，我们也能扩展它，并像这个函数是 `ImageView` 的一部分一样使用它，而且我们甚至不需要修改
    `ImageView` 类。扩展函数从外部扩展了 `ImageView` 的功能。
- en: How it works…
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The prefix to the extension function (the name that comes before the dot) is
    called **receiver** **type**, that is, the type being extended. This receiver
    object is accessed inside the function using the `this` keyword. The extension
    functions are resolved statically; it's like calling a static method. Since this
    is a static method, it's not needed to be defined under the class, but since it's
    a static method, it's hard to test. For example, Mockito (a testing framework)
    cannot test static methods, so to produce great code quality, use extension function
    only if that function doesn't require any testing.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展函数的前缀（点号前的名称）被称为**接收器类型**，即被扩展的类型。这个接收器对象在函数内部使用 `this` 关键字访问。扩展函数是静态解析的；就像调用一个静态方法。由于这是一个静态方法，它不需要在类下定义，但由于它是静态方法，很难进行测试。例如，Mockito（一个测试框架）无法测试静态方法，所以为了产生高质量的代码，只有当该函数不需要任何测试时才使用扩展函数。
- en: There's more…
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'What happens when you create an extension function with a name similar to that
    of a member function? For example, in the following code, what will happen if
    we call `c.foo()`?:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个与成员函数名称相似的扩展函数时会发生什么？例如，在以下代码中，如果我们调用 `c.foo()`，会发生什么？
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is the output we get:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的输出结果：
- en: '[PRE29]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: So a member function will win if an extension function with the same name is
    called.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果调用具有相同名称的扩展函数，成员函数将获胜。
- en: How to work with Generics in Kotlin
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何在 Kotlin 中使用泛型
- en: Generic methods and classes help us use the same method or class for various
    types. This improves code reusability. In this recipe, we will understand Generics
    and how to use it in Kotlin. Generics in Kotlin is quite similar to Generics in
    Java, but there are additional special keywords in Kotlin that make Generics in
    Kotlin more intuitive. Let's dive in.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型方法和类帮助我们使用相同的方法或类来处理各种类型。这提高了代码的可重用性。在这个菜谱中，我们将了解泛型以及如何在 Kotlin 中使用它。Kotlin
    中的泛型与 Java 中的泛型非常相似，但 Kotlin 中有额外的特殊关键字，这使得 Kotlin 中的泛型更加直观。让我们深入探讨。
- en: Getting ready
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to install a preferred development environment that compiles and runs
    Kotlin. You can also use the command line for the purpose, for which you need
    a Kotlin compiler installed along with JDK. I am using IntelliJ IDE to compile
    and run my Kotlin code for this recipe.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装一个首选的开发环境，该环境可以编译和运行 Kotlin。您也可以使用命令行，为此您需要安装 Kotlin 编译器和 JDK。我使用 IntelliJ
    IDE 来编译和运行我的 Kotlin 代码，以完成这个菜谱。
- en: How to do it…
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Now, let''s follow these steps to understand how Generics works in Kotlin,
    with the help of some examples:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们按照以下步骤，通过一些示例来了解 Kotlin 中泛型的工作原理：
- en: 'Let''s start with a generic class that we can instantiate using any type of
    parameter:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从可以接受任何类型参数的通用类开始：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output of this program is this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的输出如下：
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can also restrict what types are allowed in our generic class like this:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也可以像这样限制在通用类中允许的类型：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If we try to use the preceding class with a type that is not a `Number`, for
    example, a `String`, we get the following error:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们尝试使用前面的类与不是 `Number` 类型的类型，例如 `String`，我们会得到以下错误：
- en: '[PRE33]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, let''s try an example of a generic method:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试一个泛型方法的示例：
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The output of the preceding code will be as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出将如下所示：
- en: '[PRE35]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: There's more…
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Generic types in Java are invariant, which means `List<String>` is not a subtype
    of `List<Object>`. Java has this so that we are not able to add, say, a `Float`
    to a `List` that contains `String` and has the type as `Object`. In Kotlin, we
    have a better solution where we use the wildcard argument as  `? extends E`, which
    denotes that the method accepts a subtype of E or collection of E and not just
    E itself. This gives us the power to read from a collection of E but not write
    to it, as we do not know what items are accepted. This makes Kotlin covariant.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Java 中的泛型类型是不变的，这意味着 `List<String>` 不是 `List<Object>` 的子类型。Java 有这样的设计，以便我们无法向包含
    `String` 且类型为 `Object` 的 `List` 中添加，比如说，一个 `Float`。在 Kotlin 中，我们有一个更好的解决方案，即使用通配符参数
    `? extends E`，它表示该方法接受 E 的子类型或 E 的集合，而不仅仅是 E 本身。这使我们能够从 E 的集合中读取，但不能写入，因为我们不知道可以接受哪些项。这使得
    Kotlin 具有协变性。
- en: How to implement polymorphism in Kotlin
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何在 Kotlin 中实现多态
- en: '**Polymorphism** is the ability of an object to take many forms, depending
    on the situation. Kotlin supports two types of polymorphism: **compile-time polymorphism**
    and **run-time polymorphism**. In this recipe, we will try both. Let''s get started.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**多态**是对象根据情况采取多种形式的能力。Kotlin 支持两种类型的多态：**编译时多态**和**运行时多态**。在这个菜谱中，我们将尝试两者。让我们开始吧。'
- en: Getting ready
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to install a preferred development environment that compiles and runs
    Kotlin. You can also use the command line for the purpose, for which you need
    a Kotlin compiler installed along with JDK. I am using IntelliJ IDE to compile
    and run my Kotlin code for this recipe.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装一个首选的开发环境，该环境可以编译和运行 Kotlin。您也可以使用命令行，为此您需要安装 Kotlin 编译器和 JDK。我使用 IntelliJ
    IDE 来编译和运行我的 Kotlin 代码，以完成这个菜谱。
- en: How to do it…
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In the following steps, we will learn how to use polymorphism in Kotlin:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下步骤中，我们将学习如何在 Kotlin 中使用多态：
- en: 'Let''s start with compile-time polymorphism. In **compile-time polymorphism**,
    the name functions, that is, the signature remains the same but parameters or
    return type is different. At compile time, the compiler then resolves which functions
    we are trying to call based on the type of parameters and more. Check out this
    example:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从编译时多态开始。在**编译时多态**中，函数名，即签名保持不变，但参数或返回类型不同。在编译时，编译器根据参数类型等确定我们试图调用的函数。查看以下示例：
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here''s the output of the preceding code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这是上述代码的输出：
- en: '[PRE37]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, let''s talk about run-time polymorphism. In **run-time polymorphism**,
    the compiler resolves a call to overridden/overloaded methods at runtime. We can
    achieve run-time polymorphism using method overriding. Let''s try an example where
    we extend a superclass and override one of its member methods:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们谈谈运行时多态。在**运行时多态**中，编译器在运行时解析对重写/重载方法的调用。我们可以通过方法重写来实现运行时多态。让我们尝试一个扩展超类并重写其成员方法的示例：
- en: '[PRE38]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output of the preceding code is this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE39]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, the compiler resolves, at run-time, which method to execute.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，编译器在运行时确定要执行哪个方法。
- en: Restricting class hierarchies
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制类层次结构
- en: In this recipe, we will learn how to restrict the class hierarchies in Kotlin.
    Before we move ahead, let's understand why this is a cause worth spending our
    time on.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何在Kotlin中限制类层次结构。在我们继续之前，让我们了解为什么这是一个值得花费时间的原因。
- en: Getting ready
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: I'll be using Android Studio to run the code described in this recipe.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用Android Studio来运行本食谱中描述的代码。
- en: How to do it…
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'When we are sure that a value or a class can have only a limited set of types
    or number of subclasses, that''s when we try to restrict class hierarchy. Yes,
    this might sound like an enum class but, actually, it''s much more than that.
    Enum constant exists only as a single instance, whereas a subclass of a sealed
    class can have multiple instances that can contain state. Let''s look at an example
    in the mentioned steps:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们确定一个值或类只能具有有限的一组类型或子类数量时，那就是我们尝试限制类层次结构的时候。是的，这听起来可能像枚举类，但实际上，它远不止于此。枚举常量仅作为单个实例存在，而密封类的子类可以有多个实例，这些实例可以包含状态。让我们看看以下步骤中的示例：
- en: 'We will create a **sealed** class named `ToastOperation`. Under the same source
    file, we will define a `ShowMessageToast` subclass:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个名为`ToastOperation`的**密封**类。在同一个源文件中，我们将定义一个`ShowMessageToast`子类：
- en: '[PRE40]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Also, we''ll define a `ShowErrorToast` object:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们将定义一个`ShowErrorToast`对象：
- en: '[PRE41]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As you may have noted, I have defined an **object** rather than a full class
    declaration, because the `ShowErrorToast` **object** doesn't have any state. Also,
    by doing so, we have removed *is* from the *when* block, since there is just one
    instance.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所注意到的，我定义了一个**对象**而不是完整的类声明，因为`ShowErrorToast`**对象**没有任何状态。此外，通过这样做，我们已从`when`块中移除了`is`，因为只有一个实例。
- en: 'Now, we can use it in a `when` statement, as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在`when`语句中使用它，如下所示：
- en: '[PRE42]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The key benefit is that we don't need to implement the `else` block, which acted
    as the default block when the other statements didn't fit the bill.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关键好处是，我们不需要实现`else`块，当其他语句不符合要求时，它充当默认块。
- en: According to documentation, a `sealed` class can have subclasses, but all of
    them must be declared in the same file as the sealed class itself. However, the
    subclasses of subclasses need not be defined in the same file. It is abstract
    by itself, and you cannot instantiate objects from it.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 根据文档，一个**密封**类可以有子类，但所有这些子类都必须与密封类本身在同一个文件中声明。然而，子类的子类不需要在同一个文件中定义。它本身是抽象的，您不能从它实例化对象。
- en: 'Here''s our structure of `sealed` classes:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的密封类结构：
- en: '[PRE43]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As you can see, we've kept all the subclasses under the same source file in
    which we have defined the **sealed** class.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们将所有子类都放在定义了密封类的同一个源文件中。
- en: How it works…
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the preceding example, we were sure that we can only have two types of toasts:
    an error toast and a toast with a custom message. So we created a **sealed** class
    `ToastOperation` and created two subclasses of `ToastOperation`. Note that if
    we aren''t sure of types of subclasses, we will not use a **sealed** class, in
    that case, an **enum** class might be better suited.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们确信我们只能有两种类型的吐司：错误吐司和自定义消息的吐司。因此，我们创建了一个**密封**类`ToastOperation`，并创建了`ToastOperation`的两个子类。请注意，如果我们不确定子类的类型，我们不会使用**密封**类；在这种情况下，**枚举**类可能更适合。
- en: There's more…
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If you are using Kotlin versions prior to 1.1, you''ll need to implement the subclasses
    inside the sealed class, much like this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是Kotlin 1.1之前的版本，您需要在密封类内部实现子类，就像这样：
- en: '[PRE44]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note that you can use the preceding way in the new version of Kotlin as well.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您也可以在新版本的Kotlin中使用前面提到的方法。
