- en: Chapter 7. Advanced Content Creation for Urban Warrior
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。城市战士的高级内容创建
- en: With our game level finished from the previous chapter, we now have a level
    that has been playtested and we know that it is quite fun. Now that we have a
    great base to build on we can create our own content for our game to customize
    it and make the game really your own.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于我们上一章完成的游戏关卡，我们现在有一个经过测试的关卡，我们知道它非常有趣。现在我们有一个很好的基础可以在此基础上构建，我们可以为我们的游戏创建自己的内容，以定制它并使游戏真正属于你自己。
- en: 'In this chapter we shall discuss the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下内容：
- en: Creating a main menu for our game with input
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的游戏创建带有输入的主菜单
- en: Adding audio on mobile UDK for our game
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在移动UDK上为我们的游戏添加音频
- en: Importing custom textures to our game
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将自定义纹理导入我们的游戏
- en: Creating materials for both PC and iOS to use
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为PC和iOS创建材料
- en: Adding static meshes on mobile UDK for our game
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在移动UDK上为我们的游戏添加静态网格
- en: Some tips for optimization and debugging on the iOS
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于iOS优化和调试的一些技巧
- en: The assets that I will be bringing into the game in this level will be available
    on the Packt Publishing website, but with the information contained in this chapter
    it should be fairly easy to create assets of your own that you can bring into
    the game. With that being said, let's begin!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在本关卡中带入游戏中的资源将在Packt Publishing网站上提供，但根据本章提供的信息，应该相当容易创建你自己的资源并将其带入游戏。话虽如此，让我们开始吧！
- en: Tip
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从你购买的所有Packt书籍的账户中下载示例代码文件。[http://www.packtpub.com](http://www.packtpub.com)。如果你在其他地方购买了这本书，你可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册以直接将文件通过电子邮件发送给你。
- en: Main menu environment creation
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主菜单环境创建
- en: As nice as dropping right in the action of a game is, most games have a menu
    of some sort. This will also be a nice way of showing you how we can use aspects
    that we have already covered before doing something different.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然直接进入游戏动作很方便，但大多数游戏都有某种类型的菜单。这也会是一个很好的方式来展示我们如何在做一些不同的事情之前使用我们已经覆盖过的方面。
- en: Time for action—building main menu backdrop
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建主菜单背景的时间
- en: 'Sure, most menus in a game look like they''re something special, but in reality
    they are just a new level. To build the main menu backdrop perform the following
    steps:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，大多数游戏中的菜单看起来像是有特殊的东西，但实际上它们只是一个新关卡。要构建主菜单背景，请执行以下步骤：
- en: 'First, let''s open up the map that we previously used in [Chapter 3](ch03.html
    "Chapter 3. Taking It to the Next Level: Enriching with Content"), *Taking It
    to the Next Level; Enriching with Content*. Select the skydome and the two directional
    lights we created and copy them by pressing *Ctrl+C*, this is shown in the following
    screenshot:![Time for action—building main menu backdrop](img/1901_07_01.jpg)'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们打开之前在[第3章](ch03.html "第3章。提升至新水平：内容丰富")中使用的地图，“提升至新水平；内容丰富”。选择天空穹顶和创建的两个方向光源，通过按*Ctrl+C*复制它们，这在上面的截图中有展示：![构建主菜单背景的时间](img/1901_07_01.jpg)
- en: Create a new level by selecting **File** | **New..**. and select the **Blank
    Map** template. Paste the objects into your level.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择**文件** | **新建..**并选择**空白地图**模板来创建一个新的关卡。将对象粘贴到你的关卡中。
- en: Right-click on the **Cube** icon on the left-hand side toolbar directly underneath
    the **Brushes** text. In the settings for the builder brush check the **Hollow**
    option. This will create a hollow cube. Click on the **Build** button and then
    add the geometry to our level by clicking on the **CSG_Add** option that we used
    in [Chapter 2](ch02.html "Chapter 2. Beginning Urban Warrior, a Third-person Shooter"),
    *Beginning Urban Warrior; A First Person Shooter* or by using *Ctrl+A*.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击左侧工具栏中**刷子**文本直接下方的**立方体**图标。在构建刷子的设置中勾选**空心**选项。这将创建一个空心立方体。点击**构建**按钮，然后通过点击我们之前在[第2章](ch02.html
    "第2章。开始城市战士，第三人称射击游戏")中使用的**CSG_Add**选项或使用*Ctrl+A*将几何体添加到我们的关卡中。
- en: Move the camera inside of the box and create a **Player Start** actor by right-clicking
    and selecting **New Actor** | **New Player Start**. If the object has a red **X**
    on it move the object until it has plenty of space on all sides in order to spawn
    the player there:![Time for action—building main menu backdrop](img/1901_07_02.jpg)
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将相机移入盒子内部，通过右键单击并选择 **新建角色** | **新建玩家开始** 来创建一个 **玩家开始** 角色对象。如果对象上有红色 **X**，则移动对象，直到其四周都有足够的空间，以便在那里生成玩家：![动手实践——构建主菜单背景](img/1901_07_02.jpg)
- en: Access the **WorldInfo Properties** by going to the top menu and selecting **View**
    | **World Properties**. In the **Game Type** section set the **Default Game Type**
    and **Game Type** for PIE to **MobileMenuGame**.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过访问顶部菜单并选择 **查看** | **世界属性** 来访问 **WorldInfo 属性**。在 **游戏类型** 部分设置 **默认游戏类型**
    和 PIE 的 **游戏类型** 为 **MobileMenuGame**。
- en: By either copying and pasting from the actual game level or finding `StaticMesh'LT_Mech.SM.Mesh.S_LT_Mech_SM_CityNoRing01`
    inside the Content Borwser, place two of the objects into your game world in such
    a way that they have buildings in all angles.![Time for action—building main menu
    backdrop](img/1901_07_03.jpg)
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从实际游戏关卡复制粘贴或在内置浏览器中找到 `StaticMesh'LT_Mech.SM.Mesh.S_LT_Mech_SM_CityNoRing01`，以使它们在所有角度都有建筑物的样子，将两个对象放置到你的游戏世界中：![动手实践——构建主菜单背景](img/1901_07_03.jpg)
- en: Go to the **Actor Classes** tab by selecting **View** | **Browser Windows**
    | **Actor Classes**. Select the **CameraActor** found in **Common** | **CameraActor**
    and exit the building. Create a camera by right-clicking and selecting **Add Camera
    Actor Here**. Position the camera in the middle of your area, tilted slightly
    to the sky. In particular you want to make sure that you cannot see the hollow
    box we created earlier. If it's easier for you to move it out of the way, feel
    free to do that.![Time for action—building main menu backdrop](img/1901_07_04.jpg)
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择 **查看** | **浏览器窗口** | **角色类** 来访问 **角色类** 选项卡。选择在 **通用** | **CameraActor**
    中找到的 **CameraActor** 并退出建筑。通过右键单击并选择 **在此处添加相机角色** 来创建一个相机。将相机放置在区域中间，略微倾斜朝向天空。特别是要确保你看不到我们之前创建的空心盒子。如果你更容易将其移开，请随意操作。![动手实践——构建主菜单背景](img/1901_07_04.jpg)
- en: Press *F4* in order to access the Camera Actor's properties. In the **Movement**
    section change the **Physics** property to **PHYS_Rotating**. Select the **Yaw**
    section of the **Rotation Rate** and set it to `20`. This special type of physics
    will move the actor along the rotation rate but will not be able to do anything
    else. This would be great for our main menu as we just want a nice background
    effect to show up. This is how the Camera Actor's property window will look:![Time
    for action—building main menu backdrop](img/1901_07_05.jpg)
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下 *F4* 以访问相机角色的属性。在 **运动** 部分将 **物理** 属性更改为 **PHYS_Rotating**。选择 **旋转速率** 的
    **偏航** 部分，并将其设置为 `20`。这种特殊的物理类型将使角色沿着旋转速率移动，但无法执行其他操作。这对于我们的主菜单来说会很棒，因为我们只想有一个漂亮的背景效果出现。这就是相机角色属性窗口的显示方式：![动手实践——构建主菜单背景](img/1901_07_05.jpg)
- en: With our level created and our **CameraActor** selected let's go into Kismet.
    Create a **Level Loaded Event** (New **Event** | **Level Loaded)**. To its right-hand
    side create a new Matinee by right-clicking and selecting **New Matinee**. Connect
    the **Loaded** and **Visible** output of the **Level Loaded** event to the **Play**
    action of the **Matinee** and double-click on the **Matinee** to enter the Matinee
    editor.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的关卡创建完毕且已选择 **CameraActor** 后，让我们进入 Kismet。创建一个 **关卡加载事件**（新建 **事件** | **关卡加载**）。在其右侧创建一个新的
    Matinee，通过右键单击并选择 **新建 Matinee**。将 **关卡加载** 事件的 **已加载** 和 **可见** 输出连接到 **Matinee**
    的 **播放** 动作，并双击 **Matinee** 进入 Matinee 编辑器。
- en: Create a camera track with the name `Turning Camera` by right-clicking and selecting
    **Add New Camera Group**. Then create a new **Director Group** by right-clicking
    and selecting **Add New Director Group**. Add a **Keyframe** at the beginning
    of the Matinee sequence and select **Turning Camera** at the **Cut To Group**
    option that comes up. Close the Matinee editor.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键单击并选择 **添加新相机组** 来创建一个名为 `Turning Camera` 的相机轨迹。然后通过右键单击并选择 **添加新导演组** 来创建一个新的
    **导演组**。在 Matinee 序列的开始处添加一个 **关键帧**，并在出现的 **切到组** 选项中选择 **Turning Camera**。关闭
    Matinee 编辑器。
- en: Back in Kismet select the Matinee object and make sure that the **Looping**
    option is checked. Exit Kismet.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Kismet 中返回，选择 Matinee 对象并确保已勾选 **循环** 选项。退出 Kismet。
- en: Create a **Lightmass Importance Volume** to cover the area around the player
    including the buildings. Also make sure that the lights are not inside any of
    the buildings, move them if you need to.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个**光子重要性体积**来覆盖玩家周围的区域，包括建筑物。同时确保灯光不在任何建筑物内部，如果需要，请移动它们。
- en: Build our game by selecting **Build** | **Build All** and clicking on **Close**
    when finished.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择**构建** | **构建全部**来构建我们的游戏，完成后点击**关闭**。
- en: Save your project and start your game by clicking on the **Start Mobile Previewer**
    button. This is how your screen should look:![Time for action—building main menu
    backdrop](img/1901_07_06.jpg)
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**开始移动预览器**按钮保存您的项目并开始游戏。您的屏幕应该看起来像这样：![动手实践——构建主菜单背景](img/1901_07_06.jpg)
- en: What just happened?
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We now see a nice cityscape as our camera pans around at a constant rate. This
    will be a nice looking background for our title screen, and with this as a basis
    we can build our main menu.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看到城市景观，随着摄像机以恒定速度移动。这将是我们标题屏幕的一个很好的背景，以此为基础，我们可以构建我们的主菜单。
- en: Importing textures
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入纹理
- en: A mobile graphics hardware works with different formats and handles textures
    differently than a normal PC graphics hardware. By taking the necessary precautions
    and creating textures accordingly, many obstacles can be avoided. Now, I'm by
    no means an art expert but I'll briefly go over some things that you should abide
    by if you do decide to do your own textures for iOS.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 移动图形硬件与不同的格式一起工作，并且与普通PC图形硬件处理纹理的方式不同。通过采取必要的预防措施并相应地创建纹理，可以避免许多障碍。现在，我绝不是艺术专家，但我会简要介绍一些如果你决定为iOS自己制作纹理时应该遵守的事情。
- en: When creating your own textures it is important to make the size of the image
    in powers of two such as 256, 512, 1024, and 2048\. Computers process data in
    "chunks" for purposes of efficiency. For game content creation, on devices mobile
    especially, if a texture is not in a power of two Unreal will waste resources
    both in terms of time and processing power in order fix the problem. In effect
    the essence of the power of two rule is optimization, being as efficient and as
    "lite" as possible while providing the user an appropriate visual experience.
    When working with iOS, hardware textures can have a size of up to 2048 by 2048
    but use them sparingly. This is particularly important in the case of games targeting
    lower end devices (such as iPhone 3GS, iPad 1, and iPod touch 4th generation)
    that only have 256 MB of RAM.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建自己的纹理时，重要的是使图像的大小为2的幂，例如256、512、1024和2048。计算机为了效率的目的以“块”处理数据。在游戏内容创建中，尤其是在移动设备上，如果纹理不是2的幂，Unreal将会浪费时间和处理资源来修复这个问题。实际上，2的幂规则的本质是优化，尽可能高效和“轻量”，同时为用户提供适当的视觉体验。当与iOS一起工作时，硬件纹理的大小可以达到2048
    x 2048，但请谨慎使用。这对于针对低端设备（如iPhone 3GS、iPad 1和iPod touch第4代）的游戏尤其重要，这些设备只有256MB的RAM。
- en: 'The following texture formats are supported: `.bmp, .pcx, .png, .tga, .float`
    and `.psd`.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 支持以下纹理格式：`.bmp, .pcx, .png, .tga, .float`和`.psd`。
- en: Time for action—finishing the main menu
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手实践——完成主菜单
- en: 'That being said, let''s import our first texture into the game:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们将第一个纹理导入到游戏中：
- en: Open up the **Content Browser** by either selecting its icon or going to the
    **View** menu and selecting **View** | **Browser Windows** | **Content Browser**.
    Click on the **Import** button in the menu at the bottom of the window. Find the
    image that you would like to bring into the game and select **Open**:![Time for
    action—finishing the main menu](img/1901_07_07.jpg)
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择其图标或转到**视图**菜单并选择**视图** | **浏览器窗口** | **内容浏览器**来打开**内容浏览器**。在窗口底部的菜单中点击**导入**按钮。找到您想要导入到游戏中的图像并选择**打开**：![动手实践——完成主菜单](img/1901_07_07.jpg)
- en: There will be an import dialog that will come up. In the **Packages** section
    type the name `UW-MainMenuPKG` and confirm that `logo` is in the **Name** section.
    You should be brought back to the **Content Browser** where you will see our new
    package with one new file:![Time for action—finishing the main menu](img/1901_07_08.jpg)
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将出现一个导入对话框。在**包**部分输入名称`UW-MainMenuPKG`并确认`logo`在**名称**部分。你应该会回到**内容浏览器**，在那里你会看到我们的新包，包含一个新文件：![动手实践——完成主菜单](img/1901_07_08.jpg)
- en: Underneath the **New Packages** option in the **Packages** section on the left-hand
    side toolbar, right-click on the package that we just created and select **Save**
    to save the package as a file. It is important to save things often to make sure
    you don't lose your work:![Time for action—finishing the main menu](img/1901_07_09.jpg)
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧工具栏的**包**部分下方的**新包**选项中，右键点击我们刚刚创建的包，并选择**保存**以将包保存为文件。经常保存东西是很重要的，以确保你不会丢失你的工作：![完成主菜单的时间——动作时间](img/1901_07_09.jpg)
- en: 'Close the **Content Browser** and go back into Kismet. Create a **Draw Image
    event** by right-clicking and selecting **New Event** | **HUD** | **Draw Image**.
    In the properties for it select the **Display Color** as white. In the **Display
    Location** section set the **X** value to `.25`. Set the **XL** and **YL** to
    `0.5` and **UL** and **VL** to `512`. It is important to note that this Kismet
    event doesn''t give you the option to do proper scaling for aspect ratio differences
    so more complex logos may be squished, so play with the values until you find
    what works for you. Check the **Is Active** checkbox and change the **Authorized
    Global Scale** to `1.0`. Go to the **Content Browser** and left-click on our logo
    image. In the **Draw Image** properties click on the green arrow next to the **Display
    Texture** option in order to set our logo image in the world. Place a Player 0
    variable underneath the Target by right clicking and selecting **New Variable**
    | **Player** | **Player**. Inside the **Player** variable uncheck the **All Players**
    checkbox in its properties. A few of the changes we made are seen in the following
    screenshot:'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关闭**内容浏览器**并返回到Kismet。通过右键点击并选择**新事件** | **HUD** | **绘制图像**来创建一个**绘制图像事件**。在其属性中，选择**显示颜色**为白色。在**显示位置**部分，将**X**值设置为`.25`。将**XL**和**YL**设置为`0.5`，将**UL**和**VL**设置为`512`。需要注意的是，这个Kismet事件没有提供进行适当缩放以适应不同宽高比选项，因此更复杂的标志可能会被压扁，所以请调整这些值直到找到适合你的设置。勾选**是否激活**复选框，并将**授权全局缩放**更改为`1.0`。转到**内容浏览器**，左键点击我们的标志图像。在**绘制图像**属性中，点击**显示纹理**选项旁边的绿色箭头，以便在世界上设置我们的标志图像。通过右键点击并在**目标**下方选择**新变量**
    | **玩家** | **玩家**来放置一个Player 0变量。在**玩家**变量中，取消勾选其属性中的**所有玩家**复选框。以下截图显示了我们所做的几个更改：
- en: '![Time for action—finishing the main menu](img/1901_07_10.jpg)'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![完成主菜单的时间——动作时间](img/1901_07_10.jpg)'
- en: Save your project and start your game by clicking on the **Start Mobile Previewer**
    button. This is how the preview would look:![Time for action—finishing the main
    menu](img/1901_07_11.jpg)
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**开始移动预览器**按钮保存你的项目并开始游戏。这就是预览将看起来像什么：![完成主菜单的时间——动作时间](img/1901_07_11.jpg)
- en: We now have a title that follows us when we start the game, but as of right
    now nothing happens and there's no way to start the game properly. What we're
    going to do next is place some text that says "**Tap anywhere to begin**" in the
    middle of the screen and then create a button which when tapped will open our
    main game level. Knowing what we plan on doing, let's do that now!
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们有一个在游戏开始时跟随我们的标题，但到目前为止，没有任何动作发生，也没有正确开始游戏的方法。接下来我们要做的是在屏幕中间放置一些文字，上面写着“**点击任何地方开始**”，然后创建一个按钮，点击后可以打开我们的主游戏关卡。了解我们的计划后，我们现在就来做这件事！
- en: Open up the **Content Browser** by going to the **View** menu and selecting
    **View** | **Browser Windows** | **Content Browser**. In the **Object Type** section
    change the tab from **Favorites** to **All Types** and check **Fonts**. In the
    search bar type `36` and left-click on the font on the bottom which specifically
    is `Font'UI_Fonts.Fonts.UI_Fonts_Positec36'`. With it selected, open up Kismet.![Time
    for action—finishing the main menu](img/1901_07_12.jpg)
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到**视图**菜单并选择**视图** | **浏览器窗口** | **内容浏览器**来打开**内容浏览器**。在**对象类型**部分，将选项卡从**收藏夹**更改为**所有类型**，并勾选**字体**。在搜索栏中输入`36`，并左键点击底部特定的字体，即`Font'UI_Fonts.Fonts.UI_Fonts_Positec36'`。选择它后，打开Kismet。![完成主菜单的时间——动作时间](img/1901_07_12.jpg)
- en: Go back to Kismet and create a **Show Text** event by right-clicking next to
    the **Draw Image** event and selecting **New Event** | **HUD** | **Draw Text**.
    In the **Properties** section click on the green arrow next to **Display Font**
    to set the font we are going to use. Change the **Display Color** to white. On
    the **Display Location** put **X** as `.5`, **Y** as `.75` to be directly below
    our image and **Z** to `0`. In the **Display Text** section type `Tap anywhere
    to begin!`. Change the **Text Draw Method** to **DRAW_CenterText** and check the
    **Is Active** checkbox . Change the **Authorized Global Scale** to `1.0`. Underneath
    the **Target** place a Player 0 variable by right-clicking and selecting **New
    Variable** | **Player** | **Player** and uncheck the **All Players** checkbox
    in its properties. A few of the changes we made are seen in the following screenshot:![Time
    for action—finishing the main menu](img/1901_07_13.jpg)
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 Kismet，通过在 **Draw Image** 事件旁边右键单击并选择 **New Event** | **HUD** | **Draw Text**
    来创建一个 **Show Text** 事件。在 **Properties** 部分点击 **Display Font** 旁边的绿色箭头来设置我们将要使用的字体。将
    **Display Color** 改为白色。在 **Display Location** 中将 **X** 设置为 `.5`，**Y** 设置为 `.75`
    以直接位于我们的图像下方，**Z** 设置为 `0`。在 **Display Text** 部分键入 `Tap anywhere to begin!`。将
    **Text Draw Method** 改为 **DRAW_CenterText** 并勾选 **Is Active** 复选框。将 **Authorized
    Global Scale** 改为 `1.0`。在 **Target** 下方通过右键单击并选择 **New Variable** | **Player**
    | **Player** 来放置一个 Player 0 变量，并在其属性中取消勾选 **All Players** 复选框。我们所做的几个更改在以下屏幕截图中可见：![Time
    for action—finishing the main menu](img/1901_07_13.jpg)
- en: Create a bool variable underneath the **Active** section on the **Draw Text
    Event** by right-clicking on the square under the word and selecting **Create
    New Bool Variable**. Move the Matinee Sequence we just created in the **Level
    Loaded** event by selecting it and its associated object, and hold the *Ctrl*
    key to move it by dragging your left mouse button. To the right of the **Level
    Loaded** event create a new **Toggle** action by right-clicking and selecting
    **New Action** | **Toggle** | **Toggle**. Connect the **Loaded and Visible** output
    to the **Toggle** input of **Toggle**. Connect the **Bool** input of **Toggle**
    to the bool on our **Draw Text** action. Connect the **Out** from the **Toggle**
    event to the **Toggle** input of it and right click on the **Out** output and
    click on **Set Activate Delay** and give it a value of `0.1` as shown in the following
    screenshot:![Time for action—finishing the main menu](img/1901_07_14.jpg)
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Draw Text Event** 的 **Active** 部分下方创建一个布尔变量，通过在单词下方的方块上右键单击并选择 **Create
    New Bool Variable** 来实现。通过选择它及其相关对象，并按住 *Ctrl* 键拖动鼠标左键来移动我们刚刚创建的 Matinee Sequence
    到 **Level Loaded** 事件中。在 **Level Loaded** 事件右侧通过右键单击并选择 **New Action** | **Toggle**
    | **Toggle** 来创建一个新的 **Toggle** 动作。将 **Loaded and Visible** 输出连接到 **Toggle** 的
    **Toggle** 输入。将 **Toggle** 的 **Bool** 输入连接到我们的 **Draw Text** 动作的布尔值。将 **Toggle**
    事件的 **Out** 连接到其 **Toggle** 输入，并在 **Out** 输出上右键单击，然后点击 **Set Activate Delay**
    并将其值设置为 `0.1`，如以下屏幕截图所示：![Time for action—finishing the main menu](img/1901_07_14.jpg)
- en: Now that we have the blinking text saying to hit the button, how about we create
    a button to respond to the players touch? Remove the connection between the **Loaded
    and Visible** output of the **Level Loaded** event and the **Toggle** input of
    the **Toggle** event, move it over to the right and create an **Add Input Zone**
    action by right-clicking and selecting **New Action** | **Mobile** | **Add Input
    Zone**. Set the **Zone Name** to `StartGame`. Click on the little blue triangle
    next to the **New Zone** to create a new **MobileInputZone**. Inside the **Zone**
    you just created, in the **Bounds** section set the **Authored Global Scale**
    to `1.0` and the **Size X** and **Size Y** to `1.0` and check **Relative Size
    X** and **Relative Size Y** checkboxes, as shown in the following screenshot:![Time
    for action—finishing the main menu](img/1901_07_15.jpg)
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了闪烁的文本提示玩家点击按钮，我们为什么不创建一个可以响应玩家触摸的按钮呢？断开 **Level Loaded** 事件的 **Loaded
    and Visible** 输出与 **Toggle** 事件的 **Toggle** 输入之间的连接，将其移到右侧，并通过右键单击并选择 **New Action**
    | **Mobile** | **Add Input Zone** 来创建一个 **Add Input Zone** 动作。将 **Zone Name**
    设置为 `StartGame`。点击 **New Zone** 旁边的蓝色小三角形来创建一个新的 **MobileInputZone**。在您刚刚创建的 **Zone**
    中，在 **Bounds** 部分将 **Authored Global Scale** 设置为 `1.0`，将 **Size X** 和 **Size Y**
    设置为 `1.0`，并勾选 **Relative Size X** 和 **Relative Size Y** 复选框，如以下屏幕截图所示：![Time for
    action—finishing the main menu](img/1901_07_15.jpg)
- en: Now that we have a button created (it's invisible so you can't see it, but I
    assure you it's there) we should work on creating some sort of interaction when
    it happens.
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个按钮（它是不可见的，所以你看不到它，但我向你保证它在那里），我们应该着手创建一些当它发生时的交互。
- en: Create a **Mobile Button Access** event by right-clicking and selecting **New
    Event** | **Input** | **Mobile Button Access**. Inside the properties under **Seq
    Event Mobile Zone Base** in the **Target Zone Name** put the zone we created earlier,
    `StartGame`. In the **Sequence Event** section change the **Re Trigger Delay**
    to `1.0`. In the **Sequence Object** properties under **Obj Comment** type `Pressed`
    and then the check **Output Obj Comment To Screen** checkbox.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键点击并选择 **新建事件** | **输入** | **移动按钮访问** 来创建一个 **移动按钮访问** 事件。在 **目标区域名称** 下的
    **Seq Event Mobile Zone Base** 属性中，放入我们之前创建的区域，`StartGame`。在 **序列事件** 部分将 **重新触发延迟**
    改为 `1.0`。在 **序列对象** 属性下的 **Obj Comment** 中输入 `Pressed`，然后勾选 **输出对象注释到屏幕** 复选框。
- en: Inside the Unreal Editor it is not possible to open up other levels, however
    it will work in the actual game. This is just to verify that the button does indeed
    work for us.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 Unreal 编辑器内部，无法打开其他关卡，但在实际游戏中是可行的。这只是为了验证按钮确实对我们有效。
- en: Create a **Console Command** action by right-clicking and selecting **New Action**
    | **Misc** | **Console Command**. In the **Commands** section under **[0]** type
    `open levelname` where `levelname` is the name of the level you want to load.
    Create a **Player 0** variable underneath the **Target** of the **Console Command**.
    Remember that when you are ready to publish the game, remove the comments that
    you created.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键点击并选择 **新建动作** | **杂项** | **控制台命令** 来创建一个 **控制台命令** 动作。在 **[0]** 下的 **命令**
    部分输入 `open levelname`，其中 `levelname` 是你想要加载的关卡名称。在 **控制台命令** 的 **目标** 下方创建一个 **玩家
    0** 变量。记住，当你准备好发布游戏时，请移除你创建的注释。
- en: Save your project and start your game by clicking on the **Start Mobile Previewer**
    button. The preview will look like the following screenshot:![Time for action—finishing
    the main menu](img/1901_07_16.jpg)
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的项目，并点击 **开始移动预览器** 按钮来开始你的游戏。预览将类似于以下截图：![动作时间——完成主菜单](img/1901_07_16.jpg)
- en: What just happened?
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: With that, we have created a main menu such that when we tap the screen will
    go into our game level creating a professional looking start to our game.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就创建了一个主菜单，当我们点击屏幕时，会进入我们的游戏关卡，为我们的游戏创造一个专业的开始。
- en: Adding sounds
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加声音
- en: Something that many people take for granted, sound, can have a massive effect
    on people when they are playing your game. To give you a taste of how simple it
    is to add sounds to your game let's add one when we start the game.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人认为理所当然的事情，声音，当人们在玩你的游戏时，可以产生巨大的影响。为了让你体验一下将声音添加到游戏中的简单性，让我们在游戏开始时添加一个声音。
- en: However, just because it is easy to add sounds to our game, playing sounds on
    iOS devices is quite hard to do—it takes a lot of computing as an iOS device is
    only able to play one at a time; this is because sounds that are played are uncompressed.
    This is unlike music that you listen to on your computer (unless you are an audiophile)
    which is compressed in a format like MP3 which uses a compression algorithm to
    keep the size of files small. However, having uncompressed sounds makes the files
    a lot larger. Initializing multiple sounds in the same frame can cause a lot of
    performance problems. It is a good idea to not play multiple sounds at once if
    you can help it. This being said, you're going to want to make them as small as
    possible. Using 22 kHz sounds over 44 kHz sounds on iOS is an easy way to gain
    a lot of performance that would otherwise be going into processing the sound files.
    Given that the typical use case of an iOS device is either going to be over the
    bad speaker or bad headphones included with the device, you can gain a lot of
    performance for minimal sound difference.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管添加声音到我们的游戏中很简单，但在 iOS 设备上播放声音却相当困难——因为它需要大量的计算，因为 iOS 设备一次只能播放一个声音；这是因为播放的声音是不压缩的。这与你在电脑上听的音乐（除非你是音响发烧友）不同，音乐是以
    MP3 等格式压缩的，它使用压缩算法来保持文件大小小。然而，不压缩的声音使得文件变得很大。在同一个帧中初始化多个声音可能会导致很多性能问题。如果你能帮忙的话，最好不要同时播放多个声音。话虽如此，你仍然希望将它们尽可能缩小。在
    iOS 上使用 22 kHz 声音而不是 44 kHz 声音是一个简单的方法，可以获取到很多本应用于处理声音文件的性能。考虑到 iOS 设备的典型用途要么是通过设备上糟糕的扬声器，要么是通过糟糕的耳机，你可以通过最小的声音差异获得很多性能提升。
- en: Time for action—playing a sound effect
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动作时间——播放音效
- en: 'We want the player to know that we have understood him/her tapping to start
    the game. Let''s play a sound to show him/her we know. We can do this as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想让玩家知道我们已经理解了他/她点击开始游戏的行为。让我们播放一个声音来向他/她展示我们知道。我们可以这样做：
- en: Open up the **Content Browser** by either selecting its icon or going to the
    **View** menu and selecting **View** | **Browser Windows | Content Browser** .
    Click on the **Import** button in the menu at the bottom of the window. Find the
    sound that you would like to bring into the game and select **Open**. In the window
    that pops up set the package with the same name that you just created and open
    up the tab in the Options menu and check **Auto Create Cue** then click on **OK**,
    saying yes if it asks you to import the entire package.![Time for action—playing
    a sound effect](img/1901_07_17.jpg)
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择其图标或转到**视图**菜单并选择**视图** | **浏览器窗口** | **内容浏览器**来打开**内容浏览器**。在窗口底部的菜单中单击**导入**按钮。找到你想要带入游戏的声音并选择**打开**。在弹出的窗口中设置与刚刚创建的包名相同的包，并在选项菜单中打开选项卡并勾选**自动创建提示**，然后单击**确定**，如果询问你是否导入整个包，请回答是。![执行动作——播放声音效果](img/1901_07_17.jpg)
- en: Right-click on the package name on the left-hand side of the **Content Browser**
    and save our package by selecting **Save** on the menu. Left-click on the **Sound
    Cue** object and exit into Kismet.![Time for action—playing a sound effect](img/1901_07_18.jpg)
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**内容浏览器**的左侧右键单击包名，通过在菜单中选择**保存**来保存我们的包。左键单击**声音提示**对象并退出到Kismet。![执行动作——播放声音效果](img/1901_07_18.jpg)
- en: Inside Kismet disconnect the **Console Command** action that we created previously
    by holding down *Alt* and clicking on the line connecting it from the **Mobile
    Button Access** event and move it to the right by holding *Ctrl* and dragging.
    In the space available create a **Play Sound** action by right-clicking and selecting
    **New Action** | **Sound** | **Play Sound**. In the **Play Sound** action's properties
    click on the green arrow in the **Play Sound** property to set it to the sound
    we created. Connect the **Input Pressed** output from the **Mobile Button Access**
    event to the **Play** on the **Play Sound** action and the **Finished** from the
    **Play Sound** action to the **Console Command** event. Your screen should look
    like the following screenshot:![Time for action—playing a sound effect](img/1901_07_19.jpg)
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Kismet中，通过按住*Alt*并单击连接到**Mobile Button Access**事件的线条，将我们之前创建的**Console Command**动作断开连接，并按住*Ctrl*并拖动将其移动到右侧。在可用空间中，通过右键单击并选择**新建动作**
    | **声音** | **播放声音**来创建一个**播放声音**动作。在**播放声音**动作的属性中，单击**播放声音**属性中的绿色箭头将其设置为创建的声音。将**Mobile
    Button Access**事件的**Input Pressed**输出连接到**播放声音**动作的**播放**，并将**播放声音**动作的**Finished**连接到**Console
    Command**事件。你的屏幕应该看起来像以下截图：![执行动作——播放声音效果](img/1901_07_19.jpg)
- en: Save your project and start your game by clicking on the **Start Mobile Previewer**
    button.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单击**开始移动预览器**按钮保存你的项目并开始你的游戏。
- en: What just happened?
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: And now our menu creates a sound whenever we tap the screen!
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在每次我们点击屏幕时，我们的菜单都会创建一个声音！
- en: Customizing sounds
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义声音
- en: Note that the way that I'm doing sound right now doesn't take into account the
    sound's position in space. This doesn't matter since the sound is going to be
    playing directly at the player, but if you wanted to, you can edit the **SoundCue**
    by right-clicking on it in the **Content Browser** and selecting **Edit Using
    SoundCue Editor**.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我现在处理声音的方式并没有考虑到声音在空间中的位置。由于声音将直接在播放器处播放，所以这并不重要，但如果你想要的话，你可以通过在**内容浏览器**中右键单击**SoundCue**并选择**使用SoundCue编辑器编辑**来编辑**SoundCue**。
- en: The SoundCue Editor is very similar to Kismet other than the fact that the only
    event called is when it is played which is shown by an image of a Speaker. The
    **attenuation** feature can be applied to events in order to put a given sound
    into world space instead of it always being the same. However, this can only work
    if the sound is a mono sound.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: SoundCue编辑器与Kismet非常相似，除了只有当它被播放时才会调用事件，这通过一个扬声器图标表示。**衰减**功能可以应用于事件，以便将给定的声音放入世界空间，而不是总是保持相同。然而，这仅适用于单声道声音。
- en: '![Customizing sounds](img/1901_07_20.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![自定义声音](img/1901_07_20.jpg)'
- en: Once this is set it is possible to drag-and-drop a SoundCue inside a level,
    into the game world. So if you would like to add sound effects in your level that
    way you are welcome to try this and when you go around your level the sound will
    become louder and shift location based on where you are in the game world. There
    are plenty of other features to look at here, such as randomizers, but we'll only
    be playing a simple sound here. Play around with it in your own time or look at
    the Sound Cues that Epic provides with UDK to see the possible things you can
    do, such as adding modulation and variation to sounds, just like the gun shots
    sound different depending on your location in the game world, when you fire them.
    Have fun with it!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置好，你就可以将 SoundCue 拖放到关卡中，进入游戏世界。所以如果你想在关卡中通过这种方式添加声音效果，欢迎尝试，当你绕着关卡走动时，声音会根据你在游戏世界中的位置而变得更响或改变位置。这里还有很多其他功能可以查看，例如随机化器，但我们在这里只播放一个简单的声音。在你自己的时间里尝试一下，或者查看
    Epic 为 UDK 提供的 Sound Cues，看看你可以做些什么，比如添加调制和变化到声音中，就像枪声根据你在游戏世界中的位置而有所不同一样，当你开火时。享受这个过程吧！
- en: Adding music
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加音乐
- en: Similar to sound, music is done slightly differently on iOS than they are done
    for the PC. Since mobiles are usually media players they have hardware that specifically
    works with playing music efficiently, but the mobile platform is also limited
    in what it can do. Let's first add some music to our level.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 与声音类似，在 iOS 上音乐的处理方式与在 PC 上略有不同。由于手机通常是媒体播放器，它们有专门用于高效播放音乐的硬件，但移动平台在功能上也有所限制。让我们首先在我们的关卡中添加一些音乐。
- en: Time for action—adding a background music track
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加背景音乐轨道的时间——操作步骤
- en: 'Now, mobile devices have dedicated sound hardware for compressed sounds. iOS
    devices can play back one compressed stream at a time with little to no cost,
    so it will be our job to create music that works well in that regard. However,
    MP3 files do not work in the PC version of Unreal in either the editor or main
    game so I will be showing you how to add music in the Editor as well. We can do
    this as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，移动设备有专门用于压缩声音的音效硬件。iOS 设备可以一次播放一个压缩流，几乎没有成本，所以我们的任务就是创建适合这种环境的音乐。然而，MP3 文件在
    Unreal 的 PC 版本中既在编辑器中也在主游戏中都不适用，所以我将向你展示如何在编辑器中添加音乐。我们可以这样做：
- en: Go to Windows Explorer and open your `UDKGame\Build\iPhone\Resources\Music`
    folder. This is the folder that you need to place any MP3 file that you want to
    play within your game. For the sake of this we will be using a file already included
    with UDK, but feel free to put in any MP3 file that you like and whenever I say
    `Jazz_Menu_01`, type the name of your file. The music folder would look like the
    following screenshot:![Time for action—adding a background music track](img/1901_07_21.jpg)
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Windows 资源管理器并打开你的 `UDKGame\Build\iPhone\Resources\Music` 文件夹。这个文件夹是你需要放置任何你希望在游戏中播放的
    MP3 文件的地方。为了这个示例，我们将使用 UDK 中已包含的文件，但你可以随意放入你喜欢的任何 MP3 文件，并且每当我说 `Jazz_Menu_01`
    时，请输入你文件的名称。音乐文件夹看起来如下截图所示：![添加背景音乐轨道的时间——截图](img/1901_07_21.jpg)
- en: Open the **Content Browser** by either selecting its icon or going to the **View**
    menu and selecting **View** | **Browser Windows** | **Content Browser**. Inside
    the **Content Browser** change the **Object Type** to **Sound Cues** and type
    `music` in the textbox at the top of the window. Left-click on the first item
    which is `SoundCue'A_Music_GoDown.MusicSegments.A_Music_GoDown_Ambient01Cue'`
    and exit into Kismet. The following screenshot shows this:![Time for action—adding
    a background music track](img/1901_07_22.jpg)
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择其图标或转到 **视图** 菜单并选择 **视图** | **浏览器窗口** | **内容浏览器** 来打开 **内容浏览器**。在 **内容浏览器**
    中，将 **对象类型** 更改为 **声音提示** 并在窗口顶部的文本框中输入 `music`。左键单击第一个项目 `SoundCue'A_Music_GoDown.MusicSegments.A_Music_GoDown_Ambient01Cue'`
    并进入 Kismet。以下截图显示了这一点：![添加背景音乐轨道的时间——截图](img/1901_07_22.jpg)
- en: Note
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that this file will not be used in the game when it goes on an iOS device,
    but will let you know that for sure that sound is playing. If you had your own
    music file you could export it with Audacity ([http://audacity.sourceforge.net/](http://audacity.sourceforge.net/))
    and import it in much the same way that you would for sound effects, but that
    is a good exercise to do on your own.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，当这个文件在 iOS 设备上运行游戏时，它不会被用于游戏，但它会确保你知道声音正在播放。如果你有自己的音乐文件，你可以使用 Audacity ([http://audacity.sourceforge.net/](http://audacity.sourceforge.net/))
    导出它，并以与声音效果相同的方式导入它，但这是一个很好的个人练习。
- en: In Kismet remove the connection between the **Loaded and Visible** output on
    the **Level Loaded** event and the **In** section of the **Add Input Zone** action.
    Move the **Level Loaded** action to the left by holding *Ctrl* and dragging. In
    the space created right-click and create a **Play Music Track** action by right-clicking
    and selecting **New Action** | **Sound** | **Play Music Track**. Connect the **Loaded
    and Visible** output from the **Level Loaded** event into the **In** of the **Play
    Music Track** and the **Out** from the **Play Music Track** action into the **In**
    of the **Add Input Zone** action. Inside the properties for the **Play Music Track**
    action extend the **Seq Act Play Music Track** section. Click on the green arrow
    next to the **Sound Cue** to set the PC version of music to play, and then at
    the bottom of the screen you will see **MP3Filename** where you will put `Jazz_Menu_01.`![Time
    for action—adding a background music track](img/1901_07_23.jpg)
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Kismet中，删除**Level Loaded**事件上的**Loaded and Visible**输出与**Add Input Zone**动作的**In**部分之间的连接。通过按住*Ctrl*键并拖动将**Level
    Loaded**动作向左移动。在创建的空间中右键点击并创建一个**Play Music Track**动作，通过右键点击并选择**New Action**
    | **Sound** | **Play Music Track**。将**Level Loaded**事件的**Loaded and Visible**输出连接到**Play
    Music Track**的**In**，并将**Play Music Track**动作的**Out**连接到**Add Input Zone**动作的**In**。在**Play
    Music Track**动作的属性中扩展**Seq Act Play Music Track**部分。点击**Sound Cue**旁边的绿色箭头来设置要播放的PC版本音乐，然后在屏幕底部你会看到**MP3Filename**，在那里你会放置`Jazz_Menu_01.`![行动时间——添加背景音乐轨道](img/1901_07_23.jpg)
- en: Save your project and start your game by clicking on the **Start Mobile Previewer**
    button.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的项目，然后通过点击**开始移动预览器**按钮来开始你的游戏。
- en: What just happened?
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: With that, we have created a main menu that when tapped will go into our game
    level creating a professional looking start to our game.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就创建了一个主菜单，点击后会进入我们的游戏关卡创建，为我们的游戏提供了一个专业的外观。
- en: Custom materials
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义材质
- en: Materials are what the Unreal Engine uses in order to put images onto brushes
    or 3D models that we've created; now, we'll get to putting in custom models in
    a minute, but first we need to get materials in and for those that don't know
    how to use a 3D modeling program this will be the extent of what they can do,
    without learning another program. There are also some stunning professional-quality
    maps made only using Materials and BSPs and minimal meshes such as the *Hardcore
    Oldskool Low-Poly Map Pack* at [http://holp.beyondunreal.com/index.html](http://holp.beyondunreal.com/index.html),
    so you don't have to learn one if you don't want to, but it helps.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 材质是虚幻引擎用来将图像放置到我们创建的画笔或3D模型上的东西；现在，我们将在下一分钟内放入自定义模型，但首先我们需要放入材质，对于那些不知道如何使用3D建模程序的人来说，这将是他们能够做到的极限，而不需要学习另一个程序。还有一些仅使用材质和BSP以及最小网格的令人惊叹的专业质量地图，例如在[http://holp.beyondunreal.com/index.html](http://holp.beyondunreal.com/index.html)的*Hardcore
    Oldskool Low-Poly Map Pack*，所以如果你不想学习，你不必学习，但这有帮助。
- en: Time for action—customizing brushes
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——自定义画笔
- en: The level that we created in the previous chapter does indeed look good, but
    it would be even better to put actual buildings into the level, so let's try to
    make the brushes more building-like by adding some custom Materials to them!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中我们创建的关卡确实看起来不错，但如果我们能在关卡中加入实际的建筑会更好，所以让我们尝试通过添加一些自定义材质来使画笔更像建筑！
- en: Open up the **Content Browser** by either selecting its icon or going to the
    **View** menu and selecting **View** | **Browser Windows** | **Content Browser**.
    Click on the **Import** button in the menu at the bottom of the window. Select
    both the files `building03` and `building03_NRM` by clicking on one, holding down
    the *Ctrl* key and selecting the other. With these selected click on **Open**.
    This is how your screen would look:![Time for action—customizing brushes](img/1901_07_24.jpg)
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择其图标或转到**视图**菜单并选择**视图** | **浏览器窗口** | **内容浏览器**来打开**内容浏览器**。在窗口底部的菜单中点击**导入**按钮。通过点击一个文件，按住*Ctrl*键并选择另一个文件来选择`building03`和`building03_NRM`两个文件。选择后点击**打开**。你的屏幕将看起来像这样：![行动时间——自定义画笔](img/1901_07_24.jpg)
- en: There will be an import dialog that will come up. In the **Package** section
    type the name `UW-GamePKG` and confirm that `building03` is in the **Name** section.
    Inside the **Options** section check the box for **Create Material** and click
    on **OK** and then for the `building03_NRM` file uncheck the **Create Material**
    option and click on **OK**. You should be brought back to the **Content Browser**
    where you will see our new package with three new files, as shown in the following
    screenshot:![Time for action—customizing brushes](img/1901_07_25.jpg)
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将会出现一个导入对话框。在**包**部分输入名称`UW-GamePKG`并确认`building03`位于**名称**部分。在**选项**部分勾选**创建材质**复选框，然后点击**确定**。对于`building03_NRM`文件，取消勾选**创建材质**选项并点击**确定**。你应该会返回到**内容浏览器**，在那里你会看到我们新的包含三个新文件的新包，如下面的截图所示：![操作时间——自定义刷子](img/1901_07_25.jpg)
- en: Double-click on the `building03_Mat` material in order to enter the **Material
    Editor**. Now the **Material Editor** may look scary at first, but just like the
    Sound Editor it is amazingly similar to Kismet when you look at it. Click on the
    **Texture Sample** with the texture that we imported and drag it to the right-hand
    side of the **Diffuse** option by holding *Ctrl* and dragging.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`building03_Mat`材质以进入**材质编辑器**。一开始，**材质编辑器**可能看起来有些吓人，但就像声音编辑器一样，当你仔细观察时，它和Kismet非常相似。点击带有我们导入的纹理的**纹理样本**，并按住*Ctrl*键将其拖动到**漫反射**选项的右侧。
- en: Go to the **Content Browser** and select the `building03_NRM` texture by left-clicking
    it and going back into the **Material Editor**. Hold down the *T* key and left-click
    on the screen near the **Normal** section of the **PreviewMaterial_0** area, you
    should see a new Texture Sample show up. You also select the Texture Sample from
    the menu on the right-hand side and drag-and-drop it in from the **Material Expressions**
    area. Connect the **Normal** option from the **PreviewMaterial_0** to the black
    connector of the new **Texture Sample**.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**内容浏览器**，通过左键单击`building03_NRM`纹理并返回**材质编辑器**来选择它。按住*T*键并在**预览材质_0**区域的**法线**部分附近屏幕上左键单击，你应该会看到一个新的纹理样本出现。你也可以从右侧的菜单中选择纹理样本并将其从**材质表达式**区域拖动并放置。将**预览材质_0**的**法线**选项连接到新的**纹理样本**的黑色连接器。
- en: You will notice that our Material now looks like it has depth to it. That is
    because a normal map is a technique used for faking the lighting of bumps and
    dents. It is used to add details without using more polygons and what you see
    now is how it would look if you played your game on PC. When playing the game
    on iOS, UDK will attempt to bake it into the lightmap used by the level using
    the PC materials normal map, while the advanced effects use the normal map slot
    under the **Mobile** section of the material editor.
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会注意到我们的材质现在看起来有了深度。这是因为法线贴图是一种用于模拟凹凸光照的技术。它用于在不使用更多多边形的情况下添加细节，你现在看到的就是如果你在PC上玩游戏时的样子。当在iOS上玩游戏时，UDK会尝试使用PC材质的法线贴图将其烘焙到由级别使用的光照贴图中，而高级效果则使用材质编辑器**移动**部分下的法线贴图槽。
- en: Again, there are a lot of other options that you can use on the PC version of
    UDK that you cannot use on the iOS. However, there is a very good guide for those
    who want to create their own textures on the different things you can do on UDN
    at [http://udn.epicgames.com/Three/MobileMaterialReference.html](http://udn.epicgames.com/Three/MobileMaterialReference.html).
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次强调，在UDK的PC版本中，有许多其他选项你无法在iOS上使用。然而，对于那些想在UDN上创建自己的纹理的人来说，有一个非常好的指南，介绍了你可以在UDN上做的不同事情，链接为[http://udn.epicgames.com/Three/MobileMaterialReference.html](http://udn.epicgames.com/Three/MobileMaterialReference.html)。
- en: Deselect the **Texture Sample** and you should see the **Properties** for the
    Material at the bottom of the screen. Open up the **Mobile** section by click
    on the green arrow beside **Mobile Normal Texture** in order to load our normal
    map into the game. Go into the **Content Browser** and select our diffuse texture
    and then click the green arrow for **Mobile Base Texture**. The **Material Editor**
    window will look like the following screenshot:![Time for action—customizing brushes](img/1901_07_26.jpg)
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消选择**纹理样本**，你应该会在屏幕底部看到材质的**属性**。通过点击**移动法线纹理**旁边的绿色箭头打开**移动**部分，以便将我们的法线贴图加载到游戏中。进入**内容浏览器**，选择我们的漫反射纹理，然后点击**移动基础纹理**的绿色箭头。**材质编辑器**窗口将看起来如下面的截图所示：![操作时间——自定义刷子](img/1901_07_26.jpg)
- en: In the menu click on the green checkmark at the top in order to save the changes
    that you've made and close the **Material Editor**. Save the package you've created
    by right-clicking on the package and selecting **Save** from the menu and saving
    the package in a location on your computer.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在菜单中，点击顶部绿色的勾选标记以保存您所做的更改并关闭**材质编辑器**。通过右键单击包并从菜单中选择**保存**来保存您创建的包，并将包保存在您的计算机上的某个位置。
- en: Repeat steps 1 to 6 for the other materials in the folder as we will be using
    them later.![Time for action—customizing brushes](img/1901_07_27.jpg)
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤1到6，对文件夹中的其他材质进行操作，因为我们稍后会使用它们。![操作时间—自定义笔刷](img/1901_07_27.jpg)
- en: 'Open up the game level that we created in the previous chapter. Find a large
    brush that you created for a building before, left-click to select one of the
    surfaces then right-click and select **Select Surfaces** | **Matching Brush**.
    Go to the **Content Browser** and select `building01_Mat` by left-clicking on
    it. At the brush right-click and select **Apply Material : building01_Mat**. You
    may click on the **Unlit** button on the perspective toolbar or press *Alt+3*
    to help you see what''s going on. When you are finished you can press *Alt+4*
    to go back to **Lit** mode.'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '打开我们在上一章中创建的游戏关卡。找到之前为建筑物创建的大笔刷，左键单击以选择其中一个表面，然后右键单击并选择**选择表面** | **匹配笔刷**。转到**内容浏览器**，通过左键单击选择`building01_Mat`。在笔刷上右键单击并选择**应用材质
    : building01_Mat**。您可以通过点击透视工具栏上的**不发光**按钮或按*Alt+3*来帮助您看到正在发生的事情。完成操作后，您可以按*Alt+4*返回到**发光**模式。'
- en: We can start to see how the building could work out using this material, but
    each side seems to be doing its own thing in the different coordinates, thankfully
    we can easily fix this problem.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以看到使用这种材质如何使建筑物看起来更精致。幸运的是，我们可以轻松地解决这个问题，因为每个侧面似乎都在不同的坐标系中做自己的事情。
- en: Open up the **Surface Properties** menu by either pressing *F5* or going to
    **View** | **Surface Properties** and selecting the matching brush textures again.
    Change the **Alignment** to **Box** and hit **Apply**. Then change the **Simple**
    scaling value to `4.0` and hit **Apply** again.![Time for action—customizing brushes](img/1901_07_28.jpg)
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按*F5*键或转到**视图** | **表面属性**并再次选择匹配的笔刷纹理来打开**表面属性**菜单。将**对齐**设置为**框**并点击**应用**。然后更改**简单**缩放值为`4.0`并再次点击**应用**。![操作时间—自定义笔刷](img/1901_07_28.jpg)
- en: Apply textures to your level on buildings that you would like to see changed
    using the materials provided or with your own. Note that since the player will
    not see the roofs of our buildings we do not need to have a texture for them.
    This is seen in the following screenshot:![Time for action—customizing brushes](img/1901_07_29.jpg)
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用提供的材质或您自己的材质将纹理应用到您想要更改的建筑物上。请注意，由于玩家不会看到我们建筑物的屋顶，我们不需要为它们提供纹理。这可以在以下屏幕截图中看到：![操作时间—自定义笔刷](img/1901_07_29.jpg)
- en: Save your project and start your game by clicking on the **Start Mobile Previewer**
    button.![Time for action—customizing brushes](img/1901_07_30.jpg)
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存您的项目，然后通过点击**启动移动预览器**按钮开始您的游戏。![操作时间—自定义笔刷](img/1901_07_30.jpg)
- en: What just happened?
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We now have a world that looks more polished with our own textures filling the
    world. With the same basic concepts here you can paint your brushes however you
    want!
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个看起来更精致的世界，因为我们自己的纹理填充了整个世界。在这里使用相同的基本概念，您可以随意绘制您的笔刷！
- en: Custom meshes
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义网格
- en: The static meshes that are included inside of UDK are fine, but if you want
    to create anything that is remotely different and detailed, chances are you will
    need to import custom meshes of your own.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: UDK中包含的静态网格是好的，但如果你想要创建任何不同且详细的物体，很可能会需要导入你自己的自定义网格。
- en: 'For those creating their own models, there are various different tutorials
    on the internet for you to look at, but in general export your model as an FBX
    file and enable smoothing groups when exporting it and try to keep your models
    as low poly as possible. For more information on the creation of the models you
    can visit: [http://udn.epicgames.com/Three/DesigningForMobile.html](http://udn.epicgames.com/Three/DesigningForMobile.html).'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些创建自己模型的人来说，互联网上有各种不同的教程供您参考，但通常情况下，将您的模型导出为FBX文件，并在导出时启用平滑组，并尽量保持您的模型低多边形。有关模型创建的更多信息，您可以访问：[http://udn.epicgames.com/Three/DesigningForMobile.html](http://udn.epicgames.com/Three/DesigningForMobile.html)。
- en: Time for action—importing custom objects
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作时间—导入自定义对象
- en: 'In our case, we would like to replace some of the BSP buildings that we created
    in the game with some simple static meshes that I created. We can do this as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们希望用我创建的一些简单静态网格替换我们在游戏中创建的一些BSP建筑物。我们可以这样做：
- en: Open up the **Content Browser** by either selecting its icon or going to the
    **View** menu and selecting **View** | **Browser Windows** | **Content Browser**.
    Click on the **Import** button in the menu at the bottom of the window. Find the
    two building `.fbx` files, select them and then click on **Open**. In the window
    that pops up set the package with the same name that you created before and click
    on **OK**, saying yes if it asks you to import the entire package. This is seen
    in the following screenshot:![Time for action—importing custom objects](img/1901_07_31.jpg)
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择其图标或转到**视图**菜单并选择**视图** | **浏览器窗口** | **内容浏览器**来打开**内容浏览器**。在窗口底部的菜单中点击**导入**按钮。找到两个建筑`.fbx`文件，选择它们然后点击**打开**。在弹出的窗口中设置与您之前创建的相同名称的包，并点击**确定**，如果询问您是否导入整个包，请回答是。这可以在以下屏幕截图中看到：![操作时间——导入自定义对象](img/1901_07_31.jpg)
- en: Right-click on the package name on the left-hand side of the **Content Browser**
    and save our package by selecting **Save** in the menu. Double-click on the first
    building in order to enter its properties, as shown in the following screenshot:![Time
    for action—importing custom objects](img/1901_07_32.jpg)
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**内容浏览器**左侧的包名称上右键点击，并通过选择菜单中的**保存**来保存我们的包。双击第一个建筑物以进入其属性，如图所示：![操作时间——导入自定义对象](img/1901_07_32.jpg)
- en: With the **Static Mesh Editor** open go back into the **Content Browser** and
    left-click on `building01_Mat` file. Inside the Properties under **LODInfo.[0].Elements.[0]**
    in **Material** click on the green arrow pointing towards the left to set the
    Material to the one we selected, as shown in the following screenshot:![Time for
    action—importing custom objects](img/1901_07_33.jpg)
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在打开的**静态网格编辑器**中，返回到**内容浏览器**，左键点击`building01_Mat`文件。在**材质**下的**LODInfo.[0].Elements.[0]**属性中，点击指向左边的绿色箭头以设置材质为我们选择的材质，如图所示：![操作时间——导入自定义对象](img/1901_07_33.jpg)
- en: On the menu at the top of the **Static Mesh Editor** click **Collision** | **6DOP
    Simplified Collision** in order to make the building collide with objects.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**静态网格编辑器**顶部的菜单中点击**碰撞** | **6DOP简化碰撞**，以便使建筑物与对象发生碰撞。
- en: Note
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you would like to see the collision generated for the object you can click
    on the icon in the panel at the top of the screen that looks like it has a red
    box around it. You can also import your own custom collision that you created
    in your favorite modeling program. For more information about that, visit: [http://udn.epicgames.com/Three/FBXStaticMeshPipeline.html#Collision](http://udn.epicgames.com/Three/FBXStaticMeshPipeline.html#Collision)'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您想查看为对象生成的碰撞，可以点击屏幕顶部的面板中的图标，它看起来像周围有一个红色框。您还可以导入您在您喜欢的建模程序中创建的自定义碰撞。有关更多信息，请访问：[http://udn.epicgames.com/Three/FBXStaticMeshPipeline.html#Collision](http://udn.epicgames.com/Three/FBXStaticMeshPipeline.html#Collision)
- en: Double-click on **building02** to enter the **Static Mesh Editor** and repeat
    steps 3 and 4 using `building02_Mat` as the material to use.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击**building02**进入**静态网格编辑器**，并使用`building02_Mat`作为要使用的材质重复步骤3和4。
- en: 'Back in our level find a building that is a similar shape to **building01**.
    Delete that brush and in its place right-click and select **Add Static Mesh :
    UWGamePKG.Building01**. Scale the object up till it fits the area of the object
    you deleted and move it down until it fits the ground or hit the *End* key, then
    click on **Rebuild All**.![Time for action—importing custom objects](img/1901_07_34.jpg)'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到我们的级别，找到一个与**building01**形状相似的建筑物。删除该笔刷，在其位置右键点击并选择**添加静态网格：UWGamePKG.Building01**。将对象放大直到它适合您删除的对象的区域，并将其向下移动直到它适合地面或按*End*键，然后点击**重建所有**。![操作时间——导入自定义对象](img/1901_07_34.jpg)
- en: Do the same for other buildings, and continue replacing brushes with the buildings
    at random intervals trying to make it so you can't see duplicates of them within
    the same frame or area.![Time for action—importing custom objects](img/1901_07_35.jpg)
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对其他建筑物做同样的事情，并在随机的时间间隔内用建筑物替换笔刷，试图确保您在同一帧或区域内看不到它们的重复。![操作时间——导入自定义对象](img/1901_07_35.jpg)
- en: Turn on the **Emulate Mobile Feature** at this point to give you a better feel
    of what the game may look on the device. You can toggle the mode on and off by
    clicking on the little icon that looks like a phone to the left-hand side of the
    **Install on iOS Device** button.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此阶段打开**模拟移动功能**以更好地感受游戏在设备上的外观。您可以通过点击位于**安装到iOS设备**按钮左侧的小图标（看起来像一部手机）来切换模式的开和关。
- en: Save your project and start your game by clicking on the **Start Mobile Previewer**
    button.![Time for action—importing custom objects](img/1901_07_36.jpg)
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**开始移动预览器**按钮保存您的项目并开始游戏。![行动时间——导入自定义对象](img/1901_07_36.jpg)
- en: What just happened?
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: You now have all sorts of custom features added into your game giving you some
    great examples and now if you'd like to go in and bring in your own models you
    are free to do that as well!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经在游戏中添加了各种自定义功能，提供了一些很好的示例，如果您想添加自己的模型，您也可以自由地这样做！
- en: Optimizations
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化
- en: There are a ton of resources on how to optimize your game and plenty of discussions
    on forums of the best ways to do things. In the following sections I will talk
    about different aspects that I use in order to optimize my games.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何优化游戏有大量的资源，论坛上也有很多关于最佳实践方式的讨论。在接下来的章节中，我将讨论我用来优化游戏的不同方面。
- en: Console commands—statistics
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制台命令——统计数据
- en: One of the neat new additions to UDK in terms of mobiles is the fact that by
    holding four fingers on the screen at a time you can open up the console window.
    You can find a list of console commands you can use in UDK at [http://udn.epicgames.com/Three/ConsoleCommands.html](http://udn.epicgames.com/Three/ConsoleCommands.html).
    Also note that the values you may see on the PC are in no way an indicator of
    how things will be on an iOS device so be sure to do your testing by either using
    the four-finger process or calling the `Console Command` in Kismet. The following
    are some of the stats that I found most useful when debugging projects.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动设备方面，UDK的一个新亮点是，通过同时按住屏幕上的四个手指，您可以打开控制台窗口。您可以在[http://udn.epicgames.com/Three/ConsoleCommands.html](http://udn.epicgames.com/Three/ConsoleCommands.html)找到UDK中可以使用的控制台命令列表。此外，请注意，您在PC上看到的值绝不是iOS设备上事物状态的指标，因此请确保通过使用四指操作或调用Kismet中的`Console
    Command`来进行测试。以下是我发现当调试项目时最有用的部分统计数据。
- en: stat fps
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: stat fps
- en: The easiest one to see why we would want it, the FPS counter tells us how many
    frames per second our game runs. 24 frames per second is the accepted threshold
    where animation becomes possible, if it is much less, the visuals seems jagged
    or our brains can tell that they are just images. 30 FPS is an accepted standard
    in most Unreal games, though some have been able to do 60.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最容易理解我们为什么想要它的，就是FPS计数器告诉我们游戏每秒运行了多少帧。每秒24帧是动画成为可能的公认阈值，如果远低于这个数值，视觉效果看起来会参差不齐，或者我们的大脑可以判断出它们只是图像。在大多数Unreal游戏中，30
    FPS是一个公认的标准，尽管有些游戏已经能够达到60 FPS。
- en: stat game
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: stat game
- en: This shows statistics related to the time it takes to run different parts of
    the game, which may make it easier to see which sections of the game are taking
    the longest to run with the number of checkmarks, and the time it takes to do
    certain things such as Kismet and UnrealScript.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了与运行游戏不同部分所需时间相关的统计数据，这可能会使您更容易通过复选标记的数量看到游戏哪些部分运行时间最长，以及执行某些事情（如Kismet和UnrealScript）所需的时间。
- en: stat memory
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: stat memory
- en: This shows how much memory is being used by each individual section of the game.
    The larger the memory, the more processing power it takes to use and the larger
    your game will be. Apple only allows you to download apps that are 50 MB or less
    through 3G/4G, so having an app with a size larger than this will force it to
    be downloaded through WiFi, which will probably be how your game will wind up,
    due to the size of UDK, but it still is a good idea to keep your memory footprint
    low.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了游戏每个独立部分使用的内存量。内存越大，所需的处理能力就越多，您的游戏也会越大。苹果只允许通过3G/4G下载50 MB或更小的应用程序，因此具有大于此大小的应用程序将迫使它通过WiFi下载，这可能是由于UDK的大小，但仍然是一个保持内存占用低的好主意。
- en: '![stat memory](img/1901_07_37.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![stat memory](img/1901_07_37.jpg)'
- en: stat es2
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: stat es2
- en: OpenGL ES2 is the iOS rendering device and while inside the Mobile Previewer
    it may crash when run on an iOS device. You can see useful data in terms of how
    many draw calls are done as well other useful stats to see. Try to keep your draw
    calls down as low as you can as it will probably be the thing that slows your
    game down the most.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL ES2是iOS渲染设备，在Mobile Previewer中运行iOS设备时可能会崩溃。你可以看到有关绘制调用次数以及其他有用统计数据的有用信息。尽量将绘制调用保持在尽可能低的水平，因为这可能是减慢你的游戏速度的最主要因素。
- en: '![stat es2](img/1901_07_38.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![stat es2](img/1901_07_38.jpg)'
- en: Combining meshes
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合并网格
- en: Speaking of draw calls, we have just learned how to create meshes in our game
    project earlier in this chapter. When wanting to optimize our game, it may be
    a good idea to combine similar meshes that contain the same texture together as
    long as it is still low poly. Having fewer meshes reduces the amount of draw calls
    that need to be made. In the same regard, reduce the amount of materials that
    you use on an individual object, constraining yourself to only one Material per
    object if you possibly can. Using multiple materials on an object at the very
    least doubles the amount of memory needed to compute and run it, which is not
    a very good thing when you're trying to make your game as efficient as possible.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 说到绘制调用，我们在本章前面已经学习了如何在游戏项目中创建网格。当你想要优化你的游戏时，将具有相同纹理的相似网格组合在一起可能是个好主意，只要它们仍然是低多边形。减少网格的数量可以减少需要进行的绘制调用数量。同样地，减少单个对象上使用的材质数量，如果可能的话，将每个对象限制使用一个材质。在对象上使用多个材质至少会加倍计算和运行它所需的内存，这在尝试使你的游戏尽可能高效时并不是一个好现象。
- en: Precomputed visibility
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预计算可见性
- en: 'Hardware occlusion queries are appealing in games because they work in completely
    dynamic scenes, but sadly iOS devices do not support occluding objects. By occluding
    objects I mean that if the player does not see an object, the game can skip drawing
    that object. While our little game happens to run fine, larger projects will want
    to make use of this feature as it can greatly improve runtimes. To learn how to
    set precomputed visibility in your game, see: [http://udn.epicgames.com/Three/PrecomputedVisibility.html](http://udn.epicgames.com/Three/PrecomputedVisibility.html).'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件遮挡查询在游戏中很有吸引力，因为它们可以在完全动态的场景中工作，但遗憾的是iOS设备不支持遮挡对象。通过遮挡对象，我的意思是如果玩家看不到一个对象，游戏可以跳过绘制该对象。虽然我们的小游戏运行得很好，但较大的项目将希望利用这个功能，因为它可以极大地提高运行时间。要了解如何在你的游戏中设置预计算可见性，请参阅：[http://udn.epicgames.com/Three/PrecomputedVisibility.html](http://udn.epicgames.com/Three/PrecomputedVisibility.html)。
- en: Streaming volumes
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流体积
- en: 'While we''re on the topic of larger levels, by far the best way in my opinion
    to create larger levels is by using streaming volumes. What that basically does
    is make it so that when you enter a certain area of the world, a level will be
    loaded. However, in the transition between levels there may be a time when more
    than one level is open which will lower your frame rate drastically. I personally
    create small areas in between my larger levels that contain parts of both levels
    that make the transition more seamless and less of a hog on memory all at once.
    For more information on streaming volumes and how to set it up, check out: [http://udn.epicgames.com/Three/LevelStreamingVolumes.html](http://udn.epicgames.com/Three/LevelStreamingVolumes.html)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们正在讨论更大的关卡，但在我看来，创建更大关卡的最佳方式是使用流体积。这基本上意味着当你进入世界的某个区域时，会加载一个关卡。然而，在关卡之间的转换过程中，可能会有一个时刻同时打开多个关卡，这将极大地降低你的帧率。我个人在较大的关卡之间创建小区域，这些区域包含两个关卡的部分，使得转换更加无缝，并且一次性减少对内存的占用。有关流体积及其设置的更多信息，请查看：[http://udn.epicgames.com/Three/LevelStreamingVolumes.html](http://udn.epicgames.com/Three/LevelStreamingVolumes.html)。
- en: Debugging
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试
- en: Being able to debug your game doesn't seem that important, until something in
    your game breaks. Having a firm grounding in ways to see what is going on in your
    game will definitely help you later on down the road as you delve into projects
    of your own.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 能够调试你的游戏似乎并不那么重要，直到你的游戏中出现问题时。对了解游戏内部情况的方法有扎实的掌握，无疑会在你深入自己的项目时给你带来帮助。
- en: Comment your code
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释你的代码
- en: 'This is something that was drilled into me in college and advice I am very
    thankful for taking. Chances are that while working on any large project you are
    not going to be touching a particular sequence in Kismet every day. Weeks are
    going to go by and you are going to forget why certain things were done. This
    is just as applicable to Kismet as it is to any other kind of programming language,
    and thankfully Unreal gives us the ability to make it simple to tell others what
    is going on. Selecting multiple objects and then right-clicking and selecting
    **Comment** allows you to type something in, which can give a clue into what a
    group of Kismet nodes are used for, such as this reworked Player Spawned event:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我上大学时被灌输的东西，也是我非常感激采纳的建议。很可能在你处理任何大型项目时，你不会每天都要接触Kismet中的特定序列。几周过去了，你可能会忘记为什么做了某些事情。这对Kismet来说同样适用，对任何其他编程语言来说也是如此，幸运的是，Unreal给了我们一个简单地向他人说明情况的能力。选择多个对象，然后右键单击并选择**注释**，允许你输入一些内容，这可以提供关于一组Kismet节点用途的线索，例如这个重新设计的玩家生成事件：
- en: '![Comment your code](img/1901_07_39.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![注释你的代码](img/1901_07_39.jpg)'
- en: 'I also added in object comments at the end of the different input zones, for
    example I did this when I put in the push button example, except I didn''t trigger
    the output on the screen. Now it is used so that when I glance at the code I know
    what I''m adding. Cleaning up the code that we did during the project I came up
    with this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我还在不同输入区域的末尾添加了对象注释，例如，我在放入按钮示例时就是这样做的，除了我没有在屏幕上触发输出。现在它被用来确保当我浏览代码时，我知道我在添加什么。在清理项目期间我们做的代码时，我得到了这个：
- en: '![Comment your code](img/1901_07_40.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![注释你的代码](img/1901_07_40.jpg)'
- en: Even with a glance it is always better to look at than having no guidance at
    all, making it simple to find what you're looking for either there or in any of
    the subsequences we created. You could even take this idea further, creating subsequences
    for each of the different items, but that's more of finding what you're comfortable
    with and getting accustomed to your own style of doing things.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是匆匆一瞥，也比没有任何指导要好，这使得在任何一个我们创建的子序列中找到你想要的东西变得简单。你甚至可以将这个想法进一步扩展，为每个不同的项目创建子序列，但这更多的是找到你感到舒适的方式，并习惯你自己的做事风格。
- en: Captain's log
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 船长的日志
- en: 'Now, there will come a time where you are sure everything is correct and all
    of your Kismet actions are being called. Well, there''s one way to be sure of
    the value that something is, and that''s by logging it and displaying what the
    data is at runtime. You can create a **Log** action by going into **New Action**
    | **Misc** | **Log**. From there you can right-click on the object and select
    **Expose Variable** and choose a type of something you''d like to get the value
    of. With that if you set the **Target** to **Player 0** and the other item to
    some of that type, when you play the game and it is called, the game will display
    what it is. For example when I add a **Log** action to this event:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，会有这么一个时刻，你确信一切都是正确的，所有的Kismet动作都被调用了。好吧，有一种方法可以确保某个值是正确的，那就是通过记录并显示运行时的数据。你可以通过进入**新建动作**
    | **杂项** | **日志**来创建一个**日志**动作。从那里，你可以右键单击对象并选择**暴露变量**，选择你想要获取值的类型。有了这个，如果你将**目标**设置为**玩家0**，将其他项目设置为该类型的一些内容，当你玩游戏并且调用它时，游戏将显示它是什么。例如，当我向这个事件添加一个**日志**动作时：
- en: '![Captain''s log](img/1901_07_41.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![船长的日志](img/1901_07_41.jpg)'
- en: '`UTPawn_0` gets displayed in the log. This is the name of the object that we
    put in the object variable link of the Log action.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`UTPawn_0`在日志中显示。这是我们放入日志动作对象变量链接中的对象的名称。'
- en: '![Captain''s log](img/1901_07_42.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![船长的日志](img/1901_07_42.jpg)'
- en: Being able to make sure that an object has a value you think it should have
    is one of the most obvious ways to tell if something is wrong, other than it not
    being called at all, of course.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 能够确保一个对象具有你认为它应该具有的值，是除了它根本未被调用之外，判断某事是否出错的最明显的方法之一。
- en: Summary
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Our game is now effectively our own, or at least on its way to being our own.
    With this knowledge I''m confident that you are more than ready to build your
    game to be as large as you''d like as well as inputting all sorts of custom stuff
    into the game. We''ve specifically learned how to:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏现在实际上是我们自己的，或者至少正在朝着我们自己的方向发展。有了这个知识，我坚信你已经准备好构建你想要的大小游戏，并将各种自定义内容输入到游戏中。我们特别学习了如何：
- en: Create a main menu for our game with input
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的游戏创建一个带有输入的主菜单
- en: Add audio on mobile UDK for our game
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的游戏在移动UDK上添加音频
- en: Import custom textures to our game
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将自定义纹理导入到我们的游戏中
- en: Create a materials for both PC and iOS to use
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为PC和iOS创建材料
- en: Add static meshes on Mobile UDK for our game
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在移动UDK上为我们的游戏添加静态网格
- en: Optimize and Debug our game on the iOS
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在iOS上优化和调试我们的游戏
- en: Now that we've learned how to import all of your custom content to your heart's
    desire, we need to complete our main game in the next chapter. We will go over
    how to take the game that we created and get it onto the iTunes store and the
    steps that it requires as well to make your game a success!
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何将所有您想要的定制内容导入到您的游戏中，我们接下来需要完成我们的主要游戏内容。在下一章中，我们将介绍如何将我们创建的游戏上传到iTunes商店，以及为了使您的游戏成功所需的步骤！
