- en: Implementing the Place Reviewer Frontend
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现地点评论者前端
- en: 'In the previous chapter, we continued our exploration of Kotlin as a viable
    language for the creation of web applications by commencing the building of the
    Place Reviewer website. We began the chapter by discussing the Model-View-Controller
    design pattern and taking a high-level look at the primary components at play
    in MVC applications: the model, the view, and the controller. Once we had a clear
    understanding of the MVC design pattern and how it works, we commenced with the
    design and implementations of the backend for the *Place Reviewer* application.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们继续探索Kotlin作为创建Web应用程序的可行语言，开始构建地点评论者网站。我们以讨论模型-视图-控制器设计模式并从高层次查看MVC应用程序中起主要作用的组件：模型、视图和控制器开始本章。一旦我们对MVC设计模式及其工作原理有了清晰的理解，我们就开始了*地点评论者*应用程序后端的开发和实现。
- en: First and foremost, we identified and clearly stated the anticipated use cases
    for our application. Next, we identified the data required to build an application
    that facilitates the use cases identified. After identification of the data to
    be catered for, we went full steam ahead with the development of the backend.
    We set up a Postgres database with which our application will communicate, then
    implemented the necessary entities and models for our application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们确定了并清楚地说明了我们应用程序预期的用例。接下来，我们确定了构建一个能够促进已识别用例的应用程序所需的数据。在确定要提供的数据后，我们全力以赴地开发了后端。我们设置了一个Postgres数据库，我们的应用程序将通过它与数据库通信，然后实现了我们应用程序所需的必要实体和模型。
- en: Further into the chapter, we discovered how to secure our application—authentication-wise—with
    Spring Security, this time without the use of JWTs. Finally, we learned how to
    create controllers for Spring MVC-based applications, as well as how to manage
    server logs with the ELK stack.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的进一步内容中，我们发现了如何使用Spring Security来确保我们的应用程序——从认证的角度来看——这次没有使用JWT。最后，我们学习了如何为基于Spring
    MVC的应用程序创建控制器，以及如何使用ELK堆栈管理服务器日志。
- en: 'In this chapter, we shall finish up the creation of the *Place Reviewer* application
    by implementing its frontend. In the process of doing this, we shall learn about
    the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过实现其前端来完成*地点评论者*应用程序的创建。在这个过程中，我们将了解以下内容：
- en: Working with the Google Places API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Google地点API
- en: Application testing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序测试
- en: Deploying web applications to AWS
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Web应用程序部署到AWS
- en: Let's get straight into this chapter by implementing the views for our application.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接进入本章，通过实现我们应用程序的视图来开始。
- en: Creating views with Thymeleaf
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Thymeleaf创建视图
- en: 'As previously defined, a view is a representation of data that exists in and
    is generated by an application. Views are the primary points of interaction that
    a user has with an application built with the MVC pattern. The view layer may
    utilize different technologies to render information to a user. Spring supports
    a number of view options. These view options are also referred to as templates.
    Template support in a Spring application is provided by a template engine. Simply
    put, a template engine enables the utilization of static template files with the
    view layer of an application. A template engine may also be referred to as a template
    library. The following template libraries are available for use with Spring:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，视图是存在于应用程序中并由应用程序生成数据的表示。视图是用户与使用MVC模式构建的应用程序的主要交互点。视图层可能利用不同的技术向用户呈现信息。Spring支持多种视图选项。这些视图选项也被称为模板。Spring应用程序中的模板支持由模板引擎提供。简单来说，模板引擎使应用程序的视图层能够使用静态模板文件。模板引擎也可以称为模板库。以下模板库可用于与Spring一起使用：
- en: Thymeleaf
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Thymeleaf
- en: JSP/JSTL
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSP/JSTL
- en: Freemaker
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Freemaker
- en: Tiles
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tiles
- en: Velocity
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Velocity
- en: 'This list is by no means intended to be exhaustive. There are a number of other
    template libraries available for use with Spring. We shall be relying on Thymeleaf
    to provide template processing support for our application. If you recall, we
    included templating support with Thymeleaf upon initial creation of our project.
    Inspecting the dependencies section of our project''s `pom.xml` file will reveal
    the addition of Thymeleaf to our project:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表绝对不是详尽的。还有许多其他模板库可用于与Spring一起使用。我们将依赖Thymeleaf为我们提供模板处理支持。如果您还记得，我们在项目初始创建时就包括了Thymeleaf的模板支持。检查我们项目`pom.xml`文件的依赖关系部分将揭示Thymeleaf被添加到我们的项目中：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: At this juncture, you may desire a more formal definition of what exactly Thymeleaf
    is. As stated on Thymeleaf's official website, *Thymeleaf is a modern server-side
    Java template engine for both web and standalone environments. Thymeleaf's main
    goal is to bring elegant natural templates to your development workflow - HTML
    that can be correctly displayed in browsers and also work as static prototypes,
    allowing for stronger collaboration in development teams.* If you require a deeper
    understanding of Thymeleaf and its goals, you can find more information about
    it at [http://thymeleaf.org](http://thymeleaf.org).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你可能希望有一个更正式的定义来确切了解Thymeleaf是什么。正如Thymeleaf官方网站上所述，*Thymeleaf是一个现代的服务端Java模板引擎，适用于Web和独立环境。Thymeleaf的主要目标是为您的发展工作流程带来优雅的自然模板
    - 可以在浏览器中正确显示并且也可以作为静态原型工作的HTML，从而在开发团队中实现更强的协作。* 如果你需要更深入地了解Thymeleaf及其目标，你可以在[http://thymeleaf.org](http://thymeleaf.org)找到更多关于它的信息。
- en: In the previous chapter, we took a simple example of view creation in Spring
    by implementing a `hello.html` view for the `HelloController`. However, the view
    we created only displayed a `Hello world!` message to its viewers. We will be
    creating slightly more complex views in this chapter. We shall start by creating
    a view facilitating user registration on the platform.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们通过为`HelloController`实现一个`hello.html`视图来展示了Spring中视图创建的一个简单例子。然而，我们创建的视图仅向观众显示了`Hello
    world!`消息。在本章中，我们将创建稍微复杂一些的视图。我们将首先创建一个视图，以方便在平台上进行用户注册。
- en: Implementing the user registration view
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现用户注册视图
- en: 'In this section, we are going to accomplish two tasks. Firstly, we are going
    to create a view layer that facilitates the registration of new users on the Place
    Reviewer platform. Secondly, we are going to create suitable controllers and actions
    to present the user with the registration view and handle registration form submissions.
    Simple enough right? Glad you think so! Go ahead and create a `register.html`
    template in the `Place Reviewer` project. Recall that all template files belong
    in the templates directory under resources. Now, add the following template HTML
    to the file:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将完成两个任务。首先，我们将创建一个视图层，以方便在Place Reviewer平台上注册新用户。其次，我们将创建合适的控制器和操作，以向用户展示注册视图并处理注册表单的提交。简单吧？很高兴你这么想！现在，在`Place
    Reviewer`项目中创建一个`register.html`模板。回想一下，所有模板文件都应位于资源目录下的`templates`目录中。现在，将以下模板HTML添加到文件中：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this code snippet, we utilized HTML to create a template for the user registration
    page. The web page in itself is simple. It contains a navigation bar and a form
    in which a user will input the required registration details for submission. As
    this is a Thymeleaf template, it should come as no surprise that we utilized some
    Thymeleaf-specific attributes. Let''s take a look at some of these attributes:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中，我们利用HTML创建了一个用户注册页面的模板。网页本身很简单。它包含一个导航栏和一个表单，用户将在其中输入所需的注册详细信息以进行提交。由于这是一个Thymeleaf模板，我们使用了一些Thymeleaf特定的属性也就不足为奇了。让我们看看其中的一些属性：
- en: '`th:href`: This is an attribute modifier attribute. When it is processed by
    the templating engine, it computes the link URL to be utilized and sets it in
    the appropriate tag in which it is used. Examples of tags that this attribute
    can be used in are `<a>` and `<link>`. We used the `th:href` attribute in the
    code snippet, as shown here:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`th:href`：这是一个属性修饰符属性。当模板引擎处理它时，它会计算要使用的链接URL并将其设置在使用的适当标签中。此属性可以用于的标签示例包括`<a>`和`<link>`。正如以下代码片段所示，我们使用了`th:href`属性：'
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`th:action`: This attribute works just like the HTML action attribute. It specifies
    where to send the form data when a form is submitted. The following code snippet
    specifies that the form data should be sent to an endpoint with the path `/users/registrations`:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`th:action`：此属性的工作方式与HTML action属性相同。它指定在表单提交时将表单数据发送到何处。以下代码片段指定表单数据应发送到路径为`/users/registrations`的端点：'
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`th:text`: This attribute is used to specify the text held by a container:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`th:text`：此属性用于指定容器中持有的文本：'
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`th:if`: This attribute can be used to specify whether an HTML tag should be
    rendered based on the result of a conditional test:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`th:if`：此属性可以用来指定是否根据条件测试的结果渲染HTML标签：'
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this code snippet, if a model attribute error exists and its value is not
    equal to null, then the `span` tag is rendered on the HTML page; otherwise, it
    is not rendered.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中，如果存在模型属性错误且其值不等于null，则`span`标签将在HTML页面上渲染；否则，它不会被渲染。
- en: 'We also made use of `th:if` in our navigation bar to specify when it should
    display a button permitting a user to log out of their account:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在导航栏中使用了`th:if`来指定何时显示允许用户注销账户的按钮：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If the `principal` model attribute is set in the template and it is not `null`,
    then the sign out button is displayed. The `principal` will always be null unless
    the user is logged in to their account.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模板中的`principal`模型属性被设置且不是`null`，则显示注销按钮。除非用户已登录其账户，否则`principal`始终为`null`。
- en: How we added the navigation bar to our template directly may appear to be all
    right at first glance but it is important we put more thought into what we did.
    It is not uncommon to make use of a navigation bar DOM element more than once
    within an application. In fact, this is done very often! We do not want to have
    to keep rewriting this same code for a navigation bar over and over again in our
    templates. To avoid this unnecessary repetition, we need to implement the navigation
    bar as a fragment that can be included at any time within a template.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们直接将导航栏添加到模板中的做法，乍一看可能看起来没问题，但重要的是我们要对我们的做法进行更多思考。在应用程序中多次使用导航栏DOM元素并不罕见。事实上，这种情况非常常见！我们不希望在模板中反复重写相同的导航栏代码。为了避免这种不必要的重复，我们需要将导航栏实现为一个可以在模板中随时包含的片段。
- en: 'Create a `fragments` directory within `templates` and add a `navbar.html` file
    with the following code to it:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在`templates`目录下创建一个`fragments`目录，并向其中添加一个`navbar.html`文件，包含以下代码：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this code snippet, we defined a navigation bar fragment available for inclusion
    in templates with the `th:fragment` attribute. A defined fragment can be inserted
    at any time within a template with the use of `th:insert`. Modify the inner HTML
    of the `<body>` tag in `register.html` to make use of the newly defined fragment
    as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中，我们定义了一个可用于在模板中包含的导航栏片段，并使用`th:fragment`属性。定义的片段可以在模板中的任何位置使用`th:insert`插入。按照以下方式修改`register.html`中的`<body>`标签的内部HTML，以使用新定义的片段：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As can already be seen, the separation of our navigation bar HTML into a fragment
    has made our code more succinct and will contribute positively to the quality
    of our developed templates.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如已所见，将我们的导航栏HTML代码分离成片段，使我们的代码更加简洁，并将对开发模板的质量产生积极影响。
- en: Having created the necessary template for the user registration page, we need
    to create a controller that will render this template to a visitor of the site.
    Let's create an application controller. Its job will be to render the web pages
    of the *Place Reviewer* application to a user upon request.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了用户注册页面的必要模板之后，我们需要创建一个控制器，用于将此模板渲染给网站的访客。让我们创建一个应用程序控制器。它的任务将在用户请求时渲染`Place
    Reviewer`应用程序的网页。
- en: 'Add the `ApplicationController` class, shown here, to the controller package:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下所示的`ApplicationController`类添加到控制器包中：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Nothing special is being done in the code snippet here. We created an MVC controller
    with a single action that handles a HTTP `GET` request to the `/register` path
    by rendering the `register.html` view to the user.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中，没有进行任何特殊操作。我们创建了一个MVC控制器，包含一个处理对`/register`路径的HTTP `GET`请求的动作，通过渲染`register.html`视图给用户。
- en: 'We are almost ready to view our newly created registration page. Before we
    check it out, we must add the `app.css` file required by `register.html`. Static
    resources such as CSS files should be added to the `static` directory within the
    application `resource` directory. Add a `css` directory within the `static` directory
    and add an `app.css` file containing the code shown here to it:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎准备好查看新创建的注册页面了。在我们检查它之前，我们必须添加`register.html`所需的`app.css`文件。CSS文件等静态资源应添加到应用程序`resource`目录下的`static`目录中。在`static`目录下添加一个`css`目录，并向其中添加一个包含以下代码的`app.css`文件：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Great work! Now, go ahead and run the *Place Reviewer* application. Upon starting
    the app, open your favorite browser and access the web page residing at `http://localhost:5000/register`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！现在，继续运行`Place Reviewer`应用程序。启动应用程序后，打开您最喜欢的浏览器，访问位于`http://localhost:5000/register`的网页。
- en: 'Now, we must implement the logic involved in registering the user. To do this,
    we must declare an action that accepts the form data sent by the registration
    form and appropriately processes the data, with the goal of registering the user
    successfully on the platform. If you recall, we specified that the form data should
    be sent via `POST` to `/users/registrations`. Consequently, we need an action
    that handles such a HTTP request. Add a `UserController` class to the `com.example.placereviewer.controller`
    package with the code shown here:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须实现注册用户涉及的逻辑。为此，我们必须声明一个动作，该动作接受注册表单发送的表单数据，并适当处理数据，目标是成功在平台上注册用户。如果你还记得，我们指定表单数据应该通过`POST`发送到`/users/registrations`。因此，我们需要一个处理此类HTTP请求的动作。将`UserController`类添加到`com.example.placereviewer.controller`包中，代码如下：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`create()` handles HTTP `POST` requests sent to `/users/registrations`. It
    takes three arguments. The first is form, which is an object of the `User` class.
    `@ModelAttribute` is used to annotate `form`. `@ModelAttribute` indicates that
    the argument should be retrieved by the model. The form model attribute is populated
    by data submitted by the form to the endpoint. The `username`, `email`, and `password`
    parameters are all submitted by the registration form. All objects of type `User`
    have `username`, `email`, and `password` properties, hence the data submitted
    by the form is assigned to the corresponding model properties.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`create()`处理发送到`/users/registrations`的HTTP `POST`请求。它接受三个参数。第一个是表单，它是`User`类的一个对象。`@ModelAttribute`用于注释`form`。`@ModelAttribute`表示应该通过模型检索参数。表单模型属性由表单提交到端点的数据填充。`username`、`email`和`password`参数都是由注册表单提交的。所有类型的`User`对象都有`username`、`email`和`password`属性，因此表单提交的数据被分配给相应的模型属性。'
- en: The second argument of the function is an instance of `BindingResult`. `BindingResult`
    serves as a result holder for `DataBinder`. In this case, we used it to bind results
    of the validation process done by a `UserValidator`, which we are going to create
    in a bit. The third argument is a `Model`. We use this to add attributes to our
    model for subsequent access by the view layer.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的第二个参数是`BindingResult`的一个实例。`BindingResult`作为`DataBinder`的结果持有者。在这种情况下，我们使用它来绑定由`UserValidator`完成的验证过程的结果，我们将在稍后创建它。第三个参数是`Model`。我们使用它来向我们的模型添加属性，以便后续由视图层访问。
- en: 'Before proceeding further with explanations pertaining to the logic implemented
    in the `create()` action, we must implement both `UserValidator` and `SecurityService`.
    `UserValidator` has the sole task of validating user information submitted to
    the backend. Create a `com.example.placereviewer.component` package and include
    the `UserValidator` class here to it:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在进一步解释`create()`动作中实现的逻辑之前，我们必须实现`UserValidator`和`SecurityService`。`UserValidator`的唯一任务是验证提交给后端的用户信息。创建一个`com.example.placereviewer.component`包，并将`UserValidator`类包含在其中：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Validating that submitted user parameters are not empty. An empty parameter
    is rejected with an error code and error message:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 验证提交的用户参数不为空。空参数被错误代码和错误消息拒绝：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Validating the length of a submitted username. A username whose length is less
    than 6 is rejected:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 验证提交的用户名长度。长度小于6的用户名被拒绝：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Validating the submitted username does not already exist. A username already
    taken by a user is rejected:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 验证提交的用户名尚未被占用。已被用户占用的用户名被拒绝：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Validating the length of a submitted password. Passwords less than 8 characters
    in length are rejected:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 验证提交的密码长度。长度小于8个字符的密码被拒绝：
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`UserValidator` implements the `Validator` interface, which is used to validate
    objects. As such, it overrides two methods: `supports(Class<*>?)` and `validate(Any?,
    Errors)`. `supports()` is used to assert that the validator can validate the object
    supplied to it. In the case of `UserValidator`, `supports()` asserts that the
    supplied object is an instance of the `User` class. Hence, all objects of type
    `User` are supported for validation by `UserValidator`.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserValidator`实现了`Validator`接口，该接口用于验证对象。因此，它覆盖了两个方法：`supports(Class<*>?)`和`validate(Any?,
    Errors)`。`supports()`用于断言验证器可以验证它提供的对象。在`UserValidator`的情况下，`supports()`断言提供的对象是`User`类的一个实例。因此，`UserValidator`支持所有类型的`User`对象进行验证。'
- en: '`validate()` validates the provided objects. In cases where validation rejections
    occur, it registers the error with the provided `Error` object. Ensure you read
    through the comments placed within the body of the `validate()` method to get
    a better grasp of what is going on within the method.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`validate()`验证提供的对象。在验证拒绝的情况下，它将错误注册到提供的`Error`对象中。确保您阅读`validate()`方法体内的注释，以更好地了解方法内部发生的情况。'
- en: Now, we shall work on `SecurityService`. We will implement a `SecurityService`
    to facilitate the identification of the currently logged in user and the automatic
    login of a user after their registration.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将着手实现`SecurityService`。我们将实现一个`SecurityService`以方便识别当前登录用户以及在用户注册后的自动登录。
- en: 'Add the `SecurityService` interface here to `com.example.placereviewer.service`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里将`SecurityService`接口添加到`com.example.placereviewer.service`：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, add a `SecurityServiceImpl` class to `com.example.placereviewer.service`.
    As the name suggests, `SecurityServiceImpl` implements `SecurityService`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，向`com.example.placereviewer.service`添加一个`SecurityServiceImpl`类。正如其名所示，`SecurityServiceImpl`实现了`SecurityService`：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`findLoggedInUser()` returns the username of the currently logged in user.
    `Username` retrieval is done with the help of Spring Framework''s `SecurityContextHolder`
    class. An instance of `UserDetails` is retrieved by accessing the logged in user''s
    authentication details with a call to `SecurityContextHolder.getContext().authentication.details`.
    It is important to note that `SecurityContextHolder.getContext().authentication.details`
    returns an `Object` and not an instance of `UserDetails`. As such, we must do
    a type check to assert that the object retrieved conforms to the type `UserDetails`
    as well. If it does, we return the username of the currently logged in user. Otherwise,
    we return null.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`findLoggedInUser()`返回当前登录用户的用户名。通过调用`SecurityContextHolder.getContext().authentication.details`来使用Spring框架的`SecurityContextHolder`类检索`Username`。需要注意的是，`SecurityContextHolder.getContext().authentication.details`返回一个`Object`而不是`UserDetails`的实例。因此，我们必须进行类型检查以确保检索到的对象符合`UserDetails`类型。如果是，我们返回当前登录用户的用户名。否则，我们返回null。'
- en: The `autoLogin()` method will be used for the simple task of authenticating
    a user after registering on the platform. The submitted username and password
    of the user are passed as arguments to `autoLogin()`, after which an instance
    of `UsernamePasswordAuthenticationToken` is created for the registered user. Once
    an instance of `UsernamePasswordAuthenticationToken` is created, we utilize `AuthenticationManager`
    to authenticate the user's token. If `UsernamePasswordAuthenticationToken` is
    successfully authenticated, we set the authentication property of the current
    user to `UsernamePasswordAuthenticationToken`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`autoLogin()`方法将用于在平台上注册后对用户进行简单认证的任务。用户的提交用户名和密码作为参数传递给`autoLogin()`，之后为注册用户创建一个`UsernamePasswordAuthenticationToken`实例。一旦创建了`UsernamePasswordAuthenticationToken`实例，我们就利用`AuthenticationManager`来验证用户的令牌。如果`UsernamePasswordAuthenticationToken`成功验证，我们将当前用户的认证属性设置为`UsernamePasswordAuthenticationToken`。'
- en: 'Having made our necessary class additions, let''s return to our `UserController`
    to finish up our explanation of the create action. Within `create()`, first and
    foremost the submitted form input is validated with an instance of `UserValidator`.
    Errors arising during the course of form data validation are all bound to the
    instance of `BindingResult` injected into our controller by Spring. Consider these
    lines of code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了必要的类之后，让我们回到`UserController`以完成对创建操作的说明。在`create()`方法中，首先使用`UserValidator`实例验证提交的表单输入。在表单数据验证过程中出现的所有错误都绑定到由Spring注入到我们的控制器中的`BindingResult`实例。考虑以下代码行：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`bindingResult` is first checked to assert whether any errors occurred during
    form data validation. If errors occurred, we retrieve the message of the first
    error detected and set a `model` attribute error to hold the error message for
    later access by the view. In addition, we create `model` attributes to hold each
    input submitted by the user. Lastly, we re-render the registration view to the
    user.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 首先检查`bindingResult`以确认在表单数据验证过程中是否发生了任何错误。如果发生错误，我们检索第一个检测到的错误的消息，并将错误消息设置为一个`model`属性错误，以便稍后由视图访问。此外，我们创建`model`属性来保存用户提交的每个输入。最后，我们将注册视图重新渲染给用户。
- en: 'Notice how we made multiple method invocations for the same `Model` instance
    in the previous code snippet. There is a much cleaner way we can do this. This
    involves the use of Kotlin''s `with` function:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们在之前的代码片段中是如何对同一个`Model`实例进行多次方法调用的。我们可以用一种更干净的方式来做这件事。这涉及到Kotlin的`with`函数的使用：
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: See how easy and convenient the function is to use? Go ahead and modify `UserController`
    to make use of `with`, as shown in the preceding code.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个函数使用起来有多简单、方便？继续修改`UserController`，使其使用`with`，如前述代码所示。
- en: You may be wondering why we decided to store a user's submitted data in model
    attributes. We did this to have a way to reset the data contained in the registration
    form to what was originally submitted after the re-rendering of the registration
    view. It will certainly be frustrating for a user to have to input all form data
    over and over, even if only one form input entered is invalid.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道我们为什么决定将用户提交的数据存储在模型属性中。我们这样做是为了在重新渲染注册视图后，有一种方法可以将注册表单中包含的数据重置为最初提交的内容。如果只有一个表单输入无效，用户不得不反复输入所有表单数据，这肯定会让人感到沮丧。
- en: 'When no input submitted by the user is invalid, the following code runs:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户提交的所有输入都无效时，以下代码会运行：
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As expected, when the data submitted by a user is valid, he is registered on
    the platform and logged in to his account automatically. Lastly, he is redirected
    to his home page. Before we try out our registration form, we must do two things:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，当用户提交的数据有效时，他将在平台上注册并自动登录到他的账户。最后，他将被重定向到他的主页。在我们尝试我们的注册表单之前，我们必须做两件事：
- en: Utilize the model attributes specified in `register.html`
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用`register.html`中指定的模型属性
- en: Create a `home.html` template and a controller to render the template
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`home.html`模板和一个控制器来渲染该模板
- en: 'Luckily for us, both are rather simple to do. First, to utilize the `model`
    attributes. Modify the form contained in `register.html` as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这两者都相当简单。首先，为了利用`model`属性。按照以下方式修改`register.html`中的表单：
- en: '[PRE22]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Can you spot the changes we made? If you said we used Thymeleaf''s `th:value`
    template attribute to preset the value held by form inputs to their respective
    `model` attribute values, you are right. Now, let''s make a simple `home.html`
    template. Add the `home.html` template here to the `templates` directory:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你能发现我们做了哪些改动吗？如果你说我们使用了Thymeleaf的`th:value`模板属性来预置表单输入所持有的值与相应的`model`属性值，你就对了。现在，让我们制作一个简单的`home.html`模板。将`home.html`模板添加到`templates`目录中：
- en: '[PRE23]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, update `ApplicationController` to include an action handling GET requests
    to `/home`, as shown here:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，更新`ApplicationController`以包括处理GET请求到`/home`的操作，如下所示：
- en: '[PRE24]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `home` action retrieves a list of all reviews stored within the database.
    In addition, the home action sets a model attribute that holds a principal containing
    information on the currently logged in user. Lastly, the home action renders the
    home page to the user.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`home`操作检索数据库中存储的所有评论列表。此外，`home`操作设置一个模型属性，该属性包含有关当前登录用户的信息。最后，`home`操作将主页渲染给用户。'
- en: Having done what's necessary, let's register a user on the Place Reviewer platform.
    Build and run the application, and access the registration page from your browser
    (`http://localhost:5000/register`). Firstly, we want to check whether our form
    validations work by inputting and submitting invalid form data.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 完成必要的步骤后，让我们在Place Reviewer平台上注册一个用户。构建并运行应用程序，然后从您的浏览器中访问注册页面（`http://localhost:5000/register`）。首先，我们想通过输入和提交无效的表单数据来检查我们的表单验证是否工作。
- en: '![](img/f81ca59e-618a-4099-a07a-0489a4c34d36.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f81ca59e-618a-4099-a07a-0489a4c34d36.jpg)'
- en: 'As can be seen, the error was detected by `UserValidator` and was successfully
    bound to `BindingResult`, then rendered appropriately as an error in the view.
    Feel free to enter invalid data for other form inputs and ensure the other validations
    we implemented work as expected. Now to verify that our registration logic works.
    Input `king.kevin`, `king.k@gmail.com`, and `Kingsman406` in the username, email,
    and password fields, then click Sign Up! A new account will be created and you
    will be presented with the home page:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如上图所示，错误被`UserValidator`检测到，并成功绑定到`BindingResult`，然后在视图中适当地显示为错误。请随意输入其他表单输入的无效数据，并确保我们实现的其它验证按预期工作。现在来验证我们的注册逻辑。在用户名、电子邮件和密码字段中输入`king.kevin`、`king.k@gmail.com`和`Kingsman406`，然后点击注册！将创建一个新的账户，并将主页展示给你：
- en: '![](img/8c56c444-e7e3-4a30-a9de-9b7a7ff1242e.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8c56c444-e7e3-4a30-a9de-9b7a7ff1242e.jpg)'
- en: It will come as no surprise to you that we are going to make serious modifications
    to the home page over the course of this chapter. However, for now let's turn
    our attention towards creating a suitable user login page.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将对主页进行重大修改，这对你来说可能不会感到惊讶。然而，现在让我们将注意力转向创建一个合适的用户登录页面。
- en: Implementing the login view
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现登录视图
- en: Similar to how we went about implementing the user registration view, first
    and foremost we must work on the view template. The template required for the
    login view must possess a form that takes the username and password of the user
    to be logged in as input. We must also provide a button that facilitates the submission
    of the login form—after all, there is no point having a form if it cannot be submitted.
    In addition, we must have a means of alerting the user if something goes wrong
    with the login process, such as in a scenario where the user enters an invalid
    username and password combination. Lastly, we should provide a link to the account
    registration page for situations where the viewer of the login page does not already
    possess an account.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们实现用户注册视图的方式类似，首先我们必须处理视图模板。登录视图所需的模板必须包含一个表单，该表单接受要登录的用户名和密码作为输入。我们还必须提供一个按钮，以便用户可以提交登录表单——毕竟，如果表单无法提交，那么它就没有意义。此外，我们必须有一种方法来提醒用户登录过程中可能出现的错误，例如在用户输入无效的用户名和密码组合的情况下。最后，我们应该提供一个链接到账户注册页面，以便登录页面的查看者尚未拥有账户。
- en: 'Having identified what is needed from the template to be implemented, let''s
    go ahead with creating it. Add a `login.html` file to the template directory.
    Now, it is time to work on the template. As always, we must first include the
    necessary stylesheets and scripts to the template. This is done in the following
    code snippet:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定了模板中需要实现的内容后，让我们继续创建它。将一个`login.html`文件添加到模板目录中。现在，是时候开始处理模板了。和往常一样，我们首先需要将必要的样式表和脚本包含到模板中。这可以通过以下代码片段完成：
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Having added the style and JavaScript includes necessary for the template,
    we can now work on the `<body>` of the template. As we have said before, the body
    of an HTML template contains the DOM elements that will be rendered to the user
    upon page load. Add the following code within the `<body>` tag of `login.html`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了模板所需的样式和JavaScript包含后，我们现在可以开始处理模板的`<body>`部分。正如我们之前所说的，HTML模板的主体包含在页面加载时将渲染给用户的DOM元素。在`login.html`的`<body>`标签内添加以下代码：
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'With the body added, the HTML we have created sufficiently describes the required structure
    of our login page. Along with adding the required form, we added the navigation
    bar fragment created earlier to the page—no need to write boilerplate code. We
    also added a means by which a user can be provided feedback pertaining to errors
    that may arise in the login process. This was done with the following lines:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了主体后，我们创建的HTML已经足够描述我们登录页面所需的结构。除了添加必要的表单，我们还添加了之前创建的导航栏片段到页面中——无需编写样板代码。我们还添加了一种方式，用户可以通过它获得有关登录过程中可能出现的错误反馈。这是通过以下几行代码实现的：
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When `param.error` is set, it signifies that an error has occurred during user login,
    so an Invalid username and password combination message is shown to the user.
    Something to keep in mind is that besides the login page often being the first
    point of contact a user has with a web application, it can also be a user''s last
    point of contact with the app during an interaction session. This is particularly
    true in the case of user logouts. After a user is done interacting with an application
    and logs out, they should be redirected to a login screen. As a result of such
    a possibility, we added some text to notify a user that they''ve been logged out:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当`param.error`被设置时，表示在用户登录过程中发生了错误，因此向用户显示一个无效的用户名和密码组合信息。需要注意的是，登录页面通常是用户与Web应用接触的第一个点，也可能是用户在会话期间与该应用的最后一个接触点。这在用户注销的情况下尤其如此。当用户完成与应用的交互并注销后，他们应该被重定向到登录屏幕。由于这种可能性，我们在通知用户他们已被注销的文本中添加了一些内容：
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `<div>` tag is displayed to a user after a successful logout from their
    account. At this point, ideally we should implement a controller to render `login.html`
    but if you recall, we have already done so with the use of a custom Spring MVC
    configuration via our implemented `MvcConfig` class, specifically in the section
    of code shown here:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户成功注销账户后，会显示一个`<div>`标签。在这个时候，理想情况下我们应该实现一个控制器来渲染`login.html`，但如果你记得，我们已经通过使用自定义Spring
    MVC配置以及我们实现的`MvcConfig`类来做到了这一点，具体代码如下：
- en: '[PRE29]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We made use of a `ViewControllerRegistry` instance to add a view controller
    that handles requests to `/login` and set the view to be used to the just-implemented
    login template. Build and run the application to view the newly implemented view.
    The web page can be accessed via `http:localhost:5000/login`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`ViewControllerRegistry`实例添加了一个处理`/login`请求的视图控制器，并将要使用的视图设置为刚刚实现的登录模板。构建并运行应用程序以查看新实现的视图。可以通过`http:localhost:5000/login`访问网页：
- en: '![](img/1abef211-e0f7-47fc-bcbd-6111ec85f1ae.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1abef211-e0f7-47fc-bcbd-6111ec85f1ae.jpg)'
- en: 'Trying to log in with invalid user credentials will present us with a nice
    error message:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用无效的用户凭据尝试登录会显示一个友好的错误消息：
- en: '![](img/1e84dfa3-3a45-450a-9faa-239f89217747.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1e84dfa3-3a45-450a-9faa-239f89217747.jpg)'
- en: On the other hand, attempting to log in with valid credentials takes us to the
    application's home page. Speaking of the home page, we need to work on completing
    its view layer. We are going to need to work directly with the Google Places API
    from this point onward. As such, we must set up our application to do so before
    proceeding.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，使用有效的凭据尝试登录将带我们到应用程序的主页。说到主页，我们需要完成其视图层的工作。从现在开始，我们将直接与Google Places API进行工作。因此，在继续之前，我们必须设置我们的应用程序以这样做。
- en: Setting up the Place Reviewer app with the Google Places API web service
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Google Places API Web服务设置Place Reviewer应用程序
- en: 'The process of setting up a web application with the Google Places API is quick
    and painless and can be completed in well under five minutes. All in all, the
    setup can be done in two easy steps:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Google Places API设置Web应用程序的过程快速且无痛苦，可以在五分钟内完成。总的来说，设置可以在两个简单步骤中完成：
- en: Get an API key
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取API密钥
- en: Include the Google Places API in your web application
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Google Places API集成到您的Web应用程序中
- en: Getting an API key
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取API密钥
- en: 'An API key can be gotten by visiting [https://developers.google.com/places/web-service/get-api-key](https://developers.google.com/places/web-service/get-api-key),
    scrolling to the Get an API key section, and clicking the GET A KEY button:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通过访问[https://developers.google.com/places/web-service/get-api-key](https://developers.google.com/places/web-service/get-api-key)，滚动到“获取API密钥”部分，并点击“GET
    A KEY”按钮，可以获取一个API密钥：
- en: '![](img/f55d2dd7-061f-4079-8ecc-d0be79e2cd85.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f55d2dd7-061f-4079-8ecc-d0be79e2cd85.jpg)'
- en: 'Upon clicking the button, you will be presented with a modal from which you
    can select or create a project to be integrated with the Google Places API Web
    Service. Click on the dropdown and select Create a new project. You will be requested
    to provide a project name. Input `Place Reviewer` as the project name:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 点击按钮后，您将看到一个模态窗口，您可以从中选择或创建一个要集成到Google Places API Web服务中的项目。点击下拉菜单并选择“创建新项目”。您将被要求提供项目名称。输入“Place
    Reviewer”作为项目名称：
- en: '![](img/91ef273c-e70e-4de6-a602-22e43f3a2e84.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/91ef273c-e70e-4de6-a602-22e43f3a2e84.jpg)'
- en: After providing a project name, click NEXT to proceed. Your project will be
    set up for use with the API and you will be presented with an API key to use!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 提供项目名称后，点击“下一步”继续。您的项目将配置为使用API，并将向您展示一个可使用的API密钥！
- en: '![](img/af8f5a3a-672d-4f18-92d7-f7c5d31b017a.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/af8f5a3a-672d-4f18-92d7-f7c5d31b017a.jpg)'
- en: Now that we have an API key, let's have a look at how to use it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了API密钥，让我们看看如何使用它。
- en: Including Google Places API in your web application
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Google Places API集成到您的Web应用程序中
- en: 'Utilizing an API key for the Google Places API Web Service is just as easy—if
    not easier—as generating the API key. To make use of a generated API key in your
    web application, all that is necessary is the inclusion of the following line
    of HTML in the markup of the page you want to make use of the web service:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 利用Google Places API Web服务的API密钥就像生成API密钥一样简单——如果不是更简单的话。要在您的Web应用程序中使用生成的API密钥，只需在您想要使用Web服务的页面标记中包含以下HTML行即可：
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Ensure you replace  `{{API_KEY}}` with your generated API key.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将`{{API_KEY}}`替换为您生成的API密钥。
- en: Implementing the home view
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现主页视图
- en: As expected, at this point it will be required of us to do a bit of coding.
    In keeping with practices we have adhered to in previous chapters, it will be
    wise of us to firstly make a barebones graphical mockup of the view we want to
    create before commencing with coding. This will save a significant amount of time
    in the long run by providing a clear direction regarding what we want to build.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，在这个阶段，我们将需要做一些编码工作。按照我们在前几章中遵循的实践，在我们开始编码之前，首先制作一个我们想要创建的视图的裸骨图形草图是明智的。这将通过提供关于我们想要构建的清晰方向，在长期内节省大量时间。
- en: 'We want the home page we are creating to do the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们正在创建的首页能够做到以下：
- en: Show the latest place reviews posted on the platform
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示平台上发布的最新地点评论
- en: Provide direct access to a web page for review creation
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供直接访问创建审查网页的方式
- en: Provide a means by which a user can sign out of their account
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供一种用户可以注销其账户的方式
- en: Enable a user to view the exact location of a reviewed place with the help of
    a map
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用地图帮助用户查看已审查地点的确切位置
- en: 'Keeping all these requirements in mind, we can draw a rough sketch of our final
    template that looks something like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些要求，我们可以绘制一个最终模板的粗略草图，看起来像这样：
- en: '![](img/1c83f661-e849-49e5-a7a7-91635775d9fd.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1c83f661-e849-49e5-a7a7-91635775d9fd.jpg)'
- en: We are aiming for functionality over flash in our layout design. You can see
    that layout requirements one through four are immediately satisfied by this sketch.
    Clicking on View location will present the user of the application with a modal
    within which a map showing the exact place reviewed will be displayed.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的布局设计中，我们追求的是功能而非闪存。你可以看到，这个草图立即满足了布局要求一至四。点击“查看位置”将向应用程序用户展示一个模态窗口，其中将显示已审查的确切位置的地图。
- en: 'Having clearly stated the template we will be creating, let us code. As always,
    first and foremost we need to include external stylesheets and scripts to our
    template. Open up `home.html` and add the following code to it:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 明确说明了我们将要创建的模板后，让我们开始编码。和往常一样，首先和最重要的是，我们需要将外部样式表和脚本包含到我们的模板中。打开`home.html`并添加以下代码：
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Nice work! In addition to external stylesheets, we are going to make use of
    internal styles in this template. To define internal stylesheets in HTML files,
    simply add a `<style>` tag within the head of the HTML and input your desired
    CSS rules. Add the following style to `home.html`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 很好！除了外部样式表，我们还将在这个模板中使用内部样式。要在HTML文件中定义内部样式表，只需在HTML的头部添加一个`<style>`标签，并输入你想要的CSS规则。将以下样式添加到`home.html`：
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, lets work on the body of the page. As you already know, all elements that
    make up the body of an HTML template must exist in a `<body>`  tag. With that
    in mind, we can work on `home.html`. Start by adding the following HTML to the
    template file:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始处理页面的主体。正如你所知，组成HTML模板主体的所有元素都必须存在于一个`<body>`标签中。考虑到这一点，我们可以开始处理`home.html`。首先，将以下HTML添加到模板文件中：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Great job! Do not worry too much about what the preceding code block does as
    of now. We shall explain everything in due time. Moving on continue the body of
    `home.html` by adding the following lines of code to it:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！现在不必太担心前面的代码块做了什么。我们将在适当的时候解释一切。继续在`home.html`的主体中添加以下代码行：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The preceding code declares a modal that will hold a map displaying the exact
    location a review was created—upon the request of the user. We are not done with
    the home template yet. Continue work on the `<body>`  further by adding the following
    lines of code to it:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码声明了一个模态，其中将包含显示评论创建的确切位置的地图——根据用户的请求。我们还没有完成首页模板。继续在`<body>`中添加以下代码行：
- en: '[PRE35]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, add internal JavaScript for the HTML page:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为HTML页面添加内部JavaScript：
- en: '[PRE36]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following function initializes and displays a map showing the location
    where a review was written:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数初始化并显示一个地图，显示撰写评论的位置：
- en: '[PRE37]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Load place marker creates a map marker on the reviewed location:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 加载地点标记在已审查的位置创建地图标记：
- en: '[PRE38]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Quite a lot has been done on `home.html`, so let''s talk a bit about what exactly
    is going on in the view, starting with the `<head>` tag. We included stylesheets
    and scripts required by the home page from lines 4 through 16 of the `<head>`
    tag. The CSS included is as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在`home.html`上已经做了很多工作，所以让我们谈谈视图中的具体内容，从`<head>`标签开始。我们从`<head>`标签的第4行到第16行包含了主页所需的样式表和脚本。包含的CSS如下：
- en: '[PRE39]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: These are external stylesheet inclusions for our application's CSS; Toastr,
    a library for the creation of JavaScript toast notifications; Bootstrap, a powerful
    library for designing websites and web applications; **Font Awesome**, an icon
    toolkit for websites and web applications; and buttons, a powerful and highly
    customizable web and CSS buttons library.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们应用程序CSS的外部样式表包含；Toastr，一个用于创建JavaScript toast通知的库；Bootstrap，一个用于设计和开发网站及Web应用程序的强大库；**Font
    Awesome**，一个用于网站和Web应用程序的图标工具包；以及按钮，一个功能强大且高度可定制的Web和CSS按钮库。
- en: 'Right after the CSS inclusions, we have a number of external JavaScript inclusions
    as well:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在CSS包含之后，我们还有一系列外部JavaScript包含：
- en: '[PRE40]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The script inclusions in their respective order are for: JQuery, a JavaScript
    library designed specifically to simplify the client-side HTML scripting process;
    Toastr; Popper, a library used to manage poppers in web applications; Bootstrap;
    buttons; and the Google Places API web service. Once again, ensure you replace
    the `{{API_KEY}}` with your API key for the Google Places API web service—this
    is important.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 按照各自的顺序，脚本包含是为了：JQuery，一个专门设计来简化客户端HTML脚本过程的JavaScript库；Toastr；Popper，一个用于管理Web应用程序中popper的库；Bootstrap；buttons；以及Google
    Places API Web服务。再次提醒，确保将 `{{API_KEY}}` 替换为Google Places API Web服务的API密钥——这一点很重要。
- en: 'Immediately after the JavaScript inclusions, we defined an internal stylesheet
    for the web page. Unfortunately, an explanation of stylesheets and their creation
    is beyond the scope of this book. However, it will be a good idea to brush up
    on CSS in your spare time. Further down `home.html`, we added a `<body>` tag as
    follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript包含之后，我们定义了一个网页的内部样式表。不幸的是，关于样式表及其创建的解释超出了本书的范围。然而，在业余时间复习CSS将是一个好主意。在
    `home.html` 的下方，我们添加了如下 `<body>` 标签：
- en: '[PRE41]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`th:onload` in this is used to specify JavaScript that must be run after the
    page has been completely loaded. In short, it specifies code to be executed after
    an `onload` event occurs. In this case, the script to be run is a JavaScript function
    we defined further down the template, `showNoReviewNotification(boolean)`.  The
    function shows a toast message indicating that no reviews are available to be
    viewed when the reviews list provided by the model is empty. `showNoReviewNotification(boolean)`
    is declared in our template as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`th:onload` 用于指定在页面完全加载后必须运行的JavaScript。简而言之，它指定了在 `onload` 事件发生后要执行的代码。在这种情况下，要运行的脚本是我们进一步在模板中定义的JavaScript函数
    `showNoReviewNotification(boolean)`。该函数显示一个toast消息，表明当模型提供的评论列表为空时没有可查看的评论。`showNoReviewNotification(boolean)`
    如下声明在我们的模板中：
- en: '[PRE42]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`showNoReviewNotification(boolean)` takes a single `Boolean` argument, `show`.
    When `show` is true, a toast notification with the message `No reviews to see` is
    rendered to the user. The display of toast notifications to a user is made possible
    by the Toastr library we are utilizing.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`showNoReviewNotification(boolean)` 接收一个单一的 `Boolean` 参数 `show`。当 `show` 为真时，向用户渲染一个包含消息
    “没有可查看的评论” 的toast通知。向用户显示toast通知是通过我们正在使用的Toastr库实现的。'
- en: 'When there are reviews available to be shown to the user, then a container
    is created for each review item as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当有评论可供用户查看时，就会为每个评论项创建一个容器，如下所示：
- en: '[PRE43]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Each review container displays the username of the reviewer, the name of the
    place reviewed, the review title, the review body and a button enabling the user
    to view the reviewed location. Thymeleaf''s `th:each` attribute was used to iterate
    over each review in the `reviews` list, as shown here:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 每个评论容器都会显示评论者的用户名、被评论地点的名称、评论标题、评论正文以及一个按钮，允许用户查看被评论的位置。Thymeleaf的 `th:each`
    属性被用来遍历 `reviews` 列表中的每个评论，如下所示：
- en: '[PRE44]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'A good way to understand the iteration process is by reading `th:each="review:
    ${reviews}"` as `For each review in reviews`. The review currently being iterated
    upon is held by the `review` variable. Hence, the data held by the review being
    iterated upon can be accessed like any other object. This is the case here:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '理解迭代过程的一个好方法是阅读 `th:each="review: ${reviews}"` 如同 “遍历 reviews 列表中的每个评论”。当前正在迭代的评论由
    `review` 变量持有。因此，可以像访问任何其他对象一样访问正在迭代的评论所持有的数据。这里就是这种情况：'
- en: '[PRE45]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`th:text` sets the text held by the `<div>` to the value assigned to `review.placeName`.
    It is also necessary to explain the process by which location maps are shown to
    the user. Take a close look at the following lines of code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`th:text` 将 `<div>` 中持有的文本设置为 `review.placeName` 分配的值。同时，也需要解释通过何种过程向用户展示位置地图。仔细查看以下代码行：'
- en: '[PRE46]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This code block defines a button that does two things when a click event occurs
    on it. Firstly, it displays a modal identified by the ID `mapModal` to the user.
    Secondly, it initializes and renders a map displaying the exact location that
    was reviewed. The rendering of the map is made possible by the `showLocation()`
    JavaScript function we defined in our template file.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码块定义了一个按钮，当在它上发生点击事件时执行两个操作。首先，它向用户显示一个ID为`mapModal`的模态框。其次，它初始化并渲染一个显示已评论的确切位置的地图。地图的渲染是通过我们在模板文件中定义的`showLocation()`
    JavaScript函数实现的。
- en: '`showLocation()` takes three parameters as its arguments. The first is the
    longitudinal coordinate, the second a latitudinal coordinate, and the third the
    unique identifier of the location reviewed—a place ID. The place ID for the location
    is provided by the Google Places API. Firstly, `showLocation()` retrieves a central
    point for the locational coordinates provided. This is done by utilizing the Google
    Places API''s `google.maps.LatLng` class. Simply defined, a `LatLng` is a point
    in geographical coordinates (longitude and latitude). Upon retrieving the central
    point, a new map is created with the use of the `Map` class (again, provided by
    the Google Places API) as shown in this code snippet:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`showLocation()`接受三个参数作为其参数。第一个是经度坐标，第二个是纬度坐标，第三个是已评论位置的唯一标识符——位置ID。位置ID由Google
    Places API提供。首先，`showLocation()`通过利用Google Places API的`google.maps.LatLng`类检索提供的定位坐标的中心点。简单来说，`LatLng`是地理坐标中的一个点（经度和纬度）。在检索到中心点后，使用`Map`类（同样由Google
    Places API提供）创建一个新的地图，如以下代码片段所示：'
- en: '[PRE47]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The created map is placed within a DOM container element with an ID `map`. After
    creating the necessary map, we create a location marker at the exact location
    with the help of the `loadPlaceMarker()` function. `loadPlaceMarker()` takes instances
    of `google.maps.places.PlacesService`, `Map`, and a place id as its three arguments.
    `PlacesService` is a class that possesses methods for the retrieval of place information
    and searching places.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的地图被放置在一个具有ID `map`的DOM容器元素中。在创建必要的地图后，我们使用`loadPlaceMarker()`函数在确切位置创建一个位置标记。`loadPlaceMarker()`函数接受`google.maps.places.PlacesService`、`Map`和位置ID作为其三个参数。`PlacesService`是一个具有检索位置信息和搜索位置的方法的类。
- en: The instance of `google.maps.places.PlacesService` is firstly used to retrieve
    the details of the place with the specified place ID (the reviewed location).
    If the details of the place are successfully retrieved, `status === google.maps.places.PlacesServiceStatus.OK`
    evaluates to true and a marker for the location is placed on the map. The marker
    is created with the `google.maps.Marker` class. `Marker()` takes an optional options
    object as a its sole argument. When the options object is present, the place marker
    is created with the options specified. In this case, we specified a map in the
    options object. As such, the marker is added to the map upon its creation.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`google.maps.places.PlacesService`的实例首先用于检索具有指定位置ID（已评论的位置）的位置详细信息。如果位置详细信息检索成功，`status
    === google.maps.places.PlacesServiceStatus.OK`评估为true，则在地图上放置一个位置标记。标记是通过`google.maps.Marker`类创建的。`Marker()`接受一个可选的选项对象作为其唯一参数。当存在选项对象时，使用指定的选项创建位置标记。在这种情况下，我们在选项对象中指定了一个地图。因此，在创建时，标记被添加到地图上。'
- en: 'Lastly, we added a form to our template that sends a `GET` request to the `/reviews/new`
    path upon its submission, and added a button that submits the form upon clicking.
    This was done in the lines shown here:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在模板中添加了一个表单，当提交表单时，它会向`/reviews/new`路径发送一个`GET`请求，并添加了一个按钮，点击该按钮会提交表单。这是在以下代码行中完成的：
- en: '[PRE48]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: That is all we need to do regarding the home page, so go ahead and check it
    out! Rebuild and run the application, register an account, and view the home page
    you just created!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 关于主页，我们所需做的就这些了，所以请继续检查它！重新构建并运行应用程序，注册一个账户，查看您刚刚创建的主页！
- en: '![](img/7ff0f079-ffd8-4674-9023-6ee04e65ddb2.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7ff0f079-ffd8-4674-9023-6ee04e65ddb2.jpg)'
- en: As you can see, no reviews have been created on the platform for viewing. We
    must now work on a web page that allows the creation of reviews.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，平台上尚未创建任何用于查看的评论。我们现在必须制作一个网页，允许创建评论。
- en: Implementing the review creation web page
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现评论创建网页
- en: 'Thus far, we have created views for user registration and login, as well as
    a homepage for logged in users to peruse reviews posted on the platform. We must
    now work on the view that facilitates the creation of these reviews. As always,
    first, before creating the view, let us work on an action that will be in charge
    of rendering our to-be-developed view to users. Open up the `ApplicationController`
    class and add the following method to it:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了用户注册和登录的视图，以及一个供已登录用户浏览平台上发布的评论的主页。现在我们必须着手创建一个视图，以便创建这些评论。一如既往地，首先，在创建视图之前，让我们先工作于一个负责将即将开发的视图渲染给用户的动作。打开`ApplicationController`类，并向其中添加以下方法：
- en: '[PRE49]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `createReview()` action handles HTTP `GET` requests to the `/create-review`
    request path by returning a `create-review.html` template to the client for rendering.
    Go ahead and add a `create-review.html` file to the project `template` directory.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`createReview()`动作处理对`/create-review`请求路径的HTTP `GET`请求，通过向客户端返回一个`create-review.html`模板来渲染。现在，请将`create-review.html`文件添加到项目的`template`目录中。'
- en: 'Similar to what we did before, let''s begin by adding external styles and scripts
    to `create-review.html`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前所做的一样，让我们首先在`create-review.html`中添加外部样式和脚本：
- en: '[PRE50]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, add our required internal stylesheet for the webpage:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加我们网页所需的内部样式表：
- en: '[PRE51]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The next thing on our agenda is the creation of the necessary form for the
    input of review data. Continue the `create-review.html` template with the following
    code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一步要做的事情是创建必要的表单，以便输入评论数据。在`create-review.html`模板中继续以下代码：
- en: '[PRE52]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, let us add a modal that will enable the user to select the review location
    from a map. Do not worry too much about the details of the selection process as
    of now. We shall talk more on it shortly:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个模态框，使用户能够从地图中选择评论位置。目前不必过于担心选择过程的细节。我们稍后会详细讨论：
- en: '[PRE53]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'And lastly, we finish up the template by including its internal JavaScript,
    as shown in the code snippets that follow:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过包含以下代码片段中的内部JavaScript来完成模板：
- en: '[PRE54]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In the preceding code snippet, we created references to important DOM elements
    that exist on the page. These references include references to place specific
    input fields (the fields for the address, name, ID, and latitudinal and longitudinal
    coordinates of a place). In addition, we added references for the containers displaying
    the details of a selected place, such as the place name and place address. At
    this juncture, we will declare a few functions. These functions are `initialize()`,
    `getPlaceDetailsById()`, `updateViewData()`, `setFormValues()`, `showSelectionsStatusContainer()`,
    and `setContainerText()`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们创建了页面中存在的关键DOM元素的引用。这些引用包括对特定地点输入字段的引用（地址、名称、ID以及地点的经纬度坐标字段）。此外，我们还添加了显示所选地点详细信息的容器引用，例如地点名称和地点地址。在此阶段，我们将声明几个函数。这些函数是`initialize()`、`getPlaceDetailsById()`、`updateViewData()`、`setFormValues()`、`showSelectionsStatusContainer()`和`setContainerText()`。
- en: 'Start by adding the `initialize()` and `getPlaceDetailsById()` functions shown
    here to the template:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将这里显示的`initialize()`和`getPlaceDetailsById()`函数添加到模板中：
- en: '[PRE55]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We have added the function below to enable us to get the details of a particular
    place from the Google Places API Invoked to retrieve the details of a place:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了以下函数，以便从调用的Google Places API中获取特定地点的详细信息：
- en: '[PRE56]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, add `updateView()` and `setFormValues()` as shown here:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加`updateView()`和`setFormValues()`，如下所示：
- en: '[PRE57]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The function below is called to update view form data:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数被调用以更新视图表单数据：
- en: '[PRE58]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Finally, finish up the template by adding the code shown here:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过添加以下代码来完成模板：
- en: '[PRE59]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Similar to the previous template, we begin `create-review.html`  with the addition
    of both external and internal CSS and JavaScript required by the template in the
    HTML `<head>` tag. Further into the template, we create a form that takes the
    following form data as its input:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的模板类似，我们以添加模板在HTML `<head>`标签中所需的内外部CSS和JavaScript开始`create-review.html`。在模板的进一步部分，我们创建了一个表单，它接受以下表单数据作为输入：
- en: '`title`: A user defined title for the review being created.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`: 用户为创建的评论定义的标题。'
- en: '`body`: The body of the review. This is the main review text.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`body`: 评论的主体。这是主要的评论文本。'
- en: '`placeAddress`: The address of the place being reviewed.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`placeAddress`: 被评论地点的地址。'
- en: '`placeName`: The name of the place being reviewed.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`placeName`: 被评论地点的名称。'
- en: '`placeId`: The unique ID of the location being reviewed.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`placeId`: 被评论地点的唯一ID。'
- en: '`latitude`: The latitudinal coordinate of the reviewed location.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`latitude`：被评论地点的纬度。'
- en: '`longitude`: The longitudinal coordinate of the reviewed location.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`longitude`：被评论地点的经度。'
- en: 'There will be no need for the user to provide form input for `placeAddress`,
    `placeName`, `placeId`, `latitude`, and `longitude`. As such, we have hidden the
    parent `<div>` of the aforementioned input elements. We shall utilize the Google
    Places API to retrieve place-specific information. Make sure to note that in the
    template we are using a modal to display a map for location selection. The modal
    is toggled by a `button` we added in our template as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 用户无需为`placeAddress`、`placeName`、`placeId`、`latitude`和`longitude`提供表单输入。因此，我们已经隐藏了上述输入元素的父`<div>`。我们将利用Google
    Places API来检索特定地点的信息。请确保注意，在模板中我们使用模态来显示用于位置选择的地图。该模态可以通过我们在模板中添加的`button`切换，如下所示：
- en: '[PRE60]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Clicking on the button will display the map modal to the user. Upon rendering
    the map, a user can click on their desired review location from the map. Performing
    such a click action will trigger the map''s click event, which in turn will be
    handled by the listener we defined in the template as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 点击按钮将向用户显示地图模态。在渲染地图后，用户可以从地图上点击他们想要的评论位置。执行此类点击操作将触发地图的点击事件，然后由我们在模板中定义的监听器处理，如下所示：
- en: '[PRE61]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '`getPlacesDetailsById()` takes two arguments: an instance of `google.maps.places.PlacesService`
    and the ID of the place whose information is to be retrieved. The `PlacesService`
    instance is then used to retrieve the information of the place. After this information
    retrieval, the view is duly updated with the information retrieved: place-specific
    form data is set, the place name and address container within the map modal is
    updated, and a message indicating that a location has successfully been selected
    is shown to the user. Upon selection of a location and the input of all required
    form data, the user can then submit their review.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`getPlacesDetailsById()`接受两个参数：一个`google.maps.places.PlacesService`的实例和要检索信息的地点的ID。然后使用`PlacesService`实例检索地点信息。在信息检索之后，视图将相应地更新检索到的信息：设置特定地点的表单数据，更新地图模态中的地点名称和地址容器，并向用户显示一个表示已成功选择位置的消息。在选择了位置并输入所有必要表单数据后，用户可以提交他们的评论。'
- en: 'We are almost ready to try out the review creation page. Before we do, we must
    create a review validator, as well as a controller action that handles `POST`
    requests sent to the `/reviews` path. Let''s start with `ReviewValidator`. Add
    the `ReviewValidator` class shown here to `com.example.placereviewer.component`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎准备好尝试评论创建页面了。在我们这样做之前，我们必须创建一个评论验证器，以及一个处理发送到`/reviews`路径的`POST`请求的控制器操作。让我们从`ReviewValidator`开始。将以下`ReviewValidator`类添加到`com.example.placereviewer.component`中：
- en: '[PRE62]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'As we have previously explained the workings of custom validators, there is
    little need to explain how this validator works. Without taking time, let us implement
    a controller class for HTTP requests pertaining to reviews. Create a `ReviewController`
    class in `com.example.placereviewer.controller` and add the following code to
    it:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前解释过的自定义验证器的运作方式，这里就没有太多必要解释这个验证器是如何工作的了。不耽误时间，让我们来实现一个控制器类，用于处理与评论相关的HTTP请求。在`com.example.placereviewer.controller`中创建一个`ReviewController`类，并向其中添加以下代码：
- en: '[PRE63]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Having added the `ReviewValidator` and `ReviewController` classes, build and
    run the project, log in as a user, and navigate to `http://localhost:5000/create-review`
    from your favorite browser.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了`ReviewValidator`和`ReviewController`类之后，构建并运行项目，以用户身份登录，并从您喜欢的浏览器导航到`http://localhost:5000/create-review`。
- en: 'Upon page load, you will be presented with a form you can use to add a new
    review:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 页面加载时，您将看到一个表单，您可以使用它来添加新的评论：
- en: '![](img/328b5242-6ab0-492f-8e79-0c31b07afb00.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/328b5242-6ab0-492f-8e79-0c31b07afb00.jpg)'
- en: 'Users are required to select a review location before a review can be submitted.
    To select a review location, click the Select Location button:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 用户在提交评论之前必须选择评论位置。要选择评论位置，请点击“选择位置”按钮：
- en: '![](img/e4f022ca-b8fd-47f7-898a-08634042614d.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e4f022ca-b8fd-47f7-898a-08634042614d.jpg)'
- en: 'Clicking the Select Location button will present the user with a modal containing
    a map from which they can select a location of choice to review. Clicking on a
    location from the map will bring up an information window on the map containing
    data pertaining to the clicked location. In addition, the modal container for
    holding the selected place name and address will be updated:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“选择位置”按钮将向用户展示一个包含地图的模态窗口，用户可以从中选择他们想要评论的位置。点击地图上的位置将在地图上弹出一个信息窗口，包含有关点击位置的数据。此外，用于保存所选地点名称和地址的模态容器也将被更新：
- en: '![](img/48c3b312-dc65-4fac-9835-9e30d0568600.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/48c3b312-dc65-4fac-9835-9e30d0568600.jpg)'
- en: 'After a user selects their review location of choice, they can close the modal
    by clicking Done and proceed to filling in the title and body of their review:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 用户选择他们偏好的评论位置后，可以通过点击“完成”来关闭模态窗口，并继续填写他们的评论标题和正文：
- en: '![](img/dcfa41a3-f9e3-46e4-a4a9-694dce9e6357.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dcfa41a3-f9e3-46e4-a4a9-694dce9e6357.jpg)'
- en: 'Notice that the review form now indicates that a review location has been selected
    successfully. Once the user fills in all the necessary review information, they
    can proceed to submit the review by clicking Submit Review:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，评论表单现在显示已成功选择评论位置。一旦用户填写了所有必要的评论信息，他们可以通过点击“提交评论”来提交评论：
- en: '![](img/d48c136d-3edb-43f0-b341-e547064d7ac9.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d48c136d-3edb-43f0-b341-e547064d7ac9.jpg)'
- en: 'After review submission, the user is redirected to their home page, from which
    they can now see the review submitted. Clicking on the View location button of
    any review displayed on the home page will render a modal containing a map displaying
    the exact location reviewed:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在评论提交后，用户将被重定向到他们的主页，在那里他们现在可以看到他们提交的评论。点击主页上显示的任何评论的“查看位置”按钮将显示一个包含显示评论确切位置的地图的模态窗口：
- en: '![](img/fb72bff1-204f-4192-86ef-4479b26c4fa5.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fb72bff1-204f-4192-86ef-4479b26c4fa5.jpg)'
- en: The map displayed to the user possesses a marker indicating the exact location
    reviewed by the reviewer.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 展示给用户的地图上有一个标记，指示评论者评论的确切位置。
- en: At this stage, we have concluded all the core functionality of the *Place Reviewer*
    application. Before we wrap up this chapter, let us explore how to test Spring
    applications.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段，我们已经完成了“地点评论者”应用的核心功能。在我们结束这一章之前，让我们探讨如何测试Spring应用程序。
- en: Spring application testing
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring应用程序测试
- en: 'Earlier on in this book, we discussed application testing and why it is necessary
    in creating reliable software. We must now explore the process of testing Spring
    applications. A Spring application can be tested in four easy steps:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的早期，我们讨论了应用程序测试及其在创建可靠软件中的必要性。现在我们必须探索测试Spring应用程序的过程。Spring应用程序可以通过四个简单的步骤进行测试：
- en: Add necessary testing dependencies to the project
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向项目中添加必要的测试依赖项
- en: Create a configuration class
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建配置类
- en: Configure test class to use custom configuration
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置测试类以使用自定义配置
- en: Write required tests
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写必要的测试
- en: We shall look at each of these steps one by one.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐一查看这些步骤。
- en: Adding necessary testing dependencies to the project
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向项目中添加必要的测试依赖项
- en: 'This involves the inclusion of suitable testing dependencies in your project.
    Open the `Place Reviewer` project''s `pom.xml` file and add the following dependencies:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这涉及到在项目中包含合适的测试依赖项。打开“地点评论者”项目的`pom.xml`文件，并添加以下依赖项：
- en: '[PRE64]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In the coming sections, we are going to learn how to write tests with jUnit
    and Hamcrest. JUnit is a testing framework for the Java programming language and
    Hamcrest is a library that provides matchers, which can be combined to create
    meaningful expressions of intent.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将学习如何使用JUnit和Hamcrest编写测试。JUnit是Java编程语言的测试框架，Hamcrest是一个提供匹配器的库，这些匹配器可以组合起来创建有意义的意图表达式。
- en: Creating a configuration class
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建配置类
- en: 'The creation of a test configuration class aids the proper running of written
    tests. Within the `src/test/kotlin` directory of the `Place Reviewer` project,
    add a `config` package to `com.example.placereviewer`. Add the `TestConfig` class
    shown here to the package created:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 创建测试配置类有助于正确运行编写的测试。在“地点评论者”项目的`src/test/kotlin`目录中，向`com.example.placereviewer`添加一个`config`包。将以下`TestConfig`类添加到创建的包中：
- en: '[PRE65]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Configuring a test class to use custom configuration
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置测试类以使用自定义配置
- en: 'To do this, open the Spring application''s test class and use an `@ContextConfiguration`
    annotation to specify the configuration classes to be used by the test class.
    Open `PlaceReviewerApplicationTests.kt` (located in the `com.example.placereviewer`
    package of your project''s `src/test/kotlin` directory). Now, set its configuration
    class as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，打开 Spring 应用程序的测试类，并使用 `@ContextConfiguration` 注解来指定测试类将使用的配置类。打开 `PlaceReviewerApplicationTests.kt`（位于你项目
    `src/test/kotlin` 目录下的 `com.example.placereviewer` 包中）。现在，将其配置类设置为以下内容：
- en: '[PRE66]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Great work! You are now ready to write some application tests.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！你现在可以开始编写一些应用程序测试了。
- en: Writing your first test
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写你的第一个测试
- en: Writing code for application tests is like writing code for any other part of
    a Spring application. You can make use of components and services as you would
    in any other part of your application. Let us demonstrate this, shall we?
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 为应用程序测试编写代码就像为 Spring 应用程序的任何其他部分编写代码一样。你可以像在其他任何部分一样使用组件和服务。让我们来演示这一点，好吗？
- en: 'Add the following `TestUserService` interface to `com.example.placereviewer.service`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下 `TestUserService` 接口添加到 `com.example.placereviewer.service`：
- en: '[PRE67]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now, add the following `TestUserServiceImpl` class to the package:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将以下 `TestUserServiceImpl` 类添加到包中：
- en: '[PRE68]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Return to the `PlaceReviewerApplicationTests.kt` file and modify it to reflect
    these changes:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到 `PlaceReviewerApplicationTests.kt` 文件，并修改它以反映这些更改：
- en: '[PRE69]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The `testUserRetrieval()` method is a test that, when run, makes use of the
    stub method we defined in `TestUserServiceImpl` to retrieve a user and asserts
    that the object returned by the function is an instance of the `User` class.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`testUserRetrieval()` 方法是一个测试，当运行时，会使用我们在 `TestUserServiceImpl` 中定义的存根方法来检索一个用户，并断言该函数返回的对象是
    `User` 类的实例。'
- en: 'To run a written test, click the Run Test button to the right of the created
    test in the IDE window:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行编写的测试，请点击 IDE 窗口中创建的测试右侧的“运行测试”按钮：
- en: '![](img/b744466f-c30b-404f-a000-949e4d533bf3.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b744466f-c30b-404f-a000-949e4d533bf3.jpg)'
- en: '`testUserRetrieval` will be run and the result of the test run will be displayed
    at the bottom of the IDE window:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`testUserRetrieval` 将会被执行，并且测试运行的结果将在 IDE 窗口的底部显示：'
- en: '![](img/cbd3c160-eb73-4507-bc4a-78e68630162a.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cbd3c160-eb73-4507-bc4a-78e68630162a.jpg)'
- en: In this case, the test we wrote passed. That's a great thing. However, as you
    develop larger and more complex applications and write tests for application modules,
    you will discover that more often than not, written tests fail. When this happens,
    do not fret; simply stay calm and debug your application. As time passes, you
    will learn to create more reliable software.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们编写的测试通过了。这是一个非常好的事情。然而，随着你开发更大、更复杂的应用程序并为应用程序模块编写测试，你将发现，很多时候编写的测试会失败。当这种情况发生时，不要烦恼；只需保持冷静并调试你的应用程序。随着时间的推移，你会学会创建更可靠的软件。
- en: Summary
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we wrapped up our journey through Kotlin by finishing up the
    *Place Reviewer* application. In the process, we explored—in depth—the creation
    of view layers for Spring MVC-based applications. Furthermore, we learned how
    to integrate an application with Google Places API Web Services with the goal
    of making an application location-aware.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们通过完成 *Place Reviewer* 应用程序来结束了 Kotlin 的旅程。在这个过程中，我们深入探讨了基于 Spring MVC
    的应用程序视图层的创建。此外，我们学习了如何将应用程序与 Google Places API Web 服务集成，目的是使应用程序具有位置感知能力。
- en: In addition, we learned about form input validation with the help of `Validator`
    classes and `BindingResult`. Finally, we covered how to configure for testing
    and write tests for Spring-based applications.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们在 `Validator` 类和 `BindingResult` 的帮助下学习了表单输入验证。最后，我们介绍了如何为基于 Spring 的应用程序配置测试并编写测试。
