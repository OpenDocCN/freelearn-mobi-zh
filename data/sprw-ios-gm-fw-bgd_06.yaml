- en: Chapter 6. Adding Game Logic
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。添加游戏逻辑
- en: '*In the previous chapter, we learned about animating our objects on the screen
    using tweens; we also learned about sprite sheets, generated our very own sprite
    sheet with texture information, and animated it.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*在上一章中，我们学习了如何使用tweens在屏幕上动画化我们的对象；我们还学习了精灵图集，生成了带有纹理信息的自己的精灵图集，并对其进行了动画化。*'
- en: 'Let''s take a quick look at what kind of topics we will tackle in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下本章我们将解决哪些主题：
- en: Shooting cannonballs, which is pretty much a core mechanic of our game
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 射击炮弹，这是我们游戏的一个基本机制
- en: Once a cannonball is displayed on the battlefield, it should be able to collide
    with the enemy ship
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦在战场上展示出炮弹，它应该能够与敌舰相撞
- en: Destroying the enemy ship, if enough cannonballs hit the ship
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果足够的炮弹击中敌舰，则摧毁敌舰
- en: Extending the asset manager
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展资源管理器
- en: In the previous chapter, we loaded our very first texture atlas and displayed
    each subtexture as frames in a movie clip. We did not use our asset manager for
    this as we hadn't implemented this functionality yet.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们加载了我们第一个纹理图集，并将每个子纹理作为电影剪辑中的帧进行显示。我们没有使用资源管理器来做这件事，因为我们还没有实现这个功能。
- en: So, let's go ahead and allow our asset manager to deal with texture atlases.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们继续并允许我们的资源管理器处理纹理图集。
- en: Time for action – adding texture atlases to the asset manager
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始行动时间 - 向资源管理器添加纹理图集
- en: 'We can extend our asset manager with the following steps:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下步骤扩展我们的资源管理器：
- en: Open our game's project file, if it's not already open.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未打开，请打开我们的游戏项目文件。
- en: 'Switch to the `TextureManager.h` file and declare the method `registerTextureAtlas`,
    as shown in the following code:'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`TextureManager.h`文件并声明`registerTextureAtlas`方法，如下所示：
- en: '[PRE0]'
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Switch to the `TextureManager.m` file and implement the `registerTextureAtlas`
    method, as shown in the following code:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`TextureManager.m`文件并实现`registerTextureAtlas`方法，如下所示：
- en: '[PRE1]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Head over to the `Assets.h` file and add the static method `textureAtlas`:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`Assets.h`文件并添加静态方法`textureAtlas`：
- en: '[PRE2]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the `Assets.m` file, implement the following method by referring to its
    `TextureManager` instance:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets.m`文件中，通过其`TextureManager`实例实现以下方法：
- en: '[PRE3]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the battlefield scene (`Battlefield.m`), navigate to where we are loading
    the texture atlas and getting the textures:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在战场场景（`Battlefield.m`）中，导航到我们加载纹理图集和获取纹理的位置：
- en: '[PRE4]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Replace the preceding code with the following line of code:'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将前面的代码替换为以下代码行：
- en: '[PRE5]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Run the example. We will see the following constellation of ships on the screen:![Time
    for action – adding texture atlases to the asset manager](img/1509OS_06_01.jpg)
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例。我们将在屏幕上看到以下舰船星座：![开始行动时间 – 向资源管理器添加纹理图集](img/1509OS_06_01.jpg)
- en: '*What just happened?*'
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: In step 1, we opened our Xcode template from where we left off in the previous
    chapter. In order to load texture atlases, we needed to switch to the texture
    manager, which we designated to load everything that is remotely connected to
    textures. In step 2, we declared the method we used in order to use texture atlases
    through the asset management system. To keep the method names consistent, we will
    name this method `registerTextureAtlas` to make it similar to `registerTexture`.
    The signature resembles that of `registerTexture`, but it returns an instance
    of `SPTextureAtlas` instead of `SPTexture`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤1中，我们从上一章结束的地方打开了我们的Xcode模板。为了加载纹理图集，我们需要切换到纹理管理器，我们指定它来加载所有与纹理有关联的内容。在步骤2中，我们声明了用于通过资产管理系统中使用纹理图集的方法。为了保持方法名称的一致性，我们将此方法命名为`registerTextureAtlas`，使其类似于`registerTexture`。签名类似于`registerTexture`，但它返回一个`SPTextureAtlas`实例而不是`SPTexture`。
- en: In the next step, we implemented the `registerTextureAtlas` method that loads
    the texture through the `filename` parameter, and we used the `SPTextureAtlas`
    factory method just like we did when we learned about texture atlases.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们实现了通过`filename`参数加载纹理的`registerTextureAtlas`方法，我们使用`SPTextureAtlas`工厂方法，就像我们学习纹理图集时做的那样。
- en: Once we finished extending the texture manager part, we needed to extend the
    `Assets` class, which we did in step 4 by adding the function head which we implemented
    in step 5\. To keep the naming scheme consistent, we named this method `textureAtlas`.
    In this method, we just called the `registerTextureAtlas` method of our texture
    manager and returned the result.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了扩展纹理管理器部分，我们需要扩展 `Assets` 类，我们在第 4 步中通过添加第 5 步中实现的函数头来实现这一点。为了保持命名方案一致，我们把这个方法命名为
    `textureAtlas`。在这个方法中，我们只是调用了我们的纹理管理器的 `registerTextureAtlas` 方法，并返回了结果。
- en: We updated the lines in the battlefield to load the texture atlas for the movie
    clip through the asset management system. Instead of two lines—one for setting
    up the texture atlas instance and another for getting the needed textures out
    of the atlas—we now have only a single line that gets our texture atlas with the
    `textureAtlas` method from the last two steps and then gets the necessary textures
    for the movie clip.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在战场上更新了行，通过资产管理系统加载电影剪辑的纹理图集。而不是两行——一行用于设置纹理图集实例，另一行用于从图集中获取所需的纹理——我们现在只有一行代码，它使用上两步中的
    `textureAtlas` 方法获取我们的纹理图集，然后获取电影剪辑所需的纹理。
- en: When we ran the example in the last step, we had the exact result as we did
    at the end of the previous chapter, which is a good sign and an indication that
    the changes work as they should.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在上一步运行示例时，我们得到了与上一章结尾完全相同的结果，这是一个好兆头，表明更改按预期工作。
- en: Structuring our ships
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构化我们的船只
- en: So far, our ships are just instances of `SPImage` with tweens attached to them
    right inside our battlefield scene. In order to keep code duplication to a minimum,
    let's refactor the ship logic into its own class.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的船只只是 `SPImage` 的实例，它们在我们的战场场景中直接附加了补间动画。为了将代码重复性降到最低，让我们将船只逻辑重构到它自己的类中。
- en: Time for action – creating a ship class
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 创建船只类
- en: 'To structure the code of our ship, follow these steps:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结构化我们船只的代码，请遵循以下步骤：
- en: Add a new group called `Entities`.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `Entities` 的新组。
- en: Inside this group, add a new Objective-C class called `Ship`, which is derived
    from `SPSprite`.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个组中，添加一个名为 `Ship` 的新 Objective-C 类，它从 `SPSprite` 派生出来。
- en: 'Open the `Ship.h` file. Add one instance variable for the ship image and another
    for the movie clip of the ship shooting cannonballs, as shown in the following
    code:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Ship.h` 文件。为船只图像添加一个实例变量，并为船只射击炮弹的电影剪辑添加另一个实例变量，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Declare an alternative initializer called `initWithContentsOfFile`, which takes
    an `NSString` as its parameter:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `initWithContentsOfFile` 的备用初始化器，它接受一个 `NSString` 作为参数：
- en: '[PRE7]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Declare a method called `shoot`, as shown in the following code:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `shoot` 的方法，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Declare another method called `moveTo` that takes the `x` value as its first
    parameter and the `y` value as its second parameter, as shown in the following
    code:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明另一个名为 `moveTo` 的方法，它接受 `x` 值作为其第一个参数，`y` 值作为其第二个参数，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Declare a method called `stop`, as shown in the following code:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为 `stop` 的方法，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Define the default initializer for the `Ship` class with the following lines
    of code:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码定义 `Ship` 类的默认初始化器：
- en: '[PRE11]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, define the alternate initializer that takes `filename` as its parameter,
    as shown in the following code:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，定义一个接受 `filename` 作为参数的备用初始化器，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Implement the `shoot` method with the following lines:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码实现 `shoot` 方法：
- en: '[PRE13]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The content of the `moveTo` method should look like the following code:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`moveTo` 方法的具体内容应如下所示：'
- en: '[PRE14]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Implement the `stop` method, as shown in the following code:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现名为 `stop` 的方法，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Switch to the `Battlefield.h` file and update the class so that the instance
    variable `_pirateShip` is from the type `Ship`, as shown in the following code:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到 `Battlefield.h` 文件，并更新类，使实例变量 `_pirateShip` 是 `Ship` 类型，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, switch to the `Battlefield.m` file.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，切换到 `Battlefield.m` 文件。
- en: 'Update the `onBackgroundTouch` method in the scene, as shown in the following
    code:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中更新 `onBackgroundTouch` 方法，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, update the `onShipStop` method, as shown in the following code:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，更新 `onShipStop` 方法，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Update the remaining references from `SPImage` to the `Ship` class and remove
    all occurrences of the cannon ship, as shown in the following code:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新剩余的从 `SPImage` 到 `Ship` 类的引用，并删除所有关于炮舰的引用，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Run the example. We now see the pirate and enemy ships on the screen:![Time
    for action – creating a ship class](img/1509OS_06_02.jpg)
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例。我们现在可以在屏幕上看到海盗船和敌舰：![动手实践 – 创建船只类](img/1509OS_06_02.jpg)
- en: '*What just happened?*'
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: 'In game development, the term entity usually refers to an object on the screen
    which interacts with other objects. Let''s take a 2D action side-scroller as an
    example: the enemy ships as well as the ship controlled by the player were entities.
    The bullets were entities too. A bullet, for example, interacted with the player
    ship as it spawned from it. The enemy ships interacted with the bullets; if a
    bullet hit an enemy ship, it needed to react by losing hit points or by being
    destroyed. The same applied to the player ship.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发中，术语实体通常指的是屏幕上的一个对象，它与其他对象进行交互。以一个2D动作侧滚动游戏为例：敌舰以及玩家控制的船只都是实体。子弹也是实体。例如，子弹从玩家船只产生时，会与玩家船只进行交互。敌舰会与子弹交互；如果子弹击中敌舰，它需要通过减少生命值或被摧毁来做出反应。同样的情况也适用于玩家船只。
- en: Entities also feature in more advanced game development techniques such as the
    entity-component pattern, where the interaction is described as components. These
    components are then attached to entities.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 实体也在更高级的游戏开发技术中发挥作用，例如实体-组件模式，其中交互被描述为组件。然后，这些组件被附加到实体上。
- en: What we need to take away from our game is a clear separation between the different
    elements of the game. In step 1, we added a new group called `Entities`. In the
    next step, we defined our very first entity called `Ship`, which is a subclass
    of `SPSprite`. It was also possible to add a prefix before the class name, just
    like all Sparrow classes have the prefix `SP`. For our game, the prefix `PG` would
    make sense as it stands for PirateGame.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从我们的游戏中提取的是不同游戏元素之间的清晰分离。在步骤1中，我们添加了一个名为`Entities`的新组。在下一步中，我们定义了我们第一个实体`Ship`，它是`SPSprite`的子类。在类名前添加前缀也是可能的，就像所有Sparrow类都有前缀`SP`一样。对于我们的游戏，前缀`PG`是有意义的，因为它代表PirateGame。
- en: 'The ship had two instance variables, which we declared in step 3: one was the
    cannonball-shooting animation we previously saw in the battlefield scene and the
    second was the image of the ship itself.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 船只有两个实例变量，我们在步骤3中声明了它们：一个是我们在战场场景中之前看到的炮弹射击动画，另一个是船只本身的图像。
- en: In addition to the default initializer, we declared a second initializer in
    step 4\. This method takes `filename` as a parameter. We didn't want to create
    a separate class for the pirate ship. We can use the same class for both types.
    We just needed a different `filename` parameter for either the enemy or the pirate
    ship.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 除了默认初始化器外，我们在步骤4中声明了第二个初始化器。该方法接受`filename`作为参数。我们不想为海盗船创建一个单独的类。我们可以使用相同的类来处理这两种类型。我们只需要为敌舰或海盗船提供不同的`filename`参数。
- en: 'Our ship class needed to have the following behaviors:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的船只类需要以下行为：
- en: Shooting (step 5)
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 射击（步骤5）
- en: Moving the ship to a certain position (step 6)
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将船只移动到特定位置（步骤6）
- en: Stopping the movement (step 7)
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止移动（步骤7）
- en: 'Our `Ship.h` file now looks like the following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Ship.h`文件现在看起来像以下代码：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once all methods and instance variables for the `Ship` class were declared,
    we went on to implement the methods. Before we did that, we defined the initializer
    in step 8: we initialized the movie clip—with the texture atlas from the shooting
    pirate ship—and the ship image itself. The only difference to what we know so
    far is that we are initializing the image if it hasn''t been initialized yet.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明了`Ship`类的所有方法和实例变量之后，我们继续实现方法。在这样做之前，我们在步骤8中定义了初始化器：我们初始化了电影片段——使用射击海盗船的纹理图集——以及船只图像本身。与我们所知的不同之处在于，如果图像尚未初始化，我们将初始化它。
- en: In the second initializer that we implemented in step 9, we initialized the
    image with the filename we passed in and we called the default initializer. So,
    if the alternate initializer was called, we didn't overwrite the `_idleImage`
    instance variable with a fresh instance of `SPImage`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤9中我们实现的第二个初始化器中，我们使用传递的文件名初始化了图像，并调用了默认初始化器。因此，如果调用了备用初始化器，我们不会用`SPImage`的新实例覆盖`_idleImage`实例变量。
- en: 'The full piece of code of `Ship.m` up to this point is as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`Ship.m`的完整代码如下：
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the next steps, we implemented methods for the ship''s actions:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们实现了船只动作的方法：
- en: '**Shooting**: Plays the `_shooting` movie clip (step 10).'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**射击**：播放`_shooting`电影片段（步骤10）。'
- en: '**Moving**: This is the moving logic of the ship we previously had in the `backgroundTouch`
    method in the battlefield scene. Instead of removing all tweens from the ship
    instance, we called the `stop` method from the `ship` instance (step 11).'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移动**：这是我们之前在战场场景中的`backgroundTouch`方法中拥有的船的移动逻辑。我们不是从船的实例中移除所有补间动画，而是从`ship`实例中调用了`stop`方法（步骤11）。'
- en: '**Stopping**: Removes all tweens from the current instance (step 12).'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**停止**：从当前实例（步骤12）移除所有补间动画。'
- en: 'In its completeness, these methods look like the following piece of code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在其完整性方面，这些方法看起来像以下代码片段：
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the last steps, we updated the battlefield scene. First, we updated the header
    file. We needed to import the `Ship.h` file, and instead of being a pointer to
    `SPImage`, the `_pirateShip` instance variable was a pointer to the `Ship` class.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后几步中，我们更新了战场场景。首先，我们更新了头文件。我们需要导入`Ship.h`文件，并且`_pirateShip`实例变量不再是`SPImage`的指针，而是`Ship`类的指针。
- en: 'After this step, our `Battlefield.h` file had the following content:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步之后，我们的`Battlefield.h`文件包含以下内容：
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We updated the touch interactions in the battlefield scene:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更新了战场场景中的触摸交互：
- en: '`onBackgroundTouch`: Since we moved the movement logic to the `Ship` class,
    we just needed to call the correct method, which was `moveTo`, and pass in the
    *x* and *y* coordinate of `touch` (step 15)'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onBackgroundTouch`：由于我们将移动逻辑移动到了`Ship`类，我们只需要调用正确的方法，即`moveTo`，并传递`touch`的*x*和*y*坐标（步骤15）。'
- en: '`onShipStop`: Similar to the `moveTo` method, we just needed to call the `stop`
    method of the ship itself (step 16)'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onShipStop`：与`moveTo`方法类似，我们只需要调用船本身的`stop`方法（步骤16）。'
- en: 'The touch events inside the `Battlefield.m` file should resemble the following
    piece of code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`Battlefield.m`文件中的触摸事件应该类似于以下代码片段：'
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the next step, we updated the initializer for the ships. We didn't need the
    `cannonShip` movie clip anymore as this was an instance variable inside the `Ship`
    class.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们更新了船的初始化器。我们不再需要`cannonShip`电影剪辑，因为这个是`Ship`类中的一个实例变量。
- en: 'Let''s take a look at the initializer in the following code that binds these
    touch selectors and sets up the ship itself:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码中的初始化器，它绑定这些触摸选择器并设置船本身：
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When we ran the example, we saw two ships on the screen; if we tapped anywhere,
    our pirate ship moved to that point, just like we expected it to. If we touched
    the ship during movement, it stopped.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行示例时，我们在屏幕上看到了两艘船；如果我们触摸任何地方，我们的海盗船会移动到那个点，就像我们预期的那样。如果我们触摸船在移动过程中，它会停止。
- en: Extending the ship class
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展船类
- en: 'Now that the base of our ship class is done, let''s think of what we need for
    the ship class:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了船类的基础，让我们考虑我们需要为船类添加什么：
- en: '**Hit points**: If a ship is hit, the hit points should reflect this state.
    The ship will start out with a given number of hit points, say 20 for example,
    and it will lose some each time it is hit. When it finally reaches zero hit points,
    it will be completely destroyed.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生命值**：如果一艘船被击中，生命值应该反映这种状态。船将从一个给定的生命值开始，比如20，每次被击中都会失去一些。当它最终达到零生命值时，它将被完全摧毁。'
- en: '**Direction**: This is the direction the ship is facing. Depending on the direction,
    the cannonballs will be fired from each side of the ship.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方向**：这是船面对的方向。根据方向，炮弹将从船的每一边发射。'
- en: We should abstain from using filenames where we don't necessarily need to, for
    example now, when initializing our ship instances.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该避免在不必要的情况下使用文件名，例如现在，当我们初始化船的实例时。
- en: Before we go ahead and get to the coding part of things, let's download the
    latest images from [https://github.com/freezedev/pirategame-assets/releases/download/0.6/Graphics_06.zip](https://github.com/freezedev/pirategame-assets/releases/download/0.6/Graphics_06.zip).
    These images include updated sprite sheets for both the pirate ship and a cannonball
    that we will use later.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续进行编码部分之前，让我们从[https://github.com/freezedev/pirategame-assets/releases/download/0.6/Graphics_06.zip](https://github.com/freezedev/pirategame-assets/releases/download/0.6/Graphics_06.zip)下载最新的图片。这些图片包括海盗船和炮弹的更新精灵表，我们将在以后使用。
- en: Delete the `ship_small_cannon` files and copy the newer files to the project.
    This can be done easily, but Xcode doesn't always like replacing existing files.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 删除`ship_small_cannon`文件，并将新文件复制到项目中。这可以轻松完成，但Xcode并不总是喜欢替换现有文件。
- en: Time for action – adding more functionality to the ship class
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候采取行动了——为船类添加更多功能
- en: 'Let''s extend the ship class using the following steps:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤扩展船类：
- en: Open the `Ship.h` file.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Ship.h`文件。
- en: 'Add `enum` for the eight directions of the ship, as shown in the following
    code:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个用于船的八个方向的 `enum`，如下面的代码所示：
- en: '[PRE26]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add another `enum` for the type of the ship, as shown in the following code:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个用于船类型的 `enum`，如下面的代码所示：
- en: '[PRE27]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Change the `_shootingClip` instance variable to be a pointer to the `NSArray`
    class and remove the `_idleImage` instance variable, as shown in the following
    code:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `_shootingClip` 实例变量改为指向 `NSArray` 类的指针，并移除 `_idleImage` 实例变量，如下面的代码所示：
- en: '[PRE28]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add a property for the ship''s `hitpoints`, as shown in the following line
    of code:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为船的 `hitpoints` 添加一个属性，如下面的代码行所示：
- en: '[PRE29]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Add another property for `type`, as shown in the following line of code:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `type` 添加另一个属性，如下面的代码行所示：
- en: '[PRE30]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The third property is the direction of the ship:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三个属性是船的方向：
- en: '[PRE31]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Because we will need to write custom getters and setters for this property
    as well, we will need an instance variable of the same name, prefixed with an
    underscore:'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因为我们将需要为这个属性编写自定义的获取器和设置器，所以我们需要一个同名的实例变量，前面加下划线：
- en: '[PRE32]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Replace the `initWithContentsOfFile` method declaration with `initWithType`.
    This method takes `ShipType` as its parameter, as shown in the following line
    of code:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `initWithContentsOfFile` 方法声明替换为 `initWithType`。此方法以 `ShipType` 作为其参数，如下面的代码行所示：
- en: '[PRE33]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Switch to the `Ship.m` file.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到 `Ship.m` 文件。
- en: 'Let''s implement the `initWithType` method with the following lines of code:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用以下代码实现 `initWithType` 方法：
- en: '[PRE34]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Remove the `initWithContentsOfFile` method and update the default initializer
    to use the `initWithType` method, as shown in the following code:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除 `initWithContentsOfFile` 方法，并将默认初始化器更新为使用 `initWithType` 方法，如下面的代码所示：
- en: '[PRE35]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Implement the custom getter for the `direction` property by simply returning
    the `_direction` instance variable.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过简单地返回 `_direction` 实例变量来实现 `direction` 属性的自定义获取器。
- en: 'The setter for the `direction` property needs to have the following code:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`direction` 属性的设置器需要以下代码：'
- en: '[PRE36]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Replace the content of the `shoot` method with the following lines:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `shoot` 方法的内联内容替换为以下行：
- en: '[PRE37]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Within the `moveTo` method, after the creation of the `tweenX` and `tweenY`
    objects, declare and define two variables that should detect which direction the
    ship will be rotated to, as shown in the following code:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `moveTo` 方法中，在创建 `tweenX` 和 `tweenY` 对象之后，声明并定义两个变量，这些变量应该检测船将旋转到的方向，如下面的代码所示：
- en: '[PRE38]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Only update the values if a certain threshold has been broken, as shown in
    the following code:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有在达到某个特定阈值时才更新值，如下面的代码所示：
- en: '[PRE39]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Change `direction` to `DirectionEast` if `signX` has the value `1` and `signY`
    still has the value `0`, as shown in the following code:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `signX` 的值为 `1` 且 `signY` 仍为 `0`，则将 `direction` 更改为 `DirectionEast`，如下面的代码所示：
- en: '[PRE40]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Repeat this for all the remaining directions.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对所有剩余的方向重复此操作。
- en: Switch to the `Battlefield.m` file.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到 `Battlefield.m` 文件。
- en: Update the initializers to the pirate and enemy ships. Only the pirate ship
    needs to have the `PirateShip` value from the `ShipType` type.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新海盗船和敌船的初始化器。只有海盗船需要从 `ShipType` 类型中获取 `PirateShip` 值。
- en: 'Inside the `onShipStop` method, add the functionality to shoot when the pirate
    ship is tapped twice and stop if the ship is tapped once, as shown in the following
    code:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onShipStop` 方法内部，添加当海盗船被点击两次时射击以及当船被点击一次时停止的功能，如下面的代码所示：
- en: '[PRE41]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Rename `onShipStop` and all its references to `onShipTap`.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `onShipStop` 及其所有引用重命名为 `onShipTap`。
- en: Run the example.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例。
- en: We now see that the ship is moving in the direction where we touched the screen.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在看到船正在移动到我们触摸屏幕的方向。
- en: '![Time for action – adding more functionality to the ship class](img/1509OS_06_03.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 – 向船类添加更多功能](img/1509OS_06_03.jpg)'
- en: '*What just happened?*'
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: 'First, we opened the ship header file, and then we defined an `enum` for all
    the direction states. Objective-C provides a handy `NS_ENUM` macro which lets
    us do exactly that. As the first parameter, we need the type the `enum` will be
    represented as. The second parameter is the name of the `enum` type. This `enum`
    type has eight states: north, south, west, east, and a combination of these.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们打开了船的头文件，然后定义了一个包含所有方向状态的 `enum`。Objective-C 提供了一个方便的 `NS_ENUM` 宏，它允许我们做到这一点。作为第一个参数，我们需要
    `enum` 将表示的类型。第二个参数是 `enum` 类型的名称。这个 `enum` 类型有八个状态：北、南、西、东以及这些方向的组合。
- en: In step 3, we defined a second `enum` for the type of ship. It can either be
    a pirate ship or a normal enemy ship without black flags.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3步中，我们定义了一个用于船类型的第二个 `enum`。它可以是海盗船或没有黑旗的正常敌船。
- en: In step 4, we redefined the type of the `_shootingClip` instance. The reasoning
    behind this change is that we hold all movie clips in an array and can access
    a specific movie clip through the index.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4步中，我们重新定义了`_shootingClip`实例的类型。这种变化的理由是我们将所有电影剪辑保存在一个数组中，并且可以通过索引访问特定的电影剪辑。
- en: 'In the next few steps, we added a few properties to the class, as listed:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个步骤中，我们向类中添加了一些属性，如下所示：
- en: '`hitpoints`: This indicates how many hit points the ship currently has (step
    5)'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hitpoints`：这表示船当前有多少生命值（第5步）'
- en: '`type`: This indicates the type of the ship (step 6)'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`：这表示船的类型（第6步）'
- en: '`direction`: This indicates the direction the ship is facing (step 7)'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`direction`：这表示船面向的方向（第7步）'
- en: While it would have been fine to just add the filename to each initializer call
    when we created an instance of the ship class, it would get messy once we either
    changed all of these filenames or if we had more than just a few ships on the
    screen. This is why we replaced the `initWithContentsOfFile` method with the `initWithType`
    method.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建船类实例时，只需将文件名添加到每个初始化器调用中，这本来是可以的，但如果我们更改了所有这些文件名，或者屏幕上有不止几艘船，就会变得混乱。这就是为什么我们用`initWithType`方法替换了`initWithContentsOfFile`方法。
- en: 'Next, we implemented all of the methods we just declared. We started with the
    one we declared last. As this was our go-to initializer, we got through what was
    happening here:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们实现了我们刚刚声明的所有方法。我们从最后声明的方法开始。由于这是我们首选的初始化器，所以我们了解了这里发生的情况：
- en: We set the `hitpoints` property to `100`. While `100` is more or less a random
    number, it is a good starting point to balance from as it's very easy to calculate
    with. For example, let's say we require four hits to destroy any ships; the damage
    potential of a cannonball is 25.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将`hitpoints`属性设置为`100`。虽然`100`或多或少是一个随机数字，但它是一个很好的起点，因为它很容易计算。例如，假设我们需要四次打击来摧毁任何船只；炮弹的破坏潜力是25。
- en: We set the `type` property to the value of the `type` parameter.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将`type`属性设置为`type`参数的值。
- en: 'We set the texture atlas to either the pirate ship atlas or the other option,
    depending on the type. A ternary operation was just a fancy way of writing an
    `if` statement, as shown in the following line of code:'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们根据类型将纹理图集设置为海盗船图集或其他选项。三元运算只是编写一个`if`语句的一种花哨方式，如下面的代码行所示：
- en: '[PRE42]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The advantage of the ternary operation was that we could assign its result directly
    to a variable.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 三元运算的优势在于我们可以直接将结果分配给变量。
- en: 'We got the textures for each direction. Within the texture atlas, every direction
    of the shooting animation was prefixed with the abbreviation of the direction:
    `n` for north, `nw` for northwest, and so on.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为每个方向获取了纹理。在纹理图集中，射击动画的每个方向都以方向的缩写前缀命名：`n`代表北，`nw`代表西北，依此类推。
- en: We then defined the speed for the animations. We set it to 12 frames per second
    as we didn't want the animation to be slower than usual. After all, operating
    the cannons is tough.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们定义了动画的速度。我们将其设置为每秒12帧，因为我们不希望动画比平时慢。毕竟，操作大炮是困难的。
- en: 'Just like we made an instance of `NSArray` for every direction, we needed to
    do the same for all the movie clips. We could also write this line as follows:'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就像我们为每个方向创建了一个`NSArray`实例一样，我们还需要为所有电影剪辑做同样的事情。我们也可以将这一行写成以下形式：
- en: '[PRE43]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We added all movie clips to the `_shootingClip` instance variable.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将所有电影剪辑添加到`_shootingClip`实例变量中。
- en: All the movie clips were added to the display tree by iterating over the `_shootingClip`
    instance variable. We also wanted the movie clips to play only once, which is
    why we set the `loop` property to `NO`.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过遍历`_shootingClip`实例变量，我们将所有电影剪辑添加到显示树中。我们还希望电影剪辑只播放一次，这就是为什么我们将`loop`属性设置为`NO`。
- en: The default direction of a ship was south-west.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 船的默认方向是西南方向。
- en: In step 11, we significantly simplified the default initializer by just calling
    the `initWithType` initializer with the `ShipNormal` type.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在第11步中，我们通过仅调用带有`ShipNormal`类型的`initWithType`初始化器，显著简化了默认初始化器。
- en: We started with creating the custom getters and setters for the `direction`
    property. We added the `nonatomic` keyword to the property definition. This was
    a performance optimization method to make the generated accessor faster, but non-thread
    safe. Since Sparrow should only be used single-threaded, it was safe to use `nonatomic`
    in our game. Internally, Objective-C had already defined the getters and setters
    as `propertyName` and `setPropertyName`, or in our case, `direction` and `setDirection`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从为`direction`属性创建自定义的getter和setter开始。我们在属性定义中添加了`nonatomic`关键字。这是一种性能优化方法，可以使生成的访问器更快，但不是线程安全的。由于Sparrow应该只用于单线程，所以在我们的游戏中使用`nonatomic`是安全的。在内部，Objective-C已经将getter和setter定义为`propertyName`和`setPropertyName`，或者在我们的情况下，`direction`和`setDirection`。
- en: To use our own code, we just needed to overwrite these methods. The getter for
    the `direction` property was pretty simple as it just needed to return the `_direction`
    instance variable.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用我们自己的代码，我们只需覆盖这些方法。`direction`属性的getter相对简单，因为它只需要返回`_direction`实例变量。
- en: In our custom setter for the `direction` property, we needed to set the instance
    variable `_direction` to the value of the parameter first. Then, we iterated through
    all the movie clips and set its `visible` property to `NO`. We then showed the
    movie clip of the current direction. This was very similar to how we show scenes
    through the scene director.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们为`direction`属性自定义的setter中，我们首先需要将实例变量`_direction`设置为参数的值。然后，我们遍历所有电影剪辑并将它们的`visible`属性设置为`NO`。接着，我们显示了当前方向的电影剪辑。这与我们通过场景导演展示场景的方式非常相似。
- en: 'In step 14, we updated the `shoot` method using the following steps:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在第14步中，我们使用以下步骤更新了`shoot`方法：
- en: We removed all animatable objects from the juggler which originate from any
    of the movie clips.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从杂技演员中移除了所有来自任何电影剪辑的可动画对象。
- en: We played the movie clip from the current direction and added it to the juggler.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们播放了当前方向的电影剪辑并将其添加到杂技演员中。
- en: We added an event listener to the movie clip that fired when the movie clip
    animation was complete. Instead of a selector, we used a block. A block (also
    called a closure in non-Objective-C environments) is a function which has access
    to non-local variables. So, while we could define variables inside the block,
    we accessed the variables as if we were declaring a statement inside the `shoot`
    method. A block had a certain appeal to it as we didn't need to define a separate
    selector for just a few lines of code. There were few things we needed to be careful
    about when using blocks, but Xcode usually warned us about potential side effects.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为电影剪辑添加了一个事件监听器，当电影剪辑动画完成时触发。我们使用了一个块而不是选择器。块（在非Objective-C环境中也称为闭包）是一个可以访问非局部变量的函数。因此，虽然我们可以在块内部定义变量，但我们访问变量就像在`shoot`方法内部声明一个语句一样。块有一定的吸引力，因为我们不需要为几行代码定义一个单独的选择器。在使用块时，我们需要注意一些事情，但Xcode通常会警告我们潜在的副作用。
- en: Inside our block, we stopped the movie clip as it didn't reset itself. It was
    like rewinding a VHS tape.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的块内部，我们停止了电影剪辑，因为它不会重置自己。这就像倒带VHS磁带一样。
- en: 'At this time, we updated the ship''s direction when it moved. To achieve this,
    we defined two variables inside the `moveTo` method: `signX` and `signY`. Their
    default values were `0`.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个时候，我们更新了当船移动时的方向。为了实现这一点，我们在`moveTo`方法内部定义了两个变量：`signX`和`signY`。它们的默认值都是`0`。
- en: The idea behind that was to map the direction from the values we got in our
    `moveTo` method to a value from the `ShipDirection` values. If `signY` was `1`,
    it would map to `DirectionNorth`; if `signX` was `-1`, it would map to `DirectionWest`;
    and if both had the values at the same time, they would map to `DirectionNorthWest`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是将我们从`moveTo`方法中得到的方向值映射到`ShipDirection`值。如果`signY`是`1`，它将映射到`DirectionNorth`；如果`signX`是`-1`，它将映射到`DirectionWest`；如果两者同时具有相同的值，它们将映射到`DirectionNorthWest`。
- en: We had set the `signX` variables to the *x* coordinate of the object minus the
    target *x* coordinate and dividing that by `distanceX`. So, our values for `signX`
    were either `1` or `-1`. The same happened for the `signY` variable.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`signX`变量设置为对象的*x*坐标减去目标*x*坐标，然后除以`distanceX`。因此，我们的`signX`值要么是`1`，要么是`-1`。对于`signY`变量也是同样的情况。
- en: Now, if we moved the ship, we only got directions such as `DirectionNorthWest`,
    `DirectionNorthEast`, `DirectionSouthEast`, and `DirectionSouthWest`. It is pretty
    much impossible to tap the same pixel on a line twice. This was why we needed
    a threshold. We only set `signX` and `signY` to `1` or `-1`, respectively, if
    distance was more than 40 points. In this case, 40 was not a random number; a
    rectangle with 40 x 40 points is the average size of a tap, according to Apple.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们移动船，我们只能得到`DirectionNorthWest`、`DirectionNorthEast`、`DirectionSouthEast`和`DirectionSouthWest`这样的方向。在一条线上两次点击同一个像素点几乎是不可能的。这就是为什么我们需要一个阈值。只有当距离超过40个点时，我们才将`signX`和`signY`分别设置为`1`或`-1`。在这种情况下，40不是一个随机的数字；根据Apple的说法，一个40
    x 40点的矩形是点击的平均大小。
- en: In steps 17 and 18, we mapped the `signX` and `signY` variables to the `ShipDirection`
    values, and we set the `direction` property accordingly.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤17和18中，我们将`signX`和`signY`变量映射到`ShipDirection`值，并相应地设置了`direction`属性。
- en: Within the battlefield scene, we needed to create our ship instances. For the
    enemy ship, we used the default initializer.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在战场场景中，我们需要创建我们的船实例。对于敌船，我们使用了默认初始化器。
- en: In step 21, we updated the `onShipStop` method. We utilized the `tapCount` property
    of the `touch` object to see how many times the object had been tapped. If the
    ship had been tapped once, it would stop its movement, and if it had been tapped
    twice, it would shoot.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤21中，我们更新了`onShipStop`方法。我们利用`touch`对象的`tapCount`属性来查看对象被点击了多少次。如果船被点击了一次，它会停止移动；如果被点击了两次，它会射击。
- en: Since the `onShipStop` method did not only stop the ship but also shot if tapped
    twice, it was a good call to rename this method to `onShipTap`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`onShipStop`方法不仅停止了船，而且在被双击时射击，因此将其重命名为`onShipTap`是一个好主意。
- en: When we ran the example, the ship changed its direction depending on where we
    tapped on the screen, and when we double-tapped the ship, we saw the cannon animation.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行示例时，船会根据我们在屏幕上点击的位置改变方向，当我们双击船时，我们会看到炮弹动画。
- en: Shooting cannonballs
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 射击炮弹
- en: When we double-tap our ship, the animation plays. However, there is one obvious
    thing missing, the cannonballs! Let's go ahead and add some cannonballs.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们双击我们的船时，动画会播放。然而，有一个明显的东西缺失，那就是炮弹！让我们继续添加一些炮弹。
- en: Time for action – allowing the ship to shoot cannonballs
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 允许船射击炮弹
- en: 'Let''s allow the pirate ship to shoot cannonballs by following these steps:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤允许海盗船射击炮弹：
- en: Open the `Ship.h` file.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Ship.h`文件。
- en: 'Add a read-only property called `isShooting`, which has an instance variable
    counterpart called `_isShooting`, as shown in the following code:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个只读属性`isShooting`，它有一个实例变量对应项`_isShooting`，如下面的代码所示：
- en: '[PRE44]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Add a cannonball for the left-hand side and the right-hand side of the ship.
    Both of them are pointers to `SPImage`, as shown in the following code:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为船的左侧和右侧添加一个炮弹。它们都是指向`SPImage`的指针，如下面的代码所示：
- en: '[PRE45]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Switch to the `Ship.m` file.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`Ship.m`文件。
- en: Inside the `initWithType` method, set the `_isShooting` instance variable to
    `NO` at the top of the method.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`initWithType`方法内部，将`_isShooting`实例变量设置为`NO`，位于方法顶部。
- en: Inside the `initWithType` method, create both cannonballs with the `cannonball.png`
    image, set their `visible` property to `NO`, and add them to the display tree.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`initWithType`方法内部，使用`cannonball.png`图像创建两个炮弹，将它们的`visible`属性设置为`NO`，并将它们添加到显示树中。
- en: 'Inside the `shoot` method, abort if `_isShooting` is set to `YES`, else set
    `_isShooting` to `YES`, as shown:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`shoot`方法内部，如果`_isShooting`设置为`YES`则中止，否则将`_isShooting`设置为`YES`，如下所示：
- en: '[PRE46]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Set some default values for the animation speed and target position, as shown
    in the following code:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为动画速度和目标位置设置一些默认值，如下面的代码所示：
- en: '[PRE47]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Add a reference to the movie clip with the current direction, as shown in the
    following line of code:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加对当前方向的影片剪辑的引用，如下面的代码行所示：
- en: '[PRE48]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Create a tween object for each cannonball and their respective *x* and *y*
    properties:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个炮弹及其相应的*x*和*y*属性创建一个补间对象：
- en: '[PRE49]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Set up the cannonballs and their tween properties for a direction pair, as
    shown in the following code:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下代码设置炮弹及其补间属性的方向对：
- en: '[PRE50]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Set up the cannonballs for the `DirectionEast/DirectionWest` pair.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`DirectionEast/DirectionWest`对设置炮弹。
- en: Set both cannonballs to be visible on the screen and add all cannonball-related
    tweens to the main juggler.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个炮弹设置为在屏幕上可见，并将所有与炮弹相关的补间添加到主杂技师中。
- en: Remove all tweens that originate from the cannonballs just after the line where
    we removed all tweens originating from the movie clips.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在移除所有来自电影剪辑的缓动效果之后，立即移除所有来自炮弹的缓动效果。
- en: Once the movie clip is finished, set the `_isShooting` instance variable to
    `NO` and hide both cannonballs.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦电影剪辑播放完毕，将 `_isShooting` 实例变量设置为 `NO` 并隐藏两个炮弹。
- en: Run the example. Our pirate ship can now shoot cannonballs, as shown in the
    following screenshot:![Time for action – allowing the ship to shoot cannonballs](img/1509OS_06_04.jpg)
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例。现在我们的海盗船可以发射炮弹，如下面的截图所示：![行动时间 – 允许船发射炮弹](img/1509OS_06_04.jpg)
- en: '*What just happened?*'
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: 'We started this example in the header file of the `Ship` class, where we added
    a few new properties, such as:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个示例中从 `Ship` 类的头文件开始，添加了一些新的属性，例如：
- en: '`isShooting`: This indicates if the ship is currently shooting (step 2)'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isShooting`：这表示船当前是否在射击（步骤 2）'
- en: '`cannonBallLeft`: This indicates the cannonball shooting from the left-hand
    side of the ship (step 3)'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cannonBallLeft`：这表示从船的左侧发射的炮弹（步骤 3）'
- en: '`cannonBallRight`: This indicates the cannonball shooting from the right-hand
    side of the ship (step 3)'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cannonBallRight`：这表示从船的右侧发射的炮弹（步骤 3）'
- en: 'In the next steps, we modified the `initWithType` method using the following
    steps:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们使用以下步骤修改了 `initWithType` 方法：
- en: We set `_isShooting` to a default value, which is `NO` (step 5)
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将 `_isShooting` 设置为默认值，即 `NO`（步骤 5）
- en: We created the cannonball objects (step 6)
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了炮弹对象（步骤 6）
- en: We hid both cannonballs (step 6)
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们隐藏了两个炮弹（步骤 6）
- en: We added the cannonballs to the display tree (step 6)
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将炮弹添加到显示树中（步骤 6）
- en: 'Let''s head into the `shoot` method and see what changed here:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进入 `shoot` 方法，看看这里有什么变化：
- en: We only executed the method if the ship was not shooting to minimize potential
    side effects and prevent someone from tapping on the ship all the time (step 7).
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们只有在船没有射击时才执行该方法，以最小化潜在的副作用并防止有人一直点击船（步骤 7）。
- en: We defined the variable `shootingTime` at the time the shooting took place.
    It is set to 1.2 seconds because this is the approximate length of the movie clip
    animation (step 8).
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在射击发生时定义了变量 `shootingTime`。它被设置为 1.2 秒，因为这大约是电影剪辑动画的长度（步骤 8）。
- en: The variable `innerBox` was the distance from the edge of the ship image to
    the actual image itself (step 8).
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量 `innerBox` 是船图像边缘到实际图像本身的距离（步骤 8）。
- en: The variable `targetPos` stored how far the cannonballs would fly (step 8).
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量 `targetPos` 存储了炮弹将飞行的距离（步骤 8）。
- en: For convenience, we defined the `currentClip` variable, so we didn't have to
    type `_shootingClip[self.direction]` each time we wanted to access the movie clip
    of the current direction (step 9).
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了方便，我们定义了 `currentClip` 变量，这样我们就不必每次想要访问当前方向的动画剪辑时都输入 `_shootingClip[self.direction]`（步骤
    9）。
- en: We defined a tween for each coordinate and cannonball, so in total, we had four
    tweens at this point (step 10).
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为每个坐标和炮弹定义了一个缓动效果，所以到目前为止，我们总共有四个缓动效果（步骤 10）。
- en: In steps 11 and 12, we set up the positions and the tweens for the cannonballs.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在步骤 11 和 12 中，我们设置了炮弹的位置和缓动效果。
- en: We needed to see the cannonballs on the screen, which is why we set them to
    be visible. To see the corresponding animation, we needed to add the tweens to
    the juggler (step 13).
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要在屏幕上看到炮弹，这就是为什么我们将它们设置为可见。为了看到相应的动画，我们需要将缓动效果添加到杂耍者中（步骤 13）。
- en: We also removed all tweens originating from the cannonballs before we actually
    played the animation (step 14).
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在实际播放动画之前，我们还移除了所有来自炮弹的缓动效果（步骤 14）。
- en: The last thing we needed to update in the `shoot` method was setting the `_isShooting`
    instance variable to `NO` once the animation was complete, and we hid both cannonballs
    in the same block (step 15).
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `shoot` 方法中最后需要更新的东西是将 `_isShooting` 实例变量设置为 `NO`，一旦动画完成，并在同一块中隐藏两个炮弹（步骤 15）。
- en: When we ran the example and double-tapped our pirate ship, the movie clip played
    and two huge cannonballs emerged from both sides of the ship.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行示例并双击我们的海盗船时，电影剪辑播放，两个巨大的炮弹从船的两侧出现。
- en: Have a go hero
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下，英雄
- en: So far, the ship cannot shoot diagonally. Go ahead and implement this functionality
    on your own.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，船不能斜向射击。请自行实现这个功能。
- en: Collision detection
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞检测
- en: 'Before we implement collision detection, let''s take a look at different types
    of collision detections:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现碰撞检测之前，让我们看看不同类型的碰撞检测：
- en: '**Bounding box collision**: We check the bounds of the entities (which is a
    rectangle). If these rectangles intersect, we have a collision.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边界框碰撞**：我们检查实体的边界（这是一个矩形）。如果这些矩形相交，则表示发生了碰撞。'
- en: '**Bounding sphere collision**: We calculate the distance between two entities.
    If the distance is smaller than the radius of both entities combined, these entities
    are colliding.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边界球体碰撞**：我们计算两个实体之间的距离。如果距离小于两个实体半径之和，则这些实体正在碰撞。'
- en: '**Pixel collision**: We check if all the pixels of one entity intersect with
    the pixels of another entity. While this is definitely the most detailed and comprehensive
    collision check, it is also the most CPU-intensive one.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**像素碰撞**：我们检查一个实体的所有像素是否与另一个实体的像素相交。虽然这确实是最详细和全面的碰撞检查，但它也是最占用 CPU 资源的一种。'
- en: Now that our pirate ship is actually shooting cannonballs, let's implement the
    functionality that can hit and sink the enemy ship. We use the bounding box collision
    because this is one of the easiest collision detection types to implement.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经让海盗船实际上开始射击炮弹了，让我们实现可以击沉敌舰的功能。我们使用边界框碰撞，因为这是最容易实现的碰撞检测类型之一。
- en: Time for action – letting cannonballs collide with ships
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 让炮弹与船只碰撞
- en: 'To check if cannonballs collide against the enemy ship, follow these steps:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查炮弹是否与敌舰碰撞，请按照以下步骤操作：
- en: Open the `Ship.h` file.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Ship.h` 文件。
- en: We need to add custom getters and setters to the `hitpoints` property, so let's
    make this property `nonatomic` and add an instance variable called `_hitpoints`.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为 `hitpoints` 属性添加自定义的获取器和设置器，所以让我们将这个属性设置为 `nonatomic` 并添加一个名为 `_hitpoints`
    的实例变量。
- en: Declare the methods `abortShooting` and `hit`.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明 `abortShooting` 和 `hit` 方法。
- en: Switch to the `Ship.m` file.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到 `Ship.m` 文件。
- en: The custom `hitpoints` getter just returns the instance variable `_hitpoints`.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自定义的 `hitpoints` 获取器仅返回实例变量 `_hitpoints`。
- en: 'The custom setter for `hitpoints` contains the following code:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`hitpoints` 的自定义设置器包含以下代码：'
- en: '[PRE51]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `abortShooting` method consists of the following lines:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`abortShooting` 方法包含以下行：'
- en: '[PRE52]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `hit` method has the following content:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`hit` 方法包含以下内容：'
- en: '[PRE53]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In the battlefield header file, we need to add an instance variable called `_enemyShip`,
    which is a pointer to the class `Ship`.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在战场头文件中，我们需要添加一个名为 `_enemyShip` 的实例变量，它是指向 `Ship` 类的指针。
- en: Update the references from `ship` to `_enemyShip`.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新从 `ship` 到 `_enemyShip` 的引用。
- en: 'Add an event listener to the `SP_EVENT_TYPE_ENTER_FRAME` event, as shown in
    the following code:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个事件监听器来监听 `SP_EVENT_TYPE_ENTER_FRAME` 事件，如下面的代码所示：
- en: '[PRE54]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Implement the `onEnterFrame` method with the following lines of code:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码实现 `onEnterFrame` 方法：
- en: '[PRE55]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Run the example. When the enemy ship is hit, it flashes red for a moment, as
    shown in the following screenshot:![Time for action – letting cannonballs collide
    with ships](img/1509OS_06_05.jpg)
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例。当敌舰被击中时，它会短暂地闪烁红色，如下面的截图所示：![行动时间 – 让炮弹与船只碰撞](img/1509OS_06_05.jpg)
- en: '*What just happened?*'
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: In step 2, we updated our `hitpoints` property so that we can add custom getters
    and setters. In the next step, we declared the methods `abortShooting` and `hit`.
    We needed the first method to cancel the current shooting animations and the second
    method to do something when a ship has been hit.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 2 中，我们更新了 `hitpoints` 属性，以便我们可以添加自定义的获取器和设置器。在下一步中，我们声明了 `abortShooting`
    和 `hit` 方法。我们需要第一个方法来取消当前的射击动画，第二个方法则在船只被击中时执行某些操作。
- en: We defined the custom getter and setter in steps 5 and 6, respectively. For
    the getter, we just returned the instance variable `_hitpoints` that we declared
    in step 2\. For the setter, we set this instance variable; but when `_hitpoints`
    equals or was below zero, we hid the ship.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在步骤 5 和 6 中分别定义了自定义的获取器和设置器。对于获取器，我们只是返回了我们在步骤 2 中声明的实例变量 `_hitpoints`。对于设置器，我们设置了该实例变量；但是当
    `_hitpoints` 等于或低于零时，我们隐藏了船只。
- en: The `abortShooting` method in step 7 set the `_isShooting` instance variable,
    removed all tweens from the cannonballs, and hid the cannonballs as well.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤 7 中的 `abortShooting` 方法设置了 `_isShooting` 实例变量，从炮弹中移除了所有补间动画，并隐藏了炮弹。
- en: The `hit` method subtracted 25 points from `hitpoints` and added an animation
    that let the ship flash red for a very short amount of time to get some visual
    feedback if a ship had been hit.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`hit` 方法从 `hitpoints` 中减去 25 分，并添加了一个动画，让船只非常短暂地闪烁红色，以便在船只被击中时提供一些视觉反馈。'
- en: In the next two steps, we refactored the enemy ship instance to be an instance
    variable, instead of being a local variable inside the initializer. We also updated
    all references to the enemy ship.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两个步骤中，我们将敌舰实例重构为一个实例变量，而不是初始化器内部的局部变量。我们还更新了所有对敌舰的引用。
- en: In step 11, we added an event listener. This event listener was called on each
    frame. In the next step, we implemented the collision between the enemy ship and
    the cannonballs from the pirate ship.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 11 中，我们添加了一个事件监听器。这个事件监听器在每个帧上被调用。在下一个步骤中，我们实现了敌舰和海盗船的炮弹之间的碰撞。
- en: First, we needed to get the bounds from each of these objects relative to the
    current scene. We needed to see if any of the cannonballs intersected with the
    enemy ship. In order to make sure that the cannons were actually firing, we checked
    for the visibility of the cannonballs, and then we called the `hit` method from
    the enemy ship and the `abortShooting` method from the pirate ship. The latter
    was necessary, otherwise the check would happen again with a positive result,
    so much so that the enemy ship would be destroyed instantly and we wouldn't even
    get to see the red flashing ship.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要从每个对象相对于当前场景的边界值。我们需要查看是否有任何炮弹与敌舰相交。为了确保大炮实际上在开火，我们检查了炮弹的可见性，然后从敌舰调用了
    `hit` 方法，从海盗船调用了 `abortShooting` 方法。后者是必要的，否则检查会再次发生，并且结果为正，以至于敌舰会立即被摧毁，我们甚至看不到那艘闪烁的红船。
- en: When we ran the example, we needed to hit the enemy ship exactly four times
    for it to disappear. Each time the enemy ship was hit, it flashed red for a moment.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行示例时，我们需要准确击中敌舰四次，它才会消失。每次敌舰被击中，它都会短暂地闪烁红色。
- en: Loading gameplay-relevant data
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载游戏相关数据
- en: 'Let''s reflect on what kind of gameplay-relevant data we have at this moment.
    They are:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们反思一下此刻我们拥有的游戏相关数据类型。它们是：
- en: Hit points for each ship
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每艘船的生命值
- en: The damage a cannonball inflicts
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 炮弹造成的损伤
- en: Positions for each ship in the battlefield
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 战场中每艘船的位置
- en: We should put this data in a file and load it in the game.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该将这些数据放在一个文件中，并在游戏中加载它。
- en: Time for action – avoiding hardcoded values
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 避免硬编码值
- en: 'To separate and load our gameplay-relevant data, we need to follow these steps:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分离和加载我们的游戏相关数据，我们需要遵循以下步骤：
- en: 'Add a new file called `gameplay.json` in the `Resources` folder with the following
    content:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Resources` 文件夹中添加一个名为 `gameplay.json` 的新文件，内容如下：
- en: '[PRE56]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Open the `Ship.h` file.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Ship.h` 文件。
- en: 'Add a property called `maxHitpoints`, as shown in the following line of code:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `maxHitpoints` 的属性，如下面的代码行所示：
- en: '[PRE57]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Inside the `Ship` initializer, replace the piece of code where we set `hitpoints`
    with the following lines of code:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Ship` 初始化器内部，将设置 `hitpoints` 的代码段替换为以下几行代码：
- en: '[PRE58]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Inside the `hit` method, replace the hardcoded damage value to load from the
    `gameplay.json` file, as shown in the following code:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `hit` 方法内部，将硬编码的损伤值替换为从 `gameplay.json` 文件中加载的值，如下面的代码所示：
- en: '[PRE59]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Inside the `Battlefield.m` file, replace the hardcoded ship positions with
    those from the `gameplay.json` file, as shown in the following code:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Battlefield.m` 文件内部，将硬编码的船只位置替换为来自 `gameplay.json` 文件的那些，如下面的代码所示：
- en: '[PRE60]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Run the example.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例。
- en: 'Instead of having hardcoded values in our code, we are now loading the values
    from a file. As a result, the ships are at different starting positions, as shown
    in the following screenshot:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在不再在代码中硬编码值，而是从文件中加载这些值。因此，船只处于不同的起始位置，如下面的截图所示：
- en: '![Time for action – avoiding hardcoded values](img/1509OS_06_06.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![行动时间 – 避免硬编码值](img/1509OS_06_06.jpg)'
- en: '*What just happened?*'
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: In step 1, we created the JSON file with values that we will load later on.
    The values we have so far are the hit points, damage, and of course, positions
    of the ships.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 1 中，我们创建了 JSON 文件，其中包含我们稍后将要加载的值。我们目前拥有的值包括生命值、损伤值，当然还有船只的位置。
- en: Inside the `Ship.h` file, we added a new property called `maxHitpoints`, which
    indicates the maximum health of any ship.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Ship.h` 文件内部，我们添加了一个名为 `maxHitpoints` 的新属性，它表示任何船只的最大健康值。
- en: In step 4, we first set the `maxHitpoints` property with the `hitpoints` property
    from the `gameplay.json` file. Since a property is loaded from the `gameplay.json`
    file and it is from the type `id`, we need to cast it into a more familiar data
    type. We casted it into a pointer to `NSNumber` and then used its integer value
    through the `intValue` method.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4步中，我们首先使用`gameplay.json`文件中的`hitpoints`属性设置`maxHitpoints`属性。由于属性是从`gameplay.json`文件加载的，并且其类型为`id`，我们需要将其转换为更熟悉的数据类型。我们将它转换为指向`NSNumber`的指针，然后通过`intValue`方法使用其整数值。
- en: In the next step, we did the same for the `damage` property.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们对`damage`属性也做了同样的处理。
- en: In step 6, we switched to the battlefield scene and updated the positions for
    the ships to reflect the same from the `gameplay.json` file.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6步中，我们切换到战场场景，并更新了船只的位置，以反映来自`gameplay.json`文件中的相同位置。
- en: When we ran the example, our ships were at the position we defined in the `gameplay.json`
    file. Shooting and destroying an enemy worked as expected.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行示例时，我们的船只位于我们在`gameplay.json`文件中定义的位置。射击和摧毁敌人按预期工作。
- en: Pop quiz
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 突击测验
- en: Q1\. How can event listeners be described?
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 如何描述事件监听器？
- en: Using blocks
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用块
- en: Using selectors
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用选择器
- en: Using selectors or blocks
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用选择器或块
- en: Q2\. When is an event registered to `SP_TYPE_EVENT_ENTER_FRAME` called?
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: Q2. 何时调用注册到`SP_TYPE_EVENT_ENTER_FRAME`的事件？
- en: Once in the first frame after it's added to the display tree
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦在添加到显示树的第一帧中
- en: Once every frame
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每一帧一次
- en: Never
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从不
- en: Q3\. Detecting double taps is not possible with Sparrow.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: Q3. 使用Sparrow无法检测双击。
- en: 'True'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误
- en: Summary
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about adding the basic game logic elements to our
    game.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何将基本游戏逻辑元素添加到我们的游戏中。
- en: Specifically, we covered how to structure our code. We got a deeper knowledge
    of touches, event listeners, and collision detections.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们介绍了如何构建我们的代码。我们对触摸、事件监听器和碰撞检测有了更深入的了解。
- en: Now that our pirate ship can actually shoot and hit things, let's add user-interface
    elements—which is the topic of the next chapter.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的小海盗船实际上可以射击并击中东西了，让我们添加用户界面元素——这是下一章的主题。
