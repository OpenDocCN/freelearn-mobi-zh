- en: Chapter 4. Design Patterns with Swift
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章. 使用 Swift 的设计模式
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Writing into a log file
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入日志文件
- en: Creating a factory of musical notes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建音乐音符的工厂
- en: Simulating a home automation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟家庭自动化
- en: Delivering some pizzas
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递送一些披萨
- en: Protocol-oriented programming
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协议导向编程
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: When object-oriented programming was introduced, the developers noticed that
    there were some objects or classes that were programmed following the same philosophy.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当面向对象编程被引入时，开发者注意到有一些对象或类是按照相同的哲学编程的。
- en: Xerox labs, for example, introduced the Model-View-Controller pattern in the
    70s to develop programs using SmallTalk. A few other patterns were introduced
    by Xerox, but they were not called this.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，施乐实验室在70年代引入了模型-视图-控制器模式，用于使用 SmallTalk 开发程序。施乐还引入了一些其他模式，但它们并没有被这样称呼。
- en: When a book called *Design Patterns* was released in 1994, written by the Gang
    of Four, it brought solutions for common engineering problems. It demonstrated
    that the main problem with software development costs was maintenance; the usage
    of design patterns would cause a high cost in the first phase of software development
    but it would significantly reduce the maintenance costs.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当1994年出版了一本名为《设计模式》的书，作者是四人帮，它为常见的工程问题提供了解决方案。它表明软件开发成本的主要问题是维护；使用设计模式会在软件开发的第一阶段造成高昂的成本，但它会显著降低维护成本。
- en: Nowadays, design patterns are so important that it is very common to talk about
    them in job interviews. If you are experienced in Swift or Objective-C, you've
    already used some of these patterns without realizing.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，设计模式如此重要，以至于在面试中谈论它们非常普遍。如果你在 Swift 或 Objective-C 方面有经验，你已经在不知不觉中使用了其中的一些模式。
- en: In this chapter, we will cover a few design patterns; if possible, we will look
    at some common samples of these patterns in Swift.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍几个设计模式；如果可能的话，我们将查看这些模式在 Swift 中的常见示例。
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Before we start, I''d like to comment that design patterns are very questionable
    nowadays; for example, the singleton pattern that is shown in the *Writing into
    a log file* recipe of this chapter was criticized by some developers because it
    is very easy to implement, and this is also the reason some programmers avoid
    this pattern. Others don''t think that way, they think that you can use it, but
    only at the right moment, as the author explains in this URL: [http://www.ibm.com/developerworks/library/co-single/](http://www.ibm.com/developerworks/library/co-single/).
    Anyway, arguing about this topic is out of the scope of this book. I will show
    you some patterns, and then you can decide whether to use them and when.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我想评论一下，如今设计模式非常值得怀疑；例如，本章“写入日志文件”的食谱中展示的单例模式被一些开发者批评，因为它非常容易实现，这也是一些程序员避免使用这种模式的原因。其他人并不这样认为，他们认为你可以使用它，但只有在正确的时候，正如作者在这篇URL中解释的那样：[http://www.ibm.com/developerworks/library/co-single/](http://www.ibm.com/developerworks/library/co-single/)。无论如何，关于这个话题的争论超出了本书的范围。我将向你展示一些模式，然后你可以决定是否使用它们以及何时使用。
- en: Another detail I'd like to comment on is that some examples can look more complicated
    than those without patterns. Don't forget that design patterns are not based on
    simplicity, but in software maintenance.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我还想评论的另一个细节是，一些示例可能比没有模式的示例看起来更复杂。别忘了设计模式不是基于简单性，而是基于软件维护。
- en: Writing into a log file
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写入日志文件
- en: 'This recipe is about a very simple and also a very common pattern design: the
    Singleton pattern. The idea of this pattern is to have an object with only one
    instance. You''ve already used this pattern in Swift or Objective-C, for example,
    when you used UIDevice or UIApplication.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱是关于一个非常简单但也很常见的模式设计：单例模式。这个模式的想法是只有一个实例的对象。你已经在使用 Swift 或 Objective-C 时使用过这个模式，例如，当你使用
    UIDevice 或 UIApplication 时。
- en: For this recipe, we will create an object that will write out logs into a file.
    Note that it doesn't matter where we are in our application code, we should write
    only into one single file using one single object.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们将创建一个对象，它将把日志写入文件。请注意，我们在应用程序代码中的位置无关紧要，我们应该只使用一个对象写入一个单独的文件。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: As we will write into a file, you will probably like to see its contents after
    running the application. Before we start, let's check whether we are able to see
    the destination folder.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将写入文件，你可能在运行应用程序后想查看其内容。在我们开始之前，让我们检查我们是否能够看到目标文件夹。
- en: 'If you use the simulator, open the Finder window and go to your home directory;
    you can use the shortcut *command* + *shift* + *H*. If you can''t see a folder
    called `Library`, you have to press *command* + *J* to show the view options.
    Now, check the **Show Library Folder** option, as shown in the following screenshot:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用模拟器，打开Finder窗口并转到你的主目录；你可以使用快捷键*command* + *shift* + *H*。如果你看不到名为`Library`的文件夹，你必须按*command*
    + *J*来显示视图选项。现在，检查**显示库文件夹**选项，如以下截图所示：
- en: '![Getting ready](img/00038.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/00038.jpeg)'
- en: Of course, you won't have the application if you haven't run it yet, so on your
    `viewDidLoad` method, paste the code `print(NSHomeDirectory())` to know your path,
    and then you can follow it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你还没有运行应用程序，你就不会有这个应用程序，所以在你`viewDidLoad`方法中，粘贴代码`print(NSHomeDirectory())`以了解你的路径，然后你可以跟随它。
- en: Tip
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: An easy way to open the document folder of the application is to print the home
    directory and copy it. Then, you can go to the **Finder** application, press *command*
    + *shift* + *G* and paste your path.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 打开应用程序文档文件夹的一个简单方法是打印主目录并复制它。然后，你可以转到**Finder**应用程序，按*command* + *shift* + *G*并粘贴你的路径。
- en: How to do it…
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Let's create a small calculator and record the user actions. Remember that we
    don't need to instantiate the logger object every time we use the log; as it will
    be a singleton, you can call it from anywhere. So, let's get started.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个小型计算器并记录用户操作。记住，我们每次使用日志时不需要实例化日志对象；因为它将是一个单例，你可以从任何地方调用它。所以，让我们开始吧。
- en: 'Start a project called `Chapter 4 Log File` and create a file called `Log.swift`.
    Here is where we will define our log class. Copy the following code into the file:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始一个名为`Chapter 4 Log File`的项目，并创建一个名为`Log.swift`的文件。这里我们将定义我们的日志类。将以下代码复制到文件中：
- en: '[PRE0]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, of course, we need to complete our application to check the usage of our
    code. Go to the storyboard and add two text fields (each of them will represent
    a number), a segmented control that will represent the current operator, a button
    to show the result, and a label where the result will be displayed. Your layout
    should be similar to the following one:![How to do it…](img/00039.jpeg)
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当然，我们需要完成我们的应用程序以检查我们代码的使用。转到故事板，并添加两个文本字段（每个字段将代表一个数字）、一个表示当前操作符的分段控件、一个显示结果的按钮，以及一个显示结果的标签。你的布局应类似于以下之一：![如何做到这一点…](img/00039.jpeg)
- en: 'Now, let''s code the view controller. First, let''s add the attributes:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写视图控制器。首先，让我们添加一些属性：
- en: '[PRE1]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Don''t forget to link each graphic component with its attribute. Now, it''s
    time to code our program methods; in this case, we will develop a method to save
    the chosen operator and another to show the results:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要忘记将每个图形组件与其属性链接。现在，是我们编写程序方法的时候了；在这种情况下，我们将开发一个保存所选操作符的方法，以及一个显示结果的方法：
- en: '[PRE2]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To finish our application, we should add a little bit of code on our application
    delegate. Filling these events will register when the user has opened the application,
    put the application on in the background, and returned to the application. Here
    is the code:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成我们的应用程序，我们应在应用程序代理上添加一些代码。填充这些事件将在用户打开应用程序、将应用程序置于后台以及返回到应用程序时注册。以下是代码：
- en: '[PRE3]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, click on play and test the program; then, press the Home button and come
    back to the application. When you are done, go to the application documents folder,
    as demonstrated at the beginning, and open the file `application.log`. Note that
    every action was registered on the same file; it doesn't matter if it was an event
    produced by the app delegate or by the view controller.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击播放并测试程序；然后，按住主页按钮并返回到应用程序。完成操作后，前往应用程序文档文件夹，如开头所示，并打开文件`application.log`。请注意，所有操作都记录在同一个文件中；无论是应用程序代理还是视图控制器产生的事件，都没有关系。
- en: How it works…
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, we will see the introduction of the access control. Swift has
    three access levels:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将看到访问控制的介绍。Swift 有三个访问级别：
- en: '**Public**: In this level, the object, attribute, or global variable can be
    used from anywhere, even from another module'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公共**：在这个级别，对象、属性或全局变量可以从任何地方使用，甚至可以从另一个模块'
- en: '**Internal**: In this level, the corresponding entity can be accessed from
    anywhere, except from another module'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内部**：在这个级别，相应的实体可以从任何地方访问，除了另一个模块'
- en: '**Private**: In this level, the entity can be accessed only from the current
    file, even from the same module'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**私有**：在这个级别，实体只能从当前文件访问，即使是同一个模块'
- en: As you can see, the idea of a singleton is to make sure that there will be only
    one instance of a class. As the initializer of the class is private, it can't
    be called from anywhere, but only from a method or function that is in the current
    file.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，单例模式的思想是确保一个类只有一个实例。由于类的初始化器是私有的，它不能从任何地方调用，只能从当前文件中的方法或函数中调用。
- en: So, we created a method called `getInstance` to access the only instance we
    have, and then we can access the object methods. Notice that we had to use classes;
    if we used structs, we would break the rule of one object only.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们创建了一个名为`getInstance`的方法来访问我们拥有的唯一实例，然后我们可以访问对象方法。请注意，我们必须使用类；如果我们使用结构体，就会破坏只有一个对象的原则。
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Sometimes, you will see the implementation of a singleton accepting nil values,
    such as `private var myLogInstance:Log?`, and then initializing it inside the
    `getInstance` method, such as:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你会看到单例的实现接受nil值，例如`private var myLogInstance:Log?`，然后在`getInstance`方法中初始化它，例如：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The reason is that some software architects think that you don't have to start
    your application instantiating every singleton object, except when you are going
    to use it. There are some singleton objects that are never called, and you shouldn't
    waste this memory. If you notice, this class also had a deinitializer. Technically
    speaking, this method won't be called if you are running your application on iOS
    because iOS apps usually don't finish. However, the application can still end
    in certain circumstances, and you might close the file handle in the right way.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是一些软件架构师认为，你不需要在启动应用程序时实例化每个单例对象，除非你打算使用它。有一些单例对象永远不会被调用，你不应该浪费这些内存。如果你注意到，这个类还有一个析构器。从技术上讲，如果你在iOS上运行应用程序，这个方法不会被调用，因为iOS应用程序通常不会结束。然而，在特定情况下，应用程序仍然可以结束，你可能会正确地关闭文件句柄。
- en: Now, when talking about file usage, first of all, we have to know what the application
    document's folder path is, because this is the location we have chosen for writing
    the log file. There is a function called `NSSearchPathForDirectoriesInDomains`
    that returns the full path of a requested folder (actually, it returns an array
    of paths). After calling this function, we can create the file with the file manager
    and open it using `NSFileHandle`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们谈论文件使用时，首先，我们必须知道应用程序文档文件夹的路径，因为这是我们选择写入日志文件的位置。有一个名为`NSSearchPathForDirectoriesInDomains`的函数，它返回请求文件夹的完整路径（实际上，它返回一个路径数组）。在调用此函数后，我们可以使用文件管理器创建文件，并使用`NSFileHandle`打开它。
- en: Tip
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Don''t use paths by concatenating with the home directories in this manner:
    `NSHomeDirectory() + /Documents`. Apple can change its path in future versions
    like it did with the bundle on iOS 8.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 不要以这种方式通过连接家目录路径来使用路径：`NSHomeDirectory() + /Documents`。苹果可能会像在iOS 8中对捆绑包所做的那样，在未来版本中更改其路径。
- en: If this class wasn't a singleton, you wouldn't open this file here; you would
    open and close it every time you had to write a message because you must avoid
    having two open handles for the same file. Opening and closing a handle is a slow
    operation; it can affect your application performance.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个类不是单例，你不会在这里打开这个文件；每次你需要写入消息时，你都会打开和关闭它，因为你必须避免为同一文件打开两个句柄。打开和关闭句柄是一个缓慢的操作；它可能会影响你的应用程序性能。
- en: In the case of writing into the log file with a high frequency, you will have
    to avoid clashing the file writing or opening, but if you have a singleton, this
    problem is much easier to control.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在高频率写入日志文件的情况下，你必须避免文件写入或打开时的冲突，但如果你有一个单例，这个问题就更容易控制。
- en: To finish this recipe, I would like to comment that this simple log system is
    based on real log systems used in applications. Usually, log files try to register
    the log level, such as info, error, warning or debug, and its time. With this
    information in mind, you can filter your log when it gets bigger and figure out
    what is going on when the application has crashed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个菜谱，我想评论一下，这个简单的日志系统是基于应用程序中使用的真实日志系统。通常，日志文件会尝试记录日志级别，如info、error、warning或debug，以及时间。有了这些信息，当日志文件变大时，你可以过滤日志，并在应用程序崩溃时找出发生了什么。
- en: There's more…
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: The solution we had for our singleton application was to keep the object instance
    on a global variable; the ideal solution for this pattern is keeping it on a class
    variable, also called a static attribute. Swift 2 introduced support for static
    attributes so we no longer have to worry about this problem.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为单例应用程序找到的解决方案是将对象实例保存在全局变量中；对于这种模式来说，理想的做法是将它保存在类变量中，也称为静态属性。Swift 2 引入了对静态属性的支持，所以我们不再需要担心这个问题。
- en: Creating a factory of musical notes
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建音乐音符的工厂
- en: Composing music with computers is something very common nowadays. Creating software
    that allows a musician to create his own music looks easy but it is not, mainly
    because there are lots of possibilities for each note.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用计算机创作音乐现在是非常常见的。创建允许音乐家创作自己音乐的软件看起来很简单，但实际上并不简单，主要是因为每个音符都有很多可能性。
- en: In this recipe, we will use the pattern **Abstract Factory**. This pattern will
    allow us to change the note type that we want to create, and it will also initialize
    the note type for us.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将使用 **抽象工厂** 模式。这个模式将允许我们更改我们想要创建的音符类型，并且它也会为我们初始化音符类型。
- en: 'As you may know, there are a lot of note symbols; you can check this URL on
    Wikipedia if you want to know more about it: [http://en.wikipedia.org/wiki/List_of_musical_symbols](http://en.wikipedia.org/wiki/List_of_musical_symbols).'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，有很多音符符号；如果你想了解更多，可以查看维基百科上的这个链接：[http://en.wikipedia.org/wiki/List_of_musical_symbols](http://en.wikipedia.org/wiki/List_of_musical_symbols)。
- en: 'However, for this recipe, we will work with three types of notes: the drum
    quarter note, the piano quarter note, and the quarter rest note. Of course, this
    is only an example; in a real program, you will probably have to complete it with
    tied notes, and so on.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于这个食谱，我们将处理三种类型的音符：鼓的四分音符、钢琴的四分音符和四分休止符。当然，这只是一个例子；在一个真正的程序中，你可能需要完成它，比如添加连音等。
- en: Getting ready
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Create a project called `Chapter 4 Musical Notes`; now, download the pictures
    that correspond to this recipe from the Internet. In this case, we have these
    pictures: `staff.png`, `quarter_rest.png`, `cnote.png`, `dnote`, `cdrum.png`,
    and `ddrum.png`.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `Chapter 4 Musical Notes` 的项目；现在，从互联网上下载与此食谱对应的图片。在这种情况下，我们有这些图片：`staff.png`、`quarter_rest.png`、`cnote.png`、`dnote`、`cdrum.png`
    和 `ddrum.png`。
- en: We will also need some MP3 sounds for this recipe. Download three sounds for
    the piano notes and another three for the drums; of course, we won't have any
    sound for the rest note.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要为这个食谱准备一些 MP3 声音。下载三个钢琴音符的声音和另外三个鼓点的声音；当然，对于其他音符我们不会有声音。
- en: Place the pictures that were downloaded into your `images.xcassets` folder.
    If you like, you can also add the same pictures with different resolutions for
    use in different resolution devices (iPad and iPhone).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 将下载的图片放入你的 `images.xcassets` 文件夹中。如果你愿意，你也可以添加不同分辨率的相同图片，以便在不同的分辨率设备（iPad 和
    iPhone）上使用。
- en: Before you start, we will just need to add a framework called `AVFoundation`.
    This will enable our app to play sounds. To do this, just click on the project
    navigator, then click on build phases. After this, expand the **Link binary with
    Libraries** section, then click on the plus button. Select **AVFoundation** and
    click on **Add**.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始之前，我们只需要添加一个名为 `AVFoundation` 的框架。这将使我们的应用程序能够播放声音。为此，只需点击项目导航器，然后点击构建阶段。之后，展开
    **链接二进制与库** 部分，然后点击加号按钮。选择 **AVFoundation** 并点击 **添加**。
- en: How to do it…
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'As usual, we will start with the models. First, let''s create a note protocol,
    as we know that in future we can have more than one type of note and we should
    be prepared for it. So, create a new file called `NoteProtocol.swift` and put
    the following code in it:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如同往常，我们将从模型开始。首先，让我们创建一个音符协议，因为我们知道将来可能会有多种类型的音符，我们应该为此做好准备。因此，创建一个名为 `NoteProtocol.swift`
    的新文件，并将以下代码放入其中：
- en: '[PRE5]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The next step is to create an implementation of this protocol. Create a file
    called `MusicalNote.swift` and add the following content into it:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是创建这个协议的实现。创建一个名为 `MusicalNote.swift` 的文件，并将以下内容添加到其中：
- en: '[PRE6]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now that we have implemented our note class, see to it that this note is not
    piano-specific or drum-specific; we only need to build it in a different way according
    to the note type and step. So, now we need to define a factory of notes. With
    the same logic we applied before, we now need to create a protocol of a note.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经实现了音符类，请确保这个音符不是针对钢琴或鼓的特定音符；我们只需要根据音符类型和步长以不同的方式构建它。因此，现在我们需要定义一个音符工厂。使用我们之前应用的相同逻辑，我们现在需要创建一个音符协议。
- en: 'The only method that we will define is `createNote`, and it needs to know the
    note step (C, D, or E) and its position on the staff. It''s time to create a new
    file called `AbstractNoteFactory.swift` and type the following code:'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将定义的唯一方法是`createNote`，它需要知道音符步长（C、D或E）及其在乐谱上的位置。是时候创建一个名为`AbstractNoteFactory.swift`的新文件，并输入以下代码：
- en: '[PRE7]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once we have the definition of a note factory, we can start creating our own
    factories. Let''s start with the simplest one: `SilenceFactory`; this factory
    will create only one kind of note, no matter its step. Type this code in a file
    called `SilenceFactory.swift`:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们有了音符工厂的定义，我们就可以开始创建我们自己的工厂。让我们从最简单的一个开始：`SilenceFactory`；这个工厂将只创建一种音符，无论其步长如何。在名为`SilenceFactory.swift`的文件中输入以下代码：
- en: '[PRE8]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'With this class, we will save some steps for when we need to create a new silent
    note. Following the same logic, let''s create the piano factory and the drum factory.
    Use this code to create the piano factory:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这个类，我们将为创建新的静音笔记节省一些步骤。按照相同的逻辑，让我们创建钢琴工厂和鼓工厂。使用以下代码创建钢琴工厂：
- en: '[PRE9]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And now, let''s create the drum factory:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建鼓工厂：
- en: '[PRE10]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Good, it's time to create our layout. For this recipe, we will need to add a
    staff (the image view), which is where the notes will be displayed, a segmented
    control that will let us choose the note factory we want, and a play button that
    will appear after we create 10 notes and which will allow us to hear our music.![How
    to do it…](img/00040.jpeg)
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，现在是时候创建我们的布局了。对于这个食谱，我们需要添加一个乐谱（图像视图），这是音符将显示的地方，一个分段控制器，它将允许我们选择我们想要的音符工厂，以及一个在我们创建10个音符后出现的播放按钮，它将允许我们听到我们的音乐。![如何做到这一点…](img/00040.jpeg)
- en: We won't allow the user to play the music before it is completely composed.
    For this reason, the play button must start as invisible. To do this, after adding
    the button to the view on the storyboard, click on it, go to the attribute inspector,
    and select the **Hidden** option.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在音乐完全创作完成之前，我们不会允许用户播放音乐。因此，播放按钮必须一开始是不可见的。要做到这一点，在故事板上将按钮添加到视图中后，点击它，转到属性检查器，并选择**隐藏**选项。
- en: 'As you know, we now have to link the segmented control and the button with
    its attribute. Let''s also add other attributes that are necessary for this app:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如您所知，我们现在必须将分段控制器和按钮与其属性链接。让我们也添加这个应用所需的其他属性：
- en: '[PRE11]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 笔记
- en: In this case, we had to specify the factory type as `AbstractNoteFactory`; if
    not, it will be declared as `SilenceFactory`, and it won't allow us to change
    the factory type.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，我们必须指定工厂类型为`AbstractNoteFactory`；如果不这样做，它将被声明为`SilenceFactory`，并且不允许我们更改工厂类型。
- en: 'Let''s add the possibility to tap on the staff and add a note. To do this,
    we will add the following code on `viewDidLoad`:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加在乐谱上点击并添加音符的可能性。为此，我们将在`viewDidLoad`中添加以下代码：
- en: '[PRE12]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As you can see, every time we tap on the screen, we have to check whether it
    is in a place where we can add a note. Let''s implement this gesture action:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，每次我们点击屏幕时，我们都需要检查它是否在可以添加笔记的位置。让我们实现这个手势动作：
- en: '[PRE13]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As you can see, when we tap on the screen, we just ask for a new note; it doesn''t
    matter which one is the current factory. Now, the segmented control will change
    the current factory when the user wants it:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，当我们点击屏幕时，我们只是请求一个新的音符；当前是哪个工厂并不重要。现在，分段控制器将在用户想要时更改当前工厂：
- en: '[PRE14]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To finish this app, we have to create an event for the play button. As we are
    not going to press the button for each note, we will initialize the timer and
    create a method to play each note after half a second:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成这个应用，我们必须为播放按钮创建一个事件。由于我们不会为每个音符按下按钮，我们将初始化计时器，并在半秒后创建一个播放每个音符的方法：
- en: '[PRE15]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, click on play and compose your music.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击播放并创作你的音乐。
- en: How it works…
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The Abstract Factory pattern saves us from performing a lot of steps after instantiating
    an object. As a programmer, we don't need to worry about the class that the object
    needs to use, only the base class; in this case, it created an object of the `NoteProtocol`
    type.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂模式使我们免于在实例化对象后执行许多步骤。作为程序员，我们不需要担心对象需要使用的类，只需要基类；在这种情况下，它创建了一个`NoteProtocol`类型的对象。
- en: As every factory implements the same protocol, we don't need to check which
    the current factory is. We can also create new factories, and the code change
    wouldn't be painful.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个工厂都实现了相同的协议，我们不需要检查当前是哪个工厂。我们还可以创建新的工厂，代码更改也不会痛苦。
- en: There's more…
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: We will create another creational pattern that will allow us to create a home
    automation simulator.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建另一个创建型模式，这将允许我们创建智能家居模拟器。
- en: Simulating a home automation
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟智能家居
- en: Technology is getting more and more popular every day; soon we will control
    even our door locks from our mobile phones. However, how does it work? Imagine
    when you walk into your living room, a sensor can detect that there is someone
    there and it will turn on the light. Also, if a barometer detects that it is going
    to rain, it can close the home windows. The examples mentioned here are good samples
    of objects that change their status and tell other objects about this change.
    For this case, we will use the pattern **Observer**, also known as the **publisher-subscriber**
    pattern.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 技术每天都在变得越来越受欢迎；很快我们甚至可以从手机上控制我们的门锁。然而，它是如何工作的呢？想象一下，当你走进客厅时，一个传感器可以检测到有人在，它会打开灯。此外，如果气压计检测到将要下雨，它可以关闭家里的窗户。这里提到的例子是改变状态并通知其他对象这一变化的对象的好样本。对于这种情况，我们将使用模式
    **Observer**，也称为 **发布-订阅** 模式。
- en: In this recipe, we will create a sample of a home with only two windows, a door
    lock, and a clothes line. To make it simple, the application will read the sensor
    information from a file.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个只有两个窗户、一个门锁和一个晾衣绳的家居样本。为了简化，应用程序将从文件中读取传感器信息。
- en: When we receive information from the radar, it may be that someone is approaching
    your home. In this case, the door lock must be locked and the windows should be
    closed, or when this person goes away, the windows can be opened again. Also,
    when the barometer detects that it is going to rain, the windows must be closed
    and the clothes line must collect the clothes. When the rain stops, these robots
    can do the opposite action.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们收到雷达信息时，可能有人正在接近你的家。在这种情况下，门锁必须上锁，窗户应该关闭，或者当这个人离开时，窗户可以再次打开。此外，当气压计检测到将要下雨时，窗户必须关闭，晾衣绳必须收集衣物。当雨停了，这些机器人可以执行相反的动作。
- en: Getting ready
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's create a new project called `Chapter 4 Observer`. My first idea for this
    recipe was to create a list of actions into a file, but as with a few actions,
    it will be enough; we will create an array with actions instead.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为 `Chapter 4 Observer` 的新项目。我最初的想法是将动作列表创建到一个文件中，但随着几个动作的完成，这将是足够的；我们将创建一个包含动作的数组。
- en: How to do it…
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'First, let''s create the simplest model, which in our case is the door lock.
    Basically, the only thing that we need to do here is to store its status, which
    can be opened or closed. So, create a file called `DoorLock.swift` and add the
    following code:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建最简单的模型，在我们的例子中是门锁。基本上，我们在这里需要做的唯一一件事是存储其状态，可以是开启或关闭。因此，创建一个名为 `DoorLock.swift`
    的文件，并添加以下代码：
- en: '[PRE16]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once we''ve done the previous code, we can do something similar with the clothes
    line, so put the following code into a new file called `ClothesLine.swift`:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成前面的代码后，我们可以对晾衣绳做类似的事情，所以将以下代码放入一个新文件 `ClothesLine.swift` 中：
- en: '[PRE17]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Ok, now we need our last accessory, that is, the window. In this case, we have
    to store the count of times it was closed. Imagine that two people approach our
    house and one of them goes away; we have to keep the window closed because there
    is another person still near our house. So, create a file called `Window.swift`
    and add the following code:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，现在我们需要我们的最后一个配件，那就是窗户。在这种情况下，我们必须存储窗户关闭的次数。想象一下，两个人接近我们的房子，其中一个人离开了；我们必须保持窗户关闭，因为还有另一个人仍然靠近我们的房子。因此，创建一个名为
    `Window.swift` 的文件，并添加以下代码：
- en: '[PRE18]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Good, now it''s time to create the radar. Remember that the radar needs to
    store some objects that will notify the status change, so we will create a nested
    class called `RadarObserver`. Start adding this class into a new file called `Radar.swift`,
    as follows:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，现在是我们创建雷达的时候了。记住，雷达需要存储一些将通知状态变化的对象，所以我们将创建一个嵌套类 `RadarObserver`。开始将这个类添加到一个新文件
    `Radar.swift` 中，如下所示：
- en: '[PRE19]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This feature can be added because we are creating a nested class; Swift doesn't
    allow us to create nested protocols. Now, create the methods that store or remove
    the observers. We will not remove any observer in this recipe but, as I told you
    earlier, always be prepared for the future.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个功能可以添加，因为我们正在创建一个嵌套类；Swift 不允许我们创建嵌套协议。现在，创建存储或删除观察者的方法。在这个菜谱中，我们不会删除任何观察者，但正如我之前告诉你的，总是为未来做好准备。
- en: 'The last part of this class is the methods that change the object status:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个类的最后一部分是改变对象状态的方法：
- en: '[PRE20]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once we''ve understood it, we can create the barometer following the philosophy
    which we have used here:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们理解了它，我们就可以根据我们在这里使用的哲学创建气压计：
- en: '[PRE21]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Ok, now we can create our display. For this recipe, we will add five labels,
    one for each accessory and one to show the last action. We also need a button
    to start simulating the reception of radar and barometer events. You will see
    a view similar to the following one:![How to do it…](img/00041.jpeg)
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，现在我们可以创建我们的显示界面了。在这个菜谱中，我们将添加五个标签，每个标签对应一个配件，还有一个标签用于显示最后执行的动作。我们还需要一个按钮来开始模拟接收雷达和气压计事件。您将看到一个类似于以下视图的界面：![如何做…](img/00041.jpeg)
- en: 'Now, let''s link these components with the corresponding attributes:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将这些组件与相应的属性链接起来：
- en: '[PRE22]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, let''s go to the view controller and let''s start completing the attributes.
    In this case, we need a radar, a barometer, two windows, a door lock, a clothes
    line, a list of actions that will be performed, and a timer to make the simulation
    easier for our eyes:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们转到视图控制器，并开始完成属性。在这种情况下，我们需要一个雷达、一个气压计、两个窗户、一个门锁、一个晾衣绳、一个将要执行的动作列表和一个计时器，以便使模拟对眼睛更容易：
- en: '[PRE23]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, let''s create a private function that will update the labels. This function
    is an auxiliary function, so we don''t need to repeat this code in every observer
    action:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个私有函数来更新标签。这个函数是一个辅助函数，所以我们不需要在每个观察者动作中重复这段代码：
- en: '[PRE24]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, on our `viewDidLoad` method, we will add the observer''s code. The following
    code only has the creation of the first two observers; you have to complete it
    following the same rule because it will be exhausting showing all of them:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在我们的`viewDidLoad`方法中，我们将添加观察者的代码。以下代码只创建了前两个观察者；您必须按照相同的规则完成它，因为展示所有这些会非常繁琐：
- en: '[PRE25]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, we can complete creating the simulator, the event of our button, which
    will initialize the actions and the timer, and a function that will be called
    by the timer and perform the corresponding action:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以完成创建模拟器，按钮的事件，它将初始化动作和计时器，以及一个将被计时器调用并执行相应动作的函数：
- en: '[PRE26]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It's done now! Click on play and watch it work.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在完成了！点击播放并观看它的工作。
- en: How it works…
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: As you can see, the main goal of an observer is to execute an action, and to
    do this we used closures. This Swift feature is equivalent to blocks on Objective-C
    and function variables in JavaScript. A closure knows where the object was created
    and can access its attributes even if it was stored in another object.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，观察者的主要目标是执行一个动作，而为了做到这一点，我们使用了闭包。这个Swift特性在Objective-C中相当于blocks，在JavaScript中相当于函数变量。闭包知道对象是在哪里创建的，即使它被存储在另一个对象中，也能访问其属性。
- en: In our recipe, when the radar or the barometer detects something different,
    it will notify every observer who has subscribed to it. Each observer acts over
    the corresponding accessory (window, door lock, or that thing called a clothes
    line). Note that if we would like to write a traditional object method, it will
    be necessary to create new classes that inherit from the same observer and store
    in it the attribute that it is going to use. It wouldn't be a bad implementation,
    but using closures is much easier and more flexible.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的菜谱中，当雷达或气压计检测到不同的情况时，它将通知所有订阅了它的观察者。每个观察者都会对相应的配件（窗户、门锁或称为晾衣绳的东西）进行操作。请注意，如果我们想编写传统的对象方法，将需要创建新的类，这些类从同一个观察者继承，并存储它将要使用的属性。这不会是一个糟糕的实现，但使用闭包要容易得多，也更灵活。
- en: If you are a Martin Fowler fan, you have probably noticed that some code here
    is very similar to the barometer observer and the radar observer. This is what
    Mr. Martin calls the smell of a code, meaning that the code doesn't need to be
    technically wrong to still smell bad.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是Martin Fowler的粉丝，您可能已经注意到这里的一些代码与气压计观察者和雷达观察者非常相似。这就是Mr. Martin所说的代码的“味道”，意思是代码不需要在技术上出错，仍然可能很糟糕。
- en: That would be true in this case, except that this is just an example. Remember
    that in real life, the radar would probably have to notify you of the intruder's
    position, and the barometer would need to notify you of the precipitation, making
    the notifier's methods incompatible.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，这将是正确的，但这是一个例子。记住，在现实生活中，雷达可能需要通知您入侵者的位置，气压计需要通知您降水情况，这使得通知者的方法不兼容。
- en: There's more…
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: We already learned about behavioral patterns and creational patterns. In the
    next recipe, we will use a structural pattern, creating new object types based
    on a new feature.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了行为模式和创建模式。在下一个菜谱中，我们将使用结构模式，基于新特性创建新的对象类型。
- en: Delivering some pizzas
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 送一些披萨
- en: Imagine that you have to create a new window type which will have a border;
    the first idea is borrowed from a window class, creating a new class called `BorderedWindow`.
    You can do the same thing with scroll bars; call it `ScrolledWindow`. Now, if
    we need to create a window with a scroll and border, we have to create a new class
    called `ScrolledAndBorderedWindow`, but imagine that we now need to add a double
    and triple bordered window, which will have lots of combinations.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您必须创建一个具有边框的新窗口类型；第一个想法是从一个窗口类借用的，创建一个名为 `BorderedWindow` 的新类。您可以用相同的方式处理滚动条；称之为
    `ScrolledWindow`。现在，如果我们需要创建一个具有滚动和边框的窗口，我们必须创建一个名为 `ScrolledAndBorderedWindow`
    的新类，但想象一下，我们现在需要添加双边框和三边框的窗口，这将有很多组合。
- en: To prevent this kind of problem, there is a pattern called **decorator**; this
    pattern allows us to create new object types based on a new feature.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这类问题，有一个名为 **装饰器** 的模式；这个模式允许我们根据新特性创建新的对象类型。
- en: Getting ready
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project called `Chapter 4 Pizzas` and add the pizza image into
    `Images.xcassets`. Now, let's heat up the oven and prepare some pizzas.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `Chapter 4 Pizzas` 的新项目，并将披萨图片添加到 `Images.xcassets` 中。现在，让我们预热烤箱并准备一些披萨。
- en: How to do it…
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Let''s execute these steps to deliver some pizzas:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行这些步骤来送披萨：
- en: 'First of all, let''s create a base class that defines a pizza, so create a
    new file called `Pizza.swift` and create the following class:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个基类，定义披萨，因此创建一个名为 `Pizza.swift` 的新文件，并创建以下类：
- en: '[PRE27]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As you can see, this class stores the price and the pizza or ingredient name.
    Now, we can define some pizzas with their prices:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，这个类存储价格和披萨或配料名称。现在，我们可以定义一些披萨及其价格：
- en: '[PRE28]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create a new file called `PizzaDecorators.swift`; here is where we will create
    the extra ingredients. First, we need to create a class that defines what a pizza
    decorator is:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `PizzaDecorators.swift` 的新文件；这是我们创建额外配料的地方。首先，我们需要创建一个定义披萨装饰器的类：
- en: '[PRE29]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, let''s add some extra ingredients. In this case, we will have jalapeños,
    cheese, mushrooms, and olives:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加一些额外配料。在这种情况下，我们将有墨西哥辣椒、奶酪、蘑菇和橄榄：
- en: '[PRE30]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Good! Once you're done with that, we can create the view. We will add one label
    to display the total, four buttons for the extra ingredients, one text view to
    display the ingredients that we've already added to our pizza, and an Image View
    to make our application happier. At the end, we should have a layout similar to
    the one shown here:![How to do it…](img/00042.jpeg)
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的！完成这个任务后，我们可以创建视图。我们将添加一个标签来显示总数，四个按钮用于添加额外配料，一个文本视图来显示我们已添加到披萨中的配料，以及一个 Image
    View 来让我们的应用程序更愉快。最后，我们应该有一个类似于这里所示的布局：![如何做…](img/00042.jpeg)
- en: 'Now, we can create the view controller. Let''s start with the attributes:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以创建视图控制器。让我们从属性开始：
- en: '[PRE31]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let''s ask the user to select the pizza that he wants. In this case, we need
    to do it on `viewDidAppear` because we will do it with an action sheet, and this
    component doesn''t work on the `viewDidLoad` method because the view is not ready
    to display action sheets yet:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们要求用户选择他想要的披萨。在这种情况下，我们需要在 `viewDidAppear` 中做这件事，因为我们将通过操作表来做，这个组件在 `viewDidLoad`
    方法中不起作用，因为视图还没有准备好显示操作表：
- en: '[PRE32]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We need to create a method called `refreshPrice`; it is as easy as this one:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建一个名为 `refreshPrice` 的方法；它就像这样简单：
- en: '[PRE33]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To finish our application, we have to add the events that belong to the buttons;
    don''t forget to link them:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成我们的应用程序，我们必须添加属于按钮的事件；别忘了将它们链接起来：
- en: '[PRE34]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now the application is done, press play, choose a pizza, add some ingredients
    and enjoy your meal.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在应用程序已经完成，按播放，选择披萨，添加一些配料，享受您的餐点。
- en: How it works…
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The decorator pattern allows us to create a new object based on another one,
    which is very useful to prevent the creation of uncontrolled numbers of classes
    based on combinations of features.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式允许我们根据另一个对象创建新的对象，这对于防止基于特性组合创建无序数量的类非常有用。
- en: See also
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: There are more patterns. You can check them out on Wikipedia ([http://en.wikipedia.org/wiki/Software_design_pattern](http://en.wikipedia.org/wiki/Software_design_pattern)).
    Check which ones are the best for your project. There is also another feature
    called anti-pattern, which explains common bad practices. In the next chapter,
    we will learn how to work with concurrent code with Swift, something that is very
    common nowadays, mainly if you like to develop games.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有更多的模式。你可以在维基百科上查看它们（[http://en.wikipedia.org/wiki/Software_design_pattern](http://en.wikipedia.org/wiki/Software_design_pattern)）。检查哪些最适合你的项目。还有一个名为反模式的功能，它解释了常见的坏做法。在下一章中，我们将学习如何使用
    Swift 处理并发代码，这在当今非常常见，尤其是如果你喜欢开发游戏。
- en: Protocol-oriented programming
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向协议编程
- en: 'With the first version of Swift, you were able to extend classes, structs,
    and enums using extensions. This is a very powerful feature and allows you, the
    developer, to fine tune existing types to better meet your application needs.
    With Swift 2.0, Apple has included a new feature: protocol extensions. It is easy
    to only think of this as a small feature; however, it has the power to transform
    the way you write your code. Apple is calling this new paradigm protocol-oriented
    programming. In this recipe, we will learn how to take advantage of this new feature
    and some new patterns compared to object-oriented programming.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 的第一个版本中，你可以使用扩展来扩展类、结构和枚举。这是一个非常强大的功能，允许开发者根据应用程序的需求对现有类型进行微调。使用 Swift
    2.0，Apple 包含了一个新特性：协议扩展。很容易只把它看作是一个小特性；然而，它具有改变你编写代码方式的力量。Apple 将这种新范式称为面向协议编程。在这个食谱中，我们将学习如何利用这个新特性以及与面向对象编程相比的一些新模式。
- en: Getting ready
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, create a new playground titled `Chapter 4 Protocols`. We will
    be using a playground only for this recipe, so do not worry about any project
    settings.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，创建一个新的游乐场，命名为 `第4章 协议`。我们将只为这个食谱使用游乐场，所以不用担心任何项目设置。
- en: How to do it…
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Let''s start by adding some code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先添加一些代码：
- en: 'First, we will create two protocols and a struct that conforms to these two
    protocols, like so:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建两个协议和一个符合这两个协议的结构体，如下所示：
- en: '[PRE35]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'With OOP, we could have created a single superclass with all properties and
    subclasses when needed. However, this would result in a more complex superclass
    and each subclass would contain properties/functionality that it does not need.
    By defining `Flyable` and `Transportable` as protocols, we can have custom data
    types inherit from multiple sources instead of a single superclass. Now that we
    have some basic protocols, it''s time to actually extend them. Let''s extend the
    `Flyable` protocol to check whether another `Flyable` object is faster. Add this
    code to your playground:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用面向对象编程，我们可以在需要时创建一个包含所有属性的单个超类和子类。然而，这将导致超类更加复杂，每个子类都会包含它不需要的属性/功能。通过将 `Flyable`
    和 `Transportable` 定义为协议，我们可以让自定义数据类型从多个来源继承，而不是单个超类。现在我们已经有一些基本的协议，是时候真正扩展它们了。让我们扩展
    `Flyable` 协议来检查另一个 `Flyable` 对象是否更快。将以下代码添加到你的游乐场中：
- en: '[PRE36]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'It is important to note another new feature related to protocol extensions:
    default behaviors. If you look at our previous implementation, you will notice
    that we defined a method rather than declare one. Standard protocols require the
    conforming object to define each method, but with Swift 2.0, we can provide a
    default implementation so other classes do not have to.'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一个与协议扩展相关的新特性也很重要：默认行为。如果你查看我们之前的实现，你会注意到我们定义了一个方法而不是声明一个。标准协议要求符合的对象定义每个方法，但使用
    Swift 2.0，我们可以提供一个默认实现，这样其他类就不必这样做。
- en: 'Let''s create another extension, but only for types that also conform to the
    Transportable protocol. Add this code to your playground:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建另一个扩展，但仅针对也符合 Transportable 协议的类型。将以下代码添加到你的游乐场中：
- en: '[PRE37]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `Self` keyword with a capital `S` represents that class or structure that
    is conforming to the protocol. In this case it means the `Plane` class. Using
    this simple combination, you can see how useful protocol extensions can be with
    custom types. The real power of protocol extensions comes from your ability to
    extend the Swift Standard Library. Let's take a look.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 带有大写 `S` 的 `Self` 关键字表示符合协议的类或结构体。在这种情况下，它意味着 `Plane` 类。使用这个简单的组合，你可以看到协议扩展对于自定义类型是多么有用。协议扩展的真正力量来自于你扩展
    Swift 标准库的能力。让我们看看。
- en: Note
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Using the protocol extension feature with the Swift Standard Library allows
    us to add functionality to existing protocols such as `Equatable` and `CollectionType`
    (arrays and dictionaries).
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用协议扩展功能与Swift标准库一起，我们可以向现有的协议（如`Equatable`和`CollectionType`（数组和解构））添加功能。
- en: 'Let''s add functionality to `CollectionType` to get the average speed of `Flyable`
    types in an array. Add this code to your playground:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们给`CollectionType`添加功能，以获取数组中`Flyable`类型对象的平均速度。将以下代码添加到你的playground中：
- en: '[PRE38]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This protocol extension defines the `averageTopSpeed` method. The implementation
    is pretty simple. We define a count and total variable and then iterate through
    each item in the collection and add to the total while incrementing count. We
    have to manually increment count because `CollectionType` has a different property
    type for count (rather than `Int`).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这个协议扩展定义了`averageTopSpeed`方法。实现相当简单。我们定义了一个计数和总变量，然后遍历集合中的每个项目，并在增加计数的同时将其添加到总和中。我们必须手动增加计数，因为`CollectionType`的计数属性类型与`Int`不同。
- en: How it works…
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Because protocols provide more flexibility, you can create more finely tuned
    code to fit each of your application's needs. For the most power, utilize custom
    type protocol extensions as well as extending the Swift Standard Library extensions.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 由于协议提供了更多的灵活性，你可以创建更精细的代码来满足每个应用程序的需求。为了获得最大的功能，利用自定义类型协议扩展以及扩展Swift标准库扩展。
- en: Note how we are creating a struct for `Plane` rather than an object. This highlights
    one issue with OOP involving object reference.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何为`Plane`创建一个结构体而不是一个对象的。这突显了面向对象编程中涉及对象引用的一个问题。
- en: 'Imagine we have two objects: A and B. A creates some set of data and then shares
    this data with object B by reference. This means two different objects are referencing
    the same data object. B then changes some of this data. Now, object A may find
    data with changes it does not know how to handle. This may seem like a small issue
    but can cause many problems, even in simple applications.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 想象我们有两个对象：A和B。A创建了一些数据集，然后通过引用将此数据与对象B共享。这意味着两个不同的对象正在引用相同的数据对象。B随后更改了这些数据中的一些。现在，对象A可能会发现一些它不知道如何处理的数据变化。这似乎是一个小问题，但可能会在简单应用中引起许多问题。
- en: In Swift, structs are passed by value instead of reference. In our previous
    example, object A would have copied the data rather than pass a reference to it,
    thus each object would have its own copy that does not interfere with the other.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，结构体是通过值传递而不是引用传递的。在我们的上一个例子中，对象A会复制数据而不是传递其引用，因此每个对象都会有自己的副本，不会干扰其他对象。
- en: See also
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: If you would like to learn more or better understand why you would want to use
    protocol extensions and protocol-oriented programming, check out the WWDC 2015
    video titled *Protocol-Oriented Programming in Swift* ([https://developer.apple.com/videos/play/wwdc2015-408/](https://developer.apple.com/videos/play/wwdc2015-408/))
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想了解更多或更好地理解为什么你想使用协议扩展和面向协议的编程，请查看WWDC 2015的视频，标题为*Swift中的面向协议编程*([https://developer.apple.com/videos/play/wwdc2015-408/](https://developer.apple.com/videos/play/wwdc2015-408/))
