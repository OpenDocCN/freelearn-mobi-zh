- en: Chapter 5\. Customizing Kernel and Boot Sequence
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章\. 自定义内核和引导序列
- en: In the previous chapter, we created and deployed our first custom version of
    Android. We created a version for a commercial smartphone, the Google Nexus 6,
    and a more hard-core version for a development board, the Udoo Quad. We learned
    about more development tools, such as ADB and Fastboot. We focused on the debugging
    tools, mastering the serial connection, and the boot sequence.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建并部署了我们自己的第一个自定义Android版本。我们为商业智能手机Google Nexus 6创建了一个版本，并为开发板Udoo
    Quad创建了一个更硬核的版本。我们学习了更多开发工具，如ADB和Fastboot。我们专注于调试工具，掌握串行连接和引导序列。
- en: 'In this chapter, we will dive into the system—from the kernel customization
    to the boot sequence. You will learn how to retrieve the proper source code for
    Google devices, how to set up the build environment, how to build your first custom
    version of the Linux kernel, and deploy it to your device. You will learn about:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入系统——从内核定制到引导序列。您将学习如何获取谷歌设备的正确源代码，如何设置构建环境，如何构建您的第一个自定义Linux内核版本，并将其部署到您的设备上。您将了解：
- en: Toolchain overview
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工具链概述
- en: How to configure the host system to compile your own Linux kernel
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何配置主机系统以编译自己的Linux内核
- en: How to configure the Linux kernel
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何配置Linux内核
- en: Linux kernel overview
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux内核概述
- en: Android boot sequence
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android引导序列
- en: The `Init` process
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Init`进程'
- en: An overview of the Linux kernel
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linux内核概述
- en: In and built around the Linux kernel. One of the reasons to choose the Linux
    kernel was its unquestioned flexibility and the infinite possibilities to adjust
    it to any specific scenario and requirement. These are the features that have
    made Linux the most popular kernel in the embedded industry.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux内核及其构建中。选择Linux内核的一个原因是其无可置疑的灵活性和无限的可能性，可以将其调整到任何特定场景和需求。正是这些特性使Linux成为嵌入式行业中最受欢迎的内核。
- en: Linux kernel comes with a GPL license. This particular license allowed Google
    to contribute to the project since the early stages of Android. Google provided
    bug fixing and new features, helping Linux to overcome a few obstacles and limitations
    of the 2.6 version. In the beginning, Linux 2.6.32 was the most popular version
    for the most part of the Android device market. Nowadays, we see more and more
    devices shipping with the new 3.x versions.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核附带GPL许可证。这个特定的许可证允许谷歌从Android的早期阶段开始为项目做出贡献。谷歌提供了错误修复和新功能，帮助Linux克服了2.6版本的几个障碍和限制。最初，Linux
    2.6.32是Android设备市场中最受欢迎的版本。如今，我们看到越来越多的设备配备了新的3.x版本。
- en: 'The following screenshot shows the current build for the official Google Motorola
    Nexus 6, with kernel 3.10.40:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了官方谷歌摩托罗拉Nexus 6的当前构建，内核版本为3.10.40：
- en: '![](img/epub_36702041_73.jpeg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/epub_36702041_73.jpeg)'
- en: 'The Android version we created in the previous chapters was equipped with a
    binary version of the Linux kernel. Using an already compiled version of the kernel
    is the standard practice: as we have seen, AOSP provides exactly this kind of
    experience.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们创建并部署了我们自己的Android版本，该版本配备了Linux内核的二进制版本。使用已经编译好的内核版本是标准做法：正如我们所见，AOSP提供了这种类型的体验。
- en: As advanced users, we can take it a step further and build a custom kernel for
    our custom Android system. The Nexus family offers an easy entry into this world
    as we can easily obtain the kernel source code we need to build a custom version.
    We can also equip our custom Android system with our custom Linux kernel and we
    will have a full-customized ROM, tailored for our specific needs.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 作为高级用户，我们可以更进一步，为我们的自定义Android系统构建一个自定义内核。Nexus系列提供了进入这个世界的便捷途径，因为我们可以轻松地获取构建自定义版本所需的内核源代码。我们还可以将我们的自定义Linux内核装备到我们的自定义Android系统中，我们将拥有一个完全定制的ROM，适用于我们的特定需求。
- en: In this book, we are using Nexus devices on purpose—Google is one of the few
    companies that formally make available the kernel source code. Even if every company
    producing and selling Android devices is forced by law to release the kernel source
    code, very few of them actually do it, despite all the GPL license rules.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们故意使用Nexus设备——谷歌是少数几家正式提供内核源代码的公司之一。即使每个生产和销售Android设备的公司都受到法律强制要求发布内核源代码，但其中很少有人真正这样做，尽管有GPL许可证规则。
- en: Obtaining the kernel
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取内核
- en: Google provides the kernel source code and binary version for every single version
    of Android for every single device of the Nexus family.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌为Nexus系列中每个设备的每个Android版本提供了内核源代码和二进制版本。
- en: 'The following table shows where the binary version and the source code are
    located, ordered by device code name:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了二进制版本和源代码的位置，按设备代码名称排序：
- en: '![](img/epub_36702041_74.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/epub_36702041_74.jpeg)'
- en: As in Chapter 4, *Moving to real-world hardware*, we are going to work with
    the Motorola Nexus 6, code name `Shamu`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正如第4章“转向现实硬件”中所述，我们将使用摩托罗拉Nexus 6，代码名称`Shamu`。
- en: Both the kernel binary version and the kernel source code are stored in a git
    repository. All we need to do is compose the proper URL and clone the corresponding
    repository.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 内核的二进制版本和内核源代码都存储在git存储库中。我们只需要编写正确的URL并克隆相应的存储库。
- en: Retrieving the kernel's binary version
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 获取内核的二进制版本
- en: 'In this section, we are going to obtain the kernel as a binary, prebuilt file.
    All we need is the previous table that shows every device model, with its codename
    and its binary location that we can use to compose the download of the URL. We
    are targeting Google Nexus 6, codename `shamu` with binary location:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将获取内核作为二进制、预构建文件。我们需要的只是之前显示每个设备型号、其代码名称及其二进制位置的表格，我们可以使用这些信息来组成下载URL。我们针对的是谷歌Nexus
    6，代码名称`shamu`，二进制位置：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'So, to retrieve the binary version of the Motorola Nexus 6 kernel, we need
    the following command:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要获取摩托罗拉Nexus 6内核的二进制版本，我们需要以下命令：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The previous command will clone the repo and place it in the `shamu-kernel`
    folder. This folder contains a file named `zImage-dtb`—this file is the actual
    kernel image that can be integrated in our ROM and flashed into our device.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 上一条命令将克隆存储库并将其放置在`shamu-kernel`文件夹中。这个文件夹包含一个名为`zImage-dtb`的文件——这个文件是实际可以集成到我们的ROM并刷入我们设备的内核镜像。
- en: 'Having the kernel image, we can obtain the kernel version with the following
    command:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 获取内核镜像后，我们可以使用以下命令获取内核版本：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Output:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '![](img/epub_36702041_75.jpeg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/epub_36702041_75.jpeg)'
- en: 'The previous screenshot shows the command output: our kernel image version
    is 3.10.40 and it has been compiled with GCC version 4.8 on October the the twenty-second
    at 22:49.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示了命令输出：我们的内核镜像版本是3.10.40，它是在10月22日22:49使用GCC版本4.8编译的。
- en: Obtaining the kernel source code
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 获取内核源代码
- en: 'As for the binary version, the previous table is critical also to download
    the kernel source code. Targeting the Google Nexus 6, we create the download URL
    using the source location string for the device codename `shamu`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于二进制版本，上一张表格对于下载内核源代码也是关键的。针对谷歌Nexus 6，我们使用设备代码名称`shamu`的源位置字符串创建下载URL：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once we have the exact URL, we can clone the GIT repository with the following
    command:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了确切的URL，我们就可以使用以下命令克隆GIT存储库：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Git will create an `msm` folder. The folder will be strangely empty—that's because
    the folder is tracking the `master` branch by default. To obtain the kernel for
    our Nexus 6, we need to switch to the proper branch.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Git将创建一个`msm`文件夹。文件夹会奇怪地空着——这是因为文件夹默认跟踪`master`分支。为了获取我们的Nexus 6的内核，我们需要切换到正确的分支。
- en: 'There are a lot of available branches and we can check out the list with the
    following command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的分支有很多，我们可以使用以下命令查看列表：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The list will show every single branch, targeting a specific Android version
    for a specific Nexus device. The following screenshot shows a subset of these
    repositories:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 列表将显示每个分支，针对特定Nexus设备的特定Android版本。以下截图显示了这些存储库的子集：
- en: '![](img/epub_36702041_76.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/epub_36702041_76.jpeg)'
- en: 'Now that you have the branch name, for your device and your Android version,
    you just need to checkout the proper branch:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了分支名称，对于你的设备和你的Android版本，你只需要检出正确的分支：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following screenshot shows the expected command output:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了预期的命令输出：
- en: '![](img/epub_36702041_77.jpeg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/epub_36702041_77.jpeg)'
- en: Setting up the toolchain
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置工具链
- en: 'The toolchain is the set of all the tools needed to effectively compile a specific
    software to a binary version, enabling the user to run it. In our specific domain,
    the toolchain allows us to create a system image ready to be flashed to our Android
    device. The interesting part is that the toolchain allows us to create a system
    image for an architecture that is different from our current one: odds are that
    we are using an x86 system and we want to create a system image targeting an ARM
    (Advanced RISC Machine) device. Compiling software targeting an architecture different
    from the one on our host system is called **cross-compilation**.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 工具链是所有用于有效地将特定软件编译成二进制版本所需工具的集合，使用户能够运行它。在我们的特定领域，工具链允许我们创建一个系统镜像，该镜像可以用于烧录到我们的Android设备上。有趣的是，工具链允许我们为与当前架构不同的架构创建系统镜像：我们很可能是使用x86系统，但我们想创建一个针对ARM（高级精简指令集机器）设备的系统镜像。针对与宿主系统架构不同的架构编译软件被称为**交叉编译**。
- en: The Internet offers a couple of handy solutions for this task—we can use the
    standard toolchain, available with the AOSP (Android Open Source Project) or we
    can use an alternative, very popular toolchain, the Linaro toolchain. Both toolchains
    will do the job—compile every single C/C++ file for the ARM architecture.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网为这项任务提供了一些方便的解决方案——我们可以使用与AOSP（Android开源项目）一起提供的标准工具链，或者我们可以使用一个替代的、非常流行的工具链，即Linaro工具链。这两个工具链都能完成工作——为ARM架构编译每一个C/C++文件。
- en: As usual, even the toolchain is available as precompiled binary or as source
    code, ready to be compiled. For our journey, we are going to use the official
    toolchain, provided by Google, but when you need to explore this world even more,
    you could try out the binary version of Linaro toolchain, downloadable from [www.linaro.org/download](http://www.linaro.org/download).
    Linaro toolchain is known to be the most optimized and performing toolchain in
    the market, but our goal is not to compare toolchains or stubbornly use the best
    or most popular one. Our goal is to create the smoothest possible experience,
    removing unnecessary variables from the whole building a custom Android system
    equation.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，工具链既可用预编译的二进制文件提供，也可作为源代码提供，以便编译。对于我们的旅程，我们将使用由Google提供的官方工具链，但当你需要更深入地探索这个领域时，你可以尝试下载来自[www.linaro.org/download](http://www.linaro.org/download)的Linaro工具链的二进制版本。Linaro工具链被认为是市场上最优化和性能最好的工具链，但我们的目标不是比较工具链或固执地使用最好的或最受欢迎的一个。我们的目标是创建尽可能平滑的体验，从整个构建自定义Android系统方程中移除不必要的变量。
- en: Getting the toolchain
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取工具链
- en: 'We are going to use the official toolchain, provided by Google. We can obtain
    it with Android source code or downloading it separately. Having your trusted
    Android source code folder at hand, you can find the toolchain in the following
    folder:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用由Google提供的官方工具链。我们可以通过Android源代码或单独下载来获取它。如果您手头有信任的Android源代码文件夹，您可以在以下文件夹中找到工具链：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This folder contains everything we need to build a custom kernel—the compiler,
    the linker, and few more tools such as a debugger.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件夹包含构建自定义内核所需的所有内容——编译器、链接器以及一些其他工具，如调试器。
- en: 'If, for some unfortunate reason, you are missing the Android source code folder,
    you can download the toolchain using the following git command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某些不幸的原因，您缺少Android源代码文件夹，您可以使用以下git命令下载工具链：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Preparing the host system
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备宿主系统
- en: 'To successfully compile our custom kernel, we need a properly configured host
    system. The requirements are similar to those we satisfied to build the whole
    Android system in the previous chapter:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功编译我们的自定义内核，我们需要一个配置正确的宿主系统。要求与我们在上一章中构建整个Android系统时满足的要求相似：
- en: Ubuntu
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu
- en: Linux kernel source code
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux内核源代码
- en: Toolchain
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工具链
- en: Fastboot
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fastboot
- en: 'Ubuntu needs a bit of love to accomplish this task: we need to install the
    `ncurses-dev` package:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Ubuntu需要一点爱来完成任务：我们需要安装`ncurses-dev`包：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Once we have all the required tools installed, we can start configuring the
    environment variables we need. These variables are used during the cross-compilation
    and can be set via the console. Fire up your trusted Terminal and launch the following
    commands:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了所有必需的工具，我们就可以开始配置所需的环境变量。这些变量在交叉编译过程中使用，并且可以通过控制台进行设置。启动您信任的终端并运行以下命令：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Configuring the kernel
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置内核
- en: Before being able to compile the kernel, we need to properly configure it. Every
    device in the Android repository has a specific branch with a specific kernel
    with a specific configuration to be applied.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在能够编译内核之前，我们需要正确配置它。Android仓库中的每个设备都有一个特定的分支，带有特定的内核和特定的配置要应用。
- en: 'The table on page 2 has a column with the exact information we need—`Build
    configuration`. This information represents the parameter we need to properly
    configure the kernel build system. Let''s configure everything for our Google
    Nexus 6\. In your terminal, launch the following command:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 第2页的表格中有一列包含我们需要的精确信息——`构建配置`。这些信息代表了我们正确配置内核构建系统所需的参数。让我们为我们的Google Nexus 6配置一切。在你的终端中，运行以下命令：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This command will create a kernel configuration specific for your device. The
    following screenshot shows the command running and the final success message:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将创建一个针对你的设备的特定内核配置。以下截图显示了命令的运行情况和最终的成功消息：
- en: '![](img/epub_36702041_78.jpeg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/epub_36702041_78.jpeg)'
- en: Once the `.config` file is in place, you could already build the kernel, using
    the default configuration. As advanced users, we want more and that's why we will
    take full control of the system, digging into the kernel configuration. Editing
    the configuration could enable missing features or disable unneeded hardware support,
    to create the perfect custom kernel, and fit your needs.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`.config`文件就位，你就可以使用默认配置来构建内核。作为高级用户，我们想要更多，这就是为什么我们将完全控制系统，深入内核配置。编辑配置可以启用缺失的功能或禁用不需要的硬件支持，以创建完美的自定义内核，满足你的需求。
- en: Luckily, to alter the kernel configuration, we don't need to manually edit the
    `.config` file. The Linux kernel provides a graphical tool that will allow you
    to navigate the whole configuration file structure, get documentation about the
    single configurable item, and prepare a custom configuration file with zero effort.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，为了改变内核配置，我们不需要手动编辑`.config`文件。Linux内核提供了一个图形工具，它将允许你导航整个配置文件结构，获取关于单个可配置项的文档，并毫不费力地准备一个自定义配置文件。
- en: 'To access the configuration menu, open your terminal, navigate to the `kernel`
    folder and launch the following command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问配置菜单，打开你的终端，导航到`kernel`文件夹并运行以下命令：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following screenshot shows the official Linux kernel configuration tool—no
    frills, but very effective:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了官方Linux内核配置工具——没有花哨的功能，但非常有效：
- en: '![](img/epub_36702041_79.jpeg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/epub_36702041_79.jpeg)'
- en: 'In the upper half of the screenshot, you can see the version of the kernel
    we are going to customize and a quick doc about how you can navigate all those
    menu items: you navigate using the *arrow* keys, you enter a subsection with the
    *Enter* key, you select or deselect an item using *Y*/*N* or *Spacebar* to toggle.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在截图的上半部分，你可以看到我们将要定制的内核版本以及如何导航所有这些菜单项的快速文档：你使用*箭头键*导航，使用*Enter键*进入子菜单，使用*Y*/*N*或*空格键*选择或取消选择一个项。
- en: With great power comes great responsibility, so be careful enabling and disabling
    features—check the documentation in `menuconfig`, check the Internet, and, most
    of all, be confident. A wrong configuration could cause a freeze during the boot
    sequence and this would force you to learn, to create a different configuration
    and try again.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 权力越大，责任越大，所以启用和禁用功能时要小心——检查`menuconfig`中的文档，检查互联网，最重要的是，要有信心。错误的配置可能会在引导过程中导致系统冻结，这将迫使你学习，创建不同的配置并再次尝试。
- en: 'As a real-world example, we are going to enable the FTDI support. Future Technology
    Devices International or FTDI is a worldwide known semiconductor company, popular
    for its RS-232/TTL to USB devices. These devices come in very handy to communicate
    to embedded devices using a standard USB connection. To enable the FTDI support,
    you need to navigate to the right menu by following these steps:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 作为现实世界的例子，我们将启用FTDI支持。Future Technology Devices International或FTDI是一家全球知名的半导体公司，以其RS-232/TTL到USB设备而闻名。这些设备在通过标准USB连接与嵌入式设备通信时非常有用。要启用FTDI支持，你需要按照以下步骤导航到正确的菜单：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Once you reach this section, you need to enable the following item:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你到达这个部分，你需要启用以下项：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following screenshot shows the correctly selected item and gives you an
    idea of how many devices we could possibly support (this screen only shows the
    USB Serial Converter support):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了正确选择的项，并给你一个我们可能支持多少设备的想法（此屏幕只显示USB串行转换器支持）：
- en: '![](img/epub_36702041_80.jpeg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/epub_36702041_80.jpeg)'
- en: 'Once you have everything in place, just select **Exit** and save the configuration,
    as shown in the following screenshot:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦一切就绪，只需选择**退出**并保存配置，如图所示：
- en: '![](img/epub_36702041_81.jpeg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/epub_36702041_81.jpeg)'
- en: With the exact same approach, you can add every new feature you want. One important
    note, we added the FTDI package merging it into the kernel image. Linux kernel
    gives you the opportunity to make a feature available also as a module. A module
    is an external file, with `.ko` extension, that can be injected and loaded in
    the kernel at runtime. The kernel modules are a great and handy feature when you
    are working on a pure Linux system, but they are very impractical on Android.
    With the hope of having a modular kernel, you should code yourself the whole module
    loading system, adding unnecessary complexity to the system. The choice we made
    of having the FTDI feature inside the kernel image penalizes the image from a
    size point of view, but relieves us from the manual management of the module itself.
    That's why the common strategy is to include every new feature we want right into
    the kernel core.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用完全相同的方法，您可以添加您想要的每一个新功能。一个重要的注意事项，我们添加了FTDI包，将其合并到内核映像中。Linux内核给您提供了将功能作为模块提供的可能性。模块是一个外部文件，具有`.ko`扩展名，可以在运行时注入和加载到内核中。内核模块在您在纯Linux系统上工作时是一个伟大且方便的功能，但在Android上它们非常不实用。希望有一个模块化内核，您应该自己编写整个模块加载系统，这会给系统增加不必要的复杂性。我们选择将FTDI功能包含在内核映像中，从尺寸角度来看可能会受到惩罚，但可以免除对模块本身的手动管理。这就是为什么常见的策略是将我们想要的每一个新功能直接集成到内核核心中。
- en: Compiling the kernel
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译内核
- en: 'Once you have a properly configured environment and a brand new configuration
    file, you just need one single command to start the building process. On your
    terminal emulator, in the kernel source folder, launch:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有一个正确配置的环境和一个全新的配置文件，您只需要一个命令就可以开始构建过程。在您的终端模拟器中，在内核源文件夹中，启动：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `make` command will wrap up the necessary configuration and will launch
    the compiling and assembling process. The duration of the process heavily depends
    on the performance of your system: it could be one minute or one hour. As a reference,
    an i5 2.40 GHz CPU with 8 GB of RAM takes 5-10 minutes to complete a clean build.
    This is incredibly quicker than compiling the whole AOSP image, as you can see,
    due to the different complexity and size of the code base.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`make`命令将完成必要的配置并启动编译和汇编过程。这个过程所需的时间很大程度上取决于您系统的性能：可能是一分钟或一个小时。作为一个参考，i5 2.40
    GHz CPU，8 GB RAM的系统完成一个干净的构建需要5-10分钟。这比编译整个AOSP镜像要快得多，正如您所看到的，这是因为代码库的复杂性和大小不同。'
- en: Working with non-Google devices
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与非谷歌设备一起工作
- en: 'So far, we have worked with Google devices, enjoying the Google open-source
    mindset. As advanced users, we frequently deal with devices that are not from
    Google or that are not even a smartphone. As a real-world example, we are going
    to use again a UDOO board: a single-board computer that supports Ubuntu or Android.
    For the time being, the most popular version of UDOO is the UDOO Quad and that''s
    the version we are targeting.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直使用谷歌设备，享受谷歌开源的心态。作为高级用户，我们经常处理来自谷歌或甚至不是智能手机的设备。作为一个现实世界的例子，我们将再次使用UDOO板：一款支持Ubuntu或Android的单板计算机。目前，UDOO最流行的版本是UDOO
    Quad，这也是我们针对的版本。
- en: 'As for every other device, the standard approach is to trust the manufacturer''s
    website to obtain kernel source code and any useful documentation for the process:
    most of all, how to properly flash the new kernel to the system. When working
    with a custom kernel, the procedure is quite consolidated. You need the source
    code, the toolchain, a few configuration steps, and, maybe, some specific software
    package to be installed on to your host system. When it comes to flashing the
    kernel, every device can have a different procedure. This depends on how the system
    has been designed and which tools the manufacturing team provides. Google provides
    `fastboot` to flash our images to our devices. Other manufactures usually provide
    tools that are similar or that can do similar things with little effort.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他所有设备，标准方法是将制造商的网站视为获取内核源代码和任何有用文档的过程的信任来源：最重要的是，如何正确地将新内核刷入系统。当使用自定义内核时，程序相当规范。您需要源代码、工具链、几个配置步骤，也许还需要在您的宿主系统上安装一些特定的软件包。当涉及到刷写内核时，每个设备都可能有不同的程序。这取决于系统的设计方式和制造团队提供的工具。Google
    提供了 `fastboot` 来将我们的镜像刷入我们的设备。其他制造商通常提供类似或可以轻松完成类似任务的工具。
- en: The UDOO development team worked hard to make the UDOO board fully compatible
    with `fastboot`—instead of forcing you to adjust to their tools, they adjusted
    their device to work with the tools you already know. They tuned up the board's
    bootloader and you can now flash the `boot.img` using `fastboot`, like you were
    flashing a standard Google Android device.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: UDOO 开发团队努力使 UDOO 板完全兼容 `fastboot`——而不是强迫您适应他们的工具，他们调整了他们的设备以与您已经熟悉的工具一起工作。他们调整了板上的引导加载程序，现在您可以使用
    `fastboot` 来刷写 `boot.img`，就像您在刷写标准的 Google Android 设备一样。
- en: 'To obtain the kernel, we just need to clone a git repository. With your trusted
    terminal, launch the following command:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取内核，我们只需要克隆一个 git 仓库。使用您信任的终端，运行以下命令：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once we have the kernel, we need to install a couple of software packages in
    our Ubuntu system to be able to work with it. With the following command, everything
    will be installed and put in place:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了内核，我们需要在 Ubuntu 系统中安装一些软件包，以便能够与之一起工作。使用以下命令，所有内容都将被安装并就绪：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Time to pick a toolchain! UDOO gives you a few possibilities—you can use the
    same toolchain you used for the Nexus 6 or you can use the one provided by the
    UDOO team itself. If you decide to use the UDOO official toolchain, you can download
    it with a couple of terminal commands. Be sure you have already installed `curl`.
    If not, just install it with the following command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候选择工具链了！UDOO 给您提供了一些选择——您可以使用与 Nexus 6 相同的工具链，或者使用 UDOO 团队提供的工具链。如果您决定使用 UDOO
    官方工具链，您可以使用几个终端命令下载它。请确保您已经安装了 `curl`。如果没有，只需使用以下命令安装它：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once you have `curl`, you can use the following command to download the toolchain:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您安装了 `curl`，您可以使用以下命令下载工具链：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, you have everything in place to launch the build process:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经准备好启动构建过程：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following is the output:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![](img/epub_36702041_82.jpeg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/epub_36702041_82.jpeg)'
- en: 'The previous screenshot shows the output of the configuration process. When
    the default `.config` file is ready, you can launch the build process with the
    following command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示了配置过程的输出。当默认的 `.config` 文件准备就绪时，您可以使用以下命令启动构建过程：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When the build process is over, you can find the kernel image in the `arch`
    folder:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建过程完成后，您可以在 `arch` 文件夹中找到内核镜像：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As for the Nexus 6, we can customize the UDOO kernel using `menuconfig`. From
    the kernel source folder, launch the following command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Nexus 6，我们可以使用 `menuconfig` 来自定义 UDOO 内核。从内核源代码文件夹中，运行以下命令：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following screenshot shows the UDOO kernel configuration menu. It''s very
    similar to the Nexus 6 configuration menu. We have the same combination of keys
    to navigate, select and deselect features, and so on:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 UDOO 内核配置菜单。它与 Nexus 6 配置菜单非常相似。我们有相同的按键组合来导航、选择和取消选择功能等：
- en: '![](img/epub_36702041_83.jpeg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/epub_36702041_83.jpeg)'
- en: Working with UDOO, the same warnings we had with the Nexus 6 apply here too—be
    careful while removing components from the kernel. Some of them are just meant
    to be there to support specific hardware, some of them, instead, are *vital* for
    the system to boot. As always, feel free to experiment, but be careful about gambling!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 UDOO 时，与 Nexus 6 一样，我们在移除内核组件时也要小心——其中一些只是为了支持特定硬件而存在，而另一些则是系统启动的*关键*。像往常一样，您可以自由实验，但请注意不要冒险！
- en: This kind of development device makes debugging the kernel a bit easier compared
    to a smartphone. UDOO, as with a lot of other embedded development boards, provides
    a serial connection that enables you to monitor the whole boot sequence. This
    comes in handy if you are going to develop a driver for some hardware and you
    want to integrate it into your kernel or even if you are simply playing around
    with some custom kernel configuration. Every kernel and boot-related message will
    be printed to the serial console, ready to be captured and analyzed.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 与智能手机相比，这种类型的开发设备使内核调试变得稍微容易一些。UDOO，就像许多其他嵌入式开发板一样，提供了一个串行连接，使您能够监控整个启动序列。如果您正在为某些硬件开发驱动程序并将其集成到内核中，或者您只是想玩一些自定义内核配置，这将非常有用。每个内核和启动相关的消息都将打印到串行控制台，以便捕获和分析。
- en: 'The next screenshot shows the boot sequence for our UDOO Quad board:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个截图显示了我们的 UDOO Quad 板的启动序列：
- en: '![](img/epub_36702041_84.jpeg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/epub_36702041_84.jpeg)'
- en: As you can see, there is plenty of debugging information, from the board power-on
    to the Android system prompt.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，从板子开机到 Android 系统提示，有大量的调试信息。
- en: Driver management
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 驾驶员管理
- en: 'Since version 2.6.x, Linux gives the developer the opportunity to compile parts
    of the kernel as separated modules that can be injected into the core, to add
    more features at runtime. This approach gives flexibility and freedom: there is
    no need to reboot the system to enjoy new features and there is no need to rebuild
    the whole kernel if you only need to update a specific module. This approach is
    widely use in the PC world, by embedded devices such as routers, smart TVs, and
    even by our familiar UDOO board.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 2.6.x 版本以来，Linux 给开发者提供了将内核的部分编译为分离的模块的机会，这些模块可以注入到核心中，以便在运行时添加更多功能。这种方法提供了灵活性和自由度：无需重新启动系统即可享受新功能，如果您只需要更新特定模块，则无需重新构建整个内核。这种方法在
    PC 世界中广泛使用，包括路由器、智能电视，甚至是我们熟悉的 UDOO 板。
- en: 'To code a new kernel module is no easy task and it''s far from the purpose
    of this book: there are plenty of books on the topic and most of the skill set
    comes from experience. In these pages, you are going to learn about the big picture,
    the key points, and the possibilities.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个新的内核模块并非易事，这远非本书的目的：关于这个主题有很多书籍，而大部分技能都来自经验。在这些页面中，您将了解整体情况、关键点和可能性。
- en: 'Unfortunately, Android doesn''t use this modular approach: every required feature
    is built in a single binary kernel file, for practical and simplicity reasons.
    In the last few years there has been a trend to integrate into the kernel even
    the logic needed for Wi-Fi functionality, that was before it was loaded from a
    separated module during the boot sequence.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Android 并不使用这种模块化方法：每个必需的功能都构建在一个单一的二进制内核文件中，出于实用性和简单性的原因。在过去的几年里，有一种趋势是将
    Wi-Fi 功能所需的逻辑也集成到内核中，这在之前是从分离的模块在启动序列中加载的。
- en: As we saw with the FTDI example in the previous pages, the most practical way
    to add a new driver to our Android kernel is using `menuconfig` and building the
    feature as a core part of the kernel.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一页的 FTDI 示例中看到的那样，将新驱动程序添加到我们的 Android 内核中最实用的方法是使用 `menuconfig` 并将功能作为内核的核心部分构建。
- en: In the next chapter, we will dig deeper in this topic and add new features to
    our kernel that are not present in the default configuration.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地探讨这个主题，并为我们的内核添加一些默认配置中不存在的功能。
- en: Altering the CPU frequency
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改 CPU 频率
- en: Overclocking a CPU is one of the most loved topics among advanced users. The
    idea of getting the maximum amount of power from your device is exciting. Forums
    and blogs are filled with discussions about overclocking and in this section we
    are going to have an overview and clarify a few tricky aspects that you could
    deal with on your journey.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 超频 CPU 是高级用户中最受欢迎的话题之一。从您的设备中获取最大性能的想法令人兴奋。论坛和博客充满了关于超频的讨论，在本节中，我们将概述并澄清您在旅程中可能会遇到的几个棘手方面。
- en: Every CPU is designed to work with a specific clock frequency or within a specific
    frequency range. Any modern CPU has the possibility to scale its clock frequency
    to maximize performance when needed and power consumption when performance is
    not needed, saving precious battery in case of our beloved mobile devices. Overclocking,
    then, denotes the possibility to alter this working clock frequency via software,
    increasing it to achieve performance higher than the one the CPU was designed
    for.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 每个CPU都是设计用来与特定的时钟频率或特定频率范围内工作的。任何现代CPU都有可能在需要时调整其时钟频率以最大化性能，在不需要性能时降低功耗，从而在我们的心爱移动设备上节省宝贵的电池。因此，超频表示通过软件改变这个工作时钟频率的可能性，将其提高到高于CPU设计频率的水平。
- en: 'Contrary to what we often read on unscrupulous forum threads or blogs, overclocking
    a CPU can be a very dangerous operation: we are forcing the CPU to work with a
    clock frequency that formally hasn''t been tested. This could backfire on us with
    a device rebooting autonomously, for its own protection, or we could even damage
    the CPU, in the worst-case scenario.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们经常在无良论坛帖子或博客上读到的内容相反，CPU超频可能是一个非常危险的操作：我们正在迫使CPU以正式尚未测试过的时钟频率工作。这可能会对我们产生反效果，导致设备自动重启以保护自身，或者在最坏的情况下，我们甚至可能损坏CPU。
- en: 'Another interesting aspect of managing the CPU clock frequency is the so-called
    underclock. Leveraging the CPU clock frequency scaling feature, we can design
    and implement scaling policies to maximize the efficiency, according to CPU load
    and other aspects. We could, for instance, reduce the frequency when the device
    is idle or in sleep mode and push the clock to the maximum when the device is
    under heavy load, to enjoy the maximum effectiveness in every scenario. Pushing
    the CPU management even further, lots of smartphone CPUs come with a multicore
    architecture: you can completely deactivate a core if the current scenario doesn''t
    need it.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 管理CPU时钟频率的另一个有趣方面是所谓的降频。利用CPU时钟频率调整功能，我们可以根据CPU负载和其他方面设计并实施调整策略，以最大化效率。例如，当设备空闲或处于睡眠模式时，我们可以降低频率；当设备处于重负载时，我们可以将时钟频率推至最大，以在每个场景中享受最大的效果。进一步推进CPU管理，许多智能手机CPU都采用多核架构：如果当前场景不需要，你可以完全关闭一个核心。
- en: The key concept of underclocking a CPU is adding a new frequency below the lowest
    frequency provided by the manufacturer. Via software, we would be able to force
    the device to this frequency and save battery. This process is not riskless. We
    could create scenarios in which the device has a CPU frequency so low that it
    will result in an unresponsive device or even a frozen device. As for overclocking,
    these are unexplored territories and only caution, experience and luck will get
    you to a satisfying result.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 降低CPU频率的关键概念是在制造商提供的最低频率以下添加一个新的频率。通过软件，我们可以强制设备运行在这个频率上并节省电池。这个过程并非没有风险。我们可能会创建出设备CPU频率如此之低，以至于会导致设备无响应或甚至冻结的情况。至于超频，这些是未知的领域，只有谨慎、经验和运气才能让你得到满意的结果。
- en: An overview of the governors
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总体概述
- en: Linux kernel manages CPU scaling using specific policies called **governors**.
    There are a few pre-build governors in the Linux kernel, already available via
    `menuconfig`, but you can also add custom-made governors, for your specific needs.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核使用称为**控制器**的特定策略来管理CPU频率调整。Linux内核中已经预建了一些控制器，可以通过`menuconfig`访问，但你也可以添加定制的控制器，以满足你的特定需求。
- en: 'The following screenshot shows the `menuconfig` section of Google Nexus 6 for
    CPU scaling configuration:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了Google Nexus 6的`menuconfig`部分，用于CPU频率调整配置：
- en: '![](img/epub_36702041_85.jpeg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/epub_36702041_85.jpeg)'
- en: 'As you can see, there are six prebuild governors. Naming conventions are quite
    useful and make names self-explanatory: for instance, the `performance` governor
    aims to keep the CPU always at maximum frequency, to achieve the highest performance
    at every time, sacrificing battery life.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，有六个预构建的控制器。命名约定非常有用，使得名称具有自解释性：例如，`performance`控制器旨在始终保持CPU在最高频率，以在任何时候实现最高性能，牺牲电池寿命。
- en: 'The most popular governors on Android are definitely the `ondemand` and `interactive`
    governors: these are quite common in many Android-based device kernels. Our reference
    device, Google Nexus 6, uses `interactive` as the default governor.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android上最受欢迎的控制器无疑是`ondemand`和`interactive`控制器：这些在许多基于Android的设备内核中相当常见。我们的参考设备Google
    Nexus 6使用`interactive`作为默认控制器。
- en: As you would expect, Google disallows direct CPU frequency management, for security
    reasons. There is no quick way to select a specific frequency or a specific governor
    on Android. However, advanced users can satisfy their curiosity or their needs
    with a little effort. In the next chapter, you will learn more about CPU management,
    but, for now, let's customize your boot image.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所预期，出于安全原因，谷歌禁止直接管理 CPU 频率。在 Android 上没有快速选择特定频率或特定管理器的方法。然而，高级用户可以通过一点努力来满足他们的好奇心或需求。在下一章中，你将了解更多关于
    CPU 管理的内容，但现在，让我们定制你的引导镜像。
- en: Customizing the boot image
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定制引导镜像
- en: So far, you learned how to obtain the kernel source code, how to set up the
    system, how to configure the kernel, and how to create your first custom kernel
    image. The next step is about equipping your device with your new kernel. To achieve
    this, we are going to analyze the internal structure of the `boot.img` file used
    by every Android device.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学习了如何获取内核源代码，如何设置系统，如何配置内核，以及如何创建你的第一个自定义内核镜像。下一步是给你的设备配备你的新内核。为了实现这一点，我们将分析每个
    Android 设备使用的 `boot.img` 文件的内部结构。
- en: Creating the boot image
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建引导镜像
- en: A custom ROM comes with four `.img` files, necessary to create a working Android
    system. Two of them (`system.img` and `data.img`) are compressed images of a Linux
    compatible filesystem.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一个自定义固件包含四个 `.img` 文件，这些文件是创建工作 Android 系统所必需的。其中两个（`system.img` 和 `data.img`）是兼容
    Linux 文件系统的压缩镜像。
- en: The remaining two files (`boot.img` and `recovery.img`) don't contain a standard
    filesystem. Instead, they are custom image files, specific to Android. These images
    contain a 2KB header sector, the kernel core, compressed with `gzip`, a ramdisk,
    and an optional second stated loader.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的两个文件（`boot.img` 和 `recovery.img`）不包含标准文件系统。相反，它们是针对 Android 的自定义镜像文件。这些镜像包含一个
    2KB 的头部扇区，内核核心，使用 `gzip` 压缩，ramdisk 以及可选的第二状态加载器。
- en: Android provides further info about the internal structure of the image file
    in the `boot.img.h` file contained in the `mkbootimg` package in the AOSP source
    folder.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Android 在 AOSP 源文件夹中 `mkbootimg` 包含的 `boot.img.h` 文件中提供了关于镜像文件内部结构的更多信息。
- en: 'The following screenshot shows a snippet of the content of this file:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了该文件内容的一个片段：
- en: '![](img/epub_36702041_86.jpeg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/epub_36702041_86.jpeg)'
- en: As you can see, the image contains a graphical representation of the `boot.img`
    structure. This ASCII art comes with a deeper explanation of sizes and pages.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，该图像包含 `boot.img` 结构的图形表示。这种 ASCII 艺术包含对大小和页面的更深入解释。
- en: To create a valid `boot.img` file, you need the kernel image you have just built
    and a ramdisk. A ramdisk is a tiny filesystem that is mounted into the system
    RAM during the boot time. A ramdisk provides a set of critically important files,
    needed for a successful boot sequence. For instance, it contains the `init` file
    that is in charge of launching all the services needed during the boot sequence.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个有效的 `boot.img` 文件，你需要你刚刚构建的内核镜像和一个 ramdisk。ramdisk 是一个在引导时挂载到系统 RAM 中的小型文件系统。ramdisk
    提供了一组对引导序列至关重要的文件，对于成功的引导序列是必需的。例如，它包含负责启动引导序列中所需所有服务的 `init` 文件。
- en: 'There are two main ways to generate a boot image:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 生成引导镜像主要有两种方法：
- en: We could use the `mkbootimg` tool
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 `mkbootimg` 工具
- en: We could use the Android build system
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 Android 构建系统
- en: 'Using `mkbootimg` gives you a lot of freedom, but comes with a lot of complexity.
    You would need a serious amount of command-line arguments to properly configure
    the generating system and create a working image. On the other hand, the Android
    build system comes with the whole set of configuration parameters already set
    and ready to go, with zero effort for us to create a working image. Just to give
    you a rough idea of the complexity of `mkbootimg`, the following screenshot shows
    an overview of the required parameters:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `mkbootimg` 给你提供了很多自由度，但同时也带来了很多复杂性。你需要大量的命令行参数来正确配置生成系统并创建一个有效的镜像。另一方面，Android
    构建系统已经包含了整个配置参数集，已经设置好并准备好使用，我们无需做任何努力就可以创建一个有效的镜像。仅为了给你一个关于 `mkbootimg` 复杂性的大致概念，以下截图显示了所需的参数概览：
- en: '![](img/epub_36702041_87.jpeg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/epub_36702041_87.jpeg)'
- en: Playing with something so powerful is tempting, but, as you can see, the amount
    of possible wrong parameters passed to `mkbootimg` is large. As pragmatic developers,
    dealing with `mkbootimg` is not worth the risk at the moment. We want the job
    done, so we are going to use the Android build system to generate a valid boot
    image with no effort.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 玩弄如此强大的东西很有吸引力，但正如你所看到的，传递给 `mkbootimg` 的可能错误参数数量很大。作为务实的开发者，目前处理 `mkbootimg`
    的风险不值得。我们想要完成任务，所以我们将使用 Android 构建系统轻松生成一个有效的引导镜像。
- en: 'In the previous chapters, you created a custom version of the whole system
    using Android source code and a properly configured build system. We are going
    to take advantage of all the work that we have already done to complete this new
    step. All that you need to do is export a new environment variable, pointing to
    the kernel image you have created just a few pages ago. With your trusted terminal
    emulator, launch:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你使用 Android 源代码和正确配置的构建系统创建了一个整个系统的自定义版本。我们将利用我们已经完成的所有工作来完成这一新步骤。你所需要做的只是导出一个新的环境变量，指向你几页前创建的内核镜像。使用你信任的终端模拟器，启动：
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Once you have set and exported the `TARGET_PREBUILT_KERNEL` environment variable,
    you can launch:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你设置了并导出了 `TARGET_PREBUILT_KERNEL` 环境变量，你可以启动：
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'A brand new, fully customized, boot image will be created by the Android build
    system and will be placed in the following folder:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一个全新的、完全定制的引导镜像将由 Android 构建系统创建，并将放置在以下文件夹中：
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: With just a couple of commands, we have a brand new `boot.img` file, ready to
    be flashed. Using the Android build system to generate the boot image is the preferred
    way for all the Nexus devices and for all those devices, such as the UDOO, that
    are designed to be as close as possible to an official Google device.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 只需几条命令，我们就有了全新的 `boot.img` 文件，准备好刷入。使用 Android 构建系统生成引导镜像是所有 Nexus 设备以及那些设计得尽可能接近官方
    Google 设备的设备的首选方式。
- en: For all those devices on the market that are compliant to this philosophy, things
    start to get tricky, but not impossible. Some manufactures take advantage of the
    Apache v2 license and don't provide the whole Android source code. You could find
    yourself in a scenario where you only have the kernel source code and you won't
    be able to leverage the Android build system to create your boot image or even
    understand how `boot.img` is actually structured.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有符合这一理念的市场上的设备，事情开始变得棘手，但并非不可能。一些制造商利用 Apache v2 许可证，不提供完整的 Android 源代码。你可能会发现自己只有内核源代码，而无法利用
    Android 构建系统创建你的引导镜像，甚至无法理解 `boot.img` 实际的结构。
- en: 'In these scenarios, one possible approach could be to pull the `boot.img` from
    a working device, extract the content, replace the default kernel with your custom
    version, and recreate `boot.img` using `mkbootimg`: easier said than done.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，一个可能的方法是从一个工作设备中提取 `boot.img`，提取内容，用你的自定义版本替换默认内核，然后使用 `mkbootimg` 重新创建
    `boot.img`：说起来容易做起来难。
- en: Right now, we want to focus on the main scenario, dealing with a system that
    is not fighting us. In the upcoming chapters, you will learn how to fight back
    and take full control of the system.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们想要关注主要场景，处理一个不与我们抗争的系统。在接下来的章节中，你将学习如何反击并完全控制系统。
- en: Upgrading the new boot image
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 升级新的引导镜像
- en: Once you have your brand new, customized boot image, containing your customized
    kernel image, you only need to flash it to your device. We are working with Google
    devices or, at least, Google-compatible devices, so you will be able to use `fastboot`
    to flash your `boot.img` file to your device.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了全新的、定制的引导镜像，其中包含你的自定义内核镜像，你只需要将其刷入你的设备。我们正在处理 Google 设备或至少是兼容 Google 的设备，因此你将能够使用
    `fastboot` 将你的 `boot.img` 文件刷入你的设备。
- en: To be able to flash the image to the device, you need to put the device in `fastboot
    mode`, also known as `bootloader mode`. Every device has its own way to reach
    this mode, so, according to the device you are using, you can examine the table
    in Chapter 4, *Moving to Real-World Hardware* with all the steps to reach the
    fastboot mode.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够将镜像刷入设备，你需要将设备置于 `fastboot mode`，也称为 `bootloader mode`。每个设备都有进入此模式的方法，因此，根据你使用的设备，你可以查看第4章
    *迈向现实硬件* 中的表格，其中包含了到达 fastboot 模式的所有步骤。
- en: 'Once your device is in fastboot mode, you can connect it via USB to your host
    computer. Fire up a terminal emulator and launch the command to upgrade the boot
    partition:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的设备进入快启模式，您可以通过USB将其连接到主机计算机。启动一个终端模拟器并运行升级引导分区的命令：
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In a few seconds, `fastboot` will replace the content of the device boot partition
    with the content of your `boot.img` file. When the flashing process is successfully
    over, you can reboot your device with:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟后，`fastboot`将用您的`boot.img`文件的内容替换设备引导分区的内容。当烧录过程成功完成后，您可以使用以下命令重启您的设备：
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The device will reboot using your new kernel and, thanks to the new USB TTL
    support that you added a few pages ago, you will be able to monitor the whole
    boot sequence with your terminal emulator.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 设备将使用您的新内核重启，多亏了您在前几页添加的新USB TTL支持，您将能够使用终端模拟器监控整个引导序列。
- en: Android boot sequence
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android引导序列
- en: 'To fully understand all Android internals, we are going to learn how the whole
    boot sequence works: from the power-on to the actual Android system boot. The
    Android boot sequence is similar to any other embedded system based on Linux:
    in a very abstract way, after the power-on, the system initializes the hardware,
    loads the kernel, and finally the Android framework. Any Linux-based system undergoes
    a similar process during its boot sequence: your Ubuntu computer or even your
    home DSL router.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了全面理解所有Android内部结构，我们将学习整个引导序列是如何工作的：从开机到实际的Android系统引导。Android的引导序列与基于Linux的任何其他嵌入式系统类似：在非常抽象的方式下，在开机后，系统初始化硬件，加载内核，并最终加载Android框架。任何基于Linux的系统在其引导序列中都会经历一个类似的过程：您的Ubuntu计算机甚至您的家庭DSL路由器。
- en: In the next sections, we are going to dive deeper in to these steps to fully
    comprehend the operating system we love so much.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将深入探讨这些步骤，以全面理解我们如此喜爱的操作系统。
- en: Internal ROM – bios
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内部ROM – BIOS
- en: When you press the power button on your device, the system loads a tiny amount
    of code, stored inside a ROM memory. You can think about this as an equivalent
    of the BIOS software you have in your PC. This software is in charge of setting
    up all the parameters for CPU clock and running the RAM memory check. After this,
    the system loads the bootloader into memory and launches it.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当您按下设备上的电源按钮时，系统会加载存储在ROM内存中的一小部分代码。您可以将这想象成您PC上所拥有的BIOS软件的等效物。该软件负责设置CPU时钟的所有参数并运行RAM内存检查。之后，系统将引导加载程序加载到内存中并启动它。
- en: An overview of bootloader
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引导加载程序概述
- en: So far, the bootloader has been loaded into the RAM memory and started. The
    bootloader is in charge of loading the system kernel into the RAM memory and launching
    it, to continue the boot sequence.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，引导加载程序已经加载到RAM内存并启动。引导加载程序负责将系统内核加载到RAM内存中并启动它，以继续引导序列。
- en: 'The most popular bootloader software for Android devices is U-Boot, the Universal
    Bootloader. U-Boot is widely used in all kinds of embedded systems: DSL routers,
    smart TVs, infotainment systems, for example. U-boot is open source software and
    its flexibility to be customized for any device is definitely one of the reasons
    for its popularity.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Android设备来说，最流行的引导加载程序软件是U-Boot，即通用引导加载程序。U-Boot在各种嵌入式系统中得到广泛应用：如DSL路由器、智能电视、信息娱乐系统等。U-boot是开源软件，它可以根据任何设备进行定制，这种灵活性无疑是其受欢迎的原因之一。
- en: U-boot's main task is to read the kernel image from the boot partition, load
    it into the RAM memory, and run it. From this moment on, the kernel is in charge
    of finishing the boot sequence.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: U-boot的主要任务是读取引导分区中的内核镜像，将其加载到RAM内存中，并运行它。从这一刻起，内核负责完成引导序列。
- en: 'You could think about U-boot on Android like GRUB on your Ubuntu system: it
    reads the kernel image, decompresses it, loads it into the RAM memory, and executes
    it. The following diagram gives you a graphical representation of the whole boot
    sequence as on an embedded Linux system, an Android system, and a Linux PC:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将Android系统中的U-boot想象成Ubuntu系统中的GRUB：它读取内核镜像，解压缩它，将其加载到RAM内存中，并执行它。以下图表为您展示了嵌入式Linux系统、Android系统和Linux
    PC上的整个引导序列的图形表示：
- en: '![](img/epub_36702041_88.jpeg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![引导加载程序概述](img/epub_36702041_88.jpeg)'
- en: The kernel
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内核
- en: After the bootloader loads the kernel, the kernel's first task is to initialize
    the hardware. With all the necessary hardware properly set up, the kernel mounts
    the ramdisk from `boot.img` and launches `init`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 引导加载程序加载内核后，内核的第一个任务是初始化硬件。当所有必要的硬件都正确设置后，内核从`boot.img`挂载ramdisk并启动`init`。
- en: The Init process
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化进程
- en: In a standard Linux system, the `init` process takes care of starting all the
    core services needed to boot the system. The final goal is to complete the boot
    sequence and start the graphical interface or the command line to make the system
    available to the user. This whole process is based on a specific sequence of system
    scripts, executed in a rigorous order to assure system integrity and proper configuration.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准的 Linux 系统中，`init` 进程负责启动引导系统所需的所有核心服务。最终目标是完成引导序列并启动图形界面或命令行，以便用户可以使用系统。整个过程基于一系列特定的系统脚本，以严格的顺序执行，以确保系统完整性和正确的配置。
- en: Android follows the same philosophy, but it acts in a different way. In a standard
    Android system, the `ramdisk`, contained in the `boot.img`, provides the `init`
    script and all the scripts necessary for the boot.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Android 遵循相同的理念，但行为不同。在标准的 Android 系统中，`ramdisk`（包含在 `boot.img` 中）提供了 `init`
    脚本和引导所需的所有脚本。
- en: 'The Android init process consists of two main files:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Android 初始化进程由两个主要文件组成：
- en: init.rc
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: init.rc
- en: init.${ro.hardware}.rc
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: init.${ro.hardware}.rc
- en: The `init.rc` file is the first initialization script of the system. It takes
    care of initializing those aspects that are common to all Android systems. The
    second file is very hardware specific. As you can guess, `${ro.hardware}` is a
    placeholder for the reference of a particular hardware where the boot sequence
    is happening. For instance, `${ro.hardware}` is replaced with `goldfinsh` in the
    emulator boot configuration.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`init.rc` 文件是系统的第一个初始化脚本。它负责初始化所有 Android 系统共有的方面。第二个文件非常特定于硬件。正如你所猜到的，`${ro.hardware}`
    是引导序列发生时特定硬件的占位符。例如，在模拟器引导配置中，`${ro.hardware}` 被替换为 `goldfinsh`。'
- en: In a standard Linux system, the init sequence executes a set of bash scripts.
    These bash scripts start a set of system services. Bash scripting is a common
    solution for a lot of Linux systems, because it is very standardized and quite
    popular.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准的 Linux 系统中，初始化序列执行一组 bash 脚本。这些 bash 脚本启动一组系统服务。Bash 脚本在许多 Linux 系统中是一个常见的解决方案，因为它非常标准化且相当流行。
- en: 'Android systems use a different language to deal with the initialization sequence:
    Android Init Language.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Android 系统使用不同的语言来处理初始化序列：Android 初始化语言。
- en: The Android init language
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Android 初始化语言
- en: The Android team chose to not use Bash for Android init scripts, but to create
    its own language to perform configurations and services launches.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Android 团队选择不使用 Bash 来编写 Android 初始化脚本，而是创建了自己的语言来执行配置和服务启动。
- en: 'The Android Init Language is based on five classes of statements:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Android 初始化语言基于五个语句类别：
- en: Actions
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动作
- en: Commands
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令
- en: Services
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务
- en: Options
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选项
- en: Imports
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入
- en: Every statement is line-oriented and is based on specific tokens, separated
    by white spaces. Comment lines start with a `#` symbol.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 每个语句都是面向行的，并且基于特定的标记，由空白字符分隔。注释行以 `#` 符号开头。
- en: Actions
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 动作
- en: An Action is a sequence of commands bound to a specific trigger that's used
    to execute the particular action at a specific moment. When the desired event
    happens, the Action is placed in an execution queue, ready to be performed.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 动作是一系列与特定触发器绑定的命令，用于在特定时刻执行特定动作。当发生期望的事件时，动作被放入执行队列，准备执行。
- en: 'This snippet shows an example of an Action statement:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段展示了动作语句的一个示例：
- en: '[PRE29]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Actions have unique names. If a second Action is created with the same name
    in the same file, its set of commands is added to the first Action commands, set
    and executed as a single action.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 动作具有独特的名称。如果在同一文件中创建了具有相同名称的第二个动作，则其命令集将添加到第一个动作的命令集中，作为一个单独的动作进行设置和执行。
- en: Services
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 服务
- en: 'Services are programs that the init sequence will execute during the boot.
    These services can also be monitored and restarted if it''s mandatory they stay
    up. The following snippet shows an example of a service statement:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 服务是初始化序列在引导过程中执行的程序。如果需要这些服务保持运行状态，则可以对其进行监控和重启。以下片段展示了服务语句的一个示例：
- en: '[PRE30]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Services have unique names. If in the same file, a service with a nonunique
    name exists, only the first one is evaluated as valid; the second one is ignored
    and the developer is notified with an error message.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 服务具有独特的名称。如果在同一文件中存在一个非唯一名称的服务，则只有第一个被视为有效；第二个将被忽略，并且开发者会收到错误消息。
- en: Options
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 选项
- en: Options statements are coupled with services. They are meant to influence how
    and when init manages a specific service.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 选项语句与服务相关联。它们旨在影响 init 如何以及何时管理特定服务。
- en: 'Android provides quite an amount of possible options statements:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Android提供了相当多的可能选项语句：
- en: '`critical`: This specifies a device-critical service. The service will be constantly
    monitored and if it dies more than four times in four minutes, the device will
    be rebooted in Recovery Mode.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`critical`: 这指定了一个设备关键服务。服务将被持续监控，如果它在四分钟内死亡超过四次，设备将在恢复模式下重启。'
- en: '`disabled:` This service will be in a default stopped state. init won''t launch
    it. A disabled service can only be launched manually, specifying it by name.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`disabled:` 此服务将处于默认停止状态。init不会启动它。禁用的服务只能通过手动启动，指定其名称。'
- en: '`setenv <name> <value>`: This sets an environment variable using `name` and
    `value`.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setenv <name> <value>`: 使用`name`和`value`设置环境变量。'
- en: '`socket <name> <type> <perm> [ <user> [ <group> [ <seclabel> ] ] ]`: This command
    creates a Unix socket, with a specified `name`, (`/dev/socket/<name>`) and provides
    its file descriptor the specified service. `<type>` specifies the type of socket:
    `dgram`, `stream`, or `seqpacket`. Default `<user>` and `<group>` are 0\. `<seclabel>`
    specifies the SELinx security context for the created socket.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket <name> <type> <perm> [ <user> [ <group> [ <seclabel> ] ] ]`: 此命令创建一个Unix套接字，指定`name`（`/dev/socket/<name>`），并为指定的服务提供文件描述符。`<type>`指定套接字类型：`dgram`、`stream`或`seqpacket`。默认的`user`和`group`是0。`seclabel`指定创建套接字的SELinx安全上下文。'
- en: '`user <username>`: This changes the username before the service is executed.
    The default username is `root`.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user <username>`: 在服务执行之前更改用户名。默认用户名是`root`。'
- en: '`group <groupname> [ <groupname> ]*`: This changes the group name before the
    service is executed.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`group <groupname> [ <groupname> ]*`: 在服务执行之前更改组名。'
- en: '`seclabel <seclabel>`: This changes the SELinux level before launching the
    service.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seclabel <seclabel>`: 在启动服务之前更改SELinux级别。'
- en: '`oneshot`: This disables the service monitoring and the service won''t be restarted
    when it terminates.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`oneshot`: 这将禁用服务监控，当服务终止时，它不会被重启。'
- en: '`class <name>`: This specifies a service class. Classes of services can be
    launched or stopped at the same time. A service with an unspecified `class` value
    will be associated to the default class.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class <name>`: 这指定了一个服务类。可以同时启动或停止服务类。未指定`class`值的服务的将关联到默认类。'
- en: '`onrestart`: This executes a command when the service is restarted.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onrestart`: 当服务重启时执行一个命令。'
- en: '`writepid <file...>`: When a services forks, this option will write the process
    ID (PID) in a specified file.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`writepid <file...>`: 当服务分叉时，此选项将进程ID（PID）写入指定的文件。'
- en: Triggers
  id: totrans-231
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 触发器
- en: 'Triggers specify a condition that has to be satisfied to execute a particular
    action. They can be event triggers or property triggers. Event triggers can be
    fired by the trigger command or by the `QueueEventTrigger()` function. The example
    event triggers are `boot` and `late-init`. Property triggers can be fired when
    an observed property changes value. Every Action can have multiple Property triggers,
    but only one Event trigger; refer to the following code for instance:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 触发器指定了一个必须满足的条件，以便执行特定的动作。它们可以是事件触发器或属性触发器。事件触发器可以通过触发命令或`QueueEventTrigger()`函数来触发。示例事件触发器有`boot`和`late-init`。属性触发器可以在观察到的属性值改变时触发。每个动作可以有多个属性触发器，但只有一个事件触发器；以下代码为例：
- en: '[PRE31]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This Action will be executed when the `boot` event is triggered and the property
    `a` is equal to `b`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当`boot`事件被触发且属性`a`等于`b`时，此动作将被执行。
- en: Commands
  id: totrans-235
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 命令
- en: 'The Command statement specifies a command that can be executed during the boot
    sequence, placing it in the `init.rc` file. Most of these commands are common
    Linux system commands. The list is quite extensive. Let''s look at them in detail:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 命令语句指定了在引导序列中可以执行的命令，将其放置在`init.rc`文件中。大多数这些命令是常见的Linux系统命令。列表相当广泛。让我们详细看看它们：
- en: '`bootchart_init`: This starts bootchart if it is properly configured. Bootchart
    is a performance monitor and can provide insights about the boot performance of
    a device.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bootchart_init`: 如果配置正确，这将启动bootchart。Bootchart是一个性能监控器，可以提供有关设备引导性能的见解。'
- en: '`chmod <octal-mode-permissions> <filename>`: This changes file permissions.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chmod <octal-mode-permissions> <filename>`: 这更改文件权限。'
- en: '`chown <owner> <group> <filename>`: This changes the owner and the group for
    the specified file.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chown <owner> <group> <filename>`: 更改指定文件的拥有者和组。'
- en: '`class_start <serviceclass>`: This starts a service specified by its class
    name.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class_start <serviceclass>`: 这通过类名启动指定的服务。'
- en: '`class_stop <serviceclass>`: This stops and disables a service specified by
    its class name.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class_stop <serviceclass>`: 停止并禁用由其类名指定的服务。'
- en: '`class_reset <serviceclass>`: This stops a service specified by its class name.
    It doesn''t disable the service.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class_reset <serviceclass>`: 停止由其类名指定的服务。它不会禁用服务。'
- en: '`copy <src> <dst>`: This copies a source file to a new destination file.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`copy <src> <dst>`: 将源文件复制到新的目标文件。'
- en: '`domainname <name>`: This sets the domain name.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`domainname <name>`: 设置域名。'
- en: '`enable <servicename>`: This starts a service by its name. If the service is
    already queued to be started, then it starts the service immediately.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enable <servicename>`: 通过名称启动一个服务。如果该服务已经排队等待启动，则立即启动该服务。'
- en: '`exec [<seclabel>[<user>[<group> ]* ]] -- <command> [ <argument> ]*`: This
    forks and executes the specified command. The execution is blocking: no other
    command can be executed in the meantime.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exec [<seclabel>[<user>[<group> ]* ]] -- <command> [ <argument> ]*`: 分叉并执行指定的命令。执行是阻塞的：在此期间不能执行其他命令。'
- en: '`export <name> <value>`: This sets and exports an environment variable.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`export <name> <value>`: 设置并导出一个环境变量。'
- en: '`hostname <name>`: This sets the hostname.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hostname <name>`: 设置主机名。'
- en: '`ifup <interface>`: This enables the specified network interface.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ifup <interface>`: 启用指定的网络接口。'
- en: '`insmod <path>`: This loads the specified kernel module.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`insmod <path>`: 加载指定的内核模块。'
- en: '`load_all_props`: This loads all the system properties.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`load_all_props`: 加载所有系统属性。'
- en: '`load_persist_props`: This loads the persistent properties, after the successful
    decryption of the `/data` partition.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`load_persist_props`: 在成功解密`/data`分区后，加载持久属性。'
- en: '`loglevel <level>`: This sets the kernel log level.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loglevel <level>`: 设置内核日志级别。'
- en: '`mkdir <path> [mode] [owner] [group]`: This creates a folder with the specified
    name, permissions, owner, and group. The defaults are 755 as permissions, and
    root as owner and group.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mkdir <path> [mode] [owner] [group]`: 创建具有指定名称、权限、所有者和组的文件夹。默认权限为755，所有者和组为root。'
- en: '`mount_all <fstab>`: This mounts all the partitions in the `fstab` file.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mount_all <fstab>`: 将`fstab`文件中的所有分区挂载。'
- en: '`mount <type> <device> <dir> [ <flag> ]* [<options>]`: This mounts a specific
    device in a specific folder. A few mount flags are available: `rw`, `ro`, `remount`,
    `noatime`, and all the common Linux mount flags.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mount <type> <device> <dir> [ <flag> ]* [<options>]`: 在特定文件夹中挂载特定设备。一些挂载标志可用：`rw`、`ro`、`remount`、`noatime`以及所有常见的Linux挂载标志。'
- en: '`powerctl`: This is used to react to changes of the `sys.powerctl` system parameter,
    critically important for the implementation of the reboot routing.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`powerctl`: 用于响应`sys.powerctl`系统参数的变化，对于重启路由的实现至关重要。'
- en: '`restart <service>`: This restarts the specified service.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`restart <service>`: 重新启动指定的服务。'
- en: '`rm <filename>`: This deletes the specified file.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rm <filename>`: 删除指定的文件。'
- en: '`rmdir <foldername>`: This deletes the specified folder.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rmdir <foldername>`: 删除指定的文件夹。'
- en: '`setpropr <name> <value>`: This sets the system property with the specified
    name with the specified value.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setpropr <name> <value>`: 使用指定的值设置具有指定名称的系统属性。'
- en: '`start <service>`: This starts a service.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start <service>`: 启动一个服务。'
- en: '`stop <service>`: This stops a service.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stop <service>`: 停止一个服务。'
- en: '`swapon_all <fstab>`: This enables the swap partitions specified in the fstab
    file.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`swapon_all <fstab>`: 启用`fstab`文件中指定的交换分区。'
- en: '`symlink <target> <path>`: This creates a symbolic link from the target file
    to the destination path.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`symlink <target> <path>`: 从目标文件到目标路径创建一个符号链接。'
- en: '`sysclktz <mins_west_of_gtm>`: This sets the system clock.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sysclktz <mins_west_of_gtm>`: 设置系统时钟。'
- en: '`trigger <event>`: This programmatically triggers the specified event.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trigger <event>`: 以编程方式触发指定的事件。'
- en: '`wait <filename > [ <timeout> ]`: This monitors a path for a file to appear.
    A timeout can be specified. If not, the default timeout value is 5 seconds.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wait <filename > [ <timeout> ]`: 监视路径以等待文件出现。可以指定超时时间。如果没有指定，默认超时值为5秒。'
- en: '`write <filename> <content>`: This writes the specified content to the specified
    file. If the file doesn''t exist, it creates the file. If the file already exists,
    it won''t append the content, but it will override the whole file.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`write <filename> <content>`: 将指定的内容写入指定的文件。如果文件不存在，则创建文件。如果文件已存在，则不会追加内容，但会覆盖整个文件。'
- en: Imports
  id: totrans-270
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 导入
- en: 'Imports specify all the external files that are needed in the current file
    and imports them:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 导入指定了当前文件中需要的所有外部文件并将它们导入：
- en: '[PRE32]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The previous snippet is an example of how the current init script can be extended,
    importing an external init script. `path` can be a single file or even a folder.
    In case *path* is a folder, all the files that exists in the first level of the
    specified folder will be imported. The command doesn''t act recursively on folders:
    nested folders must be imported programmatically one by one.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码片段是一个示例，说明了当前的 init 脚本如何扩展，导入外部 init 脚本。`path` 可以是一个单个文件，甚至是一个文件夹。如果 `path`
    是一个文件夹，那么该文件夹第一级中的所有文件都将被导入。该命令不会递归地作用于文件夹：嵌套文件夹必须逐个通过程序导入。
- en: Summary
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to obtain the Linux kernel for your device,
    how to set up your host PC to properly build your custom kernel, how to add new
    features to the kernel, build it, package it, and flash it to your device.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何获取适用于你的设备的 Linux 内核，如何设置你的主机 PC 以正确构建自定义内核，如何向内核添加新功能，构建它，打包它，并将其闪存到你的设备上。
- en: You learned how the Android boot sequence works and how to manipulate the init
    scripts to customize the boot sequence.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 你学习了 Android 启动序列的工作原理以及如何操作 init 脚本来自定义启动序列。
- en: In the next chapter, you will learn how to *cook* your first custom ROM, how
    to root your device, and replace the recovery partition.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何制作你的第一个自定义 ROM，如何给你的设备 root 权限，以及如何替换恢复分区。
