- en: Chapter 6. Physics Simulation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 物理模拟
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introduction to physics simulation
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理模拟简介
- en: Integrating physics engine with games
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将物理引擎集成到游戏中
- en: Adding real-world simulation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加现实世界模拟
- en: Introduction
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'In [Chapter 5](part0036_split_000.html#page "Chapter 5. Adding Music to iOS
    Games and an Introduction to iCloud"), *Adding Music to iOS Games and an Introduction
    to iCloud* we learned various ways to add music to our games along with iCloud
    integration. Now in this chapter, our major focus will be on adding reality to
    the games by introducing physics simulation. SpriteKit has a seamlessly bundled
    physics engine and in this chapter we will be exploring and working to add physics
    to our games. Basically, the SpriteKit has been divided into the following two
    major components:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](part0036_split_000.html#page "第5章。为iOS游戏添加音乐及iCloud简介")中，我们学习了如何将音乐添加到我们的游戏中，以及如何与iCloud集成。现在在本章中，我们的主要重点是通过对物理模拟的介绍来为游戏添加现实感。SpriteKit无缝集成了物理引擎，在本章中我们将探索并尝试将物理添加到我们的游戏中。基本上，SpriteKit被分为以下两个主要组件：
- en: The graphical interface that you see on the screen including UI interface, animations,
    sound effects, and so on
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你在屏幕上看到的图形界面，包括UI界面、动画、音效等
- en: The second is the physical physics world, which determines the interaction and
    behaviors of game objects
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个是物理物理世界，它决定了游戏对象之间的交互和行为
- en: Introduction to physics simulation
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物理模拟简介
- en: We all like games that have realistic effects and actions. In this chapter we
    will learn about the ways to make our games more realistic. Have you ever wondered
    how to provide realistic effect to game objects? It is physics that provides a
    realistic effect to the games and their characters. In this chapter, we will learn
    how to use physics in our games.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都喜欢具有真实效果和动作的游戏。在本章中，我们将学习如何使我们的游戏更加逼真。你是否曾经想过如何为游戏对象提供真实效果？正是物理为游戏及其角色提供了真实效果。在本章中，我们将学习如何在游戏中使用物理。
- en: While developing the game using SpriteKit, you will need to change the world
    of your game frequently. The world is the main object in the game that holds all
    the other game objects and physics simulations. We can also update the gravity
    of the gaming world according to our need. The default world gravity is 9.8, which
    is also the earth's gravity, World gravity makes all bodies fall down to the ground
    as soon as they are created.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用SpriteKit开发游戏时，你需要经常更改游戏的世界。世界是游戏中主要的对象，它包含所有其他游戏对象和物理模拟。我们还可以根据需要更新游戏世界的重力。默认世界重力为9.8，这也是地球的重力，世界重力使得所有物体在创建后立即落向地面。
- en: 'More about SpriteKit can be explored using the following link:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下链接了解更多关于SpriteKit的信息：
- en: '[https://developer.apple.com/library/ios/documentation/GraphicsAnimation/Conceptual/SpriteKit_PG/Physics/Physics.html](https://developer.apple.com/library/ios/documentation/GraphicsAnimation/Conceptual/SpriteKit_PG/Physics/Physics.html)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.apple.com/library/ios/documentation/GraphicsAnimation/Conceptual/SpriteKit_PG/Physics/Physics.html](https://developer.apple.com/library/ios/documentation/GraphicsAnimation/Conceptual/SpriteKit_PG/Physics/Physics.html)'
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The first task is to create the world and then add bodies to it, which can interact
    according to the principles of physics. You can create game objects in the form
    of sprites and associate physics bodies to them. You can also set various properties
    of the object to specify its behavior.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 第一项任务是创建世界并向其中添加物体，这些物体可以按照物理原理进行交互。你可以以精灵的形式创建游戏对象，并将物理体关联到它们。你还可以设置对象的各种属性来指定其行为。
- en: How to do it...
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: In this section, we will learn about the basic components that are used to develop
    games. We will also learn how to set game configurations, including the world
    settings such as gravity and boundary.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习用于开发游戏的基本组件。我们还将学习如何设置游戏配置，包括重力、边界等世界设置。
- en: 'The initial step is to apply the gravity to the scene. Every scene has a physics
    world associated with it. We can update the gravity of the physics world in our
    scene using the following line of code:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是将重力应用到场景中。每个场景都有一个与之关联的物理世界。我们可以使用以下代码行来更新场景中物理世界的重力：
- en: '[PRE0]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Currently we have set the gravity of the scene to 0, which means the bodies
    will be in a state of free fall. They will not experience any force due to gravity
    in the world.
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 目前，我们已经将场景的重力设置为0，这意味着物体将处于自由落体状态。它们在世界中不会因为重力而受到任何力的作用。
- en: 'In several games we also need to set a boundary to the games. Usually, the
    bounds of the view can serve as the bounds for our physics world. The following
    code will help us to set up the boundary for our game, which will be as per the
    bounds of our game scene:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在几个游戏中，我们还需要为游戏设置边界。通常，视图的边界可以充当物理世界的边界。以下代码将帮助我们设置游戏的边界，这将与游戏场景的边界一致：
- en: '[PRE1]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the first line of code we are initializing a `SKPhysicsBody` object. This
    object is used to add the physics simulation to any `SKSpriteNode`. We have created
    the `gameBorderBody` as a rectangle with the dimensions equal to the current scene
    frame.
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在代码的第一行中，我们初始化了一个`SKPhysicsBody`对象。这个对象用于将物理模拟添加到任何`SKSpriteNode`。我们创建了一个`gameBorderBody`，其尺寸等于当前场景的帧。
- en: Then we assign that physics object to the `physicsBody` of our current scene
    (every `SKSpriteNode` object has the `physicsBody` property through which we can
    associate physics bodies to any node).
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们将该物理对象分配给当前场景的`physicsBody`（每个`SKSpriteNode`对象都有一个`physicsBody`属性，通过它可以关联物理体到任何节点）。
- en: After this we update the `physicsBody.friction`. This line of code updates the
    friction property of our world. The friction property defines the friction value
    of one physics body with another physics body. Here we have set this to `0`, in
    order to make the objects move freely, without slowing down.
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此之后，我们更新了`physicsBody.friction`。这一行代码更新了我们世界的摩擦属性。摩擦属性定义了一个物理体与另一个物理体之间的摩擦值。在这里，我们将它设置为`0`，以便使物体能够自由移动，而不会减速。
- en: 'Every game object is inherited from the `SKSpriteNode` class, which allows
    the physics body to hold on to the node. Let us take an example and create a game
    object using the following code:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个游戏对象都是继承自`SKSpriteNode`类，这使得物理体可以保持对节点的控制。让我们举一个例子，使用以下代码创建一个游戏对象：
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We are already familiar with the first few lines of code wherein we are creating
    the sprite reference and then adding it to the scene. Now in the next line of
    code, we are associating a physics body with that sprite. We are initializing
    the circular physics body with radius and associating it with the sprite object.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经熟悉了代码的前几行，其中我们创建了精灵引用并将其添加到场景中。现在在下一行代码中，我们将物理体与该精灵关联。我们初始化了一个具有半径的圆形物理体，并将其与精灵对象关联。
- en: Then we can update various other properties of the physics body such as friction,
    restitution, linear damping, and so on.
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们可以更新物理体的各种其他属性，例如摩擦、恢复、线性阻尼等。
- en: The physics body properties also allow you to apply force. To apply force you
    need to provide the direction where you want to apply force.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 物理体属性还允许你施加力。要施加力，你需要提供你想要施加力的方向。
- en: '[PRE3]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the code we are applying force in the bottom-right corner of the world. To
    provide the direction coordinates we have used `CGVectorMake`, which accepts the
    vector coordinates of the physics world.
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在代码中，我们在世界的右下角施加力。为了提供方向坐标，我们使用了`CGVectorMake`，它接受物理世界的向量坐标。
- en: You can also apply impulse instead of force. Impulse can be defined as a force
    that acts for a specific interval of time and is equal to the change in linear
    momentum produced over that interval.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以施加冲量而不是力。冲量可以定义为在特定时间间隔内作用的力，并且等于在该时间间隔内产生的线性动量变化。
- en: '[PRE4]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'While creating games, we frequently use static objects. To create a rectangular
    static object we can use the following code:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建游戏时，我们经常使用静态对象。要创建一个矩形静态对象，我们可以使用以下代码：
- en: '[PRE5]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: So all the code is the same except one special property, which is dynamic. By
    default this property is set to `YES`, which means that all the physics bodies
    will be dynamic by default and can be converted to static after setting this Boolean
    to `NO`. Static bodies do not react to any force or impulse. Simply put, dynamic
    physics bodies can move while the static physics bodies cannot .
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所以所有代码都是相同的，除了一个特殊的属性，它是动态的。默认情况下，此属性设置为`YES`，这意味着所有物理体默认都是动态的，并且可以在将此布尔值设置为`NO`后转换为静态。静态体不会对任何力或冲量做出反应。简单来说，动态物理体可以移动，而静态物理体则不能。
- en: Integrating physics engine with games
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将物理引擎集成到游戏中
- en: From this section onwards, we will develop a mini game that will have a dynamic
    moving body and a static body. The basic concept of the game will be to create
    an infinite bouncing ball with a moving paddle that will be used to give direction
    to the ball.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从本节开始，我们将开发一个具有动态移动身体和静态身体的迷你游戏。游戏的基本概念将是创建一个无限弹跳的球，并使用移动的拍子来给球提供方向。
- en: Getting ready...
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中...
- en: 'To develop a mini game using the physics engine, start by creating a new project.
    Open Xcode and go to **File** | **New** | **Project** and then navigate to **iOS**
    | **Application** | **SpriteKit Game**. In the pop-up screen, provide the **Product
    Name** as `PhysicsSimulation`, navigate to **Devices** | **iPhone** and click
    on **Next** as shown in the following screenshot:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用物理引擎开发迷你游戏，首先创建一个新的项目。打开Xcode，转到**文件** | **新建** | **项目**，然后导航到**iOS** | **应用程序**
    | **SpriteKit游戏**。在弹出的窗口中，提供**产品名称**为`PhysicsSimulation`，导航到**设备** | **iPhone**，然后点击**下一步**，如图所示：
- en: '![Getting ready...](img/00096.jpeg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![准备中...](img/00096.jpeg)'
- en: Click on **Next** and save the project on your hard drive.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**下一步**并将项目保存在您的硬盘上。
- en: 'Once the project is saved, you should be able to see something similar to the
    following screenshot:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 保存项目后，您应该能够看到以下截图类似的内容：
- en: '![Getting ready...](img/00097.jpeg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![准备中...](img/00097.jpeg)'
- en: In the project settings page, just uncheck the **Portrait** from **Device**
    **Orientation** section as we are supporting only landscape mode for this game.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目设置页面中，只需取消勾选**设备方向**部分的**纵向**，因为我们只为这个游戏支持横向模式。
- en: 'Graphics and games cannot be separated for long; you will also need some graphics
    for this game. Download the graphics folder, drag it and import it into the project.
    Make sure that the **Copy items into destination group''s folder (if needed)**
    is checked and then click on **Finish** button. It should be something similar
    to the following screenshot:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图形和游戏不能长期分离；您还需要为这个游戏准备一些图形。下载图形文件夹，将其拖动并导入到项目中。确保勾选了**如果需要，将项目组文件夹中的项目复制到目标文件夹**，然后点击**完成**按钮。它应该类似于以下截图：
- en: '![Getting ready...](img/00098.jpeg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![准备中...](img/00098.jpeg)'
- en: How to do it...
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Now your project template is ready for a physics-based mini game. We need to
    update the game template project to get started with code game logic. Take the
    following steps to integrate the basic physics object in the game.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的项目模板已准备好用于基于物理的迷你游戏。我们需要更新游戏模板项目以开始编写游戏逻辑代码。按照以下步骤将基本物理对象集成到游戏中。
- en: 'Open the file `GameScene.m` .This class creates a scene that will be plugged
    into the games. Remove all code from this class and just add the following function:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开文件`GameScene.m`。这个类创建了一个将被连接到游戏中的场景。从这个类中删除所有代码，并添加以下函数：
- en: '[PRE6]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This `initWithSize` method creates an blank scene of the specified size. The
    code written inside the `init` function allows you to add the background image
    at the center of the screen in your game.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个`initWithSize`方法创建了一个指定大小的空白场景。`init`函数中编写的代码允许您在游戏中将背景图像放置在屏幕中央。
- en: Now when you compile and run the code, you will observe that the background
    image is not placed correctly on the scene. To resolve this, open `GameViewController.m`.
    Remove all code from this file and add the following function;
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在当您编译并运行代码时，您将观察到背景图像在场景中放置不正确。要解决这个问题，打开`GameViewController.m`。从这个文件中删除所有代码，并添加以下函数；
- en: '[PRE7]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To ensure that the view hierarchy is properly laid out, we have implemented
    the `viewWillLayoutSubviews` method. It does not work perfectly in `viewDidLayoutSubviews`
    method because the size of the scene is not known at that time.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了确保视图层次结构正确布局，我们实现了`viewWillLayoutSubviews`方法。它不能在`viewDidLayoutSubviews`方法中完美工作，因为那时场景的大小是未知的。
- en: Now compile and run the app. You should be able to see the background image
    correctly. It will look something similar to the following screenshot:![How to
    do it...](img/00099.jpeg)
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在编译并运行应用程序。您应该能够正确地看到背景图像。它看起来类似于以下截图：![如何操作...](img/00099.jpeg)
- en: 'So now that we have the background image in place, let us add gravity to the
    world. Open `GameScene.m` and add the following line of code at the end of the
    `initWithSize` method:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，现在我们已经放置了背景图像，让我们给世界添加重力。打开`GameScene.m`，并在`initWithSize`方法的末尾添加以下代码行：
- en: '[PRE8]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This line of code will set the gravity of the world to 0, which means there
    will be no gravity.
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这行代码将设置世界的重力为0，这意味着将没有重力。
- en: 'Now as we have removed the gravity to make the object fall freely, it''s important
    to create a boundary around the world, which will hold all the objects of the
    world and prevent them to go off the screen. Add the following line of code to
    add the invisible boundary around the screen to hold the physics objects:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经移除了重力以使物体自由下落，因此创建一个围绕世界的边界非常重要，这将包含世界中的所有物体，并防止它们离开屏幕。添加以下代码行以在屏幕周围添加不可见的边界来保持物理对象：
- en: '[PRE9]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the first line, we are are creating an edge-based physics boundary object,
    with a screen size frame. This type of a physics body does not have any mass or
    volume and also remains unaffected by force and impulses. Then we associate the
    object with the physics body of the scene. In the last line we set the friction
    of the body to 0, for a seamless interaction between objects and the boundary
    surface. The final file should look something like the following screenshot:'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第一行，我们创建了一个基于边缘的物理边界对象，具有屏幕大小的框架。这种类型的物理体没有质量或体积，并且不受力和冲量的影响。然后我们将对象与场景的物理体关联起来。在最后一行，我们将物体的摩擦力设置为0，以便物体与边界表面之间实现无缝交互。最终的文件应该看起来像以下截图：
- en: '![How to do it...](img/00100.jpeg)'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做……](img/00100.jpeg)'
- en: 'Now we have our surface ready to hold the physics world objects. Let us create
    a new physics world object using the following line of code:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了准备好的表面来容纳物理世界对象。让我们使用以下代码行创建一个新的物理世界对象：
- en: '[PRE10]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here we have created the sprite and then we have added it to the scene. Then
    in the later steps we associate the circular physics body with the sprite object.
    Finally, we alter the properties of that physics body.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们已经创建了精灵，并将其添加到场景中。然后在后续步骤中，我们将圆形物理体与精灵对象关联起来。最后，我们改变该物理体的属性。
- en: Now compile and run the application; you should be able to see the circular
    ball on the screen as shown in screenshot below:![How to do it...](img/00101.jpeg)
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在编译并运行应用程序；你应该能在屏幕上看到圆形球体，如下面的截图所示：![如何做……](img/00101.jpeg)
- en: 'The circular ball is added to the screen, but it does nothing. So it''s time
    to add some action in the code. Add the following line of code at the end of the
    `initWithSize` method:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 圆形球被添加到屏幕上，但它没有任何作用。因此，是时候在代码中添加一些动作了。在`initWithSize`方法的末尾添加以下代码行：
- en: '[PRE11]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will apply the force on the physics body, which in turn will move the associated
    ball sprite as well.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将对物理体施加力，进而移动相关的球体精灵。
- en: Now compile and run the project. You should be able to see the ball moving and
    then collide with the boundary and bounce back, as there is no friction between
    the boundary and the ball. So now we have the infinite bouncing ball in the game.![How
    to do it...](img/00102.jpeg)
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在编译并运行项目。你应该能看到球体移动，然后与边界碰撞并弹回，因为边界和球体之间没有摩擦力。所以现在我们在游戏中有了无限弹跳的球体。![如何做……](img/00102.jpeg)
- en: How it works…
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'There are several properties used while creating physics bodies to define their
    behavior in the physics world. The following is a detailed description of the
    properties used in the preceding code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建物理体时，使用了一些属性来定义它们在物理世界中的行为。以下是对前面代码中使用到的属性的详细描述：
- en: '**Restitution property** defines the bounciness of an object. Setting the restitution
    to `1.0f`, means that the ball collision will be perfectly elastic with any object.
    This means that the ball will bounce back with a force equal to the impact.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**恢复系数属性**定义了物体的弹跳性。将恢复系数设置为`1.0f`，意味着球体碰撞将与任何物体完美弹性。这意味着球体会以等于冲击力的力量弹回。'
- en: '**Linear Damping** **property** allows the simulation of fluid or air friction.
    This is accomplished by reducing the linear velocity of the body. In our case,
    we do not want the ball to slow down while moving and hence we have set the restitution
    to `0.``0f`.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线性阻尼**属性允许模拟流体或空气摩擦。这是通过减少物体的线性速度来实现的。在我们的例子中，我们不希望球体在移动时减速，因此我们将恢复系数设置为`0.0f`。'
- en: There's more…
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多……
- en: 'You can read about all these properties in detail at Apple''s developer documentation:
    [https://developer.apple.com/library/IOs/documentation/SpriteKit/Reference/SKPhysicsBody_Ref/index.html](https://developer.apple.com/library/IOs/documentation/SpriteKit/Reference/SKPhysicsBody_Ref/index.html).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在苹果的开发者文档中详细了解所有这些属性：[https://developer.apple.com/library/IOs/documentation/SpriteKit/Reference/SKPhysicsBody_Ref/index.html](https://developer.apple.com/library/IOs/documentation/SpriteKit/Reference/SKPhysicsBody_Ref/index.html)。
- en: Adding real-world simulation
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加真实世界模拟
- en: Now we will be adding some real simulation in the game. We will add more physics
    bodies and make them interact with each other. This will help us to understand
    the physics interaction between various physics objects.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在游戏中添加一些真正的模拟。我们将添加更多物理实体，并使它们相互交互。这将帮助我们理解各种物理对象之间的物理交互。
- en: How to do it...
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Now we have the infinite bouncing ball in place. To add more fun to the game,
    let us add some more elements to the it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经放置了无限弹跳的球。为了使游戏更有趣，让我们向其中添加更多元素。
- en: 'First we will add the static block to the game. To accomplish this, add the
    following line of code at the end of the `initWithSize` method:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将静态块添加到游戏中。为此，在`initWithSize`方法的末尾添加以下代码行：
- en: '[PRE12]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: First we create the block sprite. After that we associate a physics body to
    it and change the various parameters of the physics body object as well. The most
    important thing to note here is `block.physicsBody.dynamic = NO`. By default all
    the physics bodies are dynamic; so to create static bodies, we just need to set
    the `physicsBody.dynamic` Boolean to `NO`.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，我们创建块精灵。然后，我们将物理实体与之关联，并更改物理实体对象的各项参数。这里需要注意的最重要的事情是`block.physicsBody.dynamic
    = NO`。默认情况下，所有物理实体都是动态的；因此，要创建静态实体，我们只需将`physicsBody.dynamic`布尔值设置为`NO`。
- en: After adding the code, the final file should look something similar to the following
    screenshot:![How to do it...](img/00103.jpeg)
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加代码后，最终文件应类似于以下截图：![如何操作...](img/00103.jpeg)
- en: Now compile and run the code. You should be able to see the block on the screen
    with a static body. Observe closely that when the ball collides with the block,
    it bounces back and you can play with it endlessly.![How to do it...](img/00104.jpeg)
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在编译并运行代码。你应该能够在屏幕上看到具有静态实体的块。仔细观察，当球与块碰撞时，它会弹回，你可以无限地玩它。![如何操作...](img/00104.jpeg)
- en: 'It''s time to add some more action to make the game exciting. Now we will make
    the block paddle move based on touch. The following functions will help us to
    accomplish this:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候添加更多动作使游戏更吸引人了。现在我们将使挡板块根据触摸移动。以下函数将帮助我们完成这项任务：
- en: '[PRE13]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: These methods provide the callback when you touch the screen and also provide
    the list of the objects which were touched. There are three callbacks for touch
    begin, touch move and touch end action.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些方法在您触摸屏幕时提供回调，并提供被触摸的对象列表。有三个回调用于触摸开始、触摸移动和触摸结束动作。
- en: 'Now add the following code just before the `@implementation` line in `GameScene.m`
    file:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`GameScene.m`文件中的`@implementation`行之前添加以下代码：
- en: '[PRE14]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We have thus created a property to hold the user's state of touch on the paddle.
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，我们创建了一个属性来保存用户在挡板上的触摸状态。
- en: 'Now we will implement `touchesBegan:withEvent` function in our `GameScene.m`
    file. Add the following function just next to the `init` method:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将在`GameScene.m`文件中实现`touchesBegan:withEvent`函数。在`init`方法旁边添加以下函数：
- en: '[PRE15]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This function will listen for the touch begin event and use it to find the body
    at the location where the user taps on the scene. In the next line, we get the
    physics body at the touch location.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此函数将监听触摸开始事件，并使用它来找到用户在场景中触摸的位置的实体。在下一行，我们获取触摸位置的物理实体。
- en: Now compile and run the code. When you touch on the paddle, you should be able
    to see the logs demonstrating the touch working on the paddle.![How to do it...](img/00105.jpeg)
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在编译并运行代码。当您触摸挡板时，应该能够看到日志演示触摸在挡板上的工作。![如何操作...](img/00105.jpeg)
- en: 'Now let us go ahead and implement `touchesMoved:withEvent` and add the following
    function just next to `touchesBegan`:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们继续实现`touchesMoved:withEvent`并在`touchesBegan`旁边添加以下函数：
- en: '[PRE16]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Initially, check if the paddle is tapped. If yes, then update the paddle position
    based on the user's touch location. While repositioning, we just need to make
    sure that the position *y* of the paddle does not change.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 初始时，检查挡板是否被触摸。如果是，则根据用户的触摸位置更新挡板位置。在重新定位时，我们只需确保挡板的*Y*位置不发生变化。
- en: 'Finally add the following function after `touchedMoved` in the `GameScene.m`
    file:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`GameScene.m`文件中的`touchedMoved`之后添加以下函数：
- en: '[PRE17]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Just turn the `isPaddleTapped` flag off in the touch end function.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在触摸结束函数中，只需关闭`isPaddleTapped`标志。
- en: Now compile and run the game. You should be able to move the paddle block to
    hit the ball and keep it moving. You should tap on the paddle to move it to the
    left and right sides of the screen.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在编译并运行游戏。你应该能够移动挡板块来击打球并保持其移动。你应该轻触挡板来将其移动到屏幕的左右两侧。
