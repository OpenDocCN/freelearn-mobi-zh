- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Implementing Your First Wear OS Using Jetpack Compose
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jetpack Compose实现你的第一个Wear OS
- en: '**Wear OS** is an operating system developed by Google for smartwatches and
    other wearable devices. There are several reasons why creating Wear OS for Android
    is essential in our Modern Android Development. First, this means expanding the
    Android ecosystem; Wear OS extends the Android ecosystem by allowing developers
    to create apps and services that can be accessed through a smartwatch or other
    wearable device.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**Wear OS**是由谷歌为智能手表和其他可穿戴设备开发的操作系统。有几个原因说明为什么在现代Android开发中创建Wear OS对于Android至关重要。首先，这意味着扩展Android生态系统；Wear
    OS通过允许开发者创建可以通过智能手表或其他可穿戴设备访问的应用和服务来扩展Android生态系统。'
- en: This expands the reach of Android and creates new opportunities for developers
    and users. In addition, it provides seamless integration with Android smartphones,
    allowing users to easily access notifications, calls, and other information on
    their smartwatches, hence providing a more convenient and efficient way for users
    to interact with your application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这扩大了Android的覆盖范围，为开发者和用户创造了新的机会。此外，它还提供了与Android智能手机的无缝集成，使用户能够轻松地在他们的智能手表上访问通知、电话和其他信息，从而为用户提供了一种更方便、更高效的方式与您的应用程序互动。
- en: Let’s not forget the most notable apps that can benefit from this are health
    and fitness tracking apps, including heart rate monitoring, step tracking, and
    workout tracking. This allows users to track their fitness goals and stay motivated
    to achieve them. Finally, Wear OS allows users to customize their smartwatch with
    different watch faces, apps, and widgets. This provides a personalized experience
    that meets individual needs and preferences.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们不要忘记，从中受益最显著的应用程序是健康和健身追踪应用，包括心率监测、步数追踪和锻炼追踪。这使用户能够跟踪他们的健身目标并保持动力去实现它们。最后，Wear
    OS允许用户通过不同的表盘、应用程序和部件来定制他们的智能手表。这提供了一个个性化的体验，满足个人的需求和偏好。
- en: Wearable technology is a rapidly growing market, and as the technology continues
    to evolve, Wear OS has the potential to become a key player in the wearable technology
    market. Wear OS is still very new, and in this chapter, we will explore simple
    basic examples as many of the APIs might change in the future. Therefore, getting
    an idea of how it works and how to create cards, buttons, and show lists will
    be helpful.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 可穿戴技术是一个快速发展的市场，随着技术的不断进步，Wear OS有潜力成为可穿戴技术市场的主要参与者。Wear OS仍然非常新，在本章中，我们将探讨一些简单的基本示例，因为许多API可能在将来发生变化。因此，了解它是如何工作的以及如何创建卡片、按钮和显示列表将是有帮助的。
- en: 'In this chapter, we’ll be covering the following recipes:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下菜谱：
- en: Getting started with your first Wear OS in Android Studio
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Android Studio中开始你的第一个Wear OS
- en: Creating your first button
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建你的第一个按钮
- en: Implementing a scrollable list
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个可滚动的列表
- en: Implementing cards in Wear OS (`TitleCard` and `AppCard`)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Wear OS中实现卡片（`TitleCard`和`AppCard`）
- en: Implementing a chip and a toggle chip
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个芯片和一个切换芯片
- en: Implementing `ScalingLazyColumn` to showcase your content
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现`ScalingLazyColumn`以展示你的内容
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The complete source code for this chapter can be found at [https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_ten](https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_ten).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整源代码可以在[https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_ten](https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_ten)找到。
- en: Getting started with your first Wear OS in Android Studio
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Android Studio中开始你的第一个Wear OS
- en: The Android OS is used worldwide, and one of the use cases is Wear OS (by *wear*,
    we mean smartwatches). This is good news for Android developers because this means
    more jobs. Furthermore, many applications now have to support Wear OS, such as
    Spotify, fitness tracking apps, heart monitoring apps, and more, which implies
    more use cases will arise, and companies will adopt building for *Wear OS* even
    if it’s only for notification purposes. Therefore, this chapter will explore how
    to get started.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Android操作系统在全球范围内被广泛使用，其中一种使用案例是Wear OS（我们所说的“wear”指的是智能手表）。这对Android开发者来说是个好消息，因为这意味着更多的就业机会。此外，现在许多应用程序都需要支持Wear
    OS，例如Spotify、健身追踪应用、心率监测应用等，这预示着将出现更多的使用案例，并且公司将会采用为*Wear OS*构建，即使只是为了通知目的。因此，本章将探讨如何开始。
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will look into getting started with Wear OS and how to set
    up your virtual watch testing environment.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探讨如何开始使用Wear OS以及如何设置你的虚拟手表测试环境。
- en: How to do it…
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'To create your first project on Wear OS in Jetpack Compose, follow these steps:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Jetpack Compose 中创建您的第一个 Wear OS 项目，请按照以下步骤操作：
- en: First, create a new Android project in Android Studio and ensure you have the
    latest version of Android Studio and the Wear OS SDK installed.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在 Android Studio 中创建一个新的 Android 项目，并确保您已安装最新版本的 Android Studio 和 Wear OS
    SDK。
- en: Then, following the procedure of creating your first application, [*Chapter
    1*](B18827_01.xhtml#_idTextAnchor014)*, Getting Started with Modern Android Development
    Skills,* pick **Wear OS** instead of **Phone and Tablet**, as shown in *Figure
    10**.1*.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，按照创建您的第一个应用程序的流程，参考 [*第 1 章*](B18827_01.xhtml#_idTextAnchor014)，“现代 Android
    开发技能入门”，选择 **Wear OS** 而不是 **手机和平板**，如图 *图 10.1* 所示。
- en: "![Figure 10.1 – Selecting Wear OS\uFEFF](img/Figure_10.1.jpg)"
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1 – 选择 Wear OS](img/Figure_10.1.jpg)'
- en: Figure 10.1 – Selecting Wear OS
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – 选择 Wear OS
- en: 'Choose `WearOSExample`. You will notice it uses a minimum SDK of `API 30: Android`
    `11.0 (R)`.'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '选择 `WearOSExample`。您会注意到它使用的是最小 SDK `API 30: Android` `11.0 (R)`。'
- en: "![Figure 10.2 – Minimum SDK version\uFEFF](img/Figure_10.2.jpg)"
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.2 – 最小 SDK 版本](img/Figure_10.2.jpg)'
- en: Figure 10.2 – Minimum SDK version
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – 最小 SDK 版本
- en: Click **Finish**, and you should be able to see a sample code template provided
    for you.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **完成**，您应该能够看到为您提供的示例代码模板。
- en: Now, let’s go ahead and get our virtual Wear OS testing device set up to run
    the already provided code template. Navigate to **Tools** | **Device Manager**,
    then create a new device. If you need help in this section, refer to [*Chapter
    1*](B18827_01.xhtml#_idTextAnchor014), *Getting Started with Modern Android* *Development
    Skills*.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们继续设置我们的虚拟 Wear OS 测试设备以运行提供的代码模板。导航到 **工具** | **设备管理器**，然后创建一个新设备。如果您在这个部分需要帮助，请参考
    [*第 1 章*](B18827_01.xhtml#_idTextAnchor014)，“现代 Android 开发技能入门”。
- en: Now, see *Figure 10**.3* to choose your Wear OS virtual testing device. Note
    that you can also choose either a round, square, or rectangular device. We will
    use round.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，查看 *图 10.3* 以选择您的 Wear OS 虚拟测试设备。请注意，您也可以选择圆形、方形或矩形设备。我们将使用圆形。
- en: "![Figure 10.3 – Wear OS virtual device set up\uFEFF](img/Figure_10.3.jpg)"
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.3 – Wear OS 虚拟设备设置](img/Figure_10.3.jpg)'
- en: Figure 10.3 – Wear OS virtual device set up
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 – 设置 Wear OS 虚拟设备
- en: Hit **Next**, then download the system image – in our case, **R**, which is
    API level 30.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **下一步**，然后下载系统镜像 – 在我们的案例中，**R**，API 级别 30。
- en: "![Figure 10.4 – Installing the system image for testing\uFEFF](img/Figure_10.4.jpg)"
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.4 – 安装测试系统镜像](img/Figure_10.4.jpg)'
- en: Figure 10.4 – Installing the system image for testing
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4 – 安装测试系统镜像
- en: Then press **Finish**, and you should have a ready-to-use Wear OS virtual testing
    device.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击 **完成**，您应该有一个可用的 Wear OS 虚拟测试设备。
- en: Now, go ahead and change the text in `Greeting()` to say `"Hello, Android Community"`
    in the code template and run, and you should have something similar to *Figure
    10**.5*. If everything is installed correctly, you should not have a build error.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将 `Greeting()` 中的文本更改为代码模板中的 `"Hello, Android Community"` 并运行，您应该会有类似于 *图
    10.5* 的结果。如果一切安装正确，您不应该有构建错误。
- en: "![Figure 10.5 – Displaying a greeting on a Wear OS virtual device\uFEFF](img/Figure_10.5.jpg)"
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.5 – 在 Wear OS 虚拟设备上显示问候语](img/Figure_10.5.jpg)'
- en: Figure 10.5 – Displaying a greeting on a Wear OS virtual device
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5 – 在 Wear OS 虚拟设备上显示问候语
- en: Also, ensure you change the text on the round string resource too.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，确保您也更改了圆形字符串资源上的文本。
- en: That’s it, you have successfully set up your first Wear OS, and we were able
    to run the already provided `Greeting()`. In the following recipe, we will look
    at creating a simple button.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，您已成功设置您的第一个 Wear OS，并且我们已经能够运行提供的 `Greeting()`。在接下来的配方中，我们将查看创建一个简单的按钮。
- en: How it works…
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: You will notice the template looks precisely how you’d build Android applications,
    the only difference being the libraries used. The template uses Compose, which
    makes our work easier while developing since we will be using most of the concepts
    that we learned in previous chapters.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到模板看起来与构建 Android 应用程序的方式完全一样，唯一的区别是使用的库。模板使用 Compose，这使得我们在开发中工作更加容易，因为我们将会使用我们在前几章中学到的大多数概念。
- en: 'The following is a comparison to help you know the difference between the Wear
    OS dependency and the standard dependency:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是比较，以帮助您了解 Wear OS 依赖项和标准依赖项之间的区别：
- en: "![Figure 10.6 – Different types of dependencies (\uFEFFsource: developer.android.com)\uFEFF\
    ](img/Figure_10.6.jpg)"
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.6 – 不同类型的依赖项（来源：developer.android.com）](img/Figure_10.6.jpg)'
- en: 'Figure 10.6 – Different types of dependencies (source: developer.android.com)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 – 不同类型的依赖关系（来源：developer.android.com）
- en: Creating your first button
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您的第一个按钮
- en: In this recipe, we will create our first button in Wear OS to explore the principles
    and best practices of building in Wear OS.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建 Wear OS 上的第一个按钮，以探索构建 Wear OS 的原则和最佳实践。
- en: Getting ready
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to have completed the previous recipe to get started on this one. We
    will be building upon our already created `WearOSExample` project.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要完成上一个菜谱，才能开始这个菜谱。我们将基于已经创建的 `WearOSExample` 项目进行构建。
- en: How to do it…
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'To create your first button on Wear OS in Jetpack Compose, you can follow these
    steps:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Jetpack Compose 中创建 Wear OS 上的第一个按钮，您可以按照以下步骤操作：
- en: 'Using the already-created project, we will be adding a new button. Let’s go
    ahead and remove some of the already provided code, `fun` `Greeting(greetingName:
    String)`:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '使用已创建的项目，我们将添加一个新的按钮。让我们继续删除一些已提供的代码，`fun Greeting(greetingName: String)`：'
- en: "![Figure 10.7 – A screenshot showing what to be deleted\uFEFF](img/Figure_10.7.jpg)"
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.7 – 展示要删除内容的截图](img/Figure_10.7.jpg)'
- en: Figure 10.7 – A screenshot showing what to be deleted
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7 – 展示要删除内容的截图
- en: Removing the `Greeting()` function called in `WearOSExampleTheme` will complain;
    go ahead and remove that too.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除在 `WearOSExampleTheme` 中调用的 `Greeting()` 函数将引发错误；继续删除它。
- en: 'Then create a new `Composable` function that will define your button. You can
    use the `Button` function provided by Jetpack Compose:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后创建一个新的 `Composable` 函数来定义您的按钮。您可以使用 Jetpack Compose 提供的 `Button` 函数：
- en: '[PRE0]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, call the new function in our `WearApp()` function:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在我们的 `WearApp()` 函数中调用新函数：
- en: '[PRE9]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, in our activity, call the `setContent` method with your button''s `Composable`
    function as the parameter:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在我们的活动中，使用按钮的 `Composable` 函数作为参数调用 `setContent` 方法：
- en: '[PRE29]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You can also utilize the already provided `Preview` function to view the changes.
    You will notice that we explicitly specify the device, `@Preview(device = Devices.WEAR_OS_SMALL_ROUND,
    showSystemUi =` `true)`:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以利用已提供的 `Preview` 函数来查看更改。您会注意到我们明确指定了设备，`@Preview(device = Devices.WEAR_OS_SMALL_ROUND,
    showSystemUi = true)`：
- en: '[PRE38]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Run your Wear OS app, and you should see your button displayed on the screen,
    as shown in *Figure 10**.8*:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行您的 Wear OS 应用，您应该在屏幕上看到您的按钮，如图 *图 10.8* 所示：
- en: "![Figure 10.8 – A button in Wear \uFEFFOS](img/Figure_10.8.jpg)"
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.8 – Wear OS 中的按钮](img/Figure_10.8.jpg)'
- en: Figure 10.8 – A button in Wear OS
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8 – Wear OS 中的按钮
- en: Let’s look at another example, which is a button with an icon; this is pretty
    similar to the first button, but in this case, we will just be adding an icon
    instead of text.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看另一个例子，这是一个带图标的按钮；这与第一个按钮非常相似，但在这个例子中，我们将只添加图标而不是文本。
- en: 'Create a new function called `SampleButton2()` and add the following code:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `SampleButton2()` 的新函数，并添加以下代码：
- en: '[PRE43]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Finally, comment out `SampleButton`, add `SampleButton2`, and run; you should
    see something similar to *Figure 10**.9*:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，注释掉 `SampleButton`，添加 `SampleButton2`，并运行；您应该看到类似于 *图 10.9* 的内容：
- en: "![Figure 10.9 – A button with an icon in Wear\uFEFF OS](img/Figure_10.9.jpg)"
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.9 – Wear OS 中的带图标的按钮](img/Figure_10.9.jpg)'
- en: Figure 10.9 – A button with an icon in Wear OS
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9 – Wear OS 中的带图标的按钮
- en: Important note
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: It is important to note that the Wear OS platform has some unique considerations
    when it comes to designing and testing apps, such as the smaller screen size and
    the need to optimize battery life. It’s essential to test your app on an actual
    device to ensure it works as expected on Wear OS.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，Wear OS 平台在设计和应用测试方面有一些独特的考虑因素，例如屏幕尺寸较小和需要优化电池寿命。在真实设备上测试您的应用对于确保它在 Wear
    OS 上按预期工作至关重要。
- en: How it works…
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Judging from your previous knowledge of Compose, everything we have worked on
    so far should look familiar. In our example, we’re using `SampleButton` and `WearOSExampleTheme`
    from the Wear OS Compose library to create a button that’s designed specifically
    for Wear OS devices.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您对 Compose 的先前知识，我们迄今为止所做的一切都应该看起来很熟悉。在我们的例子中，我们使用 Wear OS Compose 库中的 `SampleButton`
    和 `WearOSExampleTheme` 来创建一个专门为 Wear OS 设备设计的按钮。
- en: '`SampleButton` takes in an `onClick` lambda that gets called when the button
    is clicked and a modifier that sets the size of the button based on what we specify,
    which, in our example, is a simple `fillMaxWidth()`.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`SampleButton` 接收一个 `onClick` lambda，当按钮被点击时会被调用，以及一个设置按钮大小的修饰符，根据我们指定的内容，在我们的例子中，是一个简单的
    `fillMaxWidth()`。'
- en: 'We’re using `horizontalArrangement` in the column to center our button and
    using the `MaterialTheme` color to paint the background. In the case of Wear OS,
    Google recommends using the default material wear shapes; these are already optimized
    for non-round and round devices, which makes our work easier as developers. See
    the following link for more information on shapes: [https://developer.android.com/reference/kotlin/androidx/wear/compose/material/Shapes](https://developer.android.com/reference/kotlin/androidx/wear/compose/material/Shapes).'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在列中使用`horizontalArrangement`来居中按钮，并使用`MaterialTheme`颜色来绘制背景。在Wear OS的情况下，谷歌建议使用默认的材料穿戴形状；这些形状已经针对非圆形和圆形设备进行了优化，这使得我们的工作作为开发者来说更容易。有关形状的更多信息，请参阅以下链接：[https://developer.android.com/reference/kotlin/androidx/wear/compose/material/Shapes](https://developer.android.com/reference/kotlin/androidx/wear/compose/material/Shapes)。
- en: Finally, we’re using the `Text` composable to display the button text, which
    is vital since it tells users what the button’s intended use is.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`Text`可组合函数来显示按钮文本，这对于告诉用户按钮的预期用途至关重要。
- en: Implementing a scrollable list
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现可滚动列表
- en: Implementing a scrollable list is essential for creating an effective and user-friendly
    Android app that meets the needs of your users. A scrollable list allows you to
    display a large amount of information on a small screen, which can be beneficial,
    especially in a tiny device such as a watch. By scrolling through the list, users
    can quickly and easily access all of the items without navigating to different
    screens or pages.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 实现可滚动列表对于创建一个有效且用户友好的满足用户需求的Android应用至关重要。可滚动列表允许您在小型屏幕上显示大量信息，这在小型设备（如手表）上尤其有益。通过滚动列表，用户可以快速轻松地访问所有项目，而无需导航到不同的屏幕或页面。
- en: Users expect a smooth and responsive scrolling experience when interacting with
    lists. Implementing a scrollable list with optimized performance can help ensure
    the app feels fast and responsive to the user. Scrollable lists can be customized
    to suit a variety of use cases and design requirements. You can adjust the layout,
    appearance, and behavior of the list to fit your app’s specific needs and provide
    a unique user experience. In this recipe, we will look at how you can implement
    a scrollable list in Wear OS.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 用户在与列表交互时期望有一个平滑且响应灵敏的滚动体验。实现具有优化性能的可滚动列表可以帮助确保应用对用户来说感觉快速且响应灵敏。可滚动列表可以根据各种用例和设计要求进行定制。您可以调整列表的布局、外观和行为，以满足您应用的特定需求并提供独特的用户体验。在本食谱中，我们将探讨如何在Wear
    OS中实现可滚动列表。
- en: Getting ready
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to have completed the previous recipe to get started on this one. We
    will be using our already created `WearOSExample` project to continue this part.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要完成上一个食谱才能开始这个食谱。我们将使用已经创建的`WearOSExample`项目来继续这一部分。
- en: How to do it…
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Follow these steps to build a scrollable list in Wear OS using Jetpack Compose:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤使用Jetpack Compose在Wear OS中构建可滚动列表：
- en: In your `MainActivity.kt` file, let’s create a new `Composable` function containing
    your scrollable list. You can call it anything you like, but for this example,
    we’ll call it `WearOSList`.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`MainActivity.kt`文件中，让我们创建一个新的`Composable`函数来包含您的可滚动列表。您可以将其命名为任何您喜欢的名称，但为了本例，我们将将其命名为`WearOSList`。
- en: Another option is to create a new package to organize our code better and call
    the package `components`. Inside `components`, create a new Kotlin file and call
    it `WearOsList`.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个选项是创建一个新的包来更好地组织我们的代码，并将其命名为`components`。在`components`内部，创建一个新的Kotlin文件，并将其命名为`WearOsList`。
- en: 'In our `WearOSList` function, we will need a list of strings for our example;
    we can just create sample dummy data to showcase an example:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`WearOSList`函数中，我们需要一个字符串列表作为示例；我们只需创建一些示例数据来展示一个例子：
- en: '[PRE70]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Inside our `WearOSList` function, create `ScalingLazyColumn`, which is optimized
    for Wear OS. This will be the container for our scrollable list. We will talk
    about `ScalingLazyColumn` later in the chapter:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`WearOSList`函数内部，创建`ScalingLazyColumn`，它是针对Wear OS优化的。这将是我们的可滚动列表的容器。我们将在本章后面讨论`ScalingLazyColumn`：
- en: '[PRE72]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Building for Wear OS might be challenging due to content size, hence the need
    to be familiar with Wear’s best practices.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 由于内容大小，构建Wear OS可能会具有挑战性，因此熟悉Wear的最佳实践是必要的。
- en: 'For our items, we will create a new `Composable` function called `WearOSListItem`,
    which will just have a `text` since we are just showcasing a text:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的项目，我们将创建一个新的`Composable`函数，命名为`WearOSListItem`，它将只有一个`text`，因为我们只是展示文本：
- en: '[PRE78]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'For our data, we will create a dummy list, so go ahead and add the following
    in the `WearApp()` function:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的数据，我们将创建一个虚拟列表，所以请继续在 `WearApp()` 函数中添加以下内容：
- en: '[PRE82]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Finally, comment out the two buttons we created, call `WearOSList`, pass in
    `itemList`, and run the application:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，注释掉我们创建的两个按钮，调用 `WearOSList`，传入 `itemList`，并运行应用程序：
- en: '[PRE90]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'You should see a list similar to *Figure 10**.10*:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该看到一个类似于 *图 10.10* 的列表：
- en: "![Figure 10.10 – Scrollable list o\uFEFFf items](img/Figure_10.10.jpg)"
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.10 – 可滚动项目列表](img/Figure_10.10.jpg)'
- en: Figure 10.10 – Scrollable list of items
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.10 – 可滚动项目列表
- en: How it works…
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this example, we’re using `WearOsList` and `WearOSExampleTheme` from the
    Wear OS Compose library to create a list that’s designed specifically for Wear
    OS devices.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们使用 Wear OS Compose 库中的 `WearOsList` 和 `WearOSExampleTheme` 来创建一个专为 Wear
    OS 设备设计的列表。
- en: We start by creating a `WearOSList` composable that takes in a list of items
    as a parameter. Inside `ScalingLazyColumn`, we use the `items` function to iterate
    through the list of items and create a `WearOSListItem` for each.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个接受项目列表作为参数的 `WearOSList` 可组合函数。在 `ScalingLazyColumn` 内部，我们使用 `items`
    函数遍历项目列表并为每个项目创建一个 `WearOSListItem`。
- en: The `WearOSListItem` composable has a `Composable` `text` function.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`WearOSListItem` 可组合函数有一个 `Composable` `text` 函数。'
- en: Implementing Cards in Wear OS (TitleCard and AppCard)
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Wear OS 中实现卡片（TitleCard 和 AppCard）
- en: 'When building for Wear OS, we have two significant cards that we need to consider:
    `AppCard` and `TitleCard`. A good use case for cards would be **Notification**
    and **Smart Reply**. If you use a wearable device, you might know what these are;
    if you don’t use a wearable device, you can look them up, but in this recipe,
    we will also explore examples.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当为 Wear OS 构建时，我们需要考虑两个重要的卡片：`AppCard` 和 `TitleCard`。卡片的一个良好用途是 **通知** 和 **智能回复**。如果您使用可穿戴设备，您可能知道这些是什么；如果您不使用可穿戴设备，您可以查找它们，但在这个菜谱中，我们也会探索示例。
- en: Furthermore, if you create a Notification card, you intend to provide a quick
    and easy way to view and respond to notifications from your apps. When a notification
    arrives, it appears as a card on your watch face, which you can then swipe away
    or tap to open and interact with the notification.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您创建通知卡片，您的目的是提供一个快速简便的方式查看和回复来自您应用的通知。当通知到达时，它将作为卡片出现在您的手表表面上，然后您可以滑动或点击以打开并与之交互。
- en: As for Smart Reply cards, this feature uses machine learning to suggest responses
    to messages you receive based on the context of the message. These cards appear
    as a response option to notifications and allow you to quickly send a message
    without needing to type it out manually.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于智能回复卡片，此功能使用机器学习根据消息的上下文建议回复消息。这些卡片作为响应选项出现在通知中，允许您快速发送消息而无需手动输入。
- en: Both Notification and Smart Reply cards are essential because they provide an
    efficient and streamlined way to manage notifications and respond to messages
    without having to pull out your phone constantly. They allow you to stay connected
    while on the go and keep you informed of important information without disrupting
    your daily routine, which is why Wear OS is here to stay, and knowing how to build
    for it will come in handy. In this recipe, we will create a simple card and see
    how to handle navigation in Wear OS.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 通知和智能回复卡片都是必不可少的，因为它们提供了一种高效且简化的方式来管理通知和回复消息，而无需不断拿出手机。它们允许您在移动时保持连接，并让您在不打扰日常生活的情况下了解重要信息，这就是为什么
    Wear OS 会一直存在，并且了解如何为其构建将非常有用。在这个菜谱中，我们将创建一个简单的卡片，并看看如何在 Wear OS 中处理导航。
- en: Getting ready
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need to have completed the previous recipes to continue with this recipe.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须完成之前的菜谱才能继续此菜谱。
- en: How to do it…
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Here’s an example of creating a card in Wear OS using Jetpack Compose. Open
    the `WearOSExample` project and code along:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在 Wear OS 中使用 Jetpack Compose 创建卡片的示例。打开 `WearOSExample` 项目并跟随代码：
- en: Inside the `components` package, let’s create a new Kotlin file and call it
    `MessageCardExample`.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `components` 包内，让我们创建一个新的 Kotlin 文件，并将其命名为 `MessageCardExample`。
- en: 'Inside `MessageCardExample`, create a new composable function called `MessageCard`:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MessageCardExample` 内部，创建一个新的可组合函数，命名为 `MessageCard`：
- en: '[PRE98]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'We must now call `AppCard()` since this is what we want. `AppCard` takes in
    `appName`, `time`, `title`, and more, as shown in *Figure 10**.11*. This means
    you can customize your `AppCard` `()` to fit your needs:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在必须调用 `AppCard()`，因为这是我们想要的。`AppCard` 接受 `appName`、`time`、`title` 等，如图 *图
    10.11* 所示。这意味着您可以根据需要自定义 `AppCard` `()`：
- en: "![Figure 10.11 – AppCard \uFEFFcompo\uFEFFsable function](img/Figure_10.11.jpg)"
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.11 – AppCard 可组合函数](img/Figure_10.11.jpg)'
- en: Figure 10.11 – AppCard composable function
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.11 – AppCard 可组合函数
- en: 'This makes our work easier as developers since we know exactly what we need
    when building, thereby increasing developer productivity:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这使得我们的工作更容易，作为开发者，我们知道在构建时需要什么，从而提高了开发者的生产力：
- en: '[PRE100]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Now, let’s go ahead and implement our `AppCard()` and send a message to our
    users. For our example, we will hardcode the data, but if you have an endpoint,
    you can pull data and display it as needed:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们继续实现我们的 `AppCard()` 并向我们的用户发送消息。在我们的例子中，我们将硬编码数据，但如果你有一个端点，你可以拉取数据并按需显示：
- en: '[PRE109]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'In `MainActivity`, comment out other composable functions, for now add `MessageCard()`,
    and run it:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainActivity` 中，注释掉其他可组合函数，现在添加 `MessageCard()` 并运行它：
- en: "![Figure 10.12 – AppCard \uFEFFwith a notification](img/Figure_10.12.jpg)"
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.12 – 带通知的 AppCard](img/Figure_10.12.jpg)'
- en: Figure 10.12 – AppCard with a notification
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.12 – 带通知的 AppCard
- en: How it works…
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: '`TitleCard` and `AppCard` are both used to display information on Wear OS,
    but they have different purposes. In our example, we use `AppCard()`, but as you
    can see in *Figure 10**.13*, `TitleCard()` takes in several inputs that are similar
    to `AppCard()`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`TitleCard` 和 `AppCard` 都用于在 Wear OS 上显示信息，但它们有不同的用途。在我们的例子中，我们使用 `AppCard()`，但正如你在
    *图 10**.13* 中所看到的，`TitleCard()` 接收几个与 `AppCard()` 类似的输入：'
- en: '![Figure 10.13 – TitleCard input](img/Figure_10.13.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.13 – TitleCard 输入](img/Figure_10.13.jpg)'
- en: Figure 10.13 – TitleCard input
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.13 – TitleCard 输入
- en: You can use `TitleCard()` to display information that is relevant to the current
    context, such as the name of a song that is playing or the title of a movie that
    is being watched. It is typically displayed at the top of the screen and can be
    dismissed by swiping it away. A good example is Spotify.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `TitleCard()` 来显示与当前上下文相关的信息，例如正在播放的歌曲名称或正在观看的电影标题。它通常显示在屏幕顶部，可以通过滑动来关闭。一个好的例子是
    Spotify。
- en: When using `AppCard()`, you can display information about an app that is currently
    running, such as the name of the app and a brief description of what it does,
    as we did in our example. It is typically displayed on a smaller card that can
    be tapped to open the app. That is why it has `onClick{/**TODO*/}`, which can
    lead to more information.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `AppCard()` 时，你可以显示当前运行的应用程序的信息，例如应用程序的名称和它所做简要描述，就像我们在示例中所做的那样。它通常显示在一个较小的卡片上，可以点击打开应用程序。这就是为什么它有
    `onClick{/**TODO*/}`，这可以引导到更多信息。
- en: 'When deciding whether to use `TitleCard()` or `AppCard()`, you should consider
    the following factors:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当决定是否使用 `TitleCard()` 或 `AppCard()` 时，你应该考虑以下因素：
- en: The amount of information that you need to display
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要显示的信息量
- en: The relevance of the information to the current context
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信息与当前上下文的相关性
- en: The desired user experience
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所期望的用户体验
- en: If you need to display a lot of information, `TitleCard()` may be a better option.
    If you only need to display a small amount of information, `AppCard()` may be
    a better option. If you want the information to be relevant to the current context,
    `TitleCard()` may be a better option. If you want the information displayed on
    a smaller card that can be tapped to open the app, `AppCard()` may be a better
    option.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要显示大量信息，`TitleCard()` 可能是一个更好的选择。如果你只需要显示少量信息，`AppCard()` 可能是一个更好的选择。如果你想显示的信息与当前上下文相关，`TitleCard()`
    可能是一个更好的选择。如果你想显示的信息在一个可以点击打开应用程序的较小卡片上，`AppCard()` 可能是一个更好的选择。
- en: Implementing a chip and a toggle chip
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现芯片和切换芯片
- en: In this recipe, we will explore significant Wear components; a chip and a toggle
    chip are both used to display and interact with data.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探索重要的 Wear 组件；芯片和切换芯片都用于显示和交互数据。
- en: A **chip** is a small, rectangular element that can be used to display text,
    icons, and other information. It is typically used to display items that are related
    or that have a common theme.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '**芯片**是一个可以用来显示文本、图标和其他信息的微小、矩形元素。它通常用来显示相关或具有共同主题的项目。'
- en: A **toggle chip** is a component that can be used to represent a binary value.
    It is typically used to represent things such as on/off, yes/no, or true/false.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**切换芯片**是一个可以用来表示二进制值的组件。它通常用来表示诸如开/关、是/否或真/假等事物。'
- en: 'It is fair to mention that you can use these components in your regular application,
    and we will explore them more in [*Chapter 11*](B18827_11.xhtml#_idTextAnchor619).
    When deciding which component to use, you should consider the following factors:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 公平地说，你可以在你的常规应用中使用这些组件，我们将在 [*第 11 章*](B18827_11.xhtml#_idTextAnchor619) 中进一步探讨它们。在决定使用哪个组件时，你应该考虑以下因素：
- en: The type of data that you want to display
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想要显示的数据类型
- en: The type of interaction that you want to enable
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想要启用的交互类型
- en: The look and feel that you want to achieve
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想要达到的外观和感觉
- en: Getting ready
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will be using our already-created project for this section.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用已经创建的项目来处理本节内容。
- en: How to do it…
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We will create a chip and a toggle chip in this recipe. Follow these steps:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个芯片和一个切换芯片。按照以下步骤操作：
- en: Let’s go ahead and build our first chip; inside the `components` package, create
    a Kotlin file and call it `ChipExample.kt`.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续构建我们的第一个芯片；在 `components` 包内，创建一个 Kotlin 文件，并将其命名为 `ChipExample.kt`。
- en: Inside the file, create a composable function called `ChipWearExample()`.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件内部，创建一个名为 `ChipWearExample()` 的可组合函数。
- en: 'Now, let’s go ahead and call the `Chip()` composable function. You can also
    use the `Chip` component to display dynamic information. To do this, you can use
    the `modifier` property to specify a function that will be called to update the
    information displayed on the chip:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们调用 `Chip()` 可组合函数。你还可以使用 `Chip` 组件来显示动态信息。为此，你可以使用 `modifier` 属性来指定一个函数，该函数将被调用来更新芯片上显示的信息：
- en: '[PRE136]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'In `MainActivity`, go ahead and comment out the existing `Composable` functions,
    add `ChipWearExample()`, and run the app:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainActivity` 中，先注释掉现有的 `Composable` 函数，添加 `ChipWearExample()`，然后运行应用：
- en: "![Figur\uFEFFe 10.14 – A chip with a message](img/Figure_10.14.jpg)"
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.14 – 带有消息的芯片](img/Figure_10.14.jpg)'
- en: Figure 10.14 – A chip with a message
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.14 – 带有消息的芯片
- en: Now, let’s go ahead and create a toggle chip; inside our `component` package,
    create a Kotlin file and call it `ToggleChipExample`.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个切换芯片；在我们的 `component` 包内，创建一个 Kotlin 文件，并将其命名为 `ToggleChipExample`。
- en: 'Inside `ToggleChipExample`, create a `Composable` function and call it `ToggleChipWearExample()`.
    We will use the `ToggleChip()` component:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ToggleChipExample` 内部，创建一个名为 `ToggleChipWearExample()` 的 `Composable` 函数。我们将使用
    `ToggleChip()` 组件：
- en: '[PRE164]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'Finally, run the code, and you should be able to toggle the chip on and off
    depending on whether you want to get any notifications or not:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，运行代码，你应该能够根据是否想要接收通知来切换芯片的开和关：
- en: '![Figure 10.15 – A toggle chip](img/Figure_10.15.jpg)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.15 – 切换芯片](img/Figure_10.15.jpg)'
- en: Figure 10.15 – A toggle chip
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.15 – 切换芯片
- en: How it works…
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: To implement a chip in Wear OS Jetpack Compose, we need to use the already provided
    `Chip()` component. The `Chip()` component is stadium shaped and has a maximum
    height designed to take no more than two lines of text and can be used to display
    text, icons, and other information.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Wear OS Jetpack Compose 中实现芯片，我们需要使用已经提供的 `Chip()` 组件。`Chip()` 组件是体育场形状的，具有最大高度设计，最多只能显示两行文本，可以用来显示文本、图标和其他信息。
- en: You can also use the `Chip()` component to display dynamic information. To do
    this, you can use the `modifier` property to specify a function that will be called
    to update the information displayed on the chip. You can look at the `Chip()`
    component to see what it accepts as its parameters.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 `Chip()` 组件来显示动态信息。为此，你可以使用 `modifier` 属性来指定一个函数，该函数将被调用来更新芯片上显示的信息。你可以查看
    `Chip()` 组件以了解它接受哪些参数。
- en: 'The `ToggleChip()` composable function takes in several parameters; here are
    a few significant ones:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToggleChip()` 可组合函数接受多个参数；以下是一些重要的参数：'
- en: '`checked`: A Boolean value that represents whether the toggle chip is currently
    checked'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`checked`：一个表示切换芯片当前是否被选中的布尔值'
- en: '`onCheckedChange`: A lambda function that will be called when the checked state
    of the toggle chip changes'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onCheckedChange`：一个当切换芯片的选中状态改变时将被调用的 lambda 函数'
- en: '`modifier`: An optional modifier that can be used to customize the appearance
    or behavior of the toggle chip'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`modifier`：一个可选的修饰符，可以用来自定义切换芯片的外观或行为'
- en: '`colors`: An optional `ToggleChipColors` object that can be used to customize
    the colors of the toggle chip'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`colors`：一个可选的 `ToggleChipColors` 对象，可以用来自定义切换芯片的颜色'
- en: 'We use `TextOverflow` to handle overflowing text since we are dealing with
    small screens. Check out *Figure 10**.15* for more details on what `ToggleChip`
    takes in as parameters:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`TextOverflow`来处理溢出的文本，因为我们处理的是小屏幕。查看*图10.15*以获取关于`ToggleChip`接受哪些参数的更多详细信息：
- en: "![Figure 10.16 – What the ToggleChip \uFEFFcompo\uFEFFsable function accepts\
    \ as \uFEFFparameter\uFEFFs](img/Figure_10.16.jpg)"
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![图10.16 – ToggleChip可组合函数接受的参数](img/Figure_10.16.jpg)'
- en: Figure 10.16 – What the ToggleChip composable function accepts as parameters
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.16 – ToggleChip可组合函数接受的参数
- en: Implementing ScalingLazyColumn to showcase your content
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将`ScalingLazyColumn`实现为展示您的内容
- en: '`ScalingLazyColumn` extends `LazyColumn`, which is very powerful in Jetpack
    Compose. You can think of `ScalingLazyColumn` as a component in Wear OS that is
    used to display a list of items that can be scrolled vertically. The items are
    scaled and positioned based on their position in the list, and the entire list
    can be scrolled by dragging the top or bottom of the list.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScalingLazyColumn`扩展了`LazyColumn`，在Jetpack Compose中非常强大。您可以将`ScalingLazyColumn`视为Wear
    OS中用于显示可垂直滚动的项目列表的组件。项目根据其在列表中的位置进行缩放和定位，整个列表可以通过拖动列表的顶部或底部进行滚动。'
- en: You can use it, for example, to display a list of components; in our example,
    we will use it to display all the elements we created in previous recipes. You
    will also notice we used it in the *Implementing a scrollable list* recipe, where
    we have a list and displayed the items.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用它，例如，来显示组件列表；在我们的示例中，我们将使用它来显示我们在之前的食谱中创建的所有元素。您还会注意到我们在*实现可滚动列表*食谱中使用了它，在那里我们有一个列表并显示了项目。
- en: Getting ready
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need to have completed the previous recipes to continue with this recipe.
    In addition, in this recipe, instead of commenting on all the elements we created,
    we will display them as items in `ScalingLazyColumn`.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要完成之前的食谱才能继续进行本食谱。此外，在本食谱中，我们不会对创建的所有元素进行注释，而是将它们作为`ScalingLazyColumn`中的项目显示。
- en: How to do it…
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Follow these steps to build your first `ScalingLazyColumn`:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤构建您的第一个`ScalingLazyColumn`：
- en: 'In `MainActivity`, you will notice a comment:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainActivity`中，您会注意到一条注释：
- en: '[PRE190]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE193]'
- en: The comment is a callout to developers to utilize `ScalingLazyColumn`, which
    is an optimized version of `LazyColumn` for Wear OS.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 评论呼吁开发者利用`ScalingLazyColumn`，这是`LazyColumn`针对Wear OS的优化版本。
- en: 'We need to start by creating a `scalingListState` value and initialize it to
    `rememberScalingLazyListState()`:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要首先创建一个`scalingListState`值并将其初始化为`rememberScalingLazyListState()`：
- en: '[PRE194]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE194]'
- en: The `rememberScalingLazyListState()` function simply does as its definition
    implies, which is to remember the state.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '`rememberScalingLazyListState()`函数简单地按照其定义执行，即记住状态。'
- en: 'We will now need to clean up our Composable function by removing the modifiers
    we added and using one for all the views. Let’s create a `contentModifier = Modifier`,
    and one for our icons:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要通过移除我们添加的修饰符并使用一个修饰符来处理所有视图来清理我们的Composable函数。让我们创建一个`contentModifier
    = Modifier`，以及一个用于我们的图标：
- en: '[PRE195]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE200]'
- en: We will also need to create a `Scaffold()`, which implements the Wear Material
    Design visual layout structure. `Scaffold()` uses `modifier`, `vignette`, `positionIndicator`,
    `pageIndicator`, `timeText`, and `content`.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要创建一个`Scaffold()`，它实现了Wear Material Design的视觉布局结构。`Scaffold()`使用`modifier`、`vignette`、`positionIndicator`、`pageIndicator`、`timeText`和`content`。
- en: 'Let’s go ahead and build our screen. In `Scaffold`, we will use three parameters:
    `vignette` (which is a full-screen slot for applying a vignette over the content
    of the scaffold), `positionIndicator`, and `timeText`. Look at the *How it works…*
    section to learn more about the parameters:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续构建我们的屏幕。在`Scaffold`中，我们将使用三个参数：`vignette`（这是一个全屏槽，用于在scaffold的内容上应用vignette）、`positionIndicator`和`timeText`。查看*它如何工作…*部分以了解更多关于参数的信息：
- en: '[PRE201]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE201]'
- en: 'For `TimeText`, we will call `Modifier.scrollAway` and pass in `scalingListState`:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`TimeText`，我们将调用`Modifier.scrollAway`并传递`scalingListState`：
- en: '[PRE202]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'Since we only have one screen for our project sample, which is scrollable,
    we will try to show all items simultaneously and all the time. Hence, in `vignette`,
    we will say the position will be `TopAndBottom`:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们的项目样本只有一个屏幕，且可滚动，我们将尝试同时显示所有项目并始终保持。因此，在`vignette`中，我们将说位置将是`TopAndBottom`：
- en: '[PRE203]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE203]'
- en: 'Finally, on `positionIndicator`, we will just pass `scalingListState`:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`positionIndicator`上，我们只需传递`scalingListState`：
- en: '[PRE204]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'Now, we can finally build our `ScalingLazyColumn()`. We will use `fillMaxSize`
    for the modifier, and `autoCentering` will be set to index zero; then for `state`,
    pass our already created `scalingListState`, and in the items, pass our components:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们终于可以构建我们的 `ScalingLazyColumn()`。我们将使用 `fillMaxSize` 作为修饰符，并将 `autoCentering`
    设置为零索引；然后对于 `state`，传递我们已创建的 `scalingListState`，在项目项中传递我们的组件：
- en: '[PRE205]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE227]'
- en: 'You can get the entire code in the *Technical requirements* section. To clean
    up some of the code in `item{}`, we have the following:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以在 *技术要求* 部分获取完整的代码。为了清理 `item{}` 中的部分代码，我们有以下内容：
- en: '[PRE228]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE232]'
- en: Finally, when you run the application, you should be able to see all the items
    displayed and be able to scroll smoothly.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，当您运行应用程序时，您应该能够看到所有显示的项目，并且能够平滑地滚动。
- en: "![Figure 10\uFEFF.17 – Our \uFEFFcomp\uFEFFosable elements on Wear OS](img/Figure_10.17.jpg)"
  id: totrans-415
  prefs: []
  type: TYPE_IMG
  zh: "![图 10\uFEFF.17 – Wear OS 上的我们的可组合元素](img/Figure_10.17.jpg)"
- en: Figure 10.17 – Our composable elements on Wear OS
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.17 – Wear OS 上的我们的可组合元素
- en: How it works…
  id: totrans-417
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Wear OS Jetpack Compose is a UI toolkit for building Wear OS apps using the
    Jetpack Compose framework. It is designed to make it easier and more efficient
    for developers to create wearable apps with a modern and responsive UI. As mentioned
    before, the `Composable` function called `Scaffold()` has several inputs. In *Figure
    10**.18*, you will see their meaning and why you might want to use them:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: Wear OS Jetpack Compose 是一个用于使用 Jetpack Compose 框架构建 Wear OS 应用的 UI 工具包。它旨在使开发者更容易、更高效地创建具有现代和响应式界面的可穿戴应用。正如之前提到的，名为
    `Scaffold()` 的 `Composable` 函数有几个输入。在 *图 10**.18* 中，您将看到它们的意义以及为什么您可能想要使用它们：
- en: "![Fig\uFEFFure 10.18 – Scaffold function parameters](img/Figure_10.18.jpg)"
  id: totrans-419
  prefs: []
  type: TYPE_IMG
  zh: "![Fig\uFEFFure 10.18 – Scaffold 函数参数](img/Figure_10.18.jpg)"
- en: Figure 10.18 – Scaffold function parameters
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.18 – Scaffold 函数参数
- en: Some of the significant advantages of Wear OS in Jetpack Compose is that it
    provides a set of pre-built UI components that are optimized for the unique features
    of Wear OS devices. And one of the critical benefits is that it simplifies the
    development process by reducing the amount of boilerplate code that is required
    to create a UI.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: Wear OS 在 Jetpack Compose 中的某些显著优势是它提供了一套针对 Wear OS 设备独特特性优化的预构建 UI 组件。其中一个关键好处是它通过减少创建
    UI 所需的样板代码量来简化开发过程。
- en: 'It also provides a consistent and flexible UI design language that can be used
    across different apps. There is more to learn about Wear OS; also, since this
    is a new technology, many of the concepts here might change or advance due to
    API changes in the future, but for now, you can learn more by following this link:
    [https://developer.android.com/wear](https://developer.android.com/wear).'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 它还提供了一致且灵活的 UI 设计语言，可以在不同的应用中使用。关于 Wear OS 还有更多可以学习的内容；此外，由于这是一项新技术，这里的一些概念可能会因为未来
    API 的变化而改变或进步，但到目前为止，您可以通过以下链接了解更多信息：[https://developer.android.com/wear](https://developer.android.com/wear)。
- en: Important note
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'There is more to build in Wear OS; for instance, you can build a tile and react
    when the tile items get clicked to perform an action. To learn more about how
    you can create your first tile, follow this link: [https://developer.android.com/codelabs/wear-tiles](https://developer.android.com/codelabs/wear-tiles).'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Wear OS 中还有更多可以构建的内容；例如，您可以构建一个瓷砖，并在瓷砖项被点击时执行操作。要了解更多关于如何创建您的第一个瓷砖的信息，请点击此链接：[https://developer.android.com/codelabs/wear-tiles](https://developer.android.com/codelabs/wear-tiles)。
