- en: Chapter 9. Performance Testing and Profiling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章。性能测试和配置文件
- en: In the previous chapters, we studied and developed tests for our Android application.
    Those tests let us evaluate the compliance to a certain number of specifications
    and allow us to determine if the software is behaving correctly or according to
    these rules by taking a binary verdict, whether it complies or not. If it does
    the software is correct; if it does not we have to fix it until it does.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们研究了为我们的 Android 应用程序开发的测试。这些测试使我们能够评估符合一定数量的规范，并允许我们通过二进制判断（是否合规）来确定软件是否按这些规则正确运行。如果它符合，则软件是正确的；如果不符，我们必须修复它，直到它符合。
- en: In many other cases, mainly after we have verified that the software conforms
    to all these specifications, we want to move forward and know how or in what manner
    they are satisfied, and at the same time how the system performs under different
    situations to analyze other attributes such as usability, speed, response time,
    and reliability.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多其他情况下，主要是在我们验证软件符合所有这些规范之后，我们希望向前推进，了解它们是如何满足的，同时了解系统在不同情况下的性能，以分析其他属性，如可用性、速度、响应时间和可靠性。
- en: 'According to Android Developer''s Guide ([http://developer.android.com/guide/index.html](http://developer.android.com/guide/index.html)),
    these are the best practices when it comes to designing our application:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 根据《Android 开发者指南》（[http://developer.android.com/guide/index.html](http://developer.android.com/guide/index.html)），以下是我们设计应用程序时的最佳实践：
- en: Designing for performance
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为性能设计
- en: Designing for responsiveness
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为响应性设计
- en: Designing for seamlessness
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为无缝设计
- en: It's extremely important to follow these best practices and start thinking mainly
    in terms of performance and responsiveness from the very beginning of the design.
    Since our application will run on mobile devices with limited computer power,
    the bigger gains are obtained by identifying the targets for the optimization
    once our application is built, at least partially, and applying the performance
    testing that we will be discussing soon.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要遵循这些最佳实践，并在设计之初主要从性能和响应性的角度思考。由于我们的应用程序将在有限的计算机功率的移动设备上运行，因此通过识别优化目标，我们可以获得更大的收益，至少部分地构建我们的应用程序，并应用我们即将讨论的性能测试。
- en: 'As Donald Knuth popularized years ago:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如唐纳德·克努特多年前所普及的：
- en: '"Premature *optimization is the root of all evil"*.'
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “过早的*优化是万恶之源*”。
- en: These optimizations, which are based on guesses, intuition, and even superstition
    often interfere with the design over short term periods, and with readability
    and maintainability over long term periods. On the contrary, *micro-optimizations*
    are based on identifying the bottlenecks or hot-spots that require optimization,
    apply the changes, and then benchmark again to evaluate the improvements of the
    optimization. So the point we are concentrating on here is on measuring the existing
    performance and the optimization alternatives.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这些基于猜测、直觉甚至迷信的优化，在短期内可能会干扰设计，在长期内可能会干扰可读性和可维护性。相反，*微优化*基于识别需要优化的瓶颈或热点，应用更改，然后再次基准测试以评估优化的改进。因此，我们在这里关注的是衡量现有性能和优化替代方案。
- en: 'This chapter will introduce a series of concepts related to benchmarking and
    profiles as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍一系列与基准测试和配置文件相关的概念，如下所示：
- en: Traditional logging statement methods
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统的日志语句方法
- en: Creating Android performance tests
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 Android 性能测试
- en: Using profiling tools
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用性能分析工具
- en: Microbenchmarks using Caliper
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Caliper 进行微基准测试
- en: Ye Olde Logge method
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 旧日志方法
- en: Sometimes this is too simplistic for real scenarios but I'm not going to say
    that it could not help in some cases mainly because its implementation takes minutes
    and you only need the `logcat` text output to analyze the case, which comes in
    handy during situations as described in previous chapters where you want to automate
    procedures or apply Continuous Integration.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有时这对于实际场景来说过于简单，但我不认为它不能在某些情况下有所帮助，主要是因为它的实现只需要几分钟，而你只需要`logcat`文本输出来分析案例，这在前面章节中描述的情况中很有用，那时你想自动化流程或应用持续集成。
- en: 'This method consists in timing a method, and or a part of it, surrounding it
    by two time measures and logging the difference at the end:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法包括计时一个方法，或其一部分，围绕它进行两次时间测量，并在结束时记录差异：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is very straightforward. We take the times and log the difference. For
    this we are using the `Log.i()` method and we can see the output in `logcat` while
    we run the application. You can control the execution of this benchmark by setting
    `true` or `false` to the `BENCHMARK_TEMPERATURE_CONVERSION` constant that you
    should have defined elsewhere.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常直接。我们记录时间并记录差异。为此，我们使用 `Log.i()` 方法，并在运行应用程序时可以在 `logcat` 中看到输出。您可以通过将 `BENCHMARK_TEMPERATURE_CONVERSION`
    常量设置为 `true` 或 `false` 来控制此基准的执行，该常量您应该在别处定义。
- en: 'When we launch the activity with the `BENCHMARK_TEMPERATURE_CONVERSION` constant
    set to true in the `logcat`, we will receive messages like these every time the
    conversion takes place:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 `logcat` 中将 `BENCHMARK_TEMPERATURE_CONVERSION` 常量设置为 `true` 来启动活动时，每次转换发生时我们都会收到如下消息：
- en: '**INFO/TemperatureConverterActivity(392): TemperatureConversion took 55 ms
    to complete**.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**INFO/TemperatureConverterActivity(392): 温度转换完成耗时 55 毫秒**。'
- en: '**INFO/TemperatureConverterActivity(392): TemperatureConversion took 11 ms
    to complete**.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**INFO/TemperatureConverterActivity(392): 温度转换完成耗时 11 毫秒**。'
- en: '**INFO/TemperatureConverterActivity(392): TemperatureConversion took 5 ms to
    complete**.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**INFO/TemperatureConverterActivity(392): 温度转换完成耗时 5 毫秒**。'
- en: Something you should take into account is that these benchmark-enabling constants
    should not be enabled in the production build, as other common constants are used
    like DEBUG or LOGD. To avoid this mistake you should integrate the verification
    of these constants values in the build process you are using for automated builds
    such as Ant or Make.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该考虑的是，这些启用基准的常量不应在生产构建中启用，因为还使用了其他常见常量，如 DEBUG 或 LOGD。为了避免这种错误，您应该在用于自动化构建（如
    Ant 或 Make）的构建过程中集成这些常量值的验证。
- en: Pretty simple, but this would not apply for more complex cases.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单，但这不适用于更复杂的情况。
- en: Performance tests in Android SDK
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android SDK 中的性能测试
- en: If the previous method of adding log statements does not suit you, there is
    a different method of getting performance test results from our application.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果之前添加日志语句的方法不适合您，我们可以采用另一种方法从我们的应用程序中获取性能测试结果。
- en: Unfortunately, performance tests in Android SDK are half baked (at least up
    to Android 2.3 Gingerbread, the latest version available at the time this book
    was written). There is no reasonable way of getting performance test results from
    an Android SDK application as the classes used by Android tests are hidden in
    the Android SDK and only available to system applications, that is to applications
    that are built as part of the main build or system image. This strategy is not
    available for SDK applications so we are not digging deeper in that direction
    and we will focus on other available choices.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Android SDK 中的性能测试并不完善（至少在本书编写时，最新的版本是 Android 2.3 Gingerbread）。从 Android
    SDK 应用程序中获取性能测试结果没有合理的方法，因为 Android 测试所使用的类隐藏在 Android SDK 中，并且仅对系统应用程序可用，即作为主构建或系统镜像的一部分构建的应用程序。这种策略对
    SDK 应用程序不可用，因此我们不会深入这个方向，而是将重点放在其他可用的选择上。
- en: Launching the performance test
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动性能测试
- en: These tests are based on a similar approach like the one used by Android to
    test system applications. The idea is to extend `android.app.Instrumentation`
    to provide performance snapshots, automatically creating a framework that we can
    even extend to satisfy other needs. We are presenting a simple case here due to
    the limitations imposed by this medium.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试基于与 Android 测试系统应用程序所使用的方法类似的方法。想法是扩展 `android.app.Instrumentation` 以提供性能快照，自动创建一个我们可以甚至扩展以满足其他需求的框架。由于这个媒体的限制，我们在这里展示一个简单的案例。
- en: Creating the LaunchPerformanceBase instrumentation
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 LaunchPerformanceBase 仪器
- en: 'Our first step is to extend `Instrumentation` to provide the functionality
    we need. We are using a new package named `com.example.aatg.tc.test.launchperf`
    to keep our tests organized:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是扩展 `Instrumentation` 以提供我们需要的功能。我们正在使用一个名为 `com.example.aatg.tc.test.launchperf`
    的新包来组织我们的测试：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We are extending `Instrumentation` here. The constructor initialized the two
    fields in this class: `mResults` and `mIntent`. At the end we invoke the method
    `setAutomaticPerformanceSnapshots()` which is the key here to create this performance
    test.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '我们在这里扩展了 `Instrumentation`。构造函数初始化了该类中的两个字段：`mResults` 和 `mIntent`。最后，我们调用
    `setAutomaticPerformanceSnapshots()` 方法，这是创建此性能测试的关键。 '
- en: The method `LaunchApp()` is in charge of starting the desired `Activity` and
    waiting before returning.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`LaunchApp()` 方法负责启动所需的 `Activity` 并等待返回。'
- en: The `finish()` method logs the results received and then invokes `Instrumentation's
    finish()`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`finish()` 方法记录接收到的结果，然后调用 `Instrumentation` 的 `finish()`。'
- en: Creating the TemperatureConverterActivityLaunchPerformance class
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 TemperatureConverterActivityLaunchPerformance 类
- en: This class sets up the `Intent` to invoke the `TemperatureConverterActivity`
    and furnish the infrastructure provided by the `LaunchPerformanceBase` class to
    test the performance of launching our `Activity:`
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类设置了 `Intent` 以调用 `TemperatureConverterActivity`，并提供了 `LaunchPerformanceBase`
    类所提供的基础设施来测试我们的 `Activity` 的性能：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, `onCreate()` calls `super.onCreate()` as the Android lifecycle dictates.
    Then the `Intent` is set, specifying the class name and the package. Then one
    of the `Instrumentation's` methods is called, `start()`, which creates and starts
    a new thread in which to run instrumentation. This new thread will make a call
    to `onStart()`, where you can implement the instrumentation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`onCreate()` 调用 `super.onCreate()`，遵循 Android 生命周期。然后设置 `Intent`，指定类名和包名。然后调用
    `Instrumentation` 的一个方法，`start()`，它创建并启动一个新的线程来运行仪器化测试。这个新线程将调用 `onStart()`，在那里你可以实现仪器化测试。
- en: Then `onStart()` implementation follows, invoking `LaunchApp()` and `finish()`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是 `onStart()` 的实现，调用 `LaunchApp()` 和 `finish()`。
- en: Running the tests
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行测试
- en: To be able to run this test we need to define the specific `Instrumentation`
    in the `AndroidManifest.xml` of the `TemperatureConverterTest` project.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够运行这个测试，我们需要在 `TemperatureConverterTest` 项目的 `AndroidManifest.xml` 中定义特定的
    `Instrumentation`。
- en: 'This is the snippet of code we have to add to the manifest:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们要添加到清单中的代码片段：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Once everything is in place we are ready to start running the test.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一切准备就绪后，我们就可以开始运行测试了。
- en: 'First, install the APK that includes these changes. Then, we have several options
    to run the tests as we have reviewed in previous chapters. In this case we are
    using the command line as it is the easiest way of getting all the details. Replace
    the serial number for what is applicable in your case:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，安装包含这些更改的 APK。然后，我们有几种运行测试的方法，正如我们在前面的章节中回顾的那样。在这种情况下，我们使用命令行，因为它是最容易获取所有细节的方法。替换适用于你情况的序列号：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We receive the set of results for this test in the standard output:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在标准输出中收到了这个测试的结果集：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We have highlighted two of the values we are interested in: **execution_time**
    and **cpu_time**. They account for the total execution time and the CPU time used
    respectively.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们突出显示了两个我们感兴趣的值：**execution_time** 和 **cpu_time**。它们分别代表总执行时间和使用的 CPU 时间。
- en: Running this test on an emulator increases the potential for mis-measurement,
    because the host computer is running other processes that also take on the CPU,
    and the emulator does not necessarily represent the performance of a real piece
    of hardware.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟器上运行此测试会增加误测量的可能性，因为主机计算机正在运行其他进程，这些进程也会占用 CPU，而模拟器并不一定代表真实硬件的性能。
- en: Because of this we are taking these two measures into account. The `execution_time`
    gives us the real time and `cpu_time` the total time used by the CPU to compute
    our code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，我们正在考虑这两项措施。`execution_time` 给我们提供了实际时间，而 `cpu_time` 提供了用于计算我们代码的总 CPU
    时间。
- en: Needless to say, that in this and any other case where you measure something
    that is variable over time, you should use a measurement strategy and run the
    test several times to obtain different statistical values, such as average or
    standard deviation.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 不言而喻，在测量随时间变化的事物时，你应该使用测量策略并多次运行测试以获得不同的统计值，例如平均值或标准差。
- en: Unfortunately, the current implementation of Android ADT does not allow using
    an instrumentation that does not extend `android.test.InstrumentationTestRunner`,
    though `.launchperf.TemperatureConverterActivityLaunchPerformance` extends `LaunchPerformaceBase`
    that extends `Instrumentation`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，当前 Android ADT 的实现不允许使用不扩展 `android.test.InstrumentationTestRunner` 的仪器化测试，尽管
    `.launchperf.TemperatureConverterActivityLaunchPerformance` 扩展了 `LaunchPerformaceBase`，而
    `LaunchPerformaceBase` 又扩展了 `Instrumentation`。
- en: 'This screenshot shows the error trying to define this Instrumentation in Eclipse
    Run Configurations:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这张截图显示了在 Eclipse 运行配置中尝试定义此仪器化测试时出现的错误：
- en: '![Running the tests](img/3500_09_01.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![运行测试](img/3500_09_01.jpg)'
- en: Using the Traceview and dmtracedump platform tools
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Traceview 和 dmtracedump 平台工具
- en: The Android SDK includes among its various tools two that are specially intended
    to analyze performance problems and potentially determine the target to apply
    optimizations.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Android SDK 包含了各种工具，其中有两个是专门用于分析性能问题和可能确定应用优化的目标的。
- en: 'These tools have an advantage over other alternatives: usually no modification
    to the source code is needed for simpler tasks. However, for more complex cases
    some additions are needed, but they are very simple as we will see shortly.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具与其他替代方案相比具有优势：通常对于更简单的任务不需要修改源代码。然而，对于更复杂的情况，需要添加一些内容，但它们非常简单，就像我们很快就会看到的那样。
- en: 'If you don''t need precision about starting and stopping tracing, you can drive
    it from the command line or Eclipse. For example, to start tracing from the command
    line you can use the following command. Remember to replace the serial number
    for what is applicable in your case:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不需要关于开始和停止跟踪的精确度，您可以从命令行或Eclipse驱动它。例如，要从命令行开始跟踪，您可以使用以下命令。请记住，用您的情况中适用的序列号替换：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Do something, for example enter a temperature in the Celsius field to force
    a conversion.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 做些事情，例如在摄氏度字段中输入温度以强制转换。
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Otherwise, if you need more precision about when profiling starts, you can
    add this piece of code instead of the previous one:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，如果您需要更多关于分析开始时间的精确度，您可以添加此段代码而不是之前的那个：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will create a trace file, using the default name `dmtrace.trace` in the
    Sdcard by invoking `Debug.startMethodTracing()`, which starts method tracing with
    the default log name and buffer size. When we are done, we call `Debug.stopMethodTracing()`
    to stop the profiling.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个跟踪文件，通过调用`Debug.startMethodTracing()`在Sdcard中使用默认名称`dmtrace.trace`，该命令以默认日志名称和缓冲区大小开始方法跟踪。当我们完成时，我们调用`Debug.stopMethodTracing()`来停止分析。
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To be able to write to the Sdcard the application requires a `android.permission.WRITE_EXTERNAL_STORAGE`
    permission added in the manifest.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够写入Sdcard，应用程序需要在清单中添加`android.permission.WRITE_EXTERNAL_STORAGE`权限。
- en: For VMs earlier than Android 2.2, the permission is required even for doing
    this from Eclipse as the file is also generated. Starting with Android 2.2, the
    stream is sent through the JDWP connection and the permission is not needed anymore.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Android 2.2之前的虚拟机，即使从Eclipse执行此操作也需要权限，因为文件也会生成。从Android 2.2开始，流通过JDWP连接发送，不再需要权限。
- en: You need to exercise the application in order to obtain the trace file. This
    file needs to be pulled to the development computer to be further analyzed using
    `traceview:`
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要运行应用程序以获取跟踪文件。此文件需要被拉到开发计算机上，以便使用`traceview`进行进一步分析：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After running this command `traceview''s` window appears displaying all the
    information collected:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，`traceview`的窗口出现，显示收集到的所有信息：
- en: '![Using the Traceview and dmtracedump platform tools](img/3500_09_02.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![使用Traceview和dmtracedump平台工具](img/3500_09_02.jpg)'
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that enabling profiling really slows down the application execution
    so the measure should be interpreted by its relative weight not by their absolute
    values.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，启用分析确实会减慢应用程序的执行速度，因此应该根据其相对权重而不是绝对值来解释测量结果。
- en: The top part of the window shows the **timeline panel** and a colored area for
    every method. Time increases to the right. There are also small lines under the
    colored row displaying the extent of all the calls to the selected method.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口的顶部显示**时间线面板**和每个方法的彩色区域。时间向右增加。在彩色行下方还有小线显示所选方法的全部调用范围。
- en: We profiled a small segment of our application so only the main thread was running.
    In other cases where other threads were running during the profiling, this information
    will also be displayed.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们分析了应用程序的小部分，所以只有主线程在运行。在其他情况下，如果在分析期间有其他线程在运行，此信息也将显示。
- en: The bottom part shows the **profile panel** and every method executed and its
    parent-child relationship. We refer to calling methods as *parents* and called
    methods as *children*. When clicked, a method expands to show its parents and
    children. Parents are shown with a purple background and children with a yellow
    background.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 底部部分显示**配置面板**和每个执行的方法及其父子关系。我们将调用方法称为*父方法*，被调用方法称为*子方法*。当点击时，方法展开以显示其父方法和子方法。父方法以紫色背景显示，子方法以黄色背景显示。
- en: Also the color selected for the method, done in a round-robin fashion, is displayed
    before the method name.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 选择的用于方法的颜色，以轮询方式完成，显示在方法名称之前。
- en: Finally, at the bottom there's a **Find:** field where we can enter a filter
    to reduce the amount of information displayed. For example if we are only interested
    in displaying methods in the `com.example.aatg.tc` package, we should enter **com/example/aatg/tc**.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在底部有一个**查找**字段，我们可以输入一个过滤器以减少显示的信息量。例如，如果我们只想显示`com.example.aatg.tc`包中的方法，我们应该输入**com/example/aatg/tc**。
- en: Clicking on a column will set the order of the list according to this column
    in ascending or descending order.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 点击列将根据该列按升序或降序设置列表的顺序。
- en: 'This table describes the available columns and their descriptions:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 本表描述了可用的列及其描述：
- en: '| Column | Description |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 列 | 描述 |'
- en: '| --- | --- |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| name | The name of the method including its package name in the form described
    above, which is using "/" (slash) as the delimiter. Also the parameters and the
    return type are displayed. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| name | 方法的名称，包括其包名，形式如上所述，使用"/"（斜杠）作为分隔符。同时显示参数和返回类型。 |'
- en: '| Incl% | The inclusive time, as a percentage of the total time, used by the
    method. That is including all of its children. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| Incl% | 方法使用的包含时间，占总时间的百分比。即包括其所有子项。 |'
- en: '| Inclusive | The inclusive time, in milliseconds, used by this method. That
    is including this method and all of its children. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| Inclusive | 此方法使用的包含时间，以毫秒为单位。即包括此方法和其所有子项。 |'
- en: '| Excl% | The exclusive time, as a percentage of the total time, used by the
    method. That is excluding all of its children. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| Excl% | 方法使用的排除时间，占总时间的百分比。即不包括其所有子项。 |'
- en: '| Exclusive | The exclusive time, in milliseconds, this is the total time spent
    in this method. That is excluding all of its children. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| Exclusive | 排除时间，以毫秒为单位，这是在此方法中花费的总时间。即不包括其所有子项。 |'
- en: '| Calls+RecurCalls/Total | This column shows the number of calls for this method
    and the number of recursive calls.The number of calls compared with the total
    number of calls made to this method. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| Calls+RecurCalls/Total | 此列显示此方法的调用次数和递归调用次数。这是与调用此方法的总调用次数相比的调用次数。 |'
- en: '| Time/Call | The time in milliseconds of every call.That is Inclusive/Calls.
    |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| Time/Call | 每次调用的耗时，以毫秒为单位。即包含时间/调用次数。 |'
- en: Microbenchmarks
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微基准测试
- en: Benchmarking is the act of running a computer program or operation in order
    to compare operations in a way that produces quantitative results, normally by
    running a set of tests and trials against them.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试是指运行计算机程序或操作，以便以产生定量结果的方式比较操作，通常是通过对这些操作运行一系列测试和试验。
- en: 'Benchmarks can be organized in two big categories:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试可以分为两大类：
- en: Macrobenchmarks
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏基准测试
- en: Microbenchmarks
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微基准测试
- en: '**Macrobenchmarks** exist as a means to compare different platforms in specific
    areas such as processor speed, number of floating point operations per unit of
    time, graphics and 3D performance, and so on. They are normally used against hardware
    components but can also be used to test software specific areas, such as compiler
    optimization or algorithms.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**宏基准测试**作为一种比较不同平台在特定领域（如处理器速度、每单位时间的浮点运算次数、图形和3D性能等）的方法存在。它们通常用于硬件组件，但也可以用于测试软件特定区域，例如编译器优化或算法。'
- en: As opposed to these traditional macrobenchmarks, a **microbenchmark** attempts
    to measure the performance of a very small piece of code, often a single method.
    The results obtained are used to choose between competing implementations that
    provide the same functionality deciding the optimization path.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 与这些传统的宏基准测试相反，**微基准测试**试图测量非常小的一段代码的性能，通常是单个方法。获得的结果用于在提供相同功能的不同实现之间进行选择，决定优化路径。
- en: The risk here is to microbenchmark something different than what you think you
    are measuring. This is something to take into account mainly in the case of JIT
    compilers as used by Android starting with version 2.2 Froyo. The JIT compiler
    may compile and optimize your microbenchmark differently than the same code in
    your application. So, be cautious when taking your decision.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的风险在于微基准测试可能与你认为测量的内容不同。这主要是在使用Android从2.2 Froyo版本开始的JIT编译器的情况下需要考虑的事情。JIT编译器可能会以不同于应用程序中相同代码的方式编译和优化你的微基准测试。因此，在做出决定时要谨慎。
- en: This is different from the profiling tactic introduced in the previous section
    as this approach does not consider the entire application but a single method
    or algorithm at a time.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这与上一节中介绍的分析策略不同，因为这种方法并不考虑整个应用程序，而是一次考虑一个方法或算法。
- en: Caliper microbenchmarks
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Caliper 微基准测试
- en: '**Caliper** is Google''s Open Source framework for writing, running, and viewing
    results of microbenchkmarks. There are many examples and tutorials on its website
    at [http://code.google.com/p/caliper/](http://code.google.com/p/caliper/).'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**Caliper** 是 Google 的开源框架，用于编写、运行和查看微基准测试的结果。在其网站上有很多示例和教程，网址为 [http://code.google.com/p/caliper/](http://code.google.com/p/caliper/)。'
- en: It's a work in progress but still useful in many circumstances. We are exploring
    its essential use here and will introduce more Android related usage in the next
    chapter.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这还是一个正在进行中的项目，但在许多情况下仍然很有用。我们在这里探索其基本用法，并在下一章中介绍更多与 Android 相关的用法。
- en: Its central idea is to benchmark methods, mainly to understand how efficient
    they are; we may decide that this is the target for our optimization, perhaps
    after analyzing the results provided by profiling via traveview.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 其核心思想是基准测试方法，主要是为了了解它们的效率；我们可能会决定这是我们的优化目标，也许是在分析了通过 traveview 做的剖析提供的结果之后。
- en: Caliper benchmark extends normally `com.google.caliper.SimpleBenchmark` which
    implements the `Benchmark` interface. Benchmarks are structured in a similar fashion
    as JUnit 3 tests and maintain the same structure with the difference that here
    benchmarks start with the prefix **time** as opposed to **test**. Every benchmark
    then accepts an `int` parameter usually named `reps`, indicates the number of
    repetitions to benchmark the code that sits inside the method surrounded by a
    loop counting the repetitions.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Caliper 基准测试通常扩展 `com.google.caliper.SimpleBenchmark`，该类实现了 `Benchmark` 接口。基准测试的结构与
    JUnit 3 测试类似，并保持了相同的结构，唯一的区别是这里的基准测试以 **time** 前缀开始，而不是 **test**。每个基准测试都接受一个 `int`
    参数，通常命名为 `reps`，表示要基准测试的方法中代码的重复次数，该方法被一个计数重复的循环所包围。
- en: The `setUp()` method is also present.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`setUp()` 方法也存在。'
- en: We need caliper installed in our computer. At the time of this writing, caliper
    is not distributed as binary but as source code that you can download and build
    yourself. Follow the instructions provided in its website which basically is getting
    the source code and building yourself.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在我们的计算机上安装 caliper。在撰写本文时，caliper 并非以二进制形式分发，而是以源代码形式提供，您可以下载并自行构建。请遵循其网站上的说明，基本上就是获取源代码并自行构建。
- en: 'Put in a very simple way, you can do it using these command lines. You need
    Subversion and Ant installed to do it:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 用非常简单的方式来说，您可以使用以下命令行来完成它。您需要安装 Subversion 和 Ant 才能完成此操作：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `calliper-0.0.jar` and `allocation.jar` will be found in the `build/caliper-0.0/lib`
    subdirectory.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`calliper-0.0.jar` 和 `allocation.jar` 将会在 `build/caliper-0.0/lib` 子目录下找到。'
- en: Creating the TemperatureConverterBenchmark project
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 TemperatureConverterBenchmark 项目
- en: Let's start by creating a new Java project in Eclipse. Yes, this time is not
    an Android project, just Java.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在 Eclipse 中创建一个新的 Java 项目开始。是的，这次不是 Android 项目，而是 Java。
- en: For consistency use the package `com.example.aatg.tc.benchmark` as the main
    package.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持一致性，请使用包 `com.example.aatg.tc.benchmark` 作为主包。
- en: Add the `caliper` library and the existing `TemperatureConverter` project to
    the **Java Build Path** in the project's properties.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `caliper` 库和现有的 `TemperatureConverter` 项目添加到项目的属性中的 **Java Build Path**。
- en: 'Then create the `TemperatureConverterBenchmark` class that is containing our
    benchmarks:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后创建包含我们的基准测试的 `TemperatureConverterBenchmark` 类：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We have a `setUp()` method that, similar to JUnit tests, is run before the benchmarks
    are run. This method initializes an array of random temperatures used in the conversion
    benchmark. The size of this array is passed as a parameter to caliper and annotated
    here with the `@Param` annotation. Caliper will provide the value of this parameter
    automatically.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个 `setUp()` 方法，类似于 JUnit 测试，在基准测试运行之前执行。此方法初始化用于转换基准测试的随机温度数组。此数组的大小作为参数传递给
    caliper，并在此处用 `@Param` 注解标记。Caliper 将自动提供此参数的值。
- en: We use a Gaussian distribution for the pseudo-random temperatures as this could
    be a good model of the reality.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用高斯分布来模拟伪随机温度，因为这可能是现实世界的一个很好的模型。
- en: Then the benchmark itself. As we noted before it should start with the prefix
    time, as in this instance `timeCelsiusToFahrenheit()`. Inside this method we loop
    for the repetitions and invoke the conversion `TemperatureConverter.celsiusToFahrenheit()`
    which is the method we wish to benchmark.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是基准测试本身。正如我们之前提到的，它应该以时间前缀开始，例如在这个例子中是 `timeCelsiusToFahrenheit()`。在这个方法中，我们循环进行重复操作，并调用转换
    `TemperatureConverter.celsiusToFahrenheit()`，这是我们希望基准测试的方法。
- en: Running caliper
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行 caliper
- en: 'To run caliper we use a script which is based on the script that comes with
    the distribution. Be sure to place it in a directory included in the `PATH` or
    use the correct path to invoke it:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行caliper，我们使用一个基于分发中提供的脚本的脚本。请确保将其放置在包含在`PATH`中的目录中，或者使用正确的路径来调用它：
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Adapt it to your needs. Before running it, remember that we still need to set
    our `CLASSPATH` so caliper can find the `TemperatureConverter` and the benchmarks
    themselves. For example:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的需求进行适配。在运行之前，请记住我们仍然需要设置我们的`CLASSPATH`，以便caliper能够找到`TemperatureConverter`以及基准测试本身。例如：
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Afterwards we can run caliper as:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 之后我们可以像这样运行caliper：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will run the benchmarks and if everything goes well we will be presented
    with the results:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这将运行基准测试，如果一切顺利，我们将看到结果：
- en: '**0% Scenario{vm=java, benchmark=CelsiusToFahrenheit, size=1} 8.95ns; σ=0.11ns
    @ 10 trials**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**0% Scenario{vm=java, benchmark=CelsiusToFahrenheit, size=1} 8.95ns; σ=0.11ns
    @ 10 trials**'
- en: '**.caliperrc found, reading properties..**.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**.caliperrc found, reading properties..**.'
- en: '**ns logarithmic runtime**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**ns 对数运行时间**'
- en: '**9 XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**9 XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX**'
- en: '**vm: java**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**vm: java**'
- en: '**benchmark: CelsiusToFahrenheit**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**基准：摄氏度转华氏度**'
- en: '**size: 1**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**size: 1**'
- en: 'Alternatively we can repeat the benchmark for different number of temperatures
    to find out if the values itself affect the performance of the conversion. In
    such cases we run:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以为不同的温度重复基准测试，以找出这些值本身是否会影响转换的性能。在这种情况下，我们运行：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here we added different sizes for the temperatures array and the results obtained
    are as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为温度数组添加了不同的尺寸，得到的结果如下：
- en: '**0% Scenario{vm=java, trial=0, benchmark=CelsiusToFahrenheit, size=1} 3.47
    ns; σ=0.19 ns @ 10 trials**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**0% Scenario{vm=java, trial=0, benchmark=CelsiusToFahrenheit, size=1} 3.47
    ns; σ=0.19 ns @ 10 trials**'
- en: '**33% Scenario{vm=java, trial=0, benchmark=CelsiusToFahrenheit, size=10} 11.67
    ns; σ=1.20 ns @ 10 trials**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**33% Scenario{vm=java, trial=0, benchmark=CelsiusToFahrenheit, size=10} 11.67
    ns; σ=1.20 ns @ 10 trials**'
- en: '**67% Scenario{vm=java, trial=0, benchmark=CelsiusToFahrenheit, size=100} 63.06
    ns; σ=3.83 ns @ 10 trials**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**67% Scenario{vm=java, trial=0, benchmark=CelsiusToFahrenheit, size=100} 63.06
    ns; σ=3.83 ns @ 10 trials**'
- en: '**67% Scenario{vm=java, trial=0, benchmark=CelsiusToFahrenheit, size=100} 63.06
    ns; σ=3.83 ns @ 10 trials**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**67% Scenario{vm=java, trial=0, benchmark=CelsiusToFahrenheit, size=100} 63.06
    ns; σ=3.83 ns @ 10 trials**'
- en: '**size ns linear runtime**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**size ns 线性运行时间**'
- en: '**1 3.47 =**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**1 3.47 =**'
- en: '**10 11.67 =====**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**10 11.67 =====**'
- en: '**100 63.06 ==============================**'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**100 63.06 ==============================**'
- en: '**vm: java**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**vm: java**'
- en: '**trial: 0**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**trial: 0**'
- en: '**benchmark: CelsiusToFahrenheit**'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**基准：摄氏度转华氏度**'
- en: To help visualize these results there is a service hosted in the Google AppEngine
    ([http://microbenchmarks.appspot.com](http://microbenchmarks.appspot.com)) that
    accepts your result's data and lets you visualize them in a much better way. To
    access this service you should obtain an API key providing your Google login.
    Once obtained this key is placed in the `.caliperrc` file in your home directory
    and next time you run the benchmarks the results will be uploaded.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助可视化这些结果，有一个托管在Google AppEngine上的服务（[http://microbenchmarks.appspot.com](http://microbenchmarks.appspot.com)），它接受您的结果数据，并以更好的方式让您可视化它们。要访问此服务，您应该获得一个提供您的Google登录的API密钥。一旦获得此密钥，它就被放置在您主目录中的`.caliperrc`文件中，下次运行基准测试时，结果将被上传。
- en: 'The `.caliperrc` would look like this snippet after you pasted the obtained
    API key:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在粘贴获得的API密钥后，`.caliperrc`将看起来像以下片段：
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now run the benchmarks again using the same command line as before:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次使用之前的相同命令行运行基准测试：
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In addition to the text output, you will receive the instructions to access
    the results online. You can view current and previous benchmark results online
    at:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 除了文本输出外，您还将收到访问结果的说明。您可以在以下位置在线查看当前和以前的基准测试结果：
- en: '[http://microbenchmarks.appspot.com/run/user@gmail.com/com.example.aatg.tc.benchmark.TemperatureConverterBenchmark.CelsiusToFahrenheitBenchmark](http://microbenchmarks.appspot.com/run/user@gmail.com/com.example.aatg.tc.benchmark.TemperatureConverterBenchmark.CelsiusToFahrenheitBenchmark).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://microbenchmarks.appspot.com/run/user@gmail.com/com.example.aatg.tc.benchmark.TemperatureConverterBenchmark.CelsiusToFahrenheitBenchmark](http://microbenchmarks.appspot.com/run/user@gmail.com/com.example.aatg.tc.benchmark.TemperatureConverterBenchmark.CelsiusToFahrenheitBenchmark).'
- en: Note
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: In the previous URL replace `user@gmail.com` with your real Google login username
    that you used to generate the API key.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的URL中，将`user@gmail.com`替换为您用于生成API密钥的真实Google登录用户名。
- en: '![Running caliper](img/3500_09_03.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![运行caliper](img/3500_09_03.jpg)'
- en: Summary
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we dissected the available alternatives to test the performance
    measures of our application benchmarking and profiling our code.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们分析了可用的替代方案，以测试我们应用程序的性能指标，并对我们的代码进行基准测试和性能分析。
- en: While some options that should be provided by the Android SDK are not yet completed
    by the time of this writing, and there is no possibility to implement Android
    `PerformanceTestCases` because some code is hidden in the SDK, we visited and
    analyzed some other valid alternatives.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在撰写本文时，Android SDK应提供的某些选项尚未完成，并且由于SDK中隐藏了一些代码，无法实现Android `PerformanceTestCases`，但我们访问并分析了其他一些有效的替代方案。
- en: Among these alternatives we found that we can use simple log statements to more
    sophisticated code extending Instrumentation.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些替代方案中，我们发现我们可以使用简单的日志语句来扩展更复杂的代码，以增强Instrumentation功能。
- en: Subsequently we analyzed profiling alternatives and described and exemplified
    the use of `traceview` and `dmtracedump`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，我们分析了性能分析替代方案，并描述和举例说明了`traceview`和`dmtracedump`的使用。
- en: Finally, we discovered caliper—a microbenchmarking tool that has native support
    for Android. However, we introduced its most basic usage and postponed more specific
    Android and Dalvik VM usage for the next chapter.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们发现了一个名为caliper的微基准测试工具，它对Android有原生支持。然而，我们只介绍了其最基本的使用方法，并将更具体的Android和Dalvik
    VM使用方法推迟到下一章。
- en: In the next chapter we will be building Android from source code to obtain an
    EMMA instrumented build and we will be executing coverage report on our code.
    We will also introduce alternative tactics and tools by the end of the chapter.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从源代码构建Android，以获得EMMA增强的构建，并将对我们的代码执行覆盖率报告。我们还将在本章结束时介绍替代策略和工具。
