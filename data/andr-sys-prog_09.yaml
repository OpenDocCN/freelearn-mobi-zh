- en: Booting Up x86vbox Using PXE/NFS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 PXE/NFS 引导 x86vbox
- en: In the last chapter, we created the x86vbox device and we were able to build
    it in our environment. In this chapter, we will start to debug the boot up process
    for x86vbox. The first thing that we meet in the boot up process is the bootloader
    issue. We could use the same GRUB bootloader as Android-x86\. With GRUB, we still
    have issues about how to configure and install it on the storage media. If we
    go this way, we need to spend some time talking about the topics related to bootloader.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了 x86vbox 设备，并且我们能够在我们的环境中构建它。在这一章中，我们将开始调试 x86vbox 的引导过程。在引导过程中我们遇到的第一件事是引导加载程序问题。我们可以使用与
    Android-x86 相同的 GRUB 引导加载程序。使用 GRUB，我们仍然会遇到如何在存储介质上配置和安装它的问题。如果我们这样做，我们需要花时间讨论与引导加载程序相关的话题。
- en: 'Using VirtualBox as a virtual hardware platform, we have a much simpler solution.
    We can use the built-in PXE boot mechanism to avoid bootloader issues. From a
    debugging point of view, PXE boot can make the entire boot up process more transparent
    to us. With PXE boot, we can move the installation of bootloader out of the picture
    so we can concentrate on debugging the Android system itself. In this chapter,
    we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 VirtualBox 作为虚拟硬件平台，我们有一个更简单的解决方案。我们可以使用内置的 PXE 引导机制来避免引导加载程序问题。从调试的角度来看，PXE
    引导可以使整个引导过程对我们更加透明。使用 PXE 引导，我们可以将引导加载程序的安装移出画面，这样我们就可以专注于调试 Android 系统本身。在本章中，我们将涵盖以下主题：
- en: Setting up a PXE boot environment
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 PXE 引导环境
- en: Configuring VirtualBox to boot from PXE
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 VirtualBox 从 PXE 引导
- en: Setting up the root filesystem using NFS
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 NFS 设置根文件系统
- en: Setting up a PXE boot environment
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 PXE 引导环境
- en: What is PXE? **PXE** means **Preboot Execution Environment**. To build a Linux
    environment, what we need is to find a way to load the kernel and ramdisk to the
    system memory. This is one of the major tasks performed by most Linux bootloaders.
    The bootloader usually fetches the kernel and ramdisk from some kind of storage
    device, such as flash storage, hard disk, USB, and so on. It can also be retrieved
    from a network connection. PXE is a method that can boot a device with LAN connection
    and a PXE-capable **network interface controller** (**NIC**).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是 PXE？**PXE** 代表 **预引导执行环境**。为了构建 Linux 环境，我们需要找到一种方法将内核和 ramdisk 装载到系统内存中。这是大多数
    Linux 引导加载程序执行的主要任务之一。引导加载程序通常从某种存储设备中获取内核和 ramdisk，例如闪存存储、硬盘、USB 等。它也可以从网络连接中获取。PXE
    是一种可以启动具有 LAN 连接和 PXE 兼容 **网络接口控制器**（**NIC**）的设备的方法。
- en: 'As shown in the following diagram, PXE uses the DHCP and TFTP protocols to
    complete the boot process. In the simplest environment, a PXE server is set up
    as both a DHCP and TFTP server. The NIC client obtains the IP address from the
    DHCP server and uses the TFTP protocol to get the kernel and ramdisk images to
    start the boot process:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图中所示，PXE 使用 DHCP 和 TFTP 协议来完成引导过程。在最简单的环境中，PXE 服务器被设置为 DHCP 和 TFTP 服务器。NIC
    客户端从 DHCP 服务器获取 IP 地址，并使用 TFTP 协议获取内核和 ramdisk 映像以启动引导过程：
- en: '![](img/image_09_001.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_09_001.png)'
- en: PXE boot environment
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: PXE 引导环境
- en: In this section, we will learn how to prepare a PXE-capable ROM for a VirtualBox
    virtio network adapter so that we can use this ROM and boot the system via PXE.
    We will also learn how to set up a PXE server, which is the key element in the
    PXE setup. In VirtualBox, it includes a built-in PXE server. We will use this
    built-in PXE server to boot the Android system.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何为 VirtualBox virtio 网络适配器准备一个 PXE 兼容的 ROM，以便我们可以使用这个 ROM 通过 PXE
    引导系统。我们还将学习如何设置 PXE 服务器，这是 PXE 设置中的关键元素。在 VirtualBox 中，它包括一个内置的 PXE 服务器。我们将使用这个内置的
    PXE 服务器来引导 Android 系统。
- en: Preparing PXE Boot ROM
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备 PXE 引导 ROM
- en: 'Even though PXE boot is supported by VirtualBox, the setup is not consistent
    on a different NIC. You may get error messages such as `PXE-E3C - TFTP Error -
    Access Violation` during the boot. This is because PXE boot depends on LAN Boot
    ROM. When you choose different network adapters, you may get different test results.
    To get a consistent test result, you can use the LAN Boot ROM from the Etherboot/gPXE
    project. gPXE is an open source (GPL) network bootloader. It provides a direct
    replacement for proprietary PXE ROMs, with many extra features such as DNS, HTTP,
    iSCSI, and so on. There is a page at the gPXE project website about how to set
    up LAN Boot ROM for VirtualBox:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管VirtualBox支持PXE引导，但不同网络适配器上的设置并不一致。在引导过程中，您可能会收到诸如`PXE-E3C - TFTP错误 - 访问违规`之类的错误消息。这是因为PXE引导依赖于LAN引导ROM。当您选择不同的网络适配器时，您可能会得到不同的测试结果。为了获得一致的测试结果，您可以使用来自Etherboot/gPXE项目的LAN引导ROM。gPXE是一个开源（GPL）网络引导程序。它提供了对专有PXE
    ROM的直接替换，具有许多额外功能，如DNS、HTTP、iSCSI等。在gPXE项目网站上有一个页面，介绍了如何为VirtualBox设置LAN引导ROM：
- en: '[http://www.etherboot.org/wiki/romburning/vbox](http://www.etherboot.org/wiki/romburning/vbox)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.etherboot.org/wiki/romburning/vbox](http://www.etherboot.org/wiki/romburning/vbox)'
- en: 'The following table lists network adapters supported by VirtualBox:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了VirtualBox支持的网络适配器：
- en: '| **VirtualBox adapters** | **PCI vendor ID** | **PCI device ID** | **Mfr name**
    | **Device name** |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| **VirtualBox适配器** | **PCI厂商ID** | **PCI设备ID** | **制造商名称** | **设备名称** |'
- en: '| Am79C970A | 1022h | 2000h | AMD | PCnet-PCI II (AM79C970A) |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| Am79C970A | 1022h | 2000h | AMD | PCnet-PCI II (AM79C970A) |'
- en: '| Am79C973 | 1022h | 2000h | AMD | PCnet-PCI III (AM79C973) |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| Am79C973 | 1022h | 2000h | AMD | PCnet-PCI III (AM79C973) |'
- en: '| 82540EM | 8086h | 100Eh | Intel | Intel PRO/1000 MT Desktop (82540EM) |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 82540EM | 8086h | 100Eh | Intel | Intel PRO/1000 MT Desktop (82540EM) |'
- en: '| 82543GC | 8086h | 1004h | Intel | Intel PRO/1000 T Server (82543GC) |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 82543GC | 8086h | 1004h | Intel | Intel PRO/1000 T Server (82543GC) |'
- en: '| 82545EM | 8086h | 100Fh | Intel | Intel PRO/1000 MT Server (82545EM) |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 82545EM | 8086h | 100Fh | Intel | Intel PRO/1000 MT Server (82545EM) |'
- en: '| virtio | 1AF4h | 1000h |  | Paravirtualized Network (virtio-net) |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| virtio | 1AF4h | 1000h |  | 虚拟化网络（virtio-net） |'
- en: Since paravirtualized networks have better performance in most situations, we
    will explore how to support PXE boot using the virtio-net network adapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在大多数情况下虚拟化网络具有更好的性能，我们将探讨如何使用virtio-net网络适配器支持PXE引导。
- en: Downloading and building the LAN Boot ROM
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载和构建LAN引导ROM
- en: There may be LAN Boot ROM binary images available on the Internet, but they
    are not provided at the gPXE project. We have to build from source code according
    to the instructions from the gPXE project website.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 网络上可能有可用的LAN引导ROM二进制镜像，但它们在gPXE项目中并未提供。我们必须根据gPXE项目网站上的说明从源代码构建。
- en: 'Let''s download and build the source code using the following commands:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下命令下载和构建源代码：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Fixing up the ROM image
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复ROM镜像
- en: 'Before the ROM image can be used, the ROM image has to be updated due to VirtualBox
    having the following requirements on ROM image size:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在ROM镜像可以使用之前，由于VirtualBox对ROM镜像大小有以下要求，因此必须更新ROM镜像：
- en: Size must be 4K aligned (that is, a multiple of 4,096)
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大小必须是4K对齐的（即4,096的倍数）
- en: Size must not be greater than 64K
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大小不能超过64K
- en: 'Let''s check the image size first and make sure that it is not larger than
    65,536 bytes (64K):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先检查镜像大小，确保它不超过65,536字节（64K）：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can see that it is less than 64K. Now we have to pad the image file to a
    4K boundary. We can do this using the following commands:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到它小于64K。现在我们必须将镜像文件填充到4K边界。我们可以使用以下命令来完成此操作：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We check the image file size again:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次检查镜像文件大小：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As we can see, the file size is 64K now. To be convenient, I will upload this
    file at the following link and you can download it:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，文件大小现在是64K。为了方便，我将在以下链接上传此文件，您可以下载它：
- en: '[https://sourceforge.net/projects/android-system-programming/files/android-7/ch14/1af41000.rom/download](https://sourceforge.net/projects/android-system-programming/files/android-7/ch14/1af41000.rom/download)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://sourceforge.net/projects/android-system-programming/files/android-7/ch14/1af41000.rom/download](https://sourceforge.net/projects/android-system-programming/files/android-7/ch14/1af41000.rom/download)'
- en: Configuring the virtual machine to use the LAN Boot ROM
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置虚拟机使用LAN引导ROM
- en: The user-based VirtualBox configuration can be stored in the `$HOME/.VirtualBox`
    folder and we need to use this folder for the built-in PXE server.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 基于用户的VirtualBox配置可以存储在`$HOME/.VirtualBox`文件夹中，我们需要使用此文件夹来配置内置的PXE服务器。
- en: 'This folder is not created by default, so we need to create it first:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件夹默认不会创建，因此我们需要首先创建它：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After we create this folder, we can launch VirtualBox and quit. Then, let''s
    look at the content of the `$HOME/.VirtualBox` folder again, as shown in the following
    screenshot:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建这个文件夹后，我们可以启动 VirtualBox 并退出。然后，让我们再次查看 `$HOME/.VirtualBox` 文件夹的内容，如下面的截图所示：
- en: '![](img/image_09_002.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_09_002.png)'
- en: From the preceding screenshot, we can see that the content of this folder is
    empty before we run VirtualBox. After we execute VirtualBox and quit, there are
    a list of files that are created by VirtualBox in this folder.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的截图，我们可以看到在运行 VirtualBox 之前，这个文件夹的内容是空的。在执行 VirtualBox 并退出后，这个文件夹中会创建一系列由
    VirtualBox 生成的文件。
- en: 'Now, we can change the configuration to use the LAN Boot ROM we just created.
    To use this LAN Boot ROM, we can use the `VBoxManage` command to update VirtualBox
    settings. We use the following command to set the `LanBootRom` path:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以更改配置以使用我们刚刚创建的 LAN 启动 ROM。要使用此 LAN 启动 ROM，我们可以使用 `VBoxManage` 命令更新 VirtualBox
    设置。我们使用以下命令设置 `LanBootRom` 路径：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We copied the LAN Boot ROM to `$HOME/.VirtualBox/1af41000.rom`. We use `global`
    here, then all VMs will use the gPXE LAN Boot ROM. We can change `global` to a
    specific virtual machine name. In that case, the gPXE LAN Boot ROM will only be
    used by that virtual machine.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 LAN 启动 ROM 复制到了 `$HOME/.VirtualBox/1af41000.rom`。在这里我们使用 `global`，然后所有虚拟机都将使用
    gPXE LAN 启动 ROM。我们可以将 `global` 改为特定的虚拟机名称。在这种情况下，gPXE LAN 启动 ROM 将仅由该虚拟机使用。
- en: 'Having set up the configuration, let''s look at the `$HOME/.VirtualBox/VirtualBox.xml`
    configuration file:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 设置好配置后，让我们看看 `$HOME/.VirtualBox/VirtualBox.xml` 配置文件：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As we can see, the `VBoxInternal/Deices/pcbios/o/Config/LanBootRom` configuration
    is set in this configuration file.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`VBoxInternal/Deices/pcbios/o/Config/LanBootRom` 配置设置在这个配置文件中。
- en: 'To remove the preceding configuration, we just have to reset the path value
    as follows. The `$VM_NAME` argument can be `global` or a virtual machine name:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除前面的配置，我们只需将路径值重置如下。`$VM_NAME` 参数可以是 `global` 或虚拟机名称：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can also check the current configuration using the following command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用以下命令检查当前配置：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Setting up the PXE boot environment
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 PXE 启动环境
- en: 'With a proper PXE ROM installed, we can set up the PXE server now. Before we
    set up a PXE server, we need to think about the network connections. There are
    three ways a virtual machine in VirtualBox can connect to the network:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了适当的 PXE ROM 之后，我们现在可以设置 PXE 服务器了。在我们设置 PXE 服务器之前，我们需要考虑网络连接。在 VirtualBox
    中，虚拟机可以通过三种方式连接到网络：
- en: '**Bridged network**: This connects to the same physical network as the host.
    It looks like the virtual machine connects to the same LAN connection as the host.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**桥接网络**：这连接到与主机相同的物理网络。看起来虚拟机连接到与主机相同的 LAN 连接。'
- en: '**Host-only network**: This connects to a virtual network that is only visible
    by the virtual machine and the host. In this configuration, the virtual machine
    cannot connect to an outside network, such as the Internet.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仅主机网络**：这连接到仅由虚拟机和主机可见的虚拟网络。在这个配置中，虚拟机无法连接到外部网络，例如互联网。'
- en: '**NAT network**: This one connects to the host network through NAT. This is
    the most common choice. In this configuration, the virtual machine can access
    the external network, but the external network cannot connect to the virtual machine
    directly. For example, if you set up a FTP service on the virtual machine, the
    computers on the LAN of the host cannot access this FTP service. If you want to
    publish this service, you have to use port forwarding settings to do this.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NAT 网络**：这个连接通过 NAT 连接到主机网络。这是最常见的选项。在这个配置中，虚拟机可以访问外部网络，但外部网络无法直接连接到虚拟机。例如，如果您在虚拟机上设置
    FTP 服务，主机局域网中的计算机无法访问此 FTP 服务。如果您想发布此服务，您必须使用端口转发设置来完成此操作。'
- en: With these concepts in mind, if you want to use a dedicated machine as the PXE
    server, you can use a bridged network in your environment. However, you must be
    very careful using this setup. This is usually done by the IT group in your organization,
    since you cannot set up a DHCP server on the LAN without affecting others. We
    won't use this option here.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解了这些概念之后，如果您想使用专用机器作为 PXE 服务器，您可以在环境中使用桥接网络。但是，您必须非常小心使用这种设置。这通常由您组织的 IT 部门完成，因为您不能在局域网中设置
    DHCP 服务器而不影响其他人。我们这里不会使用这个选项。
- en: The host-only network is actually a good choice for this case, because this
    kind of network is an isolated network configuration. The network connection only
    exists between the host and the virtual machine. It is possible to use the host-only
    network to set up the PXE server, but we won't use this option in our setup.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 仅主机网络实际上是这种情况下的一个好选择，因为这种网络是一种隔离的网络配置。网络连接仅存在于主机和虚拟机之间。可以使用仅主机网络来设置 PXE 服务器，但我们在设置中不会使用此选项。
- en: In VirtualBox, PXE booting in the NAT network is supported. With this option,
    we don't need to set up a separate PXE server by ourselves. We will use this built-in
    PXE server in this book. The test environment from this chapter to [Chapter 14](15628e05-2216-4855-8347-588f61c8f61a.xhtml),
    *Customizing and Debugging Recovery* will use this setup.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在 VirtualBox 中，NAT 网络支持 PXE 启动。使用此选项，我们不需要自己设置单独的 PXE 服务器。本书中将使用此内置 PXE 服务器。从本章到第
    14 章 [自定义和调试恢复](15628e05-2216-4855-8347-588f61c8f61a.xhtml) 的测试环境将使用此设置。
- en: Configuring and testing the PXE boot
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置和测试 PXE 启动
- en: We can create a virtual machine instance to test the environment. We will demonstrate
    this in the Ubuntu 14.04 environment. The same setup can be duplicated to the
    Windows or OS X environment as well.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个虚拟机实例来测试环境。我们将以 Ubuntu 14.04 环境为例进行演示。相同的设置也可以复制到 Windows 或 OS X 环境。
- en: Setting up the virtual machine
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置虚拟机
- en: 'Let''s create a virtual machine called pxeAndroid in VirtualBox first. After
    starting the VirtualBox, we can click the New button to create a new virtual machine,
    as shown in the following screenshot:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 VirtualBox 中首先创建一个名为 pxeAndroid 的虚拟机。启动 VirtualBox 后，我们可以点击新建按钮来创建一个新的虚拟机，如下面的截图所示：
- en: '![](img/image_09_003.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_09_003.png)'
- en: We call it pxeAndroid and choose Linux as the type of virtual machine. We can
    just follow the wizard to create this virtual machine with a suitable configuration.
    After the virtual machine is created, we need to make a few changes to the settings.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称之为 pxeAndroid，并选择 Linux 作为虚拟机的类型。我们可以直接按照向导创建具有合适配置的虚拟机。虚拟机创建完成后，我们需要对设置进行一些修改。
- en: 'The first thing that needs to be changed is the network configuration. We need
    to set the network adapter as a NAT network. We can click the name of the virtual
    machine, pxeAndroid, first and then click on the Settings button to change the
    settings. Select the Network option on the left-hand side, as we can see in the
    following screenshot:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 需要更改的第一件事是网络配置。我们需要将网络适配器设置为 NAT 网络。我们可以先点击虚拟机的名称，pxeAndroid，然后点击设置按钮来更改设置。在左侧选择“网络”选项，如下面的截图所示：
- en: '![](img/image_09_004.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_09_004.png)'
- en: 'We select Adapter 1, the default for the NAT network. We need to change the
    Adapter Type to Paravirtualized Network (virtio-net) since we will use the PXE
    ROM that we just built. The NAT network can connect to the outside network. It
    supports port forwarding so that we can access certain services in the virtual
    machine. The one that we need to set up here is the ADB service. We need to use
    ADB to debug the x86vbox device later. We can set up the port forwarding for ADB
    as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择适配器 1，NAT 网络的默认适配器。由于我们将使用我们刚刚构建的 PXE ROM，我们需要将适配器类型更改为虚拟化网络（virtio-net）。NAT
    网络可以连接到外部网络。它支持端口转发，这样我们就可以访问虚拟机中的某些服务。我们需要设置的是 ADB 服务。我们需要使用 ADB 来调试 x86vbox
    设备。我们可以按照以下方式设置 ADB 的端口转发：
- en: '![](img/image_09_005.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_09_005.png)'
- en: 'Next, we can click on the System option to specify that the default boot order
    is to boot from the network interface, as shown in the following screenshot:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以点击“系统”选项来指定默认的启动顺序是从网络接口启动，如下面的截图所示：
- en: '![](img/image_09_006.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_09_006.png)'
- en: Using VirtualBox internal PXE booting with NAT
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 VirtualBox 内部 PXE 启动与 NAT
- en: 'Once we set up the virtual machine, we can use the built-in PXE server of VirtualBox
    for PXE boot using the NAT network. To use the built-in PXE server, we need to
    set it up using the following steps:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置了虚拟机，我们就可以使用 VirtualBox 内置的 PXE 服务器通过 NAT 网络进行 PXE 启动。要使用内置 PXE 服务器，我们需要按照以下步骤进行设置：
- en: Create a `$HOME/.VirtualBox/TFTP` folder. The built-in `TFTP` root is at `$HOME/.VirtualBox/TFTP`
    on Linux or `%USERPROFILE%\.VirtualBox\TFTP` on Windows.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `$HOME/.VirtualBox/TFTP` 文件夹。Linux 上的内置 `TFTP` 根目录位于 `$HOME/.VirtualBox/TFTP`，Windows
    上的 `%USERPROFILE%\.VirtualBox\TFTP`。
- en: Usually, the default boot image name is `pxelinux.0` for PXE boot, but it is
    `vmname.pxe` for the VirtualBox built-in PXE. For example, if we use `pxeAndroid`
    as the virtual machine name, we have to make a copy of `pxelinux.0` and name it
    `pxeAndroid.pxe` under the `TFTP` root folder.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常，对于PXE引导，默认引导映像名称是`pxelinux.0`，但对于VirtualBox内置的PXE，它是`vmname.pxe`。例如，如果我们使用`pxeAndroid`作为虚拟机名称，我们必须在`TFTP`根目录下复制`pxelinux.0`并将其命名为`pxeAndroid.pxe`。
- en: Configuring pxelinux.cfg
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置pxelinux.cfg
- en: Before we can test the virtual machine that we just set up, we need to specify
    it in the configuration file to let the PXE boot know where to find the kernel
    and ramdisk images.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够测试刚刚设置的虚拟机之前，我们需要在配置文件中指定它，以便让PXE引导知道在哪里找到内核和ramdisk映像。
- en: 'The PXE boot process is something like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: PXE引导过程大致如下：
- en: When the pxeAndroid virtual machine powers on, the client will get the IP address
    through DHCP.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当pxeAndroid虚拟机开机时，客户端将通过DHCP获取IP地址。
- en: After the DHCP configuration is found, the configuration includes the standard
    information such as IP address, subnet mask, gateway and DNS, and so on. In addition,
    it also provides the location of the TFTP server and the filename of a boot image.
    The name of the boot image is usually `pxelinux.0`. The name of the boot image
    is `vmname.pxe` for the built-in PXE boot environment where the `vmname` should
    be the name of virtual machine. For example, it is `pxeAndroid.pxe` for our virtual
    machine.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到DHCP配置后，配置包括标准信息，如IP地址、子网掩码、网关和DNS等。此外，它还提供了TFTP服务器的位置和引导映像的文件名。引导映像的名称通常是`pxelinux.0`。对于内置PXE引导环境，引导映像的名称是`vmname.pxe`，其中`vmname`应该是虚拟机的名称。例如，对于我们的虚拟机，它是`pxeAndroid.pxe`。
- en: The client contacts the TFTP server to obtain the boot image. The boot image
    should be put under `TFTP` root, which is `$HOME/.VirtualBox/TFTP` in our case.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端联系TFTP服务器以获取引导映像。引导映像应放在`TFTP`根目录下，在我们的例子中是`$HOME/.VirtualBox/TFTP`。
- en: The TFTP server sends the boot image (`pxelinux.0` or `vmname.pxe`), and the
    client executes it.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TFTP服务器发送引导映像（`pxelinux.0`或`vmname.pxe`），客户端执行它。
- en: By default, the boot image searches the `pxelinux.cfg` directory on the TFTP
    server for boot configuration files.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，引导映像在TFTP服务器上的`pxelinux.cfg`目录中搜索引导配置文件。
- en: The client downloads all the files it needs (kernel, ramdisk, root filesystem,
    and so on) and then loads them.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端下载它需要的所有文件（内核、ramdisk、根文件系统等），然后加载它们。
- en: The `pxeAndroid` target machine reboots.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pxeAndroid`目标机器重新启动。'
- en: 'In step 5, the boot image searches the boot configuration files in the following
    steps:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5步中，引导映像按照以下步骤搜索引导配置文件：
- en: First, it searches for the boot configuration file that is named according to
    the MAC address represented in lower case hexadecimal digits with dash separators.
    For example, for the MAC address 08:00:27:90:99:7B, it searches for the file `08-00-27-90-99-7b`.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它搜索根据表示为带短划线分隔的小写十六进制数字的MAC地址命名的引导配置文件。例如，对于MAC地址08:00:27:90:99:7B，它搜索文件`08-00-27-90-99-7b`。
- en: Then, it searches for the configuration file using the IP address (of the machine
    that is being booted) in upper-case hexadecimal digits. For example, for the IP
    address 192.168.56.100, it searches for the `C0A83864` file.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它使用大写十六进制数字中的机器（正在引导的机器）的IP地址来搜索配置文件。例如，对于IP地址192.168.56.100，它搜索`C0A83864`文件。
- en: If that file is not found, it removes one hexadecimal digit from the end and
    tries again. However, if the search is still not successful, it finally looks
    for a file named `default` (in lower case).
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果找不到该文件，它将从末尾删除一个十六进制数字并再次尝试。然而，如果搜索仍然不成功，它最终会寻找一个名为`default`（小写）的文件。
- en: 'For example, if the boot filename is `$HOME/.VirtualBox/TFTP/pxeAndroid.pxe`,
    the Ethernet MAC address is 08:00:27:90:99:7B, and the IP address is 192.168.56.100,
    the boot image looks for filenames in the following order:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果引导文件名为`$HOME/.VirtualBox/TFTP/pxeAndroid.pxe`，以太网MAC地址为08:00:27:90:99:7B，IP地址为192.168.56.100，引导映像将按照以下顺序搜索文件名：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `pxelinux.0` boot image is part of an open source project the Syslinux.
    We can get the boot image and the menu user interface from the Syslinux project
    using the following command:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`pxelinux.0`引导映像是Syslinux开源项目的一部分。我们可以使用以下命令从Syslinux项目获取引导映像和菜单用户界面：'
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After Syslinux is installed, `pxelinux.0` can be copied to the `TFTP` root
    folder as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Syslinux后，`pxelinux.0`可以按照以下方式复制到`TFTP`根目录：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To have a better user interface, we can copy `menu.c32` to the `TFTP` folder
    as well:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有一个更好的用户界面，我们还可以将`menu.c32`复制到`TFTP`文件夹中：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: pxelinux.cfg/default
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pxelinux.cfg/default
- en: 'Now, we will look at how to configure the boot configuration file `$HOME/.VirtualBox/TFTP/pxelinux.cfg/default`.
    In our setup, it looks like the following code snippet:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将查看如何配置启动配置文件`$HOME/.VirtualBox/TFTP/pxelinux.cfg/default`。在我们的设置中，它看起来像以下代码片段：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding file can be download from [https://github.com/shugaoye/asp-sample/blob/master/ch09/pxelinux.cfg/default](https://github.com/shugaoye/asp-sample/blob/master/ch09/pxelinux.cfg/default).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的文件可以从[https://github.com/shugaoye/asp-sample/blob/master/ch09/pxelinux.cfg/default](https://github.com/shugaoye/asp-sample/blob/master/ch09/pxelinux.cfg/default)下载。
- en: You can copy it from the above mentioned GitHub URL and you need to change the
    NFS shared folder to your own `ROOT=10.0.2.2:/{your NFS shared folder}`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从上述GitHub URL复制它，并且需要将NFS共享文件夹更改为您自己的`ROOT=10.0.2.2:/{您的NFS共享文件夹}`。
- en: 'The syntax in the boot configuration file can be found at the following URL
    from the Syslinux project:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 启动配置文件中的语法可以在Syslinux项目的以下URL中找到：
- en: '[http://www.syslinux.org/wiki/index.php?title=SYSLINUX](http://www.syslinux.org/wiki/index.php?title=SYSLINUX)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.syslinux.org/wiki/index.php?title=SYSLINUX](http://www.syslinux.org/wiki/index.php?title=SYSLINUX)'
- en: 'In the preceding configuration file that we use in this chapter, we can see
    the following commands and options:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中我们使用的配置文件中，我们可以看到以下命令和选项：
- en: '`prompt`: It will let the bootloader know if it will show a LILO-style *boot:*
    prompt. With this command-line prompt, you can input the option directly. All
    the boot options are defined by the command `label`.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prompt`：它将让引导加载程序知道是否会显示LILO风格的*boot:*提示。使用此命令行提示，您可以直接输入选项。所有启动选项都由`label`命令定义。'
- en: '`default`: It defines the default boot option.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default`：定义默认启动选项。'
- en: '`timeout`: If more than one `label` entry is available, this directive indicates
    how long to pause at the boot: prompt until booting automatically, in units of
    1/10 s. The timeout is cancelled when any key is pressed, the assumption being
    that the user will complete the command line. A timeout of zero will disable the
    timeout completely. The default is 0.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timeout`：如果有多个`label`条目可用，此指令表示在启动提示符处暂停多长时间直到自动启动，单位为1/10秒。按下任何键时取消超时，假设用户将完成命令行。超时设置为0将完全禁用超时。默认值为0。'
- en: '`label`: A human-readable string that describes a kernel and options. The default
    label is `linux`, but you can change this with the `DEFAULT` keyword.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`label`：一个描述内核和选项的易读字符串。默认标签是`linux`，但您可以使用`DEFAULT`关键字更改它。'
- en: '`kernel`: The kernel file that the boot image will boot.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kernel`：引导映像将启动的内核文件。'
- en: '`append`: The kernel command line that can be passed to the kernel during the
    boot.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`append`：在引导过程中可以传递给内核的内核命令行。'
- en: In the preceding configuration file, we show two boot options. In the first
    option, we can boot to a minimum Linux environment using the NFS root filesystem.
    We can install the x86vbox images from that environment to the hard disk. In the
    second option, we can boot x86vbox from the `/dev/sda1` disk partition. We will
    explore these options in detail later.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的配置文件中，我们展示了两个启动选项。在第一个选项中，我们可以使用NFS根文件系统启动到最小Linux环境。我们可以从该环境安装x86vbox镜像到硬盘。在第二个选项中，我们可以从`/dev/sda1`磁盘分区启动x86vbox。我们将在稍后详细探讨这些选项。
- en: Setting up a serial port for debugging
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置调试用的串行端口
- en: The reason why we want to boot Android using PXE and NFS is because we want
    to use a very simple bootloader and find an easier way to debug the system. In
    order to see the debug log, we want to redirect the debug output from the video
    console to a serial port so that we can separate the graphic user interface from
    the debug output. We need to do two things in order to meet our goals.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要使用PXE和NFS启动Android的原因是因为我们想要使用一个非常简单的引导加载程序，并找到一种更容易调试系统的方法。为了查看调试日志，我们想要将视频控制台的调试输出重定向到串行端口，以便我们可以将图形用户界面与调试输出分开。为了达到我们的目标，我们需要做两件事。
- en: 'The Linux kernel debug message can be redirected to a specific channel using
    kernel command-line arguments. We specify this in PXE boot configuration with
    the `console=ttyS3,115200` option. This is defined in `pxelinux.cfg/default` as
    follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核调试消息可以通过内核命令行参数重定向到特定通道。我们在PXE引导配置中使用`console=ttyS3,115200`选项指定此选项。这在`pxelinux.cfg/default`中定义如下：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We will explain the details about kernel parameters in the `append` option
    later in this chapter. The next thing is that we need to create a virtual serial
    port that we can connect to. We configure this in the virtual machine settings
    page, as shown in the following screenshot:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面解释 `append` 选项中关于内核参数的详细信息。接下来，我们需要创建一个可以连接到的虚拟串行端口。我们可以在虚拟机设置页面中配置此端口，如图所示：
- en: '![](img/image_09_007.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_09_007.png)'
- en: We use a host pipe to simulate the virtual serial port. We can set the path
    as something like `/tmp/pxeAndroid_p`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用主机管道来模拟虚拟串行端口。我们可以将路径设置为类似 `/tmp/pxeAndroid_p` 的内容。
- en: 'The mapping between `COMx` to `/dev/ttySx` is as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`COMx` 到 `/dev/ttySx` 的映射如下：'
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To connect to the host pipe, we can use a tool such as `minicom`. If you don''t
    have `minicom` installed, you can install and configure `minicom` as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接到主机管道，我们可以使用 `minicom` 这样的工具。如果您还没有安装 `minicom`，可以按照以下步骤安装和配置 `minicom`：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To set up `minicom`, we can use the following command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置 `minicom`，我们可以使用以下命令：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: After `minicom` starts, select Serial port setup, and set Serial Device as unix#/tmp/pxeAndroid_p.
    Once this is done, select Save setup as dfl and Exit from Minicom as shown in
    the following screenshot. Now we can connect to the virtual serial port using
    `minicom`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `minicom` 启动后，选择串行端口设置，并将串行设备设置为 unix#/tmp/pxeAndroid_p。完成此操作后，选择将设置保存为默认并从
    Minicom 中退出，如图所示。现在我们可以使用 `minicom` 连接到虚拟串行端口。
- en: '![](img/image_09_008.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_09_008.png)'
- en: 'After we have made all the changes for the x86vbox configuration, we can power
    on the virtual machine and test it. We should be able to see the following boot
    up screen:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对 x86vbox 配置进行了所有更改后，我们可以开启虚拟机并对其进行测试。我们应该能够看到以下引导屏幕：
- en: '![](img/image_09_009.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_09_009.png)'
- en: We can see from the preceding screenshot that the virtual machine loads the
    `pxelinux.cfg/default` file and waits on the boot prompt. We are ready to boot
    from PXE ROM now.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的屏幕截图我们可以看到，虚拟机加载了 `pxelinux.cfg/default` 文件，并等待引导提示。现在我们可以从 PXE ROM 引导了。
- en: NFS filesystem
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NFS 文件系统
- en: We created the x86vbox device in [Chapter 8](acf2363a-2a0f-40b9-a35f-c8bb0e523737.xhtml),
    *Creating Your Own Device on VirtualBox*, and we were able to build it. However,
    we did not discuss how to boot images. The issue here is the output from the build
    is the standard AOSP images. They are not able to be used by VirtualBox directly.
    For example, `system.img` can be used by the emulator, but not VirtualBox. VirtualBox
    can use standard virtual disk images in VDI, VHD, or VMDK formats, but not a raw
    disk image such as `system.img`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [第 8 章](acf2363a-2a0f-40b9-a35f-c8bb0e523737.xhtml) 中创建了 x86vbox 设备，*在 VirtualBox
    中创建自己的设备*，并且我们能够构建它。然而，我们没有讨论如何引导镜像。这里的问题是构建输出的标准 AOSP 镜像不能直接由 VirtualBox 使用。例如，`system.img`
    可以由模拟器使用，但不能由 VirtualBox 使用。VirtualBox 可以使用标准虚拟磁盘镜像，格式为 VDI、VHD 或 VMDK，但不能使用像
    `system.img` 这样的原始磁盘镜像。
- en: In the Android-x86 build, the output is an installation image, such as ISO or
    USB disk image formats. With an installation image, it can be burnt to a CDROM
    and USB drive. Then, we can boot VirtualBox from CDROM or USB to install the system
    just as we install Windows on our PC. It is quite tedious and not efficient to
    use this method when we are debugging a system. As a developer, we want a simple
    and quick way so that we can start the debugging immediately after we build the
    system.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android-x86 构建中，输出是安装镜像，例如 ISO 或 USB 磁盘镜像格式。使用安装镜像，它可以烧录到 CDROM 和 USB 驱动器上。然后，我们可以从
    CDROM 或 USB 引导 VirtualBox 来安装系统，就像我们在 PC 上安装 Windows 一样。当我们调试系统时，使用这种方法既繁琐又低效。作为开发者，我们希望有一个简单快捷的方法，这样我们就可以在构建系统后立即开始调试。
- en: The method that we will use here is to boot the system using the NFS filesystem.
    The key point is that we will treat the output folder of the AOSP build as the
    root filesystem directly so that we can boot the system using it without any additional
    work.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里将使用的方法是使用 NFS 文件系统来引导系统。关键点是，我们将直接将 AOSP 构建输出的输出文件夹视为根文件系统，这样我们就可以用它来引导系统而无需任何额外的工作。
- en: If you are an embedded system developer, you may have used this method in your
    work already. When we work on the initial debugging phase of an embedded Linux
    system, we often use the NFS filesystem as the root filesystem. With this method,
    we can avoid flashing the images to the flash storage every time after the build.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是嵌入式系统开发者，您可能已经在工作中使用过这种方法。当我们对嵌入式 Linux 系统的初始调试阶段进行工作时，我们经常使用 NFS 文件系统作为根文件系统。使用这种方法，我们可以在每次构建后避免将镜像刷入闪存存储。
- en: Preparing the kernel
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备内核
- en: 'To support NFS boot, we need a Linux kernel with NFS filesystem support. The
    default Linux kernel for Android doesn''t have NFS boot support. In order to boot
    Android and mount the NFS directory as the root filesystem, we have to recompile
    the Linux kernel with the following options enabled:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要支持NFS引导，我们需要一个具有NFS文件系统支持的Linux内核。Android的默认Linux内核没有NFS引导支持。为了引导Android并将NFS目录作为根文件系统挂载，我们必须重新编译Linux内核，并启用以下选项：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can use `menuconfig` to change the kernel configuration or copy a configuration
    file with NFS support.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`menuconfig`来更改内核配置或复制带有NFS支持的配置文件。
- en: 'To configure the kernel build using `menuconfig`, we can use the following
    commands:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`menuconfig`配置内核构建，我们可以使用以下命令：
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can also use the configuration file with NFS enabled in my GitHub. We can
    observe the difference between this configuration file and the default kernel
    configuration file from Android-x86 as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用我在GitHub上启用了NFS的配置文件。我们可以如下观察此配置文件与Android-x86默认内核配置文件的差异：
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can copy this configuration file and use it to build the Linux kernel. The
    following commands just show how to build the kernel separately. You don''t have
    to do this if you build x86vbox by checking out the source code of this chapter.
    This is included in the x86vbox device Makefiles:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以复制此配置文件并使用它来构建Linux内核。以下命令仅显示如何单独构建内核。如果您通过检查本章的源代码构建x86vbox，则无需执行此操作。这包含在x86vbox设备的Makefiles中：
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: After the build, we can copy the kernel and ramdisk files to the `TFTP` root
    at `$HOME/.VirtualBox/TFTP/x86vbox`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 构建完成后，我们可以将内核和ramdisk文件复制到`TFTP`根目录`$HOME/.VirtualBox/TFTP/x86vbox`。
- en: Setting up the NFS server
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置NFS服务器
- en: 'When we have a NFS-capable kernel, we need to set up the NFS server on our
    development host so that we can mount to the NFS folders exported by our NFS server.
    We can check whether the NFS server is already installed or not using the following
    command:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个具有NFS功能的内核时，我们需要在我们的开发主机上设置NFS服务器，以便我们可以挂载NFS服务器导出的NFS文件夹。我们可以使用以下命令检查NFS服务器是否已经安装：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If the NFS server is not installed, we can install it using the following command:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果NFS服务器未安装，我们可以使用以下命令安装它：
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once we have a NFS server ready, we need to export our root filesystem through
    NFS. We will use the AOSP build output folder as we mentioned previously. We can
    add the following line to the `/etc/exports` configuration file:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有一个NFS服务器准备就绪，我们需要通过NFS导出我们的根文件系统。我们将使用之前提到的AOSP构建输出文件夹。我们可以在`/etc/exports`配置文件中添加以下行：
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After that, we execute the following command to export the `$AOSP/out/target/product`
    folder. You need to replace `$AOSP` with the absolute path in your setup:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们执行以下命令来导出`$AOSP/out/target/product`文件夹。您需要用您设置中的绝对路径替换`$AOSP`：
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Configuring the PXE boot menu
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置PXE引导菜单
- en: When we have a real bootloader such as PXE Boot ROM, we have a way to support
    the boot path like a real Android device. As we know, Android devices can boot
    to three different modes--bootloader mode, recovery mode, and the normal start-up.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个真实的引导加载程序，如PXE引导ROM时，我们有一种支持引导路径的方式，就像真正的Android设备一样。正如我们所知，Android设备可以启动到三种不同的模式--引导加载程序模式、恢复模式和正常启动。
- en: With PXE Boot ROM, we can easily support the same and more. By configuring the
    `pxelinux.cfg/default` file, we can allow x86vbox to boot in different paths.
    We will configure multiple boot paths here.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用PXE引导ROM，我们可以轻松支持相同和更多的功能。通过配置`pxelinux.cfg/default`文件，我们可以允许x86vbox在不同的路径上启动。我们将在这里配置多个引导路径。
- en: Booting to NFS installation
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动到NFS安装
- en: Since we cannot use AOSP image files to boot x86vbox directly, we need to install
    AOSP images to the VirtualBox hard disk. This is very similar to Android-x86\.
    In Android-x86, we need to use a CDROM or USB stick to install the system so that
    we can boot Android after the installation. Instead of using a CDROM or USB image
    for the installation, we can install the system from the NFS path directly. If
    we set the NFS path to the `$AOSP/out/target/product` path, we can install the
    system right after the completion of the build.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不能使用AOSP镜像文件直接启动x86vbox，我们需要将AOSP镜像安装到VirtualBox硬盘上。这与Android-x86非常相似。在Android-x86中，我们需要使用CDROM或USB闪存驱动器来安装系统，以便在安装后启动Android。而不是使用安装的CDROM或USB镜像，我们可以直接从NFS路径安装系统。如果我们设置NFS路径为`$AOSP/out/target/product`路径，我们可以在构建完成后立即安装系统。
- en: 'We can boot the system to an installation mode so that we can use the Android-x86
    installation script that we discussed to install x86vbox images to the virtual
    hard disk:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将系统引导到安装模式，这样我们就可以使用我们之前讨论的Android-x86安装脚本将x86vbox镜像安装到虚拟硬盘：
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the preceding configuration, we use the NFS-capable kernel from the `TFTP`
    folder such as `$HOME/.VirtualBox/TFTP/x86vbox/kernel`. The `initrd.img` ramdisk
    image is also stored in the same folder. Both files under the `TFTP` folder can
    actually be symbolic links to the AOSP output. In this case, we don''t have to
    copy them after the build, as we can see from the following screenshot:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配置中，我们使用`TFTP`文件夹中的NFS兼容内核，例如`$HOME/.VirtualBox/TFTP/x86vbox/kernel`。`initrd.img`
    ramdisk镜像也存储在同一个文件夹中。`TFTP`文件夹下的这两个文件实际上可以是指向AOSP输出的符号链接。在这种情况下，我们不需要在构建后复制它们，如下面的截图所示：
- en: '![](img/image_09_010.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_09_010.png)'
- en: 'We use the following three options to configure the NFS boot:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下三种选项来配置NFS引导：
- en: '`ip=dhcp`: Use DHCP to get the IP address from the DHCP server. The DHCP server
    can be the built-in DHCP server of VirtualBox or an external DHCP server.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ip=dhcp`：使用DHCP从DHCP服务器获取IP地址。DHCP服务器可以是VirtualBox的内置DHCP服务器或外部DHCP服务器。'
- en: '`root=/dev/nfs`: Use the NFS boot.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`root=/dev/nfs`：使用NFS引导。'
- en: '`ROOT=10.0.2.2:$AOSP/out/target/product`: The root is the AOSP output folder
    in the development host. If we use the built-in PXE, the IP address `10.0.2.2`
    is the default host IP address in the NAT network. It could be changed using the
    VirtualBox configuration. In your configuration, you need to replace `$AOSP` with
    an absolute path.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ROOT=10.0.2.2:$AOSP/out/target/product`：根是开发主机上的AOSP输出文件夹。如果我们使用内置PXE，IP地址`10.0.2.2`是NAT网络中的默认主机IP地址。它可以通过VirtualBox配置进行更改。在你的配置中，你需要将`$AOSP`替换为一个绝对路径。'
- en: We want to monitor the debug output so we set the console to the virtual serial
    port that we configured previously as `console=ttyS3,115200`. We can use a host
    pipe to connect to it using `minicom`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想监控调试输出，因此将控制台设置为之前配置的虚拟串行端口`console=ttyS3,115200`。我们可以使用`minicom`通过主机管道连接到它。
- en: 'We set three kernel parameters by using the Android-x86 init script and installation
    script:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用Android-x86 init脚本和安装脚本设置了三个内核参数：
- en: '`INSTALL=1`: Tells the init script that we want to install the system'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INSTALL=1`：告诉init脚本我们想要安装系统'
- en: '`DEBUG=2`: This will bring us to the debug console during the boot process'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DEBUG=2`：这将使我们能够在引导过程中进入调试控制台'
- en: '`SRC=/x86vbox` : This is the directory for the root filesystem'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SRC=/x86vbox`：这是根文件系统的目录'
- en: Finally, the `androidboot.hardware=x86vbox` option is passed to the Android
    init process to tell it which init script to run. In this case, the device init
    script `init.x86vbox.rc` will be executed as we discussed in the previous chapter.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`androidboot.hardware=x86vbox`选项被传递给Android init进程，以告诉它运行哪个init脚本。在这种情况下，设备init脚本`init.x86vbox.rc`将按照我们在上一章中讨论的方式执行。
- en: In our PXE boot menu, we can add another configuration for the installation
    without the `console=ttyS3,115200` option. In this case, all debug output will
    print on the screen, which is the default standard output.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的PXE引导菜单中，我们可以添加另一个配置，以便在没有`console=ttyS3,115200`选项的情况下进行安装。在这种情况下，所有调试输出将打印到屏幕上，这是默认的标准输出。
- en: To find out what is installed on the harddisk, you can refer to [Chapter 6](b6a6462f-1c3d-46fd-89e9-a543423c576d.xhtml),
    *Debugging the Boot Up Process Using a Customized ramdisk*. The filesystem layout
    on the hard disk is similar to the directory layout for `x86emu_x86.img`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出硬盘上安装了什么，你可以参考[第6章](b6a6462f-1c3d-46fd-89e9-a543423c576d.xhtml)，*使用自定义ramdisk调试引导过程*。硬盘上的文件系统布局与`x86emu_x86.img`的目录布局相似。
- en: Booting from a hard disk
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从硬盘引导
- en: 'We can have another option, as follows,to boot the system from the hard disk
    after we install the system using the previous configuration:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用之前的配置安装系统后，我们可以选择另一个选项，如下所示，从硬盘引导系统：
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding configuration, we use the `/dev/sda1` device as the root and
    we don't have the `INSTALL=1` option. With this configuration, the virtual machine
    will boot to the Android system from the hard disk `/dev/sda1` and the debug output
    will print to the virtual serial port.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配置中，我们使用`/dev/sda1`设备作为根，并且没有`INSTALL=1`选项。使用此配置，虚拟机将从硬盘`/dev/sda1`引导到Android系统，并且调试输出将打印到虚拟串行端口。
- en: We can use another similar configuration that prints the debug output to the
    screen.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用另一个类似的配置，将调试输出打印到屏幕。
- en: Booting to recovery
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进入恢复模式
- en: 'With the PXE boot menu, we can configure the system to boot to recovery as
    well. We can use the following configuration:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用PXE引导菜单，我们还可以配置系统引导到恢复。我们可以使用以下配置：
- en: '[PRE28]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We will use a configuration similar to this in [Chapter 12](5eff5635-ac58-4b48-80d4-b7e69b464d8e.xhtml),
    *Introducing Recovery* to [Chapter 14](15628e05-2216-4855-8347-588f61c8f61a.xhtml),
    *Customizing and Debugging Recovery*, when we explore recovery programming. The
    difference here is that we use a recovery ramdisk instead of `initrd.img`. Since
    recovery is a self-contained environment, we can set the `ROOT` variable to other
    partitions as well.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们探索恢复编程时，我们将在[第12章](5eff5635-ac58-4b48-80d4-b7e69b464d8e.xhtml)“介绍恢复”到[第14章](15628e05-2216-4855-8347-588f61c8f61a.xhtml)“定制和调试恢复”中使用与此类似的配置。这里的区别在于我们使用恢复ramdisk而不是`initrd.img`。由于恢复是一个自包含的环境，我们还可以将`ROOT`变量设置为其他分区。
- en: Be aware that the `x86vbox recovery` configuration cannot be tested in this
    chapter. We will test this in [Chapter 12](5eff5635-ac58-4b48-80d4-b7e69b464d8e.xhtml),
    *Introducing Recovery* to [Chapter 14](15628e05-2216-4855-8347-588f61c8f61a.xhtml),
    *Customizing and Debugging Recovery*.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`x86vbox recovery`配置在本章中无法进行测试。我们将在[第12章](5eff5635-ac58-4b48-80d4-b7e69b464d8e.xhtml)“介绍恢复”到[第14章](15628e05-2216-4855-8347-588f61c8f61a.xhtml)“定制和调试恢复”中测试此配置。
- en: 'With all the preceding setup, we can boot to the PXE boot menu, as shown in
    the following screenshot:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成所有前面的设置后，我们可以启动到PXE引导菜单，如下面的截图所示：
- en: '![](img/image_09_011.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_09_011.png)'
- en: 'We can select the first option from the preceding PXE boot menu to boot to
    a debug console as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从前面的PXE引导菜单中选择第一个选项来引导到调试控制台，如下所示：
- en: '![](img/image_09_012.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_09_012.png)'
- en: From the preceding debug output, we can see that the virtual machine obtains
    the IP address `10.0.2.15` from DHCP server `10.0.2.2`. The NFS root is found
    at IP address `10.0.2.2`, which is the development host. In the default VirtualBox
    NAT network setup, the IP address of the DHCP server or the host is `10.0.2.2`.
    The IP address of the built-in TFTP server is `10.0.2.4`. The DNS server IP address
    is `10.0.2.3`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的调试输出中，我们可以看到虚拟机从DHCP服务器`10.0.2.2`获得了IP地址`10.0.2.15`。NFS根文件系统位于IP地址`10.0.2.2`，即开发主机。在默认的VirtualBox
    NAT网络设置中，DHCP服务器或主机的IP地址为`10.0.2.2`。内置TFTP服务器的IP地址为`10.0.2.4`。DNS服务器IP地址为`10.0.2.3`。
- en: 'It is possible to boot the Android system from the `$OUT/system` directory
    using the NFS filesystem. However, we need to make changes to `netd` to disable
    flushing the routing rules. The changes can be done in the following file in the
    `flushRules` function:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用NFS文件系统从`$OUT/system`目录启动Android系统是可能的。然而，我们需要对`netd`进行修改以禁用刷新路由规则。这些修改可以在以下文件中的`flushRules`函数中完成：
- en: '`$AOSP/system/netd/server/RouteController.cpp`'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`$AOSP/system/netd/server/RouteController.cpp`'
- en: Without this change, the network connection will be reset after the routing
    rules are flushed. However, we can still use NFS boot to perform the first stage-boot
    or install the system to hard disk.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不进行此更改，则在刷新路由规则后，网络连接将被重置。然而，我们仍然可以使用NFS引导执行第一阶段引导或安装系统到硬盘。
- en: Summary
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learnt a debugging method using a combination of PXE boot
    and the NFS root filesystem. This is a common practice in the embedded Linux development
    world. We try to use a similar setup for Android system development. As we can
    see, this setup can make the development and debugging process more efficient.
    We can use this setup to remove the bootloader dependency. We can also reduce
    the time to flash or provision build images to the device.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了一种使用PXE引导和NFS根文件系统的组合进行调试的方法。这在嵌入式Linux开发领域是一种常见做法。我们尝试为Android系统开发使用类似的设置。正如我们所看到的，这种设置可以使开发和调试过程更加高效。我们可以使用这个设置来移除引导加载程序的依赖。我们还可以减少将构建镜像刷入或配置到设备上的时间。
- en: 'I wrote an article to discuss a more advanced case about the PXE/NFS setup
    using an external DHCP/TFTP server running in the host-only network environment.
    If you are interested in this topic, you can read it at the following URL:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我写了一篇文章来讨论使用在主机-only网络环境中运行的外部DHCP/TFTP服务器进行PXE/NFS设置的更高级案例。如果您对这个主题感兴趣，您可以在以下URL中阅读它：
- en: '[https://www.packtpub.com/books/content/booting-android-system-using-pxenfs](https://www.packtpub.com/books/content/booting-android-system-using-pxenfs)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/books/content/booting-android-system-using-pxenfs](https://www.packtpub.com/books/content/booting-android-system-using-pxenfs)'
- en: In the next chapter, we will continue our journey on the boot up process of
    x86vbox. We will explore and learn how to enable the graphic system on VirtualBox
    so that we can bring up the Android system eventually for the x86vbox device.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续我们的旅程，探讨x86vbox的启动过程。我们将探索和学习如何启用VirtualBox上的图形系统，以便最终为x86vbox设备启动Android系统。
