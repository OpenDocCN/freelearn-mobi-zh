- en: Chapter 3. Animations and Texture
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章。动画和纹理
- en: In [Chapter 2](part0018_split_000.html#page "Chapter 2. SpriteKit"), *SpriteKit*,
    you learned about the basic structure of SpriteKit and its building blocks such
    as scenes, nodes, sprites, and so on. We got a flying spaceship in the sky by
    touching the screen, and now in this chapter we will be moving to a fully featured
    game play for the user.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 2 章](part0018_split_000.html#page "Chapter 2. SpriteKit") 中，你学习了 SpriteKit
    的基本结构和其构建块，如场景、节点、精灵等。我们通过触摸屏幕在空中获得了一个飞行的飞船，现在在本章中，我们将转向为用户提供完整游戏体验。
- en: You will learn about how the content of sprites are changed using animations,
    how textures (which store sprite data) are used to render the sprites, how to
    create a large image for all game assets using the texture atlas, some character
    (spaceship) animations, and last but the most beautiful will be creating a parallax
    background for the game full of animations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你将了解如何使用动画改变精灵的内容，如何使用纹理（存储精灵数据）来渲染精灵，如何使用纹理图集创建一个包含所有游戏资产的大图像，一些角色（飞船）动画，最后但同样重要的是，为充满动画的游戏创建一个视差背景。
- en: 'In this chapter, we will be focusing on the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将关注以下食谱：
- en: Animating your textures
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画化你的纹理
- en: Creating a texture atlas
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建纹理图集
- en: Adding animations using a texture atlas
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用纹理图集添加动画
- en: Collision detection
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞检测
- en: Parallax background
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视差背景
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Adding animations into our games using SpriteKit is an easy task, as we did
    in the previous chapter, where we added some `SKAction` functions to get the spaceship
    to move. These were the animations related to their movement, orientations, and
    somewhat related to their transformations. However, now the animation that we
    are going to talk about is the content change of a sprite. Animations will be
    animating multiple images (that is, frames) of the same sprite multiple times
    per second, giving a feel of being alive for the sprite. This is somewhat similar
    to the way we capture the videos, it's just a sequence of the snapshots per second.
    These types of animations need a lot of images to be accomplished thereby increasing
    the memory size for these textures. The texture is represented by a `SKTexture`
    object created and attached with the sprite. Texture object automatically loads
    the sprite data (called Texture data) whenever it is visible and is used to render
    the sprite in the respective scene. And when the sprite is removed or not visible
    in the scene, it deletes the texture data, and as a result automatic memory management
    is simplified.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SpriteKit 将动画添加到我们的游戏中是一个简单的任务，正如我们在上一章中所做的那样，我们在那里添加了一些 `SKAction` 函数来使飞船移动。这些动画与它们的运动、方向以及某种程度上与它们的变换有关。然而，现在我们要讨论的动画是精灵内容的变化。动画将通过每秒多次动画化同一精灵的多个图像（即，帧），给精灵带来一种活生生的感觉。这有点类似于我们捕捉视频的方式，它只是每秒快照的序列。这类动画需要大量的图像来完成，从而增加了这些纹理的内存大小。纹理由一个
    `SKTexture` 对象表示，该对象与精灵一起创建和附加。纹理对象在可见时自动加载精灵数据（称为纹理数据），并用于在相应场景中渲染精灵。当精灵被移除或在场景中不可见时，它将删除纹理数据，因此自动内存管理得到了简化。
- en: Technically, all of this means that sprites have display frames, which have
    different textures that change by a fixed delay between each frame. And everything
    we are going to do in the starter and solution kit will be continued from where
    we left in the previous chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，所有这些都意味着精灵有显示帧，这些帧有不同的纹理，并且每个帧之间通过固定的延迟来改变。而我们将在入门和解决方案套件中要做的一切都将从我们在上一章中离开的地方继续。
- en: Animating your textures
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画化你的纹理
- en: In this recipe, we will look at how textures are created and attached to sprites.
    We will also do some content change (that is, frame changing animations) with
    the help of textures.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将查看如何创建和附加纹理到精灵。我们还将借助纹理进行一些内容更改（即，帧更改动画）。
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get started with textures to be animated, we should know about scenes, nodes,
    and sprites. As sprites are created with an image and are added on scene, which
    occupies more memory, textures should be a solution to this problem.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用要动画化的纹理，我们应该了解场景、节点和精灵。由于精灵是通过图像创建并添加到场景中的，这会占用更多内存，因此纹理应该是解决这个问题的一个方案。
- en: How to do it...
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Now, as memory management is more optimized with texture, we can start with
    the animations to change the frames of a sprite by a fixed time. For that, we
    will be showing a prop in the environment, which is a coin rotating 360 degrees
    horizontally.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于纹理的内存管理更加优化，我们可以开始通过固定时间改变精灵的帧进行动画。为此，我们将展示一个环境中的道具，这是一个水平旋转360度的硬币。
- en: 'The following are the steps involved to make a coin look like it is rotating
    360 degrees horizontally:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将硬币看起来像水平旋转360度的步骤：
- en: First of all, copy all the images (that is, frames) of the coin as provided
    in the `Project_Resources` folder with the kit. There are total six images of
    coins, each rotated at an angle horizontally.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，复制`Project_Resources`文件夹中提供的所有硬币图像（即帧），这些图像与工具包一起提供。总共有六个硬币图像，每个图像都水平旋转了一定角度。
- en: Add a method to `FSMyScene` called `addCoin` in which we create a sprite for
    the coin with the initial image to be displayed on the sky background using texture
    (`Coin1.png`).
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`FSMyScene`中添加一个名为`addCoin`的方法，在其中我们使用纹理（`Coin1.png`）创建一个硬币精灵，初始图像要显示在天空背景上。
- en: '[PRE0]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To show the coin on the screen, specify its position; as of now, the position
    is set to the center of the screen, and then add it to the `FSMyScene`.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在屏幕上显示硬币，指定其位置；目前，位置设置为屏幕中心，然后将其添加到`FSMyScene`。
- en: '[PRE1]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Similarly, create textures for the remaining frames of the coin to add frame
    animations.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，为硬币的其余帧创建纹理以添加帧动画。
- en: '[PRE2]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Combining all coin textures creates an array of texture.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将所有硬币纹理组合在一起创建一个纹理数组。
- en: '[PRE3]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Create a `SKAction` class for `coinAnimation` using a class method of `SKAction`
    and run the action on the coin sprite added on `FSMyScene`.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`SKAction`类的类方法为`coinAnimation`创建一个`SKAction`类，并在`FSMyScene`上添加的硬币精灵上运行该动作。
- en: '[PRE4]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Adding all these lines of code makes our `addCoin` method:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 添加所有这些代码行使我们的`addCoin`方法：
- en: '![How to do it...](img/00026.jpeg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/00026.jpeg)'
- en: How it works...
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When we create a texture object using `SKTexture`, as we did in the preceding
    section, the texture stores the image (that is, frame) data into it which is further
    forwarded to create a sprite. This helps in memory management, because when the
    sprites are removed, the data associated with them (that is, texture) is also
    removed thereby releasing the memory.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`SKTexture`创建纹理对象，就像我们在前一节中所做的那样，纹理将图像（即帧）数据存储到其中，然后进一步转发以创建精灵。这有助于内存管理，因为当精灵被移除时，与之关联的数据（即纹理）也会被移除，从而释放内存。
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Similarly, the coin is also added using texture in the center of the screen
    with its initial frame, which looks like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，使用纹理在屏幕中心添加硬币，其初始帧看起来像这样：
- en: '![How it works...](img/00027.jpeg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/00027.jpeg)'
- en: Now we will see how animations of frames work using a number of textures. We
    have just created some textures using some coin images, which are visually designed
    in increasing order of horizontal rotation angle. So an array in the same order
    of textures is created.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用多个纹理来了解帧动画是如何工作的。我们刚刚使用一些硬币图像创建了一些纹理，这些纹理在视觉上按水平旋转角度递增的顺序设计。因此，创建了一个与纹理顺序相同的数组。
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Using a class method of `SKAction`, the coin animation textures array is given
    as an input with a frame delay of 0.2 seconds.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`SKAction`类的类方法，将硬币动画纹理数组作为输入，帧延迟为0.2秒。
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding function takes the textures and shows them with a delay of 0.2
    seconds in the order the textures are given.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数接受纹理，并以纹理提供的顺序以0.2秒的延迟显示它们。
- en: 'Hence, the overall `addCoin` method with the animation code written gives a
    feel that a coin has rotated horizontally once in the center of the screen, and
    this is what the scene looks like:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，包含动画代码的整体`addCoin`方法给人一种硬币在屏幕中心水平旋转一周的感觉，这就是场景看起来像这样的原因：
- en: '![How it works...](img/00028.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/00028.jpeg)'
- en: Creating a texture atlas
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建纹理图集
- en: The texture atlas is a way of combining all the app assets (that is, images)
    into one or more larger images to improve the performance of the app so that the
    app can draw multiple images in a single draw call of the scene that is rendered.
    For example, if we have more than one image file to be loaded in the sprite, SpriteKit
    will perform one drawing call for each sprite. However, if we combine all the
    required images in one image file, then SpriteKit can render all the sprites in
    one draw call that uses very less memory to do so. It is recommended to create
    an atlas of all the required images for any game project.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理图集是将所有应用程序资源（即图像）组合成一个或多个较大图像的方法，以提高应用程序的性能，以便应用程序可以在单个渲染场景的绘制调用中绘制多个图像。例如，如果我们有多个图像文件需要加载到精灵中，SpriteKit将为每个精灵执行一次绘制调用。然而，如果我们将所有必需的图像组合到一个图像文件中，那么SpriteKit可以在使用非常少的内存的情况下，在一个绘制调用中渲染所有精灵。建议为任何游戏项目创建所有必需图像的纹理图集。
- en: Xcode has the capability of building texture atlases for your collection of
    images to make it a larger image, thereby improving the performance. While creating
    texture atlases, there should be a balance of too many or very few textures, so
    that the memory load doesn't increase.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode具有为您的图像集合构建纹理图集的能力，使其成为一个更大的图像，从而提高性能。在创建纹理图集时，应保持纹理过多或过少的平衡，以免内存负载增加。
- en: Getting ready
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: To create a texture atlas, we should be aware of what sprites and textures are,
    most importantly how the sprite is created using textures. We will take the *Animating
    your textures* recipe as a reference to start this. In this recipe, we will be
    learning how to create a texture atlas for a collection of images that are coin
    images used for animation and the spaceship.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建纹理图集，我们应该了解精灵和纹理是什么，最重要的是如何使用纹理创建精灵。我们将以*动画你的纹理*食谱为参考开始。在这个食谱中，我们将学习如何为用于动画的硬币图像和太空船创建纹理图集。
- en: How to do it...
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following are the steps to be performed for creating a texture atlas for
    a collection of images:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为图像集合创建纹理图集的步骤：
- en: Create a system folder where your project is stored in the starter project of
    `FlyingSpaceship`.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`FlyingSpaceship`的启动项目中创建一个存储项目的系统文件夹。
- en: Note
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It should not be an Xcode group folder; it has to be a system folder.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它不应是一个Xcode组文件夹；它必须是一个系统文件夹。
- en: In that folder, add all images of coins and the image of the spaceship added
    previously in the app bundle.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在那个文件夹中，添加所有硬币的图像以及之前在应用程序包中添加的太空船图像。
- en: Right-click on the `Resources` folder and click on **Add Files to "FlyingSpaceship"**.![How
    to do it...](img/00029.jpeg)
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击`Resources`文件夹，然后点击**将文件添加到"FloatingSpaceship"**。![如何操作...](img/00029.jpeg)
- en: A finder view is opened. From there, select `FSGame.atlas` and click on the
    **Add** button. Whenever we build the project, the compiler looks for folders
    with a naming convention such as `name.atlas`. Hence, the folders are identified
    and all the images in that folder are combined to form one or more large images.![How
    to do it...](img/00030.jpeg)
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个查找器视图。从那里，选择`FSGame.atlas`并点击**添加**按钮。每次我们构建项目时，编译器都会寻找命名约定为`name.atlas`的文件夹。因此，文件夹被识别，并且该文件夹中的所有图像都被组合成一个或多个大图像。![如何操作...](img/00030.jpeg)
- en: After adding the `FSGame.atlas` file to the project, the `Resources` folder
    looks like this:![How to do it...](img/00031.jpeg)
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将`FSGame.atlas`文件添加到项目后，`Resources`文件夹看起来像这样：![如何操作...](img/00031.jpeg)
- en: Now, for enabling the generation of the Texture Atlas, go to the build settings
    of the project and search for type `Spritekit`; the search results will look like
    this:![How to do it...](img/00032.jpeg)
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了启用纹理图集的生成，转到项目的构建设置并搜索类型`Spritekit`；搜索结果将看起来像这样：![如何操作...](img/00032.jpeg)
- en: Now you can see the **Enable Texture Atlas Generation** field in the **SpriteKit
    Deployment Options** section. Set that bool to **Yes**.![How to do it...](img/00033.jpeg)
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以在**SpriteKit部署选项**部分看到**启用纹理图集生成**字段。将该布尔值设置为**是**。![如何操作...](img/00033.jpeg)
- en: As a result, whenever we build the project, the compiler generates a property
    list to access the images of the texture atlas by its name, which we have given
    to the folder.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每次我们构建项目时，编译器都会生成一个属性列表，通过其名称访问纹理图集的图像，这是我们给文件夹的。
- en: How it works...
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: After the creation of the texture atlas, the most important part is how we will
    be able to access images from the texture atlas. It's done by enabling the bool
    **Enable Texture Atlas Generation**. After this, whenever we build the project,
    the compiler looks for folders with a naming convention such as `name.atlas`.
    Hence, the folders are identified and all the images in that folder are combined
    to form one or more large images.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建纹理图集之后，最重要的部分是我们将如何能够访问纹理图集中的图像。这是通过启用bool值**Enable Texture Atlas Generation**来完成的。之后，每次我们构建项目时，编译器都会寻找具有类似`name.atlas`命名约定的文件夹。因此，文件夹被识别，并且该文件夹中的所有图像都被组合成一个或多个大图像。
- en: Here, Xcode generates a `.plist` file after setting the bool. After that, the
    texture atlas name is used to get the texture atlas in the code and from there
    we can get any image, which is put in that folder that is, texture atlas.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Xcode在设置bool值后生成一个`.plist`文件。之后，使用纹理图集名称在代码中获取纹理图集，并从那里我们可以获取任何图像，这些图像被放在那个文件夹中，即纹理图集。
- en: There's more...
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Whenever we create a texture atlas, there is always a trade-off between using
    too many textures or few images. When using few images SpriteKit still needs to
    make many drawing calls to render each frame. And for many textures, the images
    in quantity may increase the texture data thereby leading to a load on the memory.
    So it's up to us how we want to go; we can switch between both the alternatives
    with relative ease. Hence, different configurations can be tried out to have the
    best performance.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们创建纹理图集时，总是存在使用过多纹理或较少图像之间的权衡。当使用较少图像时，SpriteKit仍然需要做出许多绘图调用以渲染每一帧。而对于许多纹理，图像数量的增加可能会增加纹理数据，从而对内存造成负载。因此，这取决于我们如何选择；我们可以相对容易地在两种选择之间切换。因此，可以尝试不同的配置以获得最佳性能。
- en: Adding animations using a texture atlas
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用纹理图集添加动画
- en: We have already learned about animations even before learning how to use textures
    for loading images from `App Bundle`. As we have a texture atlas (that is, a larger
    combined image), we will be loading the images by that texture atlas. All sprites
    added in the `FSMyScene` file are loaded by the images from the `App Bundle`,
    so now we will be loading all the images by the texture atlas in the sprite. Lastly,
    some animations will be applied to them using the texture atlas to load the images.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习如何使用纹理从`App Bundle`加载图像之前，我们就已经了解了动画。因为我们有一个纹理图集（即一个较大的组合图像），我们将通过该纹理图集加载图像。在`FSMyScene`文件中添加的所有精灵都通过`App
    Bundle`中的图像加载，所以现在我们将通过精灵中的纹理图集加载所有图像。最后，将使用纹理图集加载的图像应用一些动画。
- en: Getting ready
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before starting with the animations using a texture atlas to load images, we
    should know the process of creating a texture atlas using a combination of images
    and doing some animations of changing frame after a fixed delay. So here we will
    be doing the same animation of coin rotation we did earlier, but now using a texture
    atlas. This recipe will be called *Adding animations using a texture atlas*. After
    that we will animate a bunch of coins from one end to another (right to left)
    in the `FSMyScene` in a random fashion giving a feel that coins are just moving
    in the sky.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用纹理图集加载图像进行动画之前，我们应该了解使用图像组合创建纹理图集的过程，并在固定延迟后进行一些帧变化的动画。所以这里我们将做之前做的同样的硬币旋转动画，但现在使用纹理图集。这个配方将被称为*使用纹理图集添加动画*。之后，我们将以随机方式在`FSMyScene`中从一端到另一端（从右到左）动画化一组硬币，给人一种硬币在天空中移动的感觉。
- en: How to do it…
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'First of all, we will be replacing the creation of textures using the image
    by the texture atlas images in `App Bundle`. Perform the following steps:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将用纹理图集图像在`App Bundle`中创建纹理的过程替换掉使用图像创建纹理的过程。执行以下步骤：
- en: Create an object of `SKTextureAtlas` by specifying its name that is, `FSGame`
    (name of the texture atlas).
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过指定其名称，即`FSGame`（纹理图集的名称），创建一个`SKTextureAtlas`对象。
- en: '[PRE8]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The images previously added to the project bundle should be removed to avoid
    redundancy.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应该从项目包中移除之前添加的图像，以避免冗余。
- en: '[PRE9]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now create the texture using a texture atlas object by passing the spaceship
    image that has to be set to the sprite.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在通过传递要设置到精灵中的太空船图像来使用纹理图集对象创建纹理。
- en: '[PRE10]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the `addCoin` method of FSMyScene, use the preceding process to create the
    textures using the t`extureAtlas` object for all coin textures.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在FSMyScene的`addCoin`方法中，使用前面的过程通过`t`extureAtlas`对象为所有硬币纹理创建纹理。
- en: '[PRE11]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Once all the textures are created, use the same code of `addCoin` to add and
    animate the coin.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦所有纹理都创建完毕，使用与`addCoin`相同的代码来添加和动画硬币。
- en: Let's make the coin animation more live and natural. Feed the action formed
    for animating the texture with a fixed delay to another `SKAction` making it repeat
    forever giving a feel of continuous rotation of coin (never ending).
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使硬币动画更加生动和自然。将用于动画纹理的动作与一个固定延迟一起传递给另一个`SKAction`，使其无限重复，从而给人一种硬币持续旋转（永不结束）的感觉。
- en: '[PRE12]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After a little tweaking, remove the last texture from the array so that when
    the `repeatForever` action is going to run, the first image will appear after
    the last image, so there is no need for the last texture.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 经过一些调整后，从数组中移除最后一个纹理，这样当`repeatForever`动作运行时，第一个图像将在最后一个图像之后出现，因此不需要最后一个纹理。
- en: '[PRE13]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now our forever rotating coin is built and can be used either as a prop or collectables
    in our game.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了一个永远旋转的硬币，可以用作游戏中的道具或可收集物品。
- en: 'These are the steps to make the coins collectables:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 制作可收集硬币的步骤如下：
- en: For making a coin move from the left end to the right end of the screen, we
    have to calculate the initial and final positions.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使硬币从屏幕的左侧移动到右侧，我们必须计算初始和最终位置。
- en: '[PRE14]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: After that, set the initial position as the coin sprite position.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，设置初始位置为硬币精灵的位置。
- en: '[PRE15]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The initial position of the coin is set and now we have to animate the coin
    from the initial position to the final position. This can be done by adding a
    move `SKAction` to the coin sprite specifying its final destination.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 硬币的初始位置被设置，现在我们必须将硬币从初始位置动画到最终位置。这可以通过向硬币精灵添加一个移动`SKAction`并指定其最终目的地来实现。
- en: '[PRE16]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, our `addCoin` method has been fully prepared for the game. For moving
    the coins as collectables, perform the following steps:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的`addCoin`方法已经完全准备好用于游戏。为了移动作为可收集物品的硬币，执行以下步骤：
- en: 'For making these coins move as collectables in the scene, a little bit of refactoring
    is required in the update method. Update the `diffTim`e and `lastUpdatedTime`
    as shown in the following code:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使这些硬币在场景中作为可收集物品移动，需要在更新方法中进行一些重构。更新`diffTim`e和`lastUpdatedTime`，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now using `currentTime`, create a timer kind of functionality by declaring a
    property called `lastCoinAdded` in the private interface of FSMyScene.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在通过在FSMyScene的私有接口中声明一个名为`lastCoinAdded`的属性，使用`currentTime`创建一个计时器功能。
- en: '[PRE18]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: So this is the timer added in the update method and the diff of `currentTime`
    and `lastCoinAdded` is checked by 1\. Hence, after every 1.0 second, a coin will
    be added with animation moving from left to right on the screen.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，这是在更新方法中添加的计时器，通过检查`currentTime`和`lastCoinAdded`的差值来1。因此，每过1.0秒，就会添加一个硬币，动画从屏幕左侧移动到右侧。
- en: '[PRE19]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Finally, our update method is ready to animate multiple coins after a set delay.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的更新方法已经准备好在设定延迟后动画多个硬币。
- en: How it works…
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Before we were creating the sprite using images from `App Bundle`, but now we
    will be using texture atlas to get the images and passing to the sprites. The
    preceding texture atlas named `FSGame.atlas` holds multiple images of coins and
    spaceship in it. The internal code loads the frames and stores them in an array.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前是使用来自`App Bundle`的图片来创建精灵，但现在我们将使用纹理图集来获取图片并将其传递给精灵。之前名为`FSGame.atlas`的纹理图集包含了多个硬币和宇宙飞船的图片。内部代码加载这些帧并将它们存储在一个数组中。
- en: 'SpriteKit first searches for the image file, if not found it searches inside
    the texture atlases build into the app bundle. If we want to work explicitly with
    texture atlases, use the `SKTextureAtlas` class. It fetches the texture atlas
    by specifying its name:'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SpriteKit首先搜索图像文件，如果找不到，它会在应用包中构建的纹理图集中搜索。如果我们想显式地使用纹理图集，可以使用`SKTextureAtlas`类。通过指定其名称来获取纹理图集：
- en: '[PRE20]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Then we can use the atlas object to get the required image for creation of sprites.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们可以使用图集对象来获取创建精灵所需的图片。
- en: '[PRE21]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now we will understand how the coins are converted into collectables. For moving
    the coins, its initial and final positions are to be decided.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将了解硬币是如何被转换成可收集物品的。为了移动硬币，需要决定其初始和最终位置。
- en: The initial position in *x* dimensions, is fixed to the width of the frame plus
    half of its coin so that it is added outside the screen and *y* dimensions are
    randomly chosen from 0 to 320 using the `arc4random()`function.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*x*维度上的初始位置固定为框架宽度加上硬币的一半，这样它就被添加到屏幕外，而*y*维度则使用`arc4random()`函数从0到320随机选择。
- en: '[PRE22]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: For the final position, the *x* dimension is set to negative of half of its
    own width and the *y* dimension is the same as the initial position *x*.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于最终位置，*x* 轴设置为自身宽度的一半的负值，*y* 轴与初始位置 *x* 相同。
- en: '[PRE23]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![How it works…](img/00034.jpeg)'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何工作…](img/00034.jpeg)'
- en: 'Now the collectable is ready to be added to the scene. But for multiple coins
    to be added moving left to right on the scene, a timer has to be implemented.
    The timer looks like this:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在可收集物品已准备好添加到场景中。但是，为了使多个硬币在场景中从左向右移动，必须实现一个计时器。计时器看起来像这样：
- en: '[PRE24]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After all these implementations, multiple coins are seen moving from left to
    right as shown in the following screenshot:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成所有这些实现后，可以看到多个硬币从左向右移动，如下面的截图所示：
- en: '![How it works…](img/00035.jpeg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/00035.jpeg)'
- en: Collision detection
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞检测
- en: We have our game integrated with collectables. Let's see how the spaceship will
    collect these collectables that is, coins. In character animation, we will be
    doing the animations on the spaceship and the coins when they collide with each
    other.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将游戏与可收集物品集成在一起。让我们看看宇宙飞船将如何收集这些可收集物品，即硬币。在角色动画中，我们将对相互碰撞的宇宙飞船和硬币进行动画处理。
- en: Getting ready
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before moving on to the complex animations to be applied on the entities of
    the scene, the understanding of actions (that is, `SKAction`) and update function
    of scene (`SKScene`) has to be there. This is so that during updation we can detect
    the collision between the coin and the spaceship and do some animations on both
    of them.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续对场景中的实体应用复杂动画之前，必须理解动作（即 `SKAction`）和场景的更新函数（`SKScene`）。这样，在更新过程中，我们可以检测硬币与宇宙飞船之间的碰撞，并对它们进行一些动画处理。
- en: How to do it…
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'The following are the steps involved in detecting the collision and animating
    both the entities (coin and spaceship):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 检测碰撞并对两个实体（硬币和宇宙飞船）进行动画的以下步骤包括：
- en: Write an `detectSpaceShipCollisionWithCoins` method in which we will enumerate
    the coin objects.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个 `detectSpaceShipCollisionWithCoins` 方法，我们将遍历硬币对象。
- en: '[PRE25]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In that enumeration, determine that the frame of the spaceship and the frame
    of any coin intersects with the help of `CGRectIntersectsRect()`.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在枚举中，使用 `CGRectIntersectsRect()` 确定宇宙飞船的帧与任何硬币的帧相交。
- en: '[PRE26]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When a collision is detected, inform the scene that a coin has collided with
    the spaceship by a function called `spaceShipCollidedWithCoin`.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当检测到碰撞时，通过名为 `spaceShipCollidedWithCoin` 的函数通知场景，硬币与宇宙飞船发生了碰撞。
- en: '[PRE27]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'After all this, the `detectSpaceShipCollisionWithCoins` method looks like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些之后，`detectSpaceShipCollisionWithCoins` 方法看起来如下：
- en: '![How to do it…](img/00036.jpeg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](img/00036.jpeg)'
- en: 'After detecting the collision, the `spaceShipCollidedWithCoin` function is
    invoked, which calls two other functions that implement animation methods for
    the spaceship and coin that have collided. The definition of this method looks
    like this:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检测到碰撞后，调用 `spaceShipCollidedWithCoin` 函数，该函数调用两个其他函数，这些函数实现了碰撞宇宙飞船和硬币的动画方法。此方法的定义如下：
- en: '[PRE28]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The animation written for the spaceship is as if it is taking the coin into
    itself. There are two actions created for `scaleUp` and `scaleDown` with a scale
    factor 1.4 and 1.0 respectively to be played for 0.2 each.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为宇宙飞船编写的动画看起来像是将硬币吸入自身。创建了两个动作 `scaleUp` 和 `scaleDown`，分别用于缩放因子 1.4 和 1.0，每个动作播放
    0.2 秒。
- en: '[PRE29]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: After that, these two animation arrays are formed to be used for creating a
    sequence action.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，形成这两个动画数组以用于创建序列动作。
- en: '[PRE30]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Lastly the sequence action formed runs on the spaceship.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，形成的序列动作在宇宙飞船上运行。
- en: '[PRE31]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: For the coin, the animation should be as if it is disappearing as it is taken
    by the spaceship. Thus, two core animations `fadeOut` and `scaleDown` are created
    with a 0.2 scale factor having a time interval of 0.4 each, forming an array of
    animations.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于硬币，动画应该看起来像是被宇宙飞船带走时正在消失。因此，创建了两个核心动画 `fadeOut` 和 `scaleDown`，每个动画的缩放因子为 0.2，时间间隔为
    0.4，形成一个动画数组。
- en: '[PRE32]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Using these animations, a group animation is formed.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这些动画，形成一个组动画。
- en: '[PRE33]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As for the coin, when it collides with the spaceship, it has to be removed from
    the scene when its animation is over. So create an action using the block to remove
    the coin after the previously created group animation is completed.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关于硬币，当它与宇宙飞船相撞时，动画结束后必须从场景中移除。因此，在之前创建的组动画完成后，使用积木创建一个动作来移除硬币。
- en: '[PRE34]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As the animations are ready, create the sequence action for it using an array.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当动画准备就绪时，使用数组创建其序列动作。
- en: '[PRE36]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Hence, the coin looks as if it is disappearing when the preceding complex actions
    run on the coin.
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，当先前的复杂动作在硬币上运行时，硬币看起来就像是要消失一样。
- en: '[PRE37]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As all the code of the animation and collision detection is done, call the `detechSpaceShipCollisionWithCoins`
    method, so that in each frame the collision is detected and the coin is collected
    by the character of the game (that is, the spaceship).
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于所有动画和碰撞检测的代码都已完成，调用`detechSpaceShipCollisionWithCoins`方法，以便在每一帧检测碰撞，并通过游戏角色（即飞船）收集硬币。
- en: '[PRE38]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How it works…
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The most important part of this section is the collision detection. It is done
    with the help of the `CGRectIntersectsRect` method in which the coins are enumerated
    and checked whether their frames intersect the spaceship frame. If they do, then
    two different animations are played on the coin and spaceship.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 本节最重要的部分是碰撞检测。它是通过`CGRectIntersectsRect`方法完成的，其中枚举硬币并检查它们的框架是否与飞船框架相交。如果相交，则在硬币和飞船上播放两个不同的动画。
- en: '[PRE39]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'When detection happens, the game looks like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当检测发生时，游戏看起来是这样的：
- en: '![How it works…](img/00037.jpeg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理…](img/00037.jpeg)'
- en: Now we come to animations. The animation of the spaceship is a simple one. Just
    to give a feel of collecting the coins, `scaleUp` and `scaleDown` animations are
    used in sequence.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来谈谈动画。飞船的动画很简单。为了给收集硬币的感觉，我们按顺序使用了`scaleUp`和`scaleDown`动画。
- en: '[PRE40]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'However, for coins, a complex one with three actions is created, which are
    as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于硬币，创建了一个复杂的动作，包括以下三个动作：
- en: '`FadeOutAction` to fade the coin for 0.4 seconds, which appears to be disappearing.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FadeOutAction`使硬币在0.4秒内淡出，看起来像是消失。'
- en: '[PRE41]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`ScaleDownAction` to scale down the coin to make it shrink into the spaceship
    in 0.4 seconds.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScaleDownAction`将硬币缩小，使其在0.4秒内缩入飞船。'
- en: '[PRE42]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: A `CallBack` function that is used to remove the coin from the scene when the
    preceding animations are over.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`CallBack`函数，用于在先前的动画结束后从场景中移除硬币。
- en: '[PRE43]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: After creation of all these actions, a group of `fadeOut` and `scaleDown`, a
    sequence of animation with a sequence of group animation and callback action is
    created, which is applied on the coin.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建所有这些动作之后，创建了一组`fadeOut`和`scaleDown`，这是一个由一系列组动画和回调动作组成的动画序列，它应用于硬币。
- en: 'Whenever there is a collision, the spaceship scales up and down with the coin
    fading out as depicted in the following screenshot:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 每当发生碰撞时，飞船会上下缩放，而硬币会淡出，如下截图所示：
- en: '![How it works…](img/00038.jpeg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理…](img/00038.jpeg)'
- en: Parallax background
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视差背景
- en: 'Now our mini game FlyingSpaceship is about to finish. To give the feel of a
    game environment we will introduce a parallax scrolling background. A parallax
    scrolling background is composed of multiple background layers (that is, nodes);
    animating them simultaneously gives a feel of dynamic background. To add some
    cool flyers to the game we will add two layers of background: the `SpaceBlueSky`
    and the `SpaceWhiteMist` in the form of nodes.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的小游戏FlyingSpaceship即将结束。为了给游戏环境增添感觉，我们将引入一个视差滚动背景。视差滚动背景由多个背景层（即节点）组成；同时动画它们会给人一种动态背景的感觉。为了给游戏添加一些酷炫的飞行物，我们将添加两层背景：以节点形式出现的`SpaceBlueSky`和`SpaceWhiteMist`。
- en: Getting ready
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To start with this cool feature, we should be aware of the scrolling background
    created in the previous chapter and have a basic knowledge of sprites, nodes,
    and math. We are going to cook the *Parallax background* recipe in the FlyingSpaceship
    game.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，要使用这个酷炫的功能，我们应该了解在前一章中创建的滚动背景，并具备对精灵、节点和数学的基本知识。我们将在FlyingSpaceship游戏中制作*视差背景*的配方。
- en: How to do it…
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'To create multiple scrolling backgrounds with varying speeds of scrolling,
    we will be creating a class for it to accomplish the parallax background. The
    steps involved in creating a class for parallax background named as `FSParallaxNode`
    are as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建具有不同滚动速度的多个滚动背景，我们将创建一个类来完成视差背景。创建名为`FSParallaxNode`的视差背景类所涉及的步骤如下：
- en: Create a new file by right clicking on the **FlyingSpaceship** project.![How
    to do it…](img/00039.jpeg)
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在**FlyingSpaceship**项目上右键单击来创建一个新文件。![如何操作…](img/00039.jpeg)
- en: Select **Objective-C Class** in the **Cocoa Touch** section.![How to do it…](img/00040.jpeg)
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Cocoa Touch**部分选择**Objective-C Class**。![如何操作…](img/00040.jpeg)
- en: Name the class `FSParallaxNode` and click on **Next**.![How to do it…](img/00041.jpeg)
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类命名为`FSParallaxNode`并点击**下一步**。![如何操作…](img/00041.jpeg)
- en: Now to create the class, select the `FlyingSpaceship` folder in which it has
    to be created and click on **Create**.![How to do it…](img/00042.jpeg)
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在要创建类，请选择要创建的`FlyingSpaceship`文件夹，并点击**创建**。![如何操作…](img/00042.jpeg)
- en: Now we need to add two methods in the header of `FSParallaxNode`. Firstly, in
    the `init` method, we need to specify `imageFiles`, which are the images to be
    scrolled, the canvas size, and the velocity with which the images will scroll.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要在`FSParallaxNode`的头部添加两个方法。首先，在`init`方法中，我们需要指定`imageFiles`，即要滚动的图片，画布大小以及图片滚动的速度。
- en: '[PRE44]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Secondly, an update method called from the update of Scene in which the `FSParallaxNode`
    method is added so that the scrolling is made infinite.
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其次，有一个名为从场景更新中调用的更新方法，其中添加了`FSParallaxNode`方法，使得滚动变得无限。
- en: '[PRE45]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In `FSParallaxNode.m`, declare some properties in its private interface to store
    all background nodes, counts of backgrounds, and velocity of that parallax node.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`FSParallaxNode.m`中，在其私有接口中声明一些属性以存储所有背景节点、背景数量和该视差节点的速度。
- en: '[PRE46]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In definition of the `init` method, first assign all the parameters passed in
    the function like `velocity`. Now we assign `noOfBackgrounds` using the `imageFiles`
    count and make an array of backgrounds with a capacity of `noOfBackgrounds`.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`init`方法的定义中，首先分配函数中传递的所有参数，例如`velocity`。现在我们使用`imageFiles`计数来分配`noOfBackgrounds`，并创建一个容量为`noOfBackgrounds`的背景数组。
- en: '[PRE47]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Using the `imageFiles`, enumerate them using the block. In enumeration, add
    background nodes using the `imageFiles` class, add them to the backgrounds array
    and on `FSParallaxNode`.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`imageFiles`，使用块进行枚举。在枚举过程中，使用`imageFiles`类添加背景节点，将它们添加到背景数组中，并在`FSParallaxNode`上。
- en: '[PRE48]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Also, specify the `backgroundNode` size, which is passed in the `init` method,
    its `anchorPoint` to `CGPointZero`, its position according to the `idx` integer
    and a name of the node as `background`.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还需要指定`backgroundNode`的大小，这是通过`init`方法传递的，其`anchorPoint`为`CGPointZero`，其位置根据`idx`整数，节点名称为`background`。
- en: '[PRE49]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'After all this, our `init` method is ready as shown in the following screenshot:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成所有这些之后，我们的`init`方法就准备好了，如下面的截图所示：
- en: '![How to do it…](img/00043.jpeg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作…](img/00043.jpeg)'
- en: Now let's see how these backgrounds added on `FSParallaxNode` are to be scrolled;
    it will be done by an instance update method.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何滚动添加到`FSParallaxNode`上的这些背景；这将通过一个实例更新方法来完成。
- en: Some `cleanUp` has to be done or in other terms some code movement. Copy the
    two static methods used in the `FSMyScene` to `FSParallaxNode` class used for
    some math, remove the initialization of the `SpaceBackground` method and the call
    of moving background made in the update from `FSMyScene`. Cut the code of the
    method for moving the background from the `FSMyScene` file and paste in the `updateForDeltaTime`
    function of `FSParallaxNode`. Now we will be making some tweaks to the method.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 必须进行一些`cleanUp`操作，或者换句话说，需要移动一些代码。将`FSMyScene`中使用的两个静态方法复制到用于某些数学计算的`FSParallaxNode`类中，移除`SpaceBackground`方法的初始化以及从`FSMyScene`中更新的移动背景调用。从`FSMyScene`文件中剪切移动背景的方法代码，并将其粘贴到`FSParallaxNode`的`updateForDeltaTime`函数中。现在我们将对方法进行一些调整。
- en: '`SKParallax` node is the parent for all the other nodes of backgrounds added
    on it. So using the velocity, send in the `init` and `diffTime`, method which
    will be passed by the `FSMyScene` update methods, we calculate the position of
    the parent that is, `FSParallax` node.'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SKParallax`节点是所有添加到其上的背景节点的父节点。因此，使用速度，通过`init`和`diffTime`方法（这些方法将通过`FSMyScene`的更新方法传递），我们计算出父节点的位置，即`FSParallax`节点。'
- en: '[PRE50]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now enumerate the backgrounds that is, all nodes added to the parent. In this
    enumeration, find the position of an individual background with respect to the
    parent node. After this, check whether the position of a background is less than
    the negative of its width (that is, reached the left end), then change the position
    of that background to its right end.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，枚举背景，即所有添加到父节点上的节点。在这个枚举过程中，找到相对于父节点的单个背景的位置。之后，检查背景的位置是否小于其宽度的负值（即到达了左端），然后改变该背景的位置到其右端。
- en: '[PRE51]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Finally, our update method is constructed, which provides a functionality of
    multiple backgrounds scrolling infinitely.![How to do it…](img/00044.jpeg)
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们的更新方法构建完成，它提供了多个背景无限滚动的功能。![如何操作…](img/00044.jpeg)
- en: As of now, the `FSParallaxNode` class, which provides the functionality of parallax
    scrolling background is created and it's time to create objects in `FSMyScene`
    to make a cool environment.
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到目前为止，提供视差滚动背景功能的`FSParallaxNode`类已经创建，现在是时候在`FSMyScene`中创建对象以创建一个酷炫的环境了。
- en: We will be adding two background layers BlueSky and WhiteMist, so create two
    objects for each of them.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将添加两个背景层：BlueSky和WhiteMist，因此为每个背景创建两个对象。
- en: '[PRE52]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Add a method called `addParallaxNodes` and call it in the first line of the
    `init` method of `FSMyScene`.
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加一个名为`addParallaxNodes`的方法，并在`FSMyScene`的`init`方法的第一行调用它。
- en: '[PRE53]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: For two parallax nodes, we have to add the following two constants for their
    relative speeds.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于两个视差节点，我们必须为它们的相对速度添加以下两个常量。
- en: '[PRE54]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In `addParallaxNodes,` make an array of `blueSkyParallaxBackgroundImages` and
    create an object of `FSParallax` by passing the size of the scene and velocity
    at which it is going to scroll.
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`addParallaxNodes`中，创建一个`blueSkyParallaxBackgroundImages`数组，并通过传递场景大小和滚动速度创建一个`FSParallax`对象。
- en: '[PRE55]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Similar to the blue sky background, we have to implement the mist images as
    well. To add more reality to the game, we will add the `mistParallaxBackgroundImages`
    function.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与蓝天背景类似，我们还需要实现雾图像。为了使游戏更具现实感，我们将添加`mistParallaxBackgroundImages`函数。
- en: '[PRE56]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Once the nodes have been added to the scene, they need to be updated for scrolling
    purposes. So call the `updateForDeltaTime` function of `FSMyScene` for both the
    nodes.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦节点被添加到场景中，它们需要更新以实现滚动。因此，为两个节点调用`FSMyScene`的`updateForDeltaTime`函数。
- en: '[PRE57]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: After all these steps, the dynamic environment with a parallax scrolling background
    is ready for the game.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 经过所有这些步骤后，带有视差滚动的背景的动态环境已经准备好用于游戏。
- en: How it works…
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Since we have done the scrolling of background in the previous chapter, it is
    time we made a separate class for it called `FSParallaxNode`. In this class, multiple
    backgrounds of the same image are placed and scrolled in each update of the scene.
    It means that the scrolling is done on the basis of the positions of all background
    nodes added to `FSParallaxNode`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在上一章中已经完成了背景的滚动，现在是时候为它创建一个单独的类，称为`FSParallaxNode`。在这个类中，相同的多个背景图像被放置并在场景的每次更新中滚动。这意味着滚动是基于添加到`FSParallaxNode`的所有背景节点的位置来进行的。
- en: 'Using this `FSParallaxNode`, two objects of it are created: `BlueSkyBackground`
    and `WhiteMistBackground`. All are added as normal nodes to the scene in the `init`
    method. For them to scroll, the update method calls the `updateForDeltaTime` function
    in which the class checks for the position of individual background positions
    reached at the left end of the screen and changes the position so that it again
    starts with the right-end side. This whole algorithm makes these individual backgrounds
    scroll making a full parallax scrolling background. The parallax scrolling background
    really looks cool as shown in the following screenshot:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个`FSParallaxNode`，创建了两个对象：`BlueSkyBackground`和`WhiteMistBackground`。所有这些都在`init`方法中作为普通节点添加到场景中。为了使它们滚动，更新方法调用`updateForDeltaTime`函数，其中类检查屏幕左侧达到的各个背景位置，并改变位置，使其再次从屏幕右侧开始。这个整个算法使这些单独的背景滚动，形成一个完整的视差滚动背景。视差滚动背景看起来真的很酷，如下面的截图所示：
- en: '![How it works…](img/00045.jpeg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的…](img/00045.jpeg)'
