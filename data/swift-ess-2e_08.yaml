- en: Chapter 8. Adding Watch Support
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章 添加手表支持
- en: Apple released watchOS to the public with the release of the Apple Watch in
    April 2015\. However, with the release of watchOS 2 in September 2015, developers
    have been able to write extensions that run on the watch itself rather than relying
    on a companion iOS device being available. This chapter will show how to add watch
    support to the existing Repository Browser application (created in [Chapter 7](part0050_split_000.html#1FLS41-d7e55eb5242648e89c396442afe4f84b
    "Chapter 7. Building a Repository Browser"), *Building a Repository Browser*.)
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果在2015年4月发布Apple Watch的同时发布了watchOS。然而，随着2015年9月watchOS 2的发布，开发者能够编写在手表本身上运行的扩展，而不是依赖于可用的配套iOS设备。本章将展示如何将手表支持添加到现有的仓库浏览器应用（在第7章[Building
    a Repository Browser](part0050_split_000.html#1FLS41-d7e55eb5242648e89c396442afe4f84b
    "第7章. 构建仓库浏览器")中创建），即*构建仓库浏览器*。
- en: 'This chapter will present the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍以下主题：
- en: Adding a watch extension to an existing project
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将手表扩展添加到现有项目
- en: The type of watch interfaces
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手表界面的类型
- en: Using tables, text, and images
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用表格、文本和图像
- en: How to transition between screens with selected context
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在选中上下文之间切换屏幕
- en: Best practices for watch applications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 智能手表应用的最佳实践
- en: Watch applications
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手表应用
- en: A watch application consists of code that can execute on the watch itself. A
    watch application is developed in Swift and run as a *watch extension* and a *watch
    app*. For watchOS 2, both run on the watch. (On watchOS 1, the watch extension
    ran on the companion iPhone.) This chapter will assume watchOS 2 is being used
    in order to run Swift-compiled code directly on the watch.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 手表应用由可以在手表本身上执行代码组成。手表应用是用Swift开发的，并以**手表扩展**和**手表应用**的形式运行。对于watchOS 2，两者都在手表上运行。（在watchOS
    1中，手表扩展在配套的iPhone上运行。）本章将假设使用watchOS 2来直接在手表上运行Swift编译的代码。
- en: Note
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As the first version of watchOS did not allow code to be executed on the watch,
    the code was bundled up into a watch extension, which ran as part of the companion
    application on the iPhone. The watch app contained resources and other images
    which were presented directly on the watch. With watchOS 2, the separation became
    less relevant. A future version of Xcode or watchOS may result in the two concepts
    becoming combined.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由于第一版watchOS不允许在手表上执行代码，代码被打包成一个手表扩展，作为iPhone上配套应用的组成部分运行。手表应用包含资源和其他图像，这些图像直接在手表上显示。随着watchOS
    2的发布，这种分离变得不那么相关。Xcode或watchOS的将来版本可能会导致这两个概念合并。
- en: Adding a watch target
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加手表目标
- en: 'To add watch support for an existing application, a new target must be created
    for the watch. Open the existing **Repository Browser** application, navigate
    to **File** | **New** | **Target**, and select **WatchKit App** from the **watchOS**
    section:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要为现有应用添加手表支持，必须为手表创建一个新的目标。打开现有的**仓库浏览器**应用，导航到**文件** | **新建** | **目标**，并在**watchOS**部分选择**WatchKit
    App**：
- en: '![Adding a watch target](img/00096.jpeg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![添加手表目标](img/00096.jpeg)'
- en: 'Once this is created, it will ask for the name of the watch application. This
    can''t be the same name as the enclosing project, so call it `RepositoryBrowserWatch`
    instead. The language should be **Swift**; the other user interface elements (**Complications**,
    **Glance**, and **Notifications**) are not relevant to this project, and so, it
    can be deselected:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 创建完成后，将询问手表应用的名称。这个名字不能与包含的项目同名，因此可以将其命名为`RepositoryBrowserWatch`。语言应该是**Swift**；其他用户界面元素（**
    complication**、**Glance**和**通知**）与本项目无关，因此可以取消选择：
- en: '![Adding a watch target](img/00097.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![添加手表目标](img/00097.jpeg)'
- en: 'When **Finish** is pressed, the following new elements will be created in the
    project:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当按下**完成**按钮时，项目中将创建以下新元素：
- en: '`RepositoryBrowserWatch`: This is the watch application, which provides the
    interface descriptions for the application'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RepositoryBrowserWatch`：这是手表应用，它提供了应用的界面描述'
- en: '`RepositoryBrowserWatch Extension`: This is the content corresponding to the
    watch application''s executable code'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RepositoryBrowserWatch Extension`：这是对应手表应用可执行代码的内容'
- en: '`InterfaceController.swift`: This is the Swift file corresponding to the user
    interface element that gets automatically created'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InterfaceController.swift`：这是对应自动创建的用户界面元素的Swift文件'
- en: '`ExtensionDelegate.swift`: This is the Swift file corresponding to the user
    application as a whole (similar to an `AppDelegate` on a traditional iOS application)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExtensionDelegate.swift`：这是对应整个用户应用的Swift文件（类似于传统iOS应用中的`AppDelegate`）'
- en: Adding the GitHubAPI to the watch target
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 GitHubAPI 添加到监视目标
- en: 'In order to allow the watch application to use the `GitHubAPI` that was developed
    in [Chapter 7](part0050_split_000.html#1FLS41-d7e55eb5242648e89c396442afe4f84b
    "Chapter 7. Building a Repository Browser"), *Building a Repository Browser*,
    the following code should be added to the `ExtensionDelegate`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许手表应用程序使用在 [第 7 章](part0050_split_000.html#1FLS41-d7e55eb5242648e89c396442afe4f84b
    "第 7 章。构建仓库浏览器") 中开发的 `GitHubAPI`，*构建仓库浏览器*，应将以下代码添加到 `ExtensionDelegate`：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will initially generate a compile-time error because the `GitHubAPI` class
    (and the dependent classes) is not currently associated to the watch target. To
    resolve this, select the `GitHubAPI`, `Threads`, `NSURLExtensions`, and `URITemplate`
    Swift files and open the file inspector by pressing *Command* + *Option* + *1*
    or by navigating to **View | Utilities | Show File Inspector**. Ensure these are
    added to the **RepositoryBrowserWatch Extension** target by selecting the appropriate
    checkbox:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这将最初生成一个编译时错误，因为 `GitHubAPI` 类（以及相关的类）目前没有与监视目标关联。为了解决这个问题，选择 `GitHubAPI`、`Threads`、`NSURLExtensions`
    和 `URITemplate` Swift 文件，并通过按 *Command* + *Option* + *1* 或通过导航到 **视图 | 工具 | 显示文件检查器**
    打开文件检查器。确保这些文件通过选择相应的复选框添加到 **RepositoryBrowserWatch 扩展** 目标中：
- en: '![Adding the GitHubAPI to the watch target](img/00098.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![将 GitHubAPI 添加到监视目标](img/00098.jpeg)'
- en: 'Now when the watch target is built and run, a watch simulator will show up
    with a black screen and the time at the top-right of the application. If this
    is not displayed, verify that the target selected is for the watch application:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当监视目标构建并运行时，手表模拟器将显示一个黑色屏幕，并在应用程序右上角显示时间。如果未显示，请验证所选的目标是否为手表应用程序：
- en: '![Adding the GitHubAPI to the watch target](img/00099.jpeg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![将 GitHubAPI 添加到监视目标](img/00099.jpeg)'
- en: Creating watch interfaces
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建监视接口
- en: A watch's user interface is built up of elements in a similar way to iOS applications,
    except that the user toolkit is built using `WatchKit` instead of `UIKit`. In
    the same way that classes, such as `UITableView`, exist, corresponding classes,
    such as `WKInterfaceTable`, also exist. There are minor differences; for example,
    the `UITableView` will dynamically populate the elements upon display, but the
    `WKInterfaceTable` will expect to be told in advance how many rows exist and what
    these rows are.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 手表的用户界面是以类似于 iOS 应用程序的方式构建的，除了用户工具包是使用 `WatchKit` 而不是 `UIKit` 构建的。与 `UITableView`
    等类存在的方式相同，也存在相应的类，如 `WKInterfaceTable`。有一些细微的差异；例如，`UITableView` 将在显示时动态填充元素，但
    `WKInterfaceTable` 需要事先知道有多少行以及这些行是什么。
- en: Adding a list of users to the watch
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将用户列表添加到监视列表
- en: Unlike the `UITableView`, which provides section headers to group rows, a `WKInterfaceTable`
    only permits a single list of items. Instead, the application will be designed
    so that the first screen will show a list of users, and then the second screen
    will show the selected user's repositories.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 与提供分组行标题的 `UITableView` 不同，`WKInterfaceTable` 只允许一个项目列表。相反，应用程序将被设计成第一个屏幕将显示用户列表，然后第二个屏幕将显示所选用户的仓库。
- en: 'For testing purposes, add the following into the `applicationDidFinishLaunching`
    method of the `ExtensionDelegate` class:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试目的，将以下内容添加到 `ExtensionDelegate` 类的 `applicationDidFinishLaunching` 方法中：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will allow other classes to query the `ExtensionDelegate` property `users`
    to show some content. As with the `AppDelegate` of an iOS application, there is
    a global singleton that can be accessed. Add the following to the `InterfaceController`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许其他类查询 `ExtensionDelegate` 属性 `users` 来显示一些内容。与 iOS 应用程序的 `AppDelegate` 一样，有一个全局单例可以访问。将以下内容添加到
    `InterfaceController`：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To display a list of users, the interface itself must have a table. Each table
    row has its own controller class, which can be a simple `NSObject` subclass. To
    display a list of user names, create a `UserRowController` class that has a single
    label. As this is a private implementation detail of the `InterfaceController`,
    it makes sense to include it in the same file:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示用户列表，界面本身必须有一个表格。每一行表格都有一个自己的控制器类，这可以是一个简单的 `NSObject` 子类。要显示用户名列表，创建一个 `UserRowController`
    类，它包含一个单独的标签。由于这是 `InterfaceController` 的私有实现细节，将其包含在同一个文件中是有意义的：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add the following to the `InterfaceController` class, which will be connected
    to the interface later:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到 `InterfaceController` 类中，该类稍后将连接到界面：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, the table can be populated in the `awakeWithContext` method. This involves
    setting the number of rows, and the type of the rows. Add the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，可以在`awakeWithContext`方法中填充表格。这涉及到设置行数和行的类型。添加以下内容：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If the application is run at this point, several errors will occur because the
    `IBOutlet` references have not been connected, and the row type user has not been
    associated with the `UserRowController` class.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此时运行应用程序，将发生几个错误，因为`IBOutlet`引用尚未连接，行类型`user`尚未与`UserRowController`类关联。
- en: Wiring up the interface
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接界面
- en: Having generated the content for the users, the interface must be wired to the
    implementation detail. Open `Interface.storyboard` in the `RepositoryBrowserWatch`
    folder and go to **Interface Controller Scene**. This will present a black watch
    surrounded with a clock and **Any Screen Size** displayed at the bottom. Like
    iOS application interfaces, they can come in different sizes (38mm or 42mm at
    the time of writing).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 生成用户内容后，界面必须连接到实现细节。在`RepositoryBrowserWatch`文件夹中打开`Interface.storyboard`，并转到**接口控制器场景**。这将显示一个带有时钟和底部显示**任何屏幕尺寸**的黑色手表。像iOS应用程序界面一样，它们可以有不同的尺寸（在撰写本文时为38mm或42mm）。
- en: 'Open the object library by pressing *Command* + *Option* + *Control* + *3*
    or by navigating to **View | Utilities | Show Object Library**. Type `table` into
    the search field and then drag it into the watch interface:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通过按*Command* + *Option* + *Control* + *3*键或通过导航到**视图 | 工具 | 显示对象库**打开对象库。在搜索字段中输入`table`，然后将它拖动到手表界面中：
- en: '![Wiring up the interface](img/00100.jpeg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![连接界面](img/00100.jpeg)'
- en: 'From the **Interface Controller** in the document outline on the left, press
    *Control* and drag down to the table to create a connection to the `usersTable`
    outlet that is defined in the interface controller:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从左侧文档大纲中的**接口控制器**，按*Control*键并向下拖动到表格中，创建一个连接到接口控制器中定义的`usersTable`出口：
- en: '![Wiring up the interface](img/00101.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![连接界面](img/00101.jpeg)'
- en: 'When the `InterfaceController` is instantiated, the `usersTable` will be wired
    up to the outlet. However, there are still no connections to the rows. To do this,
    drag a label into the dotted area with the **Table Row** placeholder. To ensure
    that the label takes up all the available space, set the size to **Relative to
    Container** with a factor of **1** for both **Width** and **Height**:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当`InterfaceController`实例化时，`usersTable`将连接到出口。然而，行之间还没有连接。为此，将一个标签拖动到带有**表格行**占位符的虚线区域。为了确保标签占用所有可用空间，将大小设置为**相对于容器**，宽度和高度的因素均为**1**：
- en: '![Wiring up the interface](img/00102.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![连接界面](img/00102.jpeg)'
- en: In order to connect the label's text with the `UserRowController`, two things
    have to be done. Firstly, the type of the row must be set to correspond to the
    `UserRowController` class, which will allow the label to be wired up to the name
    outlet. Secondly, the row must be given the identifier user to allow it to be
    connected with the `rowType` that was specified in the previous section.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将标签的文本与`UserRowController`连接起来，必须做两件事。首先，行的类型必须设置为与`UserRowController`类相对应，这将允许标签连接到名称出口。其次，行必须被赋予标识符`user`，以便它可以与之前章节中指定的`rowType`连接。
- en: 'To set the row controller''s class, open the **Identity Inspector** by pressing
    the *Command* + *Option* + *3* keys or by navigating to **View | Utilities | Show
    Identity Inspector**. Choose **UserRowController** from the dropdown, which should
    also set the module name **RepositoryBrowserWatch_Extension**. Once this is done,
    the user controller can make a connection to the label by pressing *Control* and
    dragging to the label, followed by choosing the **name** outlet:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置行控制器的类，通过按*Command* + *Option* + *3*键或通过导航到**视图 | 工具 | 显示身份检查器**打开**身份检查器**。从下拉菜单中选择**UserRowController**，这应该也会设置模块名称**RepositoryBrowserWatch_Extension**。完成此操作后，用户控制器可以通过按*Control*键并拖动到标签，然后选择**name**出口来连接到标签：
- en: '![Wiring up the interface](img/00103.jpeg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![连接界面](img/00103.jpeg)'
- en: 'To set the row controller''s type, switch to the **Attributes Inspector** by
    pressing the *Command* + *Option* + *4* keys or by navigating to **View | Utilities
    | Show Attributes Inspector**, and entering the `rowType` that was used previously,
    which is `user`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置行控制器的类型，通过按*Command* + *Option* + *4*键或通过导航到**视图 | 工具 | 显示属性检查器**切换到**属性检查器**，输入之前使用的`rowType`，即`user`：
- en: '![Wiring up the interface](img/00104.jpeg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![连接界面](img/00104.jpeg)'
- en: 'Now when the application is run the list of users should be seen, which includes
    `alblue`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当应用程序运行时，应该可以看到用户列表，其中包括`alblue`：
- en: '![Wiring up the interface](img/00105.jpeg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![连接界面](img/00105.jpeg)'
- en: Adding an image
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加图片
- en: 'It is possible to use the existing API to return an image for the user, and
    this can be displayed using a `WKInterfaceImage` in a similar way to the text
    name. First, an outlet needs to be created in the `UserRowController` so that
    it can be connected to the interface:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用现有的API为用户返回一张图片，并且可以使用`WKInterfaceImage`以类似文本名称的方式显示它。首先，需要在`UserRowController`中创建一个出口，以便将其连接到界面：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The interface now needs to be updated to add the image. This can be done by
    searching for **image** in the object library and then dragging it into the user
    row.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 界面现在需要更新以添加图片。这可以通过在对象库中搜索**图片**，然后将其拖入用户行来完成。
- en: The watch prefers that image sizes are known in advance, so the size of the
    image can be fixed with a size of 32 by 32 pixels, which will be sufficient for
    both the larger and smaller watch sizes. Marking the image as **Aspect Fit** will
    ensure that the image doesn't get resized inappropriately, and that the whole
    image will be displayed.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 手表更喜欢提前知道图片大小，因此可以将图片大小固定为32x32像素，这对于大尺寸和小尺寸的手表都足够。将图片标记为**填充**将确保图片不会被不恰当地调整大小，并且整个图片都将显示。
- en: Tip
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It is possible to click the **+** icon next to the **size** and then specify
    different dimensions for the two different watches.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 可以点击**+**图标旁边的**大小**，然后为两个不同的手表指定不同的尺寸。
- en: 'Aligning the image on the right and on the center will give the same impression
    for both sizes of watch. Changing the alignment to **Right** and **Center** will
    allow the display to adjust to different sizes. It may also make sense to modify
    the user''s name width from **Relative to Container** to **Size to Fit**, but
    this is not strictly necessary. Finally, connect the outlet from the **user**
    row with the image using *Control* and dragging the mouse, followed by choosing
    the **icon** outlet. The resulting user interface will look like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 将图片右对齐和居中对齐会给手表的两种尺寸带来相同的印象。将对齐方式更改为**右对齐**和**居中对齐**将允许显示适应不同的尺寸。也可能有必要将用户名称的宽度从**相对于容器**更改为**大小适应**，但这不是严格必要的。最后，使用*控制*和拖动鼠标将来自**用户**行的出口与图片连接，然后选择**图标**出口。结果的用户界面将看起来像这样：
- en: '![Adding an image](img/00106.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![添加图片](img/00106.jpeg)'
- en: 'Having created and wired up the image, the last step is to populate the data.
    In the `InterfaceController` method `awakeFromContext`, after setting the user''s
    name, add a call to the API to acquire the image similar to the `DetailViewController`
    in the last chapter:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 创建并连接好图片后，最后一步是填充数据。在`InterfaceController`方法`awakeFromContext`中，在设置用户名称后，添加对API的调用以获取图片，类似于上一章中的`DetailViewController`：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now when the application is run, after a brief pause, the user''s avatar will
    be seen:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当应用程序运行后，经过短暂的暂停，将看到用户的头像：
- en: '![Adding an image](img/00107.jpeg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![添加图片](img/00107.jpeg)'
- en: Responding to user interaction
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应用户交互
- en: Typically, a watch user interface will present information to the user or let
    them select or manipulate it in some way. When items are presented in a table,
    then it is natural to let the user tap on the row to show a subsequent screen.
    Watch applications use **segues** to move from one screen to another in a similar
    way to iOS applications.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，手表用户界面会向用户展示信息，或者让他们以某种方式选择或操作它。当项目以表格形式展示时，自然会让用户轻触行以显示后续屏幕。手表应用程序使用**segues**以类似于iOS应用程序的方式从一个屏幕移动到另一个屏幕。
- en: 'The first step will involve creating a new controller file called `RepositoryListController.swift`.
    This will be used to hold the `RepositoryListController` and `RepositoryRowController`
    classes, in a very similar way to the existing `InterfaceController`. As with
    the other view, there will be a table to store the rows, and each row will have
    a `name` label:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步将涉及创建一个新的控制器文件，名为`RepositoryListController.swift`。这将用于存储`RepositoryListController`和`RepositoryRowController`类，与现有的`InterfaceController`非常相似。与其他视图一样，将有一个表格来存储行，并且每一行都将有一个`name`标签：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Tip
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Don't forget to add the `RepositoryListController.swift` file to the `RepositoryBrowserWatch
    Extension` target, or it will not be possible to use that as the implementation
    class.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记将`RepositoryListController.swift`文件添加到`RepositoryBrowserWatch Extension`目标中，否则将无法将其用作实现类。
- en: Once these classes have been created, the `Interface.storyboard` can be opened
    and a new **Interface Controller** dragged in from the object library. This will
    create an empty screen, which can have other objects added.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了这些类，就可以打开 `Interface.storyboard` 并从对象库中拖入一个新的 **Interface Controller**。这将创建一个空白的屏幕，可以添加其他对象。
- en: Tip
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Ensure that the **Interface Controller** is selected, instead of the **Glance
    Interface Controller** or the **Notification Interface Controller** as these are
    used for different purposes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 确保选择的是 **Interface Controller**，而不是 **Glance Interface Controller** 或 **Notification
    Interface Controller**，因为这些用于不同的目的。
- en: Once the interface controller has been created, drag a **Table** from the object
    library onto the interface controller, and then drag a **Label** from the object
    library into the row placeholder in the same way as in the previous interface
    controller example.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了界面控制器，从对象库中拖动一个 **Table** 到界面控制器，然后以与上一个界面控制器示例相同的方式，从对象库中拖动一个 **Label**
    到行占位符。
- en: The interface controller will need to be updated to point to the `RepositoryListController`
    class; this can be done by selecting the interface controller and going to the
    **Identity Inspector** as before. Once the `RepositoryListController` implementation
    is defined, press *Control* and drag it from the interface controller icon to
    the table and wire it to the `repositoriesTable`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 界面控制器需要更新以指向 `RepositoryListController` 类；这可以通过选择界面控制器并像之前一样转到 **Identity Inspector**
    来完成。一旦定义了 `RepositoryListController` 实现，按 *Control* 并从界面控制器图标拖动到表格，并将其连接到 `repositoriesTable`。
- en: Tip
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: These connections are made in the same way as they were for the `usersTable`
    in the previous section.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这些连接与上一节中 `usersTable` 的连接方式相同。
- en: The row placeholder's class can be defined by selecting the placeholder under
    the **Repositories Table** in the document outline, and then setting the row controller's
    identity to `repository` in the **Attributes Inspector**. This will allow the
    repository row placeholder to connect the name attribute to the label in the scene.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 行占位符的类可以通过在文档大纲中选择 **Repositories Table** 下的占位符，然后在 **Attributes Inspector**
    中将行控制器的身份设置为 `repository` 来定义。这将允许仓库行占位符将名称属性连接到场景中的标签。
- en: The last connection is to add a **segue** from the users screen to the repositories
    screen. Press *Control* and drag from the **user** row in the **Users Table**
    to the repository list controller, and in the popup, select a **Push Segue**.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个连接是将从用户屏幕到仓库屏幕添加一个 **segue**。按 *Control* 并从 **Users Table** 中的 **user**
    行拖动到仓库列表控制器，并在弹出窗口中选择 **Push Segue**。
- en: 'The final connection will look like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的连接将看起来像这样：
- en: '![Responding to user interaction](img/00108.jpeg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![响应用户交互](img/00108.jpeg)'
- en: When the user is selected in the first screen, the second screen should slide
    over. At the moment this will be empty but the repositories will be populated
    in the next section.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在第一个屏幕中被选中时，第二个屏幕应该滑过。目前这将是空的，但在下一节中会填充仓库。
- en: Adding context and showing repositories
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加上下文并显示仓库
- en: To pass data from one screen to another requires a context to be set. Each `WKInterface`
    screen has an `awakeWithContext` function that can be used to pass an arbitrary
    object into the screen when it is displayed. This can be used to supply a user
    object, which in turn can be used to look up a set of repositories.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要从一个屏幕传递数据到另一个屏幕，需要设置一个上下文。每个 `WKInterface` 屏幕都有一个 `awakeWithContext` 函数，可以在屏幕显示时将任意对象传递到屏幕中。这可以用来提供一个用户对象，进而可以用来查找一组仓库。
- en: 'The first element is setting the context object when transitioning out of a
    screen. In the `InterfaceController` class, add a new method `contextForSegueWithIdentifier`,
    as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个元素是在从屏幕过渡出去时设置上下文对象。在 `InterfaceController` 类中添加一个新方法 `contextForSegueWithIdentifier`，如下所示：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now when the `RepositoryListController` is displayed, the currently-selected
    user will be passed through. To receive the object, create an `awakeWithContext`
    method in the `RepositoryListController` class, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当 `RepositoryListController` 显示时，当前选定的用户将被传递。为了接收对象，在 `RepositoryListController`
    类中创建一个 `awakeWithContext` 方法，如下所示：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tip
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: This will allow the code to be debugged at this point to verify that the object
    is being passed through as expected.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许在此处调试代码，以验证对象是否按预期传递。
- en: 'Displaying a list of repositories requires using the API to generate a list
    of data, creating the appropriate number of rows, and then setting the row contents
    as before. This can be implemented by updating the `awakeWithContext` method in
    the `RepositoryListController`, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 显示仓库列表需要使用API生成数据列表，创建适当数量的行，然后设置行内容，就像之前一样。这可以通过更新`RepositoryListController`中的`awakeWithContext`方法来实现，如下所示：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now when the watch application is run, and a user selected, a list of repositories
    should be populated in the second screen:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当手表应用程序运行时，如果用户选择了一个仓库，第二个屏幕应该填充了仓库列表：
- en: '![Adding context and showing repositories](img/00106.jpeg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![添加上下文和显示仓库](img/00106.jpeg)'
- en: Adding a detail screen
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加详细屏幕
- en: The final part of the watch application is to create a modal screen that is
    similar to the `DetailViewController` in the iOS application. When the user selects
    a repository, details about the repository should be presented modally.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 手表应用程序的最后一部分是创建一个类似于iOS应用程序中`DetailViewController`的模态屏幕。当用户选择一个仓库时，应该以模态方式展示仓库的详细信息。
- en: 'This will be implemented with a new `RepositoryController.swift` file, which
    will contain a `WKInterfaceController` and have four labels that can be wired
    up in the interface:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这将通过一个新的`RepositoryController.swift`文件来实现，该文件将包含一个`WKInterfaceController`并具有四个可以在界面中连接的标签：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Tip
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Don't forget to add the `RepositoryController.swift` file to the `RepositoryBrowserWatch
    Extension` target, or it will not be possible to use that as the implementation
    class.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记将`RepositoryController.swift`文件添加到`RepositoryBrowserWatch Extension`目标中，否则无法将其用作实现类。
- en: To add the screen, open the `Interface.storyboard` and drag another **Interface
    Controller** from the object library onto the canvas. In the **Identity Inspector**,
    set `RepositoryController` as the **Class** type, which will allow the labels
    to be wired up subsequently.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加屏幕，打开`Interface.storyboard`，从对象库中拖动另一个**界面控制器**到画布上。在**身份检查器**中，将`RepositoryController`设置为**类**类型，这将允许随后连接标签。
- en: Drag four **Label** objects into the watch interface. They will line up automatically
    in a row, one under each other. These can be given placeholder text of `Repo`,
    `Issues`, `Watchers`, and `Forks`—although the content of these will be changed
    programmatically. By dragging and dropping from the **Repository Controller**
    onto each of the labels, wire up the connections for the outlets so that they
    can be controlled programmatically.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 将四个**标签**对象拖入观察界面。它们将自动排成一行，一个接一个。这些可以赋予占位文本为`Repo`、`Issues`、`Watchers`和`Forks`——尽管这些内容将程序化地更改。通过从**仓库控制器**拖动并放置到每个标签上，为输出连接设置线路，以便它们可以程序化控制。
- en: 'Finally, wire up the segue from the repository list controller so that when
    the **repository** row controller under the **Repositories Table** is selected,
    a **Modal** selection segue is chosen. The completed set of connections should
    look like this in Xcode:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，连接从仓库列表控制器到过渡，以便当在**仓库表**下选择**仓库**行控制器时，选择**模态**选择过渡。在Xcode中，完成的连接应如下所示：
- en: '![Adding a detail screen](img/00109.jpeg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![添加详细屏幕](img/00109.jpeg)'
- en: At this point the application can be tested, and selecting a repo should transition
    into the new screen although the correct content won't be displayed yet.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，应用程序可以进行测试，选择一个仓库应该过渡到新屏幕，尽管正确的内容尚未显示。
- en: Populating the detail screen
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 填充详细屏幕
- en: 'To wire up the labels in the detail screen, a similar process has to be followed
    for the previous screen: the context needs to be set from the transitioning screen,
    and then the data needs to be populated into the receiving screen.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要在详细屏幕中连接标签，需要遵循与上一个屏幕类似的过程：需要从过渡屏幕设置上下文，然后将数据填充到接收屏幕中。
- en: In the `RepositoryListController`, the selected repository information needs
    to be passed on through the `contextForSegueWithIdentifier` method. However, unlike
    the `users` list (which is persisted in the `ExtensionDelegate`), there is no
    such stored repositories data list. As a result, it is necessary to persist a
    temporary copy of the repositories when the screen is woken.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在`RepositoryListController`中，需要通过`contextForSegueWithIdentifier`方法传递所选仓库的信息。然而，与`users`列表（在`ExtensionDelegate`中持久化）不同，没有这样的存储仓库数据列表。因此，当屏幕唤醒时，有必要持久化仓库的临时副本。
- en: 'Modify the `awakeWithContext` method of the `RepositoryListController` class
    to store entries in the `repos` property so that when one is selected it can be
    used to set the context when transitioning out of the screen:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`RepositoryListController`类的`awakeWithContext`方法，以便将条目存储在`repos`属性中，以便在选中时可以用于在退出屏幕时设置上下文：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now when the repository is selected, the key/value pairs will be passed on through
    the cached content from before.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当选择存储库时，键/值对将通过之前缓存的內容传递。
- en: 'The last step in filling in the details screen is to use this context object
    to set up the labels. In the `RepositoryController` class, add an `awakeWithContext`
    method that receives the key/value dictionary, and uses the fields to display
    information about the repository:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 填写详细屏幕的最后一步是使用此上下文对象来设置标签。在`RepositoryController`类中，添加一个`awakeWithContext`方法，该方法接收键/值字典，并使用字段显示有关存储库的信息：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now when the application is run, the user should be able to step through each
    of the three screens to see the content.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当运行应用时，用户应该能够逐个浏览三个屏幕以查看内容。
- en: '![Populating the detail screen](img/00110.jpeg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![填充详细屏幕](img/00110.jpeg)'
- en: Best practice for watch applications
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手表应用的最佳实践
- en: As watches are very low-powered devices with limited networking, care should
    be taken to reduce networking where possible. The example application shown here
    (using several REST-based calls to a backend server) is sending and receiving
    more data than needed; if this was being designed as a custom application, then
    the protocol should be minimized to avoid unnecessary data transmission.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于手表是低功耗设备，网络功能有限，因此应尽可能减少网络使用。这里展示的示例应用（使用多个基于REST的调用到后端服务器）发送和接收的数据比所需的多；如果这是一个定制应用，那么应该最小化协议以避免不必要的传输。
- en: The example application also presented user information as a list of text data,
    which may not be the most appropriate way of showing data. Consider other mechanisms
    to present information in a more graphical way where appropriate.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 示例应用还以文本数据列表的形式展示了用户信息，这可能不是展示数据的最佳方式。考虑在适当的情况下使用其他机制以更图形化的方式展示信息。
- en: UI thread considerations
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UI线程注意事项
- en: It is generally bad practice to perform any networking on the main thread, such
    as the lookups for the API, and for the query for a user's repositories. Instead,
    the lookups should be run in a background thread, switching back to the UI thread
    where necessary to perform updates.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在主线程上执行任何网络操作，如API查找和用户仓库查询，通常是不良的做法。相反，查找应该在后台线程中运行，在必要时切换回UI线程以执行更新。
- en: 'For example, in the API lookup for the connection, the connect method looks
    like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在连接的API查找中，connect方法看起来是这样的：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This uses optional initializers to return a `GitHubAPI` whether the network
    connection succeeded or not, but this means that the call has to block before
    it can be used. This means that the `GitHubAPI()` initializer called in the `applicationDidFinishLaunching`
    will be blocking the application''s startup, which is not excellent user experience.
    Instead, it is better to do something like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用可选初始化器来返回`GitHubAPI`，无论网络连接是否成功。但这意味着在可以使用之前，调用必须阻塞。这意味着在`applicationDidFinishLaunching`中调用的`GitHubAPI()`初始化器会阻塞应用的启动，这不是良好的用户体验。相反，最好是这样做：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Adding background threads increases the complexity, but this means that the
    application will start faster. It may be necessary to update the UI initialization
    logic such that the calls to the API are deferred until the network service is
    available, or show other loading progress indicators to give the user feedback
    that something is happening.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 添加后台线程会增加复杂性，但这也意味着应用启动会更快。可能需要更新UI初始化逻辑，以便将API调用推迟到网络服务可用，或者显示其他加载进度指示器，以向用户提供反馈，表明有操作正在进行。
- en: Stored data
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储数据
- en: The user list in the example application only stores a single variable, which
    is hardcoded into the application. Normally, this won't be the case, but the watch
    is not set up for data input. Instead, the companion iOS application should be
    used to define a list of users (with appropriate error checking and interface)
    and then communicate that with the watch application.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 示例应用中的用户列表仅存储一个变量，该变量硬编码到应用中。通常情况下不会是这样，但手表并未设置用于数据输入。相反，应使用配套的iOS应用来定义用户列表（带有适当的错误检查和界面），然后与手表应用进行通信。
- en: There are two ways of achieving this. The best way is to use the iCloud infrastructure
    and have the document updated on the iOS device and then mirrored to the watch
    automatically. This will allow the user to transition to new iOS devices or watches
    in the future without needing to recreate the list.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种实现方式。最好的方法是使用iCloud基础设施，并在iOS设备上更新文档，然后自动镜像到手表。这将使用户在未来过渡到新的iOS设备或手表时无需重新创建列表。
- en: An alternative way is to send messages between the watch and the iOS device
    using the `WatchConnectivity` module and the `WCSession` type. This provides a
    singleton that is accessible through the `WCSession.defaultSession()`, which can
    be used to send and receive messages between the iOS device and the paired watch.
    Please note that the session may not be supported, so it should be checked with
    `session.isSupported()` first; and if it is, then it must be activated with `session.activate()`
    before any messages can be sent or received. Incoming messages are routed to the
    associated `delegate`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用`WatchConnectivity`模块和`WCSession`类型在手表和iOS设备之间发送消息。这提供了一个单例，可以通过`WCSession.defaultSession()`访问，可以用来在iOS设备和配对的手表之间发送和接收消息。请注意，会话可能不受支持，因此应首先使用`session.isSupported()`进行检查；如果是的话，则必须在发送或接收任何消息之前使用`session.activate()`激活它。传入的消息会被路由到相关的`delegate`。
- en: The watch can also persist data using the session's `watchDirectoryURL`, which
    returns the location that temporary data can be written to. This can be used to
    add additional information which is loaded at startup. For example, the GitHubAPI
    could cache the API once it has been initially retrieved, then used for subsequent
    requests, and reloaded automatically if necessary.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 手表还可以使用会话的`watchDirectoryURL`持久化数据，该URL返回可以写入临时数据的位置。这可以用来添加在启动时加载的附加信息。例如，GitHubAPI可以在最初检索后缓存API，然后用于后续请求，并在必要时自动重新加载。
- en: Appropriate use of complications and glances
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合理使用复杂功能和快速查看
- en: The watch's interface predominantly uses different types of widgets for different
    interactions. A *complication* is a small utility widget that's displayed on the
    screen of the watch face (for example, the rising sun or a stopwatch timer). A
    *notification* is a small brief information update (similar to the notifications
    on iOS such as an incoming message), which can be used to perform simple actions
    (such as responding with a yes/no/maybe) or to launch the full application. A
    *glance* is a simple location-derived item that may give the user a way of telling
    them that something is nearby when they raise their wrist.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 手表的界面主要使用不同类型的控件来处理不同的交互。一个**复杂功能**是一个显示在手表表盘屏幕上的小型实用控件（例如，升起的太阳或计时器）。一个**通知**是一个简短的信息更新（类似于iOS上的通知，如收到的消息），可以用来执行简单的操作（如回答是/否/可能）或启动完整的应用程序。一个**快速查看**是一个简单的基于位置的项目，当用户抬起手腕时，可能会告诉用户附近有什么东西。
- en: Depending on the type of application created, there may be appropriate ways
    that these can be used in order to give the user specific information on demand.
    However, they shouldn't be used just for the sake of using them; if they aren't
    going to provide any useful information, they should not be used.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 根据创建的应用程序类型，可能会有适当的方法来使用这些功能，以便在需要时向用户提供特定信息。然而，它们不应该仅仅为了使用而使用；如果它们不会提供任何有用的信息，则不应使用。
- en: There are also other ways of interacting with the application; for example,
    watchOS 2 has support for direct interaction of the digital crown and force pushes.
    For more information, see the Apple Watch Human Interface Guidelines.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 与应用程序交互还有其他方式；例如，watchOS 2支持直接与数字表冠和强推进行交互。有关更多信息，请参阅Apple Watch人机界面指南。
- en: Summary
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Watch applications can run code in the same way that they run on an iOS device
    although the way in which they are uploaded to the watch is slightly different.
    Running code on the simulator is very different to running on a real device; the
    network and processor are much more limited than will be expected for a desktop
    class machine (or even an iOS device). As a result, testing on a real device is
    essential in order to test the full experience.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 与iOS设备上的运行方式相同，手表应用程序也可以运行代码，尽管它们上传到手表的方式略有不同。在模拟器上运行代码与在真实设备上运行非常不同；网络和处理器比桌面级机器（甚至iOS设备）预期的要有限得多。因此，在实际设备上进行测试对于测试完整体验是必不可少的。
- en: This chapter presented how watch applications and extensions are built, how
    they are packaged in the form of watch extensions and watch apps, and how they
    can share code with a parent application to avoid code duplication. The watch
    interface demonstrated how to transition between screens using segues to implement
    a watch extension of the iOS application that was created in the previous chapter.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了如何构建手表应用和扩展，如何将它们打包成手表扩展和手表应用的形式，以及它们如何与父应用共享代码以避免代码重复。手表界面演示了如何使用segues在屏幕之间切换，以实现上一章创建的iOS应用的手表扩展。
- en: Appendix A. References to Swift-related Websites, Blogs, and Notable Twitter
    Users
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录A. 对Swift相关网站、博客和知名Twitter用户的引用
- en: Learning any language initially focuses on the syntax and semantics of the language,
    but it quickly moves on to learning the suite of both standard and additional
    libraries that allow programmers to be productive. A single book cannot hope to
    list all possible libraries that will be needed; this book is intended to be the
    start of a learning journey.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 学习任何语言最初都集中在语言的语法和语义上，但很快就会转向学习标准库和附加库的套件，这些库使程序员能够高效地工作。一本书不可能列出所有可能需要的库；这本书旨在成为学习旅程的开始。
- en: For further reading, this appendix presents a number of additional resources
    that may be useful to the reader in order to continue this journey. In addition,
    look out for other books by Packt Publishing that present different aspects of
    Swift. This list of resources is necessarily incomplete; new resources will become
    available after the publication of this book, but you may be able to find new
    developments as they occur by following the feeds and posts of the resources given
    here.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步阅读，本附录提供了一些额外的资源，这些资源可能对读者继续这一旅程有所帮助。此外，请注意Packt Publishing出版的其他书籍，这些书籍展示了Swift的不同方面。这个资源列表必然是不完整的；在本书出版后，新的资源将会出现，但您可以通过关注这里提供的资源的订阅和帖子来找到新的发展。
- en: Language
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语言
- en: 'The Swift language is developed by Apple, and a number of documents are available
    from the Swift developer page at [https://developer.apple.com/swift/](https://developer.apple.com/swift/).
    This includes a language reference guide and an introduction to the standard library:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Swift语言由苹果公司开发，可以在[https://developer.apple.com/swift/](https://developer.apple.com/swift/)的Swift开发者页面上找到许多文档。这包括语言参考指南和标准库的介绍：
- en: The Swift programming language can be found at [https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/)
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift编程语言可以在[https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/)找到
- en: The Swift standard library reference can be found at [https://developer.apple.com/library/ios/documentation/General/Reference/SwiftStandardLibraryReference/](https://developer.apple.com/library/ios/documentation/General/Reference/SwiftStandardLibraryReference/)
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift标准库参考可以在[https://developer.apple.com/library/ios/documentation/General/Reference/SwiftStandardLibraryReference/](https://developer.apple.com/library/ios/documentation/General/Reference/SwiftStandardLibraryReference/)找到
- en: Integrating Swift and Cocoa can be found at [https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/)
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift和Cocoa的集成可以在[https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/)找到
- en: Swifter provides a list of all Swift functions at [http://swifter.natecook.com](http://swifter.natecook.com)
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swifter提供了所有Swift函数的列表，可以在[http://swifter.natecook.com](http://swifter.natecook.com)找到
- en: The Swift language was open sourced in December 2015 and has a new home at [https://swift.org](https://swift.org),
    along with the new Swift blog at [https://swift.org/blog/](https://swift.org/blog/).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Swift语言在2015年12月开源，并在[https://swift.org](https://swift.org)有一个新的家，同时还有一个新的Swift博客在[https://swift.org/blog/](https://swift.org/blog/)。
- en: Twitter users
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Twitter用户
- en: 'There are a lot of active Twitter users that use Swift; in many cases posts
    will be marked with the `#swift` hashtag, and can be found at [http://twitter.com/search?q=%23swift](http://twitter.com/search?q=%23swift).
    Popular users that the author follows include (in alphabetical Twitter handle
    name):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多活跃的Twitter用户使用Swift；在许多情况下，帖子会被标记为`#swift`标签，可以在[http://twitter.com/search?q=%23swift](http://twitter.com/search?q=%23swift)找到。作者关注的流行用户包括（按Twitter昵称字母顺序）：
- en: '`@AirspeedSwift:` This twitter has a good selection of tweets and retweets
    of Swift-related subjects'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@AirspeedSwift:` 这个推特有关于Swift相关主题的好选择和转推'
- en: '`@ChrisEidhof`: This is author of the *Functional Swift* book and `@objcio`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ChrisEidhof`: 这是《Functional Swift》书籍的作者和`@objcio`的作者'
- en: '`@CodeWithChris`: This twitter is a collection of tutorials on iOS programming'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@CodeWithChris`: 这个推特是关于iOS编程教程的集合'
- en: '`@CodingInSwift:` This twitter contains cross-posts by a collection of Swift
    resources'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@CodingInSwift:` 这个推特包含了一系列Swift资源的跨帖'
- en: '`@CompileSwift`: This twitter contains posts on Swift'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@CompileSwift`: 这个推特包含关于Swift的文章'
- en: '`@cwagdev`: Chris Wagner writes some of the iOS tutorials with Ray Wenderlich'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@cwagdev`: 克里斯·沃格德撰写了一些与雷·温德利希合作的iOS教程'
- en: '`@FunctionalSwift`: This is a selection of functional snippets, along with
    a Functional Swift book'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@FunctionalSwift`: 这是一系列功能片段的选择，以及一本《Functional Swift》书籍'
- en: '`@LucasDerraugh`: This is the creator of video tutorials on YouTube'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@LucasDerraugh`: 这是YouTube上视频教程的创作者'
- en: '`@NatashaTheRobot:` This twitter contains a great summary of what''s happening,
    along with newsletters and cross references'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@NatashaTheRobot:` 这个推特包含了对正在发生的事情的精彩总结，以及新闻简报和交叉引用'
- en: '`@nnnnnnnn`: Nate Cook, who reviewed an earlier version of this book and provides
    the Swifter list just mentioned'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@nnnnnnnn`: 内特·库克，他审阅了本书的早期版本，并提供了刚刚提到的Swifter列表'
- en: '`@PracticalSwift`: This is a good collection of blog posts talking about the
    Swift language'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@PracticalSwift`: 这是一个关于Swift语言的博客文章好集合'
- en: '`@rwenderlich`: Ray Wenderlich has many posts relating to iOS development;
    a wealth of information and more recently Swift topics as well'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@rwenderlich`: 雷·温德利希有许多与iOS开发相关的文章；信息量丰富，最近还涉及Swift话题'
- en: '`@SketchyTech`: This is a collection of blog posts on Swift'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@SketchyTech`: 这是关于Swift的博客文章集合'
- en: '`@SwiftCastTV`: These are video tutorials of Swift'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@SwiftCastTV`: 这些是Swift的视频教程'
- en: '`@SwiftEssentials`: This is the twitter feed for this book'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@SwiftEssentials`: 这是本书的推特动态'
- en: '`@SwiftLDN`: This Twitter posts Swift meetups based in London, also invites
    great Swift talks and presenters'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@SwiftLDN`: 这个推特发布基于伦敦的Swift聚会，也邀请了一些优秀的Swift演讲者和演示者'
- en: 'In addition to the Swift-focused Twitter users, there are a number of other
    Cocoa (Objective-C) developers who blog regularly on topics relating to the iOS
    and OS X platforms. Given that any Objective-C framework can be integrated into
    a Swift app (and vice versa), quite often, there will be useful information from
    reading these posts:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 除了专注于Swift的推特用户外，还有许多其他Cocoa（Objective-C）开发者定期在iOS和OS X平台相关主题上写博客。鉴于任何Objective-C框架都可以集成到Swift应用中（反之亦然），阅读这些帖子通常会提供有用的信息：
- en: '`@Cocoanetics`: Oliver Drobnik writes about iOS and provides training'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Cocoanetics`: 奥利弗·德罗尼克撰写关于iOS并提供培训'
- en: '`@CocoaPods`: CocoaPods is a dependency management system for Objective-C frameworks
    (pods) and is being extended into the Swift domain'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@CocoaPods`: CocoaPods是一个Objective-C框架（库）的依赖管理系统，现在正在扩展到Swift领域'
- en: '`@Mattt`: Mattt Thompson writes about many iOS subjects, is the author of the
    AFNetworking and AlamoFire networking libraries, and who moved to Apple to write
    the Swift package manager'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Mattt`: 马特·汤普森撰写关于许多iOS主题的文章，是AFNetworking和AlamoFire网络库的作者，后来加入了苹果公司编写Swift包管理器'
- en: '`@MikeAbdullah`:Mike Abdullah writes about general iOS development'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@MikeAbdullah`: 迈克·阿卜杜拉撰写关于通用iOS开发的文章'
- en: '`@MikeAsh`: Mike Ash knows everything there is to know, and what he doesn''t
    know, he finds out'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@MikeAsh`: 迈克·阿什知道所有的事情，不知道的事情他会去了解'
- en: '`@MZarra`: Marcus S. Zarra has written a lot about Core Data and synching'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@MZarra`: 马库斯·S·扎拉写过很多关于Core Data和同步的内容'
- en: '`@NSHipster`: This is a collection of assembled iOS and Cocoa posts that are
    organised by Mattt Thompson'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@NSHipster`: 这是马特·汤普森整理的iOS和Cocoa文章集合'
- en: '`@objcio`: This is a monthly publication on Objective-C topics with some Swift'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@objcio`: 这是一个关于Objective-C话题的月度出版物，其中包含一些Swift内容'
- en: '`@PerlMunger`: Matt Long posts about Swift, Cocoa, and iOS'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@PerlMunger`: 马特·朗撰写关于Swift、Cocoa和iOS的文章'
- en: 'The reviewers of this book included:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的审稿人包括：
- en: '`@AnilVrgs`: Anil Varghese'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@AnilVrgs`: 安尼尔·瓦格谢斯'
- en: '`@Ant_Bello`: Antonio Bello'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Ant_Bello`: 安东尼奥·贝洛'
- en: '`@ArvidGerstmann`: Arvid Gerstmann'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ArvidGerstmann`: 阿维德·格斯特曼'
- en: '`@jiaaro`: James Robert'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@jiaaro`: 詹姆斯·罗伯特'
- en: '`@nnnnnnnn`: Nate Cook'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@nnnnnnnn`: 内特·库克'
- en: 'The author''s personal and book twitter accounts are:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 作者的个人和书籍推特账号是：
- en: '`@AlBlue` is the author''s twitter account'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@AlBlue` 是作者的推特账号'
- en: '`@SwiftEssentials` is the book''s twitter account'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@SwiftEssentials` 是这本书的推特账号'
- en: Meetups such as `@SwiftLdn` keep a track of interesting Swift writers in a Twitter
    list at [https://twitter.com/SwiftLDN/lists/swift-writers/members](https://twitter.com/SwiftLDN/lists/swift-writers/members),
    which may have more up-to-date recommendations than this section, as well as the
    Ray Wenderlich team at [https://twitter.com/rwenderlich/lists/raywenderlich-com-team/members](https://twitter.com/rwenderlich/lists/raywenderlich-com-team/members).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 `@SwiftLdn` 的聚会跟踪有趣的 Swift 作者在 Twitter 列表 [https://twitter.com/SwiftLDN/lists/swift-writers/members](https://twitter.com/SwiftLDN/lists/swift-writers/members)
    中，这可能比本节有更更新的推荐，以及 Ray Wenderlich 团队 [https://twitter.com/rwenderlich/lists/raywenderlich-com-team/members](https://twitter.com/rwenderlich/lists/raywenderlich-com-team/members)。
- en: Blogs and tutorial sites
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 博客和教程网站
- en: 'There are a number of blogs that cover Swift and related technologies. Here
    are a selection that you may be interested in:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多博客涵盖了 Swift 和相关技术。以下是一些你可能感兴趣的精选：
- en: '[https://developer.apple.com/swift/blog/](https://developer.apple.com/swift/blog/)
    is the official Apple Swift blog'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://developer.apple.com/swift/blog/](https://developer.apple.com/swift/blog/)
    是官方的 Apple Swift 博客'
- en: '[http://airspeedvelocity.net](http://airspeedvelocity.net) is the blog for
    `@AirspeedSwift`'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://airspeedvelocity.net](http://airspeedvelocity.net) 是 `@AirspeedSwift`
    的博客'
- en: '[http://alblue.bandlem.com/Tag/swift/](http://alblue.bandlem.com/Tag/swift/)
    is the author''s blog on Swift'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://alblue.bandlem.com/Tag/swift/](http://alblue.bandlem.com/Tag/swift/)
    是作者关于 Swift 的博客'
- en: '[http://mikeabdullah.net](http://mikeabdullah.net) is Mike Abdullah''s blog'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://mikeabdullah.net](http://mikeabdullah.net) 是 Mike Abdullah 的博客'
- en: '[http://mikeash.com](http://mikeash.com) writes the Friday Q&A series on all
    things iOS and OS X'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://mikeash.com](http://mikeash.com) 撰写了关于 iOS 和 OS X 的周五问答系列'
- en: '[http://natecook.com/blog/tags/swift/](http://natecook.com/blog/tags/swift/)
    is Nate Cook''s blog on Swift'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://natecook.com/blog/tags/swift/](http://natecook.com/blog/tags/swift/)
    是 Nate Cook 的 Swift 博客'
- en: '[http://nshipster.com](http://nshipster.com) is the blog for `@NSHipster`'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://nshipster.com](http://nshipster.com) 是 `@NSHipster` 的博客'
- en: '[http://objc.io](http://objc.io) is the blog for `@objcio`'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://objc.io](http://objc.io) 是 `@objcio` 的博客'
- en: '[http://practicalswift.com](http://practicalswift.com) is collected by `@PracticalSwift`'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://practicalswift.com](http://practicalswift.com) 由 `@PracticalSwift`
    收集'
- en: '[http://sketchytech.blogspot.co.uk](http://sketchytech.blogspot.co.uk) is a
    collected blog of Swift articles by `@SketychTech`'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://sketchytech.blogspot.co.uk](http://sketchytech.blogspot.co.uk) 是由 `@SketychTech`
    收集的 Swift 文章博客'
- en: '[http://swiftessentials.org](http://swiftessentials.org) is the companion site
    for this book, along with the repository at [https://github.com/alblue/com.packtpub.swift.essentials/](https://github.com/alblue/com.packtpub.swift.essentials/)'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://swiftessentials.org](http://swiftessentials.org) 是本书的配套网站，以及位于 [https://github.com/alblue/com.packtpub.swift.essentials/](https://github.com/alblue/com.packtpub.swift.essentials/)
    的仓库'
- en: '[http://swiftnews.curated.co](http://swiftnews.curated.co) is collected by
    `@NatashaTheRobot`'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://swiftnews.curated.co](http://swiftnews.curated.co) 由 `@NatashaTheRobot`
    收集'
- en: '[http://www.cimgf.com](http://www.cimgf.com) presents a collection of topics
    on Cocoa, by Marcus S Zarra and others'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.cimgf.com](http://www.cimgf.com) 展示了 Marcus S Zarra 和其他人关于 Cocoa
    的主题集合'
- en: '[http://www.raywenderlich.com](http://www.raywenderlich.com) has a collection
    of tutorials about iOS development, including both Cocoa and Swift'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.raywenderlich.com](http://www.raywenderlich.com) 收集了关于 iOS 开发的教程，包括
    Cocoa 和 Swift'
- en: Meetups
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Meetups
- en: A number of local iOS developer groups existed before Swift was created; they
    have since been supplanted by Swift-specific groups. These will of course vary
    by geographic location, but a few meetup sites exist, such as EventBrite at [http://www.eventbrite.co.uk](http://www.eventbrite.co.uk),
    and Meetup at [http://www.meetup.com](http://www.meetup.com).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 创建之前，存在许多本地的 iOS 开发者小组；它们随后被 Swift 特定的群体所取代。这些小组当然会因地理位置而异，但存在一些聚会网站，例如
    EventBrite 在 [http://www.eventbrite.co.uk](http://www.eventbrite.co.uk)，以及 Meetup
    在 [http://www.meetup.com](http://www.meetup.com)。
- en: There are also likely to be Twitter groups or meetups near you; for example,
    in London, there is `@SwiftLDN` at [https://twitter.com/SwiftLDN](https://twitter.com/SwiftLDN)
    who have regular meetings listed at [http://www.meetup.com/swiftlondon/](http://www.meetup.com/swiftlondon/).
    In New York, the [http://www.meetup.com/NYC-Swift-Developers/](http://www.meetup.com/NYC-Swift-Developers/)
    group is fairly active. In San Francisco, both [http://www.meetup.com/swift-language/](http://www.meetup.com/swift-language/)
    and [http://www.meetup.com/San-Francisco-SWIFT-developers/](http://www.meetup.com/San-Francisco-SWIFT-developers/)
    are active.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你附近可能也有Twitter群组或聚会；例如，在伦敦，有`@SwiftLDN`在[https://twitter.com/SwiftLDN](https://twitter.com/SwiftLDN)，他们定期在[http://www.meetup.com/swiftlondon/](http://www.meetup.com/swiftlondon/)列出会议。在纽约，[http://www.meetup.com/NYC-Swift-Developers/](http://www.meetup.com/NYC-Swift-Developers/)群组相当活跃。在旧金山，[http://www.meetup.com/swift-language/](http://www.meetup.com/swift-language/)和[http://www.meetup.com/San-Francisco-SWIFT-developers/](http://www.meetup.com/San-Francisco-SWIFT-developers/)都是活跃的。
- en: Afterword
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 后记
- en: '*A journey of a thousand miles begins with a single step*. Your journey to
    writing great Swift applications has just begun. As with any journey, traveling
    companions can provide support, assistance, and encouragement; and many of the
    companions given here can provide connections to many more. I hope you enjoy your
    journey.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '*千里之行，始于足下*。你编写优秀的Swift应用程序的旅程才刚刚开始。就像任何旅程一样，旅伴可以提供支持、帮助和鼓励；这里提到的许多旅伴可以为你提供通往更多资源的连接。我希望你享受你的旅程。'
