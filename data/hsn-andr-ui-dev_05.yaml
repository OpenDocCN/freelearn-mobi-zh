- en: Binding Data to Widgets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据绑定到小部件
- en: So far, you've been copying the data from your data model into your presentation
    layer by hand, and then copying it back as well. This shifting data back and forth
    between stateful widgets is something that you always need to do at some level.
    Where and how the data is copied can change, but it has to be done to make applications
    work. In this chapter, we'll look at a system provided by Android called data
    binding. **Data binding** provides an alternative to the copying back and forth
    of data, but also opens several other design opportunities to allow more reuse
    of code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你一直是手动将数据从数据模型复制到你的表示层，然后再将其复制回来。这种在具有状态的控件之间来回移动数据的行为，在某种程度上是你始终需要做的。数据复制的位置和方式可能会改变，但为了使应用程序工作，这必须完成。在本章中，我们将探讨
    Android 提供的一个名为数据绑定的系统。**数据绑定**为数据的来回复制提供了一种替代方案，同时也为代码的更多重用打开了几个其他设计机会。
- en: Data binding offers you a way to dramatically reduce the amount of boiler-plate
    code in your application, while remaining type-safe and providing excellent performance.
    The data binding engine allows you to provide user interface logic that is clearly
    separated from the layout resources, and can be easily reused by many screens
    in the application, while reducing the complexity of both the application code
    and the layout resource files.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 数据绑定为你提供了一种方法，可以显著减少应用程序中的样板代码量，同时保持类型安全并提供出色的性能。数据绑定引擎允许你提供用户界面逻辑，该逻辑与布局资源明显分离，并且可以很容易地由应用程序中的许多屏幕重用，同时简化应用程序代码和布局资源文件的复杂性。
- en: 'In this chapter, we''ll look at the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Why data binding exists
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据绑定存在的理由
- en: How to write data-bound layouts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写数据绑定布局
- en: How to use data binding in an MVP design
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 MVP 设计中使用数据绑定
- en: Reactive programming and your data model
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式编程和你的数据模型
- en: How to use data binding in Activities, Fragments, and widgets
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 Activity、Fragment 和小部件中使用数据绑定
- en: Exploring data models and widgets
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索数据模型和小部件
- en: In theory, the widgets can directly reference the memory that they are manipulating
    by holding points to the data, rather than copying the data back and forth, but
    more often than not, it doesn't make sense to use the same data format for storage
    and for editing.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，小部件可以直接通过持有数据指针来引用它们正在操作的记忆，而不是来回复制数据，但大多数情况下，使用相同的数据格式来存储和编辑是没有意义的。
- en: 'Take strings of text for example; the best way to store a string is as a character
    array; whenever you need to send the text anywhere, over the network or to a display,
    you can simply read from the first character until the last one, and each one
    can be transmitted as-is. For example, "Hello World" can be stored as the string
    length followed by each of the characters:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以文本字符串为例；存储字符串的最佳方式是作为字符数组；每次需要将文本发送到任何地方，无论是通过网络还是显示，都可以简单地从第一个字符读取到最后的字符，每个字符都可以原样传输。例如，"Hello
    World" 可以存储为字符串长度，后跟每个字符：
- en: '![](img/0ddc7071-e47a-498d-8e0c-fb1680324ca4.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0ddc7071-e47a-498d-8e0c-fb1680324ca4.jpg)'
- en: 'This is not a good way to store a string that is being edited; however, for
    editing, it''s best to have some buffer space around the cursor to avoid having
    to copy large amounts of data back and forth as the user types and corrects themselves.
    For example, if the user places their cursor right after the word "Hello", the
    same array might look like this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是存储正在编辑的字符串的好方法；然而，对于编辑来说，最好在光标周围留有缓冲空间，以避免在用户输入和更正时需要来回复制大量数据。例如，如果用户将光标放在单词
    "Hello" 之后，相同的数组可能看起来像这样：
- en: '![](img/fdc672fc-3230-4556-852b-443d2c376cb1.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fdc672fc-3230-4556-852b-443d2c376cb1.jpg)'
- en: This tension between how data should be stored when it'll only be read, and
    how it should be edited, is an important part of why modern user-interface widgets
    tend to be complex pieces of machinery in their own right. They don't just need
    to look pretty; they need to be fast, and for that, they need to internally represent
    the data in a way that suits their implementation best. As a result, instead of
    being able to have an `EditText` widget just manipulate an array of characters,
    we're forced to copy the strings in and out of its internal structures, as you've
    been doing so by hand thus far.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这种在数据只读时应如何存储，以及编辑时应如何存储之间的张力，是现代用户界面小部件往往成为复杂机械的重要原因之一。它们不仅需要看起来漂亮，还需要快速，为此，它们需要在内部以最适合其实现的方式表示数据。因此，我们无法让`EditText`小部件仅仅操作一个字符数组，我们被迫像你迄今为止手动做的那样，在内部结构中复制和粘贴字符串。
- en: The data binding system in Android allows you to reference your object model
    directly from your layout files, and then generate all the Java code required
    to wire the object model to the widgets. This system is called data-binding, and
    its core classes can be found in the `android.databinding` package. The data binding
    system also allows for *reactive programming*; when the data model is changed,
    it can directly reflect in the user interface widgets, allowing the application
    to keep what is on the screen up to date without having to explicitly update the
    widgets. The data binding system is also completely type-safe, because it generates
    all the code when your application is compiled, so any type errors are produced
    then and there, rather than possibly at runtime, where your users might see them.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Android中的数据绑定系统允许你直接从布局文件中引用你的对象模型，然后生成连接对象模型到小部件所需的全部Java代码。这个系统被称为数据绑定，其核心类可以在`android.databinding`包中找到。数据绑定系统还支持*响应式编程*；当数据模型发生变化时，它可以直接反映在用户界面小部件上，使得应用无需显式更新小部件就能保持屏幕上的内容更新。数据绑定系统也是完全类型安全的，因为它在应用编译时生成所有代码，所以任何类型错误都会立即产生，而不是可能在运行时产生，那时用户可能会看到它们。
- en: The Observer pattern
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者模式
- en: 'The data binding framework in Android makes use of the **Observer pattern**
    to allow for *reactive programming*. Any object that is referenced by a layout
    file that implements the `Observable` interface is watched, and when it signals
    that it has changed, the user interface updates accordingly. As the data binding
    system can be used on any attribute or setter of any widget, this means that you
    can control far more than just the content or state of the user interface. You
    can control whether widgets are visible or invisible, and you can control which
    image is used for the background of a widget. At its core, the Observer pattern
    looks like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Android中的数据绑定框架利用**观察者模式**来实现*响应式编程*。任何由实现`Observable`接口的布局文件引用的对象都会被监视，当它发出已更改的信号时，用户界面会相应地更新。由于数据绑定系统可以用在任何小部件的任何属性或设置器上，这意味着你可以控制的不仅仅是用户界面内容或状态。你可以控制小部件是可见还是不可见，还可以控制用于小部件背景的图像。在核心上，观察者模式看起来是这样的：
- en: '![](img/2941af8c-4d23-493f-971f-51385c6399cd.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2941af8c-4d23-493f-971f-51385c6399cd.jpg)'
- en: 'In the Android Observer pattern, the data model classes expose themselves as
    Observable by implementing the `android.databinding.Observable` interface and
    notifying a list of event-listeners (observers) of any changes to their state.
    Android provides several convenience classes that make implementing this pattern
    much easier. There are three ways in which you can implement this pattern for
    Android:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android观察者模式中，数据模型类通过实现`android.databinding.Observable`接口并通知一系列事件监听器（观察者）其状态的变化来暴露自己。Android提供了几个便利类，使得实现这个模式变得容易得多。你可以通过以下三种方式在Android中实现这个模式：
- en: Implement Observable in your object model
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的对象模型中实现可观察模型
- en: Implement an Observable model on top of your object model
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的对象模型之上实现一个可观察模型
- en: Implement Observable in a presentation layer
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在表示层实现可观察模型
- en: 'Let''s take a look at these three ways in detail:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看这三种方法：
- en: '**Implementing Observable directly in your object model** is common, but has
    the side effect of polluting your object model with the Observable pattern and
    Android classes that will effectively stop you from using the same code base in
    other parts of the system (for example, on the server side). This is a good approach
    when your object model code will only ever be used by your Android application.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的对象模型中**直接实现可观察**是常见的，但副作用是使用可观察模式和Android类污染你的对象模型，这实际上会阻止你在系统的其他部分（例如服务器端）使用相同的代码库。当你的对象模型代码仅由你的Android应用程序使用时，这是一个好的方法。
- en: '**Implementing an Observable layer on top of the object model** is sometimes
    a better option, but can also lead to complications; every object referenced through
    the observable layer also needs to be wrapped in an Observable object. This leads
    to much greater complexity in the model implementation, and doesn''t cover changes
    made outside of the Observable layer. This approach is useful when you are generating
    the code for your object model with a tool, or need an additional application-specific
    layer for your Android application code.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在对象模型之上**实现一个可观察层**有时是一个更好的选择，但也可能导致复杂化；通过可观察层引用的每个对象也需要被包裹在一个可观察对象中。这会导致模型实现变得更加复杂，并且无法覆盖在可观察层之外做出的更改。当你使用工具生成对象模型的代码，或者需要在Android应用程序代码中添加额外的应用特定层时，这种方法是有用的。
- en: '**Implementing the Observer pattern at the presentation layer** means that
    the root references held by the data binding layer are themselves Observable,
    but the object model is not. This will technically allow you to have an immutable
    data model if you wanted to. The data binding engine will never see the changes
    to the individual fields in the data model, but instead is notified that the whole
    model has changed. This can also be a very expensive model, as the data binding
    layer will reevaluate every part of the data model for every change made to it.
    However, this is a good approach when your application tends to update several
    fields in a model simultaneously, or is heavily multithreaded.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在表示层**实现观察者模式**意味着数据绑定层持有的根引用本身是可观察的，但对象模型不是。这从技术上允许你拥有一个不可变的数据模型。数据绑定引擎将不会看到数据模型中各个字段的更改，而是被通知整个模型已更改。这也可能是一个非常昂贵的模型，因为数据绑定层将重新评估数据模型的每个部分，以应对对其所做的每个更改。然而，当你的应用程序倾向于同时更新模型中的多个字段，或者高度多线程时，这是一个很好的方法。
- en: None of these options are always better than the others; rather, it's worth
    considering each of them when it comes to ensuring that your user interface will
    stay in-sync with the application's overall state. In some screens, this reactive
    behavior may even be undesirable, since it can easily disrupt the user. In these
    cases, it's worth using data binding just to populate the screen.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项中没有一个是始终优于其他选项的；相反，在确保你的用户界面与应用程序的整体状态保持同步时，值得考虑每个选项。在某些屏幕上，这种反应性行为甚至可能是不希望的，因为它可能会轻易地打扰用户。在这些情况下，仅为了填充屏幕，使用数据绑定就值得了。
- en: The data binding system is not bidirectional; changes in the model reflect in
    the user interface, but input in the user interface widgets are not pushed into
    the model automatically. This means that your application must still handle events
    and capture the changes in the user interface, as shown earlier.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 数据绑定系统不是双向的；模型中的更改反映在用户界面上，但用户界面小部件中的输入不会自动推送到模型中。这意味着你的应用程序仍然需要处理事件并捕获用户界面中的更改，如前面所示。
- en: Enabling data binding
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用数据绑定
- en: 'By default in an Android project, the data binding capabilities are turned
    off. You''ll need to enable them in your project''s `build.gradle` file by hand.
    Follow these quick steps to enable the data binding system:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android项目中，默认情况下数据绑定功能是关闭的。你需要在项目的`build.gradle`文件中手动启用它们。按照以下快速步骤启用数据绑定系统：
- en: 'Start by locating the `build.gradle` file for your application module in the
    Android panel in Android Studio:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在Android Studio的Android面板中找到你的应用程序模块的`build.gradle`文件：
- en: '![](img/e7bfab0a-4ee0-4099-bf6e-91e87c3b20a6.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e7bfab0a-4ee0-4099-bf6e-91e87c3b20a6.png)'
- en: 'Open this file and locate the `android` block:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开此文件并定位到`android`块：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'At the end of the `android` block, add the following snippet to enable data
    binding:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`android`块的末尾，添加以下片段以启用数据绑定：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Once you save this file, Android Studio will open a banner at the top of the
    file, telling you that it needs to sync the project. Click on the Sync Now link
    on the right-hand side of the banner and wait for the sync to complete.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存此文件后，Android Studio将在文件顶部打开一个横幅，告诉你需要同步项目。点击横幅右侧的“立即同步”链接，等待同步完成。
- en: Congratulations! You've just enabled the data binding framework on your project.
    Now you can get started, making use of the data binding system in your layout
    files, which will simplify the application and open doors to new ways to reuse
    your code base.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经在你的项目中启用了数据绑定框架。现在你可以开始了，利用你的布局文件中的数据绑定系统，这将简化应用程序并打开通往重用代码库的新方法。
- en: Data binding a layout file
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据绑定布局文件
- en: 'Data binding works primarily through code generation, and there is very little
    in the way of runtime overhead. It permits you to use a special expression language
    in your layout XML files, which gets converted into Java code before your application
    is compiled. These expressions can call methods, access properties, and are even
    useful for triggering events. They do have a few restrictions, however: they cannot
    directly reference the widgets in your user interface, and they cannot create
    any new objects (they have no `new` operator). As a result, you''ll need to provide
    your layout files with some utility methods in order to keep things simple, and
    there are a few guidelines to follow when working with expressions:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 数据绑定主要通过代码生成来实现，运行时开销非常小。它允许你在布局XML文件中使用特殊的表达式语言，这些表达式在应用程序编译之前被转换为Java代码。这些表达式可以调用方法、访问属性，甚至对于触发事件也很有用。然而，它们也有一些限制：它们不能直接引用用户界面中的小部件，也不能创建任何新对象（它们没有`new`运算符）。因此，你需要为你的布局文件提供一些实用方法以保持简单，并且在使用表达式时有一些指南需要遵循：
- en: '**Keep the expressions simple**: Don''t write application logic into the expressions;
    rather, create a utility method that can be reused'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持表达式简单**：不要在表达式中写入应用程序逻辑；相反，创建一个可重用的实用方法。'
- en: '**Avoid manipulating data directly**: As tempting as it might be, ensure that
    your data is always ready for presentation before it''s given to the layout binding.
    Keep default values in your model, `Activity`, or `Fragment` classes, and not
    in the layout XML files'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免直接操作数据**：尽管这样做可能很有吸引力，但请确保在将数据提供给布局绑定之前，数据总是准备好用于展示。在你的`Activity`或`Fragment`类模型中保留默认值，而不是在布局XML文件中。'
- en: '**Use presenter objects**: When you have simple transformations that need to
    be done on the data (such as formatting a date or number), put these into objects.
    The expression language can reference static methods, but presenter objects are
    much more powerful and flexible'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用展示者对象**：当你需要对数据进行一些简单的转换（例如格式化日期或数字）时，将这些转换放入对象中。表达式语言可以引用静态方法，但展示者对象要强大得多，也更加灵活。'
- en: '**Pass events in**: Avoid using the expressions language for more than a method
    call when you''re writing events, and try to pass the events into the layout as
    objects, either as a presenter, or as command objects. This keeps the events flexible
    and reusable'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传递事件**：在编写事件时，避免使用表达式语言进行除方法调用之外的操作，并尝试将事件作为对象传递到布局中，无论是作为展示者还是作为命令对象。这保持了事件的灵活性和可重用性。'
- en: By sticking to these guidelines, you'll find that working with the data binding
    system not only frees you from some of the most common user interface boilerplate
    code, but also improves the quality of your layouts and overall application. By
    using objects in your layout files rather than static methods, you'll end up with
    modular classes that can be easily reused throughout your application.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通过坚持这些指南，你会发现使用数据绑定系统不仅能让你摆脱一些最常见的用户界面模板代码，还能提高你布局和整体应用程序的质量。通过在你的布局文件中使用对象而不是静态方法，你最终会得到模块化的类，这些类可以在整个应用程序中轻松重用。
- en: 'Now that your app can capture people''s expenses as claims, it''s time to start
    thinking about how the information will be displayed. There are two major components
    to this: the list of claim items the user has created, and their overall travel
    allowance that they''re supposed to keep to. So far, you have the capture screen,
    and while in many ways it''s the most important screen in the app, it''s not the
    first one that the user will see--that will be the overview screen.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的应用可以捕获人们的费用作为索赔，是时候开始考虑如何显示这些信息了。这有两个主要组成部分：用户创建的索赔项列表，以及他们应该保持的整体旅行津贴。到目前为止，您有捕获屏幕，虽然在许多方面它是应用中最重要的屏幕，但并不是用户首先看到的屏幕——那将是概览屏幕。
- en: The overview screen's main job is to display the claim items in order, from
    most recent to the oldest. However, to keep the user's life simple, we'll also
    display a summary card at the top of the screen, which will help them stay on
    track with their spending. For this example, we'll assume that the allowance is
    specified as an amount per day that they are traveling.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 概览屏幕的主要任务是按顺序显示索赔项，从最新到最旧。然而，为了保持用户的简单生活，我们还会在屏幕顶部显示一个摘要卡片，这有助于他们跟踪他们的消费。在这个例子中，我们假设津贴是按每天旅行金额指定的。
- en: Creating an Observable model
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个 Observable 模型
- en: 'To get things started on this part of the project, you''ll need a new model
    class to encapsulate the allowance and spending of the user. We''ll call the new
    class `Allowance`, and build in some utility methods to fetch useful information
    (such as how much the user spent between two dates). Most importantly, this new
    model needs to tell us when it changes. This can technically be done in several
    ways: through an event-bus, or specialized listeners, but for this example, we''ll
    go with an Observer pattern. To make this work, the `Allowance` class will extend
    from `BaseObservable`, a convenience class that is part of the data binding API.
    Whenever the `Allowance` class changes, it''ll emit events notifying its observers
    of the change. Let''s get started building the `Allowance` class:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始这个项目部分的工作，你需要一个新的模型类来封装用户的津贴和消费。我们将把这个新类命名为 `Allowance`，并内置一些实用方法来获取有用的信息（例如用户在两个日期之间的消费金额）。最重要的是，这个新模型需要告诉我们何时发生变化。这可以从技术上通过事件总线或专门的监听器来完成，但在这个例子中，我们将采用观察者模式。为了使这可行，`Allowance`
    类将扩展自 `BaseObservable`，这是一个数据绑定 API 的一部分，用于方便的类。每当 `Allowance` 类发生变化时，它将发出事件，通知其观察者变化。让我们开始构建
    `Allowance` 类：
- en: Right-click on the `model` package and select New| Java Class.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 `model` 包，然后选择“新建| Java 类”。
- en: Name the new class `Allowance`.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新类命名为 `Allowance`。
- en: Change the Superclass to `android.databinding.BaseObservable`.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将父类更改为 `android.databinding.BaseObservable`。
- en: Add `android.os.Parcelable` to the Interfaces field.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `android.os.Parcelable` 添加到接口字段。
- en: Click OK to create the new class.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“确定”以创建新类。
- en: 'At the top of the class, declare the following fields and constructors, and
    a getter method for the `amountPerDay`, which represents the allowance the user
    is aiming for:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类顶部，声明以下字段和构造函数，以及一个获取 `amountPerDay` 的 getter 方法，它代表用户希望获得的津贴：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now comes the first bit of the Observable implementation; when we change the
    `amountPerDay` field, we need to notify any Observers that the `Allowance` object
    has changed:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是 Observable 实现的第一部分；当我们更改 `amountPerDay` 字段时，我们需要通知任何观察者 `Allowance` 对象已更改：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `Allowance` class will always ensure that all the `ClaimItem` objects are
    sorted from the newest to the oldest; knowing this, we can add some convenience
    methods to find the *start* and *end* dates for the `Allowance` object:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Allowance` 类将始终确保所有 `ClaimItem` 对象按从新到旧的顺序排序；了解这一点后，我们可以添加一些便利方法来找到 `Allowance`
    对象的 *起始* 和 *结束* 日期：'
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, create a simple calculation method to determine how much has been spent
    in total for this `Allowance`. This method simply adds up all the amounts in all
    the `ClaimItem` objects:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个简单的计算方法来确定这个 `Allowance` 的总消费金额。这个方法简单地将所有 `ClaimItem` 对象中的金额加起来：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, add another calculation method to calculate the amount spent between
    two dates. This can be used to find out how much was spent on a specific day,
    week, month, and so on:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加另一个计算方法来计算两个日期之间的消费金额。这可以用来找出特定日期、周、月等的消费金额：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, you''ll need a method to add a `ClaimItem` to the `Allowance`. The `Allowance`
    always maintains the list of `ClaimItem` objects sorted from newest to oldest,
    so this method simply sorts the list each time an item is added, and then notifies
    observers that the `Allowance` has changed:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您需要一个方法来向`Allowance`添加`ClaimItem`。`Allowance`始终维护从最新到最旧的`ClaimItem`对象列表，因此每次添加项目时，此方法只需对列表进行排序，然后通知观察者`Allowance`已更改：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Sorting a list like this is a very poor implementation, but very simple to write.
    In practice, you should binary-search for the correct position to add the `ClaimItem`.
    Android provides classes to help with this, which we'll explore later in the book.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对列表进行此类排序是一个非常糟糕的实现，但非常简单易写。在实际应用中，您应该使用二分查找来确定添加`ClaimItem`的正确位置。Android提供了帮助进行此操作的类，我们将在本书的后面部分探讨。
- en: 'We also need to be able to remove `ClaimItem` objects from the `Allowance`.
    This is also a mutative operation, so we notify any observers when it''s done:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要能够从`Allowance`中删除`ClaimItem`对象。这也是一个可变操作，因此在完成后通知任何观察者：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add the accessor methods for the `ClaimItem` objects:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`ClaimItem`对象的访问器方法：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finish the `Allowance` class by writing its `Parcelable` implementation:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过编写其`Parcelable`实现来完成`Allowance`类的编写：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `Allowance` class is the first (and currently, the only) part of your object
    model that needs to be observed, as you can see; building an `Observable` model
    is not difficult, and being able to watch your model state for changes opens some
    fantastic opportunities, such as automatic network synchronization or statistics
    aggregation.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`Allowance`类是您对象模型中需要观察的第一个（也是目前唯一的）部分；构建一个`Observable`模型并不困难，能够观察模型状态的变化会打开一些惊人的机会，例如自动网络同步或统计聚合。
- en: If you have an event bus in your application, pushing object model changes through
    there rather than direct observation is often a better option as it will offer
    better decoupling. There are a large number of event-bus APIs compatible with
    Android, and it's worth checking them out. A well-known API with an Event Bus
    implementation is Google's Guava API ([https://github.com/google/guava](https://github.com/google/guava)).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序中有事件总线，通过它而不是直接观察来推送对象模型更改通常是一个更好的选择，因为它将提供更好的解耦。有许多与Android兼容的事件总线API，值得检查它们。一个具有事件总线实现的知名API是Google的Guava
    API ([https://github.com/google/guava](https://github.com/google/guava))。
- en: Establishing the AllowanceOverviewFragment
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立AllowanceOverviewFragment
- en: 'The allowance overview will be presented as a card at the top of an overview
    screen. The overview card will be populated by a new `Fragment` class that will
    encapsulate the first part of the data binding. The `AllowanceOverviewFragment`
    will depend on the data binding system to do most of the heavy lifting, and will
    provide the layout binding with a special `AllowanceOverviewPresenter` object
    that can be queried for statistics and data. The `AllowanceOverviewPresenter`
    will, in turn, reference the `Allowance` object, and listen for any changes on
    it in order to update and cache the statistics data. The relationship between
    these entities can be best explained with the following diagram:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 允许概述将以卡片的形式显示在概述屏幕的顶部。概述卡片将由一个新的`Fragment`类填充，该类将封装数据绑定的第一部分。`AllowanceOverviewFragment`将依赖于数据绑定系统来完成大部分繁重的工作，并将提供一个特殊的`AllowanceOverviewPresenter`对象，该对象可以查询统计数据和数据。`AllowanceOverviewPresenter`将反过来引用`Allowance`对象，并监听其上的任何更改，以便更新和缓存统计数据。这些实体之间的关系可以用以下图表最好地解释：
- en: '![](img/3245c549-f1eb-415b-99cc-2aabe02a972f.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3245c549-f1eb-415b-99cc-2aabe02a972f.jpg)'
- en: 'Encapsulating the statistics in a `Fragment` means that it''s easier to include
    in other layouts that might include different information to the overview screen.
    Follow these quick steps to create the `AllowanceOverviewFragment` and `AllowanceOverviewPresenter`
    skeleton:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Fragment`中封装统计数据意味着它更容易包含在其他布局中，这些布局可能包含与概述屏幕不同的信息。按照以下快速步骤创建`AllowanceOverviewFragment`和`AllowanceOverviewPresenter`骨架：
- en: Right-click on the `ui` package and select New | Fragment |Fragment (Blank).
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击`ui`包，然后选择“新建”|“Fragment”|“Fragment（空白）”。
- en: Name the Fragment `AllowanceOverviewFragment`.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Fragment命名为`AllowanceOverviewFragment`。
- en: 'Turn off the Include fragment factory methods? and Include interface callbacks?
    options:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭“包含Fragment工厂方法”和“包含接口回调”选项：
- en: '![](img/02627d0a-6201-4c2d-9d07-38982df1a481.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/02627d0a-6201-4c2d-9d07-38982df1a481.png)'
- en: Click on Finish to create the new `Fragment` and its default layout file.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“完成”以创建新的`Fragment`及其默认布局文件。
- en: Right-click on the `ui` package again and select New| Java Class.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次右键单击 `ui` 包，并选择“新建| Java 类”。
- en: Name the new class `presenters.AllowanceOverviewPresenter`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新类命名为 `presenters.AllowanceOverviewPresenter`。
- en: Click OK to create the new package and class.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“确定”以创建新的包和类。
- en: 'The first thing the `AllowanceOverviewPresenter` needs is an inner class to
    hold the cached spending statistics that will be displayed to the user. This will
    be an immutable structure; when the statistics change, we refresh all of them
    at the same time:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AllowanceOverviewPresenter` 需要的第一件事是一个内部类，用于存储将显示给用户的缓存支出统计信息。这将是一个不可变结构；当统计信息发生变化时，我们将同时刷新所有这些信息：'
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You'll note that the fields in the `SpendingStats` class are `public final`,
    and have no getters. When dealing with data binding, the coupling is typically
    very tight, so introducing getter methods can actually create more complexity.
    It's better to avoid getter methods until they're needed.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到 `SpendingStats` 类的字段是 `public final`，并且没有getter方法。在处理数据绑定时，耦合通常非常紧密，因此引入getter方法实际上可能会增加复杂性。最好在需要之前避免使用getter方法。
- en: 'We need to expose the `SpendingStats` outside of the class in such a way that
    the data binding will watch for changes. Android data binding, again, has a helper
    class; when you have a field that needs to be observed, you can use the `ObservableField`
    class. When an expression in the data binding layout file references one of these,
    it will automatically listen for changes and reevaluate when the field is changed:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要以某种方式将 `SpendingStats` 暴露在类外部，以便数据绑定可以监视其变化。Android数据绑定再次有一个辅助类；当你有一个需要观察的字段时，你可以使用
    `ObservableField` 类。当数据绑定布局文件中的表达式引用这些之一时，它将自动监听变化，并在字段更改时重新评估：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When using `ObservableField` (and its cousins: `OvservableString`, `ObservableInt`,
    and such), it''s best to declare them as `final` and initialized. The data binding
    system can''t watch for changes on the field itself, but instead, will attach
    a listener to the `ObservableField` object.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `ObservableField`（及其表亲：`ObservableString`、`ObservableInt` 等）时，最好将它们声明为 `final`
    并初始化。数据绑定系统无法监视字段本身的变化，而是将监听器附加到 `ObservableField` 对象上。
- en: 'The `AllowanceOverviewPresenter` also requires an `Allowance` object that it
    will encapsulate, and a constructor:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AllowanceOverviewPresenter` 还需要一个 `Allowance` 对象，它将封装它，以及一个构造函数：'
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, the `AllowanceOverviewPresenter` needs a method to allow the user
    to update the amount they''re permitted to spend each day. In this case, the presenter
    acts as a helper to keep some of the logic out of the layout files; the `EditText`
    widget will provide a number as a `CharSequence`, so `AllowanceOverviewPresenter`
    needs to parse it and handle any errors if it''s invalid in some way:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`AllowanceOverviewPresenter` 需要一个方法，允许用户更新他们每天被允许花费的金额。在这种情况下，演示者充当助手，将一些逻辑从布局文件中排除；`EditText`
    小部件将提供一个数字作为 `CharSequence`，因此 `AllowanceOverviewPresenter` 需要解析它并处理任何错误，如果它在某些方面无效：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `AllowanceOverviewPresenter` class will serve as an intermediary system
    between the raw data-bound layout file, and the raw object model. This allows
    you to keep any rendering logic out of the object model, while also keeping the
    data model requirements out of the layout XML file.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`AllowanceOverviewPresenter` 类将作为原始数据绑定布局文件和原始对象模型之间的中介系统。这允许你将任何渲染逻辑从对象模型中排除，同时也将数据模型需求从布局XML文件中排除。'
- en: Creating the AllowanceOverview layout
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 `AllowanceOverview` 布局
- en: 'Now, it''s time to create the layout file and bind it to the `AllowanceOverviewPresenter`
    class. A data-bound layout file is a little different from a normal Android layout.
    As each layout XML file results in its own binding class, they have a root element
    of `layout`, followed by a `data` section that declares the variables that they
    will bind to. Each variable is named and typed with its Java class, because during
    compilation, these are all turned into Java variables in a generated binding class.
    Ultimately, you want to create a layout that will look like this at the top of
    the overview screen:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候创建布局文件并将其绑定到 `AllowanceOverviewPresenter` 类了。数据绑定布局文件与正常的Android布局文件略有不同。由于每个布局XML文件都会生成自己的绑定类，因此它们有一个
    `layout` 的根元素，后面跟着一个 `data` 部分，该部分声明了它们将要绑定的变量。每个变量都以其Java类命名和类型化，因为在编译期间，这些都会转换为生成绑定类中的Java变量。最终，你希望创建的布局在概述屏幕顶部看起来像这样：
- en: '![](img/1bed86f5-8506-4873-ad01-1162e9b6b0be.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1bed86f5-8506-4873-ad01-1162e9b6b0be.png)'
- en: 'The Daily Allowance field will allow the user to directly edit how much they
    are allocated per day, while the labels to the right will display their spending
    today, this week, and in total. Follow these steps to construct the preceding
    layout; unlike previous examples, these steps don''t use the Design view for editing,
    and the layout is built from right to left:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 每日配额字段将允许用户直接编辑他们每天分配的金额，而右侧的标签将显示他们今天的支出、本周的支出以及总支出。按照以下步骤构建前面的布局；与之前的示例不同，这些步骤不使用设计视图进行编辑，布局是从右到左构建的：
- en: Open the `fragment_allowance_overview.xml` layout file.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`fragment_allowance_overview.xml`布局文件。
- en: Change the editor to Text mode.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将编辑器更改为文本模式。
- en: 'Change the root element from `FrameLayout` to layout, and remove the contents:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将根元素从`FrameLayout`更改为布局，并删除内容：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, declare a data section within the `layout` and declare a presenter variable
    for the `AllowanceOverviewPresenter` class:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`layout`中声明一个数据部分，并为`AllowanceOverviewPresenter`类声明一个表示变量：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Unlike the `data` section, the widget elements have no special root, so directly
    after the `data` section (and still nested within the `layout` element), declare
    the root element of this layout, which will be a `ConstraintLayout`:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与`data`部分不同，小部件元素没有特殊的根，因此在`data`部分之后（并且仍然嵌套在`layout`元素中），声明此布局的根元素，它将是一个`ConstraintLayout`：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Within the `ConstraintLayout`, create a `TextView` that will serve as the label
    with the word `Total` in it:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ConstraintLayout`中创建一个`TextView`，它将作为包含单词`Total`的标签：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: On the line specifying the `android:text` attribute, Android Studio will complain
    that the `@string/label_total` resource doesn't exist. Use the code assistance
    (usually *Alt* + *Enter*), and select Create string value resource 'label_total'.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在指定`android:text`属性的行上，Android Studio会抱怨`@string/label_total`资源不存在。使用代码辅助功能（通常是*Alt*
    + *Enter*），并选择创建字符串值资源`label_total`。
- en: A dialog will open, prompting you for the resource value; enter `Total` and
    click on the OK button.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将会打开一个对话框，提示您输入资源值；输入`Total`并点击确定按钮。
- en: Use the same code assistance to create a dimension resource on the following
    line, specifying the minimum width. Give the new `allowance_overview_label_min_width`
    resource a value of `50dp` and click OK.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相同的代码辅助功能在下一行创建一个尺寸资源，指定最小宽度。将新的`allowance_overview_label_min_width`资源设置为`50dp`并点击确定。
- en: 'Below the Total label widget, create a `TextView` that will contain the actual
    amount of money the user has spent in their `Allowance`:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在总标签小部件下方创建一个`TextView`，它将包含用户在`Allowance`中实际花费的金额：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Note that here, you haven''t specified an `android:text` attribute. This will
    be the first data-bound attribute in the layout file, and we want to display the
    total field of the `SpendingStats` object from the presenter. Write this `android:text`
    attribute into the `TextView` above the `app:layout_constraintEnd_toEndOf` attribute:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，在这里，您没有指定`android:text`属性。这将是布局文件中的第一个数据绑定属性，我们希望显示表示中的`SpendingStats`对象的总额字段。将此`android:text`属性写入上面的`TextView`，在`app:layout_constraintEnd_toEndOf`属性之前：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Data-bound expressions are all wrapped in `@{..}` to signal their difference
    from normal attributes. The code looks like Java, but it's not. Note the `??`
    operator; it's a very useful "null-safe" operator. If any part of the left-hand
    side is null, the right-hand side (in this case, the `"0"` string) will be used
    instead (like a very specific ternary operator). Also, make note of the single
    quotes around the `android:text` attribute; data-bound layouts must still be a
    valid XML file, and the preceding code needs to specify a Java string that uses
    double quotes. Rather than escaping the Java string as `&quot;0&quot;`, it's cleaner
    to use single quotes for the XML attribute.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 数据绑定表达式都包裹在`@{..}`中，以表示它们与普通属性的不同。代码看起来像Java，但实际上不是。注意`??`运算符；它是一个非常有用的“空安全”运算符。如果左侧的任何部分为null，则将使用右侧的值（在这种情况下，是`"0"`字符串）代替（就像一个非常具体的三元运算符）。此外，注意`android:text`属性周围的单引号；数据绑定布局仍然必须是一个有效的XML文件，并且前面的代码需要指定一个使用双引号的Java字符串。与其将Java字符串转义为`&quot;0&quot;`，不如使用单引号来清理XML属性。
- en: Another important factor is how you need to use `Integer.toString` to ensure
    that the correct method is invoked on the `TextView`. Leaving it as an `int` will
    cause `TextView.setText(int)` to be invoked, and this expects a string-resource
    identifier.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要因素是您需要使用`Integer.toString`来确保在`TextView`上调用正确的方法。将其保留为`int`将导致调用`TextView.setText(int)`，它期望一个字符串资源标识符。
- en: 'Next, you''ll need to declare very similar `TextView` elements for the weekly
    label and amount display. These are virtually identical to the total `TextView`
    elements, except for their labels, IDs, and constraints. You''ll also need to
    create a `label_week` string resource with a value of `Week`:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你需要为每周标签和金额显示声明非常相似的`TextView`元素。这些元素几乎与总`TextView`元素完全相同，只是它们的标签、ID和约束不同。你还需要创建一个值为`Week`的`label_week`字符串资源：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You''ll need to repeat the same for the Today numbers. Again, you''ll want
    to change the labels, IDs, and constraints, and create a `label_today` string
    resource with a value of `Today`:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要为今天的数字重复相同的操作。同样，你需要更改标签、ID和约束，并创建一个值为`Today`的`label_today`字符串资源：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The last element of this card is the daily allowance input area, where the
    user can enter how much they are allowed to spend each day. It consists of a `TextInputLayout`
    and a `TextInputEditText` widget bound to the amount per day. In this element,
    you''ll also be binding the `TextInputEditText` widget to an event handler, which
    looks a lot like a Java lambda, but like all the binding expressions, it''s not.
    However, it is translated into Java:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此卡片中的最后一个元素是每日限额输入区域，用户可以输入他们每天可以花费的金额。它由一个`TextInputLayout`和一个绑定到每天金额的`TextInputEditText`小部件组成。在这个元素中，你还将`TextInputEditText`小部件绑定到一个事件处理器，这看起来很像Java
    lambda表达式，但像所有绑定表达式一样，它并不是。然而，它被翻译成了Java：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Use the Android Studio code assistant to create the `label_daily_allowance`
    string resource with a value of `Daily Allowance`.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Android Studio代码助手创建一个值为`Daily Allowance`的`label_daily_allowance`字符串资源。
- en: Now, if you go back to the Design mode, you'll be able to see what your new
    fragment will look like on the screen of the user's device. The event-handler
    is hooked up and will be triggered every time the user changes any text in the
    Daily Allowance input box. The event trigger will invoke the `presenter.updateAllowance`
    method, which in turn will attempt to parse the value and set it on the `Allowance`
    object (assuming that it can be parsed as an integer).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你回到设计模式，你将能够看到你的新片段在用户设备屏幕上的样子。事件处理器已经连接，并且每次用户在每日限额输入框中更改任何文本时都会被触发。事件触发器将调用`presenter.updateAllowance`方法，该方法反过来会尝试解析该值并将其设置在`Allowance`对象上（假设它可以解析为整数）。
- en: Updating the SpendingStats class
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新`SpendingStats`类
- en: You've already created the `SpendingStats` class and bound it to your layout,
    but it won't ever have any data in it because it's never actually created, and
    the `ObservableField<SpendingStats>` field in the `AllowanceOverviewPresenter`
    is never populated. There's a good reason for that--the stats take time to calculate.
    Even if we had a database to do the heavy lifting, there is potentially a substantial
    overhead to calculate these three numbers before you can put them on the screen,
    while you can directly invoke the `Allowance.getTotalSpent()` method as part of
    your layout XML that will block the main thread for the entire time it took to
    calculate that number. That's not a good idea, as that time delay can quickly
    add up and lead to degraded user experience or even Application Not Responding
    errors.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经创建了`SpendingStats`类并将其绑定到你的布局中，但它永远不会包含任何数据，因为它从未真正创建过，`AllowanceOverviewPresenter`中的`ObservableField<SpendingStats>`字段也从未被填充。这有一个很好的原因——统计需要时间来计算。即使我们有数据库来做繁重的工作，在将这三个数字显示在屏幕上之前，计算这些数字可能存在相当大的开销。而你可以直接在布局XML中调用`Allowance.getTotalSpent()`方法，这将阻塞主线程直到计算完那个数字。这不是一个好主意，因为这种延迟会迅速累积，并可能导致用户体验下降或甚至出现应用程序无响应错误。
- en: 'The answer is to listen for changes to the `Allowance` object, and recalculate
    the values on a worker thread before updating the `SpendingStats` field in the
    `AllowanceOverviewPresenter`. The data binding system will take care of the rest
    and populate the values on the screen. There are two structures that are needed
    for this part of the example: an observer to watch for any changes on the `Allowance`
    object, and an `ActionCommand` to calculate and update the `SpendingStats` in
    the `AllowanceOverviewPresenter`. Let''s create them:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是监听`Allowance`对象的更改，并在更新`AllowanceOverviewPresenter`中的`SpendingStats`字段之前在一个工作线程上重新计算值。数据绑定系统将负责其余部分，并在屏幕上填充值。本例的这一部分需要两个结构：一个观察者来监视`Allowance`对象上的任何更改，以及一个`ActionCommand`来计算并更新`AllowanceOverviewPresenter`中的`SpendingStats`。让我们创建它们：
- en: Open the `AllowanceOverviewPresenter` source file in Android Studio.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android Studio中打开`AllowanceOverviewPresenter`源文件。
- en: 'At the bottom of the `AllowanceOverviewPresenter` class, start a new `ActionCommand`
    inner class to update the `SpendingStats`, named `UpdateSpendingStatsCommand`:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AllowanceOverviewPresenter`类的底部，开始一个新的`ActionCommand`内部类来更新`SpendingStats`，命名为`UpdateSpendingStatsCommand`：
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `UpdateSpendingStatsCommand` will need two utility methods to calculate
    the date ranges for *this week*, and *today*. Unfortunately, Android doesn''t
    support the new Java 8 time APIs; you''ll need to use the `Calendar` class. On
    the other hand, Android provides a very useful utility class named `Pair`, that
    is perfect for defining a date range:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`UpdateSpendingStatsCommand`需要两个实用方法来计算*本周*和*今天*的日期范围。不幸的是，Android不支持新的Java
    8时间API；你需要使用`Calendar`类。另一方面，Android提供了一个非常有用的实用类`Pair`，非常适合定义日期范围：'
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You'll find that there are two different `Pair` implementations available to
    your application. One is part of the core Android platform (`android.util.Pair`),
    and the other is provided by the support packages (`android.support.v4.util.Pair`).
    The support implementation is intended for applications targeting API version
    4 and lower, and your application is targeting API version 16 and higher; so,
    you should use the platform (`android.util.Pair`) implementation.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现你的应用程序中有两种不同的`Pair`实现可用。一个是Android核心平台的一部分（`android.util.Pair`），另一个是由支持包提供的（`android.support.v4.util.Pair`）。支持实现旨在针对API版本4及以下的应用程序，而你的应用程序针对的是API版本16及以上；因此，你应该使用平台实现（`android.util.Pair`）。
- en: 'Then, you need to implement the `onBackground` method to process the data in
    the `Allowance` object into the `SpendingStats`:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你需要实现`onBackground`方法，将`Allowance`对象中的数据处理到`SpendingStats`中：
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, the `UpdateSpendingStatsCommand` needs its `onForeground` to set the
    `SpendingStats` field on the `AllowanceOverviewPresenter`, which will cause the
    user interface to update with the new data:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，`UpdateSpendingStatsCommand`需要其`onForeground`设置`AllowanceOverviewPresenter`上的`SpendingStats`字段，这将导致用户界面使用新数据更新：
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'That completes the `UpdateSpendingStatsCommand`; now, in the `AllowanceOverviewPresenter`
    class, you''ll need an instance of the `UpdateSpendingStatsCommand` that you can
    invoke when the `Allowance` object changes:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这完成了`UpdateSpendingStatsCommand`；现在，在`AllowanceOverviewPresenter`类中，你需要一个`UpdateSpendingStatsCommand`的实例，当`Allowance`对象发生变化时可以调用：
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, you need `AllowanceOverviewPresenter` to be able to watch for changes
    to the `Allowance` object. This will involve an observer that Android''s data
    binding API calls an `OnPropertyChangedCallback`. The problem is that `OnPropertyChangedCallback`
    is a class and not an interface, so for the `AllowanceOverviewPresenter`, use
    an anonymous-inner class for the `OnPropertyChangedCallback`:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你需要`AllowanceOverviewPresenter`能够监视`Allowance`对象的变化。这将涉及一个观察者，Android的数据绑定API调用`OnPropertyChangedCallback`。问题是`OnPropertyChangedCallback`是一个类而不是接口，所以对于`AllowanceOverviewPresenter`，使用匿名内部类作为`OnPropertyChangedCallback`：
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `AllowanceOverviewPresenter` needs to connect the observer to the `Allowance`
    object in its constructor:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AllowanceOverviewPresenter`需要在构造函数中将其观察者连接到`Allowance`对象：'
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'References held by `Observable` objects to their observers are strong references,
    so if care isn''t taken, you can find yourself with memory leaks. To avoid that,
    it''s a good idea to detach the listener when the `AllowanceOverviewPresenter`
    will no longer be needed; however, this will need to be done from outside:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Observable`对象持有的对其观察者的引用是强引用，所以如果不注意，你可能会发现自己有内存泄漏。为了避免这种情况，当`AllowanceOverviewPresenter`不再需要时，一个好的做法是断开监听器；然而，这需要从外部完成：'
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Most of the code for the `UpdateSpendingStatsCommand` is taken up by the date-range
    calculations; it's otherwise a very simple class. The important aspects are that
    it both encapsulates the calculations, and runs them on a background worker thread
    that keeps the user interface running smoothly while it adds up the numbers.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateSpendingStatsCommand`的大部分代码被日期范围计算占据；否则它是一个非常简单的类。重要的是它既封装了计算，又在后台工作线程上运行，以保持用户界面在计算数字时平滑运行。'
- en: Data binding and fragments
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据绑定和片段
- en: 'When working with the data binding framework, it''s important to put some additional
    thought into where to encapsulate the various parts of your user interface. As
    you can hook the logic directly into the layout files, it will often be a better
    idea to use classes similar to the `DatePickerWrapper` you wrote in [Chapter 3](75335d7f-3cda-4985-b992-965f46adc335.xhtml),
    *Taking Actions*, with an `<include>` and `<merge>` tag, rather that wrapping
    groups of components in classes. Data-bound layouts that are included in other
    layouts still have variables, and it''s the responsibility of the outer layout
    to pass those variables downward, into the included layout file. For example,
    a layout including a date picker might look something like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用数据绑定框架工作时，重要的是要考虑将用户界面的各个部分封装在哪里。由于你可以直接将逻辑钩入布局文件，因此通常更好的做法是使用类似于你在[第3章](75335d7f-3cda-4985-b992-965f46adc335.xhtml)，“采取行动”，中编写的`DatePickerWrapper`的类，使用`<include>`和`<merge>`标签，而不是将组件组包裹在类中。包含在其他布局中的数据绑定布局仍然有变量，并且外部布局有责任将这些变量向下传递到包含的布局文件中。例如，包含日期选择器的布局可能看起来像这样：
- en: '[PRE32]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As long as either `user` or its `dateOfBirth` is `Observable`, the layout will
    automatically reflect any changes to it. This pattern allows you to not only modularize
    your layouts, but also ensure that they only receive the data that they actually
    require in order to work. The other advantage is that using it with `<merge>`
    elements plays very nicely with the `ConstraintLayout`, allowing you to build
    complex and reusable layout elements that nest in your code, but are flat (not
    nested) in the component hierarchy. Flat layouts using `ConstraintLayout` are
    often easier to build, are typically faster to render, and allow for more flexible
    animations than deeply nested layouts. They can be harder to modularize for reuse;
    data-binding makes this much easier.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 只要`user`或其`dateOfBirth`是`Observable`，布局将自动反映对其的任何更改。这种模式不仅允许你模块化你的布局，还可以确保它们只接收它们实际需要以工作的数据。另一个优点是，使用`<merge>`元素与`ConstraintLayout`配合使用时，可以非常顺畅，允许你构建复杂且可重用的布局元素，这些元素在代码中嵌套，但在组件层次结构中是平的（不是嵌套的）。使用`ConstraintLayout`的平面布局通常更容易构建，渲染速度通常更快，并且比深层嵌套布局提供更多灵活的动画。它们可能更难模块化以供重用；数据绑定使这一点变得容易得多。
- en: If you're wondering whether it's a good idea to still introduce fragments and
    widget classes, look at logical boundaries, where you will be forced to nest your
    components. An excellent example of a good boundary is a `CardView`. A `CardView`
    requires a nested layout, so its contents are perfect candidates for a widget
    or fragment, which can further help with encapsulation of your layout and logic.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还在犹豫是否仍然引入片段和视图类，看看逻辑边界，你将不得不嵌套你的组件。一个很好的边界示例是`CardView`。`CardView`需要一个嵌套布局，因此其内容是完美适合作为视图或片段的候选，这可以进一步帮助你封装布局和逻辑。
- en: It's also important to consider your "presenter" classes and objects when you
    build them. A single layout can have any number of variables, and the presenter
    classes don't have to be shallow structures. It's common to build presenter classes
    in levels by inheritance, where you might build an application level presenter
    with global rules (how to format dates and numbers), with children for things
    like displaying dialogs; remember that some of the logic might not be used directly
    by the layout, but rather by an event handler method. Breaking the presenter classes
    up in this way allows you to further confine logic to where it's needed, and improve
    your code reusability.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建它们时，也要考虑你的“展示者”类和对象。单个布局可以有任意数量的变量，展示者类不必是浅层结构。按继承级别构建展示者类很常见，你可能构建一个应用级别的展示者，具有全局规则（如何格式化日期和数字），以及用于显示对话框等子类；记住，一些逻辑可能不是直接由布局使用，而是由事件处理方法使用。以这种方式拆分展示者类可以进一步将逻辑限制在需要的地方，并提高代码的可重用性。
- en: Test your knowledge
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: Android's data binding framework follows what sort of binding?
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Android的数据绑定框架遵循哪种绑定？
- en: Model-View View-Model (bidirectional) binding
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型-视图-视图模型（双向）绑定
- en: Model-View-Presenter pattern
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型-视图-展示者模式
- en: Model-View (unidirectional) binding
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型-视图（单向）绑定
- en: Data Bound Layouts have variables that must be which of the following?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据绑定布局必须具有以下哪种变量？
- en: Any Java Object
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何Java对象
- en: Observable by the data binding framework
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可由数据绑定框架观察
- en: Presenter objects
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示对象
- en: Model objects
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型对象
- en: Which of the following features belongs to data binding expressions?
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个功能属于数据绑定表达式？
- en: They must be written in single quotes
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们必须用单引号编写
- en: They are Java expressions
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是 Java 表达式
- en: They are a special expression language
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是一种特殊的表达式语言
- en: They're only evaluated at runtime
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们仅在运行时评估
- en: To trigger an update of a data-bound user interface, you must do which of these?
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要触发数据绑定用户界面的更新，你必须做以下哪一项？
- en: Listen for object model changes with an event bus
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用事件总线监听对象模型的变化
- en: Extend the `PropertyChangeCallback` class
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展 `PropertyChangeCallback` 类
- en: Call refresh on the generated `Binding` object
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在生成的 `Binding` 对象上调用刷新
- en: Make a change that the `Binding` object can observe
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对 `Binding` 对象进行一个可以观察到的更改
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Data binding can not only massively reduce the amount of boilerplate code required
    to write a user interface, but can actively improve your code base and increase
    how much code you can reuse. By avoiding complex binding expressions and encapsulating
    the display logic in your presenter classes, you can build highly modular layouts
    that are fast, type-safe, and reusable.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 数据绑定不仅可以大量减少编写用户界面所需的样板代码量，还可以积极改进你的代码库并增加可重用代码的数量。通过避免复杂的绑定表达式并在你的表示类中封装显示逻辑，你可以构建高度模块化的布局，这些布局快速、类型安全且可重用。
- en: It's sometimes useful to think of the data-bound layout files as Java classes
    in their own right; after all, they will each result in a generated Binding class.
    It's useful to keep in mind that the Binding classes themselves are also observable,
    so any changes to them through their generated setter methods will automatically
    trigger an update in the user interface as well. Also, remember that when you
    include a data-bound layout in another, you need to pass all of its variables
    downward, which is just like specifying arguments on a constructor, and those
    variables don't need to be directly contained within the parent layout.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 有时将数据绑定布局文件视为它们自己的 Java 类是有用的；毕竟，它们每个都会生成一个 `Binding` 类。记住，`Binding` 类本身也是可观察的，所以通过它们生成的设置方法对它们的任何更改都会自动触发用户界面的更新。此外，记住当你将数据绑定布局包含在另一个布局中时，你需要向下传递所有其变量，这就像在构造函数中指定参数一样，而这些变量不需要直接包含在父布局中。
- en: So far, you've been building an in-memory data model, but this means that when
    your application is terminated, all the data is lost. In the next chapter, we'll
    take a look at long-term data storage on Android, and find out how to integrate
    it with your user interface without degrading the user experience and perceived
    performance.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你一直在构建内存中的数据模型，但这也意味着当你的应用程序终止时，所有数据都会丢失。在下一章中，我们将探讨 Android 上的长期数据存储，并了解如何在不降低用户体验和感知性能的情况下将其与用户界面集成。
