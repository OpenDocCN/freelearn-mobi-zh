- en: Getting Your App Ready for the Play Store
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为应用准备Play商店
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The Android 6.0 Runtime Permission Model
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android 6.0运行时权限模型
- en: How to schedule an alarm
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设置闹钟
- en: Receiving notification of device boot
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收设备启动通知
- en: Using AsyncTask for background work
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AsyncTask进行后台工作
- en: Adding speech recognition to your app
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将语音识别添加到您的应用中
- en: How to add Google sign-in to your app
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将谷歌登录添加到您的应用中
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: As we approach the end of this book, it's time to add the finishing touches
    to your application before releasing it to the Play Store. The recipes in this
    chapter cover the topics that can make a difference between users keeping your
    app or removing it.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们接近这本书的结尾时，是时候在将应用发布到Play商店之前为您的应用添加一些最后的修饰了。本章中的配方涵盖了可以在用户保留或删除您的应用之间产生差异的主题。
- en: Our first recipe, *The Android 6.0 Runtime permission model*, is certainly an
    important topic, possibly being the primary reason Android went from version 5.x
    to version 6! Changes to the Android permission model have been requested for
    some time, so this new model is a welcome change, at least for users.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一道菜，*Android 6.0运行时权限模型*，无疑是一个重要的话题，可能是Android从5.x版本升级到6.x版本的主要原因！对Android权限模型的更改已经请求了一段时间，所以这个新模型是一个受欢迎的改变，至少对于用户来说是这样。
- en: Next, we'll take a look at alarms in *How to schedule an alarm*. One of the
    primary benefits of alarms is that the OS is responsible for maintaining the alarm,
    even when your application is not running. Since alarms do not persist after rebooting
    the device, we'll also look at how to detect a device reboot so you can recreate
    your alarms in *Receiving notification of device boot*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看*如何设置闹钟*中的闹钟。闹钟的主要好处之一是操作系统负责维护闹钟，即使您的应用没有运行。由于闹钟在设备重启后不会持续存在，我们还将查看如何检测设备重启，以便您可以在*接收设备启动通知*中重新创建您的闹钟。
- en: Almost any serious Android application will need a way to perform potentially
    blocking tasks off the main thread. Otherwise, your app runs the risk of being
    perceived as sluggish, or worse, completely unresponsive. `AsyncTask` was designed
    to make it easier to create a background worker task, as we'll demonstrate in
    the *Using AsyncTask for background work* recipe.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎任何严肃的Android应用都需要一种方式来在主线程之外执行可能阻塞的任务。否则，您的应用可能会被认为运行缓慢，或者更糟，完全无响应。`AsyncTask`被设计用来简化创建后台工作任务的难度，正如我们将在*使用AsyncTask进行后台工作*配方中展示的那样。
- en: If you want your app to benefit from hands-free typing or voice recognition,
    take a look at the *Adding speech recognition to your app* recipe, in which we'll
    explore the Google Speech API.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望您的应用受益于免提输入或语音识别，请查看*将语音识别添加到您的应用中*配方，我们将探索Google语音API。
- en: Finally, we'll end the chapter with a recipe showing how to make your app more
    comfortable and encourage users to log in with the *How to add Google sign-in
    to your app* recipe.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将以*如何将谷歌登录添加到您的应用中*配方来结束本章，展示如何使您的应用更加舒适并鼓励用户登录。
- en: The Android 6.0 Runtime Permission Model
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android 6.0运行时权限模型
- en: The old security model was a sore point for many in Android. It's common to
    see reviews commenting on the permissions an app requires. Sometimes, permissions
    were unrealistic (such as a Flashlight app requiring internet permission), but
    other times, the developer had good reasons to request certain permissions. The
    main problem was that it was an all-or-nothing prospect.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 旧的安全模型是许多Android用户的痛点。经常看到评论提到应用所需的权限。有时，权限是不切实际的（例如，手电筒应用需要互联网权限），但有时开发者有很好的理由请求某些权限。主要问题是这是一个全有或全无的选择。
- en: This finally changed with the Android 6 Marshmallow (API 23) release. The new
    permission model still declares permissions in the manifest as before, but users
    have the option of selectively accepting or denying each permission. Users can
    even revoke a previously granted permission.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这最终随着Android 6 Marshmallow（API 23）的发布而改变。新的权限模型仍然像以前一样在清单中声明权限，但用户可以选择性地接受或拒绝每个权限。用户甚至可以撤销之前授予的权限。
- en: Although this is a welcome change for many, for a developer, it has the potential
    to break the code that was working before. We've talked about this permission
    change in the previous recipes, as it has far-reaching implications. This recipe
    will put it all together to serve as a single point of reference when implementing
    this change in your own apps.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这对许多人来说是一个受欢迎的变革，但对于开发者来说，它有可能破坏之前正常工作的代码。我们已经在之前的菜谱中讨论了这一权限变更，因为它具有深远的影响。这个菜谱将把所有内容整合在一起，以便在实现你自己的应用中的这一变更时作为一个单一的参考点。
- en: Google now requires apps to target Android 6.0 (API 23) and above to be included
    on the Play Store. If you haven't already updated your app, apps not updated will
    be removed by the end of the year (2018).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Google现在要求应用的目标为Android 6.0（API 23）或更高版本才能包含在Play Store中。如果你还没有更新你的应用，未更新的应用将在年底（2018年）被移除。
- en: Getting ready
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in Android Studio and call it `RuntimePermission`. Use
    the default Phone & Tablet option and select Empty Activity when prompted for
    Activity Type.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中创建一个新的项目，命名为`RuntimePermission`。使用默认的“手机和平板”选项，并在提示活动类型时选择“空活动”。
- en: The sample source code sets the minimum API to 23, but this is not required.
    If your `compileSdkVersion` is API 23 or above, the compiler will flag your code
    for the new security model.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 示例源代码将最小API设置为23，但这不是必需的。如果你的`compileSdkVersion`是API 23或更高，编译器将标记你的代码以使用新的安全模型。
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We need to start by adding our required permission to the manifest, then we''ll
    add a button to call our check permission code. Open the Android Manifest and
    follow these steps:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要首先将所需的权限添加到清单中，然后我们将添加一个按钮来调用我们的检查权限代码。打开Android Manifest并按照以下步骤操作：
- en: 'Add the following permission:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下权限：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Open `activity_main.xml` and replace the existing `TextView` with this button:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`activity_main.xml`并用此按钮替换现有的`TextView`：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Open `MainActivity.java` and add the following constant to the class:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainActivity.java`并将以下常量添加到类中：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add this method for a permission check:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加此方法进行权限检查：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add this method to request permission:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加此方法来请求权限：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add this method to show the explanation dialog:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加此方法来显示解释对话框：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add this method to handle the button click:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加此方法来处理按钮点击：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Override `onRequestPermissionsResult()` as follows:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下重写`onRequestPermissionsResult()`方法：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, you're ready to run the application on a device or emulator.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以在设备或模拟器上运行应用程序了。
- en: How it works...
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Using the new Runtime Permission model involves the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的运行时权限模型涉及以下步骤：
- en: Check to see whether you have the desired permissions
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查你是否拥有所需的权限
- en: If not, check whether we should display the rationale (meaning that the request
    was previously denied)
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果不是，检查是否应该显示理由（意味着请求之前已被拒绝）
- en: Request the permission; only the OS can display the permission request
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求权限；只有操作系统可以显示权限请求
- en: Handle the request response
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理请求响应
- en: 'Here are the corresponding methods:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是相应的函数：
- en: '`ContextCompat.checkSelfPermission`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ContextCompat.checkSelfPermission`'
- en: '`ActivityCompat.requestPermissions`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ActivityCompat.requestPermissions`'
- en: '`ActivityCompat.shouldShowRequestPermissionRationale`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ActivityCompat.shouldShowRequestPermissionRationale`'
- en: '`onRequestPermissionsResult`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onRequestPermissionsResult`'
- en: Even though you are requesting permissions at runtime, the desired permission
    must be listed in the Android Manifest. If the permission is not specified, the
    OS will automatically deny the request.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你在运行时请求权限，所需的权限也必须在Android Manifest中列出。如果没有指定权限，操作系统将自动拒绝请求。
- en: There's more...
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'You can grant/revoke permissions through the ADB with the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过ADB使用以下命令授予/撤销权限：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here''s an example to grant the `SEND_SMS` permission for our test app:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个为我们的测试应用授予`SEND_SMS`权限的示例：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: See also
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考也
- en: System Permissions Developer Docs: [https://developer.android.com/guide/topics/security/permissions.html](https://developer.android.com/guide/topics/security/permissions.html)
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统权限开发者文档：[https://developer.android.com/guide/topics/security/permissions.html](https://developer.android.com/guide/topics/security/permissions.html)
- en: See the following link on how Android 8 (API 26) modified the behavior of how
    permissions are granted: [https://developer.android.com/about/versions/oreo/android-8.0-changes#rmp](https://developer.android.com/about/versions/oreo/android-8.0-changes#rmp)
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅以下链接了解Android 8（API 26）如何修改了权限授予的行为：[https://developer.android.com/about/versions/oreo/android-8.0-changes#rmp](https://developer.android.com/about/versions/oreo/android-8.0-changes#rmp)
- en: For a Kotlin version of this recipe, see *Runtime Permission in Kotlin* in [Chapter
    16](939d2c0b-84d8-4093-a827-641186032dee.xhtml), *Getting Started with Kotlin*
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 Kotlin 版本的此菜谱，请参阅 [第 16 章](939d2c0b-84d8-4093-a827-641186032dee.xhtml) 的
    *Runtime Permission in Kotlin*，*Getting Started with Kotlin*
- en: How to schedule an alarm
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何安排闹钟
- en: 'Android provides `AlarmManager` to create and schedule alarms. Alarms offer
    the following features:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Android 提供了 `AlarmManager` 来创建和安排闹钟。闹钟提供以下功能：
- en: Schedule alarms for a set time or interval
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安排特定时间或间隔的闹钟
- en: Maintained by the OS, not your application, so alarms are triggered even if
    your application is not running or the device is asleep
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由操作系统维护，而不是您的应用程序，因此即使您的应用程序没有运行或设备处于睡眠状态，闹钟也会被触发
- en: Can be used to trigger periodic tasks (such as an hourly news update), even
    if your application is not running
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以用于触发周期性任务（如每小时新闻更新），即使您的应用程序没有运行
- en: Your app does not use resources (such as timers or background services), since
    the OS manages the scheduling
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的应用程序不使用资源（如计时器或后台服务），因为操作系统管理调度
- en: Alarms are not the best solution if you need a simple delay while your application
    is running (such as a short delay for a UI event.) For short delays, it's easier
    and more efficient to use a Handler, as we've done in several previous recipes.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在应用程序运行时需要简单的延迟（例如 UI 事件的短暂延迟），则 Alarms 不是最佳解决方案。对于短延迟，使用 Handler 更容易且更高效，正如我们在几个先前的菜谱中所做的那样。
- en: 'When using alarms, keep these best practices in mind:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用闹钟时，请记住以下最佳实践：
- en: Use as infrequent an alarm timing as possible
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能使用不频繁的闹钟时间
- en: Avoid waking up the device
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免唤醒设备
- en: Use as imprecise timing as possible; the more precise the timing, the more resources
    required
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能使用不精确的时间；时间越精确，所需的资源越多
- en: Avoid setting alarm times based on clock time (such as 12:00); add random adjustments
    if possible to avoid congestion on servers (especially important when checking
    for new content, such as weather or news)
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免根据时钟时间设置闹钟时间（例如 12:00）；如果可能，添加随机调整以避免服务器拥堵（特别是在检查新内容，如天气或新闻时尤为重要）
- en: 'Alarms have three properties, as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 闹钟有三个属性，如下所示：
- en: Alarm type (see in the following list)
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闹钟类型（见以下列表）
- en: Trigger time (if the time has already passed, the alarm is triggered immediately)
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发时间（如果时间已经过去，则闹钟立即触发）
- en: Pending Intent
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pending Intent
- en: 'A repeating alarm has the same three properties, plus an Interval:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 重复闹钟具有相同的三个属性，加上一个间隔：
- en: Alarm type (see the following list)
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闹钟类型（见以下列表）
- en: Trigger time (if the time has already passed, it triggers immediately)
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发时间（如果时间已经过去，则立即触发）
- en: Interval
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 间隔
- en: Pending Intent
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pending Intent
- en: 'There are four alarm types:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种闹钟类型：
- en: '`RTC` (**Real Time Clock**): This is based on the wall clock time. This does
    not wake'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RTC`（**实时时钟**）：这是基于墙上的时钟时间。这不会唤醒设备。'
- en: the device.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 设备。
- en: '`RTC_WAKEUP`: This is based on the wall clock time. This wakes the device if
    it'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RTC_WAKEUP`：这是基于墙上的时钟时间。如果设备处于睡眠状态，这将唤醒设备。'
- en: is sleeping.
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 设备处于睡眠状态。
- en: '`ELAPSED_REALTIME`: This is based on the time elapsed since the device boot.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ELAPSED_REALTIME`：这是基于设备启动以来经过的时间。'
- en: This does not wake the device.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这不会唤醒设备。
- en: '`ELAPSED_REALTIME_WAKEUP`: This is based on the time elapsed since the'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ELAPSED_REALTIME_WAKEUP`：这是基于设备启动以来经过的时间。'
- en: device boot. This wakes the device if it is sleeping.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 设备启动。如果设备处于睡眠状态，这将唤醒设备。
- en: Elapsed Real Time is better for time interval alarms, such as every 30 minutes.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Elapsed Real Time 对于时间间隔闹钟（如每 30 分钟）更好。
- en: Alarms do not persist after device reboots. All alarms are canceled when a device
    shuts down, so it is your app's responsibility to reset the alarms on device boot.
    (See the *Receive notification of device boot* recipe for more information.)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 闹钟在设备重启后不会持续存在。当设备关闭时，所有闹钟都会被取消，因此您需要在设备启动时负责重置闹钟。（有关更多信息，请参阅 *Receive notification
    of device boot* 菜谱。）
- en: The following recipe will demonstrate how to create alarms with `AlarmManager`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下菜谱将演示如何使用 `AlarmManager` 创建闹钟。
- en: Getting ready
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: Create a new project in Android Studio and call it `Alarms`. Use the default
    Phone & Tablet option and select Empty Activity when prompted for Activity Type.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建一个新的项目，命名为 `Alarms`。使用默认的 Phone & Tablet 选项，并在提示 Activity
    类型时选择 Empty Activity。
- en: How to do it...
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Setting an alarm requires a Pending Intent, which Android sends when the alarm
    is triggered. Therefore, we need to set up a Broadcast Receiving to capture the
    alarm intent. Our UI will consist of just a simple button to set the alarm. To
    start, open the Android Manifest and follow these steps:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 设置闹钟需要一个挂起意图，当闹钟被触发时，Android会发送这个意图。因此，我们需要设置一个广播接收器来捕获闹钟意图。我们的UI将仅包含一个简单的按钮来设置闹钟。首先，打开AndroidManifest文件，按照以下步骤操作：
- en: 'Add the following `<receiver>` to the `<application>` element at the same level
    as the existing `<activity>` element:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与现有`<activity>`元素同一级别的`<application>`元素中添加以下`<receiver>`：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Open `activity_main.xml` and replace the existing TextView with the
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`activity_main.xml`并将现有的TextView替换为
- en: 'following button:'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下按钮：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create a new Java class called `AlarmBroadcastReceiver` using the following
    code:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码创建一个新的Java类`AlarmBroadcastReceiver`：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Open `ActivityMain.java` and add the method for the button click:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`ActivityMain.java`并为按钮点击添加方法：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You're ready to run the application on a device or emulator.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在可以开始在设备或模拟器上运行应用程序了。
- en: How it works...
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Creating the alarm is done with this line of code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 创建闹钟是通过以下代码行完成的：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here''s the method signature:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是方法签名：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Prior to Android 4.4 KitKat (API 19), this was the method to request an exact
    time. Android 4.4 and later will consider this as an inexact time for efficiency,
    but will not deliver the intent prior to the requested time. (See `setExact()`
    as follows if you need an exact time.)
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android 4.4 KitKat（API 19）之前，这是请求确切时间的方法。Android 4.4及以后的版本将考虑这作为一个不精确的时间以提高效率，但不会在请求时间之前发送意图。（如果您需要确切的时间，请参见以下`setExact()`方法。）
- en: 'To set the alarm, we create a Pending Intent with our previously defined alarm
    action:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置闹钟，我们创建一个带有先前定义的闹钟动作的挂起意图：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is an arbitrary string and could be anything we want, but it needs to be
    unique, so we prepend our package name. We check for this action in the Broadcast
    Receiver's `onReceive()` callback.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个任意字符串，可以是任何我们想要的，但它需要是唯一的，因此我们需要在前面加上我们的包名。我们在广播接收器的`onReceive()`回调中检查这个动作。
- en: There's more...
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If you click the Set Alarm button and wait for thirty minutes, you will see
    the Toast when the alarm triggers. If you are too impatient to wait and click
    the Set Alarm button again before the first alarm is triggered, you won't get
    two alarms. Instead, the OS will replace the first alarm with the new alarm, since
    they both use the same Pending Intent. (If you need multiple alarms, you need
    to create different Pending Intents, such as using different Actions.)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击设置闹钟按钮并等待三十分钟，当闹钟触发时，您将看到Toast提示。如果您太急躁，在第一个闹钟触发之前再次点击设置闹钟按钮，您不会得到两个闹钟。相反，操作系统将用新的闹钟替换第一个闹钟，因为它们都使用了相同的挂起意图。（如果您需要多个闹钟，您需要创建不同的挂起意图，例如使用不同的动作。）
- en: Cancel the alarm
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消闹钟
- en: 'If you want to cancel the alarm, call the `cancel()` method by passing the
    same Pending Intent you have used to create the alarm. If we continue with our
    recipe, this is how it would look:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想取消闹钟，通过传递创建闹钟时使用的相同挂起意图调用`cancel()`方法。如果我们继续我们的菜谱，它将看起来像这样：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Repeating alarm
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重复闹钟
- en: 'If you want to create a repeating alarm, use the `setRepeating()` method. The
    Signature is similar to the `set()` method, but with an interval. This is shown
    as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想创建重复闹钟，请使用`setRepeating()`方法。签名与`set()`方法类似，但带有间隔。如下所示：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For the Interval, you can specify the interval time in milliseconds or use
    one of the predefined `AlarmManager` constants:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于间隔，您可以指定以毫秒为单位的间隔时间，或使用预定义的`AlarmManager`常量之一：
- en: '`INTERVAL_DAY`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INTERVAL_DAY`'
- en: '`INTERVAL_FIFTEEN_MINUTES`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INTERVAL_FIFTEEN_MINUTES`'
- en: '`INTERVAL_HALF_DAY`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INTERVAL_HALF_DAY`'
- en: '`INTERVAL_HALF_HOUR`'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INTERVAL_HALF_HOUR`'
- en: '`INTERVAL_HOUR`'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INTERVAL_HOUR`'
- en: See also
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: AlarmManager Developer Docs: [https://developer.android.com/reference/android/app/AlarmManager.html](https://developer.android.com/reference/android/app/AlarmManager.html)
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AlarmManager开发者文档：[https://developer.android.com/reference/android/app/AlarmManager.html](https://developer.android.com/reference/android/app/AlarmManager.html)
- en: Receiving notification of device boot
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接收设备启动通知
- en: Android sends out many intents during its lifetime. One of the first intents
    sent is `ACTION_BOOT_COMPLETED`. If your application needs to know when the device
    boots, you need to capture this intent.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Android在其生命周期中会发送许多意图。其中第一个发送的意图是`ACTION_BOOT_COMPLETED`。如果您的应用程序需要知道设备何时启动，您需要捕获这个意图。
- en: This recipe will walk you through the steps required to be notified when the
    device boots.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱将指导您完成在设备启动时接收通知所需的步骤。
- en: Getting ready
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in Android Studio and call it `DeviceBoot`. Use the default
    Phone & Tablet option and select Empty Activity when prompted for Activity Type.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中创建一个新的项目，命名为`DeviceBoot`。使用默认的Phone & Tablet选项，并在提示活动类型时选择Empty
    Activity。
- en: How to do it...
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To start, open the Android Manifest and follow these steps:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开AndroidManifest并按照以下步骤操作：
- en: 'Add the following permission:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下权限：
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add the following `<receiver>` to the `<application>` element, at the same
    level as the existing `<activity>` element:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`<receiver>`添加到`<application>`元素中，与现有的`<activity>`元素处于同一级别：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create a new Java class called `BootBroadcastReceiver` using the following
    code:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码创建一个新的Java类`BootBroadcastReceiver`：
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Reboot the device to see the Toast.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重启设备以查看Toast。
- en: How it works...
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the device boots, Android will send the `BOOT_COMPLETED` intent. As long
    as our application has the permission to receive the intent, we will receive notifications
    in our Broadcast Receiver.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当设备启动时，Android会发送`BOOT_COMPLETED`意图。只要我们的应用程序有接收该意图的权限，我们就会在Broadcast Receiver中收到通知。
- en: 'There are three aspects to make this work:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这一切工作，有三个方面需要考虑：
- en: A permission for `RECEIVE_BOOT_COMPLETED`
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RECEIVE_BOOT_COMPLETED`权限'
- en: Adding both `BOOT_COMPLETED` and `DEFAULT` to the receiver intent filter
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在接收器意图过滤器中添加`BOOT_COMPLETED`和`DEFAULT`
- en: Checking for the `BOOT_COMPLETED` action in the Broadcast Receiver
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Broadcast Receiver中检查`BOOT_COMPLETED`动作
- en: Obviously, you'll want to replace the Toast message with your own code, such
    as for recreating any alarms you might need.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你将想要用你自己的代码替换Toast消息，例如重新创建你可能需要的任何闹钟。
- en: There's more...
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If you followed the previous recipe, then you already have a Broadcast Receiver.
    You don''t need a separate `BroadcastReceiver` for each action, just check for
    each action as needed. Here''s an example if we need to handle another action:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遵循了前面的食谱，那么你已经有了一个Broadcast Receiver。你不需要为每个动作创建单独的`BroadcastReceiver`，只需按需检查每个动作即可。以下是一个示例，如果我们需要处理另一个动作：
- en: '[PRE22]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: See also
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Intent Developer Docs: [https://developer.android.com/reference/android/content/Intent.html](https://developer.android.com/reference/android/content/Intent.html)
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Intent开发者文档：[https://developer.android.com/reference/android/content/Intent.html](https://developer.android.com/reference/android/content/Intent.html)
- en: Using the AsyncTask for background work
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AsyncTask进行后台工作
- en: Throughout this book, we have mentioned the importance of not blocking the main
    thread. Performing long running operations on the main thread can cause your application
    to appear sluggish, or worse, hang. If your application doesn't respond within
    about 5 seconds, the system will likely display the **Application Not Responding**
    (**ANR**) dialog with the option to terminate your app. (This is something you
    will want to avoid as it's a good way to get your app uninstalled.)
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，我们提到了不阻塞主线程的重要性。在主线程上执行长时间运行的操作可能会导致你的应用程序看起来反应迟缓，或者更糟，挂起。如果你的应用程序在约5秒内没有响应，系统可能会显示**应用程序无响应**（**ANR**）对话框，并提供终止你的应用程序的选项。（你希望避免这种情况，因为这可能是你的应用程序被卸载的好方法。）
- en: 'Android applications use a single thread model with two simple rules, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Android应用程序使用单线程模型，有两个简单的规则，如下所示：
- en: Don't block the main thread
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要阻塞主线程
- en: Perform all UI operations *on* the main thread
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有UI操作都在主线程上执行
- en: When Android starts your application, it automatically creates the main (or
    UI) thread. This is the thread from which all UI operations must be called. The
    first rule is "don't block the main thread." This means that you need to create
    a background, or a worker, thread for any long-running or potentially-blocking
    task. This is why all network-based tasks should be performed off the main thread.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当Android启动你的应用程序时，它会自动创建主（或UI）线程。这是所有UI操作必须调用的线程。第一条规则是“不要阻塞主线程。”这意味着你需要为任何长时间运行或可能阻塞的任务创建一个后台或工作线程。这就是为什么所有基于网络的任务都应该在主线程之外执行。
- en: 'Android offers the following options when working with background threads:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当与后台线程一起工作时，Android提供了以下选项：
- en: '`Activity.runOnUiThread()`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Activity.runOnUiThread()`'
- en: '`View.post()`'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`View.post()`'
- en: '`View.postDelayed()`'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`View.postDelayed()`'
- en: '`Handler`'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Handler`'
- en: '`AsyncTask`'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AsyncTask`'
- en: This recipe will explore the `AsyncTask` class; since it was created previously,
    you won't have to use the Handler or post methods directly.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将探讨`AsyncTask`类；由于它之前已经被创建，你不需要直接使用Handler或post方法。
- en: Getting ready
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in Android Studio and call it `AsyncTask`. Use the default
    Phone & Tablet option and select Empty Activity when prompted for Activity Type.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建一个新的项目，命名为 `AsyncTask`。使用默认的 Phone & Tablet 选项，并在提示 Activity
    类型时选择 Empty Activity。
- en: How to do it...
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We only need a single button for this example. Open `activity_main.xml` and
    follow
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要一个按钮来演示这个例子。打开 `activity_main.xml` 并按照
- en: 'these steps:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤：
- en: 'Replace the existing TextView with the following button:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下按钮替换现有的 TextView：
- en: '[PRE23]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Open `MainActivity.java` and add the following global variable:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainActivity.java` 并添加以下全局变量：
- en: '[PRE24]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Add the `AsyncTask` class:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `AsyncTask` 类：
- en: '[PRE25]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add the following code to `onCreate()` to initialize the button:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `onCreate()` 以初始化按钮：
- en: '[PRE26]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add the method for the button click:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加按钮点击的方法：
- en: '[PRE27]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You're ready to run the application on a device or emulator.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以运行应用程序在设备或模拟器上了。
- en: How it works...
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This is a very simple example of an `AsyncTask` just to show it working. Technically,
    only `doInBackground()` is required, but usually, you want to receive notifications when
    it finishes, which is done via `onPostExecute()` .
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的 `AsyncTask` 示例，只是为了展示它的工作原理。技术上，只需要 `doInBackground()`，但通常，你希望在它完成时收到通知，这是通过
    `onPostExecute()` 实现的。
- en: An `AsyncTask` works by creating a worker thread for the `doInBackground()`
    method, then responds on the UI thread in the `onPostExecute()` callback. Our
    example uses the Thread.Sleep() method to put the thread to sleep for the specified
    time (1000 milliseconds in our example). Since we call CountingTask with the value
    10, the background task is going to take 10 seconds. This example illustrates
    that in fact the task is executing in the background since otherwise, Android
    would display the ANR dialog after 5 seconds.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncTask` 通过为 `doInBackground()` 方法创建一个工作线程来工作，然后在 `onPostExecute()` 回调中在
    UI 线程上响应。我们的示例使用 `Thread.Sleep()` 方法使线程休眠指定的时间（在我们的示例中是1000毫秒）。由于我们用值10调用 `CountingTask`，后台任务将花费10秒钟。这个例子说明了实际上任务是在后台执行的，因为否则，Android
    将在5秒后显示 ANR 对话框。'
- en: It's also important to note how we waited until `onPostExecute()` is called
    before we do any UI actions (such as enabling the button in our example.) If we
    attempt to modify the UI in the worker thread, the code would either not compile
    or throw a runtime exception. You should also note how we instantiated a new `CountingTask`
    object on each button click. This is because an `AsyncTask` can only execute once.
    Attempting to call execute again will also throw an exception.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 也很重要的是要注意，我们在执行任何 UI 操作（如在我们的示例中启用按钮）之前，等待 `onPostExecute()` 被调用。如果我们尝试在工作线程中修改
    UI，代码将无法编译或抛出运行时异常。你也应该注意，我们如何在每次按钮点击时实例化一个新的 `CountingTask` 对象。这是因为 `AsyncTask`
    只能执行一次。再次尝试调用 execute 也会抛出异常。
- en: There's more...
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: At its minimum, the `AsyncTask` can be very simple but it is still very flexible
    with more options available if you need them. When using an `AsyncTask` with an
    Activity, it's important to understand when the Activity is destroyed and recreated
    (such as during an orientation change), the `AsyncTask` continues to run. This
    can leave your `AsyncTask` orphaned and it might respond to the now destroyed
    activity (causing a `NullPointer` exception). For this reason, it's common to
    use the `AysncTask` with a Fragment (which is not destroyed on screen rotation).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单的情况下，`AsyncTask` 可以非常简单，但它仍然非常灵活，如果你需要的话，还有更多选项可用。当使用 `AsyncTask` 与 Activity
    时，了解 Activity 在何时被销毁和重新创建（例如，在方向改变期间）很重要，`AsyncTask` 会继续运行。这可能会使你的 `AsyncTask`
    成为一个孤儿，并且它可能会对现在已销毁的活动做出响应（导致 `NullPointer` 异常）。因此，通常使用 `AsyncTask` 与 Fragment（在屏幕旋转时不会被销毁）一起使用。
- en: Parameter types
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数类型
- en: 'For many people, the most confusing aspect of the `AsyncTask` is the parameters
    when creating their own class. If you look at our class declaration, there are
    three parameters for the `AsyncTask`; they are defined as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多人来说，`AsyncTask` 最令人困惑的方面是在创建自己的类时参数。如果你查看我们的类声明，`AsyncTask` 有三个参数；它们定义如下：
- en: '[PRE28]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The parameters are generic types and are used as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 参数是泛型类型，并按以下方式使用：
- en: '**Params**: This is the parameter type to call `doInBackground()`'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参数**：这是用于调用 `doInBackground()` 的参数类型'
- en: '**Progress**: This is the parameter type to post updates'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进度**：这是用于发布更新的参数类型'
- en: '**Result**: This is the parameter type to post results'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结果**：这是用于发布结果的参数类型'
- en: When you declare your own class, substitute the parameters with the variable
    type you need.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当你声明自己的类时，用你需要的变量类型替换参数。
- en: 'Here''s the process flow for the `AsyncTask` and how the preceding parameters
    are used:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `AsyncTask` 的流程以及如何使用前面的参数的示例：
- en: '`onPreExecute()`: This is called before `doInBackground()` begins'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onPreExecute()`: 在 `doInBackground()` 开始之前调用'
- en: '`doInBackground(Params)`: This executes in a background thread'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doInBackground(Params)`: 这个方法在后台线程中执行'
- en: '`onProgressUpdate(Progress)`: This is called (on the UI thread) in response'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onProgressUpdate(Progress)`: 当 `doInBackground()` 开始之前，这个方法会在 UI 线程中被调用。'
- en: to the calling of `publishProgress(Progress)` in the worker thread
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到工作线程中调用 `publishProgress(Progress)`
- en: '`onPostExecute(Result)`: This is called (on the UI thread) when the worker'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onPostExecute(Result)`: 当工作线程中的 `publishProgress(Progress)` 被调用后，这个方法会在 UI
    线程中被调用。'
- en: thread finishes
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 线程结束
- en: Canceling the task
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消任务
- en: 'To cancel the task, call the cancel method on the object as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 取消任务，请按照以下方式在对象上调用 cancel 方法：
- en: '[PRE29]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You will need to have the object instance to access the `cancel()` method. (We
    did not save the object in our previous example.) After setting `cancel(true)`,
    calling `isCancelled()` in `doInBackground()` will return `true`, allowing you
    to exit a loop. If cancelled, `onCancelled()` will be called instead of `onPostExecute()`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要拥有对象实例来访问 `cancel()` 方法。（在我们的上一个示例中，我们没有保存对象。）在设置 `cancel(true)` 之后，在 `doInBackground()`
    中调用 `isCancelled()` 将返回 `true`，允许您退出循环。如果被取消，将调用 `onCancelled()` 而不是 `onPostExecute()`。
- en: See also
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: AsyncTask Developer Docs: http://developer.android.com/reference/android/os/AsyncTask.html
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AsyncTask 开发者文档：http://developer.android.com/reference/android/os/AsyncTask.html
- en: RXJava for Android is another option and gaining much traction in Android development: [https://github.com/ReactiveX/RxAndroid](https://github.com/ReactiveX/RxAndroid)
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RXJava for Android 是另一个选项，在 Android 开发中获得了很大的关注：[https://github.com/ReactiveX/RxAndroid](https://github.com/ReactiveX/RxAndroid)
- en: Definitely take a look at the Android Architecture Components included with
    the Android JetPack: [https://developer.android.com/topic/libraries/architecture/](https://developer.android.com/topic/libraries/architecture/)
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一定要查看 Android JetPack 中包含的 Android 架构组件：[https://developer.android.com/topic/libraries/architecture/](https://developer.android.com/topic/libraries/architecture/)
- en: Adding speech recognition to your app
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将语音识别添加到您的应用程序中
- en: Android 2.2 (API 8) introduced speech recognition in Android, and it continues
    to improve with almost every new major Android release. This recipe will demonstrate
    how to add speech recognition to your app using the Google Speech service.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Android 2.2 (API 8) 在 Android 中引入了语音识别功能，并且几乎在每次新的主要 Android 版本发布中都得到了改进。本食谱将演示如何使用
    Google 语音服务将语音识别添加到您的应用程序中。
- en: Getting ready
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in Android Studio and call it `SpeechRecognition`. Use
    the default Phone & Tablet option and select Empty Activity when prompted for
    Activity Type.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建一个新的项目，并将其命名为 `SpeechRecognition`。使用默认的 Phone & Tablet 选项，并在提示活动类型时选择
    Empty Activity。
- en: How to do it...
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'We''ll start by adding a Speak Now (or microphone) button to the layout, then
    we''ll add the necessary code to call the speech recognizer. Open `activity_main.xml`
    and follow these steps:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将在布局中添加一个“现在说话”（或麦克风）按钮，然后添加调用语音识别器所需的代码。打开 `activity_main.xml` 并按照以下步骤操作：
- en: 'Replace the existing `TextView` with the following XML:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将现有的 `TextView` 替换为以下 XML：
- en: '[PRE30]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Define the `REQUEST_SPEECH` constant:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `REQUEST_SPEECH` 常量：
- en: '[PRE31]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Add the following code to the existing `onCreate()` callback:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到现有的 `onCreate()` 回调中：
- en: '[PRE32]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Add the button click method:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加按钮点击方法：
- en: '[PRE33]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add the following code to override the `onActivityResult()` callback:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到重写的 `onActivityResult()` 回调中：
- en: '[PRE34]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You're ready to run the application on a device or emulator.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在可以开始在设备或模拟器上运行应用程序了。
- en: How it works...
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The work here is done by the Google Speech Recognizer included in Android. To
    make sure the service is available on the device, we call `PackageManager` in
    `onCreate()`. If at least one activity is registered to handle the `RecognizerIntent.ACTION_RECOGNIZE_SPEECH`
    intent, then we know it's available. If no activities are available, we display
    a Toast indicating speech recognition is not available and disable the mic button.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的工作是由 Android 中包含的 Google 语音识别器完成的。为了确保服务在设备上可用，我们在 `onCreate()` 中调用 `PackageManager`。如果至少有一个活动注册来处理
    `RecognizerIntent.ACTION_RECOGNIZE_SPEECH` intent，那么我们知道它是可用的。如果没有可用的活动，我们将显示一个
    Toast，指示语音识别不可用，并禁用麦克风按钮。
- en: 'The button click starts the recognition process by calling an intent created
    with `RecognizerIntent.ACTION_RECOGNIZE_SPEECH`. The `EXTRA_LANGUAGE_MODEL` parameter
    is required and has the following two choices:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮点击通过调用使用 `RecognizerIntent.ACTION_RECOGNIZE_SPEECH` 创建的 intent 来启动识别过程。`EXTRA_LANGUAGE_MODEL`
    参数是必需的，并且有以下两个选项：
- en: '`LANGUAGE_MODEL_FREE_FORM`'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LANGUAGE_MODEL_FREE_FORM`'
- en: '`LANGUAGE_MODEL_WEB_SEARCH`'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LANGUAGE_MODEL_WEB_SEARCH`'
- en: We get the result back in the `onActivityResult()` callback. If the result equals `RESULT_OK`,
    then we should have a list of words recognized, which we can retrieve using `getStringArrayListExtra()`.
    The array list will be ordered starting with the highest recognition confidence.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `onActivityResult()` 回调中获取结果。如果结果等于 `RESULT_OK`，则我们应该有一个识别出的单词列表，我们可以使用
    `getStringArrayListExtra()` 来检索它。数组列表将按识别置信度从高到低排序。
- en: 'If you want to retrieve the confidence rating, retrieve the float array using
    `EXTRA_CONFIDENCE_SCORES`. Here''s an example:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想获取置信度评分，请使用 `EXTRA_CONFIDENCE_SCORES` 获取浮点数组。以下是一个示例：
- en: '[PRE35]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The confidence rating is optional and may not be present. A score of 1.0 indicates
    highest confidence, while 0.0 indicates lowest confidence.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 置信度评分是可选的，可能不存在。1.0 分表示最高置信度，而 0.0 分表示最低置信度。
- en: There's more...
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'Using the intent is a quick and easy way to get speech recognition; however,
    if you would prefer not to use the default Google activity, you can call the `SpeechRecognizer`
    class directly. Here''s an example of how to instantiate the class:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 使用意图是一个快速简单的方法来获取语音识别；然而，如果你不想使用默认的 Google 活动，你可以直接调用 `SpeechRecognizer` 类。以下是如何实例化类的示例：
- en: '[PRE36]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You will need to add the `RECORD_AUDIO` permission and implement the `RecognitionListener`
    class to handle the speech events. (See the following links for more information.)
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要添加 `RECORD_AUDIO` 权限并实现 `RecognitionListener` 类来处理语音事件。（有关更多信息，请参阅以下链接。）
- en: See also
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: RecognizerIntent Developer Docs: [http://developer.android.com/reference/android/speech/RecognizerIntent.html](http://developer.android.com/reference/android/speech/RecognizerIntent.html)
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RecognizerIntent 开发者文档：[http://developer.android.com/reference/android/speech/RecognizerIntent.html](http://developer.android.com/reference/android/speech/RecognizerIntent.html)
- en: SpeechRecognizer Developer Docs: [http://developer.android.com/reference/android/speech/SpeechRecognizer.html](http://developer.android.com/reference/android/speech/SpeechRecognizer.html)
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SpeechRecognizer 开发者文档：[http://developer.android.com/reference/android/speech/SpeechRecognizer.html](http://developer.android.com/reference/android/speech/SpeechRecognizer.html)
- en: RecognitionListener Developer Docs: [http://developer.android.com/reference/android/speech/RecognitionListener.html](http://developer.android.com/reference/android/speech/RecognitionListener.html)
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RecognitionListener 开发者文档：[http://developer.android.com/reference/android/speech/RecognitionListener.html](http://developer.android.com/reference/android/speech/RecognitionListener.html)
- en: How to add Google sign-in to your app
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何将 Google 登录添加到你的应用
- en: '*Google sign in* allows your users to sign in to your application using their
    Google credentials. This option offers several advantages to your user, including
    the following:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '*Google 登录* 允许你的用户使用他们的 Google 凭据登录到你的应用程序。此选项为你的用户提供以下优势：'
- en: Confidence because they're using Google
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 置信度，因为他们使用 Google
- en: Convenience since they can use their existing account
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方便之处在于他们可以使用现有的账户
- en: 'There are also several advantages for you, the developer:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你，作为开发者，也有一些优势：
- en: Convenience of not having to write your own authentication server
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要编写自己的身份验证服务器的便利性
- en: More users logging in to your app
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多用户登录到你的应用
- en: 'This recipe will walk you through the process of adding Google sign-in to your
    application. Here''s a screenshot showing the "GoogleSignin" button in the application
    that we''ll create in the recipe:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将指导你将 Google 登录添加到你的应用程序中。以下是一个截图，显示了我们将要在食谱中创建的应用程序中的 "GoogleSignin" 按钮：
- en: '![](img/eb69fe5e-d18a-4499-8cf6-ad9e5ede4c5c.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eb69fe5e-d18a-4499-8cf6-ad9e5ede4c5c.png)'
- en: Getting ready
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in Android Studio and call it `GoogleSignIn`. Use the default
    Phone & Tablet option and select Empty Activity when prompted for Activity Type.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建一个新的项目，并将其命名为 `GoogleSignIn`。使用默认的 Phone & Tablet 选项，并在提示活动类型时选择
    Empty Activity。
- en: 'Google sign-in uses the Google Services plugin, which requires a Google Services
    Configuration file, which is available from the Google Developer Console. To create
    the configuration file, you will need the following information:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Google 登录使用 Google 服务插件，这需要一个 Google 服务配置文件，该文件可以从 Google 开发者控制台获取。要创建配置文件，你需要以下信息：
- en: Your application package name
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的应用程序包名
- en: Your signing certificate's SHA-1 hash code (see the *Authenticating Your Client*
    link at the end of the recipe for more information)
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的签名证书的 SHA-1 哈希码（有关更多信息，请参阅食谱末尾的 *Authenticating Your Client* 链接）
- en: 'When you have the information, log in to this Google link and follow the wizard
    to enable sign-in:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有了信息，登录到这个 Google 链接，并按照向导启用登录：
- en: '[https://developers.google.com/identity/sign-in/android/start-integrating?refresh=1#configure_a_console_name_project](https://developers.google.com/identity/sign-in/android/start-integrating?refresh=1#configure_a_console_name_project)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developers.google.com/identity/sign-in/android/start-integrating?refresh=1#configure_a_console_name_project](https://developers.google.com/identity/sign-in/android/start-integrating?refresh=1#configure_a_console_name_project)'
- en: If you are downloading the source files, you will need to create a new package
    name when following the preceding steps, as the existing package name has already
    been registered.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在下载源文件，您需要在遵循前面的步骤时创建一个新的包名，因为现有的包名已经被注册。
- en: How to do it...
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'After completing the preceding *Getting ready* section, follow these steps:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成前面的 *准备就绪* 部分后，按照以下步骤操作：
- en: Copy the `google-services.json` file you downloaded in the *Getting ready* section
    to your app folder (`<project folder>\GoogleSignIn\app`)
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将在 *准备就绪* 部分下载的 `google-services.json` 文件复制到您的应用文件夹中（`<项目文件夹>\GoogleSignIn\app`）
- en: 'Open the app module Gradle build file, `build.gradle (Module: app)`, and add
    the following statement to the dependencies section:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '打开应用模块的 Gradle 构建文件，`build.gradle (Module: app)`，并在依赖项部分添加以下语句：'
- en: '[PRE37]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Open `activity_main.xml` and replace the existing `TextView` with the following
    XML:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `activity_main.xml` 并将现有的 `TextView` 替换为以下 XML：
- en: '[PRE38]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Open `MainActivity.java` and add the following global declarations:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainActivity.java` 并添加以下全局声明：
- en: '[PRE39]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Add the following code to the existing `onCreate()`:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到现有的 `onCreate()` 中：
- en: '[PRE40]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Add the `signIn()` method:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `signIn()` 方法：
- en: '[PRE41]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Create an override for the `onActivityResult()` callback as follows:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下创建 `onActivityResult()` 回调的覆盖：
- en: '[PRE42]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You're ready to run the application on a device or emulator.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在可以运行应用程序在设备或模拟器上。
- en: How it works...
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Google has made it relatively easy to add Google sign-in with their `GoogleSignInClient` and
    `GoogleSignInOptions` APIs. First, we create a `GoogleSignInOptions` object with
    the builder. This is where we specify the sign-in options we want, such as requesting
    email ID. Then, call the `GoogleSignIn.getClient()` method to get the `GoogleSignInClient`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: Google 通过他们的 `GoogleSignInClient` 和 `GoogleSignInOptions` API 使添加 Google 登录变得相对简单。首先，我们使用构建器创建一个
    `GoogleSignInOptions` 对象。这是我们指定我们想要的登录选项的地方，例如请求电子邮件 ID。然后，调用 `GoogleSignIn.getClient()`
    方法来获取 `GoogleSignInClient`。
- en: 'When the user clicks on the Google sign-in button (created with the `com.google.android.gms.common.SignInButton` class),
    we send an Intent for `GoogleSignInApi` to the handle. We process the result in
    `onActivityResult()`. If the sign-in was successful, we can get the account details.
    In our example, we just get the email, but additional information is available
    such as the following:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击 Google 登录按钮（使用 `com.google.android.gms.common.SignInButton` 类创建）时，我们向处理程序发送一个
    `GoogleSignInApi` 的 Intent。我们在 `onActivityResult()` 中处理结果。如果登录成功，我们可以获取账户详情。在我们的示例中，我们只获取电子邮件，但还有其他附加信息，例如以下内容：
- en: '`getDisplayName()`: This is the display name'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getDisplayName()`: 这是显示名称'
- en: '`getEmail()`: The email address'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getEmail()`: 电子邮件地址'
- en: '`getId()`: The unique ID for the Google account'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getId()`: Google 账户的唯一 ID'
- en: '`getPhotoUrl()`: The display photo'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getPhotoUrl()`: 显示照片'
- en: '`getIdToken()`: This is for backend authentication'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getIdToken()`: 这用于后端身份验证'
- en: Refer to the *GoogleSignInAccount* link in the *See also* section for a complete
    list.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 参考在“另请参阅”部分中的 *GoogleSignInAccount* 链接以获取完整列表。
- en: There's more...
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: What if you want to check whether the user has already signed in?
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想检查用户是否已经登录过？
- en: '[PRE43]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If the account is not null, then you have the details for the last sign-in.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果账户不为空，那么您就有最后一次登录的详细信息。
- en: See also
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Google link for authenticating your client: [https://developers.google.com/android/guides/client-auth](https://developers.google.com/android/guides/client-auth)
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google 链接用于验证您的客户端：[https://developers.google.com/android/guides/client-auth](https://developers.google.com/android/guides/client-auth)
- en: GoogleSignInAccount Developer Docs: [https://developers.google.com/android/reference/com/google/android/gms/auth/api/signin/GoogleSignInAccount](https://developers.google.com/android/reference/com/google/android/gms/auth/api/signin/GoogleSignInAccount)
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GoogleSignInAccount 开发者文档：[https://developers.google.com/android/reference/com/google/android/gms/auth/api/signin/GoogleSignInAccount](https://developers.google.com/android/reference/com/google/android/gms/auth/api/signin/GoogleSignInAccount)
