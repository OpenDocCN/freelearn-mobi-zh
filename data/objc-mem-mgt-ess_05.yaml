- en: Chapter 5. Managing Your Application Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 管理您的应用程序数据
- en: 'In this chapter, you will be introduced to the concept of managing your application
    data to ensure that your application will perform at an optimal level during runtime.
    The following topics will be covered:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解管理应用程序数据的概念，以确保您的应用程序在运行时表现最佳。以下内容将涵盖：
- en: Resource optimization
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源优化
- en: Disk and memory caching
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 磁盘和内存缓存
- en: Serialization
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列化
- en: Different forms of data saving
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同形式的数据保存
- en: Pros and cons of various data saving methods
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种数据保存方法的优缺点
- en: We will also cover some common pitfalls and assumptions that people commonly
    associate with the development of iOS applications. One example will be image
    loading, where if the developers are not careful in planning the proper architecture
    of their application, they will encounter situations where the application will
    lag or run out of memory and lead to an application crash.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将涵盖一些常见的陷阱和假设，人们通常将这些与iOS应用程序的开发联系起来。一个例子是图片加载，如果开发者没有仔细规划他们应用程序的正确架构，他们可能会遇到应用程序卡顿或内存不足的情况，从而导致应用程序崩溃。
- en: Device memory
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备内存
- en: As with all computing devices, iPads and iPhones have a finite amount of memory
    and you may be tempted to develop applications without any concern about the memory
    usage. Doing so is not ideal for development as memory optimizing and management
    should always be at the top of your mind when doing any type of development, regardless
    of whatever platform you will be developing on.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 就像所有计算设备一样，iPad和iPhone都有有限的内存，您可能会被诱惑在不考虑内存使用的情况下开发应用程序。这样做并不理想，因为无论您在哪个平台上进行开发，内存优化和管理都应该始终是您心中的首要任务。
- en: 'Let''s take a look at the amount of memory that each of the iOS devices have,
    and we will start with iPhones:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看iOS设备中每个设备有多少内存，我们将从iPhone开始：
- en: '|   | iPhone 4S | iPhone 5 | iPhone 5C | iPhone 5S |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '|   | iPhone 4S | iPhone 5 | iPhone 5C | iPhone 5S |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| **RAM** | 512 MB | 1 GB | 1 GB | 1 GB |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| **RAM** | 512 MB | 1 GB | 1 GB | 1 GB |'
- en: 'Here is the RAM for iPads:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是iPad的RAM：
- en: '|   | iPad Air | iPad Mini 2 | iPad Mini Wi-Fi + Cellular | iPad 2 Wi-Fi +
    3G | iPad Mini Wi-Fi | iPad 3 Wi-Fi | iPad 3 Wi-Fi + Cellular | iPad 4 Wi-Fi |
    iPad 2 Wi-Fi |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '|   | iPad Air | iPad Mini 2 | iPad Mini Wi-Fi + Cellular | iPad 2 Wi-Fi +
    3G | iPad Mini Wi-Fi | iPad 3 Wi-Fi | iPad 3 Wi-Fi + Cellular | iPad 4 Wi-Fi |
    iPad 2 Wi-Fi |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| **RAM** | 1 GB | 1 GB | 512 MB | 512 MB | 512 MB | 1 GB | 1 GB | 1 GB | 512
    MB |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| **RAM** | 1 GB | 1 GB | 512 MB | 512 MB | 512 MB | 1 GB | 1 GB | 1 GB | 512
    MB |'
- en: Now, the amount of memory does look impressive as you fondly remember the days
    of old, where your old desktop ran on 256 MB of RAM, but do remember that iOS
    does not let you play with the full 512 MB or 1 GB RAM. The OS will allocate some
    to system processes in your device, and you will only get a subset of the available
    RAM for your application.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，内存的量看起来确实很令人印象深刻，您可能会深情地回忆起那些旧日子，当时您的旧台式机运行在256 MB的RAM上，但请记住，iOS不会让您玩转完整的512
    MB或1 GB RAM。操作系统会为您的设备中的系统进程分配一些，您将只能获得可用RAM的一个子集用于您的应用程序。
- en: In your application, everything will occupy memory and storage space. Some of
    the biggest culprits are binary assets, such as videos and images, which can be
    total resource hogs to even your class objects that can take up precious space
    if you do not take note of them when doing your development. So, let's start with
    image optimization as almost every application will make use of images in one
    way or another.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的应用程序中，所有内容都将占用内存和存储空间。其中一些最大的罪魁祸首是二进制资源，例如视频和图片，它们甚至可能成为您类对象的大消耗者，如果您在开发时没有注意到它们，它们可能会占用宝贵的空间。因此，让我们从图片优化开始，因为几乎每个应用程序都会以某种方式使用图片。
- en: Image optimization
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图片优化
- en: 'Any application will look boring and drab without the usage of `.png` and some
    nice images. However, one thing about images is that they take up much more memory
    than their file size implies. A single 1 MB `.png` file can occupy double or triple
    their memory size when loaded into the memory. The reason is because PNG is basically
    a compressed file format, such as a ZIP file. So, all the image data is compressed
    into a PNG file and when your application needs to display your PNG image. It
    needs to load the PNG file into memory, uncompress it, and then it will be able
    to get the image data to be used by your code and will consume more memory in
    the process. So, if your application has 20 MB of PNG files, you are easily looking
    at 40 MB or more of RAM allocation just for images. So, a few tips for image optimization
    are:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 任何应用程序如果没有使用 `.png` 格式和一些漂亮的图片，看起来都会显得单调乏味。然而，关于图片的一个问题是，它们占用的内存比文件大小所暗示的要多得多。一个单独的
    1 MB `.png` 文件在加载到内存中时，可能会占用其内存大小的两倍或三倍。原因是 PNG 基本上是一种压缩文件格式，就像 ZIP 文件一样。因此，所有的图像数据都被压缩进
    PNG 文件中，当你的应用程序需要显示 PNG 图像时，它需要将 PNG 文件加载到内存中，解压缩它，然后才能获取用于代码的图像数据，在这个过程中会消耗更多的内存。所以，如果你的应用程序有
    20 MB 的 PNG 文件，你可能会看到 40 MB 或更多的 RAM 分配仅用于图像。因此，以下是一些图像优化的技巧：
- en: Save your image as PNG-8 instead of PNG-24 as PNG-8 consumes less RAM than their
    equivalent PNG-24\. Only use PNG-24 if you need the alpha channel for transparency.
    The difference between PNG-8 and PNG-24 is the image quality and the number of
    colors that you can have. The 8 and 24 means 8-bits per pixel and 24-bits per
    pixel respectively. So, PNG-8 can only support up to 256 colors while PNG-24 can
    support up to 16 million colors, so PNG-24 is the best option if you need to display
    images with a lot of colors such as photographs, while logos and user interface
    elements such as icons can probably get by with PNG-8\. PNG-24 also supports alpha
    transparency, which is good for images that need to have a transparent background.
    So, knowing which format to use in which situation will help you in reducing the
    memory consumption of your application.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将你的图像保存为 PNG-8 而不是 PNG-24，因为 PNG-8 比等效的 PNG-24 消耗更少的 RAM。只有在你需要透明通道时才使用 PNG-24。PNG-8
    和 PNG-24 之间的区别在于图像质量和你可以拥有的颜色数量。8 和 24 分别代表每像素 8 位和每像素 24 位。因此，PNG-8 只能支持多达 256
    种颜色，而 PNG-24 可以支持多达 1600 万种颜色，所以如果你需要显示颜色丰富的图像，如照片，PNG-24 是最佳选择，而标志和用户界面元素，如图标，可能可以用
    PNG-8 来处理。PNG-24 也支持透明度，这对于需要透明背景的图像来说是个优点。因此，了解在哪种情况下使用哪种格式将有助于你减少应用程序的内存消耗。
- en: If you can use JPG files, then use them as they are a lossy format, and it means
    that you will get a bit of image degradation, but generally the image degradation
    is almost invisible to the naked eye. However, note that JPG files do not support
    alpha transparency.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你可以使用 JPG 文件，那么请使用它们，因为它们是一种有损格式，这意味着你会有一些图像退化，但通常这种图像退化对肉眼几乎不可见。然而，请注意，JPG
    文件不支持透明度。
- en: PNG is a lossless format, which means that there is no image degradation when
    you use PNG files, but it comes at a price that it consumes more RAM when loaded
    into your device compared to a JPG, which is a lossy format.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: PNG 是一种无损格式，这意味着当你使用 PNG 文件时，没有图像退化，但代价是它加载到你的设备中时比有损格式的 JPG 消耗更多的 RAM。
- en: So, keep PNG files and JPG files to an absolute minimum if you can and only
    use them if you have to.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果可能的话，尽量将 PNG 文件和 JPG 文件的数量控制在绝对最小，并且只有在必要时才使用它们。
- en: Lazy loading
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 懒加载
- en: What is lazy loading? It is a design pattern or a way of doing things in software
    design where you load a resource such as a PNG, MP3 file, and so on only at the
    time when it is needed. This helps to mitigate the problem of insufficient memory
    instead of loading all your resources at once. You only load it when you need
    it in a "lazy" manner. There is also one more advantage, that is, it minimizes
    the start up time of your application since you only load the resources on demand
    and this takes less time to load. So, you gain a speed boost in terms of time.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 懒加载是什么？它是一种设计模式，或者是在软件设计中处理事情的一种方式，其中你只在需要时才加载资源，如 PNG、MP3 文件等。这有助于减轻一次性加载所有资源时内存不足的问题。你只有在需要时以“懒”的方式加载它。还有一个优点，那就是它最小化了应用程序的启动时间，因为你只按需加载资源，这需要更少的时间来加载。因此，你在时间上获得了速度提升。
- en: Imagine you have multiple UIViews where each view has 10 UIImages, but only
    one view can be seen at any one time. Without proper thought, you will be tempted
    to write code to load all 10 UIImages for all the UIViews at once. However, upon
    further reflection, the question arises as to whether there is a need to do so.
    It would be better if you refactor your code to load the 10 UIImages only when
    that UIView is visible to the user and then clean it up once the user is not viewing
    it and load the next batch of UIImages from the next UIView, which will be visible
    to the user. This will add a bit more of coding for you, but the trade-off in
    terms of efficient memory usage will be worth it.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有多个`UIView`，每个视图有10个`UIImages`，但任何时候只能看到一个视图。如果没有经过适当的思考，您可能会倾向于编写一次性加载所有10个`UIImages`的代码。然而，经过进一步的反思，问题出现了，即是否有必要这样做。如果您将代码重构为仅在用户可以看到该`UIView`时加载10个`UIImages`，并在用户不再查看它时清理它，然后从下一个视图加载下一批`UIImages`，这将对该视图可见，这将更好。这将为您增加一些编码工作，但就有效内存使用而言，这种权衡将是值得的。
- en: 'This is one of the simplest implementations where we just override the getter
    method of a class:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种最简单的实现，我们只是覆盖了类的获取方法：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can put the preceding code in place of the normal getter method of your
    class. The preceding code checks whether the object does or does not exists, and
    if it does not exist, then it will create the object. However, if the object already
    exists, then it will not create it again.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将前面的代码替换为您的类的正常获取方法。前面的代码检查对象是否存在，如果不存在，则创建对象。然而，如果对象已经存在，则不会再次创建它。
- en: Control creation
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控件创建
- en: Controls are part and parcel of every iOS application and they also consume
    memory on your device and every instance will consume bytes and bits of memory.
    When you are creating a lot of `UITableViewCell` class, for example, you will
    be looking at a control that is consuming a lot of memory sooner or later.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 控件是每个iOS应用程序的一部分，它们也会消耗您的设备上的内存，每个实例都会消耗字节和比特的内存。当您创建大量的`UITableViewCell`类时，例如，您迟早会看到一个消耗大量内存的控件。
- en: Also, tasks such as loading images and getting data from a remote server are
    considered as slow processes and will slow down your application. I am sure that
    you have used iOS apps where when you scroll down a `UITableView` view object
    you will see a noticeable lag as new images are loaded into the newly revealed
    cells. In this world, where people are used to images loading quickly on their
    desktop and mobile phones, such slowness and laggy UI are not acceptable and can
    mean the difference between a user staying engaged with your application or uninstalling
    your application.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，像加载图像和从远程服务器获取数据这样的任务被认为是缓慢的过程，并将减慢您的应用程序。我相信您已经使用过iOS应用程序，当您向下滚动`UITableView`视图对象时，您会注意到当新图像被加载到新出现的单元格中时，会有明显的延迟。在这个人们习惯于在桌面和手机上快速加载图像的世界里，这种缓慢和卡顿的用户界面是不可接受的，并且可能意味着用户是继续与您的应用程序互动还是卸载您的应用程序之间的区别。
- en: The fundamental mantra is that you must not let your users wait for 1 second
    or even 1 millisecond more than what is absolutely necessary. One tip to compensate
    for the perceived slowness of an application is to have a simple animation such
    as fading in an image after showing a spinner in order to give the user the perception
    that the application is not actually very slow since there is an animation playing.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 基本原则是，您绝对不能让用户等待超过1秒或1毫秒。为了弥补应用程序感知到的缓慢，一个技巧是在显示旋转器后淡入一个图像，以使用户感觉到应用程序实际上并不非常慢，因为有一个动画正在播放。
- en: Reusing your controls is a must if you are experiencing huge memory usage, which
    is impacting the usability of your iOS application. Later on, we will cover how
    to use the tool called **Instrument** in Xcode to monitor the memory usage. Creating
    objects is an expensive process and has a performance cost.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在经历巨大的内存使用，这影响了您iOS应用程序的可用性，那么重用您的控件是必须的。稍后，我们将介绍如何使用Xcode中的**Instrument**工具来监控内存使用。创建对象是一个昂贵的流程，并且有性能成本。
- en: If you need to create an object on the fly over a short period of time, such
    as scrolling quickly through a `UITableView` view object, you will experience
    some lag as your code will be creating new `UITableViewCell` class instead of
    reusing old ones.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要在短时间内动态创建对象，例如快速滚动`UITableView`视图对象，您将体验到一些延迟，因为您的代码将创建新的`UITableViewCell`类而不是重用旧的类。
- en: 'Reusing `UITableViewCell` is a lot faster and will enhance the performance
    of your application. Luckily, Apple has already created code for us to reuse a
    cell, which can be implemented easily with a few lines of code. So, let''s look
    at the `dequeueReusableCellWithIdentifier` method as a good example with the following
    code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 重复使用 `UITableViewCell` 可以大大提高应用程序的性能。幸运的是，苹果已经为我们创建了重复使用单元格的代码，这可以通过几行代码轻松实现。因此，让我们以以下代码为例，看看
    `dequeueReusableCellWithIdentifier` 方法：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Looking at the preceding code, you can see that we attempt to assign a cell
    using the `dequeueReusableCellWithIdentifier` method, then it will return a pointer
    to that cell if it already exists. Next, our code (`!cell`) will check whether
    that pointer is not nil, then it will create the cell. This is the exact same
    technique we used in the previous section *Lazy loading*, except that we apply
    this technique to an iOS control, which in this case, is a `UITableViewCell` object.
    These few lines of code serve three functions:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 查看前面的代码，你可以看到我们尝试使用 `dequeueReusableCellWithIdentifier` 方法分配一个单元格，如果该单元格已经存在，它将返回对该单元格的指针。接下来，我们的代码（`!cell`）将检查该指针是否不为空，然后创建单元格。这正是我们在上一节
    *懒加载* 中使用的相同技术，只不过这次我们将此技术应用于iOS控件，在这种情况下，是一个 `UITableViewCell` 对象。这几行代码有三个功能：
- en: This helps to prevent a situation where your app is lagging when you are scrolling
    up as it eliminates the need to create new instances of `UITableViewCell`.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这有助于防止在向上滚动时应用程序出现卡顿的情况，因为它消除了创建新的 `UITableViewCell` 实例的需求。
- en: If you have 1,000 rows of data and only 4 rows are visible on screen at any
    given time, then it makes no sense to create 1,000 `UITableViewCell` when you
    only need to create five. A few other cells can be partially visible and hence
    need to be created too. So, the five cells will only be created as it needs to
    be visible to the user while the remaining cells are not loaded.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你有一千行数据，但任何给定时间只有四行可见，那么当你只需要创建五个单元格时创建一千个 `UITableViewCell` 是没有意义的。一些其他单元格可能部分可见，因此也需要创建。所以，只有当单元格需要对用户可见时才会创建这五个单元格，而其余单元格则不会加载。
- en: While a single `UITableViewCell` class occupies a lot of memory, storing 1,000
    of them is not easy, and through a few extra lines of code, you can avoid unnecessary
    memory usage and use the memory you save for other parts of your code.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然 `UITableViewCell` 类本身占用大量内存，但存储一千个这样的类并不容易，通过几行额外的代码，你可以避免不必要的内存使用，并将节省的内存用于代码的其他部分。
- en: Caching
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存
- en: 'Caching is a concept where you store resources on disk or memory for faster
    access. Caching will occupy more space, but in situations where you need to worry
    more about loading speed than memory, caching can be a very good technique to
    use. Consider this common scenario:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存是一个在磁盘或内存中存储资源以实现更快访问的概念。缓存将占用更多空间，但在需要更多地考虑加载速度而不是内存的情况下，缓存可以是一个非常有效的技术。考虑以下常见场景：
- en: Downloading a large file such as an image or even a movie
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载大文件，如图片甚至电影
- en: Write the file to a disk
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将文件写入磁盘
- en: Read the files from the disk and display them
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从磁盘读取文件并显示它们
- en: If you follow the normal method as mentioned earlier, a bottleneck that you
    will face is slow loading of the file from disk. Disk access can be as slow as
    10,000 or even 1,000,000 slower than memory access and it won't make a good user
    experience as the user will be kept waiting while your app is loading the files
    from disk. Caching will help slow this problem as your file is saved to memory
    where read access is faster.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遵循前面提到的常规方法，你将面临的一个瓶颈是文件从磁盘加载缓慢。磁盘访问可能比内存访问慢10,000倍甚至1,000,000倍，这不会提供良好的用户体验，因为用户在等待你的应用程序从磁盘加载文件时会被保持等待。缓存可以帮助减缓这个问题，因为你的文件被保存在内存中，而读取访问更快。
- en: 'This is good from a user point of view as they do not need to wait a long time
    for the file to be loaded and can help to optimize the user experience of your
    application since every second wasted can lead to the user moving away from your
    application. Caching on disk or memory has its pros and cons as illustrated in
    the following table:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户的角度来看，这是很好的，因为他们不需要等待很长时间来加载文件，并且可以帮助优化应用程序的用户体验，因为每一秒钟的浪费都可能导致用户离开你的应用程序。磁盘或内存上的缓存有其优缺点，如下表所示：
- en: '|   | Disk | Memory |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '|   | 磁盘 | 内存 |'
- en: '| --- | --- | --- |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **Storage** | Persistent, as data is not lost when device is switched off
    | Ephemeral, as data is lost when device is switched off |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| **存储** | 持久性，因为当设备关闭时数据不会丢失 | 临时性，因为当设备关闭时数据会丢失 |'
- en: '| **Speed** | Slow | Fast |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| **速度** | 慢 | 快 |'
- en: '| **Storage size** | Large | Small, as memory is generally lesser than disk
    storage |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| **存储大小** | 大 | 小，因为内存通常小于磁盘存储 |'
- en: So as a rule of thumb, it will be best to do all caching on memory first and
    then move to caching on disk only when your application is running low on memory
    or you experience memory warning errors. If you are downloading large files such
    as movies, you will need to store the movie file on disk since the file normally
    will not be able to fit into memory.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，作为一个经验法则，最好首先在内存中进行所有缓存，然后在您的应用程序内存不足或遇到内存警告错误时，才将缓存移动到磁盘上。如果您正在下载大文件，如电影，您需要将电影文件存储在磁盘上，因为文件通常无法适应内存。
- en: As a sidenote, caching uses a few algorithms for implementation, such as **Most
    Recently Used** (**MRU**) or **Least Recently Used** (**LRU**). MRU means the
    cache will discard the most recently used items first when the cache is full,
    while LRU is the reverse opposite where the least recently used items will be
    discarded instead. The implementation strategy is out of the scope of this book
    and it is up to the manufacturer to decide.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，缓存实现使用了几个算法，例如 **最近最少使用**（**MRU**）或 **最近最少使用**（**LRU**）。MRU 表示当缓存满时，缓存将首先丢弃最近最少使用的项目，而
    LRU 则相反，将丢弃最少使用的项目。实现策略超出了本书的范围，由制造商决定。
- en: Fortunately, we do not need to write a lot of code to implement efficient caching.
    There are a few iOS caching libraries that we can use and they are available for
    us to use. So, in this section, we will look at one of the most popular caching
    libraries.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们不需要编写很多代码来实现高效的缓存。有一些 iOS 缓存库我们可以使用，它们可供我们使用。因此，在本节中，我们将查看最受欢迎的缓存库之一。
- en: SDWebImage
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SDWebImage
- en: 'The first library we will be looking at is called SDWebImage. The source code
    can be downloaded via a Git clone from [https://github.com/rs/SDWebImage](https://github.com/rs/SDWebImage),
    and it comes with a demo project too. So, let''s look at the important parts of
    this demo project. I have summarized the steps for you:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的第一个库名为 SDWebImage。源代码可以通过 Git 克隆从 [https://github.com/rs/SDWebImage](https://github.com/rs/SDWebImage)
    下载，并且它还附带了一个演示项目。因此，让我们看看这个演示项目的重要部分。我已经为您总结了以下步骤：
- en: Open the Xcode project.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Xcode 项目。
- en: Open up `masterviewcontroller`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `masterviewcontroller`。
- en: Import `UIImageView`+`WebCache.h`.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `UIImageView`+`WebCache.h`。
- en: Look for the `cellforrowatindexpath` method.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找 `cellforrowatindexpath` 方法。
- en: Call this method `setImageWithURL:placeholderImage`.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此方法命名为 `setImageWithURL:placeholderImage`。
- en: 'Now, let''s look into each of these steps in detail:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们详细看看这些步骤：
- en: 'Open the `SDWebImage Demo.xcodeproj` project and run it. You should see the
    following screen, which is a list of table view cells with images and text:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `SDWebImage Demo.xcodeproj` 项目并运行它。您应该看到以下屏幕，其中包含带有图片和文本的表格视图单元格列表：
- en: '![SDWebImage](img/00024.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![SDWebImage](img/00024.jpeg)'
- en: 'If you tap on a table view cell, it will show this screen, which shows the
    larger size of the image that you tapped on:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击表格视图单元格，它将显示此屏幕，显示您点击的图片的较大尺寸：
- en: '![SDWebImage](img/00025.jpeg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![SDWebImage](img/00025.jpeg)'
- en: 'Next, open up `MasterViewController` and look for the following piece of code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开 `MasterViewController` 并查找以下代码片段：
- en: '[PRE2]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is where the code will get the image from the server and then cache it
    on the device.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的代码将从服务器获取图片，然后在设备上进行缓存。
- en: 'To implement this in your own code, you need to import `UIImageView`+`WebCache.h`
    and then call the `setImageWithURL:placeholderImage`: method, where you can add
    in your own placeholder PNG and JPG image to replace `@"placeholder"`.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要在自己的代码中实现此功能，您需要导入 `UIImageView`+`WebCache.h`，然后调用 `setImageWithURL:placeholderImage`
    方法，您可以在其中添加自己的占位符 PNG 和 JPG 图片来替换 `@"placeholder"`。
- en: So, when you run the app again you will notice that images are not pulled from
    server again, but are instead served from the cache on the device, so you will
    see that the images load faster as a result.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当您再次运行应用程序时，您会注意到图片不再从服务器拉取，而是从设备上的缓存中提供，因此您会看到图片加载速度更快。
- en: Object serialization
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象序列化
- en: What is serialization? This is a question that a lot of people find hard to
    explain or understand. Serialization is the method or concept where we convert
    data structures or objects into a format for it to be stored in memory or disk
    for storage, or to be transmitted across a network link. It can also assist in
    memory management as it provides an alternative mechanism where we save some files
    to disk instead of memory, which is usually the case for big files, such as movie
    files. Serialization formats include JSON, XML, YAML, and so on. And luckily for
    iOS developers, Apple provides us with a robust framework that helps us take away
    the low-level code when we want to do serialization. So, when we want to store
    our data structures or objects in memory or disk, we can use Apple's frameworks
    such as Core Data or NSCoding, which provides an abstraction layer and hides away
    the lower-level coding for us.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是序列化？这是一个很多人觉得难以解释或理解的问题。序列化是将数据结构或对象转换成一种格式的方法或概念，以便将其存储在内存或磁盘上进行存储，或者通过网络链路进行传输。它还可以帮助进行内存管理，因为它提供了一个替代机制，即我们将一些文件保存到磁盘而不是内存中，这对于大文件，如电影文件通常是这种情况。序列化格式包括
    JSON、XML、YAML 等。幸运的是，对于 iOS 开发者来说，Apple 提供了一个强大的框架，帮助我们在我们想要进行序列化时移除底层代码。因此，当我们想要将我们的数据结构或对象存储在内存或磁盘上时，我们可以使用
    Apple 的框架，如 Core Data 或 NSCoding，它提供了一个抽象层，并隐藏了底层的编码工作。
- en: When it comes to data saving or serialization, we tend to stick with the one
    method that we are most familiar with. However, this is not a good way of doing
    things as various methods have their pros and cons, and we should consider our
    use case before we decide on the best method. To this extent, Apple has provided
    us with a few different methods for data serialization and it is up to us, the
    developers, to decide which method suits us best. One of the simplest ways is
    to use NSCoding. What is NSCoding? NSCoding is basically a protocol provided by
    Apple for you to encode and decode your data into a buffer, which can then be
    persisted to disk for persistent storage.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到数据保存或序列化时，我们往往倾向于坚持我们最熟悉的方法。然而，这并不是一个好的做法，因为各种方法都有其优缺点，我们在决定最佳方法之前应该考虑我们的用例。在这方面，Apple
    为我们提供了一些不同的数据序列化方法，这取决于我们，即开发者，来决定哪种方法最适合我们。其中最简单的方法之一是使用 NSCoding。什么是 NSCoding？NSCoding
    是 Apple 提供的一个协议，用于将您的数据编码和解码到缓冲区，然后可以持久化到磁盘进行持久存储。
- en: Usage of the `NSCoding` protocol also involves the `NSKeyedArchiver` and `NSKeyedUnarchiver`
    methods as `NSCoding` is a protocol with delegate methods for serializing our
    data structure and custom object into a format that can be stored in memory or
    disk. `NSKeyedArchiver` and `NSKeyedUnarchiver` are the methods that will actually
    do the work of storing our serialized data into disk for persistent storage. So
    to kick things off, we will use an example to help us understand how serializing
    and archiving works for iOS applications.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `NSCoding` 协议也涉及到 `NSKeyedArchiver` 和 `NSKeyedUnarchiver` 方法，因为 `NSCoding`
    是一个协议，它提供了用于将我们的数据结构和自定义对象序列化成可以存储在内存或磁盘上的格式的代理方法。`NSKeyedArchiver` 和 `NSKeyedUnarchiver`
    是实际将我们的序列化数据存储到磁盘以进行持久存储的方法。因此，为了开始，我们将使用一个示例来帮助我们理解序列化和归档在 iOS 应用程序中的工作方式。
- en: 'Use the listed steps for the following example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下步骤进行以下示例：
- en: Add the `NSCoding` protocol to your custom object.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `NSCoding` 协议添加到您的自定义对象中。
- en: Implement `encodeWithCoder` and `initWithCoder` and assign the values you wish
    to store.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `encodeWithCoder` 和 `initWithCoder` 方法，并分配您希望存储的值。
- en: Call the `archiveRootObject` and `unarchiveObjectWithFile` methods to save your
    serialized data to disk and load it from the disk respectively.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `archiveRootObject` 和 `unarchiveObjectWithFile` 方法来将您的序列化数据保存到磁盘，并从磁盘加载它。
- en: 'For example, we create a custom object called `OurCustomObject`, and then to
    use the `NSCoding` protocol, we need to add it to our interface declaration:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，我们创建了一个名为 `OurCustomObject` 的自定义对象，然后为了使用 `NSCoding` 协议，我们需要将其添加到我们的接口声明中：
- en: '[PRE3]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, we need to write the `encodeWithCoder` method to save the data:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要编写 `encodeWithCoder` 方法来保存数据：
- en: '[PRE4]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now that we have the code to encode and decode the data into a serialized format,
    we need to put in the actual code to save it to disk on our device, so we can
    use `NSKeyedArchiver` to do the actual writing to disk, while we use `NSKeyedUnarchiver`
    to get the data from the disk:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经有了将数据编码和解码成序列化格式的代码，我们需要输入实际的代码来将数据保存到我们的设备磁盘上，因此我们可以使用 `NSKeyedArchiver`
    来执行实际的磁盘写入操作，同时我们使用 `NSKeyedUnarchiver` 来从磁盘获取数据：
- en: '[PRE5]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then to load our object from disk, we just use the following code:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后要从磁盘加载我们的对象，我们只需使用以下代码：
- en: '[PRE6]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There is no need to call `initWithCoder` and `encodeWithCoder` anywhere in our
    code as those method calls are called when you call `unarchiveObjectWithFile`
    and `archiveRootObject`. However, you need to implement `initWithCoder` and `encodeWithCoder`
    as these two methods need to contain the necessary code to encode and decode the
    `isReset`, `userName`, and `score` variables that form `OurCustomObject`. As you
    can see, `NSCoding` is a relatively powerful way to store data to disk compared
    to `NSUserDefaults`, and the code is quite easy to understand and write. However,
    if you need more power features for data storage, NSCoding will not be the best
    choice and Core Data will be the better option as it has more features such as
    being able to perform queries, being optimized for speed, support for different
    serialization formats such as XML, SQLite, or NSDate, among other benefits.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，没有必要调用`initWithCoder`和`encodeWithCoder`，因为这些方法调用是在你调用`unarchiveObjectWithFile`和`archiveRootObject`时进行的。然而，你需要实现`initWithCoder`和`encodeWithCoder`，因为这两个方法需要包含必要的代码来编码和解码构成`OurCustomObject`的`isReset`、`userName`和`score`变量。正如你所见，与`NSUserDefaults`相比，`NSCoding`是一种相对强大的将数据存储到磁盘的方法，代码也相当容易理解和编写。然而，如果你需要更多数据存储功能，NSCoding可能不是最佳选择，而Core
    Data将是更好的选择，因为它具有更多功能，例如能够执行查询，针对速度优化，支持不同的序列化格式，如XML、SQLite或NSDate，以及其他好处。
- en: SQLite
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQLite
- en: 'SQLite, for those familiar with **Relational DataBase Management System** (**RDBMS**),
    is a database based on the relational model. A SQLiteis, a RDBMS that is available
    for us in iOS, has a lot of the features and functions of RDBMS that many people
    are familiar with, such as ACID properties, queries, and so on. Core Data is Apple''s
    framework for data storage and you can use Core Data to store data into a SQLite
    database. However, there are some cases when you need to use SQLite instead of
    Core Data. So, I will elaborate further on this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于熟悉**关系型数据库管理系统**（**RDBMS**）的人来说，SQLite是一个基于关系模型的数据库。一个SQLite数据库，作为iOS中可用的RDBMS，具有许多人们熟悉的功能和功能，如ACID属性、查询等。Core
    Data是Apple的数据存储框架，你可以使用Core Data将数据存储到SQLite数据库中。然而，在某些情况下，你需要使用SQLite而不是Core
    Data。因此，我将进一步阐述这一点：
- en: SQLite as a database is available on multiple platforms besides iOS. So this
    means that if you are developing an application that runs on multiple platforms
    or has the possibility to run on other non-iOS platforms, SQLite will be the option
    for you to seriously consider since you will avoid framework lock-in using Core
    Data. SQLite also is faster than NSCoding, plus it adds querying functionality,
    which is not possible if you use `NSUserDefaults`.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite作为一个数据库，除了iOS平台外，还可在多个平台上使用。这意味着，如果你正在开发一个需要在多个平台或有可能在其他非iOS平台上运行的应用程序，SQLite将是你需要认真考虑的选项，因为你将避免使用Core
    Data时框架锁定的问题。SQLite也比NSCoding更快，并且它增加了查询功能，这是使用`NSUserDefaults`时无法实现的。
- en: Also, if you have experience with SQLite and your use case for data storage
    is very straightforward along with no experience with Core Data, then you should
    choose SQLite.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，如果你有SQLite的使用经验，并且你的数据存储用例非常直接，没有Core Data的使用经验，那么你应该选择SQLite。
- en: It does not require a **Model-View-Controller** (**MVC**) conceptual model.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不需要**模型-视图-控制器**（**MVC**）概念模型。
- en: Now, this does not mean that SQLite should be the default data storage solution
    for you when you need to store data to disk. This is because there are other options
    such as Core Data and various other factors such as speed and ease of coding,
    which will play a big part in your decision-making as we will see later in this
    chapter and the chapter on Core Data later on.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这并不意味着当你需要将数据存储到磁盘时，SQLite应该成为你的默认数据存储解决方案。这是因为还有其他选项，如Core Data，以及诸如速度和编码的简便性等因素，这些因素将在我们稍后在本章和Core
    Data章节中看到，将在你的决策中扮演重要角色。
- en: SQLite versus Core Data
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQLite与Core Data的比较
- en: Core Data is a rich and sophisticated object graph management framework with
    a lot of bells and whistles that you require for complex use cases. In the *Introduction
    to Core Data Programming Guide*, Apple mentions that the Core Data framework provides
    generalized and automated solutions to common tasks associated with object life
    cycle and object graph management, including persistence, which means it prevents
    you from writing a lot of code to do your everyday data storage tasks.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Core Data 是一个丰富且复杂的对象图管理框架，具有许多你为复杂用例所需的功能。在 *Core Data 编程指南简介* 中，苹果提到 Core
    Data 框架为与对象生命周期和对象图管理相关的常见任务提供了通用和自动化的解决方案，包括持久化，这意味着它防止你编写大量代码来完成日常数据存储任务。
- en: Core Data uses models that are your objects and these are the model in the commonly
    used MVC architecture. These enable you to store whole objects and it ties in
    very closely with the controller and view classes of your iOS application. So,
    developers who are using MVC architectures will have no problem absorbing the
    Core Data concepts and models.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Core Data 使用的是你的对象模型，这些模型在常用的 MVC 架构中被称为模型。这些模型使你能够存储整个对象，并且与你的 iOS 应用程序中的控制器和视图类紧密相连。因此，使用
    MVC 架构的开发者将不会在吸收 Core Data 概念和模型时遇到问题。
- en: The tools for development using the Core Data framework is tied in deeply into
    Xcode and it enables developers to quickly write code and lay out their data models
    in a fast and efficient manner, and thus, save you time, which allows you to spend
    it on other parts of the project.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Core Data 框架进行开发的工具与 Xcode 深度集成，它使开发者能够快速编写代码并以快速高效的方式布局他们的数据模型，从而节省时间，这让你可以将时间投入到项目的其他部分。
- en: Core Data framework is also available for the Mac OS, and this enables reusability
    of your code if you intend to create a Mac version of your application.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Core Data 框架也适用于 Mac OS，如果你打算创建应用程序的 Mac 版本，这将使你的代码具有可重用性。
- en: With Apple's iCloud storage and computing platform, you can use Core Data to
    take advantage of iCloud to sync your application and user data across multiple
    devices such as iPads and so on. iOS 8 has tighter integration with iCloud with
    the introduction of the CloudKit framework, which has new functionality such as
    allowing partial download of datasets and all this is only possible using Core
    Data.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通过苹果的 iCloud 存储和计算平台，你可以使用 Core Data 利用 iCloud 在多个设备（如 iPad 等）之间同步你的应用程序和用户数据。iOS
    8 通过引入 CloudKit 框架与 iCloud 的集成更加紧密，该框架具有新的功能，例如允许数据集的部分下载，所有这些功能都只能通过 Core Data
    实现。
- en: SQLite is a pure RDBMS and many people confuse Core Data with SQLite. SQLite
    is a RDBMS, pure and simple. So, it has a lot of the features that you will associate
    with RDBMSes, such as ACID properties, queries, and so on. However, that is where
    it ends. Core Data is an abstraction layer on top of a data store, which can be
    SQLite or other forms of data persistence, such as XML files. So, using Core Data
    will still enable you to store data in SQLite, but there will be some occasions
    when you prefer to use SQLite over Core Data.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 是一个纯关系型数据库管理系统（RDBMS），很多人将 Core Data 与 SQLite 混淆。SQLite 是一个 RDBMS，纯粹而简单。因此，它具有许多你将与
    RDBMS 相关的特性，例如 ACID 属性、查询等。然而，这就结束了。Core Data 是在数据存储之上的一层抽象，这个数据存储可以是 SQLite 或其他形式的数据持久化，例如
    XML 文件。所以，使用 Core Data 仍然可以让你在 SQLite 中存储数据，但有些情况下你可能更愿意使用 SQLite 而不是 Core Data。
- en: If data portability is an important feature for you, then using SQLite should
    be your preferred choice as SQLite is platform-independent, while Core Data is
    for Apple platforms only. So, if you use SQLite, you can be assured that your
    data files can be moved and accessed on almost any platform that supports SQLite,
    not only Apple-supported platforms.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据可移植性对你来说是一个重要的特性，那么使用 SQLite 应该是你的首选选择，因为 SQLite 是平台无关的，而 Core Data 仅适用于苹果平台。所以，如果你使用
    SQLite，你可以确信你的数据文件几乎可以在支持 SQLite 的任何平台上移动和访问，而不仅仅是苹果支持的平台上。
- en: Core Data ultimately is an abstraction layer between your code and the database.
    However, sometimes you want to get down to the lower levels of your code and avoid
    abstraction layers to understand how the code works. So, using SQLite will allow
    you to do that, as it allows you to do low level optimization if you are working
    with large datasets. Core Data can also be used to abstract the Sqlite access
    to save on development time and make your code cleaner.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Core Data最终是在你的代码和数据库之间的一个抽象层。然而，有时你想要深入到代码的底层，避免抽象层来理解代码是如何工作的。因此，使用SQLite将允许你做到这一点，因为它允许你在处理大量数据集时进行底层优化。Core
    Data也可以用来抽象对SQLite的访问，以节省开发时间并使你的代码更简洁。
- en: Ultimately, there are no hard and fast rules on when and where to use Core Data
    or SQLite. On every engineering project, there are questions and decisions to
    be made, which encompass factors such as amount of resources and platform scalability
    since Core Data only supports Apple platforms and if you intend to support non-Apple
    platforms. Core Data might not be a good choice. So, using the Core Data framework
    allows you to have a rapid solution for simple applications, but it also ties
    you into Apple's framework, which impedes data portability as if you create an
    application where a user's data such as game data needs to be present on another
    non-Apple device. You will encounter a technical lock-in if you use Core Data.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，关于何时何地使用Core Data或SQLite并没有硬性规定。在每一个工程项目中，都会有问题和决策需要做出，这涉及到资源数量和平台可扩展性等因素，因为Core
    Data仅支持Apple平台，如果你打算支持非Apple平台，Core Data可能不是一个好的选择。因此，使用Core Data框架可以让你为简单应用快速找到解决方案，但它也把你绑定在Apple的框架上，这阻碍了数据可移植性，就像你创建的应用需要用户数据（如游戏数据）存在于另一个非Apple设备上时。如果你使用Core
    Data，你将遇到技术锁定。
- en: On the other hand, SQLite allows ease of tweaking and optimization for various
    reasons. In the end, the complexity of your use case, data model, and requirements
    of your platform will be the factors that will help you make a good decision on
    the right option to choose.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，SQLite允许根据各种原因轻松调整和优化。最终，你的用例复杂性、数据模型以及平台需求将是帮助你做出选择正确选项的因素。
- en: Summary
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In summary, this chapter covered the management of your application data with
    regards to caching data to memory and data storage on to disk. We also covered
    the pros and cons of using the various storage frameworks for various situations
    and did a few code examples on using the NSCoding protocol and the SDWebImage
    open source caching framework.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，本章涵盖了应用数据的管理，包括将数据缓存到内存以及将数据存储到磁盘上。我们还讨论了在不同情况下使用各种存储框架的优缺点，并给出了一些使用NSCoding协议和SDWebImage开源缓存框架的代码示例。
- en: This chapter covers a bit of Core Data, which will help us in the next chapter
    as we deep dive into Core Data along with some code examples. The next chapter
    will be all about Core Data and its uses.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 本章简要介绍了Core Data，这将有助于我们在下一章深入探讨Core Data时，结合一些代码示例。下一章将全部关于Core Data及其用途。
