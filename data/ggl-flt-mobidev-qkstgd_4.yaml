- en: Exploiting the Widgets Variety
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用Widgets的多样性
- en: 'In this chapter, we will first take a look at constraints in Flutter and understand
    how it will help in your application development. We will then have a quick introduction
    to animations and its categories, and take a look at common patterns in it. Then,
    we will move on to using `ListView` and scrolling widgets, and, finally, have
    a quick section about silvers. All these topics will be covered in the following
    sections:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先了解Flutter中的约束以及它如何帮助您进行应用程序开发。然后，我们将简要介绍动画及其类别，并查看其中的常见模式。然后，我们将继续使用`ListView`和滚动小部件，最后简要介绍银色元素。所有这些主题将在以下章节中介绍：
- en: Constraints in Flutter
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flutter中的约束
- en: Introducing animations in Flutter
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Flutter中引入动画
- en: Using `ListView` and scrolling widgets
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ListView`和滚动小部件
- en: Introducing silvers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入银色元素
- en: Constraints in Flutter
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flutter中的约束
- en: Every widget in Flutter is rendered by a `RenderBox` object that takes the constraints
    given by the parent and sizes itself within those constraints.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Flutter中的每个部件都是由一个`RenderBox`对象渲染的，该对象接受父级提供的约束并在这些约束内调整自身大小。
- en: The difference between constraint and size is that the former gives a minimum
    and maximum of height and width, while the latter consists of a specific height
    and width.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 约束和大小之间的区别在于，前者给出了高度和宽度的最小值和最大值，而后者由特定的高度和宽度组成。
- en: 'There are three kinds of RenderBoxes, distinguished by their behavior as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种类型的`RenderBox`，根据它们的行为区分如下：
- en: Those that try to be as big as possible (`ListView`, Center and so on)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那些试图尽可能大（`ListView`、居中等）的
- en: Those that try to be the same size as their children
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那些试图与子项大小相同的
- en: Those that try to be a particular size (image, text and so on)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那些试图达到特定大小（图像、文本等）的
- en: As in every rule, we need exceptions.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 每条规则都有例外。
- en: Some widgets vary their behavior depending on their constructor arguments. For
    example, the Container widget tends to be as big as possible, but, if you give
    it a width (or height), it tries to be that particular size.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一些小部件的行为会根据它们的构造函数参数而变化。例如，容器小部件通常会尽可能大，但如果给它一个宽度（或高度），它会尝试达到那个特定的大小。
- en: A particular constraint is the unbounded (or infinite) one. In this case, either
    the maximum width or height is set to `double.INFINITY`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 特定约束是无界的（或无限的）。在这种情况下，最大宽度或高度被设置为`double.INFINITY`。
- en: A box that tries to be as big as possible won't work with unbounded constraint,
    and the framework will throw an exception.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试尽可能大的盒子在与无界约束一起使用时不会工作，并且框架将抛出异常。
- en: This can happen within flex boxes (row/column) and scrollable regions (`ListView`
    and other `ScrollView` subclasses).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能发生在弹性盒子（行/列）和可滚动区域（`ListView`和其他`ScrollView`子类）中。
- en: A constraint can be tight. This means that it leaves no room for the `RenderBox`
    object to choose a size. An example is the App widget, which forces the view to
    be as big as the screen.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 约束可以是紧的。这意味着它不留给`RenderBox`对象选择大小的空间。一个例子是App小部件，它强制视图与屏幕大小相同。
- en: 'Flex boxes (row and columns) behave differently based on whether they are in
    bounded or unbounded constraints:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 弹性盒子（行和列）在有界或无界约束中的行为不同：
- en: In bounded constraints, they try to be as big as possible in that direction
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在有界约束中，它们会尝试在那个方向上尽可能大
- en: In unbounded constraints, they try to fit their children in that direction
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在无界约束中，它们会尝试将子项适应那个方向
- en: Introducing animations in Flutter
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Flutter中引入动画
- en: Animations are one of the important features of a widget. Sometimes, developers
    think that animations are not very important, but designers know that a good set
    of animations can attract many users. They also contribute to the look and feel
    of the application, giving it more personality.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 动画是部件的一个重要特性。有时，开发者认为动画并不是很重要，但设计师知道一套好的动画可以吸引许多用户。它们还贡献于应用程序的外观和感觉，使其更具个性。
- en: Flutter has a great animation support, making it easy to build nice effects
    and movements. Many widgets come with standard motion effects designed in their
    design specification, but you can always customize them according to your own
    need.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Flutter具有出色的动画支持，使其轻松构建良好的效果和运动。许多小部件在其设计规范中带有标准运动效果，但您可以根据自己的需求进行自定义。
- en: Let's take a look at the animation categories, where we will see the two categories
    the animations in Flutter are divided into, and then take a look at the common
    patterns of animations.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看动画类别，我们将看到 Flutter 中动画分为的两个类别，然后看看动画的常见模式。
- en: Animation categories
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画类别
- en: 'In general, animations are defined in two categories:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，动画分为两类：
- en: '**Tween animations**: Short for **in-betweening**. In this case, we define the
    beginning and ending point, the timeline, and a curve of time and speed. The framework
    will do the rest of the work, calculating the transition and executing it.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓动动画**：简称 **in-betweening**。在这种情况下，我们定义开始和结束点、时间轴以及时间和速度的曲线。框架将完成其余的工作，计算过渡并执行它。'
- en: '**Physics-based animations**: These types of animations are made with the aim
    to represent the real-world behavior.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于物理的动画**：这类动画旨在代表现实世界的表现。'
- en: Common patterns
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见模式
- en: As a user, you may have noticed that some types of animations are constantly
    used in most apps. These types of animations are the common patterns in animation.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 作为用户，你可能已经注意到，大多数应用中经常使用某些类型的动画。这些类型的动画是动画中的常见模式。
- en: 'In Flutter, you can find three common patterns:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Flutter 中，你可以找到三种常见模式：
- en: '**Animated list/grid**: A simple list or grid animating when adding/removing
    an element.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动画列表/网格**：在添加/删除元素时进行动画的简单列表或网格。'
- en: '**Shared element transition**: This is used when navigating between two pages
    that have common elements. For example, an image that shows a thumbnail in one
    route and a normal picture in another.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**共享元素过渡**：当在具有公共元素的两个页面之间导航时使用。例如，一个在一条路由中显示缩略图并在另一条路由中显示正常图片的图片。'
- en: '**Staggered animation**: A sequence of animations that compose a bigger one.
    They can be sequential or overlapping.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交错动画**：由一系列组成更大动画的动画序列。它们可以是顺序的或重叠的。'
- en: Using ListView and scrolling widgets
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ListView 和滚动组件
- en: Flutter supports several scrolling widgets, such as `Gridview`, `ListView`,
    `and PageView`. Lists are the most commonly used scrolling widgets, and are a
    scrollable, linear list of widgets. It enables the display of its children one
    after another in the scroll direction.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Flutter 支持多个滚动组件，例如 `Gridview`、`ListView` 和 `PageView`。列表是最常用的滚动组件，是一个可滚动的线性组件列表。它允许在滚动方向上依次显示其子组件。
- en: ListView
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ListView
- en: '`ListView` is a linear list of scrollable items, and is one of the most commonly
    used widgets. If you have worked on `ListView`s in Android or iOS, this will be
    straightforward. As in every case, `ListView` produces child-list items one after
    another. There are several ways to build `ListView`s, so let''s take a look at
    the approaches one-by-one.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListView` 是一个可滚动的线性列表项，是最常用的组件之一。如果你在 Android 或 iOS 上工作过 `ListView`，这将非常直接。就像在所有情况下一样，`ListView`
    会依次产生子列表项。构建 `ListView` 有几种方法，所以让我们逐一看看这些方法。'
- en: Using List<Widget>
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 List<Widget>
- en: 'The easiest and most standalone way of building `ListView` is by using an explicit
    `List<Widget>` of children. This method is ideal for lists with a fixed number
    of children. Take a look at the following code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 构建 `ListView` 最简单且最独立的方式是使用显式的 `List<Widget>` 子组件。这种方法适用于具有固定数量子组件的列表。看看下面的代码：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following image shows how the preview will look after you run the preceding
    code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了运行上述代码后的预览效果：
- en: '![](img/920fb3e4-0960-4832-b722-8b529369b94f.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/920fb3e4-0960-4832-b722-8b529369b94f.png)'
- en: Using ListView.Builder
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ListView.Builder
- en: The `ListView.builder` constructor calls for `IndexedWidgetBuilder`, which helps
    developers to build children lists items on demand. This is ideally used for a
    large or infinite number of visible children, unlike the `ListView` constructor.
    The other difference is that, while in the case of `ListView`, all the list items
    have to be defined first, in this case, the `ListView.builder` constructor will
    create runtimes for the list items as they are scrolled onto the screen.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListView.builder` 构造函数需要 `IndexedWidgetBuilder`，这有助于开发者按需构建子列表项。这非常适合用于大量或无限数量的可见子项，与
    `ListView` 构造函数不同。另一个区别是，在 `ListView` 的情况下，所有列表项必须首先定义，而在这种情况下，`ListView.builder`
    构造函数将在列表项滚动到屏幕上时创建运行时。'
- en: 'Defining `ListView.builder` is simple and straightforward, as you can see in
    the following code block:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 `ListView.builder` 简单直接，如下面的代码块所示：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Using the preceding code, you will see a `ListView` constructor that shows
    the index of each item with a text glued to it. The complete code is as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的代码，你会看到一个`ListView`构造函数，它显示每个项目的索引，并附有粘合的文本。完整的代码如下：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After you run the code, the app will appear as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码后，应用将显示如下：
- en: '![](img/ef07a627-b5c8-4be6-bf0d-6b8c4ff7c8fa.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ef07a627-b5c8-4be6-bf0d-6b8c4ff7c8fa.png)'
- en: 'Now, we could add a data source to work with. The data source can be messages,
    search results, or the sources on the internet that you wish to fetch the data
    from. We will use the `List<E>.generate` constructorto generate values using the
    following definition:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以添加一个数据源来工作。数据源可以是消息、搜索结果，或者你希望从中获取数据的互联网上的源。我们将使用`List<E>.generate`构造函数来生成值，如下定义：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This creates a list of values with length positions and fills it with values
    created by calling generator for each index in the range 0 till length–1 in increasing
    order. The created list is fixed unless the value of `growable` value is set to
    `true`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个长度为`positions`的值列表，并用通过调用生成器为每个索引在0到长度-1的范围内递增顺序创建的值填充它。创建的列表是固定的，除非将`growable`值设置为`true`。
- en: 'Here is the complete code using the data source to generate `ListView`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用数据源生成`ListView`的完整代码示例：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出如下：
- en: '![](img/070eb0ed-23ea-4cd8-8050-2b719bee298a.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/070eb0ed-23ea-4cd8-8050-2b719bee298a.png)'
- en: ListView separated by calling ListView.separated
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过调用`ListView.separated`进行分隔的`ListView`
- en: 'In the previous cases of code executions, we saw that even though the `ListTiles`
    were listed, there was no separation among them. To build a divider between the
    `ListTiles`, it also provides a helper constructor for creating a `ListView`.
    The constructor is `ListView.separated`. This divider is called by the **divider
    class** to build a one device pixel-thick horizontal line, having padding on either
    side. Dividers can be used in lists, drawers, or separate content, vertically
    or horizontally based on the value of the `Axis` enum, as specified in the following `ListView.separated` constructor:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码执行案例中，我们看到尽管`ListTiles`被列出，但它们之间没有分隔。为了在`ListTiles`之间创建分隔符，它还提供了一个辅助构造函数来创建`ListView`。这个构造函数是`ListView.separated`。这个分隔符由**分隔类**调用，以构建一个一设备像素厚的水平线，两侧都有填充。分隔符可以在列表、抽屉或独立内容中使用，垂直或水平使用，具体取决于`Axis`枚举的值，如下所示`ListView.separated`构造函数：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The constructor can be called in the following way:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数可以通过以下方式调用：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This builds a fixed-length scrollable linear array of list items that are separated
    by list items `separators`. The `itemBuilder` callback will be called with indices
    greater than or equal to `0`, and less than `itemCount`. The separator is built
    after the first item and before the last item in the list. The `separatorBuilder`
    callback will be called with indices greater than or equal to `0`, and less than
    `itemCount 1`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这构建了一个固定长度的可滚动线性数组，其中的列表项通过列表项`separators`分隔。`itemBuilder`回调将在索引大于或等于`0`且小于`itemCount`时被调用。分隔符在列表中的第一个项之后和最后一个项之前构建。`separatorBuilder`回调将在索引大于或等于`0`且小于`itemCount
    1`时被调用。
- en: 'Here is the sample of the `ListView` constructor using `ListView.separated`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用`ListView.separated`的`ListView`构造函数的示例：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once you run the preceding code, you will see the `ListView` with separators.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行前面的代码，你会看到带有分隔符的`ListView`。
- en: Using ListView.custom constructor
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`ListView.custom`构造函数
- en: 'By making use of `SilverChildDelegate`, this method provides the ability to
    customize several aspects of the child model, defining the way in which they are
    built. The main parameter required for this is `SliverChildDelegate`, which builds
    the items. The types of `SliverChildDelegates` are as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`SilverChildDelegate`，此方法提供了自定义子模型几个方面的能力，定义了它们构建的方式。为此所需的主要参数是`SliverChildDelegate`，它构建项目。`SliverChildDelegates`的类型如下：
- en: '`SliverChildListDelegate`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SliverChildListDelegate`'
- en: '`SliverChildBuilderDelegate`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SliverChildBuilderDelegate`'
- en: '`SliverChildListDelegate` accepts a direct list of children, while, on the
    other hand, `SliverChildBuiderDelegate` accepts `IndexedWidgetBuilder`. Take a
    look at the `ListView.custom` constructor:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`SliverChildListDelegate`接受直接的孩子列表，而另一方面，`SliverChildBuiderDelegate`接受`IndexedWidgetBuilder`。看看`ListView.custom`构造函数：'
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Horizontal lists
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 水平列表
- en: 'Once you have received a hands-on with vertical lists, horizontal lists are
    simple. In this case, we call the `ListView` constructor, passing through a horizontal
    `scrollDirection`. This simply overrides the default vertical direction. In this
    case, we use a `Container` widget, which is an easy-to-use widget that combines
    common painting, positioning, and sizing widgets. Take a look at the following
    code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你熟悉了垂直列表，水平列表就很简单了。在这种情况下，我们调用`ListView`构造函数，传递一个水平`scrollDirection`。这仅仅覆盖了默认的垂直方向。在这种情况下，我们使用了一个`Container`小部件，这是一个易于使用的组合了常见的绘制、定位和尺寸小部件的小部件。看看下面的代码：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `ListView` `scrollDirection: Axis.horizontal` property ensures that the
    list is horizontally scrollable. Once you run the code successfully, you will
    see the following result:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListView`的`scrollDirection: Axis.horizontal`属性确保列表可以水平滚动。一旦代码成功运行，你将看到以下结果：'
- en: '![](img/c5ff0cb7-65b7-43f1-9793-e2980c385192.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c5ff0cb7-65b7-43f1-9793-e2980c385192.png)'
- en: Grid lists
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网格列表
- en: 'Just like in the case of horizontal lists, event grid lists are easy to build.
    It uses a `GridView.count` constructor that allows us to specify how many rows
    and columns we want on the screen. In the following example, we build `100` widgets
    that print the value of the position:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在水平列表的情况下，事件网格列表也很容易构建。它使用`GridView.count`构造函数，允许我们指定屏幕上需要多少行和列。在下面的例子中，我们构建了`100`个小部件，打印出它们的位置值：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding code will produce the following output:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将产生以下输出：
- en: '![](img/a25ccd3e-975a-43a0-923a-f6340bccc371.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a25ccd3e-975a-43a0-923a-f6340bccc371.png)'
- en: Introducing silvers
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍silvers
- en: We took a look at the `ListView`, now let's quickly take a look at what silvers
    are, taking a quick example from the `ListView`. Being fancy in your layout can
    be visually pleasing if executed well. That's exactly how silver can help you. A
    silver is a portion of a scrollable area using which you can bring in custom scrolling
    into your view. Let's take a simple example in the form of `ListView`. If an app
    bar remains static it can sometimes obstruct the view, so, in this case, silver
    can be used to hide the app bar while you scroll.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们先看了看`ListView`，现在让我们快速了解一下什么是silvers，通过从`ListView`中举一个简单的例子。如果你的布局设计得足够精美，那么视觉上会非常吸引人。这正是silvers能帮到你的地方。silvers是可滚动区域的一部分，通过它你可以将自定义滚动引入你的视图。让我们以`ListView`为例来看一个简单的例子。如果一个应用栏保持静态，有时可能会遮挡视图，所以在这种情况下，可以使用silvers来隐藏应用栏，在你滚动时。
- en: One thing that has to be noted is that all of the sliver components go inside `CustomScrollView`.
    As a developer, you can then combine your lists of silvers to build your custom
    scrollable area.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，所有的silvers组件都应该放在`CustomScrollView`内部。作为开发者，你可以将你的silvers列表组合起来，构建你自定义的可滚动区域。
- en: Summary
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: At the start of the chapter, we began discussing constraints in Flutter. We
    then discussed animations and forms of animation in Flutter. In the next section,
    we executed some examples of different types of lists. In the final section, we
    looked at how we can custom animate the portion.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们开始讨论Flutter中的约束。然后我们讨论了Flutter中的动画和动画形式。在下一节中，我们执行了一些不同类型列表的示例。在最后一节中，我们探讨了如何自定义动画部分。
- en: In the next chapter, we will widen our Flutter horizon and look at network and
    accessibility with Flutter.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将拓宽我们的Flutter视野，探讨Flutter中的网络和可访问性。
