- en: Chapter 5. Detecting Touchscreen Gestures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章. 检测触摸屏手势
- en: Until now, the apps we created have used `OnClickListeners` to detect user input.
    However, Android handsets are capable of handling sophisticated touchscreen gestures.
    These inputs are picked up with an `OnTouchListener` and then managed with a `GestureDetector`.
    These detectors and their own listeners are capable of recognizing several of
    the simplest and most commonly used gestures, such as **long presses**, **double-taps**,
    and **flings**. At the heart of all touchscreen events is the `MotionEvent` class,
    which handles the individual elements of a gesture, such as when and where a finger
    is placed or removed from the screen or view. This class provides numerous classes
    for querying these events and, thus, for constructing custom gestures of our own.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们创建的应用程序都使用了 `OnClickListeners` 来检测用户输入。然而，Android 手机能够处理复杂的触摸屏手势。这些输入通过
    `OnTouchListener` 捕获，然后由 `GestureDetector` 管理。这些检测器和它们自己的监听器能够识别几种最简单和最常用的手势，例如
    **长按**、**双击** 和 **滑动**。所有触摸屏事件的核心是 `MotionEvent` 类，它处理手势的各个元素，例如手指何时何地放置或从屏幕或视图中移除。这个类提供了查询这些事件的众多类，因此可以构建我们自己的自定义手势。
- en: To see how to implement gestures in our Ancient Britain app, we will add a feature
    that allows the user to view a small gallery of images within the same `ImageView`
    by swiping the view.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解如何在古代英国应用程序中实现手势，我们将添加一个功能，允许用户通过在视图中滑动来查看同一 `ImageView` 中的小图库。
- en: 'In this chapter, we will learn how to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何：
- en: Add a `GestureDetector` to a view
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `GestureDetector` 添加到视图中
- en: Add an `OnTouchListener` and an `OnGestureListener`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加 `OnTouchListener` 和 `OnGestureListener`
- en: Detect and refine fling gestures
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测和细化滑动手势
- en: Use the DDMS Logcat to observe the `MotionEvent` class
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 DDMS Logcat 来观察 `MotionEvent` 类
- en: Edit the Logcat filter configuration
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑 Logcat 过滤器配置
- en: Simplify code with a `SimpleOnGestureListener`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `SimpleOnGestureListener` 简化代码
- en: Add a `GestureDetector` to an Activity
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `GestureDetector` 添加到 Activity 中
- en: Edit the Manifest to control launch behavior
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑 Manifest 来控制启动行为
- en: Hide UI elements
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏 UI 元素
- en: Create a splash screen
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建启动画面
- en: Lock screen orientation
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁定屏幕方向
- en: Adding a GestureDetector to a view
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 `GestureDetector` 添加到视图中
- en: Together, `view.GestureDetector` and `view.View.OnTouchListener` are all that
    are required to provide our `ImageView` with gesture functionality. The listener
    contains an `onTouch()` callback that relays each `MotionEvent` to the detector.
    We are going to program the large `ImageView` so that it can display a small gallery
    of related pictures that can be accessed by swiping left or right on the image.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一起，`view.GestureDetector` 和 `view.View.OnTouchListener` 就是我们为 `ImageView` 提供手势功能所需的所有内容。监听器包含一个
    `onTouch()` 回调，它将每个 `MotionEvent` 传递给检测器。我们将编程大型的 `ImageView` 以便它能够显示一个小图库，用户可以通过在图像上左右滑动来访问这些图片。
- en: There are two steps to this task as, before we implement our gesture detector,
    we need to provide the data for it to work on.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务有两个步骤，因为在实现我们的手势检测器之前，我们需要提供它工作的数据。
- en: Adding the gallery data
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加图库数据
- en: 'As this app is for demonstration and learning purposes, and so we can progress
    as quickly as possible, we will only provide extra images for one or two of the
    ancient sites in the project. Here is how it''s done:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个应用程序是用于演示和学习目的，因此我们可以尽可能快地进步，所以我们只为项目中的一个或两个古代遗址提供额外的图片。以下是操作方法：
- en: Open the Ancient Britain project.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开古代英国项目。
- en: Open the `MainData.java` file.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainData.java` 文件。
- en: 'Add the following arrays:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下数组：
- en: '[PRE0]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Either download the project files from the Packt website or find four of your
    own images (around 640 x 480 px). Name them `henge_2`, `henge_3`, `henge_4,` and
    `wall_2` and place them in your `res/drawable` directory.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要么从 Packt 网站下载项目文件，要么找到四张你自己的图片（大约 640 x 480 像素）。将它们命名为 `henge_2`、`henge_3`、`henge_4`
    和 `wall_2` 并将它们放置在 `res/drawable` 目录中。
- en: This is all very straightforward, and the code that will accompany it allows
    you to have individual arrays of any length. This is all we need to add to our
    gallery data. Now, we need to code our `GestureDetector` and `OnTouchListener`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都非常直接，伴随的代码允许你拥有任意长度的单个数组。这是我们添加到图库数据中所需的所有内容。现在，我们需要编写我们的 `GestureDetector`
    和 `OnTouchListener`。
- en: Adding the GestureDetector
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 `GestureDetector`
- en: Along with the `OnTouchListener` that we will define for our `ImageView`, the
    GestureDetector has its own listeners. Here we will use `GestureDetector.OnGestureListener`
    to detect a fling gesture and collect the `MotionEvent` that describe it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们将为`ImageView`定义的`OnTouchListener`之外，GestureDetector还有它自己的监听器。在这里，我们将使用`GestureDetector.OnGestureListener`来检测滑动手势并收集描述它的`MotionEvent`。
- en: 'Follow these steps to program your `ImageView` to respond to fling gestures:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤编程`ImageView`以响应滑动手势：
- en: Open the `DetailActivity.java` file.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`DetailActivity.java`文件。
- en: 'Declare the following class fields:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明以下类字段：
- en: '[PRE1]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the `onCreate()` method assigns both the `detector` and `listener` like
    this:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate()`方法中，像这样分配`detector`和`listener`：
- en: '[PRE2]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Beneath this, add the following line:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此之下，添加以下行：
- en: '[PRE3]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Beneath the line `detailImage = (ImageView) findViewById(R.id.detail_image);`,
    add the following line:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`detailImage = (ImageView) findViewById(R.id.detail_image);`行之下，添加以下行：
- en: '[PRE4]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create the following inner class:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下内部类：
- en: '[PRE5]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Before dealing with the errors this generates, add the following field to the
    class:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在处理由此产生的错误之前，向类中添加以下字段：
- en: '[PRE6]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Click anywhere on the line registering the error and press *Alt* + *Enter*.
    Then select **Implement Methods**, making sure that you have the **Copy JavaDoc**
    and **Insert @Override** boxes checked.![Adding the GestureDetector](img/B04321_05_01.jpg)
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在注册错误的行上点击任何位置，然后按*Alt* + *Enter*。然后选择**实现方法**，确保已勾选**复制JavaDoc**和**插入 @Override**框。![添加GestureDetector](img/B04321_05_01.jpg)
- en: 'Complete the `onDown()` method like this:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式完成`onDown()`方法：
- en: '[PRE7]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Fill in the `onShowPress()` method:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写`onShowPress()`方法：
- en: '[PRE8]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then fill in the `onFling()` method:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后填写`onFling()`方法：
- en: '[PRE9]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Test the project on an emulator or handset.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器或手机上测试项目。
- en: The process of gesture detection in the preceding code begins when the `OnTouchListener`
    listener's `onTouch()` method is called. It then passes that `MotionEvent` to
    our gesture detector class, `GalleryGestureDetector`, which monitors motion events,
    sometimes stringing them together and timing them until one of the recognized
    gestures is detected. At this point, we can enter our own code to control how
    our app responds as we did here with the `onDown()`, `onShowPress()`, and `onFling()`
    callbacks. It is worth taking a quick look at these methods in turn.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码中手势检测的过程开始于`OnTouchListener`监听器的`onTouch()`方法被调用。然后它将那个`MotionEvent`传递给我们的手势检测类`GalleryGestureDetector`，该类监控运动事件，有时将它们串联起来并计时，直到检测到已识别的手势。在此点，我们可以输入自己的代码来控制我们的应用如何响应，就像这里使用`onDown()`、`onShowPress()`和`onFling()`回调那样。依次查看这些方法是有益的。
- en: It may seem, at the first glance, that the `onDown()` method is redundant; after
    all, it's the fling gesture that we are trying to catch. In fact, overriding the
    `onDown()` method and returning `true` from it is essential in all gesture detections
    as all the gestures begin with an `onDown()` event.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，`onDown()`方法可能显得多余；毕竟，我们试图捕捉的是滑动手势。实际上，覆盖`onDown()`方法并从中返回`true`对于所有手势检测都是必要的，因为所有手势都以一个`onDown()`事件开始。
- en: The purpose of the `onShowPress()` method may also appear unclear as it seems
    to do a little more than `onDown()`. As the **JavaDoc** states, this method is
    handy for adding some form of feedback to the user, acknowledging that their touch
    has been received. The Material Design guidelines strongly recommend such feedback
    and here we have raised the view's elevation slightly.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`onShowPress()`方法的目的也可能不清楚，因为它似乎比`onDown()`做得多一点。正如**JavaDoc**所述，此方法对于向用户添加某种形式的反馈，确认他们的触摸已被接收很有用。Material
    Design指南强烈建议这种反馈，并且在这里我们稍微提高了视图的抬升。'
- en: Without including our own code, the `onFling()` method will recognize almost
    any movement across the bounding view that ends in the user's finger being raised,
    regardless of direction or speed. We do not want very small or very slow motions
    to result in action; furthermore, we want to be able to differentiate between
    vertical and horizontal movement as well as left and right swipes. The `MIN_DISTANCE`
    and `OFF_PATH` constants are in pixels and `VELOCITY_THRESHOLD` is in pixels per
    second. These values will need tweaking according to the target device and personal
    preference. The first MotionEvent argument in `onFling()` refers to the preceding
    `onDown()` event and, like any `MotionEvent`, its coordinates are available through
    its `getX()` and `getY()` methods.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在不包括我们自己的代码的情况下，`onFling()` 方法将几乎识别任何在边界视图内结束于用户手指抬起的行为，无论方向或速度如何。我们不希望非常小或非常慢的动作导致动作发生；此外，我们还想能够区分垂直和水平移动以及左右滑动。`MIN_DISTANCE`
    和 `OFF_PATH` 常量以像素为单位，`VELOCITY_THRESHOLD` 以像素每秒为单位。这些值需要根据目标设备和个人偏好进行调整。`onFling()`
    中的第一个 `MotionEvent` 参数指的是前面的 `onDown()` 事件，就像任何 `MotionEvent` 一样，其坐标可以通过其 `getX()`
    和 `getY()` 方法获得。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The MotionEvent class contains dozens of useful classes for querying various
    event properties—for example, `getDownTime()`, which returns the time in milliseconds
    since the current `onDown()` event.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`MotionEvent` 类包含数十个用于查询各种事件属性的实用类——例如，`getDownTime()`，它返回自当前 `onDown()` 事件以来的毫秒数。'
- en: 'In this example, we used `GestureDetector.OnGestureListener` to capture our
    gesture. However, the GestureDetector has three such nested classes, the other
    two being `SimpleOnGestureListener` and `OnDoubleTapListener`. `SimpleOnGestureListener`
    provides a more convenient way to detect gestures as we only need to implement
    those methods that relate to the gestures we are interested in capturing. We will
    shortly edit our Activity so that it implements the `SimpleOnGestureListener`
    instead, allowing us to tidy our code and remove the four callbacks that we do
    not need. The reason for taking this detour, rather than applying the simple listener
    to begin with, was to get to see all of the gestures available to us through a
    gesture listener and demonstrate how useful JavaDoc comments can be, particularly
    if we are new to the framework. For example, take a look at the following screenshot:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了 `GestureDetector.OnGestureListener` 来捕获我们的手势。然而，GestureDetector
    有三个这样的嵌套类，其他两个是 `SimpleOnGestureListener` 和 `OnDoubleTapListener`。`SimpleOnGestureListener`
    提供了一种更方便的方式来检测手势，因为我们只需要实现那些与我们感兴趣捕获的手势相关的方法。我们将很快编辑我们的 Activity，使其实现 `SimpleOnGestureListener`，这样我们就可以整理我们的代码并移除我们不需要的四个回调。之所以选择这种绕路的方式，而不是一开始就应用简单的监听器，是为了看到通过手势监听器我们可以获得的所有手势，并展示
    JavaDoc 注释有多么有用，尤其是如果我们对框架还不熟悉的话。例如，看看下面的截图：
- en: '![Adding the GestureDetector](img/B04321_05_02.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![添加 GestureDetector](img/B04321_05_02.jpg)'
- en: Another very handy tool is the **Dalvik Debug Monitor Server** (**DDMS**), which
    allows us to see what is going on inside our apps while they are running. The
    workings of our gesture listener are a good place to do this as most of its methods
    operate invisibly.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常实用的工具是 **Dalvik Debug Monitor Server** (**DDMS**)，它允许我们在应用运行时查看应用内部的情况。我们的手势监听器的工作原理是一个很好的观察点，因为它的许多方法都是不可见的。
- en: Viewing gesture activity with DDMS
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 DDMS 查看手势活动
- en: 'To view the workings of our `OnGestureListener` with DDMS, we need to first
    create a tag to identify our messages and then a filter to view them. The following
    steps demonstrate how to do this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 DDMS 查看 `OnGestureListener` 的工作原理，我们首先需要创建一个标签来识别我们的消息，然后创建一个过滤器来查看它们。以下步骤演示了如何进行操作：
- en: Open the `DetailActivity.java` file.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `DetailActivity.java` 文件。
- en: 'Declare the following constant:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明以下常量：
- en: '[PRE10]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the following line inside the `onDown()` method:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onDown()` 方法内添加以下行：
- en: '[PRE11]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Add the line `Log.d(DEBUG_TAG, "onShowPress");` to the `onShowPress()` method
    and do the same for each of our `OnGestureDetector` methods.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onShowPress()` 方法中添加行 `Log.d(DEBUG_TAG, "onShowPress");`，并为我们的每个 `OnGestureDetector`
    方法做同样的事情。
- en: 'Add the following lines to the appropriate clauses in `onFling()`:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onFling()` 的适当子句中添加以下行：
- en: '[PRE12]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Open the **Android DDMS** pane from the **Android** tab at the bottom of the
    window or by pressing *Alt* + *6*.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从窗口底部的 **Android** 选项卡打开 **Android DDMS** 窗格，或者按 *Alt* + *6*。
- en: '![Viewing gesture activity with DDMS](img/B04321_05_03.jpg)'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![使用 DDMS 查看手势活动](img/B04321_05_03.jpg)'
- en: If **logcat** is not visible, it can be opened with the icon to the right of
    the top-right drop-down menu.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果**logcat**不可见，可以通过右上角下拉菜单右侧的图标打开。
- en: Click on this drop-down menu and select **Edit Filter Configuration**.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击此下拉菜单并选择**编辑过滤器配置**。
- en: Complete the dialog as shown in the following screenshot:![Viewing gesture activity
    with DDMS](img/B04321_05_04.jpg)
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下截图完成对话框：![使用DDMS查看手势活动](img/B04321_05_04.jpg)
- en: 'You can now run the project on a handset or emulator and view, in the Logcat,
    which gestures are being triggered and how. Your output should resemble the one
    here:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以在手机或模拟器上运行项目，并在Logcat中查看哪些手势被触发以及如何。你的输出应该类似于这里：
- en: '[PRE13]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**DDMS** is an invaluable tool when it comes to debugging our apps and seeing
    what is going on beneath the hood. Once a **Log Tag** has been defined in the
    code, we can then create a **filter** for it so that we see only the messages
    we are interested in. The `Log` class contains several methods to report information
    based on its level of importance. We used `Log.d`, which stands for *debug*. All
    these methods work with the same two parameters: `Log.[method](String tag, String
    message)`. The full list of these methods is as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**DDMS**是我们调试应用和查看底层发生情况时不可或缺的工具。一旦在代码中定义了**日志标签**，我们就可以为其创建一个**过滤器**，以便我们只看到我们感兴趣的消息。`Log`类包含几个方法，可以根据其重要级别报告信息。我们使用了`Log.d`，代表*调试*。所有这些方法都使用相同的两个参数：`Log.[method](String
    tag, String message)`。这些方法的完整列表如下：'
- en: '`Log.v`: Verbose'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Log.v`: 详细'
- en: '`Log.d`: Debug'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Log.d`: 调试'
- en: '`Log.i`: Information'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Log.i`: 信息'
- en: '`Log.w`: Warning'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Log.w`: 警告'
- en: '`Log.e`: Error'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Log.e`: 错误'
- en: '`Log.wtf`: Unexpected error'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Log.wtf`: 非预期错误'
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is worth noting that most debug messages will be ignored during the packaging
    for distribution except for the verbose messages; thus, it is essential to remove
    them before your final build.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在打包分发过程中，大多数调试信息将被忽略，除了详细消息；因此，在最终构建之前删除它们是至关重要的。
- en: Having seen a little more of the inner workings of our gesture detector and
    listener, we can now strip our code of unused methods by implementing `GestureDetector.SimpleOnGestureListener`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了更多关于我们的手势检测器和监听器的内部工作原理之后，我们现在可以通过实现`GestureDetector.SimpleOnGestureListener`来从我们的代码中删除未使用的方法。
- en: Implementing a SimpleOnGestureListener
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现简单的OnGestureListener
- en: 'It is very simple to convert our gesture detector from one class of listener
    to another. All we need to do is change the class declaration and delete the unwanted
    methods. To do this, perform the following steps:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的手势检测器从一类监听器转换为另一类非常简单。我们只需要更改类声明并删除不需要的方法。为此，请执行以下步骤：
- en: Open the `DetailActivity` file.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`DetailActivity`文件。
- en: 'Change the class declaration for our gesture detector class to the following:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的手势检测器类的类声明更改为以下内容：
- en: '[PRE14]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Delete the `onShowPress()`, `onSingleTapUp()`, `onScroll()`, and `onLongPress()`
    methods.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`onShowPress()`、`onSingleTapUp()`、`onScroll()`和`onLongPress()`方法。
- en: This is all you need to do to switch to the `SimpleOnGestureListener`. We have
    now successfully constructed and edited a gesture detector to allow the user to
    browse a series of images.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是切换到`SimpleOnGestureListener`所需的所有操作。我们现在已经成功构建并编辑了一个手势检测器，允许用户浏览一系列图片。
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You will have noticed that there is no `onDoubleTap()` method in the gesture
    listener. Double-taps can, in fact, be handled with the third `GestureDetector`
    listener, `OnDoubleTapListener`, which operates in a very similar way to the other
    two. However, Google, in its UI guidelines, recommends that a long press should
    be used instead, whenever possible.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到在手势监听器中没有`onDoubleTap()`方法。实际上，双击可以通过第三个`GestureDetector`监听器`OnDoubleTapListener`来处理，它的工作方式与另外两个非常相似。然而，谷歌在其UI指南中建议，在可能的情况下，应使用长按代替。
- en: Before moving on to multitouch events, we will take a look at how to attach
    a `GestureDetector` listener to an entire Activity by adding a splash screen to
    our project. In the process, we will also see how to create a Full-Screen Activity
    and how to edit the `Maniftest` file so that our app launches with the splash
    screen.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续处理多指事件之前，我们将看看如何通过向我们的项目中添加启动画面来将`GestureDetector`监听器附加到整个Activity。在这个过程中，我们还将了解如何创建全屏Activity以及如何编辑`Maniftest`文件，以便我们的应用在启动时显示启动画面。
- en: Adding a GestureDetector to an Activity
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将GestureDetector添加到Activity中
- en: The method we have employed so far allows us to attach a `GestureDetector` listener
    to any view or views and this, of course, applies to `ViewGroups` such as `Layouts`.
    There are times when we may want to detect gestures to be applied to the whole
    screen. For this purpose, we will create a splash screen that can be dismissed
    with a long press.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止采用的方法允许我们将`GestureDetector`监听器附加到任何视图或视图组，当然，这也适用于`ViewGroups`，如`Layouts`。有时我们可能想要检测整个屏幕上的手势。为此，我们将创建一个可以通过长按来关闭的启动屏幕。
- en: 'There are two things we need to do before implementing the gesture detector:
    creating a layout and editing the Manifest file so that the app launches with
    our splash screen.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现手势检测器之前，我们需要做两件事：创建布局和编辑清单文件，以便应用能够使用我们的启动屏幕启动。
- en: Designing the splash screen layout
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计启动屏幕布局
- en: 'The main difference between processing gestures for a whole Activity and an
    individual widget, is that we do not need an `OnTouchListener` as we can override
    the Activity''s own `onTouchEvent()`. Here is how it is done:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 整个活动处理手势与单个小部件处理手势之间的主要区别是，我们不需要`OnTouchListener`，因为我们可以覆盖活动自己的`onTouchEvent()`。以下是实现方法：
- en: Create a new Blank Activity from the Project Explorer context menu called `SplashActivity.java`.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从项目资源管理器上下文菜单中创建一个新的空白活动，命名为`SplashActivity.java`。
- en: The Activity wizard should have created an associated XML layout called `activity_splash.xml`.
    Open this and view it using the **Text** tab.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 活动向导应该创建了一个相关的XML布局，名为`activity_splash.xml`。打开它并使用**文本**选项卡查看。
- en: 'Remove all the padding properties from the root layout so that it looks similar
    to this:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从根布局中移除所有填充属性，使其看起来类似于以下内容：
- en: '[PRE15]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here we will need an image to act as the background for our splash screen. If
    you have not downloaded the project files from the Packt website, find an image,
    roughly of the size and aspect of your target device's screen, upload it to the
    project drawable folder, and call it `splash`. The file I used is 480 x 800 px.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们需要一个图像作为启动屏幕的背景。如果您尚未从Packt网站下载项目文件，找到一个图像，大致与目标设备屏幕的大小和宽高比相似，将其上传到项目drawable文件夹，并命名为`splash`。我使用的文件大小是480
    x 800像素。
- en: ':'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ':'
- en: '![Designing the splash screen layout](img/B04321_05_05.jpg)'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![设计启动屏幕布局](img/B04321_05_05.jpg)'
- en: 'Remove the `TextView` that the wizard placed inside the layout and replace
    it with this `ImageView`:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除向布局内放置的`TextView`，并用此`ImageView`替换：
- en: '[PRE16]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create a `TextView` beneath this, such as the following:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此之下创建一个`TextView`，例如以下内容：
- en: '[PRE17]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Add the following text property:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下文本属性：
- en: '[PRE18]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Tip
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'To save time adding string resources to the `strings.xml` file, enter a hardcoded
    string such as the preceding one and heed the warning from the editor to have
    the string extracted for you like this:'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了节省时间向`strings.xml`文件添加字符串资源，输入一个硬编码的字符串，例如前面的一个，并注意编辑器的警告，以便将字符串提取如下：
- en: '![Designing the splash screen layout](img/B04321_05_06.jpg)'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![设计启动屏幕布局](img/B04321_05_06.jpg)'
- en: There is nothing in this layout that we have not encountered before. We removed
    all the padding so that our splash image will fill the layout; however, you will
    see from the preview that this does not appear to be the case. We will deal with
    this next in our Java code, but we need to edit our **Manifest** first so that
    the app gets launched with our `SplashActivity`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个布局中，我们没有遇到任何之前没有遇到过的事情。我们移除了所有填充，以便我们的启动图像能够填充布局；然而，您将从预览中看到这似乎并不是情况。我们将在Java代码中的下一个步骤中处理这个问题，但我们需要首先编辑我们的**清单**，以便应用能够使用我们的`SplashActivity`启动。
- en: Editing the Manifest
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编辑清单文件
- en: 'It is very simple to configure the `AndroidManifest` file so that an app will
    get launched with whichever Activity we choose; the way it does so is with an
    intent. While we are editing the Manifest, we will also configure the display
    to fill the screen. Simply follow these steps:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 配置`AndroidManifest`文件以便应用能够启动我们选择的任何活动非常简单；它是通过一个意图来实现的。当我们编辑清单时，我们还将配置显示以填充屏幕。只需按照以下步骤操作：
- en: 'Open the `res/values-v21/styles.xml` file and add the following style:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`res/values-v21/styles.xml`文件并添加以下样式：
- en: '[PRE19]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Open the `AndroidManifest.xml` file.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`AndroidManifest.xml`文件。
- en: Cut-and-paste the `<intent-filter>` element from `MainActivity` to `SplashActivity`.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MainActivity`中的`<intent-filter>`元素剪切并粘贴到`SplashActivity`中。
- en: 'Include the following properties so that the entire `<activity>` node looks
    similar to this:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含以下属性，以便整个`<activity>`节点看起来类似于以下内容：
- en: '[PRE20]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We have encountered **themes** and **styles** before and, here, we took advantage
    of a built-in theme designed for **full screen activities**. In many cases, we
    might have designed a landscape layout here but, as is often the case with splash
    screens, we locked the orientation with the `android:screenOrientation` property.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经遇到过**主题**和**样式**，在这里，我们利用了一个为**全屏活动**设计的内置主题。在许多情况下，我们可能会在这里设计一个横幅布局，但正如启动屏幕通常所做的那样，我们使用`android:screenOrientation`属性锁定方向。
- en: The `android:configChanges` line is not actually needed here, but is included
    as it is useful to know about it. Configuring any attribute such as this prevents
    the system from automatically reloading the Activity whenever the device is rotated
    or the screen size changed. Instead of the Activity restarting, the `onConfigurationChanged()`
    method is called. This was not needed here as the screen size and orientation
    were taken care of in the previous lines of code and this line was only included
    as a point of interest.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`android:configChanges`这一行实际上在这里并不需要，但包括它是有用的，因为了解它。配置任何这样的属性都可以防止系统在设备旋转或屏幕尺寸改变时自动重新加载Activity。而不是Activity重新启动，`onConfigurationChanged()`方法会被调用。这里并不需要，因为屏幕尺寸和方向已经在之前的代码行中处理好了，这一行只是作为一个参考点。'
- en: Finally, we changed the value of `android:label`. You may have noticed that,
    depending on the screen size of the device you are using, the name of our app
    is not displayed in full on the home screen or apps drawer. In such cases, when
    you want to use a shortened name for your app, it can be inserted here.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们更改了`android:label`的值。你可能已经注意到，根据你使用的设备的屏幕尺寸，我们的应用程序名称在主屏幕或应用程序抽屉中可能无法完整显示。在这种情况下，当你想为你的应用程序使用简短名称时，它可以在这里插入。
- en: With everything else in place, we can get on with adding our gesture detector.
    This is not dissimilar to the way we did this before but, this time, we will apply
    the detector to the whole screen and will be listening for a long press, rather
    than a fling.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有其他设置就绪的情况下，我们可以继续添加我们的手势检测器。这并不与之前我们做的方式完全不同，但这次，我们将检测器应用于整个屏幕，并将监听长按事件，而不是滑动事件。
- en: Adding the GestureDetector
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加GestureDetector
- en: Along with implementing a gesture detector for the entire Activity here, we
    will also take the final step in configuring our splash screen so that the image
    fills the screen, but maintains its aspect ratio. Follow these steps to complete
    the app splash screen.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在这里为整个Activity实现手势检测器之外，我们还将完成配置启动屏幕的最终步骤，以便图像填充屏幕，同时保持其宽高比。按照以下步骤完成应用程序的启动屏幕。
- en: Open the `SplashActivity` file.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`SplashActivity`文件。
- en: 'Declare a `GestureDetector` as we did in the earlier exercise:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`GestureDetector`，就像我们在之前的练习中所做的那样：
- en: '[PRE21]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the `onCreate()` method, assign and configure our splash image and gesture
    detector like this:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate()`方法中，按照以下方式分配和配置我们的启动图像和手势检测器：
- en: '[PRE22]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, override the Activity''s `onTouchEvent()` like this:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，像这样覆盖Activity的`onTouchEvent()`方法：
- en: '[PRE23]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create the following `SimpleOnGestureListener` class:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下`SimpleOnGestureListener`类：
- en: '[PRE24]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Build and run the app on your phone or an emulator.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的手机或模拟器上构建并运行应用程序。
- en: The way a gesture detector is implemented across an entire Activity should be
    familiar by this point, as should the capturing of the long press event. The `ImageView.setScaleType(ImageView.ScaleType)`
    method is essential here; it is a very useful method in general. The `CENTER_CROP`
    constant scales the image to fill the view while maintaining the aspect ratio,
    cropping the edges when necessary.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，整个Activity中手势检测器的实现方式应该已经熟悉，同样，长按事件的捕获也应该熟悉。`ImageView.setScaleType(ImageView.ScaleType)`方法在这里是必不可少的；这是一个非常实用的方法。`CENTER_CROP`常量将图像缩放以填充视图，同时保持宽高比，必要时裁剪边缘。
- en: '![Adding the GestureDetector](img/B04321_05_07.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![添加GestureDetector](img/B04321_05_07.jpg)'
- en: There are several similar `ScaleTypes`, such as `CENTER_INSIDE`, which scales
    the image to the maximum size possible without cropping it, and `CENTER`, which
    does not scale the image at all. The beauty of `CENTER_CROP` is that it means
    that we don't have to design a separate image for every possible aspect ratio
    on the numerous devices our apps will end up running on. Provided that we make
    allowances for very wide or very narrow screens by not including essential information
    too close to the edges, we only need to provide a handful of images of varying
    pixel densities to maintain the image quality on large, high-resolution devices.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种类似的`ScaleTypes`，例如`CENTER_INSIDE`，它将图像缩放到最大可能的大小而不裁剪它，以及`CENTER`，它根本不缩放图像。`CENTER_CROP`的优点在于这意味着我们不需要为我们的应用最终将在其上运行的众多设备上的每一个可能的宽高比设计一个单独的图像。只要我们通过不将重要信息放置得太靠近边缘来为非常宽或非常窄的屏幕留出空间，我们只需要提供一些不同像素密度的图像，就可以在大分辨率设备上保持图像质量。
- en: Tip
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The scale type of `ImageView` can be set from within XML with `android:scaleType="centerCrop"`,
    for example.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImageView`的缩放类型可以通过XML设置，例如使用`android:scaleType="centerCrop"`。'
- en: You may have wondered why we did not use the built-in **Full-Screen Activity**
    from the wizard; we could easily have done so. The template code the wizard creates
    for a Full-Screen Activity provides far more features than we needed for this
    exercise. Nevertheless, the template is worth taking a look at, especially if
    you want a fullscreen that brings the status bar and other components into view
    when the user interacts with the Activity.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们没有使用向导提供的内置**全屏活动**；我们本可以轻松做到这一点。向导为全屏活动创建的模板代码提供了比我们这个练习所需多得多的功能。尽管如此，这个模板仍然值得一看，尤其是如果你想要一个当用户与活动交互时将状态栏和其他组件显示出来的全屏。
- en: That brings us to the end of this chapter. Not only have we seen how to make
    our apps interact with touch events and gestures, but also how to send debug messages
    to the IDE and make a Full-Screen Activity.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这就带我们结束了本章的内容。我们不仅看到了如何使我们的应用与触摸事件和手势交互，还看到了如何向IDE发送调试信息以及如何创建全屏活动。
- en: Summary
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: We began this chapter by adding a `GestureDetector` to our project. We then
    edited it so that we could filter out meaningful touch events (swipe right and
    left, in this case). We went on to see how the `SimpleOnGestureListener` can save
    us a lot of time when we are only interested in catching a subset of the recognized
    gestures. We also saw how to use DDMS to pass debug messages during runtime and
    how, through a combination of XML and Java, the status and action bars can be
    hidden and the entire screen be filled with a single view or view group.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章的开头通过向我们的项目中添加一个`GestureDetector`来开始。然后我们编辑它，以便能够过滤出有意义的触摸事件（在这个例子中是左右滑动）。接着我们看到了当只对捕获已识别手势的子集感兴趣时，`SimpleOnGestureListener`如何能为我们节省大量时间。我们还看到了如何使用DDMS在运行时传递调试信息，以及如何通过XML和Java的组合来隐藏状态栏和操作栏，使整个屏幕只填充一个视图或视图组。
- en: Next, we will explore how our apps can communicate with the user through the
    various forms of notification the framework provides. We will also see how to
    allow the user to add their own data to the app and configure some settings.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探索我们的应用如何通过框架提供的各种通知形式与用户通信。我们还将看到如何允许用户将他们自己的数据添加到应用中并配置一些设置。
