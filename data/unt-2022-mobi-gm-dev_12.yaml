- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Improving Game Feel
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改善游戏感觉
- en: We now have a basic game, but it’s just that... basic. In this chapter, you
    will learn some of the secrets of game developers to take the basic prototype
    of their game and turn it into something with a lot of polish that feels satisfying
    to play, which is known as improving the game feel of the project.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个基本的游戏，但仅仅是...基本。在本章中，你将学习游戏开发者的一些秘密，将他们游戏的基本原型转变为一个经过大量打磨、令人满意的游戏体验，这被称为改善项目的游戏感觉。
- en: Also known as *juiciness*, or making our games juicy, in some corners of the
    game industry, **game feel** is a kind of catch-all term for all the things that
    we do in a game to make it pleasing for its users to interact with. This is something
    that is done with most mobile games that are out there today, and lacking this
    kind of interactivity will make others believe our project is lacking in polish.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 也被称为*juiciness*，或者让我们的游戏更有“汁感”，在游戏行业的某些角落，**游戏感觉**是一个总称，用于描述我们在游戏中做的所有事情，以使用户的交互体验更加愉悦。这是现在大多数移动游戏都会做的事情，缺乏这种交互性会让其他人认为我们的项目缺乏打磨。
- en: In this chapter, you will learn some of the different ways that you can integrate
    several of these features into your projects. We will start off by learning how
    to make use of animations. We will then see how we can use Unity’s material system
    in order to add visual appeal to our objects. We will then improve the overall
    visual quality of our game through the use of postprocessing effects. Lastly,
    we will use one of the most powerful tools in a game developer’s toybox, the particle
    system, to improve feedback when the player moves in the environment.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何将一些这些功能集成到你的项目中的一些不同方法。我们将从学习如何使用动画开始。然后，我们将看到如何使用Unity的材料系统来为我们的对象添加视觉吸引力。接着，我们将通过使用后处理效果来提高我们游戏的整体视觉质量。最后，我们将使用游戏开发者工具箱中最强大的工具之一，粒子系统，来改善玩家在环境中移动时的反馈。
- en: 'This chapter covers a number of topics. It goes through a simple step-by-step
    process from beginning to end. Here is an outline of the tasks we will cover:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了多个主题。它从开始到结束提供了一个简单的逐步过程。以下是我们将涵盖的任务概述：
- en: Animation using LeanTween
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用LeanTween进行动画
- en: Adding tweens to the pause menu
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将缓动添加到暂停菜单
- en: Working with materials
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与材料一起工作
- en: Using postprocessing effects
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用后处理效果
- en: Adding particle effects
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加粒子效果
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This book utilizes Unity 2022.1.0b16 and Unity Hub 3.3.1, but the steps should
    work with minimal changes in future versions of the editor. If you would like
    to download the exact version used in this book, and there is a new version out,
    you can visit Unity’s download archive at [https://unity3d.com/get-unity/download/archive](https://unity3d.com/get-unity/download/archive).
    You can also find the system requirements for Unity at [https://docs.unity3d.com/2022.1/Documentation/Manual/system-requirements.html](https://docs.unity3d.com/2022.1/Documentation/Manual/system-requirements.html)
    in the **Unity Editor system requirements** section. To deploy your project, you
    will need an Android or iOS device.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用Unity 2022.1.0b16和Unity Hub 3.3.1，但步骤应该在未来版本的编辑器中只需进行最小改动即可。如果你想下载本书中使用的确切版本，并且有新版本发布，你可以访问Unity的下载存档[https://unity3d.com/get-unity/download/archive](https://unity3d.com/get-unity/download/archive)。你还可以在**Unity编辑器系统要求**部分找到Unity的系统要求[https://docs.unity3d.com/2022.1/Documentation/Manual/system-requirements.html](https://docs.unity3d.com/2022.1/Documentation/Manual/system-requirements.html)。为了部署你的项目，你需要一个Android或iOS设备。
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Unity-2022-Mobile-Game-Development-3rd-Edition/tree/main/Chapter12](https://github.com/PacktPublishing/Unity-2022-Mobile-Game-Development-3rd-Edition/tree/main/Chapter12).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章中提供的代码文件[https://github.com/PacktPublishing/Unity-2022-Mobile-Game-Development-3rd-Edition/tree/main/Chapter12](https://github.com/PacktPublishing/Unity-2022-Mobile-Game-Development-3rd-Edition/tree/main/Chapter12)。
- en: Animation using LeanTween
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用LeanTween进行动画
- en: Currently, our game’s menus are completely static. This is functional but does
    not make players excited about playing our game. To make the game seem more alive,
    we should animate our menus. Being able to use Unity’s built-in animation system
    is great, and it can be quite useful if you want to modify many different properties
    at once. If you don’t need precise control, say, if you’re only modifying a single
    property or you want to animate something purely via code, you can also make use
    of a tweening library.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们游戏的菜单完全静态。这虽然功能齐全，但并不能让玩家对我们的游戏产生兴趣。为了让游戏看起来更有活力，我们应该对菜单进行动画处理。能够使用Unity内置的动画系统是很好的，如果你想要同时修改许多不同的属性，它非常有用。如果你不需要精确控制，比如说，如果你只修改一个属性或者你想要通过代码纯动画化某个东西，你还可以使用一个插值库。
- en: Tweening, short for “in-betweening,” is a common technique used in animation
    and game development to create smooth transitions between two states or values
    over a specified duration. It involves interpolating or transitioning a property
    or set of properties from one value to another gradually.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Tweening，简称“插值”，是动画和游戏开发中常用的一种技术，用于在指定的时间内，在两个状态或值之间创建平滑的过渡。它涉及将属性或一组属性从某个值逐渐过渡到另一个值。
- en: If it is given a start and an end, the library will take care of all the work
    in the middle to get that property to that endpoint within the time and speed
    you specify. By using tweens, developers can easily add fluid and visually appealing
    animations to their applications without having to manually handle the interpolation
    calculations and animation loops. Tweening libraries provide convenient APIs and
    functionalities to create and control tweens in a straightforward and efficient
    manner.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果给出了开始和结束点，库将负责中间的所有工作，以确保属性在指定的时间和速度内到达终点。通过使用tween，开发者可以轻松地为他们的应用程序添加流畅且视觉上吸引人的动画，而无需手动处理插值计算和动画循环。插值库提供了方便的API和功能，以简单高效的方式创建和控制tween。
- en: One of my favorite tweening libraries is Dented Pixel’s *LeanTween*, which is
    open source, usable for free in commercial and non-commercial projects, optimized
    for mobile devices, and used in many games, including Pokémon Go. In the following
    sections, we will first install and set up LeanTween and then see how we can use
    it to animate our title screen UI menus.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我最喜欢的插值库之一是Dented Pixel的*LeanTween*，这是一个开源库，可以免费用于商业和非商业项目，针对移动设备进行了优化，并被许多游戏使用，包括《精灵宝可梦GO》。在接下来的章节中，我们将首先安装和设置LeanTween，然后看看我们如何使用它来动画化我们的标题屏幕UI菜单。
- en: LeanTween setup
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LeanTween设置
- en: LeanTween allows us to spin, shake, punch, move, fade, and tweak objects in
    many different ways with only one line of code per task. It also gives us the
    ability to fire custom events during the start, middle, and end of the animations,
    allowing us to effectively do whatever we want to create an animation in a way
    that is incredibly powerful once you get familiar with it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: LeanTween允许我们以仅一行代码的方式对对象进行旋转、震动、打击、移动、淡入淡出和调整，以多种不同的方式。它还允许我们在动画的开始、中间和结束时触发自定义事件，使我们能够有效地完成任何想要创建动画的事情，一旦熟悉了它，这种方式将变得非常强大。
- en: 'Now that we know we want to add tweens to our project, let’s start off by actually
    adding the LeanTween engine to our project. Implement the following steps:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道我们想要在我们的项目中添加tween，那么让我们首先将LeanTween引擎添加到我们的项目中。执行以下步骤：
- en: Open up the `LeanTween` and then press *Enter*.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`LeanTween`然后按*Enter*。
- en: 'From there, you’ll be brought to a list of items, with the first one being
    **LeanTween**; select it and you will be brought to LeanTween’s product page:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从那里，你将看到一个项目列表，第一个是**LeanTween**；选择它，你将被带到LeanTween的产品页面：
- en: '![Figure 12.1: Asset Store search](img/B18868_12_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1：资产商店搜索](img/B18868_12_01.jpg)'
- en: 'Figure 12.1: Asset Store search'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1：资产商店搜索
- en: Once on the project page, click on button that either says **Add to My Assets**
    or **Open In Unity** depending on if you have the package or not. At this point
    you may need to log into your Unity account. Once added, from the **Package Manager**,
    go ahead and from the asset page click on the **Import** button.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦进入项目页面，点击按钮，如果有的话，按钮上会写着**添加到我的资产**或**在Unity中打开**，这取决于你是否已经有了这个包。此时你可能需要登录你的Unity账户。一旦添加，从**包管理器**中，继续从资产页面点击**导入**按钮。
- en: '![Figure 12.2: Package Manager](img/B18868_12_02.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图12.2：包管理器](img/B18868_12_02.jpg)'
- en: 'Figure 12.2: Package Manager'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2：包管理器
- en: Important note
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The packages in the Package Manager here will likely look different than yours
    as they are ones that I have personally purchased from the Asset Store.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里包管理器中的包可能看起来与你的不同，因为它们是我个人从资源商店购买的。
- en: You should see an `Framework` folder here; however, the others may be useful
    to you, so feel free to use them yourself.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该在这里看到一个 `Framework` 文件夹；然而，其他的可能对你也有用，所以请随意使用它们。
- en: 'Once you’ve finished selecting what you want, click on the **Import** button:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你完成了选择，点击**导入**按钮：
- en: '![Figure 12.3: Import Unity Package dialog](img/B18868_12_03.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图12.3：导入Unity包对话框](img/B18868_12_03.jpg)'
- en: 'Figure 12.3: Import Unity Package dialog'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3：导入Unity包对话框
- en: 'We don’t need the Package Manager anymore, so go ahead and close it. You’ll
    notice that now we have the files we have selected inside our `Assets/LeanTween/Framework`
    folder:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不再需要包管理器了，所以请继续关闭它。你会注意到现在我们已经在我们的 `Assets/LeanTween/Framework` 文件夹中选择了文件：
- en: '![Figure 12.4: LeanTween imported](img/B18868_12_04.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图12.4：导入LeanTween](img/B18868_12_04.jpg)'
- en: 'Figure 12.4: LeanTween imported'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4：导入LeanTween
- en: With that, we have set up LeanTween.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们已经设置了LeanTween。
- en: Important note
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: There are other tweening libraries that you may want to consider, such as iTween
    and DOTween. For some more information and a comparison of them, check out [http://dotween.demigiant.com/#enginesComparison](http://dotween.demigiant.com/#enginesComparison).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还想考虑其他缓动库，例如iTween和DOTween。有关更多信息以及它们的比较，请查看[http://dotween.demigiant.com/#enginesComparison](http://dotween.demigiant.com/#enginesComparison)。
- en: Now that we have a tweening system in place, let’s see how we can actually use
    it!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了一个缓动系统，让我们看看我们如何实际使用它！
- en: Creating a simple tween
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个简单的缓动
- en: Made popular in animation before transitioning to game development, the process
    of tweening (or *inbetweening*) is where, given a starting and ending value, the
    computer will generate the intermediate frames between the two states, giving
    the appearance of the beginning value evolving smoothly into the second value.
    A tween is the information that we have to provide in order to start the tweening
    process.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在过渡到游戏开发之前，缓动（或*中间插值*）在动画中变得流行，这个过程是给定起始值和结束值时，计算机将在两个状态之间生成中间帧，使得起始值看起来平滑地演变到第二个值。缓动是我们必须提供的信息，以便开始缓动过程。
- en: 'Now that we have LeanTween included in our project, we can use it inside our
    code. To do that, perform the following steps:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将LeanTween包含到我们的项目中，我们可以在代码中使用它。为此，执行以下步骤：
- en: From the Unity Editor, open the **MainMenu** level by going to the **Project**
    window and double-clicking on the **MainMenu** scene.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Unity编辑器中，通过转到**项目**窗口并双击**MainMenu**场景来打开**MainMenu**级别。
- en: Now, move to the `Scripts` folder and open `MainMenuBehaviour` by double-clicking
    on it.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，转到 `Scripts` 文件夹，通过双击它来打开 `MainMenuBehaviour`。
- en: 'We will add the following new function, which we will use to have the object
    move from the left side of the screen to the center:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将添加以下新函数，我们将使用它来使对象从屏幕左侧移动到中心：
- en: '[PRE0]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Before we move anything using LeanTween, we will first set the position of our
    object (the `obj` parameter) off screen by setting the `x` position. It’s important
    to note that when dealing with UI elements in Unity, by default, we are dealing
    with screen space, which, as you can recall from [*Chapter 3*](B18868_03.xhtml#_idTextAnchor125),
    *Mobile Input/Touch Controls*, means that we are moving in terms of pixels.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用LeanTween移动任何东西之前，我们首先将我们的对象（`obj`参数）的位置设置在屏幕之外，通过设置`x`位置。需要注意的是，在处理Unity中的UI元素时，默认情况下我们处理的是屏幕空间，正如你从[*第3章*](B18868_03.xhtml#_idTextAnchor125)中回忆的，*移动输入/触摸控制*，这意味着我们是按像素移动的。
- en: From here, we’ll see that we are calling the `moveX` function from LeanTween.
    The version we are using takes in three parameters, the first being the `RectTransform`
    object we wish to move and the second being the `x` position to move it to. Based
    on how we set up the anchors and pivots, a position of 0 on the *x* axis is actually
    centered, so we pass in `0`. Lastly, we have the amount of time (in seconds) in
    which we want the transition to happen.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们可以看到我们正在从LeanTween调用 `moveX` 函数。我们使用的版本接受三个参数，第一个是我们希望移动的 `RectTransform`
    对象，第二个是我们希望移动到的 `x` 位置。根据我们设置的锚点和中心点，*x* 轴上的0位置实际上是居中的，所以我们传递 `0`。最后，我们有我们希望过渡发生的时间（以秒为单位）。
- en: 'Now that we have this function, let’s actually call it. Change the `Start`
    function of the `MainMenuBehaviour` script so that it now looks as follows:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了这个函数，让我们实际调用它。更改`MainMenuBehaviour`脚本的`Start`函数，使其看起来如下：
- en: '[PRE1]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first thing we do is bring the Facebook login menu to the screen by calling
    the `SlideMenuIn` function, which in turn will tween the menu to the center of
    the screen. LeanTween, by default, makes use of the game’s `Time.timeScale` property
    to scale movement. When we leave the game from the pause menu and go back to the
    main menu, the game will still be paused. This ensures that the game will be unpaused
    by the time we want to slide this menu in. When we start building the pause menu,
    we’ll see how we can make our tweens work even when the game is paused.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过调用`SlideMenuIn`函数将Facebook登录菜单显示到屏幕上，该函数会将菜单移动到屏幕中央。LeanTween默认使用游戏的`Time.timeScale`属性来缩放移动。当我们从暂停菜单离开游戏并返回主菜单时，游戏仍然处于暂停状态。这确保了在我们想要滑动这个菜单时，游戏不会被暂停。当我们开始构建暂停菜单时，我们将看到如何在游戏暂停时使我们的缓动效果仍然工作。
- en: If you play the game now, you’ll notice that the Facebook login screen will
    now move from off screen back into the center of the screen.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在玩游戏，你会注意到Facebook登录屏幕现在会从屏幕外移动到屏幕中央。
- en: Right now, the object moves in a fairly static manner. One of the ways we can
    add life to this tween is by giving it some additional features, such as `easeType`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，对象以相当静态的方式移动。我们可以通过添加一些额外的功能，例如`easeType`，来给这个缓动效果增加活力。
- en: 'Add the following highlighted code to the `SlideMenuIn` function:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下高亮代码添加到`SlideMenuIn`函数中：
- en: '[PRE2]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'What is happening here is that the `LeanTween.moveX` function returns an object
    of the `LTDescr` type, which is actually a reference to the tween that was created.
    To that tween, we can add additional parameters by calling additional functions
    onto the tween. In fact, an alternate way to write this is the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的情况是，`LeanTween.moveX`函数返回一个`LTDescr`类型的对象，这实际上是创建的缓动的引用。我们可以通过在缓动上调用额外的函数来添加额外的参数。实际上，编写这个的另一种方式如下：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: However, most of the examples in LeanTween’s documentation use the former method,
    chaining a number of different events to happen at once.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，LeanTween文档中的大多数示例都使用了前一种方法，即同时链式调用多个不同的事件发生。
- en: Important note
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: To see what some of the other commonly used methods are besides `easeType` in
    LeanTween, check out [https://tedliou.com/archives/leantween-ui-animation/](https://tedliou.com/archives/leantween-ui-animation/).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看除了`easeType`之外LeanTween中常用的其他方法，请参阅[https://tedliou.com/archives/leantween-ui-animation/](https://tedliou.com/archives/leantween-ui-animation/)。
- en: 'Finally, we will add the ability for the current menu to slide off screen when
    we select a button to go to another menu:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将添加当前菜单在选中按钮跳转到另一个菜单时能够滑出屏幕的功能：
- en: '[PRE4]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that this is similar to the previously written function, except now we
    are also using another function called `setOnComplete`, which can take in either
    a function or an expression lambda, which works basically as a function without
    a name and is often used in `obj`, I used a lambda. What this will do is after
    the object is off screen, it will automatically turn off; but we have the potential
    to do anything. This can be incredibly powerful, as we can do anything that we’d
    normally be able to do via code.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这与之前编写的函数类似，但现在我们还在使用另一个名为`setOnComplete`的函数，它可以接受一个函数或表达式lambda，它基本上是一个没有名称的函数，常用于`obj`中，我使用了lambda。这将做的就是在对象离开屏幕后，它会自动关闭；但我们有做任何事的潜力。这可以非常强大，因为我们可以通过代码做任何我们通常能做的事情。
- en: Important note
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: For more information on lambda expressions, check out [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/lambda-expressions](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/lambda-expressions).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 关于lambda表达式的更多信息，请参阅[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/lambda-expressions](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/lambda-expressions)。
- en: 'Then, we will need to update the `ShowMainMenu` function to actually display
    the menus:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要更新`ShowMainMenu`函数以实际显示菜单：
- en: '[PRE5]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Save the script and dive back into the game:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本并重新进入游戏：
- en: '![Figure 12.5: Menus sliding in and out](img/B18868_12_05.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图12.5：菜单的滑动进出](img/B18868_12_05.jpg)'
- en: 'Figure 12.5: Menus sliding in and out'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5：菜单的滑动进出
- en: As you can see, the menus will now fly in and out when on the main menu.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当在主菜单上时，菜单现在会飞入和飞出。
- en: With the preceding example, you should be able to see just how easy it is to
    add motion to our projects and how it can improve the overall quality of the game,
    making it more enjoyable to interact with.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的示例，你应该能够看到将运动添加到我们的项目中是多么容易，以及它如何提高游戏的整体质量，使其更具互动性。
- en: Adding tweens to the pause menu
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加暂停菜单的补间动画
- en: 'Now that we have finished the main menu, let’s continue adding tweens to the
    pause menu:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了主菜单，让我们继续为暂停菜单添加补间动画：
- en: 'Go ahead and open up our `PauseScreenBehaviour` script to have the following
    implementation of `SetPauseMenu`:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续打开我们的`PauseScreenBehaviour`脚本，以实现以下`SetPauseMenu`的实现：
- en: '[PRE6]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that because `PauseMenuBehaviour` inherits from `MainMenuBehaviour`, it
    can also call the `SlideMenuIn` and `SlideMenuOut` functions, respectively, as
    long as they are marked as `protected` or `public`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，因为`PauseMenuBehaviour`继承自`MainMenuBehaviour`，它也可以调用`SlideMenuIn`和`SlideMenuOut`函数，只要它们被标记为`protected`或`public`。
- en: 'Now, if we run the game, nothing will appear to happen when we hit the pause
    menu. This is because—as I mentioned previously—tweens are scaled by `Time.timeScale`,
    which we just changed. To fix this, we can make use of another LeanTween function,
    called `setIgnoreTimeScale`, which we will set to `true` in both functions we
    wrote previously in the `MainMenuBehaviour` script. Go back to the `MainMenuBehaviour`
    script and add the following highlighted code to the `SlideMenuIn` method:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行游戏，当我们点击暂停菜单时，看起来没有任何事情发生。这是因为——正如我之前提到的——补间动画是由`Time.timeScale`缩放的，我们刚刚改变了它。为了解决这个问题，我们可以使用另一个LeanTween函数，称为`setIgnoreTimeScale`，我们将它设置为`true`在我们在`MainMenuBehaviour`脚本中编写的两个函数中。回到`MainMenuBehaviour`脚本，并将以下高亮代码添加到`SlideMenuIn`方法中：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the highlighted code to the `SlideMenuOut` method:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将高亮代码添加到`SlideMenuOut`方法中：
- en: '[PRE8]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Save both scripts and dive into the Editor to try it out:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存这两个脚本，并进入编辑器尝试一下：
- en: '![Figure 12.6: Screen flying in](img/B18868_12_06.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图12.6：屏幕飞入](img/B18868_12_06.jpg)'
- en: 'Figure 12.6: Screen flying in'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6：屏幕飞入
- en: Perfect! We now have the screen flying in just like we wanted it to.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！我们现在已经实现了屏幕飞入的效果，就像我们想要的那样。
- en: In the previous two sections, we learned how to create tweening events and how
    to apply them to different scenarios. In the next section, we will see another
    way that we can improve the visuals of our project through the use of materials.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两个部分中，我们学习了如何创建补间事件以及如何将它们应用于不同的场景。在下一部分，我们将看到另一种方法，我们可以通过使用材质来改善我们项目的视觉效果。
- en: Working with materials
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与材质一起工作
- en: Previously, we have always used the default material for everything in our project.
    This has worked out well for us, but it may be a good idea for us to talk a little
    bit about creating custom ones to improve the visuals of our player. Materials
    are instructions on how to draw 3D objects within Unity. They consist of a shader
    and properties that the shader uses. A **shader** is a script that instructs the
    material on how to draw things on the object.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们一直在我们的项目中使用默认材质。这对我们来说效果很好，但也许我们应该谈谈创建自定义材质来改善玩家视觉效果的想法。材质是在Unity中绘制3D对象的指令。它们由一个着色器和着色器使用的属性组成。**着色器**是一个脚本，它指导材质如何在对象上绘制东西。
- en: 'Shaders are a huge subject that entire books have been written on, so we can’t
    dive too much into them here, but we can talk about working with one that is included
    in Unity, the **Standard Shader**. Implement the following steps:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器是一个很大的主题，已经有整本书被写出来，所以我们在这里不能深入探讨，但我们可以谈谈如何与Unity中包含的**标准着色器**一起工作。执行以下步骤：
- en: 'First, open the `Materials`:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开`Materials`：
- en: '![Figure 12.7: Adding Materials](img/B18868_12_07.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图12.7：添加材质](img/B18868_12_07.jpg)'
- en: 'Figure 12.7: Adding Materials'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7：添加材质
- en: 'Open up the `Materials` folder we just created, and then once inside, create
    a new material by right-clicking within the folder and then selecting **Create**
    | **Material**:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开我们刚刚创建的`Materials`文件夹，然后一旦进入其中，通过在文件夹内右键单击并选择**创建** | **材质**来创建一个新的材质：
- en: '![Figure 12.8: Creating a material](img/B18868_12_08.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图12.8：创建材质](img/B18868_12_08.jpg)'
- en: 'Figure 12.8: Creating a material'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8：创建材质
- en: Name this new material `Ball`. In the `0.9` and the `0.8`.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个新材质命名为`Ball`。在`0.9`和`0.8`。
- en: Now, go to the **Scene** view and drag and drop the **Ball** material onto our
    player object.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，转到**场景**视图，并将**球体**材质拖放到我们的玩家对象上。
- en: '![Figure 12.9: Setting material properties](img/B18868_12_09.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图12.9：设置材质属性](img/B18868_12_09.jpg)'
- en: 'Figure 12.9: Setting material properties'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.9：设置材质属性
- en: The albedo property acts as a diffuse map setting the base color of an object,
    though you can also apply a texture to use an image file to change how it looks.
    The **Metallic** parameter of a material determines how *metal-like* the surface
    is. The more metallic a surface is, the more it reflects its environment. The
    **Smoothness** property determines how smooth the surface is; a higher smoothness
    will have light bounce off it uniformly, making the reflections clearer.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 阿尔贝多属性充当漫反射贴图设置对象的基础颜色，尽管您也可以应用纹理，使用图像文件来改变其外观。材质的**金属度**参数决定了表面有多像金属。表面越像金属，它反射的环境就越多。**平滑度**属性决定了表面的平滑程度；更高的平滑度会使光线均匀地反射，使反射更清晰。
- en: Important note
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: For more information on the standard shader and its parameters, check out [https://docs.unity3d.com/Manual/StandardShaderMaterialParameters.html](https://docs.unity3d.com/Manual/StandardShaderMaterialParameters.html).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有关标准着色器和其参数的更多信息，请参阅[https://docs.unity3d.com/Manual/StandardShaderMaterialParameters.html](https://docs.unity3d.com/Manual/StandardShaderMaterialParameters.html)。
- en: Using materials is only one of the ways that we can improve the visual quality
    of our project. In fact, one of the most drastic ways that we can modify our project’s
    visuals is through the use of postprocessing effects, which we will be looking
    at next.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用材质只是我们提高项目视觉质量的一种方式。实际上，我们可以通过使用后处理效果来大幅度修改项目的视觉效果，这是我们接下来将要探讨的。后处理效果是指在屏幕上显示之前，对相机将要绘制的图像（图像缓冲区）应用滤镜和其他效果的流程。
- en: Using postprocessing effects
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用后处理效果
- en: One of the ways that we can improve the visual quality of our game with little
    effort is by using postprocessing effects (previously called **Image Effects**).
    Postprocessing is the process of applying filters and other effects to what the
    camera will draw (the image buffer) before it is displayed on screen.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用后处理效果（之前称为**图像效果**）以最小的努力提高游戏视觉质量。后处理是在屏幕上显示之前，对相机将要绘制的图像（图像缓冲区）应用滤镜和其他效果的流程。
- en: Unity includes a number of effects in its freely available postprocessing stack.
    Unity’s postprocessing stack is a set of visual effects that can be applied to
    the rendered images in a game or application to enhance the overall visual quality.
    These effects can include things like color grading, depth of field, motion blur,
    ambient occlusion, and more. By using the postprocessing stack, developers can
    easily add these effects to their games without having to create them from scratch.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Unity在其免费提供的后处理堆栈中包含了许多效果。Unity的后处理堆栈是一组可以应用于游戏或应用程序中渲染图像的视觉效果，以增强整体视觉质量。这些效果可能包括色彩分级、景深、运动模糊、环境遮挡等。通过使用后处理堆栈，开发者可以轻松地将这些效果添加到他们的游戏中，而无需从头开始创建。
- en: 'The term “stack” is used to emphasize that these effects are designed to be
    used together, in a layered manner, to achieve a desired visual style or aesthetic.
    By providing a pre-built collection of effects as a stack, Unity simplifies the
    process of implementing advanced visual effects for developers, allowing them
    to focus more on the creative aspects of their projects. So, let’s go ahead and
    add it using the following steps:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 术语“堆叠”用于强调这些效果旨在一起使用，以分层的方式实现所需的视觉风格或美学。通过提供作为堆叠的预构建效果集合，Unity简化了开发者实现高级视觉效果的流程，使他们能够更多地关注项目创意方面。因此，让我们按照以下步骤继续添加：
- en: 'Open up the Package Manager again by going to **Window** | **Package Manager**.
    From there, go to the **Packages** dropdown from the top left and set it to **Unity
    Registry**. Afterward, scroll down until you see the **Post Processing** option
    and select it:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过前往**窗口** | **包管理器**再次打开包管理器。从那里，点击左上角的**包**下拉菜单并将其设置为**Unity注册表**。之后，向下滚动直到您看到**后处理**选项并选择它：
- en: '![Figure 12.10: Post Processing](img/B18868_12_10.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图12.10：后处理](img/B18868_12_10.jpg)'
- en: 'Figure 12.10: Post Processing'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.10：后处理
- en: Once selected, click on the **Install** button and wait for it to complete.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择后，点击**安装**按钮并等待其完成。
- en: Switch to the `Post Process`. Then, move your mouse over the **Post-process
    Layer** selection and click to add the script to your project.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`后处理`。然后，将鼠标移至**后处理层**选择项上并点击，将脚本添加到您的项目中。
- en: The **Post-process Layer** component handles the blending of postprocessing
    volumes and what the postprocessing should be based on.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**后处理层**组件处理后处理体积的混合以及后处理应基于什么。'
- en: Under the **Post-process Layer** component, change **Layer** to **Everything**.
    This will make it so everything in our scene will be used in terms of blending
    between volumes.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**后处理层**组件下，将**层**更改为**所有层**。这将使得场景中的所有内容在体积混合方面都会被使用。
- en: We will next need to add the **Post-process Volume** component to our **Main
    Camera** game object. Do this by clicking on the **Add Component** button and
    then selecting the **Post-process** **Volume** option.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要将**后处理体积**组件添加到我们的**主摄像机**游戏对象中。通过点击**添加组件**按钮，然后选择**后处理** **体积**选项来完成此操作。
- en: '![Figure 12.11: Adding the volume](img/B18868_12_11.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.11：添加体积](img/B18868_12_11.jpg)'
- en: 'Figure 12.11: Adding the volume'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.11：添加体积
- en: Note that this component requires a profile. We can go ahead and add that next.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此组件需要一个配置文件。我们可以继续添加该配置文件。
- en: 'We can create a new postprocessing profile by right-clicking on the `Assets`
    folder, selecting `MobilePostProcessing`:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过在`Assets`文件夹上右键单击，选择`MobilePostProcessing`来创建一个新的后处理配置文件：
- en: '![Image 12.12: Adding a postprocessing profile](img/B18868_12_12.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图像 12.12：添加后处理配置文件](img/B18868_12_12.jpg)'
- en: 'Image 12.12: Adding a postprocessing profile'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图像 12.12：添加后处理配置文件
- en: Go back to the **Main Camera** object and attach this object to the **Profile**
    property of the **Post-process Volume** component. Afterward, go to the **Post-process
    Volume** component and then check the **Is Global** property box.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到**主摄像机**对象，并将此对象附加到**后处理体积**组件的**配置文件**属性。之后，转到**后处理体积**组件，并勾选**全局**属性框。
- en: This will make it so the volume we have created will always be visible on our
    player’s screen no matter where their camera is positioned in the world.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使得我们创建的体积无论玩家的摄像机在世界中的位置如何，都会始终显示在玩家的屏幕上。
- en: Because `Post-processing Profile` is a separate file, we can make changes to
    it while playing the game without worrying about losing our changes. With that
    in mind, start the game and pause it once gameplay has started.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于`后处理配置文件`是一个单独的文件，我们可以在玩游戏时对其进行更改，而不用担心丢失更改。考虑到这一点，开始游戏，一旦游戏开始，就暂停它。
- en: Now, there’s a large number of possible effects that can be added to modify
    how the game looks.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有大量可能的效果可以添加，以修改游戏的外观。
- en: Important note
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Note that for each element that we add to the profile you add, the frame rate
    of the devices we are trying to run our game on will be decreased. Keep testing
    your device with these options and note how it works.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于我们在配置文件中添加的每个元素，我们尝试运行游戏时设备的帧率将会降低。请使用这些选项测试您的设备，并注意其效果。
- en: 'Next, under the `0.45`:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`0.45`下：
- en: '![Figure 12.13: Adding Vignette](img/B18868_12_13.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.13：添加暗角](img/B18868_12_13.jpg)'
- en: 'Figure 12.13: Adding Vignette'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.13：添加暗角
- en: Note how there now seems to be a blackened edge or border around the game.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意现在似乎游戏周围出现了一个变黑的边缘或边框。
- en: Tip
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: If the UI menu disappears, switching from the **Scene** view back to the **Game**
    view seems to fix this issue.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果UI菜单消失，从**场景**视图切换回**游戏**视图似乎可以解决这个问题。
- en: 'Next, enable `0.35` to make it even darker by clicking on the top right of
    the section to expand it:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，启用`0.35`，通过点击该部分的右上角来使其变得更暗：
- en: '![Figure 12.14: Enabling Smoothness](img/B18868_12_14.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.14：启用平滑度](img/B18868_12_14.jpg)'
- en: 'Figure 12.14: Enabling Smoothness'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.14：启用平滑度
- en: Vignetting is the term used for the darkening and/or desaturating toward the
    edges of an image compared to the center. I like to use this when I want to have
    players focus on the center of the screen.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 暗角是指与中心相比，图像边缘变暗和/或去饱和的术语。当我想要让玩家专注于屏幕中心时，我喜欢使用这个效果。
- en: Click on the **Add effect...** button again and this time, select **Unity**
    | **Grain**.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次点击**添加效果...**按钮，这次选择**Unity** | **颗粒**。
- en: 'Check and set `0.15` and you’ll note that the screen has become fuzzier. While
    it’s not a great idea if it is set too large, note that decreasing `0.3` and unchecking
    **Colored** will help with the appearance of things:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 检查并设置`0.15`，你会注意到屏幕已经变得模糊。虽然如果设置得太大不是什么好主意，但请注意，减小`0.3`并取消选中**彩色**将有助于改善事物的外观：
- en: '![Figure 12.15: Grain](img/B18868_12_15.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.15：颗粒](img/B18868_12_15.jpg)'
- en: 'Figure 12.15: Grain'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.15：颗粒
- en: If you’ve been to a movie theater that still uses film, you may have noticed
    how there were little specks in the filmstock that were visible over the course
    of the film. The **Grain** effect in Unity simulates this film grain, causing
    the effect to become more pronounced the more the movie is played. This is often
    used in horror games to obscure the player’s vision.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经去过仍然使用胶片的电影院，你可能会注意到胶片上在电影过程中可见的小颗粒。Unity中的**颗粒**效果模拟了这种胶片颗粒，使效果在电影播放次数越多时越明显。这通常用于恐怖游戏，以模糊玩家的视线。
- en: 'Another property to add is `10`. From there, set `0.6` to help brighten things
    up:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个要添加的属性是`10`。从那里，将`0.6`设置为帮助使事物更亮：
- en: '![Figure 12.16: Bloom](img/B18868_12_16.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图12.16：Bloom效果](img/B18868_12_16.jpg)'
- en: 'Figure 12.16: Bloom'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.16：Bloom效果
- en: The **Bloom** effect attempts to mimic the imaging artifacts of real-world cameras,
    where things in areas with light will glow along the edges, thus overwhelming
    the camera.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**Bloom**效果试图模仿现实世界中相机的成像伪影，在光线较亮区域的物体沿着边缘发光，从而压倒相机。'
- en: 'Lastly, stop the game, then go back to the **Post-process Layer** component
    and, under **Anti-aliasing**, change **Mode** to **Fast Approximate Anti-aliasing
    (FXAA)** and then check **Fast** **Mode**:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，停止游戏，然后回到**后处理层**组件，在**抗锯齿**下，将**模式**更改为**快速近似抗锯齿（FXAA）**，然后检查**快速****模式**：
- en: '![Figure 12.17: Anti-aliasing](img/B18868_12_17.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图12.17：抗锯齿](img/B18868_12_17.jpg)'
- en: 'Figure 12.17: Anti-aliasing'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.17：抗锯齿
- en: Aliasing is an effect where lines appear jagged on the screen. This happens
    if the screen on the device we are trying to play our game on doesn’t have a high
    enough resolution to display properly.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 锯齿效应是屏幕上线条看起来参差不齐的效果。如果我们尝试在设备上玩游戏，而该设备的屏幕分辨率不足以正确显示，就会发生这种情况。
- en: Anti-aliasing attempts to reduce that effect by combining colors near these
    lines to remove its prominence, at the cost of it appearing blurrier.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 抗锯齿尝试通过将这些线条附近的颜色组合起来以减少其突出度，但这会使图像看起来更模糊。
- en: Important note
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: For more information on postprocessing in Unity, check out [https://docs.unity3d.com/Packages/com.unity.postprocessing@3.2/manual/index.html](https://docs.unity3d.com/Packages/com.unity.postprocessing@3.2/manual/index.html).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Unity中后处理的更多信息，请参阅[https://docs.unity3d.com/Packages/com.unity.postprocessing@3.2/manual/index.html](https://docs.unity3d.com/Packages/com.unity.postprocessing@3.2/manual/index.html)。
- en: There are a number of other properties to look into and adapt to get your project
    looking just the way you want. Explore them and find what works well for the vision
    you are looking to achieve!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多其他属性需要考虑和适应，以使你的项目看起来正是你想要的。探索它们，找到适合你想要实现愿景的方法！
- en: The game itself currently works, but it could use some more polish. One of the
    things we can do to increase the polish of the game is to make use of particle
    systems, which is what we can look at next.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏本身目前可以运行，但可以做一些润色。我们可以增加游戏润色的一种方法就是使用粒子系统，这是我们接下来要看的。
- en: Adding particle effects
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加粒子效果
- en: 'Typically used for effects that are natural or organic, such as fire, smoke,
    and sparks, particle systems create objects that are designed to be as low cost
    as possible, called particles. Due to this, we can spawn many of the particles
    at once with a minimal performance cost. One of the easiest types of particle
    systems to create is a trail to follow our player, so let’s add one of those now
    using the following steps:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通常用于自然或有机效果，如火焰、烟雾和火花，粒子系统创建的对象设计为尽可能低廉的成本，称为粒子。因此，我们可以一次生成许多粒子，而性能成本最小。最容易创建的粒子系统类型之一是追踪玩家的轨迹，所以现在让我们按照以下步骤添加一个：
- en: Select **Player** in the **Hierarchy** window, and then right-click and select
    **Effects** | **Particle System**.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中选择**Player**，然后右键单击并选择**效果**|**粒子系统**。
- en: This will make this system a child of the player, which will be good for what
    we are going to do.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这样会使这个系统成为玩家的子系统，这对我们即将要做的事情是有好处的。
- en: In the `0` and **Simulation Space** to **World**. Then, change **Start Color**
    to a color that stands out, such as purple.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`0`和**模拟空间**到**世界**。然后，将**起始颜色**更改为一个突出的颜色，例如紫色。
- en: Open up the `0` (it will automatically change to `0.0001`).
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`0`（它将自动更改为`0.0001`）。
- en: 'This is a step in the right direction. The purple particles are now following
    the player, as shown in the screenshot:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个正确的步骤。紫色粒子现在正跟随玩家，如截图所示：
- en: '![Figure 12.18: Particle trail](img/B18868_12_18.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图12.18：粒子轨迹](img/B18868_12_18.jpg)'
- en: 'Figure 12.18: Particle trail'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.18：粒子轨迹
- en: However, there are still a number of things we can do to improve this. Instead
    of just a single color, we can change it so that it randomly alternates between
    two colors.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们仍然可以做很多事情来改进这一点。我们不仅可以改变颜色，还可以让它随机在两种颜色之间交替。
- en: To do that, go to the right side of **Start Color**, and you’ll see a little
    downward-facing arrow. Click on that and then select **Random Between Two Colors**.
    Then, change the color to one of two purple colors for some randomness.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要这样做，请转到**开始颜色**的右侧，你会看到一个向下的小箭头。点击它，然后选择**在两种颜色之间随机选择**。然后，将颜色更改为两种紫色颜色之一，以增加一些随机性。
- en: Then, next to `0.5` and `1.2`.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`0.5`和`1.2`旁边。
- en: With that, set the `0` to `0.2`.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这个设置，将`0`设置为`0.2`。
- en: 'Then, open up the `100`:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，打开`100`：
- en: '![Figure 12.19: Particle settings](img/B18868_12_19.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图12.19：粒子设置](img/B18868_12_19.jpg)'
- en: 'Figure 12.19: Particle settings'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.19：粒子设置
- en: 'Save the game and play:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存游戏并播放：
- en: '![Figure 12.20: Final particle trail](img/B18868_12_20.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图12.20：最终粒子轨迹](img/B18868_12_20.jpg)'
- en: 'Figure 12.20: Final particle trail'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.20：最终粒子轨迹
- en: Tip
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you’re interested in exploring more details on things that can be done to
    polish projects, you can check out another of my Unity books, *Unity 5.x Game
    Development Blueprints*, also available from Packt, which also dives into game
    polish.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要探索更多关于如何润色项目的细节，你可以查看我的另一本Unity书籍，*Unity 5.x游戏开发蓝图*，也由Packt出版，它也深入探讨了游戏润色。
- en: As you can see, the particle system looks great on both our PC and mobile devices.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，粒子系统在我们的PC和移动设备上看起来都很棒。
- en: Of course, there are many other areas that can be improved through the use of
    particle systems. Perhaps whenever the player hits a wall, we can display some
    sparks; when we swipe, we could play another effect; when the player pauses the
    game, we could have something falling on the screen. The possibilities are endless!
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有许多其他领域可以通过使用粒子系统来改进。也许每次玩家碰到墙壁时，我们可以显示一些火花；当我们滑动时，我们可以播放另一个效果；当玩家暂停游戏时，我们可以在屏幕上显示一些东西落下。可能性是无限的！
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have now improved our game by a huge amount by only doing a few simple things.
    We first animated our menus with a few lines of code using tweens from LeanTween
    and saw how a few lines of code can improve the visual quality of our UI in a
    number of ways. We next saw how to create materials to improve the visual quality
    of our ball and then used some postprocessing effects to polish the contents of
    our screen. Finally, we discussed how to use particle effects to create a nice
    trail following our player.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在通过仅做几件简单的事情就大幅提高了我们的游戏。我们首先使用LeanTween的tweens通过几行代码动画化我们的菜单，并看到几行代码如何以多种方式提高我们UI的视觉质量。接下来，我们看到了如何创建材质来提高我们的球体视觉质量，然后使用一些后处理效果来润色屏幕内容。最后，我们讨论了如何使用粒子效果为玩家创建一条漂亮的轨迹。
- en: With these concepts, you now have the skills to dramatically improve the feel
    of your game projects so that players actually enjoy interacting with your game.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些概念，你现在拥有了大幅提高你的游戏项目感觉的技能，让玩家真正享受与你的游戏互动。
- en: By this point, our game is finally ready for the big leagues. In the next chapter,
    we will explore how to build our games in order to get our game onto the Apple
    App Store and Google Play.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的游戏终于准备好进入主流市场。在下一章中，我们将探讨如何构建我们的游戏，以便将我们的游戏发布到苹果App Store和谷歌Play。
