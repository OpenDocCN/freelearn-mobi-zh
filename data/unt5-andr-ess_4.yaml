- en: Chapter 4. Animation, Audio, Physics, and Particle Systems in Unity 5
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章：Unity 5 中的动画、音频、物理和粒子系统
- en: In this chapter, you will learn new Mecanim animation features and awesome new
    audio features in Unity 5\. At the end of this chapter, you will explore physics
    and particle systems in Unity 5.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习 Unity 5 中的新 Mecanim 动画功能和令人惊叹的新音频功能。在本章结束时，您将探索 Unity 5 中的物理和粒子系统。
- en: 'The topics that will be covered in the chapter are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: New Mecanim animation features in Unity 5
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity 5 中的新 Mecanim 动画功能
- en: New audio features in Unity 5
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity 5 中的新音频功能
- en: Physics and particle system effects in Unity 5
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity 5 中的物理和粒子系统效果
- en: New Mecanim animation features in Unity 5
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unity 5 中的新 Mecanim 动画功能
- en: Unity 5 contains some new awesome possibilities for the Mecanim animation system.
    Let's look at the new shiny features known in Unity 5.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 5 为 Mecanim 动画系统提供了一些新的令人惊叹的可能性。让我们看看在 Unity 5 中已知的新功能。
- en: State machine behavior
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态机行为
- en: 'Now, you can inherit your classes from `StateMachineBehaviour` in order to
    be able to attach them to your Mecanim animation states. This class has the following
    very important callbacks:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以从 `StateMachineBehaviour` 继承您的类，以便能够将它们附加到您的 Mecanim 动画状态。此类具有以下非常重要的回调：
- en: '`OnStateEnter`'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnStateEnter`'
- en: '`OnStateUpdate`'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnStateUpdate`'
- en: '`OnStateExit`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnStateExit`'
- en: '`OnStateMove`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnStateMove`'
- en: '`OnStateIK`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnStateIK`'
- en: The `StateMachineBehaviour` scripts behave like `MonoBehaviour` scripts, which
    you can attach on as many objects as you wish; the same is true for `StateMachineBehaviour`.
    You can use this solution with or without any animation at all.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`StateMachineBehaviour` 脚本的行为类似于 `MonoBehaviour` 脚本，您可以将它们附加到您希望的对象上；对于 `StateMachineBehaviour`
    也是如此。您可以使用此解决方案，无论是否有任何动画。'
- en: State machine transition
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态机转换
- en: Unity 5 introduced a new awesome feature for Mecanim animation systems known
    as state machine transitions in order to construct a higher abstraction level.
    In addition, entry and exit nodes were created. By these two additional nodes
    to `StateMachine`, you can now branch your start or finish state depending on
    your special conditions and requirements.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 5 为 Mecanim 动画系统引入了一个新的令人惊叹的功能，称为状态机转换，以便构建更高的抽象级别。此外，创建了入口和退出节点。通过这两个额外的节点到
    `StateMachine`，您现在可以根据您特殊条件和需求分支您的起始或结束状态。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'These mixes of transitions are possible: `StateMachine` | `StateMachine`, `State`
    | `StateMachine`, `State` | `State`.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的过渡混合如下：`StateMachine` | `StateMachine`，`State` | `StateMachine`，`State` |
    `State`。
- en: In addition, you also can reorder your layers or parameters. This is the new
    UI that allows it by a very simple and useful drag-n-drop method.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可以重新排列您的层或参数。这是通过一个非常简单且实用的拖放方法实现的新的用户界面。
- en: Asset creation API
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资产创建 API
- en: One more awesome possibility in Unity 5 was introduced using scripts in Unity
    Editor in order to programmatically create assets, such as layers, controllers,
    states, `StateMachine`, and blend trees. You can use different solutions with
    a high-level API provided by Unity engine maintenance and a low-level API, where
    you should manage all your assets manually. You can find more about both API versions
    on Unity documentation pages.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 5 中，通过在 Unity 编辑器中使用脚本引入了另一个令人惊叹的可能性，以便以编程方式创建资产，例如层、控制器、状态、`StateMachine`
    和混合树。您可以使用由 Unity 引擎维护的高级 API 和低级 API，在低级 API 中，您应该手动管理所有资产。您可以在 Unity 文档页面上找到有关这两个
    API 版本的信息。
- en: Direct blend tree
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 直接混合树
- en: Another new feature that was introduced with the new `BlendTree` type is known
    as direct. It provides direct mapping and animator parameters to the weight of
    `BlendTree` children.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 新引入的 `BlendTree` 类型的新功能被称为直接映射。它为 `BlendTree` 子项的权重提供直接映射和动画器参数。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Possibilities with Unity 5 have been enhanced with two useful features for
    Mecanim animation system:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 5 的可能性通过两个用于 Mecanim 动画系统的有用功能得到了增强：
- en: Camera can scale, orbit, and pan
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 摄像机可以缩放、环绕和平移
- en: You can access your parameters in runtime
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在运行时访问您的参数
- en: Programmatically creating assets by Unity 5 API
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过 Unity 5 API 以编程方式创建资产
- en: The following code snippets are self-explanatory, pretty simple, and straightforward.
    I list them just as a very useful reminder.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段是自我解释的，相当简单，直接明了。我列出它们只是为了作为一个非常有用的提醒。
- en: Creating the controller
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建控制器
- en: 'To create a controller you can use the following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建控制器，您可以使用以下代码：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Adding parameters
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加参数
- en: 'To add parameters to the controller, you can use this code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要向控制器添加参数，您可以使用以下代码：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Adding state machines
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加状态机
- en: 'To add state machines, you can use the following code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加状态机，您可以使用以下代码：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Adding states
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加状态
- en: 'To add states, you can use the code given here:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加状态，您可以使用这里提供的代码：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Adding transitions
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加过渡
- en: 'To add transitions, you can use the following code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加过渡，您可以使用以下代码：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Going deeper into new audio features
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深入了解新的音频功能
- en: Let's start with new amazing Audio Mixer possibilities.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从新的惊人的音频混音可能性开始。
- en: Now, you can do true submixing of audio in Unity 5.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以在Unity 5中实现真正的音频子混音。
- en: 'In the following figure, you can see a very simple example with different sound
    categories required in a game:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图中，您可以看到一个游戏所需的不同声音类别的简单示例：
- en: '![Going deeper into new audio features](img/9191OT_04_01.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![深入新的音频功能](img/9191OT_04_01.jpg)'
- en: Now in Unity 5, you can mix different sound collections within categories and
    tune up volume control and effects only once in a single place so that you can
    save a lot of time and effort. This new awesome audio feature in Unity 5 allows
    you to create a fantastic mood and atmosphere for your game.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在Unity 5中，您可以在分类内混合不同的声音集合，并在一个地方调整音量控制和效果，这样可以节省大量时间和精力。Unity 5中这个新的出色音频功能允许您为游戏创建出令人惊叹的情绪和氛围。
- en: 'Each Audio Mixer can have a hierarchy of AudioGroups:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 每个音频混音器都可以拥有一个音频组（AudioGroups）的层级结构：
- en: '![Going deeper into new audio features](img/9191OT_04_02.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![深入新的音频功能](img/9191OT_04_02.jpg)'
- en: The Audio Mixer can not only do a lot of useful things, but also mix different
    sound groups in one place. Different audio effects are applied sequentially in
    each AudioGroup.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 音频混音器不仅可以做很多有用的事情，还可以在一个地方混合不同的声音组。不同的音频效果按顺序应用于每个音频组。
- en: Now you're getting closer to the amazing, awesome, and shiny new features in
    Unity 5 for audio system! A callback script `OnAudioFilterRead`, which made possible
    the processing of samples directly into their scripts, previously was handled
    exclusively by the code.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您正在接近Unity 5音频系统中的惊人、出色和闪亮的新功能！一个回调脚本`OnAudioFilterRead`，它使得直接在脚本中处理样本成为可能，之前完全由代码处理。
- en: Unity now also supports custom plugins to create different effects. With these
    innovations, Unity 5 for audio system now has its own applications synthesizer,
    which has become much easier and more flexible than possible.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Unity现在还支持自定义插件来创建不同的效果。有了这些创新，Unity 5的音频系统现在拥有自己的合成器应用，这使得它比以前更容易、更灵活。
- en: Mood transitions
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 情绪转换
- en: As mentioned earlier, the mood of the game can be controlled with a mix of sound.
    This can be achieved with the involvement of new stems and music or ambient sounds.
    Another common way to accomplish this is to move the state of the mixture. A very
    effective way of taking mood where you want to go is by changing the volume section's
    mixture and transferring it to the different states of effect parameters.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，游戏的情绪可以通过声音的混合来控制。这可以通过引入新的声源和音乐或环境声音来实现。另一种常见的方法是通过移动混合状态来实现。通过改变音量部分的混合并将其转移到不同的效果参数状态，这是一种非常有效的方法，可以将情绪引导到您想要的方向。
- en: Inside, everything is the Audio Mixer's ability to identify pictures. Pictures
    capture the status of all parameters in Audio Mixer. Everything from investigative
    wet levels to AudioGroup tone levels can be captured and moved between the various
    parameters.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，一切都是音频混音器识别图片的能力。图片捕捉了音频混音器中所有参数的状态。从调查湿度级别到音频组音调级别的一切都可以被捕捉并在各种参数之间移动。
- en: '![Mood transitions](img/9191OT_04_03.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![情绪转换](img/9191OT_04_03.jpg)'
- en: You can even create a complex mixture of states between a whole bunch of pictures
    in your game, creating all kinds of possibilities and goals.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以在游戏中的大量图片之间创建复杂的混合状态，创造出各种可能性和目标。
- en: Imagine installing all these things without having to write a line of code to
    the script.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，在不向脚本中写入一行代码的情况下安装所有这些功能。
- en: Physics and particle system effects in Unity 5
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unity 5中的物理和粒子系统效果
- en: Physics for 2D and 3D in Unity are very similar, because they use the same concepts
    like Ias rigidbodies, joints, and colliders. However, Box2D has more features
    than Unity's 2D physics engine. It is not a problem to mix 2D and 3D physics engines
    (built-in, custom, third-party) in Unity. So, Unity provides an easy development
    way for your innovative games and applications.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Unity中的2D和3D物理在概念上非常相似，因为它们使用相同的概念，如刚体、关节和碰撞体。然而，Box2D比Unity的2D物理引擎具有更多功能。在Unity中混合2D和3D物理引擎（内置、自定义、第三方）并不成问题。因此，Unity为您的创新游戏和应用提供了简单易用的开发方式。
- en: If you need to develop some real-life physics in your project, then you should
    not write your own library, framework, or engine, except specific requirements.
    However, you should try existing physics engines, libraries, or frameworks with
    many features already made.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要在项目中开发一些真实的物理效果，那么您不应该编写自己的库、框架或引擎，除非有特定要求。然而，您应该尝试使用具有许多已制作功能的现有物理引擎、库或框架。
- en: Let's start our introduction into Unity's built-in physics engine. In the case
    that you need to set your object under Unity's built-in physics management, you
    just need to attach the Rigidbody component to this object. After that, your object
    can collide with other entities in its world and gravity will have an affect on
    it. In other words, Rigidbody will be simulated physically. In your scripts, you
    can move any of your Rigidbodies by adding vector forces to them.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始介绍Unity内置的物理引擎。如果您需要将对象置于Unity内置的物理管理之下，只需将Rigidbody组件附加到该对象即可。之后，您的对象可以与其世界中的其他实体发生碰撞，重力也会对其产生影响。换句话说，Rigidbody将进行物理模拟。在您的脚本中，您可以通过向它们添加矢量力来移动任何Rigidbody。
- en: It is not recommended to move the Transform component of a non-kinematic Rigidbody,
    because it will not collide correctly with other items. Instead, you can apply
    forces and torque to your Rigidbody.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 不建议移动非运动学Rigidbody的Transform组件，因为它将无法正确与其他物品发生碰撞。相反，您可以向您的Rigidbody施加力和扭矩。
- en: A Rigidbody can be used also to develop cars with wheel colliders and with some
    of your scripts to apply forces to it. Furthermore, a Rigidbody is used not *only*
    for vehicles, but also you can use it for any other physics issues such as airplanes,
    robots with various scripts for applying forces, and with joints.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Rigidbody也可以用来开发带有轮子碰撞体的汽车，以及使用您的脚本对其施加力。此外，Rigidbody不仅用于车辆，您还可以用它来解决任何其他物理问题，如飞机、带有各种施加力脚本的机器人以及关节。
- en: 'The most useful way to utilize a Rigidbody is to use it in collaboration with
    some primitive colliders (built-in in Unity) such as `BoxCollider` and `SphereCollider`.
    Next, we will show you two things to remember about Rigidbody:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 利用Rigidbody最有用的方式是将其与一些原始碰撞体（Unity内置）如`BoxCollider`和`SphereCollider`一起使用。接下来，我们将向您介绍关于Rigidbody的两个需要注意的事项：
- en: In your object's hierarchy, you must never have a child and its parent with
    the Rigidbody component together at the same time
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的对象层次结构中，您绝不应该同时将带有Rigidbody组件的子对象和父对象放在同一时间
- en: It is not recommended to scale Rigidbody's parent object
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不建议缩放Rigidbody的父对象
- en: One of the most important and fundamental components of physics in Unity is
    a Rigidbody component. This component activates physics calculations on the attached
    object. If you need your object to react to collisions( for example, while playing
    billiards, balls collide with each other and scatter in different directions)
    then you must also attach a `Collider` component on your GameObject. If you have
    attached a Rigidbody component to your object, then your object will move through
    the physics engine, and I recommend that you do not move your object by changing
    its position or rotation in the `Transform` component. If you need some way to
    move your object, you should apply the various forces acting on the object so
    that the Unity physics engine assumes all obligations for the calculation of collisions
    and moving dynamic objects. Also, in some situations, there is a need for a Rigidbody
    component, but your object must be moved only by changing its position or rotation
    properties in the `Transform` component. It is sometimes necessary to use components
    without Rigidbody calculating collisions of the object and its motion physics.
    That is, your object will move by your script or, for example, by running your
    animation. In order to solve this problem, you should just activate its `IsKinematic`
    property. Sometimes, it is required to use a combination of these two modes when
    `IsKinematic` is turned on and when it is turned off. You can create a symbiosis
    of these two modes, changing the `IsKinematic` parameter directly in your code
    or in your animation.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，物理学的最重要的基本组成部分之一是Rigidbody组件。这个组件会在附加的对象上激活物理计算。如果你的对象需要响应碰撞（例如，在玩台球时，球会相互碰撞并向不同方向散射），那么你必须在你的GameObject上附加一个`Collider`组件。如果你已经为你的对象附加了Rigidbody组件，那么你的对象将通过物理引擎移动，我建议你不要通过更改其在`Transform`组件中的位置或旋转来移动你的对象。如果你需要某种方式来移动你的对象，你应该应用作用在对象上的各种力，这样Unity物理引擎就会承担计算碰撞和移动动态对象的全部责任。此外，在某些情况下，可能需要Rigidbody组件，但你的对象只能通过在`Transform`组件中更改其位置或旋转属性来移动。有时，有必要使用没有Rigidbody计算对象及其运动物理的组件。也就是说，你的对象将通过你的脚本或，例如，通过运行你的动画来移动。为了解决这个问题，你应该只激活其`IsKinematic`属性。有时，当`IsKinematic`开启和关闭时，需要使用这两种模式的组合。你可以在你的代码或动画中直接更改`IsKinematic`参数，以创造这两种模式的共生体。
- en: Tip
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Changing the `IsKinematic` property very often from your code or from your animation
    can be the cause of overhead in your performance. Therefore, you should use it
    very carefully and only when you really need it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 频繁地在你的代码或动画中更改`IsKinematic`属性可能会导致你的性能开销。因此，你应该非常小心地使用它，并且只有在真正需要的时候才使用。
- en: A kinematic Rigidbody object is defined by the `IsKinematic` toggle option.
    If a Rigidbody is `Kinematic`, this object will not be affected by collisions,
    gravity, or forces.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 动力学Rigidbody对象由`IsKinematic`切换选项定义。如果一个Rigidbody是`Kinematic`，则该对象将不会受到碰撞、重力或力的
    影响。
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is a Rigidbody component for 3D physics engine and an analogous Rigidbody2D
    for 2D physics engine.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 3D物理引擎有一个Rigidbody组件，2D物理引擎有一个类似的Rigidbody2D组件。
- en: A kinematic Rigidbody can interact with other non-kinematic Rigidbodies. In
    the event of using kinematic Rigidbodies, you should translate their positions
    and rotation values of the `Transform` component by your scripts or animations.
    When there is a collision between Kinematic and non-kinematic Rigidbodies, then
    the Kinematic object will properly wake up non-kinematic Rigidbody. Furthermore,
    the first Rigidbody will apply friction to the second Rigidbody if the second
    object is on top of the first object.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 动力学Rigidbody可以与其他非动力学Rigidbody交互。在使用动力学Rigidbody的情况下，你应该通过你的脚本或动画来转换其`Transform`组件的位置和旋转值。当动力学和非动力学Rigidbody之间发生碰撞时，动力学对象将正确唤醒非动力学Rigidbody。此外，如果第二个对象位于第一个对象之上，第一个Rigidbody将对其施加摩擦力。
- en: 'Let''s list some possible usage examples of kinematic Rigidbodies:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们列出一些动力学Rigidbody的可能使用示例：
- en: There are situations when you need your objects to be under physics management,
    but sometimes to be controlled explicitly from your scripts or animations. As
    an example, you can attach Rigidbodies to the bones of your animated personage
    and connect them with joints in order to utilize your entity as a ragdoll. If
    you are controlling your character by Unity's animation system, you should enable
    the `IsKinematic` checkbox. Sometimes you may require your hero to be affected
    by Unity's built-in physics engine if you are hitting the hero. In this case you
    should disable the `IsKinematic` checkbox.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时候你需要你的对象受到物理管理，但有时需要从你的脚本或动画中明确控制。例如，你可以将`Rigidbody`附加到你的动画人物的骨骼上，并通过关节将它们连接起来，以便将你的实体用作布娃娃。如果你通过Unity的动画系统控制你的角色，你应该勾选`IsKinematic`复选框。有时，如果你在打击英雄，你可能需要你的英雄受到Unity内置物理引擎的影响。在这种情况下，你应该取消勾选`IsKinematic`复选框。
- en: If you need a moving item that can push different items, yet not by itself.
    In case you have a moving platform and you need to place some Rigidbody objects
    on top, you ought to enable the `IsKinematic` checkbox rather than simply attaching
    a collider without a Rigidbody.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你需要一个可以推动不同物品但自身不动的移动物品。如果你有一个移动平台并且需要在上面放置一些`Rigidbody`对象，你应该勾选`IsKinematic`复选框，而不是简单地附加一个没有`Rigidbody`的碰撞器。
- en: You may need to enable the `IsKinematic` property of your Rigidbody object that
    is animated and has a genuine Rigidbody follower by utilizing one of the accessible
    joints.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能需要通过使用可用的一个关节来启用你的动画`Rigidbody`对象的`IsKinematic`属性，该对象具有真实的`Rigidbody`跟随者。
- en: 'Earlier, I mentioned the collider, but now is the time to discuss this component
    in more detail. In the case of Unity, the physics engine can calculate collisions.
    You must specify geometric shapes for your object by attaching the `Collider`
    component. In most cases, the collider does not have to be the same shape as your
    mesh with many polygons. Therefore, it is desirable to use simple colliders, which
    will significantly improve your performance, otherwise with more complex geometric
    shapes you risk significantly increasing the computing time for physics collisions.
    Simple colliders in Unity are known as primitive colliders: `BoxCollider`, `BoxCollider2D`,
    `SphereCollider`, `CircleCollider2D`, and `CapsuleCollider`. Also, no one forbids
    you to combine different primitive colliders to create a more realistic geometric
    shape that the physics engine can handle very fast compared to `MeshCollider`.
    Therefore, to accelerate your performance, you should use primitive colliders
    wherever possible. You can also hang on to the child objects of different primitive
    colliders, which will change its position and rotation, depending on the parent
    `Transform` component. The Rigidbody component must be attached only to the GameObject
    root in the hierarchy of your entity.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我提到了碰撞器，但现在正是详细讨论这个组件的时候。在Unity中，物理引擎可以计算碰撞。你必须通过附加`Collider`组件来指定你的对象的几何形状。在大多数情况下，碰撞器不需要与你的多边形网格形状相同。因此，使用简单的碰撞器是理想的，这会显著提高你的性能；否则，使用更复杂的几何形状，你可能会显著增加物理碰撞的计算时间。Unity中的简单碰撞器被称为原始碰撞器：`BoxCollider`、`BoxCollider2D`、`SphereCollider`、`CircleCollider2D`和`CapsuleCollider`。此外，没有人禁止你组合不同的原始碰撞器来创建一个更真实的几何形状，与`MeshCollider`相比，物理引擎可以非常快速地处理这种形状。因此，为了加速你的性能，你应该尽可能使用原始碰撞器。你还可以挂载不同原始碰撞器的子对象，这将根据父`Transform`组件改变其位置和旋转。`Rigidbody`组件必须仅附加到你的实体层次结构中的GameObject根上。
- en: Unity provides a `MeshCollider` component for 3D physics and a `PolygonCollider2D`
    component for 2D physics. The `MeshCollider` component will use your object's
    mesh for its geometric shape. In `PolygonCollider2D`, you can edit directly in
    Unity and create any 2D geometry for your 2D physical computations. In order to
    react in collisions between different mesh colliders, you must enable a `Convex`
    property. You will certainly sacrifice performance for more accurate physics calculations,
    but if you have the right balance between quality and performance, then you can
    achieve good performance only through a proper approach.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Unity为3D物理提供了一个`MeshCollider`组件，为2D物理提供了一个`PolygonCollider2D`组件。`MeshCollider`组件将使用你的对象的网格作为其几何形状。在`PolygonCollider2D`中，你可以在Unity中直接编辑并创建任何2D几何形状用于你的2D物理计算。为了在不同的网格碰撞器之间响应碰撞，你必须启用`Convex`属性。你肯定会为了更精确的物理计算而牺牲性能，但如果你在质量和性能之间找到了合适的平衡，那么你只能通过正确的方法来实现良好的性能。
- en: Objects are static when they have a `Collider` component without a Rigidbody
    component. Therefore, you should not move or rotate them by changing properties
    in their `Transform` component, because it will leave a heavy imprint on your
    performance as a physics engine should recalculate many polygons of various objects
    for right collisions and ray casts. Dynamic objects are those that have a Rigidbody
    component. Static objects (attached with the `Collider` component and without
    Rigidbody components) can interact with dynamic objects (attached with `Collider`
    and Rigidbody components). Furthermore, static objects will not be moved by collisions
    like dynamic objects.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象具有`Collider`组件但没有Rigidbody组件时，它们是静态的。因此，您不应该通过更改其`Transform`组件中的属性来移动或旋转它们，因为这会在物理引擎上留下沉重的印记，因为物理引擎应该重新计算各种对象的多个多边形，以进行正确的碰撞和光线投射。动态对象是具有Rigidbody组件的对象。静态对象（带有`Collider`组件且没有Rigidbody组件）可以与动态对象（带有`Collider`和Rigidbody组件）交互。此外，静态对象不会像动态对象那样因碰撞而移动。
- en: 'Also, Rigidbodies can sleep in order to increase performance. Unity provides
    the ability to control sleep in a Rigidbodies component directly in the code using
    following functions:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Rigidbodies可以进入休眠状态以提高性能。Unity提供直接在代码中使用以下函数来控制Rigidbody组件中休眠的能力：
- en: '`Rigidbody.IsSleeping()`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rigidbody.IsSleeping()`'
- en: '`Rigidbody.Sleep()`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rigidbody.Sleep()`'
- en: '`Rigidbody.WakeUp()`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rigidbody.WakeUp()`'
- en: 'There are two variables characterized in the physics manager. You can open
    physics manager right from Unity menu here: **Edit** | **Project Settings** |
    **Physics**:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在物理管理器中定义了两个变量。您可以直接从Unity菜单中打开物理管理器：**编辑** | **项目设置** | **物理**：
- en: '`Rigidbody.sleepVelocity`: The default value is `0.14`. This indicates lower
    limitations for linear velocity (from zero to infinity) below which objects will
    sleep.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rigidbody.sleepVelocity`：默认值是`0.14`。这表示线性速度的下限（从零到无穷大）低于此值时，对象将进入休眠状态。'
- en: '`Rigidbody.sleepAngularVelocity`: The default value is `0.14`. This indicates
    lower limitations for angular velocity (from zero to infinity) below which objects
    will sleep.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rigidbody.sleepAngularVelocity`：默认值是`0.14`。这表示角速度的下限（从零到无穷大）低于此值时，对象将进入休眠状态。'
- en: 'Rigidbodies awaken when:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Rigidbodies在以下情况下会唤醒：
- en: An alternate Rigidbody impacts the resting Rigidbody
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个Rigidbody对静止的Rigidbody产生冲击
- en: An alternate Rigidbody was joined through a joint
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个Rigidbody通过关节连接
- en: At the point of adjusting a property of the Rigidbody
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调整Rigidbody属性时
- en: At the point of adding force vectors
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在添加力向量时
- en: Note
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A kinematic Rigidbody can wake the other sleeping Rigidbodies while static objects
    (attached with a `Collider` component and without a Rigidbody component) can't
    wake your sleeping Rigidbodies.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 动力学Rigidbody可以唤醒其他休眠的Rigidbodies，而静态对象（带有`Collider`组件且没有Rigidbody组件）不能唤醒您的休眠Rigidbodies。
- en: The PhysX physics engine which is integrated into Unity works well on mobile
    devices, but mobile devices certainly have far fewer resources than powerful desktops.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 集成到Unity中的PhysX物理引擎在移动设备上运行良好，但移动设备当然比强大的桌面电脑资源要少得多。
- en: 'Let''s look at a few points to optimize the physics engine in Unity:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些优化Unity中物理引擎的要点：
- en: First of all, note that you can adjust the `Fixed Timestep` parameter in the
    time manager in order to reduce costs for the physical execution time updates.
    If you increase the value, you can increase the quality and accuracy of physics
    in your game or in your application, but you will lose the time to process. This
    can greatly reduce your productivity, or in other words, it can increase CPU overhead.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，请注意，您可以通过在时间管理器中调整`Fixed Timestep`参数来减少物理执行时间更新的成本。如果您增加该值，可以提高您游戏或应用程序中物理的质量和精度，但您将失去处理时间。这可能会大大降低您的生产力，换句话说，它可能会增加CPU开销。
- en: The maximum allowed timestep indicates how much time will be spent in the worst
    case for physical treatment.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许的最大时间步长表示在最坏情况下物理处理将花费多少时间。
- en: The total processing time for physics depends on the awake rigidbodies and colliders
    in the scene, as well as the level of complexity of the colliders.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理的总处理时间取决于场景中唤醒的刚体和碰撞器，以及碰撞器的复杂程度。
- en: Unity provides the ability to use physical materials for setting various properties
    such as friction and elasticity. For example, a piece of ice in your game may
    have very low friction or equal to zero (minimum value), while a jumping ball
    may have a very high friction force or equal to one (maximum value) and also very
    high elasticity. You should play with the settings of your physical materials
    for different objects and choose the most suitable solution for you and the best
    solution for your performance.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 提供了使用物理材料设置各种属性的能力，例如摩擦力和弹性。例如，你游戏中的冰块可能具有非常低的摩擦力或等于零（最小值），而跳跃的球可能具有非常高的摩擦力或等于一（最大值），并且也具有非常高的弹性。你应该对不同对象的物理材料设置进行实验，并选择最适合你以及最佳性能的解决方案。
- en: Triggers do not require a lot of processing costs by the physics engine and
    can greatly help in improving your performance. Triggers are useful in situations
    where, for example, in your game you need to identify areas near all lights that
    are automatically turned on in the evening or night if the player is in its trigger
    zone or in other words within the geometric shape of its collider, which you can
    design as you wish. Unity triggers allow writing the three callbacks, which will
    be called when your object enters the trigger, while your object is staying in
    trigger, and when this object leaves the trigger. Thus, you can register any of
    these functions, the necessary instructions, for example, turn on the flashlight
    when entering the trigger zone or turn it off when exiting the trigger zone. It
    is important to know that in Unity, static objects (objects without a Rigidbody
    component) will not cause your callbacks to get into the zone trigger if your
    trigger does not contain a Rigidbody component; that is, in other words at least
    one of these objects must have a Rigidbody component in order to not ignore your
    callbacks. In the case of two triggers, there should be at least one object attached
    with a Rigidbody component to your callbacks were not ignored. Remember that when
    two objects are attached with Rigidbody and `Collider` components and if at least
    one of them is the trigger, then the trigger callbacks will be called and not
    the collision callbacks. I would also like to point out that your callbacks will
    be called for each object included in the collision or trigger zone. Also, you
    can directly control whether your collider is a trigger or not by setting the
    flag `isTrigger` value to `true` or `false` in your code. Of course, you can mix
    both options in order to obtain the best performance. All collision callbacks
    will be called only if at least one of two interacted rigidbodies is not kinematic.
    I suggest you consider code samples for collision callbacks.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 触发器不需要物理引擎进行大量的处理成本，并且可以极大地帮助提高你的性能。触发器在以下情况下非常有用，例如，在你的游戏中，你需要识别所有自动在傍晚或夜间打开的灯光附近的区域，如果玩家位于其触发区域或换句话说，位于其碰撞几何形状内。你可以按自己的意愿设计这些区域。Unity
    触发器允许编写三个回调函数，这些函数将在你的对象进入触发器时被调用，当你的对象停留在触发器内时被调用，以及当这个对象离开触发器时被调用。因此，你可以注册这些函数中的任何一个，例如必要的指令，例如进入触发器区域时打开手电筒或退出触发器区域时关闭它。重要的是要知道，在
    Unity 中，静态对象（没有 Rigidbody 组件的对象）不会使你的回调函数进入区域触发器，如果你的触发器不包含 Rigidbody 组件；换句话说，至少这些对象中必须有一个具有
    Rigidbody 组件，以便不忽略你的回调。在两个触发器的情况下，至少应该有一个带有 Rigidbody 组件的对象附加到你的回调函数上，这样就不会被忽略。记住，当两个对象都附加了
    Rigidbody 和 `Collider` 组件，并且至少有一个是触发器时，则将调用触发器回调而不是碰撞回调。我还想指出，你的回调函数将为碰撞或触发区域中包含的每个对象调用。此外，你可以通过在代码中将标志
    `isTrigger` 的值设置为 `true` 或 `false` 来直接控制你的碰撞器是否是触发器。当然，你可以混合这两种选项以获得最佳性能。所有碰撞回调函数只有在两个交互的刚体中至少有一个不是运动学刚体时才会被调用。我建议你考虑碰撞回调函数的代码示例。
- en: 'The first example callback, which will be called at the start of the collision
    event:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例回调函数，将在碰撞事件开始时被调用：
- en: '[PRE5]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The second example callback, which will be called while staying in the collision
    state:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例回调函数，将在保持碰撞状态时被调用：
- en: '[PRE6]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The third example callback, which will be called at the end of the collision
    event:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个示例回调函数，将在碰撞事件结束时被调用：
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The fourth example callback, which will be called at the start of the collision
    event is much more optimized because it avoids a collision input parameter and
    thus avoids extra calculations:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个示例回调函数，将在碰撞事件开始时被调用，它进行了更多的优化，因为它避免了碰撞输入参数，从而避免了额外的计算：
- en: '[PRE8]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The fifth example callback, which will be called while staying in the collision
    state is much more optimized because it avoids a collision input parameter and
    thus avoids extra calculations:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 第五个示例回调，在保持碰撞状态时被调用，因为它避免了碰撞输入参数，从而避免了额外的计算，所以更加优化：
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The sixth example callback, which will be called at the end of the collision
    event is more optimized because it avoids the collision input parameter and thus
    avoids extra calculations:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 第六个示例回调，在碰撞事件结束时被调用，因为它避免了碰撞输入参数，从而避免了额外的计算，所以更加优化：
- en: '[PRE10]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The seventh example callback, which will be called on entering the trigger
    collider:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 第七个示例回调，将在进入触发碰撞器时被调用：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The eighth example callback, which will be called while staying in the trigger
    collider:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 第八个示例回调，将在保持触发碰撞器状态时被调用：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The ninth example callback, which will be called on exiting the trigger collider:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 第九个示例回调，将在退出触发碰撞器时被调用：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The tenth example callback, which will be called on entering the trigger without
    the collider input parameter. This callback will be faster than with the collider
    input parameter:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 第十个示例回调，将在没有碰撞器输入参数的情况下进入触发时被调用。这个回调将比带有碰撞器输入参数的回调更快：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The eleventh example callback, which will be called on the enter trigger without
    the collider input parameter. This callback will be faster than with the collider
    input parameter:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 第十一个示例回调，将在没有碰撞器输入参数的情况下进入触发时被调用。这个回调将比带有碰撞器输入参数的回调更快：
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The twelfth example callback, which will be called on exiting the trigger without
    the collider input parameter. This callback will be faster than with the collider
    input parameter:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 第十二个示例回调，将在没有碰撞器输入参数的情况下退出触发时被调用。这个回调将比带有碰撞器输入参数的回调更快：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, let's talk about joints. If you need to attach one Rigidbody to another
    Rigidbody in order to rotate it around a specific point and axis, for example
    a hinged door, then you should use HingeJoint (for 2D appropriate name is HingeJoint2D).
    Unity also provides other types of joints; for example, spring joint is suitable
    in cases when you need to develop a trampoline or something similar. However,
    I strongly advise you not to use joints everywhere because that can ruin your
    performance. Use only what is truly necessary and as often as is really required.
    The most important thing to improve your performance is to remove all unnecessary
    things.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来谈谈关节。如果你需要将一个Rigidbody连接到另一个Rigidbody以便围绕特定点进行旋转，例如一个铰链门，那么你应该使用HingeJoint（对于2D，合适的名称是HingeJoint2D）。Unity还提供了其他类型的关节；例如，弹簧关节适用于需要开发蹦床或类似物品的情况。然而，我强烈建议你不要到处都使用关节，因为这可能会破坏你的性能。只使用真正必要的东西，并且尽可能少用。提高性能最重要的方法是移除所有不必要的元素。
- en: You can also use a `CharacterController` component for creating a first person
    game. The `CharacterController` component uses its own physics calculations separately
    from Rigidbody.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`CharacterController`组件来创建第一人称游戏。`CharacterController`组件使用其自己的物理计算，与Rigidbody分开。
- en: 'These are very convenient for walking on different surfaces around the *y*
    axis without rotation and maintaining the necessary balance in the case of a Rigidbody
    component. The `CharacterController` component also requires much less processing
    time compared to a Rigidbody. That''s why you should try to use `CharacterController`
    whenever possible instead of Rigidbody, but try to make as few as possible like
    everything else. The `CharacterController` component has `CapsuleCollider`, which
    contains upwards along the *y* axis. Next, you will research the `CharacterController`
    properties as shown in the following screenshot:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对于在*y*轴周围的不同表面上行走非常方便，无需旋转，并在Rigidbody组件的情况下保持必要的平衡。`CharacterController`组件与Rigidbody相比，所需的处理时间也少得多。这就是为什么你应该尽可能使用`CharacterController`而不是Rigidbody，但尽量像其他所有东西一样，尽可能少用。`CharacterController`组件包含`CapsuleCollider`，它沿着*y*轴向上。接下来，你将研究以下截图所示的`CharacterController`属性：
- en: '![Physics and particle system effects in Unity 5](img/9191OT_04_04.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![Unity 5中的物理和粒子系统效果](img/9191OT_04_04.jpg)'
- en: Particle system performance tips and tricks
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 粒子系统性能技巧和窍门
- en: A particle system uses a large number of small particles or, in other words,
    a huge amount of graphical objects in order to create different effects such as
    dust, rain, snow, fire, explosions, smoke, a waterfall, falling leaves, fog, stars,
    galaxies, fireworks, various magic effects, and so on. Usually a particle system
    emits a plurality of particles, which have their own life-time, after which they
    disappear gradually and are re-emitted. There are also different techniques of
    using a particle system to create fur, hair, grass, where the particles do not
    disappear, but they live for a very long time.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子系统使用大量的小粒子，换句话说，就是大量的图形对象，以创建不同的效果，如灰尘、雨、雪、火、爆炸、烟雾、瀑布、落叶、雾、星星、星系、烟花、各种魔法效果等。通常，粒子系统发射多个粒子，这些粒子有自己的寿命，之后它们逐渐消失并被重新发射。还有一些使用粒子系统创建毛发、头发、草地的技术，其中粒子不会消失，但它们可以存活很长时间。
- en: Note
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Particle systems may be 2D or 3D.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子系统可以是2D或3D。
- en: Mathematically, each particle is represented as a point mass with additional
    attributes, such as appearance, speed, orientation in space, angular velocity,
    and so on. In the course of the program, each particle changes its state with
    a specific formula, common to all particles in the system. For example, the particle
    may be exposed to gravity, to change its size, color, speed, and so on. After
    all calculations, the particle will be visualized. A particle can be visualized
    by point, triangle, sprite, or even a full three-dimensional model.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学上讲，每个粒子表示为一个具有附加属性的质量点，例如外观、速度、空间中的方向、角速度等。在程序过程中，每个粒子通过一个特定的公式改变其状态，该公式对所有系统中的粒子都是通用的。例如，粒子可能受到重力的影响，改变其大小、颜色、速度等。所有计算完成后，粒子将被可视化。粒子可以通过点、三角形、精灵甚至完整的全三维模型来可视化。
- en: Currently, there is no uniform implementation of particle systems. In different
    games and apps, 3D modeling properties, behavior, and appearance of the particles
    may be fundamentally different.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，粒子系统没有统一的实现。在不同的游戏和应用程序中，粒子的3D建模属性、行为和外观可能存在根本性的不同。
- en: In most implementations, new particles are emitted by a so-called **emitter**.
    If the emitter is a point, the new particles will then occur in the same place.
    Therefore, it is possible to simulate, for example, an explosion—the emitter is
    its center. An emitter can be a line, segment, or a plane; for example rain or
    snow particles should occur at high horizontal planes. The emitter may have an
    arbitrary geometrical object, and in this case, the new particles will emerge
    on the entire surface thereof.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数实现中，新粒子是由所谓的**发射器**发射的。如果发射器是一个点，那么新粒子将出现在相同的位置。因此，可以模拟，例如，爆炸——发射器是其中心。发射器可以是一条线、线段或一个平面；例如，雨滴或雪花粒子应该出现在高水平的水平面上。发射器可以是一个任意几何对象，在这种情况下，新粒子将出现在其整个表面上。
- en: Throughout the lifetime of the particle, the particle is rarely static. Particles
    can move, rotate, change color and/or transparency, and may deal with three-dimensional
    objects. Often, particles set the maximum life span, after which the particle
    disappears.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在粒子的整个生命周期中，粒子很少处于静止状态。粒子可以移动、旋转、改变颜色和/或透明度，并且可以处理三维对象。通常，粒子设置最大寿命，之后粒子消失。
- en: In three-dimensional, real-time applications or computer games it is generally
    considered that the particles do not cast shadows on one another and on the geometry
    of the environment and they do not absorb and emit light. Without these, the simplified
    particle system will require more resources; in the case of absorption of light,
    the particles need to be sorted by distance from the camera, and in the case of
    each particle shadows have to paint several times.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在三维、实时应用或计算机游戏中，通常认为粒子不会相互投射阴影，也不会在环境的几何形状上投射阴影，它们不会吸收和发射光线。如果没有这些，简化的粒子系统将需要更多的资源；在吸收光线的情况下，粒子需要按距离摄像机的顺序排序，而在每个粒子需要绘制几次阴影的情况下。
- en: Legacy versus Shuriken Unity's built-in particle systems
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与Unity内置的粒子系统相比，Shuriken模块的遗留系统
- en: Some of Shuriken's module's properties cannot be achieved in your scripts.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Shuriken模块的一些属性无法在您的脚本中实现。
- en: At the same time, the Legacy particle system's properties can be achieved in
    your scripts.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时，在您的脚本中也可以实现遗留粒子系统的属性。
- en: 'You can turn `emission` on and off as shown in the following code:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以根据以下代码示例开启和关闭`emission`：
- en: '[PRE17]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In event of emitting particles in explosions, you should use the `Emit` function
    as shown in the following code example:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在发射爆炸中的粒子时，你应该使用以下代码示例中的`Emit`函数：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Instead of activating and deactivating the `emission` property, you can also
    control the particles in your emitter as shown here:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 与激活和停用`emission`属性不同，你还可以像下面这样控制发射器中的粒子：
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s list obtainable properties of the `Particle` class ([http://docs.unity3d.com/ScriptReference/ParticleSystem.Particle.html](http://docs.unity3d.com/ScriptReference/ParticleSystem.Particle.html)):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们列出`Particle`类的可获取属性（[http://docs.unity3d.com/ScriptReference/ParticleSystem.Particle.html](http://docs.unity3d.com/ScriptReference/ParticleSystem.Particle.html)）：
- en: '`lifetime`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lifetime`'
- en: '`startLifetime`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startLifetime`'
- en: '`position`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`position`'
- en: '`rotation`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rotation`'
- en: '`color`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`color`'
- en: '`size`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size`'
- en: '`velocity`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`velocity`'
- en: '`randomValue`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`randomValue`'
- en: '`angularVelocity`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`angularVelocity`'
- en: Note
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Creating the Shuriken particle system in Unity is very simple. You just need
    to navigate to **GameObject** | **Create Other** | **Particle Systems**. This
    will create an instance of the Shuriken Particle System for you to play with.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中创建Shuriken粒子系统非常简单。你只需导航到**GameObject** | **Create Other** | **Particle
    Systems**。这将为你创建一个Shuriken粒子系统的实例，你可以对其进行操作。
- en: To make a Legacy particle system, you have to make a `void` GameObject or join
    the Legacy particle system to an accessible GameObject.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个旧版粒子系统，你必须创建一个`void` GameObject或将旧版粒子系统连接到一个可用的GameObject。
- en: Particle system tips
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 粒子系统技巧
- en: There are numerous things that can kill the frame rate in an up-to-date game,
    and particles are up close to the highest on the rundown of reasons. A key component
    is that particles are liable to a great deal of overdraw that is not displayed
    in your opaque geometry.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代游戏中，有许多事情会降低帧率，粒子几乎是最主要的原因之一。一个关键因素是粒子容易产生大量的不必要的渲染，而这些渲染并没有显示在你的不透明几何体上。
- en: The purpose behind the increment in overdraw is that for particles, we have
    a tendency to have heaps of distinctive primitives (typically quads) that are
    covered, maybe to copy impacts like flame or smoke. Regularly, every particle
    primitive is translucent (alpha-mixed), so the z-buffer is not overhauled as pixels
    are composed and we wind up rendering to pixels at different times. (Interestingly,
    for hazy geometry, we do keep in touch with the z-buffer, so between a conceivable
    z-prepass, sorting items front-to-back, progressive z-culling on the GPU, and
    ordinary profundity testing, the effect is that we have almost no overdraw.)
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 过度绘制增加的原因是，对于粒子，我们倾向于有大量的不同原语（通常是四边形）被覆盖，可能是为了复制火焰或烟雾等效果。通常，每个粒子原语都是透明的（alpha混合），因此z缓冲区不会被更新，当像素被写入时，我们最终在不同的时间渲染到像素上。（有趣的是，对于模糊几何体，我们确实会写入z缓冲区，因此在一个可能的z预扫描、从前到后排序项目、GPU上的渐进式z裁剪和常规深度测试之间，效果是我们几乎没有任何过度绘制。）
- en: Overdraw, thus, prompts expanded employments of both `fillrate` (how many pixels
    the fittings can render to for every second) and `bandwidth` (how much information
    you can exchange to/from the GPU for every second), both of which may be rare
    assets.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，过度绘制会导致`fillrate`（每秒可以渲染的像素数量）和`bandwidth`（每秒可以交换到/从GPU的信息量）的使用增加，这两者可能都是稀缺资源。
- en: We concur that particles can result in a considerable measure of issues. Luckily,
    there are heaps of things that are able to improve the rendering side of a particle
    system.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都认为粒子可能会引起相当多的问题。幸运的是，有许多事情能够改善粒子系统的渲染方面。
- en: '**Use opaque particles**: For example, make smoke effects truly thick so that
    (some or the sum of) the molecule boards will be obscure, with set pattern alpha.
    For a few particles, in the same way as shrapnel, rocks, or comparable objects,
    use lightweight geometry particles rather than sprites with alpha borders.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用不透明粒子**：例如，使烟雾效果真正厚重，使得（一些或全部的）分子板变得不透明，具有固定的图案alpha。对于一些粒子，例如碎片、岩石或类似物体，使用轻量级几何粒子而不是带有alpha边界的精灵。'
- en: '**Use wealthier particles**: Put more oomph in a solitary molecule sprite so
    that you require fewer of them. Use flip book surfaces to make surging in for
    example fire and smoke, instead of stacking sprites.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用更丰富的粒子**：给单个分子精灵增加更多活力，这样你需要的就少。使用翻书表面来制作例如火焰和烟雾的涌动，而不是堆叠精灵。'
- en: '**Top aggregate sum of particles**: Use fittings counters on the graphics card
    to obtain the number of particle pixels that have been rendered, and quit discharging
    or drawing particles when passing a certain breaking point (which may be set dynamically).'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**粒子总数**：使用图形卡上的适配器计数器来获取已渲染的粒子像素数，并在超过某个临界点时停止释放或绘制粒子（这个临界点可能被动态设置）。'
- en: '**Decrease state changes**: Share shaders between particles. You can get this
    by, for example, dropping characteristics for far off particles (for example,
    dropping the normal map at the earliest opportunity).'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少状态变化**：在粒子之间共享着色器。例如，你可以通过丢弃远离粒子的特性（例如，在最早的机会丢弃法线贴图）来实现这一点。'
- en: '**Make particles front-to-back premultiplied-alpha style**: Using premultiplied
    alpha (which is cooperative), you can mix particles front-to-back rather than
    the ordinary back-to-front requesting. The thought here is to utilize the front-to-back
    attracting to fill a stencil buffer when alpha gets (close) strong and at last,
    quit drawing particles all together (when they generally won''t help the visual
    scene much).'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**以前后预乘alpha风格制作粒子**：使用预乘alpha（这是协作的），你可以从前向后混合粒子，而不是普通的从后向前请求。这里的想法是利用前后吸引来填充当alpha变得（接近）强时填充模板缓冲区，最后，完全停止绘制粒子（当它们通常不会对视觉场景有很大帮助时）。'
- en: '**Bunch particles together into one molecule entity**: Instead of drawing two
    covering particles separately, you can structure a solitary (bigger) molecule
    that incorporates the two particles and performs the mixing of the two particles
    in a staightforward manner in the shader. This has a tendency to decrease the
    measure of the frame buffer understands we do, as we just need to mix one molecule.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将粒子聚集成一个分子实体**：而不是分别绘制两个重叠的粒子，你可以构建一个包含两个粒子的单一（更大的）分子，并在着色器中以简单的方式混合这两个粒子。这倾向于减少我们进行的帧缓冲区理解的量，因为我们只需要混合一个分子。'
- en: Summary
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered new Mecanim animation features in Unity 5\. You were introduced
    to the new awesome audio features in Unity 5\. At the end of this chapter, you
    explored physics and particle systems in Unity 5\. In this chapter, you covered
    many useful details for your performance within Unity built-in physics and particle
    systems. You explored Rigidbodies and different tips and tricks tied with it.
    You learned about kinematic and sleeping Rigidbodies, colliders, static colliders,
    primitive colliders, physics materials, triggers, joints, character controller,
    interactive cloth, and a lot of other useful physics definitions, details, notes,
    tips, and tricks. You also learned a lot about the particle system tips and tricks
    and how to create a simple pooling system for any of your objects.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了Unity 5中的新Mecanim动画功能。你了解了Unity 5中新的出色音频功能。在本章的最后，你探索了Unity 5中的物理和粒子系统。在本章中，你涵盖了在Unity内置物理和粒子系统中进行性能时许多有用的细节。你探索了刚体及其相关的技巧和窍门。你学习了运动学刚体和休眠刚体、碰撞体、静态碰撞体、原始碰撞体、物理材质、触发器、关节、角色控制器、交互式布料以及许多其他有用的物理定义、细节、注意事项、技巧和窍门。你还学习了关于粒子系统技巧和窍门以及如何为你的任何对象创建一个简单的对象池系统。
- en: The next chapter will include an overview about asset bundles in Unity 5\. You
    will also learn how to download new code and data in real-time for Android devices.
    At the end of this chapter, you will discover the safeness technique of the asset
    bundles in practice.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将包括Unity 5中资源包的概述。你还将学习如何实时为Android设备下载新的代码和数据。在本章的最后，你将发现资源包在实际应用中的安全性技术。
