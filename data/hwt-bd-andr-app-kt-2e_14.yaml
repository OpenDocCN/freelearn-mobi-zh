- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Coroutines and Flow
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协程和Flow
- en: This chapter introduces you to background operations and data manipulations
    with Coroutines and Flow. You’ll also learn how to manipulate and display the
    data using `LiveData` transformations and Kotlin Flow operators.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了使用协程和Flow进行后台操作和数据操作。你还将学习如何使用`LiveData`转换和Kotlin Flow操作来操作和显示数据。
- en: By the end of this chapter, you will be able to use Coroutines and Flow to manage
    network calls in the background. You will also be able to manipulate data with
    `LiveData` transformations and Flow operators.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够使用协程和Flow在后台管理网络调用。你还将能够使用`LiveData`转换和Flow操作来操作数据。
- en: You learned the basics of Android app development and implemented features such
    as RecyclerViews, notifications, fetching data from web services, and services.
    You also gained skills in the best practices for testing and persisting data.
    In the previous chapter, you learned about dependency injection. Now, you will
    learn about background operations and data manipulation.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学习了Android应用开发的基础知识，并实现了如RecyclerViews、通知、从网络服务获取数据以及服务等功能。你还掌握了测试和持久化数据的最佳实践。在前一章中，你学习了依赖注入。现在，你将学习关于后台操作和数据操作的内容。
- en: Some Android applications work on their own. However, most apps would need a
    backend server to retrieve or process data. These operations may take a while,
    depending on the internet connection, device settings, and server specifications.
    If long-running operations are run in the main **user interface** (**UI**) thread,
    the application will be blocked until the tasks are completed. The application
    might become unresponsive and prompt the user to close and stop using it.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Android应用程序可以独立工作。然而，大多数应用程序都需要后端服务器来检索或处理数据。这些操作可能需要一段时间，具体取决于网络连接、设备设置和服务器规格。如果长时间运行的操作在主**用户界面**（**UI**）线程上运行，应用程序将被阻塞，直到任务完成。应用程序可能会变得无响应，并提示用户关闭并停止使用它。
- en: To avoid this, tasks that can take an indefinite amount of time must be run
    asynchronously. An asynchronous task means it can run in parallel to another task
    or in the background. For example, while fetching data from a data source asynchronously,
    your UI can still be displayed and user interaction can occur.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，可能需要无限期时间的任务必须异步运行。异步任务意味着它可以与另一个任务并行运行或在后台运行。例如，在异步从数据源获取数据时，你的UI仍然可以显示，用户交互也可以发生。
- en: You can use libraries such as Coroutines and Flow for asynchronous operations.
    We’ll discuss both in this chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用如协程和Flow之类的库来进行异步操作。我们将在本章中讨论这两个库。
- en: 'We will cover the following key topics in this chapter:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下关键主题：
- en: Using Coroutines on Android
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Android上使用协程
- en: Transforming `LiveData`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换 `LiveData`
- en: Using Flow on Android
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Android上使用Flow
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The complete code for all the exercises and the activity in this chapter is
    available on GitHub at [https://packt.link/puLUO](https://packt.link/puLUO)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有练习和活动的完整代码可在GitHub上找到，链接为 [https://packt.link/puLUO](https://packt.link/puLUO)
- en: Let’s get started with Coroutines.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始学习协程。
- en: Using Coroutines on Android
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Android上使用协程
- en: Coroutines were added in Kotlin 1.3 to manage background tasks such as making
    network calls and accessing files or databases. Kotlin coroutines are Google’s
    official recommendation for asynchronous programming on Android. Their Jetpack
    libraries, such as LifeCycle, WorkManager, and Room, now include support for coroutines.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 协程是在Kotlin 1.3中添加的，用于管理后台任务，如发起网络调用、访问文件或数据库。Kotlin协程是Google在Android上异步编程的官方推荐。它们的Jetpack库，如LifeCycle、WorkManager和Room，现在都支持协程。
- en: With coroutines, you can write your code in a sequential way. The long-running
    task can be made into a suspending function, which, when called, can pause the
    thread without blocking it. When the suspending function is done, the current
    thread will resume execution. This will make your code easier to read and debug.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用协程，你可以以顺序方式编写你的代码。可以将长时间运行的任务转换为挂起函数，当调用时，可以暂停线程而不阻塞它。当挂起函数完成后，当前线程将恢复执行。这将使你的代码更容易阅读和调试。
- en: 'To mark a function as a suspending function, you can add the `suspend` keyword
    to it; for example, if you have a function that calls the `getMovies` function,
    which fetches `movies` from your endpoint and then displays it:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要将一个函数标记为挂起函数，你可以向它添加`suspend`关键字；例如，如果你有一个调用`getMovies`函数的函数，该函数从你的端点获取`movies`并显示它：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can make the `getMovies()` function a suspending function by adding the
    `suspend` keyword:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过添加 `suspend` 关键字将 `getMovies()` 函数转换为暂停函数：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, the calling function will invoke `getMovies` and pause. After `getMovies`
    returns a list of movies, it will resume its task and display the movies.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，调用函数将调用 `getMovies` 并暂停。在 `getMovies` 返回电影列表后，它将恢复其任务并显示电影。
- en: 'Suspending functions can only be called in other suspending functions or from
    a coroutine. Coroutines have a context, which includes the coroutine dispatcher.
    Dispatchers specify what thread the coroutine will use. There are three dispatchers
    you can use:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 暂停函数只能在其他暂停函数或协程中调用。协程有一个上下文，包括协程调度器。调度器指定协程将使用哪个线程。你可以使用以下三个调度器：
- en: '`Dispatchers.Main`: Used to run on Android’s main thread'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dispatchers.Main`: 用于在 Android 的主线程上运行'
- en: '`Dispatchers.IO`: Used for network, file, or database operations'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dispatchers.IO`: 用于网络、文件或数据库操作'
- en: '`Dispatchers.Default`: Used for CPU-intensive work'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dispatchers.Default`: 用于 CPU 密集型工作'
- en: 'To change the context for your coroutine, you can use the `withContext` function
    for the code that you want to use a different thread with. For example, in your
    suspending function, `getMovies`, which gets movies from your endpoint, you can
    use `Dispatchers.IO`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改协程的上下文，你可以使用 `withContext` 函数为想要使用不同线程的代码。例如，在你的暂停函数 `getMovies` 中，它从端点获取电影，你可以使用
    `Dispatchers.IO`：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the next section, we will cover how to create coroutines.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍如何创建协程。
- en: Creating coroutines
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建协程
- en: You can create a coroutine with the `async` and `launch` keywords. The `launch`
    keyword creates a coroutine and doesn’t return anything. On the other hand, the
    `async` keyword returns a value that you can get later with the `await` function.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `async` 和 `launch` 关键字创建协程。`launch` 关键字创建一个协程，不返回任何内容。另一方面，`async` 关键字返回一个值，你可以稍后使用
    `await` 函数获取。
- en: 'The `async` and `launch` keywords must be created from `CoroutineScope`, which
    defines the lifecycle of the coroutine. For example, the coroutine scope for the
    main thread is `MainScope`. You can then create coroutines with the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`async` 和 `launch` 关键字必须从 `CoroutineScope` 创建，它定义了协程的生命周期。例如，主线程的协程作用域是 `MainScope`。然后你可以使用以下方式创建协程：'
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can also create your own `CoroutineScope` instead of using `MainScope`
    by creating one with `CoroutineScope` and passing in the context for the coroutine.
    For example, to create `CoroutineScope` for use on a network call, you can define
    the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过使用 `CoroutineScope` 创建一个自己的 `CoroutineScope` 而不是使用 `MainScope`。你可以通过使用
    `CoroutineScope` 并传递协程的上下文来创建一个。例如，为了在网络调用中使用 `CoroutineScope`，你可以定义以下内容：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The coroutine can be canceled when the function is no longer needed, such as
    when you close the activity. You can do that by calling the `cancel` function
    from `CoroutineScope`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数不再需要时，例如关闭活动时，可以取消协程。你可以通过从 `CoroutineScope` 调用 `cancel` 函数来实现这一点：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'A ViewModel also has a default `CoroutineScope` for creating coroutines: `viewModelScope`.
    Jetpack’s LifeCycle also has the `lifecycleScope` that you can use. `viewModelScope`
    is canceled when the ViewModel has been destroyed; `lifecycleScope` is also canceled
    when the lifecycle is destroyed. Thus, you no longer need to cancel them.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ViewModel 还有一个用于创建协程的默认 `CoroutineScope`：`viewModelScope`。Jetpack 的 LifeCycle
    也有你可以使用的 `lifecycleScope`。当 ViewModel 被销毁时，`viewModelScope` 会被取消；当生命周期被销毁时，`lifecycleScope`
    也会被取消。因此，你不再需要取消它们。
- en: In the next section, you will learn how to add coroutines to your project.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将学习如何将协程添加到你的项目中。
- en: Adding coroutines to your project
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加协程到你的项目
- en: 'You can add coroutines to your project by adding the following code to your
    `app/build.gradle` file dependencies:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将以下代码添加到你的 `app/build.gradle` 文件依赖项中来将协程添加到你的项目中：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`kotlinx-coroutines-core` is the main library for coroutines, while `kotlinx-coroutines-android`
    adds support for the main Android thread.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`kotlinx-coroutines-core` 是协程的主要库，而 `kotlinx-coroutines-android` 为主 Android
    线程添加了支持。'
- en: You can add coroutines in Android when making a network call or fetching data
    from a local database.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Android 中添加协程，在执行网络调用或从本地数据库获取数据时。
- en: 'If you’re using Retrofit 2.6.0 or above, you can mark the endpoint function
    as a suspending function with `suspend`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Retrofit 2.6.0 或更高版本，你可以使用 `suspend` 标记端点函数为暂停函数：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, you can create a coroutine to call the suspending `getMovies` function
    and display the list:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以创建一个协程来调用暂停的 `getMovies` 函数并显示列表：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can also use LiveData for the response of your coroutines. `LiveData` is
    a Jetpack class that can hold observable data. You can add `LiveData` to your
    Android project by adding the following dependency:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 `LiveData` 来处理协程的响应。`LiveData` 是一个可以持有可观察数据的 Jetpack 类。你可以通过添加以下依赖项将
    `LiveData` 添加到你的 Android 项目中：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Let’s try to use coroutines in an Android project.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在一个 Android 项目中使用协程。
- en: Exercise 14.01 – using coroutines in an Android app
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 14.01 – 在 Android 应用中使用协程
- en: 'For this chapter, you will work with an application that displays popular movies
    using The Movie Database API. Go to [https://developers.themoviedb.org](https://developers.themoviedb.org)
    and register for an API key. In this exercise, you will be using coroutines to
    fetch a list of popular movies:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你将使用 The Movie Database API 显示热门电影的应用程序。前往 [https://developers.themoviedb.org](https://developers.themoviedb.org)
    并注册 API 密钥。在这个练习中，你将使用协程来获取热门电影列表：
- en: Open the `Popular Movies` project in Android Studio in the `Chapter14` directory
    from this book's code repository.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本书代码仓库的 `Chapter14` 目录中打开 Android Studio 中的 `Popular Movies` 项目。
- en: 'Open the `AndroidManifest.xml` file and add the `INTERNET` permission inside
    the manifest tag but outside the application tag:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `AndroidManifest.xml` 文件并在 manifest 标签内但不在 application 标签外添加 `INTERNET` 权限：
- en: '[PRE10]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Open the `app/build.gradle` file and add the dependencies for the Kotlin Coroutines:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `app/build.gradle` 文件并添加 Kotlin 协程的依赖项：
- en: '[PRE11]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: These will allow you to use coroutines in your project.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些将允许你在项目中使用协程。
- en: 'Also, add the dependencies for the ViewModel and `LiveData` extension libraries:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，添加 ViewModel 和 `LiveData` 扩展库的依赖项：
- en: '[PRE12]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Open the `MovieService` interface and replace it with the following code:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MovieService` 接口并将其替换为以下代码：
- en: '[PRE13]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This will mark `getPopularMovies` as a suspending function.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这将 `getPopularMovies` 标记为挂起函数。
- en: 'Open `MovieRepository` and add `apiKey` (with the value from the Movie Database
    API):'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MovieRepository` 并添加 `apiKey`（使用来自电影数据库 API 的值）：
- en: '[PRE14]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the `MovieRepository` file, add the movies and error `LiveData` for the
    list of movies:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MovieRepository` 文件中，为电影列表添加电影和错误 `LiveData`：
- en: '[PRE15]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add the suspending `fetchMovies` function to retrieve the list from the endpoint:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加挂起的 `fetchMovies` 函数以从端点检索列表：
- en: '[PRE16]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Open `MovieApplication` and add a property for `movieRepository`:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MovieApplication` 并为 `movieRepository` 添加一个属性：
- en: '[PRE17]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Override the `onCreate` function of the `MovieApplication` class and initialize
    `movie``Repository`:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖 `MovieApplication` 类的 `onCreate` 函数并初始化 `movieRepository`：
- en: '[PRE18]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Update the contents of `MovieViewModel` with the following code:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码更新 `MovieViewModel` 的内容：
- en: '[PRE19]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `fetchPopularMovies` function has a coroutine, using `viewModelScope`, that
    will fetch the movies from `movieRepository`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetchPopularMovies` 函数有一个协程，使用 `viewModelScope` 从 `movieRepository` 获取电影。'
- en: 'Open the `MainActivity` class. At the end of the `onCreate` function, create
    `movie` **Repository** and `movieViewModel`:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainActivity` 类。在 `onCreate` 函数的末尾，创建 `movie` **仓库** 和 `movieViewModel`：
- en: '[PRE20]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After that, add an observer to `popularMovies` and `error` `LiveData` from
    `movie``ViewModel`:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，向 `movieViewModel` 的 `popularMovies` 和 `error` `LiveData` 添加观察者：
- en: '[PRE21]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will update the activity’s RecyclerView with the movies fetched. The list
    of movies is filtered using Kotlin’s `filter` function to only include movies
    released this year. They are then sorted by popularity using Kotlin’s `sortedByDescending`
    function.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这将更新活动中的 RecyclerView，显示获取到的电影。电影列表使用 Kotlin 的 `filter` 函数进行过滤，仅包括今年上映的电影。然后使用
    Kotlin 的 `sortedByDescending` 函数按受欢迎程度排序。
- en: 'Run the application. You will see that the app will display a list of popular
    movie titles from the current year, sorted by popularity:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序。你会看到应用程序将显示当前年份的热门电影列表，按受欢迎程度排序：
- en: '![Figure 14.1 – The app displaying popular movies released this year, sorted
    by popularity](img/B19411_14_01.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.1 – 显示按受欢迎程度排序的今年上映热门电影的 app](img/B19411_14_01.jpg)'
- en: Figure 14.1 – The app displaying popular movies released this year, sorted by
    popularity
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.1 – 显示按受欢迎程度排序的今年上映热门电影的 app
- en: 'Click on a movie, and you will see its details, such as its release date and
    an overview:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击一部电影，你将看到其详细信息，例如上映日期和概述：
- en: '![Figure 14.2 – The movie details screen](img/B19411_14_02.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.2 – 电影详情屏幕](img/B19411_14_02.jpg)'
- en: Figure 14.2 – The movie details screen
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.2 – 电影详情屏幕
- en: You have used coroutines and `LiveData` to retrieve and display a list of popular
    movies from a remote data source without blocking the main thread.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经使用了协程和 `LiveData` 来从远程数据源检索并显示热门电影列表，而不会阻塞主线程。
- en: Before passing `LiveData` into the UI for display, you can also transform the
    data first. You will learn about that in the next section.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在将 `LiveData` 传递到 UI 进行显示之前，你也可以先转换数据。你将在下一节中了解这一点。
- en: Transforming LiveData
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换 LiveData
- en: Sometimes, the `LiveData` you pass from the ViewModel to the UI layer needs
    to be processed first before displaying. For example, you can only select a part
    of the data or do some processing on it first. In the previous exercise, you filtered
    the data to only select popular movies from the current year.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，从 ViewModel 传递到 UI 层的 `LiveData` 需要先进行处理，然后再显示。例如，你可能只能选择数据的一部分，或者先对其进行一些处理。在之前的练习中，你过滤了数据，只选择了当年流行的电影。
- en: To modify `LiveData`, you can use the `Transformations` class. It has two functions,
    `Transformations.map` and `Transformations.switchMap`, that you can use.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改 `LiveData`，你可以使用 `Transformations` 类。它有两个函数，`Transformations.map` 和 `Transformations.switchMap`，你可以使用。
- en: '`Transformations.map` modifies the value of `LiveData` into another value.
    This can be used for tasks such as filtering, sorting, or formatting the data.
    For example, you can transform `movieLiveData` into string `LiveData` from the
    movie’s title:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`Transformations.map` 将 `LiveData` 的值修改为另一个值。这可以用于过滤、排序或格式化数据等任务。例如，你可以将 `movieLiveData`
    转换为包含电影标题的字符串 `LiveData`：'
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When `movieLiveData` changes value, `movieTitleLiveData` will also change based
    on the movie’s title.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `movieLiveData` 的值发生变化时，`movieTitleLiveData` 也会根据电影的标题发生变化。
- en: 'With `Transformations.switchMap`, you can transform the value of a `LiveData`
    into another `LiveData`. This is used when you want to do a specific task involving
    a database or network operation with the original `LiveData`. For example, if
    you have a `LiveData` representing a movie `id` object, you can transform that
    into movie `LiveData` by applying the `getMovieDetails` function, which returns
    `LiveData` of movie details from the `id` object (such as from another network
    or database call):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Transformations.switchMap`，你可以将一个 `LiveData` 的值转换为另一个 `LiveData`。这在你想要对原始
    `LiveData` 执行涉及数据库或网络操作的具体任务时使用。例如，如果你有一个表示电影 `id` 对象的 `LiveData`，你可以通过应用 `getMovieDetails`
    函数将其转换为电影 `LiveData`，该函数从 `id` 对象返回电影详情 `LiveData`（例如，来自另一个网络或数据库调用）：
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Let’s use `LiveData` transformations on the list of movies fetched using coroutines.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `LiveData` 转换对使用协程获取的电影列表进行转换。
- en: Exercise 14.02 – LiveData transformations
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 14.02 – LiveData 转换
- en: 'In this exercise, you will transform the `LiveData` list of movies before passing
    them to the observers in the `MainActivity` file:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将在将 `LiveData` 列表传递给 `MainActivity` 文件中的观察者之前对其进行转换：
- en: Open the `Popular Movies` project you worked on in the previous exercise in
    Android Studio.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你在之前练习中在 Android Studio 中工作的 `Popular Movies` 项目。
- en: 'Open the `MainActivity` file. In the `movieViewModel.popularMovies` observer
    in the `onCreate` function, remove the filter and the `sortedByDescending` function
    calls. The code should look like the following:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainActivity` 文件。在 `onCreate` 函数中的 `movieViewModel.popularMovies` 观察者中，移除过滤和
    `sortedByDescending` 函数调用。代码应如下所示：
- en: '[PRE24]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This will now display all movies in the list without them being sorted by popularity.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将显示列表中的所有电影，而不会按流行度排序。
- en: 'Run the application. You should see all movies (even those from the past year),
    not sorted by popularity:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序。你应该看到所有电影（包括去年的电影），但不会按流行度排序：
- en: '![Figure 14.3 – The app with unsorted popular movies](img/B19411_14_03.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.3 – 未排序的流行电影应用](img/B19411_14_03.jpg)'
- en: Figure 14.3 – The app with unsorted popular movies
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.3 – 未排序的流行电影应用
- en: 'Open the `MovieViewModel` class and update `popularMovies` with `LiveData`
    transformations to filter and sort the movies:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MovieViewModel` 类，并使用 `LiveData` 转换来过滤和排序电影：
- en: '[PRE25]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This will select the movies released this year and sort them by title before
    passing them to the UI observer in `MainActivity`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这将选择当年发布的电影，并按标题排序后再传递给 `MainActivity` 中的 UI 观察者。
- en: 'Run the application. You will see that the app shows a list of popular movies
    from the current year, sorted by popularity:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序。你会看到应用显示了一个按流行度排序的当年流行电影列表：
- en: '![Figure 14.4 – The app with the movies released last month sorted by popularity](img/B19411_14_04.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.4 – 按流行度排序的上个月发布的电影应用](img/B19411_14_04.jpg)'
- en: Figure 14.4 – The app with the movies released last month sorted by popularity
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.4 – 按流行度排序的上个月发布的电影应用
- en: You have used `LiveData` transformations to modify the list of movies to select
    only the ones released in the previous month. They were also sorted by popularity
    before passing them to the observers in the UI layer.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经使用了 `LiveData` 转换来修改电影列表，只选择上个月发布的电影。在将它们传递给 UI 层的观察者之前，它们也按受欢迎程度进行了排序。
- en: In the next section, you will learn about Kotlin Flows.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将了解 Kotlin 流。
- en: Using Flow on Android
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Android 上使用 Flow
- en: In this section, you will look into using Flows for asynchronous programming
    in Android. Flow, an asynchronous stream library built on top of Kotlin Coroutines,
    is ideal for live data updates in your application. Android Jetpack libraries
    include Room, WorkManager, and Jetpack Compose, and third-party libraries support
    Flow.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将探讨在 Android 中使用流进行异步编程。Flow 是一个基于 Kotlin 协程构建的异步流库，非常适合在应用程序中更新实时数据。Android
    Jetpack 库包括 Room、WorkManager 和 Jetpack Compose，第三方库支持 Flow。
- en: A Flow of data is represented by the `kotlinx.coroutines.flow.Flow` interface.
    Flows emit multiple values of the same type one at a time. For example, `Flow<String>`
    is a Flow that emits string values.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 数据流由 `kotlinx.coroutines.flow.Flow` 接口表示。流一次发射相同类型的一个值。例如，`Flow<String>` 是一个发射字符串值的流。
- en: 'A flow starts to emit values when you call the suspending `collect` function
    from a coroutine or another suspending function. In the following example, the
    `collect` function was called from the coroutine created using the `launch` builder
    of `lifecycleScope`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在协程或另一个挂起函数中调用挂起的 `collect` 函数时，流开始发射值。在下面的示例中，`collect` 函数是从使用 `lifecycleScope`
    的 `launch` 构建器创建的协程中调用的：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, the `collect{}` function was called on `viewModel.fetchMovies()`. This
    will start the Flow’s emission of movies; each movie title is then logged.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，对 `viewModel.fetchMovies()` 调用了 `collect{}` 函数。这将启动 Flow 的电影发射；然后记录下每部电影的标题。
- en: 'To change the `CoroutineContext` where the Flow runs, you can use the `flowOn()`
    function to change the Dispatcher. The previous example can be updated with a
    different Dispatcher, as shown in the following code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改 Flow 运行的 `CoroutineContext`，你可以使用 `flowOn()` 函数来更改调度器。前面的示例可以使用不同的调度器进行更新，如下面的代码所示：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this example, the Dispatcher for the Flow will be changed to `Dispatchers.IO`.
    Calling `flowOn` will only change the functions before it, not the functions and
    operators after.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，Flow 的调度器将被更改为 `Dispatchers.IO`。调用 `flowOn` 只会更改它之前的函数，而不会更改它之后的函数和操作符。
- en: In the next section, you will learn about collecting Flows on Android.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将学习如何在 Android 上收集流。
- en: Collecting Flows on Android
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Android 上收集流
- en: In Android, Flows are usually collected in the Activity or Fragment for display
    in the UI. Moving the app in the background will not stop the data collection.
    The app must not do so and continue updating the screen to avoid memory leaks
    and prevent wasting resources.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 中，流通常在 Activity 或 Fragment 中收集以在 UI 中显示。将应用移至后台不会停止数据收集。应用不应这样做，并继续更新屏幕以避免内存泄漏和防止资源浪费。
- en: You can safely collect flows in the UI Iayer by manually handling lifecycle
    changes or by using `Lifecycle.repeatOnLifecycle` and `Flow.flowWithLifecycle`,
    available in the `lifecycle-runtime-ktx` library, starting with version 2.4.0.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过手动处理生命周期变化或使用 `lifecycle-runtime-ktx` 库中的 `Lifecycle.repeatOnLifecycle`
    和 `Flow.flowWithLifecycle`（从版本 2.4.0 开始提供）来安全地在 UI 层收集流。
- en: 'To use it in your project, add the following to your `app/build.gradle` dependencies:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要在项目中使用它，请将以下内容添加到你的 `app/build.gradle` 依赖项中：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This adds the `lifecycle-runtime-ktx` library to your project, so you can use
    both `Lifecycle.repeatOnLifecycle` and `Flow.flowWithLifecycle`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将 `lifecycle-runtime-ktx` 库添加到你的项目中，这样你就可以使用 `Lifecycle.repeatOnLifecycle`
    和 `Flow.flowWithLifecycle`。
- en: '`Lifecycle.repeatOnLifecycle(state, block)` will suspend the parent coroutine
    until the lifecycle is destroyed and executes the suspending `block` code when
    the Lifecycle is at least in the `state` provided. The flow will stop when the
    Lifecycle moves out of the state and restart when the lifecycle moves back to
    the state. `Lifecycle.repeatOnLifecycle` must be called on Activity’s `onCreate`
    or on Fragment’s `onViewCreated`.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lifecycle.repeatOnLifecycle(state, block)` 将挂起父协程，直到生命周期被销毁，并在生命周期至少处于提供的
    `state` 时执行挂起的 `block` 代码。当生命周期离开该状态时，流将停止，当生命周期返回该状态时，流将重新启动。`Lifecycle.repeatOnLifecycle`
    必须在 Activity 的 `onCreate` 或 Fragment 的 `onViewCreated` 中调用。'
- en: When using `Lifecycle.State.STARTED` for `state`, the `repeatOnLifecycle` will
    start Flow collection when the Lifecycle is started and stop when the Lifecycle
    is stopped (`onStop()` is called).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `Lifecycle.State.STARTED` 作为 `state` 时，`repeatOnLifecycle` 将在 Lifecycle
    开始时开始 Flow 收集，并在 Lifecycle 停止时停止（调用 `onStop()`）。
- en: If you use `Lifecycle.State.RESUMED`, the start will be when the Lifecycle is
    resumed, and the stop will be when `onPause` is called or when the Lifecycle is
    paused.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 `Lifecycle.State.RESUMED`，开始将在 Lifecycle 恢复时，停止将在 `onPause` 被调用或 Lifecycle
    暂停时。
- en: 'The following example shows how you can use `Lifecycle.repeatOnLifecycle`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何使用 `Lifecycle.repeatOnLifecycle`：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this class, `repeatOnLifecycle` with `Lifecycle.State.STARTED` starts collecting
    the Flow of movies when the lifecycle is started and stops when the lifecycle
    is stopped.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，`repeatOnLifecycle` 与 `Lifecycle.State.STARTED` 一起使用，当生命周期开始时开始收集电影 Flow，当生命周期停止时停止。
- en: '`Flow.flowWithLifecycle` is another way to safely collect Flows in Android.
    It emits values from the Flow and operators preceding the call (the upstream Flow)
    when the lifecycle is at least in the state you set or the default, `Lifecycle.State.STARTED`.
    Internally, it uses `Lifecycle.repeatOnLifecycle`. The following example shows
    how you can use `Flow.flowWithLifecycle`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flow.flowWithLifecycle` 是在 Android 中安全收集 Flows 的另一种方式。它在生命周期至少处于你设置的或默认的 `Lifecycle.State.STARTED`
    状态时，从 Flow 发射值和调用之前的操作符（上游 Flow）。内部使用 `Lifecycle.repeatOnLifecycle`。以下示例展示了如何使用
    `Flow.flowWithLifecycle`：'
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, we used `flowWithLifecycle` with `Lifecycle.State.STARTED` to collect
    the Flow of movies when the lifecycle is started and stop when the lifecycle is
    stopped.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用了 `flowWithLifecycle` 与 `Lifecycle.State.STARTED` 来在生命周期开始时收集电影 Flow，并在生命周期停止时停止。
- en: In the following section, you will learn how to create Flows.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将学习如何创建 Flows。
- en: Creating Flows with Flow Builders
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Flow Builders 创建 Flows
- en: 'You can create Flows using the Flow Builders from the Kotlin Flow API. The
    following are the Flow Builders you can use:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 Kotlin Flow API 中的 Flow Builders 来创建 Flows。以下是可以使用的 Flow Builders：
- en: '`flow{}`: This creates a new Flow from a suspendable lambda block. You can
    send values using the `emit` function.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flow{}`: 这会从一个可挂起的 lambda 块创建一个新的 Flow。你可以使用 `emit` 函数发送值。'
- en: '`flowOf()`: This creates a Flow from the specified value or the `vararg` values.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flowOf()`: 这会从指定的值或 `vararg` 值创建一个 Flow。'
- en: '`asFlow()`: This is an extension function used to convert a type (sequence,
    array, range, or collection) into a Flow.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asFlow()`: 这是一个扩展函数，用于将类型（序列、数组、范围或集合）转换为 Flow。'
- en: 'The following example shows how to use the Flow Builders in an application:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何在应用程序中使用 Flow Builders：
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this example, `fetchMovies` created a Flow using `flow{}` and emitted each
    movie from the list. The `fetchTop3Titles` function uses `flowOf` to create a
    Flow with the titles of the first three movies. Finally, `fetchMovieIds` converted
    the list of IDs into a Flow of movie IDs using the `asFlow` function.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`fetchMovies` 使用 `flow{}` 创建了一个 Flow，并从列表中发射了每部电影。`fetchTop3Titles` 函数使用
    `flowOf` 创建了一个包含前三部电影标题的 Flow。最后，`fetchMovieIds` 使用 `asFlow` 函数将 ID 列表转换成了电影 ID
    的 Flow。
- en: In the next section, you will learn about the Kotlin Flow operators you can
    use with Flows.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将了解你可以与 Flows 一起使用的 Kotlin Flow 操作符。
- en: Using operators with Flows
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Flows 的操作符
- en: There are built-in Flow operators you can use with Flows. You can collect Flows
    with terminal operators and transform Flows with intermediate operators.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Flows 有一些内置的操作符可以与 Flows 一起使用。你可以使用终端操作符收集 Flows，并使用中间操作符转换 Flows。
- en: 'Terminal operators, such as the `collect` function used in the previous examples,
    are used to collect Flows. The following are the other terminal operators you
    can use:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 终端操作符，如前例中使用的 `collect` 函数，用于收集 Flows。以下是可以使用的其他终端操作符：
- en: '`count`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count`'
- en: '`first` and `firstOrNull`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`first` 和 `firstOrNull`'
- en: '`last` and `lastOrNull`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`last` 和 `lastOrNull`'
- en: '`fold`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fold`'
- en: '`reduce`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reduce`'
- en: '`single` and `singleOrNull`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`single` 和 `singleOrNull`'
- en: '`toCollection`, `toList`, and `toSet`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toCollection`、`toList` 和 `toSet`'
- en: These operators work similarly to the Kotlin `Collection` function with the
    same name.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作符与 Kotlin `Collection` 函数同名操作符的工作方式类似。
- en: 'You can use Intermediate operators to modify a Flow and return a new one. They
    can also be chained. The following Intermediate operators work the same as the
    Kotlin collection functions with the same name:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用中间操作符来修改 Flow 并返回一个新的 Flow。它们也可以链式使用。以下中间操作符与 Kotlin 集合函数同名操作符的工作方式相同：
- en: '`filter`, `filterNot`, `filterNotNull`, and `filterIsInstance`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter`、`filterNot`、`filterNotNull` 和 `filterIsInstance`'
- en: '`map` and `mapNotNull`'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map` 和 `mapNotNull`'
- en: '`onEach`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onEach`'
- en: '`runningReduce` and `runningFold`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runningReduce` 和 `runningFold`'
- en: '`withIndex`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`withIndex`'
- en: 'Additionally, there is a `transform` operator you can use to apply your own
    operation. For example, this class has a Flow that uses the `transform` operator:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个 `transform` 操作符可以用来应用你自己的操作。例如，这个类有一个使用 `transform` 操作符的 Flow：
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, the `transform` operator was used in the Flow of movies to only emit the
    ones whose `voteAverage` is higher than `0.6` (60%).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，使用了 `transform` 操作符在电影 Flow 中仅发射 `voteAverage` 大于 `0.6`（60%）的电影。
- en: There are also size-limiting Kotlin Flow operators such as `drop`, `dropWhile`,
    `take`, and `takeWhile`, which function similarly to the Kotlin collection functions
    of the same name.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有大小限制的 Kotlin Flow 操作符，如 `drop`、`dropWhile`、`take` 和 `takeWhile`，它们的功能与
    Kotlin 集合函数同名类似。
- en: Let’s add Kotlin Flow into an Android project.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将 Kotlin Flow 添加到 Android 项目中。
- en: Exercise 14.03 – using Flow in an Android application
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 14.03 – 在 Android 应用中使用 Flow
- en: 'In this exercise, you will update the Popular Movies app to use Kotlin Flow
    in fetching the list of movies:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将更新流行电影应用以使用 Kotlin Flow 来获取电影列表：
- en: Open the Popular Movies project from the previous exercise in Android Studio.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Android Studio 中上一个练习的“流行电影”项目。
- en: 'Go to the `MovieRepository` class and remove the `movies` and `error` `LiveData`.
    Then, replace the `fetchMovies` function with the following:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 `MovieRepository` 类，删除 `movies` 和 `error` `LiveData`。然后，用以下内容替换 `fetchMovies`
    函数：
- en: '[PRE33]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This changes the `fetchMovies` function to use Kotlin Flow. The Flow will emit
    the list of movies from `movieService.getPopularMovies`, and it will flow on the
    `Dispatchers.IO` dispatcher.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这将修改 `fetchMovies` 函数以使用 Kotlin Flow。Flow 将从 `movieService.getPopularMovies`
    发射电影列表，并在 `Dispatchers.IO` 调度器上流动。
- en: 'Open the `MovieViewModel` class. In the class declaration, add a dispatcher
    parameter with a default value of `Dispatchers.IO`:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MovieViewModel` 类。在类声明中，添加一个具有默认值 `Dispatchers.IO` 的调度器参数：
- en: '[PRE34]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This will be the dispatcher that will be used later for the Flow.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是之后用于 Flow 的调度器。
- en: 'Replace the `popularMovies` `LiveData` with the following:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `popularMovies` `LiveData` 替换为以下内容：
- en: '[PRE35]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You will use these for the value of the list of movies from `MovieRepository`.
    `StateFlow` is an observable Flow that emits state updates to the collectors,
    while `MutableStateFlow` is a `StateFlow` that you can change the value. In Android,
    `StateFlow` can be an alternative to `LiveData`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用这些来获取 `MovieRepository` 中电影列表的值。`StateFlow` 是一个可观察的 Flow，它向收集器发射状态更新，而 `MutableStateFlow`
    是一个可以更改值的 `StateFlow`。在 Android 中，`StateFlow` 可以作为 `LiveData` 的替代品。
- en: 'Remove the `error` `LiveData` and replace it with the following:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除 `error` `LiveData` 并替换为以下内容：
- en: '[PRE36]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You will use these for handling when the Flow encounters an exception.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用这些来处理 Flow 遇到异常的情况。
- en: 'Change the content of the `fetchPopularMovies` function with the following:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `fetchPopularMovies` 函数的内容更改为以下内容：
- en: '[PRE37]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This will collect the list of movies from `movieRepository` and set it to `MutableStateFlow`
    in `_popularMovies` (and `StateFlow` in `popularMovies`).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这将收集来自 `movieRepository` 的电影列表并将其设置到 `_popularMovies` 中的 `MutableStateFlow`（以及
    `popularMovies` 中的 `StateFlow`）。
- en: 'Open the `app/build.gradle` file and add the following in the dependencies:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `app/build.gradle` 文件，并在依赖项中添加以下内容：
- en: '[PRE38]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This allows you to use `lifecycleScope` for collecting the Flows in `MainActivity`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许你在 `MainActivity` 中使用 `lifecycleScope` 来收集 Flows。
- en: 'Go to the `MainActivity` file and remove the lines of code for observing `popularMovies`
    and `error` from `MovieViewModel`. Add the following to collect the Flow from
    `MovieViewModel`:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 `MainActivity` 文件，从 `MovieViewModel` 中删除观察 `popularMovies` 和 `error` 的代码行。添加以下内容以收集来自
    `MovieViewModel` 的 Flow：
- en: '[PRE39]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Run the application. The app will display the list of movies, as shown in the
    following screenshot:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序。应用将显示电影列表，如下面的截图所示：
- en: '![Figure 14.5 – The app displaying popular movies](img/B19411_14_011.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.5 – 显示流行电影的 app](img/B19411_14_011.jpg)'
- en: Figure 14.5 – The app displaying popular movies
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.5 – 显示流行电影的 app
- en: In this exercise, you added Kotlin Flow to an Android project. `MovieRepository`
    returns the list of movies as a Flow, which was collected in `MovieViewModel`.
    `MovieViewModel` uses `StateFlow`, which was then collected in `MainActivity`
    for displaying in RecyclerView.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将 Kotlin Flow 添加到 Android 项目中。`MovieRepository` 返回电影列表作为 Flow，然后在 `MovieViewModel`
    中收集。`MovieViewModel` 使用 `StateFlow`，然后 `MainActivity` 收集它以在 RecyclerView 中显示。
- en: Let’s move on to the next activity.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续下一个活动。
- en: Activity 14.01 – creating a TV Guide app
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动十四点零一 - 创建电视指南应用
- en: A lot of people watch television. Most of the time, though, they are not sure
    what TV shows are currently airing. Suppose you wanted to develop an app that
    can display a list of these shows from the Movie Database API’s `tv/on_the_air`
    endpoint using Kotlin Flow.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人观看电视。不过，大多数时候，他们不确定当前正在播出的电视节目是什么。假设你想开发一个应用程序，该应用程序可以使用 Kotlin Flow 从 Movie
    Database API 的 `tv/on_the_air` 端点显示这些节目的列表。
- en: 'The app will have two screens: the main screen and the details screen. On the
    main screen, you will display a list of the TV shows that are on the air. The
    TV shows will be sorted by name. Clicking on a TV show will open the details screen,
    which displays more information about the selected TV show.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将有两个屏幕：主屏幕和详情屏幕。在主屏幕上，你将显示正在播出的电视节目列表。电视节目将按名称排序。点击一个电视节目将打开详情屏幕，该屏幕显示所选电视节目的更多信息。
- en: 'The following steps are for the completion of the activity:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤是为了完成活动：
- en: Create a new project in Android Studio and name it `TV Guide`. Set its package
    name.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建一个新的项目，命名为 `TV Guide`。设置其包名。
- en: Add the `INTERNET` permission in the `AndroidManifest.xml` file.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `AndroidManifest.xml` 文件中添加 `INTERNET` 权限。
- en: Add the dependencies for Retrofit, Coroutines, Moshi, Lifecycle, and other libraries
    in your `app/build.gradle` file.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `app/build.gradle` 文件中添加 Retrofit、Coroutines、Moshi、Lifecycle 和其他库的依赖项。
- en: Add a `layout_margin` dimension value.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `layout_margin` 尺寸值。
- en: Create a `view_tv_show_item.xml` layout file with `ImageView` for the poster
    and `TextView` for the name of the TV show.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `view_tv_show_item.xml` 布局文件，其中包含用于海报的 `ImageView` 和用于电视节目名称的 `TextView`。
- en: In the `activity_main.xml` file, remove the `Hello World` TextView and add a
    RecyclerView to the list of TV shows.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `activity_main.xml` 文件中，删除 `Hello World` TextView 并将 RecyclerView 添加到电视节目列表中。
- en: Create a `TVShow` model class.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `TVShow` 模型类。
- en: Create another class named `TVResponse` for the response you get from the API
    endpoint for the TV shows on air.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为从 API 端点获取正在播出的电视节目的响应创建另一个名为 `TVResponse` 的类。
- en: Create a new activity named `DetailsActivity` with `activity_details.xml` as
    the layout file.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `DetailsActivity` 的新活动，其布局文件为 `activity_details.xml`。
- en: Open the `AndroidManifest.xml` file and add the `parentActivityName` attribute
    in the `DetailsActivity` declaration.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `AndroidManifest.xml` 文件，并在 `DetailsActivity` 声明中添加 `parentActivityName`
    属性。
- en: In `activity_details.xml`, add the views for the details of the TV show.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `activity_details.xml` 中添加电视节目详情的视图。
- en: Open `DetailsActivity` and add the code to display the details of the TV show
    selected.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `DetailsActivity` 并添加显示所选电视节目详情的代码。
- en: Create a `TVShowAdapter` adapter class for the list of TV shows.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为电视节目列表创建一个 `TVShowAdapter` 适配器类。
- en: Create a `TelevisionService` class for adding the `Retrofit` method.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `TelevisionService` 类以添加 `Retrofit` 方法。
- en: Create a `TVShowRepository` class with a constructor for `tvService`, and properties
    for `apiKey` and `tvShows`.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `TVShowRepository` 类，其中包含 `tvService` 构造函数以及 `apiKey` 和 `tvShows` 属性。
- en: Create a function to retrieve the list of TV shows from the endpoint.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数以从端点检索电视节目列表。
- en: Create a `TVShowViewModel` class with a constructor for `TVShowRepository`.
    Add the `tvShows` and `error` StateFlow and a `fetchTVShows` function that collects
    the Flow from the repository.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `TVShowViewModel` 类，其中包含 `TVShowRepository` 构造函数。添加 `tvShows` 和 `error`
    StateFlow 以及一个 `fetchTVShows` 函数，该函数收集来自存储库的 Flow。
- en: Create an application class named `TVApplication` with a property for `TVShowRepository`.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `TVApplication` 的应用程序类，其中包含 `TVShowRepository` 属性。
- en: Set `TVApplication` as the value for the application in the `AndroidManifest.xml`
    file.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `AndroidManifest.xml` 文件中将 `TVApplication` 设置为应用程序的值。
- en: Open `MainActivity` and add the code to update the RecyclerView when the Flow
    from `ViewModel` updates its value. Add a function that will open the details
    screen when clicking on a TV show from the list.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainActivity` 并添加代码以在 `ViewModel` 的 Flow 更新其值时更新 RecyclerView。添加一个函数，当点击列表中的电视节目时将打开详情屏幕。
- en: 'Run your application. The app will display a list of TV shows. Clicking on
    a TV show will open the details activity, which displays the show details. The
    main screen and details screen will be similar to the following screenshot:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行你的应用程序。应用程序将显示电视节目列表。点击一个电视节目将打开详情活动，该活动显示节目详情。主屏幕和详情屏幕将与以下截图类似：
- en: '![Figure 14.6 – The main screen and details screen of the TV Guide app](img/B19411_14_05.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.6 – TV Guide 应用程序的主屏幕和详情屏幕](img/B19411_14_05.jpg)'
- en: Figure 14.6 – The main screen and details screen of the TV Guide app
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.6 – TV Guide 应用程序的主屏幕和详情屏幕
- en: Note
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found at [https://packt.link/By7eE](https://packt.link/By7eE).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在 [https://packt.link/By7eE](https://packt.link/By7eE) 找到。
- en: Summary
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter focused on doing background operations with Coroutines and Flow.
    Background operations are used for long-running tasks such as accessing data from
    the local database or a remote server.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍了使用 Kotlin 协程和 Flow 进行后台操作。后台操作用于长时间运行的任务，例如从本地数据库或远程服务器访问数据。
- en: You started with the basics of using Kotlin coroutines, Google’s recommended
    solution for asynchronous programming. You learned that you can make a background
    task into a suspending function with the `suspend` keyword. Coroutines can be
    started with the `async` or `launch` keywords.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你从 Kotlin 协程的基本用法开始，这是 Google 推荐的异步编程解决方案。你了解到你可以使用 `suspend` 关键字将后台任务转换为挂起函数。协程可以通过
    `async` 或 `launch` 关键字启动。
- en: You learned how to create suspending functions and how to start coroutines.
    You also used dispatchers to change the thread where a coroutine runs. Then, you
    used coroutines for performing network calls and modified the data retrieved with
    the `map` and `switchMap` `LiveData` transformation functions.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你学习了如何创建挂起函数以及如何启动协程。你还使用了调度器来改变协程运行的线程。然后，你使用协程进行网络调用，并使用 `map` 和 `switchMap`
    `LiveData` 转换函数修改检索到的数据。
- en: You then moved on to using Kotlin Flow in an Android app to load the data in
    the background. To safely collect flows in the UI layer, prevent memory leaks,
    and avoid wasting resources, you can use `Lifecycle.repeatOnLifecycle` and `Flow.flowWithLifecycle`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你转向在 Android 应用中使用 Kotlin 流来在后台加载数据。为了在 UI 层面上安全地收集流程，防止内存泄漏，并避免资源浪费，你可以使用
    `Lifecycle.repeatOnLifecycle` 和 `Flow.flowWithLifecycle`。
- en: You learned about using Flow Builders to create Flows. The `flow` builder function
    creates a new Flow from a suspending lambda block and then you can send values
    with `emit()`. The `flowOf` function creates a Flow that emits the value or the
    `vararg` values. You can use the `asFlow()` extension function to convert collections
    and functional types into a Flow.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你学习了如何使用 Flow Builders 来创建流程。`flow` 构建函数从一个挂起 lambda 块创建一个新的流程，然后你可以通过 `emit()`
    发送值。`flowOf` 函数创建一个发出值或 `vararg` 值的流程。你可以使用 `asFlow()` 扩展函数将集合和函数类型转换为流程。
- en: Finally, you explored Flow operators and learned how to use them with Kotlin
    Flows. Terminal operators are used to start the collection of the Flow. With Intermediate
    operators, you can transform a Flow into another Flow.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你探索了 Flow 操作符，并学习了如何在 Kotlin 流中使用它们。终端操作符用于启动流的收集。通过中间操作符，你可以将一个流程转换成另一个流程。
- en: In the next chapter, you will learn about architecture patterns. You will learn
    about patterns such as **Model-View-ViewModel** (**MVVM**) and how you can improve
    the architecture of your app.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习关于架构模式的内容。你将学习诸如 **模型-视图-视图模型**（**MVVM**）的模式，以及你如何改进你应用的架构。
