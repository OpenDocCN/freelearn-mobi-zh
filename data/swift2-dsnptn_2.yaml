- en: Chapter 2. Structural Patterns – Decorator, Proxy, and Bridge
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章 结构型模式 - 装饰器、代理和桥接
- en: 'After reviewing the five creational patterns in the previous chapter, we will
    now talk about another category of patterns: the structural patterns. There are
    seven patterns to talk about; these patterns ease the design by identifying a
    simple way to realize relationships between entities.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章回顾了五种创建型模式之后，我们现在将讨论另一类模式：结构型模式。有七个模式要讨论；这些模式通过识别实体之间关系实现的一种简单方式来简化设计。
- en: We will see how these patterns help you to encapsulate the composition of objects
    through the use of an interface, allowing you to conveniently abstract your system
    as the creational pattern does to encapsulate the creation of objects. Structural
    patterns highlight the use of interfaces.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到这些模式如何通过使用接口来封装对象的组合，从而方便地抽象你的系统，就像创建型模式封装对象的创建一样。结构型模式强调了接口的使用。
- en: You will see how the composition is designed; we will not interfere with the
    object itself but with the one that will transfer the structuration. This second
    object is strongly related to the first one. Indeed, the first object presents
    the interface to the client and manages its relationship with the second object,
    which, manages the composition and doesn't have any interfaces with clients.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到组合是如何设计的；我们不会干扰对象本身，而是会干扰那个将传递结构化的对象。这个第二个对象与第一个对象有很强的关联。确实，第一个对象向客户端展示接口并管理它与第二个对象的关系，而第二个对象管理组合，并且不与客户端有任何接口。
- en: One important thing to make a note of is that this structuration allows a great
    flexibility to your system by allowing dynamic modification of the composition.
    Indeed, we can substitute an object with another if both inherit the same class
    and use the same interface.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一个重要事项是，这种结构化通过允许动态修改组合，为你的系统提供了极大的灵活性。确实，如果两个对象继承自相同的类并使用相同的接口，我们可以用另一个对象替换它。
- en: Static and dynamic composition
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态和动态组合
- en: We can have several possible implementations. The classic way to design this
    is to differentiate these implementations in subclasses. In this case, we will
    provide an interface from where our classes will implement this interface.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以有几种可能的实现。设计这种模式的一种经典方法是区分这些实现，在子类中。在这种情况下，我们将提供一个接口，我们的类将实现这个接口。
- en: 'This solution consists of a static composition. Indeed, once the implementation
    class of an object is chosen, we can no longer change it. The following diagram
    is the implementation of an object by heritage:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决方案由静态组合组成。确实，一旦选择了对象的实现类，我们就不能再更改它。下面的图展示了通过继承实现对象的实现：
- en: '![Static and dynamic composition](img/4852_02_01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![静态和动态组合](img/4852_02_01.jpg)'
- en: Another way is to separate the implementation in another object. The implementation
    parts are managed by an instance of the `ConcreteImplementationA` class or by
    the `ConcreteImplementationB` class. This reference is referred by the `implementation`
    attribute. This instance can then be easily substituted by another instance at
    runtime. This composition is dynamic.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是将在另一个对象中分离实现。实现部分由`ConcreteImplementationA`类的实例或`ConcreteImplementationB`类管理。这个引用通过`implementation`属性进行引用。这个实例可以在运行时轻松地被另一个实例所替代。这种组合是动态的。
- en: The following UML class diagram shows us clearly how to structure your objects
    using a dynamic composition. The `ConcreteImplementation` class can be switched
    at runtime, without having to modify the `Realization` object.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的UML类图清楚地展示了如何使用动态组合来结构化你的对象。`ConcreteImplementation`类可以在运行时切换，而不需要修改`Realization`对象。
- en: 'We can eventually modify the realization object, without having to modify our
    original object, as shown in the following diagram:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终可以修改实现对象，而不需要修改原始对象，如下面的图所示：
- en: '![Static and dynamic composition](img/4852_02_02.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![静态和动态组合](img/4852_02_02.jpg)'
- en: In this chapter, you'll see how to use this solution with the bridge pattern.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将看到如何使用桥接模式来使用这个解决方案。
- en: 'The discovery of the structural patterns will span three chapters. In this
    chapter, we will introduce you to three of them:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 结构型模式的研究将跨越三章。在本章中，我们将介绍其中的三个：
- en: The decorator pattern
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰器模式
- en: The proxy pattern
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理模式
- en: The bridge pattern
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桥接模式
- en: These three patterns provide a mechanism of adding states and behaviors dynamically,
    controlling the creation and access of objects, and keeping the specification
    and implementation separate.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种模式提供了一种动态添加状态和行为的机制，控制对象的创建和访问，并保持规范和实现分离。
- en: 'The objectives of the three structural patterns that we will see in this chapter
    are described in the following table:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将看到的三个结构模式的目的是在以下表格中描述：
- en: '| Pattern | Objective |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 模式 | 目标 |'
- en: '| --- | --- |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| The decorator pattern | This pattern allows you to dynamically add new behaviors
    and functionalities to the object. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 装饰者模式 | 这种模式允许您动态地向对象添加新的行为和功能。|'
- en: '| The proxy pattern | This pattern is a substitute of another object. It provides
    a behavior that can adapt to the optimization or security needs. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 代理模式 | 这种模式是另一个对象的替代品。它提供了一种可以适应优化或安全需求的行为。|'
- en: '| The bridge pattern | This pattern decouples an abstraction from its implementation,
    enabling them to vary independently. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 桥接模式 | 这种模式解耦了抽象与其实现，使它们能够独立变化。|'
- en: The decorator pattern
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰者模式
- en: The first structural pattern that we will discuss is the decorator pattern.
    It introduces you to the object substitution by adding new functionalities or
    behaviors.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的第一个结构模式是装饰者模式。它通过添加新的功能或行为来介绍对象替代。
- en: Roles
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 角色
- en: The main objective of this pattern is to dynamically add new functionalities
    to an object. The interface of the object will not be modified, so from the client's
    perspective, this is fully transparent.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的主要目标是动态地向对象添加新的功能。对象的接口将不会修改，因此从客户端的角度来看，这是完全透明的。
- en: This pattern is an alternative to the addition of a subclass that adds functionalities
    to its parent class. A key implementation point in the decorator pattern is that
    decorators both inherit the original class and contain an instantiation of it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式是向父类添加功能的子类添加的替代品。装饰者模式的一个关键实现点是装饰者既继承原始类，又包含其实例。
- en: 'This pattern can be used when:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式可以在以下情况下使用：
- en: A system adds dynamically new functionalities to an object, without having to
    modify its interface, which means without having to modify the client of this
    object
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个系统可以动态地向对象添加新的功能，而不必修改其接口，这意味着不必修改该对象的客户端
- en: A system manages the behavior that can be dynamically removed
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个系统管理可以动态移除的行为
- en: The use of inheritance is not a good option because of an already complex class
    hierarchy
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于已经有一个复杂的类层次结构，使用继承不是一个好的选择
- en: Design
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计
- en: 'The generic UML class diagram of the decorator pattern is quiet simple: The
    `ConcreteComponent` and `AbstractDecorator` classes share the same interface that
    have the same method name. Our `AbstractDecorator` class defines a constructor
    where we pass our `Abstractcomponent` class as an argument. Then, in our `ConcreteDecorator`
    class, we reroute the operation call to the `additionalOperation` methods to add
    new functionalities or behaviors to the original component, as shown in the following
    diagram:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰者模式的通用UML类图相当简单：`ConcreteComponent` 和 `AbstractDecorator` 类共享相同的接口，具有相同的方法名。我们的
    `AbstractDecorator` 类定义了一个构造函数，其中我们传递我们的 `Abstractcomponent` 类作为参数。然后，在我们的 `ConcreteDecorator`
    类中，我们将操作调用重定向到 `additionalOperation` 方法，以向原始组件添加新的功能或行为，如图所示：
- en: '![Design](img/4852_02_03.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![设计](img/4852_02_03.jpg)'
- en: Participants
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参与者
- en: 'In the preceding diagram, there are four participants in this pattern:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，这个模式中有四个参与者：
- en: '`AbstractComponent`: This is the common interface to components and decorators.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AbstractComponent`：这是组件和装饰器的公共接口。'
- en: '`ConcreteComponent`: This is the main object to which we want to add behaviors
    and/or functionalities.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcreteComponent`：这是我们想要添加行为和/或功能的主要对象。'
- en: '`AbstractDecorator`: This abstract class contains a reference to a component.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AbstractDecorator`：这个抽象类包含对组件的引用。'
- en: '`ConcreteDecoratorA` and `ConcreteDecoratorB`: These are the concrete subclasses
    of `AbstractDecorator`. These classes implement the functionalities added to the
    component.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcreteDecoratorA` 和 `ConcreteDecoratorB`：这些是 `AbstractDecorator` 的具体子类。这些类实现了添加到组件的功能。'
- en: Collaboration
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协作
- en: When a decorator receives a message that must reach the component, it redirects
    the message by making a prior or posterior operation to that redirection.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当装饰者收到必须到达组件的消息时，它会通过先前的或后续操作将该消息重定向。
- en: Sample
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 样例
- en: 'To illustrate this pattern, we will take a simple example. Let''s suppose that
    you have a drawing software that enables you to draw some shapes on the screen:
    a rectangle and square.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这个模式，我们将举一个简单的例子。假设你有一个绘图软件，它允许你在屏幕上绘制一些形状：一个矩形和一个正方形。
- en: You already know how to draw these shapes. Now, you need to add a new functionality
    that will add a rounded angle to your shapes. To do this, you need to decide which
    decorator pattern you need to use that will allow you to not to interfere with
    the existing class method signature.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道如何绘制这些形状。现在，你需要添加一个新功能，该功能将为你的形状添加一个圆角。为此，你需要决定使用哪种装饰器模式，这将允许你不对现有类方法签名进行干扰。
- en: Implementation
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'First, we will create our interface that defines the shape. We will simulate
    a `Draw()` operation. In fact, the method will return a string that tells us what
    is drawn:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建我们的界面，它定义了形状。我们将模拟一个 `Draw()` 操作。实际上，该方法将返回一个字符串，告诉我们绘制了什么：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we will create our two concrete classes that implement the `IShape` interface.
    We will have the `Square` and `Rectangle` classes. They both implement the `draw`
    function. This function returns the shape that is currently drawn:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建我们的两个具体类，它们实现了 `IShape` 接口。我们将有 `Square` 和 `Rectangle` 类。它们都实现了 `draw`
    函数。此函数返回当前绘制的形状：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Our classes are ready; now, we prepare our abstract `ShapeDecorator` class
    that defines the structure of our future concrete decorators. This class implements
    the `IShape` interface too, so the `Draw()` function must be present. Nevertheless,
    Swift doesn''t have an abstract class, so we implement the draw method, but we
    force an exception to tell us that this method must be implemented. The `ShapeDecorator`
    class will not be used by the client itself. The client will call the `ConcreteDecorator`
    object to add a new functionality to its shape:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好了类；现在，我们准备我们的抽象 `ShapeDecorator` 类，该类定义了我们未来具体装饰器的结构。这个类也实现了 `IShape`
    接口，因此 `Draw()` 函数必须存在。然而，Swift 没有抽象类，所以我们实现了 draw 方法，但强制抛出异常来告诉我们必须实现此方法。`ShapeDecorator`
    类本身不会被客户端使用。客户端将调用 `ConcreteDecorator` 对象来为其形状添加新功能：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we add our concrete decorator class that inherits from the `ShapeDecorator`
    abstract class. We add our new `setRoundedCornerShape` functionality to this class
    and override the `draw` function to return the shape that is drawn, but with rounded
    corners:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们添加我们的具体装饰器类，该类继承自 `ShapeDecorator` 抽象类。我们将新的 `setRoundedCornerShape` 功能添加到这个类中，并重写
    `draw` 函数以返回绘制的形状，但具有圆角：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Usage
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用
- en: Now, here is the easy part that shows us how to use all of the code, we already
    have written, from the client perspective.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这是容易的部分，它展示了从客户端的角度如何使用我们已编写的所有代码。
- en: 'We first create our two concrete shapes:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建我们的两个具体形状：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we want to have some shapes with rounded corners. To do this, we simply
    call the `ConcreteDecorator` class that interests us, the `RoundedCornerShapeDecorator`
    class, and pass a new shape (`Rectangle` or `Square`) as an argument of the constructor:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要一些具有圆角的形状。为此，我们只需调用我们感兴趣的 `ConcreteDecorator` 类，即 `RoundedCornerShapeDecorator`
    类，并将新的形状（`Rectangle` 或 `Square`）作为构造函数的参数传递：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we simulate the `Draw()` method on the screen of our shapes by calling
    the `draw` operation:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们通过调用 `draw` 操作来模拟我们的形状屏幕上的 `Draw()` 方法：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The Playground will return the following result:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 操场将返回以下结果：
- en: '![Usage](img/4852_02_04.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![使用](img/4852_02_04.jpg)'
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Swift allows you to implement the decorator pattern using the concept of extensions.
    This allows you to add additional methods to concrete classes or constructs, without
    having to subclass or alter the original one. With extensions, you can add new
    methods but no new properties, as opposed to a subclass.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 允许你使用扩展的概念来实现装饰器模式。这允许你向具体类或结构添加额外的方法，而无需子类化或修改原始类。与子类不同，使用扩展可以添加新方法但不能添加新属性。
- en: The proxy pattern
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理模式
- en: The second pattern that we will talk about in this chapter is the proxy pattern.
    It is often used for security or optimization purposes.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将讨论的第二种模式是代理模式。它通常用于安全或优化目的。
- en: Roles
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 角色
- en: The objective of the proxy pattern is to substitute an object (the subject)
    with another one that will control its access. The object that substitutes the
    subject shares the same interface, so it is transparent from the consumer's perspective.
    The proxy is often a small (public) object that stands in for a more complex (private)
    object that is activated once certain circumstances are clear. The proxy adds
    a level of indirection by accepting requests from a client object and passing
    them to the real subject as necessary.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 代理模式的目标是用另一个对象（主题）替换对象，该对象将控制其访问。替代主题的对象共享相同的接口，因此对消费者来说是透明的。代理通常是一个小的（公共）对象，代表一个更复杂的（私有）对象，一旦某些情况明确，就会激活。代理通过接受来自客户端对象的请求并将它们传递给真实主题作为必要的方式，增加了一层间接性。
- en: 'The proxy pattern is used in object-oriented programming. There are several
    types of proxies, which are as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 代理模式用于面向对象编程。有几种类型的代理，如下所示：
- en: '**A virtual proxy**: This allows you to create a "big" object at the appropriate
    time (used when the creation process is slow)'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**虚拟代理**：这允许你在适当的时候创建一个“大”对象（用于创建过程缓慢时）'
- en: '**A remote proxy**: This allows you to access an object that is available on
    another environment (such as on a multiplayer game server)'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**远程代理**：这允许你访问另一个环境（如多人游戏服务器）上可用的对象'
- en: '**An authentication proxy**: This check whether the access permission for a
    request is correct or not'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证代理**：这检查请求的访问权限是否正确'
- en: Design
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计
- en: The following class diagram is quite simple; we have an interface that defines
    our subject, both the proxy and `RealSubject` implement this interface.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类图相当简单；我们有一个定义我们的主题（代理和`RealSubject`）的接口。
- en: 'The client will call the proxy, not the `RealSubject` object himself. The proxy
    contains a reference to the `RealSubject` object. When the proxy receives a request,
    it can analyze it, and if the request is considered to be valid, it can be rerouted
    to the `RealSubject.request()` method. The proxy can decide when to create, or
    not, the `RealSubject` object avoiding to have to manage too big object in memory
    if useless. The following figure represent the generic class diagram of the proxy
    pattern:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端将调用代理，而不是直接调用`RealSubject`对象。代理包含对`RealSubject`对象的引用。当代理收到请求时，它可以分析它，如果认为请求是有效的，它可以将其重新路由到`RealSubject.request()`方法。代理可以决定何时创建或不需要创建`RealSubject`对象，以避免在内存中管理无用的过大对象。以下图表示代理模式的通用类图：
- en: '![Design](img/4852_02_05.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![设计](img/4852_02_05.jpg)'
- en: Participants
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参与者
- en: 'There are only three participants in this pattern:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式中只有三个参与者：
- en: '`ISubject`: This is the common interface of the `Proxy` and `RealSubject` object'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ISubject`：这是`Proxy`和`RealSubject`对象的公共接口'
- en: '`RealSubject`: This is the object that is controlled and manipulated by the
    proxy.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RealSubject`: 这是被代理控制并操作的对象。'
- en: '`Proxy`: This is the object that substitutes `RealSubject`. It has the same
    interface of the `RealSubject` object (the `ISubject` interface). It creates,
    controls, enhances, and authenticates access to a `RealSubject` object.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Proxy`：这是替代`RealSubject`的对象。它具有与`RealSubject`对象相同的接口（`ISubject`接口）。它创建、控制、增强和验证对`RealSubject`对象的访问。'
- en: Collaboration
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协作
- en: The proxy receives the incoming request from a client instead of the `RealSubject`.
    If necessary, the message is then delegated to the `RealSubject` object. In this
    case, prior to the delegation, the proxy creates the `RealSubject` object if it
    has not already been done.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 代理接收来自客户端的传入请求，而不是`RealSubject`。如果需要，消息随后被委托给`RealSubject`对象。在这种情况下，在委托之前，如果尚未完成，代理会创建`RealSubject`对象。
- en: Illustration
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插图
- en: We are developing a new software; this software presents a video catalog in
    a list. For each video in the list, we have a placeholder for the video and a
    description. The placeholder of the video first displays a screenshot of the video.
    If we click on this image, the video will be launched.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在开发一个新的软件；这个软件以列表的形式展示视频目录。对于列表中的每个视频，我们都有一个视频占位符和描述。视频的占位符首先显示视频的截图。如果我们点击这张图片，视频将被启动。
- en: The video catalog contains videos, so it will be too heavy to have all of these
    videos in memory and transferring them through the network will take too long.
    The proxy pattern will help us organize all of this. We will create the subject
    only when we will need it, once the screenshot is clicked.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 视频目录包含视频，因此如果将这些视频全部保存在内存中，将会很重，而且通过网络传输这些视频将花费很长时间。代理模式将帮助我们组织所有这些。我们将在需要时创建主题，一旦点击截图。
- en: 'The two advantages are as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 两个优点如下：
- en: The list is loaded quickly, mainly if it is downloaded from the network
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表加载迅速，主要是在从网络下载时
- en: Only videos that we want to watch are created, loaded, and played
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只创建、加载和播放我们想要观看的视频
- en: The `Screenshot` class that represents the video is called the proxy of the
    `Video` subject. The proxy substitutes the `Video` subject for the display. The
    `Screenshot` class implements the same interface as the `Video` subject (the `RealSubject`
    object).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 代表视频的`Screenshot`类被称为`Video`主题的代理。代理代替显示`Video`主题。`Screenshot`类实现了与`Video`主题相同的接口（即`RealSubject`对象）。
- en: 'In our example, the proxy pattern design is as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，代理模式设计如下：
- en: '![Illustration](img/4852_02_06.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![插图](img/4852_02_06.jpg)'
- en: When the proxy receives the `display()` message, it will display the video if
    this one already exists. If it receives the `click()` message, it will first create
    the `Video` subject and then load the video.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当代理接收到`display()`消息时，如果该视频已存在，它将显示视频。如果它接收到`click()`消息，它将首先创建`Video`主题并加载视频。
- en: Implementation
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: We will first define the interface that will be used by our proxy and real subject.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定义我们的代理和真实主题将使用的接口。
- en: When we simulate the real behavior of these methods with Playground, these methods
    return a string, telling us what the code is expected to do. We can ensure what
    we are coding is correct by checking the message returned by Playground.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用Playground模拟这些方法的真实行为时，这些方法返回一个字符串，告诉我们代码预期要做什么。我们可以通过检查Playground返回的消息来确保我们编写的代码是正确的。
- en: 'The interface will have only two methods: `click()` and `display()`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接口将只有两种方法：`click()`和`display()`：
- en: '[PRE7]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `RealSubject` object is represented here with the video class. We implement
    the interface and display the message according to the action:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这里用视频类表示`RealSubject`对象。我们实现接口并根据动作显示消息：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The proxy now implements the same interface as the `RealSubject` object: the
    `IAnimation` interface but has the intelligence to create the `RealSubject` object,
    here the `video` object, when needed in the `click` method:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 代理现在实现了与`RealSubject`对象相同的接口：`IAnimation`接口，但具有在`click`方法中需要时创建`RealSubject`对象（这里指`video`对象）的智能：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Usage
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用方法
- en: The cool part is to simulate the client.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最酷的部分是模拟客户端。
- en: We first create a new proxy, `Screenshot`, and then we simulate the operation.
    We call `display` from the proxy. As the video is not created or loaded, it is
    the screenshot that will be displayed.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个新的代理`Screenshot`，然后模拟操作。我们从代理调用`display`。由于视频尚未创建或加载，所以将显示截图。
- en: 'Then, we simulate a click. We can see that when we call the `click` method,
    the video gets loaded. As the video is created and loaded, we call the `display`
    method, which informs us that the video is now playing (instead of the screenshot
    of the video):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们模拟一个点击。我们可以看到当我们调用`click`方法时，视频被加载。随着视频的创建和加载，我们调用`display`方法，它通知我们视频现在正在播放（而不是视频的截图）：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The result in Playground is as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在Playground中的结果是：
- en: '![Usage](img/4852_02_07.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![使用方法](img/4852_02_07.jpg)'
- en: Note
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Use the proxy pattern when you have objects, which are as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有以下对象时使用代理模式：
- en: Expensive to create
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建成本高昂
- en: Need access control
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要访问控制
- en: Access remote sites
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问远程站点
- en: Need to perform some actions whenever they are accessed
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要在访问时执行某些操作
- en: 'Also, use the proxy pattern when you want to:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当你想要：
- en: Create objects only when their operations are requested
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有在请求操作时才创建对象
- en: Perform checks or housekeeping on objects whenever accessed
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在访问对象时执行检查或维护工作
- en: Have a local object that will refer to a remote object
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有一个本地对象，该对象将引用远程对象
- en: Implement access rights on objects when their operations are requested
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在请求对象操作时对对象实施访问权限
- en: The bridge pattern
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 桥接模式
- en: Remember that, at the beginning of the chapter, we discussed dynamic composition
    that allows you to change the implementation of an object at runtime. The bridge
    pattern is another structural pattern that allows this.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在章节开头，我们讨论了动态组合，它允许你在运行时更改对象的实现。桥接模式是另一种允许这种操作的构造型模式。
- en: Roles
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 角色
- en: The bridge pattern decouples an abstraction from its implementation. This means
    that this pattern separates the implementation of an object from its representation
    and interface.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接模式解耦了抽象与其实现。这意味着这个模式将对象的实现与其表示和接口分离。
- en: Thus, firstly, the implementation can fully be encapsulated, and secondly, the
    implementation and representation can independently change, without having any
    constraints between them.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先，实现可以完全封装，其次，实现和表示可以独立改变，而它们之间没有任何约束。
- en: 'This pattern can be used:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式可以用作：
- en: To avoid a strong link between the object representation and its implementations
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免对象表示与其实现之间的强链接
- en: To avoid any impact between the interaction of the objects and their clients
    when the implementations of objects are modified
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免在对象及其客户端之间的交互受到对象实现修改的影响
- en: To allow the representation of objects and their implementations to keep their
    extension capability by creating new subclasses
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了允许通过创建新的子类来保持对象及其实现的可扩展性
- en: To avoid to obtain very complex classes hierarchies
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了避免获得非常复杂的类层次结构
- en: Design
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计
- en: 'In the class diagram of the bridge pattern, the separation between the abstraction
    and the implementation is very well represented—notice the left-hand side and
    right-hand side of the following diagram:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在桥接模式的类图中，抽象和实现之间的分离得到了很好的体现——注意以下图示的左侧和右侧：
- en: '![Design](img/4852_02_08.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![设计](img/4852_02_08.jpg)'
- en: Participants
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参与者
- en: 'The bridge pattern uses a minimum of four participants:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接模式使用最少的四个参与者：
- en: The `AbstractClass` represents the domain objects. This class contains the interface
    used by clients and contains a reference to an object that implements the `Implementation`
    interface.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AbstractClass` 代表领域对象。这个类包含客户端使用的接口，并包含一个实现 `Implementation` 接口的对象的引用。'
- en: The `ConcreteClass` is the class that implements the methods defined in the
    `AbstractClass`.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcreteClass` 是实现 `AbstractClass` 中定义的方法的类。'
- en: The `ImplementationBase` class defines the method signature of the concrete
    implementation classes. The methods defined here differ from the methods of the
    `Abstract` class. These two sets of methods are different. Generally, methods
    of the `AbstractClass` are high-level methods, while the methods of the `implementation`
    class are low-level methods.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ImplementationBase` 类定义了具体实现类的函数签名。这里定义的方法与 `Abstract` 类的方法不同。这两组方法不同。通常，`AbstractClass`
    的方法是高级方法，而 `implementation` 类的方法是低级方法。'
- en: The `ConcreteImplementationA` (`B` …) classes are concrete classes that realize
    methods introduced in the `ImplementationBase` interface.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcreteImplementationA` (`B` …) 类是具体类，它们实现了在 `ImplementationBase` 接口中引入的方法。'
- en: Tip
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `ImplementationBase` interface represents the bridge.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImplementationBase` 接口代表桥。'
- en: Collaboration
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协作
- en: The operation of `AbstractClass` and its subclasses invokes the methods defined
    in the `ImplementationBase` interface, which represent the bridge.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbstractClass` 及其子类操作调用 `ImplementationBase` 接口中定义的方法，这些方法代表桥。'
- en: Illustration
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: We should be able to turn on the light or TV using the same object. Once my
    code to turn on the light or TV will be implemented in my client, I don't need
    to modify it if the `ConcreteImplementation` structure changes. Using the bridge
    pattern, I will use an object that inherits from `AbstractClass`. This object
    contains a method that the client will consume. This method doesn't turn on the
    TV, but it calls the method defined in the `ImplementationBase` class; thus, depending
    on the object that our abstract object uses, it will run the actions that are
    defined in the `ConcreteImplementation` class, which are represented by the TV
    or the light.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该能够使用同一个对象来打开灯或电视。一旦我的代码实现了打开灯或电视，如果 `ConcreteImplementation` 结构发生变化，我就不需要修改它。使用桥接模式，我将使用一个继承自
    `AbstractClass` 的对象。这个对象包含一个客户端将使用的方法。这个方法不会打开电视，但它调用在 `ImplementationBase` 类中定义的方法；因此，根据我们的抽象对象使用的对象，它将运行在
    `ConcreteImplementation` 类中定义的操作，这些操作由电视或灯表示。
- en: Implementation
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: Given the preceding problem, we will first define the method and a property
    that contains the object we want to manipulate. This object will implement the
    `ImplementationBase` interface, which represents the bridge.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 给定前面的问题，我们首先定义一个方法和一个包含我们想要操作的对象的属性。这个对象将实现`ImplementationBase`接口，它代表桥接。
- en: 'The object that will be manipulated by clients will have a `turnOn()` method.
    This is the only method known by the client:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端将要操作的对象将有一个`turnOn()`方法。这是客户端所知的唯一方法：
- en: '[PRE11]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we will define the `ImplementationBase` interface. It contains the `run()`method
    that each `ConcreteImplementation` class will implement:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将定义`ImplementationBase`接口。它包含每个`ConcreteImplementation`类将实现的`run()`方法：
- en: '[PRE12]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Our interfaces are now ready; we can create the `RemoteControl` class that
    our clients will use. Depending on the object referred in the `concreteImpl` property,
    the `turnOn()` method will call the run method of the `concreteImpl` object. To
    obtain a reference to the `concreteImpl` object, we will add an argument to the
    constructor (`init`) of the `RemoteControl` class:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建客户端将使用的`RemoteControl`类；根据`concreteImpl`属性中引用的对象，`turnOn()`方法将调用`concreteImpl`对象的run方法。为了获取`concreteImpl`对象的引用，我们将在`RemoteControl`类的构造函数（`init`）中添加一个参数：
- en: '[PRE13]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, we implement our `ImplementationBase` class for the `TV` and `Light`
    classes. A `run()` method is needed in each of them. The `run()` method contains
    all the needed logic that will permit you to turn on the light or TV. In our example,
    we only display a text that indicates the action has been completed:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们为`TV`和`Light`类实现我们的`ImplementationBase`类。每个类都需要一个`run()`方法。`run()`方法包含所有需要的逻辑，这将允许你打开灯或电视。在我们的例子中，我们只显示一个指示操作已完成的文本：
- en: '[PRE14]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Usage
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用
- en: 'From the client''s perspective, we will use our `RemoteControl` abstraction
    class, pass the final object to the constructor when we want to manipulate (the
    `Light` or `TV` class), and call the `turnOn()` method of the `RemoteControl`
    object to execute the action:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 从客户端的角度来看，我们将使用我们的`RemoteControl`抽象类，在我们想要操作（`Light`或`TV`类）时将最终对象传递给构造函数，并调用`RemoteControl`对象的`turnOn()`方法来执行操作：
- en: '[PRE15]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Thanks to Playground, we can now see the live result, which is as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了Playground，我们现在可以看到实时结果，如下所示：
- en: '![Usage](img/4852_02_09.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![使用](img/4852_02_09.jpg)'
- en: 'We can see two messages on the right-hand side of our Playground file: **tv
    turned on** and **light turned on**, which means that the `run()` method of each
    final object has been correctly executed.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Playground文件的右侧看到两条消息：**电视已打开**和**灯已打开**，这意味着每个最终对象的`run()`方法已经正确执行。
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'We discussed the three structural patterns in this chapter: the decorator pattern,
    the proxy pattern, and the bridge pattern. From a high-level perspective, all
    of them help you extend classes without using inheritance, but using a dynamic
    composition of its class hierarchy.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们讨论了三种结构模式：装饰者模式、代理模式和桥接模式。从高层次来看，它们都帮助你在不使用继承的情况下扩展类，而是使用其类层次结构的动态组合。
- en: Extending our original class has some impact on our original object except for
    the proxy pattern where it remains completely unchanged. The decorator pattern
    that needs to be designed needs to have the original class already developed because
    every concrete decorator needs to implement an interface based on the original
    object structure. The bridge pattern is more closely coupled, and there is an
    understanding that the original object must incorporate considerable references
    to the rest of the system.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展我们的原始类对我们的原始对象有一些影响，除了代理模式外，它保持完全不变。需要设计的装饰者模式需要原始类已经开发，因为每个具体的装饰者都需要根据原始对象结构实现一个接口。桥接模式更紧密地耦合，有一种理解是原始对象必须包含对整个系统的大量引用。
- en: We also discussed all the patterns that rely on rerouting operations. We learned
    that the rerouting is always done from the new code back to the original.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了所有依赖于重路由操作的模式。我们了解到重路由总是从新代码回溯到原始代码。
- en: It is important to note that in real-time applications, where performance is
    required, the overhead of the time for rerouting the operations might not be acceptable.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，在需要性能的实时应用中，重路由操作所需的时间开销可能不可接受。
- en: In the next chapter, we will continue our discovery of structural patterns with
    the composite and flyweight patterns, which can be applied to systems that have
    huge data objects.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续我们的结构模式探索之旅，探讨组合模式和享元模式，这些模式可以应用于拥有大量数据对象的系统。
