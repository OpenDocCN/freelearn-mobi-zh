- en: Chapter 8. Introduction to Swift
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. Swift简介
- en: 'Apple held their **Worldwide Developers Conference** (**WWDC**) for 2014 on
    June 2 at Moscone West in San Francisco, which was the same venue as previous
    years. They announced a slew of new APIs, technologies for games such as Metal,
    new operating systems for iOS (iOS 8) and Mac (Yosemite), and the most important
    announcement for iOS developers in 2014, that is, the announcement of Swift, a
    new programming language, which some say is meant to replace Objective-C, as Objective-C
    was introduced in 1983 and is showing its age due to its long history. Swift is
    meant to be an easy and simple to learn programming language that will lower the
    barrier to entry for developers who are intimidated by Objective-C. However, what
    is Swift and what is good about it? How far does it differ from Objective-C, and
    finally, how easy is it to learn Swift? These are the questions that we will cover
    in this chapter, and to start things off, here is a list of topics we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果公司在2014年6月2日在旧金山的Moscone West举办了他们的**全球开发者大会**（**WWDC**），与往年一样，地点设在同一个场馆。他们宣布了一系列新的API、用于游戏的技术如Metal、新的iOS（iOS
    8）和Mac（Yosemite）操作系统，以及2014年对iOS开发者来说最重要的公告，即Swift编程语言的发布，有些人认为Swift是为了取代Objective-C，因为Objective-C自1983年推出以来，由于其历史悠久，已经开始显得有些过时。Swift旨在成为一个易于学习和简单的编程语言，这将降低那些被Objective-C吓到的开发者的入门门槛。然而，Swift是什么？它有哪些优点？它与Objective-C有多大的不同？最后，学习Swift有多容易？这些问题我们将在本章中探讨，为了开始，以下是我们将要涵盖的主题列表：
- en: Welcome to Swift
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 欢迎来到Swift
- en: Swift basics
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift基础知识
- en: Memory management
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存管理
- en: Welcome to Swift
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 欢迎来到Swift
- en: Swift is actually not a new language, as Apple started the development of Swift
    back in 2010\. Since programming languages such as Ruby, Python, Haskell, Rust,
    and so on have surged in popularity, Swift was developed using language ideas
    from these popular languages. As Apple describes Swift as *Objective-C without
    the C*, you can consider Swift as a language that is a reimagining of Objective-C
    using modern concepts and syntax borrowed from languages such as JavaScript, but
    still keeping the essence and spirit of Objective-C.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Swift实际上并不是一门新语言，因为苹果公司早在2010年就开始了Swift的开发。随着像Ruby、Python、Haskell、Rust等编程语言的流行，Swift的开发使用了这些流行语言的语言理念。正如苹果公司将Swift描述为“没有C的Objective-C”，你可以将Swift视为一种语言，它是对Objective-C的重新构想，使用了来自JavaScript等语言的现代概念和语法，同时仍然保留了Objective-C的本质和精神。
- en: Swift does away with pointers and makes memory management opaque to the developer
    through the use of ARC so that they can focus on their iOS application creation
    and not worry about memory management most of the time. Swift uses ARC and not
    the GC method found in Java. This means that Swift can still leak memory if you
    are not careful by using cyclic strong references. Smalltalk is a programming
    language released in 1972 that has heavily influenced Objective-C in terms of
    architecture, such as message passing. And the Smalltalk aspect of Objective-C,
    such as method calls, has been replaced with dot notation and a namespace system
    that is reminiscent of Java and C#. However, Swift is not a totally radical departure
    from Objective-C. Key Objective-C concepts such as protocols, closures, and categories
    are still present in Swift, except that the syntax is much cleaner and crisper.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Swift通过使用ARC（自动引用计数）来消除指针，并通过这种方式使内存管理对开发者来说是透明的，这样他们就可以专注于iOS应用程序的开发，而无需担心大多数时候的内存管理。Swift使用ARC而不是Java中发现的GC（垃圾回收）方法。这意味着如果你不小心使用循环强引用，Swift仍然可能会泄漏内存。Smalltalk是一种在1972年发布的编程语言，它在架构方面对Objective-C产生了重大影响，例如消息传递。Objective-C中的Smalltalk方面，如方法调用，已被点符号和类似Java和C#的命名空间系统所取代。然而，Swift并不是完全脱离Objective-C的。Objective-C的关键概念，如协议、闭包和类别，仍然存在于Swift中，只是语法更加清晰和简洁。
- en: Swift's approach to memory management is that it uses ARC, and one problem with
    ARC is that a developer can unintentionally create a strong reference cycle where
    instances of two different classes include a reference to the other. So, Swift
    provides the weak and unowned keyboards to prevent strong reference cycles from
    occurring.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Swift对内存管理的处理方法是使用ARC，ARC的一个问题是开发者可能会无意中创建一个强引用循环，其中两个不同类的实例都包含对另一个类的引用。因此，Swift提供了弱引用和弱引用键（unowned）来防止强引用循环的发生。
- en: For a seasoned Objective-C programmer who comes from a C or C++ background,
    Swift may seem like a totally new language as it does away with some aspects of
    Objective-C such as verbosity. I am sure that a lot of Objective-C developers
    have experienced "square brackets hell", where simple functionalities need to
    be wrapped with a lot of square brackets, thus rendering the code hard to read,
    and which also runs the risk of introducing bugs into your application. The goal
    of Swift is to let developers harness the power of Objective-C without C. So,
    there are some aspects of Swift that indeed make it easier for a developer, but
    conversely, there are some parts of Swift that do not seem to be fully fleshed
    out yet. However, bear in mind that at the time of writing this, Swift is still
    in beta and Apple may still introduce a lot of changes in the following weeks
    and months. However, with Apple putting its full weight behind Swift, now is a
    good time to start learning some Swift basics. As with all new technology that
    Apple introduces, you will require Xcode 6 beta and higher to run and build your
    Swift code as Xcode 5 does not support Swift. Your Swift code can also run on
    iOS 7 and Mac OS 10.9.3\. So, if you are an Apple developer, you can download
    Xcode 6 beta and install it on your Mac as it will be installed side by side with
    your Xcode 5 and will not override anything or break your current Xcode projects.
    So, let's get cracking.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个有C或C++背景的资深Objective-C程序员来说，Swift可能看起来像一门全新的语言，因为它摒弃了一些Objective-C的方面，例如冗长性。我相信很多Objective-C开发者都经历过“方括号地狱”，其中简单的功能需要用很多方括号包裹，这使得代码难以阅读，并且也可能会将错误引入你的应用程序。Swift的目标是让开发者能够在没有C的情况下利用Objective-C的力量。因此，Swift确实有一些方面让开发者更容易使用，但相反，Swift也有一些部分似乎还没有完全完善。然而，请记住，在撰写本文时，Swift仍然处于beta测试阶段，Apple在接下来的几周和几个月内可能还会引入很多变化。然而，随着Apple全力支持Swift，现在是开始学习一些Swift基础的好时机。就像Apple引入的所有新技术一样，你需要Xcode
    6 beta或更高版本来运行和构建你的Swift代码，因为Xcode 5不支持Swift。你的Swift代码也可以在iOS 7和Mac OS 10.9.3上运行。所以，如果你是苹果开发者，你可以下载Xcode
    6 beta并将其安装在你的Mac上，因为它将与你的Xcode 5并行安装，不会覆盖任何内容或破坏你的当前Xcode项目。那么，让我们开始吧。
- en: Basics of Swift
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swift基础
- en: Swift syntax is very different to Objective-C, while Objective-C has a lot of
    reliance on C and C++ components such as pointers, strong typing, and so on. Swift
    is very similar to popular scripting languages such as Python and Ruby with regards
    to terseness and variable declaration. So, let's look at some basics of Swift
    to get acquainted with it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Swift的语法与Objective-C非常不同，虽然Objective-C有很多依赖于C和C++组件，如指针、强类型等。Swift在简洁性和变量声明方面与流行的脚本语言（如Python和Ruby）非常相似。让我们看看Swift的一些基础知识，以便熟悉它。
- en: Variable declaration
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量声明
- en: 'Swift does away with the need to remember ints, floats, NSStrings, and so on
    and consolidates all of these type of variables under one type, and that is of
    the type `var`. If you are familiar with JavaScript, then the `var` keyword should
    not be unfamiliar to you. Swift supports the type inference, where depending on
    the value that you assign to a variable, it will infer its type:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Swift摒弃了记住`int`、`float`、`NSString`等的需求，并将所有这些类型的变量合并为一种类型，即`var`类型。如果你熟悉JavaScript，那么`var`关键字应该不会陌生。Swift支持类型推断，根据你分配给变量的值，它会推断其类型：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This means that the variable, `welcome`, is inferred to have a string type
    as I assigned the text `Hello world` to it. However, if you want to be specific,
    you can annotate a variable like this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着变量`welcome`被推断为字符串类型，因为我将它赋值为文本`Hello world`。然而，如果你想更具体一些，你可以这样注释一个变量：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then to append two strings together in Swift, you can do the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在Swift中，要将两个字符串连接起来，你可以这样做：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you were using Objective-C, you will need to type out the longer syntax:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前使用的是Objective-C，你需要输入更长的语法：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Swift also supports constants with the keyword `let`. So, to declare a constant,
    you can just type the following syntax:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Swift还支持使用`let`关键字声明常量。因此，要声明一个常量，你只需输入以下语法：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that Swift now infers that `LIFE_MEANING` is an integer as you have assigned
    the value `42` to it. To print out a line of text for logging, which is analogous
    to NSLog from Apple's Cocoa framework, you can use the `println` keyword, whereas
    with NSLog, you need to specify the format specifier such as `%d` for integers,
    `%@` for NSStrings, or `%f` for float/double.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Swift 现在推断 `LIFE_MEANING` 是一个整数，因为你已经将它赋值为 `42`。要打印一行用于日志的文本，类似于 Apple 的
    Cocoa 框架中的 NSLog，你可以使用 `println` 关键字，而使用 NSLog 时，你需要指定格式说明符，例如 `%d` 用于整数，`%@`
    用于 NSStrings，或 `%f` 用于 float/double。
- en: 'There is no need to do this for Swift; you can just use the following syntactical
    examples:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Swift 来说，没有必要这样做；你可以直接使用以下语法示例：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: One thing that has not changed from Objective-C is that comments in Swift are
    denoted by the `//` for single line comments and `/*` and `*/` for multiline comments.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一件没有从 Objective-C 改变的事情是，Swift 中的注释用 `//` 表示单行注释，用 `/*` 和 `*/` 表示多行注释。
- en: Semicolons are also optional. Some of you may want to be pedantic and put a
    semicolon, but personally, I don't like any additional typing than is necessary,
    so I tend to omit the semicolon (;) for my Swift code.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 分号也是可选的。有些人可能想过于严谨，会加上分号，但就我个人而言，我不喜欢比必要的多打任何多余的字符，所以我倾向于在我的 Swift 代码中省略分号 (;)。
- en: '![Variable declaration](img/00034.jpeg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![变量声明](img/00034.jpeg)'
- en: As with all programming languages, Swift supports an array of operators for
    arithmetic comparison and assignment.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有编程语言一样，Swift 支持用于算术比较和赋值的运算符数组。
- en: All the operators such as `/`, `*`, `+`, and so on perform the same function
    as in Objective-C except that the `+` operator serves a dual function as a string
    concatenation operator if you need to concatenate multiple strings.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 所有如 `/`、`*`、`+` 等运算符的功能与 Objective-C 中相同，只是 `+` 运算符在需要连接多个字符串时还充当字符串连接运算符的双重功能。
- en: 'Swift introduces the concept of closed range operators, which defines a range
    that runs from *x* to *y* and includes the values *x* and *y* if you use it like
    this (*x...y*). For example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 引入了闭区间运算符的概念，它定义了一个从 *x* 到 *y* 的范围，如果你使用它像这样 (*x...y*)，它包括 *x* 和 *y* 的值。例如：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will print out the values **1**, **2**, **3**, **4**, and **5**. As you
    may have noticed by now, this can be used to replace the more verbose tradition
    for loop in Objective-C, which is represented by these lines of code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出值 **1**、**2**、**3**、**4** 和 **5**。正如你可能已经注意到的，这可以用来替换 Objective-C 中更冗长的传统
    for 循环，它由以下代码行表示：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'However, what if you want to do some common `for` loop code to loop through
    an array? Then, you will need a half-closed range operator, which is similar to
    a closed range operator except that there is one dot less (*x..y*):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你想要执行一些常见的 `for` 循环代码来遍历数组呢？那么，你需要一个半开区间运算符，它与闭区间运算符类似，只是少了一个点 (*x..y*)：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As you have seen earlier, Swift also has support for collection types such
    as arrays as shown earlier and dictionaries, which we will cover in the next few
    pages. To start off declaring an array, you just use the following syntax:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如你之前所见，Swift 也支持集合类型，如之前展示的数组以及字典，我们将在接下来的几页中介绍。要开始声明一个数组，你只需使用以下语法：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, there are some properties that can come in handy, among others, such
    as:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，还有一些有用的属性，例如：
- en: '`count`: This returns the number of items in the array'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count`：这个属性返回数组中的项目数量'
- en: '`isEmpty`: This is a Boolean variable that returns true if the count property
    is `0`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isEmpty`：这是一个布尔变量，当计数属性为 `0` 时返回 true'
- en: '`append`: This property will allow you to add an item to the end of an array'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`append`：这个属性将允许你向数组的末尾添加一个项目'
- en: 'Swift provides some helper code to iterating over an array instead of using
    a `for` loop, `while` loop, or `do-while` loop. Array iteration is easier in Swift
    as you just need to do this to do the iteration:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 提供了一些辅助代码来迭代数组，而不是使用 `for` 循环、`while` 循环或 `do-while` 循环。在 Swift 中，数组迭代更容易，因为你只需这样做即可进行迭代：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: No longer do you need to write any verbose and unnecessary code for a `for`,
    `while`, or `do-while` loop as you can use the item variable to access the array.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你不再需要为 `for`、`while` 或 `do-while` 循环编写任何冗长且不必要的代码，因为你可以使用项目变量来访问数组。
- en: Next, we will cover dictionary. The dictionary in Swift is similar to `NSDictionary`
    in Cocoa, in terms of functionality and usage. However, there is a major difference
    in that, whereas in `NSDictionary` and `NSMutableDictionary`, you are allowed
    to use any object as the key and value, which does not provide any information
    about the object nature. In Swift, the type of keys and values in a dictionary
    are always made explicitly clear using explicit type annotation or via type inference.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍字典。在 Swift 中，字典的功能和用法与 Cocoa 中的 `NSDictionary` 类似。然而，有一个主要区别在于，在 `NSDictionary`
    和 `NSMutableDictionary` 中，你可以使用任何对象作为键和值，这并不提供有关对象性质的信息。在 Swift 中，字典中键和值的类型总是通过显式类型注解或类型推断明确指定。
- en: 'The syntax for a dictionary in Swift is quite straightforward, as shown here:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 中字典的语法非常简单，如下所示：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding code uses explicit type notation as you can see that the key
    and value are explicitly defined as `String` and `String` respectively. This is
    very similar to how you declare dictionaries in Javascript or Maps in Java, by
    running the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码使用了显式的类型表示法，正如你所见，键和值被明确地定义为 `String` 和 `String`。这与你在 JavaScript 中声明字典或在
    Java 中声明 Map 的方式非常相似，只需运行以下代码即可：
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding code uses type inference where once we assign `Breed1` to the
    key and `Bull Dog` to the value, Swift automatically infers that our dictionary
    will hold two strings.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码使用了类型推断，一旦我们将 `Breed1` 分配给键，将 `Bull Dog` 分配给值，Swift 就会自动推断我们的字典将包含两个字符串。
- en: 'Modifying a dictionary in Swift is similar to how you access an array except
    that instead of using an index, you use the key, which in our case is a String.
    So, if you want to modify the value that maps to the `Breed1` key, you can do
    it as shown here:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中修改字典的方式与访问数组类似，只是你使用键而不是索引，在我们的例子中键是一个字符串。因此，如果你想修改映射到 `Breed1` 键的值，你可以像下面这样操作：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Alternatively, Swift allows us to update a value another way, which is the
    `updateValue` method as demonstrated here:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Swift 允许我们以另一种方式更新值，即 `updateValue` 方法，如下所示：
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Both ways will allow you to update a value using the key, but I prefer the first
    way as it is less verbose, yet equally easy to read and understand.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方式都可以让你使用键来更新值，但我更喜欢第一种方式，因为它更简洁，但同样易于阅读和理解。
- en: 'Iteration over a dictionary is similar to the iteration of an array in Swift
    where we can forgo the old Objective-C `for`, `while`, or `do-while` loop methods.
    To do a dictionary iteration in Swift, we just use the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中遍历字典与遍历数组类似，我们可以放弃旧的 Objective-C `for`、`while` 或 `do-while` 循环方法。要在
    Swift 中进行字典迭代，我们只需使用以下代码：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In any general purpose programming language, control flow statements are a necessity
    in order to control the flow of your code and your app. So, although Swift is
    a big departure from Objective-C, it still allows for control flow constructs
    of C-like languages such as C++.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何通用编程语言中，控制流语句都是必要的，以便控制代码和应用程序的流程。因此，尽管 Swift 与 Objective-C 相去甚远，但它仍然允许使用类似于
    C++ 的 C 语言风格的控制流结构。
- en: 'Here is a list of control flow constructs available for you to use in Swift:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个 Swift 中可用的控制流结构的列表：
- en: The `for` loop
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for` 循环'
- en: The `for-in` loop
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for-in` 循环'
- en: The `while` loop
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while` 循环'
- en: The `do-while` loop
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`do-while` 循环'
- en: The `if` statement
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if` 语句'
- en: The `switch` statement
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`switch` 语句'
- en: These control flow statements serve the same purpose as they will in Objective-C,
    but there are a few improvements to them, which I will explain briefly.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这些控制流语句与 Objective-C 中的作用相同，但它们有一些改进，我将简要解释。
- en: Iterating statements
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代语句
- en: 'For statements that iterate over and over again, such as `for` loops, Swift
    emphasizes the `for-in` loop for iteration. This is also known as an enhanced
    for loop in other programming languages such as Java. This improves readability
    and adds terseness to your code. For example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像 `for` 循环这样的重复执行语句，Swift 强调使用 `for-in` 循环进行迭代。在其他编程语言（如 Java）中也称为增强型 for
    循环。这提高了代码的可读性，并使代码更加简洁。例如：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'However, if you have the need for a Objective-C traditional style `for` loop,
    you can do it with Swift, as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你需要 Objective-C 传统的 `for` 循环风格，你可以使用 Swift 来实现，如下所示：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Conditional statements
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件语句
- en: 'If statements behave the same way as they do in Objective-C, except for a minor
    change of syntax as shown here. Do note that the brackets are optional, so we
    did not put it around the conditional expression:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: If语句的行为与Objective-C中的行为相同，除了语法上有一个小的变化，如下所示。请注意，括号是可选的，所以我们没有将它们放在条件表达式周围：
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Note that in the preceding example, we have a very simple condition, so we
    have opted to eliminate our brackets. However, what if you have multiple conditions?
    Then, Swift will use the normal rules of precedence that you are familiar with,
    but the lack of brackets can make the operations hard to understand. So, in this
    case, I would prefer to use brackets for multiple conditions and operations like
    the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面的例子中，我们有一个非常简单的条件，所以我们选择消除我们的括号。但是，如果你有多个条件呢？在这种情况下，Swift将使用你熟悉的正常优先级规则，但缺少括号可能会使操作难以理解。因此，在这种情况下，我更倾向于使用括号来处理多个条件和操作，如下所示：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'However, in Swift, Switch statements have now been made easier for debugging
    by not having to fall through the next case. So now the entire switch statement
    finishes its execution as soon as the first matching switch case is completed.
    So, the following statement will show the following output:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在Swift中，Switch语句现在通过不需要进入下一个case来简化了调试。因此，现在整个switch语句在第一个匹配的switch case完成后立即完成其执行。所以，下面的语句将显示以下输出：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The output will be `"Number is 2"` in Swift instead of `"Number is 1"` and `"Number
    is 3"`, which you will see in Objective-C.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，输出将是 `"Number is 2"`，而不是在Objective-C中看到的 `"Number is 1"` 和 `"Number
    is 3"`。
- en: Control flows in Swift have been made better where the syntax has been improved
    to add readability and to prevent developers from creating non-obvious bugs such
    as a Switch case fallthrough due to a missing `break` statement.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Swift中的控制流已经得到改进，语法已经改进以提高可读性，并防止开发者创建非明显的错误，例如由于缺少`break`语句而导致的Switch case
    fallthrough。
- en: Functions
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数
- en: 'Functions are the fundamental building blocks of every programming language,
    and it is also the same in Swift, but there are some improvements made, which
    we will go through now. The syntax for a function has changed quite a bit, so
    a function in Swift now has the following syntax:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是每种编程语言的基本构建块，在Swift中也是如此，但也有一些改进，我们现在将介绍。函数的语法已经发生了很大的变化，因此Swift中的函数现在具有以下语法：
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'So, you can call it using `println(animalType("Dog"))`. If the function does
    not have a return value, you can avoid adding the arrow (`->`) like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以使用 `println(animalType("Dog"))` 来调用它。如果一个函数没有返回值，你可以避免添加箭头（`->`），如下所示：
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Functions in Swift can now have multiple return values as part of a compound
    return value where you can use a tuple return type.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Swift中的函数现在可以具有多个返回值，作为复合返回值的一部分，你可以使用元组返回类型。
- en: 'A tuple type is just a fancy term for a comma separated list of zero or types,
    which are enclosed in a parenthesis. So, to let a function have multiple return
    values, a tuple is what you need as shown here:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 元组类型只是对由逗号分隔的零个或多个类型列表的一个花哨的称呼，这些类型被括号包围。因此，为了让一个函数有多个返回值，你需要使用元组，如下所示：
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then to use the return value, you need to assign it to a variable:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后为了使用返回值，你需要将其分配给一个变量：
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Swift allows the default values in a function where a default value is used
    if a function parameter is not used:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Swift允许在函数中使用默认值，如果函数参数没有被使用，将使用默认值：
- en: '[PRE25]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'So, in the preceding example, `num2` will have a default value of 0 if you
    do not pass in a parameter for the second parameter in the add function, as shown
    here:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在前面的例子中，如果在不传递第二个参数的情况下调用add函数，`num2`将具有默认值0，如下所示：
- en: '[PRE26]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Swift functions also allow the function to accept a variable number of arguments,
    which is useful when you need to pass in a varying number of parameters to a function.
    To enable a function to accept a varying number of parameters, you just need to
    add three full stops (`...`) in your function, shown as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Swift函数还允许函数接受可变数量的参数，这在需要向函数传递可变数量的参数时非常有用。要使函数能够接受可变数量的参数，你只需要在你的函数中添加三个点（`...`），如下所示：
- en: '[PRE27]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'So, you can call the `getAverage` function using a varying number of parameters
    such as `getAverage(1, 2, 3)` or `getAverage(1, 2, 3, 4, 5)`. By default, Swift
    makes all function parameters as constant to promote good programming practice.
    This is one of the more unique features of Swift, which you do not find in other
    procedural programming languages such as C++, Objective-C, and so on. So trying
    to modify a function parameter will result in an error. However, if you need to
    modify a function parameter in your code, you just need to add the `var` keyword
    to tell Swift to treat that function parameter as a variable, not as a constant,
    shown as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以使用可变数量的参数调用`getAverage`函数，例如`getAverage(1, 2, 3)`或`getAverage(1, 2, 3,
    4, 5)`。默认情况下，Swift将所有函数参数视为常量，以促进良好的编程实践。这是Swift的更多独特功能之一，你在其他过程式编程语言（如C++、Objective-C等）中找不到。因此，尝试修改函数参数将导致错误。但是，如果你需要在代码中修改函数参数，你只需添加`var`关键字来告诉Swift将该函数参数视为变量，而不是常量，如下所示：
- en: '[PRE28]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'One of the important changes that functions in Swift, different from Objective-C,
    is that you can have nested functions where a function is created inside another
    function. But do note that the inner function is only available to the enclosing
    function. To declare a nested function, you can just use a normal function call:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Swift中函数的一个重要变化，与Objective-C不同，是你可以在另一个函数内部创建嵌套函数。但请注意，内部函数仅对封装函数可用。要声明嵌套函数，你只需使用正常的函数调用即可：
- en: '[PRE29]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Classes and structures in Swift
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Swift中的类和结构体
- en: As you know, classes and structures are general purpose data structures that
    form the building block of the code of your application. You can define properties
    and methods to add functionality to these classes and structures using the same
    syntax as you will for the variables, functions, and so on.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，类和结构体是通用数据结构，是应用程序代码的构建块。你可以定义属性和方法来为这些类和结构体添加功能，使用与变量、函数等相同的语法。
- en: 'Classes and structures in Swift have many common points such as:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Swift中的类和结构体有许多共同点，例如：
- en: Defining properties to store values
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义属性以存储值
- en: Defining methods to provide added functionalities
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义方法以提供附加功能
- en: The ability to be extended to expand their functionalities
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够扩展以扩展其功能
- en: The possibility to conform to protocols to provide standard functionalities
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够遵守协议以提供标准功能
- en: 'However, classes have other differences that structures do not possess; they
    are:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，类与结构体有其他结构体不具备的差异；它们是：
- en: Inheritance to allow a subclass to inherit the characteristic of another
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承，允许子类继承另一个类的特性
- en: Type casting, which allows you to check and interpret the type of a class instance
    during runtime
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型转换，允许你在运行时检查和解释类实例的类型
- en: Reference counting, which allows more than one reference to a class instance
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用计数，允许对类实例有多个引用
- en: Deinitializers, which allow a class to do resource freeing
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 析构器，允许类进行资源释放
- en: Structures are copied when they are passed around in your code
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体在你代码中传递时会被复制
- en: 'To declare a class or structure, use the `class` and `struct` keyword respectively:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个类或结构体，分别使用`class`和`struct`关键字：
- en: '[PRE30]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As in Objective-C, to use a `struct` or `class`, you need to create an instance
    of it before you can use it. So, for `struct` and `class`, you need to use the
    `()` to create an instance of a `class` or `struct`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 与Objective-C一样，要使用`struct`或`class`，你需要在使用它之前创建其实例。因此，对于`struct`和`class`，你需要使用`()`来创建`class`或`struct`的实例。
- en: '[PRE31]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To access a property in a `class` or `struct`, you can use the "`.`" operator
    to access it, as shown here:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问`class`或`struct`中的属性，你可以使用"`.`"运算符来访问它，如下所示：
- en: '[PRE32]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'For classes, you can define your own custom initializer and deinitializer in
    your class file. Initializers for your struct members are automatically created
    for you, which you can use, as shown here:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类，你可以在你的类文件中定义自己的自定义初始化器和析构器。你的结构体成员的初始化器会自动为你创建，你可以使用，如下所示：
- en: '[PRE33]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Generally, you do not need to do any manual cleanup of your allocated instances
    as Swift will do it for you using ARC. However, if you are using some custom resources,
    then you may need to do the additional cleanup yourself. One use case will be
    when you have a class that opens a text file and writes or appends some data to
    it. So, in this situation, you may need to close the file before your instance
    is deallocated. An example syntax of deinitialization is as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你不需要手动清理你分配的实例，因为Swift会为你使用ARC来完成。然而，如果你使用了一些自定义资源，那么你可能需要自己进行额外的清理。一个用例是当你有一个类打开一个文本文件并向其中写入或追加数据时。所以，在这种情况下，你可能需要在你的实例被销毁之前关闭文件。一个初始化器语法的例子如下：
- en: '[PRE34]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: One of the most important differences between a Swift class and Swift struct
    is that Swift classes are passed by reference, which means that a reference to
    the existing class instance is created when you assign it to another instance,
    and any change to the new instance will affect the original instance. This is
    in contrast with pass by value where a copy of the value is passed to the variable
    so that what happens in the new variable will not affect the original variable.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Swift类和Swift结构体之间最重要的区别之一是Swift类是通过引用传递的，这意味着当你将它赋给另一个实例时，会创建现有类实例的引用，任何对新的实例的改变都会影响原始实例。这与按值传递形成对比，按值传递会将值的副本传递给变量，因此新变量中发生的事情不会影响原始变量。
- en: 'So, depending on this difference, sometimes using a class is more useful in
    some situations while in other situations using a struct would be better. It all
    depends on the context of your program or application. So, let''s use some code
    to help us understand this better:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，根据这种差异，在某些情况下使用类可能更有用，而在其他情况下使用结构体会更好。这完全取决于你的程序或应用程序的上下文。所以，让我们用一些代码来帮助我们更好地理解这一点：
- en: '[PRE35]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If you use the following code, you will notice that the `classA` member `x`
    will also be set to the value of `100` as a reference to `classA` is passed when
    you run the code `classB = classA`. So, whatever affects `classB` will also affect
    `classA`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用以下代码，你会注意到`classA`成员`x`也会被设置为`100`的值，因为当你运行`classB = classA`代码时，会传递一个`classA`的引用。所以，任何影响`classB`的也会影响`classA`。
- en: Closures
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 闭包
- en: Closures in Swift are known as blocks in Objective-C. Both have the same concept
    of creating self-contained blocks of code that can be passed around and used.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Swift中的闭包在Objective-C中被称为blocks。两者都有创建自包含代码块的概念，这些代码块可以被传递和使用。
- en: 'Closures use `{` and `}` to denote the beginning and end respectively. So,
    a very simple example of creating a closure and calling it would be something
    like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包使用`{`和`}`分别表示开始和结束。所以，创建一个闭包并调用的一个非常简单的例子可能是这样的：
- en: '[PRE36]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You can see the output **Hello Gibson** appearing in your debug console.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在你的调试控制台中看到输出**Hello Gibson**。
- en: 'Of course, you will need to pass in arguments and get return values from your
    closures. You also need to use `(` and `)` to enclose your arguments and `->`
    to denote your return values as you can see here:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你需要向闭包传递参数并从闭包获取返回值。你还需要使用`(`和`)`来包围你的参数，并使用`->`来表示你的返回值，就像你在这里看到的那样：
- en: '[PRE37]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If you run the code, you will get the output **Howdy Gibby** because I passed
    in two string variables of the names `s1` and `name` respectively as you can see
    from the line `(s1: String, name: String)`, while I ask a return value of the
    type string using `-> String`.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你运行代码，你会得到输出**Howdy Gibby**，因为我传递了两个字符串变量`s1`和`name`，分别对应于你从`(s1: String,
    name: String)`行中看到的，而我要求返回一个字符串类型的值，使用`-> String`。'
- en: Next, let's move on to memory management in Swift, which you still need to take
    note of as ARC frees you from a lot of memory management techniques, but you still
    need to take note of some memory management techniques in Swift as Swift can still
    leak memory if you are not careful.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们继续讨论Swift中的内存管理，这你仍然需要注意，因为自动引用计数（ARC）让你免于许多内存管理技术，但你仍然需要在Swift中注意一些内存管理技术，因为如果你不小心，Swift仍然可能会泄漏内存。
- en: Memory management in Swift
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swift中的内存管理
- en: Swift was created to avoid some of the downsides of C, one of which being memory
    management. Notice that nowhere in this chapter did I mention anything about pointers,
    memory allocation, deallocation, and so on. This is because in Swift, memory management
    is made to be as painless as possible so that you, the developer, can focus more
    on your application development than on debugging memory leaks. Every time a new
    instance of a class is created, ARC will allocate a chunk of the memory to be
    used to store information about that instance. This chunk of memory holds information
    such as the instance type (string, integer, and so on) along with the values of
    the properties that are associated with that instance. ARC will free up the memory
    used by that instance when it is no longer needed or referenced. This is to avoid
    a situation where instances still occupy precious memory space when they are no
    longer being used or needed.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 的创建是为了避免 C 语言的一些缺点，其中之一就是内存管理。注意，在本章中，我并没有提到任何关于指针、内存分配、释放等内容。这是因为 Swift
    中的内存管理被设计得尽可能简单，以便你，作为开发者，可以更多地关注应用程序开发而不是调试内存泄漏。每当创建一个新的类实例时，ARC 会分配一块内存用于存储该实例的信息。这块内存包含有关实例类型（字符串、整数等）以及与该实例相关联的属性值等信息。当该实例不再需要或被引用时，ARC
    会释放该实例使用的内存。这是为了避免实例在不再使用或需要时仍然占用宝贵的内存空间的情况。
- en: 'However, if you try to access an instance''s properties or methods after ARC
    has deallocated it, then a crash will be the likely result that you will see.
    So, to make sure that this does not happen to you, ARC will track how many properties,
    variables, and constants are currently referencing a class instance, and ARC will
    not allow deallocation as long as there is at least one active reference to that
    instance from another object in your code somewhere. A strong reference is created
    when you assign a class instance to a property, constant, or variable, and this
    strong reference keeps a strong hold on that class instance, and ARC will not
    make a deallocation call as long as that strong reference remains. Let''s illustrate
    this with some code to understand this further:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你在 ARC 释放实例之后尝试访问实例的属性或方法，那么你很可能会看到崩溃的结果。所以，为了确保这种情况不会发生在你身上，ARC 会跟踪当前有多少属性、变量和常量正在引用一个类实例，并且只要代码中的某个地方至少有一个活动引用指向该实例，ARC
    就不会允许释放。当你将类实例赋给属性、常量或变量时，就会创建一个强引用，这个强引用会紧紧地保持对那个类实例的控制，并且只要这个强引用存在，ARC 就不会进行释放调用。让我们通过一些代码来进一步说明这一点：
- en: 'Let''s declare a class called `Dog`:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们声明一个名为 `Dog` 的类：
- en: '[PRE38]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, we will create two references to the `Dog` class:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将创建两个对 `Dog` 类的引用：
- en: '[PRE39]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that there is a `?` keyword, which means that `dog1` is of an optional
    type, which means that it could be nil. In Swift, any variable with a `?` keyword
    means that there is a possibility that it can hold a nil value. Since we declared
    `dog1` and `dog2` as an optional type, it means that `dog1` and `dog2` are initialized
    with a value of nil and do not have a reference to the `Dog` class.
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到存在一个 `?` 关键字，这意味着 `dog1` 是一个可选类型，这意味着它可能是 nil。在 Swift 中，任何带有 `?` 关键字的变量都意味着它有可能包含一个
    nil 值。由于我们声明了 `dog1` 和 `dog2` 为可选类型，这意味着 `dog1` 和 `dog2` 被初始化为 nil 值，并且没有对 `Dog`
    类的引用。
- en: 'Next, we will create an instance and assign two variables, `dog1` and `dog2`
    respectively:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个实例，并将两个变量分别赋值为 `dog1` 和 `dog2`：
- en: '[PRE40]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: So, now there are two strong references to the `Dog` instance. One is through
    `dog1` and the other is from `dog2` to `dog1`.
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，有两个对 `Dog` 实例的强引用。一个是通过 `dog1`，另一个是从 `dog2` 到 `dog1`。
- en: 'One thing to note about Swift is that the type inference only works for the
    initial assignment; assigning another type to the same variable will throw an
    error. This is quite different from other languages such as JavaScript, where
    no error will be thrown. Let me illustrate what I mean with an example:'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于 Swift，有一点需要注意，类型推断仅适用于初始赋值；将另一个类型赋给同一变量将引发错误。这与 JavaScript 等其他语言截然不同，后者不会抛出错误。让我用一个例子来说明我的意思：
- en: '[PRE41]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'So, you can try assigning `dog1` to nil, as shown here:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，你可以尝试将 `dog1` 赋值为 nil，如下所示：
- en: '[PRE42]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'ARC will see that `dog2` still holds a strong reference and will not deallocate
    the `Dog` instance. The only time that the `Dog` instance will be deallocated
    will be when `dog2` is set to nil as shown here:'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ARC 会看到 `dog2` 仍然持有强引用，因此不会释放 `Dog` 实例。`Dog` 实例将被释放的唯一情况是当 `dog2` 被设置为 nil，如下所示：
- en: '[PRE43]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Conversely, Swift also supports weak references where the reference does not
    have a strong reference onto the instance that it references. So, ARC will dispose
    of an instance even if it has a weak reference. To create a weak reference, you
    need to use the `weak` keyword as shown here:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，Swift 也支持弱引用，其中引用没有对它引用的实例的强引用。因此，即使有弱引用，ARC 也会销毁实例。要创建弱引用，你需要使用 `weak` 关键字，如下所示：
- en: '[PRE44]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Notice that the `?` keyword is added at the end of the `String` keyword as a
    weak reference can be allowed to have a value of nil, so all weak references must
    be declared as optional using the `?` keyword. Notice that it is also declared
    as a variable as weak references will have their values changed in the code during
    runtime. So, a weak reference cannot be declared as a constant as a weak reference
    does not have a strong hold on the instance it refers to. So, when this instance
    is going to be deallocated while the weak reference is still referring to it,
    ARC will set the weak reference to nil when that situation arises and you can
    check the value of a weak reference to see if that object has been deallocated.
    This way you can avoid a situation where you end up with a reference to an invalid
    instance that has already been deallocated by ARC.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`?` 关键字被添加到 `String` 关键字末尾，因为弱引用可以允许有 `nil` 的值，所以所有弱引用都必须使用 `?` 关键字声明为可选。注意，它也被声明为变量，因为弱引用的值在代码运行时可能会改变。因此，弱引用不能声明为常量，因为弱引用对其引用的实例没有强引用。所以，当这个实例即将被释放而弱引用仍然指向它时，ARC会在这种情况下将弱引用设置为
    `nil`，你可以检查弱引用的值以查看该对象是否已被释放。这样你可以避免出现最终得到一个指向已由ARC释放的无效实例的引用的情况。
- en: 'In between strong and weak references, there is another type of reference that
    keeps a weak hold on an instance it refers to, but it cannot be set to nil, so
    it is always assumed to have a value. This is known as an unowned reference. It
    can be used as a replacement for a weak reference and for some use cases as we
    will see here:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在强引用和弱引用之间，还有一种引用类型，它对其引用的实例保持弱引用，但不能设置为 `nil`，因此它总是假定有一个值。这被称为非拥有引用。它可以作为弱引用的替代品，以及在某些用例中，正如我们将在这里看到的：
- en: '[PRE45]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Notice that we initialize `City` within the initializer method for `Country`,
    but we also need to initialize `Country` within the initializer method of `City`,
    and this presents itself as a conundrum since `Country` depends on the initializer
    of `City` and `City` depends on the initializer of `Country`. To get a solution
    to this, you can declare the `capital` variable of `Country` as an implicit unwrapped
    optional property, which you denote by using `!`. This means that the `capital`
    property will have a default value as nil.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在 `Country` 的初始化方法中初始化了 `City`，但我们还需要在 `City` 的初始化方法中初始化 `Country`，这本身就是一个难题，因为
    `Country` 依赖于 `City` 的初始化器，而 `City` 依赖于 `Country` 的初始化器。为了解决这个问题，你可以将 `Country`
    的 `capital` 变量声明为一个隐式解包的可选属性，这可以通过使用 `!` 来表示。这意味着 `capital` 属性将有一个默认值 `nil`。
- en: The `!` keyword also serves as a unwrapping function where you can get the value
    of the property without assigning that property to a local variable. As mentioned
    earlier, a variable that is denoted with the optional symbol, which is a `?` keyword,
    can either contain a value or nothing. So, when you are testing against this variable
    of the type denoted as optional, you need to know whether there is a value without
    directly accessing the underlying value. The `!` keyword means that you can unwrap
    the variable to get access to the value.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`!` 关键字还充当一个解包函数，你可以获取属性值而不必将该属性分配给局部变量。如前所述，带有可选符号（即 `?` 关键字）的变量可以包含一个值或者什么都没有。因此，当你测试这个类型为可选的变量时，你需要知道是否有值，而不必直接访问其底层值。`!`
    关键字意味着你可以解包变量以获取访问值。'
- en: However, this does not absolve you from checking whether that property is nil
    as you still need to check for nil in your code.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不能免除你检查该属性是否为 `nil` 的责任，因为你仍然需要在代码中检查 `nil`。
- en: So, now what happens is that `capital` has a default nil value and the `Country`
    instanced is considered as fully initialized as soon as the `Country` instance
    sets its `name` property within its own initializer method. This means that the
    `Country` initializer method can start to reference and pass around its `self`
    property as soon as the `name` property is set. So now the `Country` initializer
    can therefore pass the `self` property as one of the parameters for the `City`
    initializer when the `Country` initializer is setting its own `city` property.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在的情况是 `capital` 具有默认的 nil 值，一旦 `Country` 实例在其初始化方法中设置了其 `name` 属性，它就被视为完全初始化。这意味着
    `Country` 初始化方法可以在设置 `name` 属性后立即开始引用和传递其 `self` 属性。因此，现在 `Country` 初始化方法可以在设置自己的
    `city` 属性时，将 `self` 属性作为参数之一传递给 `City` 初始化方法。
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As you can see, Swift is a big departure in terms of syntax, style, and paradigm
    from Objective-C. Swift was developed to move away from the C paradigm of programming
    where we need to wrap our heads around memory management, allocation, and deallocation.
    We went through some of the basic features of Swift and noted that Swift features
    more terse code, has made memory management, and is also fuss free, since ARC
    takes care of memory management for us in Swift. However, Swift is still in the
    beta stage at the time of this writing, so it can still be subject to changes
    in its journey to alpha and release status. Therefore, you can expect that some
    features will be added or removed during this period. However, the fundamentals
    of Swift will not be changed significantly, and I hope that this chapter has given
    you a better understanding of Swift and has prepared you for programming in Swift
    in the near future.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Swift 在语法、风格和范式方面与 Objective-C 有很大不同。Swift 是为了摆脱编程中的 C 范式，在那里我们需要理解内存管理、分配和释放。我们回顾了
    Swift 的一些基本特性，并指出 Swift 具有更简洁的代码，内存管理更加简单，因为 ARC 在 Swift 中为我们处理内存管理。然而，Swift 在撰写本文时仍处于测试阶段，因此在其走向
    alpha 版本和发布状态的过程中，其功能仍可能发生变化。因此，您可以预期在此期间某些功能可能会被添加或删除。但是，Swift 的基础将不会发生重大变化，我希望这一章能帮助您更好地理解
    Swift，并为您在不久的将来使用 Swift 进行编程做好准备。
- en: To find out more information about Swift, the best resource to refer to is Apple's
    website on Swift programming at [https://developer.apple.com/swift/blog/](https://developer.apple.com/swift/blog/)
    as it has been updated constantly since Swift was announced.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 Swift 的信息，最佳参考资料是苹果公司 Swift 编程网站 [https://developer.apple.com/swift/blog/](https://developer.apple.com/swift/blog/)，因为自
    Swift 公布以来，该网站的内容一直持续更新。
- en: In the next chapter, we will look at memory management techniques using some
    of the excellent tools in Xcode, such as Static Analyzer, and we will also cover
    more details on the various techniques so that you will know which debugging tool
    is the best tool to use in different situations.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨使用 Xcode 中的一些优秀工具（如静态分析器）进行内存管理的技术，我们还将更详细地介绍各种技术，以便您知道在不同情况下哪种调试工具是最好的工具。
