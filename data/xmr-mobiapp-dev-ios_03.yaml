- en: Chapter 3. Views and Layouts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 视图和布局
- en: In terms of the iPhone and the iPad, a view can be thought of as what you see,
    but the types of views you see depend (to an extent) on the application type you
    select when you create your application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在iPhone和iPad的层面上，视图可以被认为是你所看到的，但你看到的视图类型（在一定程度上）取决于你创建应用时选择的应用类型。
- en: 'In this chapter we will be covering the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Projects and their types of layouts
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目及其布局类型
- en: Ensuring that your design fits all iOS devices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保你的设计适合所有iOS设备
- en: UI controls
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI控件
- en: Selection of the project type
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目类型选择
- en: 'When you first decide to create an iOS application, you will be presented with
    the view shown in the following screenshot:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次决定创建iOS应用时，你会看到以下截图所示的视图：
- en: '![Selection of the project type](img/00020.jpeg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![项目类型选择](img/00020.jpeg)'
- en: Application types and their view types
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用类型及其视图类型
- en: 'The project types require a bit of an explanation, which has been provided
    in the following table:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 项目类型需要一些解释，以下表格中已提供：
- en: '| Project type | View type |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| 项目类型 | 视图类型 |'
- en: '| --- | --- |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Master-Detail | A table based layout. |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 主-详情 | 基于表格的布局。|'
- en: '| Single View | The simplest form of view. The name does not mean that you
    have an app with just one page, but that views don''t propagate through (so view
    1 may have tabs that go to view 2\. View 2 could be a `MT.D`). |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 单视图 | 最简单的视图形式。名称并不意味着你的应用只有一个页面，而是指视图不会通过（因此视图1可能有跳转到视图2的标签页。视图2可能是`MT.D`）。|'
- en: '| Tabbed | A standard view with a number of persistent tabs at the bottom of
    the screen. The view changes, but the tabs stay. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 标签视图 | 一种标准视图，屏幕底部有多个持久标签。视图会变化，但标签保持不变。|'
- en: '| OpenGL | Fast, responsive, used for high resolution gaming. I won''t be covering
    this here, as it is outside the scope of this book. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| OpenGL | 快速、响应式，用于高分辨率游戏。这里不会涉及，因为它超出了本书的范围。|'
- en: A more complete explanation of the project types can be found at [http://oleb.net/blog/2013/05/xcode-project-templates-difference/](http://oleb.net/blog/2013/05/xcode-project-templates-difference/).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在[http://oleb.net/blog/2013/05/xcode-project-templates-difference/](http://oleb.net/blog/2013/05/xcode-project-templates-difference/)可以找到对项目类型的更完整解释。
- en: The iOS layout
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: iOS布局
- en: When dealing with the layout of the iPhone (and the iPad) user interface, a
    number of factors have to be taken into consideration; the most important is probably
    the physical size of the screen. While it is easy to create a user interface using
    Xcode, unlike Android devices, iOS does not really auto-resize. The UI is partially
    due to the way layouts are created in iOS.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理iPhone（和iPad）用户界面的布局时，必须考虑许多因素；其中最重要的是屏幕的物理尺寸。虽然使用Xcode创建用户界面很容易，但与Android设备不同，iOS并不真正自动调整大小。UI部分是由于iOS中布局的创建方式。
- en: The Canvas model
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 画布模型
- en: When I was growing up, I was given a "fuzzy felt" kit at school. For those who
    don't know what it is, a fuzzy felt kit consists of a large background piece of
    felt onto which you stick other pieces of felt; this enables you to create lots
    of pictures. Designing for iOS is the same. You can drag-and-drop any piece of
    the user interface into the main view and leave it there. This is what gives iOS
    a part of the richness it enjoys; it is up to the designer to create, rather than
    have strict rules on what goes where. For the application, the UI elements all
    have an **absolute** position on the screen, rather than being relative to any
    other objects. Here, though, is the problem.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当我成长的时候，我在学校得到了一个“毛绒布”套件。对于那些不知道这是什么的人来说，毛绒布套件由一块大的背景布组成，你可以在上面粘贴其他布料；这使你能够制作出很多图片。为iOS设计也是如此。你可以将用户界面的任何部分拖放到主视图中并留下它。这就是iOS拥有其丰富性的部分原因；设计师需要创造，而不是对放置的位置有严格的规则。对于应用来说，UI元素在屏幕上都有**绝对**的位置，而不是相对于其他对象。然而，这里有一个问题。
- en: If you increase the screen size, those positions stay the same. So, what may
    look good on an iPhone 4 has bits missing on the 3G and has gaps on the iPhone
    5—don't start thinking about the iPad—as the view would be just in the middle
    of the screen, usually squashed up.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你增加屏幕尺寸，这些位置保持不变。所以，在iPhone 4上看起来不错的东西在3G上可能缺失部分，在iPhone 5上可能有间隙——不要开始考虑iPad——因为视图通常位于屏幕中间，通常是挤压在一起的。
- en: How to avoid some of these problems
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何避免这些问题中的某些
- en: The simplest method is, when using Xcode to design your UI, you check the **Use
    AutoLayout** checkbox on the UI View. This does the moving around for you.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是，当使用 Xcode 设计你的 UI 时，你需要在 UI 视图中勾选**使用自动布局**复选框。这会为你完成移动操作。
- en: '![How to avoid some of these problems](img/00021.jpeg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![如何避免这些问题之一](img/00021.jpeg)'
- en: The problem here though is that you need to set this **Use AutoLayout** on every
    view, and it is also not supported on the iPhone 3GS. However, the 3GS is now
    so old that it is probably not worth going through the hoops required to auto-scale
    on it. The 3GS supports iOS 6, but only by hacking. iOS 5 is nearing the end of
    its life (at the time of writing).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，这里的问题是您需要在每个视图中设置此**使用自动布局**，并且它也不支持 iPhone 3GS。然而，3GS 现在已经非常旧了，可能不值得费心去自动缩放。3GS
    支持 iOS 6，但只能通过黑客手段。iOS 5 正接近其生命的终结（在撰写本文时）。 '
- en: Views and View Controllers
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图和视图控制器
- en: They sound similar, but they're not. The simplest way to think of a View Controller
    and a View is like a web page. A typical web page is a piece of information served
    up from a server. The content may be created dynamically (say from a database
    query), but for the user it's just data. This would be considered as a View. It
    has things on it, but no real user interaction.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 它们听起来很相似，但它们并不相同。将视图控制器和视图视为网页的最简单方法是。一个典型的网页是从服务器提供的信息。内容可能是动态创建的（例如，从数据库查询），但对于用户来说，它只是数据。这将被视为视图。它上面有东西，但没有真正的用户交互。
- en: A View Controller is closer to a web page constructed using `ASP.net`, or some
    other form of language that feeds back to a server (such as PHP). The website
    has a button on it. The button has an event, which is then fed back to the code
    (known as the handler code) behind the button. The View created using Xcode is
    the web page, and the source file with a connection is the server.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 视图控制器更接近于使用 `ASP.net` 或其他形式的语言构建的网页（例如 PHP）。该网站有一个按钮。按钮有一个事件，然后将其反馈到按钮背后的代码（称为处理代码）。使用
    Xcode 创建的视图是网页，带有连接的源文件是服务器。
- en: As outlined in the previous chapter, the objects on `UIViewController` are connected
    to the code behind the control by clicking on the control (as well as pressing
    the *Ctrl* key) and dragging the widget to the connector entry window.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，`UIViewController`上的对象通过点击控件（以及按住*Ctrl*键）并将小部件拖到连接器入口窗口来与控件的代码（称为处理代码）连接。
- en: Other Views
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他视图
- en: 'Outside of the View choice, there are a number of other views that are available,
    as shown in the following table:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 除了视图选择之外，还有许多其他视图可用，如下表所示：
- en: '| View name | Description |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 视图名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **Activity Indicator** **View** | It is a modal indicator that shows that
    something (an activity) is occurring. This can be the loading of a web page or
    the rendering of a map. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| **活动指示器** **视图** | 它是一个模态指示器，显示正在发生某事（活动）。这可能是指网页的加载或地图的渲染。|'
- en: '| **Progress** **View** | It shows the progress of time for an activity—gives
    the user a better idea of how long something is going to take. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| **进度** **视图** | 它显示了活动的进度——给用户一个更好的想法，了解某件事将花费多长时间。|'
- en: '| **Collection** **View** | It displays a collection of cells (`CollectionViewCells`).
    Each cell can be defined. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| **集合** **视图** | 它显示一组单元格（`CollectionViewCells`）。每个单元格都可以被定义。|'
- en: '| **Collection Reusable View** | A reusable collection works as follows: say
    you have a group of cells which, for argument''s sake, occupies the screen. In
    a standard collection, when the cells go off screen, they are still held in the
    collection. While this makes rendering faster when they return, they take up memory
    space. The reusable collection stores a pointer to the cell and then refreshes
    when back on the screen—the collection is then reused. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| **可重用集合视图** | 可重用集合的工作方式如下：假设你有一组单元格，为了论证，它们占据了屏幕。在一个标准集合中，当单元格离开屏幕时，它们仍然被保留在集合中。虽然这使它们返回时的渲染更快，但它们会占用内存空间。可重用集合存储单元格的指针，并在返回屏幕时刷新——然后集合被重用。|'
- en: '| **Table View** | It will be covered in [Chapter 4](../Text/part0026.html#page
    "Chapter 4. Controllers"), *Controllers*. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| **表格视图** | 它将在[第 4 章](../Text/part0026.html#page "第 4 章。控制器")中介绍，*控制器*。|'
- en: '| **ImageView** | Think of this as a picture view. It has no click events and
    displays images. It can, however, play animations within it. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| **图片视图** | 可以将其视为一个图片视图。它没有点击事件，显示图片。然而，它可以在其中播放动画。|'
- en: '| **Text View** | It displays multiple lines of text. Can be a read only as
    well as a read/write. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| **文本视图** | 它显示多行文本。可以是只读的，也可以是读写。|'
- en: '| **Web View** | It is a view used to render HTML. The HTML file can be held
    on the phone or remotely. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| **网页视图** | 它是一个用于渲染 HTML 的视图。HTML 文件可以存储在手机上或远程。|'
- en: '| **Map View** | It displays a map with various options. Maps are covered later
    in this book. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| **地图视图** | 它显示带有各种选项的地图。地图将在本书的后面部分介绍。|'
- en: '| **Scroll View** | It is a view designed to allow more content to be accommodated
    on a screen than the screen size actually allows. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| **滚动视图** | 它是一个设计用来在屏幕上容纳比屏幕尺寸实际允许的更多内容的视图。|'
- en: '| **Picker View** | It is a user-definable picker. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| **选择视图** | 它是一个用户可定义的选择器。|'
- en: '| **AdBanner View** | It is an advertising banner bar for in-app advertising.
    |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| **广告横幅视图** | 它是用于应用内广告的广告横幅栏。|'
- en: '| **GLKit View** | It is used for OpenGL-ES rendering. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| **GLKit 视图** | 它用于 OpenGL-ES 渲染。|'
- en: I will deal with the views not covered here elsewhere in this book. As with
    all views, these too need to be dragged onto the view in Xcode and then linked
    to the main code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在本书的其他地方处理这里未涉及到的视图。与所有视图一样，这些视图也需要拖放到 Xcode 中的视图中，然后将其链接到主代码。
- en: Activity Indicator and Progress View
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动指示器和进度视图
- en: The `UIActivityIndicatorView` class is a very simple view to implement.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIActivityIndicatorView` 类是一个实现起来非常简单的视图。'
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `UIProgressView` class is a little more complex, but still quite simple.
    This works on a thread system to keep track of the indicator. Let''s start by
    setting one up:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIProgressView` 类稍微复杂一些，但仍然相当简单。它通过线程系统来跟踪指示器。让我们先设置一个：'
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next is to construct the thread routine. The `NSAutoreleasePool` class is used
    as a temporary block of memory that is released once the code within the braces
    has been executed. In the following code, it allows access to the `InvokeOnMainThread`
    method:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是构建线程例程。`NSAutoreleasePool` 类用作一个临时内存块，一旦大括号内的代码执行完毕，就会释放它。在以下代码中，它允许访问 `InvokeOnMainThread`
    方法：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And finally, link it to the Progress View:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将其链接到进度视图：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: UIImageView
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`UIImageView`'
- en: 'A `UIImageView` class can bring an image in from `UIImage`, which in turn brings
    images in from a number of places:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `UIImageView` 类可以从 `UIImage` 中引入图像，而 `UIImage` 又可以从多个地方引入图像：
- en: '`FromFile`: a file held within the structure of the application (for example,
    if the application has a directory called `Graphics`, the `FromFile` would point
    to `Graphics` | `image.png`).'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FromFile`：在应用程序结构中存储的文件（例如，如果应用程序有一个名为 `Graphics` 的目录，则 `FromFile` 将指向 `Graphics`
    | `image.png`）。'
- en: '`FromImage`: loads from `CoreImage` files.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FromImage`：从 `CoreImage` 文件加载。'
- en: '`FromResource`: loads from the `Resources` directory. These are embedded from
    within the application.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FromResource`：从 `Resources` 目录加载。这些是从应用程序内部嵌入的。'
- en: '`FromBundle`: loads an image relative to the main application bundle and caches
    it.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FromBundle`：从主应用程序包中加载一个图像并将其缓存。'
- en: '`LoadFromData`: an image created from within the app.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoadFromData`：从应用程序内部创建的图像。'
- en: 'To load a file into `UIImageView`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要将文件加载到 `UIImageView`：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `UIImageView` class can also display animations. The main prerequisite for
    doing this is that you should have a number of images to animate. In my example,
    I have six images of a tractor. The wheels are the only parts that move.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIImageView` 类也可以显示动画。进行此操作的主要前提是你应该有一系列要动画化的图像。在我的例子中，我有一个拖拉机的六张图片。车轮是唯一移动的部分。'
- en: '![UIImageView](img/00022.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![UIImageView](img/00022.jpeg)'
- en: 'To start the animation, use the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始动画，使用以下代码：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To stop the animation, use:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止动画，使用以下命令：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![Note](img/00001.gif)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![笔记](img/00001.gif)'
- en: Tip
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Animation is covered in [Chapter 10](../Text/part0048.html#page "Chapter 10. Animation"),
    *Animation*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 动画在 [第 10 章](../Text/part0048.html#page "第 10 章。动画") *动画* 中介绍。
- en: '![Note](img/00001.gif)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![笔记](img/00001.gif)'
- en: UICollectionView
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`UICollectionView`'
- en: The simplest Collection View that you're likely to see is an image gallery.
    Think of the Collection View as being a grid view that can be extended. Each Collection
    View is made up of three different items; cells, supplementary views (data-driven
    views), and decoration views.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你最可能看到的简单集合视图是一个图片库。将集合视图视为可以扩展的网格视图。每个集合视图由三个不同的项目组成；单元格、辅助视图（数据驱动视图）和装饰视图。
- en: Cells
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单元格
- en: Each `UICollectionView` class will contain `UICollectionViewCells`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `UICollectionView` 类将包含 `UICollectionViewCells`。
- en: 'These cells have a main Content View (where you see something, be it a picture
    or the data derived within the app), and surrounding the Content View is one of
    the two background views: normal or selected. If the content part is not smaller
    than the background, the background won''t be seen.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这些单元格有一个主要内容视图（您可以看到的东西，无论是图片还是应用内部导出的数据），围绕内容视图的是两个背景视图之一：正常或选中。如果内容部分不小于背景，则背景将不可见。
- en: Supplementary Views
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 辅助视图
- en: These are views that present information linked to each section of `UICollectionView`.
    They are data driven. Where the cells are from a data source, the Supplementary
    View presents that section's data (for example, the main view could be the front
    covers of books, the Supplementary View could be the table of contents).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是展示与 `UICollectionView` 的每个分区相关的信息的视图。它们是数据驱动的。单元格来自数据源时，辅助视图展示该分区的数据（例如，主视图可能是书的封面，辅助视图可能是目录）。
- en: Decoration View
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 装饰视图
- en: These are not data generated and are there purely for aesthetic purposes.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不是生成数据，它们纯粹是为了美观目的。
- en: Data source
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数据源
- en: The `UICollectionView` class gets its data via the `UICollectionViewDataSource`
    class. This class provides information, such as the cells (from `GetCell`), supplementary
    views (from `GetViewForSupplementaryElement`), number of sections (from `NumberOfSections`
    or 1 if not implemented), and the number of items per section (from `GetItemsCount`).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`UICollectionView` 类通过 `UICollectionViewDataSource` 类获取其数据。这个类提供信息，例如单元格（从
    `GetCell` 获取），辅助视图（从 `GetViewForSupplementaryElement` 获取），分区数量（从 `NumberOfSections`
    获取，如果没有实现则为 1），以及每个分区的项目数量（从 `GetItemsCount` 获取）。'
- en: Cell Reuse
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单元重用
- en: The `UICollectionView` class will only call the data source to get cells for
    items that are on the screen. Items that are not on the screen are placed in a
    queue to be reused.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`UICollectionView` 类将只调用数据源来获取屏幕上项目的单元格。不在屏幕上的项目将被放入队列以供重用。'
- en: UIWebView
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UIWebView
- en: The `UIWebView` class effectively transforms your device into a web browser
    with JavaScript capabilities as well as the usual web facilities, such as move
    back, forward, and typing a URL in the text field when extended with `UITextField`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIWebView` 类将您的设备有效地转换成一个具有 JavaScript 功能以及常规网络功能的网络浏览器，例如，当扩展到 `UITextField`
    时，可以后退、前进以及在文本字段中输入 URL。'
- en: 'To load a web page is simple enough, as shown in the following code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 加载网页很简单，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There are a number of factors to remember with web page loading. The first factor
    is that it is typically an asynchronous task; in other words, some parts are completed
    before others and it is quite possible that the application flow will return to
    the main thread before the task is completed. The second factor is the speed.
    I'll not concern myself with the second factor for now.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在网页加载中，有一些因素需要记住。第一个因素是它通常是一个异步任务；换句话说，某些部分在完成之前就已经完成，并且任务完成之前应用程序流程可能会返回主线程。第二个因素是速度。现在我不会关注第二个因素。
- en: 'To overcome the problem caused by asynchronous tasks, there are a number of
    events that can be used:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了克服异步任务引起的问题，可以使用以下多个事件：
- en: '`LoadStarted`'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoadStarted`'
- en: '`LoadFinished`'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoadFinished`'
- en: '`LoadError`'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoadError`'
- en: The boolean `IsLoading`
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值 `IsLoading`
- en: The `IsLoading` boolean is a flag that can be checked at any point to determine
    if something is loading (true) or has completed loading (false).
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`IsLoading` 布尔值是一个标志，可以在任何时刻检查以确定是否正在加载（true）或已完成加载（false）。'
- en: 'For example:'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE8]'
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To move back and forward, the following methods can be used:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了前进和后退，可以使用以下方法：
- en: '`web.GoBack()`'
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`web.GoBack()`'
- en: '`web.GoForward()`'
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`web.GoForward()`'
- en: These methods have a simple boolean test
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些方法有一个简单的布尔测试
- en: '`web.CanGoBack`'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`web.CanGoBack`'
- en: '`web.CanGoForward`'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`web.CanGoForward`'
- en: 'For refreshing a webpage, the following method can be used:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了刷新网页，可以使用以下方法：
- en: '[PRE9]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It is also possible to include zoom support and fitting the page
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还可以包括缩放支持和页面适配
- en: '[PRE10]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: MapView
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 地图视图
- en: '![Note](img/00001.gif)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![注意](img/00001.gif)'
- en: Note
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: These are the iOS maps, not Google Maps (Apple moved from using Google to their
    own maps with iOS 6).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 iOS 地图，而不是 Google 地图（苹果从 iOS 6 开始从使用 Google 地图转向使用自己的地图）。
- en: '![Note](img/00001.gif)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![注意](img/00001.gif)'
- en: Maps under iOS require the use of `CoreLocations` and `MapKit`. Mapping and
    location services are dealt with later in [Chapter 12](../Text/part0055.html#page
    "Chapter 12. Peripherals"), *Peripherals*.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在 iOS 中，地图需要使用 `CoreLocations` 和 `MapKit`。映射和位置服务将在第 12 章[外围设备](../Text/part0055.html#page
    "第 12 章。外围设备")中处理，*外围设备*。
- en: UIScrollView
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UIScrollView
- en: There are times when too much information will be displayed on screen (for example,
    if you are dynamically generating content or creating some form of a drawing application).
    In such cases, `UIScrollView` can be used to ensure that the user can see everything.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候屏幕上会显示过多的信息（例如，如果你正在动态生成内容或创建某种形式的绘图应用程序）。在这种情况下，可以使用`UIScrollView`来确保用户可以看到所有内容。
- en: The view (when combined with `PageEnabled = true;`) works by calculating the
    size of the page.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 视图（当与`PageEnabled = true;`结合使用时）通过计算页面大小来工作。
- en: 'Assuming that the Scroll View has been created in Xcode (and is called `scrollView`),
    the code will be as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 假设滚动视图已经在Xcode中创建（并命名为`scrollView`），代码如下：
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We now have an effective page system. The problem is tracing which page the
    user is on. This is handled with `UIPageControl`. In the previous example, tracking
    would be performed as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个有效的页面系统。问题是追踪用户在哪个页面。这可以通过`UIPageControl`来处理。在先前的例子中，跟踪将如下进行：
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the `ViewDidLoad()` method, tracking would be performed as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ViewDidLoad()`方法中，跟踪将如下进行：
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: AdBannerView
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AdBannerView
- en: You have seen these on many different apps. These are the bars at the top that
    advertise anything, from cars to fast food, and normally are targeted on the app
    type (for example, if you design an application that gives statistics on a car
    performance, the ad banner will typically get adverts for car magazines, car games,
    and so on). It is simply a way of generating income for the application developer.
    Advert support is a part of the `AdSupport` namespace.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你在许多不同的应用程序中都见过这些。这些是顶部广告栏，可以宣传从汽车到快餐等各种商品，通常针对应用程序类型（例如，如果你设计一个提供汽车性能统计的应用程序，广告横幅通常会获得汽车杂志、汽车游戏等广告）。这仅仅是一种为应用程序开发者生成收入的方式。广告支持是`AdSupport`命名空间的一部分。
- en: 'The simple way to consider these views is as a form of web view with a number
    of key events:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这些视图的一种简单方式是将其视为一种带有多个关键事件的网页视图：
- en: '`AdLoaded`: until the ad is loaded, the view isn''t shown. This makes the experience
    less obtrusive for the user.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AdLoaded`: 在广告加载之前，视图不会显示。这使得用户体验不那么侵扰。'
- en: '`FailedToReceive`: the advert failed to download.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FailedToReceive`: 广告下载失败。'
- en: Implementing a view with multiple View Controllers
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现包含多个视图控制器（View Controllers）的视图
- en: It is simple enough to implement a view with more than one View Controller.
    Say we have two views. One occupies the top 130 pixels of the screen; the other
    is 250 pixels in height. It is added by adding the second view as a subview to
    the first.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个包含多个视图控制器（View Controller）的视图足够简单。比如说我们有两个视图。一个占据屏幕顶部130像素的空间；另一个高度为250像素。通过将第二个视图作为子视图添加到第一个视图上来实现。
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The events from both the View Controllers will still work as they do normally
    (so say the second view is a web view and the first has some buttons, the buttons
    will still respond to the the Touch events and the web view will still respond
    to the Web events).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 来自两个视图控制器的所有事件仍然会像通常一样工作（比如说第二个视图是一个网页视图，而第一个有一些按钮，按钮仍然会响应触摸事件，网页视图仍然会响应网络事件）。
- en: The issue, though, comes when view 1 (the parent) wants to act on the events
    of view 2\. This too is not that difficult to do. In fact, when dealing with the
    `MT.D` class in [Chapter 2](../Text/part0019.html#page "Chapter 2. The User Interface"),
    *The User Interface*, the `SubView` event was acted on in the parent by overriding
    the `Selected` event with adelegate in another class (as demonstrated in the following
    code examples).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当视图1（父视图）想要对视图2（子视图）的事件做出反应时，问题就出现了。这也不是那么困难。实际上，在处理[第2章](../Text/part0019.html#page
    "第2章. 用户界面")中的`MT.D`类时，*用户界面*，父视图通过在另一个类中重写`Selected`事件并使用代理（adelegate）来处理`SubView`事件（如下面的代码示例所示）。
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And within the class handling `UIPickerViewModel`, the `Selected` method has
    to be overridden to support `PickerChangedEventArgs` as shown in the following
    code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理`UIPickerViewModel`的类中，必须重写`Selected`方法以支持`PickerChangedEventArgs`，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Finally within the main app, code that calls the class `UIPickerView` needs
    to fire on the new event.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在主应用程序中，调用`UIPickerView`类的代码需要在新的事件上触发。
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Summary
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: It is a little wonder that the iPhone is such an adaptable device for displaying
    various forms of data with all of these Views and View types available, despite
    its complexity; it is actually a simple enough system to code for.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在拥有所有这些视图和视图类型的情况下，iPhone能够适应性地显示各种形式的数据，尽管其复杂，但这也并不奇怪；实际上，它是一个足够简单的系统，可以用来编码。
- en: In the next chapter, we will delve deeper into controllers.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地探讨控制器。
