- en: Chapter 1. Thanks for the Memory Game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章 感谢记忆游戏
- en: As children, we learn many useful skills by playing games. We learn coordination,
    strategy, and memory skills. These are all skills we take with us throughout our
    lives. The perfect place to start is a traditional childhood game.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在儿童时期，我们通过玩游戏学习了许多有用的技能。我们学会了协调、策略和记忆技能。这些都是我们一生中都会拥有的技能。一个完美的开始就是传统的童年游戏。
- en: 'In this chapter, we cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了以下主题：
- en: Scenes versus layers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 场景与图层
- en: Sprites and sprite sheets
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精灵和精灵图集
- en: Loading sequential files
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载顺序文件
- en: Random playfield generation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机生成游戏区域
- en: Touch handlers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触摸处理
- en: Using actions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用动作
- en: Basic matching strategies
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本匹配策略
- en: Scoring
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 得分
- en: Tracking lives
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪生命值
- en: Game over conditions
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏结束条件
- en: SimpleSoundEngine
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SimpleSoundEngine
- en: The project is...
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目是...
- en: 'We will begin with classic **memory game**. Not just any memory game – *the*
    memory game that is the source of joy and frustration of children everywhere.
    In case you''ve never been exposed to this game (really?), the gameplay is simple.
    The playing field is a set of tiles with pretty pictures on the front, and a generic
    back image. You turn over two tiles to see if you made a match. If not, you turn
    them back over. Pick another pair of tiles and see if they match. Repeat this
    till all the tiles are matched. Let''s take a look at the finished game:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从经典的**记忆游戏**开始。不仅仅是任何记忆游戏——*就是*那个让孩子们到处都感到快乐和挫折的记忆游戏。如果你从未接触过这个游戏（真的吗？），游戏玩法很简单。游戏区域是一组带有漂亮图片的瓷砖，背面是通用图像。你翻转两张瓷砖来看是否匹配。如果不匹配，你将它们翻回。挑选另一对瓷砖，看看它们是否匹配。重复这个过程，直到所有瓷砖都匹配。让我们看看完成的游戏：
- en: '![The project is...](img/9007_01_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![项目是...](img/9007_01_01.jpg)'
- en: Our memory game needs to be flexible enough to allow different skill levels
    in the game. We will create different skill levels by varying the number of memory
    tiles on the board. If there are four tiles (two each of two designs), that's
    pretty easy. Creating a 4 x 5 grid of tiles is a lot more challenging (20 tiles,
    10 designs). We will build a single project that will handle these variations
    dynamically.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的记忆游戏需要足够灵活，以便允许游戏中有不同的技能水平。我们将通过改变棋盘上的记忆瓷砖数量来创建不同的技能水平。如果有四块瓷砖（每种设计各两块），那就相当简单。创建一个4
    x 5的瓷砖网格要更具挑战性（20块瓷砖，10种设计）。我们将构建一个单一的项目，它可以动态地处理这些变化。
- en: 'Our game will be a little different from the traditional version in two ways:
    it is single player only, and we will add a way to lose the game, to make it more
    exciting. We''ll go into detail on that aspect later.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏在两个方面将与传统版本略有不同：它仅限单人游戏，我们将添加一种输掉游戏的方式，使其更具趣味性。我们将在稍后详细介绍这一点。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We will detail several foundational design approaches in this chapter that will
    be used throughout the book. To avoid repetitive code, later chapters will omit
    some of the boilerplate detail that we cover here.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细介绍几个基础的设计方法，这些方法将在整本书中使用。为了避免代码重复，后续章节将省略我们在这里覆盖的一些样板细节。
- en: Let's build a menu
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们构建一个菜单
- en: We'll start building the project from the default cocos2d v2.x - cocos2d iOS
    template. Once the project is created, we first remove the `HelloWorldLayer.h/.m`
    files. `HelloWorld` is a good starting point for learning the code structure,
    but we don't really want (or need) this boilerplate class for anything (don't
    forget to remove the `#import "HelloWorldLayer.h"` at the top of the `IntroLayer.m`
    class). For now we'll leave the reference in the bottom of the `IntroLayer.m`'s
    `makeTransition` class.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从默认的cocos2d v2.x - cocos2d iOS模板开始构建项目。一旦项目创建完成，我们首先删除`HelloWorldLayer.h/.m`文件。`HelloWorld`是学习代码结构的好起点，但我们实际上并不需要（或需要）这个样板类来做任何事情（别忘了在`IntroLayer.m`类的顶部删除`#import
    "HelloWorldLayer.h"`）。现在我们将保留`IntroLayer.m`的`makeTransition`类底部的引用。
- en: One of the most commonly used classes in the cocos2d framework is probably the
    `CCLayer`. A `CCLayer` is the object that is (usually) represented on the screen,
    and acts as our "canvas" for our game. We use the `CCLayer` object as a basis,
    and then create subclasses of it to add our own game code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在cocos2d框架中最常用的类之一可能是`CCLayer`。`CCLayer`是（通常）在屏幕上表示的对象，并作为我们游戏的“画布”。我们以`CCLayer`对象为基础，然后创建它的子类来添加我们自己的游戏代码。
- en: 'There is another often-used class, the `CCScene` class. A `CCScene` class can
    be thought of as a "container" for `CCLayer` objects. A `CCScene` object is rarely
    used for much more than adding `CCLayer`s as children. A good comparison is like
    the creation of cartoons before the age of computers. Each scene was assembled
    from a stack of transparent plastic sheets, each with a different part of the
    scene on it: each main character would have their own layer, another for the background,
    another for each different element of the scene. Those plastic sheets are the
    equivalent of a `CCLayer` objects, and the `CCScene` class is where these are
    stacked up to display on screen.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个经常使用的类是 `CCScene` 类。可以将 `CCScene` 类视为 `CCLayer` 对象的“容器”。`CCScene` 对象很少用于比添加
    `CCLayer`s 作为子对象更多的事情。一个很好的比较是计算机时代之前的卡通制作。每个场景都是由堆叠的透明塑料片组成的，每张塑料片上都有场景的不同部分：每个主要角色都有自己的层，另一个用于背景，另一个用于场景的每个不同元素。这些塑料片相当于
    `CCLayer` 对象，而 `CCScene` 类就是这些堆叠起来在屏幕上显示的地方。
- en: We will start with a basic `CCLayer` subclass, `MTMenuLayer`. We create a title,
    and a basic menu. We need to pay attention to how we call the `MTPlayfieldScene`
    class (our main game screen) from the menu.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将从基本的 `CCLayer` 子类 `MTMenuLayer` 开始。我们创建一个标题和一个基本的菜单。我们需要注意我们如何从菜单调用 `MTPlayfieldScene`
    类（我们的主要游戏屏幕）。 '
- en: '**Filename:** `MTMenuLayer.m`'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `MTMenuLayer.m`'
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You will notice that the `startGameXXX` methods are calling a custom constructor
    for the scene, rather than the normal `[MyLayer scene]` that is commonly used.
    We will explain the `sceneWithRows:andColumns:` method shortly.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，`startGameXXX` 方法调用的是场景的自定义构造函数，而不是常用的 `[MyLayer scene]`。我们将在稍后解释 `sceneWithRows:andColumns:`
    方法。
- en: This book will not include the complete code within the text. Portions that
    aren't interesting for the discussion will be omitted.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将不会在文本中包含完整的代码。对于讨论不感兴趣的部分将被省略。
- en: Tip
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在 [http://www.packtpub.com](http://www.packtpub.com) 的账户中下载您购买的所有 Packt
    书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问 [http://www.packtpub.com/support](http://www.packtpub.com/support)
    并注册以获取文件
- en: e-mailed directly to you.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 直接发送到您的邮箱。
- en: Where is the scene?
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 场景在哪里？
- en: 'Oh, you noticed? The boilerplate cocos2d template includes a class method `+(id)`
    scene inside the layer (in `HelloWorldLayer`). While this approach works, it can
    lead to confusion as we build more complex scenes with multiple layers. Using
    the template-based approach may seem odd when you call a method that takes a `CCScene`
    object as a parameter, yet you pass it a value like `[MySpecialLayer scene]`.
    So are you referencing a `CCScene` or `CCLayer` object? It makes a lot more logical
    sense to us that you would, in this example, pass a value like `[MySpecialScene
    scene]`. It is less confusing to pass a scene object when a `CCScene` is requested.
    A `CCScene` object is a higher-level container that was designed to contain `CCLayer`
    objects, so why not keep it as its own class? Let''s go ahead and examine our
    approach:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，您注意到了吗？cocos2d 模板中包含一个在层（在 `HelloWorldLayer` 中）内部的类方法 `+(id)` scene。虽然这种方法可行，但随着我们构建更复杂的场景和多个层，它可能会导致混淆。当您调用一个接受
    `CCScene` 对象作为参数的方法时，使用基于模板的方法可能看起来有些奇怪，而您传递的是一个像 `[MySpecialLayer scene]` 这样的值。那么您是在引用
    `CCScene` 对象还是 `CCLayer` 对象呢？在这个例子中，您传递一个像 `[MySpecialScene scene]` 这样的值在逻辑上会更有意义。当请求
    `CCScene` 对象时传递场景对象会更清晰。`CCScene` 对象是一个更高级的容器，它被设计用来包含 `CCLayer` 对象，所以为什么不保持它作为一个独立的类呢？让我们继续检查我们的方法：
- en: '**Filename:** `MTMenuScene.h`'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `MTMenuScene.h`'
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Filename:** `MTMenuScene.m`'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `MTMenuScene.m`'
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here we have followed the convention that the scene method returns an `autoreleased`
    object. We do not explicitly call `alloc` on it (when we instantiate the class),
    so we don't "own" the object.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们遵循了场景方法返回一个 `autoreleased` 对象的惯例。我们不会在它上面显式调用 `alloc`（当我们实例化类时），所以我们不“拥有”这个对象。
- en: 'Now we can go back to the `IntroLayer.m` file, and change the `makeTransition`
    method to point to our new menu scene:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以回到 `IntroLayer.m` 文件，并将 `makeTransition` 方法更改为指向我们新的菜单场景：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We also need to make sure we are importing the `MTMenuScene.h` file in the `AppDelegate.m`
    file. Now that our menu is complete, we can concentrate on the game itself.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要确保在 `AppDelegate.m` 文件中导入了 `MTMenuScene.h` 文件。现在我们的菜单已经完成，我们可以专注于游戏本身。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is important to note that this design of using `CCScene` as a separate class
    in the structure is not universally adopted. Many people choose to follow the
    same approach as the templates. Both ways will work, but we are of the "camp"
    that strongly believes these should kept separate, as we have done here. Both
    ways are perfectly valid coding practice, and you are free to structure your code
    in other way.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，这种使用 `CCScene` 作为结构中单独类的做法并不被普遍采用。许多人选择遵循与模板相同的方法。两种方法都可以工作，但我们属于“阵营”，强烈认为这些应该保持分离，就像我们在这里所做的那样。两种方法都是完全有效的编码实践，你可以自由地以其他方式组织你的代码。
- en: Building the playfield
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建游戏区域
- en: Next, we will add a `CCScene` class to drive our main game screen, here named
    `MTPlayfieldScene`. Much of this looks the same as the `MTMenuScene` class we
    defined earlier, except here we define a method `sceneWithRows:andColumns:` instead
    of the simpler scene method we used in the previous code.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个 `CCScene` 类来驱动我们的主游戏屏幕，这里命名为 `MTPlayfieldScene`。这部分代码与之前定义的 `MTMenuScene`
    类非常相似，只是在这里我们定义了一个方法 `sceneWithRows:andColumns:` 而不是之前代码中使用的更简单的场景方法。
- en: '**Filename:** `MTPlayfieldScene.m`'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `MTPlayfieldScene.m`'
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here we have the custom `sceneWithRows:andColumns:` method we referenced in
    the `MTMenuLayer` earlier. The class method handles the `alloc` and `init` methods,
    and identifies it as an autoreleased object, so we don't have to worry about releasing
    it later. The `sceneWithRows:andColumns:` method passes the rows and columns variables
    directly to the `MTPlayfieldLayer` class' custom `init` method, `layerWithRows:andColumns:`.
    This lets us pass the requested values through the scene to the layer, where we
    can use the values later.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们之前在 `MTMenuLayer` 中引用的定制 `sceneWithRows:andColumns:` 方法。类方法处理 `alloc` 和
    `init` 方法，并将其标识为自动释放的对象，因此我们不必担心稍后释放它。`sceneWithRows:andColumns:` 方法直接将行和列变量传递给
    `MTPlayfieldLayer` 类的定制 `init` 方法 `layerWithRows:andColumns:`。这使得我们可以通过场景将请求的值传递到层，在那里我们可以稍后使用这些值。
- en: We need sprites
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们需要精灵
- en: Before we proceed with building the playing field, we need some graphics to
    use in our game. Our design calls for square images for the tiles, and one image
    to use for the common back of the tiles. Because we want them to be able to scale
    to different sizes (for our different skill levels), we need images large enough
    to look good at the simplest skill level, which is a two by two grid. Unless your
    goal is the "chunky pixel" look, you never want to scale images up. Based on the
    screen size, we want our tiles to be 150 points wide and 150 points high. Since
    we want to use better graphics on iPhone (and iPod Touch) Retina Display devices,
    our -hd version of the graphics will need to be 300 pixels by 300 pixels.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建游戏区域之前，我们需要一些用于游戏中的图形。我们的设计要求使用正方形图像作为瓦片，以及一个用于瓦片共同背面的图像。因为我们希望它们能够适应不同的尺寸（针对不同的技能等级），我们需要足够大的图像，以便在最简单的技能等级（即两个乘以两个的网格）上看起来很好。除非你的目标是“像素块”的外观，否则你永远不希望放大图像。根据屏幕大小，我们希望瓦片的宽度为150点，高度为150点。由于我们希望在iPhone（和iPod
    Touch）Retina显示屏设备上使用更好的图形，我们的-hd图形版本需要是300像素乘以300像素。
- en: Tip
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Points are the easiest way to use cocos2d effectively. On an older iOS Device,
    one point equals one pixel on the screen. On Retina Display devices, one point
    equals *two* pixels, which occupy the same physical space on the screen as the
    one pixel on the non-Retina screens. From a practical perspective, this means
    that once you provide the -hd graphics, cocos2d will treat your Retina and non-Retina
    layouts identically, with no extra layout code. You *can* do things in pixels
    if you really want to, but we wouldn't recommend making a habit of it.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 点是有效使用cocos2d的最简单方式。在较旧的iOS设备上，一个点等于屏幕上的一个像素。在Retina显示屏设备上，一个点等于 *两个* 像素，它们在屏幕上占据与非Retina屏幕上的一个像素相同的物理空间。从实用角度来看，这意味着一旦你提供了-hd图形，cocos2d将把Retina和非Retina布局视为相同，无需额外的布局代码。你
    *可以* 如果真的想的话用像素来做事情，但我们不建议养成这种习惯。
- en: For this game, we will be using a variety of photos. There was some amount of
    manipulation needed to arrive at the proper aspect ratio and size. This is a great
    place to make use of Automator that is part of Mac OS X. There is an Automator
    script in the source code for this chapter inside a folder called `Helpers`. When
    you run it, it will prompt for a folder of images. Once selected, it will create
    a folder on your desktop called `ch1_tiles`, and it will contain sequentially
    numbered images (that is `tile1.png`, `tile2.png`, and so on), with each image
    being exactly 300 pixels by 300 pixels.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这款游戏，我们将使用各种照片。为了达到正确的宽高比和尺寸，需要进行一些调整。这是利用Mac OS X中的Automator的一个绝佳地方。本章源代码中有一个名为`Helpers`的文件夹，里面有一个Automator脚本。当你运行它时，它会提示选择一个图像文件夹。一旦选择，它将在你的桌面上创建一个名为`ch1_tiles`的文件夹，并包含按顺序编号的图像（即`tile1.png`、`tile2.png`等等），每个图像的尺寸正好是300像素×300像素。
- en: 'Two other images will be needed to build the game: `backButton.png` will be
    used for navigation and `tileback.png` will be used as the image for the back
    of the tiles when they are face down.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 需要另外两张图片来构建游戏：`backButton.png`将用于导航，而`tileback.png`将作为翻转时瓷砖背面的图像。
- en: Building a sprite sheet
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建精灵图集
- en: '**Sprite sheets** are one of the foundations of any effective cocos2d game.
    Compiling all of your sprites into sprite sheets lets cocos2d load fewer files
    as well as giving you the ability to use a batch node. We won''t delve into the
    "under the hood" details of the `CCSpriteBatchNode` class here except at a high
    level. When you load a sprite sheet into a batch node, it acts as a "parent" for
    all the sprites on it. When you use a batch node, the calls to draw the sprites
    on the screen are batched together, which gives a performance boost. This batch
    drawing allows the system to draw 100 sprites with about the same efficiency (and
    speed) as drawing one sprite. The bottom line is batch nodes allow you to draw
    a lot more on-screen without slowing your game down.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**精灵图集**是任何有效的cocos2d游戏的基础之一。将所有精灵编译到精灵图集中可以让cocos2d加载更少的文件，同时赋予你使用批处理节点的功能。在这里，我们不会深入探讨`CCSpriteBatchNode`类的“内部细节”，只从高层次上简要说明。当你将精灵图集加载到批处理节点中时，它充当所有图集上精灵的“父节点”。当你使用批处理节点时，绘制屏幕上精灵的调用会被批量处理，这可以提升性能。这种批量绘制允许系统以绘制一个精灵的相同效率（和速度）绘制100个精灵。简而言之，批处理节点允许你在不降低游戏速度的情况下在屏幕上绘制更多内容。'
- en: 'There are two files needed for a sprite sheet: the texture (image file) and
    the plist file. We don''t even want to think about attempting to hand-build the
    sprite sheet. Fortunately, there are a number of very good tools that were built
    for this. The most established sprite sheet tools in the cocos2d community are
    TexturePacker ([http://www.texturepacker.com](http://www.texturepacker.com)) and
    Zwoptex ([http://zwopple.com/zwoptex](http://zwopple.com/zwoptex)), although there
    are a number of newer apps that are also available. Which tool you use is a matter
    of personal preference. Regardless of the tool, you will need to create both the
    standard and -hd versions of the images. (Most current tools have built-in options
    to aid in this process.)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 制作精灵图集需要两个文件：纹理（图像文件）和plist文件。我们甚至不想去尝试手动构建精灵图集。幸运的是，有许多专为这个目的构建的非常好用的工具。在cocos2d社区中，最成熟的精灵图集工具是TexturePacker
    ([http://www.texturepacker.com](http://www.texturepacker.com)) 和 Zwoptex ([http://zwopple.com/zwoptex](http://zwopple.com/zwoptex))，尽管也有许多新应用可供选择。你使用哪个工具完全取决于个人喜好。无论使用哪种工具，你都需要创建图像的标准版和-hd版本。（大多数当前工具都内置了辅助选项以简化此过程。）
- en: 'No matter which tool is used, the desired result is four files: `memorysheet.png`,
    `memorysheet.plist`, `memorysheet-hd.png`, and `memorysheet-hd.plist`. The -hd
    files include the 300 x 300 images for the iPhone Retina Display, and the others
    include the 150 x 150 pixel images for non-Retina iPhone Displays. We also include
    the `backButton.png` and `tileback.png` files in appropriate sizing in both sprite
    sheets as well. Let''s take a look at the final sprite sheet we will use for this
    game:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 无论使用哪种工具，期望的结果是四个文件：`memorysheet.png`、`memorysheet.plist`、`memorysheet-hd.png`和`memorysheet-hd.plist`。-hd文件包含适用于iPhone
    Retina显示屏的300像素×300像素的图像，而其他文件包含适用于非Retina iPhone显示屏的150像素×150像素的图像。我们还将在两个精灵图集中包含适当尺寸的`backButton.png`和`tileback.png`文件。让我们看看我们将用于这款游戏的最终精灵图集：
- en: '![Building a sprite sheet](img/9007_01_02.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![构建精灵图集](img/9007_01_02.jpg)'
- en: On to the playfield
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进入游戏场
- en: Now we're ready to get to the playfield layer itself. We know we need to keep
    track of the size of the game screen, how big each tile should be, how big the
    game board should be, and how much spacing we need between the tiles when they
    are laid out in a grid.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好进入游戏区域层本身。我们知道我们需要跟踪游戏屏幕的大小、每个瓷砖的大小、游戏板的大小以及当瓷砖以网格形式排列时它们之间的间距。
- en: Creating the playfield header
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建游戏区域头文件
- en: In the header, we also have the declaration for the class method `initWithRows:andColumns:`
    that we called in the `MTPlayfieldScene` class.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在头文件中，我们还声明了类方法 `initWithRows:andColumns:`，这是我们之前在 `MTPlayfieldScene` 类中调用的。
- en: '**Filename:** `MTPlayfieldLayer.h`'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `MTPlayfieldLayer.h`'
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: One item to point out in the header is the `CGSize size` variable. This is a
    convenience variable we use to avoid repetitive typing. The name `size` is an
    abbreviation for `winSize`, which is a value that the `CCDirector` class will
    provide for you that identifies the size of the screen, in points. You can read
    the value from the `CCDirector` every time you use it, but doing so will make
    your code lines a bit longer. Our approach will work fine, as long as we do not
    support both portrait and landscape modes in the same layer. If we do allow both
    orientations, then the value we have cached in the `size` variable will be incorrect.
    Since our app only allows `LandscapeLeft` and `LandscapeRight` orientations, the
    size is identical in both orientations, so the `size` will be stable for our game.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在头文件中需要指出的一点是 `CGSize size` 变量。这是一个方便的变量，我们用它来避免重复输入。名称 `size` 是 `winSize` 的缩写，这是一个
    `CCDirector` 类将为您提供用于标识屏幕大小的值，单位为点。每次使用时，您都可以从 `CCDirector` 中读取该值，但这样做会使您的代码行稍微长一些。我们的方法将正常工作，只要我们不支持同一层中的纵向和横向模式。如果我们允许两种方向，那么我们缓存在
    `size` 变量中的值将是不正确的。由于我们的应用程序只允许 `LandscapeLeft` 和 `LandscapeRight` 方向，两种方向的大小是相同的，因此
    `size` 将在我们的游戏中保持稳定。
- en: Creating the playfield layer
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建游戏区域层
- en: 'In the `MTPlayfieldLayer.m` file, we implement our custom `layerWithRows:andColumns:`
    and `initWithRows:andColumns:` methods as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MTPlayfieldLayer.m` 文件中，我们实现了自定义的 `layerWithRows:andColumns:` 和 `initWithRows:andColumns:`
    方法，具体如下：
- en: '**Filename:** `MTPlayfieldLayer.m`'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `MTPlayfieldLayer.m`'
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The class method `layerWithRows:andColumns:` is the method we saw in the `MTPlayfieldScene`
    class earlier. The class method calls the `alloc` and `initWithRows: andColumns:`
    methods, and then wraps it all in an `autorelease` call since it is a convenience
    method. The instance method `initWithRows:AndColumns:` (called by the class method)
    sets up a few of the variables we established in the header, including the assignment
    of our passed `numRows` and `numColumns` parameters into the instance variables
    `boardRows` and `boardColumns`.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 类方法 `layerWithRows:andColumns:` 是我们在之前的 `MTPlayfieldScene` 类中看到的那个方法。类方法调用 `alloc`
    和 `initWithRows:andColumns:` 方法，然后通过一个 `autorelease` 调用来包装所有这些操作，因为它是一个方便的方法。实例方法
    `initWithRows:AndColumns:`（由类方法调用）设置了一些在头文件中建立的变量，包括将传递的 `numRows` 和 `numColumns`
    参数分配到实例变量 `boardRows` 和 `boardColumns` 中。
- en: Memory games are traditionally played with a square or rectangular layout. They
    also need an even number of tiles in the game, since there will be two of each
    type of tile. Because we are allowing flexible parameters for the number of rows
    and the number of columns, there are certain combinations that will not work.
    Requesting five rows and five columns means we will have 25 tiles on the board,
    which is impossible to win. To protect our game from these invalid values, we
    multiply the `boardRows` times the `boardColumns`. If the result is not even (using
    the % 2 check), then we remove one `boardRow` from the game. From the prior example,
    if we requested a five by five board (resulting in 25 tiles), the code would alter
    it to a four by five grid, which has 20 tiles.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 记忆游戏传统上以方形或矩形布局进行。它们还需要游戏中有偶数个瓷砖，因为每种类型的瓷砖将有两个。由于我们允许行数和列数的灵活参数，某些组合将无法工作。请求五行五列意味着我们将有
    25 个瓷砖在板上，这是不可能获胜的。为了保护我们的游戏不受这些无效值的影响，我们将 `boardRows` 乘以 `boardColumns`。如果结果是奇数（使用
    % 2 检查），则从游戏中移除一个 `boardRow`。从先前的例子中，如果我们请求一个五乘五的板（结果为 25 个瓷砖），代码将将其更改为四乘五的网格，该网格有
    20 个瓷砖。
- en: We also set the `tileSize` value here, based on an even spacing of the tiles,
    along with the extra pad space we will be using between the tiles. Because we
    need square tiles, there is also the additional check to force the tiles to be
    square if the source images are not. This will distort the images, but it won't
    disrupt the game mechanics. Additionally, the `boardOffsetX` and `boardOffsetY`
    variables simply ensure the board will be nicely centered in the available board
    space.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在这里设置了`tileSize`值，基于瓷砖的均匀间距，以及我们将在瓷砖之间使用的额外填充空间。因为我们需要正方形瓷砖，所以还有一个额外的检查来强制瓷砖成为正方形，即使源图像不是正方形也是如此。这将扭曲图像，但不会破坏游戏机制。此外，`boardOffsetX`和`boardOffsetY`变量只是确保棋盘将在可用的棋盘空间中居中。
- en: The flow of the game
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏流程
- en: 'We will need several arrays in the game to help track the tiles. The first,
    `tilesAvailable`, will be used in the loading and building of the playfield. The
    second, `tilesInPlay`, will contain all of the tiles that have not yet been matched.
    The third, `tilesSelected`, will be used for the match detection methods. Since
    we are handling a relatively small number of tiles, using this multiple array
    structure will work fine for our purposes without any performance concerns. Let''s
    add the code for the arrays now:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在游戏中使用几个数组来帮助跟踪瓷砖。第一个，`tilesAvailable`，将用于加载和构建游戏区域。第二个，`tilesInPlay`，将包含所有尚未匹配的瓷砖。第三个，`tilesSelected`，将用于匹配检测方法。由于我们处理的瓷砖数量相对较少，使用这种多数组结构将非常适合我们的目的，而不会引起任何性能问题。现在让我们添加数组的代码：
- en: '**Filename:** `MTPlayfieldLayer.h` (already in variable declarations)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `MTPlayfieldLayer.h` (已在变量声明中)'
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Filename:** `MTPlayfieldLayer.m` (`initWithRows`, add after "Initialize the
    arrays")'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `MTPlayfieldLayer.m` (`initWithRows`，在“初始化数组”之后添加)'
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here we established the three `NSMutableArray` arrays in the header as variables,
    instantiated them in the `initWithRows:andColumns:` method, and added them to
    a new `dealloc` method. The `dealloc` method releases the three arrays. The `[super
    dealloc]` call is always required, and it should be the last line of the `dealloc`
    method. This call to `super dealloc` tells the parent class of the current class
    to do whatever it needs to clean up. This is important to call because our current
    class doesn't have to worry about the details of any clean up that is done by
    the parent `CCLayer` class.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在头文件中作为变量建立了三个`NSMutableArray`数组，在`initWithRows:andColumns:`方法中实例化了它们，并将它们添加到一个新的`dealloc`方法中。`dealloc`方法释放了这三个数组。`[super
    dealloc]`调用始终是必需的，并且它应该是`dealloc`方法的最后一行。这个对`super dealloc`的调用告诉当前类的父类执行它需要做的任何清理工作。这一点很重要，因为我们的当前类不需要担心由父`CCLayer`类执行的任何清理细节。
- en: A stack of tiles
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 瓷砖堆
- en: Now we need to define the class for the tiles themselves. We have a few variables
    we need to track for the tiles and we will use the `MTMemoryTile` class to handle
    some of the touch detection and tile animation.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要定义瓷砖本身的类。我们需要跟踪一些瓷砖变量，我们将使用`MTMemoryTile`类来处理一些触摸检测和瓷砖动画。
- en: The memory tile class
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记忆瓷砖类
- en: For this, we will be subclassing `CCSprite`. This will allow us to still treat
    it like a `CCSprite`, but we will enhance it with other methods and properties
    specific to the tile.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，我们将继承`CCSprite`。这将允许我们仍然将其视为`CCSprite`，但我们将通过其他方法和属性来增强它，这些方法和属性是针对瓷砖的特定功能。
- en: '**Filename:** `MTMemoryTile.h`'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `MTMemoryTile.h`'
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here we are declaring the variables with an underscore prefix, but we set the
    corresponding property without the underscore prefix. This is usually done to
    avoid accidentally setting the variable value directly, which would bypass the
    getter and setter methods for the property. This split-naming is finalized in
    the `@synthesize` statements in the `.m` file, where the property will be set
    to the variable. These statements will be of the basic format:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用下划线前缀来声明变量，但我们将相应的属性设置为没有下划线前缀。这通常是为了避免意外直接设置变量值，从而绕过属性的getter和setter方法。这种拆分命名在`.m`文件中的`@synthesize`语句中最终确定，其中属性将被设置为变量。这些语句将具有基本格式：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We''re planning ahead with this class, including the headers for three methods
    that we will use for the tile animation: `flipTile`, `showFace`, and `showBack`
    . This class will be responsible for handling its own animation.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个类中提前规划，包括三个我们将用于瓷砖动画的方法的头文件：`flipTile`、`showFace`和`showBack`。这个类将负责处理自己的动画。
- en: All animation in our game will be done using cocos2d actions. Actions are essentially
    transformations of some sort that can be "run" on most types of cocos2d objects
    (for example, `CCLayer`, `CCSprite`, and so on). There are quite a number of different
    actions defined in the framework. Some of the most commonly used are actions such
    as `CCMoveTo` (to move an object), `CCScaleTo` (to change the scale of the object),
    and `CCCallFunc` (to call another method). Actions are a "fire and forget" feature.
    Once you schedule an action, unless you explicitly change the action (such as
    calling `stopAllActions`), the actions will continue until complete. This is further
    extended by "wrapping" several actions together in a `CCSequence` action, which
    allows you to chain several actions together, to be run in the order specified.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中的所有动画都将使用cocos2d动作完成。动作本质上是一些可以“运行”在大多数类型的cocos2d对象上（例如，`CCLayer`，`CCSprite`等）的变换。框架中定义了相当多的不同动作。其中一些最常用的动作包括`CCMoveTo`（移动对象），`CCScaleTo`（改变对象的缩放），以及`CCCallFunc`（调用另一个方法）。动作是一个“点火后忘记”的功能。一旦你安排了一个动作，除非你明确地更改动作（例如调用`stopAllActions`），否则动作将继续直到完成。这通过在`CCSequence`动作中“包装”几个动作进一步扩展，这允许你将几个动作链接在一起，按照指定的顺序运行。
- en: We will use `CCSequence` "chaining" extensively throughout the book. Actions
    can be run on most cocos2d objects, but they are most commonly called (via the
    `runAction:` method) on the `CCSprite` and `CCLayer` objects.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在整本书中广泛使用`CCSequence`“链接”。动作可以在大多数cocos2d对象上运行，但它们最常见的是通过`runAction:`方法在`CCSprite`和`CCLayer`对象上调用。
- en: '**Filename:** `MTMemoryTile.m`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `MTMemoryTile.m`'
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We will not be using a touch handler inside this class, since we will need to
    handle the matching logic in the main layer anyway. Instead, we expose the `containsTouchLocation`
    method , so the layer can "ask" the individual tiles if they were touched. This
    uses the tile's `boundingBox`, which is baked-in functionality in cocos2d. A `boundingBox`
    is a `CGRect` representing the smallest rectangle surrounding the sprite image
    itself.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不会在这个类中使用触摸处理程序，因为我们无论如何都需要在主层中处理匹配逻辑。相反，我们公开`containsTouchLocation`方法，以便层可以“询问”单个瓦片是否被触摸。这使用瓦片的`boundingBox`，这是cocos2d中内置的功能。`boundingBox`是一个`CGRect`，代表围绕精灵图像本身的最小矩形。
- en: We also see the `showFace` and `showBack` methods. These methods will set a
    new display frame for the tile. In order to retain the name of the sprite frame
    that is used for the face of this tile, we use the `faceSpriteName` variable to
    hold the sprite frame name (which is also the original image filename). We don't
    need to keep a variable for the tile back, since all tiles will be using the same
    image, so we can safely hardcode that name.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了`showFace`和`showBack`方法。这些方法将为瓦片设置一个新的显示帧。为了保留用于此瓦片面部的精灵帧名称，我们使用`faceSpriteName`变量来保存精灵帧名称（它也是原始图像文件名）。我们不需要保留瓦片背面的变量，因为所有瓦片都将使用相同的图像，因此我们可以安全地硬编码该名称。
- en: 'The `flipTile` method makes use of the `CCOrbitCamera` to deform the tile by
    rotating the "camera" around the sprite image. This is a bit of visual trickery
    and isn''t a perfect flip (some extra deformation occurs nearer the edges of the
    screen), but it gives a fairly decent animation without a lot of heavy coding
    or prerendered animations. Here we use a `CCSequence` action to queue three actions.
    The first action, `rotateToEdge`, will rotate the tile on its axis until it is
    edge-wise to the screen. The second calls out to the `changeFace` method, which
    will do an instant swap between the front and back of the tile. The third action,
    `rotateFlat`, completes the rotation back to the original "flat" orientation.
    The same `flipTile` method can be used for flipping to the front and flipping
    to the back, because the `isFaceUp` Boolean being used allows the `changeTile`
    method to know whether front or back should be visible. Let''s look at following
    screenshot, which shows the tile flips, in mid-flip:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`flipTile`方法利用`CCOrbitCamera`通过围绕精灵图像旋转“相机”来变形瓦片。这是一种视觉技巧，并不是完美的翻转（屏幕边缘附近发生了一些额外的变形），但它提供了相当不错的动画，而不需要大量的重编码或预渲染动画。在这里，我们使用`CCSequence`动作来排队三个动作。第一个动作`rotateToEdge`将瓦片绕其轴旋转，直到它边缘对齐屏幕。第二个动作调用`changeFace`方法，这将立即在瓦片的前后之间进行交换。第三个动作`rotateFlat`完成旋转，回到原始的“平坦”方向。相同的`flipTile`方法可以用于翻转到前面和翻转到后面，因为正在使用的`isFaceUp`布尔值允许`changeTile`方法知道是否应该显示前面或后面。让我们看看以下截图，它显示了瓦片的翻转，处于翻转过程中：'
- en: '![The memory tile class](img/9007_01_03.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![记忆瓷砖类](img/9007_01_03.jpg)'
- en: Tip
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the color images of this book**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载本书的彩色图像**'
- en: We also provide you a PDF file that has color images of the screenshots/diagrams
    used in this book. The color images will help you better understand the changes
    in the output.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还为您提供了一个包含本书中使用的截图/图表彩色图像的PDF文件。彩色图像将帮助您更好地理解输出中的变化。
- en: You can download this file from [http://www.packtpub.com/sites/default/files/downloads/9007OS_ColoredImages.pdf](http://www.packtpub.com/sites/default/files/downloads/9007OS_ColoredImages.pdf)
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://www.packtpub.com/sites/default/files/downloads/9007OS_ColoredImages.pdf](http://www.packtpub.com/sites/default/files/downloads/9007OS_ColoredImages.pdf)下载此文件。
- en: Loading tiles
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载瓷砖
- en: 'Now we have our tile class, we''re ready to load some tiles into the `tilesAvailable`
    array:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的瓷砖类，我们准备将一些瓷砖加载到`tilesAvailable`数组中：
- en: '**Filename:** `MTPlayfieldLayer.m`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `MTPlayfieldLayer.m`'
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here we loop through all the unique tiles we need (up to the value of `maxTiles`,
    which is set to half of the available spaces on the board). Inside that loop,
    we set up another *for* loop that counts to `2`. We do this because we need two
    copies of each tile to assemble our board. Since we have established that our
    tiles are named as `tile#.png`, we create an `NSString` with the incremental name,
    and create an `MTMemoryTile` object with a standard `CCSprite` constructor. As
    we said earlier, we want to keep a copy of the image name for the `showFace` method,
    so we set the `faceSpriteName` variable to that value. It wouldn't be much of
    a game if we had all the tiles face up, so we call `showBack`, so the tiles are
    face down before they are used on screen. Finally, we add the tile we just created
    to the `tilesAvailable` array. Once this method completes, the `tilesAvailable`
    array will be the only retain we have on the tiles.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们遍历所有需要的独特瓷砖（最多到`maxTiles`的值，这是设置为板上可用空间一半的值）。在这个循环内部，我们设置另一个计数到`2`的`for`循环。我们这样做是因为我们需要每个瓷砖的两个副本来组装我们的板。因为我们已经确定我们的瓷砖被命名为`tile#.png`，我们创建一个带有递增名称的`NSString`，并使用标准的`CCSprite`构造函数创建一个`MTMemoryTile`对象。正如我们之前所说的，我们想要保留图像名称的副本用于`showFace`方法，所以我们设置`faceSpriteName`变量为该值。如果所有瓷砖都是正面朝上，那就不会是一个很好的游戏，所以我们调用`showBack`，这样在屏幕上使用之前，瓷砖都是背面朝下。最后，我们将我们刚刚创建的瓷砖添加到`tilesAvailable`数组中。一旦此方法完成，`tilesAvailable`数组将是我们在瓷砖上唯一的保留。
- en: Drawing tiles
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制瓷砖
- en: 'Now we need to draw a randomly selected tile in every position to make a nice
    grid. First we need to figure out where each tile should be positioned. If we
    were using a fixed number of tiles, we could use absolute positioning. To account
    for the dynamic number of tiles, we add a "helper" method to determine positioning
    as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要在每个位置随机选择一个瓷砖来形成一个漂亮的网格。首先，我们需要确定每个瓷砖应该放置的位置。如果我们使用固定数量的瓷砖，我们可以使用绝对定位。为了适应动态数量的瓷砖，我们添加了一个“辅助”方法来确定定位，如下所示：
- en: '**Filename:** `MTPlayfieldLayer.m`'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `MTPlayfieldLayer.m`'
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To calculate the x position, we determine the total footprint of a single tile
    and the associated padding. We multiply this times the column number minus one
    half. We add this result to the board offset we calculated earlier. Why do we
    subtract one half? This is because our positions are based on the complete size
    of the tile and the padding. What we need is the center point of the tile, because
    that is our `anchorPoint` (that is the point on which the tile will pivot or rotate.).
    We need this anchor point left at the center (the default `anchorPoint` for a
    `CCSprite` object, as it happens), because when we flip the tiles, the flip will
    be based on this `anchorPoint`, so we want them to flip around the middle of the
    tile. Now that we have our tile positioning established, we can go ahead and start
    building the tiles on the screen.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算x位置，我们确定单个瓷砖的总占用面积以及相关的填充。我们将这个值乘以列数减去一半。然后，我们将这个结果加到之前计算出的板偏移量上。为什么我们要减去一半？这是因为我们的位置是基于瓷砖的完整大小和填充。我们需要的是瓷砖的中心点，因为那是我们的`anchorPoint`（即瓷砖将围绕其翻转或旋转的点）。我们需要这个锚点在左侧中心（对于`CCSprite`对象来说，这是默认的`anchorPoint`），因为当我们翻转瓷砖时，翻转将基于这个`anchorPoint`，所以我们希望它们围绕瓷砖的中间翻转。现在我们已经确定了瓷砖的位置，我们可以继续在屏幕上构建瓷砖。
- en: '**Filename:** `MTPlayfieldLayer.m`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `MTPlayfieldLayer.m`'
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here we use two nested *for* loops to iterate through all rows and all columns.
    We use `arc4random()` to select a random tile from the `tilesAvailable` array
    and build a new `MTMemoryTile` object that references the tile selected. After
    setting the `MTMemoryTile` object's variables for which row and column it represents,
    we set the scale factor for the tile. Since our images are bigger than needed
    for most game types, we divide the desired `tileSize` by the actual `contentSize`
    of the image. When applied, this will correctly scale our image to the desired
    display size. We only use the x (width) value, since we already enforced in the
    `initWithRows:andColumns:` method that the images will always be square.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用两个嵌套的`for`循环来遍历所有行和所有列。我们使用`arc4random()`从`tilesAvailable`数组中选择一个随机瓷砖，并构建一个新的`MTMemoryTile`对象，该对象引用所选的瓷砖。在设置`MTMemoryTile`对象代表哪一行和哪一列的变量之后，我们设置瓷砖的缩放因子。由于我们的图像比大多数游戏类型所需的都要大，我们将所需的`tileSize`除以实际的`contentSize`。当应用时，这将正确地将我们的图像缩放到所需的显示大小。我们只使用x（宽度）值，因为我们已经在`initWithRows:andColumns:`方法中强制执行了图像总是正方形的。
- en: We use the `tilePosforRow` method to determine where it should be on the layer,
    and we add it. After adding it to the layer, we also add the new tile to the `tilesInPlay`
    array and remove it from the `tilesAvailable` array. By removing it from `tilesAvailable`,
    we ensure that we cannot select the same tile twice. After all iterations of the
    nested loops, the `tilesAvailable` array should be empty, and the board should
    be fully populated with tiles.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`tilePosforRow`方法来确定它应该在层上的位置，并将其添加进去。在将其添加到层之后，我们还将新的瓷砖添加到`tilesInPlay`数组中，并从`tilesAvailable`数组中移除它。通过从`tilesAvailable`中移除它，我们确保我们不会两次选择相同的瓷砖。在嵌套循环的所有迭代之后，`tilesAvailable`数组应该为空，并且棋盘应该完全用瓷砖填充。
- en: Adding interactivity
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加交互性
- en: 'Now that we have our randomized grid of tiles on the board, we need to add
    the touch handler to let us interact with them. Since our game mechanics are pretty
    simple, we will use just the `ccTouchesEnded` method as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在棋盘上有了随机排列的瓷砖网格，我们需要添加触摸处理程序来让我们与之交互。由于我们的游戏机制相当简单，我们将只使用`ccTouchesEnded`方法，如下所示：
- en: '**Filename:** `MTPlayfieldLayer.m`'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `MTPlayfieldLayer.m`'
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the touch handler, the touches are provided in an `NSSet`. However, since
    we do not have multiple touches enabled, we can be sure we will only be getting
    a single touch that we care about. Why is there no multi-touch in this game? Multiple
    simultaneous touches would cause confusion for the player and really complicate
    the code to determine which tiles should be checked for a match. So by not enabling
    multiple touches, we save ourselves extra work, and reduce the confusion for the
    flow of the game.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在触摸处理程序中，触摸是通过`NSSet`提供的。然而，由于我们没有启用多个触摸，我们可以确信我们只会得到一个我们关心的单一触摸。为什么这个游戏中没有多触摸功能？多个同时触摸会让玩家感到困惑，并且会极大地复杂化确定哪些瓷砖应该进行检查以匹配的代码。因此，通过不启用多触摸，我们节省了额外的努力，并减少了游戏流程中的困惑。
- en: The first section of the method checks to see if we have reached a game over
    state (as represented by a `YES` value in the `isGameOver` variable, any touch
    after we have reached game over will return the player to the menu screen.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的第一部分检查我们是否达到了游戏结束状态（由`isGameOver`变量中的`YES`值表示），任何在达到游戏结束后的触摸都将将玩家返回到菜单屏幕。
- en: The second section of the method is detecting touches on the back button. The
    `location` and `convLoc` variables together convert the touch into a coordinate
    in our game screen. We use this location to check if the `backButton` was touched.
    If it has been touched, we also exit to the menu screen, regardless of what else
    is going on in the game.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的第二部分是检测对返回按钮的触摸。`location`和`convLoc`变量一起将触摸转换为我们游戏屏幕中的坐标。我们使用这个位置来检查是否触摸了`backButton`。如果已经触摸，无论游戏中发生什么，我们也会退出到菜单屏幕。
- en: We then check to make sure the `tilesSelected` array doesn't have two items
    in it. The `tilesSelected` array is with the tiles that have been flipped face
    up. If there are two tiles already face up, that means the match checking has
    not yet been resolved. In those cases, we don't want to let the user keep flipping
    over tiles, so we simply return without responding to the touch. This will effectively
    throw away the touch, so we can safely move on with our game.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来检查确保`tilesSelected`数组中没有两个项目。`tilesSelected`数组包含已经翻转过来的瓷砖。如果有两个瓷砖已经翻转过来，这意味着匹配检查尚未解决。在这些情况下，我们不希望让用户继续翻转瓷砖，所以我们简单地返回而不响应触摸。这将有效地丢弃触摸，因此我们可以安全地继续我们的游戏。
- en: 'If we don''t have two tiles selected already, then we iterate through all of
    the tiles in the `tilesInPlay` array and poll it to determine: a) are you being
    touched? and b) are you face down. If both of these are `true`, we send the message
    to the touched tile to flip over (`flipTile`), and we add the tile to the `tilesSelected`
    array. If this was our second tile added to the `tilesSelected` array, we will
    call the `checkForMatch` method after a delay of one second. This delay gives
    us two benefits: it allows the player to see the potential match they just made,
    and it gives plenty of time to finish iterating through the `tilesInPlay` array
    so we don''t risk mutating the array. **Mutating** an array means you tried to
    change it while it was being evaluated. If we skipped the delay, the `checkForMatch`
    method would cause this mutation (and crash) because it can remove tiles from
    the `tilesInPlay` array. Go ahead and try it yourself. Actually seeing the error
    messages when you know what you did wrong will help you know where to look later,
    when you cause a crash without knowing what you did wrong.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们还没有选择两个瓷砖，那么我们就遍历`tilesInPlay`数组中的所有瓷砖，并对其进行轮询以确定：a) 是否被触摸？b) 是否面朝下。如果这两个条件都为`true`，我们向被触摸的瓷砖发送消息以翻转它（`flipTile`），并将其添加到`tilesSelected`数组中。如果这是添加到`tilesSelected`数组的第二个瓷砖，我们将在一秒后调用`checkForMatch`方法。这种延迟有两个好处：它允许玩家看到他们刚刚做出的潜在匹配，并且有足够的时间完成遍历`tilesInPlay`数组，这样我们就不会冒着修改数组的危险。**修改**数组意味着你在它被评估时尝试更改它。如果我们跳过了延迟，`checkForMatch`方法就会导致这种修改（和崩溃），因为它可以从`tilesInPlay`数组中移除瓷砖。试试看吧。当你知道你做错了什么时，实际看到错误信息将有助于你了解稍后当你不知道自己做了什么时崩溃的位置。
- en: Checking for matches
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查匹配
- en: Since we have done quite a bit of preparation for the rest of the mechanics
    of the game, it might come as a surprise that the logic to check for matching
    tiles is very simple. Since we stored the name of the image used for each tile
    inside the `MTMemoryTile` object, it is a matter of comparing the two and see
    if they are the same.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经为游戏的其余机制做了很多准备工作，因此检查匹配瓷砖的逻辑可能非常简单可能会让人感到惊讶。由于我们在`MTMemoryTile`对象内部存储了每个瓷砖使用的图像名称，所以只需要比较这两个名称是否相同即可。
- en: '**Filename:** MTPlayfieldLayer.m'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** MTPlayfieldLayer.m'
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you recall, in the `ccTouchesEnded` method we stored the face up tile in
    the `tilesSelected` array. Our logic only allows there to be two objects in the
    `tilesSelected` array, and the `checkForMatch` method is called only when there
    are two objects in that array. Because of those restrictions, we can safely assume
    that there are objects in that array at index `0` and index `1`. (We create references
    to them as `tileA` and `tileB` to make the code simpler.)
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，在`ccTouchesEnded`方法中，我们将翻转的瓷砖存储在`tilesSelected`数组中。我们的逻辑只允许数组中有两个对象，并且只有当数组中有两个对象时才调用`checkForMatch`方法。由于这些限制，我们可以安全地假设该数组中存在索引`0`和索引`1`的对象。（我们创建对它们的引用作为`tileA`和`tileB`以使代码更简单。）
- en: It is trivial at this point to call `isEqualToString` on the `faceSpriteName`
    variable of `tileA` and pass it the value of the `faceSpriteName variable from
    tileB`. If these strings are equal, we have a match. When comparing strings, you
    cannot use `==` operations, you must use `isEqualToString:`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，调用`isEqualToString`对`tileA`的`faceSpriteName`变量，并传递`tileB`的`faceSpriteName`变量的值是微不足道的。如果这些字符串相等，我们就找到了匹配。在比较字符串时，你不能使用`==`操作符，你必须使用`isEqualToString:`。
- en: When a match is found, we call the `removeMemoryTile` method that simply removes
    the tile passed. If we don't have a match, we send the message to each tile to
    flip itself back over. Since we have resolved the matching, either by making a
    match or by turning the tiles back over, we then remove the tiles from the `tilesSelected`
    array so we have an empty array to hold the next possible match.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当找到匹配时，我们调用`removeMemoryTile`方法，该方法简单地移除传递的瓷砖。如果没有找到匹配，我们向每个瓷砖发送消息，使其翻转回来。由于我们已经通过匹配或翻转瓷砖解决了匹配问题，因此我们从`tilesSelected`数组中移除瓷砖，以便有一个空数组来保存下一个可能的匹配。
- en: Scoring and excitement
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 得分和兴奋感
- en: The game works well with the development we have covered, but there are a few
    places where we can add a little more visual flair and some excitement. Players
    love having a game that keeps score. They also love animation. There is excitement
    to be had by having the ability to lose. Let's give the player what they want.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏与我们所涵盖的开发工作配合得很好，但有几个地方我们可以添加一些视觉亮点和一些兴奋感。玩家喜欢有计分的游戏。他们还喜欢动画。拥有失败的能力可以带来兴奋感。让我们给玩家他们想要的东西。
- en: We build the score and lives displays using `CCLabelTTF` labels, with the variables
    `playerScore` and `livesRemaining` as their label contents. These are declared
    as variables of the layer, so we can easily update them. When we start animating
    tiles, it will be useful to know where the score and lives displays are on screen.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `CCLabelTTF` 标签构建分数和生命值显示，其中 `playerScore` 和 `livesRemaining` 作为它们的标签内容。这些被声明为层的变量，因此我们可以轻松地更新它们。当我们开始动画瓦片时，知道分数和生命值显示在屏幕上的位置将是有用的。
- en: 'There are two main approaches to adding text to the screen: `CCLabelTTF` and
    `CCLabelBMFont` . Both have their uses, which we will briefly outline here. `CCLabelTTF`
    uses a standard TTF font file. The way it draws the text on the screen is not
    very efficient and can cause performance issues in some uses. The other approach,
    `CCLabelBMFont`, uses a bitmap (image file) of the font and internally uses a
    batch node to render the text. This means it is highly efficient at drawing, with
    very little performance concern. Other than the use of a TTF file versus an image
    file, the way you code for them is very similar. One potential issue with a `BMFont`
    file is that you must have the entire font in a single bitmap. If you are using
    a large font size, this often causes you to need to leave out some characters
    that may be needed to support international keyboards. A TTF file does not have
    this problem. Also, it is common with the `CCLabelBMFont` approach to have multiple
    versions of the font if you want to use different font sizes. In this book, we
    will use `CCLabelTTF` labels throughout because we do not have any performance
    (frame rate) concerns with any of these projects.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 向屏幕添加文本主要有两种方法：`CCLabelTTF` 和 `CCLabelBMFont`。两者都有其用途，我们在这里简要概述。`CCLabelTTF`
    使用标准的 TTF 字体文件。它在屏幕上绘制文本的方式效率不高，可能会在某些应用中引起性能问题。另一种方法，`CCLabelBMFont`，使用字体的位图（图像文件），并在内部使用批处理节点来渲染文本。这意味着它在绘制时非常高效，几乎没有性能问题。除了使用
    TTF 文件与图像文件的区别外，为它们编码的方式非常相似。`BMFont` 文件的一个潜在问题是，你必须在一个位图中拥有整个字体。如果你使用大字体大小，这通常意味着你需要省略一些可能需要的字符，以支持国际键盘。TTF
    文件没有这个问题。此外，如果你想要使用不同的字体大小，使用 `CCLabelBMFont` 方法通常会有多个字体的版本。在这本书中，我们将使用 `CCLabelTTF`
    标签，因为我们没有在这些项目中遇到任何性能（帧率）问题。
- en: If we were to have performance issues, we would certainly switch to using `CCLabelBMFont`
    instead of `CCLabelTTF`. We leave it as an exercise for the reader to convert
    these projects to use the `CCLabelBMFont` class. (For creation of the bitmaps,
    an excellent resource is Glyph Designer, available at [http://glyphdesigner.71squared.com](http://glyphdesigner.71squared.com).)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们遇到性能问题，我们肯定会切换到使用 `CCLabelBMFont` 而不是 `CCLabelTTF`。我们将将其转换为使用 `CCLabelBMFont`
    类的任务留给读者去完成。（对于位图的创建，一个很好的资源是 Glyph Designer，可在 [http://glyphdesigner.71squared.com](http://glyphdesigner.71squared.com)
    获取。）
- en: '**Filename:** `MTPlayfieldLayer.m`'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `MTPlayfieldLayer.m`'
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Rather than hardcoding the values in multiple places, it is a preferred approach
    to create helper methods such as `scorePosition` and `livesPosition`, which return
    a `CGPoint` reference of where those elements are onscreen. Here we see the calculations,
    which place the score and lives near the left edge of the screen, with the score
    three quarters of the way up the screen, and the lives one quarter of the way
    up the screen.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是在多个地方硬编码值，创建辅助方法如 `scorePosition` 和 `livesPosition` 是一种更受欢迎的方法，这些方法返回屏幕上这些元素的位置的
    `CGPoint` 引用。在这里，我们看到计算结果，将分数和生命值放置在屏幕的左侧边缘附近，分数位于屏幕的三分之二处，生命值位于屏幕的四分之一处。
- en: The creation of simple labels is very basic, using the positioning we saw above.
    To see how the score and lives are created, please consult the accompanying code
    bundle for this book.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 创建简单的标签非常基础，使用我们上面看到的定位。要了解分数和生命值是如何创建的，请参阅本书的配套代码包。
- en: 'Now we will need a way to score and animate the tiles when the player makes
    a successful match. When a match is scored, we will fly the tiles to the score,
    and then have them shrink into the score position until they disappear. Let''s
    see how that works:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当玩家完成一次成功的匹配时，我们需要一种方法来评分和动画瓦片。当匹配得分时，我们将瓦片飞到分数处，然后让它们缩小到分数位置，直到消失。让我们看看这是如何工作的：
- en: '**Filename:** `MTPlayfieldLayer.m`'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名：** `MTPlayfieldLayer.m`'
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here we leverage the cocos2d actions heavily, using the stock actions of `CCMoveTo`,
    `CCScaleTo`, `CCDelayTime`, and `CCCallFuncND`. One aspect of our flying-to-score
    effect is that we want the tiles to move at a constant rate. If we hardcoded a
    duration for the `CCMoveTo` action, the tiles closer to the score would move slowly,
    and those farther away would move really fast. To achieve a constant rate, we
    set a desired speed (`tileVelocity`), then calculate how far away the tile is
    from the score. We divide these out to arrive at the correct movement duration
    for this tile. After we initiate the actions, we increment the score by one (`playerScore++`),
    and call the `calculateLivesRemaining` method (which we will see shortly).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们大量利用了cocos2d动作，使用了`CCMoveTo`、`CCScaleTo`、`CCDelayTime`和`CCCallFuncND`等标准动作。我们飞向分数效果的一个方面是我们希望瓷砖以恒定的速度移动。如果我们为`CCMoveTo`动作硬编码一个持续时间，那么靠近分数的瓷砖会移动得慢，而远离分数的瓷砖会移动得非常快。为了达到恒定的速度，我们设置了一个期望的速度（`tileVelocity`），然后计算瓷砖与分数的距离。我们将这些值除以得到这个瓷砖正确的移动持续时间。在我们启动动作后，我们将分数加一（`playerScore++`），并调用`calculateLivesRemaining`方法（我们很快就会看到）。
- en: Animating the score
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画化分数
- en: Now that we have the tile animation added, now we should do something more flashy
    with the score itself.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了瓷砖动画，现在我们应该对分数本身做一些更吸引人的处理。
- en: '**Filename:** `MTPlayfieldLayer.m`'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `MTPlayfieldLayer.m`'
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We finally settled on scaling the score up, change it to the new value, and
    scale it back to normal. This is all done with standard cocos2d actions, so we
    could add in more flair with other effects. A `CCRotateTo` action might add a
    nice touch by spinning the score around when it updates. For this game, we will
    stick to this simpler animation. We leave it as a challenge to the reader to add
    these types of enhancements for more "visual flair."
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终决定将分数放大，改为新值，然后再将其缩回正常大小。这一切都是通过标准的cocos2d动作完成的，因此我们可以通过其他效果添加更多亮点。一个`CCRotateTo`动作在分数更新时旋转分数可能会增加一个很好的效果。对于这款游戏，我们将坚持这种更简单的动画。我们将添加这些类型增强作为对读者的挑战，以增加更多的“视觉亮点”。
- en: Adding lives and game over
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加生命值和游戏结束
- en: Now we come to the point where we decide how the player can win or lose. You
    win after you have successfully matched all the tiles on the board. Losing is
    less obvious in a one-player game like this. Our approach is to give the player
    a number of lives. When you take a turn and fail to match the tiles, you lose
    a life. Lose all of them, and it's game over. The challenge comes from deciding
    how many lives the player should have. After testing several approaches, we determined
    the most exciting way would be to have the number of lives set to half the number
    of tiles currently on the board. If the board has 20 tiles in play, the player
    has 10 lives. Once the player makes a successful match, the lives are recalculated
    based on the new number of tiles in play. This gives some level of excitement
    as the lives are dwindling, and it encourages the player to think about their
    moves more carefully.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来到了决定玩家如何赢或输的点。当你成功匹配了板上的所有瓷砖时，你就赢了。在一个像这样的单人游戏中，失败可能不那么明显。我们的方法是给玩家一定数量的生命值。当你走一步并且未能匹配瓷砖时，你会失去一个生命值。失去所有生命值，游戏就结束了。挑战在于决定玩家应该有多少生命值。经过测试几种方法后，我们确定最激动人心的方式是将生命值设置为当前板上瓷砖数量的一半。如果板上有20个瓷砖，玩家就有10个生命值。一旦玩家成功匹配，生命值将根据新的瓷砖数量重新计算。这给生命值减少带来了一些紧张感，并鼓励玩家更加仔细地思考他们的走法。
- en: '**Filename:** `MTPlayfieldLayer.m`'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `MTPlayfieldLayer.m`'
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding section of code looks very similar to the score methods. We leverage
    cocos2d actions to animate the lives display, only this time we also turn the
    text red when the number of lives is reduced, and then change it back to blue
    at the end of the `CCSequence` of actions. One item of note here is the `updateLivesDisplayQuiet`
    method. This method is called when the player makes a successful match to let
    us change the lives to their new value without the "oh-no" fanfare that we use
    when the player loses a life.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的前一部分看起来与得分方法非常相似。我们利用cocos2d动作来动画化生命值的显示，这次我们还在生命值减少时将文本变为红色，并在`CCSequence`动作序列结束时将其变回蓝色。这里值得注意的一点是`updateLivesDisplayQuiet`方法。当玩家成功匹配时，该方法会被调用，这样我们就可以在不使用玩家失去生命时使用的“哦不”的喧闹声的情况下，将生命值更改为新的值。
- en: We now have two game over conditions to consider. If `livesRemaining` is zero,
    the player loses. If the `tilesInPlay` array is empty, the player has won. This
    feels like a good time to put the code together into a single method to check
    these conditions.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要考虑两种游戏结束条件。如果`livesRemaining`为零，玩家失败。如果`tilesInPlay`数组为空，玩家获胜。这似乎是把这些条件组合成一个单独的方法来检查的好时机。
- en: '**Filename:** `MTPlayfieldLayer.m`'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `MTPlayfieldLayer.m`'
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Bringing it all together
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将所有元素整合在一起
- en: 'We have added extra flash and flair in the code, but we haven''t tied it all
    together yet. Most of the new code is integrated into the `checkForMatch` method,
    so let''s see how that looks with everything integrated:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在代码中添加了额外的闪光和华丽效果，但我们还没有将它们全部整合在一起。大部分新代码都集成到了`checkForMatch`方法中，所以让我们看看整合后的样子：
- en: '**Filename:** `MTPlayfieldLayer.m`'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `MTPlayfieldLayer.m`'
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now we have a fully functional game, complete with scoring, lives, a way to
    win and a way to lose. There is only one necessary element still missing.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个功能齐全的游戏，包括得分、生命值、获胜方式和失败方式。但仍有一个必要的元素尚未添加。
- en: It's quiet...too quiet
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 很安静...太安静了
- en: A major mistake some casual game designers make is to downplay the importance
    of audio. When you are playing a quiet game without the aid of a computer, there
    are always subtle sounds. Playing cards give a soft "thwap" sound when playing
    solitaire. Tokens in board games click as they tap their way around the board.
    Video games should have these "incidental" sound effects, too. These are the button
    clicks, the buzzers when something goes wrong, and so forth.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一些休闲游戏设计师犯的一个主要错误是低估了音频的重要性。当你在没有电脑辅助的情况下玩一个安静的游戏时，总有微小的声音。玩单人纸牌游戏时，牌会发出轻柔的“噗嗤”声。在桌面游戏中，标记在移动时会发出“咔嗒”声。视频游戏也应该有这些“偶然”的声音效果。这些是按钮点击声、出错时的蜂鸣声等等。
- en: We will be using `CocosDenshion`, the audio engine that is bundled with cocos2d.
    `CocosDenshion` includes a very easy to use interface appropriately named `SimpleAudioEngine`.
    To initialize it, you need to import it into your classes (including the `AppDelegate.m`
    file) and add one line near the end of the `application:didFinishLaunchingWithOptions:`
    method (before the return `YES;` line).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`CocosDenshion`，这是cocos2d捆绑的音频引擎。`CocosDenshion`包括一个非常易于使用的接口，命名为`SimpleAudioEngine`。为了初始化它，你需要将其导入到你的类中（包括`AppDelegate.m`文件），并在`application:didFinishLaunchingWithOptions:`方法的末尾添加一行（在返回`YES;`行之前）。
- en: '**Filename:** `AppDelegate.m`'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `AppDelegate.m`'
- en: '[PRE23]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: For our implementation, we want to preload all of our sound effects so there
    is no lag the first time the sound effect is played. We do this with a method
    that is called from the `initWithRows:andColumns:` method of our `MTPlayfieldLayer`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的实现，我们希望预加载所有声音效果，以便在第一次播放声音效果时没有延迟。我们通过从`MTPlayfieldLayer`的`initWithRows:andColumns:`方法中调用的一个方法来实现这一点。
- en: '**Filename:** `MTPlayfieldLayer.m`'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件名:** `MTPlayfieldLayer.m`'
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `preloadEffect` method of `SimpleAudioEngine` actually takes an `NSString`
    as an argument. We have defined constants to hold the names of the sound files.
    (These constants are at the top of the `MTPlayfieldLayer.m` file, above the `@implementation`
    statement.)
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleAudioEngine`的`preloadEffect`方法实际上接受一个`NSString`作为参数。我们定义了常量来保存声音文件的名称。（这些常量位于`MTPlayfieldLayer.m`文件的顶部，在`@implementation`语句之上。）'
- en: '[PRE25]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Why do we do this? By using `#define` statements in a single location, we can
    easily change the sound files we are using in one place, rather than relying on
    find-and-replace functionality to change the filenames throughout our code. Having
    done this, anywhere we want to play the `button.caf` file, we can simply refer
    to it as `SND_TILE_FLIP` (no quotes around it), and Xcode takes care of the rest.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么要这样做？通过在单个位置使用`#define`语句，我们可以轻松地更改我们正在使用的声音文件，而不是依赖于在整个代码中查找并替换功能来更改文件名。完成此操作后，无论我们想在何处播放`button.caf`文件，我们都可以简单地将其称为`SND_TILE_FLIP`（无需引号），Xcode会处理其余部分。
- en: 'We have peppered the code with various playing of these sound effects, but
    we won''t go into detail on where each sound is triggered. When you want to play
    a sound effect, you can call it with a single line of code, as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在代码中加入了各种声音效果，但不会详细介绍每个声音触发的地方。当你想要播放一个声音效果时，你可以用一行代码来调用它，如下所示：
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It doesn't get much simpler than that!
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么比这更简单了！
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We've covered a lot of ground with this memory game. At this point you should
    be familiar with the methodology we will continue you use throughout the book
    regarding `CCScene` and `CCLayer` organization. We have used a custom `init` method
    to make our game engine more flexible. We have also covered effective use of actions,
    `SimpleSoundEngine`, a couple ways of handling touches, and some basic game flow
    intelligence. And this is just the beginning! In the next chapter, we tackle a
    modern favorite, a Match-3 game. We'll explore a couple ways to solve the match
    detection problem, and build a fun game along the way.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个记忆游戏中已经覆盖了很多内容。到现在，你应该已经熟悉了我们将在整本书中继续使用的关于`CCScene`和`CCLayer`组织的方法论。我们使用了一个自定义的`init`方法来使我们的游戏引擎更加灵活。我们还涵盖了动作的有效使用、`SimpleSoundEngine`、处理触摸的几种方法以及一些基本的游戏流程智能。而这仅仅是个开始！在下一章中，我们将探讨一个现代流行的游戏，即三消游戏。我们将探索解决匹配检测问题的几种方法，并在过程中构建一个有趣的游戏。
