- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Building the Packtagram UI
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 Packtagram UI
- en: As we leave the exciting world of chat applications behind, it’s time to take
    on another interesting challenge – social networking. Social networking apps have
    seen an exponential rise in popularity over the last decade, becoming integral
    to our daily lives. These platforms have changed the way we communicate, share,
    and interact with each other on a global scale. Among them, Instagram stands out
    with its simplicity, its emphasis on visuals, and its engaging features, such
    as its newsfeed and stories.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们告别令人兴奋的聊天应用世界，是时候接受另一个有趣的挑战——社交网络。在过去十年中，社交网络应用的人气呈指数级增长，成为我们日常生活的重要组成部分。这些平台改变了我们在全球范围内沟通、分享和相互互动的方式。其中，Instagram
    以其简洁性、对视觉的重视以及其引人入胜的功能（如新闻源和故事）脱颖而出。
- en: The next few chapters are dedicated to the process of creating an Instagram-like
    social networking application while leveraging Android’s powerful features and
    capabilities. We will call it Packtagram!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几章将致力于创建一个类似 Instagram 的社交网络应用的过程，同时利用 Android 强大的功能和特性。我们将称之为 Packtagram！
- en: To start this journey, we’ll begin by setting up a solid foundation and structuring
    our project. The structure of an Android application has a significant impact
    on the ease of development and the application’s scalability over time. This chapter
    will cover various aspects of project structuring, such as defining the file hierarchy,
    segregating modules, and choosing the right architecture pattern for our needs.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始这段旅程，我们将从建立一个坚实的基础和构建我们的项目结构开始。Android 应用的结构对开发便利性和应用随时间扩展的伸缩性有重大影响。本章将涵盖项目结构方面的各个方面，例如定义文件层次结构、分离模块以及选择适合我们需求的正确架构模式。
- en: Once our project structure is robust and scalable, we’ll transition into the
    realm of UI development. In the case of Instagram, the primary components that
    catch our attention are its newsfeed and stories. We’ll dive into the process
    of implementing these critical features, focusing on their user-friendly interfaces
    and seamless navigation flow.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的项目结构稳健且可扩展，我们将过渡到 UI 开发的领域。以 Instagram 为例，吸引我们注意的主要组件是其新闻源和故事。我们将深入研究实现这些关键功能的过程，重点关注它们用户友好的界面和流畅的导航流程。
- en: 'After the UI, we’ll move on to the heart of any dynamic application: data retrieval.
    We’ll learn how to interact with servers to fetch data, focusing on the newsfeed.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在 UI 之后，我们将转向任何动态应用的核心：数据检索。我们将学习如何与服务器交互以获取数据，重点关注新闻源。
- en: In the final part of this chapter, we will venture into the world of data caching.
    Social media apps often involve a large amount of data transfer, and to provide
    a seamless and efficient user experience, effective data management strategies,
    including caching, are necessary. We will explore how to store stories and news
    items locally, thus reducing network calls and improving the app’s performance.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们将探索数据缓存的领域。社交媒体应用通常涉及大量的数据传输，为了提供无缝且高效的用户体验，有效的数据管理策略，包括缓存，是必要的。我们将探讨如何本地存储故事和新闻条目，从而减少网络调用并提高应用性能。
- en: 'This chapter will cover the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Setting up Packtagram’s modules and dependencies
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 Packtagram 的模块和依赖项
- en: Creating the stories screen
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建故事屏幕
- en: Creating the newsfeed screen and its components
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新闻源屏幕及其组件
- en: Using Retrofit and Moshi to retrieve newsfeed information
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Retrofit 和 Moshi 获取新闻源信息
- en: Implementing pagination to the newsfeed
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在新闻源中实现分页
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: As in the previous chapter, you will need to have Android Studio (or another
    editor of your preference) installed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，您需要安装 Android Studio（或您偏好的其他编辑器）。
- en: We are going to start a new project in this chapter, so it isn’t necessary to
    download the changes that you made in the previous chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始一个新的项目，因此没有必要下载您在上一章中做出的更改。
- en: 'Nonetheless, you can have the complete code that we are going to build through
    this chapter in this book’s GitHub repository: [https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-4](https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-4).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，您可以通过本书的 GitHub 仓库获取我们将在此章节中构建的完整代码：[https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-4](https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-4)。
- en: Setting up Packtagram’s modules and dependencies
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 Packtagram 的模块和依赖项
- en: 'To set up our app structure, we are going to create a new project. We could
    do this by following the same instructions that we covered in [*Chapter 1*](B19443_01.xhtml#_idTextAnchor015),
    but we are going to introduce a variation here: our Gradle files will be written
    in Kotlin, and we will also use version catalogs.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置我们的应用程序结构，我们将创建一个新的项目。我们可以通过遵循我们在[*第一章*](B19443_01.xhtml#_idTextAnchor015)中介绍的同一条指令来完成这项工作，但在这里我们将引入一个变化：我们的Gradle文件将使用Kotlin编写，并且我们还将使用版本目录。
- en: Setting up a version catalog
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置版本目录
- en: A **version catalog** is a feature that was introduced in Gradle 7.0 to centralize
    the declaration of dependencies in a project. This feature provides an organized
    way to manage dependencies, making it easier to control and update the different
    versions of libraries across different modules of a project.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**版本目录**是Gradle 7.0中引入的一个功能，用于在项目中集中声明依赖项。此功能提供了一种有组织的方式来管理依赖项，使得控制和管理项目不同模块中库的不同版本变得更加容易。'
- en: With a version catalog, you define all the dependencies and their versions in
    a `libs.versions.toml`. This file resides in the Gradle folder of your project.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用版本目录，你将在`libs.versions.toml`中定义所有依赖项及其版本。此文件位于你的项目Gradle文件夹中。
- en: 'A version catalog offers several benefits:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 版本目录提供了几个好处：
- en: It simplifies dependency management by providing a single place to define and
    update the dependencies
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过提供一个单一的地方来定义和更新依赖项，简化了依赖项管理。
- en: It minimizes errors caused by discrepancies in dependency versions across modules
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它最小化了由于模块间依赖项版本差异引起的错误。
- en: It improves the readability of build scripts by removing the need to declare
    each dependency individually as the declaration is centralized in a unique file
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过将每个依赖项的声明集中在一个独特的文件中，消除了在构建脚本中单独声明每个依赖项的需求，从而提高了构建脚本的可读性。
- en: 'To use version catalogs, in Android Studio, fill out the details for a new
    project, including **Name** – here, I chose **Packtagram**. For the **Build configuration
    language** field, select **Kotlin** **DSL (build.gradle.kts)**:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用版本目录，在Android Studio中，填写新项目的详细信息，包括**名称** - 这里，我选择了**Packtagram**。对于**构建配置语言**字段，选择**Kotlin**
    **DSL (build.gradle.kts)**：
- en: '![Figure 4.1: Creating a new project in Android Studio Jellyfish (2023.3.1)](img/B19443_04_001.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1：在Android Studio Jellyfish (2023.3.1)中创建新项目](img/B19443_04_001.jpg)'
- en: 'Figure 4.1: Creating a new project in Android Studio Jellyfish (2023.3.1)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1：在Android Studio Jellyfish (2023.3.1)中创建新项目
- en: 'With this option, Android Studio will automatically create the file needed
    to specify the versions. This file is called `libs.versions.toml` and its default
    content will look like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此选项，Android Studio将自动创建一个文件来指定版本。此文件称为`libs.versions.toml`，其默认内容如下所示：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As shown in the following code (and in the `libs.version.toml` file generated
    by Android Studio in your project), the file is composed of several sections:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下代码（以及Android Studio在项目中生成的`libs.version.toml`文件）所示，该文件由几个部分组成：
- en: '**versions**: This section contains the versions of the dependencies that will
    be used in your project. You simply assign a reference name to each version number.
    This is useful to centralize versioning, particularly when the same version of
    a library is used in multiple places.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本**：本节包含将在你的项目中使用的依赖项的版本。你只需为每个版本号分配一个引用名称。这对于集中版本管理非常有用，尤其是在多个地方使用同一版本的库时。'
- en: '**libraries**: In this block, you define your actual dependencies by assigning
    them an alias and linking them to the correct version defined in the **versions**
    block. This alias can then be used throughout your project to refer to the dependency.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**库**：在这个块中，你通过为它们分配别名并将它们链接到**版本**块中定义的正确版本来定义你的实际依赖项。然后，你可以在整个项目中使用此别名来引用依赖项。'
- en: '**bundles**: Bundles are groups of dependencies that are commonly used together.
    By creating a bundle, you can include multiple dependencies in your build scripts
    with a single alias. This can simplify your build scripts and make them easier
    to read and manage.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**捆绑包**：捆绑包是一组通常一起使用的依赖项。通过创建一个捆绑包，你可以在构建脚本中使用单个别名包含多个依赖项。这可以简化你的构建脚本，并使它们更容易阅读和管理。'
- en: '**plugins**: This section is where Gradle plugins that are used in the project
    are defined. Similar to libraries, each plugin is given an alias and linked to
    a version number from the **versions** block. This feature makes managing plugins
    as straightforward as managing other dependencies.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插件**: 本节定义了项目中使用的 Gradle 插件。类似于库，每个插件都会被赋予一个别名，并链接到 **versions** 块中的版本号。这个特性使得管理插件与其他依赖项一样简单。'
- en: 'Now, if we open the `gradle.build.kts` file of our app module, we’ll see how
    the version catalog declarations are used. For example, here, we can see how the
    plugins are now applied:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们打开应用模块的 `gradle.build.kts` 文件，我们将看到版本目录声明是如何使用的。例如，在这里，我们可以看到插件是如何现在被应用的：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The term `alias` is used here to refer to a predefined plugin dependency that
    has been specified in the `libs.versions.toml` file.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的术语 `alias` 是指在 `libs.versions.toml` 文件中指定的预定义插件依赖项。
- en: 'Here, we can see how the dependencies are declared:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到依赖项是如何声明的：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, every dependency is referred to by the name we have given them
    in the version catalog file (`libs.versions.toml`). It is now easier to have all
    the project dependencies synchronized and included in the modules.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，每个依赖项都通过我们在版本目录文件（`libs.versions.toml`）中给它们命名的名称来引用。现在同步和包含所有项目依赖项到模块中变得更加容易。
- en: Talking about modules, it’s time we also structure our app using modularization.
    We already learned about the different strategies to modularize our app in [*Chapter
    1*](B19443_01.xhtml#_idTextAnchor015), so this is a good time to review that information.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 说到模块化，现在是时候使用模块化来结构化我们的应用了。我们已经在 [*第一章*](B19443_01.xhtml#_idTextAnchor015) 中学习了如何模块化我们的应用的不同策略，所以这是一个复习该信息的好时机。
- en: Modularizing our app
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块化我们的应用
- en: 'In this case, we will segment Packtagram into several feature modules, each
    encapsulating distinct functionalities:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将 Packtagram 分割成几个功能模块，每个模块封装了不同的功能：
- en: '**Newsfeed module**: The newsfeed module is dedicated to the main feed and
    is where users see and interact with posts from those they follow. We’ll isolate
    this functionality because it’s the core user experience and likely the first
    screen users will see. This module will need to handle rendering posts, managing
    likes and comments, and refreshing the feed.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**新闻源模块**: 新闻源模块专注于主要源，是用户查看和与关注者发布的帖子互动的地方。我们将隔离这个功能，因为它是最核心的用户体验，可能是用户首先看到的屏幕。此模块将需要处理帖子的渲染、管理点赞和评论以及刷新源。'
- en: '**Stories module**: We’ll separate the stories functionality into its own module
    because it’s a distinct user experience that requires specific UI elements and
    data handling. The stories module needs to manage how different user stories are
    rendered, track the view status, and manage story creation.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**故事模块**: 我们将故事功能分离到自己的模块中，因为它是一个独特的用户体验，需要特定的 UI 元素和数据处理。故事模块需要管理不同用户故事的渲染方式，跟踪视图状态，以及管理故事创建。'
- en: '**Profile module**: User profiles are a central part of the Instagram experience,
    so we’ll house this functionality in the profile module. This module will handle
    displaying user information, managing posts specific to a user, and editing profile
    details.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**个人资料模块**: 用户资料是 Instagram 体验的核心部分，因此我们将此功能放在个人资料模块中。此模块将处理显示用户信息、管理特定于用户的帖子以及编辑个人资料详情。'
- en: '**Search module**: Search functionality is complex enough to justify its own
    module. This module will deal with user queries, display search results, and manage
    interactions with search results.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**搜索模块**: 搜索功能足够复杂，足以证明其作为一个模块的合理性。此模块将处理用户查询、显示搜索结果以及管理与搜索结果的交互。'
- en: '**Messaging module**: Direct messaging is a separate feature in Instagram,
    so we’ll also isolate it in a dedicated module. This module will manage creating
    and displaying chats, sending and receiving messages, and notifications of new
    messages.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息模块**: 直接消息是 Instagram 中的一个独立功能，因此我们也将它隔离到一个专门的模块中。此模块将管理创建和显示聊天、发送和接收消息以及新消息的通知。'
- en: '**Core module**: This module will contain shared utilities, network interfaces,
    and other common components used across the application. This prevents code duplication
    and provides a central point for managing shared resources.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**核心模块**: 此模块将包含共享工具、网络接口和其他在应用程序中使用的通用组件。这防止了代码重复，并为管理共享资源提供了一个中心点。'
- en: By choosing this modularization strategy, we’ve effectively separated our app
    into logical components that can be developed, tested, and debugged independently.
    This also aligns well with the idea of **separation of concerns**, ensuring that
    each part of our app has a clear, singular purpose. In the following sections,
    we’ll explore each of these modules in detail, building the functionalities one
    by one, culminating in our completed social networking app.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择这种模块化策略，我们有效地将我们的应用程序分解为逻辑组件，这些组件可以独立地进行开发、测试和调试。这也很好地符合**关注点分离**的理念，确保我们的应用程序的每个部分都有一个清晰、单一的目的。在接下来的章节中，我们将详细探讨这些模块，逐一构建功能，最终完成我们的社交网络应用程序。
- en: 'So, let’s create the modules while following the same instructions provided
    in [*Chapter 1*](B19443_01.xhtml#_idTextAnchor015). Our module structure will
    look like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们按照在[*第一章*](B19443_01.xhtml#_idTextAnchor015)中提供的相同说明来创建模块。我们的模块结构将如下所示：
- en: '![Figure 4.2: The modules structure for Packtagram](img/B19443_04_002.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2：Packtagram的模块结构](img/B19443_04_002.jpg)'
- en: 'Figure 4.2: The modules structure for Packtagram'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：Packtagram的模块结构
- en: As we can see, we should have a module called `:app` (already created when creating
    the project), a module called `:core` for the core functionality, and a module
    called :`feature` that contains all of the feature modules (`:messaging`, `:newsfeed`,
    `:profile`, `:search`, and `:stories`).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们应该有一个名为`:app`的模块（在创建项目时已创建），一个名为`:core`的模块用于核心功能，以及一个名为`:feature`的模块，其中包含所有功能模块（`:messaging`、`:newsfeed`、`:profile`、`:search`和`:stories`）。
- en: As part of this project, we will focus on the `newsfeed` and `stories` modules
    (we already know how to create messaging functionality as that was covered in
    the last three chapters, so we don’t need to cover that again).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本项目的一部分，我们将重点关注`newsfeed`和`stories`模块（我们已经知道如何创建消息功能，因为这在过去的三个章节中已经涵盖，所以不需要再次介绍）。
- en: 'In the case of the feature modules, we will structure them internally using
    the same approach we already followed in the WhatsPackt project: organizing the
    code and dependencies in layers. For example, we could structure the `:newsfeed`
    module like so:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于功能模块，我们将使用与在WhatsPackt项目中遵循的相同方法内部构建它们：按层组织代码和依赖项。例如，我们可以这样构建`:newsfeed`模块：
- en: '![Figure 4.3: Internal structure for the feature modules](img/B19443_04_003.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3：功能模块的内部结构](img/B19443_04_003.jpg)'
- en: 'Figure 4.3: Internal structure for the feature modules'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3：功能模块的内部结构
- en: 'Here, we can see that we have created four internal packages:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们已经创建了四个内部包：
- en: '**data**: This is where we will place the logic for the data layer, including
    the components needed to retrieve the information from the backend and the data
    sources'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据层**：这是我们放置数据层逻辑的地方，包括从后端和数据源获取信息的组件'
- en: '**di**: This is where we will place the logic needed to define the dependency
    injection instructions'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖注入指令**：这是我们放置定义依赖注入指令所需逻辑的地方'
- en: '**domain**: This is where we will place the domain logic, including the repositories
    and use cases'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**领域层**：这是我们放置领域逻辑的地方，包括仓库和用例'
- en: '**ui**: This is where we will place all the logic related to the user interface,
    including ViewModels, composables, and other Android View components'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户界面**：这是我们放置所有与用户界面相关的逻辑的地方，包括ViewModels、composables和其他Android View组件'
- en: We will implement the necessary components that will be part of the modules
    in this and the following chapters.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现必要的组件，这些组件将构成本章节和以下章节中模块的一部分。
- en: As part of our module structure, we’ve included an internal module specifically
    for dependency injection. Previously, in our WhatsPackt project, we used the Dagger
    Hilt framework for dependency injection. However, in this project, we will take
    a different approach by using Koin.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们模块结构的一部分，我们包含了一个专门用于依赖注入的内部模块。在之前的WhatsPackt项目中，我们使用了Dagger Hilt框架进行依赖注入。然而，在这个项目中，我们将采取不同的方法，使用Koin。
- en: Getting to know Koin
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解Koin
- en: 'Koin was mentioned briefly in [*Chapter 1*](B19443_01.xhtml#_idTextAnchor015),
    but let’s learn about its main features here:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Koin在[*第一章*](B19443_01.xhtml#_idTextAnchor015)中简要提到，但让我们在这里了解其主要特性：
- en: '**Simplicity**: It offers an easy setup process and is easy to learn'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单性**：它提供了一个简单的设置过程，并且易于学习'
- en: '**Efficiency**: It is lightweight as it doesn’t rely on reflection'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**效率**：它轻量级，因为它不依赖于反射'
- en: '**Kotlin-centric**: Designed specifically for Kotlin, it leverages Kotlin-specific
    features such as extension functions, **domain-specific languages** (**DSLs**),
    and property delegation'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**以 Kotlin 为中心**：专门为 Kotlin 设计，它利用 Kotlin 特定的功能，如扩展函数、**领域特定语言**（**DSL**）和属性委托'
- en: '**Scope management**: It has a clear way to manage the life cycle of injected
    instances'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作用域管理**：它有明确的方式来管理注入实例的生命周期'
- en: '**Integration**: It provides seamless integration with popular frameworks,
    such as ViewModel, Coroutines, and others'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成**：它提供了与流行框架（如 ViewModel、Coroutines 等）的无缝集成'
- en: '**Testing**: It includes tools to simplify testing by allowing dependencies
    to be mocked or overridden'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试**：它包括允许依赖项被模拟或覆盖的工具，以简化测试'
- en: '**DSL configuration**: Koin uses a more readable and concise form of configuration'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DSL 配置**：Koin 使用更易读和简洁的配置形式'
- en: Let’s prepare Koin for this project so that we can use it in the following sections
    and chapters.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为这个项目准备 Koin，这样我们就可以在接下来的章节中使用它。
- en: Setting up Koin
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 Koin
- en: 'To start setting up Koin, we need to add the necessary dependency to our version
    catalog. To do that, you will add the necessary Koin dependencies to the `libs.versions.toml`
    file. Be sure to use the latest version of Koin and replace `latest-version` with
    the actual version number:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始设置 Koin，我们需要将必要的依赖项添加到我们的版本目录中。为此，您将必要的 Koin 依赖项添加到 `libs.versions.toml`
    文件中。请确保使用 Koin 的最新版本，并将 `latest-version` 替换为实际版本号：
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As we can see, we have added the `koin` version in the `versions` block and
    the packages we might need in the `libraries` block.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们在 `versions` 块中添加了 `koin` 版本，并在 `libraries` 块中添加了我们可能需要的包。
- en: 'Now, we need to add the dependencies to our module’s Gradle files. To do this,
    add the following lines to the dependency Lambda:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将依赖项添加到我们的模块的 Gradle 文件中。为此，将以下行添加到依赖 Lambda：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Adding these dependencies will allow us to use Koin in our modules. As a start,
    you should add them to the `:app`, `:feature:newsfeed`, and `:feature:stories`
    modules, which are the modules we are going to work with in this and the following
    two chapters.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这些依赖项将允许我们在模块中使用 Koin。作为一个开始，您应该将它们添加到 `:app`、`:feature:newsfeed` 和 `:feature:stories`
    模块中，这些是我们将在本章节和接下来的两个章节中要处理的模块。
- en: 'Next, we need to create our `Application` class. Koin is typically initialized
    in your `Application` class. As we don’t have one already, we will create one
    as part of the `:app` module and add the following code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建我们的 `Application` 类。Koin 通常在您的 `Application` 类中初始化。由于我们还没有一个，我们将作为
    `:app` 模块的一部分创建一个，并添加以下代码：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the `startKoin` block, we’ve specified that we want to use the Android logger
    (`androidLogger()`). The `androidLogger()` function is a part of Koin’s API and
    configures Koin to use Android’s native logging mechanism. Essentially, it enables
    Koin to print logs to Logcat.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `startKoin` 块中，我们指定了我们要使用 Android 日志记录器（`androidLogger()`）。`androidLogger()`
    函数是 Koin API 的一部分，并配置 Koin 使用 Android 的原生日志机制。本质上，它使 Koin 能够将日志打印到 Logcat。
- en: When you initialize Koin with `androidLogger()`, you will be able to see important
    information about Koin’s behavior and operations in Logcat while debugging your
    application. This includes details such as which dependencies are being created,
    if any errors occur during the creation of a dependency, the life cycle of scopes,
    and more.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用 `androidLogger()` 初始化 Koin 时，您将能够在调试应用程序时在 Logcat 中看到有关 Koin 行为和操作的重要信息。这包括有关正在创建哪些依赖项、在创建依赖项过程中是否发生错误、作用域的生命周期等详细信息。
- en: After that, we provided the Android context (`androidContext(this@MyApplication)`)
    to the framework in case we need it to create any of our dependencies.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将 Android 上下文（`androidContext(this@MyApplication)`）提供给框架，以防我们需要它来创建任何依赖项。
- en: 'The next line is `modules(appModule)`. This function is where you’ll list the
    modules that contain your project’s dependencies and the instructions to provide
    them. To start, we will only have `appModule`, which we can create like so:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 下一条是 `modules(appModule)`。这个函数是您列出包含项目依赖项和提供它们指令的地方。一开始，我们只有 `appModule`，我们可以这样创建它：
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Inside the `module` block, we should define our dependencies once we start
    building them. Here’s an example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `module` 块内部，一旦我们开始构建它们，我们应该定义我们的依赖项。以下是一个示例：
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `module` function in Koin is used to define a module where you specify how
    to create your various dependencies. Inside a module, you can use functions such
    as `single`, `factory`, and `viewModel` to create instances of your dependencies.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Koin中的`module`函数用于定义一个模块，在该模块中，你指定如何创建你的各种依赖项。在模块内部，你可以使用`single`、`factory`和`viewModel`等函数来创建依赖项的实例。
- en: 'Here’s a breakdown of these functions:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是对这些函数的分解：
- en: '**single**: This function creates a singleton object of the specified type.
    Once this object is created, the same instance will be provided every time this
    type of object is needed. For example, **single { MyDataSource(get()) }** defines
    how to create a single instance of **MyDataSource**. The **get()** function inside
    the curly braces is a Koin function that fetches any required dependencies for
    creating the **MyDataSource** instance.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**single**: 这个函数创建指定类型的单例对象。一旦这个对象被创建，每次需要此类对象时都将提供相同的实例。例如，**single { MyDataSource(get())
    }**定义了如何创建**MyDataSource**的单例实例。大括号内的**get()**函数是一个Koin函数，用于获取创建**MyDataSource**实例所需的任何依赖项。'
- en: '**factory**: This function is used when you want to create a new instance every
    time the dependency is needed, instead of reusing the same instance. For instance,
    **factory { MyUseCase(get()) }** creates a new **MyUseCase** object every time
    a **MyUseCase** instance is requested.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**factory**: 当你希望在每次需要依赖项时创建一个新实例，而不是重用相同的实例时，使用此函数。例如，**factory { MyUseCase(get())
    }**每次请求**MyUseCase**实例时都会创建一个新的**MyUseCase**对象。'
- en: '**viewModel**: This function is used to create instances of **ViewModel** classes.
    It works like **single** but is specialized for Android’s **ViewModel** instances.
    All **ViewModel** instances are tied to an activity or fragment life cycle and
    can survive configuration changes, such as screen rotation. For instance, **viewModel
    { MyViewModel(get()) }** defines how to create an instance of **MyViewModel**.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**viewModel**: 这个函数用于创建**ViewModel**类的实例。它类似于**single**，但专门用于Android的**ViewModel**实例。所有**ViewModel**实例都与活动或片段的生命周期相关联，并且可以在配置更改（如屏幕旋转）中存活。例如，**viewModel
    { MyViewModel(get()) }**定义了如何创建**MyViewModel**的实例。'
- en: '**bind**: This function is used alongside **single**, **factory**, or **scoped**
    to provide additional interfaces this class can fulfill. For example, if the **MyImplementation**
    class implements **MyInterface**, you could enter the following:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**bind**: 这个函数与**single**、**factory**或**scoped**一起使用，为这个类提供额外的接口。例如，如果**MyImplementation**类实现了**MyInterface**，你可以输入以下内容：'
- en: '[PRE8]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `get()` function that you can see in the definitions is a Koin function
    that automatically fetches the required dependencies. For example, if `MyDataSource`
    has a dependency on a `MyApi` instance, then `get()` will fetch that `MyApi` instance,
    provided that it has been defined somewhere in the Koin modules.
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在定义中看到的`get()`函数是一个Koin函数，它自动获取所需的依赖项。例如，如果`MyDataSource`依赖于一个`MyApi`实例，那么`get()`将获取那个`MyApi`实例，前提是它已经在Koin模块中定义过。
- en: Returning to our project, we are going to leave the `appModule` empty for now
    – we will complete it once we start creating new components.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到我们的项目，我们现在将`appModule`留空 - 一旦我们开始创建新的组件，我们就会完成它。
- en: Talking of components, let’s start with the UI we need to show the stories screen.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 说到组件，让我们从我们需要显示故事屏幕的UI开始。
- en: Creating the stories screen
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建故事屏幕
- en: In this section, we’ll focus on developing a feature for creating and editing
    new stories within our stories feature. We’ll begin by writing a `StoryEditorScreen`
    composable, along with its corresponding `ViewModel`, aptly named `StoryEditorViewModel`.
    Although this `ViewModel` will initially have limited functionality, we’ll expand
    upon it in subsequent chapters.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将专注于开发我们故事功能中创建和编辑新故事的功能。我们将从编写一个名为`StoryEditorScreen`的可组合组件及其相应的`ViewModel`开始，命名为`StoryEditorViewModel`。尽管这个`ViewModel`最初的功能有限，但我们在后续章节中会对其进行扩展。
- en: 'Let’s start creating our `ViewModel`, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建我们的`ViewModel`，如下所示：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code, we are declaring `StoryEditorViewModel` and adding a
    property that will indicate if our screen is in edit mode or not. Edit mode will
    be used when the user has taken a photo or a video and wants to add more components
    to it.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们声明了`StoryEditorViewModel`并添加了一个属性，该属性将指示我们的屏幕是否处于编辑模式。编辑模式将在用户拍照或录制视频并想要添加更多组件时使用。
- en: 'Now, we need to take care of the dependency injection of this `ViewModel` as
    it must be accessible from the screen we are about to create. We can create `storyModule`
    in`:feature:story` to be able to provide it, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要注意这个 `ViewModel` 的依赖注入，因为它必须可以从我们即将创建的屏幕中访问。我们可以在 `:feature:story` 中创建
    `storyModule` 以能够提供它，如下所示：
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we are just telling Koin that it needs to provide `StoryEditorViewModel`
    where it is needed.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是告诉 Koin 它需要在需要的地方提供 `StoryEditorViewModel`。
- en: 'We also need to add this new module to the `PacktagramApplication` Koin initialization:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将这个新模块添加到 `PacktagramApplication` Koin 初始化中：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the `modules(appModule, storyModule)` line, we have included `storyModule`
    to provide all the dependencies that we’ll need in the stories feature.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `modules(appModule, storyModule)` 行中，我们包含了 `storyModule` 以提供我们在 stories 功能中需要的所有依赖项。
- en: 'Now, we are ready to start with the Jetpack Compose magic and create `StoryEditorScreen`.
    This screen will have `viewModel` as a dependency and handle `TopAppBar` and a
    new composable, `StoryContent`, that will hold the main functionality of the story
    creation and edition. We can create `StoryEditorScreen` as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好开始使用 Jetpack Compose 的魔法并创建 `StoryEditorScreen`。这个屏幕将 `viewModel` 作为依赖项，并处理
    `TopAppBar` 和一个新的组合器 `StoryContent`，它将包含故事创建和编辑的主要功能。我们可以如下创建 `StoryEditorScreen`：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As we can see, the `StoryEditorScreen` composable receives `StoryEditorViewModel`
    as a parameter, which provides data and functionality for this screen. This `ViewModel`
    is provided by Koin, using the `koinViewModel` function.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`StoryEditorScreen` 组合器接收 `StoryEditorViewModel` 作为参数，它为这个屏幕提供数据和功能。这个
    `ViewModel` 由 Koin 通过 `koinViewModel` 函数提供。
- en: Next, `isEditing` is a state derived from the `isEditing` state flow of `ViewModel`.
    This state will represent whether the user is in the process of editing a story
    or not. The `collectAsState()` function collects the latest value from the state
    flow and represents it as a state in Compose. Whenever the `isEditing` state flow
    emits a new value, the UI will recompose to reflect the new state.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`isEditing` 是从 `ViewModel` 的 `isEditing` 状态流中派生出来的状态。这个状态将表示用户是否正在编辑故事。`collectAsState()`
    函数从状态流中收集最新的值并将其表示为 Compose 中的状态。每当 `isEditing` 状态流发出新的值时，UI 将重新组合以反映新的状态。
- en: Inside `StoryEditorScreen`, there’s a `Column` composable that takes up the
    maximum size of the screen. A `Column` composable allows us to arrange its children
    vertically. Inside this `Column`, there’s a condition to check the `isEditing`
    state. If `isEditing` is true, `TopAppBar` will be shown with `TopAppBar` is a
    composable that represents a Material Design App Bar and is generally placed at
    the top of the screen – this App Bar will only be shown when the user is in the
    editing state.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `StoryEditorScreen` 内部，有一个 `Column` 组合器占据了屏幕的最大尺寸。`Column` 组合器允许我们垂直排列其子元素。在这个
    `Column` 中，有一个检查 `isEditing` 状态的条件。如果 `isEditing` 为真，将显示 `TopAppBar`，这是一个表示 Material
    Design App Bar 的组合器，通常放置在屏幕顶部 – 这个 App Bar 只会在用户处于编辑状态时显示。
- en: The `StoryContent` composable is then included in `Column`, outside of the condition
    for `isEditing`. This means that `StoryContent` will always be shown, regardless
    of whether the user is in editing mode or not. The `isEditing` state is passed
    to `StoryContent` to inform it of the current editing status. Let’s work on this
    composable now.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`StoryContent` 组合器随后被包含在 `Column` 中，位于 `isEditing` 条件之外。这意味着无论用户是否处于编辑模式，`StoryContent`
    总是会显示。`isEditing` 状态被传递给 `StoryContent` 以告知其当前的编辑状态。现在让我们来处理这个组合器。'
- en: 'This composable should have a background that will be the image or the video
    the user wants to include in the story and will take all the space on the screen.
    By doing this, the options on the screen will be different, depending on whether
    we’re capturing the media or editing it. Here’s the code for this composable:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组合器应该有一个背景，这将是用戶想要包含在故事中的图片或视频，并将占据屏幕上的所有空间。通过这样做，屏幕上的选项将根据我们是在捕获媒体还是编辑媒体而有所不同。以下是这个组合器的代码：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let’s break down this code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解这段代码：
- en: The outermost **Box** is the main container, which takes up the maximum size
    of its parent and adds a padding of **20.dp**.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最外层的 **Box** 是主要容器，它占据其父容器的最大尺寸并添加了 **20.dp** 的填充。
- en: The first child of **Box** is another **Box** that is set to take up the full
    width and wrap the content height.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Box** 的第一个子元素是另一个设置为占据完整宽度和包裹内容高度的 **Box**。'
- en: Inside this **Box**, there is a **Button** component aligned to the top-start
    corner of its parent **Box**. This button is used to handle a back navigation
    action. Inside this button is an **Image** component with an arrow icon.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在此**Box**内部，有一个对齐到其父**Box**顶部左角的**按钮**组件。此按钮用于处理后退导航操作。在此按钮内部是一个带有箭头图标的**Image**组件。
- en: Note
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The terms “start” and “end” are used for layout positioning to ensure better
    support for both **left-to-right** (**LTR**) and **right-to-left** (**RTL**) languages.
    When you use the “start” and “end” attributes in your layout, Android automatically
    adjusts the orientation based on the text direction of the current locale. In
    LTR languages such as English, “start” maps to “left” and “end” maps to “right,”
    while in RTL languages such as Arabic, “start” maps to “right” and “end” maps
    to “left.” This approach simplifies the process of localizing your app for multiple
    languages and text directions.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 术语“开始”和“结束”用于布局定位，以确保更好地支持**从左到右**（LTR）和**从右到左**（RTL）的语言。当你在布局中使用“开始”和“结束”属性时，Android会根据当前区域的文本方向自动调整方向。在LTR语言，如英语中，“开始”映射到“左”，“结束”映射到“右”，而在RTL语言，如阿拉伯语中，“开始”映射到“右”，“结束”映射到“左”。这种方法简化了为多种语言和文本方向本地化应用程序的过程。
- en: If the **isEditing** flag is true, an additional **Button** is added to **Box**.
    This button, which is aligned to the top end (the right, in LTR layouts) of its
    parent **Box**, allows users to create a caption for their story. The button uses
    an image of a caption icon to communicate its function.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果**isEditing**标志为真，则会在**Box**中添加一个额外的**按钮**。此按钮与父**Box**的顶部端点（在LTR布局中为右侧）对齐，允许用户为他们的故事创建标题。按钮使用标题图标的图像来传达其功能。
- en: The next child of the outermost **Box** is **Image**, which displays a default
    image. This **Image** takes up the maximum size of **Box**, signifying that this
    image will be the main focus of this screen.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最外层**Box**的下一个子元素是**Image**，它显示默认图像。此**Image**占据**Box**的最大尺寸，这意味着此图像将是此屏幕的主要焦点。
- en: The last child of the outermost **Box** is a Row that’s aligned to the bottom
    center of **Box**. This **Row** contains two different buttons that are displayed
    conditionally, based on the **isEditing** flag.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最外层**Box**的最后一个子元素是一个对齐到**Box**底部中心的**Row**。此**Row**包含两个不同的按钮，这些按钮根据**isEditing**标志有条件地显示。
- en: If **isEditing** is false, **OutlinedButton** is shown. This button, styled
    to look like a circular button with a border, allows the user to take a photo.
    Note that the actual implementation for taking a photo is not included in the
    provided code and should be handled in the **onClick** function.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果**isEditing**为假，则显示**OutlinedButton**。此按钮设计得像一个带边框的圆形按钮，允许用户拍照。请注意，拍照的实际实现不包括在提供的代码中，应在**onClick**函数中处理。
- en: If **isEditing** is true, a **Button** component appears instead. This button,
    labeled **Share Story**, is intended to allow the user to share the created story.
    As you can see, it is using **stringResource** with a key of **R.string.share_story**,
    so we should add it to **string.xml**. Again, the actual implementation of the
    share functionality should be handled in the **onClick** function.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果**isEditing**为真，则会出现一个**按钮**组件。此按钮标记为**分享故事**，旨在允许用户分享创建的故事。如您所见，它正在使用**stringResource**，其键为**R.string.share_story**，因此我们应该将其添加到**string.xml**。同样，分享功能的实际实现应在**onClick**函数中处理。
- en: 'With the previous code, when the screen is in editing mode, it should look
    like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的代码，当屏幕处于编辑模式时，它应该看起来像这样：
- en: '![Figure 4.4: The story screen in edit mode](img/B19443_04_004.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图4.4：编辑模式下的故事屏幕](img/B19443_04_004.jpg)'
- en: 'Figure 4.4: The story screen in edit mode'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4：编辑模式下的故事屏幕
- en: 'Otherwise, when it is not in editing mode, it will look like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，当它不在编辑模式时，它将看起来像这样：
- en: '![Figure 4.5: The story screen when it is not in edit mode](img/B19443_04_005.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图4.5：非编辑模式下的故事屏幕](img/B19443_04_005.jpg)'
- en: 'Figure 4.5: The story screen when it is not in edit mode'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5：非编辑模式下的故事屏幕
- en: As we can see, it is easy and intuitive to add or remove composables conditionally
    from a view.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，从视图中有条件地添加或删除可组合项既简单又直观。
- en: With that, we’ve finished the story screen, until we add more functionality
    in the next chapters to capture photos and video. Let’s continue with the newsfeed
    user interface.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们就完成了故事屏幕，直到我们在下一章中添加更多功能来捕捉照片和视频。让我们继续处理新闻源用户界面。
- en: Creating the newsfeed screen and its components
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新闻源屏幕及其组件
- en: 'The newsfeed is the main screen of our Packtagram app and is where the user
    will see the latest posts from their friends. It is structured using several components:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 新闻源是 Packtagram 应用程序的主屏幕，用户将在这里看到他们朋友的最新帖子。它使用多个组件进行结构化：
- en: '**Title bar**: This is where the user can access the messaging feature'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标题栏**：这是用户可以访问消息功能的地方'
- en: '**List of posts**: The list of posts shown in our app'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**帖子列表**：我们应用中显示的帖子列表'
- en: '**Bottom bar**: This is used to navigate to different sections in the app'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**底部栏**：用于在应用中导航到不同的部分'
- en: We are going to start structuring our newsfeed screen by creating a `MainScreen`
    composable. Here, we will define the user interface for the main view in our Packtagram
    app.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始通过创建 `MainScreen` 组合组件来构建我们的新闻源屏幕。在这里，我们将定义 Packtagram 应用程序主视图的用户界面。
- en: 'This `MainScreen` composable will have a `Scaffold` composable as its main
    component. Here, we will define the title bar and the bottom bar with the different
    options for navigation:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `MainScreen` 组合组件将有一个 `Scaffold` 组合组件作为其主要组件。在这里，我们将定义标题栏和底部栏，以及不同的导航选项：
- en: '[PRE14]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we are starting with the composable declaration and the properties we
    need to handle the tabs that we are going to use in the `bottomBar` navigation.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们开始使用组合声明和我们需要处理 `bottomBar` 导航中将要使用的选项的属性。
- en: 'Now, it’s time to add the `Scaffold` composable. This is where we will add
    the `title` and `bottomBar`. Let’s start with the `title`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候添加 `Scaffold` 组合组件了。这是我们添加 `title` 和 `bottomBar` 的地方。让我们从 `title` 开始：
- en: '[PRE15]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With that, we have created the `Scaffold` composable and added `TopAppBar`.
    We used this in [*Chapter 1*](B19443_01.xhtml#_idTextAnchor015), but it is important
    to remember that a container is generally used to hold the title of the screen
    and any actions relevant to the screen’s context. Here, `TopAppBar` takes in two
    important lambdas:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经创建了 `Scaffold` 组合组件并添加了 `TopAppBar`。我们在 [*第一章*](B19443_01.xhtml#_idTextAnchor015)
    中使用了它，但重要的是要记住，容器通常用于包含屏幕的标题以及与屏幕上下文相关的任何操作。在这里，`TopAppBar` 接收两个重要的 Lambda：
- en: '**title**: This is where you define the title of the App Bar. In this case,
    it’s displaying a **Text** composable that fetches a string resource – that is,
    the name of the app (Packtagram).'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标题**：这是定义应用栏标题的地方。在这种情况下，它显示一个 **Text** 组合组件，该组件获取字符串资源——即应用名称（Packtagram）。'
- en: '**actions**: This is where we define the actions that will appear on the right-hand
    side of the App Bar. Actions are typically represented with icons and are used
    to perform functions relevant to the current screen. In this case, there’s a single
    **IconButton** with an envelope icon (which, when clicked, would navigate the
    user to the messaging screen).'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作**：这是定义将出现在应用栏右侧的操作的地方。操作通常用图标表示，并用于执行与当前屏幕相关的功能。在这种情况下，有一个带有信封图标的单个 **IconButton**（点击时将用户导航到消息屏幕）。'
- en: 'The next step is to add the `BottomBar`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是添加 `BottomBar`：
- en: '[PRE16]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, `BottomBar` is usually where navigation controls for the app are placed.
    In this case, `TabRow` is used, which is a container for `Tab` composables. The
    main Lambda of `TabRow` is used to generate the `Tab` elements. It iterates through
    each `TabItem` in tabs (which is a list of `TabItem` objects generated by `generateTabs()`),
    and for each one, it creates a `Tab` element. The `Tab` element is provided with
    an icon from `TabItem`, regardless of whether it’s selected (based on if its index
    matches `selectedIndex.value`), and an `onClick` function that sets `selectedIndex.value`
    to the index of the clicked `Tab`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`BottomBar` 通常放置应用的导航控件。在本例中，使用的是 `TabRow`，它是一个 `Tab` 组合组件的容器。`TabRow` 的主要
    Lambda 用于生成 `Tab` 元素。它遍历 tabs 中的每个 `TabItem`（这是由 `generateTabs()` 生成的 `TabItem`
    对象列表），并为每个对象创建一个 `Tab` 元素。`Tab` 元素会提供一个来自 `TabItem` 的图标，无论它是否被选中（基于其索引是否与 `selectedIndex.value`
    匹配），以及一个 `onClick` 函数，该函数将 `selectedIndex.value` 设置为点击的 `Tab` 的索引。
- en: 'Now, we need to add the content to the `Scaffold` composable:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要向 `Scaffold` 组合组件添加内容：
- en: '[PRE17]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `content` section is where the main content of your app goes. In this case,
    the content is a `HorizontalPager` composable with pages corresponding to the
    tabs in the bottom bar.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`content` 部分是放置应用主要内容的地方。在这种情况下，内容是一个 `HorizontalPager` 组合组件，其页面与底部栏中的标签相对应。'
- en: 'The main Lambda in `HorizontalPager` is used to generate each page. The content
    of the page is determined by the index provided to the Lambda: when `index` is
    `0`, `NewsFeed()` is displayed, and placeholders are left for the rest of the
    navigation options.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`HorizontalPager` 中的主要 Lambda 用于生成每一页。页面的内容由提供给 Lambda 的索引决定：当 `index` 为 `0`
    时，显示 `NewsFeed()`，并为其他导航选项留下占位符。'
- en: 'There’s another Lambda inside the `content` section: the `LaunchedEffect` block.
    This is essentially a side effect that is performed when `selectedIndex.value`
    changes. In this case, it triggers an animation that scrolls `HorizontalPager`
    to the page that corresponds to the selected index.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `content` 部分内部还有一个 Lambda：`LaunchedEffect` 块。这本质上是一个副作用，当 `selectedIndex.value`
    发生变化时执行。在这种情况下，它触发一个动画，将 `HorizontalPager` 滚动到与选定索引对应的页面。
- en: Now that `MainScreen` is ready, we can work on the `NewsFeed` list.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `MainScreen` 已经准备好了，我们可以着手处理 `NewsFeed` 列表。
- en: Creating the NewsFeed list
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 NewsFeed 列表
- en: 'First, we need to create the `ViewModel` class that we are going to use in
    our `NewsFeed` composable. We will call it `NewsFeedViewModel` and add the following
    code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建我们将在 `NewsFeed` 组合器中使用的 `ViewModel` 类。我们将称之为 `NewsFeedViewModel` 并添加以下代码：
- en: '[PRE18]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we are initializing `NewsFeedViewModel`. For now, we will only have a
    public property. We’ll use this to gather information so that we can render the
    posts in the user interface.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们正在初始化 `NewsFeedViewModel`。目前，我们只有一个公共属性。我们将使用它来收集信息，以便在用户界面中渲染帖子。
- en: 'Now, it is time to handle the dependency injection for this `NewsFeedViewModel`.
    We are creating a dependency injection module per app module. So, in this case,
    since we are working on the newsfeed module, we will create a new dependency injection
    module to provide `NewsFeedViewModel`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候处理这个 `NewsFeedViewModel` 的依赖注入了。我们为每个应用模块创建一个依赖注入模块。所以在这种情况下，因为我们正在处理新闻源模块，我们将创建一个新的依赖注入模块来提供
    `NewsFeedViewModel`：
- en: '[PRE19]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, we will add it to the modules list in `PacktagramApplication`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将将其添加到 `PacktagramApplication` 中的模块列表中：
- en: '[PRE20]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we’ve added `newsFeedModule` to the already existing modules list in `PacktagramApplication`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已将 `newsFeedModule` 添加到 `PacktagramApplication` 中现有的模块列表中。
- en: 'Now, we need to create the `NewsFeed` composable, which will include the list
    of posts:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建 `NewsFeed` 组合器，它将包括帖子列表：
- en: '[PRE21]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we can use `LazyColumn` to render the list of posts. As we can see, we
    will need a `PostItem` composable to draw every list item. We will build this
    in the following section.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们可以使用 `LazyColumn` 来渲染帖子列表。正如我们所看到的，我们需要一个 `PostItem` 组合器来绘制每个列表项。我们将在下一节中构建它。
- en: Creating the PostItem composable
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 PostItem 组合器
- en: 'Our `PostItem` composable will include all the components needed to render
    a post. We will need the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `PostItem` 组合器将包括渲染帖子所需的所有组件。我们需要以下内容：
- en: A title bar with the picture and name of the author
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有作者图片和名字的标题栏
- en: The media content (a picture initially but this could also be a video)
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 媒体内容（最初是一张图片，但这也可能是视频）
- en: An action bar with several actions (like, share, and so on)
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有多个操作（如点赞、分享等）的操作栏
- en: A label with the likes count
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示点赞数量的标签
- en: A caption written by the author
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作者撰写的标题
- en: The timestamp of the post’s publication
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帖子发布的时间戳
- en: 'Following those requirements, this is what our `PostItem` composable will look
    like:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 根据那些要求，我们的 `PostItem` 组合器将看起来像这样：
- en: '[PRE22]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, it is very readable and almost self-explanatory. We will create
    a `Column` composable and place every one of the composables we need vertically,
    leaving some spaces between as needed.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它非常易于阅读，几乎是自我解释的。我们将创建一个 `Column` 组合器，并将我们需要的每个组合器垂直放置，根据需要留出一些空间。
- en: 'Now, let’s create the composables we’ll need. We will start in order, with
    `TitleBar`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建我们需要的组合器。我们将按顺序开始，首先是 `TitleBar`：
- en: '[PRE23]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The base for this composable will be a `Row` composable as it will arrange its
    children in a horizontal sequence. The `verticalAlignment` parameter is set to
    `Alignment.CenterVertically` to align the items in the row vertically in the center.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组合器的基是一个 `Row` 组合器，因为它将子项按水平顺序排列。`verticalAlignment` 参数设置为 `Alignment.CenterVertically`，以使行中的项目垂直居中。
- en: 'Here’s a description of the children composables that were used:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对所使用的子组合器的描述：
- en: '**Spacer**: This is used to provide some space on the interface. Here, it provides
    a width of **5.dp** at the start of the row.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**间隔符**：这用于在界面上提供一些空间。在这里，它为行的开始提供了 **5.dp** 的宽度。'
- en: '**Image**: This is an image composable that is being used to display the user’s
    profile picture. The image source is taken from the **Post** object that was passed
    in.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图像**：这是一个用于显示用户个人资料的图像可组合项。图像来源是从传入的**Post**对象中获取的。'
- en: '**Text**: This displays the user’s name and takes the name from the **Post**
    object that was passed in. The **fontWeight** parameter is set to **FontWeight.Bold**
    to make the text bold.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本**：这显示用户的姓名，并从传入的**Post**对象中获取姓名。**fontWeight**参数设置为**FontWeight.Bold**，使文本加粗。'
- en: '**IconButton**: This is a button with an icon. The **onClick** parameter is
    a Lambda function that gets called when the button is clicked. In this case, the
    function is empty, but this is where you would put code to handle the button press.
    The **Icon** element inside is used to display the **more-options** icon.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IconButton**：这是一个带有图标的按钮。**onClick**参数是一个 Lambda 函数，当按钮被点击时会被调用。在这种情况下，该函数为空，但这是你放置处理按钮点击代码的地方。内部的**Icon**元素用于显示**更多选项**图标。'
- en: 'Now that `TitleBar` is ready, it’s time for the `MediaContent` composable,
    which will display the content that the user has posted:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`TitleBar`已经准备好了，是时候考虑`MediaContent`可组合项了，它将显示用户发布的内 容：
- en: '[PRE24]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding code generates a box that contains an image as this composable
    is used to display the main image content of a post. These are the main components:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码生成一个包含图像的框，因为此可组合项用于显示帖子的主要图像内容。这些是主要组件：
- en: '**Box**: This is a layout composable that stacks its children. In this case,
    it’s used to hold an **Image** component. The **contentAlignment** parameter is
    set to **Alignment.Center** to center the image in the box and has a modifier
    applied to it to fill the maximum width and to set a height of **300.dp**.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Box**：这是一个布局可组合项，堆叠其子元素。在这种情况下，它用于容纳一个**Image**组件。**contentAlignment**参数设置为**Alignment.Center**，以在框中居中图像，并对其应用了一个修改器，以填充最大宽度并设置高度为**300.dp**。'
- en: '**Image**: This is an **Image** composable that’s used to display an image.
    The image source is taken from the **Post** object passed in. The modifier is
    used to ensure the image fills the maximum size of the **Box** composable. Here,
    **rememberImagePainter** is used to load and display the image from a source (such
    as a URL or a local file), and it’s remembered across recompositions.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图像**：这是一个用于显示图像的**Image**可组合项。图像来源是从传入的**Post**对象中获取的。修改器用于确保图像填充**Box**可组合项的最大尺寸。在这里，**rememberImagePainter**用于从源（如
    URL 或本地文件）加载和显示图像，并且它在重组之间被记住。'
- en: 'Now that we’ve completed the `MediaContent` composable, we will consider `ActionsBar`,
    which will provide the instructions to render the action buttons:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了`MediaContent`可组合项，我们将考虑`ActionBar`，它将提供渲染操作按钮的指令：
- en: '[PRE25]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The preceding code generates a UI that represents the action buttons under
    a post, similar to those on Instagram where you can like, comment, share, and
    bookmark a post. Here’s what each part of the function does:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码生成一个 UI，表示帖子下的操作按钮，类似于 Instagram 上的那些，你可以点赞、评论、分享和收藏帖子。以下是函数每个部分的作用：
- en: '**Column**: This creates a column in which you can place other UI elements
    vertically. The **horizontalAlignment** parameter is set to **Alignment.CenterHorizontally**,
    which centers the elements horizontally in the column.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列**：这创建了一个列，可以在其中垂直放置其他 UI 元素。**horizontalAlignment**参数设置为**Alignment.CenterHorizontally**，这将在列中水平居中元素。'
- en: '**Row**: This creates a row in which other UI elements can be placed horizontally.
    It fills the maximum size of the parent, which is **Column**.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行**：这创建了一个行，其中可以水平放置其他 UI 元素。它填充了父元素的**最大尺寸**，即**列**。'
- en: The first group of three **IconButton** composables are in a **Row** composable
    and are for the **Like**, **Comment**, and **Share** actions. Each **IconButton**
    takes a Lambda for the **onClick** event, which currently does nothing.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前三组**IconButton**可组合项位于一个**Row**可组合项中，用于**点赞**、**评论**和**分享**操作。每个**IconButton**都接受一个
    Lambda 用于**onClick**事件，目前这个函数不做任何事情。
- en: There are then two additional **Row** composables, both with **fillMaxHeight().weight(1f)**,
    that appear to be placeholders, perhaps for adding additional icons in the future.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后还有两个额外的**Row**可组合项，两者都带有**fillMaxHeight().weight(1f)**，看起来像是占位符，可能是为了将来添加额外的图标。
- en: The final **Row** composable has an **IconButton** composable for the **Bookmark**
    action. It has **verticalAlignment** set to **Alignment.CenterVertically** and
    **horizontalArrangement** set to **Arrangement.End** to position the icon in the
    center vertically and at the end (right-hand side in LTR layouts) of the available
    space horizontally.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终的 **Row** 组合器包含一个用于 **Bookmark** 操作的 **IconButton** 组合器。它将 **verticalAlignment**
    设置为 **Alignment.CenterVertically**，将 **horizontalArrangement** 设置为 **Arrangement.End**
    以在垂直方向上居中图标，并在水平方向上位于可用空间的末尾（在 LTR 布局中为右侧）。
- en: '**Icon**: Each **Icon** displays an image and has a **contentDescription**
    composable for accessibility purposes. The **modifier** parameter can be used
    to adjust the layout or other visual properties of the icon.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图标**: 每个 **图标** 显示一个图像，并具有一个用于无障碍目的的 **contentDescription** 组合。可以使用 **modifier**
    参数来调整图标的布局或其他视觉属性。'
- en: 'Having configured the `ActionsBar` composable to provide a flexible UI layout
    featuring a range of interactive buttons, our next focus will be the likes count.
    It’s very straightforward to implement:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置了 `ActionsBar` 组合器以提供具有一系列交互按钮的灵活 UI 布局后，我们的下一个重点是点赞数。实现起来非常简单：
- en: '[PRE26]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `LikesCount` function is a `Composable` function that creates a row to
    display the number of likes that a post has received. Here’s what each part of
    the function does:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`LikesCount` 函数是一个 `Composable` 函数，用于创建一个行来显示帖子收到的点赞数。以下是函数的每个部分所做的工作：'
- en: '**Row**: This creates a row in which other UI elements can be placed horizontally.
    It uses the provided modifier to fill the maximum width of the parent container,
    setting its height to **30.dp** and adding a padding of **10.dp** horizontally.
    The **verticalAlignment** parameter is set to **Alignment.CenterVertically**,
    which centers the elements vertically in the row.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行**: 这创建了一个行，可以在其中水平放置其他 UI 元素。它使用提供的修饰符来填充父容器的最大宽度，将其高度设置为 **30.dp** 并在水平方向上添加
    **10.dp** 的填充。**verticalAlignment** 参数设置为 **Alignment.CenterVertically**，这将在行中垂直居中元素。'
- en: '**Text**: This creates a text element that displays the number of likes that
    the post has received. It gets the **likesCount** field from the **Post** object,
    converts it into a string, and appends the word **likes** to the end. It also
    sets the font weight to bold and the font size to **16.sp**.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本**: 这创建了一个显示帖子的点赞数的文本元素。它从 **Post** 对象中获取 **likesCount** 字段，将其转换为字符串，并在末尾添加单词
    **likes**。它还设置了字体粗细为粗体，字体大小为 **16.sp**。'
- en: 'The next composable is the caption, which is the text that the user adds to
    the post:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个组合器是标题，这是用户添加到帖子的文本：
- en: '[PRE27]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here’s what each part of the function does:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是函数每个部分所做的工作：
- en: '**Row**: This creates a row in which other UI elements can be placed horizontally.
    It uses the provided modifier to fill the maximum width of the parent container,
    wrap its height to its content, and add a padding of **10.dp** horizontally. The
    **verticalAlignment** parameter is set to **Alignment.CenterVertically**, which
    centers the elements vertically in the row.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行**: 这创建了一个行，可以在其中水平放置其他 UI 元素。它使用提供的修饰符来填充父容器的最大宽度，将其高度包裹为其内容，并在水平方向上添加
    **10.dp** 的填充。**verticalAlignment** 参数设置为 **Alignment.CenterVertically**，这将在行中垂直居中元素。'
- en: '**Text**: This creates a text element that displays the caption of the post,
    preceded by the user’s name. The **buildAnnotatedString** function is used to
    build a string with different text styles for different parts. Thanks to that,
    the user’s name is styled with a bold font weight, and the caption is styled with
    a normal font weight.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本**: 这创建了一个显示帖子的标题的文本元素，标题前有用户名。使用 **buildAnnotatedString** 函数构建具有不同文本样式的字符串。多亏了这一点，用户名以粗体字体样式呈现，而标题则以正常字体样式呈现。'
- en: 'Upon completing the `Caption` composable, let’s tackle the `CommentsCount`
    composable:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成 `Caption` 组合器后，让我们来处理 `CommentsCount` 组合器：
- en: '[PRE28]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `CommentsCount` composable creates a layout to display the number of comments
    on a post. Here’s what each part of the function does:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`CommentsCount` 组合器创建了一个布局来显示帖子的评论数。以下是函数的每个部分所做的工作：'
- en: '**Row**: This creates a row in which other UI elements can be placed horizontally.
    It uses the provided modifier to fill the maximum width of the parent container,
    wrap its height to its content, and add a padding of **10.dp** horizontally. The
    **verticalAlignment** parameter is set to **Alignment.CenterVertically**, which
    centers the elements vertically in the row.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行（Row）**：这将在其中放置其他UI元素的行中创建一个行。它使用提供的修饰符来填充父容器最大宽度，将其高度包裹到内容中，并在水平方向上添加**10.dp**的内边距。**verticalAlignment**参数设置为**Alignment.CenterVertically**，使行中的元素垂直居中。'
- en: '**Text**: This creates a text element that displays the number of comments.
    The **stringResource** function is used to get a string resource, which is a format
    string that takes a number and inserts it into the correct place to form a string
    that says **Read 3 comments**. The string format is then filled in with the number
    of comments from the **Post** object.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本（Text）**：这创建了一个显示评论数量的文本元素。使用**stringResource**函数获取字符串资源，这是一个格式字符串，它接受一个数字并将其插入到正确的位置，形成一个表示“阅读3条评论”的字符串。然后，该字符串格式用**Post**对象中的评论数量填充。'
- en: 'Now that we’ve finished implementing the `CommentsCount` composable, we will
    create the `TimeStamp` composable:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了`CommentsCount`可组合组件的实现，我们将创建`TimeStamp`可组合组件：
- en: '[PRE29]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `TimeStamp` function is a composable that creates a layout to display the
    timestamp of a post. Here’s what each part of the function does:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`TimeStamp`函数是一个创建用于显示帖子时间戳的布局的可组合组件。以下是函数的每个部分所做的工作：'
- en: '**Row**: This creates a row in which other UI elements can be placed horizontally.
    It uses the provided **Modifier** value to fill the maximum width of the parent
    container, wrap its height to its content, and add a padding of **10.dp** horizontally.
    The **verticalAlignment** parameter is set to **Alignment.CenterVertically**,
    centering the elements vertically in the row.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行（Row）**：这将在其中放置其他UI元素的行中创建一个行。它使用提供的**Modifier**值来填充父容器最大宽度，将其高度包裹到内容中，并在水平方向上添加**10.dp**的内边距。**verticalAlignment**参数设置为**Alignment.CenterVertically**，使行中的元素垂直居中。'
- en: '**Text**: This creates a text element that displays the timestamp. The **text**
    parameter of this function is set to a string that includes the **timeStamp**
    attribute from the **Post** object. The **fontSize** and **fontWeight** parameters
    set the size and weight of the font to **10.sp** and **FontWeight.Light**, respectively.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本（Text）**：这创建了一个显示时间戳的文本元素。此函数的**text**参数设置为包含**Post**对象中的**timeStamp**属性的字符串。**fontSize**和**fontWeight**参数分别设置字体大小为**10.sp**和**FontWeight.Light**。'
- en: 'With this composable, we have finished the `Post` composable components. If
    we do a preview with fake data, we’ll see the following screen:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个可组合组件，我们已经完成了`Post`可组合组件。如果我们用假数据预览，我们会看到以下屏幕：
- en: '![Figure 4.6: Newsfeed screen](img/B19443_04_006.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图4.6：新闻源屏幕](img/B19443_04_006.jpg)'
- en: 'Figure 4.6: Newsfeed screen'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6：新闻源屏幕
- en: Now, it is time to implement a way to populate the information needed from the
    backend.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候实现一种从后端获取所需信息的方法了。
- en: Using Retrofit and Moshi to retrieve newsfeed information
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Retrofit和Moshi检索新闻源信息
- en: In this section, we’re going to prepare our app so that it can retrieve the
    newsfeed information from the backend. To do that, we’ll need to create an HTTP
    client that handles the calls to the backend services. Since we used `ktor` in
    our first project, we are going to take a different approach for this one and
    use **Retrofit**.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将准备我们的应用程序，使其能够从后端检索新闻源信息。为此，我们需要创建一个处理对后端服务调用请求的HTTP客户端。由于我们在第一个项目中使用了`ktor`，我们将对此采取不同的方法，并使用**Retrofit**。
- en: 'Retrofit is a type-safe HTTP client for Android and Java (which is completely
    compatible with Kotlin). Retrofit makes it easy to connect to a REST web service
    by translating the API into Kotlin or Java interfaces. Here are some of its main
    features:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Retrofit是一个适用于Android和Java（与Kotlin完全兼容）的类型安全HTTP客户端。Retrofit通过将API转换为Kotlin或Java接口，使连接到REST
    Web服务变得简单。以下是它的一些主要功能：
- en: '**Easy to use**: Retrofit turns your HTTP API into a Kotlin or Java interface.
    All you have to do is define the API’s URL and method (**GET**, **POST**, and
    so on) using annotations. Retrofit will automatically convert the HTTP responses
    into data objects.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于使用**：Retrofit将您的HTTP API转换为Kotlin或Java接口。您只需使用注解定义API的URL和方法（**GET**、**POST**等）。Retrofit将自动将HTTP响应转换为数据对象。'
- en: '**Type conversion**: By default, Retrofit can only deserialize HTTP bodies
    into OkHttp’s **ResponseBody** type and it can only accept its **RequestBody**
    type for **@Body**. Converters can be added to support other types. For example,
    a JSON converter can be used to convert the API’s responses into Kotlin or Java
    objects automatically.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型转换**：默认情况下，Retrofit只能将HTTP体反序列化为OkHttp的**ResponseBody**类型，并且它只能接受**@Body**的**RequestBody**类型。可以通过添加转换器来支持其他类型。例如，可以使用JSON转换器自动将API的响应转换为Kotlin或Java对象。'
- en: '**HTTP methods annotations**: You can use annotations to describe HTTP methods
    such as **GET**, **POST**, **DELETE**, **UPDATE**, and others. You can also use
    other annotations, such as **Headers**, **Body**, **Field**, **Path**, and more,
    to make your request exactly as needed.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP方法注解**：你可以使用注解来描述HTTP方法，如**GET**、**POST**、**DELETE**、**UPDATE**等。你还可以使用其他注解，如**Headers**、**Body**、**Field**、**Path**等，使你的请求完全符合需求。'
- en: '**URL parameter replacement and query parameter support**: Add parameters to
    your request with annotations. For example, you can add a path parameter by setting
    the specific value in the URL, or you can add a query parameter at the end of
    the URL.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**URL参数替换和查询参数支持**：使用注解向请求添加参数。例如，你可以通过在URL中设置特定值来添加路径参数，或者你可以在URL末尾添加查询参数。'
- en: '**Synchronous and asynchronous calls**: Retrofit supports both synchronous
    (blocking) calls and asynchronous (non-blocking) calls. For Android, asynchronous
    calls are more important as network operations on the main thread are discouraged.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同步和异步调用**：Retrofit支持同步（阻塞）调用和异步（非阻塞）调用。对于Android，异步调用更为重要，因为不建议在主线程上进行网络操作。'
- en: '**Support for coroutines and RxJava**: Retrofit provides out-of-the-box support
    for coroutines and RxJava. This makes it easy to use with these popular libraries
    for handling asynchronous operations.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协程和RxJava支持**：Retrofit提供了开箱即用的协程和RxJava支持。这使得与这些流行的库处理异步操作变得容易。'
- en: '**Interceptors**: Retrofit also allows you to use OkHttp’s interceptors. You
    can add headers to every request or log the request and response data for debugging
    purposes.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拦截器**：Retrofit还允许你使用OkHttp的拦截器。你可以为每个请求添加头信息，或者为了调试目的记录请求和响应数据。'
- en: 'We also need to use a converter to parse the backend responses into objects.
    We will use **Moshi** ([https://github.com/square/moshi](https://github.com/square/moshi))
    for that. Moshi is a modern JSON library for Android and Java, also built by Square.
    It aims to be easy to use and efficient, and its design is inspired by the well-regarded
    Gson library, but it seeks to improve upon several design aspects. Here are some
    of its main features:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要使用转换器将后端响应解析为对象。我们将使用**Moshi**（[https://github.com/square/moshi](https://github.com/square/moshi)）来完成这项工作。Moshi是一个现代的Android和Java
    JSON库，也是由Square构建的。它旨在易于使用且高效，其设计灵感来源于备受推崇的Gson库，但它在几个设计方面寻求改进。以下是其主要功能：
- en: '**Easy to use**: Moshi provides simple **toJson()** and **fromJson()** methods
    to convert Java and Kotlin objects into JSON and vice versa.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于使用**：Moshi提供了简单的**toJson()**和**fromJson()**方法，用于将Java和Kotlin对象转换为JSON以及反向转换。'
- en: '**Built-in and custom converters**: Moshi has built-in support for converting
    many common types and can encode any object graph of these. For other classes,
    you can write custom converters, called **adapters**, that define how these types
    are converted to and from JSON.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内置和自定义转换器**：Moshi内置了对许多常见类型的转换支持，并能编码这些类型的任何对象图。对于其他类，你可以编写自定义转换器，称为**适配器**，来定义这些类型如何转换为JSON以及从JSON转换回来。'
- en: '**Kotlin support**: Moshi supports Kotlin and provides the **moshi-kotlin-codegen**
    module, which leverages annotation processing to generate adapters for your Kotlin
    classes automatically.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kotlin支持**：Moshi支持Kotlin，并提供**moshi-kotlin-codegen**模块，该模块利用注解处理自动生成Kotlin类的适配器。'
- en: '**Null safety**: Moshi handles **null** values in the JSON input and can be
    configured to allow or disallow **null** values in your Java or Kotlin objects.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**空值安全**：Moshi处理JSON输入中的**null**值，并且可以配置为允许或禁止Java或Kotlin对象中的**null**值。'
- en: '**Annotation-based**: Much like Retrofit, Moshi uses annotations to denote
    special behavior for certain fields (for example, custom names and transient values).'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于注解**：与Retrofit类似，Moshi使用注解来表示某些字段的特殊行为（例如，自定义名称和瞬态值）。'
- en: '**Fault-tolerant**: Moshi is fault-tolerant and will not fail the entire operation
    if it encounters unknown properties or incompatible types in the JSON data. This
    can be beneficial when dealing with APIs that may occasionally change.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容错性**: Moshi 具有容错性，当它在 JSON 数据中遇到未知属性或不兼容类型时，不会使整个操作失败。当处理可能偶尔改变的 API 时，这可能是有益的。'
- en: '**Efficient**: Moshi is designed to be efficient in its operation, minimizing
    object allocation and garbage collection overhead.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高效**: Moshi 被设计为在操作中高效，最小化对象分配和垃圾回收开销。'
- en: Now that we know the advantages of using Retrofit with Moshi, let’s start integrating
    them into our project.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道了使用 Retrofit 与 Moshi 的优势，让我们开始将它们集成到我们的项目中。
- en: Adding the Retrofit and Moshi dependencies
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 Retrofit 和 Moshi 依赖
- en: 'To use both the Retrofit and Moshi libraries, we need to configure their dependencies.
    First, we will add them to the versions catalog file:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Retrofit 和 Moshi 库，我们需要配置它们的依赖项。首先，我们将它们添加到版本目录文件中：
- en: '[PRE30]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, we will include the dependencies in our module’s `build.gradle.kts` file,
    making them available to use in our module:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将这些依赖项包含在我们的模块的 `build.gradle.kts` 文件中，使它们在我们的模块中可用：
- en: '[PRE31]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: After adding these dependencies, we should be ready to work with both libraries.
    Let’s start creating our data source so that we can obtain the data for the newsfeed.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这些依赖项后，我们应该准备好使用这两个库。让我们开始创建我们的数据源，以便我们可以获取新闻源的数据。
- en: Creating the data source for the newsfeed
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新闻源的数据源
- en: 'At this point, we’re ready to create our data source. We will do this in the
    `:feature:newsfeed` module. First, we need to create an interface to define our
    API endpoints using Retrofit. We can use `@GET`, `@POST`, and others to define
    what kind of HTTP request we want to make:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们准备创建我们的数据源。我们将在 `:feature:newsfeed` 模块中完成这项工作。首先，我们需要创建一个接口来定义我们的 API
    端点，使用 Retrofit。我们可以使用 `@GET`、`@POST` 等来定义我们想要进行的 HTTP 请求类型：
- en: '[PRE32]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This is an interface for the Retrofit library that’s used to turn the HTTP
    API into a Kotlin interface. It also defines an endpoint for your API:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个用于将 HTTP API 转换为 Kotlin 接口的 Retrofit 库的接口。它还定义了您的 API 的端点：
- en: '**interface NewsFeedService**: This is declaring a new interface named **NewsFeedService**.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口 NewsFeedService**: 这是在声明一个名为 **NewsFeedService** 的新接口。'
- en: '**@GET("feed")**: This is an annotation that describes an HTTP GET request.
    The **"feed"** parameter is the endpoint where the request will be sent. So, the
    full URL for this request would be something like [https://packtagram.com/feed](https://packtagram.com/feed)
    if the base URL of your Retrofit client is [https://packtagram.com/](https://packtagram.com/).'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**@GET("feed")**: 这是一个描述 HTTP GET 请求的注解。参数 **"feed"** 是请求将被发送的端点。因此，这个请求的完整
    URL 将类似于 [https://packtagram.com/feed](https://packtagram.com/feed)，如果您的 Retrofit
    客户端的基本 URL 是 [https://packtagram.com/](https://packtagram.com/)。'
- en: '**suspend fun getNewsFeed(): List<PostApiData>**: This is declaring a function
    named **getNewsFeed** that is expected to return a list of **Post** objects. The
    **suspend** keyword means that this function is a suspending function, which is
    a type of function that can be paused and resumed at a later time. This will be
    called later from a coroutine.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**挂起函数 getNewsFeed(): List<PostApiData>**: 这是在声明一个名为 **getNewsFeed** 的函数，它预期返回一个
    **Post** 对象的列表。关键字 **suspend** 表示这个函数是一个挂起函数，这是一种可以在稍后暂停和恢复的函数类型。这将在稍后从协程中调用。'
- en: So, to put it all together, when `getFeed` is called, it will make a `GET` request
    to the [https://packtagram.com/feed](https://packtagram.com/feed) URL and expect
    to receive a JSON array of `PostApiData` objects, which are then parsed into a
    list of `Post` objects in your Kotlin code.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总的来说，当调用 `getFeed` 时，它将向 [https://packtagram.com/feed](https://packtagram.com/feed)
    URL 发送 `GET` 请求，并期望接收一个 `PostApiData` 对象的 JSON 数组，然后这些对象在您的 Kotlin 代码中被解析成 `Post`
    对象的列表。
- en: To see an example of a JSON file that contains the expected fields, check out
    [https://api.mockfly.dev/mocks/09e4e43e-7992-4dd7-b99f-e168667a240e/feed](https://api.mockfly.dev/mocks/09e4e43e-7992-4dd7-b99f-e168667a240e/feed).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看包含预期字段的 JSON 文件的示例，请查看 [https://api.mockfly.dev/mocks/09e4e43e-7992-4dd7-b99f-e168667a240e/feed](https://api.mockfly.dev/mocks/09e4e43e-7992-4dd7-b99f-e168667a240e/feed)。
- en: 'Now, we need to generate a client from this interface. For that, we will use
    the Retrofit builder:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要从这个接口生成一个客户端。为此，我们将使用 Retrofit 构建器：
- en: '[PRE33]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, we are creating a function called `getNewsFeedApi()` that will build the
    `NewsFeedService` client. For that, we need a `BASE_URL` function that we can
    hardcode in this same file. The recommendation is to store this information in
    a configuration file so that we can easily change it if we need to have different
    `buildTypes` of the app, for example.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在创建一个名为 `getNewsFeedApi()` 的函数，该函数将构建 `NewsFeedService` 客户端。为此，我们需要一个
    `BASE_URL` 函数，我们可以将其硬编码在此文件中。建议将此信息存储在配置文件中，这样我们就可以轻松地更改它，例如，如果我们需要不同 `buildTypes`
    的应用程序。
- en: We are also adding the Moshi converter using the `.addConverterFactory` **(MoshiConverterFactory.create())**
    function. This will allow Retrofit to deserialize the backend responses using
    Moshi.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在使用 `.addConverterFactory` **(MoshiConverterFactory.create())** 函数添加 Moshi
    转换器。这将允许 Retrofit 使用 Moshi 反序列化后端响应。
- en: 'Now, we need to create `NewsFeedRemoteDataSource`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建 `NewsFeedRemoteDataSource`：
- en: '[PRE34]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As we can see, we have created a `NewsFeedRemoteDataSource` composable. Here,
    we will have one function, `getNewsFeed(`). This function will call `NewsFeedService`
    to obtain the newsfeed.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们已经创建了一个 `NewsFeedRemoteDataSource` 可组合组件。在这里，我们将有一个名为 `getNewsFeed()`
    的函数。此函数将调用 `NewsFeedService` 来获取新闻源。
- en: Now, let’s create the repository for this newsfeed.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为这个新闻源创建仓库。
- en: Creating the repository
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建仓库
- en: 'The next step is to define the repository that will orchestrate the information
    gathering and storage using the different data sources (for now, we only have
    one, `NewsFeedRemoteDataSource`). It will also map the information into the new
    layer: the domain layer.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是定义将使用不同数据源（目前我们只有一个，`NewsFeedRemoteDataSource`）来协调信息收集和存储的仓库。它还将信息映射到新层：域层。
- en: 'First, we’ll define its interface as part of the domain layer:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义其接口作为域层的一部分：
- en: '[PRE35]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Second, we’ll implement its functionality as part of the data layer:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步，我们将实现其功能作为数据层的一部分：
- en: '[PRE36]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As we can see, for now, it will only have a `getNewsFeed()` function that will
    obtain a list of `Post`. objects It will obtain the newsfeed from the remote data
    source and map the `PostApiData` objects into `Post` objects.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，目前它将只有一个 `getNewsFeed()` 函数，该函数将获取 `Post` 对象的列表。它将从远程数据源获取新闻源并将 `PostApiData`
    对象映射到 `Post` 对象。
- en: Now, let’s create the use case to obtain this data.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个用例来获取这些数据。
- en: Creating the GetTheNewsFeedUseCase
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 GetTheNewsFeedUseCase
- en: 'As we progress through the layers, the next step will be to create the use
    cases needed. In this case, we will create a use case to obtain the newsfeed –
    that is, `GetTheNewsFeedUseCase`:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们通过层，下一步将是创建所需的用例。在这种情况下，我们将创建一个用于获取新闻源的用例——即 `GetTheNewsFeedUseCase`：
- en: '[PRE37]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, we are using `repository` to get the newsfeed in the `invoke` function.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在使用 `repository` 在 `invoke` 函数中获取新闻源。
- en: 'Before continuing, we need to create the data classes that we will be using
    in the data and domain layers. In the case of the domain layer, we will create
    the `Post` data class:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们需要创建我们将在数据和域层中使用的数据类。在域层的案例中，我们将创建 `Post` 数据类：
- en: '[PRE38]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, we are declaring all the fields that we need for the `Post` object in
    the domain layer.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在声明在域层中 `Post` 对象所需的所有字段。
- en: 'In the case of the data layer, we will create the `PostApiData` data class
    and mapping functions that we’ll need to map to the domain object:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据层的案例中，我们将创建所需的 `PostApiData` 数据类和映射函数，我们将将其映射到域对象：
- en: '[PRE39]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, we should include the fields that the response from the backend will return
    to our app. Note that we are using the `@Json(name = "")` annotation in the properties
    to specify the name of the field in the JSON that the backend will return.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们应该包括后端响应将返回到我们的应用程序的字段。请注意，我们正在使用 `@Json(name = "")` 注解在属性中指定后端将返回的 JSON
    字段名称。
- en: 'Before jumping to consume the use case in `ViewModel`, we have to sort out
    the dependency injection for all the components we have just created. We will
    do so in `newsFeedModule`:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在跳转到 `ViewModel` 中的用例之前，我们必须整理我们刚刚创建的所有组件的依赖注入。我们将在 `newsFeedModule` 中这样做：
- en: '[PRE40]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now, it is time to integrate this use case into `NewsFeedViewModel`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候将此用例集成到 `NewsFeedViewModel` 中了。
- en: Integrating the use case into our ViewModel
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将用例集成到 ViewModel 中
- en: 'For the ViewModel, we will need to create a new function to obtain the posts.
    We will call it `loadPosts()`:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 ViewModel，我们需要创建一个新的函数来获取帖子。我们将称其为 `loadPosts()`：
- en: '[PRE41]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, we are loading the posts as soon as the app shows the view and the ViewModel
    is created.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在加载帖子，一旦应用程序显示视图并且 ViewModel 被创建。
- en: The changes to the `posts` property are already being consumed by our `NewsFeed`
    composable, so it will update the UI when it receives any posts.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `posts` 属性的更改已经被我们的 `NewsFeed` 组合式消费，因此当它收到任何帖子时，它将更新 UI。
- en: We could also add some error handling here, but as we already worked on that
    topic in the first project, we will leave it here.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在这里添加一些错误处理，但由于我们已经在第一个项目中处理了该主题，我们将在这里保留它。
- en: Now, it wouldn’t be realistic (and performant) to load all the existing posts
    initially. As we did with the messaging project, we’ll need to paginate so that
    we can obtain the posts gradually, following the user scroll. We will see how
    in the next section.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一开始就加载所有现有帖子并不现实（也不高效）。就像我们在消息项目中做的那样，我们需要分页，以便我们可以逐渐获取帖子，跟随用户的滚动。我们将在下一节中看到这一点。
- en: Implementing pagination in the newsfeed
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在新闻源中实现分页
- en: To implement pagination in our app, we will start by modifying the Retrofit
    service. Typically you’re required to add parameters to your API endpoint that
    control the “page” of data you’re requesting. For instance, we might have a `pageNumber`
    parameter and a `pageSize` parameter (though this will depend on the design of
    your backend endpoints).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的应用程序中实现分页，我们将首先修改 Retrofit 服务。通常，您需要向您的 API 端点添加参数来控制您请求的数据的“页”。例如，我们可能有一个
    `pageNumber` 参数和一个 `pageSize` 参数（尽管这将取决于您后端端点的设计）。
- en: 'First, let’s adjust `NewsFeedService` so that it includes the two parameters
    we just mentioned:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们调整 `NewsFeedService`，使其包括我们刚才提到的两个参数：
- en: '[PRE42]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, we will need to change the signature of the data source function so that
    it includes those fields. In the data source, we will change the following function:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要更改数据源函数的签名，使其包括这些字段。在数据源中，我们将更改以下函数：
- en: '[PRE43]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the repository, we will handle storing the current page and keeping the
    desired size of pages (this could also be a constant somewhere):'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储库中，我们将处理存储当前页和保持所需页面大小（这也可以是某个地方的一个常量）：
- en: '[PRE44]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, we are storing the current page so that when we call the data source,
    we can specify if we want the next one. We have also added a function called `resetPagination()`
    that will reset the current page so that we can start again.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们存储当前页，以便当我们调用数据源时，我们可以指定我们是否想要下一页。我们还添加了一个名为 `resetPagination()` 的函数，该函数将重置当前页，以便我们可以重新开始。
- en: 'Next, we are going to use `resetPagination()` in `UseCase` when the user navigates
    to the top and wants to get the first of the publications:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，当用户导航到顶部并想要获取出版物列表的第一页时，我们将使用 `resetPagination()` 在 `UseCase` 中：
- en: '[PRE45]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The next step is to handle when we should load the next page and load the next
    posts. To do so, we’ll need to modify our `NewsFeed` composable and `NewsFeedViewModel`.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是处理何时加载下一页和加载下一批帖子。为此，我们需要修改我们的 `NewsFeed` 组合式和 `NewsFeedViewModel`。
- en: 'First, we are going to implement the `NewsFeedViewModel` part:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将实现 `NewsFeedViewModel` 部分：
- en: '[PRE46]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here, we’ve renamed our initial function `loadInitialPosts()` so that it indicates
    that it will load the first posts. Then, we created a new function called `loadMorePosts()`
    that will load the new page. It will add it to the existing post list.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将初始函数重命名为 `loadInitialPosts()`，以便它表明它将加载第一篇帖子。然后，我们创建了一个名为 `loadMorePosts()`
    的新函数，该函数将加载新页面。它将把它添加到现有的帖子列表中。
- en: 'Now, we need to make a few modifications to our `NewsFeed` composable so that
    it will call the ViewModel when a new page is needed. For that reason, we need
    to create a `LazyListState` extension that we will invoke whenever the user reaches
    the end of the list:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要对 `NewsFeed` 组合式进行一些修改，以便它在需要新页面时调用 ViewModel。为此，我们需要创建一个 `LazyListState`
    扩展，我们将在用户到达列表末尾时调用它：
- en: '[PRE47]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This extension function observes the scrolling state of `LazyColumn` or `LazyRow`.
    When the user has scrolled to the bottom, it calls the provided `loadMore` function
    to load more items. This pattern is common in implementing “infinite scrolling”
    or “pagination,” which is what we are currently implementing.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 此扩展函数观察 `LazyColumn` 或 `LazyRow` 的滚动状态。当用户滚动到列表底部时，它将调用提供的 `loadMore` 函数来加载更多项目。这种模式在实现“无限滚动”或“分页”时很常见，这正是我们目前正在实现的。
- en: 'Now, we need to use it in our `LazyColumn` layout. For that, we need to remember
    `LazyListState` in the `NewsFeed` composable:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在我们的 `LazyColumn` 布局中使用它。为此，我们需要在 `NewsFeed` 组合式中记住 `LazyListState`：
- en: '[PRE48]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: With this change, every time our user reaches the bottom of the list, we will
    call the function to load more posts and get the next page.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 随着这一变化，每次用户到达列表底部时，我们都会调用函数来加载更多帖子并获取下一页。
- en: Now that we’ve finished our paging implementation, our user experience will
    be more performant and smoother when navigating the newsfeed.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了分页功能的实现，当用户在浏览新闻源时，用户体验将更加高效和流畅。
- en: Summary
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we primarily focused on structuring and modularizing our Packtagram
    app while enhancing maintainability. Leveraging Jetpack Compose, we designed the
    components and screens for some of the features of the interface that we are going
    to be working on in the next chapters.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们主要专注于对Packtagram应用进行结构和模块化，同时增强其可维护性。利用Jetpack Compose，我们设计了界面中一些将在下一章中继续工作的功能组件和屏幕。
- en: Additionally, this chapter delved into the intricacies of connecting the developed
    UI to the backend, which is pivotal for data management and operation handling.
    We implemented Retrofit for network operations and Moshi for JSON parsing, bridging
    the gap between the user interface and the data source. Moreover, we introduced
    the concept of paging to efficiently manage large datasets. By doing so, we ensured
    smoother data load, faster response times, and enhanced app performance overall,
    significantly improving the user’s experience.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，本章还深入探讨了将开发的UI连接到后端的技术细节，这对于数据管理和操作处理至关重要。我们实现了Retrofit用于网络操作和Moshi用于JSON解析，架起了用户界面和数据源之间的桥梁。此外，我们引入了分页的概念，以有效地管理大量数据集。通过这样做，我们确保了数据加载更加平滑，响应时间更快，整体提升了应用性能，显著改善了用户体验。
- en: In the next chapter, we will dive into the photo functionality of our app. We
    will use an incredible library called CameraX and take advantage of some of its
    capabilities. We will also learn how to apply machine learning to our camera preview
    using ML Kit.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨我们应用的照片功能。我们将使用一个名为CameraX的令人难以置信的库，并利用其一些功能。我们还将学习如何使用ML Kit将机器学习应用于相机预览。
