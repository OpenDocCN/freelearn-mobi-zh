- en: Chapter 4. Storyboard Applications with Swift and iOS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章. 使用 Swift 和 iOS 的 Storyboard 应用
- en: Storyboards were originally introduced in Xcode 4.2 with iOS 5.0\. Storyboards
    solved the problem of being able to graphically present the flow of screens in
    an iOS application, and they also provided a way to edit the content of these
    screens in one place instead of many separate `xib` files. Storyboards work in
    the same way with Swift as with Objective-C, and the *Swift and storyboards* section
    shows how to integrate Swift code with storyboard transitions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Storyboard 首先在 Xcode 4.2 和 iOS 5.0 中引入。Storyboard 解决了在 iOS 应用程序中图形化展示屏幕流程的问题，并且还提供了一种方法，可以在一个地方而不是多个单独的
    `xib` 文件中编辑这些屏幕的内容。Storyboard 与 Swift 的工作方式与 Objective-C 相同，*Swift 和 storyboard*
    部分展示了如何将 Swift 代码与 storyboard 切换集成。
- en: 'This chapter will present the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍以下主题：
- en: How to create a storyboard project
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建 storyboard 项目
- en: Creating multiple scenes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建多个场景
- en: Using segues to navigate between scenes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用切换在场景之间导航
- en: Writing custom view controllers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写自定义视图控制器
- en: Connecting views to outlets in Swift
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Swift 中将视图连接到输出口
- en: Laying out views with Auto Layout
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自动布局排列视图
- en: Using constraints to build resizable views
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用约束构建可调整大小的视图
- en: Storyboards, scenes, and segues
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Storyboard、场景和切换
- en: By default, Xcode 7 creates a `Main.storyboard` file instead of a `MainWindow.xib`
    file for newly-created iOS projects. The `UIMainStoryboardFile` key in the `Info.plist`
    file points to the application's main storyboard name (without the extension).
    When the application starts up, the `Main.storyboard` file is loaded instead of
    the `NSMainNib` entry. Prior versions of Xcode allowed developers to opt in or
    out of storyboards, but with Xcode 7, storyboards are the default and developers
    cannot easily opt out. It is still possible to use the `xib` files for individual
    sections of an application or to use them to load custom classes for prototype
    table cells. In addition, Xcode 7 creates a `LaunchScreen.storyboard` to display
    as a splash screen (on iOS 8 and higher) while the application is loading, in
    preference to prerendered screens at fixed resolutions. This allows devices with
    many different resolutions (including future unannounced ones) to render pixel-perfect
    splash screens without having to be rendered at different resolutions for each
    new device size.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Xcode 7 为新创建的 iOS 项目创建一个 `Main.storyboard` 文件，而不是 `MainWindow.xib` 文件。`Info.plist`
    文件中的 `UIMainStoryboardFile` 键指向应用程序的主 storyboard 名称（不带扩展名）。当应用程序启动时，将加载 `Main.storyboard`
    文件而不是 `NSMainNib` 条目。Xcode 的早期版本允许开发者选择是否使用 storyboard，但 Xcode 7 中，storyboard
    是默认选项，开发者无法轻易选择退出。尽管如此，仍然可以使用 `xib` 文件为应用程序的各个部分或用于加载原型表格单元格的自定义类。此外，Xcode 7 创建一个
    `LaunchScreen.storyboard` 文件，在应用程序加载时显示为启动画面（在 iOS 8 及更高版本上），优先于固定分辨率的预渲染屏幕。这允许具有许多不同分辨率的设备（包括未来未宣布的设备）渲染像素完美的启动画面，而无需为每个新设备尺寸渲染不同分辨率的画面。
- en: A *storyboard* is a collection of *scenes* (separate screens) that are connected
    with *segues* (pronounced *seg-ways*). Each scene is represented by a *view controller*,
    which has an associated *view*. Segues transition between different scenes with
    a customizable user-interface transition, such as a slide or fade, and they can
    be triggered from a UI control or programmatically.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*Storyboard* 是由 *segues*（发音为 *seg-ways*）连接的 *场景*（独立的屏幕）集合。每个场景由一个 *视图控制器* 表示，它有一个相关的
    *视图*。切换通过可定制的用户界面过渡（如滑动或淡入淡出）在不同场景之间进行转换，并且可以从 UI 控件或以编程方式触发。'
- en: Creating a storyboard project
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 storyboard 项目
- en: As the default templates with Xcode 7 use storyboards by default, any of the
    templates will work. In fact, each of the application templates set up a specific
    type of view controller and template code. The simplest template to work with
    and customize is the **Single View Application**, which can be selected by navigating
    to **File** | **New** | **Project…**. Create a project called `Storyboards`, which
    uses a single-view application, for experimentation with this chapter. (Refer
    to the *Creating a single view iOS application* section in [Chapter 3](part0029_split_000.html#RL0A1-d7e55eb5242648e89c396442afe4f84b
    "Chapter 3. Creating an iOS Swift App"), *Creating an iOS Swift App*, for more
    details on how to create a new application.)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Xcode 7 的默认模板默认使用故事板，因此任何模板都将工作。实际上，每个应用程序模板都设置了一个特定的视图控制器和模板代码。最简单且易于定制的工作模板是**单视图应用程序**，可以通过导航到**文件**
    | **新建** | **项目…**来选择。创建一个名为 `Storyboards` 的项目，使用单视图应用程序，以实验本章内容。（有关如何创建新应用程序的更多详细信息，请参阅[第
    3 章](part0029_split_000.html#RL0A1-d7e55eb5242648e89c396442afe4f84b "第 3 章。创建
    iOS Swift 应用")中的*创建单视图 iOS 应用程序*部分，*创建 iOS Swift 应用*。）
- en: Scenes and view controllers
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 场景和视图控制器
- en: 'Standard view controllers can be used to build up an application, which includes
    the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 标准视图控制器可以用来构建应用程序，包括以下内容：
- en: Split views using a `UISplitViewController` class, which can contain any of
    the following but may not be embedded in any other view controller
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `UISplitViewController` 类的分割视图，该类可以包含以下任何一种，但不能嵌入到任何其他视图控制器中
- en: Tabbed views using a `UITabBarController` class, which can contain any of the
    following but may only be embedded in a split view or used as the root controller
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `UITabBarController` 类的标签视图，该类可以包含以下任何一种，但只能嵌入到分割视图中或用作根控制器
- en: Navigational controls can be added to existing controllers with a `UINavigationController`
    class, which can contain any of the following and may be embedded in any of the
    preceding or used as a root view controller
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用 `UINavigationController` 类向现有控制器添加导航控件，该类可以包含以下任何一种，并且可以嵌入到前面的任何一种或用作根视图控制器
- en: Paginated views using a `UIPageViewController` class, which provide both sliding
    and page curling display options
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `UIPageViewController` 类的翻页视图，该类提供滑动和翻页显示选项
- en: Tabular views using a `UITableViewController` class
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `UITableViewController` 类的表格视图
- en: Grid views using a `UICollectionViewController` class
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `UICollectionViewController` 类的网格视图
- en: Audio-visual content using a `AVPlayerViewController` class
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `AVPlayerViewController` 类的音频-视频内容
- en: OpenGL ES content using a `GLKViewController` class
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `GLKViewController` 类的 OpenGL ES 内容
- en: Custom controller content using a `UIViewController` class or a custom subclass
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `UIViewController` 类或自定义子类创建自定义控制器内容
- en: 'These classes can be mixed, but there is an explicit ordering that must be
    followed to satisfy the Apple **Human Interface Guidelines** (also known as the
    **HIG**). These are all optional, but if combined, they need to obey this ordering:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类可以混合使用，但必须遵循明确的顺序以满足苹果的**人类界面指南**（也称为**HIG**）。这些都是可选的，但如果组合使用，则需要遵守此顺序：
- en: '![Scenes and view controllers](img/00037.jpeg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![场景和视图控制器](img/00037.jpeg)'
- en: In addition to the standard view controller classes, custom subclasses can be
    used as well. This is covered in more detail in the *Custom view controllers*
    section later in this chapter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标准视图控制器类之外，还可以使用自定义子类。这将在本章后面的“自定义视图控制器”部分中更详细地介绍。
- en: Adding views to the scene
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向场景添加视图
- en: The `Main.storyboard` file can be opened by clicking on the file in the project
    navigator. An editor will open, which shows the storyboard as a set of scenes
    along with the document outline on the left. In a single-page application, only
    one view controller will exist.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在项目导航器中单击文件来打开 `Main.storyboard` 文件。将打开一个编辑器，它将故事板显示为一系列场景，同时在左侧显示文档大纲。在单页应用程序中，只有一个视图控制器存在。
- en: '![Adding views to the scene](img/00038.jpeg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![向场景添加视图](img/00038.jpeg)'
- en: The arrow to the left of the view controller indicates that this scene is the
    *initial view controller*. This can also be set with the **Is Initial View Controller**
    checkbox, which can be seen by selecting the **View Controller** from the scene
    and navigating to the *attributes inspector* (go to **View** | **Utilities** |
    **Show Attributes Inspector**, or press *Command* + *Option* + *4*). The initial
    view controller can also be changed to a different scene by dragging and dropping
    the arrow to point to a different scene.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 视图控制器左侧的箭头表示此场景是 *初始视图控制器*。这也可以通过选择场景中的 **视图控制器** 并导航到 *属性检查器*（转到 **视图** | **实用工具**
    | **显示属性检查器**，或按 *Command* + *Option* + *4*）来设置。也可以通过拖放箭头指向不同的场景来将初始视图控制器更改为不同的场景。
- en: 'Views are added by dragging and dropping them from the *object library* at
    the bottom-right of Xcode. The object library can be shown by navigating to **View**
    | **Utilities** | **Show Object Library**, or by pressing *Command* + *Option*
    + *Control* + *3*. Click on a view, such as the **Label**, and drag it into the
    view:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从 Xcode 右下角的 *对象库* 中拖放来添加视图。可以通过导航到 **视图** | **实用工具** | **显示对象库**，或者按 *Command*
    + *Option* + *Control* + *3* 来显示对象库。点击一个视图，例如 **标签**，然后将其拖放到视图中：
- en: '![Adding views to the scene](img/00039.jpeg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![将视图添加到场景](img/00039.jpeg)'
- en: 'The label''s text content can be modified by double-clicking on the label in
    the view and typing or by selecting the object and editing the text attribute
    in the attributes inspector:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在视图中双击标签并输入或通过选择对象并在属性检查器中编辑文本属性来修改标签的文本内容：
- en: '![Adding views to the scene](img/00040.jpeg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![将视图添加到场景](img/00040.jpeg)'
- en: When the element is dragged, blue guide lines may be shown. They suggest locations
    for the views; the standard is to have a 20pt gap between the views and the edge
    of the screen and an 8pt gap between adjacent views.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当元素被拖动时，可能会显示蓝色引导线。它们建议视图的位置；标准做法是在视图和屏幕边缘之间保持 20pt 的间隔，在相邻视图之间保持 8pt 的间隔。
- en: Drag the **Welcome to Swift** label to the top-left of the scene and then drag
    a **Button** from the object library into the scene. Rename the button's title
    to **Press Me**. This button should be a standard space (8pt) away from the label
    and aligned at the baseline (the level at which the text naturally sits).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 将 **欢迎使用 Swift** 标签拖放到场景的左上角，然后从对象库中拖放一个 **按钮** 到场景中。将按钮的标题重命名为 **按我**。此按钮应与标签保持标准空间（8pt）的距离，并对齐在基线（文本自然坐落的水平）上。
- en: '![Adding views to the scene](img/00041.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![将视图添加到场景](img/00041.jpeg)'
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: At this point, the text in the views is hardcoded in the user interface file
    and the alignment is manual, which means that the views will not resize if the
    parent view is modified. These problems will be addressed in the *Connecting views
    to outlets in Swift* and *Using Auto Layout* sections later in this chapter.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段，视图中的文本在用户界面文件中是硬编码的，对齐是手动的，这意味着如果修改父视图，视图将不会调整大小。这些问题将在本章后面的 *将视图连接到 Swift
    中的出口* 和 *使用自动布局* 部分中解决。
- en: To view the storyboard in the simulator, click on the **Play** button at the
    top or press *Command* + *R* to run the application. A window should be shown
    with **Welcome to Swift** and **Press Me**. At this stage, pressing the button
    will have no effect, which will be fixed in the next section.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要在模拟器中查看故事板，请点击顶部的 **播放** 按钮，或按 *Command* + *R* 来运行应用程序。应该会显示一个包含 **欢迎使用 Swift**
    和 **按我** 的窗口。在此阶段，按按钮将没有效果，这将在下一节中修复。
- en: Segues
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转场
- en: A *segue* is a transition to a different scene in a storyboard. Segues can be
    hooked up to views on the screen or can be triggered via code. The most common
    transitions are when the user has selected a view in the user interface, such
    as a button, a table row, or a details icon, and a new scene is displayed.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*转场* 是在故事板中转到不同场景的过渡。转场可以连接到屏幕上的视图，也可以通过代码触发。最常见的过渡是当用户在用户界面中选择了视图，例如按钮、表格行或详情图标时，会显示新的场景。'
- en: 'To demonstrate a segue, a new scene is required. Drag a **View Controller**
    from the object library and drop it onto the storyboard. The exact location of
    the view controller doesn''t matter, but conventionally, scenes are organized
    from left to right in the order in which they will be viewed, so dropping it on
    the right-hand side of the existing view controller is recommended, as shown in
    the following screenshot:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示过渡，需要一个新场景。从对象库中拖动一个**View Controller**并将其拖放到故事板中。视图控制器的确切位置无关紧要，但传统上，场景按照它们将被查看的顺序从左到右组织，因此建议将其拖放到现有视图控制器的右侧，如下面的截图所示：
- en: '![Segues](img/00042.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![过渡](img/00042.jpeg)'
- en: Once the **View Controller** has been added, drop a label onto the top-left
    and change the text to **Please do not press this button again**. This will present
    a visual clue that the screen has changed when the segue is followed.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加了**View Controller**，将标签拖到左上角并将文本更改为**请不要再按此按钮**。这将提供一个视觉线索，表明当跟随过渡时屏幕已更改。
- en: Now, select the **Press Me** button and press the *Control* key while dragging
    the mouse to the newly created view controller. When the mouse button is released,
    a pop-up menu will be shown with a number of options that are grouped into **Action
    Segue** and **Non-Adaptive Action Segue**. The former is preferred; the latter
    is only there for backward compatibility and might be removed in the future.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，选择**Press Me**按钮，在拖动鼠标的同时按住**Control**键到新创建的视图控制器。当鼠标按钮释放时，将显示一个弹出菜单，其中包含多个选项，这些选项被分组为**动作过渡**和**非自适应动作过渡**。前者是首选的；后者仅用于向后兼容，未来可能会被移除。
- en: '![Segues](img/00043.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![过渡](img/00043.jpeg)'
- en: Tip
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Alternatively, the object can be selected from the *document outline* on the
    left, and dragged to the object below in the document outline. It is possible
    to drag from the view in the editor area to an object in the document outline
    and vice versa. Dragging to the document outline is sometimes faster and more
    accurate, especially when there are multiple scenes in a storyboard. The document
    outline can be displayed by navigating to **Editor** | **Show Document Outline**,
    if it is not visible, or by clicking on the icon at the bottom-left of the editor.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以从左侧的*文档大纲*中选择该对象，并将其拖到文档大纲下的对象。可以从编辑器区域中的视图拖动到文档大纲中的对象，反之亦然。将拖动到文档大纲有时更快、更准确，尤其是在故事板中有多个场景时。可以通过导航到**编辑器**
    | **显示文档大纲**来显示文档大纲，如果它不可见，或者通过点击编辑器左下角的图标。
- en: Choose the **Show** option and a segue will be created between the two views.
    This is represented as an arrow connecting them and another object in the document
    outline. The icon inside the circular-segue line shows what kind of transition
    will occur; a **push** will have an arrow pointing to the left, while **present
    modally** will be represented as a square box. The **popover** type will show
    a small popover icon in the segue.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**显示**选项，将在两个视图之间创建一个过渡。这表示为连接它们的箭头和文档大纲中的另一个对象。圆形过渡线内的图标显示了将发生的过渡类型；**推送**将有一个指向左边的箭头，而**模态显示**将表示为一个方形框。**弹出**类型将在过渡中显示一个小弹出图标。
- en: '![Segues](img/00044.jpeg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![过渡](img/00044.jpeg)'
- en: Run the application in the simulator and click the **Press Me** button. A window
    should slide up and display the second message.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟器中运行应用程序并点击**Press Me**按钮。应该会弹出一个窗口并显示第二条消息。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There will be no way to dismiss or exit the second screen. This is intentional
    and will be fixed in the next section.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 将无法关闭或退出第二个屏幕。这是故意的，将在下一节中修复。
- en: Adding a navigation controller
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加导航控制器
- en: When there are multiple screens to be displayed, a parent controller is required
    to keep track of which screen is currently being shown and what the next step
    (or previous step) is. This is the purpose of a *navigation controller*; although
    it has no direct visual representation, it is represented as a scene in a storyboard
    and can affect the layout of the individual elements in the storyboard.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当有多个屏幕需要显示时，需要一个父控制器来跟踪当前显示哪个屏幕以及下一步（或上一步）是什么。这就是*导航控制器*的目的；尽管它没有直接的可视表示，但在故事板中它被表示为一个场景，并且可以影响故事板中各个元素的位置布局。
- en: 'To embed the initial scene into a navigation controller, select the initial
    view and navigate to **Editor** | **Embed In** | **Navigation Controller**. This
    will create a new navigation controller view and place it to the left-hand side
    of the first scene. It will also change the initial view controller to the navigation
    controller and set up a *relationship segue* with the name **root view controller**
    between the navigation controller and the first scene that is represented by an
    icon that is similar to a percent symbol but with the line rotated the other way:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要将初始场景嵌入到导航控制器中，选择初始视图，然后转到**编辑器** | **嵌入** | **导航控制器**。这将创建一个新的导航控制器视图并将其放置在第一个场景的左侧。它还将初始视图控制器更改为导航控制器，并在导航控制器和第一个场景（由一个类似百分符号的图标表示，但线条方向相反）之间设置名为**root
    view controller**的*关系转换*：
- en: '![Adding a navigation controller](img/00045.jpeg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![添加导航控制器](img/00045.jpeg)'
- en: It will be necessary to move the label and button below the newly added navigation
    bar so that they are still visible. This can either be done before the navigation
    controller is introduced or by selecting through overlapping objects.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有必要将标签和按钮移动到新添加的导航栏下方，以便它们仍然可见。这可以在引入导航控制器之前完成，或者通过选择重叠的对象来完成。
- en: To temporarily hide the navigation bar, delete the relationship segue between
    the navigation controller and the welcome scene, and the navigation bar will disappear.
    This will allow the objects to be selected and moved elsewhere temporarily in
    order to be repositioned. To add it back again, press the *Control* key and drag
    the mouse cursor from the navigation controller to the welcome scene and choose
    **root view controller** under **Relationship Segue**; or alternatively, set the
    **Top Bar** attribute to **None** in the attribute inspector.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要暂时隐藏导航栏，删除导航控制器和欢迎场景之间的关系转换，导航栏将消失。这将允许暂时选择并移动对象到其他地方，以便重新定位。要再次添加它，按住*Control*键并将鼠标光标从导航控制器拖动到欢迎场景，并在**关系转换**下选择**root
    view controller**；或者，在属性检查器中将**顶栏**属性设置为**无**。
- en: Alternatively, to select through overlapping objects, first select the object
    in the document outline so that the location is shown with the drag boxes. Then,
    press the *Shift* key and right-click it for a pop-up menu of the objects under
    the mouse position at any depth. From here, the object can be selected and then
    moved with the arrow keys to reposition them elsewhere.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，要选择重叠的对象，首先在文档大纲中选择对象，以便显示拖动框的位置。然后，按住*Shift*键并右键单击它，以在任何深度显示鼠标位置下的对象弹出菜单。从这里，可以选择对象，然后使用箭头键将其移动到其他位置。
- en: '![Adding a navigation controller](img/00046.jpeg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![添加导航控制器](img/00046.jpeg)'
- en: 'Now when the application is run and the **Press Me** button is tapped, the
    message will be shown again but with a **< Back** navigation menu item as well,
    as shown here:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当应用程序运行并点击**Press Me**按钮时，消息将再次显示，但还会显示一个**< 返回**导航菜单项，如下所示：
- en: '![Adding a navigation controller](img/00047.jpeg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![添加导航控制器](img/00047.jpeg)'
- en: Naming scenes and views
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名场景和视图
- en: When working with many scenes, calling all of them **View Controller Scene**
    is not helpful. To distinguish between them, the controllers can be renamed in
    the storyboard editor.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理许多场景时，将它们全部称为**视图控制器场景**没有帮助。为了区分它们，可以在故事板编辑器中重命名控制器。
- en: 'To change the name of a scene, select its view controller in the document outline
    and go to **View** | **Utilities** | **Show Attributes Inspector** or press *Command*
    + *Option* + *3*, and then drill down to the **Document** section where the label
    hint will read **Document Label**. Typing in another value, such as `Press` `Me`,
    `Message`, or `Initial` will rename both the view controller and the scene in
    the document outline:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改场景的名称，请在文档大纲中选择其视图控制器，然后转到**视图** | **实用工具** | **显示属性检查器**，或者按*Command* +
    *Option* + *3*，然后钻到**文档**部分，其中标签提示将显示为**文档标签**。输入另一个值，例如`Press` `Me`，`Message`或`Initial`，将重命名文档大纲中的视图控制器和场景：
- en: '![Naming scenes and views](img/00048.jpeg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![命名场景和视图](img/00048.jpeg)'
- en: Tip
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: By default, the name of the element in the document outline is taken from the
    text value of the element or the type if no text value is present. This means
    that updates to the label or button text will be automatically reflected in the
    outline. However, it is possible to add document labels to any view in the document
    outline.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，文档大纲中元素的名称取自元素的文本值或如果没有文本值则取类型。这意味着标签或按钮文本的更新将自动反映在大纲中。然而，可以在文档大纲中的任何视图中添加文档标签。
- en: Swift and storyboards
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swift和故事板
- en: So far in this chapter, the storyboard content does not involve any Swift or
    other programming content—it used the drag and drop capabilities of the storyboard
    editor. Fortunately, it is easy to integrate Storyboard and Swift using a *custom
    view controller*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章中的故事板内容不涉及任何Swift或其他编程内容——它使用了故事板编辑器的拖放功能。幸运的是，使用自定义视图控制器（*custom view
    controller*）集成Storyboard和Swift非常容易。
- en: Custom view controllers
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义视图控制器
- en: 'Each standard view controller has a corresponding superclass (listed in the
    *Scenes and view controllers* section previously in this chapter). This can be
    replaced with a custom subclass, which then has the ability to influence and change
    what happens in the user interface. To replace the message in the **Message Scene**,
    create a new file named `MessageViewCotroller.swift` with the following content:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 每个标准视图控制器都有一个相应的超类（在本章之前提到的*场景和视图控制器*部分中列出）。这可以被替换为自定义子类，然后它就有能力影响和改变用户界面中发生的事情。要替换**Message
    Scene**中的消息，创建一个名为`MessageViewCotroller.swift`的新文件，并包含以下内容：
- en: '[PRE0]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Having created this class, it can be associated with the view controller by
    selecting it in the storyboard and then switching to the identity inspector by
    navigating to **View** | **Utilities** | **Show Identity Inspector** or pressing
    *Command* + *Option* + *3*. In the **Custom Class** section, the **Class** will
    show `UIViewController` as a hint. Entering `MessageViewController` here will
    associate the custom controller with the view controller:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了这个类之后，可以通过在故事板中选择它，然后通过导航到**View** | **Utilities** | **Show Identity Inspector**或按*Command*
    + *Option* + *3*来切换到身份检查器来将其与视图控制器关联。在**Custom Class**部分，**Class**将显示`UIViewController`作为提示。在这里输入`MessageViewController`将自定义控制器与视图控制器关联：
- en: '![Custom view controllers](img/00049.jpeg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![自定义视图控制器](img/00049.jpeg)'
- en: 'This will have no visible impact to the message scene; running the application
    will be the same as before. To show a difference, create a `viewDidLoad` method
    with an `override` keyword and then create a random color for the background as
    follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这将对消息场景没有明显的影响；运行应用程序将与之前相同。要显示差异，创建一个带有`override`关键字的`viewDidLoad`方法，然后创建一个随机的背景颜色，如下所示：
- en: '[PRE1]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Running the application and pressing the **Press Me** button results in a differently
    colored view being created each time.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并按下**Press Me**按钮会导致每次创建不同颜色的视图。
- en: Tip
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: This does not demonstrate good user experience, but is used here to demonstrate
    the fact that `viewDidLoad` is called each time the segue occurs. It is typically
    used to set up view state just before showing the view to the user.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不展示良好的用户体验，但在这里使用它来展示每次发生转场时都会调用`viewDidLoad`的事实。它通常用于在向用户显示视图之前设置视图状态。
- en: Connecting views to outlets in Swift
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Swift中将视图连接到出口
- en: Each view controller has an implicit relationship with its view, and each view
    has its own `backgroundColor` property. This example will work regardless of what
    the view happens to be. What if the view controller needs to interact with the
    view's content in some way? The view controller could walk the view programmatically,
    looking for a certain type of view or for a view with a particular identifier,
    but there is a better way to do this.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 每个视图控制器都有一个与其视图的隐式关系，每个视图都有自己的`backgroundColor`属性。这个例子将适用于任何视图。如果视图控制器需要以某种方式与视图的内容交互呢？视图控制器可以程序性地遍历视图，寻找特定类型的视图或具有特定标识符的视图，但有一种更好的方法来做这件事。
- en: Both the interface builder and storyboard have the concept of *outlets*, which
    are a predefined point in a class that can be exposed and can have connections
    between the UI and the code. In Objective-C, this was done with an `IBOutlet`
    qualifier. In Swift, this is done with a `@IBOutlet` attribute. In effect, they
    are variables that can be bound to the UI.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接口构建器和故事板都有*出口（outlets）*的概念，它们是在类中的一个预定义点，可以公开并可以在UI和代码之间建立连接。在Objective-C中，这是通过`IBOutlet`限定符来实现的。在Swift中，这是通过`@IBOutlet`属性来实现的。实际上，它们是可以绑定到UI的变量。
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When defining a class with a `@IBOutlet` attribute, the `@objc` attribute is
    also implicitly added marking this Swift class as using the Objective-C runtime.
    As all the `UIKit` classes are already Objective-C types, this doesn't matter;
    but for types where the Objective-C runtime should not be used, care should be
    taken when adding attributes, such as `@IBOutlet`. The `@objc` attribute can also
    be used for non-UI classes that need to use the Objective-C runtime.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当定义一个具有`@IBOutlet`属性的类时，`@objc`属性也会隐式添加，标记这个Swift类使用Objective-C运行时。由于所有`UIKit`类已经是Objective-C类型，这并不重要；但对于不应该使用Objective-C运行时的类型，在添加属性时，如`@IBOutlet`，应小心谨慎。`@objc`属性也可以用于需要使用Objective-C运行时的非UI类。
- en: 'The following steps are required to create an outlet in a Swift view controller:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 创建Swift视图控制器中的输出需要以下步骤：
- en: Define an outlet in the view controller code with `@IBOutlet` `weak` `var` of
    an optional type of the connected view.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在视图控制器代码中使用`@IBOutlet` `weak` `var`定义一个可选类型的输出。
- en: Connect the outlet in the view controller to the view by pressing *Control*
    and dragging the mouse cursorfrom the view to the outlet.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按*Control*并从视图拖动鼠标光标到输出，将视图控制器中的输出连接到视图。
- en: To do this, open the **assistant editor** by pressing *Command* + *Option* +
    *Enter* or by going to **View** | **Assistant Editor** | **Show Assistant Editor**.
    This will show a side-by-side view of the associated source file. This is useful
    to display the associated custom view controller for a selected view in the storyboard
    (or the interface file).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，请按*Command* + *Option* + *Enter*或转到**视图** | **辅助编辑器** | **显示辅助编辑器**来打开**辅助编辑器**。这将显示关联源文件的并排视图。这对于显示故事板中选定的视图的关联自定义视图控制器非常有用（或接口文件）。
- en: 'Once the assistant editor is displayed, open the **Message Scene** from the
    storyboard and press *Control* while dragging the mouse cursorfrom the message
    label to the assistant editor and dropping it just after the class declaration:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦显示辅助编辑器，从故事板中打开**消息场景**，按*Control*并从消息标签拖动鼠标光标到辅助编辑器，并在类声明后释放鼠标。
- en: '![Connecting views to outlets in Swift](img/00050.jpeg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![在Swift中将视图连接到输出](img/00050.jpeg)'
- en: 'A pop-up dialog will ask what to call the field and present some other information;
    ensure **Outlet** is selected, name it `message`, and ensure that it has a **Weak**
    storage type:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一个弹出对话框将询问如何命名字段并显示一些其他信息；确保选择**输出**，命名为`message`，并确保它具有**弱**存储类型：
- en: '![Connecting views to outlets in Swift](img/00051.jpeg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![在Swift中将视图连接到输出](img/00051.jpeg)'
- en: 'This will result in the following line being added to the `MessageViewController`
    class, and it will wire up the label to the property as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`MessageViewController`类中添加以下行，并将标签连接到属性如下：
- en: '[PRE2]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `@IBOutlet` attribute (defined in `UIKit`) allows interface builder to bind
    to the property. The **Weak** storage type—which can be changed in the pop-up
    dialog—indicates that this class will not hold a strong reference to the object
    so that when the view is dismissed, the controller will not own it.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`@IBOutlet`属性（在`UIKit`中定义）允许界面构建器绑定到属性。**弱**存储类型——可以在弹出对话框中更改——表示此类不会持有对象的强引用，因此当视图被关闭时，控制器不会拥有它。'
- en: Tip
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Generally, all `@IBOutlet` connections should be marked as `weak`, because the
    storyboard or the `xib` file is the owner of the object, not the controller. Ownership
    does not pass when assigning properties from interface builder. Changing it to
    something other than `weak` may lead to circular references. As Swift uses a reference
    counting approach to determine when an object is no longer referenced, a circular
    reference between strong references can cause memory leaks.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，所有`@IBOutlet`连接都应标记为`weak`，因为故事板或`xib`文件是对象的拥有者，而不是控制器。从界面构建器分配属性时，所有权不会传递。将其更改为其他类型可能导致循环引用。由于Swift使用引用计数方法来确定对象何时不再被引用，强引用之间的循环引用可能导致内存泄漏。
- en: The exclamation mark on the end of the type `UILabel!` indicates that it is
    an *implicitly unwrapped optional*. This property is stored as an optional type,
    but the accessor code will automatically unwrap it at the point of use. As the
    view controller will not have a reference to the `message` at the point of initialization,
    it will be `nil`, so it must be stored as an optional. However, as the value is
    known to not be `nil` after the view has been loaded, the implicitly unwrapped
    optional saves the `?.` calls that would otherwise be used each time it is used.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 类型 `UILabel!` 末尾的感叹号表示它是一个**隐式展开的可选类型**。这个属性以可选类型存储，但在使用时访问器代码会自动展开它。由于视图控制器在初始化时不会有对
    `message` 的引用，它将是 `nil`，因此必须存储为可选类型。然而，由于在视图加载后知道值不是 `nil`，隐式展开的可选类型节省了每次使用时都会使用的
    `?.` 调用。
- en: Note
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An implicitly unwrapped optional is still an optional value under the covers;
    it is syntactic sugar to unwrap it at the point of use each time the value is
    accessed. When the view is loaded, but before the `viewDidLoad` method is called,
    the outlet's value will be wired to the instantiated view on screen.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式展开的可选类型在底层仍然是一个可选值；每次访问值时在使用的点展开它是语法糖。当视图加载时，但在调用 `viewDidLoad` 方法之前，出口的值将被连接到屏幕上的实例化视图。
- en: The connections can be seen in the connections inspector, which can be displayed
    by selecting the message label and pressing *Command* + *Option* + *6* or by navigating
    to **View** | **Utilities** | **Show Connections Inspector**. The inspector can
    also be used to remove existing connections or add new ones.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这些连接可以在连接检查器中看到，可以通过选择消息标签并按 *Command* + *Option* + *6* 或通过导航到 **视图** | **实用工具**
    | **显示连接检查器** 来显示检查器。检查器还可以用来删除现有连接或添加新的连接。
- en: '![Connecting views to outlets in Swift](img/00052.jpeg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![在 Swift 中将视图连接到出口](img/00052.jpeg)'
- en: 'Now that the connection has been made between the message view and the custom
    controller, instead of changing the background color of the view, change the background
    color of the `message` instead, as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在消息视图和自定义控制器之间已经建立了连接，而不是更改视图的背景颜色，而是更改 `message` 的背景颜色，如下所示：
- en: '[PRE3]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Run the application and the message will have the background color changed
    each time the scene is displayed:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，每次场景显示时消息的背景颜色都会改变：
- en: '![Connecting views to outlets in Swift](img/00053.jpeg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![在 Swift 中将视图连接到出口](img/00053.jpeg)'
- en: Calling actions from interface builder
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从界面构建器调用动作
- en: In the same way that outlets are variables for interface builder to assign to
    (or read from), *actions* are methods/functions that can be triggered from a view
    in interface builder. The `@IBAction` attribute is used to annotate a method or
    function that can be wired up.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 与界面构建器中的出口变量一样，*动作*是可以从界面构建器中的视图触发的函数/方法。`@IBAction` 属性用于注释可以连接的方法或函数。
- en: Note
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As with `@IBOutlet`, using `@IBAction` on a function causes the compiler to
    implicitly add a `@objc` attribute to the class in order to force it to use the
    Objective-C runtime.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `@IBOutlet` 类似，在函数上使用 `@IBAction` 会导致编译器隐式地向类添加一个 `@objc` 属性，以强制它使用 Objective-C
    运行时。
- en: 'To change the message when a button is invoked, a suitable `changeMessage`
    is required. Historically, the signature for an action method was one that returned
    `void`, marked with `IBAction`, and took a `sender` argument, which could be any
    object. In Swift, this signature translates to the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要在按钮被调用时更改消息，需要一个合适的 `changeMessage`。从历史上看，动作方法的签名是一个返回 `void`、标记为 `IBAction`
    并接受 `sender` 参数的方法，该参数可以是任何对象。在 Swift 中，这个签名转换为以下形式：
- en: '[PRE4]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'However, with Swift, the `sender` is no longer a required argument. It is,
    therefore, possible to bind an action with the following signature:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 Swift 中，`sender` 已不再是必需的参数。因此，可以绑定以下签名的动作：
- en: '[PRE5]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If the signature is changed, any existing bindings must be deleted and recreated,
    as an error will be reported otherwise.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果更改签名，必须删除并重新创建任何现有绑定，否则将报告错误。
- en: Tip
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is difficult to convert from a `func` that doesn't take an argument to one
    that takes an argument. It is easier to have a `func` that takes an argument that
    isn't required. If not sure, choose the function signature that takes a sender
    object and then just ignore it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 将不带参数的 `func` 转换为带参数的 `func` 是困难的。有一个带参数但不必需的 `func` 更容易。如果不清楚，请选择接受发送者对象的函数签名，然后只需忽略它即可。
- en: 'The `changeMessage` function can randomly select a message and set the text
    on the label, as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`changeMessage`函数可以随机选择一条消息并设置标签上的文本，如下所示：'
- en: '[PRE6]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When the function is invoked, the message text will change to a value that
    is defined in the array. To call the function, it needs to be wired up in the
    storyboard editor. Add a new **Button** from the object library to the message
    scene, with a `Change Message` label. To connect it to the action, press *Control*
    and drag the mouse cursor from the **Change Message** button in **Message Scene**
    and drop it on the **Message** view controller at the top:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数被调用时，消息文本将更改为数组中定义的值。要调用该函数，需要在故事板编辑器中将其连接起来。从对象库中添加一个新的**按钮**到消息场景，并带有`Change
    Message`标签。要连接到操作，按*Control*并从**消息场景**中的**更改消息**按钮拖动鼠标光标，并将其放在顶部的**消息**视图控制器上：
- en: '![Calling actions from interface builder](img/00054.jpeg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![从界面构建器调用操作](img/00054.jpeg)'
- en: 'A pop-up menu will then display the outlets and actions that this can be connected
    to. Select the **changeMessage** from the list:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将显示一个弹出菜单，列出可以连接到的出口和操作。从列表中选择**changeMessage**：
- en: '![Calling actions from interface builder](img/00055.jpeg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![从界面构建器调用操作](img/00055.jpeg)'
- en: Tip
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If **changeMessage** isn't listed, check that the view controller is defined
    to be `MessageViewController` and verify that the `@IBAction` attribute is added
    to the `changeMessage` function.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果**changeMessage**没有列出，请检查视图控制器是否定义为`MessageViewController`，并验证是否已将`@IBAction`属性添加到`changeMessage`函数中。
- en: Now when the application is run and the **Change Message** button is pressed,
    the label will change to one of the hardcoded values.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当应用程序运行并按下**更改消息**按钮时，标签将更改为预定义的值之一。
- en: Note
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The message label will not change in size because the view has no automatic
    layout associated with it. The *Using Auto Layout* section in this chapter explains
    how to fix this problem.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 消息标签的大小不会改变，因为与之关联的视图没有自动布局。本章中“使用自动布局”部分解释了如何解决这个问题。
- en: Triggering a segue with code
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用代码触发segues
- en: A segue can be triggered programmatically from code if additional setup is required
    or if there are data parameters that need to be passed from one view controller
    to another (such as the currently-selected object).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要额外的设置或需要从一个视图控制器传递数据参数到另一个视图控制器（例如当前选定的对象），可以使用代码来触发segues。
- en: 'Segues have named *segue identifiers*, which are used in code to trigger specific
    segues. To test this out, drag a new **View Controller** from the library (by
    pressing *Command* + *Option* + *Control* + *3* or by navigating to **View** |
    **Utilities** | **Show Object Library**) onto the main storyboard and name it
    `About`. Drag a **Label** and give it the text: `About` `this` `App`.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Segues有命名的**segue标识符**，在代码中用于触发特定的segues。为了测试这一点，从库中拖动一个新的**视图控制器**（通过按*Command*
    + *Option* + *Control* + *3*或通过导航到**视图** | **实用工具** | **显示对象库**）到主故事板，并将其命名为`About`。拖动一个**标签**并给它输入文本：`About`
    `this` `App`。
- en: 'Next, create a segue by pressing *Control* and dragging the mouse cursor between
    the **Message** scene to the new scene. The named identifier can be set as `about`
    through the attributes inspector (shown by pressing *Command* + *Option* + *4*
    or by navigating to **View** | **Utilities** | **Show Attributes Inspector**):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过按*Control*并拖动鼠标光标在**消息**场景和新的场景之间创建一个segues。可以通过属性检查器设置命名标识符为`about`（通过按*Command*
    + *Option* + *4*或通过导航到**视图** | **实用工具** | **显示属性检查器**）：
- en: '![Triggering a segue with code](img/00056.jpeg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![使用代码触发segues](img/00056.jpeg)'
- en: 'Finally, drag a new **Button** to the **Change Message** scene and call it
    `About`. Instead of directly calling the segue, create a new `@IBAction` called
    `about`. When this button is pressed, the following code will be run:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将一个新的**按钮**拖到**更改消息**场景，并命名为`About`。而不是直接调用segues，创建一个新的`@IBAction`名为`about`。当这个按钮被按下时，将运行以下代码：
- en: '[PRE7]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When the **About** button is pressed, the **About** screen will be displayed.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当按下**关于**按钮时，将显示**关于**屏幕。
- en: Passing data with segues
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过segues传递数据
- en: Typically, in a master-detail application, data needs to be passed from one
    scene to the next. This may be the currently selected object, or it may require
    additional information to be processed. When the segue is called, the view controller's
    `prepareForSegue` method is called, with the destination segue and the sending
    object. This allows any internal state of the view controller to be passed to
    the new segue.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在主从应用程序中，需要将数据从一个场景传递到下一个场景。这可能是指当前选定的对象，或者可能需要传递额外的信息以进行处理。当调用 `segue` 时，会调用视图控制器的
    `prepareForSegue` 方法，并带有目的地 `segue` 和发送对象。这允许将视图控制器任何内部状态传递给新的 `segue`。
- en: 'The `UIStoryboardSegue` contains an identifier, which was set in the previous
    section. As the `prepareForSegue` method may be called on the `MessageViewController`
    for any number of segues, it is common for a `switch` statement to be used on
    the identifier so that the right action can be taken. For a single segue, an `if`
    statement can be used as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIStoryboardSegue` 包含一个标识符，该标识符在上一节中已设置。由于 `prepareForSegue` 方法可能对 `MessageViewController`
    的任意数量的 `segue` 进行调用，因此通常会在标识符上使用 `switch` 语句，以便采取正确的操作。对于单个 `segue`，可以使用以下 `if`
    语句：'
- en: '[PRE8]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, the `prepareForSegue` method is called with `segue`, which contains the
    destination (the scene) and the identifier. The `if` statement ensures that the
    correct identifier is matched. In this case, the background color of the message
    label (which is chosen randomly when the view is loaded) is passed to the destination
    view's background color; however, any property on either the view controller or
    the view can be set here.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，使用 `segue` 调用 `prepareForSegue` 方法，其中包含目的地（场景）和标识符。`if` 语句确保匹配正确的标识符。在这种情况下，消息标签的背景颜色（在视图加载时随机选择）被传递到目的地视图的背景颜色；然而，可以在这里设置视图控制器或视图上的任何属性。
- en: Using Auto Layout
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自动布局
- en: '**Auto Layout** has been part of Xcode for the last few releases, and it was
    added to support an evolution from the previous springs-and-struts approach that
    predated Mac OS X. First released on iOS 6.0, it has evolved to the point where
    size-independent displays can now be created as the default.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动布局（Auto Layout**）已经成为了 Xcode 的几个版本的一部分，并且它的加入是为了支持从之前预 dating Mac OS X
    的弹簧和支柱方法向其演变。首次在 iOS 6.0 中发布，它已经发展到可以创建默认的无尺寸依赖的显示。'
- en: Understanding constraints
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解约束
- en: In Xcode 5, interface builder enabled Auto Layout by default for the first time.
    When a label was dragged to the top or bottom of the parent view, a dotted blue
    line would indicate that the label was correctly spaced, and a *constraint* would
    be generated.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xcode 5 中，界面构建器首次默认启用自动布局。当将标签拖动到父视图的顶部或底部时，一条虚线蓝色的线会指示标签被正确地间隔，并且会生成一个 *约束*。
- en: However, in many cases, the constraints weren't created correctly or had undesired
    effects. For example, positioning a button in the center at the top may not maintain
    the location depending on whether the constraint being added was absolute (200px
    from the right) or relative (in the center of the screen). In both cases, the
    button may look like it was positioned correctly, only to fail when the device's
    screen orientation rotates or it is run on a screen of different size.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在许多情况下，约束没有被正确创建或者产生了不期望的效果。例如，将按钮放置在顶部中央的位置可能不会保持位置，这取决于添加的约束是绝对位置（距离右侧
    200 像素）还是相对位置（屏幕中央）。在这两种情况下，按钮可能看起来被正确地定位，但设备屏幕方向旋转或在不同尺寸的屏幕上运行时可能会失败。
- en: In Xcode 6, although the guidelines are still displayed as views are moved around,
    relative constraints are not created. Instead, each view is given an exact hardcoded
    position that does not change with screen rotation or with a change of display
    size.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xcode 6 中，尽管指南在视图移动时仍然以视图的形式显示，但不会创建相对约束。相反，每个视图都被赋予了一个确切的硬编码位置，这个位置不会随着屏幕旋转或显示尺寸的改变而改变。
- en: In Xcode 7, Auto Layout is the preferred way of creating applications, and views
    are implicitly selected for Auto Layout. In addition, separate user interfaces
    can be created for different *size classes*, which allows applications such as
    Calculator and Mail to provide different user interfaces that are based on the
    device's rotation. On larger screen devices that have the ability to dock applications
    next to each other, the size classes are used to determine how each application
    looks and behaves.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xcode 7中，自动布局是创建应用的推荐方式，视图会隐式选择自动布局。此外，可以为不同的*大小类别*创建单独的用户界面，这使得像计算器和邮件这样的应用能够根据设备的旋转提供不同的用户界面。在具有将应用并排停靠能力的大屏幕设备上，大小类别用于确定每个应用的外观和行为。
- en: Constraints must be added manually to the views in order to restore the right
    behavior, and as manual constraints are added, absolute constraints are removed.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了恢复正确的行为，必须手动将约束添加到视图中，并且随着手动约束的添加，绝对约束将被移除。
- en: Adding constraints
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加约束
- en: In the example application, the **Welcome to Swift** label and the **Press Me**
    button are next to each other, a small distance from the top. However, when the
    screen is rotated in the simulator, by pressing *Command* and the left or right
    arrow keys, the spacing between the labels and the top doesn't change, so the
    labels look further away.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例应用中，“欢迎使用Swift”标签和“按我”按钮相邻，距离顶部一小段距离。然而，当在模拟器中旋转屏幕时，通过按下*命令*键和左右箭头键，标签与顶部之间的间距不会改变，因此标签看起来更远。
- en: The desired outcome is that the label remains a standard distance away from
    the top-left edge and the button remains aligned to the label's baseline.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 所期望的结果是标签与左上角保持标准距离，按钮与标签的基线对齐。
- en: 'There are two separate constraints that need to be applied to the label:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 需要对标签应用两个独立的约束：
- en: Be a standard vertical distance away from the top of the parent view
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与父视图的顶部保持标准垂直距离
- en: Be a standard horizontal distance away from the left of the parent view
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与父视图的左侧保持标准水平距离
- en: 'There are also two constraints that need to be applied to the button:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 需要对按钮应用以下两个约束：
- en: Be aligned with the label's baseline
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与标签的基线对齐
- en: Be a standard vertical distance away from the label
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与标签保持标准垂直距离
- en: There are different ways of adding a constraint, which are covered in the following
    sections.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 添加约束有不同的方法，以下章节将进行介绍。
- en: Adding a constraint with drag and drop
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用拖放添加约束
- en: 'A quick way to add a constraint is to press *Control* and drag the mouse cursor
    from the view to the top of the container. Depending on the direction of the drag,
    different options will be displayed. Dragging vertically upwards presents the
    vertical alignment options:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 添加约束的一个快捷方法是按下*控制*键并从视图拖动鼠标光标到容器的顶部。根据拖动的方向，将显示不同的选项。垂直向上拖动将显示垂直对齐选项：
- en: '![Adding a constraint with drag and drop](img/00057.jpeg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![使用拖放添加约束](img/00057.jpeg)'
- en: The **Vertical Spacing to Top Layout Guide** option will insert a recommended
    break between the navigation bar and the label. There is a **Center Horizontally
    in Container** option, which is also a vertical separation but not appropriate
    in this case.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**垂直间距到顶部布局指南**选项将在导航栏和标签之间插入一个推荐的间隔。还有一个**在容器中水平居中**选项，这也是一种垂直分隔，但在此情况下不适用。'
- en: The other types that are active—**Equal Widths**, **Equal Heights**, and **Aspect
    Ratio**—allow multiple views to be sized relative to each other.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 其他激活的类型——**等宽**、**等高**和**宽高比**——允许多个视图相对于彼此进行尺寸调整。
- en: 'Dragging horizontally will show a different set of options at the top, including
    **Leading Space to Container Margin** and **Center Vertically in Container**:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 水平拖动将显示顶部的一组不同选项，包括**到容器边距的领先空间**和**在容器中垂直居中**：
- en: '![Adding a constraint with drag and drop](img/00058.jpeg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![使用拖放添加约束](img/00058.jpeg)'
- en: 'If the mouse is dragged at an angle, both sets of options will be displayed,
    as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果鼠标以一定角度拖动，将显示两组选项，如下所示：
- en: '![Adding a constraint with drag and drop](img/00059.jpeg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![使用拖放添加约束](img/00059.jpeg)'
- en: Adding constraints to the Press Me scene
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向“按我”场景添加约束
- en: 'To set the constraints for the welcome label, press *Control* and drag the
    mouse cursor from the label to the left, and select **Leading Space to Container
    Margin**. An orange line will appear, and an orange outline will be displayed:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置欢迎标签的约束，请按*Control*键并从标签拖动鼠标光标到左侧，并选择**到容器边距的领先空间**。将出现一条橙色线，并显示一个橙色轮廓：
- en: '![Adding constraints to the Press Me scene](img/00060.jpeg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![向“按我”场景添加约束](img/00060.jpeg)'
- en: Note
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The orange line indicates an *ambiguous constraint*, which means that some constraints
    have been added to the view but are not enough to uniquely position the label.
    In this case, the label is positioned from the left of the container, but it could
    be anywhere with respect to the top or bottom of the screen. The red dotted lines
    show where the Auto Layout algorithm will place the view with the constraints
    that are currently specified.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 橙色线表示一个**模糊的约束**，这意味着已经向视图添加了一些约束，但不足以唯一地定位标签。在这种情况下，标签从容器的左侧定位，但它相对于屏幕的顶部或底部可以是任何位置。红色虚线显示了自动布局算法将放置具有当前指定约束的视图的位置。
- en: 'To resolve this problem, press *Control* and drag the mouse pointer from the
    label to the top and select **Vertical Spacing to Top Layout Guide**. Once this
    is done, two constraints will be displayed in blue, which represent the constraints
    about the object:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，请按*Control*键并将鼠标指针从标签拖动到顶部并选择**到顶部布局指南的垂直间距**。完成此操作后，将显示两个蓝色的约束，代表关于对象的约束：
- en: '![Adding constraints to the Press Me scene](img/00061.jpeg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![向“按我”场景添加约束](img/00061.jpeg)'
- en: Tip
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If there is an orange box surrounding the label along with a warning that says
    **Frame for label will be different at run-time**, this can be fixed with the
    **Update Frames** option that is discussed in the next section.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果标签周围有一个橙色框，并显示警告信息**在运行时标签的框架将不同**，这可以通过下一节中讨论的**更新框架**选项来修复。
- en: 'The constraints can also be seen in the document outline on the left-hand side:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 约束也可以在左侧的文档大纲中看到：
- en: '![Adding constraints to the Press Me scene](img/00062.jpeg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![向“按我”场景添加约束](img/00062.jpeg)'
- en: 'If the application is run now and rotated, the label is correctly repositioned,
    but the button is not:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在运行应用程序并旋转，标签将正确重新定位，但按钮不会：
- en: '![Adding constraints to the Press Me scene](img/00063.jpeg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![向“按我”场景添加约束](img/00063.jpeg)'
- en: Adding missing constraints
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加缺失的约束
- en: 'To find out which views have no constraints, click through the views one by
    one in the document outline and check the size inspector (which can be seen by
    pressing *Command* + *Option* + *5* or by navigating to **View** | **Utilities**
    | **Show Size Inspector**). For views that have constraints set, there will be
    content shown under the **Constraints** section:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出哪些视图没有约束，请逐个在文档大纲中点击视图，并检查大小检查器（可以通过按*Command* + *Option* + *5*或导航到**视图**
    | **实用工具** | **显示大小检查器**来查看）。对于已设置约束的视图，将在**约束**部分下显示内容：
- en: '![Adding missing constraints](img/00064.jpeg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![添加缺失的约束](img/00064.jpeg)'
- en: If a view has no constraints associated with it, then this section will be empty.
    Interface builder has an option to create missing constraints for selected views,
    which can be accessed by navigating to **Editor** | **Resolve Auto Layout Issues**
    | **Add Missing Constraints** or from the **Resolve Auto Layout Issues** menu
    at the bottom-right, which looks like a triangle between two vertical lines.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个视图没有与之关联的约束，那么本节将是空的。界面构建器有一个选项可以为选定的视图创建缺失的约束，可以通过导航到**编辑器** | **解决自动布局问题**
    | **添加缺失的约束**或从底部的**解决自动布局问题**菜单（看起来像两条垂直线之间的三角形）来访问。
- en: 'When selected, the options in the top-half apply to selected views only, while
    the options in the bottom-half work on all the views in the selected view controller:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当选中时，上半部分的选项仅适用于选定的视图，而下半部分的选项作用于选定视图控制器中的所有视图：
- en: '![Adding missing constraints](img/00065.jpeg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![添加缺失的约束](img/00065.jpeg)'
- en: 'The options include:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 选项包括：
- en: '**Update Frames**: This is based on the current constraints; it automatically
    repositions and resizes the views to correspond to what will happen at runtime'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更新框架**：这是基于当前约束；它自动重新定位和调整视图的大小，以对应运行时的情况'
- en: '**Update Constraints**: This is based on the current positions of the objects
    and attempts to recalculate the existing constraints (but not create new ones)'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更新约束**：这是基于对象的当前位置，并尝试重新计算现有的约束（但不创建新的约束）'
- en: '**Add Missing Constraints**: This is based on the approximate positioning of
    the components and adds constraints that creates the same result'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加缺失约束**：这是基于组件的大致位置，添加创建相同结果的约束'
- en: '**Reset to Suggested Constraints**: This is equivalent to clearing all the
    constraints associated with the views and then reading missing constraints'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重置为建议的约束**：这相当于清除与视图相关联的所有约束，然后读取缺失的约束'
- en: '**Clear Constraints**: This removes all the constraints associated with the
    views'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清除约束**：这会移除与视图相关联的所有约束'
- en: 'To add constraints to the **Press Me** button, click on the view and then navigate
    to **Editor** | **Resolve Auto Layout Issues** | **Selected Views** | **Add Missing
    Constraints**. There should be two constraints added: a baseline alignment with
    the label, and a horizontal space to the label.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要向**Press Me**按钮添加约束，请点击视图，然后导航到**编辑器** | **解决自动布局问题** | **所选视图** | **添加缺失约束**。应该添加两个约束：与标签的基线对齐，以及到标签的水平间距。
- en: To see the effect of the **Update Frames** operation, move the label and the
    button to different places in the view controller. Orange lines and dotted outlines
    will be shown, indicating that there is an ambiguous constraint. Navigate to **Choose
    Editor** | **Resolve Auto Layout Issues** | **All Views in View Controller** |
    **Update Frames**, and the views will automatically move to the right places and
    resize.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看**更新框架**操作的效果，请将标签和按钮移动到视图控制器中的不同位置。将显示橙色线条和虚线轮廓，指示存在模糊的约束。导航到**选择编辑器** |
    **解决自动布局问题** | **视图控制器中的所有视图** | **更新框架**，视图将自动移动到正确的位置并调整大小。
- en: Note
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The views are sized to their *intrinsic size*, which is the size that just fits
    the content. For example, a label's intrinsic size is the size in which the text
    can fit into the space in the current font. This can be used to fix the size of
    the label in the **Message Scene**; by adding constraints, the changing text will
    result in the intrinsic size being recalculated, and the background color will
    be correctly sized.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 视图的大小设置为它们的**固有大小**，即刚好适合内容的大小。例如，标签的固有大小是文本可以适应当前字体空间的大小。这可以用来固定**消息场景**中标签的大小；通过添加约束，文本的变化将导致固有大小重新计算，背景色将正确调整大小。
- en: Now, run the application and rotate the device, by pressing *Command* and the
    left and right arrow keys to see the view resize itself correctly.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行应用程序并旋转设备，通过按**Command**键和左右箭头键来查看视图是否正确调整大小。
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced the concept of storyboards as a sequence of scenes that
    are connected with segues, which can either be wired with the GUI or driven programmatically.
    Finally, Auto Layout can be used to build applications that respond to differences
    in screen orientation or size, as well as respond to changes in view size or other
    properties.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了故事板的概念，它是一系列通过转场连接的场景，这些场景可以是与GUI有线连接，也可以是程序驱动。最后，可以使用自动布局来构建能够响应屏幕方向或大小变化的以及响应视图大小或其他属性变化的程序。
- en: The next chapter will present how to create custom views in Swift.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍如何在Swift中创建自定义视图。
