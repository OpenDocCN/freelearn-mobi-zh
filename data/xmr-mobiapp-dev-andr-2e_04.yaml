- en: Chapter 4. Adding a List View
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章：添加列表视图
- en: 'In this chapter, we finally get to what many of you have been waiting for,
    developing the user interface. We will walk you through the activities related
    to creating and populating a `ListView`, which includes the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们终于到达了很多人一直在等待的部分，即开发用户界面。我们将向您介绍创建和填充`ListView`的相关活动，包括以下主题：
- en: Creating the POIApp activity layout
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建POIApp活动布局
- en: Creating a custom list row item layout
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义列表行项布局
- en: The `ListView` and `ListAdapter` classes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ListView`和`ListAdapter`类'
- en: Extending `BaseAdapter` to provide data to the `ListView` widget
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`BaseAdapter`扩展以向`ListView`小部件提供数据
- en: Working with web services in Xamarin.Android
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Xamarin.Android中处理网络服务
- en: Working with the `ActionBar` menu options
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与`ActionBar`菜单选项一起工作
- en: Handling list item click events
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理列表项点击事件
- en: Handling the network state
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理网络状态
- en: Creating the POI ListView layout
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建POI ListView布局
- en: It is technically possible to create and attach the user interface elements
    to your activity using C# code. However, it is a bit of a mess. We will go with
    the most common approach by declaring the XML-based layout. Keeping this in mind,
    let's begin this chapter by creating a layout to display the POI list items.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，您可以使用C#代码创建并将用户界面元素附加到您的活动上。然而，这会有些混乱。我们将采用最常见的方法，通过声明基于XML的布局。考虑到这一点，让我们从创建一个用于显示POI列表项的布局开始这一章。
- en: When we created the new `POIApp` solution in the previous chapter (Chapter 3,
    *Creating the Points Of Interest App*), a default layout and activity was created
    as part of the Xamarin Studio project template.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在上一章（第3章，*创建兴趣点应用*）中创建新的`POIApp`解决方案时，作为Xamarin Studio项目模板的一部分，创建了一个默认布局和活动。
- en: 'Rather than deleting these files, let''s give them more appropriate names and
    remove unnecessary content as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是删除这些文件，让我们给它们更合适的名字并删除不必要的内客，如下所示：
- en: Select the `Main.axml` file in **Resources** | **Layout** and rename it to `POIList.axml`.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**资源** | **布局**中选择`Main.axml`文件并将其重命名为`POIList.axml`。
- en: Double-click on the `POIList.axml` file to open it in a layout designer window.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`POIList.axml`文件以在布局设计器窗口中打开它。
- en: Currently, the `POIList.axml` file contains the layout that was created as part
    of the default Xamarin Studio template. As per our requirement, we need to add
    a `ListView` widget that takes the complete screen width and a `ProgressBar` in
    the middle of the screen. The indeterminate progress bar will be displayed to
    the user while the data is being downloaded from the server. Once the download
    is complete and the data is ready, the indeterminate progress bar will be hidden
    before the POI data is rendered on the list view.
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 目前，`POIList.axml`文件包含的是作为默认Xamarin Studio模板的一部分创建的布局。根据我们的要求，我们需要添加一个占满整个屏幕宽度的`ListView`小部件和一个位于屏幕中间的`ProgressBar`。在从服务器下载数据时，将向用户显示不确定的进度条。一旦下载完成且数据准备就绪，不确定的进度条将在POI数据在列表视图中渲染之前被隐藏。
- en: Now, open the **Document Outline** tab in the designer window and delete both
    the button and `LinearLayout`.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在设计师窗口中打开**文档大纲**选项卡并删除按钮和`LinearLayout`。
- en: Now, in the designer **Toolbox**, search for `RelativeLayout` and drag it onto
    the designer layout preview window.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在设计师**工具箱**中搜索`RelativeLayout`并将其拖动到设计师布局预览窗口中。
- en: Search for `ListView` in the **Toolbox** search field and drag it over the layout
    designer preview window. Alternatively, you can drag and drop it over `RelativeLayout`
    in the **Document Outline** tab.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**工具箱**搜索框中搜索`ListView`并将其拖动到布局设计器预览窗口中。或者，您也可以将其拖放到**文档大纲**选项卡中的`RelativeLayout`上。
- en: 'We have just added a `ListView` widget to `POIList.axml`. Let''s now open the
    **Properties** pad view in the designer window and edit some of its attributes:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚将`ListView`小部件添加到了`POIList.axml`中。现在，在设计师窗口中打开**属性**面板视图并编辑一些属性：
- en: '![](img/mxWb8kcH.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/mxWb8kcH.jpg)'
- en: 'As we may recall from Chapter 3, *Creating the Points of Interest App*, the
    **Properties** pad allows you to modify the properties of a selected widget. There
    are five buttons at the top of the pad that switch the set of properties being
    edited. The **@+id** notation notifies the compiler that a new resource ID needs
    to be created to identify the widget in API calls, and `listView1` identifies
    the name of the constant. Now, perform the following steps:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们回忆第3章，*创建兴趣点应用*，**属性**面板允许您修改所选小部件的属性。面板顶部有五个按钮，用于切换正在编辑的属性集。**@+id**表示通知编译器需要创建一个新的资源ID来识别API调用中的小部件，而`listView1`标识常量的名称。现在，执行以下步骤：
- en: Change the ID name to `poiListView` and save the changes. Switch back to the
    **Document Outline** pad and notice that the `ListView` ID is updated.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将ID名称更改为`poiListView`并保存更改。切换回**文档大纲**面板，并注意`ListView` ID已更新。
- en: Again, switch back to the **Properties** pad and click on the **Layout** button.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，切换回**属性**面板，并点击**布局**按钮。
- en: Under the **View Group** section of the layout properties, set both the **Width**
    and **Height** properties to `match_parent`.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在布局属性的**视图组**部分，将**宽度**和**高度**属性都设置为`match_parent`。
- en: The `match_parent` value for the `Height` and `Width` properties tells us that
    the `ListView` can use the entire content area provided by the parent, excluding
    any margins specified. In our case, the parent would be the top-level `RelativeLayout`.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Height`和`Width`属性的`match_parent`值告诉我们，`ListView`可以使用父级提供的整个内容区域，不包括指定的任何边距。在我们的例子中，父级将是顶级的`RelativeLayout`。'
- en: Tip
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Prior to API level 8, `fill_parent` was used instead of `match_parent` to accomplish
    the same effect. In API level 8, `fill_parent` was deprecated and replaced with
    `match_parent` for clarity. Currently, both the constants are defined as the same
    value, so they have exactly the same effect. However, `fill_ parent` may be removed
    from the future releases of the API; so, going forward, `match_parent` should
    be used.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在API级别8之前，使用`fill_parent`代替`match_parent`以实现相同的效果。在API级别8中，`fill_parent`被弃用，并替换为`match_parent`以提高清晰度。目前，这两个常量被定义为相同的值，因此它们具有完全相同的效果。然而，`fill_parent`可能会在未来版本的API中被移除；因此，从现在开始，应该使用`match_parent`。
- en: So far, we have added a `ListView` to `RelativeLayout`, let's now add a **Progress
    Bar** to the center of the screen.
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经将`ListView`添加到`RelativeLayout`中，现在让我们将**进度条**添加到屏幕的中心。
- en: Search for **Progress Bar** in the **Toolbox** search field. You will notice
    that several types of progress bars will be listed, including horizontal, large,
    normal, and small. Drag the normal progress bar onto `RelativeLayout`.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**工具箱**搜索字段中搜索**进度条**。你会注意到将列出几种类型的进度条，包括水平、大、普通和小。将普通进度条拖到`RelativeLayout`上。
- en: By default, the **Progress Bar**widget is aligned to the top left of its parent
    layout. To align it to the center of the screen, select the progress bar in the
    **Document Outline** tab, switch to the **Properties** view, and click on the
    **Layout** tab. Now select the **Center In Parent** checkbox, and you will notice
    that the progress bar is aligned to the center of the screen and will appear at
    the top of the list view.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认情况下，**进度条**小部件与其父布局的左上角对齐。要将它对齐到屏幕中心，请在**文档大纲**选项卡中选择进度条，切换到**属性**视图，并点击**布局**选项卡。现在选择**在父级中居中**复选框，你会注意到进度条已对齐到屏幕中心，并将出现在列表视图的顶部。
- en: Currently, the progress bar is visible in the center of the screen. By default,
    this could be hidden in the layout and will be made visible only while the data
    is being downloaded.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，进度条在屏幕中心可见。默认情况下，这可以在布局中隐藏，并且只有在数据正在下载时才会显示。
- en: Change the **Progress Bar** ID to `progressBar` and save the changes.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**进度条**ID更改为`progressBar`并保存更改。
- en: To hide the **Progress Bar** from the layout, click on the **Behavior** tab
    in the **Properties** view. From **Visibility**, select **Box**, and then select
    **gone**.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从布局中隐藏**进度条**，请点击**属性**视图中的**行为**选项卡。从**可见性**中选择**框**，然后选择**消失**。
- en: This behavior can also be controlled by calling `setVisibility()` on any view
    by passing any of the following behaviors. Later in this chapter, we will see
    how to hide the view programmatically using the activity code.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此行为也可以通过在任意视图中调用`setVisibility()`并通过传递以下任何行为来实现控制。在本章的后面部分，我们将看到如何使用活动代码以编程方式隐藏视图。
- en: 'The `View.Visibility` property allows you to control whether a view is visible
    or not. It is based on the `ViewStates` enum, which defines the following values:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`View.Visibility`属性允许您控制视图是否可见。它基于`ViewStates`枚举，该枚举定义了以下值：'
- en: Value
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 值
- en: Description
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 描述
- en: '`Gone`'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`Gone`'
- en: This value tells the parent `ViewGroup` to treat the View as though it does
    not exist, so no space will be allocated in the layout
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此值告诉父`ViewGroup`将视图视为不存在，因此不会在布局中分配空间
- en: '`Invisible`'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`Invisible`'
- en: This value tells the parent `ViewGroup` to hide the content for the View; however,
    it occupies the layout space
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此值告诉父`ViewGroup`隐藏视图的内容；然而，它仍然占据布局空间
- en: '`Visible`'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`Visible`'
- en: This value tells the parent `ViewGroup` to display the content of the View
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此值告诉父`ViewGroup`显示视图的内容
- en: 'Click on the **Source** tab to switch the IDE context from visual designer
    to code, and see what we have built so far. Notice that the following code is
    generated for the `POIList.axml` layout:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**源**选项卡以将IDE上下文从可视化设计器切换到代码，查看我们迄今为止所构建的内容。注意以下代码是为`POIList.axml`布局生成的：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Creating POIListActivity
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建POIListActivity
- en: 'When we created the `POIApp` solution, along with the default layout, a default
    activity (`MainActivity.cs`) was created. Let''s rename the `MainActivity.cs`
    file to `POIListActivity.cs`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建`POIApp`解决方案时，除了默认布局外，还创建了一个默认活动（`MainActivity.cs`）。让我们将`MainActivity.cs`文件重命名为`POIListActivity.cs`：
- en: Select the `MainActivity.cs` file from Solution Explorer and rename to `POIListActivity.cs`.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从解决方案资源管理器中选择`MainActivity.cs`文件并将其重命名为`POIListActivity.cs`。
- en: Open the `POIListActivity.cs` file in the code editor and rename the class to
    `POIListActivity`.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码编辑器中打开`POIListActivity.cs`文件并将类重命名为`POIListActivity`。
- en: The `POIListActivity` class currently contains the code that was created automatically
    while creating the solution using Xamarin Studio. We will write our own activity
    code, so let's remove all the code from the `POIListActivity` class.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`POIListActivity`类目前包含在创建解决方案时自动创建的代码。我们将编写自己的活动代码，因此让我们从`POIListActivity`类中删除所有代码。'
- en: 'Override the `OnCreate()` activity life cycle callback method. This method
    will be used to attach the activity layout, instantiate the views, and write other
    activity initialization logic. Add the following code blocks to the `POIListActivity`
    class:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`OnCreate()`活动生命周期回调方法。此方法将用于附加活动布局、实例化视图以及编写其他活动初始化逻辑。将以下代码块添加到`POIListActivity`类中：
- en: '[PRE1]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now let's set the activity content layout by calling the `SetContentView(layoutId)`
    method. This method places the layout content directly into the activity's view
    hierarchy. Let's provide the reference to the `POIList` layout created in previous
    steps.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们通过调用`SetContentView(layoutId)`方法来设置活动内容布局。此方法将布局内容直接放置到活动的视图层次结构中。让我们提供之前步骤中创建的`POIList`布局的引用。
- en: 'At this point, the `POIListActivity` class looks as follows:'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一点上，`POIListActivity`类看起来如下：
- en: '[PRE2]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that in the preceding code snippet, the `POIListActivity` class uses
    some of the `[Activity]` attributes such as `Label`, `MainLauncher`, and `Icon`.
    During the build process, Xamarin.Android uses these attributes to create an entry
    in the `AndroidManifest.xml` file. As we have already learnt form Chapter 1, *The
    Anatomy of an Android App*, the `AndroidManifest.xml` file is one of the simple
    application configuration files that describes the functionality and requirements
    of your Android application. Xamarin makes it easier by allowing all of the Manifest
    properties to set using attributes so that you never have to modify them manually
    in `AndroidManifest.xml`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面的代码片段中，`POIListActivity`类使用了`[Activity]`属性的一些属性，例如`Label`、`MainLauncher`和`Icon`。在构建过程中，Xamarin.Android使用这些属性在`AndroidManifest.xml`文件中创建一个条目。正如我们在第1章“Android应用的解剖结构”中学到的，`AndroidManifest.xml`文件是描述您的Android应用程序功能和要求的一种简单应用程序配置文件。Xamarin通过允许使用属性设置所有Manifest属性，从而使其更容易，这样您就无需手动在`AndroidManifest.xml`中修改它们。
- en: So far, we have declared an activity and attached the layout to it. At this
    point, if you run the app on your Android device or emulator, you will notice
    that a blank screen will be displayed. The following sections in this chapter
    will walk you through the magic of making the `POIListActivity` activity fully
    functional.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经声明了一个活动并将布局附加到它。在此阶段，如果您在Android设备或模拟器上运行应用程序，您将注意到将显示一个空白屏幕。本章的后续部分将带您了解使`POIListActivity`活动完全功能化的魔法。
- en: Creating the POI list row layout
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建POI列表行布局
- en: 'We now turn our attention to the layout for each row in the `ListView` widget.
    The Android platform provides a number of default layouts out of the box that
    can be used with a `ListView` widget:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将注意力转向`ListView`小部件中每一行的布局。Android平台提供了一些默认布局，可以直接与`ListView`小部件一起使用：
- en: Layout
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 布局
- en: Description
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 描述
- en: '`SimpleListItem1`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleListItem1`'
- en: A single line with a single caption field
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一行，包含一个标题字段
- en: '`SimpleListItem2`'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleListItem2`'
- en: A two-line layout with a larger font and a brighter text color for the first
    field
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 两行布局，第一字段使用较大字体和较亮的文本颜色
- en: '`TwoLineListItem`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`TwoLineListItem`'
- en: A two-line layout with an equal sized font for both lines and a brighter text
    color for the first line
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 两行布局，两行字体大小相等，第一行文本颜色较亮
- en: '`ActivityListItem`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActivityListItem`'
- en: A single line of text with an image view
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一行文本，包含一个图像视图
- en: All of the preceding three layouts provide a pretty standard design, but for
    more control over content layout, a custom layout can also be created, which is
    what is needed for `poiListView`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前三个布局都提供了一个相当标准的布局，但为了更好地控制内容布局，也可以创建一个自定义布局，这正是`poiListView`所需要的。
- en: 'To create a new layout, perform the following steps:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的布局，请执行以下步骤：
- en: In the **Solution** pad, navigate to **Resources** | **Layout**, right-click
    on it, and navigate to **Add** | **New File**.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**解决方案**面板中，导航到**资源** | **布局**，右键单击它，然后导航到**添加** | **新建文件**。
- en: Select **Android** from the list on the left-hand side, **Android Layout** from
    the template list, enter `POIListItem` in the name column, and click on **New**.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从左侧的列表中选择**Android**，从模板列表中选择**Android布局**，在名称列中输入`POIListItem`，然后单击**新建**。
- en: 'Before we proceed to lay out the design for each of the row items in the list,
    we must draw on a piece of paper and analyze how the UI will look like. In our
    example, the POI data will be organized as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始为列表中每一行的项目布局设计之前，我们必须在纸上绘制并分析UI将如何呈现。在我们的例子中，POI数据将组织如下：
- en: '![](img/NIUBUsJX.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/NIUBUsJX.jpg)'
- en: 'There are a number of ways to achieve this layout, but we will use `RelativeLayout`
    to achieve the same result. There is a lot going on in this diagram. Let''s break
    it down as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这种布局有几种方法，但我们将使用`RelativeLayout`来实现相同的结果。这个图表中有很多内容。让我们如下分解：
- en: A `RelativeLayout` view group is used as the top-level container; it provides
    a number of flexible options for positioning relative content, its edges, or other
    content.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RelativeLayout`视图组用作顶级容器；它提供了一系列灵活的选项来定位相对内容、其边缘或其他内容。'
- en: An `ImageView` widget is used to display a photo of the POI, and it is anchored
    to the left-hand side of the `RelativeLayout` utility.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ImageView`小部件来显示POI的照片，并将其锚定在`RelativeLayout`实用工具的左侧。
- en: Two `TextView` widgets are used to display the POI name and address information.
    They need to be anchored to the right-hand side of the `ImageView` widget and
    centered within the parent `RelativeLayout` utility. The easiest way to accomplish
    this is to place both the `TextView` classes inside another layout; in this case,
    a `LinearLayout` widget with the orientation set to vertical.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用两个`TextView`小部件来显示POI名称和地址信息。它们需要锚定在`ImageView`小部件的右侧，并在父`RelativeLayout`实用工具内居中。完成此操作的最简单方法是，将两个`TextView`类放置在另一个布局中；在这种情况下，一个方向设置为垂直的`LinearLayout`小部件。
- en: An additional `TextView` widget is used to display the distance, and it is anchored
    on the right-hand side of the `RelativeLayout` view group and centered vertically.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一个额外的`TextView`小部件来显示距离，并将其锚定在`RelativeLayout`视图组的右侧，并垂直居中。
- en: Now, our task is to get this definition into `POIListItem.axml`. The next few
    sections describe how to accomplish this using the `Content` view of the designer
    when feasible and the `Source` view when required.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的任务是把这个定义放入`POIListItem.axml`中。接下来的几节将描述如何在可行时使用设计器的`内容`视图，在需要时使用`源`视图来完成这项任务。
- en: Adding a RelativeLayout view group
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加RelativeLayout视图组
- en: 'The `RelativeLayout` layout manager allows its child views to be positioned
    relative to each other or relative to the container or another container. In our
    case, for building the row layout, as shown in the preceding diagram, we can use
    `RelativeLayout` as a top-level view group. When the `POIListItem.axml` layout
    file was created, by default a top-level `LinearLayout` was added. First, we need
    to change the top-level `ViewGroup` to `RelativeLayout`. The following section
    will take you through the steps to complete the layout design for the POI list
    row:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`RelativeLayout`布局管理器允许其子视图相对于彼此或相对于容器或另一个容器进行定位。在我们的案例中，为了构建行布局，如前图所示，我们可以使用`RelativeLayout`作为顶级视图组。当创建`POIListItem.axml`布局文件时，默认添加了一个顶级`LinearLayout`。首先，我们需要将顶级`ViewGroup`更改为`RelativeLayout`。以下部分将指导您完成POI列表行布局设计的步骤：'
- en: With `POIListItem.axml` opened in the content mode, select the entire layout
    by clicking on the content area. You should see a blue outline going around the
    edge. Press *Delete*. The `LinearLayout` view group will be deleted, and you will
    see a message indicating that the layout is empty.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内容模式下打开`POIListItem.axml`，通过点击内容区域选择整个布局。您应该看到一个蓝色轮廓围绕边缘。按*Delete*键。`LinearLayout`视图组将被删除，您将看到一个指示布局为空的提示信息。
- en: Alternatively, you can also select the `LinearLayout` view group from the **Document
    Outline** tab and press *Delete*.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，您也可以从**文档大纲**选项卡中选择`LinearLayout`视图组，然后按*Delete*键。
- en: Locate the `RelativeLayout` view group in the toolbox and drag it onto the layout.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在工具箱中找到`RelativeLayout`视图组，并将其拖放到布局中。
- en: 'Select the `RelativeLayout` view group from **Document Outline**. Open the
    **Properties** pad and change the following properties:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**文档大纲**中选择`RelativeLayout`视图组。打开**属性**面板，并更改以下属性：
- en: The **Padding** option to `5dp`
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**填充**选项设置为`5dp`'
- en: The **Layout Height** option to `wrap_content`
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**布局高度**选项设置为`wrap_content`'
- en: The **Layout Width** option to `match_parent`
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**布局宽度**选项设置为`match_parent`'
- en: The padding property controls how much space will be placed around each item
    as a margin, and the height determines the height of each list row. Setting the
    **Layout Width** option to `match_ parent` will cause the `POIListItem` content
    to consume the entire width of the screen, while setting the **Layout Height**
    option to `wrap_content` will cause each row to be equal to the longest control.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 填充属性控制每个项目周围作为边距的空间量，而高度决定了每行列表的高度。将**布局宽度**选项设置为`match_parent`将使`POIListItem`内容消耗整个屏幕的宽度，而将**布局高度**选项设置为`wrap_content`将使每行等于最长的控件。
- en: 'Switch to the **Code** view to see what has been added to the layout. Notice
    that the following lines of code have been added to `RelativeLayout`:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到**代码**视图以查看已添加到布局中的内容。注意以下代码行已添加到`RelativeLayout`中：
- en: '[PRE3]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tip
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Android runs on a variety of devices that offer different screen sizes and densities.
    When specifying dimensions, you can use a number of different units, including
    pixels (px), inches (in), and density-independent pixels (dp). Density-independent
    pixels are abstract units based on 1 dp being 1 pixel on a 160 dpi screen. At
    runtime, Android will scale the actual size up or down based on the actual screen
    density. It is a best practice to specify dimensions using density-independent
    pixels.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Android运行在多种设备上，这些设备提供不同的屏幕尺寸和密度。在指定尺寸时，您可以使用多种不同的单位，包括像素（px）、英寸（in）和密度无关像素（dp）。密度无关像素是基于在160
    dpi屏幕上1 dp等于1像素的抽象单位。在运行时，Android将根据实际屏幕密度调整实际大小。使用密度无关像素指定尺寸是一种最佳实践。
- en: Adding an ImageView widget
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加ImageView小部件
- en: 'The `ImageView` widget in Android is used to display the arbitrary image for
    different sources. In our case, we will download the images from the server and
    display them in the list. Let''s add an `ImageView` widget to the left-hand side
    of the layout and set the following configurations:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Android中的`ImageView`小部件用于显示来自不同来源的任意图像。在我们的案例中，我们将从服务器下载图像并在列表中显示它们。让我们在布局的左侧添加一个`ImageView`小部件，并设置以下配置：
- en: Locate the `ImageView` widget in the toolbox and drag it onto `RelativeLayout`.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在工具箱中找到`ImageView`小部件，并将其拖放到`RelativeLayout`中。
- en: With the `ImageView` widget selected, use the **Properties** pad to set the
    ID to `poiImageView`.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择`ImageView`小部件时，使用**属性**面板将ID设置为`poiImageView`。
- en: Now, click on the **Layout** tab in the **Properties** pad and set the **Height**
    and **Width** values to `65 dp`.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击**属性**面板中的**布局**选项卡，并将**高度**和**宽度**值设置为`65 dp`。
- en: 'In the property grouping named `RelativeLayout`, set **Center Vertical** to
    **true**. Simply clicking on the checkbox does not seem to work, but you can click
    on the small icon that looks like an edit box, which is to the right-hand side,
    and just enter `true`. If everything else fails, just switch to the **Source**
    view and enter the following code:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为 `RelativeLayout` 的属性分组中，将 **Center Vertical** 设置为 **true**。简单地点击复选框似乎不起作用，但你可以点击右侧看起来像编辑框的小图标，然后输入
    `true`。如果其他方法都失败了，只需切换到 **Source** 视图并输入以下代码：
- en: '[PRE4]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the property grouping named `ViewGroup`, set the **Margin Right** to `5dp`.
    This brings some space between the POI image and the POI name.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为 `ViewGroup` 的属性分组中，将 **Margin Right** 设置为 `5dp`。这会在 POI 图像和 POI 名称之间留出一些空间。
- en: 'Switch to the **Code** view to see what has been added to the layout. Notice
    the following lines of code added to `ImageView`:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到 **Code** 视图查看已添加到布局中的内容。注意以下行代码被添加到 `ImageView`：
- en: '[PRE5]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Adding a LinearLayout widget
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加一个 `LinearLayout` 小部件
- en: '`LinearLayout` is one of the most basic layout managers that organizes its
    child views either horizontally or vertically based on the value of its `orientation`
    property. Let''s add a `LinearLayout` view group that will be used to lay out
    the POI name and address data as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinearLayout` 是最基础的布局管理器之一，根据其 `orientation` 属性的值，水平或垂直地组织其子视图。让我们添加一个 `LinearLayout`
    视图组，它将用于布局 POI 名称和地址数据，如下所示：'
- en: Locate the `LinearLayout` (vertical) view group in the toolbox.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在工具箱中定位垂直的 `LinearLayout` 视图组。
- en: Adding this widget is a little trickier because we want it anchored to the right-hand
    side of the `ImageView` widget.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加此小部件稍微有些复杂，因为我们希望它锚定到 `ImageView` 小部件的右侧。
- en: Drag the `LinearLayout` view group to the right-hand side of the `ImageView`
    widget until the edge turns to a blue dashed line, and then drop the `LinearLayout`
    view group. It will be aligned with the right-hand side of the `ImageView` widget.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `LinearLayout` 视图组拖动到 `ImageView` 小部件的右侧，直到边缘变成蓝色虚线，然后释放鼠标。它将与 `ImageView`
    小部件的右侧对齐。
- en: In the property grouping named `RelativeLayout` of the **Layout** section, set
    **Center Vertical** to `true`. As before, you will need to enter `true` in the
    edit box or manually add it to the **Source** view.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Layout** 部分的名为 `RelativeLayout` 的属性分组中，将 **Center Vertical** 设置为 `true`。和之前一样，你需要在编辑框中输入
    `true` 或手动将其添加到 **Source** 视图。
- en: 'Switch to the **Code** view to see what has been added to the layout. Notice
    the following lines of code added to `LinearLayout`:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到 **Code** 视图查看已添加到布局中的内容。注意以下行代码被添加到 `LinearLayout`：
- en: '[PRE6]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Adding the name and address TextView classes
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加名称和地址的 `TextView` 类
- en: 'Add the `TextView` classes to display the POI name and address:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 添加 `TextView` 类以显示 POI 名称和地址：
- en: Locate `TextView` in the **Toolbox** and add a `TextView` class to the layout.
    This `TextView` needs to be added within the `LinearLayout` view group we just
    added, so drag `TextView` over the `LinearLayout` view group until it turns blue
    and then drop it.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Toolbox** 中定位 `TextView` 并将其添加到布局中。这个 `TextView` 需要添加到我们刚刚添加的 `LinearLayout`
    视图组中，所以将 `TextView` 拖动到 `LinearLayout` 视图组上，直到它变成蓝色，然后释放鼠标。
- en: Name the `TextView` ID as `nameTextView` and set the `text size` to `20sp`.
    The text size can be set in the **Style** section of the **Properties** pad; you
    will need to expand the **Text Appearance** group by clicking on the ellipsis
    (**...**) button on the right-hand side.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `TextView` 的 ID 命名为 `nameTextView` 并设置 `text size` 为 `20sp`。文本大小可以在 **Properties**
    面板的 **Style** 部分设置；你需要通过点击右侧的省略号（**...**）按钮来展开 **Text Appearance** 组。
- en: Tip
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Scale-independent pixels** (**sp**) are like dp units, but they are also
    scaled by the user''s font size preference. Android allows users to select a font
    size in the Accessibility section of Settings. When font sizes are specified using
    sp, Android will not only take into account the screen density when scaling text,
    but will also consider the user''s accessibility settings. It is recommended that
    you specify font sizes using sp.'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**Scale-independent pixels** （**sp**）类似于 dp 单位，但它们也会根据用户的字体大小偏好进行缩放。Android
    允许用户在设置中的可访问性部分选择字体大小。当使用 sp 指定字体大小时，Android 不仅会在缩放文本时考虑屏幕密度，还会考虑用户的可访问性设置。建议使用
    sp 来指定字体大小。'
- en: Add another `TextView` to the `LinearLayout` view group using the same technique
    except dragging the new widget to the bottom edge of the `nameTextView` until
    it changes to a blue dashed line and then drop it. This will cause the second
    `TextView` to be added below `nameTextView`. Set the font size to `14sp`.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相同的技术将另一个`TextView`添加到`LinearLayout`视图组中，除了将新小部件拖动到`nameTextView`的底部边缘，直到它变成蓝色虚线，然后放下。这将导致第二个`TextView`添加到`nameTextView`下方。设置字体大小为`14sp`。
- en: Change the ID of the newly added `TextView` to `addrTextView`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新添加的`TextView`的ID更改为`addrTextView`。
- en: Now change the sample text for both `nameTextView` and `addrTextView` to **POI
    Name** and **City**, **State**, **Postal Code**.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`nameTextView`和`addrTextView`的示例文本更改为**POI名称**、**城市**、**州**、**邮政编码**。
- en: To edit the text shown in `TextView`, just double tap the widget on the content
    panel. This enables a small editor that allows you to enter the text directly.
    Alternately, you can change the text by entering a value for the **Text** property
    in the **Widget** section of the **Properties** pad.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编辑`TextView`中显示的文本，只需在内容面板上双击小部件。这将启用一个小型编辑器，允许您直接输入文本。或者，您可以通过在**属性**面板的**小部件**部分的**文本**属性中输入值来更改文本。
- en: 'It is a design practice to declare all your static strings in the `Resources/values/string.xml`
    file. By declaring the strings in the `strings.xml` file, you can easily translate
    your whole app to support other languages. Let''s add the following strings to
    `string.xml`:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Resources/values/string.xml`文件中声明所有静态字符串是一种设计实践。通过在`strings.xml`文件中声明字符串，您可以轻松地将整个应用程序翻译成支持其他语言。让我们将以下字符串添加到`string.xml`文件中：
- en: '[PRE7]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can now change the **Text** property of both `nameTextView` and `addrTextView`
    by selecting the ellipsis (**…**) button, which is next to the **Text** property
    in the **Widget** section of the **Properties** pad. Notice that this will open
    a dialog window that lists all the strings declared in the `string.xml` file.
    Select the appropriate strings for both `TextView` objects.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在可以通过选择**属性**面板的**小部件**部分的**文本**属性旁边的省略号（**…**）按钮来更改`nameTextView`和`addrTextView`的**文本**属性。注意这将打开一个对话框窗口，列出了在`string.xml`文件中声明的所有字符串。为两个`TextView`对象选择适当的字符串。
- en: 'Now let''s switch to the **Code** view to see what has been added to the layout.
    Notice the following lines of code added inside `LinearLayout`:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们切换到**代码**视图，看看布局中添加了什么。注意在`LinearLayout`内部添加的以下代码行：
- en: '[PRE8]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Adding the distance TextView
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加距离`TextView`
- en: 'Add a `TextView` to show the distance from POI:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个`TextView`来显示从POI的距离：
- en: Locate the `TextView` in the toolbox and add a `TextView` to the layout. This
    `TextView` needs to be anchored to the right-hand side of the `RelativeLayout`
    view group, but there is no way to visually accomplish this; so, we will use a
    multistep process. Initially, align the `TextView` with the right-hand edge of
    the `LinearLayout` view group by dragging it to the left-hand side until the edge
    changes to a dashed blue line and drop it.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在工具箱中定位`TextView`，并将一个`TextView`添加到布局中。这个`TextView`需要锚定到`RelativeLayout`视图组的右侧，但没有办法通过视觉方式完成；因此，我们将使用多步骤过程。最初，通过将其拖动到左侧，直到边缘变成虚线蓝色，然后将它放下，将`TextView`与`LinearLayout`视图组的右侧边缘对齐。
- en: In the **Widget** section of the **Properties** pad, name the widget as `distanceTextView`
    and set the font size to `14sp`.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**属性**面板的**小部件**部分，将小部件命名为`distanceTextView`，并设置字体大小为`14sp`。
- en: In the **Layout** section of the **Properties** pad, set **Align Parent Right**
    to **true**, **Center Vertical** to **true**, and clear out the `linearLayout1`
    view group name in the **To Right Of** layout property.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**属性**面板的**布局**部分，将**Align Parent Right**设置为**true**，**Center Vertical**设置为**true**，并在**To
    Right Of**布局属性中清除`linearLayout1`视图组名称。
- en: Change the sample text to **204 miles**. To do this, let's add a new string
    entry to `string.xml` and set the **Text** property from the **Properties** pad.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将示例文本更改为**204英里**。为此，让我们在`string.xml`中添加一个新的字符串条目，并从**属性**面板的**小部件**部分的**文本**属性中设置**文本**属性。
- en: 'The following screenshot depicts what should be seen from the Content view
    at this point:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了此时内容视图应该显示的内容：
- en: '![](img/OejOO7zu.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/OejOO7zu.jpg)'
- en: 'Switch back to the **Source** tab in the layout designer, and notice the following
    code generated for the `POIListItem.axml` layout:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 切换回布局设计器中的**源**选项卡，注意为`POIListItem.axml`布局生成的以下代码：
- en: '[PRE9]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Creating the PointOfInterest apps entity class
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建PointOfInterest应用程序实体类
- en: 'The first class that is needed is the one that represents the primary focus
    of the application, a `PointofInterest` class. `POIApp` will allow the following
    attributes to be captured for the Point Of Interest app:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 首先需要的类是代表应用程序主要焦点的 `PointofInterest` 类。`POIApp` 将允许 Point Of Interest 应用程序捕获以下属性：
- en: '`Id`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ID`'
- en: '`Name`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`名称`'
- en: '`Description`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`描述`'
- en: '`Address`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`地址`'
- en: '`Latitude`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`纬度`'
- en: '`Longitude`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`经度`'
- en: '`Image`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`图片`'
- en: The POI entity class can be nothing more than a simple .NET class, which houses
    these attributes.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: POI 实体类可能只是一个简单的 .NET 类，它包含这些属性。
- en: 'To create a POI entity class, perform the following steps:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 POI 实体类，请执行以下步骤：
- en: Select the `POIApp` project from the Solution Explorer in Xamarin Studio. Select
    the `POIApp` project and not the solution, which is the top-level node in the
    **Solution** pad.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Xamarin Studio 的解决方案资源管理器中选择 `POIApp` 项目。选择 `POIApp` 项目，而不是解决方案，它是 **解决方案**
    选项卡中的顶级节点。
- en: Right-click on it and select **New File**.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击并选择 **新建文件**。
- en: On the left-hand side of the **New File** dialog box, select **General**.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **新建文件** 对话框的左侧，选择 **通用**。
- en: At the top of the template list, in the middle of the dialog box, select **Empty
    Class (C#)**.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模板列表的顶部，在对话框的中间，选择 **空类 (C#)**。
- en: Enter the name `PointOfInterest` and click on **OK**. The class will be created
    in the `POIApp` project folder.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入名称 `PointOfInterest` 并单击 **确定**。该类将在 `POIApp` 项目文件夹中创建。
- en: Change the visibility of the class to public and fill in the attributes based
    on the list previously identified.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类的可见性更改为公共，并根据之前确定的列表填写属性。
- en: 'The following code snippet is from `\POIApp\POIApp\PointOfInterest.cs` from
    the code bundle available for this book:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段来自本书提供的代码包中的 `\POIApp\POIApp\PointOfInterest.cs`：
- en: '[PRE10]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that the **Latitude** and **Longitude** attributes are all marked as nullable.
    In the case of latitude and longitude, (0, 0) is actually a valid location so
    a null value indicates that the attributes have never been set.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，**纬度**和**经度**属性都被标记为可空。在纬度和经度的案例中，(0, 0) 实际上是一个有效的位置，因此空值表示这些属性从未被设置。
- en: Populating the ListView item
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 填充 ListView 项
- en: All the adapter views such as `ListView` and `GridView` use an `Adapter` that
    acts as a bridge between the data and views. The `Adapter` iterates through the
    content and generates Views for each data item in the list.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 所有适配器视图，如 `ListView` 和 `GridView`，都使用一个 `Adapter` 作为数据与视图之间的桥梁。`Adapter` 遍历内容并为列表中的每个数据项生成视图。
- en: The Android SDK provides three different adapter implementations such as `ArrayAdapter`,
    `CursorAdapter`, and `SimpleAdapter`. An `ArrayAdapter` expects an array or a
    list as input, while `CursorAdapter` accepts the instance of the `Cursor`, and
    `SimpleAdapter` maps the static data defined in the resources. The type of adapter
    that suits your app need is purely based on the input data type.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Android SDK 提供了三种不同的适配器实现，如 `ArrayAdapter`、`CursorAdapter` 和 `SimpleAdapter`。`ArrayAdapter`
    期望输入一个数组或列表，而 `CursorAdapter` 接受 `Cursor` 的实例，`SimpleAdapter` 将资源中定义的静态数据映射。适合您应用程序的适配器类型纯粹基于输入数据类型。
- en: The `BaseAdapter` is the generic implementation for all of the three adapter
    types, and it implements the `IListAdapter`, `ISpinnerAdapter`, and `IDisposable`
    interfaces. This means that the `BaseAdapter` can be used for `ListView`, `GridView`,
    or `Spinners`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseAdapter` 是所有三种适配器类型的泛型实现，它实现了 `IListAdapter`、`ISpinnerAdapter` 和 `IDisposable`
    接口。这意味着 `BaseAdapter` 可以用于 `ListView`、`GridView` 或 `Spinners`。'
- en: For `POIApp`, we will create a subtype of `BaseAdapter&lt;T&gt;` as it meets
    our specific needs, works well in many scenarios, and allows the use of our custom
    layout.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `POIApp`，我们将创建 `BaseAdapter<T>` 的子类型，因为它满足我们的特定需求，在许多场景中表现良好，并允许使用我们的自定义布局。
- en: Creating POIListViewAdapter
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 POIListViewAdapter
- en: 'In order to create POIListViewAdapter, we will start by creating a custom adapter
    as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建 POIListViewAdapter，我们将首先创建一个自定义适配器，如下所示：
- en: Create a new class named `POIListViewAdapter`.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `POIListViewAdapter` 的新类。
- en: Open the `POIListViewAdapter` class file, make the class a public class, and
    specify that it inherits from `BaseAdapter&lt;PointOfInterest&gt;`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `POIListViewAdapter` 类文件，将类设为公共类，并指定它继承自 `BaseAdapter<PointOfInterest>`。
- en: Now that the adapter class has been created, we need to provide a constructor
    and implement four abstract methods.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在适配器类已经创建，我们需要提供一个构造函数并实现四个抽象方法。
- en: Implementing a constructor
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现构造函数
- en: Let's implement a constructor that accepts all the information we will need
    to work with to populate the list.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个构造函数，它接受我们将需要用于填充列表的所有信息。
- en: 'Typically, you need to pass at least two parameters: an instance of an activity
    because we need the activity context while accessing the standard common resources
    and an input data list that can be enumerated to populate the `ListView`. The
    following code shows the constructor from the code bundle:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你需要传递至少两个参数：一个活动实例，因为我们需要在访问标准公共资源时使用活动上下文，以及一个可以枚举的输入数据列表，用于填充 `ListView`。以下代码展示了代码包中的构造函数：
- en: '[PRE11]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Implementing Count { get }
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现 `Count { get }`
- en: 'The `BaseAdapter&lt;T&gt;` class provides an abstract definition for a read-only
    `Count` property. In our case, we simply need to provide the count of POIs as
    provided in `poiListData`. The following code example demonstrates the implementation
    from the code bundle:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseAdapter<T>` 类提供了一个只读 `Count` 属性的抽象定义。在我们的情况下，我们只需要提供 `poiListData` 中提供的
    POI 的数量。以下代码示例展示了代码包中的实现：'
- en: '[PRE12]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Implementing GetItemId()
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现 `GetItemId()`
- en: 'The `BaseAdapter&lt;T&gt;` class provides an abstract definition for a method
    that returns a long ID for a row in the data source. We can use the `position`
    parameter to access a POI object in the list and return the corresponding ID.
    The following code example demonstrates the implementation from the code bundle:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseAdapter<T>` 类提供了一个返回数据源中行长 ID 的方法的抽象定义。我们可以使用 `position` 参数访问列表中的 POI
    对象并返回相应的 ID。以下代码示例展示了代码包中的实现：'
- en: '[PRE13]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Implementing the index getter method
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现 `index getter` 方法
- en: 'The `BaseAdapter&lt;T&gt;` class provides an abstract definition for an index
    getter method that returns a typed object based on a position parameter passed
    in as an index. We can use the position parameter to access the POI object from
    `poiListData` and return an instance. The following code example demonstrates
    the implementation from the code bundle:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseAdapter<T>` 类提供了一个基于索引参数返回类型对象的索引获取方法的抽象定义。我们可以使用位置参数从 `poiListData` 访问
    POI 对象并返回一个实例。以下代码示例展示了从代码包中的实现：'
- en: '[PRE14]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Implementing GetView()
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现 `GetView()`
- en: 'The `BaseAdapter&lt;T&gt;` class provides an abstract definition for `GetView()`,
    which returns a view instance that represents a single row in the `ListView` item.
    As in other scenarios, you can choose to construct the view entirely in code or
    to inflate it from a layout file. We will use the layout file we previously created.
    The following code example demonstrates inflating a view from a layout file:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseAdapter<T>` 类提供了一个 `GetView()` 的抽象定义，它返回一个表示 `ListView` 项中单个行的视图实例。与其他场景一样，你可以选择完全在代码中构建视图，或者从布局文件中填充它。我们将使用之前创建的布局文件。以下代码示例展示了从布局文件中填充视图：'
- en: '[PRE15]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first parameter of `Inflate` is a resource ID and the second is a root `ViewGroup`,
    which in this case can be left `null` since the view will be added to the `ListView`
    item when it is returned.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`Inflate` 的第一个参数是一个资源 ID，第二个参数是一个根 `ViewGroup`，在这个例子中可以留为 `null`，因为视图将在返回时被添加到
    `ListView` 项中。'
- en: Reusing row Views
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重复使用行视图
- en: 'The `GetView()` method is called for each row in the source dataset. For datasets
    with large numbers of rows, hundreds, or even thousands, it would require a great
    deal of resources to create a separate view for each row, and it would seem wasteful
    since only a few rows are visible at any given time. The `AdapterView` architecture
    addresses this need by placing row Views into a queue that can be reused as they
    scroll out of view of the user. The `GetView()` method accepts a parameter named
    `convertView`, which is of type `view`. When a view is available for reuse, `convertView`
    will contain a reference to the view; otherwise, it will be `null` and a new view
    should be created. The following code example depicts the use of `convertView`
    to facilitate the reuse of row Views:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetView()` 方法会在源数据集的每一行上被调用。对于行数众多的数据集，比如数百行甚至数千行，为每一行创建一个单独的视图将需要大量的资源，而且由于在任何给定时间只有少数几行是可见的，这看起来似乎是浪费的。`AdapterView`
    架构通过将行视图放入一个队列中来解决这个需求，这些视图在滚动出用户视野时可以被重复使用。`GetView()` 方法接受一个名为 `convertView`
    的参数，其类型为 `view`。当一个视图可供重复使用时，`convertView` 将包含对该视图的引用；否则，它将是 `null`，此时应该创建一个新的视图。以下代码示例展示了如何使用
    `convertView` 来促进行视图的重复使用：'
- en: '[PRE16]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Populating row Views
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 填充行视图
- en: Now that we have an instance of the view, we need to populate the fields. The
    `View` class defines a named `FindViewById&lt;T&gt;` method, which returns a typed
    instance of a widget contained in the view. You pass in the resource ID defined
    in the layout file to specify the control you wish to access.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个视图实例，我们需要填充字段。`View` 类定义了一个命名的 `FindViewById<T>` 方法，它返回视图中包含的小部件的泛型实例。您通过传递在布局文件中定义的资源
    ID 来指定您希望访问的控制。
- en: 'The following code returns access to `nameTextView` and sets the **Text** property:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码返回对 `nameTextView` 的访问权限并设置 **Text** 属性：
- en: '[PRE17]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Populating `addrTextView` is slightly more complicated because we only want
    to use the portions of the address we have, and we want to hide the `TextView`
    if none of the address components are present.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 填充 `addrTextView` 稍微复杂一些，因为我们只想使用我们拥有的地址部分，并且当地址的任何组件都不存在时，我们想要隐藏 `TextView`。
- en: 'The `View.Visibility` property allows you to control the visibility property
    of a view. In our case, we want to use the `ViewState.Gone` value if none of the
    components of the address are present. The following code shows the logic in `GetView`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`View.Visibility` 属性允许您控制视图的可见性属性。在我们的情况下，如果我们没有地址的任何组件，我们想要使用 `ViewState.Gone`
    值。以下代码展示了 `GetView` 中的逻辑：'
- en: '[PRE18]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Populating the value for the distance text view requires an understanding of
    the location services. We need to do some calculation, by considering the user's
    current location with the POI latitude and longitude. This part will be covered
    in Chapter 9, *Making POIApp Location Aware*.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 填充距离文本视图的值需要了解位置服务。我们需要进行一些计算，考虑到用户的当前位置与 POI 的纬度和经度。这部分将在第 9 章 *使 POIApp 具有位置感知能力*
    中介绍。
- en: Populating the list thumbnail image
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 填充列表缩略图图像
- en: Image downloading and processing is a complex task. You need to consider the
    various aspects, such as network logic, to download images from the server, caching
    downloaded images for performance, and image resizing for avoiding the memory
    out conditions. Instead of writing our own logic for doing all the earlier mentioned
    tasks, we can use `UrlImageViewHelper`, which is a free component available in
    the Xamarin Component Store.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图像下载和处理是一个复杂的过程。您需要考虑各种方面，例如网络逻辑，从服务器下载图像，为了性能而缓存下载的图像，以及为了避免内存溢出条件而调整图像大小。我们不必为执行所有上述任务编写自己的逻辑，我们可以使用
    `UrlImageViewHelper`，这是一个在 Xamarin 组件商店中可用的免费组件。
- en: The Xamarin Component Store provides a set of reusable components, including
    both free and premium components, that can be easily plugged into any Xamarin-based
    application.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin 组件商店提供了一套可重用的组件，包括免费和付费组件，可以轻松地集成到任何基于 Xamarin 的应用程序中。
- en: Using UrlImageViewHelper
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 UrlImageViewHelper
- en: 'The following steps will walk you through the process of adding a component
    from the Xamarin Component Store:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将指导您从 Xamarin 组件商店添加组件的过程：
- en: To include the `UrlImageViewHelper` component in `POIApp`, you can either double-click
    on the `Components` folder in the **Solution** pad, or right-click and select
    **Edit Components**.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在 `POIApp` 中包含 `UrlImageViewHelper` 组件，您可以在 **解决方案** 面板中双击 `Components` 文件夹，或者右键单击并选择
    **编辑组件**。
- en: Notice that the component manager will be loaded with the already downloaded
    components and a **Get More Components** button that allows you to open the **Components**
    store from the window. Note that to access the component manager, you need to
    log in to your Xamarin account:![](img/SwDRCFYC.jpg)
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，组件管理器将加载已下载的组件以及一个 **获取更多组件** 按钮，允许您从窗口中打开 **组件** 商店。请注意，要访问组件管理器，您需要登录您的
    Xamarin 账户！![img/SwDRCFYC.jpg](img/SwDRCFYC.jpg)
- en: Search for `UrlImageViewHelper` in the components search box available in the
    left-hand side pane. Now click on the download button to add your Xamarin Studio
    solution.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧窗格中可用的组件搜索框中搜索 `UrlImageViewHelper`。现在点击下载按钮以添加您的 Xamarin Studio 解决方案。
- en: 'Now that we have added the `UrlImageViewHelper` component, let''s go back to
    the `GetView()` method in the `POIListViewAdapter` class. Let''s take a look at
    the following section of the code:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经添加了 `UrlImageViewHelper` 组件，让我们回到 `POIListViewAdapter` 类中的 `GetView()`
    方法。让我们看一下以下代码段：
- en: '[PRE19]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let us examine how the preceding code snippet works:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看前面的代码片段是如何工作的：
- en: 'The `SetUrlDrawable()` method defined in the `UrlImageViewHelper` component
    provides a logic to download an image using a single line of code. It accepts
    three parameters: an instance of `imageView`, where the image is to be displayed
    after the download, the image source URL, and the placeholder image.'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`UrlImageViewHelper`组件中定义的`SetUrlDrawable()`方法提供了一条使用单行代码下载图像的逻辑。它接受三个参数：一个`imageView`实例，图像下载后将在其中显示，图像源URL和占位图像。
- en: Add a new image `ic_placeholder.png` to the `drawable Resources` directory.
    While the image is being downloaded, the placeholder image will be displayed on
    `imageView`.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的图像`ic_placeholder.png`添加到`drawable Resources`目录。在图像下载期间，占位图像将在`imageView`上显示。
- en: Downloading the image over the network requires Internet permissions. The following
    section will walk you through the steps involved in defining permissions in your
    `AndroidManifest.xml` file.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在网络上下载图像需要互联网权限。以下部分将指导您在`AndroidManifest.xml`文件中定义权限的步骤。
- en: Adding Internet permissions
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加互联网权限
- en: Android apps must be granted permissions while accessing certain features, such
    as downloading data from the Internet, saving an image in storage, and so on.
    You must specify the permissions that an app requires in the `AndroidManifest.xml`
    file. This allows the installer to show potential users the set of permissions
    an app requires at the time of installation.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在访问某些功能时，例如从互联网下载数据、在存储中保存图像等，Android应用必须被授予权限。您必须在`AndroidManifest.xml`文件中指定应用所需的权限。这允许安装程序在安装时向潜在用户展示应用所需的权限集合。
- en: 'To set the appropriate permissions, perform the following steps:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置适当的权限，执行以下步骤：
- en: 'Double-click on `AndroidManifest.xml` in the **Properties** directory in the
    **Solution** pad. The file will open in the manifest editor. There are two tabs:
    **Application** and **Source**, at the bottom of the screen, that can be used
    to toggle between viewing a form for editing the file and the raw XML, as shown
    in the following screenshot:![](img/WwoNP5Zc.jpg)'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击**Solution**面板中**Properties**目录下的`AndroidManifest.xml`。文件将在manifest编辑器中打开。屏幕底部有两个标签：**Application**和**Source**，可以用来在编辑文件的表单视图和原始XML之间切换，如下面的截图所示：![img/WwoNP5Zc.jpg](img/WwoNP5Zc.jpg)
- en: In the **Required permissions** list, check **Internet** and navigate to **File**
    | **Save**.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Required permissions**列表中，勾选**Internet**并导航到**File** | **Save**。
- en: Switch to the **Source** view to view the XML as follows:![](img/TcyeJQCV.jpg)
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到**Source**视图以查看XML，如下所示：![img/TcyeJQCV.jpg](img/TcyeJQCV.jpg)
- en: Hooking up POIListViewAdapter
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接POIListViewAdapter
- en: 'We have the list layout and adapter ready; let''s now proceed to hook up the
    data in `poiListView`. We need to switch back to the `POIListActivity` class and
    add the following changes:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好了列表布局和适配器；现在让我们继续将数据连接到`poiListView`。我们需要切换回`POIListActivity`类并添加以下更改：
- en: 'Declare the following variables inside the `POIListActivity` class:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`POIListActivity`类内部声明以下变量：
- en: '[PRE20]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, in the `OnCreate` method, instantiate the `ListView` and `ProgressBar`:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`OnCreate`方法中，实例化`ListView`和`ProgressBar`：
- en: '[PRE21]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'For now, we will create an `Async` method that is responsible for downloading
    the data from the server and displaying it in `POIListActivity`. Add the following
    method to the `POIListActivity` class:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，我们将创建一个`Async`方法，该方法负责从服务器下载数据并在`POIListActivity`中显示。将以下方法添加到`POIListActivity`类中：
- en: '[PRE22]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Call the `DownloadPoisListAsync()` method from the `OnCreate()` activity life
    cycle callback.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`OnCreate()`活动生命周期回调中调用`DownloadPoisListAsync()`方法。
- en: Note that this chapter uses the Android device networking capabilities for downloading
    the data form a REST web service. The following sections in this chapter will
    cover how to make a network request fetch data from the server in detail.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，本章使用Android设备的网络功能从REST网络服务下载数据。本章的以下部分将详细介绍如何进行网络请求从服务器获取数据。
- en: 'Now for testing purposes, let''s add the following method that provides a dummy
    POI list object. Later in this chapter, we will remove this method while we integrate
    with a REST web service:'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在为了测试目的，让我们添加以下方法，该方法提供了一个虚拟的POI列表对象。在本章的后面部分，我们将集成REST网络服务时移除此方法：
- en: '[PRE23]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s add the following logic to the `downloadPoisAsync()` method to make
    our `POIApp` fully functional:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`downloadPoisAsync()`方法中添加以下逻辑，使我们的`POIApp`完全功能化：
- en: '[PRE24]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Notice the following in the preceding code:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下代码中的内容：
- en: The progress bar is shown to the user when the download starts. When the download
    is complete, the `progressBar` is hidden.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载开始时，向用户显示进度条。下载完成后，隐藏`progressBar`。
- en: Currently, the `GetPoiListTestData()` method simulates the network request and
    provides the list of POI objects.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目前，`GetPoiListTestData()`方法模拟网络请求并提供POI对象列表。
- en: Once the data download is complete, the `POIListViewAdapter` class is instantiated
    by passing the downloaded POI list result and then it is set to list view.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据下载完成后，通过传递下载的POI列表结果实例化`POIListViewAdapter`类，然后将其设置为列表视图。
- en: 'We have done a great deal of work so far! Let''s just build and run the app
    on the Android emulator or device. You will see the output, as shown in the following
    screenshot:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经做了大量的工作！现在，让我们在Android模拟器或设备上构建并运行应用程序。您将看到以下截图所示的输出：
- en: '![](img/vtcV96G4.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/vtcV96G4.jpg)'
- en: The `ListView` works great with the test data. Now it is the time to worry about
    consuming the real POI data from the REST web service. The following section will
    guide you through establishing an HTTP network request form the Android device.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListView`与测试数据配合得很好。现在，我们需要担心从REST网络服务中消耗真实的POI数据。以下部分将指导您通过Android设备建立HTTP网络请求。'
- en: Consuming the web service
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消耗互联网服务
- en: Until now, we have created the layout for the list view and list adapter; now
    it is the time to worry about how to consume the web service to download the data
    and to hook it up to the screen. The following section will walk you through the
    steps on how to download data asynchronously from the web service.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经为列表视图和列表适配器创建了布局；现在，我们需要担心如何消耗互联网服务以下载数据并将其连接到屏幕。以下部分将指导您如何从互联网服务异步下载数据。
- en: An introduction to web services
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 互联网服务简介
- en: Web services are one of the integral parts of the **World Wide Web** (**WWW**)
    infrastructure. It allows the server application to share the data or logic with
    connected clients via web protocols such as REST and SOAP using data formats,
    such as XML and JSON.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网服务是**万维网**（**WWW**）基础设施的组成部分之一。它允许服务器应用程序通过REST和SOAP等网络协议以及XML和JSON等数据格式，与连接的客户端共享数据或逻辑。
- en: Web services expose a set of **Application Programming Interfaces** (**APIs**)
    that provides a uniform data access mechanism for client applications. It doesn't
    matter which programming language the web service is written in; the client applications
    with different operating systems or different programming languages can access
    the services seamlessly, as long as they adhere to the web service API specification.
    For example, a web service that is written in Java and hosted on Apache Tomcat
    can be used by a .NET web form, iOS, or an Android application.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网服务公开了一组**应用程序编程接口**（**APIs**），为客户端应用程序提供统一的数据访问机制。无论互联网服务是用哪种编程语言编写的，只要客户端应用程序遵循互联网服务API规范，无论它们使用的是不同的操作系统或不同的编程语言，都可以无缝地访问服务。例如，用Java编写并托管在Apache
    Tomcat上的互联网服务可以被.NET网络表单、iOS或Android应用程序使用。
- en: SOAP and REST are the two standard web service architectures used vastly in
    the industry by larger players. Microsoft developed SOAP and REST was developed
    by W3C Technical Architecture Group. While SOAP brings its own protocol with additional
    security layers, the REST implementation is considerably easier. Companies such
    as Google and Microsoft are migrating most of their existing services to REST.
    Which web service architecture is better is an endless debate worth Googling;
    however, choosing the one that works for you is purely an architectural decision
    based on your requirements.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: SOAP和REST是两个在行业中广泛使用的标准互联网服务架构。Microsoft开发了SOAP，而REST是由W3C技术架构组开发的。虽然SOAP带来了自己的协议和额外的安全层，但REST实现要容易得多。像Google和Microsoft这样的公司正在将它们的大部分现有服务迁移到REST。哪个互联网服务架构更好是一个无休止的辩论，值得Google搜索；然而，选择适合您的架构纯粹是一个基于您需求的架构决策。
- en: The `POIApp` example code provided in this book will consume the web service
    developed in Java (JAX-RS) using the REST architecture. The following section
    will walk you through the steps on how to deploy and set up on your system for
    testing `POIApp`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 本书提供的`POIApp`示例代码将使用REST架构消耗用Java（JAX-RS）开发的互联网服务。以下部分将指导您如何部署和设置您的系统以测试`POIApp`。
- en: Deploying the POI web service
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署POI互联网服务
- en: The code bundle provided in this book includes the POI web service project code,
    which will be used for completing the remaining chapters in this book. The code
    bundle includes a *readme* file describing the steps required for deploying the
    POI Web service. The following section will walk you through the steps provided
    in the readme file and deploy the web service before you proceed with this chapter.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 本书提供的代码包包括POI Web服务项目代码，这些代码将用于完成本书剩余章节的内容。代码包包括一个*readme*文件，描述了部署POI Web服务所需的步骤。以下部分将指导您完成readme文件中的步骤，并在您继续本章之前部署Web服务。
- en: 'The POI web service sample application provides two APIs: one to fetch the
    list of POIs available on the server and the other to create a new POI record
    in the server database.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: POI Web服务示例应用程序提供了两个API：一个用于获取服务器上可用的POI列表，另一个用于在服务器数据库中创建新的POI记录。
- en: 'In this chapter, we will be using the following API specification for getting
    the list of POIs from the web server:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用以下API规范从Web服务器获取POI列表：
- en: '**Request method**: `GET`'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求方法**：`GET`'
- en: '**Resource URI**: `/com.packet.poiapp/api/poi/pois`'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源URI**：`/com.packet.poiapp/api/poi/pois`'
- en: '**Content-type**: `application/json`'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内容类型**：`application/json`'
- en: '**Accept-type**: `application/json`'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接受类型**：`application/json`'
- en: '**Response Body**:'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应体**：'
- en: '[PRE25]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Consuming REST web services asynchronously
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步消费REST Web服务
- en: Consuming REST web services in the Xamarin Android application is relatively
    easier than it looks. There are various framework classes, such as `WebClient`,
    `WebRequest`, `HttpWebRequest`, `HttpClient`, and other third-party libraries,
    such as `RestSharp` and `Service Stack`, that are available for Xamarin to consume
    REST web services.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin Android应用程序中消费REST Web服务比看起来要简单。有各种框架类，如`WebClient`、`WebRequest`、`HttpWebRequest`、`HttpClient`，以及其他第三方库，如`RestSharp`和`Service
    Stack`，可供Xamarin消费REST Web服务。
- en: For developing `POIApp`, we will taper our discussion to `HttpClient`. The `HttpClient`
    is newly introduced in .NET 4.5 and provides some of the advanced features, such
    as a strong type header, shared cache, cache control, and so on. The following
    section will walk you through the steps on how to use `HttpClient` to make an
    asynchronous web service request from the Xamarin Android application.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发`POIApp`时，我们将讨论的重点放在`HttpClient`上。`HttpClient`是.NET 4.5中新引入的，提供了一些高级功能，例如强类型头、共享缓存、缓存控制等。以下部分将指导您如何使用`HttpClient`从Xamarin
    Android应用程序中异步发起Web服务请求。
- en: Creating the POIService class
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建POIService类
- en: 'Now, we will create a standard C# class that abstracts all the logic to consume
    REST web services and will make our activity look much tidier. To create the new
    `POIService` class, perform the following steps:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个标准的C#类，该类抽象了所有用于消费REST Web服务的逻辑，从而使我们的活动看起来更加整洁。要创建新的`POIService`类，请执行以下步骤：
- en: Select the `POIApp` project in the **Solution** pad in Xamarin Studio.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Xamarin Studio的**解决方案**面板中选择`POIApp`项目。
- en: Right-click on it and select **New File**.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击并选择**新建文件**。
- en: On the left-hand side of the **New File** dialog box, select **General**.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**新建文件**对话框的左侧选择**通用**。
- en: At the top of the template list, in the middle of the dialog box, select **Empty
    Class(C#)**.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模板列表的顶部，在对话框的中间，选择**空类(C#)**。
- en: Enter the name `POIService` and click on **OK**.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入名称`POIService`并点击**确定**。
- en: 'Declare a string constant that represents the resource''s URI endpoint to access
    the POI web service for fetching the list of POIs available in the server. At
    this stage, I assume that the web service code is hosted on the local computer
    with port 8080\. In real time, your application will use the domain where the
    endpoint is hosted:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个表示资源URI端点的字符串常量，用于访问POI Web服务以获取服务器上可用的POI列表。在此阶段，我假设Web服务代码托管在本地计算机的8080端口上。在实际应用中，您的应用程序将使用端点所在的主机域：
- en: '[PRE26]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For any technical reasons/limitations you couldn''t complete the web service
    installation, you can still continue to test your application with Apiary mock
    feeds. For testing with mock feeds, you can use the following feed URL:'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于任何技术原因/限制，您无法完成Web服务安装，您仍然可以使用Apiary模拟数据继续测试您的应用程序。对于使用模拟数据测试，您可以使用以下数据源URL：
- en: '[PRE27]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Asynchronous programming with async and await
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用async和await进行异步编程
- en: Downloading data from the server is a long-running blocking operation, and it
    is recommended for mobile apps to perform all such long-running tasks off the
    main thread. For making a responsive and smooth user experience, mobile applications
    need to create a new thread for any long-running operations. Since the release
    of **.NET 4.5**, the `async` and `await` keywords are used to implement multi-threading
    easily, without getting your hands dirty in threads. The methods defined by the
    `async` and `await` keywords are often called the `async` methods.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 从服务器下载数据是一个长时间运行并阻塞的操作，对于移动应用来说，建议在主线程之外执行所有此类长时间运行的任务。为了实现响应和流畅的用户体验，移动应用需要为任何长时间运行的操作创建一个新的线程。自从
    **.NET 4.5** 发布以来，`async` 和 `await` 关键字被用来轻松实现多线程，而不必在线程上动手。由 `async` 和 `await`
    关键字定义的方法通常被称为 `async` 方法。
- en: 'The following are some of the key things you must know before implementing
    the `async` methods:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现 `async` 方法之前，你必须了解以下关键事项：
- en: The `async` keyword is used to notify the .NET language **Common Language Runtime**
    (**CLR**) to create a new thread of execution and execute tasks asynchronously.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`async` 关键字用于通知 .NET 语言 **公共语言运行时** (**CLR**) 创建一个新的执行线程并异步执行任务。'
- en: The `await` keyword automatically pauses the caller thread and executes the
    tasks on a new thread; once the task is finished, the control is returned. A single
    `async` method can have one or more `await` keywords.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`await` 关键字会自动暂停调用线程，并在新线程上执行任务；一旦任务完成，控制权将返回。单个 `async` 方法可以有一个或多个 `await`
    关键字。'
- en: The `async` method always returns `Task&lt;T&gt;`, where **T** represents the
    data type of the result expected after the execution. A void return type can be
    used when no result is expected.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`async` 方法始终返回 `Task<T>`，其中 **T** 代表执行后期望的结果的数据类型。当不需要结果时，可以使用 void 返回类型。'
- en: As a convention, Microsoft recommends the name of the `async` methods to suffix
    with async. However, this is not mandatory, but it helps to remind the caller
    to use the `await` keyword.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一种约定，Microsoft 建议将 `async` 方法的名称后缀为 `async`。然而，这并非强制性的，但它有助于提醒调用者使用 `await`
    关键字。
- en: 'Now that we understand the basics to create the async method, let''s define
    a method in the `POIService` class and name it `GetPOIListAsync`. The `GetPOIListAsync`
    method will be used to consume the REST web service asynchronously, deserialize
    the response in the POI list collection, and return the result back to the activity
    for displaying results in the list:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了创建异步方法的基本知识，让我们在 `POIService` 类中定义一个方法，并将其命名为 `GetPOIListAsync`。`GetPOIListAsync`
    方法将用于异步消费 REST 网络服务，反序列化 POI 列表集合中的响应，并将结果返回给活动以在列表中显示结果：
- en: '[PRE28]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Notice that the return type of the `GetPOIListAsync` method is `Task&lt;List&lt;PointOfInterest&gt;&gt;`,
    and the `List&lt;PointOfInterest&gt;` is the result expected on `POIListActivity`
    for rendering the data on the list view.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`GetPOIListAsync` 方法的返回类型是 `Task<List<PointOfInterest>>`，而 `List<PointOfInterest>`
    是在 `POIListActivity` 上渲染列表视图时期望的结果。
- en: The `GetPOIListAsync` method now creates an instance of `HttpClient`, sets the
    HTTP header accept type as `application/json`, and calls the `GetAsync()` method
    by passing the web service URL. The accept type header metadata tells the server
    about the response the media format client expects. The `GetAsync()` method initiates
    a GET request to the specified endpoint and returns the `HttpResponseMessage`
    instance.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetPOIListAsync` 方法现在创建了一个 `HttpClient` 实例，将 HTTP 头部接受类型设置为 `application/json`，并通过传递网络服务
    URL 调用 `GetAsync()` 方法。接受类型头部元数据告诉服务器客户端期望的响应媒体格式。`GetAsync()` 方法启动对指定端点的 GET
    请求，并返回 `HttpResponseMessage` 实例。'
- en: 'If the response status code is returned as a success **(** `200OK` **)**, we
    are good to proceed to fetch the contents. As we know from the web service specification,
    the response is a structured JSON string; we can retrieve the values by calling
    the `GetStringAsync` method. For the status code other than success, we can place
    the logic to handle the error case. In order to simplify this example, we will
    just print the error log on the console:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果响应状态码返回成功 **(** `200OK` **)**，我们可以继续获取内容。正如我们从网络服务规范中了解的那样，响应是一个结构化的 JSON
    字符串；我们可以通过调用 `GetStringAsync` 方法来检索值。对于除成功状态码之外的状态码，我们可以放置处理错误情况的逻辑。为了简化这个示例，我们将在控制台上打印错误日志：
- en: '[PRE29]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that the preceding `GetPOIListAsync` method used for consuming the REST
    web service requires the Internet permission. As we have already added the Internet
    permission, while downloading the image using the `UrlImageViewHelper` Xamarin
    component, we don't need to add the permission again.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面用于消费 REST 服务的 `GetPOIListAsync` 方法需要互联网权限。由于我们已经添加了互联网权限，在下载图片时使用 `UrlImageViewHelper`
    Xamarin 组件，我们不需要再次添加权限。
- en: The `await` keyword expects the download results to proceed further and hence,
    it waits for the ongoing download task to complete. Once the download task is
    completed, the POI web service response JSON string is assigned to a content variable.
    At this point, the string result has to be deserialized to the .NET object and
    the result has to be returned back to `POIListActivity`. The following section
    will guide you with the steps to deserialize the content string into a JSON object.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`await` 关键字期望下载结果继续进行，因此它等待当前的下载任务完成。一旦下载任务完成，POI 网络服务响应 JSON 字符串将被分配给一个内容变量。此时，字符串结果需要反序列化为
    .NET 对象，并将结果返回给 `POIListActivity`。以下部分将指导您如何将内容字符串反序列化为 JSON 对象。'
- en: 'While HttpClient in combination with `async` and `await` keyword provides a
    native API support for dealing with asynchronous network request, you can also
    take advantages of the powerful and yet popular framework such as Service Stack
    or Rest Sharp. Here are a few links that you can refer to:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 HttpClient 与 `async` 和 `await` 关键字结合提供了处理异步网络请求的本地 API 支持，但您也可以利用功能强大且流行的框架，如
    Service Stack 或 Rest Sharp。以下是一些您可以参考的链接：
- en: '[https://msdn.microsoft.com/en-us/library/hh191443.aspx](https://msdn.microsoft.com/en-us/library/hh191443.aspx)'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://msdn.microsoft.com/en-us/library/hh191443.aspx](https://msdn.microsoft.com/en-us/library/hh191443.aspx)'
- en: '[https://github.com/restsharp/RestSharp](https://github.com/restsharp/RestSharp)'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/restsharp/RestSharp](https://github.com/restsharp/RestSharp)'
- en: '[https://servicestack.net/](https://servicestack.net/)'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://servicestack.net/](https://servicestack.net/)'
- en: Serializing and deserializing using Json.NET
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Json.NET 进行序列化和反序列化
- en: 'Another important decision that we need to make while serializing and deserializing
    the JSON data is how we will get the response string converted to a .NET object
    and vice versa. There are a number of options available, including `DataContractJsonSerailzier`
    from .NET. Json.NET is an open source component library created by James Newton-King,
    and this is definitely worth considering because of the following reasons:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在序列化和反序列化 JSON 数据时，我们需要做出的另一个重要决定是如何将响应字符串转换为 .NET 对象，反之亦然。有多个选项可供选择，包括来自 .NET
    的 `DataContractJsonSerailzier`。Json.NET 是由 James Newton-King 创建的开源组件库，这绝对值得考虑，原因如下：
- en: It's small, fast, and reliable
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它体积小、速度快、可靠
- en: It's available as a free component in the Xamarin Component Store and via NuGet
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它作为免费组件在 Xamarin 组件商店和 NuGet 中可用
- en: It makes simple tasks extremely simple to accomplish
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使简单任务变得极其简单
- en: With these characteristics in mind, we will proceed by adding the Json.NET component
    to `POIApp` from the Xamarin Component Store. To add the Json.NET component, follow
    the same steps that we performed while adding the `UrlImageViewHelper` component.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些特性，我们将通过将 Json.NET 组件添加到 `POIApp` 从 Xamarin 组件商店中继续操作。要添加 Json.NET 组件，请遵循我们添加
    `UrlImageViewHelper` 组件时执行的相同步骤。
- en: Once the Json.NET component is added to the solution, the next step is to convert
    the response string and to make a list of `PointOfInterest` objects.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将 Json.NET 组件添加到解决方案中，下一步是将响应字符串转换为 `PointOfInterest` 对象的列表。
- en: 'Include the following namespace directives in the `POIListActivity.cs` file:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `POIListActivity.cs` 文件中包含以下命名空间指令：
- en: '[PRE30]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Declare a list collection in the `GetPOIListAsync()` method to hold the POI''s
    list response:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `GetPOIListAsync()` 方法中声明一个列表集合以保存 POI 列表响应：
- en: '[PRE31]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Initialize the `poiListData` list collection. Place the following code snippet
    in the `downloadPoisAsync()` method after the `Console.Out.WriteLine` statement:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `downloadPoisAsync()` 方法中 `Console.Out.WriteLine` 语句之后初始化 `poiListData` 列表集合。放置以下代码片段：
- en: '[PRE32]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, it is time to deserialize the JSON string to the .NET object. Notice that
    the response JSON string is an object with a key `pois` representing the array
    of the `PointOfInterest` objects. Add the following code snippet to the `GetPOIListAsync()`
    method to deserialize the string to the .NET object.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候将 JSON 字符串反序列化为 .NET 对象了。请注意，响应 JSON 字符串是一个具有 `pois` 键的对象，该键代表 `PointOfInterest`
    对象的数组。将以下代码片段添加到 `GetPOIListAsync()` 方法中以将字符串反序列化为 .NET 对象。
- en: 'The following line of code will convert the complete JSON response string to
    `JObject`:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行代码将完整的 JSON 响应字符串转换为 `JObject`：
- en: '[PRE33]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now fetch the values for the `pois` key and iterate through it to convert to
    the .NET list:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在获取 `pois` 键的值并遍历它以转换为 .NET 列表：
- en: '[PRE34]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `JToken` is a generic representation of the JSON value of any kind. It could
    be a string, object, array, property, and so on. The `ToList()` method returns
    the collections of the `JToken` objects. The `token.ToObject` method converts
    each of the poiJSON tokens to the `PointOfInterest` object type and adds it to
    the `poiListData` collection. Finally, we return the list result back to the caller.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`JToken` 是任何类型的 JSON 值的通用表示。它可以是一个字符串、对象、数组、属性等等。`ToList()` 方法返回 `JToken` 对象的集合。`token.ToObject`
    方法将每个 poiJSON 标记转换为 `PointOfInterest` 对象类型，并将其添加到 `poiListData` 集合中。最后，我们将列表结果返回给调用者。'
- en: Updating POIListActivity
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新 POIListActivity
- en: 'So far, we have downloaded the data, and we are ready to use the data in `POIListActivity`.
    Let''s do the following changes in `POIListActivity`:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经下载了数据，并且我们准备在 `POIListActivity` 中使用这些数据。让我们在 `POIListActivity` 中进行以下更改：
- en: Delete the `GetPoiListTestData()` method from the `POIListActivity` class.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `POIListActivity` 类中删除 `GetPoiListTestData()` 方法。
- en: 'Create an instance of `POIService` in the `DownloadPoisListAsync` method and
    call the `GetPOIListAsync` method:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `DownloadPoisListAsync` 方法中创建 `POIService` 的实例并调用 `GetPOIListAsync` 方法：
- en: '[PRE35]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We have done a great deal of work so far; now it's time to compile and run the
    app. Compile and run the application using the Android emulator based on the procedure
    we used in the previous chapters.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经做了很多工作；现在是时候编译并运行应用程序了。使用我们在前几章中使用的程序编译并运行应用程序。
- en: 'Bingo! You will notice that the app will download the data from the POI web
    service and display the list of POIs on the scrollable list view:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: Bingo！你会注意到应用程序将从 POI 网络服务下载数据并在可滚动的列表视图中显示 POI 列表：
- en: '![](img/SlfgXL9q.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![](img/SlfgXL9q.jpg)'
- en: Adding actions to ActionBar
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向ActionBar添加操作
- en: 'With Android 3.0 (Honeycomb, API level 11), Android introduced a uniform title,
    such as a widget that docks to the top of the screen, called **ActionBar**. It
    allows apps to add activity-specific actions to the top of the device screen,
    just below the status bar. We will define two actions for the `POIListActivity`
    class: `New`, to create a new POI, and `Refresh`, to refresh the cache of POIs
    from the device''s local storage.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Android 3.0（Honeycomb，API 级别 11）开始，Android 引入了一个统一标题，例如一个停靠在屏幕顶部的小部件，称为 **ActionBar**。它允许应用程序在设备屏幕顶部（状态栏下方）添加特定于活动的操作。我们将为
    `POIListActivity` 类定义两个操作：`新建`，用于创建新的 POI，以及 `刷新`，用于刷新设备本地存储中的 POI 缓存。
- en: 'The `Activity` class provides the following virtual methods that can be overridden
    to add actions:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`Activity` 类提供了以下虚拟方法，可以重写以添加操作：'
- en: Virtual Method
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟方法
- en: Description
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 描述
- en: '`OnCreateOptionsMenu`'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnCreateOptionsMenu`'
- en: It allows the creation of the actions either through API calls or through inflating
    an XML definition
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 它允许通过 API 调用或通过填充 XML 定义来创建操作
- en: '`OnOptionsItemSelected`'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnOptionsItemSelected`'
- en: It is called when an action in `ActionBar` is clicked
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击 `ActionBar` 中的操作时调用
- en: Defining the menu XML file
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义菜单 XML 文件
- en: Actions can be defined in a menu XML file that resides in the `Resources/menu`
    folder, or it can be created programmatically using API calls. We will define
    the **New** and **Refresh** actions in an XML file named `POIListViewMenu.xml`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在位于 `Resources/menu` 文件夹中的菜单 XML 文件中定义操作，或者可以通过 API 调用程序化创建。我们将在名为 `POIListViewMenu.xml`
    的 XML 文件中定义 **新建** 和 **刷新** 操作。
- en: 'To create `POIListViewMenu.xml`, perform the following steps:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 `POIListViewMenu.xml`，请执行以下步骤：
- en: Select the `Resources` folder in `POIApp`, right-click on it, and navigate to
    **Add** | **New Folder**.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `POIApp` 中选择 `Resources` 文件夹，右键单击它，然后导航到 **添加** | **新建文件夹**。
- en: Name the folder menu.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件夹命名为菜单。
- en: Select the menu folder, right-click on it, and navigate to **Add** | **New File**.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择菜单文件夹，右键单击它，然后导航到 **添加** | **新建文件**。
- en: Navigate to **XML** | **Empty XML** file, enter `POIListViewMenu.xml` for the
    name, and click on **New**.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 **XML** | **空 XML** 文件，输入 `POIListViewMenu.xml` 作为名称，然后单击 **新建**。
- en: 'You now need to fill in the definitions for the two actions we identified.
    Unfortunately, Xamarin Studio does not contain a template for menu XML files,
    so you have to hunt the format down from the Android documentation or online examples.
    The following code contains definitions for `actionNew` and `actionRefresh`:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在需要填写我们确定的两个操作的定义。不幸的是，Xamarin Studio 不包含菜单 XML 文件的模板，因此您必须从 Android 文档或在线示例中查找格式。以下代码包含了
    `actionNew` 和 `actionRefresh` 的定义：
- en: '[PRE36]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Note that from the menu definition, we have referenced two new drawables: `ic_new`
    and `ic_refresh`. We need to add these images to the project in the same way that
    we did for the `ic_app` icon in Chapter 3, *Creating the Points of Interest App*.
    The images can be found in the `drawable` folder present in the `assets` location.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，从菜单定义中，我们已经引用了两个新的可绘制资源：`ic_new` 和 `ic_refresh`。我们需要以与第 3 章“创建兴趣点应用”中为 `ic_app`
    图标所做的方式相同，将这些图像添加到项目中。这些图像可以在 `assets` 位置下的 `drawable` 文件夹中找到。
- en: Setting menus in OnCreateOptionsMenu()
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 `OnCreateOptionsMenu()` 中设置菜单
- en: 'The `OnCreateOptionsMenu()` method is called to give an opportunity to the
    `Activity` parameter to define actions for the `ActionBar`. The `Activity` class
    provides a `MenuInflater` method, which reads the XML definition file and places
    the action defined on the ActionBar. The following code shows the implementation
    from the code bundle:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnCreateOptionsMenu()` 方法被调用，以给 `Activity` 参数一个定义 `ActionBar` 上的操作的机会。`Activity`
    类提供了一个 `MenuInflater` 方法，它读取 XML 定义文件并将定义在 `ActionBar` 上的操作放置进去。以下代码显示了代码块中的实现：'
- en: '[PRE37]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Handling selection in OnOptionsItemSelected()
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 `OnOptionsItemSelected()` 中处理选择
- en: 'The `OnOptionsItemSelected()` method is called whenever an action in the ActionBar
    is clicked and an instance of `IMenuItem` is passed in. The `IMenuItem ItemId`
    instance corresponds to the ID specified in the item definition and can be used
    to determine which action was clicked on. The following code shows the implementation
    of `OnOptionsItemSelected()` from the code bundle:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击 ActionBar 中的操作时，会调用 `OnOptionsItemSelected()` 方法，并传递一个 `IMenuItem` 实例。`IMenuItem
    ItemId` 实例对应于项目定义中指定的 ID，可用于确定点击了哪个操作。以下代码显示了代码块中 `OnOptionsItemSelected()` 的实现：
- en: '[PRE38]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note that we have simply created a placeholder for `actionNew` and placed two
    method calls for `actionRefresh`.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们只是为 `actionNew` 创建了一个占位符，并为 `actionRefresh` 放置了两个方法调用。
- en: The `DownloadPoisListAsync()` method is called to download and refresh the data
    on the list.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `DownloadPoisListAsync()` 方法来下载并刷新列表上的数据。
- en: 'Let''s now run the `POIApp` and notice the two buttons, **Add** and **Refresh**,
    on the POI list activity title:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行 `POIApp` 并注意 POI 列表活动标题上的两个按钮，**添加** 和 **刷新**：
- en: '![](img/IMUA78SR.jpg)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/IMUA78SR.jpg)'
- en: Handling the ListView click event
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理 ListView 点击事件
- en: When a user clicks on a row, the POI app will navigate to a detailed view in
    order to allow you to view and update the complete set of information. We will
    build the detailed view in the next chapter but will go ahead and discuss handling
    clicks now.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '当用户点击一行时，POI 应用将导航到一个详细视图，以便您查看和更新完整的信息集。我们将在下一章构建详细视图，但现在我们将讨论如何处理点击。 '
- en: 'Clicks can be handled using a traditional event handler. The `ListView` item
    provides an `ItemClick` event handler, which accepts a `ListView.ItemClickEventArgs`
    parameter. The `ListView.ItemClickEventArgs` parameter provides the following
    information that can be used for processing the event:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用传统的事件处理器来处理点击。`ListView` 项目提供了一个 `ItemClick` 事件处理器，它接受一个 `ListView.ItemClickEventArgs`
    参数。`ListView.ItemClickEventArgs` 参数提供了以下信息，可用于处理事件：
- en: Property
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 属性
- en: Description
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 描述
- en: '`ID`'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '`ID`'
- en: It is the ID for the data associated with the row that was clicked. This would
    be the value returned from `GetItemId()`.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 它是点击的行的相关数据的 ID。这将是从 `GetItemId()` 返回的值。
- en: '`Position`'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '`位置`'
- en: It is the position in the `ListView` item of the row that was clicked.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 它是被点击行的 `ListView` 项中的位置。
- en: '`View`'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`视图`'
- en: It is the view associated with the row that was clicked. This would be the view
    returned from `GetView()`.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 它是被点击行的相关视图。这将是从 `GetView()` 返回的视图。
- en: '`Parent`'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`父级`'
- en: It is the `AdapterView` architecture that contains the row that was clicked.
    In our case, it is `ListView`.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 它是包含被点击行的 `AdapterView` 架构。在我们的例子中，它是 `ListView`。
- en: 'Create an event handler in `POIListActivity` to process click events on the
    `ListView` item. We are not ready to add the navigation, as we have not yet created
    our detailed view, so we will just show you a `Toast` message. The following code
    is from the code bundle:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `POIListActivity` 中创建一个事件处理器来处理 `ListView` 项的点击事件。由于我们尚未创建详细视图，所以我们现在只展示一个
    `Toast` 消息。以下代码来自代码块：
- en: '[PRE39]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We also need to hook up the event handler. Add the following line of code to
    the end of the `OnCreate` method:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要连接事件处理器。将以下行代码添加到 `OnCreate` 方法的末尾：
- en: '[PRE40]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Run the `POIApp` project and click on a **POI**; notice that the POI name of
    the corresponding row is printed on the console.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `POIApp` 项目并点击一个 **POI**；注意相应的行中的 POI 名称被打印在控制台上。
- en: Handling no network condition
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理无网络条件
- en: The network conditions in mobile devices are uncertain. Sometimes, a user manually
    disables the network connections or they are unavailable due to various external
    reasons. For applications that use network data, you must handle different network
    states. Applications should react gracefully by showing an appropriate message
    to the user.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 移动设备中的网络条件是不确定的。有时，用户会手动禁用网络连接，或者由于各种外部原因而不可用。对于使用网络数据的应用程序，您必须处理不同的网络状态。应用程序应通过向用户显示适当的消息来优雅地做出反应。
- en: In `POIApp`, before starting the download, we must confirm the availability
    of the network data connections. If the network is unavailable, we should notify
    the user with an appropriate message otherwise continue with the download request.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `POIApp` 中，在开始下载之前，我们必须确认网络数据连接的可用性。如果网络不可用，我们应该使用适当的消息通知用户，否则继续进行下载请求。
- en: The `ConnectivityManager` class present in the `System.Net` package can be used
    to query the state of device network connectivity. This class can also be used
    to monitor the network connection and notify when there is a change in the network
    state. In our case, we will just query the network information just to know that
    the network is available.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 存在于 `System.Net` 包中的 `ConnectivityManager` 类可以用来查询设备网络连接的状态。此类还可以用来监控网络连接，并在网络状态发生变化时通知。在我们的案例中，我们只是查询网络信息，以便知道网络是可用的。
- en: 'Accessing the network state using the `ConnectivityManager` class requires
    `ACCESS_NETWORK_STATE` user permission in the `AndroidManifest.xml` file. Follow
    the same steps as we did earlier while adding the Internet permission, or alternatively,
    you can directly add the following code to the `AndroidManifest.xml` source editor:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ConnectivityManager` 类访问网络状态需要在 `AndroidManifest.xml` 文件中请求 `ACCESS_NETWORK_STATE`
    用户权限。按照我们之前添加互联网权限时的相同步骤进行，或者您可以直接将以下代码添加到 `AndroidManifest.xml` 源编辑器中：
- en: '[PRE41]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now add the following utility method to the `POIService` class that reads the
    network information and returns `true` if the device is connected:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将以下实用方法添加到 `POIService` 类中，该方法读取网络信息，如果设备已连接则返回 `true`：
- en: '[PRE42]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now do the following changes to the `DownloadPoisListAsync` method in the `POIService`
    class:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 现在请对 `POIService` 类中的 `DownloadPoisListAsync` 方法进行以下更改：
- en: '[PRE43]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: You must be surprised about the `Toast`. Well, we will learn about it in the
    next section.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 你一定会对 `Toast` 感到惊讶。嗯，我们将在下一节中学习它。
- en: Toast
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Toast
- en: The `Toast` is a noninteractive, auto disposable view used to display a short
    message for a specified period of time and disposes itself. Android recommends
    that you use `Toast` only to notify the user, where the user's attention is not
    mandate. For any such notification that requires the user's attention or interaction,
    consider using dialog.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '`Toast` 是一个非交互式、自动可丢弃的视图，用于在指定时间内显示一条简短的消息，并自行销毁。Android 推荐您仅使用 `Toast` 来通知用户，在这种情况下，用户的注意力不是强制性的。对于任何需要用户注意或交互的通知，请考虑使用对话框。'
- en: 'Creating a `Toast` is simple, all you have to do is to call the `MakeText()`
    static method by passing three parameters: the application context, message to
    be shown, and the time duration for the `Toast` to be shown. The time duration
    is a non-negative integer value in milliseconds, but it is recommended that you
    use the standard `Long` and `Short` constants defined in the `ToastLength` enum.
    The `MakeText()` method initializes the Toast with the given properties and returns
    a `Toast` instance on which we can call the `Show()` method to display `Toast`.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`Toast`很简单，您只需通过传递三个参数调用`MakeText()`静态方法：应用程序上下文、要显示的消息以及`Toast`显示的时间长度。时间长度是一个非负整数，单位为毫秒，但建议您使用在`ToastLength`枚举中定义的标准`Long`和`Short`常量。`MakeText()`方法使用给定的属性初始化`Toast`，并返回一个`Toast`实例，我们可以调用其`Show()`方法来显示`Toast`。
- en: 'In the preceding code snippet, we are displaying the `Toast` message when the
    device is offline. The following code depicts calls to the `MakeText()` and `Show()`
    methods to display `Toast` on the `Delete` action:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们在设备离线时显示`Toast`消息。以下代码展示了调用`MakeText()`和`Show()`方法在`Delete`操作上显示`Toast`：
- en: '[PRE44]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Summary
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered a lot about how to create user interface elements
    using different layout managers and widgets such as `TextView`, `ImageView`, `ProgressBar`,
    and `ListView`.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细介绍了如何使用不同的布局管理器和控件（如`TextView`、`ImageView`、`ProgressBar`和`ListView`）来创建用户界面元素。
- en: We also covered how to consume REST web services using the Xamarin.Android `HttpClient`
    class, deserialize the JSON response using the Json.NET component, and populate
    the data on the screen.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了如何使用Xamarin.Android的`HttpClient`类来消费REST网络服务，使用Json.NET组件反序列化JSON响应，并在屏幕上填充数据。
- en: The next chapter will introduce you to some more view groups and build more
    complex UIs. We will continue with `POIApp` by adding a detailed view and allow
    the user the option to create or delete a Point Of Interest.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将向您介绍更多视图组，并构建更复杂的用户界面。我们将继续使用`POIApp`，添加详细视图，并允许用户创建或删除兴趣点。
