- en: Chapter 7. Adding Reality to Games
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 为游戏添加现实感
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Creating physics bodies in the world
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在世界中创建物理体
- en: Physics joints
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理关节
- en: Detecting contact and collisions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测接触和碰撞
- en: Introduction
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'In the previous chapters, you learned about the anatomy of physics simulation
    in games. We have explored various sections of the Physics engine, including its
    integration with games and playing with the basics of the game engine. You have
    learned the ways to create static and dynamic bodies as well. Now, in this chapter,
    our major focus will be on adding some more reality to games by the advanced level
    of physics integration. This includes playing with lots of physics bodies tied
    together with joints. You will also learn the ways to detect the collision between
    two physics bodies. The overall agenda will be to create a mini game in the chapter,
    which will hold together all the recipes and will help in better understanding
    of these sections. The game will be divided into three the following parts:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学习了游戏物理模拟的结构。我们已经探索了物理引擎的各个部分，包括其与游戏的集成以及游戏引擎基础的操作。你还学习了创建静态和动态体的方法。现在，在本章中，我们将重点关注通过高级物理集成为游戏添加更多现实感。这包括与关节连接的许多物理体的操作。你还将学习检测两个物理体之间碰撞的方法。整体目标是在本章中创建一个迷你游戏，它将包含所有食谱，并有助于更好地理解这些部分。游戏将分为以下三个部分：
- en: Creating the game holding a physics world with some physics bodies
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建包含一些物理体的物理世界游戏
- en: Then we will move forward and join those physics bodies with various types of
    joints
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们将继续前进，使用各种类型的关节将物理体连接起来
- en: Then, finally, you will learn various ways to detect the collision and contact
    between the various physics bodies in the world
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，最终，你将学习各种检测世界中各种物理体之间碰撞和接触的方法
- en: Creating physics bodies in the world
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在世界中创建物理体
- en: In this recipe, we will be creating a fresh game project and will set it up
    to be used in all the recipes. The game project will hold together the creation
    of a physics world along with some physics body objects. We will be using these
    physics objects to add joints between them.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将创建一个新的游戏项目，并将其设置成适用于所有食谱。这个游戏项目将包含创建物理世界和一些物理体对象。我们将使用这些物理对象在它们之间添加关节。
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'To develop a mini game using the physics engine, start by creating a new project.
    Open Xcode and go to **File** | **New** | **Project** and navigate to **iOS**
    | **Application** | **SpriteKit Game**. In the popup, provide the product name
    as `Physics Joints` and navigate to **Devices** | **iPhone** and click on **Next**
    as shown in the following screenshot:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要开发一个使用物理引擎的迷你游戏，首先创建一个新的项目。打开Xcode，转到**文件** | **新建** | **项目**，导航到**iOS** |
    **应用程序** | **SpriteKit Game**。在弹出的窗口中，将产品名称指定为`Physics Joints`，导航到**设备** | **iPhone**，并点击**下一步**，如下面的截图所示：
- en: '![Getting ready](img/00106.jpeg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/00106.jpeg)'
- en: Click on **Next** and save the project on your hard drive.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**下一步**，并将项目保存到你的硬盘上。
- en: 'Once the project is saved, you should be able to see project settings. In this
    project settings page, just uncheck the **Portrait** from the **Device Orientation**
    section as we are supporting only landscape mode for this game. The final screen
    should look something similar to following screenshot:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 保存项目后，你应该能够看到项目设置。在这个项目设置页面中，只需取消选中**设备方向**部分中的**纵向**，因为我们只支持本游戏的横屏模式。最终屏幕应类似于以下截图：
- en: '![Getting ready](img/00107.jpeg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/00107.jpeg)'
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Now our project template is ready to hold together some advanced physics behaviors.
    To accommodate these behaviors, we also need to tweak some code in the project.
    Perform the following steps to update the project as per our requirements:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的项目模板已经准备好包含一些高级物理行为。为了适应这些行为，我们还需要在项目中调整一些代码。按照以下步骤更新项目以满足我们的要求：
- en: 'Open the `GameScene.m` file available with the code bundle of this chapter;
    this class creates a scene that will be plugged into the game. Remove all the
    code from this class and just add the following function:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开本章代码包中可用的`GameScene.m`文件；这个类创建了一个将被插入到游戏中的场景。从这个类中删除所有代码，并仅添加以下函数：
- en: '[PRE0]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This `initWithSize` method creates an empty scene with specified size. The code
    written inside the `init` function changes the background color of the scene.
    We can tweak the rgb to get the desired background color.
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个`initWithSize`方法创建了一个指定大小的空场景。`init`函数中编写的代码改变了场景的背景颜色。我们可以调整RGB值以获得所需的背景颜色。
- en: 'Now open `GameViewController.m`. Remove all the code from this file and add
    the following function:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开`GameViewController.m`文件。从该文件中删除所有代码，并添加以下函数：
- en: '[PRE1]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now compile and run the app. You should be able to see the background color
    correctly. This will look something similar to following screenshot:![How to do
    it...](img/00108.jpeg)
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在编译并运行应用程序。你应该能够正确地看到背景颜色。这看起来类似于以下截图：![如何操作...](img/00108.jpeg)
- en: 'Now we have the background color in place, so let''s add the gravity to the
    world. Open `GameScene.m` and add the following line of code in the end of the
    `initWithSize` method:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经设置了背景颜色，所以让我们向世界添加重力。打开`GameScene.m`文件，并在`initWithSize`方法的末尾添加以下代码行：
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This line of code will set the gravity of the world to -0.5, which means all
    the physics objects will experience a force towards the ground in the game scene.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这行代码将设置世界的重力为-0.5，这意味着所有物理对象在游戏场景中都将受到向地面的力。
- en: 'Now we have applied some gravitational force to make the objects pulled towards
    the ground. So it''s important to make some boundary to the world, which will
    hold all the objects of the world and prevent them from going off the screen.
    Add the following line of code to add the invisible boundary around the screen
    to hold the physics objects:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经应用了一些重力，使物体被拉向地面。因此，为世界添加一些边界是很重要的，这将保持世界中的所有物体，并防止它们离开屏幕。添加以下代码行以在屏幕周围添加不可见的边界以保持物理对象：
- en: '[PRE3]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the first line, we are creating an edge-based physics boundary object with
    a screen-size frame. This type of physics body does not have any mass or volume
    and they also remain unaffected by forces and impulses. Then we associate the
    object with the physics body of the scene. In the last line, we change the friction
    of the body to 0, to make interaction between objects and the boundary surface
    lossless.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一行，我们创建了一个基于屏幕大小的框架的边缘物理边界对象。这种物理体没有质量或体积，它们也不会受到力和冲量的影响。然后我们将对象与场景的物理体关联起来。在最后一行，我们将物体的摩擦力更改为0，以使物体与边界表面的交互无损耗。
- en: 'Now we are all set to create physics bodies in the world. Add the following
    method just after the `initWithSize` method:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经准备好在世界上创建物理体。在`initWithSize`方法之后添加以下方法：
- en: '[PRE4]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is the update method that will be called in each frame of the game execution.
    So all the actions that need regular updates will be coded inside this method.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是将在游戏执行过程中的每一帧调用的更新方法。因此，所有需要定期更新的操作都将在这个方法中编码。
- en: It's time to create physics objects in the world. All the physics objects are
    referred to as bodies. Now add the following method to create the bodies in the
    physics world.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候在世界上创建物理对象了。所有物理对象都被称为体。现在添加以下方法来在物理世界中创建体。
- en: '[PRE5]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding code will create two physics bodies, one rectangle and one square.
    We have adjusted the bodies' positions relative to each other.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码将创建两个物理体，一个矩形和一个正方形。我们已经调整了物体相对于彼此的位置。
- en: 'Now, add the following line of code at the end of the `initWithSize` method
    to add the physics bodies in the game scene:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`initWithSize`方法的末尾添加以下代码行以在游戏场景中添加物理体：
- en: '[PRE6]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here we are creating the bodies by calling the instance method inside `initWithSize`.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们通过调用`initWithSize`中的实例方法来创建物体。
- en: Now, compile and run the app. You should be able to see the two physics bodies
    created in the world and they will fall to the ground because of gravity. This
    will look something similar to following screenshot:![How to do it...](img/00109.jpeg)
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编译并运行应用程序。你应该能够看到在世界上创建的两个物理体，并且由于重力作用，它们将落向地面。这看起来类似于以下截图：![如何操作...](img/00109.jpeg)
- en: Physics joints
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物理关节
- en: We have already seen lots of interesting features of the physics engine. However,
    we can make our games even more interesting by connecting the physics bodies with
    each other using joints. All the physics simulation and forces will be applied
    on the bodies after considering the way they are joined together.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了物理引擎的许多有趣特性。然而，我们可以通过使用关节将物理体相互连接来使我们的游戏更加有趣。所有物理模拟和力都将考虑它们连接的方式后应用于体上。
- en: Getting ready
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'There are various ways of joining two physics bodies together. They vary based
    on the places and the location of the bodies that are joined. Joints are divided
    into the following types based on the ways they connect bodies with each other:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 将两个物理体连接在一起的方法有很多种。它们根据连接的物体位置和位置而有所不同。根据连接物体的方式，关节被分为以下类型：
- en: '**Pin Joint**: This type of joint joins/pins two physics together such that
    they both can independently rotate around their anchor point. The joint will look
    something similar to following diagram:![Getting ready](img/00110.jpeg)'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**销轴**：这种类型的关节将两个物理体连接/固定在一起，这样它们都可以独立地围绕它们的锚点旋转。关节看起来类似于以下图示：![准备中](img/00110.jpeg)'
- en: '**Limit Joint**: In this type of joints the bodies always maintain the fix
    maximum distance from each other. This is something like the bodies are connected
    to each other with a rote with a fixed maximum distance which is the length of
    the rope.![Getting ready](img/00111.jpeg)'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**限制关节**：在这种类型的关节中，两个物体总是保持彼此之间的最大固定距离。这就像两个物体通过一根固定最大距离的绳子连接在一起。![准备中](img/00111.jpeg)'
- en: '**Spring Joint**: This type of joint attaches two bodies as if they were connected
    to each other with a spring. This makes them behave in a perfectly elastic manner.
    The length of the spring can be defined by the initial distance between two bodies.![Getting
    ready](img/00112.jpeg)'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹簧关节**：这种类型的关节将两个物体连接起来，就像它们通过弹簧连接在一起一样。这使得它们以完美的弹性方式行为。弹簧的长度可以通过两个物体之间的初始距离来定义。![准备中](img/00112.jpeg)'
- en: '**Sliding Joint**: This type of joint allows to bodies to slide with respect
    to each other. The sliding axis can be explicitly defined by the user.![Getting
    ready](img/00113.jpeg)'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**滑动关节**：这种类型的关节允许两个物体相对于彼此滑动。滑动轴可以由用户明确定义。![准备中](img/00113.jpeg)'
- en: '**Fixed Joint**: This type of joint fuses the two physics bodies with each
    other through a provided reference point. These joints can be used to create complex
    objects, which can be broken into pieces later.![Getting ready](img/00114.jpeg)'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**固定关节**：这种类型的关节通过提供的参考点将两个物理体融合在一起。这些关节可以用来创建复杂物体，这些物体以后可以被分解成碎片。![准备中](img/00114.jpeg)'
- en: How to do it…
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Now we will open our working project again to integrate and implement all types
    of joints in our project. The following steps will provide the step-by-step ways
    to implement the joints and understand them in more depth.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将再次打开我们的工作项目，以集成和实现项目中所有类型的关节。以下步骤将提供逐步实现关节和理解它们的更深入的方法。
- en: 'To implement the pin joint, open the `GameScene.m` file and add the following
    function in it:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现销轴，打开`GameScene.m`文件，并在其中添加以下函数：
- en: '[PRE7]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the first five lines of code, we are creating a rectangular sprite with a
    physics body. We have also specified the collision and the category mask for this
    sprite.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在代码的前五行中，我们创建了一个带有物理体的矩形精灵。我们也为这个精灵指定了碰撞和类别掩码。
- en: Similarly, in the following lines of code, we will create square sprite with
    the physics body attached. For this sprite also, we are specifying the category
    and the collision masks.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类似地，在以下代码行中，我们将创建一个带有物理体的正方形精灵。对于这个精灵，我们也指定了类别和碰撞掩码。
- en: Then, finally, in last three lines of code, we are attaching the two bodies
    to each other through a pin joint. We've created an object of the `SKPhysicsJointPin`
    class and provided both the rectangle and square bodies to it along with the anchor
    point from which they will be rotating around each other.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，最后，在代码的最后三行中，我们将两个物体通过销轴连接在一起。我们创建了一个`SKPhysicsJointPin`类的对象，并将矩形和正方形物体以及它们将围绕其旋转的锚点提供给它。
- en: 'Now, replace the `createPhysicsBodiesOnScene` function call with `createPinJointOnScene`.
    Add the following code at the end of the `init` function:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`createPhysicsBodiesOnScene`函数调用替换为`createPinJointOnScene`。在`init`函数的末尾添加以下代码：
- en: '[PRE8]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The final function should look something similar to following screenshot:'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最终的函数看起来应该类似于以下截图：
- en: '![How to do it…](img/00115.jpeg)'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/00115.jpeg)'
- en: Now, compile and run the project and you should be able to see both the physics
    bodies attached with the pin joint. You can see them attached to each other through
    the anchor point.![How to do it…](img/00116.jpeg)
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编译并运行项目，你应该能够看到通过销轴连接的两个物理体。你可以看到它们通过锚点相互连接。![如何操作…](img/00116.jpeg)
- en: 'Now we will implement the fixed joint; open the `GameScene.m` file, and add
    the following function to implement the fixed joint:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将实现固定连接；打开`GameScene.m`文件，并添加以下函数以实现固定连接：
- en: '[PRE9]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, we have attached two physics bodies together with a fixed joint. In the
    last function, we have provided two bodies and the anchor point to which they
    are attached.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们已经使用固定连接将两个物理体连接在一起。在上一个函数中，我们提供了两个体以及它们所连接的锚点。
- en: 'Now, replace the `createPinJointOnScene` function call with `createFixedJointOnScene`.
    Add the following code in the end of the `init` function:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`createPinJointOnScene`函数调用替换为`createFixedJointOnScene`。在`init`函数的末尾添加以下代码：
- en: '[PRE10]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, compile and run the project and you should be able to see both the physics
    bodies attached by the fixed joint. You will observe that the bodies are attached
    together with the specified anchor point.![How to do it…](img/00117.jpeg)
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编译并运行项目，你应该能够看到两个物理体通过固定连接连接在一起。你会观察到，两个体通过指定的锚点连接在一起。![如何操作…](img/00117.jpeg)
- en: 'Now, to implement the sliding joint in our sample project, open the `GameScene.m`
    file and add the following function at the end:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，要在我们的示例项目中实现滑动连接，打开`GameScene.m`文件，并在末尾添加以下函数：
- en: '[PRE11]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now you will observe that we are creating two physics bodies and in the last
    section we are joining both of them using the slide joint. However, to see slide
    joint in action, we will have to apply impulses on the square body. Add the following
    function to apply an impulse:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你会注意到我们正在创建两个物理体，在最后一个部分中，我们使用滑动连接将它们连接起来。然而，为了看到滑动连接的效果，我们将在正方形体上应用冲量。添加以下函数以应用冲量：
- en: '[PRE12]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To add the impulse implementation, we will have to add the following line of
    code at the end of the `createSlidingJointOnScene` function.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加冲量实现，我们将在`createSlidingJointOnScene`函数的末尾添加以下代码行。
- en: '[PRE13]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now the square body will experience the impulse every 5 seconds.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，正方形体会每5秒经历一次冲量。
- en: 'Now, replace the `createFixedJointOnScene` function call with `createSlidingJointOnScene`.
    Add the following code at the end of the `init` function:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`createFixedJointOnScene`函数调用替换为`createSlidingJointOnScene`。在`init`函数的末尾添加以下代码：
- en: '[PRE14]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, compile and run the project and you should be able to see both the physics
    bodies sliding over each other.![How to do it…](img/00118.jpeg)
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编译并运行项目，你应该能够看到两个物理体相互滑动。![如何操作…](img/00118.jpeg)
- en: 'Now we will head towards implementing the spring joint in our sample project.
    Open the `GameScene.m` file and add the following function at the end of the file:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将着手在我们的示例项目中实现弹簧连接。打开`GameScene.m`文件，并在文件末尾添加以下函数：
- en: '[PRE15]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To apply a spring joint between two physics bodies, we have provided two physics
    bodies along with two anchor points as the function parameters. We can also provide
    additional parameters such as damping and frequencies.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要在两个物理体之间应用弹簧连接，我们已提供两个物理体以及两个锚点作为函数参数。我们还可以提供额外的参数，例如阻尼和频率。
- en: 'Now, replace the `createSlidingJointOnScene` function call with `createSpringJointOnScene`.
    Add the following code at the end of the `init` function:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`createSlidingJointOnScene`函数调用替换为`createSpringJointOnScene`。在`init`函数的末尾添加以下代码：
- en: '[PRE16]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now compile and run the project and you should be able to see both the physics
    bodies sliding over each other.![How to do it…](img/00119.jpeg)
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编译并运行项目，你应该能够看到两个物理体相互滑动。![如何操作…](img/00119.jpeg)
- en: 'Our next type of joint is the limit joint in our sample project. Now open the
    `GameScene.m` file and add the following function at the end of the file:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在示例项目中接下来的一种连接类型是极限连接。现在打开`GameScene.m`文件，并在文件末尾添加以下函数：
- en: '[PRE17]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the second last section, we are applying the limit joint on both the physics
    bodies that we have created. To apply a limit joint, we have to pass both the
    bodies along with the anchor points that create the joint. Now, when the joint
    object is initialized, we can add the joint to the physics world.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在倒数第二个部分，我们在我们创建的两个物理体上应用了极限连接。要应用极限连接，我们必须传递两个体以及创建连接的锚点。现在，当连接对象初始化后，我们可以将连接添加到物理世界中。
- en: As we have seen earlier in sliding joint, an extra impulse has been applied
    on one of the bodies. Similarly, here also we have to apply the impulse on the
    square body to test the limit joint behavior.
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如我们之前在滑动连接中看到的，在其中一个体上应用了额外的冲量。同样，这里我们也要在正方形体上应用冲量以测试极限连接的行为。
- en: 'Now, replace the `createSpringJointOnScene` function call with `createLimitJointOnScene`.
    Add the following code at the end of the `init` function:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`createSpringJointOnScene`函数调用替换为`createLimitJointOnScene`。在`init`函数的末尾添加以下代码：
- en: '[PRE18]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now compile and run the project and you should be able to see both the physics
    bodies sliding over each other.![How to do it…](img/00120.jpeg)
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在编译并运行项目，你应该能够看到两个物理体相互滑动。[如何做到这一点…](img/00120.jpeg)
- en: Detecting contact and collisions
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测接触和碰撞
- en: We apply physics simulation to the bodies by adding the `SKPhysicsBody` function
    to a node. While the scene processes each frame, it performs all the physics-related
    calculations for all the bodies in the scene. It also calculates all the custom
    forces that are applied on any body in the scene, which eventually gives the realistic
    effects in the game. Collision detection is an important part while developing
    any game in the real world because in almost all games we check for the collision
    of two bodies. For example, in any warfare game, we may need to check whether
    a bullet has collided with the player.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在节点上添加`SKPhysicsBody`函数来对节点应用物理模拟。当场景处理每一帧时，它为场景中的所有物理体执行所有与物理相关的计算。它还计算场景中任何物理体上施加的所有自定义力，这最终在游戏中产生逼真的效果。在现实世界的任何游戏中开发时，碰撞检测都是一个重要的部分，因为在几乎所有的游戏中，我们都会检查两个物理体的碰撞。例如，在任何战争游戏中，我们可能需要检查子弹是否与玩家发生了碰撞。
- en: Getting ready
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'There are various shapes for the physics bodies that can be used to apply physics
    to a scene. These shapes are defined as the personal space of the node. When the
    shape of one node intersects with the shape of another node, the `-didBeginContact`
    method is invoked and physics may be applied. Now, to implement the collision
    detection, we will have to understand the following properties of the physics
    bodies:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 物理体有多种形状，可以用来将物理应用到场景中。这些形状被定义为节点的个人空间。当一个节点的形状与另一个节点的形状相交时，会调用`-didBeginContact`方法，并可能应用物理。现在，为了实现碰撞检测，我们需要了解物理体的以下属性：
- en: '`categoryBitMask`: This property defines the category of the physics body.
    We can have custom categories depending on our requirement. For example, in a
    warfare game, we can have player, bullets, and enemies as the categories. All
    the physics bodies can be based on these categories.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`categoryBitMask`：这个属性定义了物理体的类别。我们可以根据需求有自定义的类别。例如，在战争游戏中，我们可以有玩家、子弹和敌人作为类别。所有物理体都可以基于这些类别。'
- en: '`collisionBitMask`: This property adds a mask that defines which physics bodies
    can collide with this physics body. This will help the physics engine to evaluate
    and throw only the required results in the delegate methods. For example, the
    bullets can only collide with enemies, not with any player.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collisionBitMask`：这个属性添加了一个掩码，定义了哪些物理体可以与这个物理体碰撞。这将帮助物理引擎评估并仅在代理方法中抛出所需的结果。例如，子弹只能与敌人碰撞，而不能与任何玩家碰撞。'
- en: '`contactTestBitMask`: This property defines the mask to specify which categories
    of physics bodies cause intersection notifications with this physics body.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contactTestBitMask`：这个属性定义了指定哪些物理体类别与这个物理体产生交叉通知的掩码。'
- en: How to do it…
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Now, we will open our working project again to implement an example dealing
    with collision and contact detection. The following steps will provide the step-by-step
    ways to implement and understand collision detection in our project:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将再次打开我们的工作项目来实现一个处理碰撞和接触检测的示例。以下步骤将提供逐步实现和理解项目中碰撞检测的方法：
- en: 'To implement the collision detection, open the `GameScene.m` file and add the
    following function at the end of the file:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现碰撞检测，打开`GameScene.m`文件，并在文件末尾添加以下函数：
- en: '[PRE19]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now we are familiar with code in this function. We will create two physics bodies
    and add them on the scene. Finally, in the last section, we will apply an impulse
    every 5 seconds on the physics body.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了这个函数中的代码。我们将创建两个物理体并将它们添加到场景中。最后，在最后一节中，我们将每5秒对物理体施加一个冲量。
- en: Here we are updating three additional parameters for each of the physics bodies.
    We are updating `categoryBitMask`, `collisionBitMask`, and `contactTestBitMask`
    for the bodies. As explained, we are updating `categoryBitMask` to provide the
    specific categories to the physics bodies. Along with that, we provide the information
    to define which bodies it can detect collision with.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们正在为每个物理体更新三个额外的参数。我们正在更新物理体的`categoryBitMask`、`collisionBitMask`和`contactTestBitMask`。如前所述，我们正在更新`categoryBitMask`以向物理体提供特定的类别。同时，我们提供信息来定义它可以检测碰撞的物理体。
- en: Now we have to add the delegate method, which will be invoked when both the
    bodies collide with each other. We have added logs to check the bodies that are
    colliding. We can identify bodies using their `categoryBitMask`.![How to do it…](img/00121.jpeg)
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须添加一个代理方法，当两个物理体相互碰撞时将被调用。我们已经添加了日志来检查正在碰撞的物理体。我们可以使用它们的`categoryBitMask`来识别物理体。![如何操作…](img/00121.jpeg)
- en: 'Now, replace the `createLimitJointOnScene` function call with `createCollisionDetectionOnScene`.
    Add the following code at the end of the `init` function:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`createLimitJointOnScene`函数调用替换为`createCollisionDetectionOnScene`。在`init`函数的末尾添加以下代码：
- en: '[PRE20]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Also we have to subscribe to the delegate callbacks for contact detection.
    To subscribe, add the following line of code:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们还需要订阅接触检测的代理回调。要订阅，请添加以下代码行：
- en: '[PRE21]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We will also have to declare the contact delegate in the interface file. So
    open `GameScene.h` and add the following code at the end of interface declaration
    line:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还必须在接口文件中声明接触代理。因此，打开`GameScene.h`并在接口声明行末尾添加以下代码：
- en: '[PRE22]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The final code file should look something similar to following screenshot:![How
    to do it…](img/00122.jpeg)
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终的代码文件应该看起来类似于以下截图：![如何操作…](img/00122.jpeg)
- en: Now compile and run the project and you should be able to see both the physics
    bodies on the screen and logs on the Xcode debug window. You can see that the
    collision has been detected and printed in the logs. You can also notice that
    the collision has been detected between the bodies with category mask as `2` and
    `4`. We have a rectangular body with mask as `2` and square body with mask as
    `4`, which are colliding with each other.![How to do it…](img/00123.jpeg)
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在编译并运行项目，你应该能够在屏幕上看到物理体，并在Xcode调试窗口中看到日志。你可以看到碰撞已经被检测并在日志中打印出来。你还可以注意到，具有类别掩码`2`和`4`的物理体之间发生了碰撞。我们有一个类别掩码为`2`的矩形物理体和一个类别掩码为`4`的正方形物理体，它们正在相互碰撞。![如何操作…](img/00123.jpeg)
- en: 'Now we will make the collision detection more intuitive. For this, let''s add
    a label on the screen, which will blink when the bodies collide with each other.
    To do this, add the following line of code at the top just before the `@implementation`
    GameScene code:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使碰撞检测更加直观。为此，让我们在屏幕上添加一个标签，当物理体相互碰撞时，该标签将闪烁。为此，在`@implementation GameScene`代码之前添加以下代码行：
- en: '[PRE23]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, add the following lines of code at the start of the `createCollisionDetectionOnScene`
    function:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`createCollisionDetectionOnScene`函数的开始处添加以下代码行：
- en: '[PRE24]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, for fade-in and fade-out of the label on collision, add the following
    line of code at the end of the `didBeginContact` method:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了在碰撞时对标签进行淡入和淡出，在`didBeginContact`方法的末尾添加以下代码行：
- en: '[PRE25]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here we are checking for the rectangular and square bodies. Once we get a callback
    for the collision of these two bodies, we can fade in the label for a fraction
    of a second and then fade it out again. This will give a nice effect to show when
    the bodies have collided with each other.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们正在检查矩形和正方形的物理体。一旦我们收到这两个物理体碰撞的回调，我们可以让标签淡入一秒钟，然后再次淡出。这将产生一个很好的效果，以显示物理体相互碰撞时的情况。
- en: Now compile and run the project and you should be able to see both the physics
    bodies attached with the pin joint. You can see them attached to each other through
    the anchor point.![How to do it…](img/00124.jpeg)
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在编译并运行项目，你应该能够看到通过销轴连接的物理体。你可以看到它们通过锚点相互连接。![如何操作…](img/00124.jpeg)
