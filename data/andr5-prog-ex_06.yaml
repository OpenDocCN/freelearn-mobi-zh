- en: Chapter 6. Notifications and the Action Bar
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章：通知和操作栏
- en: The vertically scrolling `RecyclerView`, which we have been dealing with in
    the previous chapters, is a great device for negotiating long, simple lists where
    there is either not much data in each item or where each item only displays a
    small part of the whole. There are, of course, times when we will want to display
    a full screen of information and still have this as a part of a list. This is
    where the `ViewPager` comes in as it allows us to chain together full-page, mini
    Activities called **Fragments** in such a way that we can navigate through them
    with simple, intuitive horizontal swipe gestures.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们一直在处理的垂直滚动`RecyclerView`是一个处理长列表的绝佳工具，其中每个项目中的数据不多，或者每个项目只显示整个信息的一小部分。当然，有时我们希望显示全屏信息，同时仍然将其作为列表的一部分。这就是`ViewPager`发挥作用的地方，因为它允许我们将称为**Fragment**的完整页面、迷你Activity链接在一起，这样我们可以通过简单的、直观的水平滑动手势在它们之间导航。
- en: Along with making use of the variety of views and widgets available to us, there
    are often times when we would wish to inform our user of some event even when
    they are not focused on our app. Smartphones generally provide some form of notification
    area, and Android is no exception with its **notification bar** at the top of
    the screen. Issuing notifications to the user is a very simple process, and Android
    has added two new features in Lollipop so that it is now possible to add display
    notifications on the lock screen and produce floating, heads-up notifications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 除了利用我们可用的各种视图和小部件外，我们常常希望在用户没有专注于我们的应用时，通知他们某些事件。智能手机通常提供某种形式的提示区域，而Android也不例外，其**通知栏**位于屏幕顶部。向用户发布通知是一个非常简单的过程，Android在Lollipop中增加了两个新功能，现在可以在锁屏上添加显示通知，并生成浮动、抬头通知。
- en: To demonstrate these features, we will build a small weather forecast app (using
    fake data) that will issue warnings in the form of notifications to the user when
    the weather is severe.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示这些功能，我们将构建一个小型天气预报应用（使用假数据），当天气恶劣时，将以通知的形式向用户发出警告。
- en: 'In this chapter, you will learn how to:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何：
- en: Construct a screen slide with `ViewPager`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ViewPager`构建屏幕滑动
- en: Use Fragments instead of Activities
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Fragment而不是Activity
- en: Create a `ViewPager` and `PagerAdapter`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建`ViewPager`和`PagerAdapter`
- en: Add tabs to the action bar
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向操作栏添加标签
- en: Issue notifications to the user
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向用户发布通知
- en: Manage a back stack
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理返回栈
- en: Design icons for the notification bar
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计通知栏图标
- en: Produce heads-up notifications
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成抬头通知
- en: Create expanded notifications
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建扩展通知
- en: Configure lock screen notifications
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置锁屏通知
- en: Set notification priority and visibility
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置通知优先级和可见性
- en: Constructing a ViewPager
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建ViewPager
- en: The `ViewPager` and its variants are extended from the `ViewGroup` class and
    can be thought of as a kind of layout manager that takes care of placing and navigation
    through the pages. `ViewPagers` work in conjunction with `PagerAdapters`, which
    populate each page with the appropriate data.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewPager`及其变体是从`ViewGroup`类扩展出来的，可以将其视为一种布局管理器，负责放置和导航页面。`ViewPager`与`PagerAdapters`协同工作，为每个页面填充适当的数据。'
- en: The code behind the pages of our `ViewPager` is contained within a new class,
    the `Fragment`. Fragments are very similar in structure and purpose to Activities,
    but can be contained and combined within Activities and, to all intents and purposes,
    can be thought of as sub-Activities.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`ViewPager`页面的代码包含在一个新类中，即`Fragment`。Fragment在结构和目的上与Activity非常相似，但可以被包含和组合在Activity中，从所有目的来看，可以将其视为子Activity。
- en: As always, we need to consider the layout and appearance of our app before we
    begin programming. Here, we will need layouts for the `ViewPager` and `Fragment`.
    The steps in the following section show how to set up our layout and resource
    files for this project.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 正如往常一样，在我们开始编程之前，我们需要考虑我们应用的布局和外观。在这里，我们需要为`ViewPager`和`Fragment`创建布局。以下章节中的步骤展示了如何设置我们的布局和资源文件。
- en: Creating the layout
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建布局
- en: 'Once created, this project will require two layout files and, to take advantage
    of some Material Design features, we will edit the styles resource. The following
    steps explain how this is done:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 创建项目后，该项目将需要两个布局文件，并且为了利用一些Material Design功能，我们将编辑样式资源。以下步骤解释了如何完成此操作：
- en: Create a new project in Android Studio.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android Studio中创建新项目
- en: Name it `Weather Forecast` and start it with the **Blank Activity** template.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名为`天气预报`并使用**空白活动**模板开始它。
- en: 'Open the `build.gradle (Module: app)` file.'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '打开`build.gradle (Module: app)`文件。'
- en: 'Add the following dependencies:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下依赖项：
- en: '[PRE0]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you have not downloaded the project files, locate five suitable images of
    approximately 400 x 400 px with the following names and place them in the project
    `drawable` directory:![Creating the layout](img/B04321_06_01.jpg)
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您尚未下载项目文件，请找到五个大约400 x 400 px的合适图像，名称如下，并将它们放置在项目的`drawable`目录中：![创建布局](img/B04321_06_01.jpg)
- en: Open the `res/values-v21/styles.xml` file.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`res/values-v21/styles.xml`文件。
- en: 'Add the following color items inside the `<style>` tag:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`<style>`标签内添加以下颜色项：
- en: '[PRE1]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Open the `activity_main.xml` file.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`activity_main.xml`文件。
- en: 'Replace its contents with this code:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下代码替换其内容：
- en: '[PRE2]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Create a new layout file called `fragment_layout.xml`.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`fragment_layout.xml`的新布局文件。
- en: Create a `ViewGroup` hierarchy to match the one shown here:![Creating the layout](img/B04321_06_02.jpg)
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个与这里显示的相匹配的`ViewGroup`层次结构：![创建布局](img/B04321_06_02.jpg)
- en: Using images from the `drawable` folder and text as placeholders, recreate the
    layout (with the inner two layouts highlighted), as shown here, selecting margins
    and other visual attributes as you see fit:![Creating the layout](img/B04321_06_03.jpg)
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`drawable`文件夹中的图像和文本作为占位符，重新创建布局（突出显示内部两个布局），如图所示，选择合适的边距和其他视觉属性：![创建布局](img/B04321_06_03.jpg)
- en: 'The `CardView` element should look like this:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CardView`元素应如下所示：'
- en: '[PRE3]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To achieve the correct text coloring, set `android:textAppearance` to apply
    the `textColors` we set in the `styles.xml` file with `textColorPrimary` being
    applied to views and with `textAppearance` set to `"?android:attr/textAppearanceLarge"`.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了实现正确的文本着色，将`android:textAppearance`设置为应用我们在`styles.xml`文件中设置的`textColors`，其中`textColorPrimary`应用于视图，并且将`textAppearance`设置为`"?android:attr/textAppearanceLarge"`。
- en: We added a **support library (v4)** to our gradle script along with `CardView`
    support, which we will use later. Support libraries provide features that are
    unavailable in the standard SDK and backward-compatibility for many others.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的gradle脚本中添加了一个**支持库（v4**）以及`CardView`支持，我们将在以后使用。支持库提供了标准SDK中不可用的功能，并为许多其他功能提供了向后兼容性。
- en: That's all the layout and resource work we need to do. By applying custom colors
    in the style file, we allow the system to decide which colors to apply to which
    screen components as always; here, however, it applies our own personal scheme.
    These colors are displayed throughout the app; not only this method is a good
    way to ensure that our apps are distinctive but it also gives them a consistent
    feel for very little effort on our behalf.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要做的所有布局和资源工作。通过在样式文件中应用自定义颜色，我们允许系统像往常一样决定将哪些颜色应用到哪些屏幕组件上；然而，在这里，它应用了我们自己的个人方案。这些颜色在应用中显示；不仅这种方法是确保我们的应用具有独特性的好方法，而且它也使它们在我们的努力下保持一致感。
- en: Tip
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When dealing with large layout files, the process can be tidied up somewhat
    with the use of `<include layout="@layout/some_layout"/>` where `some_layout`
    will be inserted in place of the include tag on inflation.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理大型布局文件时，可以使用`<include layout="@layout/some_layout"/>`来整理过程，其中`some_layout`将在膨胀时插入到include标签的位置。
- en: With the layout, theme and style set up, we can now continue with writing some
    code.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好布局、主题和样式后，我们现在可以继续编写一些代码。
- en: Adding a ViewPager and FragmentPagerAdapter
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加ViewPager和FragmentPagerAdapter
- en: As briefly mentioned already, a `ViewPager` is a layout manager for horizontally
    scrolling screens. The work of filling these pages is undertaken by a `PagerAdapter`,
    or more specifically in this case `FragmentPagerAdapter`, which fulfills the same
    function but with Fragments rather than Activities.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`ViewPager`是一个水平滚动屏幕的布局管理器。填充这些页面的工作由`PagerAdapter`执行，或者更具体地说，在这个案例中是`FragmentPagerAdapter`，它执行相同的函数，但使用Fragment而不是Activity。
- en: 'Including a small dataset, we will require a total of four classes to implement
    our `ViewPager`. Here is how it''s done:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 包含一个小数据集，我们将需要总共四个类来实现我们的`ViewPager`。以下是实现方法：
- en: Open the `MainActivity` class.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainActivity`类。
- en: 'Include the following imports:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含以下导入：
- en: '[PRE4]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Extend the class like this:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式扩展类：
- en: '[PRE5]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add this class field:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下类字段：
- en: '[PRE6]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add the following three lines to the `onCreate()` method to initiate our `ViewPager`:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate()`方法中添加以下三行以启动我们的`ViewPager`：
- en: '[PRE7]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Create a new class called `FragmentAdapter.java`.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`FragmentAdapter.java`的新类。
- en: 'Include the following imports:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含以下导入：
- en: '[PRE8]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Complete the class, as shown here:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下所示完成类：
- en: '[PRE9]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Create a new class called `WeatherFragment.java`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `WeatherFragment.java` 的新类。
- en: 'Add this import:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下导入：
- en: '[PRE10]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Fill out the class like this:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式填写类：
- en: '[PRE11]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create a last class called `WeatherData.java` and complete it like following:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `WeatherData.java` 的最后一个类，并按照以下方式完成它：
- en: '[PRE12]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can now run and test the app on a handset or emulator.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以在手机或模拟器上运行和测试应用程序。
- en: 'You may be wondering why instructions on which libraries to import were included
    in this section as you probably have Auto Import configured in the settings. This
    feature works perfectly in almost all situations and is a great time-saver. If
    you have not already enabled it, it can be found at `File | Settings... | IDE
    Settings | Editor | Auto Import`. It is only useful when a support library contains
    imports that have the same name as the standard libraries. Had we not imported
    these libraries first, we would have encountered something similar to the following
    screenshot when we tried to enter the code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么在本节中包含了关于导入哪些库的说明，因为你可能已经在设置中配置了自动导入。这个功能在几乎所有情况下都工作得很好，并且可以节省大量时间。如果你还没有启用它，可以在
    `文件 | 设置... | IDE 设置 | 编辑器 | 自动导入` 中找到。它仅在支持库包含与标准库同名导入时才有用。如果我们没有首先导入这些库，当我们尝试输入代码时，我们会遇到以下截图所示的情况：
- en: '![Adding a ViewPager and FragmentPagerAdapter](img/B04321_06_04.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![添加 ViewPager 和 FragmentPagerAdapter](img/B04321_06_04.jpg)'
- en: When this occurs, it is still perfectly possible to import the correct libraries
    by simply selecting the v4 version from the list the editor offers.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当这种情况发生时，仍然可以通过简单地从编辑器提供的列表中选择 v4 版本来导入正确的库。
- en: The `MainActivity` code is remarkably short as most of the work is done elsewhere.
    `ViewPagers` requires an ID, which is the XML-defined `ViewPager` as set in our
    `activity_main.xml` file. The `PagerAdapter` is implemented in the next class;
    here, all we do is to connect the two.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainActivity` 代码非常简短，因为大部分工作都在其他地方完成。`ViewPagers` 需要一个 ID，这个 ID 是在 `activity_main.xml`
    文件中设置的 XML 定义的 `ViewPager`。`PagerAdapter` 在下一个类中实现；这里我们只是将两者连接起来。'
- en: The `FragmentAdapter` class is also quite straightforward. All we need to do
    is pass the index of the selected page to our `Fragment` class, which we do with
    the Bundle object. The fragment then takes care of laying out the views with the
    appropriate data. It is important to point out that we did not use a `PagerAdapter`
    directly, but rather one of its variants, the `FragmentPagerAdapter`, which is
    designed to work with fragments There is also the `FragmentSatePagerAdapter`,
    which does an identical job, but is better suited to longer lists. The reason
    for this is the way the framework handles those pages that are not directly visible
    to the user. For short lists, such as ours, the best performance can be obtained
    with `FragmentPagerAdapter`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`FragmentAdapter` 类也非常简单易懂。我们只需要将所选页面的索引传递给我们的 `Fragment` 类，我们通过 Bundle 对象来完成这个操作。然后片段负责使用适当的数据布局视图。重要的是要指出，我们没有直接使用
    `PagerAdapter`，而是使用其变体之一，即 `FragmentPagerAdapter`，它旨在与片段一起工作。还有一个 `FragmentSatePagerAdapter`，它执行相同的工作，但更适合较长的列表。这是因为框架处理那些对用户不可直接访问的页面的方式。对于像我们这样的短列表，最佳性能可以通过
    `FragmentPagerAdapter` 实现。'
- en: The `Fragment` class we created is also very simple to understand as it does
    little more than inflating our `fragment_layout`, associating and setting our
    views in a way that is, by now, very familiar to us. Fragments are very similar
    to Activities as they each have their own life cycle, which can be intercepted
    at various points with callback methods, such as `onCreate()` and `onPause()`
    in the same way as we do with Activities. Here, we chose to use the `onCreateView()`
    method as it provides access to the instances we need to inflate the fragment
    along with the page index stored in a Bundle by the adapter and is also called
    when the view is created.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的 `Fragment` 类也非常简单易懂，因为它所做的只是扩展我们的 `fragment_layout`，以我们现在已经非常熟悉的方式关联和设置我们的视图。片段与活动非常相似，因为它们各自都有自己的生命周期，可以在不同的点通过回调方法（如
    `onCreate()` 和 `onPause()`）进行拦截，就像我们对活动所做的那样。在这里，我们选择使用 `onCreateView()` 方法，因为它提供了访问我们需要的实例来扩展片段，以及由适配器存储在
    Bundle 中的页面索引，并且当视图创建时也会被调用。
- en: '`ViewPagers` provides a lot of functionality with very little effort. Once
    connected to an adapter, we can create a screen slide without worrying about implementing
    touch listeners and having to pay much attention to which page has been selected
    at any given time.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewPagers`提供了许多功能，却几乎不需要付出任何努力。一旦连接到适配器，我们就可以创建屏幕滑动，无需担心实现触摸监听器，也不必过分关注在任何给定时间选中的是哪一页。'
- en: As it stands, our app does very little, and we need to provide more functionality,
    which we will do by firstly adding tabs to the action bar so that we can associate
    each page with an actual date, and secondly by programming a notification builder
    to issue weather alerts via the system notification area. We will begin by adding
    tabs with dates.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 就目前而言，我们的应用做得非常少，我们需要提供更多功能，这包括首先在操作栏中添加标签，以便我们可以将每个页面与实际日期关联起来，其次是通过编程一个通知构建器来发布系统通知区域中的天气警报。我们将从添加带日期的标签开始。
- en: Adding tabs and dates
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加标签和日期
- en: A weather forecasting app is of no use if the user does not know when to expect
    the weather predicted. We could easily add another view to our fragment layout,
    but we will attach our pages to the tabs on the action bar, and access calendar
    and date format classes to populate them.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户不知道何时可以期待预测的天气，那么天气预报应用就没有什么用处。我们很容易在我们的片段布局中添加另一个视图，但我们将我们的页面附加到操作栏的标签上，并访问日历和日期格式类来填充它们。
- en: To intercept changes between the pages, we will need an `OnPageChangeListener`,
    which is called whenever the page changes, and to redefine the class declaration
    so that it implements an `ActionBar.TabListener`. We will use Java's own `Calendar`
    and `SimpleDateFormat` objects to calculate and format our dates.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要拦截页面之间的变化，我们需要一个`OnPageChangeListener`，它在页面变化时被调用，并重新定义类声明，使其实现`ActionBar.TabListener`。我们将使用Java自带的`Calendar`和`SimpleDateFormat`对象来计算和格式化我们的日期。
- en: 'Everything we need to do to add tabs to our action bar can be done from within
    our `MainActivity` class by following these steps:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要添加到操作栏中的标签的所有操作都可以通过在`MainActivity`类中遵循以下步骤来完成：
- en: Open the `MainActivity.java` file.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainActivity.java`文件。
- en: 'Edit the declaration like this:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式编辑声明：
- en: '[PRE13]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Select the error this generates, follow the editor's recommendation, and implement
    the three methods suggested.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择这个错误产生的错误，遵循编辑器的建议，并实现建议的三个方法。
- en: 'Edit the `onTabSelected()` method to match the following:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`onTabSelected()`方法以匹配以下内容：
- en: '[PRE14]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Include the following class field:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含以下类字段：
- en: '[PRE15]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add the following lines to the `onCreate()` method:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下行添加到`onCreate()`方法中：
- en: '[PRE16]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Still within `onCreate()`, include the following listener to detect page changes:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在`onCreate()`中，包括以下监听器以检测页面变化：
- en: '[PRE17]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can now run the project on a device or AVD.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以在设备或AVD上运行项目了。
- en: The tabbed action bar is a familiar sight on many Android applications and the
    `ActionBar.TabListener` is an interface that is called whenever a tab is selected,
    added, or removed. Here, we use its selection to inform our `ViewPager` of the
    change. The `ViewPager` layout also provides a good opportunity to see how the
    colors we defined earlier are applied to the various components of the UI, such
    as the colored hint that appears when the user attempts to scroll beyond either
    end of the list.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 标签式操作栏在许多安卓应用中都很常见，而`ActionBar.TabListener`是一个接口，每当标签被选中、添加或移除时都会被调用。在这里，我们使用它的选择来通知我们的`ViewPager`变化。`ViewPager`布局也提供了一个很好的机会来查看我们之前定义的颜色是如何应用到UI的各种组件上的，例如当用户尝试滚动到列表的任一端之外时出现的彩色提示。
- en: '![Adding tabs and dates](img/B04321_06_05.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![添加标签和日期](img/B04321_06_05.jpg)'
- en: 'The `Calendar` and `SimpleDateFormat` classes are not hard to follow. The date
    formatting follows **Unicode Technical Standards** (**UTS**) #35, the details
    of which can be found at [http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns](http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns).
    Here, we applied a stand-alone day-of-week format with `"cccc"`. We could have
    been more creative and used something like `"c LLL d"` to have something like
    **Tue Mar 15** or even taken advantage of the system''s built-in formatting by
    changing the `dayFormat` assignation to `dayFormat = (SimpleDateFormat) new SimpleDateFormat().getDateInstance();`,
    as seen here:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`Calendar` 和 `SimpleDateFormat` 类并不难理解。日期格式化遵循 **Unicode 技术标准**（**UTS**）#35，其详细信息可以在
    [http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns](http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns)
    找到。在这里，我们应用了一个独立的星期格式，使用 `"cccc"`。我们本来可以更有创意，使用类似 `"c LLL d"` 的格式来得到类似 **Tue Mar
    15** 的结果，或者甚至利用系统内置的格式化功能，通过更改 `dayFormat` 的赋值来 `dayFormat = (SimpleDateFormat)
    new SimpleDateFormat().getDateInstance();`，如下所示：'
- en: '![Adding tabs and dates](img/B04321_06_06.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![添加标签和日期](img/B04321_06_06.jpg)'
- en: The final part of the puzzle is put into place with the `ViewPager.OnPageChangeListener`,
    which we use to inform the action bar when a new page is selected with a swipe
    rather than a tab.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个拼图部分是通过 `ViewPager.OnPageChangeListener` 实现的，我们使用它来通知操作栏当通过滑动而不是标签选择新页面时。
- en: With both forms of navigation in place and connected, we can now move on and
    program our app to issue notifications.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在两种导航形式都到位并连接后，我们现在可以继续编程我们的应用以发布通知。
- en: Programming notifications
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程通知
- en: Android 5 provides a more flexible notification framework than the previous
    versions. In addition to being able to issue standard notifications to the notification
    bar, we can now expand notifications to include more detail than before, and are
    able to notify the user when they are using a full-screen app, or even when their
    screen is locked, with **heads-up notifications** that float above the screen
    for a moment.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Android 5 提供了一个比之前版本更灵活的通知框架。除了能够向通知栏发布标准通知外，我们现在还可以将通知扩展到比以前包含更多细节，并且能够通过在屏幕上浮动的
    **heads-up 通知**来通知用户，当他们在使用全屏应用或屏幕锁定时。
- en: When using notifications, it is important to be sensitive to our user's needs
    and not issue too many notifications or give them too great a level of importance.
    It is for this reason that notifications can be assigned **priority and visibility**
    settings. With that said, it is now time to proceed with adding notifications
    to our app.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用通知时，重要的是要敏感地关注用户的需求，不要发布太多通知或给予它们过高的重要性。正因为如此，通知可以分配 **优先级和可见性** 设置。话虽如此，现在是我们向应用添加通知的时候了。
- en: Adding a standard notification and icon
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加标准通知和图标
- en: 'Assuming the notification we wish to deliver is neither important nor personal,
    and all we wish to do is to inform the user of some event and offer them the opportunity
    to open our app, we need to issue a standard notification so that a small icon
    appears on the notification bar and, when the drawer is opened, a small card appears
    with some brief text and an icon. This, if clicked on, will open our app. Notifications
    require a particular type of icon for display on the bar. We will begin with this
    and then continue to implement a notification. Complete the following steps to
    set this up on our weather app:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望发送的通知既不重要也不私密，我们只想通知用户某个事件并给他们提供打开我们应用的机会，我们需要发布一个标准通知，以便在通知栏上出现一个小图标，当抽屉打开时，会出现一个带有一些简短文本和图标的卡片。点击它将打开我们的应用。通知需要在通知栏上显示特定类型的图标。我们将从这里开始，然后继续实现通知。按照以下步骤在我们的天气应用上设置此功能：
- en: If you have not downloaded the project files, you will need a small icon of
    a single color against a transparent background (like the one you see here) called
    `small_icon.png`, and stored in the `drawable` directory:![Adding a standard notification
    and icon](img/B04321_06_07.jpg)
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您尚未下载项目文件，您需要一个单色图标，背景为透明（就像您在这里看到的那样），名为 `small_icon.png`，并存储在 `drawable`
    目录中：![添加标准通知和图标](img/B04321_06_07.jpg)
- en: Open the MainActivity Java file.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainActivity` Java 文件。
- en: 'Add this class field:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加此类字段：
- en: '[PRE18]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the `onCreate()` method, add the following clause:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onCreate()` 方法中，添加以下语句：
- en: '[PRE19]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create the `postAlert()` method and complete it like this:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `postAlert()` 方法并完成如下：
- en: '[PRE20]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The application can now be tested on an emulator or device, and opening the
    notification drawer should produce the following result:![Adding a standard notification
    and icon](img/B04321_06_08.jpg)
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用现在可以在模拟器或设备上测试，打开通知抽屉应该产生以下结果：![添加标准通知和图标](img/B04321_06_08.jpg)
- en: There are quite a few things going on here. Firstly, there was the **notification
    icon**. This is required by the builder and has to be of a specific format. Apart
    from being small, the icon needs to be a simple design on a transparent background.
    The color of the image is immaterial as only the alpha channel is considered by
    the system. For this reason, colors with intermediate alpha levels are strongly
    discouraged.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多事情在进行。首先，有**通知图标**。这是构建者所必需的，并且必须遵循特定的格式。除了要小之外，图标还需要在透明背景上的简单设计。图片的颜色并不重要，因为系统只考虑alpha通道。因此，强烈不建议使用具有中间alpha级别的颜色。
- en: 'Before getting to the rest of the code, it would be amiss not to point out
    that there is an alternative to using the small icon on the notification pop-down,
    which, although suitable for the minimal space on the bar, does not always look
    great in the circular icon to the left of the larger view. Add the following setting
    to our builder:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在到达代码的其余部分之前，指出使用通知下拉中的小图标的一个替代方案是不妥的，尽管它适合条上的最小空间，但并不总是看起来很好。在大视图左侧的圆形图标中。将以下设置添加到我们的构建器中：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Running the app now produces an icon like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行应用会产生如下图标：
- en: '![Adding a standard notification and icon](img/B04321_06_09.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![添加标准通知和图标](img/B04321_06_09.jpg)'
- en: 'We used `NotificationCompat` to construct our builder. `NotificationCompat`
    is a helper class provided by the support libraries we imported earlier. The `Builder`
    itself has three required parameters: `ContentTitle`, `ContentText`, and `SmallIcon`.
    There are many others, which we will get to, but only these three are mandatory.
    I have also set `AutoCancel` to true as this is extremely helpful because it automatically
    closes the notification once it has been selected from the drawer. The purpose
    of setting `Builder.Ticker` would have become apparent when the app was run.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`NotificationCompat`来构建我们的构建器。`NotificationCompat`是我们之前导入的支持库提供的一个辅助类。`Builder`本身有三个必需的参数：`ContentTitle`、`ContentText`和`SmallIcon`。还有很多其他的参数，我们将在后面讨论，但只有这三个是必需的。我还将`AutoCancel`设置为true，因为这非常有用，因为它会在通知被从抽屉中选中后自动关闭。设置`Builder.Ticker`的目的在应用运行时就会变得明显。
- en: Because of their available position, notifications can be viewed and triggered
    when other apps have the focus. This can lead to confusing results for the user
    when they press the back key. We want the navigation keys to behave as if the
    app had been launched in the usual way. This is the function of the **TaskStackBuilder**,
    which takes an **Intent** in this case to launch our MainActivity, and places
    it onto the recent activities back stack and the PendingIntent makes it available
    outside our app.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们可用的位置，通知可以在其他应用有焦点时查看和触发。当用户按下返回键时，这可能会导致用户产生困惑的结果。我们希望导航键的行为就像应用以通常的方式启动一样。这就是**TaskStackBuilder**的功能，它在这个案例中接受一个**Intent**来启动我们的`MainActivity`，并将其放置在最近的活动回退栈上，而`PendingIntent`使其在我们的应用外部可用。
- en: The actual notification is called with the `NotificationManager.notify()` call.
    The use of an ID was not strictly necessary here as our app only issues one notification
    at a time. However, not only is it a useful way to keep track of multiple notifications,
    but can also be used, as we did here, to ensure that a notification is issued
    only once.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的通知是通过调用`NotificationManager.notify()`来实现的。在这里使用ID并不是绝对必要的，因为我们的应用一次只发出一个通知。然而，这不仅是一种跟踪多个通知的有用方式，还可以像我们在这里做的那样，确保只发出一个通知。
- en: Expanding a notification
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展通知
- en: 'The `NotificationCompat` class provides us with three built-in styles. Here,
    we will use `BigPictureStyle`. Before we start, you will need an image to use
    as the "big picture". Find a suitable image of around 640 x 480 px, place it in
    your `drawable` folder, and name it `snow_scene` or change the reference in the
    following code. Once your image is in place, follow these short steps:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`NotificationCompat`类为我们提供了三种内置样式。在这里，我们将使用`BigPictureStyle`。在我们开始之前，你需要一个用作“大图片”的图片。找到大约640
    x 480像素的合适图片，将其放在你的`drawable`文件夹中，并命名为`snow_scene`或更改以下代码中的引用。一旦你的图片就位，按照以下简短的步骤进行：'
- en: Open the `MainActivity.java` class.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainActivity.java`类。
- en: 'Add the following code to the `onCreate()` method, just before our Intent is
    declared:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onCreate()` 方法中，在我们的 Intent 声明之前添加以下代码：
- en: '[PRE22]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: That's it! Run the app on your handset or emulator and open the notification
    drawer.![Expanding a notification](img/B04321_06_10.jpg)
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就这样！在你的手机或模拟器上运行应用并打开通知抽屉。![展开通知](img/B04321_06_10.jpg)
- en: The `NotificationCompat.Style` objects are very handy to add details to our
    notifications, and simple to understand and use. Along with `BigPictureStyle`,
    there is `BigTextStyle` for headline type notifications and `InboxStyle` for lists.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`NotificationCompat.Style` 对象非常方便为我们添加通知的详细信息，并且易于理解和使用。除了 `BigPictureStyle`，还有
    `BigTextStyle` 用于标题类型的通知，以及 `InboxStyle` 用于列表。'
- en: 'This leaves us with two other new notification features: heads-up notifications
    and lock screen notifications. Neither of these requires any additional coding
    as such, but they are triggered by adjusting certain privacy and priority settings
    of the existing notifications. The next and final section of this chapter demonstrates
    how this is done.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这就留下了我们另外两个新的通知功能：弹窗通知和锁屏通知。这两个功能都不需要额外的编码，但它们是通过调整现有通知的某些隐私和优先级设置来触发的。本章的下一节和最后一节将演示如何实现这一点。
- en: Issuing heads-up and lock screen notifications
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布弹窗和锁屏通知
- en: 'Heads-up and lock screen notifications are created in the same way as the standard
    notifications. The difference depends on the `VISIBILTY` and `PRIORITY` properties
    of our `NotificationCompat.Builder` class. The following are the steps to do this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 弹窗和锁屏通知的创建方式与标准通知相同。区别在于我们的 `NotificationCompat.Builder` 类的 `VISIBILTY` 和 `PRIORITY`
    属性。以下是如何做到这一点的步骤：
- en: Open the `MainActivity` class.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainActivity` 类。
- en: 'Give our builder instance the following properties:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给我们的构建器实例以下属性：
- en: '[PRE23]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When the app is run, it will now display heads-up and lock screen notifications.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当应用运行时，它现在将显示弹窗和锁屏通知。
- en: Tip
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The screen can be locked on an emulator by pressing *F7*.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以通过按 *F7* 键在模拟器上锁定屏幕。
- en: Here, the `setPriority()` method is how we decide whether a notification is
    important enough to consider using a heads-up message that may intrude on some
    other task they are performing more than the standard version. Priority must be
    set to `PRIORITY_HIGH` or `PRIORITY_MAX` and the notification must be set to trigger
    a vibration for notifications to appear in this manner. The other priorities are
    `MIN`, `LOW`, and `DEFAULT`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`setPriority()` 方法是我们决定一个通知是否重要到足以考虑使用可能会干扰他们正在执行的其他任务的弹窗消息，而不是标准版本。优先级必须设置为
    `PRIORITY_HIGH` 或 `PRIORITY_MAX`，并且通知必须设置为触发振动，以便以这种方式显示通知。其他优先级是 `MIN`、`LOW`
    和 `DEFAULT`。
- en: Tip
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'If you do not wish for your notification to set off a vibration, but still
    appear in a heads-up fashion, you can use the following line instead:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想让你的通知触发振动，但仍然以弹窗的形式出现，你可以使用以下行代替：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Although there are more intricate ways to configure a vibration, the constructor
    used here will suit most purposes. The array of longs represents alternating times
    in milliseconds, representing pulses of vibration and silence alternatively so
    that, in the example here, the device would buzz three times for 100 ms with pauses
    of 50 ms in between.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有更复杂的方式来配置振动，但这里使用的构造函数将满足大多数目的。长整型数组代表交替的时间（以毫秒为单位），代表振动的脉冲和静默交替，因此在这个例子中，设备会嗡嗡作响三次，每次100毫秒，中间有50毫秒的暂停。
- en: Unlike other notifications, the user can choose, via settings, whether or not
    the device displays lock screen messages. As developers, however, we can decide
    how much, if any, information is displayed on the user's lock screen.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他通知不同，用户可以通过设置选择是否在设备上显示锁屏消息。然而，作为开发者，我们可以决定在用户的锁屏上显示多少，如果有的话，信息。
- en: Setting the visibility of a notification to `PUBLIC` will cause both content
    title and content text to be displayed, setting it to `PRIVATE` will display only
    the title, and `SECRET` will display nothing at all.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 将通知的可见性设置为 `PUBLIC` 将导致内容标题和内容文本都显示出来，设置为 `PRIVATE` 将只显示标题，而 `SECRET` 则完全不显示。
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored an alternative to the vertically scrolling `RecyclerView`
    with the `ViewPager`. We used Fragments instead of Activities, and saw some of
    the things we can do with the Action Bar. We learnt how to issue notifications
    of all kinds and how to manage the back stack so as to provide consistent navigation
    back through our app for the user. In most cases, notifications are sent when
    our app is not even actively running; to do this, we will need to use Services,
    which are a kind of background Activity.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了使用`ViewPager`作为垂直滚动`RecyclerView`的替代方案。我们使用了Fragment而不是Activity，并了解了一些我们可以使用Action
    Bar完成的事情。我们学习了如何发布各种通知以及如何管理返回栈，以便为用户提供一致的导航回应用程序。在大多数情况下，当我们的应用程序甚至没有积极运行时，也会发送通知；为此，我们需要使用服务，这是一种后台Activity。
- en: In the next chapter, we will take a look at how to include Google Maps into
    our apps and make them location-aware. This involves having to register our app
    for an API key and employing a `LocationListener` to keep our app updated with
    current location data; as this can be resource hungry, we will also see how to
    optimize this process.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何将Google Maps集成到我们的应用程序中，并使它们具有位置感知能力。这涉及到注册我们的应用程序以获取API密钥，并使用`LocationListener`来确保我们的应用程序能够更新当前位置数据；由于这可能需要大量资源，我们还将了解如何优化此过程。
