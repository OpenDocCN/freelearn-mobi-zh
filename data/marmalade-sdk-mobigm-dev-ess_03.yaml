- en: Chapter 3. User Input
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。用户输入
- en: 'A video game is not going to be a whole lot of fun to play if the user has
    no way of controlling the events that happen, so in this chapter we will be looking
    at the various ways in which we can add interactivity to our programs by using
    Marmalade. By the end of this chapter you will know how to detect the following
    types of input:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户无法控制发生的事件，那么一款视频游戏将不会很有趣去玩，所以在本章中，我们将探讨使用 Marmalade 可以通过哪些方式增加程序的交互性。到本章结束时，你将知道如何检测以下类型的输入：
- en: Key presses
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键盘按键
- en: Touch screen and pointer inputs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触摸屏和指针输入
- en: Detection of gestures such as swipes and pinches
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测如滑动和捏合等手势
- en: Changes in device orientation using accelerometers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用加速度计改变设备方向
- en: Detecting key input
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测关键输入
- en: We'll start our journey into the world of player input methods with the simplest
    method possible—pressing keys, which we detect by using the s3eKeyboard API. To
    use these functions in our code, we just need to include the `s3eKeyboard.h` file.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从最简单的玩家输入方法开始我们的旅程——按键，我们通过使用 s3eKeyboard API 来检测按键。为了在我们的代码中使用这些函数，我们只需要包含
    `s3eKeyboard.h` 文件。
- en: While the touch screen may now rule supreme as the primary method of interacting
    with many modern devices, it is still worthwhile to know how to detect key presses.
    Android devices, in particular, have keys that are intended to be used for quick
    access to menus and for navigation around a program. Quite often these are not
    even physical buttons, just an area at the bottom of the touch screen, but they
    are still reported as key presses.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然触摸屏现在可能是与许多现代设备交互的主要方法，但了解如何检测按键仍然很有价值。特别是，Android 设备具有旨在用于快速访问菜单和程序导航的按键。这些按键通常甚至不是物理按钮，只是触摸屏底部的区域，但它们仍然被报告为按键。
- en: Key press detection is also extremely useful when debugging your code in the
    Windows simulator, as Marmalade allows full access to your computer's keyboard
    too. This makes it really easy to add a debugging functionality triggered by a
    key press.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 模拟器中调试代码时，按键检测也非常有用，因为 Marmalade 允许完全访问您的计算机键盘。这使得通过按键触发调试功能变得非常容易。
- en: The s3eKeyboard API allows us to detect key input either by key state or by
    character input. It also provides functionality that allows us to determine what
    kind of keyboard support the device we are running on has available.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: s3eKeyboard API 允许我们通过按键状态或字符输入来检测键盘输入。它还提供了允许我们确定我们运行的设备具有哪些键盘支持的功能。
- en: Initialization and update of key information
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 键信息的初始化和更新
- en: There is a function called `s3eKeyboardGetInt` that allows us to find out what
    kind of keyboard our device has. We can use this information to provide different
    input methods to our program should we want to. For example, entering a user's
    name on a high score might allow the user to enter their name directly if the
    device has a full alphabetic keyboard, but could fall back to a method using arrow
    keys to cycle through characters if the device does not feature a full keyboard.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为 `s3eKeyboardGetInt` 的函数，可以让我们找出我们的设备具有哪种类型的键盘。如果我们想的话，我们可以使用这些信息为我们的程序提供不同的输入方法。例如，在一个高分榜上输入用户名时，如果设备具有全字母键盘，用户可以直接输入他们的名字，但如果设备没有全键盘，则可能回退到使用箭头键循环字符的方法。
- en: 'The `s3eKeyboardGetInt` function call takes a single parameter from the `s3eKeyboardProperty`
    enumeration, and returns an integer value. Details of the available properties
    are provided in the following table:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`s3eKeyboardGetInt` 函数调用需要一个来自 `s3eKeyboardProperty` 枚举的单个参数，并返回一个整数值。以下表格提供了可用属性的具体信息：'
- en: '| Property name | Description |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 属性名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `S3E_KEYBOARD_HAS_NUMPAD` | Returns `1` if the device has a numeric keypad,
    otherwise returns `0`. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_KEYBOARD_HAS_NUMPAD` | 如果设备具有数字键盘，则返回 `1`，否则返回 `0`。 |'
- en: '| `S3E_KEYBOARD_HAS_ALPHA` | Returns `1` if the device has an alphabetic keypad,
    otherwise returns `0`. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_KEYBOARD_HAS_ALPHA` | 如果设备具有字母键盘，则返回 `1`，否则返回 `0`。 |'
- en: '| `S3E_KEYBOARD_HAS_DIRECTION` | Returns `1` if the device has directional
    controls (up, down, left, right, and a **Select** or **OK** button), otherwise
    returns `0`. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_KEYBOARD_HAS_DIRECTION` | 如果设备具有方向控制（上、下、左、右以及**选择**或**确定**按钮），则返回 `1`，否则返回
    `0`。 |'
- en: '| `S3E_KEYBOARD_NUMPAD_ORIENTATION` | If the device has a numeric keypad, this
    property will return the orientation of the keypad relative to how the user is
    holding the device (if this is possible to detect). |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_KEYBOARD_NUMPAD_ORIENTATION` | 如果设备有数字键盘，则此属性将返回键盘相对于用户持握设备的方式（如果可能检测到）的朝向。
    |'
- en: '| `S3E_KEYBOARD_GET_CHAR` | Returns `1` if the device supports the character
    code input method or `0` if it does not. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_KEYBOARD_GET_CHAR` | 如果设备支持字符码输入方法，则返回`1`；如果不支持，则返回`0`。 |'
- en: 'The final value in this table can also be used with the function `s3eKeyboardSetInt`
    to show and hide the virtual keyboard on Android and iOS devices, which will then
    allow us to use the character code input method on these types of devices. The
    following function call will display the virtual keyboard:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此表中的最终值也可以与函数`s3eKeyboardSetInt`一起使用，在Android和iOS设备上显示和隐藏虚拟键盘，这将允许我们在这些类型的设备上使用字符码输入方法。以下函数调用将显示虚拟键盘：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To hide the virtual keyboard, pass in `0` instead of `1`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要隐藏虚拟键盘，请传入`0`而不是`1`。
- en: Given that this feature is limited to just Android and iOS, and there is no
    way of determining whether the functionality is supported at runtime, this approach
    is probably best avoided if you intend to support a wide range of devices.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此功能仅限于Android和iOS，且无法确定在运行时是否支持该功能，如果您打算支持广泛的设备，则此方法可能最好避免。
- en: In order for our program to keep receiving updates on key presses, we must call
    the function `s3eKeyboardUpdate` in our code, once per game frame. The s3eKeyboard
    API keeps its own internal cache of the current key press states, which is updated
    when calling this function; so if we don't call `s3eKeyboardUpdate` frequently,
    we risk missing key press events.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的程序持续接收按键更新的信息，我们必须在代码中调用函数`s3eKeyboardUpdate`，每次游戏帧调用一次。s3eKeyboard API维护自己的内部缓存，用于当前按键状态，该缓存在调用此函数时更新；因此，如果我们不频繁调用`s3eKeyboardUpdate`，我们可能会错过按键事件。
- en: Detecting key state
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测按键状态
- en: The most useful method of key detection for most arcade style games is to be
    able to discover the up or down state of any key on the device. The s3eKeyboard
    API provides two ways in which we can do this, these being polling the current
    key state and by registering a callback function.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数街机风格的游戏，最有用的按键检测方法是可以发现设备上任何按键的上或下状态。s3eKeyboard API提供了两种方法，我们可以通过轮询当前按键状态和注册回调函数来实现这一点。
- en: Detecting key state changes using polling
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用轮询检测按键状态变化
- en: We'll start with the simplest approach of polling for the current state of a
    key. It may be the simplest approach, but in most cases it is also the best approach
    as far as game coding is concerned, since often all we want to know is whether
    a key is currently pressed or released so that we can update our game state accordingly.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从最简单的方法开始，即轮询按键的当前状态。这可能是最简单的方法，但就游戏编程而言，在大多数情况下，这也是最佳方法，因为我们通常只想知道按键是否当前被按下或释放，以便我们可以相应地更新我们的游戏状态。
- en: 'To detect the current state of any key on our device we make a call to `s3eKeyboardGetState`,
    which takes a value from the `s3eKey` enumeration (take a look at the `s3eKeyboard.h`
    file for a full list, but you can normally guess the name of the enumeration fairly
    easily—for example, `s3eKeyUp` is the up arrow key, `s3eKey4` is the number *4*
    key, and so on) to identify the key we are interested in. The function returns
    an integer value that is a bit mask representing the current state of that key.
    The following key states can be detected by performing a bitwise AND operation
    on the return value:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要检测设备上任何按键的当前状态，我们调用`s3eKeyboardGetState`，该函数从`s3eKey`枚举中取值（查看`s3eKeyboard.h`文件以获取完整列表，但您通常可以很容易地猜测枚举的名称——例如，`s3eKeyUp`是向上箭头键，`s3eKey4`是数字*4*键，等等）以识别我们感兴趣的按键。该函数返回一个整数值，它是一个表示该按键当前状态的位掩码。通过执行位与操作，可以检测以下按键状态：
- en: '| Bit mask name | Description |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 位掩码名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `S3E_KEY_STATE_DOWN` | The key is currently being held down. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_KEY_STATE_DOWN` | 按键当前被按下。 |'
- en: '| `S3E_KEY_STATE_PRESSED` | The key went from being up to down in the last
    call to `s3eKeyboardUpdate`. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_KEY_STATE_PRESSED` | 在上一次调用`s3eKeyboardUpdate`时，按键从释放变为按下。 |'
- en: '| `S3E_KEY_STATE_RELEASED` | The key went from being down to up in the last
    call to `s3eKeyboardUpdate`. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_KEY_STATE_RELEASED` | 在上一次调用`s3eKeyboardUpdate`时，按键从按下变为释放。 |'
- en: If the value returned from the function is zero, then the key can be assumed
    to currently be in the up position (that is, not being held) and has not just
    been released either.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数返回的值是零，则可以假设该键当前处于上位置（即，没有被按下）并且也没有刚刚被释放。
- en: 'The following code snippet shows how we would detect whether the number *3*
    key has just been pressed:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了我们如何检测数字 *3* 键是否刚刚被按下：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Detecting key state changes using callbacks
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用回调检测键状态变化
- en: It is also possible to be informed whenever a key is pressed or released by
    using a callback function. Callbacks are preferred by many coders since they force
    us into writing smaller, more manageable functions that often yield a more concise
    and reusable solution. The polled approach to key detection may seem easier at
    first glance but it is easy to end up with a codebase that has key state checking
    logic spread across many source files. Using the callback approach will tend to
    ensure key handling code is implemented in a more structured way.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用回调函数，我们也可以随时得知按键被按下或释放。许多程序员更喜欢回调，因为它们迫使我们编写更小、更易于管理的函数，这通常会产生更简洁、可重用的解决方案。从表面上看，轮询方法可能更容易，但很容易导致代码库中散布着键状态检查逻辑，遍布多个源文件。使用回调方法通常会确保键处理代码以更结构化的方式实现。
- en: To set up a callback function that detects key state changes, we use the `s3eKeyboardRegister`
    function. We provide this function with the enumeration value `S3E_KEYBOARD_KEY_EVENT`
    to identify the type of callback we are setting up, a pointer to a function that
    will be the callback, and a void pointer that can be used to pass in our own custom
    data to the callback function.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置一个检测键状态变化的回调函数，我们使用 `s3eKeyboardRegister` 函数。我们向这个函数提供枚举值 `S3E_KEYBOARD_KEY_EVENT`
    以标识我们设置的回调类型，一个指向将作为回调的函数的指针，以及一个 void 指针，可以用来向回调函数传递我们自己的自定义数据。
- en: When a key is pressed or released, the function we specified will be called.
    The callback function is passed a pointer to an `s3eKeyboardEvent` structure,
    which details the key press or release and is also provided with the custom data
    pointer we specified when registering the callback.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当按键被按下或释放时，我们将指定的函数将被调用。回调函数传递一个指向 `s3eKeyboardEvent` 结构的指针，该结构详细说明了按键或释放事件，并且还提供了我们在注册回调时指定的自定义数据指针。
- en: When we no longer wish to receive key state notifications, we can call `s3eKeyboardUnRegister`
    to disable the callback mechanism. We just need to pass the `S3E_KEYBOARD_KEY_EVENT`
    enumeration and the pointer to our callback method to stop the callbacks from
    occurring any more.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不再希望接收键状态通知时，我们可以调用 `s3eKeyboardUnRegister` 来禁用回调机制。我们只需传递 `S3E_KEYBOARD_KEY_EVENT`
    枚举和指向我们回调方法的指针，以停止回调的发生。
- en: 'Here''s a code snippet to illustrate how we might detect state changes to the
    number *3* key:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个代码片段，用于说明我们如何检测数字 *3* 键的状态变化：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The method of key press detection to be used is really down to project requirements
    and personal preference. Since a call to `s3eKeyboardUpdate` will cache the state
    of every key for us, a polled approach may be best if we need to detect the current
    state of several keys at any time. A callback approach may be better if we just
    want to respond immediately to a key press and are less interested in tracking
    the key's state beyond this.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用的按键检测方法实际上取决于项目需求和个人偏好。由于调用 `s3eKeyboardUpdate` 会为我们缓存每个键的状态，如果我们需要在任何时间检测多个键的当前状态，轮询方法可能最佳。如果我们只想立即响应按键，而不太关心键的状态跟踪，回调方法可能更好。
- en: Detecting character code input
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测字符代码输入
- en: The s3eKeyboard API also provides support for reading character codes from the
    keyboard. With this approach, we don't receive any notification of when a key
    was pressed or released. Instead, we receive a stream of character codes which
    automatically take into account any special modifier keys; so if a user pressed
    the *Shift* key, followed by the *A* key, then released both these keys, we would
    only receive the character code for a capital letter A.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: s3eKeyboard API 还提供了从键盘读取字符代码的支持。使用这种方法，我们不会收到按键或释放的通知。相反，我们收到一系列字符代码，这些代码会自动考虑任何特殊修饰键；因此，如果用户先按下
    *Shift* 键，然后按下 *A* 键，最后释放这两个键，我们只会收到大写字母 A 的字符代码。
- en: This approach is probably less useful for most games due to it not being an
    immediate form of notification, especially since fewer and fewer devices now feature
    physical keys that can be pressed.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这不是一种即时通知的形式，而且现在越来越少设备具有可按的物理按键，这种方法对于大多数游戏来说可能不太有用。
- en: Not all devices support this input method, so you should use a call to `s3eKeyboardGetInt(S3E_KEYBOARD_GET_CHAR)`
    to determine if it can be used.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有设备都支持这种输入方法，因此你应该使用`调用s3eKeyboardGetInt(S3E_KEYBOARD_GET_CHAR)`来确定它是否可以使用。
- en: For the sake of completeness though, let us look at how we can receive character
    codes using either polling or callbacks.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管为了完整性，让我们看看我们如何可以通过轮询或回调来接收字符代码。
- en: Detecting character code input using polling
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用轮询检测字符代码输入
- en: 'To find out if a key that generates a character code has been pressed, all
    we have to do is call the following function:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定生成字符代码的键是否被按下，我们只需调用以下函数：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `s3eWChar` type is just an alternate type definition for the standard C++
    type `wchar_t`, a wide character. While this type can vary in size, it is assumed
    to be a 16-bit value in Marmalade. When a key is pressed, its character code will
    be added to the back of a queue. Calling this function will return the character
    to the front of the queue, or `S3E_WEOF` if the queue is empty. We often call
    this function in a loop in order to try and keep the queue empty and not risk
    losing key presses.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`s3eWChar`类型只是标准C++类型`wchar_t`的另一种类型定义，是一种宽字符。虽然此类型的大小可能不同，但在Marmalade中假定它是一个16位值。当按键被按下时，其字符代码将被添加到队列的末尾。调用此函数将返回队列前面的字符，或者如果队列为空，则返回`S3E_WEOF`。我们通常在循环中调用此函数，以尝试保持队列为空，避免丢失按键。'
- en: The character codes returned will depend on the device you are running on, but
    in most cases the standard alphabet A through Z, numbers, and punctuation characters
    will be ASCII codes, just stored in a 16-bit value.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的字符代码将取决于你正在运行的设备，但在大多数情况下，标准字母表A到Z、数字和标点符号将是ASCII代码，只是存储在一个16位值中。
- en: Detecting character code input using callbacks
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用回调检测字符代码输入
- en: Using the callback method of receiving character codes takes the same approach
    as the callback method for receiving key state changes.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用接收字符代码的回调方法与接收按键状态变化的回调方法采用相同的方法。
- en: We again use `s3eKeyboardRegister` and `s3eKeyboardUnRegister` to start and
    stop notifications from occurring, but we use the enumeration value `S3E_KEYBOARD_CHAR_EVENT`
    to indicate that it is a character code event we want to receive.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用`s3eKeyboardRegister`和`s3eKeyboardUnRegister`来开始和停止通知的发生，但我们使用枚举值`S3E_KEYBOARD_CHAR_EVENT`来指示我们想要接收的是字符代码事件。
- en: The callback function we provide will now be sent a pointer to an `s3eKeyboardCharEvent`
    structure that contains a single member of type `s3eWChar` named `m_Char`. This
    member will contain the character code that was generated by the user.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供的回调函数现在将接收到一个指向`s3eKeyboardCharEvent`结构的指针，该结构包含一个名为`m_Char`的单个成员，其类型为`s3eWChar`。此成员将包含用户生成的字符代码。
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Character code input is really only recommended if you are running on a device
    with a physical keyboard, as using virtual keyboards on touch screen devices can
    be unreliable with many key presses going unnoticed, particularly when characters
    outside the normal ASCII character set are entered (for example, Chinese or Japanese
    text entry).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在具有物理键盘的设备上运行，字符代码输入才真正推荐使用，因为在使用触摸屏设备的虚拟键盘时，许多按键可能无法被可靠地检测到，尤其是在输入正常ASCII字符集之外的字符时（例如，中文或日文输入）。
- en: Inputting strings
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入字符串
- en: We've already seen how we can use the s3eKeyboard functionality to read character
    codes, but if we want to allow the user to enter a string and we don't mind our
    program forsaking its own user interface in favor of a standard modal string entry
    dialog, then we have a shortcut available to us.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使用`s3eKeyboard`功能来读取字符代码，但如果我们想要允许用户输入字符串，并且我们不在乎我们的程序放弃自己的用户界面而选择标准模式字符串输入对话框，那么我们有一个可用的快捷方式。
- en: The `s3eOSReadString` API makes string entry really simple; but it is not actually
    supported on every platform. To use this API we include the file `s3eOSReadString.h`,
    and then make a call to the function `s3eOSReadStringAvailable` to see if string
    entry functionality is available for use.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`s3eOSReadString` API使得字符串输入变得非常简单；但实际上并非每个平台都支持它。为了使用此API，我们需要包含文件`s3eOSReadString.h`，然后调用`函数s3eOSReadStringAvailable`来查看是否可以使用字符串输入功能。'
- en: If we are able to use the API, then we have two functions at our disposal. The
    first is `s3eOSReadStringUTF8`, which will display a string entry dialog and return
    a UTF-8 encoded string as a `const char` pointer. The second method is `s3eOSReadStringUTF8WithDefault`,
    which allows us to also specify a UTF-8 string that will be used to populate the
    string dialog when it appears.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够使用API，那么我们就有两个函数可供使用。第一个是`s3eOSReadStringUTF8`，它将显示一个字符串输入对话框，并以`const
    char`指针的形式返回UTF-8编码的字符串。第二个方法是`s3eOSReadStringUTF8WithDefault`，它允许我们指定一个UTF-8字符串，当对话框出现时，将使用此字符串填充字符串对话框。
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: UTF-8 is a widely used character format that allows full multilingual character
    support. It is often used when memory concerns are foremost, as single-byte characters
    such as the standard ASCII character set can still be represented in a single
    byte. Characters from outside the ASCII set (for example, Japanese Kanji) are
    encoded with two, three, or more bytes of information. One big advantage of UTF-8
    is that you can continue to use null-terminated strings since it is guaranteed
    that a zero byte will never form part of a valid character code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-8是一种广泛使用的字符格式，它允许完全的多语言字符支持。当内存问题最为关键时，它经常被使用，因为单字节字符，如标准ASCII字符集，仍然可以用一个字节表示。ASCII集之外的字符（例如，日文汉字）使用两个、三个或更多字节的信息进行编码。UTF-8的一个大优点是，您仍然可以使用空终止字符串，因为可以保证零字节永远不会成为有效字符代码的一部分。
- en: Both functions otherwise work in the same way. They both return a pointer to
    the string entered by the user (the API will take care of freeing this memory),
    or NULL if the user canceled the dialog.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数在其他方面的工作方式相同。它们都返回用户输入的字符串的指针（API将负责释放此内存），或者在用户取消对话框时返回NULL。
- en: 'They both also take an optional last parameter that can customize the layout
    of the string entry dialog. If the parameter is omitted or the value zero is passed,
    no restrictions are applied. The following table shows the other values that can
    be used:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 它们还都接受一个可选的最后一个参数，可以自定义字符串输入对话框的布局。如果省略参数或传递零值，则不应用任何限制。以下表格显示了可以使用的其他值：
- en: '| Value | Description |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 描述 |'
- en: '| --- | --- |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `S3E_OSREADSTRING_FLAG_EMAIL` | Indicates that we are expecting an e-mail
    address to be entered. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_OSREADSTRING_FLAG_EMAIL` | 表示我们期望输入一个电子邮件地址。 |'
- en: '| `S3E_OSREADSTRING_FLAG_NUMBER` | Indicates that we are expecting a numeric
    value to be entered. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_OSREADSTRING_FLAG_NUMBER` | 表示我们期望输入一个数值。 |'
- en: '| `S3E_OSREADSTRING_FLAG_PASSWORD` | Indicates that the application will use
    the OS method for entering a password, possibly hiding characters as they are
    entered. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_OSREADSTRING_FLAG_PASSWORD` | 表示应用程序将使用操作系统方法输入密码，可能隐藏输入时的字符。 |'
- en: '| `S3E_OSREADSTRING_FLAG_URL` | Indicates that we are expecting a URL to be
    entered. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_OSREADSTRING_FLAG_URL` | 表示我们期望输入一个URL。 |'
- en: When using these functions in an application, it is possible that the user may
    enter characters that we are then unable to process or display; this should be
    kept in mind, as generic string input may not always be a good choice (for example,
    you may be unable to display every possible character that can be entered using
    your game's font!).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当在应用程序中使用这些函数时，用户可能输入我们无法处理或显示的字符；这一点应予以注意，因为通用的字符串输入并不总是最佳选择（例如，您可能无法使用游戏字体显示所有可能的字符！）。
- en: Using this API will also likely break the look and feel of the game as its super
    whizzy UI is suddenly overlaid or replaced by a drab and boring system dialog.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此API也可能破坏游戏的视觉效果，因为其超级炫酷的用户界面突然被单调乏味的系统对话框覆盖或替换。
- en: These reasons, combined with the fact that it is not supported by all platforms,
    may mean that it is a better decision to implement our own in-game string entry
    routines. That being said, it is still a useful API to know about, if only for
    debugging purposes.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这些原因，加上它并非所有平台都支持的事实，可能意味着实现我们自己的游戏内字符串输入例程是一个更好的决定。尽管如此，如果只是为了调试目的，了解这个API仍然是有用的。
- en: Detecting touch screen and pointer input
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测触摸屏和指针输入
- en: There aren't many devices released these days that don't feature a touch screen.
    Most new devices have adopted this as the primary input method and have dropped
    physical buttons almost entirely.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在发布的设备中，没有多少不配备触摸屏。大多数新设备都将其作为主要输入方法，并且几乎完全放弃了物理按钮。
- en: In Marmalade we detect touch screen events using the **s3ePointer** API, which
    I have to admit is perhaps not the most obvious name for an API that handles touch
    screen input. To use this API in our own program we just need to include the `s3ePointer.h`
    file.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在Marmalade中，我们使用**s3ePointer** API检测触摸屏事件，我必须承认，对于处理触摸屏输入的API来说，这个名字可能不是最明显的。为了在我们的程序中使用此API，我们只需包含`s3ePointer.h`文件。
- en: The reason for this slightly bizarre naming is that when this API was first
    developed, touch screens were not commonplace. Instead, some devices had little
    joystick-style nubs that were able to move a pointer around the screen, much like
    a mouse on a computer.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这种略微奇怪的命名原因是，当这个API最初开发时，触摸屏并不常见。相反，一些设备有类似摇杆式的凸起，能够将指针在屏幕上移动，就像电脑上的鼠标一样。
- en: Due to the fact that touch screen input is primarily concerned with a screen
    coordinate and that it was unlikely that a device would arrive that had both touch
    screen and pointer inputs, the Marmalade SDK simply adapted the existing s3ePointer
    API to accommodate touch screens as well, since your finger or stylus is effectively
    a pointer anyway.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于触摸屏输入主要关注屏幕坐标，并且不太可能有一种设备同时具有触摸屏和指针输入，Marmalade SDK只是简单地调整了现有的s3ePointer API以适应触摸屏，因为你的手指或笔实际上就是一个指针。
- en: 'For the purpose of this chapter, whenever we talk about a position being "pointed
    at", we mean either an on-screen cursor has been moved to that position or a touch
    screen has had a contact made at that position. Positions are always returned
    as pixel positions relative to the top-left corner of the screen, as shown in
    the following diagram that shows what to expect on a device with a portrait HVGA
    screen size, such as a non-retina display iPhone:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本章的目的，当我们谈论一个位置被“指向”时，我们指的是屏幕上的光标被移动到该位置，或者触摸屏在该位置有接触。位置总是以相对于屏幕左上角的像素位置返回，如下面的图示所示，它显示了在具有竖屏HVGA屏幕尺寸的设备上可以期待的内容，例如非视网膜显示屏的iPhone：
- en: '![Detecting touch screen and pointer input](img/3363_03_01.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![检测触摸屏和指针输入](img/3363_03_01.jpg)'
- en: In the following sections, we will learn how to discover the capabilities available
    for use on the device we are running on and how to handle both single and multi-touch
    screens.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将学习如何发现我们正在运行的设备上可用的功能，以及如何处理单点和多点触摸屏。
- en: Determining available pointer functionality
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定可用的指针功能
- en: We use the function `s3ePointerGetInt` to determine the properties of the hardware
    we are running on. We pass in one of the values in the following table, and we
    can then use the result to tailor our input methodology accordingly.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`s3ePointerGetInt`函数来确定我们正在运行的硬件的特性。我们传入以下表格中的一个值，然后我们可以使用结果相应地调整我们的输入方法。
- en: '| Property | Description |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 描述 |'
- en: '| --- | --- |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `S3E_POINTER_AVAILABLE` | Returns `1` if we can use the s3ePointer API on
    the device, or `0` if we can''t. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_POINTER_AVAILABLE` | 如果我们可以在设备上使用s3ePointer API，则返回`1`，否则返回`0`。 |'
- en: '| `S3E_POINTER_HIDE_CURSOR` | If the system has some kind of mouse pointer-like
    cursor displayed on screen, this property will return 1 if the pointer is currently
    visible, otherwise it returns `0`. This property can also be used in the `s3ePointerSetInt`
    function to show and hide the cursor. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_POINTER_HIDE_CURSOR` | 如果系统在屏幕上显示某种类似鼠标指针的光标，此属性将返回1，如果指针当前可见，否则返回`0`。此属性也可以在`s3ePointerSetInt`函数中使用来显示和隐藏光标。
    |'
- en: '| `S3E_POINTER_TYPE` | This will return the type of pointer we have at our
    disposal. See the next sub-section for more information on this. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_POINTER_TYPE` | 这将返回我们可用的指针类型。有关更多信息，请参阅下一小节。 |'
- en: '| `S3E_POINTER_STYLUS_TYPE` | This will return the type of stylus our device
    uses. See the next sub-section for more information on this. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_POINTER_STYLUS_TYPE` | 这将返回我们设备使用的笔的类型。有关更多信息，请参阅下一小节。 |'
- en: '| `S3E_POINTER_MULTI_TOUCH_AVAILABLE` | If the device supports multi-touch
    (being able to detect more than one press on the touch screen at a time) the value
    `1` will be returned. Single touch devices will return `0`. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_POINTER_MULTI_TOUCH_AVAILABLE` | 如果设备支持多点触摸（能够在触摸屏上同时检测多个触摸），将返回值`1`。单点触摸设备将返回`0`。
    |'
- en: For most game code, it is usually enough to first use the `S3E_POINTER_AVAILABLE`
    property to see if we have pointer capability available and the `S3E_POINTER_MULTI_TOUCH_AVAILABLE`
    property to configure our input methodology appropriately.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数游戏代码，通常首先使用 `S3E_POINTER_AVAILABLE` 属性来查看我们是否有指针能力可用，并使用 `S3E_POINTER_MULTI_TOUCH_AVAILABLE`
    属性来适当地配置我们的输入方法。
- en: Determining the type of pointer input
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确定指针输入类型
- en: When supplying the property type `S3E_POINTER_TYPE` to `s3ePointerGetInt`, the
    return value is one from the `s3ePointerType` enumeration.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当向 `s3ePointerGetInt` 传递属性类型 `S3E_POINTER_TYPE` 时，返回值是来自 `s3ePointerType` 枚举中的一个值。
- en: '| Return Value | Description |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 返回值 | 描述 |'
- en: '| --- | --- |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `S3E_POINTER_TYPE_INVALID` | Invalid request. The most likely cause is that
    the s3ePointer API is not available on this device. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_POINTER_TYPE_INVALID` | 无效请求。最可能的原因是s3ePointer API在此设备上不可用。 |'
- en: '| `S3E_POINTER_TYPE_MOUSE` | Pointer input is coming from a device that features
    an on-screen cursor to indicate position. The cursor may be controlled by a mouse
    or some other input device, such as a joystick. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_POINTER_TYPE_MOUSE` | 指针输入来自具有屏幕光标以指示位置的设备。光标可能由鼠标或其他输入设备，如游戏手柄控制。 |'
- en: '| `S3E_POINTER_TYPE_STYLUS` | Pointer input is from a stylus-based input method,
    most likely a touch screen of some sort. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_POINTER_TYPE_STYLUS` | 指针输入来自基于笔输入的方法，很可能是某种触摸屏。 |'
- en: In the majority of cases this distinction is not normally that important, but
    it might be relevant if you need to track the movement of the pointer.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，这种区别通常并不重要，但如果您需要跟踪指针的移动，它可能是有意义的。
- en: With a mouse, our code will receive events whenever the pointer is moved across
    the screen, whether a mouse button is held or not. On a touch screen, we will
    obviously only receive movement events when the screen is being touched.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用鼠标时，我们的代码会在指针在屏幕上移动时接收事件，无论鼠标按钮是否被按下。在触摸屏上，我们显然只有在屏幕被触摸时才会接收到移动事件。
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is most notable when running on the simulator, as we will receive pointer
    events whenever the mouse pointer is moved within the bounds of the simulator
    window.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这在模拟器上运行时尤为明显，因为只要鼠标指针在模拟器窗口的边界内移动，我们就会接收到指针事件。
- en: Determining the type of stylus input
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确定笔输入类型
- en: 'If we use `s3ePointerGetInt` with the property `S3E_POINTER_TYPE` and get the
    return type `S3E_POINTER_TYPE_STYLUS`, we can interrogate a little further to
    find out what type of stylus we will be using by calling `s3ePointerGetInt` again
    with the property `S3E_POINTER_STYLUS_TYPE`. The return values possible are in
    the following table:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `s3ePointerGetInt` 与属性 `S3E_POINTER_TYPE` 并得到返回类型 `S3E_POINTER_TYPE_STYLUS`，我们可以通过再次调用
    `s3ePointerGetInt` 并使用属性 `S3E_POINTER_STYLUS_TYPE` 来进一步调查我们将使用哪种类型的笔。可能的返回值如下表所示：
- en: '| Return Value | Description |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 返回值 | 描述 |'
- en: '| --- | --- |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `S3E_STYLUS_TYPE_INVALID` | Call was invalid; most likely because we are
    not running on a hardware that uses a stylus. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_STYLUS_TYPE_INVALID` | 调用无效；最可能的原因是我们没有在使用笔的硬件上运行。 |'
- en: '| `S3E_STYLUS_TYPE_STYLUS` | Inputs are made by touching a stylus to the input
    surface. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_STYLUS_TYPE_STYLUS` | 输入是通过用笔触摸输入表面来进行的。 |'
- en: '| `S3E_STYLUS_TYPE_FINGER` | Inputs are made by touching a finger to the input
    surface. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_STYLUS_TYPE_FINGER` | 输入是通过用手指触摸输入表面来进行的。 |'
- en: This is probably not a distinction that we will need to worry about in most
    cases, but it might be useful to know so that games can be made more forgiving
    about inputs when they are made with a finger, since a stylus has a much smaller
    contact surface and should therefore allow for a far more accurate input.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能不是我们需要担心的大部分情况中的区别，但了解这一点可能对游戏在用手指进行输入时更加宽容是有用的，因为笔的接触面积要小得多，因此应该允许更精确的输入。
- en: Updating current pointer input status
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新当前指针输入状态
- en: In order to keep the s3ePointer API up-to-date with current touch screen inputs,
    it is necessary to call the `s3ePointerUpdate` function once per frame. This will
    update the cache of the current pointer status that is maintained within the s3ePointer
    API.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 s3ePointer API 与当前的触摸屏输入保持最新，有必要在每一帧中调用一次 `s3ePointerUpdate` 函数。这将更新 s3ePointer
    API 内维护的当前指针状态缓存。
- en: Detecting single touch input
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测单点触控输入
- en: If the s3ePointer API is available on our device, we are guaranteed to be able
    to detect and respond to the user touching the screen and moving their stylus
    or finger about, or moving an on-screen cursor around and pressing some kind of
    selection button.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的设备上提供了 s3ePointer API，我们就有保证能够检测并响应用户触摸屏幕、移动他们的笔或手指，或者移动屏幕上的光标并按下某种选择按钮。
- en: Even if our hardware supports multi-touch, we can still make use of single touch
    input if our game has no need to know about multiple simultaneous touch points.
    This may make it a little simpler to code our game, as we don't need to worry
    about issues such as two buttons on our user interface being pressed at the same
    time.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们的硬件支持多点触摸，如果我们的游戏不需要知道多个同时触摸点，我们仍然可以利用单点触摸输入。这可能使得编写我们的游戏代码变得稍微简单一些，因为我们不需要担心用户界面上的两个按钮同时被按下的这类问题。
- en: As with key input, we can choose to use either a polled or callback-based approach.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 就像键输入一样，我们可以选择使用轮询或回调方法。
- en: Detecting single touch input using polling
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用轮询检测单点触摸输入
- en: We can determine the current on-screen position being pointed at (either by
    the on-screen cursor or a touch on the screen) by using the `s3ePointerGetX` and
    `s3ePointerGetY` functions, which will return the current horizontal and vertical
    pixel positions being pointed at.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `s3ePointerGetX` 和 `s3ePointerGetY` 函数来确定当前被指向的屏幕上的位置（无论是屏幕上的光标还是屏幕上的触摸），这两个函数将返回当前指向的水平像素位置和垂直像素位置。
- en: In the case of a touch screen, the current position returned by these functions
    will be the last known position pointed at if the user is not currently making
    an input. The default value before any touches have been made will be (0,0)—the
    top-left corner of the screen.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在触摸屏的情况下，如果用户当前没有进行输入，这些函数返回的当前位置将是用户最后已知的位置。在触摸之前，默认值将是 (0,0)——屏幕的左上角。
- en: 'To determine whether an input is currently in progress, we can use the function
    `s3ePointerGetState`, which takes an element from the `s3ePointerButton` enumeration
    and returns a value from the `s3ePointerState` enumeration. The following table
    shows the values that make up the `s3ePointerButton` enumeration:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定当前是否有输入正在进行，我们可以使用 `s3ePointerGetState` 函数，它从一个 `s3ePointerButton` 枚举元素中获取一个元素，并返回一个
    `s3ePointerState` 枚举的值。以下表格显示了组成 `s3ePointerButton` 枚举的值：
- en: '| Value | Description |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 描述 |'
- en: '| --- | --- |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `S3E_POINTER_BUTTON_SELECT` | Returns the status of either the left mouse
    button or a touch screen tap. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_POINTER_BUTTON_SELECT` | 返回左鼠标按钮或触摸屏点击的状态。|'
- en: '| `S3E_POINTER_BUTTON_LEFTMOUSE` | An alternative name for `S3E_POINTER_BUTTON_SELECT`,
    which you may prefer to use if detecting other mouse buttons as well. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_POINTER_BUTTON_LEFTMOUSE` | `S3E_POINTER_BUTTON_SELECT` 的一个备选名称，如果您还需要检测其他鼠标按钮，可能会更愿意使用它。|'
- en: '| `S3E_POINTER_BUTTON_RIGHTMOUSE` | Returns the status of the right mouse button.
    |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_POINTER_BUTTON_RIGHTMOUSE` | 返回右鼠标按钮的状态。|'
- en: '| `S3E_POINTER_BUTTON_MIDDLEMOUSE` | Returns the status of the middle mouse
    button. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_POINTER_BUTTON_MIDDLEMOUSE` | 返回中鼠标按钮的状态。|'
- en: '| `S3E_POINTER_BUTTON_MOUSEWHEELUP` | Used to determine if the user has scrolled
    the mouse wheel upwards. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_POINTER_BUTTON_MOUSEWHEELUP` | 用于确定用户是否向上滚动鼠标滚轮。|'
- en: '| `S3E_POINTER_BUTTON_MOUSEWHEELDOWN` | Used to determine if the user has scrolled
    the mouse wheel downwards. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_POINTER_BUTTON_MOUSEWHEELDOWN` | 用于确定用户是否向下滚动鼠标滚轮。|'
- en: 'The next table shows the members of the `s3ePointerState` enumeration, which
    indicate the current status of the requested pointer button or touch screen tap:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个表格显示了 `s3ePointerState` 枚举的成员，它们指示请求的指针按钮或触摸屏点击的当前状态：
- en: '| Value | Description |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 描述 |'
- en: '| --- | --- |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `S3E_POINTER_STATE_UP` | The button is not depressed or contact is not currently
    made with the touch screen. |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_POINTER_STATE_UP` | 按钮没有被按下或当前没有与触摸屏建立接触。|'
- en: '| `S3E_POINTER_STATE_DOWN` | The button is being held down or contact has been
    made with the touch screen. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_POINTER_STATE_DOWN` | 按钮正在被按下或与触摸屏建立了接触。|'
- en: '| `S3E_POINTER_STATE_PRESSED` | The button or touch screen has just been pressed.
    |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_POINTER_STATE_PRESSED` | 按钮或触摸屏刚刚被按下。|'
- en: '| `S3E_POINTER_STATE_RELEASED` | The button or touch screen has just been released.
    |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_POINTER_STATE_RELEASED` | 按钮或触摸屏刚刚被释放。|'
- en: '| `S3E_POINTER_STATE_UNKNOWN` | Current status of this button is not known.
    For example, the middle mouse button status was requested but there is no middle
    mouse button present on the hardware. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `S3E_POINTER_STATE_UNKNOWN` | 当前按钮的状态未知。例如，请求了中间鼠标按钮的状态，但在硬件上没有中间鼠标按钮。|'
- en: With this information we now have the ability to track the pointer or touch
    screen position and determine when the user has touched or released the touch
    screen or pressed a mouse button.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些信息，我们现在能够跟踪指针或触摸屏位置，并确定用户何时触摸或释放触摸屏或按下鼠标按钮。
- en: Detecting single touch input using callbacks
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用回调检测单个触摸输入
- en: It is also possible to keep track of pointer events using a callback-based system.
    For single touch input, there are two event types that we can register callback
    functions for; these are button and motion events.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于回调的系统跟踪指针事件也是可能的。对于单点触摸输入，我们可以为两种事件类型注册回调函数；这些是按钮和移动事件。
- en: We can start receiving pointer events by calling the `s3ePointerRegister` function,
    and we can stop them by calling `s3ePointerUnRegister`. Both functions take a
    value to identify the type of event we are concerned with, and a pointer to a
    callback function.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用`s3ePointerRegister`函数开始接收指针事件，并且可以通过调用`s3ePointerUnRegister`函数停止它们。这两个函数都接受一个值来标识我们关心的事件类型，以及一个指向回调函数的指针。
- en: When registering a callback function, we can also provide a pointer to our own
    custom data structure that will be passed into the callback function whenever
    an event occurs.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在注册回调函数时，我们还可以提供一个指向我们自己的自定义数据结构的指针，该数据结构将在事件发生时传递给回调函数。
- en: 'The following code snippet shows how we can register a callback function that
    will be executed whenever the touch screen or a mouse button is pressed or released:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了我们可以如何注册一个回调函数，该函数将在触摸屏或鼠标按钮被按下或释放时执行：
- en: '[PRE4]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The button event callback's first parameter is a pointer to an `s3ePointerEvent`
    structure that contains four members. The button that was pressed is stored in
    a member called `m_Button` that is of the type `s3ePointerButton` (see the table
    in the *Detecting single touch input using polling* section earlier in this chapter
    for more details on this enumerated type).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮事件回调的第一个参数是一个指向`s3ePointerEvent`结构的指针，该结构包含四个成员。被按下的按钮存储在一个名为`m_Button`的成员中，其类型为`s3ePointerButton`（有关此枚举类型的更多详细信息，请参阅本章前面的*使用轮询检测单个触摸输入*部分）。
- en: The `m_Pressed` member will be `0` if the button was released and `1` if it
    was pressed. You might expect this to be of type `bool` rather than an integer
    but it isn't, because this is a C-based API, not C++-based and `bool` is not a
    part of the standard C language.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按钮被释放，则`m_Pressed`成员将为`0`，如果被按下，则为`1`。您可能期望这将是`bool`类型而不是整数，但事实并非如此，因为这是一个基于C的API，而不是基于C++的，并且`bool`不是标准C语言的一部分。
- en: We can also discover the screen position where the event occurred by using the
    structure's `m_x` and `m_y` members.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过使用结构的`m_x`和`m_y`成员来发现事件发生的屏幕位置。
- en: It is also possible to register a callback that will inform us when the user
    has performed a pointer motion. We again use the `s3ePointerRegister`/`s3ePointerUnRegister`
    functions, but this time use `S3E_POINTER_MOTION_EVENT` as the callback type.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以注册一个回调，当用户执行指针移动操作时，它会通知我们。我们再次使用`s3ePointerRegister`/`s3ePointerUnRegister`函数，但这次使用`S3E_POINTER_MOTION_EVENT`作为回调类型。
- en: The callback function we register will be passed a pointer to an `s3ePointerMotionEvent`
    structure that consists of just `m_x` and `m_y` members containing the screen
    coordinate that is now being pointed at.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注册的回调函数将传递一个指向`s3ePointerMotionEvent`结构的指针，该结构仅包含`m_x`和`m_y`成员，这些成员包含当前被指向的屏幕坐标。
- en: Detecting multi-touch input
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测多点触摸输入
- en: A multi-touch capable display allows us to detect more than one touched point
    on the screen at a time. Every time the screen is touched, the device's OS will
    assign that touch point an ID number. As the user moves their finger around the
    screen, the coordinates associated with that ID number will be updated until the
    user removes their finger from the screen, whereupon that touch will become inactive
    and the ID number becomes invalid.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一款支持多点触控的显示屏使我们能够同时检测屏幕上的多个触摸点。每次触摸屏幕时，设备的操作系统都会为该触摸点分配一个ID号码。当用户在屏幕上移动手指时，与该ID号码关联的坐标将会更新，直到用户将手指从屏幕上移开，此时该触摸将变为不活跃状态，ID号码也变得无效。
- en: While Marmalade does provide a polling-based approach to handling multi-touch
    events, the callback approach is possibly the better choice as it leads to slightly
    more elegant code and is a little more efficient.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Marmalade 提供了基于轮询的多点触控事件处理方法，但回调方法可能是更好的选择，因为它会导致代码更加优雅，并且效率略高。
- en: Detecting multi-touch input using polling
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用轮询检测多点触控输入
- en: Marmalade provides us with a set of functions to allow multi-touch detection.
    The functions `s3ePointerGetTouchState`, `s3ePointerGetTouchX`, and `s3ePointerGetTouchY`
    are equivalent to the single touch functions `s3ePointerGetState`, `s3ePointerGetX`,
    and `s3ePointerGetY`, except that the multi-touch versions take a single parameter—the
    touch ID number.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Marmalade 提供了一组函数，允许多点触控检测。函数 `s3ePointerGetTouchState`、`s3ePointerGetTouchX`
    和 `s3ePointerGetTouchY` 与单点触控函数 `s3ePointerGetState`、`s3ePointerGetX` 和 `s3ePointerGetY`
    相当，但多点触控版本接受一个单一参数——触摸 ID 号。
- en: The s3ePointer API also declares a preprocessor define `S3E_POINTER_TOUCH_MAX`
    that indicates the maximum possible value for the touch ID number (plus one!).
    As the user touches and releases the display, the touch ID numbers will be re-used.
    It is important to bear this in mind.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: s3ePointer API 还声明了一个预处理定义 `S3E_POINTER_TOUCH_MAX`，它表示触摸 ID 号可能的最大值（加一！）。当用户触摸和释放显示时，触摸
    ID 号将被重用。这一点非常重要。
- en: 'The following code snippet shows a loop that will allow us to process the currently
    active touch points:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了循环，它将允许我们处理当前活跃的触摸点：
- en: '[PRE5]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The biggest issue with this approach is that Marmalade never sends us an explicit
    notification that a touch event has just occurred. The `s3ePointerGetTouchState`
    function never returns `S3E_POINTER_STATE_PRESSED`, so instead we need to keep
    track of all touch IDs we have seen active so far when handling `S3E_POINTER_STATE_DOWN`.
    If a new touch ID is seen, we have detected the just-pressed condition.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法最大的问题是 Marmalade 从未向我们发送一个明确的通知，表明一个触摸事件刚刚发生。`s3ePointerGetTouchState` 函数永远不会返回
    `S3E_POINTER_STATE_PRESSED`，因此我们需要在处理 `S3E_POINTER_STATE_DOWN` 时跟踪迄今为止所有已看到的活跃触摸
    ID。如果看到一个新触摸 ID，我们就检测到了刚刚按下的条件。
- en: While this code will work, I hope you will find that the callback-based approach
    that we are about to consider leads to a slightly more elegant solution.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码可以工作，但我希望你会觉得我们即将考虑的基于回调的方法会带来一个稍微更优雅的解决方案。
- en: Multi-touch input using callbacks
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用回调的多点触控输入
- en: As with the polling approach, multi-touch detection using callbacks is almost
    exactly the same as the single touch callback method. We still use `s3ePointerRegister`
    and `s3ePointerUnRegister` to start and stop events being sent to our code, but
    instead we use `S3E_POINTER_TOUCH_EVENT` to receive notifications of the user
    pressing or releasing the screen, and `S3E_POINTER_TOUCH_MOTION_EVENT` to find
    out when the user has dragged their finger across the screen.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 与轮询方法一样，使用回调的多点触控检测几乎与单点触控回调方法完全相同。我们仍然使用 `s3ePointerRegister` 和 `s3ePointerUnRegister`
    来开始和停止事件发送到我们的代码，但这次我们使用 `S3E_POINTER_TOUCH_EVENT` 来接收用户按下或释放屏幕的通知，以及使用 `S3E_POINTER_TOUCH_MOTION_EVENT`
    来找出用户何时在屏幕上拖动手指。
- en: The callback function registered to `S3E_POINTER_TOUCH_EVENT` will be sent a
    pointer to an `s3ePointerTouchEvent` structure. This structure contains the screen
    coordinates where the event occurred (the `m_x` and `m_y` members), whether the
    screen was touched or released (the `m_Pressed` member, which will be set to `1`
    if the screen was touched), and most importantly the ID number for this touch
    event (the `m_TouchID` member), which we can use to keep track of this touch as
    the user moves their finger around the display.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注册到 `S3E_POINTER_TOUCH_EVENT` 的回调函数将接收到一个指向 `s3ePointerTouchEvent` 结构体的指针。这个结构体包含了事件发生的屏幕坐标（`m_x`
    和 `m_y` 成员），屏幕是否被触摸或释放（`m_Pressed` 成员，如果屏幕被触摸，则设置为 `1`），最重要的是，这个触摸事件的 ID 号（`m_TouchID`
    成员），我们可以使用它来跟踪用户在显示上移动手指时的触摸情况。
- en: The `S3E_POINTER_TOUCH_MOTION_EVENT` callback will receive a pointer to an `s3ePointerTouchMotionEvent`
    structure. This structure contains the ID number of the touch event that has been
    updated and the new screen coordinate values. These structure members have the
    same names as their equivalent members in the `s3ePointerTouchEvent` structure.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`S3E_POINTER_TOUCH_MOTION_EVENT` 回调将接收一个指向 `s3ePointerTouchMotionEvent` 结构体的指针。这个结构体包含了被更新的触摸事件的
    ID 号以及新的屏幕坐标值。这些结构体成员的名称与 `s3ePointerTouchEvent` 结构体中对应的成员名称相同。'
- en: Marmalade provides us with no way of adjusting the frequency of touch events.
    Instead, it is really just dependant on how often the underlying operating system
    code dispatches such events.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Marmalade 并没有提供调整触摸事件频率的方法。相反，它实际上完全依赖于底层操作系统代码调度这些事件的多频繁。
- en: Hopefully you can see that the callback-based method is a little neater than
    the polled method. Firstly, we can say goodbye to the truly nasty loop needed
    in the polled method to detect all currently active touches.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你能看出基于回调的方法比轮询方法更为整洁。首先，我们可以告别轮询方法中用于检测所有当前活动触摸点的真正讨厌的循环。
- en: Secondly, with careful coding we can use the same code path to handle both single
    and multi-touch input. If we code first for multi-touch input, then making single
    touch work is simply a case of adding a fake touch ID to incoming single touch
    events and passing them through to the multi-touch code.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，通过仔细的编码，我们可以使用相同的代码路径来处理单点和多点触摸输入。如果我们首先为多点触摸输入编写代码，那么让单点触摸工作就简单地将一个假的触摸
    ID 添加到传入的单点触摸事件中，并将它们传递到多点触摸代码中。
- en: Recognizing gesture inputs
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别手势输入
- en: The arrival of the touch screen to mobile devices brought with it a new set
    of terminology related to making inputs to our programs. For years we have been
    using a mouse, clicking and dragging to interact with programs, and now with touch
    screens we have quickly become comfortable with the idea of swiping and pinching.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 触摸屏的出现给移动设备带来了与向我们的程序输入相关的一系列新术语。多年来，我们一直使用鼠标，点击和拖动来与程序交互，而现在随着触摸屏的出现，我们很快就习惯了滑动和捏合的概念。
- en: These methods of interaction have become known as **gestures** and users have
    become so used to them now that if your application doesn't respond as they expect,
    they may get quickly frustrated with your application.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这些交互方法被称为**手势**，并且用户已经习惯了它们，现在如果你的应用程序没有按照他们的预期响应，他们可能会很快对你的应用程序感到沮丧。
- en: Unfortunately, Marmalade does not provide any support for detecting these gestures,
    so instead we have to code for them ourselves. The following sections aim to provide
    some guidance on how to easily detect both swipes and pinches.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Marmalade 并不提供检测这些手势的支持，因此我们不得不自己编写代码来实现。以下章节旨在提供一些指导，说明如何轻松地检测滑动和捏合手势。
- en: Detecting a swipe gesture
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检测滑动手势
- en: A swipe occurs when the user touches the screen and then slides that touch point
    quickly across the screen before releasing the screen.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户触摸屏幕，然后快速滑动触摸点并在释放屏幕之前将其移动到屏幕上时，就会发生滑动。
- en: To detect a swipe we must therefore first keep track of the screen coordinates
    where the user touched the screen and the time at which this occurred. When this
    touch event comes to an end due to the user releasing the screen, we first check
    the time it lasted for. If the length of time is not too long (say less than a
    quarter of a second), we check the distance between the start and end points.
    If this distance is large enough (perhaps a hundred pixels in length, or a fraction
    of the screen display size), then we have detected a swipe.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要检测滑动，我们首先必须跟踪用户触摸屏幕的屏幕坐标和触摸发生的时间。当这个触摸事件因为用户释放屏幕而结束时，我们首先检查它持续了多长时间。如果持续时间不长（比如说不到四分之一秒），我们检查起点和终点之间的距离。如果这个距离足够大（可能是一百像素的长度，或者屏幕显示尺寸的一部分），那么我们就检测到了滑动。
- en: 'Often we only want to respond to a swipe if it is in a certain direction. We
    can determine this by using the dot product, the formula for which is shown in
    the following diagram:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 通常我们只想对特定方向上的滑动做出响应。我们可以通过点积来确定这一点，其公式如下所示：
- en: '![Detecting a swipe gesture](img/3363_03_02.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![检测滑动手势](img/3363_03_02.jpg)'
- en: The dot product is calculated by multiplying the x and y components of the two
    vectors together and summing the results, or by multiplying the length of the
    two vectors together and then multiplying by the cosine of the angle between the
    two vectors.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 点积是通过将两个向量的 x 和 y 分量相乘并将结果相加来计算的，或者通过将两个向量的长度相乘，然后乘以两个向量之间角度的余弦值来计算。
- en: To check if the user's swipe lies in a particular direction, we first make the
    direction of the swipe into a unit vector, then dot product this with a unit vector
    in the desired swipe direction. By using unit vectors we reduce the formula on
    the left-hand side of the previous diagram to just the cosine of the angle between
    the vectors, so it is now very simple to see if our swipe lies along the desired
    direction.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查用户的滑动是否在特定方向，我们首先将滑动方向转换为单位向量，然后将它与期望滑动方向的单位向量进行点积。通过使用单位向量，我们将前一个图中左侧的公式简化为两个向量之间角度的余弦值，因此现在很容易看出我们的滑动是否沿着期望的方向。
- en: If the dot product value is very close to 1, then our two direction vectors
    are close to being parallel, since *cos(0°) = 1*, and we've detected a swipe in
    the required direction. Similarly, if the dot product is close to -1, we've detected
    a swipe in the opposite direction, as *cos(180°) = -1*.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果点积值非常接近1，那么我们的两个方向向量几乎是平行的，因为*cos(0°) = 1*，我们已经检测到沿所需方向的滑动。同样，如果点积接近-1，我们检测到沿相反方向的滑动，因为*cos(180°)
    = -1*。
- en: Detecting a pinch gesture
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检测捏合手势
- en: Pinch gestures can only be used on devices featuring multi-touch displays, since
    they require two simultaneous touch points. A pinch gesture is often used to allow
    zooming in and out to occur and is performed by placing two fingers on the screen
    and then moving them together or apart. This is most easily achieved using the
    thumb and index finger.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 捏合手势只能在具有多点触控显示的设备上使用，因为它们需要两个同时存在的触摸点。捏合手势通常用于允许放大和缩小，是通过在屏幕上放置两个手指然后移动它们靠近或分开来实现的。这最容易被拇指和食指完成。
- en: Detecting a pinch gesture in code is actually quite simple. As soon as we have
    detected two touch points on the screen, we calculate a vector from one point
    to the other and find the distance of this vector. This is stored as the initial
    distance and will represent no zooming.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中检测捏合手势实际上相当简单。一旦我们在屏幕上检测到两个触摸点，我们就计算从一个点到另一个点的向量，并找到这个向量的距离。这个距离被存储为初始距离，并将表示无缩放。
- en: As the user moves their fingers around the screen, we just keep calculating
    the new distance between the two touch points, and then divide this distance by
    the original distance. The end result of this calculation is a zoom scale factor.
    If the user moves their fingers together, the zoom factor will be less than one;
    if they move them apart, the zoom value will be greater than one.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在屏幕上移动手指时，我们只需不断计算两个触摸点之间的新距离，然后将这个距离除以原始距离。这个计算的结果是缩放比例因子。如果用户将手指靠在一起，缩放因子将小于1；如果他们分开手指，缩放值将大于1。
- en: The pinch gesture is complete once the user removes at least one finger from
    the display.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 用户从显示中移除至少一个手指后，捏合手势才算完成。
- en: Detecting accelerometer input
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测加速度计输入
- en: The final input method we will be considering in this chapter is the **accelerometer**,
    which allows us to detect the orientation that the user is currently holding the
    device at. An accelerometer is a sensor that can measure the forces applied to
    a device, be they static forces such as gravity, or dynamic forces generated by
    waving the device around.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将考虑的最后一个输入方法是**加速度计**，它允许我们检测用户当前持握设备时的方向。加速度计是一种可以测量作用于设备的力的传感器，无论是静态力，如重力，还是由在设备周围挥动产生的动态力。
- en: Most devices will have three accelerometers aligned perpendicularly to each
    other, as shown in the following diagram. This configuration allows us to discover
    exactly how the user is holding the device at any time and so provides a method
    of controlling our game.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数设备将有三只加速度计垂直排列，如下面的图所示。这种配置使我们能够确切地发现用户在任何时候如何持握设备，因此为我们提供了控制游戏的方法。
- en: '![Detecting accelerometer input](img/3363_03_03.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![检测加速度计输入](img/3363_03_03.jpg)'
- en: The directions of the arrows in the previous diagram show the directions in
    which acceleration will yield a positive value. This means that if you hold the
    device level with the display upwards in front of you, tipping it to the right
    will yield a positive value on the x axis accelerometer, tipping it away from
    you will generate positive y axis values and moving the device vertically upwards
    will generate a positive z axis value.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个图中箭头的方向表示加速度将产生正值的方向。这意味着如果你将设备水平放置，显示向上，在你面前倾斜，则x轴加速度计将产生正值；如果你将它远离你，则y轴将产生正值；将设备垂直向上移动将产生z轴的正值。
- en: The Marmalade SDK provides us with access to the accelerometers of a device
    using the s3eAccelerometer API, which we can use in our code by including the
    `s3eAccelerometer.h` file.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Marmalade SDK通过`s3eAccelerometer` API为我们提供了访问设备加速度计的权限，我们可以在代码中通过包含`s3eAccelerometer.h`文件来使用它。
- en: Starting and stopping accelerometer input
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始和停止加速度计输入
- en: 'Before attempting to use the accelerometer in our program, we must first check
    to see if accelerometer input is available on our device. If support is available,
    then we can start receiving accelerometer input. We do this with the following
    check:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试在我们的程序中使用加速度计之前，我们必须首先检查我们的设备上是否提供了加速度计输入。如果支持可用，那么我们可以开始接收加速度计输入。我们通过以下检查来完成：
- en: '[PRE6]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When we have finished using the accelerometers, we just make a call to `s3eAccelerometerStop`
    and we will receive no further inputs.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成使用加速度计时，我们只需调用`s3eAccelerometerStop`，我们就不会再收到进一步的输入。
- en: Note
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is good practice on mobile devices to ensure that we only enable parts of
    the hardware when we are actually using them, since this helps to conserve battery
    power. In the case of accelerometers, the power use is probably so small that
    it is insignificant, but this is an area of mobile game programming that is always
    worth keeping in mind.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动设备上，确保我们只在实际使用时启用硬件的部分是一种良好的做法，因为这有助于节省电池电量。在加速度计的情况下，功耗可能非常小，以至于可以忽略不计，但这是移动游戏编程中始终值得牢记的领域。
- en: Reading accelerometer input
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取加速度计输入
- en: Finding the current accelerometer input values is really very simple. Marmalade
    provides three functions which return the current accelerometer value for each
    axis. These functions are called `s3eAccelerometerGetX`, `s3eAccelerometerGetY`,
    and `s3eAccelerometerGetZ`. Unsurprisingly, they return the current value of the
    accelerometer for the specified axis.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 查找当前的加速度计输入值非常简单。Marmalade提供了三个函数，这些函数返回每个轴的当前加速度计值。这些函数分别称为`s3eAccelerometerGetX`、`s3eAccelerometerGetY`和`s3eAccelerometerGetZ`。不出所料，它们返回指定轴的加速度计当前值。
- en: The values returned by these functions use a value of 1000 (though we should
    use the handy definition `S3E_ACCELEROMETER_1G` to avoid magic numbers in our
    code!) to represent an acceleration equivalent to normal Earth gravity.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数返回的值使用1000（尽管我们应该使用方便的定义`S3E_ACCELEROMETER_1G`以避免代码中的魔法数字！）来表示相当于正常地球重力的加速度。
- en: When a sharp, quick movement is made to the device, the forces being applied
    to it will be greater than the normal gravitational force. In this case, the magnitude
    of the vector formed from the accelerometer values will be greater than `S3E_ACCELEROMETER_1G`.
    This can be a useful way of detecting whether the user has been shaking the device.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当对设备进行尖锐、快速的运动时，作用在设备上的力将大于正常重力。在这种情况下，由加速度计值形成的向量的大小将大于`S3E_ACCELEROMETER_1G`。这可以是一种检测用户是否在摇晃设备的有效方法。
- en: If the device were to be horizontally on a table, we should get a value of `0`
    returned for both the X and Y axes, and `-1000` for the z axis, since gravity
    acts downwards! As we rotate the device, the values returned will form a vector
    showing the direction in which gravity is acting, and we can then use this to
    determine the orientation of the device.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设备在桌面上水平放置，我们应该为X和Y轴返回`0`的值，为z轴返回`-1000`，因为重力是向下的！当我们旋转设备时，返回的值将形成一个向量，显示重力作用的方向，然后我们可以使用这个向量来确定设备的方向。
- en: Using some trigonometry, we can work out the angle of tip around the x axis
    (forward/backward) and Y-axis (left/right). The angle around the X-axis can be
    found by taking the arc tan of the Y-accelerometer value divided by the Z value.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一些三角函数，我们可以计算出围绕x轴（向前/向后）和Y轴（左/右）的尖端角度。X轴周围的角可以通过计算Y加速度计值除以Z值的反正切得到。
- en: The angle around the y axis is a little trickier. First we have to find the
    length of the accelerometer vector projected onto the YZ plane, then we can find
    the arc tan of the X-accelerometer value divided by the projected length.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Y轴周围的角稍微有点复杂。首先，我们必须找到加速度计向量在YZ平面上的投影长度，然后我们可以找到X加速度计值除以投影长度的反正切。
- en: If all this sounds like too much scary math, the following code snippet does
    it all for us. Note than when calculating the rotation around the x axis using
    the `IwGeomAtan2` function, we negate both the Y- and Z-accelerometer values in
    order to yield a more usable result range, with 0 degrees returned when the device
    is level and increasing values when tipped away from the user.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这一切听起来像太多的可怕数学，以下代码片段为我们完成了所有工作。注意，当使用 `IwGeomAtan2` 函数计算绕 x 轴的旋转时，我们会对 Y-和
    Z-加速度计值取反，以获得更可用的结果范围，当设备水平时返回 0 度，当倾斜远离用户时返回增加的值。
- en: '[PRE7]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Smoothing accelerometer input
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平滑加速度计输入
- en: One problem we will encounter when using the accelerometer for input is that
    the values returned from it tend to be a bit "jumpy". Even the steadiest hand
    will be unable to hold the device still enough to see a steady value being returned
    from the accelerometer. This can cause your game to register movements when you
    don't want it to.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用加速度计作为输入时，我们会遇到的一个问题是它返回的值往往有点“跳跃”。即使是最稳定的手也无法将设备保持静止足够长的时间，以便从加速度计获得稳定的值。这可能导致你的游戏在你不想的时候注册动作。
- en: 'A common approach for solving this problem is to smooth the accelerometer values
    by combining the current readings with the previous readings. The easiest way
    of doing this is shown in the following code:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的常见方法是通过将当前读数与之前的读数相结合来平滑加速度计值。以下代码展示了最简单的方法：
- en: '[PRE8]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The variables `accX`, `accY`, and `accZ` are the smoothed accelerometer values
    that we will use in our program for input. The `lSmoothFactor` value determines
    how much smoothing we are applying to the inputs. If it is set to `IW_GEOM_ONE`,
    no smoothing will be applied and the results will be exactly what is coming in
    from the accelerometers.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `accX`、`accY` 和 `accZ` 是我们将用于程序输入的平滑加速度计值。`lSmoothFactor` 值决定了我们将应用多少平滑到输入中。如果它设置为
    `IW_GEOM_ONE`，则不会应用任何平滑，结果将直接来自加速度计。
- en: Lower values for the smoothing factor will generate less jittery input values,
    but this will be at the expense of adding a certain amount of lag to the inputs.
    The degree of lag depends on how often the smoothing code is executed, which in
    turn depends on the frame rate of your game.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 平滑因子值越低，生成的输入值抖动越小，但这将以增加输入的延迟为代价。延迟的程度取决于平滑代码执行的频率，这又取决于你游戏的帧率。
- en: Working out a good value to use for the smoothing factor is really just a case
    of trial and error. You just need to keep tweaking the value until you achieve
    a suitable result.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 确定平滑因子的合适值实际上只是试错的过程。你只需要不断调整值，直到达到满意的结果。
- en: Note
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`IW_FIXED_MUL` is a useful function provided by Marmalade for doing fixed point
    multiplication where `IW_GEOM_ONE` (4096) is equivalent to one. It multiplies
    the two parameters together and then shifts the result back down to be in the
    correct range.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`IW_FIXED_MUL` 是 Marmalade 提供的一个有用的函数，用于执行定点乘法，其中 `IW_GEOM_ONE`（4096）相当于一。它将两个参数相乘，然后将结果移回正确的范围。'
- en: Testing accelerometer input on the Windows simulator
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Windows 模拟器上测试加速度计输入
- en: Given that computers don't tend to feature accelerometer inputs of any kind,
    testing this form of input in the Windows simulator may appear to be impossible.
    Fortunately, Marmalade does provide us with a way of doing so.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 由于计算机通常不提供任何类型的加速度计输入，因此在 Windows 模拟器中测试这种输入形式似乎是不可能的。幸运的是，Marmalade 为我们提供了一种方法来实现这一点。
- en: 'When running an application in the simulator, select the menu item **Configuration**
    | **Accelerometer…** and a window showing a small 3D representation of a mobile
    device will be displayed:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟器中运行应用程序时，选择菜单项 **配置** | **加速度计…**，将显示一个显示小型 3D 表示的移动设备的窗口：
- en: '![Testing accelerometer input on the Windows simulator](img/3363_03_04.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![在 Windows 模拟器上测试加速度计输入](img/3363_03_04.jpg)'
- en: By clicking and dragging on this virtual device, we can alter the accelerometer
    inputs being fed into the simulator. It's a little tricky to use for playing a
    game but it normally suffices, so you can at least test applications that rely
    solely on accelerometer inputs.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击并拖动这个虚拟设备，我们可以改变输入到模拟器的加速度计值。对于玩游戏来说有点棘手，但通常足够了，因此你可以至少测试那些仅依赖于加速度计输入的应用程序。
- en: The window also provides some edit boxes that show the current values of the
    accelerometer inputs as you rotate the 3D device about. These can also be used
    to enter exact values should you have need to do so.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口还提供了一些编辑框，显示当你围绕3D设备旋转时加速度计输入的当前值。如果你需要输入精确值，也可以使用这些编辑框。
- en: Example code
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例代码
- en: The code package for this chapter contains three projects that demonstrate the
    things we've learnt in this chapter.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码包包含三个项目，展示了我们在本章中学到的内容。
- en: The Gesture project
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手势项目
- en: This project demonstrates the use of the s3ePointer API by showing the screen
    coordinates pointed at by the user. If a multi-touch display is available, it
    will show multiple touch points.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目通过显示用户指向的屏幕坐标来演示s3ePointer API的使用。如果有多点触控显示屏可用，它将显示多个触摸点。
- en: The project also demonstrates a simple approach for detecting swipes and pinches
    and how it is possible to use the same gesture detection code with both single-
    and multi-touch capable displays.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目还演示了一种检测滑动和捏合的简单方法，以及如何使用相同的手势检测代码与单点和多点触控显示屏一起使用。
- en: The Slide project
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Slide项目
- en: The Slide project shows how to use the s3eAccelerometer API to read the current
    accelerometer values, apply a smoothing algorithm to them, and generate the angles
    of tip around the X- and Y-axes.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Slide项目展示了如何使用s3eAccelerometer API读取当前的加速度计值，对它们应用平滑算法，并生成围绕X轴和Y轴的倾斜角度。
- en: It also demonstrates something a little more game-like by allowing you to move
    a little red box around the screen by tipping the device.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 它还通过允许你通过倾斜设备来在屏幕上移动一个小红盒子，展示了一些更类似游戏的功能。
- en: The Skiing project
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 滑雪项目
- en: Our skiing game becomes interactive in this chapter, allowing you to rotate
    the skier left and right and have him move across the screen and affect the speed
    of scrolling. The skier can be controlled either by key presses and touch screen
    or accelerometer input.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们的滑雪游戏变得互动起来，允许你左右旋转滑雪者，让他穿越屏幕并影响滚动速度。滑雪者可以通过按键、触摸屏或加速度计输入来控制。
- en: We also have more of a game-like flow with the addition of a title screen mode
    that allows the input method to be selected, and a game over mode, which is triggered
    when the player goes into the trees at the edge of the game world.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还通过添加一个标题屏幕模式来获得更多的游戏流程，该模式允许选择输入方法，以及一个游戏结束模式，当玩家进入游戏世界边缘的树木时触发。
- en: The following sections highlight some of the new classes added to the project.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的章节突出了项目中添加的一些新类。
- en: Player rotation
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 玩家旋转
- en: Rotation of the player has been achieved by including a number of different
    animation frames, each showing the player at a different angle of rotation. This
    makes it easy to slot into our existing `GameObject` code, which expects to draw
    a square image that is not rotated.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家旋转是通过包含多个不同的动画帧来实现的，每个帧都显示了玩家以不同的旋转角度。这使得它很容易插入我们现有的`GameObject`代码中，该代码期望绘制一个未旋转的方形图像。
- en: While this solution is very simple, it is perhaps not the best option. We could
    instead have extended `GameObject` to support rotated images, which would have
    both saved memory (we would not have needed to store all the extra animation frames)
    and yielded smoother rotation results, as the skier currently steps between frames
    at 10-degree rotation increments.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个解决方案非常简单，但可能不是最佳选择。我们本可以扩展`GameObject`以支持旋转图像，这样既可以节省内存（我们就不需要存储所有额外的动画帧），还可以产生更平滑的旋转效果，因为滑雪者目前以10度旋转的增量在帧之间移动。
- en: The ModeTitle and ModeGameOver classes
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ModeTitle和ModeGameOver类
- en: These classes implement the title screen and game over modes of the game. These
    have been added to make the project feel a little more like a game, although they
    are very basic to look at.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类实现了游戏的标题屏幕和游戏结束模式。这些是为了使项目看起来更像一个游戏而添加的，尽管它们看起来非常基础。
- en: More importantly, these classes show how we can switch between game modes by
    making them active and visible. Take particular note of the `ModeGameOver` class,
    which stops the normal game mode from updating, but still allows it to render
    so we can see the game world along with the game over message.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，这些类展示了我们如何通过使它们活跃和可见来在游戏模式之间切换。特别注意的是`ModeGameOver`类，它阻止了正常游戏模式的更新，但仍然允许它渲染，这样我们就可以看到游戏世界以及游戏结束的消息。
- en: The Camera class
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摄像机类
- en: The `Camera` class has been added to the project to allow us to specify a viewing
    point in the world. When rendering, we now use the camera position as the origin's
    location on the screen. So when we move the camera, the entire screen display
    will move relative to it. This makes it possible to do a horizontal scrolling
    effect without having to update the x coordinate of everything in the game world.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在世界上指定一个观察点，项目已添加了 `Camera` 类。在渲染时，我们现在使用相机位置作为屏幕上的原点位置。因此，当我们移动相机时，整个屏幕显示将相对于它移动。这使得在不更新游戏世界中所有对象的
    x 坐标的情况下实现水平滚动效果成为可能。
- en: Another reason for making this change is to make our life easier when we upgrade
    the game to use 3D models in the next chapter, since this is closer to the way
    3D graphics are rendered.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 进行这种更改的另一个原因是，在下一章将游戏升级为使用 3D 模型时，会使我们的生活更加轻松，因为这与 3D 图形的渲染方式更接近。
- en: The Input Manager classes
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输入管理类
- en: Three new singleton classes have also been added to the project to make access
    to key, touch screen, and accelerometer inputs a little tidier. They are called
    `KeyManager`, `TouchManager`, and `AccelerometerManager` respectively.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 项目中还添加了三个新的单例类，以使访问按键、触摸屏和加速度计输入更加整洁。它们分别称为 `KeyManager`、`TouchManager` 和 `AccelerometerManager`。
- en: These classes wrap the functionality provided by Marmalade into a simpler interface,
    which makes our game code easier to read. It also means that we can make changes
    to the inputs at a later date without having to change the game code. For example,
    the `KeyManager` class provides methods to indicate if the left or right arrow
    keys have been held. If we want to remap those keys or provide alternate possible
    keys, we can do so in the `KeyManager` code and our game code will work just fine.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类将 Marmalade 提供的功能封装到一个更简单的接口中，这使得我们的游戏代码更容易阅读。这也意味着我们可以在以后更改输入而无需更改游戏代码。例如，`KeyManager`
    类提供了指示左或右箭头键是否被按住的方法。如果我们想要重新映射这些键或提供其他可能的键，我们可以在 `KeyManager` 代码中这样做，而我们的游戏代码将正常工作。
- en: The SkierController class
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SkierController 类
- en: In order to add a layer of abstraction between the `Skier` class and the various
    input managers, the `SkierController` class has been added. This class provides
    a "steering" value, which is an integer number ranging from—`IW_GEOM_ONE` to +`IW_GEOM_ONE`
    that indicates how much the user is attempting to steer left (a negative value)
    or right (a positive value). The `Skier` class can just use this value to rotate
    the skier without needing to consider how this value is derived.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 `Skier` 类和各个输入管理器之间添加一层抽象，添加了 `SkierController` 类。这个类提供了一个“转向”值，它是一个从 -`IW_GEOM_ONE`
    到 +`IW_GEOM_ONE` 的整数，表示用户尝试向左（负值）或向右（正值）转向的程度。`Skier` 类可以直接使用这个值来旋转滑雪者，而无需考虑这个值是如何得到的。
- en: Internally, the `SkierController` class generates the steering value using the
    selected input method from the title screen.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，`SkierController` 类使用标题屏幕上选择的输入方法生成转向值。
- en: For keyboard input, the left and right arrow keys modify the current steering
    value a little bit each frame.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 对于键盘输入，左右箭头键在每个帧中稍微修改当前的转向值。
- en: Touch screen input uses the horizontal position of the player's finger on the
    screen to generate the value; so it is -1 when the player is touching the left-hand
    side of the screen and +1 when they are touching the right-hand side.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 触摸屏输入使用玩家在屏幕上的水平位置来生成值；因此，当玩家触摸屏幕的左侧时为 -1，当他们触摸右侧时为 +1。
- en: Finally, accelerometer input just scales the x axis accelerometer value into
    the required range.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，加速度计输入只是将 x 轴加速度计值缩放到所需的范围内。
- en: Summary
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've covered how to make our programs interactive by detecting
    key and touch screen presses and by using the accelerometers of modern mobile
    devices. We've also seen how we can build on the basic functionality provided
    in order to detect swipe and pinch gestures.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了如何通过检测按键和触摸屏点击以及使用现代移动设备的加速度计来使我们的程序具有交互性。我们还看到了如何在此基础上构建基本功能以检测滑动和捏合手势。
- en: In the next chapter, we'll be returning to things more graphical by showing
    how we can use Marmalade to render 3D graphics in our games.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过展示如何使用 Marmalade 在我们的游戏中渲染 3D 图形来回到更图形化的内容。
