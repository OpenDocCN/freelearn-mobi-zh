- en: Chapter 7\. Tailoring Your Personal Android System
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 定制你的个人安卓系统
- en: In the previous chapter, you learned about the most popular custom Android ROMs.
    We started to dive deep and analyze those parts of the system involved in the
    modding process, to effectively understand where to customize and how to do it,
    mastering the Android modding toolset.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了最流行的自定义安卓系统。我们开始深入分析系统在修改过程中的各个部分，以有效地了解如何进行定制以及如何操作，掌握安卓修改工具集。
- en: In this chapter, we will go even further, diving deeper into every single aspect
    of a ROM, using practical examples to show how to customize and increase the performance
    of your ROM.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更进一步，深入到ROM的每一个细节，通过实际案例展示如何定制和提升ROM的性能。
- en: 'The main topics of this chapter are:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要内容包括：
- en: Hacking the Android framework
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 黑客安卓框架
- en: Adding new Android applications to the build system
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将新的安卓应用程序添加到构建系统中
- en: Adding new Linux-native apps, using the Android source code, or editing an existing
    binary ROM image
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用安卓源代码添加新的Linux原生应用程序，或编辑现有的二进制ROM镜像
- en: Optimizing the system to better support custom hardware, with focus on the application
    layer and on the kernel layer.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化系统以更好地支持自定义硬件，重点关注应用层和内核层。
- en: Receiving over the air updates – OTA
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接收空中更新 – OTA
- en: Every Android device is, by design, able to receive updates over time. These
    can be system updates—when a new Android version has been released, or security
    updates—when some critical vulnerability has been fixed and Google is distributing
    the patch. Once the update has been received, every device is able to decompress
    and apply this update, following the required procedure.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 每个安卓设备按设计都能在一段时间内接收更新。这些可以是系统更新——当新的安卓版本发布时，或者安全更新——当某些关键漏洞被修复且谷歌正在分发补丁时。一旦收到更新，每个设备都能按照所需程序解压缩并应用此更新。
- en: These types of updates are called OTA, or over the air updates, because they
    can be downloaded and applied by the Android device itself, without the support
    of a host PC. These updates are typically going to patch operating system features,
    working in the so-called *read-only* part of the system. No user app will ever
    be affected by these updates— apps installed via the Google Play Store are completely
    safe.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这类更新被称为OTA，或空中更新，因为它们可以通过安卓设备本身下载和应用，无需主机PC的支持。这些更新通常用于修复操作系统功能，在所谓的*只读*部分工作。没有任何用户应用会受到这些更新的影响——通过谷歌应用商店安装的应用完全安全。
- en: 'Android will asynchronously notify you when a new OTA is available. Most of
    the time you will receive a notification if connected to a Wi-Fi network and if
    your battery is above 50% to ensure a possible fast download and a safe updating
    process. When an update is available, a new system notification will appear in
    the Status Bar notification area. Once the notification is clicked, Android will
    show you details about the update, as shown in the following image:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当新的OTA可用时，安卓会异步通知你。大多数情况下，如果你连接到Wi-Fi网络且电池电量高于50%，你将收到通知，以确保可能的快速下载和安全的更新过程。当有更新可用时，状态栏通知区域将出现新的系统通知。一旦点击通知，安卓将显示有关更新的详细信息，如下面的图片所示：
- en: '![](img/epub_36702041_106.jpeg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/epub_36702041_106.jpeg)'
- en: 'OTA updates can be grouped into these three categories:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: OTA更新可以分为以下三类：
- en: Full system updates
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整系统更新
- en: Incremental system updates
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增量系统更新
- en: Single update packages
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个更新包
- en: Updating the whole system
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新整个系统
- en: As you can guess, this family of updates will bring up the whole system to a
    new version. They contain a whole system image, with `system`, `boot`, and `recovery`
    partitions.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，这一系列的更新将整个系统提升到新版本。它们包含整个系统镜像，包括`system`、`boot`和`recovery`分区。
- en: To install these updates, the system needs to be able to properly boot the Recovery
    system and simply read and apply the update file.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装这些更新，系统需要能够正确引导恢复系统，并简单地读取和应用更新文件。
- en: Even if it is a full system update, the user partition is not affected and no
    app or user data is erased.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是完整的系统更新，用户分区也不会受到影响，且不会删除任何应用或用户数据。
- en: Updating the system incrementally
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 增量更新系统
- en: These updates are somewhat smaller than the full system ones and their goal
    is to apply patches to specific system components. Being tailored for a specific
    version of the operating system and a specific version of the file to be patched,
    these updates cannot be randomly applied to available devices.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更新比完整的系统更新要小一些，它们的目的是应用特定系统组件的补丁。由于针对特定版本的操作系统和特定版本的文件进行定制，因此这些更新不能随机应用于可用的设备。
- en: To enforce this constraint, before installing such update files, the system
    checks for the correct file versions and any other possible requirement needed
    by the update. If some requirement is not satisfied, Android notifies the user
    with an error icon and the update procedure is aborted.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了强制执行此约束，在安装此类更新文件之前，系统会检查正确的文件版本以及更新所需的任何其他可能的要求。如果某些要求未得到满足，Android会通过错误图标通知用户，并中止更新过程。
- en: Applying a single component update
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用单个组件更新
- en: 'An OTA update package is a standard `.zip` file containing a `META-INF/com/Google/Android/update-binary`
    file. Once Android has verified the ZIP file signature, it decompresses the file
    in `/tmp` and executes it. A few arguments are passed to the command line. These
    are:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: OTA更新包是一个标准的`.zip`文件，包含一个`META-INF/com/Google/Android/update-binary`文件。一旦Android验证了ZIP文件的签名，它就会在`/tmp`中解压缩文件并执行它。一些参数传递给命令行。这些是：
- en: Update-binary API version number
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新二进制API版本号
- en: The command line file descriptor, to communicate with the command line, to send
    progress updates to the UI
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行文件描述符，用于与命令行通信，向UI发送进度更新
- en: The filename
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件名
- en: In the same folder as `update-binary`, there is another interesting file—`updater-binary`.
    This file contains the sequence of actions to perform to install the update. All
    these actions are expressed in `Edify`, a custom **Domain Specific Language**
    (**DSL**) that Google created for this task. As is usual in the open source world,
    Google documented everything about this language and you can find the documentation
    in `/bootable/recovery/edify`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在`update-binary`文件所在的同一文件夹中，还有一个有趣的文件——`updater-binary`。此文件包含执行更新的操作序列。所有这些操作都使用Google为这项任务创建的定制**领域特定语言**（**DSL**）`Edify`来表示。正如开源世界中的惯例，Google记录了有关此语言的所有信息，您可以在`/bootable/recovery/edify`中找到文档。
- en: The truth is that Recovery can execute every statically-linked binary named
    `update-library`. Leveraging this opportunity, lots of developers prefer to use
    different languages, which they are more familiar with, to perform all the operations
    needed to apply the update.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 事实是，Recovery可以执行所有名为`update-library`的静态链接二进制文件。利用这个机会，许多开发者更愿意使用他们更熟悉的语言来执行所有必要的操作以应用更新。
- en: In the next pages we will see examples of both possible scenarios, using Google's
    Edify or a custom solution.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几页中，我们将看到使用Google的Edify或自定义解决方案的两种可能场景的示例。
- en: Creating over the air updates
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建空中更新
- en: 'Google provided plenty of developer tools to generate the different types of
    OTA. If you want to generate a *Full Update OTA*, the following two steps are
    required:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Google提供了大量的开发者工具来生成不同类型的OTA。如果您想生成一个*完整更新OTA*，需要以下两个步骤：
- en: Generate a ZIP file containing the full update files
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成包含完整更新文件的ZIP文件
- en: Generate the OTA package with all the necessary toolsets for the update
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成包含更新所需所有工具集的OTA包
- en: 'To generate the `zip` file containing the chosen target files, navigate to
    the `root` folder of the AOSP sources and run the following commands:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成包含所选目标文件的`zip`文件，请导航到AOSP源代码的`root`文件夹并运行以下命令：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If the process has been successful, we should have the `zip` file containing
    the target files in the directory `dist_output`. As an example, let''s try listing
    the folder content with the following command:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果过程成功，我们应该在`dist_output`目录中有一个包含目标文件的`zip`文件。例如，让我们尝试使用以下命令列出文件夹内容：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now we should see a `.zip` file that will also have in its name the name of
    the target we are compiling for.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该看到一个`.zip`文件，其名称也将包含我们正在编译的目标名称。
- en: 'At this point, you only need to generate the OTA package containing all the
    necessary files for the update. Among the available tools, there''s a utility
    that will help us do so, through the following command:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您只需要生成包含更新所需所有文件的OTA包。在可用的工具中，有一个实用程序可以帮助我们通过以下命令完成此操作：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As shown here, you''ll find the screen with the generated OTA package and the
    command output:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如此所示，您将找到包含生成的OTA包和命令输出的屏幕：
- en: '![](img/epub_36702041_107.jpeg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/epub_36702041_107.jpeg)'
- en: Now we have our OTA package ready to be installed on *development devices*,
    because the default OTA is signed with *test keys*. If you want to provide your
    users with an installable OTA package, you need to sign the OTA with your *own
    private keys*, using the specific option provided by the OTA-generation tool.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了准备安装到 *开发设备* 上的 OTA 包，因为默认的 OTA 是用 *测试密钥* 签名的。如果你想为用户提供可安装的 OTA 包，你需要使用
    OTA 生成工具提供的特定选项，用你自己的 *私有密钥* 签名 OTA。
- en: 'In order to generate an **incremental OTA**, the procedure is nearly the same,
    except that you also need to indicate the ZIP file containing the previous OTA
    version. The command will be something like the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成 **增量 OTA**，过程几乎相同，只是你还需要指出包含上一个 OTA 版本的 ZIP 文件。命令可能如下所示：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As for our previous example, you'll get a ZIP file containing the incremental
    backup.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前的例子一样，你会得到一个包含增量备份的 ZIP 文件。
- en: Finally, there are no predefined tools for the composition of the `Update OTA`
    package, as it's up to us to decide what to install/update through the update
    script, which we will examine in detail later.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，没有预定义的工具用于组成 `Update OTA` 包，因为这取决于我们决定通过更新脚本安装/更新什么，我们将在稍后详细研究。
- en: OTA internals
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OTA 内部结构
- en: 'As anticipated in the previous section, an OTA package contains a binary file
    in its folder tree:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如前节所预期，OTA 包在其文件夹树中包含一个二进制文件：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This binary file is generated by Android's build system, in the `bootable/recovery/updater`
    folder, and it is used to properly perform the update.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个二进制文件是由 Android 的构建系统生成的，位于 `bootable/recovery/updater` 文件夹中，并用于正确执行更新。
- en: 'The binary contains internal routines and an interpreter for the scripting
    language called `Edify`. This language supports a set of ad hoc commands in order
    to allow the correct execution of a system update without affecting the integrity
    of the system itself. You can find an example of an Edify script in one of the
    OTA ZIP files you have just generated, at:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制文件包含内部例程和 `Edify` 脚本语言的解释器。这种语言支持一组特定命令，以便在不影响系统本身完整性的情况下正确执行系统更新。你可以在你刚刚生成的
    OTA ZIP 文件中的一个找到 Edify 脚本的示例，在以下位置：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Shown here is an example screenshot for an Edify script:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了一个 Edify 脚本的示例截图：
- en: '![](img/epub_36702041_108.jpeg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/epub_36702041_108.jpeg)'
- en: Usually, we don't need to manually write any Edify code, because in a standard
    scenario there are automated tools that generate the correct OTA packages containing
    all the necessary files, but it could be useful to manually modify them when debugging,
    or in case we are building our custom ROM from binaries and we need to customize
    the installation on the flash memory of the relative files.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们不需要手动编写任何 Edify 代码，因为在标准场景中，有自动化工具可以生成包含所有必要文件的正确 OTA 包，但在调试时手动修改它们可能很有用，或者在我们从二进制文件构建自定义
    ROM 并需要定制闪存上的安装时。
- en: Let's have a look at the Edify syntax in the next section.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下一节中的 Edify 语法。
- en: Edify syntax
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Edify 语法
- en: 'The first thing to know is that Edify evaluates every expression as all string
    type values. An empty string is considered as `false` in a Boolean context, while
    any other value is considered as `true`. To recapitulate, Edify supports all the
    following expression types:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要知道的是，Edify 将每个表达式评估为所有字符串类型值。在布尔上下文中，空字符串被视为 `false`，而任何其他值都视为 `true`。为了总结，Edify
    支持以下所有表达式类型：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Every string that contains the following type of character, which of course
    are not reserved words, are considered as string literal:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 包含以下类型字符的每个字符串，当然这些不是保留字，都被视为字符串字面量：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With reserved words, we refer to words such as `if else`, and `endif`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于保留字，我们指的是像 `if else` 和 `endif` 这样的词。
- en: 'Constant strings can also be written using *double-quotes*, in order to create
    strings with spaces or other characters not listed in the previous example, such
    as the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 *双引号* 来编写常量字符串，以便创建包含空格或其他字符的字符串，这些字符在之前的示例中没有列出，例如以下内容：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It can also be respectively written as follows for the new line and tab:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于新行和制表符，也可以分别写成以下内容：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As an escape character, we use `"` and `\` in a string written with *double-quotes*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 作为转义字符，我们在用 *双引号* 编写的字符串中使用 `"` 和 `\`。
- en: 'The operators are simply short-circuiting, that is, the right side isn''t even
    considered if the logic result is determined by the left side of the expression.
    The syntax can be very concise, as shown in the following snippet; the two lines
    are equivalent:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符是简单的短路运算，也就是说，如果逻辑结果由表达式的左侧确定，则甚至不会考虑右侧。语法可以非常简洁，如下面的代码片段所示；两行是等价的：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `;` character is a sequence point, meaning that what's at its left is considered
    before, and what's at its right is considered after.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`;` 字符是一个序列点，意味着其左侧的内容先被考虑，而右侧的内容后被考虑。'
- en: 'Let''s see a richer example:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个更丰富的例子：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The interpreter contains all the functions that are necessary to complete a
    correct update. Unless differently specified, the functions usually render `true`
    in case of success and `false` in case of error.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器包含完成正确更新所需的所有函数。除非另有说明，否则函数在成功时通常返回 `true`，在出错时返回 `false`。
- en: 'The language provides utility methods to control the flow and manage edge situations.
    If, for example, we want to trigger an error to block the installation, we can
    use the following functions:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 语言提供了控制流程和管理边缘情况的有用方法。例如，如果我们想触发错误以阻止安装，我们可以使用以下函数：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As you can expect, in case you want to add a new feature, you can do that by
    modifying the sources, but before that, let''s have a look at some of the most
    useful functions already available:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所料，如果你想添加新功能，你可以通过修改源代码来实现，但在那之前，让我们看看一些已经可用且非常有用的函数：
- en: '`abort([msg])`: This method gives you the opportunity to abort the currently
    running script. It also takes a string argument, `msg`, that can be shown to the
    user as further information about the abort.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abort([msg])`: 此方法允许你中断当前运行的脚本。它还接受一个字符串参数 `msg`，可以显示给用户作为中断的进一步信息。'
- en: '`assert(expr[, expr, ...])`: This method takes a list of expressions as argument
    and evaluates them one by one. If any of these expressions fail, or returns `false`,
    the whole script execution stops. The system also shows an "Assert failed" message
    and the assert text that just failed.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert(expr[, expr, ...])`: 此方法接受一个表达式列表作为参数，并逐个评估它们。如果其中任何表达式失败或返回 `false`，则整个脚本执行停止。系统还会显示一个“断言失败”消息和刚刚失败的断言文本。'
- en: '`apply_patch(src_file, tgt_file, tgt_sha1, tgt_size, patch1_sha1, patch1_blob,
    [...])`: This method takes a `patch1_blob` file and applies it as a binary patch
    to the source file `src_file` to produce the target `tgt_file`.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apply_patch(src_file, tgt_file, tgt_sha1, tgt_size, patch1_sha1, patch1_blob,
    [...])`: 此方法接受一个 `patch1_blob` 文件，并将其作为二进制补丁应用到源文件 `src_file` 上，以生成目标 `tgt_file`。'
- en: '`delete_recursive([dirname, ...])`: This function takes a list of folder names
    as argument and deletes them, also deleting every single file they contain.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete_recursive([dirname, ...])`: 此函数接受一个文件夹名称列表作为参数，并删除它们，同时删除它们包含的每个单个文件。'
- en: '`file_getprop(filename, key)`: This method can be considered as a properties
    file inspector. It takes a couple of arguments, a filename and a key, and scans
    the file as if it were a property file, looking for the provided key. If the key
    is found, its value is returned.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file_getprop(filename, key)`: 此方法可以被视为属性文件检查器。它接受一些参数，包括一个文件名和一个键，并像属性文件一样扫描文件，寻找提供的键。如果找到键，则返回其值。'
- en: '`format(fs_type, partition_type, location, fs_size, mount_point)`: This method
    provides a powerful way to format partitions.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`format(fs_type, partition_type, location, fs_size, mount_point)`: 此方法提供了一种强大的方式来格式化分区。'
- en: '`ifelse(cond, e1[, e2])`: This method represents the common `it-then-else`
    computer science statement.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ifelse(cond, e1[, e2])`: 此方法表示常见的 `if-then-else` 计算机科学语句。'
- en: '`is_mounted(mount_point)`: This method helps to detect mounted partitions.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_mounted(mount_point)`: 此方法有助于检测挂载的分区。'
- en: '`mount(fs_type, partition_type, name, mount_point)`: This method mounts a filesystem
    of `fs_type` at `mount_point`.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mount(fs_type, partition_type, name, mount_point)`: 此方法在 `mount_point` 处挂载
    `fs_type` 文件系统。'
- en: '`rename(src_filename, tgt_filename)`: This method takes two arguments, to perform
    a renaming from `src_filename` to `tgt_filename`.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rename(src_filename, tgt_filename)`: 此方法接受两个参数，用于将 `src_filename` 重命名为 `tgt_filename`。'
- en: '`run_program(path[, arg, ...])`: This method executes the binary at path, passing
    `args`, and it returns the program''s exit status.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run_program(path[, arg, ...])`: 此方法执行路径处的二进制文件，传递 `args`，并返回程序的退出状态。'
- en: '`sleep(secs)`: This method takes an integer, `secs`, as an argument and pauses
    the execution for `secs` seconds.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sleep(secs)`: 此方法接受一个整数 `secs` 作为参数，并暂停执行 `secs` 秒。'
- en: '`symlink(target[, source, ...])`: This method takes a `target` file and a list
    of `sources` and creates all sources as *symlinks* to target.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`symlink(target[, source, ...])`: 此方法接受一个`target`文件和一个`sources`列表，并将所有来源创建为指向目标的*符号链接*。'
- en: '`unmount(mount_point)`: This is the counterpart of `mount`. This method unmounts
    the filesystem mounted at `mount_point`.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unmount(mount_point)`: 这是`mount`的对应方法。此方法用于卸载在`mount_point`上挂载的文件系统。'
- en: This is just a subset of all the available commands. If you are curious about
    the whole list, you can check the official Google documentation at [http://source.android.com/devices/tech/ota/inside_packages.html](http://source.android.com/devices/tech/ota/inside_packages.html).
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这只是所有可用命令的一个子集。如果你对整个列表感兴趣，可以查看官方Google文档[http://source.android.com/devices/tech/ota/inside_packages.html](http://source.android.com/devices/tech/ota/inside_packages.html)。
- en: We are now able to modify—or create from scratch—an *Edify* script for an Update
    installation. This knowledge will turn out to be very useful with the custom ROM,
    especially when the sources are not available, in case you want to modify the
    system through a custom recovery, installing specific files in the read-only system
    partitions.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在能够修改——或者从头开始创建——用于更新安装的*Edify*脚本。这种知识将证明在自定义ROM中非常有用，尤其是在源代码不可用的情况下，如果你想通过自定义恢复修改系统，在只读系统分区中安装特定文件。
- en: OTA for custom ROM
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义ROM的OTA
- en: As already anticipated, out of the OTA concept we get a convenient system for
    the custom ROM installation. The reason for this is that most custom ROMs are
    distributed as *Update* ZIP packages, to be fed to the custom Recovery, which
    will then take care of the package installation in the system. Analyzing the OTA
    structure—as we did in the previous section—we can intuitively understand how
    to organize a specific package to install a modified version of Android. In fact,
    through an ad hoc Edify script, it is possible to format and reinstall all the
    files that are contained in any system partition, in order to distribute your
    own modified Android version.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，从OTA概念中，我们得到了一个方便的系统用于自定义ROM的安装。原因是大多数自定义ROM都是以*更新* ZIP包的形式分发，用于提供给自定义恢复，然后由恢复程序负责在系统中安装这些包。通过分析OTA结构——正如我们在上一节所做的那样——我们可以直观地理解如何组织一个特定的包来安装修改版的Android。实际上，通过一个临时的Edify脚本，可以格式化和重新安装任何系统分区的所有文件，以便分发你自己的修改版Android。
- en: This task is left as an exercise to the reader as it can be achieved with the
    knowledge acquired so far.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务留给读者作为练习，因为它可以用到目前为止获得的知识来完成。
- en: Advanced ROM customization
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级ROM定制
- en: In the previous chapters, you have made your first steps within the custom ROMs
    world; we have discovered what's already available online and analyzed the most
    characteristic aspects in detail. In this chapter we will go in deep and learn
    how to modify the most internal parts of Android's framework.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你在自定义ROM的世界中迈出了第一步；我们已经发现了在线上已有的内容，并详细分析了最典型的方面。在本章中，我们将深入探讨，学习如何修改Android框架的最内部部分。
- en: Custom ROMs are often associated with those "*hackers*" who add the most unexpected
    features and then share everything online, but it doesn't always happen like that.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义ROM通常与那些添加最意想不到功能并在线分享一切的"*黑客*"联系在一起，但并不总是如此。
- en: As explained in the previous chapters, many device manufacturers propose their
    own modified Android version, which is nothing but an Android custom ROM.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，许多设备制造商提出了他们自己的修改版Android，这实际上就是Android自定义ROM。
- en: This is a very important aspect, as this book is addressed both to the previously
    mentioned *hackers* and to those who use all this knowledge in their daily work—a
    *hacker* will often work with binary ROM, and rarely with sources, while the professional
    will certainly have the sources at their disposal, as well as all the relevant
    tools to make the development of additional features possible.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常重要的方面，因为这本书既面向前面提到的"*黑客*"，也面向那些在日常工作中使用这些知识的人——一个"*黑客*"通常会处理二进制ROM，而很少处理源代码，而专业人士肯定会有源代码，以及所有相关的工具，以便实现额外功能的发展。
- en: 'In the following section, we will try to explain the two different approaches
    to customization in a simple way. These are: from the sources and from binary.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将尝试以简单的方式解释两种不同的定制方法。这些是：从源代码和从二进制。
- en: ROM customization from binary
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 二进制ROM定制
- en: To modify a ROM starting from binary, we regrettably have few available choices.
    As we don't have the sources to generate the different images, we can only modify
    the filesystem, adding utilities and new apps, or making aesthetic changes to
    colors and icons, starting from the framework binary.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 从二进制文件开始修改 ROM，我们遗憾地只有很少的选择。由于我们没有源代码来生成不同的镜像，我们只能修改文件系统，添加实用工具和新应用程序，或者从框架二进制文件开始对颜色和图标进行美学上的更改。
- en: We can use the tools we saw in the previous chapter and apply all the required
    changes, then, when we are done, we can generate a package `update.zip` with the
    correct Edify script, that allows the installation of new features.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用上一章中看到的工具并应用所有必要的更改，然后，当我们完成时，我们可以使用正确的 Edify 脚本生成一个 `update.zip` 包，该包允许安装新功能。
- en: Furthermore, we can also add new applications both in *Java* and *C*, or enhance
    the system image adding a `BASH` environment, or copy in the `/system` partition
    updated application like *Gmail* or *Maps*, that might eat space in the `/data`
    partition.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以添加新的应用程序，无论是 *Java* 还是 *C*，或者通过添加 `BASH` 环境来增强系统镜像，或者复制更新后的应用程序到 `/system`
    分区，如 *Gmail* 或 *Maps*，这些可能会占用 `/data` 分区的空间。
- en: Even if the possibilities are limited in this kind of scenario, starting from
    a binary image, we can try some optimization and tweak, as we will see in the
    upcoming sections.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在这种场景下可能性有限，从二进制镜像开始，我们也可以尝试一些优化和调整，正如我们将在接下来的章节中看到的。
- en: Customizing ROM from source
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从源代码定制 ROM
- en: If you have the source code, you can do almost anything, but as you know,
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有源代码，您几乎可以做什么，但如您所知，
- en: '*"With great power comes great responsibility"—Uncle Ben, Spider-Man.*'
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"能力越大，责任越大"—本叔叔，蜘蛛侠。*'
- en: 'The first step is to identify the part we want to modify, and consequently,
    its repository. Let''s take, for example Android''s `Settings` menu, which we
    will keep as a master example to modify our ROM. The source code of `Settings.apk`
    is in the following path:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是确定我们想要修改的部分及其仓库。让我们以 Android 的 `Settings` 菜单为例，我们将将其作为一个主示例来修改我们的 ROM。`Settings.apk`
    的源代码在以下路径：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Once the source code path, and so, the repository, have been identified, the
    best way to start your customization is to mirror the repository on your server,
    where you will then operate the changes to the code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定了源代码路径，也就是仓库，开始您定制的最佳方式是将仓库镜像到您的服务器上，然后您将对代码进行更改。
- en: In order to make sure your repository is part of the Android system, you need
    to update the `manifest.xml`, so that when you sync again with "*repo*", you will
    clone your own `Settings` version, and not Android's.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保您的仓库是 Android 系统的一部分，您需要更新 `manifest.xml`，这样当您再次与 "*repo*" 同步时，您将克隆自己的 `Settings`
    版本，而不是 Android 的。
- en: 'After that, you need to create another personal repository, where you''ll keep
    your manifest, modifying the following line:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您需要创建另一个个人仓库，在那里您将保存您的清单，并修改以下行：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here you see where the code will be locally downloaded:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里您可以看到代码将本地下载的位置：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And here, its remote location:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 而在这里，它的远程位置：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You''ll notice that there isn''t a link in the remote position, because we''ll
    use the default one, defined at the top as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到远程位置没有链接，因为我们将使用默认的，如下所示定义在顶部：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As you can see, `fetch` refers to the parent folder "`..`" instead of an absolute
    path. The best thing to do to simplify our work is to add a remote as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`fetch` 指的是父文件夹 "`..`" 而不是绝对路径。为了简化我们的工作，最好的做法是添加一个远程仓库，如下所示：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In this way, we have defined our remote, and we only have to fix the `Settings`
    line like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，我们已经定义了我们的远程仓库，我们只需要修复 `Settings` 行，如下所示：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We now have all the necessary configuration in place to proceed with the development:
    we have our separate repository, where we can develop the code, but most importantly,
    thanks to the modification in the manifest, we don''t have to touch the remaining
    managed parts of the system managed by Google, so that the update of other components
    of Google is made simple and smooth.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好所有必要的配置来继续开发：我们有一个单独的仓库，我们可以在其中开发代码，但最重要的是，由于清单中的修改，我们不必触摸由 Google
    管理的剩余系统部分，这样其他 Google 组件的更新就变得简单且顺畅。
- en: Adding new packages to Android's build system
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将新包添加到 Android 的构建系统中
- en: 'The first step is to add a package to Android''s build system, so that, when
    we perform our build, it will be automatically compiled and added to the ROM,
    just as it happens with other applications. We can work on two levels: adding
    a system app as a compiled binary app, written in *C*, or adding a system app
    as an *Application Layer* that runs on Android Dalvik Machine and ships as an
    APK.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是将包添加到Android的构建系统中，这样，当我们执行构建时，它将自动编译并添加到ROM中，就像其他应用程序发生的那样。我们可以在两个层面上工作：将系统应用程序作为编译的二进制应用程序添加，用*C*编写，或将系统应用程序作为*应用层*添加，该层在Android
    Dalvik虚拟机上运行，并以APK的形式分发。
- en: In order to create an Android application, the first thing to do is to prepare
    the environment for writing the code and generate the APK file that will be executed
    by Android's internal virtual machine. We are going to develop a standard Android
    app using Java, Android Studio, and Android SDK.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建Android应用程序，首先要做的是为编写代码准备环境并生成将被Android内部虚拟机执行的APK文件。我们将使用Java、Android Studio和Android
    SDK开发一个标准的Android应用程序。
- en: Adding a package by binary
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过二进制添加包
- en: While developing a custom ROM, you might need to add binary executables or applications
    you don't have the source code for. For example, you might want to add a particular
    application as the default application for a specific task, so that when the user
    boots the ROM, the application is already installed into the system. We can refer
    to the `Facebook` application as an example of this.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发自定义ROM时，您可能需要添加二进制可执行文件或应用程序，您没有源代码。例如，您可能希望将特定应用程序作为特定任务的默认应用程序添加，这样当用户启动ROM时，该应用程序就已经安装到系统中。我们可以将`Facebook`应用程序作为此类示例。
- en: To successfully add a new application to your system image, you just need to
    get the `APK` file and copy it in the right ROM directory. You can do that with
    an `update.zip file`, adding the right Edify script, which will install the new
    APK—as we'll see later in more detail—or, as already anticipated in the previous
    chapters, you can perform the entire operation through Android's build system.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功将新应用程序添加到您的系统镜像中，您只需获取`APK`文件并将其复制到正确的ROM目录中。您可以使用`update.zip`文件，添加正确的Edify脚本，这将安装新的APK——我们将在稍后更详细地看到——或者，如前几章中已预料的，您可以通过Android的构建系统执行整个操作。
- en: 'The first step is to write the correct `Android.mk`; let''s imagine we have
    our APK file at the following path:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是编写正确的`Android.mk`；让我们假设我们的APK文件位于以下路径：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once your APK is in place, you need to create an `Android.mk` file and add
    the following snippet:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的APK已经就位，您需要创建一个`Android.mk`文件并添加以下片段：
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Analyzing the snippet, you will notice a couple of placeholders you will need
    to replace with your actual values. After that you''ll need to create a new entry
    in the `commons.mk` file, situated in:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 分析代码片段，您将注意到几个占位符，您需要用实际值替换它们。之后，您需要在`commons.mk`文件中创建一个新的条目，该文件位于：
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add the new APK installation-related line, as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新的APK安装相关行，如下所示：
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: At this point, you only have to recompile the AOSP to find the new APK in the
    system, preinstalled among the other system apps.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您只需重新编译AOSP，以在系统中找到新的APK，它将与其他系统应用程序一起预装。
- en: Another very common and handy way to add a precompiled app to our ROM is doing
    it with the help of the Android update system. Provided that you have already
    installed a custom recovery image—which will make all your operations easier—to
    add a new binary to Android's `/system/xbin` directory, you only need to create
    an `update.zip` with an Edify script inside to perform the right operations.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种非常常见且方便的方法是将预编译的应用程序添加到我们的ROM中，即通过Android更新系统的帮助。假设您已经安装了自定义恢复镜像——这将使所有操作都更容易——要向Android的`/system/xbin`目录添加新的二进制文件，您只需创建一个包含Edify脚本的`update.zip`文件以执行正确的操作。
- en: 'Here you''ll see an Edify script that performs a precompiled app installation
    in the target folder `/system/xbin`. The script is contained in:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您将看到一个Edify脚本，它在目标文件夹`/system/xbin`中执行预编译的应用程序安装。脚本包含在：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The script contains the following code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本包含以下代码：
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The internal structure of the `update.zip` file will look like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`update.zip`文件的内部结构将如下所示：'
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Once the update package has been created, you only need to apply it through
    the recovery custom that is installed on your device. As you have surely noted,
    the same approach, "*edify script + update.zip + recovery*", is used over and
    over, and this shows how Android's update system is solid and flexible and comes
    in handy for a huge number of tasks and scenarios; but we can go even further.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建好更新包，您只需通过设备上安装的恢复自定义应用来应用它。如您所注意到的，相同的做法，“*edify 脚本 + update.zip + 恢复*”被反复使用，这显示了
    Android 更新系统的稳固和灵活，并且对于大量任务和场景非常有用；但我们还可以更进一步。
- en: There's yet another procedure, that we might define as "*dirty*", which allows
    even more complex installations. You would still use the procedure of the update
    package, but instead of using the Edify syntax, which might often be inconvenient
    and not so powerful for advanced scenarios, you will redefine the content of the
    `update-script` binary.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种程序，我们可以将其定义为“*脏*”，它允许更复杂的安装。您仍然会使用更新包的程序，但不是使用 Edify 语法，这在许多情况下可能不方便，并且对于高级场景来说并不那么强大，您将重新定义
    `update-script` 二进制文件的内容。
- en: As you know, this binary, that by default contains the interpreter to execute
    the Edify script, is launched by the system. This "*dirty*" technique consists
    of replacing this binary with a shell script that performs the operations you
    need. With this alternative approach, you have the very powerful shell scripting
    language at your disposal, and let's consider that some recovery custom includes
    the Bash—as shell—which will hence work as the interpreter.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，这个二进制文件默认包含执行 Edify 脚本的解释器，由系统启动。这种“*脏*”技术包括用执行所需操作的 shell 脚本替换这个二进制文件。使用这种替代方法，您有了非常强大的
    shell 脚本语言，并且假设某些恢复自定义包括 Bash——作为 shell——因此它将作为解释器工作。
- en: 'The following is an example of the `busybox` installation in the Android system,
    using an ad hoc `update.zip`, with a shell script that operates the installation:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 Android 系统中使用 ad hoc `update.zip` 和操作安装的 shell 脚本进行 `busybox` 安装的示例：
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This script will replace our `update-script` and will operate the binary installation.
    As a result, the update package will have the following structure:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本将替换我们的 `update-script` 并执行二进制安装。结果，更新包将具有以下结构：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Thus, we can perform the most complex installations, and it turns out to be
    one of the most used methods by the Android ROM "modders".
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以执行最复杂的安装，并且这实际上是 Android ROM “modders”最常用的方法之一。
- en: Adding packages by source code
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过源代码添加软件包
- en: In system from source. In this section, we will make a real example by creating
    a `Hello World` application, with the help of Android Studio, which we will import
    and compile together with the entire Android system.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统源代码中。在本节中，我们将通过使用 Android Studio 创建一个“Hello World”应用程序来做一个真正的例子，我们将将其导入并与整个
    Android 系统一起编译。
- en: First, we need to create a base application with Android Studio.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要使用 Android Studio 创建一个基础应用程序。
- en: 'For the installation instructions, please read the following link: [http://developer.android.com/sdk/index.html](http://developer.android.com/sdk/index.html).'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对于安装说明，请阅读以下链接：[http://developer.android.com/sdk/index.html](http://developer.android.com/sdk/index.html)。
- en: 'When your system is ready, launch the IDE and create a new project:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的系统准备就绪时，启动 IDE 并创建一个新的项目：
- en: '![](img/epub_36702041_109.jpeg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/epub_36702041_109.jpeg)'
- en: 'The previous image shows how to specify an app name, a domain, and a path folder
    for our Android project. Once you have entered all the data, you can click **Next**
    and move to the API level selection, as shown here:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张图片显示了如何指定应用程序名称、域名和 Android 项目的路径文件夹。一旦输入所有数据，您就可以点击**下一步**并转到 API 级别选择，如这里所示：
- en: '![](img/epub_36702041_110.jpeg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/epub_36702041_110.jpeg)'
- en: 'As shown in the previous image, by default Android Studio will target API 16
    to cover more than 95% of the market. This value doesn''t really matter in our
    scenario, because this app will be installed only in our custom ROM, that is probably
    Android 6\. Let''s move to the next screen—Activity Picker:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一张图片所示，默认情况下 Android Studio 将针对 API 16，以覆盖超过 95% 的市场。在这个场景中，这个值并不重要，因为此应用将仅安装在我们的定制
    ROM 中，这可能是 Android 6。让我们转到下一个屏幕——活动选择器：
- en: '![](img/epub_36702041_111.jpeg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/epub_36702041_111.jpeg)'
- en: 'The previous image shows the plethora of possible activities we can easily
    add to our apps. For this example, we will use just an **Empty Activity**, to
    keep things simple:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张图片展示了我们可以轻松添加到我们的应用中的众多可能的活动。在这个例子中，我们将只使用一个**空活动**，以保持事情简单：
- en: '![](img/epub_36702041_112.jpeg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/epub_36702041_112.jpeg)'
- en: 'The previous image shows how to rename our brand new activity—`MainActivity`
    will do the job flawlessly. Just click **Finish** and Android Studio will bring
    you to the editor screen to add some code to your `Hello, World` app:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张图片显示了如何重命名我们全新的活动——`MainActivity`将完美地完成这项工作。只需点击**完成**，Android Studio就会带你进入编辑器屏幕，以便向你的`Hello,
    World`应用添加一些代码：
- en: '![](img/epub_36702041_113.jpeg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/epub_36702041_113.jpeg)'
- en: The previous image shows how to display a `Toast` message when our app starts;
    nothing fancy, but it's enough to give you an idea about how things can be made
    easy with the proper tool set and knowledge.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张图片显示了当我们的应用启动时如何显示`Toast`消息；没有太多花哨的东西，但足以让你了解如何通过适当的工具集和知识使事情变得简单。
- en: 'When your app is ready, just click the **Run** button and start building your
    APK file. Test it as much as you can and when you are satisfied with the results,
    copy the source code to the AOSP source code folder:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的应用准备就绪时，只需点击**运行**按钮，开始构建你的APK文件。尽可能多地测试它，当你对结果满意时，将源代码复制到AOSP源代码文件夹：
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With your current know-how, you are able to update the manifest file to add
    this app to the Android build system.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你目前的知识，你可以更新清单文件，将此应用添加到安卓构建系统中。
- en: 'The final touch is the `Android.mk` file. For this `Hello,World` example, just
    create a new file as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是`Android.mk`文件。对于这个`Hello, World`示例，只需创建一个新文件，如下所示：
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Add the following snippet:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下片段：
- en: '[PRE31]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Using Android's build system, you are now able to build and package your own
    Android apps for your custom ROM.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用安卓的构建系统，你现在能够构建和打包你自己的安卓应用到你的定制ROM中。
- en: Hacking the Android framework
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 破解安卓框架
- en: 'In these customizations were related to the User Interface. UI customization
    is a tricky topic due to the *personal taste* factor involved: many users love
    a "*pure Android*" UI, many other users love the idea of a "*different Android*"
    UI, far from the mainstream UI experience.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这些定制与用户界面相关。由于涉及**个人品味**因素，UI定制是一个棘手的话题：许多用户喜欢“*纯安卓*”界面，许多其他用户喜欢“*不同安卓*”界面的想法，远离主流的UI体验。
- en: In this section, we are giving you free will and the chance to choose between
    a vanilla Android and a customized one. You will learn how to make small customizations,
    to the status bar or to the colors, for example, or big customizations, like adding
    a new item to the **Settings** menu to properly set up the custom features of
    your custom ROM.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们给你自由选择，在纯安卓和定制安卓之间进行选择。你将学习如何进行小范围的定制，比如对状态栏或颜色进行定制，或者进行大范围的定制，比如向**设置**菜单添加新项目，以正确设置你定制ROM的定制功能。
- en: Customizing the boot sequence UI
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定制引导序列UI
- en: The graphical appearance of the ¾¦+ boot sequence is definitely one of the most
    popular customizations you'd like to do and often the one that your users will
    ask for and will love.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ¾¦+引导序列的图形外观无疑是您最想做的定制之一，通常是用户会要求并喜爱的。
- en: 'During the boot sequence, a standard Android device will show:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在引导过程中，标准的安卓设备将显示：
- en: The Splash image
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动画面
- en: The Boot animation
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引导动画
- en: 'The Splash image is a static image that the system shows in the first seconds
    after Power On. On a Google Nexus device, the Splash image looks like the following
    image:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 启动画面是系统在开机后前几秒显示的静态图像。在谷歌Nexus设备上，启动画面看起来如下所示：
- en: '![](img/epub_36702041_114.jpeg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/epub_36702041_114.jpeg)'
- en: The image shows the Google brand and a lock. As we already learned, the lock
    represents the status of the *bootloader*—locked or unlocked. The Splash image
    is associated to the initial phases of the boot—typically, the system shows the
    Splash image from the Power On to the completion of the bootloader and Linux kernel
    setup sequence.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图片显示了谷歌品牌和一个锁。正如我们之前所学的，锁代表**引导加载程序**的状态——锁定或解锁。启动画面与引导的初始阶段相关联——通常，系统从开机到引导加载程序和Linux内核设置序列完成期间显示启动画面。
- en: Customizing the ¾¦+ Splash image is no easy thing, because even if theoretically
    it's just an image, or a sequence of images, stored on the NAND memory, every
    manufacturer uses a custom approach to accomplish this goal and they are very
    unwilling to document how we could revert their work. What is extremely easy for
    them, having plenty of tools and knowledge about their system, becomes hours and
    hours of reverse engineering for us, with unpredictable results and effects on
    the stability of the whole system.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 定制¾¦+启动画面并不容易，因为即使从理论上讲它只是一个图像，或者一系列图像，存储在NAND内存中，每个制造商都使用定制的方案来完成这个目标，并且他们非常不愿意记录我们如何恢复他们的工作。对他们来说非常容易的事情，拥有大量的工具和关于他们系统的知识，对我们来说却变成了几个小时的反向工程，结果和效果对整个系统的稳定性都是不可预测的。
- en: Turning our attention to the boot animation, we can see that the boot animation
    is that sequence of images, most of the time animated, that any Android device
    shows during the startup sequence, right after the Splash image and until the
    Android system completes boot. Many manufacturers customize this animation to
    enforce their brand, and you will do the same with your *own brand*. From a technical
    point of view, the moment you see the boot animation, the kernel has been loaded,
    the partitions have been mounted, and Android is starting to boot.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 将注意力转向启动动画，我们可以看到启动动画是一系列图像，大多数情况下是动画的，任何Android设备在启动序列中都会显示这些图像，紧随启动画面之后，直到Android系统完成启动。许多制造商定制这个动画来强化他们的品牌，你也会用你的**自己的品牌**来做同样的事情。从技术角度来看，当你看到启动动画时，内核已经加载，分区已经挂载，Android开始启动。
- en: This sequence of images is way easier to customize compared to the Splash image.
    This is due to the fact that, even if the majority of the device has a custom
    boot animation, every single one of them respect very strict known requirements—that
    means that we have documentation for this!
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 与启动画面相比，这个图像序列更容易定制。这是因为即使大多数设备都有定制的启动动画，每一个都严格遵守非常严格的已知要求——这意味着我们为此有文档！
- en: As with lots of Android components, the boot animation comes as a standard `.zip`
    file and is placed in the `/system/media/` folder or in the `/data/local/`. All
    we need to customize the boot animation is to grab it, edit it as we like, and
    place it back—piece of cake!
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 就像许多Android组件一样，启动动画以标准的`.zip`文件形式提供，并放置在`/system/media/`文件夹或`/data/local/`中。我们只需要抓取它，按照我们的喜好编辑它，然后放回——小菜一碟！
- en: 'To retrieve the file, we can use our trusted `adb`. Fire up your terminal and
    run the following command:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索文件，我们可以使用我们信任的`adb`。打开你的终端并运行以下命令：
- en: '[PRE32]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Of course, if the file is not there, try the second possible location, as we
    said previously. Once you have the file on your host computer, you can decompress
    it and you will see the same folder structure as shown in the following image:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果文件不存在，就尝试我们之前提到的第二个可能的位置。一旦你在你的主机计算机上有了这个文件，你就可以解压缩它，你将看到以下图像中显示的相同的文件夹结构：
- en: '![](img/epub_36702041_115.jpeg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/epub_36702041_115.jpeg)'
- en: All those `part*` folders contain the images that create the animation, and
    the `desc.txt` file contains the instructions to properly perform the animation.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 所有那些`part*`文件夹包含创建动画的图像，而`desc.txt`文件包含正确执行动画的说明。
- en: 'Open the `desc.txt` file with your preferred text editor and you will see something
    like the following image:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你喜欢的文本编辑器打开`desc.txt`文件，你将看到以下图像类似的内容：
- en: '![](img/epub_36702041_116.jpeg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/epub_36702041_116.jpeg)'
- en: The first row specifies the resolution and the frame rate at which the animation
    will be displayed. Lines `2` to `6` specify how to show the different parts of
    the animation.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行指定了动画将显示的分辨率和帧率。行`2`到`6`指定了如何显示动画的不同部分。
- en: The first letter, "`c`", stands for "continue", and instructs the system to
    keep playing the sequence even if the boot sequence is completed.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个字母，"`c`"，代表“继续”，指示系统即使在启动序列完成后也要继续播放序列。
- en: The first number specifies how many times the part has to be repeated. In the
    example, just once, or infinite time (using 0 as the value to indicate an infinite
    loop). The second number specifies how many seconds will be waited before starting
    the next part. The last token of the row specifies the folder containing the images
    to show to create the animated sequence.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个数字指定了部分需要重复的次数。在示例中，只重复一次，或者无限时间（使用0作为值来表示无限循环）。第二个数字指定了在开始下一个部分之前将等待多少秒。行尾的最后标记指定了包含要显示的图像的文件夹。
- en: Now that you know about the inner structure of the `bootanimation.zip` file
    and how to set up the sequence, it's time to be creative and replace all those
    boring images to create your own awesome animation!
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了`bootanimation.zip`文件的内部结构和如何设置序列，是时候发挥创意，替换所有那些无聊的图像，创建你自己的精彩动画了！
- en: 'Once you are satisfied, it''s time to create a new `bootanimation.zip file`.
    Fire up your terminal and run the following command:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你满意，就是时候创建一个新的`bootanimation.zip`文件了。打开你的终端并运行以下命令：
- en: '[PRE33]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Carefully, replace `partx` with the correct sequence of folders you have in
    your animated sequence. To try out your brand new boot animation, just upload
    the `zip` file to `/data/local/` folder using `adb`. You could even create a custom
    `update.zip` and flash it to your device using Recovery. It's up to you.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细地将`partx`替换为你动画序列中正确的文件夹序列。要尝试你全新的启动动画，只需使用`adb`将`zip`文件上传到`/data/local/`文件夹。你甚至可以创建一个自定义的`update.zip`并将其通过Recovery刷入你的设备。这取决于你。
- en: Note
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'FFMPEG is a handy tool to extract images from a video to create your animated
    sequence. Fire up a terminal and run the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: FFMPEG是一个方便的工具，可以从视频中提取图像以创建你的动画序列。打开终端并运行以下命令：
- en: '[PRE34]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The previous command specifies a few interesting parameters: `-r 1` to capture
    a frame every second, `-s` to specify a resolution for the final images, and `-f
    image2` to actually capture a frame and save it as an image. As always, you can
    refer to `–h` for further documentation.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令指定了一些有趣的参数：`-r 1`用于每秒捕获一帧，`-s`用于指定最终图像的分辨率，`-f image2`用于实际捕获一帧并将其保存为图像。一如既往，你可以通过`-h`来获取更多文档信息。
- en: Customizing the Android Settings menu
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定制安卓设置菜单
- en: 'One great feature of Android is modularity: most of the system features are
    actually Android apps, developed and maintained separately. The Android `Settings`
    menu, for instance, is just an Android app itself, called `Settings.apk`, and,
    being part of the AOSP, can be freely customized, according to our needs. In the
    next pages, you will learn how to work on `Settings.apk` to add your custom menu
    item.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓的一个显著特点是模块化：大部分的系统功能实际上都是独立的安卓应用，分别开发和维护。例如，安卓的`设置`菜单本身就是一个安卓应用，称为`Settings.apk`，作为AOSP的一部分，可以根据我们的需求自由定制。在下一页，你将学习如何对`Settings.apk`进行操作以添加自定义菜单项。
- en: 'Open your terminal emulator, and from your `WORKING_DIRECTORY` containing Android
    source code, navigate to:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的终端模拟器，从包含安卓源代码的`WORKING_DIRECTORY`开始，导航到：
- en: '[PRE35]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This folder contains the source code of the vanilla `Settings` menu; this is
    your starting point for the customization.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件夹包含了原始`设置`菜单的源代码；这是你定制的起点。
- en: This is a crucial example, because, when you are working on a custom ROM, you
    are improving the system, adding new features, or enhancing existing ones. Your
    new features will probably need some level of setup and placing all the possible
    configuration options where the user expects them, that is, the `Setting`s menu,
    which is a fundamental point for a great user experience.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个关键示例，因为当你在一个自定义ROM上工作时，你正在改进系统，添加新功能或增强现有功能。你的新功能可能需要一定程度的设置，并将所有可能的配置选项放置在用户期望的位置，即`设置`菜单，这是良好用户体验的基本点。
- en: 'The following image shows the vanilla Android `Settings` menu, the object of
    our customization:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了原始安卓`设置`菜单，这是我们定制的对象：
- en: '![](img/epub_36702041_117.jpeg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/epub_36702041_117.jpeg)'
- en: 'Once you are in the `Settings` menu app folder, `packages/apps/Settings`, you
    can start editing files to add your new menu item. Let''s start with adding a
    few strings. With your preferred editor—Android Studio, Atom, SublimeText, and
    so on—edit `res/values/strings.xml` and add the following lines:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你进入了`设置`菜单应用文件夹，`packages/apps/Settings`，你就可以开始编辑文件以添加你的新菜单项。让我们从添加一些字符串开始。使用你喜欢的编辑器——Android
    Studio、Atom、SublimeText等——编辑`res/values/strings.xml`并添加以下行：
- en: '![](img/epub_36702041_118.jpeg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/epub_36702041_118.jpeg)'
- en: The `strings.xml` file contains the list of every text string used in the `Settings`
    app; it's the perfect starting point for your customization and gives you an idea
    about naming conventions and structure.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`strings.xml`文件包含了`设置`应用中使用的所有文本字符串列表；它是你定制的完美起点，并为你提供了关于命名约定和结构的想法。'
- en: 'Once you are satisfied with the string file, create a new `.java` file named
    `CustomSettings.java` and place it in the `src/com/android/settings` folder. This
    will contain all the logic we need. The following image shows a snippet of a custom
    `PreferenceFragment` you can create:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你对字符串文件满意，创建一个名为 `CustomSettings.java` 的新 `.java` 文件，并将其放置在 `src/com/android/settings`
    文件夹中。这将包含我们需要的所有逻辑。以下图片显示了你可以创建的自定义 `PreferenceFragment` 的一个片段：
- en: '![](img/epub_36702041_119.jpeg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/epub_36702041_119.jpeg)'
- en: 'This `Fragment` will load a specific layout file that you need to create. Let''s
    call it `custom_settings.xml` and populate it as shown in the next image:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `Fragment` 将加载你需要创建的特定布局文件。让我们称它为 `custom_settings.xml`，并按照下一张图片所示进行填充：
- en: '![](img/epub_36702041_120.jpeg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/epub_36702041_120.jpeg)'
- en: 'Now you need to add a few lines to the `AndroidManifest.xml`. Navigate to the
    `root` folder and edit the `AndroidManifest.xml` file as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要向 `AndroidManifest.xml` 文件中添加几行。导航到 `root` 文件夹并按照以下方式编辑 `AndroidManifest.xml`
    文件：
- en: '![](img/epub_36702041_121.jpeg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/epub_36702041_121.jpeg)'
- en: 'Navigate to the main `src/` folder and open `Settings.java`. This file contains
    every `Activity` available in the `Settings` menu. Here you can add your own `Activity`,
    as shown in the next image:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到主 `src/` 文件夹并打开 `Settings.java` 文件。这个文件包含了 `Settings` 菜单中可用的所有 `Activity`。在这里，你可以添加自己的
    `Activity`，如下一张图片所示：
- en: '![](img/epub_36702041_122.jpeg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/epub_36702041_122.jpeg)'
- en: 'The `src/` contains a `SettingsActivity.java` file. At the beginning of this
    you will find a field, `String` array, named `ENTRY_FRAGMENTS`. These are all
    the `Fragment`s that can be loaded by the `Activity` files in the `Settings` menu.
    The list is quite impressive, and on Android Marshmallow, it contains about 70
    `Fragments`; in your Android version, it will contain one more entry: yours. Add
    your `CustomSettings` class to the array, as shown in the following screenshot:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/` 目录下包含一个 `SettingsActivity.java` 文件。在这文件的开始部分，你会找到一个名为 `ENTRY_FRAGMENTS`
    的 `String` 数组。这些都是可以被 `Settings` 菜单中的 `Activity` 文件加载的 `Fragment`。这个列表相当令人印象深刻，在
    Android Marshmallow 系统中，它包含大约 70 个 `Fragment`；在你的 Android 版本中，它将包含一个额外的条目：你的。按照以下截图所示，将你的
    `CustomSettings` 类添加到数组中：'
- en: '![](img/epub_36702041_123.jpeg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](img/epub_36702041_123.jpeg)'
- en: 'We are almost there. The next thing we need to do is compile the new package
    with the following command:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了。接下来我们需要做的是使用以下命令编译新的包：
- en: '[PRE36]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Once we have created the new package, we can create a new update file and flash
    it using Recovery. On the next boot, we will see our brand new menu item in the
    **Settings** screen, as shown in the next screenshot:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了新的包，我们就可以创建一个新的更新文件，并使用 Recovery 来刷写它。在下次启动时，我们将在 **设置** 屏幕中看到我们全新的菜单项，如下一张截图所示：
- en: '![](img/epub_36702041_124.jpeg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](img/epub_36702041_124.jpeg)'
- en: Enhancing the system performance
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提升系统性能
- en: Lots of the custom ROMs that you can find on the Net bring performance enhancements,
    extended battery life, and lots of small tweaks. Most of these enhancements can
    be achieved with a surgical tuning of the `build.prop` file.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在网上找到的许多自定义 ROM 都带来了性能提升、电池寿命延长以及许多小调整。这些增强中的大多数都可以通过 `build.prop` 文件的手术式调整来实现。
- en: Customizing the system property file
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义系统属性文件
- en: The Android `build.prop` file contains details about a variety of system settings
    that are applied to the system during the boot sequence. Before diving into its
    customization, we need an overview about its internal structure.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Android 的 `build.prop` 文件包含在启动序列中应用于系统的各种系统设置的详细信息。在深入其定制之前，我们需要对其内部结构有一个概述。
- en: 'Open a terminal and connect to your device using the following command:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端并使用以下命令连接到你的设备：
- en: '[PRE37]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Navigate to the `/system` folder and open the `build.prop` file. The content
    will look like the following snippet:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到 `/system` 文件夹并打开 `build.prop` 文件。内容将类似于以下片段：
- en: '[PRE38]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As you can guess, parts of these instructions are specific for every device,
    but a few of them are quite common. We surely have device model name, brand, codename
    for product, device and board, and so on.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，这些说明中的部分是针对每个设备特定的，但其中一些相当常见。我们确实有设备型号名称、品牌、产品、设备和板子的代号等等。
- en: 'Some of these common values can be easily edited to obtain interesting behavioral
    changes in our system. For instance, you have probably noticed the tiny, but perceivable,
    delay that happens right before the smartphone starts ringing, when you receive
    a phone call. That delay can be removed by editing just a few lines in the `build.prop`
    file. Scan the file and look for these two lines:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这些常见值可以轻松编辑，以在我们的系统中获得有趣的行为变化。例如，你可能已经注意到了在接收到电话时，智能手机开始响铃前的那一小段，但可以感知到的延迟。通过仅编辑`build.prop`文件中的几行，就可以移除这个延迟。扫描文件并查找以下两行：
- en: '[PRE39]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Simply replace whatever value is assigned to them with a nice `0` (zero) and
    you can say goodbye to the delay.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地将分配给它们的任何值替换为漂亮的`0`（零），然后你可以告别延迟。
- en: 'Ever wondered why you cannot rotate the screen when the phone is displaying
    the lock screen or the application launcher? No more wondering. Look for these
    two lines and replace the existing properties with the new one:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾经想过为什么当手机显示锁屏或应用启动器时，你无法旋转屏幕？不再需要疑惑。查找这两行，并将现有的属性替换为新的属性：
- en: '[PRE40]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Do you want to rotate your device more than 180 degrees? Enable a 270 degree
    rotation with the following line:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否想要将设备旋转超过180度？通过以下行启用270度旋转：
- en: '[PRE41]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Another UI trick we can achieve with a single line edit is changing the LCD
    density value. Search for the following line:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过单行编辑实现另一个UI技巧，即更改LCD密度值。搜索以下行：
- en: '[PRE42]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Replace `XXX` with the value you want to try. Changing this value will produce
    a resizing of the system icons and an increase of the screen space: the smaller
    the value you set, the bigger the amount of free space you get. Unfortunately,
    there is no exact science here and a little *trial-and-error* is inevitable, so
    try to experiment with a few values until you find your preferred setup.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 将`XXX`替换为你想要尝试的值。更改此值将产生系统图标的大小调整和屏幕空间的增加：你设置的值越小，你得到的空闲空间就越多。不幸的是，这里没有精确的科学方法，一点点的*试错*是不可避免的，所以尝试用几个值进行实验，直到找到你喜欢的设置。
- en: 'Android devices are getting more powerful every day, but, back in the day,
    the available CPU power was very limited. To guarantee satisfactory performance
    and user experience, Android used smart tweaks, like the next one:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 每天Android设备都在变得更强大，但，在那些日子里，可用的CPU功率非常有限。为了保证令人满意的性能和用户体验，Android使用了智能调整，如下所示：
- en: '[PRE43]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The previous value alters the rendering quality of JPEG files. Even if it was
    useful in the past, we can consider it unnecessary on last generation smartphones,
    and we can safely set it to `100` and enjoy images at 100% of their original quality.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的值改变了JPEG文件的渲染质量。即使它在过去很有用，我们也可以认为在上一代智能手机上它是多余的，我们可以安全地将它设置为`100`并享受100%原始质量的图片。
- en: 'If your smartphone has physical navigation buttons, you can increase screen
    estate, removing the navigation softkeys at the bottom of the screen by setting
    the next property as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的智能手机有物理导航按钮，你可以通过以下方式设置下一个属性来增加屏幕空间，移除屏幕底部的导航软键：
- en: '[PRE44]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If your device has no physical key, you can still remove the softkeys and use
    gesture to navigate; check out the Google Play Store for gesture apps, like *All
    in one Gestures*. Continuing on the "screen estate" topic, you can remove the
    `debug mode` icon in the system notification bar with the following property:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的设备没有物理按键，你仍然可以移除软键并使用手势导航；在Google Play Store中查找手势应用，如*All in one Gestures*。继续“屏幕空间”主题，你可以通过以下属性移除系统通知栏中的`debug
    mode`图标：
- en: '[PRE45]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'These last two tweaks refer to networking settings. The first one is as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后两个调整指的是网络设置。第一个如下：
- en: '[PRE46]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This line configures how many seconds will be between every automatic Wi-Fi
    scan. Android performs automatic Wi-Fi scans by default, looking for an open network
    to connect or just to increase the precision of the navigation system. You can
    increase or decrease the frequency of these scans, trying to achieve the perfect
    balance between a higher precision of navigation and a longer battery life. The
    second networking tweak gives you the opportunity to set a default DNS server:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这行配置了每次自动Wi-Fi扫描之间的秒数。Android默认执行自动Wi-Fi扫描，寻找可连接的开放网络或仅为了提高导航系统的精度。你可以增加或减少这些扫描的频率，试图在导航的更高精度和更长的电池寿命之间找到完美的平衡。第二个网络调整给你提供了设置默认DNS服务器的机会：
- en: '[PRE47]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This is extremely useful in countries in which the government filters Internet
    websites according to their IP addresses. Using the DNS IPs shown in the previous
    snippet, Google's DNS servers, you will be able to bypass this kind of censorship.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这在政府根据 IP 地址过滤互联网网站的国家中非常有用。使用前面片段中显示的 DNS IP，Google 的 DNS 服务器，你将能够绕过这种审查。
- en: Adding a custom init sequence
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加自定义初始化序列
- en: 'Linux legacy is still strong in a few key aspects of the Android architecture.
    One of the most interesting ones is the possibility to execute custom scripts
    during initialization time. If you are familiar with Linux systems, you know about
    the `/etc/init.d` folder. This system folder contains a collection of scripts
    that can be executed during system startup. To achieve the same behavior on Android,
    we can use `busybox` and its `run-parts` utility. This utility takes a folder
    as an argument and executes every script contained in this folder. For instance,
    the following command will execute every script contained in `the /system/etc/init.d
    folder`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 的传统在 Android 架构的几个关键方面仍然很强。其中最有趣的一个是在初始化期间执行自定义脚本的可能性。如果你熟悉 Linux 系统，你了解
    `/etc/init.d` 文件夹。这个系统文件夹包含了一组在系统启动时可以执行的脚本。为了在 Android 上实现相同的行为，我们可以使用 `busybox`
    和它的 `run-parts` 工具。这个工具接受一个文件夹作为参数，并执行该文件夹中包含的每个脚本。例如，以下命令将执行 `/system/etc/init.d`
    文件夹中包含的每个脚本：
- en: '[PRE48]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To properly copy Linux `init.d` behavior, we want to be able to execute the
    scripts in a rigorous order. You can achieve this with clever file naming. Just
    rename your scripts and prepend a number, like in the following example:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确复制 Linux `init.d` 的行为，我们希望能够以严格的顺序执行脚本。你可以通过巧妙的文件命名来实现这一点。只需重命名你的脚本，并在前面加上一个数字，如下例所示：
- en: '[PRE49]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In the previous example, the `01settings` script will be executed before the
    `02optinimations` script, and so on. Now that you have a collection of ordered
    scripts and you know how to execute them one by one, you need to edit the `install-recovery.sh`
    file we saw in the previous chapters and add the following line:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`01settings` 脚本将在 `02optimizations` 脚本之前执行，依此类推。现在你已经有了一组有序的脚本，并且知道如何逐个执行它们，你需要编辑我们在前几章中看到的
    `install-recovery.sh` 文件，并添加以下行：
- en: '[PRE50]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Advanced Linux kernel modding
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级 Linux 内核修改
- en: When you think about customizing the core of an Android system, you immediately
    think about customizing the Linux kernel. It manages CPU, sensors, radio, and
    display, and it's the starting point of every great system customization. As we
    already saw, modifying the kernel is no easy job, but with the right mindset,
    knowledge, and toolset, it can be a satisfying experience.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想到定制 Android 系统的核心时，你立刻会想到定制 Linux 内核。它管理 CPU、传感器、无线电和显示，并且是每个系统定制的起点。正如我们之前看到的，修改内核并不是一件容易的事情，但有了正确的思维方式、知识和工具集，它可以是一次令人满意的体验。
- en: 'Every embedded system has its own customization possibilities and, when it
    comes to Android, most of the effort is focused on customizing the following:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 每个嵌入式系统都有其自定义的可能性，当涉及到 Android 时，大部分努力都集中在以下方面的定制：
- en: Governors
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理器
- en: I/O schedulers
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: I/O 调度器
- en: CPU overclocking/underclocking
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU 超频/降频
- en: Diving into CPU frequency management
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 深入 CPU 频率管理
- en: In work, and how you can pick a different one for different scenarios. In this
    section, you will learn how to customize existing governors and how to add new
    ones to your systems.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在工作中，以及如何根据不同的场景选择不同的管理器。在本节中，你将学习如何自定义现有的管理器以及如何将新的管理器添加到你的系统中。
- en: Note
  id: totrans-287
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: A *governor*, or CPU frequency manager, describes how the CPU behaves, based
    on specific environmental factors.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *管理器*，或 CPU 频率管理器，描述了 CPU 根据特定的环境因素如何表现。
- en: A typical general purpose governor would decrease the number of active cores
    and their working frequency when the system load is low and push the CPU to full
    power and full speed when the system is in need of high performance.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的通用管理器会在系统负载低时减少活跃核心的数量和它们的工作频率，当系统需要高性能时，将 CPU 推向全功率和全速。
- en: 'A standard Linux kernel provides the following governors:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的 Linux 内核提供了以下管理器：
- en: '**On-demand**: This is the default governor on most of the kernels on the market.
    It''s considered a *balanced* governor because it can guarantee the system to
    be reactive, quickly increasing the CPU frequency when needed. The truth is that,
    being so eager to increase the CPU frequency, this governor makes no real evaluation
    about the CPU power that is actually needed. The on-demand governor does not consider
    the actual system load; instead it just increases the CPU frequency to the max
    when it is triggered and then slowly decreases it if not needed. As you can see,
    this does not work well in a "battery saving" scenario: it is pushing to top speed
    every time the system thinks it is going to need more power, without a deeper
    analysis. This approach will surely guarantee a reactive device, but will definitely
    drain the battery very quickly.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按需**: 这是市场上大多数内核的默认调速器。它被认为是一个*平衡*的调速器，因为它可以保证系统具有反应性，在需要时快速增加CPU频率。事实是，由于如此渴望增加CPU频率，这个调速器并没有对实际所需的CPU功率进行任何实际评估。按需调速器不考虑实际系统负载；相反，当它被触发时，它会将CPU频率增加到最大值，如果不需要，它会缓慢降低。正如你所看到的，这不适合“省电”场景：每次系统认为需要更多电力时，它都会推到最高速度，而不进行更深入的分析。这种方法肯定会保证设备具有反应性，但肯定会迅速耗尽电池。'
- en: '**Powersave**: This is definitely the most effective way to save battery life,
    in a way. This governor sets the maximum CPU frequency to the lowest possible
    value. The battery will surely last "*an eternity*", but the device will be unusable:
    a 2 GHz Quad-core CPU can easily go down to 200 MHz, and if it stays there all
    the time, that''s just nonsense.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**省电**: 这无疑是节省电池寿命最有效的方法之一。这个调速器将CPU的最高频率设置为最低可能值。电池的续航时间肯定会“无限”，但设备将无法使用：一个2
    GHz四核CPU可以轻松降低到200 MHz，如果它始终保持在那里，那就毫无意义。'
- en: '**Performance**: This governor behaves as the exact opposite of the *Powersave*
    one: it sets the minimum CPU frequency to the maximum possible value to achieve
    maximum performance. Battery-wise, this will drain the battery in no time: a 2
    GHz Quad-core running all the time at full power is surely performing well, but
    the smartphone won''t last long.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**: 这个调速器与*省电*调速器的行为正好相反：它将CPU的最小频率设置为最大可能值以实现最佳性能。从电池的角度来看，这会迅速耗尽电池：一个始终以全功率运行的2
    GHz四核CPU当然表现良好，但智能手机的续航时间不会很长。'
- en: '**Interactive**: This is a smarter version of the *On-demand* governor. Its
    goal is to provide a reactive CPU scaling without falling into on-demand pitfalls.
    The On-demand governor changes the CPU frequency according to preset values, without
    any specific analysis. The interactive governor, instead, continuously evaluates
    the system load and adjusts the CPU frequency accordingly, with a more linear
    CPU scaling curve: definitely a big pro. The whole CPU scaling analysis is not
    based on raw workload, but is performed according to the requested time. This
    approach guarantees system fluidity and better performance in a multimedia scenario,
    because the CPU won''t jump up and down in frequency, but will be steady during
    the whole necessary time, providing a constant framerate when required.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交互式**: 这是按需调速器的更智能版本。其目标是提供一种反应性CPU缩放，而不会陷入按需陷阱。按需调速器根据预设值更改CPU频率，而不进行任何具体分析。相反，交互式调速器会持续评估系统负载，并根据需要调整CPU频率，具有更线性的CPU缩放曲线：这绝对是一个优点。整个CPU缩放分析不是基于原始工作量，而是根据请求的时间进行。这种方法保证了系统流畅性和在多媒体场景中的更好性能，因为CPU不会在频率上上下跳动，而是在整个必要的时间内保持稳定，在需要时提供恒定的帧率。'
- en: '**Conservative**: This governor is a smoother version of the On-demand governor.
    Unlike On-demand, the Conservative governor won''t push the CPU to the top frequency
    every single time, but will proceed through a series of CPU frequency steps, according
    to the CPU load.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保守**: 这个调速器是按需调速器的平滑版本。与按需调速器不同，保守调速器不会每次都将CPU推到最高频率，而是会根据CPU负载逐步调整CPU频率。'
- en: '**Userspace**: This is the most customizable and least "automatic" governor.
    It provides the user with the possibility to manually pick the desired frequency.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户空间**: 这是最可定制的也是最“非自动”的调速器。它为用户提供手动选择所需频率的可能性。'
- en: Adding a custom CPU frequency governor
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加自定义CPU频率调速器
- en: If you need a specific CPU behavior, or you simply want to dig deeper into kernel
    customization, you can create your own CPU governor.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要特定的CPU行为，或者你只是想更深入地了解内核定制，你可以创建自己的CPU调速器。
- en: 'For this task, you will need the kernel source code and to navigate to:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个任务，您需要内核源代码并导航到：
- en: '[PRE51]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This folder contains every governor we saw in the previous section and every
    possible custom governor you are going to add or that your device manufacturer
    already added.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件夹包含我们在上一节中看到的每个调度器以及您将要添加或设备制造商已经添加的每个可能的自定义调度器。
- en: 'Let''s create a new governor, creating a `.c` file in this folder, for example:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在该文件夹中创建一个新的调度器，例如创建一个`.c`文件：
- en: '[PRE52]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Once you have the file in place, you need to add it to the file mentioned here:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件放置好之后，您需要将其添加到以下提到的文件中：
- en: '[PRE53]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We make changes as shown in the following snippet:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按照以下片段所示进行更改：
- en: '[PRE54]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Once you are done with the `Kconfig`, edit the `Makefile` and add the following
    line:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 完成对`Kconfig`的编辑后，编辑`Makefile`并添加以下行：
- en: '[PRE55]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'As a last step, edit the following file:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，编辑以下文件：
- en: '[PRE56]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Around line 400, there is a list of currently available governors, as shown
    in the following image:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 大约在第400行，有一个当前可用的调度器列表，如下所示：
- en: '![](img/epub_36702041_125.jpeg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/epub_36702041_125.jpeg)'
- en: 'Following the same pattern, let''s add your new governor reference, using the
    following snippet:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 按照相同的模式，让我们添加您的新调度器引用，使用以下片段：
- en: '[PRE57]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Mission completed: your new governor is now available and ready to be integrated
    in your next kernel build. Try to run `menuconfig` and navigate to the governor
    screen; you will be able to enable it and set it as the default governor.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 任务完成：您的新调度器现在可用并准备好集成到您的下一个内核构建中。尝试运行`menuconfig`并导航到调度器屏幕；您将能够启用它并将其设置为默认调度器。
- en: Exploring I/O schedulers
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索I/O调度器
- en: 'I/O schedulers specify how I/O-bound operations must be performed and balanced
    among CPU cores. Android comes with a default set of I/O schedulers:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: I/O调度器指定了I/O密集型操作必须如何执行以及在CPU核心之间如何平衡。Android自带一组默认的I/O调度器：
- en: '**Noop**: This can be barely considered a scheduler. Practically speaking,
    it has no effect on the tasks list: it just queues them as they come in.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Noop**: 这几乎可以被认为是一个调度器。实际上，它对任务列表没有影响：它只是按顺序排队。'
- en: '**SIO**: This is the first real scheduler. Even if it does no task reordering,
    it guarantees the smallest possible latency from the moment the task is enqueued
    and the moment it is performed.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SIO**: 这是第一个真正的调度器。即使它不进行任务重排序，它也能保证从任务入队到执行的最小延迟。'
- en: '**CFQ**: This scheduler orders tasks in separated queues, according to specific
    categories, and assigns an execution time window to every queue. The window size
    depends on the priority assigned to the tasks involved.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CFQ**: 此调度器根据特定类别将任务排序到独立的队列中，并为每个队列分配一个执行时间窗口。窗口大小取决于分配给相关任务的优先级。'
- en: '**BFQ**: This scheduler is similar to the CFQ scheduler, but it uses disk bandwidth
    windows instead of time windows to group and schedule tasks.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BFQ**: 此调度器与CFQ调度器类似，但它使用磁盘带宽窗口而不是时间窗口来分组和调度任务。'
- en: '**Anticipatory**: This scheduler uses prediction techniques to group and schedule
    tasks, pausing executions for a short time period and waiting for a possible new
    task to be added to a specific queue.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Anticipatory**: 此调度器使用预测技术来分组和调度任务，暂停执行一段时间并等待可能的新任务被添加到特定队列。'
- en: '**ROW**: This scheduler is based on the "*read over write*" rule: every reading
    task has priority over writing tasks.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ROW**: 此调度器基于“*读优先于写*”规则：每个读取任务都比写入任务具有更高的优先级。'
- en: '**Deadline**: This scheduler guarantees termination for the enqueued tasks,
    trying to avoid "starvation" scenarios. *Starvation* is a well-known concept in
    computer science and applies to resource management. Imagine that *N* processes
    want to use the same shared resource. The shared resource can be used by one process
    at a time, and processes alternate according to their priority. What is going
    to happen if a low-priority process is asking for the resource, but the resource
    never becomes available due to other high-priority processes using it? The low-priority
    process will wait forever for the resource and never get to enjoy it. In computer
    science terminology, it will *starve*.'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Deadline**: 此调度器保证入队任务的终止，试图避免“饥饿”场景。*饥饿*是计算机科学中的一个知名概念，适用于资源管理。想象一下，*N*个进程想要使用相同的共享资源。共享资源一次只能由一个进程使用，进程根据它们的优先级交替使用。如果一个低优先级进程请求资源，但由于其他高优先级进程正在使用它，资源永远不会变得可用，会发生什么？低优先级进程将永远等待资源，永远不会得到使用。在计算机科学的术语中，它将*饿死*。'
- en: 'Every available scheduler is stored in the following folder:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 每个可用的调度器都存储在以下文件夹中：
- en: '[PRE58]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Creating an I/O scheduler can be challenging and it's beyond the purpose of
    this book. What we can do is point you in the right direction and get you curious
    about the topic.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 创建I/O调度器可能具有挑战性，这超出了本书的目的。我们能做的是为你指明正确的方向，并激发你对这个主题的兴趣。
- en: Looking forward
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 展望未来
- en: During the writing of this book, we were lucky enough to have a look at the
    upcoming Android N. The new version will probably be available at the end of 2016
    as a stable release, after a few months of public *developer preview*.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写这本书的过程中，我们很幸运地提前看到了即将到来的Android N。新版本可能于2016年底作为稳定版发布，在几个月的公开*开发者预览*之后。
- en: 'Android N introduces a few interesting features, like the "*Multi-Window*"
    mode shown in the next image:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: Android N引入了一些有趣的功能，如下一张图片所示的多窗口模式：
- en: '![](img/epub_36702041_126.jpeg)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![](img/epub_36702041_126.jpeg)'
- en: At Google, they are very focused on user feedback, and they decided to introduce
    this feature into the official version after a few months of testing by Samsung.
    Most of us will recognize the Multi-Windows mode from the already-available Android
    ROM, by Samsung. In Android N, this will be available for everybody, on every
    Android device, with full support for both orientations, portrait and landscape,
    and even the possibility to *resize* the split windows by dragging the "separator
    line".
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在谷歌，他们非常注重用户反馈，并在三星测试了几个月后决定将此功能引入官方版本。我们大多数人都会从三星已经提供的Android ROM中认出多窗口模式。在Android
    N中，这项功能将面向所有人，适用于所有Android设备，并完全支持两种方向，即纵向和横向，甚至可以通过拖动“分隔线”来*调整*分割窗口的大小。
- en: According to lots of blog posts, one of the most popular categories for Google
    Play Store apps is Caller ID filters. With Android N, this feature will be already
    available as a system feature as for the new "mobile data saving" feature that
    aims to reduce background data consumption for specific apps.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 根据许多博客文章，Google Play Store应用中最受欢迎的类别之一是来电显示过滤器。在Android N中，这个功能将作为系统功能提供，就像新的“移动数据节省”功能一样，旨在减少特定应用的背景数据消耗。
- en: 'One of the new UI enhancements that comes with Android N is the possibility
    to add and remove action icons in the scroll down `quick settings` menu, as shown
    in the next image:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: Android N带来的新UI增强之一是可以在滚动下拉的`快速设置`菜单中添加和删除操作图标，如下一张图片所示：
- en: '![](img/epub_36702041_127.jpeg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![](img/epub_36702041_127.jpeg)'
- en: 'Furthermore, the scroll down `notification` menu comes with a new notification
    design, that enables richer interactions, with quicker access to common actions,
    as shown in the next image:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，下拉的`通知`菜单还带来了新的通知设计，它允许更丰富的交互，更快地访问常用操作，如下一张图片所示：
- en: '![](img/epub_36702041_128.jpeg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![](img/epub_36702041_128.jpeg)'
- en: 'The **Settings** section received a bit of love as well, with the new in-place
    notifications, like the one shown in the next image, that gives you the opportunity
    to disable or enable settings without navigating to the specific location:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '**设置**部分也得到了一些关注，新增了就地通知，如下一张图片所示，这让你有机会在不导航到特定位置的情况下禁用或启用设置：'
- en: '![](img/epub_36702041_129.jpeg)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![](img/epub_36702041_129.jpeg)'
- en: 'The next image shows, also, the new `Navigation Drawer` that has been added
    to the `Setting` section, for a quicker navigation to the deeper menu levels:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个图片还展示了新添加到`设置`部分的`导航抽屉`，以便更快地导航到更深的菜单层级：
- en: '![](img/epub_36702041_130.jpeg)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![](img/epub_36702041_130.jpeg)'
- en: An incredible amount of small fixes will be available in this new version, and
    lots of improvements are aiming to increase performance and battery life, as the
    most wanted *doze on the go*, that promises to be a game changer for Android devices.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本中将提供大量的小修复，许多改进旨在提高性能和电池寿命，如最受欢迎的*移动中的省电模式*，它承诺将为Android设备带来变革。
- en: Summary
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter you learned how to effectively customize Android at different
    levels, following real-world examples. You now know how to programmatically create
    a custom ROM from source code, preparing a customized folder structure with every
    piece in place, ready to be assembled by Android's build system. You also know
    how to approach the customization task if you have an already-assembled system
    image, and how to customize and reassemble a binary image.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何通过实际案例在不同的级别上有效地自定义Android，你现在知道如何从源代码中程序性地创建一个自定义ROM，准备一个带有每个部件就绪的自定义文件夹结构，以便由Android的构建系统组装。你还知道如果你有一个已经组装的系统镜像，如何处理自定义任务，以及如何自定义和重新组装二进制镜像。
- en: 'The next chapter will bring you *outside* the pure smartphone experience and
    will show you how Android is effectively becoming ubiquitous in our lives: Internet
    of Things, Android Auto and Android Wear, domotics, and entertainment are just
    a few of the scenarios in which we can currently find the *green droid*.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将带你**走出**纯智能手机体验，并展示Android如何有效地成为我们生活中的无处不在：物联网、Android Auto和Android Wear、智能家居和娱乐只是我们目前能找到的*绿色机器人*的几个场景。
