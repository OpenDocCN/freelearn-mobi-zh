- en: Reactive Kotlin and Android
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式 Kotlin 和 Android
- en: So, our learning about reactive programming in Kotlin is almost complete. We
    have arrived at the last, but probably the most important, chapter of this book.
    Android is probably the biggest platform for Kotlin. During the last Google IO—Google
    IO 17, Google announced official support for Kotlin and added Kotlin as a first-class
    citizen of the Android application development. Kotlin is now the only officially
    supported Android application development language other than Java.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们关于 Kotlin 中反应式编程的学习几乎已经完成。我们已经到达了本书的最后一章，但可能是最重要的一章。Android 可能是 Kotlin
    最大的平台。在最近的 Google IO—Google IO 17 上，Google 宣布了对 Kotlin 的官方支持，并将 Kotlin 添加为 Android
    应用开发的第一个公民。现在，Kotlin 是除了 Java 之外唯一官方支持的 Android 应用开发语言。
- en: Reactive programming is already there in Android—most of the top libraries in
    Android support reactiveness. So, it is quite obvious that in a book titled *Reactive
    Programming in Kotlin*, we must cover Android as well.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式编程已经在 Android 中存在——Android 中大多数顶级库都支持反应性。因此，在名为 *Reactive Programming in
    Kotlin* 的书中，我们必须涵盖 Android。
- en: Teaching you Android development from scratch is beyond the scope of this book,
    as it's a vast topic. You can find many books out there if you would like to learn
    Android development from scratch. This book assumes you have some basic knowledge
    in Android application development and can work with `RecyclerView`, `Adapter`,
    `Activity`, Fragment, CardView, AsyncTask, and more. If you are not familiar with
    any of the topics mentioned, you can read *Expert Android Programming* by *Prajyot
    Mainkar*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 从零开始教授 Android 开发超出了本书的范围，因为这是一个庞大的主题。如果您想从头学习 Android 开发，可以找到很多书籍。本书假设您对 Android
    应用开发有一些基本知识，并且可以与 `RecyclerView`、`Adapter`、`Activity`、Fragment、CardView、AsyncTask
    等一起工作。如果您不熟悉所提到的任何主题，可以阅读 *Prajyot Mainkar* 的 *Expert Android Programming*。
- en: 'So, are you wondering what this chapter has for you? Take a look at the following
    list of the topics we will cover:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，您想知道本章为您准备了什么吗？请查看以下我们将涵盖的主题列表：
- en: Setting up Kotlin in Android Studio 2.3.3 and 3.0
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Android Studio 2.3.3 和 3.0 中设置 Kotlin
- en: Getting started with `ToDoApp` in Android and Kotlin
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Android 和 Kotlin 中开始 `ToDoApp` 的开发
- en: API calls with Retrofit 2
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Retrofit 2 进行 API 调用
- en: Setting up RxAndroid and RxKotlin
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 RxAndroid 和 RxKotlin
- en: Using RxKotlin with Retrofit 2
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 RxKotlin 与 Retrofit 2
- en: Developing our app
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发我们的应用
- en: A brief introduction to RxBinding
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RxBinding 简介简要
- en: So, let's get started with setting up Kotlin in Android Studio.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始设置 Android Studio 中的 Kotlin。
- en: Setting up Kotlin in Android Studio
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Android Studio 中设置 Kotlin
- en: We strongly encourage you to use Android Studio 3.0 for Android development,
    irrespective of whether you're using Kotlin or not. Android Studio 3.0 is the
    latest version of Android Studio, with a lot of bug fixes, new features, and improved
    Gradle build time.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强烈建议您使用 Android Studio 3.0 进行 Android 开发，无论您是否使用 Kotlin。Android Studio 3.0
    是 Android Studio 的最新版本，包含许多错误修复、新功能和改进的 Gradle 构建时间。
- en: 'For Android Studio 3.0, you don''t need to do any setup to use Kotlin for Android
    development. You just need to select Include Kotlin support while creating a new
    project. Here is a screenshot for your reference:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Android Studio 3.0，您在创建新项目时只需选择“包含 Kotlin 支持”即可，无需进行任何设置。以下是供您参考的截图：
- en: '![](img/522fe92a-f72c-4e55-a816-7b254c3fed99.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/522fe92a-f72c-4e55-a816-7b254c3fed99.jpg)'
- en: We've highlighted the Include Kotlin support section of the Android Studio—Create
    Android Project dialog.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经突出了 Android Studio—创建 Android 项目对话框中的“包含 Kotlin 支持”部分。
- en: 'However, if you''re using Android Studio 2.3.3, then follow these steps:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您正在使用 Android Studio 2.3.3，请按照以下步骤操作：
- en: Go to Android Studio | Settings | Plugins.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 Android Studio | 设置 | 插件。
- en: 'Search for `Kotlin` (take a look at the following screenshot) and install that
    plugin as follows:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索 `Kotlin`（查看以下截图）并按照以下步骤安装该插件：
- en: '![](img/deb76a4a-bd0c-427a-afd6-19311956e6b4.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/deb76a4a-bd0c-427a-afd6-19311956e6b4.jpg)'
- en: Start a new Android project.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始一个新的 Android 项目。
- en: 'To apply the Kotlin plugin to the project, open the project level `build.gradle`
    and modify the content, as shown here:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将 Kotlin 插件应用到项目中，打开项目级别的 `build.gradle` 并修改内容，如下所示：
- en: '![](img/68e6de34-8c0a-43a0-8f44-b674e9e0a53d.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/68e6de34-8c0a-43a0-8f44-b674e9e0a53d.jpg)'
- en: 'Open the `build.gradle` in your module (or we might say, app level `build.gradle`)
    and add the following `dependencies`:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您模块中的 `build.gradle` 文件（或者我们也可以说是应用级别的 `build.gradle` 文件）并添加以下 `dependencies`：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You are now all set to start writing Kotlin code in Android Studio.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已准备好开始在 Android Studio 中编写 Kotlin 代码。
- en: However, before starting with the Kotlin code, let's first review our `build.gradle`.
    The preceding code that I showed for Android Studio 2.3.3 is valid for Android
    Studio 3.0 as well, you just don't have to manually add this as Android Studio
    3.0 automatically adds it for you. However, what is the purpose of those lines?
    Let's inspect them.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在开始编写Kotlin代码之前，让我们首先回顾一下我们的`build.gradle`。我之前为Android Studio 2.3.3展示的代码对Android
    Studio 3.0同样有效，你只需要不需要手动添加，因为Android Studio 3.0会自动为你添加。然而，这些行的目的是什么？让我们检查一下。
- en: In the project level `build.gradle` file, the `ext.kotlin_version = "1.1.51"`
    line creates a variable in Gradle with the name of `kotlin_version`; this variable
    will hold a `String` value, `1.1.51` (which is the latest version of Kotlin at
    the time of writing this book). We are writing this in a variable, as this version
    is required in a number of places in the project level and app level `build.gradle`
    file. If we declare it once and use it in multiple places, then there will be
    consistency, and there won't be any chance for human mistakes.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目级别的`build.gradle`文件中，`ext.kotlin_version = "1.1.51"`这一行在Gradle中创建了一个名为`kotlin_version`的变量；这个变量将持有`String`类型的值，`1.1.51`（这是撰写本书时的最新版本）。我们在变量中写入这个版本，因为这个版本在项目级别和应用程序级别的`build.gradle`文件中的多个地方都需要。如果我们只声明一次并在多个地方使用它，那么将会有一致性，并且不会有人为错误的机会。
- en: Then, on the same file (project level `build.gradle`), we will add `classpath
    "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"`. This will define
    a classpath used by Gradle to search for `kotlin-jre` when we add them as a dependency.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在同一个文件（项目级别的`build.gradle`文件）中，我们将添加`classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"`。这将定义Gradle用于在添加它们作为依赖项时搜索`kotlin-jre`的类路径。
- en: Inside the app level `build.gradle` file, we will write `implementation "org.jetbrains.kotlin:kotlin-stdlib-jre7:$kotlin_version"`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用级别的`build.gradle`文件中，我们将编写`implementation "org.jetbrains.kotlin:kotlin-stdlib-jre7:$kotlin_version"`。
- en: So, let's get started with the Kotlin code. As we mentioned in the previous
    chapter, we will create a `ToDoApp`. There will be three screens, one for the `ToDo
    List`, one to create a `ToDo`, and one to edit/delete `ToDo`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始编写Kotlin代码。正如我们在上一章中提到的，我们将创建一个`ToDoApp`。将会有三个屏幕，一个用于`ToDo List`，一个用于创建`ToDo`，另一个用于编辑/删除`ToDo`。
- en: Getting started with ToDoApp on Android
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Android上开始使用ToDoApp
- en: 'As mentioned earlier, we are using Android Studio 3.0 (stable) for this project.
    The following screenshot depicts the project structure that we''re using:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们在这个项目中使用的是Android Studio 3.0（稳定版）。下面的截图展示了我们使用的项目结构：
- en: '![](img/71882bb0-c011-4d63-b1db-f39e50862a2e.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/71882bb0-c011-4d63-b1db-f39e50862a2e.jpg)'
- en: In this project, we are using package-by features, and I do prefer to use package-by
    for Android development, mainly for its scalability and maintainability. Also,
    note that it is best practice to use package-by feature in Android; although,
    you can obviously use your preferred model. You can read more about the package-by
    feature at [https://hackernoon.com/package-by-features-not-layers-2d076df1964d](https://hackernoon.com/package-by-features-not-layers-2d076df1964d).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们使用按功能划分的包，我确实更喜欢在Android开发中使用按功能划分的包，主要是因为其可扩展性和可维护性。此外，请注意，在Android中使用按功能划分的包是一种最佳实践；尽管如此，你显然可以使用你喜欢的模型。你可以在[https://hackernoon.com/package-by-features-not-layers-2d076df1964d](https://hackernoon.com/package-by-features-not-layers-2d076df1964d)了解更多关于按功能划分的包的信息。
- en: Now, let's understand the package structure used in this application. The root
    package here is `com.rivuchk.todoapplication`, the package for the application,
    identical with the `applicationId`. The root package contains two classes—`ToDoApp`
    and `BaseActivity`. The `ToDoApp` class extends `android.app.Application` so that
    we can have our own implementation of the `Application` class. Now, what is `BaseActivity`?
    `BaseActivity` is an abstract class created within this project, and all activities
    in this project should extend `BaseActivity`; so, if we want to implement something
    throughout all the activities in this project, we can write the code in `BaseActivity`
    and rest assured that all activities will now implement the same.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解在这个应用程序中使用的包结构。这里的根包是`com.rivuchk.todoapplication`，它是应用程序的包，与`applicationId`相同。根包包含两个类——`ToDoApp`和`BaseActivity`。`ToDoApp`类扩展了`android.app.Application`，这样我们就可以有自己的`Application`类实现。现在，什么是`BaseActivity`？`BaseActivity`是在这个项目中创建的一个抽象类，这个项目中的所有活动都应该扩展`BaseActivity`；因此，如果我们想在项目中的所有活动中实现某些功能，我们可以在`BaseActivity`中编写代码，并且可以放心，所有活动现在都会实现相同的代码。
- en: Next, we have an `apis` package for the classes and files related to the API
    calls (we will use Retrofit) and `datamodels` for models (POJO) classes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个`apis`包，用于与API调用相关的类和文件（我们将使用Retrofit），以及`datamodels`用于模型（POJO）类。
- en: We have the `Utils` package for `CommonFunctions` and `Constants` (a singleton
    `Object` to hold constant variables such as `BASE_URL` and others).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有`Utils`包用于`CommonFunctions`和`Constants`（一个单例`Object`，用于存储如`BASE_URL`等常量变量）。
- en: The `addtodo`, `tododetails`, and `todolist` are three feature-based packages.
    The `todolist` package contains `Activity` and `Adapter` for displaying the list
    of todos. The `tododetails` package contains the `Activity` responsible to display
    the details of todo. We will use the same `Activity` to edit as well. The `addtodo`
    package holds the `Activity` that will be used to accomplish the functionality
    of adding a todo.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`addtodo`、`tododetails`和`todolist`是三个基于功能的包。`todolist`包包含用于显示待办事项列表的`Activity`和`Adapter`。`tododetails`包包含负责显示待办事项详细信息的`Activity`。我们也将使用相同的`Activity`来编辑。`addtodo`包包含用于实现添加待办事项功能的`Activity`。'
- en: 'Before starting with the activities and layouts, I want you to take a look
    inside `BaseActivity` and `ToDoApp`, so here is the code inside the `ToDoApp.kt`
    file:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始活动布局之前，我希望你先看看`BaseActivity`和`ToDoApp`的内部结构，所以这里是`ToDoApp.kt`文件中的代码：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A small class indeed; it contains only a `companion object` to provide us with
    the instance. This class will grow as we move ahead with this chapter. We declared
    `ToDoApp` as the `application` class for this project in the manifest, as shown
    here:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 确实是一个小类；它只包含一个`companion object`来为我们提供实例。随着我们继续本章的学习，这个类将会逐渐增长。我们在清单文件中声明了`ToDoApp`为这个项目的`application`类，如下所示：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `BaseActivity` is also now small. As with the `ToDoApp`, it''ll also grow
    over the course of this chapter:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseActivity`现在也很小。与`ToDoApp`一样，它也会在本章的进程中逐渐增长：'
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For now, `BaseActivity` only hides the `onCreate` method from the `Activity`
    class, and provides a new abstract method—`onCreateBaseActivity`. This class also
    mandates that we override `onCreateBaseActivity` in child classes so that if there's
    anything we need to implement inside the `onCreate` method, of all activities,
    we can do that inside the `onCreate` method of `BaseActivity`, and forget the
    rest.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`BaseActivity`只隐藏了`Activity`类的`onCreate`方法，并提供了一个新的抽象方法——`onCreateBaseActivity`。这个类还强制要求我们在子类中重写`onCreateBaseActivity`，这样我们就可以在所有活动的`onCreate`方法中实现任何需要的功能，而无需在其他地方实现。
- en: So, let's get started with the `todolist`. This package contains all the sources
    required to display the list of todos. If you look at the previous screenshot
    carefully, you should notice that the package contains two classes—`TodoListActivity`
    and `ToDoAdapter`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始处理`todolist`。这个包包含了显示待办事项列表所需的所有源代码。如果你仔细查看前面的截图，你应该会注意到这个包包含两个类——`TodoListActivity`和`ToDoAdapter`。
- en: 'So, let''s start with the design of `TodoListActivity`; when completed, this
    `Activity` should look like the following screenshot:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们从`TodoListActivity`的设计开始；当完成时，这个`Activity`应该看起来像下面的截图：
- en: '![](img/ae96f7fb-8770-4d9a-b0c0-0af6aac2131e.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ae96f7fb-8770-4d9a-b0c0-0af6aac2131e.jpg)'
- en: 'As the screenshot depicts, we will need a `FloatingActionButton` and a `RecyclerView`
    for this `Activity`, so here is the XML layout for this example—`activity_todo_list.xml`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如截图所示，我们需要一个`FloatingActionButton`和一个`RecyclerView`来构建这个`Activity`，所以这里是这个示例的XML布局文件——`activity_todo_list.xml`：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Take a look at the preceding layout. In the declaration of `RecyclerView`, we
    set `layoutManager` to `LinearLayoutManager` and orientation to vertical-all from
    the layout itself, so we would not need to worry about setting it inside the code.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下前面的布局。在`RecyclerView`的声明中，我们将其`layoutManager`设置为`LinearLayoutManager`，并将方向设置为从布局本身开始的垂直，所以我们就不需要在代码中设置它了。
- en: We used a `FloatingActionButton` to add new todos. We also used `AppBarLayout`
    as an action bar.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一个`FloatingActionButton`来添加新的待办事项。我们还使用了`AppBarLayout`作为操作栏。
- en: 'It''s time to move ahead and take a look inside the `onCreateBaseActivity`
    method of the `TodoListActivity`, as shown here:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候继续前进，看看`TodoListActivity`的`onCreateBaseActivity`方法了，如下所示：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding program, we created an instance of `ToDoAdapter` to set it
    as the adapter of `rvToDoList`, the `RecyclerView` where we will display the list
    of todos. While creating the instance of `ToDoAdapter`, we passed a `lambda`;
    this `lambda` should be called when an item from the `rvToDoList` is clicked.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，我们创建了一个 `ToDoAdapter` 实例，将其设置为 `rvToDoList` 的适配器，`rvToDoList` 是我们将显示待办事项列表的
    `RecyclerView`。在创建 `ToDoAdapter` 实例时，我们传递了一个 lambda；当点击 `rvToDoList` 中的项目时，应该调用这个
    lambda。
- en: 'We also called a `fetchTodoList()`function at the end of the `onCreateBaseActivity`
    method. As the name indicates, it is responsible to fetch the todo list from the
    REST API. We will see the definition and go into the details of this method later,
    but, for now, let''s take a look at `Adapter`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在 `onCreateBaseActivity` 方法的末尾调用了一个 `fetchTodoList()` 函数。正如其名称所示，它负责从 REST
    API 获取待办事项列表。我们将在稍后查看该方法的定义和细节，但现在，让我们看看 `Adapter`：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Study the preceding code carefully. It's the complete `ToDoAdapter` class. We
    took an instance of `context` as a comment `(1)` constructor parameter. We used
    that `context` to get an instance of `Inflater`, which in turn was used to inflate
    the layouts inside the `onCreateViewHolder` method. We created a blank `ArrayList`
    of `ToDoModel`. We used that list to get item counts of the adapter `getItemCount()`
    function, and inside the `onBindViewHolder` function, to pass it to the `ViewHolder`
    instance.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细研究前面的代码。这是完整的 `ToDoAdapter` 类。我们取了一个 `context` 实例作为注释 `(1)` 构造函数参数。我们使用那个
    `context` 来获取一个 `Inflater` 实例，然后在该实例中用于 `onCreateViewHolder` 方法中的布局填充。我们创建了一个空的
    `ToDoModel` `ArrayList`。我们使用那个列表来获取适配器的 `getItemCount()` 函数的项目数，并在 `onBindViewHolder`
    函数中将其传递给 `ViewHolder` 实例。
- en: We also took a lambda as a `val` parameter inside the constructor of `ToDoAdapter`—`onItemClick`
    (comment `(2)`). That lambda should receive an instance of `ToDoModel` as a parameter
    and should return unit.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在 `ToDoAdapter` 构造函数内部将 lambda 作为 `val` 参数——`onItemClick`（注释 `(2)`）。这个 lambda
    应该接收一个 `ToDoModel` 实例作为参数，并返回 unit。
- en: We used that lambda at `bindView` of `ToDoViewHolder`, inside `onClick` (comment
    `(7)`) of `itemView` (the view for that item in the list). So, whenever we click
    on an item, the `onItemClick` lambda will be called, which is passed from the
    `TodoListActivity`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `ToDoViewHolder` 的 `bindView` 中使用了那个 lambda，在 `itemView` 的 `onClick`（注释
    `(7)`）中。所以，每次我们点击一个项目时，都会调用 `onItemClick` lambda，它是由 `TodoListActivity` 传递的。
- en: Now, focus on comment `(5)`—`setDataset()` method. This method is used to assign
    a new list to the adapter. It will clear the `ArrayList`—`TodoList` and add all
    items from the passed list to it. This method, `setDataset`, should be called
    by the `fetchTodoList()` method in `TodoListActivity`. That `fetchTodoList()`
    method is responsible for fetching the list from the REST API, and it will pass
    that list to the adapter.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，关注注释 `(5)` 中的 `setDataset()` 方法。此方法用于将一个新的列表分配给适配器。它将清除 `ArrayList`—`TodoList`
    并将传递的列表中的所有项目添加到其中。这个 `setDataset` 方法应该在 `TodoListActivity` 中的 `fetchTodoList()`
    方法中调用。那个 `fetchTodoList()` 方法负责从 REST API 获取列表，并将该列表传递给适配器。
- en: We will look inside the `fetchTodoList()` method later, but let's concentrate
    on the REST API and Retrofit 2 for API calls.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后查看 `fetchTodoList()` 方法，但让我们集中关注 REST API 和 Retrofit 2 用于 API 调用。
- en: Retrofit 2 for API calls
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Retrofit 2 用于 API 调用
- en: Retrofit by Square is one of the most famous and widely used REST clients for
    Android. It internally uses OkHTTP for HTTP and network calls. The word REST client
    makes it different from other networking libraries in Android. While most of the
    networking libraries (Volley, OkHTTP, and others) focus on synchronous/asynchronous
    requests, prioritization, ordered requests, concurrent/parallel requests, caching,
    and more. Retrofit gives more attention to making network calls and parsing data
    more like method calls. It simply turns your HTTP API into a Java interface. And
    it doesn't even try to solve network problems by itself, but delegates this to
    OkHTTP internally.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Retrofit by Square 是 Android 中最著名和最广泛使用的 REST 客户端之一。它内部使用 OkHTTP 进行 HTTP 和网络调用。REST
    客户端这个词使其与其他 Android 网络库不同。虽然大多数网络库（Volley、OkHTTP 等）专注于同步/异步请求、优先级、有序请求、并发/并行请求、缓存等，但
    Retrofit 更注重使网络调用和解析数据更像方法调用。它简单地将你的 HTTP API 转换为 Java 接口。而且它甚至不尝试自己解决网络问题，而是将此委托给内部的
    OkHTTP。
- en: 'So, how does it transform an HTTP API into a Java interfaces? Retrofit simply
    uses a converter to serialize/deserialize **POJO** (**plain old Java object**)
    classes into/from JSON or XML. Now, what is a converter? Converters are those
    helper classes that parse JSON/XML for you. A converter generally uses the `Serializable`
    interface internally to convert to/from JSON/XML and POJO classes (data classes
    in Kotlin). It being pluggable gives you many choices of converters, such as the
    following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，它是如何将HTTP API转换为Java接口的呢？Retrofit简单地使用一个转换器将POJO（**普通的Java对象**）类序列化和反序列化为JSON或XML。现在，什么是转换器？转换器是那些为你解析JSON/XML的辅助类。转换器通常使用`Serializable`接口内部进行JSON/XML和POJO类（在Kotlin中的数据类）之间的转换。它具有可插拔性，为你提供了许多转换器的选择，如下所示：
- en: Gson
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gson
- en: Jackson
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jackson
- en: Guava
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Guava
- en: Moshi
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Moshi
- en: Java 8 converter
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 8转换器
- en: Wire
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wire
- en: Protobuf
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Protobuf
- en: SimpleXML
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SimpleXML
- en: 'We will use Gson for our book. To work with Retrofit, you''ll need the following
    three classes:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Gson来处理我们的书籍。要使用Retrofit，你需要以下三个类：
- en: A `Model` class (POJO or data class)
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`Model`类（POJO或数据类）
- en: A class to provide you with the Retrofit client instance with the help of `Retrofit.Builder()`
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类，通过`Retrofit.Builder()`提供Retrofit客户端实例
- en: An `Interface` that defines possible HTTP operations, including the request
    type (GET or POST), parameters/request body/query strings, and finally the response
    type
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`Interface`，定义可能的HTTP操作，包括请求类型（GET或POST）、参数/请求体/查询字符串，以及最终的响应类型
- en: So, let's get started with the `Model` class.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们从`Model`类开始。
- en: 'Before creating the class, we need to know the structure of the JSON response
    first. We all saw JSON responses in the previous chapter, but, as a quick recap,
    here is the JSON response for the `GET_TODO_LIST` API:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建类之前，我们首先需要了解JSON响应的结构。我们在上一章中看到了JSON响应，但为了快速回顾，以下是`GET_TODO_LIST` API的JSON响应：
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `error_code` denotes whether there are any errors. If `error_code` is a
    non-zero value, then there must be an error. If it's zero, then there is no error,
    and you can proceed with parsing the data.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`error_code`表示是否存在错误。如果`error_code`是非零值，则必须存在错误。如果是零，则没有错误，你可以继续解析数据。'
- en: The `error_message` will contain information for you if there's an error. If
    the `error_code` is zero, the `error_message` will be blank.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有错误，`error_message`将包含信息。如果`error_code`为零，则`error_message`将为空。
- en: The `data` key will hold a JSON array for the list of todos.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`data`键将包含待办事项列表的JSON数组。'
- en: One thing to note here is that `error_code` and `error_message` will be consistent
    for all APIs in our project, so it will be better if we create a base class for
    all the APIs, and then we extend that class for each API when required.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一点是，`error_code`和`error_message`将与我们项目中的所有API保持一致，因此如果我们为所有API创建一个基类，然后在需要时扩展该类会更好。
- en: 'This is our `BaseAPIResponse` class:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们`BaseAPIResponse`类：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We have two `val` properties in this class—`errorCode` and `errorMessage`; note
    the annotations `@SerializedName`. This annotation is used by Gson to declare
    the serialized name for a property; the serialized name should be the same as
    the JSON response. You can easily avoid this annotation if you have the same variable
    name as the JSON response. If the variable name is different, the serialized name
    is used to match the JSON response.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们有两个`val`属性——`errorCode`和`errorMessage`；注意`@SerializedName`注解。这个注解由Gson用来声明属性的序列化名称；序列化名称应该与JSON响应相同。如果你有与JSON响应相同的变量名，你可以轻松地避免这个注解。如果变量名不同，序列化名称用于匹配JSON响应。
- en: 'Let''s now move ahead with `GetToDoListAPIResponse`; the following is the class
    definition:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续进行`GetToDoListAPIResponse`；以下是这个类的定义：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we skipped the `@Serialized` annotation for `data`, as we are using the
    same name as the JSON response. The remaining two properties are declared by the
    `BaseAPIResponse` class.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们跳过了`@SerializedName`注解的`data`，因为我们使用的是与JSON响应相同的名称。剩余的两个属性是由`BaseAPIResponse`类声明的。
- en: For data, we are using an `ArrayList` of `ToDoModel`; `Gson` will take care
    of the rest to convert a JSON array to an `ArrayList`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据，我们使用`ToDoModel`的`ArrayList`；Gson将负责将JSON数组转换为`ArrayList`。
- en: 'Let''s now take a look at the `ToDoModel` class:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下`ToDoModel`类：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `builder` class for Retrofit is simple, as shown here:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Retrofit的`builder`类很简单，如下所示：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `getClient()` function is responsible to create and provide you with a Retrofit
    client. The `getAPIService()` function helps you with pairing the Retrofit client
    with your defined HTTP operations and create an instance of the interface.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`getClient()`函数负责创建并提供Retrofit客户端。`getAPIService()`函数帮助你将Retrofit客户端与定义的HTTP操作配对，并创建接口的实例。'
- en: We used `OkHttpClient` and `Retrofit.Builder()` to create the `Retrofit` instance.
    If you're not familiar with them, you may visit [http://www.vogella.com/tutorials/Retrofit/article.html](http://www.vogella.com/tutorials/Retrofit/article.html).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`OkHttpClient`和`Retrofit.Builder()`来创建`Retrofit`实例。如果你不熟悉它们，你可以访问[http://www.vogella.com/tutorials/Retrofit/article.html](http://www.vogella.com/tutorials/Retrofit/article.html)。
- en: 'Let''s now create the interface for the HTTP operations—`APIService`—as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建HTTP操作的接口——`APIService`——如下所示：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We have created API interfaces for all our APIs. Note the return types of the
    functions. They return a `Call` instance that encapsulates the actual expected
    response.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为所有API创建了API接口。注意函数的返回类型。它们返回一个封装实际预期响应的`Call`实例。
- en: Now, what is `Call` instance? And what is the purpose of using it?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，`Call`实例是什么？使用它的目的是什么？
- en: The `Call` instance is an invocation of a Retrofit method that sends a request
    to a webserver and returns a response. Each call yields its own HTTP request and
    response pair. What to do with the `Call<T>` instance? We have to `enqueue` it
    with a `Callback<T>` instance.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`Call`实例是对Retrofit方法的一个调用，它向web服务器发送请求并返回响应。每个调用都产生它自己的HTTP请求和响应对。我们该如何处理`Call<T>`实例？我们必须用`Callback<T>`实例`enqueue`它。'
- en: So, the same pull mechanism, same callback hell. However, we should be reactive,
    shouldn't we? Let's do that.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，同样的拉取机制，同样的回调地狱。然而，我们应该是响应式的，不是吗？让我们这么做。
- en: RxKotlin with Retrofit
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RxKotlin与Retrofit
- en: In Android, we can use RxAndroid in addition to RxKotlin for added Android flavors
    and benefits, and Retrofit supports them as well.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，我们可以使用RxAndroid以及RxKotlin来增加Android风味和好处，并且Retrofit也支持它们。
- en: 'So, let''s start by modifying our `build.gradle` in favor of ReactiveX. Add
    the following dependencies to the app level `build.gradle`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们首先修改我们的`build.gradle`以支持ReactiveX。将以下依赖项添加到应用的`build.gradle`级别：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The first one will provide Retrofit 2 Adapters for RxJava 2, while the following
    two add RxAndroid and RxKotlin to the project.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个提供了Retrofit 2适配器用于RxJava 2，而接下来的两个添加了RxAndroid和RxKotlin到项目中。
- en: Note that RxKotlin is a wrapper on top of RxJava, so adapters for RxJava 2 will
    work perfectly with RxKotlin 2.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，RxKotlin是RxJava的包装器，所以RxJava 2的适配器将与RxKotlin 2完美兼容。
- en: Now that we have added the dependencies, let's move on by modifying our code
    to work with `Observable`/`Flowable` instead of `Call`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了依赖项，让我们继续修改我们的代码，使其与`Observable`/`Flowable`而不是`Call`一起工作。
- en: 'This is the modified `APIClient.kt` file:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是修改后的`APIClient.kt`文件：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This time, we added an OkHttp Logging interceptor (`HttpLoggingInterceptor`)
    along with an RxJava adapter. This OkHttp Logging interceptor will help us log
    requests and responses. Coming back to the RxJava adapters, look at the highlighted
    code—we added `RxJava2CallAdapterFactory` as the `CallAdapterFactory` of the Retrofit
    client.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们添加了一个OkHttp Logging拦截器（`HttpLoggingInterceptor`）以及一个RxJava适配器。这个OkHttp
    Logging拦截器将帮助我们记录请求和响应。回到RxJava适配器，看看高亮代码——我们添加了`RxJava2CallAdapterFactory`作为Retrofit客户端的`CallAdapterFactory`。
- en: 'We will need to modify the `APIService.kt` file as well, to make the functions
    return `Observable` instead of `Call`, as shown here:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要修改`APIService.kt`文件，以便让函数返回`Observable`而不是`Call`，如下所示：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: All the APIs now return `Observable` instead of `Call`. Finally, we are all
    set to look inside the `fetchTodoList()` function from `TodoListActivity`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有的API都返回`Observable`而不是`Call`。最后，我们一切都准备好了，可以查看`TodoListActivity`中的`fetchTodoList()`函数。
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The function does a simple task; it subscribes to the API (`Observable` from
    the API) and sets the data to the adapter when it arrives. You should consider
    adding logic to check the error code before setting the data here, but for now
    it works quite well. The screenshot of this activity is already shown at the beginning
    of this chapter, so we will omit it here.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数执行一个简单的任务；它订阅API（来自API的`Observable`），并在数据到达时将其设置到适配器中。你应该考虑在这里添加逻辑来检查错误代码，但到目前为止它工作得相当好。这个活动的截图已经在本章的开头显示过了，所以我们在这里省略它。
- en: Making Android events reactive
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使Android事件响应式
- en: We have made our API calls reactive, but what about our events? Remember the
    `ToDoAdapter`; we took a lambda, used it inside `ToDoViewHolder`, and created
    and passed the lambda at `TodoListActivity`. Quite messy. This should be reactive
    as well, shouldn't it? So, let's make the events reactive as well.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使我们的 API 调用响应式了，但我们的事件呢？记住 `ToDoAdapter`；我们在 `TodoListActivity` 中创建并传递了一个
    lambda，并在 `ToDoViewHolder` 内部使用了它。这相当混乱。这些事件也应该响应式，不是吗？所以，让我们使事件也响应式。
- en: '`Subject` plays an awesome role in making events reactive. As `Subject` is
    a great combination of `Observable` and `Observer`, we can use them as `Observer`
    inside `Adapter` and as `Observable` inside `Activity`, thus making passing events
    easy.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`Subject` 在使事件响应式方面发挥着极好的作用。由于 `Subject` 是 `Observable` 和 `Observer` 的绝佳组合，我们可以在
    `Adapter` 内部将其用作 `Observer`，并在 `Activity` 内部将其用作 `Observable`，从而使得传递事件变得容易。'
- en: 'So, let''s modify the `ToDoAdapter` as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们按照以下方式修改 `ToDoAdapter`：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The adapter looks cleaner now. We've got a `Subject` instance in the constructor,
    and when the `itemView` is clicked, we call the `onNext` event of the `Subject`
    and pass both the `itemView` and `ToDoModel` instance with help of `Pair`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在适配器看起来更简洁了。我们在构造函数中有一个 `Subject` 实例，当 `itemView` 被点击时，我们调用 `Subject` 的 `onNext`
    事件，并通过 `Pair` 将 `itemView` 和 `ToDoModel` 实例传递。
- en: However, it still looks like something is missing. The `onClick` method is still
    a callback; can't we make it reactive as well? Let's do that.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它仍然看起来像缺少了什么。`onClick` 方法仍然是一个回调；我们能不能也使其响应式呢？让我们这么做。
- en: Introducing RxBinding in Android
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Android 中引入 RxBinding
- en: To aid us Android developers, Jake Wharton created the RxBinding library, which
    helps you get Android events in a reactive way. You can find them at [https://github.com/JakeWharton/RxBinding](https://github.com/JakeWharton/RxBinding).
    Let's get started by adding it to the project.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助 Android 开发者，Jake Wharton 创建了 RxBinding 库，它可以帮助您以响应式的方式获取 Android 事件。您可以在
    [https://github.com/JakeWharton/RxBinding](https://github.com/JakeWharton/RxBinding)
    找到它们。让我们通过将其添加到项目中开始吧。
- en: 'Add the following dependency to the app level `build.gradle` file:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下依赖项添加到应用级别的 `build.gradle` 文件中：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then we can replace `onClick` inside `ToDoViewHolder` with the following line
    of code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以用以下代码行替换 `ToDoViewHolder` 内部的 `onClick`：
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It''s that easy. However, you''re probably thinking, what''s the benefit of
    making them reactive? The implementation here was simple enough, but think of
    a situation where you''ve tons of logic. You can easily divide the logic into
    operators, especially `map` and `filter` could be of great help to you. Not only
    that, but RxBindings provides you with consistency. For example, when we need
    to observe text changes on an `EditText`, we generally end up writing lines of
    code in a `TextWatcher` instance, but if you use RxBindings, it will let you do
    that as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单。然而，你可能正在想，使它们响应式有什么好处呢？这里的实现足够简单，但想想你有很多逻辑的情况。你可以轻松地将逻辑划分为操作符，特别是 `map`
    和 `filter` 可以为你提供极大的帮助。不仅如此，RxBindings 还为您提供了一致性。例如，当我们需要观察 `EditText` 上的文本变化时，我们通常会在
    `TextWatcher` 实例中编写大量的代码，但如果你使用 RxBindings，它将让你这样做：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Yes, it's really that simple and that easy. RxBinding provides you with a lot
    more benefits as well. You can take a look at [https://speakerdeck.com/lmller/kotlin-plus-rxbinding-equals](https://speakerdeck.com/lmller/kotlin-plus-rxbinding-equals)
    and [http://adavis.info/2017/07/using-rxbinding-with-kotlin-and-rxjava2.html](http://adavis.info/2017/07/using-rxbinding-with-kotlin-and-rxjava2.html).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这真的很简单，也很容易。RxBinding 还为您提供了更多的好处。您可以查看 [https://speakerdeck.com/lmller/kotlin-plus-rxbinding-equals](https://speakerdeck.com/lmller/kotlin-plus-rxbinding-equals)
    和 [http://adavis.info/2017/07/using-rxbinding-with-kotlin-and-rxjava2.html](http://adavis.info/2017/07/using-rxbinding-with-kotlin-and-rxjava2.html)。
- en: So now, thanks to Jake Wharton, we can make our views and events reactive as
    well.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在，多亏了 Jake Wharton，我们也可以使我们的视图和事件响应式。
- en: Kotlin extensions
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin 扩展
- en: At the end of this chapter, I would like to introduce you to the Kotlin extensions.
    No, not exactly the Kotlin extensions functions, although they are very much related
    to the Kotlin extension functions. Kotlin extensions is a curated list of the
    most commonly used extension functions in Android.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束之际，我想向您介绍 Kotlin 扩展。不，确切地说，不是 Kotlin 扩展函数，尽管它们与 Kotlin 扩展函数非常相关。Kotlin
    扩展是一份精心挑选的、在 Android 中最常用的扩展函数列表。
- en: 'For example, if you want an extension function to create a bitmap from a `View`/`ViewGroup`
    instance (especially useful while adding Markers in MapFragment), you can copy
    and paste the following extension function from there:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您想要一个扩展函数，可以从`View`/`ViewGroup`实例创建位图（在添加MapFragment中的标记时特别有用），您可以从那里复制并粘贴以下扩展函数：
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Or, a more common case, when you need to hide your keyboard, the following
    extension function will help you:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，更常见的情况，当您需要隐藏键盘时，以下扩展函数将帮助您：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This online listing has a lot more extension functions for you, which are maintained
    by Ravindra Kumar (Twitter, GitHub—`@ravidsrk`). So, the next time you need an
    extension function, take a look at [http://kotlinextensions.com/](http://kotlinextensions.com/) before
    writing your own.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个在线列表为您提供了更多扩展函数，由Ravindra Kumar维护（Twitter，GitHub—`@ravidsrk`）。所以，下次您需要扩展函数时，在编写自己的函数之前，先看看
    [http://kotlinextensions.com/](http://kotlinextensions.com/)。
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We are done with the final chapter of the book. In this chapter, we learned
    how to configure Retrofit for RxKotlin and RxAndroid. We learned how to make our
    Android views and events as well as our custom views reactive.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了这本书的最后一章。在这一章中，我们学习了如何为RxKotlin和RxAndroid配置Retrofit，以及如何使我们的Android视图和事件以及自定义视图变得响应式。
- en: We learned how to use RxJava2Adapter for Retrofit and how to use `Subject` for
    event passing. We also learned how to use RxBindings.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何使用RxJava2Adapter和Retrofit，以及如何使用`Subject`进行事件传递。我们还学习了如何使用RxBindings。
- en: Throughout this book, we tried to go to the depth of reactive programming and
    cover every possible concept, and we tried to make all our code reactive.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们试图深入探讨响应式编程，涵盖所有可能的概念，并尝试使所有代码都变得响应式。
- en: If you find any questions, or if you get any concerns regarding this book, feel
    free to drop a email at [rivu.chakraborty6174@gmail.com](mailto:rivu.chakraborty6174@gmail.com)
    and mention `Book Query - Reactive Programming in Kotlin` in the subject line
    of the email. You can also check out Rivu Chakraborty's website ([http://www.rivuchk.com](http://www.rivuchk.com))
    as he regularly posts there about Kotlin, Google Developer Group Kolkata, and
    Kotlin Kolkata User Group Meetups. He also writes tutorials and blogs there as
    well as writes introductions to Android Plugins developed by him. Also, when he
    writes blogs and articles elsewhere, he posts URLs to them on his site.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对此书有任何疑问，或者对此书有任何顾虑，请随时发送电子邮件至 [rivu.chakraborty6174@gmail.com](mailto:rivu.chakraborty6174@gmail.com)，并在邮件主题行中提及
    `Book Query - Reactive Programming in Kotlin`。您也可以查看Rivu Chakraborty的网站 ([http://www.rivuchk.com](http://www.rivuchk.com))，他在那里定期发布关于Kotlin、Google开发者小组加尔各答和Kotlin加尔各答用户组聚会的文章。他还在那里撰写教程和博客，以及介绍他自己开发的Android插件的简介。此外，当他撰写其他地方的博客和文章时，他会在自己的网站上发布它们的URL。
- en: Thank you for reading this book. Happy reactive programming in Kotlin.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢您阅读这本书。祝您在Kotlin中进行愉快的响应式编程。
