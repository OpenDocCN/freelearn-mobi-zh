- en: Chapter 9. Asynchronous Work on the Native Layer
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章。在本地层上的异步工作
- en: In previous chapters, we have been using Java thread APIs and concurrent primitives
    delivered by the Android SDK to build our asynchronous constructs. A Java thread,
    an independent line of execution in our application, is automatically attached
    to the Android virtual machine and is bound to one native thread on the system.
    In previous chapter examples, we executed Java compiled bytecode on the JVM and
    used Java synchronization and concurrent primitives to solve correctness and liveness
    issues.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们一直在使用 Android SDK 提供的 Java 线程 API 和并发原语来构建我们的异步结构。Java 线程是我们应用程序中独立执行线路，它自动附加到
    Android 虚拟机，并绑定到系统上的一个本地线程。在前面的章节示例中，我们在 JVM 上执行了 Java 编译的字节码，并使用 Java 同步和并发原语来解决正确性和活跃性问题。
- en: In this chapter, we will make use of the Java Native Interface (JNI) to execute
    code written in C/C++ and compile it to native code. The native code, which runs
    directly on the hardware and makes use of the native CPU **Application Binary
    Interface** (**ABI**), generally runs faster than the bytecode due to optimizations
    made by the compilers, or optimizations introduced by developers with the use
    of specific ABI techniques. Hence, when we perform intensive computing operations
    on the device this could be the way to go to obtain a performance boost on your
    application and to reduce the power consumption.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将利用 Java 本地接口（JNI）来执行用 C/C++ 编写的代码并将其编译成本地代码。本地代码直接在硬件上运行并使用本地 CPU **应用程序二进制接口**（**ABI**），由于编译器进行的优化或开发人员使用特定
    ABI 技术引入的优化，通常比字节码运行得更快。因此，当我们对设备进行密集计算操作时，这可能是提高应用程序性能和降低功耗的方法。
- en: With this in mind, we will learn how to use the JNI interface to execute concurrent
    tasks on native code (C/C++), interact with Java code from the native layer, and
    update the UI from native code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们将学习如何使用 JNI 接口在本地代码（C/C++）上执行并发任务，从本地层与 Java 代码交互，并从本地代码更新 UI。
- en: Later, we will learn how to create native threads and use synchronization primitives
    such as `mutex` and `condition` to avoid any memory consistency problems that
    could come up when the device multiple line of executions in parallel and they
    share the same memory segments.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将学习如何创建本地线程并使用同步原语如 `mutex` 和 `condition` 来避免在设备并行执行多行代码且它们共享相同的内存段时可能出现的任何内存一致性问题时。
- en: To finish, we will start a group of threads to run background work on the native
    layer that dispatches the result to the UI.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将启动一组线程在本地层上运行后台工作，并将结果分派到 UI。
- en: 'In this chapter, we will cover:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Introduction to JNI
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JNI 简介
- en: Android NDK
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android NDK
- en: Calling C functions from Java code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Java 代码调用 C 函数
- en: Calling C++ member/static functions from Java code
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Java 代码调用 C++ 成员/静态函数
- en: Accessing Java objects from native code
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从本地代码访问 Java 对象
- en: Executing native background work on Java threads
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Java 线程上执行本地后台工作
- en: Executing asynchronous work on a native thread
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地线程上执行异步工作
- en: Interacting with a Java monitor from native code
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从本地代码与 Java 监视器交互
- en: Handling Java exceptions on the native layer
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地层上处理 Java 异常
- en: Introduction to JNI
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JNI 简介
- en: '**JNI** is an interface that allows the execution of native code, written on
    C, C++, or Assembly, from the **Java Virtual Machine** (**JVM**). The interface
    strictly defines the way that any JNI implementation should act to manage and
    control the interactions between Java code and the machine code. Moreover, the
    machine code is able to interact with the JVM and create objects, execute member
    functions, modify the member variables and handle Java exceptions.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**JNI** 是一个接口，允许从 **Java虚拟机**（**JVM**）执行用 C、C++ 或汇编编写的本地代码。该接口严格定义了任何 JNI 实现应该如何行动以管理和控制
    Java 代码与机器代码之间的交互。此外，机器代码能够与 JVM 交互并创建对象、执行成员函数、修改成员变量和处理 Java 异常。'
- en: 'The JNI, which allows you to execute machine code along with your Java code,
    is typically used to:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 允许您在 Java 代码中执行机器代码的 JNI 通常用于：
- en: 'Accelerate some critical portions of your application. Since the code runs
    directly on the hardware, it could make use of specific instruction sets to improve
    the execution:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加速应用程序的一些关键部分。由于代码直接在硬件上运行，它可以利用特定的指令集来提高执行效率：
- en: 'Example: The use of SIMD instructions to accelerate audio or video floating-point
    operations.'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例：使用 SIMD 指令来加速音频或视频浮点运算。
- en: 'Integrate existing C/C++ libraries in to your Android application. You can
    port any legacy code or library written to the Android platform and use it on
    your Android application:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将现有的C/C++库集成到您的Android应用程序中。您可以将任何针对Android平台编写的遗留代码或库移植到您的Android应用程序中并使用它：
- en: 'Example: The integration of open source libraries such as `opencv`, `libgdx`,
    and `box2d` into your application runtime.'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例：将开源库如`opencv`、`libgdx`和`box2d`集成到您的应用程序运行时。
- en: 'To use a platform dependent feature that is not accessible from the Java API:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使用Java API无法访问的平台相关特性：
- en: 'Example: Low-level OS features such as poll and semaphores or native APIS such
    as OpenGL, OpenSL ES, or OpenMAX AL.'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例：如poll和信号量等低级OS特性或如OpenGL、OpenSL ES或OpenMAX AL等本地API。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that adding C/C++ with JNI to your project does not come free and it
    typically adds complexity to your project, making it harder to debug, build, and
    test. Therefore, you must evaluate the cost/benefit before you make the decision
    to use it in your application.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，将C/C++和JNI添加到您的项目中并非免费，通常会增加项目的复杂性，使得调试、构建和测试变得更加困难。因此，在决定在您的应用程序中使用它之前，您必须评估其成本效益。
- en: Android NDK (Native Development Kit)
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android NDK（本地开发工具包）
- en: To help with the building and construction of Android applications that require
    a dynamic collaboration between the Java layer and the native layer, a development
    kit named Android NDK is supplied on the Android Developer website ([http://developer.android.com/ndk/index.html](http://developer.android.com/ndk/index.html)).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助构建需要Java层和本地层之间动态协作的Android应用程序，Android开发者网站上提供了一个名为Android NDK的开发工具包([http://developer.android.com/ndk/index.html](http://developer.android.com/ndk/index.html))。
- en: The Android NDK, the Android toolset that allows you to compile your code written
    in C/C++ to the several ABIs supported by Android, is also able to compile pre-existing
    libraries written in C or C++ to the Android platform.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Android NDK是一个Android工具集，允许您将用C/C++编写的代码编译成Android支持的多个ABIs，它还能够将用C或C++编写的现有库编译到Android平台。
- en: Before we move on in more detail, you should install the NDK package in your
    development platform, following the instructions defined on [http://developer.android.com/ndk/downloads](http://developer.android.com/ndk/downloads).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们更详细地继续之前，您应该在您的开发平台上安装NDK包，按照[http://developer.android.com/ndk/downloads](http://developer.android.com/ndk/downloads)上定义的说明进行操作。
- en: At the time of writing, the latest version of NDK is 10e, so we will base our
    code and examples on this version for the rest of this chapter.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，NDK的最新版本是10e，因此我们将以此版本为基础编写代码和示例，本章的其余部分也将以此为基础。
- en: The Java source code that you will write in your application, compiled by Android
    SDK, generates Android bytecode that will be interpreted by the Android JVM on
    any Android device.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在应用程序中编写的Java源代码，由Android SDK编译，生成Android字节码，该字节码将在任何Android设备上的Android JVM上被解释。
- en: With your source code written in C or C++, the NDK compiler will convert it
    to CPU code with different instruction sets, hardware features, calling conventions,
    and storing conventions. Each kind of CPU architecture has its own ABI that defines
    how the machine code should be arranged to interact with CPU hardware.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用用C或C++编写的源代码，NDK编译器将其转换为具有不同指令集、硬件特性、调用约定和存储约定的CPU代码。每种CPU架构都有自己的ABI，它定义了机器代码应该如何排列以与CPU硬件交互。
- en: 'The NDK toolset comes with tools that abstract these hardware traits and generates
    machine code to the following ABIs: armeabi, armeabi-v7a, arm64-v8a, x86, x86_64,
    mips, and mips64.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: NDK工具集包含工具，可以抽象这些硬件特性，并为以下ABIs生成机器代码：armeabi、armeabi-v7a、arm64-v8a、x86、x86_64、mips和mips64。
- en: Most of the time you want to support as many devices as possible, so by default,
    the NDK will generate code for all the CPU architectures and instruction sets
    supported.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，您希望支持尽可能多的设备，因此默认情况下，NDK将为所有支持的CPU架构和指令集生成代码。
- en: Calling C functions from Java code
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Java代码调用C函数
- en: The powerful JNI interface, as referred to before, is able to manage interaction
    in both directions, from Java to C and from C to Java.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，强大的JNI接口能够管理双向交互，从Java到C和从C到Java。
- en: A regular Java class declaring a method with the keyword `native` declares that
    the method behavior is implemented in native code. Like a regular Java method,
    the JNI `native` method is able to receive Java objects or primitive types as
    arguments and return primitive types and objects.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 声明方法的 Java 类使用关键字 `native` 声明该方法的行为是在本地代码中实现的。与常规 Java 方法一样，JNI `native` 方法能够接收
    Java 对象或原始数据类型作为参数，并返回原始数据类型和对象。
- en: 'Let''s see how a `native` method definition will look like in a Java class:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个 `native` 方法定义在 Java 类中会是什么样子：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding activity will call the native code to check whether a number is
    prime or not and print the result on the UI.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的活动将调用本地代码来检查一个数字是否为质数，并在 UI 上打印结果。
- en: Notice that our function receives a primitive as an argument and return a primitive
    `boolean` as a result and does not have any body, like an abstract function.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的函数接收一个原始数据作为参数，并返回一个原始 `boolean` 类型的结果，并且没有函数体，就像一个抽象函数一样。
- en: With the member function declared as native, we inform the compiler that this
    function is going to be implemented in C/C++, in a native library that gets loaded
    dynamically at runtime.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当成员函数声明为 native 时，我们通知编译器该函数将在 C/C++ 中实现，在一个在运行时动态加载的本地库中。
- en: With the member function now declared as native on the Java side, let's use
    `javah` to declare and implement our native method in the native code.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在成员函数已经在 Java 侧声明为 native，让我们使用 `javah` 在本地代码中声明和实现我们的本地方法。
- en: A `javah` is able to help the developer to generate native method prototypes
    with name conventions used by the JNI interface, the SDK becomes a handy tool
    that generates a header file for all your class native methods.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`javah` 能够帮助开发者生成使用 JNI 接口命名的约定来生成本地方法原型，SDK 成为一个方便的工具，可以为您所有的类生成本地方法的头文件。'
- en: 'To use it, please go to your project directory, create a `jni` directory, and
    run the next `javah` to generate the header file for your native function. In
    Android Studio IDE, open a terminal window and go to the `src/main` directory:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，请前往您的项目目录，创建一个 `jni` 目录，并运行下一个 `javah` 以生成您本地函数的头文件。在 Android Studio IDE
    中，打开一个终端窗口并转到 `src/main` 目录：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If everything goes as expected, the file `com_..._chapter9_MyNativeActivity.h`
    will be generated with our `native` method declaration:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切按预期进行，文件 `com_..._chapter9_MyNativeActivity.h` 将会生成我们的 `native` 方法声明：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `native` method will receive a `JNIEnv*` pointer to the JVM environment,
    a `jobject` reference to the actual Java object instance that invoked the method,
    and an integer argument.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`native` 方法将接收指向 JVM 环境的 `JNIEnv*` 指针，一个指向实际调用该方法的 Java 对象实例的 `jobject` 引用，以及一个整型参数。'
- en: The previous method declared in the following JNI specification, it should be
    declared and implemented in your code and loaded on the runtime over a shared
    library.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下 JNI 规范中声明的先前方法，应在您的代码中声明和实现，并在运行时通过共享库加载。
- en: 'Now that we have the method declared, let''s create a `source` file under `jni`
    called `c_functions.c`, with the `native` method implementation for our `isPrime`
    function:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经声明了方法，让我们在 `jni` 目录下创建一个 `source` 文件，名为 `c_functions.c`，其中包含 `isPrime`
    函数的 `native` 方法实现：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When `MyNativeActivity.isPrime` is called, the JNI interface transparently forwards
    the processing to the native code function, passing a native integer primitive
    (`jint`). The Android JNI implementation automatically converts the Java type
    `int` value to a native type (`jint`), executes the native function, and at the
    end returns `jboolean` that is automatically converted by the JNI interface to
    a Java primitive, `boolean`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `MyNativeActivity.isPrime` 时，JNI 接口将处理过程透明地转发到本地代码函数，传递一个本地整型原始数据 (`jint`)。Android
    JNI 实现自动将 Java 类型 `int` 的值转换为本地类型 (`jint`)，执行本地函数，并在最后返回由 JNI 接口自动转换为 Java 原始数据
    `boolean` 的 `jboolean`。
- en: 'The following table shows how Java types are mapped to native types:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了 Java 类型如何映射到本地类型：
- en: '| Java Type | Native Type | Description |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| Java 类型 | 本地类型 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `boolean` | `Jboolean` | Unsigned 8 bits |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `boolean` | `Jboolean` | 无符号 8 位 |'
- en: '| `byte` | `Jbyte` | Signed 8 bits |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `byte` | `Jbyte` | 有符号 8 位 |'
- en: '| `char` | `jchar` | Unsigned 16 bits |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `char` | `jchar` | 无符号 16 位 |'
- en: '| `short` | `jshort` | Signed 16 bits |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `short` | `jshort` | 有符号 16 位 |'
- en: '| `int` | `jint` | Signed 32 bits |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `int` | `jint` | 有符号 32 位 |'
- en: '| `long long` | `jlong` | Signed 64 bits |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `long long` | `jlong` | 有符号 64 位 |'
- en: '| `float` | `jfloat` | Floating Number 32 bit |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `float` | `jfloat` | 32 位浮点数 |'
- en: '| `double` | `jdouble` | Floating Number 64 bit |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `double` | `jdouble` | 64 位浮点数 |'
- en: '| `Object` | `jobject` | Any Java Object |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `Object` | `jobject` | 任何 Java 对象 |'
- en: '| `Class` | `class` | Class Object |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `Class` | `class` | 类对象 |'
- en: '| `String` | `jstring` | String objects |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `String` | `jstring` | 字符串对象 |'
- en: '| `void` | `void` |   |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `void` | `void` |   |'
- en: 'Although we have the native function declared and implemented in our source
    file, the JVM will not find the method until we have loaded the shared library
    that contains our native function. First, we will define the `ndk` folder in our
    project''s root folder `local.properties` file:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在源文件中声明并实现了本地函数，但 JVM 不会找到该方法，直到我们加载包含我们的本地函数的共享库。首先，我们将在项目的根目录 `local.properties`
    文件中定义 `ndk` 文件夹：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, in our `build.gradle` module configuration we will define the shared
    library name under the `ndk` configuration section:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在我们的 `build.gradle` 模块配置中，我们将在 `ndk` 配置部分下定义共享库的名称：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, Android Studio is able to `compile c_functions.c` and generate a shared
    library with the name `mylib` for all the ABIs supported in the build directory:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Android Studio 能够编译 `c_functions.c` 并为构建目录中支持的构建目标生成名为 `mylib` 的共享库：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: These libraries are going to be packed in a universal `apk` file ready to be
    loaded by our Android application.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这些库将被打包在一个通用的 `apk` 文件中，以便我们的 Android 应用程序加载。
- en: 'All that remains is to load the library on our runtime before we try to use
    it in our code. To load shared libraries on the JVM runtime, the `java.lang.System`
    class provides a `static` method to load a shared library and its dependencies,
    so before we use it on our class we will add a static section to our `Activity`
    class to load the library as soon as the class loader loads our class:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的工作就是在我们的代码中使用它之前，在我们的运行时加载库。要在 JVM 运行时加载共享库，`java.lang.System` 类提供了一个 `static`
    方法来加载共享库及其依赖项，因此在我们使用它之前，我们将在我们的 `Activity` 类中添加一个静态部分，以便在类加载器加载我们的类时立即加载库：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When the library is required, the `System` class automatically detects the ABI
    where the device is running and loads the required platform dependent library.
    Therefore, if you are running on an x86 device, `x86/libmylib.so` is going to
    be loaded.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要库时，`System` 类会自动检测设备正在运行的 ABI 并加载所需的平台相关库。因此，如果您正在 x86 设备上运行，将加载 `x86/libmylib.so`。
- en: Calling C++ functions from native code
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从本地代码调用 C++ 函数
- en: So far, we have called a C function implemented in the `c_functions.c source`,
    so, in the next section, we will show you how to call a C++ member class.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经调用了一个在 `c_functions.c` 源文件中实现的 C 函数，因此，在下一节中，我们将向您展示如何调用 C++ 成员类。
- en: 'First, we will add the `isPrimeCPlusPlus` native method to `MyNativeActivty`
    that returns `String` as a result. Let''s see how the native function declaration
    will look:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将向 `MyNativeActivty` 添加一个名为 `isPrimeCPlusPlus` 的本地方法，该方法返回 `String` 类型的结果。让我们看看本地函数声明将如何看起来：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Running the `javah` tool against the new `MyNativeActivity` class definition
    will generate a new function declaration with the following signature:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对新的 `MyNativeActivity` 类定义运行 `javah` 工具将生成一个具有以下签名的新的函数声明：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we are going to implement the prime function, as a `class static` function,
    on a C++ source file with the name `mylib.cpp`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在名为 `mylib.cpp` 的 C++ 源文件中实现素数函数，作为一个 `class static` 函数：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If you build your project in Android Studio, the `mylib.cpp` source file will
    be detected and the new function and class will be added to the `libmylib.so`
    shared library file.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在 Android Studio 中构建项目，`mylib.cpp` 源文件将被检测到，并将新的函数和类添加到 `libmylib.so` 共享库文件中。
- en: Once we run the application, the C++ system default library will be loaded with
    a minimal system C++ runtime. The default C++ runtime does not provide the C++
    standard library, exception support, and **RunTime Type Information** (**RTTI**).
    Therefore, if you want to make use of C++ standard library string classes, containers,
    streams, and general algorithms, you will have to explicitly load the C++ runtime
    required before you load your library. For a complete and up to date comparison
    of the C++ runtime available on Android, please check C++ Runtimes on the Android
    Developer website.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行应用程序，C++ 系统默认库将加载一个最小的系统 C++ 运行时。默认的 C++ 运行时不提供 C++ 标准库、异常支持和 **运行时类型信息**（**RTTI**）。因此，如果您想使用
    C++ 标准库的字符串类、容器、流和通用算法，您必须在加载库之前显式加载所需的 C++ 运行时。有关 Android 上可用的 C++ 运行时的完整和最新比较，请访问
    Android 开发者网站上的 C++ Runtimes。
- en: 'If we want to use a different C++ runtime than the system runtime, we must
    explicitly set the runtime in your module''s `build.gradle` file:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用不同于系统运行时的 C++ 运行时，我们必须在模块的 `build.gradle` 文件中显式设置运行时：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Moreover, we must load the non-default C++ runtime library before we load our
    library or any library that depends on it:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在我们加载我们的库或任何依赖于它的库之前，我们必须先加载非默认的 C++ 运行时库：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Since `c++_shared` provides a complete STL library implementation, from now
    on we will use this runtime as the base C++ runtime for our code examples.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `c++_shared` 提供了完整的 STL 库实现，从现在起我们将使用此运行时作为代码示例的基础 C++ 运行时。
- en: Great! So far, we have learned how to interact with native methods using the
    JNI interface, so our next step is to learn how to access Java objects from native
    code.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！到目前为止，我们已经学习了如何使用 JNI 接口与原生方法交互，所以我们的下一步是学习如何从原生代码访问 Java 对象。
- en: Accessing Java objects from native code
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从原生代码访问 Java 对象
- en: When we call a native function, the C or C++ function receives a `JNIEnv` pointer
    to a table of JNI methods used to interact with JVM Runtime. The `JNIEnv` pointer
    provides us with a set of primitives ready to find a Java class definition, set
    or get Java object field values, call static or member Java object functions,
    create Java objects, interact with Java monitors, or deal with exceptions.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用原生函数时，C 或 C++ 函数接收一个指向 JNI 方法表的 `JNIEnv` 指针，这些 JNI 方法用于与 JVM 运行时交互。`JNIEnv`
    指针为我们提供了一组原始数据，可用于查找 Java 类定义、设置或获取 Java 对象字段值、调用静态或成员 Java 对象函数、创建 Java 对象、与
    Java 监视器交互或处理异常。
- en: Our next example will count the number of words on an `EditText` UI Widget on
    a native function and update a `TextView` text with count results from the native
    code. Therefore, we will learn how to use `JNIEnv` to access a member Java object
    field and how to call a Java object method `(TextView.setText`) using the `JNIEnv`
    interface.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个示例将在原生函数中计算 UI 小部件 `EditText` 上的单词数量，并使用原生代码中的计数结果更新 `TextView` 文本。因此，我们将学习如何使用
    `JNIEnv` 访问成员 Java 对象字段，以及如何使用 `JNIEnv` 接口调用 Java 对象方法（`TextView.setText`）。
- en: 'Let''s start by defining our native function and invoke it every time the `EditField`
    content changes:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先定义我们的原生函数，并在 `EditField` 内容更改时调用它：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice that a new function is added to `Activity` so make sure you run `javah`
    to generate the new native function declaration.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，已向 `Activity` 添加了新函数，请确保您运行 `javah` 以生成新的原生函数声明。
- en: 'Next, we will define the JNI native function that counts the number of words
    for a string:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义一个 JNI 原生函数，用于计算字符串中的单词数量：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We left the native implementation because we will implement it on a step-by-step
    basis. As the first step, we will get the `TextView` object instance, used to
    present the number of words on the UI text input, from the `charCountTv` object
    field.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们留下了原生实现，因为我们将会逐步实现它。作为第一步，我们将从 `charCountTv` 对象字段获取用于在 UI 文本输入中显示单词数量的 `TextView`
    对象实例。
- en: 'To access a Java object field or method, a `jmethodID` or `jfieldID` is always
    required:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问 Java 对象字段或方法，始终需要一个 `jmethodID` 或 `jfieldID`：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In order to construct the `methodSignature` or the `fieldTypeCode` (TC), we
    have to map the Java types to type codes using the following table:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建 `methodSignature` 或 `fieldTypeCode`（TC），我们必须使用以下表格将 Java 类型映射到类型代码：
- en: '| Java Type | Type Code (TC) |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| Java 类型 | 类型代码 (TC) |'
- en: '| --- | --- |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `boolean` | `Z` |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `boolean` | `Z` |'
- en: '| `Byte` | `B` |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `Byte` | `B` |'
- en: '| `Char` | `C` |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `Char` | `C` |'
- en: '| `double` | `D` |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `double` | `D` |'
- en: '| `float` | `F` |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `float` | `F` |'
- en: '| `Int` | `I` |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `Int` | `I` |'
- en: '| `Long` | `J` |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `Long` | `J` |'
- en: '| `short` | `S` |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `short` | `S` |'
- en: '| `Object` | `L<package>;` |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `Object` | `L<package>;` |'
- en: '| `Void` | `V` |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `Void` | `V` |'
- en: When we convert an array, always prefix the type code with the `[` character.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在转换数组时，始终在类型代码前加上 `[` 字符。
- en: 'To create a `jfieldID` we need a single type code. However, to construct the
    method signature we use the following format:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个 `jfieldID`，我们需要一个单独的类型代码。然而，要构建方法签名，我们使用以下格式：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s see how we obtain the `charCountTv TextView` object in the native code
    using the instructions explained below:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用以下说明中的指令在原生代码中获取 `charCountTv TextView` 对象：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once we have the `TextView` reference, we can invoke the `setText(CharSequence)`
    instance method to publish the number of words found. To invoke a Java method
    we will make use of the JNI function `CallVoidMethod` with a `jmethodId` created
    from the method signature:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了 `TextView` 引用，我们就可以调用 `setText(CharSequence)` 实例方法来发布找到的单词数量。要调用 Java
    方法，我们将使用 JNI 函数 `CallVoidMethod`，该函数由方法签名创建的 `jmethodId`：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s see how the native code that updates the `TextView charCountTv` with
    the number of words will look:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看更新`TextView charCountTv`以显示单词数的原生代码将如何看起来：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To invoke `static` methods and methods with different kind of result types,
    the JNI interface provides us with a set of functions with the following signatures:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用`static`方法和具有不同结果类型的方法，JNI接口为我们提供了一组具有以下签名的函数：
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now that we have the basic knowledge about how to call native functions with
    the JNI interface, we are ready to start using the JNI to execute asynchronous
    work on native code.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何使用JNI接口调用原生函数的基本知识，我们就可以开始使用JNI在原生代码上执行异步工作了。
- en: Executing native background work on Java threads
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Java线程上执行原生后台工作
- en: In previous sections, we used the JNI interface to execute native functions
    on the main thread. Since they run on the main thread, the functions were able
    to update the UI, access the `Activity` instance fields, and or update any UI
    widget directly.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们使用了JNI接口在主线程上执行原生函数。由于它们在主线程上运行，函数能够更新UI，访问`Activity`实例字段，或者直接更新任何UI小部件。
- en: However, as we discussed before, for long computing or intensive tasks we have
    to execute them on the background thread.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如我们之前讨论的那样，对于长时间计算或密集型任务，我们必须在后台线程上执行它们。
- en: In previous sections, we learned how to use the `AsyncTask, Loader`, `Handler`,
    and Remote Services to execute work on background threads that don't reduce the
    UI responsiveness or interfere with UI rendering.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了如何使用`AsyncTask`、`Loader`、`Handler`和远程服务在后台线程上执行工作，这些线程不会降低UI响应性或干扰UI渲染。
- en: In any of these Android specific constructs, the background thread is already
    attached to the JVM. Hence, the background thread already possesses access to
    a ready to use JNI environment.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些任何Android特定构造中，后台线程已经附加到JVM上。因此，后台线程已经拥有访问一个准备好使用的JNI环境的权限。
- en: In our next example, we will make use of the `Loader` construct and build `AsyncTaskLoader`,
    that loads an image on the background, converts the image to gray scale in native
    code, and publishes the result on the UI screen.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一个示例中，我们将使用`Loader`构造函数并构建`AsyncTaskLoader`，在后台加载图像，在原生代码中将图像转换为灰度，并在UI屏幕上发布结果。
- en: 'First, we will detail how the `Loader` Java class definition will look before
    we start to dig into the native function details:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在我们深入探讨原生函数的细节之前，我们将详细说明`Loader` Java类定义将如何看起来：
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice that our `Loader` will load a `Bitmap` image wrapped in a generic `Result`
    class, as we did in previous sections. When any exception happens on the Java
    or Native code, `Result.error` is filled, making the `Loader` consumer able to
    detect an error and react accordingly.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的`Loader`将加载一个被通用`Result`类包裹的`Bitmap`图像，就像我们在前面的章节中所做的那样。当Java或原生代码发生任何异常时，`Result.error`将被填充，使得`Loader`消费者能够检测到错误并相应地做出反应。
- en: Our loader will receive as an argument the image filename to load from the assets
    and will decode the image to a `Bitmap` object in the `ARGB_8888` format and return
    an image in grayscale
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的加载器将接收一个参数，即从资源加载的图像文件名，并将图像解码为`ARGB_8888`格式的`Bitmap`对象，并返回一个灰度图像
- en: When the native function executes in the background thread without errors, the
    `Result<Bitmap>` object is delivered to the `Loader` consumer in the UI Thread
    to be updated to the device screen.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当原生函数在后台线程上无错误执行时，`Result<Bitmap>`对象将被传递到UI线程上的`Loader`消费者，以便更新到设备屏幕。
- en: 'Executing `javah` against our new `AsynTaskLoader` class should generate the
    `com_packpublishing_asynchronousandroid_chapter9_ToGrayImageLoader.h` header file
    with the following function signature:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们的新`AsynTaskLoader`类执行`javah`应该生成具有以下函数签名的`com_packpublishing_asynchronousandroid_chapter9_ToGrayImageLoader.h`头文件：
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To process `Bitmap` objects on the native layer, the `jnigraphics` shared library
    is required. Therefore, let''s update our `gradle` build configuration to link
    our library with the `jnigraphics` shared library:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要在原生层处理`Bitmap`对象，需要`jnigraphics`共享库。因此，让我们更新我们的`gradle`构建配置，将我们的库与`jnigraphics`共享库链接：
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Linking our library `mylib` against `jnigraphics` will force the dynamic loader
    to load the `jnigraphics` library every time our library is loaded by `System.loadLibrary`.
    Beyond that, the `gradle` system will pack the `jnigraphics` shared library for
    the several ABIs required in the **application package file** (**APK**).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的库`mylib`与`jnigraphics`链接将强制动态加载器在每次通过`System.loadLibrary`加载我们的库时加载`jnigraphics`库。除此之外，`gradle`系统将为**应用程序包文件**（**APK**）中所需的几个ABIs打包`jnigraphics`共享库。
- en: Now that we have the method defined in the header, it is time to implement the
    native function that converts the original `Bitmap` to a grayscale `Bitmap`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在头文件中定义了方法，是时候实现将原始`Bitmap`转换为灰度`Bitmap`的原生函数了。
- en: 'First, let''s create the source file `image.cpp` that includes the `jni` method
    definition and the required `jnigraphics` header file:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建包含`jni`方法定义和所需的`jnigraphics`头文件的源文件`image.cpp`：
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, we will implement the function that converts the original pixels to gray
    pixels:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现将原始像素转换为灰度像素的功能：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: With the help of the `jnigraphics` library, we can read the image information
    using `AndroidBitmap_getInfo` and if everything goes well, the image info will
    be stored on the local variable `info` for further use.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在`jnigraphics`库的帮助下，我们可以使用`AndroidBitmap_getInfo`读取图像信息，如果一切顺利，图像信息将被存储在局部变量`info`中以供进一步使用。
- en: However, if `AndroidBitmap_getInfo` fails we will throw an exception in JVM
    and return immediately from the native function because we call `return`. Under
    a normal situation, if we throw an exception in the JVM with `ThrowNew`, the native
    function does not stop and transfers control to the exception handler. Therefore,
    if an exception is thrown during a native code call, when the function returns,
    the JNI interface will detect it and transfer the execution to the exception handler.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果`AndroidBitmap_getInfo`失败，我们将在JVM中抛出异常并立即从原生函数返回，因为我们调用了`return`。在正常情况下，如果我们使用`ThrowNew`在JVM中抛出异常，原生函数不会停止并将控制权传递给异常处理器。因此，如果在原生代码调用期间抛出异常，当函数返回时，JNI接口将检测到它并将执行权传递给异常处理器。
- en: In our example, we generate a `RuntimeException` with the `jclass` obtained
    from the `Findclass` JNI function.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们使用从`Findclass` JNI函数获得的`jclass`生成`RuntimeException`。
- en: When we finish the bitmap processing, we unlock the pixels through `AndroidBitmap_unlockPixels`
    and we return the `Bitmap` `jobject` to the `loadInBackground` function that originally
    invoked the native method from the background thread.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成位图处理时，我们通过`AndroidBitmap_unlockPixels`解锁像素，并将`Bitmap` `jobject`返回给最初从后台线程调用原生方法的`loadInBackground`函数。
- en: 'As you already know, the processed Bitmap will be delivered by the `AsyncTaskLoader`
    in the UIThread, and it could be used to update an `ImageView` or other kind of
    UI Widget that presents an image on the screen. Let''s see how a `LoaderCallback.onLoadFinished`
    callback might look:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，处理过的位图将由`AsyncTaskLoader`在UI线程中交付，并可用于更新屏幕上显示图像的`ImageView`或其他类型的UI小部件。让我们看看`LoaderCallback.onLoadFinished`回调可能的样子：
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this simple example, we were able to execute asynchronous work in machine
    code with `AsyncTaskLoader` help, although a similar procedure could have been
    done with an `AsyncTask` subclass, a normal thread, or even a `HandlerThread`.
    These kind of Android construct use Java background threads managed by Android
    JVM, therefore, it is not required to explicitly attach these threads to JVM since
    they are part of the JVM system and have their own `JNIEnv`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，我们能够在`AsyncTaskLoader`的帮助下以机器码的形式执行异步工作，尽管类似的程序也可以通过`AsyncTask`子类、普通线程或甚至`HandlerThread`来完成。这类Android构造使用由Android
    JVM管理的Java后台线程，因此，不需要显式地将这些线程附加到JVM，因为它们是JVM系统的一部分，并且有自己的`JNIEnv`。
- en: In the next chapter, we are going to learn how to create pure native threads
    and use them to execute background work for our Android application in a consistent
    and reliable way.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何创建纯原生线程，并使用它们以一致和可靠的方式为我们的Android应用程序执行后台工作。
- en: Executing asynchronous work on a native thread
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在原生线程上执行异步工作
- en: The Android NDK is bundled with the POSIX thread C API that provides an API
    to create and destroy native threads, native mutual exclusion synchronization
    primitives, named mutexes, and condition variables, that like Java monitors, allow
    threads to wait until a change in a resource happens. Apart from this global API,
    the developer also has access to a higher level C++11 thread API available on
    `clang` and `gnu_stl` C++ Runtimes.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Android NDK 包含 POSIX 线程 C API，它提供了一个创建和销毁本地线程、本地互斥同步原语（如命名互斥锁）和条件变量的 API，类似于
    Java 监视器，允许线程等待资源状态的变化。除了这个全局 API 之外，开发者还可以访问在 `clang` 和 `gnu_stl` C++ 运行时上可用的更高层次的
    C++11 线程 API。
- en: Since both of these frameworks offer the same kind of concurrent functionalities
    we will use C++11 thread framework for its simplicity and similarity with the
    Java Thread API.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这两个框架都提供了相同类型的并发功能，我们将使用 C++11 线程框架，因为它简单且与 Java Thread API 相似。
- en: 'First, let''s update our `ndk build.gradle` to use the clang C++ Runtime that
    supports the thread API that we are going to use in our following code examples:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们更新我们的 `ndk build.gradle` 以使用支持我们将在后续代码示例中使用的线程 API 的 clang C++ 运行时：
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Attaching and detaching native threads from JVM
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将本地线程附加到 JVM 和从 JVM 中分离
- en: In order to interact with our JVM and execute background work concurrently for
    us, the native threads should be attached to the current virtual machine and build
    its own `JNIEnv`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与我们的 JVM 交互并为我们执行并发后台工作，本地线程应该附加到当前虚拟机并构建自己的 `JNIEnv`。
- en: The thread `JNIEnv` is tied to a specific native thread and cannot be shared
    with other threads since it manages its own references and local thread environment.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 线程 `JNIEnv` 与特定的本地线程绑定，不能与其他线程共享，因为它管理自己的引用和本地线程环境。
- en: To present this to you in a more practical way, in the next few paragraphs,
    we will build a code example that creates JVM attached native threads that execute
    work in the background and interact with the UI thread, publishing a `keep-alive`
    message using a well known Android handler construct.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更实际地向您展示，在接下来的几段中，我们将构建一个代码示例，该示例创建附加到 JVM 的本地线程，在后台执行工作并与 UI 线程交互，使用众所周知的
    Android 处理器结构发布 `keep-alive` 消息。
- en: 'To attach any thread to the JVM, we need to access the global virtual machine
    structure, `JavaVM`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要将任何线程附加到 JVM，我们需要访问全局虚拟机结构，`JavaVM`：
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'A good way to get the JVM structures to retrieve from `JNI_OnLoad`, a function
    that is automatically called on our library by the JavaVM when our library gets
    loaded. When the callback is called by the JNI interface, we will save the JavaVM
    reference for future use:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一个获取 JVM 结构的好方法是从 `JNI_OnLoad` 函数中检索，这是一个当我们的库被 JavaVM 加载时自动调用的函数。当 JNI 接口回调被调用时，我们将保存
    JavaVM 引用以供将来使用：
- en: '[PRE29]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With the JVM global pointer ready to be used, we are able to attach any native
    thread to the application JVM and start interacting with the `JNIEnv`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 JVM 全局指针准备就绪并可供使用，我们能够将任何本地线程附加到应用程序 JVM 并开始与 `JNIEnv` 交互。
- en: As a starting point, we will create a high level C++ class that automatically
    attaches to the JVM, and detaches from the JVM when the instance has been destroyed.
    This class will be used as the base class in our thread examples, providing a
    common abstract interface for native thread creation.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 作为起点，我们将创建一个高级 C++ 类，该类会自动附加到 JVM，并在实例被销毁时从 JVM 中分离。这个类将作为我们线程示例的基类，提供一个用于原生线程创建的通用抽象接口。
- en: 'Let''s see how the `JavaThread` class definition will look:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `JavaThread` 类定义将如何看起来：
- en: '[PRE30]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this class header, we subclass the `JavaThread` from the original C++ thread
    class defined and we define the abstract method `run`. Any worker thread can subclass
    `JavaThread`, providing its own implementation of the `run` method. Additionally,
    the protected thread specific to the JNI interface environment is stored in `threadEnv`
    for future use by the thread subclasses.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类头文件中，我们从原始的 C++ 线程类中继承 `JavaThread` 并定义抽象方法 `run`。任何工作线程都可以继承 `JavaThread`，提供自己的
    `run` 方法实现。此外，特定于 JNI 接口环境的受保护线程存储在 `threadEnv` 中，供线程子类将来使用。
- en: 'Beyond that, we will introduce you to the C++ synchronization primitives, available
    from the thread header. `std:mutex` is a mutual exclusive primitive that only
    allows one thread at a time to enter a protected critical scope. If a thread is
    executing the critical code, another thread that tries to enter the critical section
    will block the execution until the thread executing the critical section releases
    the lock. Here is a simple example:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将向您介绍从线程头文件中可用的C++同步原语。`std:mutex`是一个互斥原语，它一次只允许一个线程进入受保护的临界区。如果一个线程正在执行临界代码，另一个尝试进入临界区的线程将阻塞执行，直到执行临界代码的线程释放锁。以下是一个简单的示例：
- en: '[PRE31]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The same behavior would have been achieved in Java by using the synchronized
    word in a Java block or a synchronized block.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，可以通过在Java块或同步块中使用`synchronized`关键字实现相同的行为。
- en: The condition concurrent primitive, like a Java monitor, can be used to block
    a thread or a group of threads execution until another thread modifies a shared
    information and sends a signal to notify the waiting threads.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于Java监视器的条件并发原语，可以用来阻塞一个线程或一组线程的执行，直到另一个线程修改共享信息并发送信号通知等待的线程。
- en: Now that we know what these C++ concurrency primitives are used for, let's implement
    the `JavaThread` that automatically attaches and detaches itself to and from JVM.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了这些C++并发原语用于什么，让我们实现自动附加和从JVM中分离的`JavaThread`。
- en: 'First of all, we will start the background native thread in the native `start()`
    by passing the `entryPoint` functions as the runtime function for the thread:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将通过传递`entryPoint`函数作为线程的运行时函数，在原生的`start()`方法中启动背景原生线程：
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As soon as `std::thread` creates the thread in the system it will call the `entrypoint`
    function in our object to initialize the JNI environment.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当`std::thread`在系统中创建线程时，它将调用我们的对象中的`entrypoint`函数来初始化JNI环境。
- en: In the meantime, we will block the calling thread until the new thread attaches
    to JVM and sends a signal to the `startCond` condition variable. Next, when `std::thread`
    initializes the new thread in the operating system, it changes the execution control
    to the member function specified in the constructor, `JavaThread::entryPoint`.
    In this function, we will attach the native thread to the JVM, dispatching the
    execution to the subclass `run()` method.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们将阻塞调用线程，直到新线程附加到JVM并发送信号到`startCond`条件变量。接下来，当`std::thread`在操作系统中初始化新线程时，它将执行控制权更改为构造函数中指定的成员函数，即`JavaThread::entryPoint`。在这个函数中，我们将原生线程附加到JVM，并将执行调度到子类`run()`方法。
- en: 'Let''s see how we might implement the `entryPoint` function:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何实现`entryPoint`函数：
- en: '[PRE33]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Notice that the thread is detached from the JVM even when a runtime exception
    is thrown during the `run` execution. When the thread is detached from the JVM,
    all the thread monitors are released and all the Java threads waiting for this
    thread are notified.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，即使在`run`执行期间抛出运行时异常，线程也会从JVM中分离出来。当线程从JVM中分离出来时，所有线程监视器都会释放，并且所有等待此线程的Java线程都会收到通知。
- en: For the stopping mechanism, we will make use of a `boolean` variable and `condition`
    variable to notify that the `shouldStop` condition has changed. Later on, our
    `JavaThread` subclass will take advantage of this mechanism to stop the `run()`
    execution.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 对于停止机制，我们将使用一个`boolean`变量和一个`condition`变量来通知`shouldStop`条件已更改。稍后，我们的`JavaThread`子类将利用此机制来停止`run()`执行。
- en: 'Let''s see how the `stop` method will look:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`stop`方法将如何看起来：
- en: '[PRE34]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: With the native thread base class completely defined, we are now ready to create
    our derived class that implements the required behavior in the `run` method.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在完全定义了原生线程基类之后，我们现在可以创建我们的派生类，该类在`run`方法中实现所需的行为。
- en: As defined before, we will use a `Handler` construct to submit messages from
    the background threads to the UI thread. Since they run on the same process and
    share the same memory, we can safely pass a reference to a `Handler` object to
    the native background threads.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将使用`Handler`构造来提交从后台线程到UI线程的消息。由于它们在同一个进程中运行并共享相同的内存，我们可以安全地将`Handler`对象的引用传递给原生后台线程。
- en: 'First, before we start to implement our `JavaThread` sub-class, we will write
    the `NativeThreadsActivity` and implement a `Handler` anonymous subclass to receive
    messages from the native threads:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在我们开始实现我们的`JavaThread`子类之前，我们将编写`NativeThreadsActivity`并实现一个`Handler`匿名子类来接收原生线程的消息：
- en: '[PRE35]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This class will also be responsible for starting and stopping the native threads
    each time we click on the **start** and **stop** button.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 此类还将负责在每次点击**启动**和**停止**按钮时启动和停止本地线程。
- en: The start and stop button setup is omitted in the code example. However, the
    **start** button will invoke the native function of `startNativeThreads`, passing
    `myHandler` as the `Handler` argument and the stop button will invoke `stopNativeThreads`
    to stop the native thread execution. Additionally, we can also call `stopNativeThreads`
    on `Activiy.onStop` to stop the threads when the activity gets destroyed.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 代码示例中省略了启动和停止按钮的设置。然而，**启动**按钮将调用 `startNativeThreads` 的本地函数，并将 `myHandler`
    作为 `Handler` 参数传递，而**停止**按钮将调用 `stopNativeThreads` 来停止本地线程的执行。此外，我们还可以在 `Activity.onStop`
    中调用 `stopNativeThreads` 来在活动被销毁时停止线程。
- en: 'Now we need to implement the `JavaThread` that will run in the background and
    submit a `healthcheck` message to the UI thread over the `handler` object. Since
    the handler is coming from a different `jniEnv`, the first thing to do is to create
    a JNI global reference from the original handler. Let''s start by implementing
    the constructor that creates a global `Handler` object reference and store the
    reference in a `member` variable:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要实现一个将在后台运行的 `JavaThread`，并通过 `handler` 对象向 UI 线程提交一个 `healthcheck` 消息。由于
    `handler` 来自不同的 `jniEnv`，首先需要从原始 `handler` 创建一个 JNI 全局引用。让我们先从实现构造函数开始，该构造函数创建一个全局的
    `Handler` 对象引用并将引用存储在一个 `member` 变量中：
- en: '[PRE36]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the constructor, we received the object reference from the main thread, we
    called our `JavaThread` default constructor, and we created a global reference
    to store the original reference.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们从主线程接收了对象引用，调用了我们的 `JavaThread` 默认构造函数，并创建了一个全局引用来存储原始引用。
- en: JNI references explained
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JNI 引用解释
- en: It's really important to understand in detail how JNI references are managed
    by JVM, because if we don't use them properly, we can crash the application or
    introduce a memory leak in the application. A memory leak will affect the application
    performance, increase battery consumption, and in the long term crash the application
    with a `java.lang.OutOfMemoryError` exception. As you know, JVM Garbage Collector
    (GC) manages the application memory use, cleaning up objects when they are not
    in use. An object is considered eligible for garbage collection when no references
    to that object exist in the memory, so, when the GC finds a none referred object
    it will release the object from the memory.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 JNI 引用如何被 JVM 管理非常重要，因为如果我们不正确使用它们，我们可能会使应用程序崩溃或引入内存泄漏。内存泄漏会影响应用程序性能，增加电池消耗，并在长期内导致应用程序因
    `java.lang.OutOfMemoryError` 异常而崩溃。如您所知，JVM 垃圾收集器 (GC) 管理应用程序内存使用，在对象不再使用时清理对象。当一个对象在内存中没有引用时，该对象被认为是垃圾收集的候选对象，因此，当
    GC 发现一个未引用的对象时，它将释放该对象从内存中。
- en: 'JNI supports three types of reference:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: JNI 支持三种类型的引用：
- en: '**Local Reference** – References attached to a thread, `JNIEnv`, which is lifetime
    valid for the duration of a native method. The reference is passed to the native
    method and destroyed as soon as the method returns. The user can also create and
    delete local references in the native method to prevent any object from being
    garbage collected. Keep in mind that a local reference is valid in the `JNIEnv`
    where it was created. The following JNI functions are available to manage local
    references:'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**局部引用** – 附属于线程、`JNIEnv` 的引用，其生命周期有效于本地方法的持续时间。该引用传递给本地方法，并在方法返回时销毁。用户也可以在本地方法中创建和删除局部引用，以防止任何对象被垃圾回收。请注意，局部引用在其创建的
    `JNIEnv` 中有效。以下 JNI 函数可用于管理局部引用：'
- en: '[PRE37]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'JVM provides a function to allocate space in the current JNI frame to store
    local references. By default, it has the capacity for 16 references:'
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: JVM 提供了一个函数来在当前 JNI 帧中分配空间以存储局部引用。默认情况下，它具有 16 个引用的容量：
- en: '[PRE38]'
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '**Global Reference** – References used to keep global objects alive for an
    unlimited period of time. These kinds of reference can be shared between thread
    `JNIEnv` objects. It is critical to explicitly delete the reference from JVM when
    they are no longer required. When you don''t free the reference from the system
    you are creating a memory leak in your application. Notice that when you free
    the reference from the system, the reference is no longer valid, so if you try
    to use it an exception will be thrown in the JNI interface. The following JNI
    functions are used to manage local references:'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局引用** – 用于保持全局对象无限期存活期的引用。这类引用可以在线程`JNIEnv`对象之间共享。在不再需要时，显式地从JVM删除引用是至关重要的。当你不释放系统中的引用时，你正在应用程序中创建内存泄漏。请注意，当你从系统中释放引用时，该引用就不再有效，因此如果你尝试使用它，JNI接口将抛出异常。以下JNI函数用于管理局部引用：'
- en: '[PRE39]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '**Weak Global Reference** – Like the global reference, but it doesn''t prevent
    the object from being garbage collected when it is the only alive reference to
    the object. Weak global references in JNI are a streamlined version of Java Weak
    References:'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弱全局引用** – 与全局引用类似，但它不会阻止对象在它是对象唯一活动引用时被垃圾回收。JNI中的弱全局引用是Java弱引用的简化版本：'
- en: '[PRE40]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Interacting with UI from native threads
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从本地线程与UI交互
- en: Since we want to cache a reference to a `Handler` object that survives the `startNativeThreads`
    execution, it makes sense to create a global reference before we save it in a
    member variable. The reference will be later used in our background thread to
    submit messages to the UI.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望缓存一个`Handler`对象的引用，该对象在`startNativeThreads`执行期间仍然存活，因此在将其保存到成员变量之前创建一个全局引用是有意义的。该引用将在我们的后台线程中用于向UI提交消息。
- en: 'Given that we created a global reference in our `HealthCheckThread` class,
    to release the reference in JVM and avoid any memory loss, we will delete the
    global reference in the `HealthCheckThread.onDetach()` function called during
    thread stopping:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在`HealthCheckThread`类中创建了一个全局引用，为了在JVM中释放引用并避免任何内存损失，我们将在线程停止期间调用的`HealthCheckThread.onDetach()`函数中删除全局引用：
- en: '[PRE41]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, we will update the `HealthCheckThread` and implement the `run` method
    that is going to submit health check messages to the `Handler` object attached
    to the UI thread:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更新`HealthCheckThread`并实现一个`run`方法，该方法将提交健康检查消息到UI线程关联的`Handler`对象：
- en: '[PRE42]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `run` function will continuously execute until `shouldStop` is `true`. Furthermore,
    between each cycle, the thread will send a message and block for one second unless
    a stop signal is sent to notify the thread to stop. In this case, the native condition
    variable is used to wake up the thread from the one second sleep when the stop
    condition is set.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`run`函数将持续执行，直到`shouldStop`为`true`。此外，在每次循环之间，线程将发送一条消息并阻塞一秒钟，除非发送停止信号通知线程停止。在这种情况下，使用本地条件变量唤醒线程从一秒钟的睡眠中醒来，当设置停止条件时。'
- en: 'All that remains regarding the `HealthCheckThread` class is to implement the
    `sendHealthMessage`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`HealthCheckThread`类剩下的工作就是实现`sendHealthMessage`：
- en: '[PRE43]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Before we start to use the handler object, we retrieve a `Message` from the
    `Handler` global message poll using the `obtainMessage` instance method. To build
    the string message passed in the `Message` object, we format a message using `ostringstream`,
    a thread ID, and the current `datetime`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用处理器对象之前，我们使用`obtainMessage`实例方法从`Handler`全局消息队列中检索一个`Message`。为了构建传递给`Message`对象的字符串消息，我们使用`ostringstream`、线程ID和当前`datetime`格式化消息。
- en: Then, we push the built `Message` to the handler object to be delivered in our
    `Activity`. To finish, we delete the created local reference from the local `JNIEnv`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将构建的`Message`推送到处理器对象，以便在我们的`Activity`中传递。最后，我们从本地`JNIEnv`删除创建的局部引用。
- en: Starting the native threads
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动本地线程
- en: 'Just to finish our example, we will write the native methods `startNativeThreads`
    and `stopNativeThreads`. These methods will create and destroy the native threads
    each time we tap on the start or stop button. The UI code is omitted for brevity.
    Let''s look at the `startNativeThreads` first:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的示例，我们将编写`startNativeThreads`和`stopNativeThreads`本地方法。每次我们点击开始或停止按钮时，这些方法将创建和销毁本地线程。为了简洁起见，省略了UI代码。让我们首先看看`startNativeThreads`：
- en: '[PRE44]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In `startNativeThreads`, we create `num_thread` threads passing the main thread
    `JNIEnv` and the handler reference to the `HealthCheckThread` constructor. The
    `HealthCheckThread` pointer returned from the constructor is cached in a static
    array for future use.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `startNativeThreads` 中，我们创建了 `num_thread` 个线程，并将主线程的 `JNIEnv` 和处理程序引用传递给 `HealthCheckThread`
    构造函数。从构造函数返回的 `HealthCheckThread` 指针被缓存在一个静态数组中，以供将来使用。
- en: Stopping the native threads
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 停止本地线程
- en: 'Given that we allocate the `HealthCheckThread` object in the dynamic memory
    using the C++ operator `new`, in the `stopNativeThreads`, apart from stopping
    the thread execution, it is required to release the dynamic memory to avoid any
    memory leaks in the native code. So, all that remains is to implement the `stopNativeThreads`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用 C++ 操作符 `new` 在动态内存中分配 `HealthCheckThread` 对象，在 `stopNativeThreads` 中，除了停止线程执行外，还需要释放动态内存，以避免在本地代码中出现内存泄漏。因此，剩下的就是实现
    `stopNativeThreads`：
- en: '[PRE45]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `stopNativeThreads` function will stop the created threads using the `JavaThread::stop`
    member function. As detailed before, the stop member function will use a condition
    primitive to notify the running loop that it should finish its execution. After
    we notify the background thread, we wait for it to finish and we destroy the object
    stored in the array pointer.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`stopNativeThreads` 函数将使用 `JavaThread::stop` 成员函数停止创建的线程。如前所述，`stop` 成员函数将使用条件原语来通知运行循环它应该完成执行。在我们通知后台线程后，我们等待它完成，并销毁存储在数组指针中的对象。'
- en: Great! In this section, we were able to start native threads, attach them to
    JVM, and interact with the main thread using a Handler object. On the way, we
    learned about the C++ `condition` and `mutex` concurrent primitives to synchronize
    the access to shared resources in the native code. Although we have been using
    the C++11 concurrent primitives to create and synchronize threads, we could have
    written our examples using the concurrent primitives provided by the POSIX `pthread`
    library.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！在本节中，我们能够启动本地线程，将它们附加到 JVM，并使用 Handler 对象与主线程交互。在这个过程中，我们学习了 C++ 的 `condition`
    和 `mutex` 并发原语，以同步对共享资源的访问。尽管我们一直在使用 C++11 并发原语来创建和同步线程，但我们也可以使用 POSIX `pthread`
    库提供的并发原语来编写我们的示例。
- en: The POSIX library `libpthread` also provides methods to manage native threads,
    mutual exclusion concurrency primitives (mutexes), and condition variables.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX 库 `libpthread` 也提供了管理本地线程、互斥并发原语（互斥锁）和条件变量的方法。
- en: Handling Java exceptions in the native layer
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在本地层处理 Java 异常
- en: While in Java, when an exception is thrown during a method execution, the JVM
    stops the normal method execution and tries to find an exception handler in the
    runtime to take control of execution, the same does not apply when you execute
    the Java method from the JNI code.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 Java 中，如果在方法执行期间抛出异常，JVM 会停止正常的方法执行，并尝试在运行时找到一个异常处理程序来控制执行，但当你从 JNI 代码执行
    Java 方法时，情况并不相同。
- en: The JNI requires developers to explicitly implement the exception handling after
    an exception has occurred in a Java method invocation.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: JNI 要求开发者在 Java 方法调用发生异常后显式实现异常处理。
- en: 'Moreover, when exception handling is pending, only a few JNI functions are
    safe to be invoked: `DeleteGlobalRef`, `DeleteLocalRef`, `DeleteWeakGlobalRef`,
    `ExceptionCheck`, `ExceptionClear`, `ExceptionDescribe`, `ExceptionOccurred`,
    `MonitorExit`, `PopLocalFrame`, `PushLocalFrame`, `Release<PrimitiveType>ArrayElements`,
    `ReleasePrimitiveArrayCritical`, `ReleaseStringChars`, `ReleaseStringCritical`,
    and `ReleaseStringUTFChars`.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当异常处理挂起时，只有少数 JNI 函数是安全的可以调用：`DeleteGlobalRef`、`DeleteLocalRef`、`DeleteWeakGlobalRef`、`ExceptionCheck`、`ExceptionClear`、`ExceptionDescribe`、`ExceptionOccurred`、`MonitorExit`、`PopLocalFrame`、`PushLocalFrame`、`Release<PrimitiveType>ArrayElements`、`ReleasePrimitiveArrayCritical`、`ReleaseStringChars`、`ReleaseStringCritical`
    和 `ReleaseStringUTFChars`。
- en: There are three ways to handle Java exceptions in a native function.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地函数中处理 Java 异常有三种方法。
- en: The first way is to clear the pending exception with `ExceptionClear` and continue
    to execute the native code. This approach is seldom safe and you need to review
    all error flows to verify that you are handling the exception properly.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是使用 `ExceptionClear` 清除挂起的异常，并继续执行本地代码。这种方法很少是安全的，你需要审查所有错误流程，以验证你是否正确处理了异常。
- en: The second way is once the pending exception is detected, release the JNI allocated
    resources, stop the native code execution, and return the control to the Java
    code. In this case, the JNI will try to find a Java exception handler in the Java
    frame that invoked the native method.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方式是，一旦检测到挂起的异常，释放 JNI 分配的资源，停止本地代码执行，并将控制权返回给 Java 代码。在这种情况下，JNI 将尝试在调用本地方法的
    Java 帧中找到一个 Java 异常处理器。
- en: The third way is to release the pending exception, generate a new exception
    with a different class type, and return from the native method with the new exception
    pending to be handled in Java code.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种方式是释放挂起的异常，生成一个新的具有不同类类型的异常，并使用新的异常从本地方法返回，该异常将在 Java 代码中待处理。
- en: In our next example, we will follow the third because we will use most of the
    functions available in the JNI to handle exceptions. First, we will show you how
    to use the JNI exception in handling functions to clear a pending Java exception.
    Beyond that, we will stop the native method execution, release all the native
    resources, and throw a different exception to be handled in Java by the `RuntimeException`
    handler.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一个示例中，我们将遵循第三种方法，因为我们将使用 JNI 中大多数可用的函数来处理异常。首先，我们将向您展示如何使用 JNI 异常处理函数清除挂起的
    Java 异常。除此之外，我们将停止本地方法执行，释放所有本地资源，并抛出一个不同的异常，以便在 Java 中由 `RuntimeException` 处理器处理。
- en: 'First, we will write an `Activity` that invoking the native method will spawn
    a pending exception in JVM:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将编写一个 `Activity`，调用本地方法将在 JVM 中产生一个挂起的异常：
- en: '[PRE46]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Each time the `genException` button is clicked, call a native method that fails
    with a runtime exception (`java.lang.IndexOutOfBoundsException`).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 每次点击 `genException` 按钮时，调用一个会抛出运行时异常（`java.lang.IndexOutOfBoundsException`）的本地方法。
- en: 'The `onClick (View v)` method is only able to handle `java.lang.RuntimeException`,
    so we must handle `IndexOutOfBoundsException` in the native function and convert
    it to `RuntimeException`:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`onClick (View v)` 方法只能处理 `java.lang.RuntimeException`，因此我们必须在本地函数中处理 `IndexOutOfBoundsException`
    并将其转换为 `RuntimeException`：'
- en: '[PRE47]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'There are two functions used to detect an exception in a JNI native function:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个函数用于检测 JNI 本地函数中的异常：
- en: The `ExceptionOccurred` function returns a `jthrowable` object reference if
    there is a pending exception that is not handled so far, or null when `no exception`
    is ready.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExceptionOccurred` 函数如果存在尚未处理的挂起异常，则返回一个 `jthrowable` 对象引用，如果没有异常准备就绪，则返回
    null。'
- en: The `ExceptionCheck` function returns `jboolean` when there is an outstanding
    unhandled exception in JVM, the function will return `JNI_TRUE` as the result.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当 JVM 中存在未处理的未处理异常时，`ExceptionCheck` 函数返回 `jboolean`，该函数将返回 `JNI_TRUE` 作为结果。
- en: Assuming that we don't want to use `jthrowable` returned by `ExceptionOccurred`,
    we will use `ExceptionCheck` to detect the exception and enter the exception handling
    code branch.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们不想使用 `ExceptionOccurred` 返回的 `jthrowable`，我们将使用 `ExceptionCheck` 来检测异常并进入异常处理代码分支。
- en: Thereafter, with the `ExceptionDescribe` function we will print the current
    pending `throwable` stack trace in the error output, and with `ExceptionClear`,
    we will clear the pending `IndexOutOfBoundsException` from JVM.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用 `ExceptionDescribe` 函数，我们将打印当前挂起的 `throwable` 栈跟踪到错误输出，而使用 `ExceptionClear`，我们将从
    JVM 中清除挂起的 `IndexOutOfBoundsException`。
- en: Given that we are only able to handle `RuntimeException` in the `Activity` function,
    we will attach a `RuntimeException` to JVM to be handled as soon as the native
    code returns.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只能在 `Activity` 函数中处理 `RuntimeException`，我们将向 JVM 附带一个 `RuntimeException`，以便在本地代码返回时立即处理。
- en: To conclude, and since we are going to stop the native function execution, we
    must release any resource or JNI references allocated before we return from the
    native function.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，由于我们打算停止本地函数执行，我们必须在从本地函数返回之前释放任何资源或 JNI 引用。
- en: Yes, with the help of these JNI exceptions, you should be able to detect and
    handle any settled unhandled exception that results from a Java method invocation.
    As stated before, it is extremely important to manually handle any pending exception
    before you try to safely invoke other JNI methods that invoke `member` or `static`
    functions, `get` or `set` fields on objects, or even create new objects.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，借助这些 JNI 异常，您应该能够检测和处理由 Java 方法调用引起的任何已解决的未处理异常。如前所述，在尝试安全调用其他 JNI 方法之前，手动处理任何挂起的异常至关重要，这些方法调用
    `member` 或 `static` 函数，`get` 或 `set` 对象上的字段，甚至创建新对象。
- en: Interacting with a Java monitor from native code
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从本地代码与 Java 监视器交互
- en: 'So far, we have been synchronizing access to shared resources in Java threads
    using synchronized statements or synchronized methods:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在Java线程中使用`synchronized`语句或`synchronized`方法同步对共享资源的访问：
- en: '[PRE48]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'When we are executing a native method and want to have access to a resource
    or variable shared between multiple Java code and native code, the JNI offers
    us `MonitorEnter` and `MonitorExit` methods to control access to the mutual exclusion
    zone managed by a Java `synchronized` block:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行本地方法并希望访问多个Java代码和本地代码之间共享的资源或变量时，JNI为我们提供了`MonitorEnter`和`MonitorExit`方法来控制对由Java
    `synchronized`块管理的互斥区的访问：
- en: '[PRE49]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '`MonitorEnter`, the function responsible for acquiring access to the Java monitor
    scope, might block when another native thread or Java thread is the owner of the
    monitor. When any thread acquires access to the block, JVM will make sure that
    no other thread enters the critical section apart from the current thread.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`MonitorEnter`是负责获取Java监视器范围的访问的函数，当另一个本地线程或Java线程是监视器的所有者时可能会阻塞。当任何线程获得对块的访问时，JVM将确保除了当前线程外，没有其他线程进入临界区。'
- en: '`MonitorExit` is the function responsible for releasing the monitor acquired
    previously with `MonitorEnter`, giving the chance to another thread to enter the
    mutual exclusion section.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`MonitorExit`是负责释放之前使用`MonitorEnter`获得的监视器的函数，给其他线程进入互斥区的机会。'
- en: Note
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To prevent a deadlock condition, any `MonitorEnter` call must be followed by
    a `MonitorExit` call.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止死锁条件，任何`MonitorEnter`调用都必须跟随一个`MonitorExit`调用。
- en: In our next code example, we will demonstrate this technique to synchronize
    the access to a shared object used by the Java code and the native code.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一个代码示例中，我们将演示这种技术来同步Java代码和本地代码使用的共享对象的访问。
- en: We are going to create a native thread that is constantly polling command requests
    from a shared queue list managed in our `Activity`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个本地线程，该线程将不断从我们在`Activity`中管理的共享队列列表中轮询命令请求。
- en: '`StatsActivity` will have a button to push commands to the shared queue list
    and will display the request responses sent by the native thread in a `TextView`.
    Whereas the UI will push commands to the request queue list in a main thread,
    and the native code will try to pull commands from the native code in a background
    thread, both need synchronized access to the shared queue list.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`StatsActivity`将有一个按钮用于将命令推送到共享队列列表，并将由本地线程发送的请求响应显示在`TextView`中。而UI将在主线程中将命令推送到请求队列列表，本地代码将尝试在后台线程中从本地代码中拉取命令，两者都需要对共享队列列表进行同步访问。'
- en: Our command will ask the native layer to send information about the amount of
    main memory that a program uses to run. As soon as it receives the response, it
    will print in the UI `TextView`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的命令将要求本地层发送有关程序运行所需主内存数量的信息。一旦收到响应，它将在UI的`TextView`中打印出来。
- en: 'To start, let''s define the code to push new commands from the UI point of
    view:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从UI的角度定义推送新命令的代码：
- en: '[PRE50]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Notice that, before `onRSSReqListener` pushes the new request command to the
    queue list, it acquires access to the synchronized section controlled by the `queueLock`
    object.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在`onRSSReqListener`将新请求命令推送到队列列表之前，它获取了对由`queueLock`对象控制的同步部分的访问。
- en: Given that the `queueLock` object is going to act as the guard object to access
    the shared resource we have to forward it to the native code.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`queueLock`对象将作为访问共享资源的保护对象，我们必须将其传递给本地代码。
- en: Since we have already written the command request consumer, now we will move
    our focus to the command request consumer, the native C++ `JavaThread` subclass
    named `CPUStatThread`, that will process the requests and send back the command
    response.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已编写了命令请求消费者，现在我们将关注命令请求消费者，名为`CPUStatThread`的本地C++ `JavaThread`子类，它将处理请求并发送命令响应。
- en: 'As explained before, `CPUStatThread` will implement the `run` method and send
    us the response using `Activity''s` `Handler`, so let''s first implement the run
    method to retrieve requests from `Activity` in the new source code file `stats.cpp`:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`CPUStatThread`将实现`run`方法，并通过`Activity`的`Handler`发送响应，因此我们首先在新的源代码文件`stats.cpp`中实现`run`方法以从`Activity`检索请求：
- en: '[PRE51]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Our run method will retrieve the `queueLock` field from `StatsActivity` and
    after acquiring access to the synchronized block controlled by the `queueLock`,
    itwill pull a new request from the queue using the `StatsActivity`''s `getNextRequest`
    method:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的运行方法将从`StatsActivity`中检索`queueLock`字段，并在获取到由`queueLock`控制的同步块访问权限后，使用`StatsActivity`的`getNextRequest`方法从队列中拉取一个新的请求：
- en: '[PRE52]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '`getNextRequest` will return -1 when nothing is available to be processed,
    therefore our thread will sleep for 100 milliseconds, as defined in our run method.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`getNextRequest`将在没有可处理的内容时返回-1，因此我们的线程将根据我们在运行方法中定义的，休眠100毫秒。'
- en: When an `RSS_REQUEST` is received, our native background will process it in
    the `sendRSSMessage` method and send a response back with the memory consumed
    by the process in the system.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 当接收到`RSS_REQUEST`时，我们的原生后台将在`sendRSSMessage`方法中处理它，并通过系统进程消耗的内存发送一个响应。
- en: Wrapping native data objects
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包装原生数据对象
- en: So far, to send any kind of structured data from native code to Java code, we
    have been building and dispatching regular Java objects. However, to reduce the
    overhead required to convert from native types to Java types, and vice-versa,
    it could make sense to send native wrapped structures or object pointers to Java
    Runtime instead of creating a pure Java object in the native code.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，为了从原生代码向Java代码发送任何类型的结构化数据，我们一直在构建和分发常规Java对象。然而，为了减少从原生类型转换为Java类型以及相反所需的开销，发送原生包装结构或对象指针到Java运行时可能是有意义的，而不是在原生代码中创建纯Java对象。
- en: 'The most reliable technique is to store the native address into a long member
    variable of the wrapper object to be compatible with 64 bit and 32 bit pointers:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 最可靠的技术是将原生地址存储在包装对象的64位和32位指针兼容的长成员变量中：
- en: '[PRE53]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As you know, JVM Garbage Collector will constantly maintain the heap memory
    and clean the unreferenced objects for us to free more memory for next allocations
    required by your application. The same does not apply to native objects allocated
    in the dynamic memory using a `new` operator or the `malloc` function.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，JVM垃圾回收器会持续维护堆内存并清理未引用的对象，以便为应用程序下一次所需的分配释放更多内存。然而，这并不适用于使用`new`运算符或`malloc`函数在动态内存中分配的原生对象。
- en: 'When we create an object in native heap, we always have to explicitly release
    it using the `delete` operator or `free` function, so to enforce the memory clean
    up on all the objects that wrap native objects we will define an interface that
    defines the required function to release underlying native objects:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在原生堆中创建一个对象时，我们总是必须显式地使用`delete`运算符或`free`函数来释放它，因此为了强制所有包装原生对象的内存清理，我们将定义一个接口，该接口定义了释放底层原生对象所需的功能：
- en: '[PRE54]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Note
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although we can use the `finalize` method to release any native resources when
    the object gets garbage collected, there is no guarantee that the GC will call
    `finalize` at any specific time in the future.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以在对象被垃圾回收时使用`finalize`方法来释放任何原生资源，但无法保证垃圾回收器会在未来的任何特定时间调用`finalize`方法。
- en: To demonstrate this technique in our example, we will send back using the `Handler`,
    a native `CPUStat` `struct` wrapped in a Java object.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的示例中演示这种技术，我们将使用`Handler`发送回一个包裹在Java对象中的原生`CPUStat``struct`。
- en: 'Let''s first define the native `CPUStat` sent when to carry the information
    related to the process memory consumption:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义在发送时携带与进程内存消耗相关的信息的原生`CPUStat`：
- en: '[PRE55]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Notice that our `JCPUStat` implements the disposable object explained before,
    so all that remains is to write the native methods for the JCPUStat class:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的`JCPUStat`实现了之前解释的可丢弃对象，因此剩下的只是编写JCPUStat类的原生方法：
- en: '[PRE56]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: To simplify the native reference handling, we created two generic functions
    to manipulate a `nativePtr` field in wrapper objects. The first function, `getNativePtr`,
    will get the pointer field from the object and with help from `reinterpret_cast`
    we will convert the original long value stored in a `CPUStat` pointer.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化原生引用的处理，我们创建了两个通用函数来操作包装对象中的`nativePtr`字段。第一个函数`getNativePtr`将从对象中获取指针字段，并借助`reinterpret_cast`将存储在`CPUStat`指针中的原始长值转换。
- en: After we get access to the original pointer, we can call the `delete` operator
    that will free the memory in the system and set the nativePtr as 0\. Setting the
    pointer to zero will prevent a double free from happening when you call the `dispose`
    method twice by mistake.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们获取到原始指针后，我们可以调用`delete`运算符来释放系统中的内存，并将nativePtr设置为0。将指针设置为0可以防止在错误地调用`dispose`方法两次时发生双重释放。
- en: 'Next, with the wrapper class defined, we will process the original request
    and build a `JCPUStat` response object to send back to `Activity` using the activity
    `Handler`:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在定义了包装类之后，我们将处理原始请求，并构建一个`JCPUStat`响应对象，使用活动的`Handler`将其发送回`Activity`：
- en: '[PRE57]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Our `sendRSSMessage` function will calculate the memory consumed by the process
    using system facilities, and build a `JCPUStat` object that wraps a native C++
    structure. Afterwards, `JCPUStat` is dispatched to the main thread using the activity
    handler member object passed in the `sendRSSMessage` function. To finish, we cleaned
    up all the local references created in the local scope.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`sendRSSMessage`函数将使用系统功能计算进程消耗的内存，并构建一个包装本地C++结构的`JCPUStat`对象。之后，使用`sendRSSMessage`函数传入的活动处理程序成员对象将`JCPUStat`调度到主线程。最后，我们清理了在局部作用域中创建的所有局部引用。
- en: The full source code is available from the Packt Publishing website. Take a
    look at the complete source code to appreciate how we determined the memory consumed
    by the current process.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码可在Packt Publishing网站上找到。查看完整的源代码，以了解我们是如何确定当前进程消耗的内存的。
- en: 'To complete the example, we will update `StatsActivity` to handle the RSS command
    response on the `Handler`:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成示例，我们将更新`StatsActivity`以在`Handler`上处理RSS命令响应：
- en: '[PRE58]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Once we get `JCPUStat` from the `Message` object, we read the RSS memory using
    its native method `getRSSMemory` and then we print the result on the console UI
    widget.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们从`Message`对象中获取到`JCPUStat`，我们就使用其本地方法`getRSSMemory`读取RSS内存，然后在控制台UI小部件上打印结果。
- en: As we explained before the `JCPUStat.dispose` method is explicitly called on
    the Java Runtime to destroy the native object sent to us by the background thread.
    The JVM GC will not clean up the native objects, therefore we must call `dispose`
    to release native resources attached to a `Disposable` object.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前解释的，`JCPUStat.dispose`方法在Java运行时被显式调用，以销毁由后台线程发送给我们的本地对象。JVM GC不会清理本地对象，因此我们必须调用`dispose`以释放附加到`Disposable`对象的本地资源。
- en: '`getRSSMemory` like the `dispose` method will make use of the `nativePtr` field
    to retrieve the RSS value stored on the native object. Let''s see how it looks:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`getRSSMemory`方法类似于`dispose`方法，将利用`nativePtr`字段从本地对象检索存储的RSS值。让我们看看它的样子：'
- en: '[PRE59]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: For brevity, `startCPUStatThread` and `stopCPUStatThread` is omitted, as it
    is very similar to code used to start the native threads on previous example—see
    the downloadable samples for the complete code.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁，省略了`startCPUStatThread`和`stopCPUStatThread`，因为它们与之前示例中启动本地线程所使用的代码非常相似——请参阅可下载的示例以获取完整代码。
- en: Great! We learned how to wrap native objects in Java objects, we defined an
    interface to purge native memory from a java object when the native object is
    no longer required and we learned how to create from native Java Objects calling
    the object constructor.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们学习了如何将本地对象包装在Java对象中，我们定义了一个接口，在本地对象不再需要时从Java对象中清除本地内存，我们还学习了如何通过调用对象构造函数从本地Java对象创建对象。
- en: Summary
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we introduce you to the JNI, a standard API available on Java
    to interact with native code written in Assembly, C or C++ that it is available
    to any Android Developer with the Android NDK kit installed.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向您介绍了JNI，这是一个在Java上可用的标准API，用于与用汇编、C或C++编写的本地代码交互，它对安装了Android NDK套件的任何Android开发者都可用。
- en: In the first section we explain how to setup a project with JNI code on Android
    Studio and how to call C function and C++ member functions from any Java class
    on your application.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分，我们解释了如何在Android Studio上设置带有JNI代码的项目，以及如何从您的应用程序中的任何Java类调用C函数和C++成员函数。
- en: Later, we use the JNI interface to execute a `Loader` asynchronous background
    work on a native function. The native function was able to convert a colorful
    image to a gray image on a Java background thread created by the `AsyncTaskLoader`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们使用JNI接口在本地函数上执行一个`Loader`异步后台工作。本地函数能够在由`AsyncTaskLoader`创建的Java后台线程中将彩色图像转换为灰度图像。
- en: Next, we discover how to attach and detach a pure native thread created using
    the C++ standard library to the JVM. The attached thread worked as a normal Java
    thread and managed its own JNI Environment, resources and references.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将发现如何将使用C++标准库创建的纯本地线程附加和分离到JVM。附加的线程作为一个正常的Java线程工作，并管理自己的JNI环境、资源和引用。
- en: In the meantime, we also discovered the differences between JNI global and Local
    references and how to access a Java object field from the native code scope.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们还发现了JNI全局引用和局部引用之间的差异，以及如何从本地代码作用域访问Java对象字段。
- en: We also learned a technique to wrap native objects on Java objects and we define
    a concrete interface to dispose JNI resources attached to Java objects.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了一种将原生对象包装在 Java 对象中的技术，并定义了一个具体接口来处理附加到 Java 对象上的 JNI 资源。
- en: At the end of the chapter, we learned how to detect and handle a pending exception
    thrown on the JVM by a Java function.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们学习了如何检测和处理在 JVM 上由 Java 函数抛出的挂起异常。
- en: We all the techniques explained on this chapter you should be able to integrate
    any code written in C/C++ in your asynchronous background execution. Beyond that,
    you can also make use of the native code to optimize a crucial functionality in
    your application or integrate with some native handy libraries.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中解释的所有技术，您应该能够将任何用 C/C++ 编写的代码集成到您的异步后台执行中。除此之外，您还可以利用原生代码来优化应用程序中的关键功能或集成一些原生实用库。
- en: In the next chapter, we will learn how to use the Google GCM to push and pull
    efficiently realtime messages from your server and how to schedule work with Google
    Play Services framework.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用 Google GCM 从您的服务器高效地推送和拉取实时消息，以及如何使用 Google Play Services 框架安排工作。
