- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Testing Your App
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试您的应用
- en: Testing Android apps is a crucial aspect of the development process, ensuring
    that our application functions as intended and meets user expectations. It helps
    us identify and fix bugs before they reach production and ensure that our app
    is stable and performs well. This chapter will equip you with the skills to write
    tests for the different layers of our app that we’ve created so far.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 测试Android应用是开发过程中的一个关键方面，确保我们的应用按预期工作并满足用户期望。它帮助我们识别和修复在它们达到生产之前的问题，并确保我们的应用稳定且性能良好。本章将为您提供编写我们迄今为止创建的应用不同层的测试的技能。
- en: In this chapter, we will learn how to add tests for the different layers in
    our **MVVM** (**Model-View-ViewModel**) architecture. We will learn the importance
    of adding tests to our apps and how to add unit tests, integration tests, and
    instrumentation tests.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何为我们的**MVVM**（**模型-视图-视图模型**）架构中的不同层添加测试。我们将了解添加测试到我们的应用的重要性以及如何添加单元测试、集成测试和仪器测试。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Importance of testing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试的重要性
- en: Testing the network and database layers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试网络和数据库层
- en: Testing our `ViewModels`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试我们的`ViewModels`
- en: Adding UI tests to our composables
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将UI测试添加到我们的可组合组件中
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the instructions in this chapter, you will need to have Android Studio
    Hedgehog or later ([https://developer.android.com/studio](https://developer.android.com/studio))
    downloaded.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章的说明，您需要下载 Android Studio Hedgehog 或更高版本([https://developer.android.com/studio](https://developer.android.com/studio))。
- en: You can use the previous chapter’s code to follow the instructions in this chapter.
    You can find the code for this chapter at [https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptertwelve](https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptertwelve).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用上一章的代码来遵循本章的说明。您可以在[https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptertwelve](https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptertwelve)找到本章的代码。
- en: Importance of testing
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试的重要性
- en: 'Writing tests is a crucial aspect of app development. It has the following
    benefits:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试是应用开发的一个关键方面。它有以下好处：
- en: It helps us to **identify and fix bugs** before they reach production. When
    we write tests for our code, we can see issues at an early stage and quickly fix
    them before they reach our users, which is normally very costly.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有助于我们在它们达到生产阶段之前**识别和修复错误**。当我们为我们的代码编写测试时，我们可以在早期阶段看到问题，并在它们到达用户之前快速修复它们，这通常成本很高。
- en: '**Ensures code quality**. When we write tests, we are forced to write code
    that can be tested. This means that we write code that is modular and loosely
    coupled. This makes our code base more maintainable and easier to work with. When
    we find a piece of code that is hard to test, it is a sign that the code is not
    well written and needs to be refactored.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**确保代码质量**。当我们编写测试时，我们被迫编写可测试的代码。这意味着我们编写的代码是模块化和松散耦合的。这使得我们的代码库更易于维护和协作。当我们发现难以测试的代码片段时，这是一个迹象，表明代码编写得不好，需要重构。'
- en: Writing tests results in **improved documentation and code understanding**.
    When we write tests, we are forced to think about how our code works and how it
    should be used. This makes it easier for other developers to understand our code.
    While tests can serve as a form of documentation, they should not replace proper
    code documentation.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写测试可以**提高文档和代码理解**。当我们编写测试时，我们被迫思考我们的代码是如何工作的以及应该如何使用。这使得其他开发者更容易理解我们的代码。虽然测试可以作为文档的一种形式，但它们不应取代适当的代码文档。
- en: Tests help us to **refactor our code with confidence**. When we have tests in
    place, we can refactor our code and be sure that we have not broken the existing
    features in our app that were working well before the refactoring. This is because
    we can run our tests and see whether they pass or fail.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试帮助我们**有信心地重构代码**。当我们有测试在位时，我们可以重构我们的代码，并确信我们没有破坏在重构之前工作良好的应用中的现有功能。这是因为我们可以运行我们的测试并查看它们是否通过或失败。
- en: Tests help us **test regression**, especially adding new features or modifying
    existing ones. Tests ensure that the existing functionality still works as before,
    and nothing has been broken.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试帮助我们**测试回归**，尤其是添加新功能或修改现有功能。测试确保现有的功能仍然按预期工作，并且没有出现任何问题。
- en: These are just to mention a few. There are many more benefits of writing tests,
    and the best way to realize them is to start writing tests for your code. One
    important thing to note is that we can also add tests to our **Continuous Integration/Continuous
    Delivery** (**CI/CD**) pipelines to ensure that our tests run automatically when
    we push our code to our repositories. This also ensures that as we collaborate
    with other people on our projects, we can be sure that our code is always in a
    good state and we can always deploy our code to production with confidence.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是提及的一小部分。写测试的好处还有很多，而实现这些好处的最佳方式就是开始为你的代码编写测试。需要注意的是，我们还可以将测试添加到我们的**持续集成/持续交付**（**CI/CD**）管道中，以确保在我们将代码推送到我们的仓库时，测试会自动运行。这也确保了在我们与其他人合作进行项目时，我们可以确信我们的代码始终处于良好状态，并且我们可以有信心地将代码部署到生产环境中。
- en: 'In Android, we have a concept called the **testing pyramid** that helps us
    to understand the several types of tests that we can write for our applications
    and how they relate to each other. The testing pyramid is divided into three layers,
    as shown in the following figure:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，我们有一个称为**测试金字塔**的概念，它帮助我们理解我们可以为我们的应用程序编写的几种测试类型以及它们之间的关系。测试金字塔分为三个层次，如下面的图所示：
- en: '![Figure 12.1 – Testing pyramid](img/B19779_12_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1 – 测试金字塔](img/B19779_12_01.jpg)'
- en: Figure 12.1 – Testing pyramid
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 测试金字塔
- en: 'As shown in the preceding diagram, we have three layers of tests:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，我们有三个层次的测试：
- en: '**Unit tests**: These tests sit at the bottom of the pyramid. These are tests
    that test a single unit of code in isolation. Unit tests are intended to test
    the smallest testable parts of an application – typically, methods and functions.
    They are the fastest to run and are the most reliable. They are also the easiest
    to write and maintain. Unit tests run on your local machine only. These tests
    are compiled to run locally on the **Java Virtual Machine** (**JVM**) to minimize
    execution time. For tests that depend on your own dependencies, we use mock objects
    to provide the external dependencies. **MockK** and **Mockito** are popular frameworks
    for mocking dependencies.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：这些测试位于金字塔的底部。这些是测试单个代码单元的测试，它们在隔离状态下进行测试。单元测试旨在测试应用程序中最小的可测试部分——通常是方法和函数。它们运行速度最快，可靠性最高。它们也是编写和维护最简单的。单元测试仅在本地机器上运行。这些测试被编译为在**Java虚拟机**（**JVM**）上本地运行，以最小化执行时间。对于依赖于你自己的依赖项的测试，我们使用模拟对象来提供外部依赖项。**MockK**和**Mockito**是流行的模拟依赖项的框架。'
- en: '**Integration tests**: These tests sit in the middle of the pyramid. They test
    how different units of code work together. They are slower to run than unit tests.
    They are also hard to write as they require multiple components and dependencies
    to work and maintain. **Roboletric** is a popular framework for writing integration
    tests.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**：这些测试位于金字塔的中间。它们测试不同的代码单元是如何协同工作的。它们的运行速度比单元测试慢。编写它们也很困难，因为它们需要多个组件和依赖项来工作和维护。**Roboletric**是编写集成测试的流行框架。'
- en: '**UI tests**: These tests sit at the top of the pyramid. They test how the
    different components of our app work together. They are the slowest to run since
    they run on a real device or emulator and are the least reliable. They are also
    the most expensive to write and maintain. There are several frameworks for writing
    UI tests, including **Espresso**, **UI Automator**, and **Appium**.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UI测试**：这些测试位于金字塔的顶部。它们测试我们应用程序的不同组件是如何协同工作的。由于它们在真实设备或模拟器上运行，所以运行速度最慢，可靠性最低。它们也是编写和维护成本最高的。有几个框架可以用来编写UI测试，包括**Espresso**、**UI
    Automator**和**Appium**。'
- en: The testing pyramid presents a way to distribute the tests that we write on
    our code base. The ideal distribution percentages are **70% for unit tests**,
    **20% for integration tests**, and **10% for UI tests**. Notice as we go up the
    pyramid that the number of tests reduces. This is because as we go up the pyramid,
    the tests become more expensive to write and maintain. This is why we should strive
    to write more unit tests than integration tests and more integration tests than
    UI tests.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 测试金字塔提供了一种在代码库上分配我们编写的测试的方法。理想的分配百分比是**单元测试70%**、**集成测试20%**和**UI测试10%**。注意，当我们向上移动金字塔时，测试的数量会减少。这是因为当我们向上移动金字塔时，测试的编写和维护成本会更高。这就是为什么我们应该努力编写比集成测试更多的单元测试，以及比UI测试更多的集成测试。
- en: Over the next few sections, we will write the tests for the different layers
    we have discussed. Let us start by testing our database and network layers in
    our app.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将为所讨论的不同层编写测试。让我们先从测试我们的应用程序中的数据库和网络层开始。
- en: Testing the network and database layers
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试网络和数据库层
- en: In this section, we are going to learn how to write tests for our network and
    database layers step by step.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将逐步学习如何编写对网络和数据库层的测试。
- en: Testing the network layer
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试网络层
- en: 'To test our network layer, we will write unit tests. However, since we are
    using Retrofit to make our network requests, we will use `MockWebServer` to mock
    our network requests. The `MockWebServer` is a library that allows us to mock
    our network requests. Let us start by setting up the test dependencies in our
    version catalog:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的网络层，我们将编写单元测试。然而，由于我们使用Retrofit进行网络请求，我们将使用`MockWebServer`来模拟网络请求。`MockWebServer`是一个允许我们模拟网络请求的库。让我们首先在我们的版本目录中设置测试依赖项：
- en: 'Open the `libs.version.toml` file and add the following versions in the versions
    section:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`libs.version.toml`文件，并在版本部分添加以下版本：
- en: '[PRE0]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We are setting up the versions for `mockWebServer`, `coroutinesTest`, and `truth`.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们正在设置`mockWebServer`、`coroutinesTest`和`truth`的版本。
- en: 'Next, in the libraries section, add the following:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在库部分，添加以下内容：
- en: '[PRE1]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we are adding the dependencies for these libraries.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们正在添加这些库的依赖项。
- en: 'Next, we will create a bundle so that it is easy to add all test dependencies
    at once. In the bundle section, add the following:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个包，以便一次性添加所有测试依赖项。在包部分，添加以下内容：
- en: '[PRE2]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Click on the **Sync Now** button at the top to add the dependencies.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击顶部的**立即同步**按钮以添加依赖项。
- en: 'Lastly, let us head over to the app-level `build.gradle.kts` file and add the
    following:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们转到应用程序级别的`build.gradle.kts`文件，并添加以下内容：
- en: '[PRE3]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will add the test bundle to our test directory.
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将把测试包添加到我们的测试目录中。
- en: Click on the **Sync Now** button to add the dependencies to our app.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**立即同步**按钮以将依赖项添加到我们的应用程序中。
- en: 'Before we start writing our tests, we need to do several setup tasks. First,
    we need to create a JSON response for the request that our test will use:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写测试之前，我们需要做一些设置任务。首先，我们需要为测试将使用的请求创建一个JSON响应：
- en: To do this, right-click on the `app` directory, select **New**, and at the bottom
    of the pop-up dialog, select **Folder**.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要做到这一点，右键单击`app`目录，选择**新建**，然后在弹出对话框的底部选择**文件夹**。
- en: 'From the options presented, select `resources`, as shown in the following figure:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从提供的选项中选择`resources`，如图所示：
- en: '![Figure 12.2 – The resources folder](img/B19779_12_02.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图12.2 – 资源文件夹](img/B19779_12_02.jpg)'
- en: Figure 12.2 – The resources folder
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – 资源文件夹
- en: 'Inside this folder, let us create a new JSON file called `catsresponse.json`
    and add the following JSON:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个文件夹内，让我们创建一个名为`catsresponse.json`的新JSON文件，并添加以下JSON：
- en: '[PRE4]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Our app uses the Cat as a Service API, which returns a list of cats per the
    filter you have applied. The API returns this list of cats in a JSON response,
    as shown previously. When testing, especially with mocked data, the structure
    and data types of the JSON response should match those of the real API to ensure
    our tests are correct.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的应用程序使用Cat as a Service API，该API根据您应用的筛选条件返回猫的列表。API以JSON响应的形式返回此猫列表，如前所述。在测试时，尤其是使用模拟数据时，JSON响应的结构和数据类型应与真实API匹配，以确保我们的测试是正确的。
- en: 'Now that we have our response ready, we have to create a class that utilizes
    this response along with our test class in the `com.packt.chaptertwelve (test)`
    directory shown in the following figure:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了准备好的响应，我们必须创建一个类来利用这个响应，以及在前面的图中所示的`com.packt.chaptertwelve (test)`目录中的测试类：
- en: '![Figure 12.3 – Test directory](img/B19779_12_03.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图12.3 – 测试目录](img/B19779_12_03.jpg)'
- en: Figure 12.3 – Test directory
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 – 测试目录
- en: 'Inside the `com.packt.chaptertwelve (test)` directory, let us create a new
    Kotlin file called `MockRequestDispatcher.kt` and add the following code:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`com.packt.chaptertwelve (test)`目录内，让我们创建一个名为`MockRequestDispatcher.kt`的新Kotlin文件，并添加以下代码：
- en: '[PRE5]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here is a breakdown of the preceding code:'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是前面代码的分解：
- en: We have created a class called `MockRequestDispatcher` that extends `Dispatcher`.
    This class will be used to mock our network requests.
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`MockRequestDispatcher`的类，它扩展了`Dispatcher`。这个类将用于模拟我们的网络请求。
- en: We override the `dispatch` function, which takes `RecordedRequest` and returns
    `MockResponse`. This function is called when a request is made to the server.
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们重写了 `dispatch` 函数，该函数接受 `RecordedRequest` 并返回 `MockResponse`。当向服务器发出请求时，将调用此函数。
- en: We check the path of the request, and if it matches the path of our request,
    we return `MockResponse` with a response code of `200` and a body of the `Json`
    response that we created earlier. For now, we have only mocked a successful response,
    but it’s important to handle all the different HTTP response codes and error cases
    to properly mimic real-world scenarios.
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们检查请求的路径，如果它与我们的请求路径匹配，我们返回带有响应代码 `200` 和我们之前创建的 `Json` 响应体的 `MockResponse`。目前，我们只模拟了成功的响应，但处理所有不同的
    HTTP 响应代码和错误情况对于正确模拟现实世界场景非常重要。
- en: If the path does not match, we throw `IllegalArgumentException`.
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果路径不匹配，我们将抛出 `IllegalArgumentException`。
- en: Lastly, we create a `getJson` function that takes a path and returns a `String`
    instance type. This function is used to read the `Json` response from the file
    that we created earlier.
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们创建了一个 `getJson` 函数，它接受一个路径并返回一个 `String` 实例类型。这个函数用于读取我们之前创建的文件中的 `Json`
    响应。
- en: We can add as many paths as we want to this class. Since our project only has
    one path, this is all we need.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以添加任意多的路径到这个类中。由于我们的项目只有一个路径，所以我们只需要这些。
- en: 'Next, let us create our test class. Let us create a new Kotlin file called
    `CatsAPITest.kt` and add the following code:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建我们的测试类。让我们创建一个名为 `CatsAPITest.kt` 的新 Kotlin 文件，并添加以下代码：
- en: '[PRE6]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here is a breakdown of the preceding code:'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面是对前面代码的分解：
- en: We have created a class called `CatsAPITest`. This class will be used to test
    our network layer.
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `CatsAPITest` 的类。这个类将用于测试我们的网络层。
- en: 'We have created two variables: `mockWebServer` and `catsAPI`. The `mockWebServer`
    variable will be used to mock our network requests. The `catsAPI` variable will
    be used to make our network requests.'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了两个变量：`mockWebServer` 和 `catsAPI`。`mockWebServer` 变量将用于模拟我们的网络请求。`catsAPI`
    变量将用于发送我们的网络请求。
- en: 'We have the `setup()` function, which is annotated with the `@Before` annotation.
    This means that this function will run before our tests run. In this function,
    we have done the following:'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有 `setup()` 函数，该函数被 `@Before` 注解标记。这意味着这个函数将在我们的测试运行之前运行。在这个函数中，我们做了以下操作：
- en: We have created a `MockWebServer` instance and assigned it to the `mockWebServer`
    variable. We then set the dispatcher of `mockWebServer` to an instance of `MockRequestDispatcher`.
    This is the class that we created earlier. We then start `mockWebServer`.
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个 `MockWebServer` 实例并将其分配给 `mockWebServer` 变量。然后我们将 `mockWebServer` 的调度程序设置为
    `MockRequestDispatcher` 的一个实例。这是我们之前创建的类。然后我们启动 `mockWebServer`。
- en: We have created a Retrofit instance and added the `kotlinx-serialization-converter`
    factory. We then assign the `catsAPI` variable to an instance of `CatsAPI`.
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个 Retrofit 实例并添加了 `kotlinx-serialization-converter` 工厂。然后我们将 `catsAPI`
    变量分配给 `CatsAPI` 的一个实例。
- en: 'We have our test function, which is annotated with the `@Test` annotation.
    This means that this function will be run as a test. In this function, we do the
    following:'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有我们的测试函数，该函数被 `@Test` 注解标记。这意味着这个函数将被作为测试运行。在这个函数中，我们做了以下操作：
- en: We wrap the test in the `runTest()` function. This is because we want to test
    suspending functions. `runTest` is a coroutine test builder designed for testing
    coroutines. It is part of the `kotlinx-coroutines-test` library that we added
    earlier.
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将测试包裹在 `runTest()` 函数中。这是因为我们想要测试挂起函数。`runTest` 是一个协程测试构建器，专为测试协程设计。它是我们之前添加的
    `kotlinx-coroutines-test` 库的一部分。
- en: We make a network request to `mockWebServer` using the `catsAPI` instance that
    we created earlier. We then assert that the response is successful.
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用之前创建的 `catsAPI` 实例向 `mockWebServer` 发送网络请求。然后我们断言响应是成功的。
- en: We have the `tearDown()` function, which is annotated with the `@After` annotation.
    This means that this function will run after our tests run. This function is used
    to shut down our `mockWebServer` instance.
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有 `tearDown()` 函数，该函数被 `@After` 注解标记。这意味着这个函数将在我们的测试运行之后运行。这个函数用于关闭我们的 `mockWebServer`
    实例。
- en: 'Press the green *run* icon next to our test class to run our tests. We should
    see the following output in the **Run** window:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下测试类旁边的绿色 *运行* 图标来运行我们的测试。我们应该在 **运行** 窗口中看到以下输出：
- en: '![Figure 12.4 – Test passing](img/B19779_12_04.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.4 – 测试通过](img/B19779_12_04.jpg)'
- en: Figure 12.4 – Test passing
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.4 – 测试通过
- en: As seen in the preceding figure, our test runs successfully. This means that
    our network layer is working as expected. We can now move on to testing our database
    layer.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，我们的测试运行成功。这意味着我们的网络层按预期工作。我们现在可以继续测试我们的数据库层。
- en: Testing the database layer
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试数据库层
- en: 'We are using `androidTest` directory shown in the following figure:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下图所示的 `androidTest` 目录：
- en: '![Figure 12.5 – Android test directory](img/B19779_12_05.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.5 – Android 测试目录](img/B19779_12_05.jpg)'
- en: Figure 12.5 – Android test directory
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.5 – Android 测试目录
- en: 'Let us create a new file called `CatsDaoTest.kt` and add the following code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为 `CatsDaoTest.kt` 的新文件，并添加以下代码：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here is a breakdown of the preceding code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是对前面代码的分解：
- en: 'We have created two variables: `database` and `catDao`. The `database` variable
    will be used to create an instance of our database. The `catDao` variable will
    be used to create an instance of our `CatDao` interface.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了两个变量：`database` 和 `catDao`。`database` 变量将用于创建我们数据库的实例。`catDao` 变量将用于创建我们
    `CatDao` 接口的实例。
- en: We have the `createDatabase()` function, which is annotated with the `@Before`
    annotation. This means that this function will run before our tests run. Inside
    the function, we create an instance of our database and assign it to the `database`
    variable. We are using the in-memory database.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有 `createDatabase()` 函数，该函数带有 `@Before` 注解。这意味着这个函数将在我们的测试运行之前运行。在函数内部，我们创建我们数据库的实例并将其分配给
    `database` 变量。我们使用的是内存数据库。
- en: We have the `closeDatabase()` function, which is annotated with the `@After`
    annotation. This means that this function will run after our tests run. This function
    is used to close our database.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有 `closeDatabase()` 函数，该函数带有 `@After` 注解。这意味着这个函数将在我们的测试运行之后运行。此函数用于关闭我们的数据库。
- en: 'With this done, we can now start writing our tests:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，我们现在可以开始编写我们的测试：
- en: 'In the `CatsDaoTest` class, add the following test function:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `CatsDaoTest` 类中，添加以下测试函数：
- en: '[PRE8]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this test, we have created a `CatEntity` object with the details of a cat.
    We then inserted the details of the cat into the database. Lastly, we assert that
    the details of the cat are in the database.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个测试中，我们创建了一个包含猫详细信息的 `CatEntity` 对象。然后我们将猫的详细信息插入到数据库中。最后，我们断言猫的详细信息在数据库中。
- en: 'Click on the green *run* icon next to our test class to run our tests. You
    should see the following output in the **Run** window:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击测试类旁边的绿色 *运行* 图标来运行我们的测试。你应该在 **运行** 窗口中看到以下输出：
- en: '![Figure 12.6 – Test to insert and read from the database](img/B19779_12_06.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.6 – 插入和从数据库读取的测试](img/B19779_12_06.jpg)'
- en: Figure 12.6 – Test to insert and read from the database
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.6 – 插入和从数据库读取的测试
- en: Our test runs successfully. This means that our database layer is working as
    expected. Let us add another test that tests adding a cat to the favorites.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试运行成功。这意味着我们的数据库层按预期工作。让我们添加另一个测试来测试将猫添加到收藏夹。
- en: 'Still inside the `CatsDaoTest` class, let us add the following test function:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在 `CatsDaoTest` 类内部，让我们添加以下测试函数：
- en: '[PRE9]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this test, we have created a `CatEntity` object with the details of a cat.
    We then insert the cat into the database. We then update the `CatEntity` object,
    passing `isFavorite` as `true`. Lastly, we assert that the cat is on the favorite
    list.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个测试中，我们创建了一个包含猫详细信息的 `CatEntity` 对象。然后我们将猫插入到数据库中。然后我们更新 `CatEntity` 对象，将
    `isFavorite` 作为 `true` 传递。最后，我们断言猫在收藏列表中。
- en: 'Click on the green *run* icon next to our test class to run our tests. You
    should see the following output in the **Run** window:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击测试类旁边的绿色 *运行* 图标来运行我们的测试。你应该在 **运行** 窗口中看到以下输出：
- en: '![Figure 12.7 – Favoriting a cat test](img/B19779_12_07.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.7 – 收藏猫测试](img/B19779_12_07.jpg)'
- en: Figure 12.7 – Favoriting a cat test
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.7 – 收藏猫测试
- en: Our tests run successfully. This means that our functionality for adding cats
    to favorites is working properly.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试运行成功。这意味着我们添加猫到收藏夹的功能工作正常。
- en: We have seen how to test our network and database layers. Next, let us test
    our ViewModel layer.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何测试我们的网络和数据库层。接下来，让我们测试我们的 ViewModel 层。
- en: Testing our ViewModels
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试我们的 ViewModels
- en: 'Our `ViewModel` class fetches data from the repository and exposes it to the
    UI. To test our `ViewModel`, we will write unit tests. Let us start by setting
    up the test dependencies in our version catalog:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `ViewModel` 类从仓库获取数据并将其暴露给 UI。为了测试我们的 `ViewModel`，我们将编写单元测试。让我们从在我们的版本目录中设置测试依赖项开始：
- en: 'Open the `libs.version.toml` file and add the following versions in the versions
    section:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `libs.version.toml` 文件，并在版本部分添加以下版本：
- en: '[PRE10]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, in the libraries section, add the following:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在库部分，添加以下内容：
- en: '[PRE11]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add the `test-mockk` dependency to the `test` bundle. Our updated `test` bundle
    should now look like this:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `test-mockk` 依赖项添加到 `test` 包中。我们的更新后的 `test` 包现在应该看起来像这样：
- en: '[PRE12]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Click on the `mockk` allows us to mock our dependencies.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `mockk` 允许我们模拟我们的依赖项。
- en: 'We are now ready to create our test class. Create a new Kotlin file called
    `CatsViewModelTest.kt` inside the test directory and add the following code:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在准备好创建测试类。在测试目录中创建一个新的 Kotlin 文件，命名为 `CatsViewModelTest.kt`，并添加以下代码：
- en: '[PRE13]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here is a breakdown of the preceding code:'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面是对前面代码的分解：
- en: 'We have created two variables: `petsRepository` and `petsViewModel`. The `petsRepository`
    variable will be used to mock our `PetsRepository` interface. We used `mockk<PetsRepository>`
    to provide a mock instance of `PetsRepository`. The `petsViewModel` variable will
    be used to create an instance of `PetsViewModel`.'
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了两个变量：`petsRepository` 和 `petsViewModel`。`petsRepository` 变量将用于模拟我们的 `PetsRepository`
    接口。我们使用 `mockk<PetsRepository>` 提供了一个 `PetsRepository` 的模拟实例。`petsViewModel` 变量将用于创建
    `PetsViewModel` 的一个实例。
- en: We have the `setup()` function, which is annotated with the `@Before` annotation.
    This means that this function will run before our tests run. We set the main dispatcher
    to `Dispatchers.Unconfined`. This is because we are using coroutines in our ViewModel.
    We then assign the `petsViewModel` property to an instance of `PetsViewModel`.
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有 `setup()` 函数，该函数被 `@Before` 注解标记。这意味着这个函数将在我们的测试运行之前执行。我们将主分发器设置为 `Dispatchers.Unconfined`。这是因为我们在
    ViewModel 中使用协程。然后我们将 `petsViewModel` 属性赋值给 `PetsViewModel` 的一个实例。
- en: We have the `tearDown()` function, which is annotated with the `@After` annotation.
    This means that this function will run after our tests run. This function is used
    to reset the main dispatcher.
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有 `tearDown()` 函数，该函数被 `@After` 注解标记。这意味着这个函数将在我们的测试运行之后执行。这个函数用于重置主分发器。
- en: 'With this, we are ready to write our test. Below the `tearDown()` function,
    add the following test function:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就准备好编写测试了。在 `tearDown()` 函数下方，添加以下测试函数：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this test function, we have created a list of cats. We then mock the `getPets()`
    function of `PetsRepository` to return a flow of cats. It returns a flow of cats
    since our `getPets()` function in `PetsRepository` returns `Flow<List<Cat>>`;
    this way, we mock the correct behavior of this function. We then call the `getPets()`
    function of `PetsViewModel`. We then assert that the `getPets()` function of `PetsRepository`
    is called. Lastly, we assert that the list of cats that we created is the same
    as the list of cats that we get from `PetsViewModel`. Remember to remove the private
    marker in our `PetsViewModel` class in case you get an error when trying to access
    the `getPets()` function. Click on the green *run* icon next to our test class
    to run our tests. You should see the following output in the **Run** window:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试函数中，我们创建了一个猫的列表。然后我们模拟 `PetsRepository` 的 `getPets()` 函数以返回一个猫的流。它返回一个猫的流，因为我们的
    `PetsRepository` 中的 `getPets()` 函数返回 `Flow<List<Cat>>`；这样，我们模拟了该函数的正确行为。然后我们调用
    `PetsViewModel` 的 `getPets()` 函数。然后我们断言 `PetsRepository` 的 `getPets()` 函数被调用。最后，我们断言我们创建的猫列表与从
    `PetsViewModel` 获取的猫列表相同。记住，如果尝试访问 `getPets()` 函数时出现错误，请从我们的 `PetsViewModel` 类中移除私有标记。点击测试类旁边的绿色
    *运行* 图标以运行我们的测试。你应该在 **运行** 窗口中看到以下输出：
- en: '![Figure 12.8 – PetsViewModelTest](img/B19779_12_08.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.8 – PetsViewModelTest](img/B19779_12_08.jpg)'
- en: Figure 12.8 – PetsViewModelTest
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.8 – PetsViewModelTest
- en: Our test runs successfully. This means that our `ViewModel` layer is working
    as expected. We can now move on to testing our UI layer. In the next section,
    we will learn how to write UI tests in Jetpack Compose.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试运行成功。这意味着我们的 `ViewModel` 层按预期工作。现在我们可以继续测试我们的 UI 层。在下一节中，我们将学习如何在 Jetpack
    Compose 中编写 UI 测试。
- en: Adding UI tests to our composables
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 UI 测试添加到我们的可组合项中
- en: Writing UI tests has been made easier for us. Jetpack Compose provides a set
    of testing APIs to find elements, verify their attributes, and perform actions
    on these elements. Jetpack Compose uses `PetListItem` composable.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 编写 UI 测试对我们来说变得更容易了。Jetpack Compose 提供了一套测试 API，用于查找元素、验证它们的属性，并在这些元素上执行操作。Jetpack
    Compose 使用 `PetListItem` 可组合项。
- en: 'Let us head over to the `PetListItem.kt` file. We need to add a `testTags`
    modifier to our composable. This is because we are using tags to identify our
    composables. In the `PetListItem` composable, modify the composable contents to
    be as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转到 `PetListItem.kt` 文件。我们需要在我们的可组合项中添加一个 `testTags` 修饰符。这是因为我们正在使用标签来识别我们的可组合项。在
    `PetListItem` 可组合项中，修改可组合项内容如下：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Notice we have added the `testTag()` modifier to our components. With this,
    we are able to use the Finders APIs in Jetpack Compose to find our composables.
    Once we use the finders, we can perform actions and assert on our composables.
    Let us now create a new file in our `androidTest` directory called `PetListItemTest.kt`
    and add the following code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们已经为我们的组件添加了 `testTag()` 修饰符。有了这个修饰符，我们能够使用 Jetpack Compose 的 Finders API
    来找到我们的可组合项。一旦我们使用了查找器，我们就可以对可组合项执行操作并断言。现在让我们在我们的 `androidTest` 目录中创建一个名为 `PetListItemTest.kt`
    的新文件，并添加以下代码：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here is a breakdown of the preceding code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是对前面代码的分解：
- en: We have created a class called `PetListItemTest`. We will use this class to
    test our `PetListItem` composable. Inside this class, we have created a rule called
    `composeTestRule`. This rule will be used to create our composables. Through this
    rule, we can set Compose content or access our activity.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `PetListItemTest` 的类。我们将使用这个类来测试我们的 `PetListItem` 可组合项。在这个类内部，我们创建了一个名为
    `composeTestRule` 的规则。这个规则将用于创建我们的可组合项。通过这个规则，我们可以设置 Compose 内容或访问我们的活动。
- en: 'We have the `testPetListItem()` function, which is annotated with the `@Test`
    annotation. Several things are happening in this function:'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个被 `@Test` 注解的 `testPetListItem()` 函数，这个函数中发生了几件事情：
- en: We have used the `with` scoping function to be able to use `composeTestRule`.
    We then set the content of our composable. In this case, it is the `PetListItem`
    composable that we want to test. We pass a `cat` object to our composable.
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用了 `with` 范围函数来能够使用 `composeTestRule`。然后我们设置了我们的可组合项的内容。在这种情况下，是我们想要测试的 `PetListItem`
    可组合项。我们向我们的可组合项传递了一个 `cat` 对象。
- en: We are using the `onNodeWithTag()` function to find our composables. We then
    use the `assertExists()` function to assert that the composables exist. This will
    find our composables using the tags that we added earlier.
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `onNodeWithTag()` 函数来找到我们的可组合项。然后我们使用 `assertExists()` 函数来断言可组合项的存在。这将使用我们之前添加的标签来找到我们的可组合项。
- en: We are using the `onNodeWithText()` function to find our composables. We then
    use the `assertIsDisplayed()` function to assert that the composables exist. We
    have also used the `onNodeWithContentDescription()` function to find our composables.
    These two functions help us find composables whose text or content description
    matches the text or content description that we pass to the function.
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `onNodeWithText()` 函数来找到我们的可组合项。然后我们使用 `assertIsDisplayed()` 函数来断言可组合项的存在。我们还使用了
    `onNodeWithContentDescription()` 函数来找到我们的可组合项。这两个函数帮助我们找到文本或内容描述与传递给函数的文本或内容描述匹配的可组合项。
- en: Lastly, we are using the `performClick()` function to perform an action on our
    composables. In this case, we are performing a click action on our `PetListItemFavoriteIcon`
    composable.
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们使用 `performClick()` 函数对我们的可组合项执行操作。在这种情况下，我们对我们 `PetListItemFavoriteIcon`
    可组合项执行点击操作。
- en: 'Click on the green *run* icon next to our test class to run our tests. We should
    see the following output in the **Run** window:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 点击我们测试类旁边的绿色 *运行* 图标来运行我们的测试。我们应该在 **运行** 窗口中看到以下输出：
- en: '![Figure 12.9 – Jetpack Compose UI tests](img/B19779_12_09.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.9 – Jetpack Compose UI 测试](img/B19779_12_09.jpg)'
- en: Figure 12.9 – Jetpack Compose UI tests
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.9 – Jetpack Compose UI 测试
- en: Our test runs successfully. Additionally, the test is also run on the device
    that we are working on. We are also able to see the components being displayed
    and actions being performed.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试运行成功。此外，测试也在我们正在工作的设备上运行。我们还能看到组件的显示和执行的操作。
- en: We have seen how to write UI tests in Jetpack Compose. To learn more about testing
    in Jetpack Compose, check out the official documentation ([https://developer.android.com/jetpack/compose/testing](https://developer.android.com/jetpack/compose/testing)).
    With the knowledge that we have gained in this chapter, we can add more tests
    to the different layers of our app. You can try adding more tests to test your
    knowledge.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何在 Jetpack Compose 中编写 UI 测试。要了解更多关于 Jetpack Compose 的测试信息，请查看官方文档([https://developer.android.com/jetpack/compose/testing](https://developer.android.com/jetpack/compose/testing))。凭借我们在本章中获得的知识，我们可以为我们的应用的不同层添加更多测试。你可以尝试添加更多测试来检验你的知识。
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned how to add tests for the different layers in
    our MVVM architecture. We have learned about the importance of adding tests to
    our apps and how to add unit tests, integration tests, and instrumentation tests.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何为我们的 MVVM 架构中的不同层添加测试。我们了解了添加测试到我们的应用的重要性，以及如何添加单元测试、集成测试和仪器测试。
- en: In the next chapter, we will learn step-by-step how to publish a new app in
    the Google Play Store. We will walk through how to create a signed app bundle
    and the things required for us to publish our first app to the Play Store. Additionally,
    we will learn about some of the Google Play Store policies and how to always stay
    compliant to avoid our apps from being removed or accounts from being banned.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将逐步学习如何在Google Play商店发布一款新应用。我们将详细介绍如何创建签名应用包以及发布我们第一个应用到Play Store所需的事项。此外，我们还将了解一些Google
    Play商店政策以及如何始终保持合规，以避免我们的应用被移除或账户被封禁。
- en: 'Part 4: Publishing Your App'
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4部分：发布您的应用
- en: Having successfully developed your app, the next phase unfolds in this part.
    You will discover the intricacies of publishing your app to the Google Play Store,
    navigating through crucial Google Play Store policies to ensure a seamless release.
    You will also dive into the realm of **continuous integration and continuous deployment**
    (**CI/CD**), unlocking the potential to automate routine tasks integral to Android
    development. You will learn how to seamlessly integrate tests and code analysis
    tools from *Part 3* into your CI/CD pipelines, streamlining development workflows.
    To conclude this part, you will elevate your app’s performance by incorporating
    crash reporting tools and enhancing user engagement through the implementation
    of push notifications, and learn some useful tips on how to secure your app.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功开发您的应用之后，下一阶段的内容将在本部分展开。您将了解如何将应用发布到Google Play商店的细节，以及如何通过遵守关键的Google Play商店政策来确保发布过程顺利。您还将深入了解**持续集成与持续部署**（**CI/CD**）领域，解锁自动化Android开发中常规任务的潜力。您将学习如何将第3部分中的测试和代码分析工具无缝集成到您的CI/CD管道中，从而简化开发工作流程。为了结束本部分，您将通过整合崩溃报告工具来提升应用性能，并通过实施推送通知来增强用户参与度，并学习一些有关如何确保应用安全的有用提示。
- en: 'This section contains the following chapters:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含以下章节：
- en: '[*Chapter 13*](B19779_13.xhtml#_idTextAnchor175), *Publishing Your App*'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B19779_13.xhtml#_idTextAnchor175), *发布您的应用*'
- en: '[*Chapter 14*](B19779_14.xhtml#_idTextAnchor198), *Continuous Integration and
    Continuous Deployment*'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第14章*](B19779_14.xhtml#_idTextAnchor198), *持续集成与持续部署*'
- en: '[*Chapter 15*](B19779_15.xhtml#_idTextAnchor215), *Improving Your App*'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第15章*](B19779_15.xhtml#_idTextAnchor215), *改进您的应用*'
