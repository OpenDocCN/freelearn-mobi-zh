- en: Chapter 4. 3D Graphics Rendering
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 3D图形渲染
- en: The graphics hardware inside the average smartphone is now capable of rendering
    3D graphics of a surprisingly high quality for a device that is small enough to
    fit into your pocket.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 普通智能手机内部的图形硬件现在能够渲染出令人惊讶的高质量3D图形，这对于一个足够小可以放入口袋的设备来说是非常了不起的。
- en: 'The Marmalade SDK makes using 3D graphics in your own games extremely easy
    to do, as you will discover when we cover the following topics in this very chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Marmalade SDK使得在你的游戏中使用3D图形变得极其简单，正如我们在本章接下来的主题中将要了解的那样：
- en: The basics of 3D graphics rendering—projection, clipping, lighting, and so on
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3D图形渲染的基本原理——投影、裁剪、光照等
- en: Creating and rendering a simple 3D model entirely in code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全通过代码创建和渲染一个简单的3D模型
- en: Exporting 3D model data from a modeling package
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从建模软件中导出3D模型数据
- en: Loading exported 3D models into memory and rendering them
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将导出的3D模型加载到内存中并渲染它们
- en: A quick 3D graphics primer
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3D图形快速入门
- en: Before we get our hands dirty with rendering code, let's just touch on some
    of the basics of how 3D rendering can be achieved. If you already have a good
    handle of 3D rendering techniques then feel free to skip this section.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写渲染代码之前，让我们简要地了解一下如何实现3D渲染的基本原理。如果你已经很好地掌握了3D渲染技术，那么你可以自由地跳过这一部分。
- en: Describing a 3D model
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述3D模型
- en: In computer graphics a 3D representation of an object is often referred to as
    a **model**. When we build a model in three dimensions for use in a video game,
    we create a group of triangles that define the shape of the model. We can also
    use quadrilaterals to make the modeling process easier, but these ultimately get
    converted into two triangles when it comes to rendering time.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机图形学中，一个对象的3D表示通常被称为**模型**。当我们为视频游戏构建一个三维模型时，我们创建了一组定义模型形状的三角形。我们也可以使用四边形来简化建模过程，但在渲染时这些最终会被转换成两个三角形。
- en: The simplest representation of a 3D model is therefore little more than a big
    list of vertices which define the triangles required to render the model, but
    we often specify a host of extra information so we can control exactly how the
    model should appear on screen.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，3D模型的最简单表示仅仅是一个大列表的顶点，这些顶点定义了渲染模型所需的三角形，但我们经常指定大量额外的信息，以便我们可以精确控制模型在屏幕上的显示方式。
- en: Specifying a model's vertex stream
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定模型的顶点流
- en: Every 3D model has a **pivot point**, also called its **origin**, which is the
    point around which the model will rotate and scale. In a 3D modeling package this
    point can be positioned wherever you want it to be, but to make the mathematics
    easier in a game we would normally treat the point (0, 0, 0) as the pivot point.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 每个3D模型都有一个**旋转中心**，也称为**原点**，这是模型围绕其旋转和缩放的点。在3D建模软件中，这个点可以放置在你想要的位置，但在游戏中为了简化数学计算，我们通常将点（0，0，0）视为旋转中心。
- en: Each triangle in the model is defined by three vertices, and each vertex consists
    of an x, y, and z component which declares the position of the vertex in what
    is called **model space** (sometimes also referred to as **object space**). This
    just means that the components of each vertex are relative to the model's pivot
    point.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 模型中的每个三角形都是由三个顶点定义的，每个顶点由一个x、y和z组件组成，这些组件声明了顶点在所谓的**模型空间**（有时也称为**对象空间**）中的位置。这仅仅意味着每个顶点的组件相对于模型的旋转中心。
- en: The following diagram shows an example of a cube. The pivot point is positioned
    at the very centre of the cube and is hence the origin of model space. The corner
    points use both positive and negative values, but each component has an absolute
    value of **100**, which yields a cube with edges of length 200 units. For clarity,
    the three front faces of the cube also show how they have been built from two
    triangles.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了一个立方体的示例。旋转中心位于立方体的中心，因此是模型空间的原点。角点使用正负值，但每个组件的绝对值都是**100**，这使得立方体的边长为200单位。为了清晰起见，立方体的三个正面也显示了它们是如何由两个三角形构建而成的。
- en: '![Specifying a model''s vertex stream](img/3363_04_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![指定模型的顶点流](img/3363_04_01.jpg)'
- en: In order to provide Marmalade with the vertices of the cube, we simply use Marmalade's
    three-component floating pointer vector class `CIwFVec3` to provide an array of
    vertices. As with the 2D rendering, we've already seen this is called a vertex
    stream, except that this time the stream consists of three component vectors.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向Marmalade提供立方体的顶点，我们只需使用Marmalade的三分量浮点指针向量类`CIwFVec3`来提供一个顶点数组。与2D渲染一样，我们已经看到这被称为顶点流，只不过这次流由三个分量向量组成。
- en: Specifying a model's index stream
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定模型的索引流
- en: You will notice that the corners of the cube in the previous diagram have been
    labeled with a number as well as their model space coordinates. If we cast our
    minds back to our work with 2D graphics, we will remember that Marmalade renders
    polygons by accepting a stream of vertices as input and also a stream of indices
    that defines the order in which those vertices should be processed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，在前面的图中，立方体的角已经被标注了一个数字以及它们在模型空间中的坐标。如果我们回顾一下我们在2D图形中的工作，我们会记得Marmalade通过接受一个顶点流作为输入以及一个定义这些顶点应如何处理的顺序的索引流来渲染多边形。
- en: The same approach applies when rendering 3D graphics. We specify the index stream
    as an array of unsigned 16-bit integers (`uint16`) and this dictates the order
    in which the vertices will be read out of the stream for rendering.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当渲染3D图形时，同样的方法也适用。我们将索引流指定为一个无符号16位整数数组（`uint16`），这决定了从流中读取顶点的顺序，以便进行渲染。
- en: One advantage of using an index stream is that we can potentially refer to the
    same point several times without having to duplicate it in the vertex stream,
    thus saving us some memory. Since the index stream is just telling the GPU which
    order it has to process the data contained in the vertex, color, UV, and normal
    streams, it can be as long or as short as we want it to be. The index stream doesn't
    even need to reference every single element of the other streams, meaning we could
    potentially create one set of streams that can be referenced by multiple different
    index streams.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用索引流的一个优点是，我们可以潜在地多次引用同一个点，而无需在顶点流中重复它，从而节省一些内存。由于索引流只是告诉GPU它必须按照什么顺序处理顶点、颜色、UV和法线流中包含的数据，因此它可以是我们想要的任意长度或短。索引流甚至不需要引用其他流的每个元素，这意味着我们可以潜在地创建一组可以由多个不同的索引流引用的流。
- en: Another advantage of index streams is that we can use them to speed up rendering.
    You will recall that we used the function call `IwGxDrawPrims` to render a 2D
    polygon. To render 3D polygons, we use the exact same call. Each call to this
    function results in the rendering engine having to perform some initialization,
    so if we can find a way to minimize the number of draw calls we have to make,
    we can render the game world more quickly.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 索引流的另一个优点是，我们可以使用它们来加速渲染。你会记得我们使用`IwGxDrawPrims`函数调用来渲染2D多边形。要渲染3D多边形，我们使用完全相同的调用。对这个函数的每次调用都会导致渲染引擎必须执行一些初始化，因此如果我们能找到一种方法来最小化我们必须做出的绘制调用次数，我们就可以更快地渲染游戏世界。
- en: We can use the index stream to achieve this by inserting degenerate polygons
    into the polygon render list. A **degenerate polygon** is one that does not modify
    any pixels when it is drawn and this is achieved by ensuring that all the vertices
    that make up the polygon will lie on the same line. Most graphics hardware are
    clever enough to recognize a degenerate polygon and will not waste time trying
    to render it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在多边形渲染列表中插入退化多边形来实现这一点。一个**退化多边形**是指绘制时不会修改任何像素的多边形，这是通过确保构成多边形的所有顶点都位于同一直线上来实现的。大多数图形硬件足够聪明，能够识别退化多边形，并且不会浪费时间尝试渲染它。
- en: As an example, let's assume we are rendering some triangle strips. We could
    render them by calling `IwGxDrawPrims` twice, or we could join the two strips
    with some degenerate polygons and render them both with a single call to `IwGxDrawPrims`.
    We can continue to do this to join together as many triangle strips as we want.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们正在渲染一些三角形带。我们可以通过调用`IwGxDrawPrims`两次来渲染它们，或者我们可以用一些退化多边形将两个带子连接起来，并通过一次调用`IwGxDrawPrims`来渲染它们。我们可以继续这样做，将我们想要的任意数量的三角形带连接起来。
- en: 'How do we specify the degenerate triangle? The easiest way, shown in the following
    diagram, is to duplicate the last point of the first strip and the first point
    of the second strip. This yields four degenerate triangles (A3A4A4, A4A4B0, A4B0B0,
    B0B0B1) but is preferable to making several draw calls. The dotted line in the
    following diagram shows the extra degenerate triangles (which collapse to form
    a line!) that join the strips together:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何指定退化三角形？以下图示中显示的最简单方法是复制第一条带的第一点以及第二条带的第一点。这产生了四个退化三角形（A3A4A4、A4A4B0、A4B0B0、B0B0B1），但比多次绘制调用更可取。以下图示中的虚线显示了连接条带的额外退化三角形（这些三角形会塌陷形成一条线！）：
- en: '![Specifying a model''s index stream](img/3363_04_02.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![指定模型的索引流](img/3363_04_02.jpg)'
- en: Specifying a model's color, UV, and normal streams
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定模型的颜色、UV和法向量流
- en: Just as with 2D rendering, there are a number of other stream types we can supply
    to make the polygons we render look more interesting. We can provide both color
    and texture UV streams in exactly the same way we did when rendering in two dimensions,
    but we can also specify a third stream type called a **normal stream**.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 就像2D渲染一样，我们还可以提供许多其他流类型，使渲染的多边形看起来更有趣。我们可以以与二维渲染相同的方式提供颜色和纹理UV流，但我们还可以指定一种称为**法向量流**的第三种流类型。
- en: 'In 3D mathematics, a **normal vector** is defined as the vector which is perpendicular
    to two other non-parallel vectors, or in other words a vector that points in the
    direction in which the polygon is facing. The following diagram shows an example
    illustrating this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在3D数学中，**法向量**被定义为垂直于两个其他非平行向量的向量，换句话说，就是指向多边形面向方向的向量。以下图示说明了这一点：
- en: '![Specifying a model''s color, UV, and normal streams](img/3363_04_12.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![指定模型的颜色、UV和法向量流](img/3363_04_12.jpg)'
- en: Why is the normal stream useful? Well, it allows us to simulate the effects
    of lights on our 3D model. By providing each vertex of our model with a **unit
    normal** (that is, a vector that points in the direction of the polygon's normal
    and which has a length of one unit), we can calculate the amount of light reflected
    from that vertex and adjust the color it is rendered with accordingly.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么法向量流有用？嗯，它允许我们模拟光线对我们3D模型的影响。通过为我们的模型每个顶点提供一个**单位法向量**（即指向多边形法线方向的向量，长度为一单位），我们可以计算从该顶点反射的光量，并相应地调整渲染的颜色。
- en: Real time lighting of a 3D model can be a time-intensive task, so when writing
    a game we try to avoid doing so when possible in order to speed up rendering.
    If we do not want to light a 3D model, there is no need to specify a normal stream;
    so, by not lighting a model we save memory too.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 3D模型的实时光照可能是一个耗时的工作，所以在编写游戏时，我们尽量在可能的情况下避免这样做，以加快渲染速度。如果我们不想对3D模型进行光照，就没有必要指定法向量流；因此，通过不光照模型，我们也能节省内存。
- en: There are a couple of points to bear in mind when specifying these additional
    streams.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定这些额外流时，有几个要点需要注意。
- en: Firstly, Marmalade expects the number of colors, UVs, and normals provided to
    match the number of vertices provided. While you can specify streams of different
    lengths, this will normally cause an assert to be fired and obviously it could
    yield unexpected results when rendering.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Marmalade期望提供的颜色、UV和法向量的数量与提供的顶点数量相匹配。虽然你可以指定不同长度的流，但这通常会导致断言被触发，并且在渲染时可能会产生意外的结果。
- en: Secondly, and perhaps most importantly, these additional streams may require
    us to add extra copies of our vertices into the vertex stream since we can only
    provide a single index stream.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，也许最重要的是，这些额外的流可能需要我们在顶点流中添加额外的顶点副本，因为我们只能提供一个索引流。
- en: Take the example of a cube where each vertex is a corner point of three different
    faces of the cube. Since each face points in a different direction, we will need
    to duplicate each vertex three times so it can be referenced in the index stream
    along with the three different normal vectors.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个立方体为例，其中每个顶点都是立方体三个不同面的角点。由于每个面指向不同的方向，我们需要将每个顶点重复三次，以便在索引流中引用，同时包含三个不同的法向量。
- en: '![Specifying a model''s color, UV, and normal streams](img/3363_04_13.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![指定模型的颜色、UV和法向量流](img/3363_04_13.jpg)'
- en: We can also run into the same problem when the UV or color at a vertex varies
    across each polygon that it forms a part of.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当顶点的UV或颜色跨越它所形成的每个多边形时，我们也会遇到相同的问题。
- en: For each different combination of color, UV, and normal we encounter, we need
    to provide an additional copy of each vertex, and therefore also an additional
    color, UV, and normal value so that all the streams are the same length.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们遇到的每种不同的颜色、UV和法线组合，我们需要提供每个顶点的额外副本，因此也需要额外的颜色、UV和法线值，以确保所有流长度相同。
- en: Performing 3D to 2D projection
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行3D到2D投影
- en: When rendering our 3D world to the display, we have to somehow convert our 3D
    model vertex data into 2D screen coordinates before we can draw anything. This
    process is called **projection** and is normally carried out using matrix mathematics
    to convert vertices between coordinate systems until we end up with screen coordinates
    that allow the triangles that make up a 3D model to be rendered on screen.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将我们的3D世界渲染到显示设备上时，我们必须以某种方式将我们的3D模型顶点数据转换为2D屏幕坐标，然后我们才能绘制任何东西。这个过程被称为**投影**，通常使用矩阵数学在坐标系之间转换顶点，直到我们得到屏幕坐标，使得构成3D模型的三角形可以在屏幕上渲染。
- en: '![Performing 3D to 2D projection](img/3363_04_14.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![执行3D到2D投影](img/3363_04_14.jpg)'
- en: The following sections provide an overview of the steps involved in projecting
    a point on to the screen to make sure you are familiar with the key concepts involved.
    A thorough explanation of the mathematics of 3D graphics is beyond the scope of
    this book, so it is expected that you will be familiar with what a matrix is,
    and with geometric operations such as rotations, scaling, and translations.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分提供了将点投影到屏幕上的步骤概述，以确保你熟悉涉及的关键概念。本书不涉及3D图形数学的详细解释，因此预期你会熟悉矩阵是什么，以及几何操作如旋转、缩放和平移。
- en: Understanding matrices for 3D graphics
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解3D图形中的矩阵
- en: Think back to school math lessons and you will hopefully remember matrices being
    described as a useful tool when trying to perform operations such as rotations,
    translations, and scaling on vectors.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下学校数学课程，你可能会记得矩阵被描述为在尝试对向量执行旋转、平移和缩放等操作时是一个有用的工具。
- en: My personal recollection about learning matrices was that they seemed slightly
    magical at the time. Here was a grid of numbers that could be used to perform
    a range of really useful geometric operations and, what's more, you could combine
    several matrices by multiplying them together to perform several operations in
    one go. The concept itself made sense, but there were so many numbers involved
    that it seemed a bit bewildering.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人对学习矩阵的记忆是，当时它们似乎有点神奇。这里有一个数字网格，可以用来执行一系列非常有用的几何操作，更重要的是，你可以通过相乘几个矩阵来一次执行多个操作。这个概念本身是合理的，但涉及到的数字太多，看起来有点令人困惑。
- en: In 3D geometry we generally use a 4 x 4 matrix, with the top left 3 x 3 grid
    of numbers representing the rotation and scaling part of the matrix, and the first
    three numbers of the bottom row representing the required translation.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在3D几何中，我们通常使用一个4x4矩阵，其中左上角的3x3数字网格代表矩阵的旋转和缩放部分，而底部第一行的前三个数字代表所需的平移。
- en: While the translation part made perfect sense to me, the 3 x 3 rotation and
    scaling part of the matrix was something I never really had a good handle on until
    the day I found out that what this part of the matrix actually represents is the
    size and direction of the x, y, and z axes.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然翻译部分对我来说完全合理，但矩阵中的3x3旋转和缩放部分是我从未真正掌握的部分，直到我发现矩阵的这一部分实际上代表的是x、y和z轴的大小和方向。
- en: 'Take a look at the following image that shows the **identity matrix** for a
    4 x 4 matrix. All this means is that every element in the matrix is `0` except
    for those in the top-left to bottom-right diagonal, which are all `1`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下图像，它显示了4x4矩阵的**单位矩阵**。这意味着矩阵中的每个元素都是`0`，除了从左上角到底右角的对角线上的元素，它们都是`1`：
- en: '![Understanding matrices for 3D graphics](img/3363_04_03.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![理解3D图形中的矩阵](img/3363_04_03.jpg)'
- en: Notice that the first three numbers on the top row are (1, 0, 0), which just
    so happens to be a unit vector along the x axis. Similarly, the second row is
    (0, 1, 0), which represents a unit vector along the y axis and the third row (0,
    0, 1) is a unit vector along the z axis.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到顶行前三个数字是（1，0，0），这恰好是一个沿着x轴的单位向量。同样，第二行是（0，1，0），它代表一个沿着y轴的单位向量，而第三行（0，0，1）是一个沿着z轴的单位向量。
- en: Once I realized this, it became much more obvious how to create matrices to
    perform different kinds of geometric operations.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我意识到这一点，创建矩阵以执行不同类型的几何操作就变得更为明显。
- en: Want a rotation around the y axis? Just work out vectors for the directions
    in which the x axis and z axis would need to lie for the desired rotation, and
    slot these into the relevant parts of the matrix. Similarly, a scale operation
    just means that we provide a non-unit-sized vector for each axis we want to scale
    along.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 想要围绕y轴旋转？只需计算出x轴和z轴需要位于的方向向量，并将这些向量放入矩阵的相关部分。同样，缩放操作只是意味着我们为每个要缩放的轴提供一个非单位大小的向量。
- en: Some of you may be reading this and thinking "that's obvious", but if this helps
    just one person to get a better understanding of how to understand matrix mathematics,
    my work is done!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一些人在阅读这篇文档时可能会想“这很明显”，但如果这能帮助至少一个人更好地理解如何理解矩阵数学，我的工作就完成了！
- en: Converting between coordinate systems
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 坐标系之间的转换
- en: When we looked at how a 3D model is represented in terms of data, we talked
    about the vertices of the model being in model space. In order to use these vertices
    for rendering, we therefore have to convert our model space vertices into screen
    coordinates.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论3D模型在数据表示中的表示时，我们提到模型的顶点位于模型空间中。因此，为了使用这些顶点进行渲染，我们必须将这些模型空间顶点转换为屏幕坐标。
- en: The first step in this process is to use a **model matrix** to convert the vertices
    from model space into **world space**. Each vertex in the model is multiplied
    by the model matrix, which will first rotate and scale the vertices so that the
    model is orientated correctly, then translate each point so that the model's pivot
    point is now at the translation provided in the matrix.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程的第一个步骤是使用**模型矩阵**将顶点从模型空间转换为**世界空间**。模型中的每个顶点都乘以模型矩阵，这将首先旋转和缩放顶点，使模型正确定位，然后平移每个点，使模型的重心现在位于矩阵中提供的平移位置。
- en: Now that all our vertices are positioned correctly in our virtual world, the
    next step is to convert them into **view space**, which is the coordinate system
    defined by the position and orientation of our viewpoint, which for obvious reasons
    is normally referred to as our camera. We do this by providing another matrix
    called the **view matrix** (or **camera matrix** if you prefer), which will rotate,
    scale, and translate the world space vertices so that they are now relative to
    our camera view.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们所有的顶点都正确地定位在我们的虚拟世界中，下一步是将它们转换为**视图空间**，这是由我们的视点的位置和方向定义的坐标系，由于显而易见的原因，通常被称为我们的相机。我们通过提供另一个称为**视图矩阵**（如果你更喜欢，也可以称为**相机矩阵**）的矩阵来完成这项工作，这个矩阵将旋转、缩放和转换世界空间顶点，使它们现在相对于我们的相机视图。
- en: With the vertices now in view space, the final operation is to convert the vertices
    into 2D screen coordinates. We have two ways of doing this, these being an **orthographic
    projection** or a **perspective projection**.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在顶点已经位于视图空间中，最后的操作是将顶点转换为2D屏幕坐标。我们有两种方法来做这件事，这包括**正射投影**或**透视投影**。
- en: An orthographic projection takes the view space coordinates and just scales
    and translates the x and y components of each vertex to put them onto the screen.
    The z component of the vertex plays no part in calculating the actual screen coordinates
    but it is used for working out the drawing order of polygons since it is used
    as a depth value.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正射投影将视图空间坐标仅缩放并平移每个顶点的x和y分量，将它们放置到屏幕上。顶点的z分量在计算实际屏幕坐标时不起作用，但它用于确定多边形的绘制顺序，因为它用作深度值。
- en: However, in most cases we use a perspective projection. Again the x and y components
    of each view space vertex are used to generate the x and y screen coordinates,
    but this time they are divided by the z component of the vertex, which has the
    effect of making objects that are further away appear smaller.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在大多数情况下，我们使用透视投影。同样，每个视图空间顶点的x和y分量用于生成x和y屏幕坐标，但这次它们被顶点的z分量除以，这会使远离物体的物体看起来更小。
- en: The components are also multiplied by a constant value called the **perspective
    multiplier** . This value is actually the distance at which the **view plane**
    lies from the camera. The view plane is the plane which contains the rectangular
    area of the screen display.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这些分量还乘以一个称为**透视乘数**的常数。这个值实际上是视图平面距离相机的距离。视图平面是包含屏幕显示矩形区域的平面。
- en: 'Normally, when we think about a camera view it is more convenient to think
    about the **field of view**, which is the horizontal angle of our viewing cone.
    The following diagram shows how we can convert this angle into the correct perspective
    multiplier value:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们思考相机视图时，更方便的是考虑**视野**，即我们观察锥体的水平角度。以下图示显示了如何将这个角度转换为正确的透视乘数值：
- en: '![Converting between coordinate systems](img/3363_04_04.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![坐标系统之间的转换](img/3363_04_04.jpg)'
- en: The next part of perspective projection is to translate the projected point.
    Normally we want a point that is directly in front of the camera to be in the
    center of the screen, so we would add an offset of half the screen width to the
    x component and half the screen height to the y-component. It is possible to specify
    a different offset position, which is particularly useful if we ever want to display
    a 3D model as part of a game's user interface. Let's say you wanted to draw a
    3D model of a collectable object that the player has just picked up at the top
    right of the screen. Specifying the offset to be this screen position is much
    easier than trying to calculate a position in 3D space relative to the camera
    position that equates to the required area of the screen.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 投影透视的下一部分是将投影点进行转换。通常我们希望位于相机正前方的点显示在屏幕中心，因此我们会将屏幕宽度的一半加到x分量上，将屏幕高度的一半加到y分量上。可以指定不同的偏移位置，这在我们需要在游戏用户界面中显示3D模型时特别有用。假设你想要在屏幕右上角绘制一个玩家刚刚捡起的可收集对象的3D模型。指定这个屏幕位置的偏移比尝试计算相对于相机位置的3D空间中的位置要容易得多，这个位置等同于所需的屏幕区域。
- en: Clipping planes
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 裁剪平面
- en: We've already discussed the view plane as being the plane which contains the
    final screen display, but there are some further planes which are used to help
    speed up rendering and also avoid some strange graphical glitches from occurring.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了视图平面作为包含最终屏幕显示的平面，但还有一些其他平面用于帮助加速渲染并避免一些奇怪的图形错误发生。
- en: First we have the **far clip plane** and the **near clip plane**, which lie
    parallel to the view plane. We tell Marmalade where we want these planes to reside
    by supplying the perpendicular distance of these planes from the camera view point.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有**远裁剪平面**和**近裁剪平面**，它们与视图平面平行。我们通过提供这些平面与相机视点的垂直距离来告诉Marmalade这些平面应该位于何处。
- en: The far clip plane prevents polygons that are too far away from the camera from
    being rendered, while the near clip plane, unsurprisingly, prevents polygons that
    are too close to the camera from being rendered. The near clip plane is particularly
    important because if we were not to use it we would start to see models that lie
    behind the camera being rendered on screen.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 远裁剪平面阻止距离相机太远的多边形被渲染，而近裁剪平面，不出所料，阻止距离相机太近的多边形被渲染。近裁剪平面尤其重要，因为我们如果不使用它，就会开始看到位于相机后面的模型在屏幕上被渲染。
- en: 'You should generally try to keep the far and near clip planes as close together
    as possible, as these values are also used for calculating depth buffer values.
    If the planes are too far apart, you can start to encounter render issues that
    are sometimes called **shimmering** or **Z-fighting**. These can occur when there
    is not enough resolution in the depth buffer values, which results in far distance
    polygons rendering with jagged edges or worse still, randomly poke through each
    other as they or the camera are moved. The following image shows another example
    of Z-fighting that can occur when trying to render two overlapping co-planar polygons:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常应该尽量使远裁剪平面和近裁剪平面尽可能靠近，因为这些值也用于计算深度缓冲区值。如果平面相隔太远，你可能会开始遇到被称为**闪烁**或**Z冲突**的渲染问题。这些问题可能发生在深度缓冲区值分辨率不足时，导致远距离多边形渲染时边缘参差不齐，或者更糟糕的是，当它们或相机移动时，会随机穿透彼此。以下图像显示了尝试渲染两个重叠的共面多边形时可能发生的另一种Z冲突示例：
- en: '![Clipping planes](img/3363_04_15.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![裁剪平面](img/3363_04_15.jpg)'
- en: There are also four more clipping planes named left, right, top, and bottom.
    These are planes which pass through the camera position and one of the left, right,
    top, or bottom borders of the screen display area on the view plane. Together
    they form a pyramid-shaped volume that emanates from the camera and defines the
    part of 3D space that is visible and could therefore appear on screen.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 还有四个名为左、右、上和下的裁剪平面。这些是通过相机位置和屏幕显示区域在视平面上的左、右、上或下边界的平面。它们共同形成一个金字塔形体积，从相机发出，定义了3D空间中可见的部分，因此可以出现在屏幕上。
- en: The clipping planes are managed automatically for us by Marmalade, and they
    are very useful as they allow us to quickly reject an entire model from being
    submitted for rendering if it is completely off screen. The off-screen check is
    performed using a bounding sphere for the model we are rendering, which is simply
    a sphere centered at the model's pivot point that encompasses all the vertices
    of the model. The bounding sphere can be quickly tested against all six clip planes
    and the model can be skipped if the bounding sphere is completely outside the
    clipping volume.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Marmalade自动为我们管理裁剪平面，它们非常有用，因为它们允许我们快速拒绝整个模型提交渲染，如果该模型完全在屏幕之外。离屏检查是通过我们正在渲染的模型的边界球体来执行的，这只是一个以模型的重心为中心，包含模型所有顶点的球体。边界球体可以快速与所有六个裁剪平面进行测试，如果边界球体完全在裁剪体积之外，则可以跳过该模型。
- en: Lighting
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 光照
- en: To finish up our 3D primer, let's take a quick look at how real-time lighting
    is achieved. We won't dwell on the mathematics of it all, since Marmalade mostly
    takes care of this for us, so instead we'll just explain the different types of
    lighting we can take advantage of.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的3D入门，让我们快速看一下实时光照是如何实现的。我们不会过多关注其数学原理，因为Marmalade主要为我们处理这些，所以我们将只解释我们可以利用的不同类型的光照。
- en: Each of the lighting types we are about to discuss can be enabled or disabled
    whenever you want. Disabling different lighting types can yield faster render
    times.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的每种光照类型都可以随时启用或禁用。禁用不同的光照类型可以缩短渲染时间。
- en: Emissive lighting
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发光光照
- en: The simplest type of lighting Marmalade provides is **emissive lighting**, which
    is little more than the amount of color that a rendered polygon will naturally
    have. The emissive lighting color is provided by the `CIwMaterial` instance that
    is set when rendering the polygon.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Marmalade提供的最简单类型的光照是**发光光照**，它只是渲染多边形自然具有的颜色量。发光光照颜色由设置在渲染多边形时的`CIwMaterial`实例提供。
- en: Emissive lighting is useful if you want to draw polygons in a single flat color,
    but normally we want a bit more flexibility than that, so we might set a color
    stream instead, or use one of the other forms of lighting.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 发光光照对于想要用单一纯色绘制多边形很有用，但通常我们希望有更多的灵活性，因此我们可能会设置一个颜色流，或者使用其他光照形式之一。
- en: Ambient lighting
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 环境光照
- en: '**Ambient lighting** provides the background level of light in our scene, such
    as the light which might be provided by the Sun.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**环境光照**为我们场景中的背景光水平提供光源，例如可能由太阳提供的光。'
- en: Without ambient lighting, any polygon that is not facing a light source directly
    would have very little light applied to it and so would appear black. Normally
    this is not very desirable, so we can use ambient lighting to provide a base level
    of color and brightness to our polygons.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 没有环境光照，任何不是直接面向光源的多边形将几乎没有光照，因此会显得是黑色的。通常这不是非常理想，因此我们可以使用环境光照为我们的多边形提供一个基本的颜色和亮度水平。
- en: In Marmalade, we set a global ambient lighting term as an RGB color. The `CIwMaterial`
    instance used when rendering also has an ambient light value that is combined
    with the global ambient light. If the material ambient light is set to bright
    white, the polygon will be rendered with the full amount of the global ambient
    light.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在Marmalade中，我们将全局环境光照项设置为RGB颜色。在渲染时使用的`CIwMaterial`实例也具有一个与环境光照结合的环境光照值。如果材质的环境光照设置为亮白色，多边形将以全局环境光照的全部量进行渲染。
- en: If the global ambient lighting is disabled, the material ambient color is used
    directly to control the color of the rendered polygons. This provides an easy
    way of brightening or darkening a model at rendering time.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果全局环境光照被禁用，则直接使用材质的环境颜色来控制渲染多边形的颜色。这提供了一种在渲染时轻松调整模型亮度和暗度的简单方法。
- en: Diffuse lighting
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 漫反射光照
- en: In order to use **diffuse lighting** our model data must provide a normal stream.
    A diffuse light comprises of both a color and a direction in which the light is
    pointing. The light's direction vector is combined with the normal vector for
    each vertex in the model using the dot product operation.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用**漫射照明**，我们的模型数据必须提供一个法线流。漫射光由颜色和光指向的方向组成。光的方向向量通过点积运算与模型中每个顶点的法线向量相结合。
- en: The result of the dot product operation is multiplied by the global diffuse
    lighting color and the current `CIwMaterial` diffuse color or the RGB value from
    the color stream, if one has been provided. This will yield the final color value
    that is used when rendering the polygon to the screen.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 点积运算的结果乘以全局漫射照明颜色和当前的`CIwMaterial`漫射颜色或颜色流中的RGB值（如果提供了的话）。这将产生用于将多边形渲染到屏幕上的最终颜色值。
- en: Specular lighting
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 镜面照明
- en: As with diffuse lighting, **specular lighting** can only work if we have provided
    a normal stream. It also needs a diffuse light to be specified as it relies on
    the direction of the diffuse light.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 与漫射照明一样，**镜面照明**只能在我们提供了法线流的情况下工作。它还需要指定漫射光，因为它依赖于漫射光的方向。
- en: This type of lighting allows us to make a model appear shinier by causing it
    to briefly become brighter when it is facing the direction of the diffuse light.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的照明使我们能够通过使模型在面向漫射光的方向上暂时变亮，使其看起来更亮。
- en: We can specify both a global and a specular light color specific to `CIwMaterial`,
    and additionally the material also provides a setting for the **specular power**
    . This value allows us to narrow down the response of the specular lighting. A
    higher number means that the vertex normal must be almost parallel to the lighting
    direction before the specular lighting will take effect.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为`CIwMaterial`指定全局和镜面光颜色，并且材料还提供了一个**镜面功率**的设置。此值允许我们缩小镜面照明的响应。数值越高，顶点法线必须几乎与照明方向平行，镜面照明才会生效。
- en: Using IwGx to render 3D graphics
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用IwGx渲染3D图形
- en: Remember when we were looking at 2D graphics rendering in [Chapter 2](ch02.html
    "Chapter 2. Resource Management and 2D Graphics Rendering"), *Resource Management
    and 2D Graphics Rendering*, I said we would be using IwGx because it would make
    the transition to rendering 3D graphics that much easier. Now's the time to see
    if my claim was true!
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们在[第二章](ch02.html "第二章。资源管理和二维图形渲染")“资源管理和二维图形渲染”中查看二维图形渲染时，我说我们将使用IwGx，因为它会使过渡到渲染三维图形变得容易得多。现在是时候看看我的说法是否正确了！
- en: In this section, we shall look at how we can implement the 3D equivalent of
    the "Hello World" program—a spinning cube.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何实现“Hello World”程序的3D等效——一个旋转的立方体。
- en: Preparing IwGx for 3D rendering
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为3D渲染准备IwGx
- en: As with 2D rendering, the very first thing we need to do is initialize the IwGx
    API by calling `IwGxInit`, and of course we should call `IwGxTerminate` at the
    end of our program.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 与二维渲染一样，我们首先需要做的事情是通过调用`IwGxInit`初始化IwGx API，当然，我们应在程序结束时调用`IwGxTerminate`。
- en: 'With IwGx ready to go we next need to set up our projection. We''re going to
    be using a perspective projection, so we need to be able to specify the perspective
    multiplier value that we want to use. The code to do this is as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当IwGx准备就绪后，我们接下来需要设置投影。我们将使用透视投影，因此我们需要能够指定我们想要使用的透视乘数值。执行此操作的代码如下：
- en: '[PRE0]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This line of code sets the perspective multiplier up, to provide a 90 degree
    field of view. See the section *Converting Between Coordinate Systems* earlier
    in this chapter for more information on how to calculate the required perspective
    multiplier value.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码设置了透视乘数，以提供90度的视野。请参阅本章前面的*坐标系统转换*部分，了解更多关于如何计算所需的透视乘数值的信息。
- en: 'Next we have to set the far and near clipping planes'' distances. For our demo
    purposes we''ll choose a value of `10` for the near plane and `1000` for the far
    plane; these values are set as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须设置远裁剪面和近裁剪面的距离。为了我们的演示目的，我们将近平面设置为`10`，远平面设置为`1000`；这些值设置如下：
- en: '[PRE1]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These values are in view space units and can be set to any value greater than
    zero (the far value should be greater than the near value too!) that works well
    for the needs of our game. Normally it is the far clip distance that is most important,
    as it needs to be set far enough out that our world is rendered satisfactorily,
    but not so far that the frame rate suffers because we are rendering too much.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值在视图空间单位中，可以设置为任何大于零的值（远值应大于近值！）以适应我们游戏的需求。通常，远裁剪距离是最重要的，因为它需要设置得足够远，以便我们的世界能够满意地渲染，但又不能太远，以免帧率下降，因为我们渲染了太多的内容。
- en: Note
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may be wondering why these numbers have been written as `10.0f` and not
    just 10 or 10.0? The reason is to ensure that the compiler treats these values
    as a single precision `float` value. The latter two forms will both be interpreted
    as a `double` and this can lead to a time consuming conversion from `double` to
    `float`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么这些数字被写成 `10.0f` 而不是只是10或10.0？原因是确保编译器将这些值视为单精度 `float` 值。后两种形式都将被解释为
    `double`，这可能导致从 `double` 到 `float` 的耗时转换。
- en: Setting lighting information
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置照明信息
- en: In order to make our spinning cube look a little more attention grabbing, we'll
    set up some lights so that as the cube spins its faces change color accordingly.
    The lighting support provided by Marmalade may look a little limited, but is generally
    adequate for most mobile games' needs.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的旋转立方体看起来更有吸引力，我们将设置一些光源，以便当立方体旋转时，其表面颜色相应地改变。Marmalade提供的照明支持可能看起来有点有限，但通常足以满足大多数移动游戏的需求。
- en: Marmalade only allows us to define a single ambient light and a single diffuse
    light. Let's start by setting the global ambient lighting value.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Marmalade只允许我们定义一个环境光和一个漫反射光。让我们首先设置全局环境光照值。
- en: The first function we call is `IwGxSetLightType`, which takes an ID number to
    identify the light we wish to modify and a definition describing the type of light
    we are specifying. Presumably this API has been chosen so that Marmalade can easily
    be made to support more lights in the future, but for now the ID number can only
    be zero or one, and the light type must be one of `IW_GX_LIGHT_AMBIENT`, `IW_GX_LIGHT_DIFFUSE`,
    or `IW_GX_LIGHT_UNUSED`. The latter value can be used to disable the light.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先调用的第一个函数是 `IwGxSetLightType`，它接受一个ID数字来标识我们想要修改的光，以及一个描述我们指定光类型的定义。这个API可能被选择是为了让Marmalade能够轻松地支持更多的光源，但到目前为止，ID数字只能是零或一，光类型必须是
    `IW_GX_LIGHT_AMBIENT`、`IW_GX_LIGHT_DIFFUSE` 或 `IW_GX_LIGHT_UNUSED` 之一。后者值可以用来禁用光源。
- en: With the type of light taken care of, we set the color of light using the function
    call `IwGxSetLightCol`. There are two versions of this function. Both take the
    ID of the light we wish to modify, but the RGB color of the light can either be
    specified as three `uint8` values for red, green, and blue, or a pointer to a
    `CIwColour` instance can be supplied instead.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完光类型后，我们使用函数调用 `IwGxSetLightCol` 来设置光的颜色。这个函数有两个版本。两者都接受我们想要修改的光的ID，但光的RGB颜色可以是三个
    `uint8` 值（红色、绿色和蓝色），或者可以提供一个指向 `CIwColour` 实例的指针。
- en: 'The following code sets the light with ID zero to be an ambient light with
    a mid-grey color:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将ID为零的光源设置为具有中等灰色颜色的环境光：
- en: '[PRE2]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now let''s create a diffuse light with a specular highlight. We''ll need two
    additional functions to do this, `IwGxSetLightSpecularCol` to set the color of
    the specular highlight, and `IwGxSetLightDirn` to set the direction in which the
    light is pointing. The direction is specified as a unit vector in terms of world
    space coordinates. Here''s some code to illustrate this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来创建一个具有漫反射光和镜面高光的光源。为此，我们需要两个额外的函数，`IwGxSetLightSpecularCol` 用于设置镜面高光的颜色，以及
    `IwGxSetLightDirn` 用于设置光的方向。方向是以世界空间坐标为单位指定的单位向量。以下是一些示例代码：
- en: '[PRE3]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code snippet sets up the light ID one to be a diffuse light with mid-grey
    intensity and a brighter grey specular highlight. The light is pointing at a 45
    degree angle between the x and z axes of the world.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码片段设置了ID为1的光源，使其成为一个具有中等灰色强度和更亮灰色镜面高光的漫反射光。光源指向世界坐标系的x和z轴之间的45度角。
- en: 'Our lights have now been initialized, so all that is left to do is let Marmalade
    know we want to switch them on! There are a number of functions available to allow
    us to do this. We can either use `IwGxLightingOn` and `IwGxLightingOff` to enable
    or disable all the initialized light sources, or we can enable each part of the
    lighting model independently. The following example code disables emissive lighting
    but enables ambient, diffuse, and specular lighting:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的光源现在已经初始化完成，所以剩下的就是通知Marmalade我们要打开它们！为此，我们有多个函数可供选择。我们可以使用`IwGxLightingOn`和`IwGxLightingOff`来启用或禁用所有已初始化的光源，或者我们可以独立地启用照明模型的每个部分。以下示例代码禁用了发射性照明，但启用了环境、漫反射和镜面照明：
- en: '[PRE4]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Since we are using specular lighting, there is one more thing to do. The material
    that is used to render our polygons must have a specular color and power specified.
    The material''s specular color is used to modulate the global specular color,
    while the power value indicates how close the vertex normal must be to the light
    direction for the specular highlight to kick in. The power value is a `uint8`
    value and only very low values (that is, less than 8) produce notable differences
    in the rendered effect. Here is the code to illustrate this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用的是镜面照明，还有一件事要做。用于渲染我们的多边形的材质必须指定一个镜面颜色和功率。材质的镜面颜色用于调制全局镜面颜色，而功率值表示顶点法线必须接近光方向的程度，以便启动镜面高光。功率值是一个`uint8`值，只有非常低的值（即小于8）才能在渲染效果中产生明显的差异。以下是说明这一点的代码：
- en: '[PRE5]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The previous examples are just making use of Marmalade's built-in lighting model
    since it is easy to use and works well enough for most needs. However, there is
    absolutely no reason we have to use this lighting model, as there is nothing stopping
    us from generating our own color stream using whatever lighting algorithm we want
    to use. Alternatively we could employ OpenGL ES 2.0 shaders, although discussion
    of this particular topic is beyond the scope of this book.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子只是利用了Marmalade的内置照明模型，因为它易于使用，并且对于大多数需求来说效果足够好。然而，我们完全没有必要使用这个照明模型，因为我们没有任何阻止我们使用我们想要的任何照明算法来生成自己的颜色流。或者，我们也可以使用OpenGL
    ES 2.0着色器，尽管关于这个特定主题的讨论超出了本书的范围。
- en: Model data for the cube
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 立方体的模型数据
- en: We're going to render a lit cube with a different color on each face, so we
    need to provide some data streams for the vertices, colors, and normals, and an
    index stream to show how this data should be interpreted by the rendering engine.
    Since we are not using textures in this example, there is no need to provide a
    UV stream.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将渲染一个带有每个面不同颜色的光照立方体，因此我们需要提供顶点、颜色和法线的数据流，以及一个索引流来显示这些数据应该如何被渲染引擎解释。由于在这个例子中我们没有使用纹理，因此不需要提供UV流。
- en: We also want to be as efficient as possible in our drawing, so our aim is to
    draw the entire cube with just a single call to `IwGxDrawPrims`. To do so we'll
    need to have three copies of each vertex (one for each face that the vertex is
    part of) so we can assign different colors and normals to it, and we'll also need
    to specify some degenerate triangles in our index stream to join all the faces
    together into one big triangle strip.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望我们的绘图尽可能高效，因此我们的目标是只用一次`IwGxDrawPrims`调用来绘制整个立方体。要做到这一点，我们需要每个顶点有三个副本（每个顶点所属的每个面一个），这样我们就可以为它分配不同的颜色和法线，我们还需要在我们的索引流中指定一些退化三角形，以便将所有面连接成一个大的三角形带。
- en: Let's start with the vertex stream. We allocate an array of `CIwFVec3` and initialize
    it with the vertex data. The cube pivot point will be dead center, so all the
    vertex coordinates will have the same magnitude.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从顶点流开始。我们分配一个`CIwFVec3`数组，并用顶点数据初始化它。立方体的中心点将是正中心，因此所有顶点坐标将具有相同的幅度。
- en: '[PRE6]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The vertices have been ordered a face at a time, so the first four vertices
    form the front of the cube, the next four the right hand face, and so on. You
    are free to specify the order however you see fit, since ultimately it will be
    the index stream that determines how the individual triangles will be rendered.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点是按面顺序排列的，所以前四个顶点形成立方体的前面，接下来的四个形成右手面，依此类推。你可以自由地指定顺序，因为最终是索引流将决定单个三角形的渲染方式。
- en: 'Now we''ll create the normal stream. Normals in Marmalade are also specified
    as instances of `CIwFVec3`, and they are expected to have unit length. This means
    that the magnitude of the vector should be one. Here''s a code snippet that will
    do the job:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建法线流。在Marmalade中，法线也被指定为`CIwFVec3`实例，并且它们应该具有单位长度。这意味着向量的模长应该是一。下面是一个执行此任务的代码片段：
- en: '[PRE7]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now we need a color stream. Just as with 2D rendering, this requires an array
    of `CIwColour` instances. Here comes the code snippet!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一个颜色流。就像在2D渲染中一样，这需要一个`CIwColour`实例的数组。下面是代码片段！
- en: '[PRE8]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, it''s time for the index stream to be created. Again, as with 2D rendering,
    this is just an array of `uint16` values which indicate the order in which elements
    of the streams should be accessed. Here''s the code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是创建索引流的时候了。同样，就像在2D渲染中一样，这只是一个`uint16`值的数组，它指示了流中元素应该被访问的顺序。下面是代码：
- en: '[PRE9]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note than the first four values in the stream define the first full face of
    the cube. The next two values form a degenerate triangle that allows us to link
    the first face to the second face without actually rendering anything. As we saw
    earlier in this chapter, the easiest way to link two triangle strips is to repeat
    the last index of the first strip and start the next strip with two copies of
    its first index. This pattern continues until we've drawn the last face of the
    cube.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，流中的前四个值定义了立方体的第一个完整面。接下来的两个值形成一个退化三角形，它允许我们将第一个面与第二个面连接起来，而实际上并不渲染任何内容。正如我们在本章前面看到的，将两个三角形带连接起来的最简单方法是将第一个带的最后一个索引重复，并以它的第一个索引的两个副本开始下一个带。这种模式一直持续到我们绘制了立方体的最后一个面。
- en: The order in which the vertices are specified is the most important consideration,
    as we must ensure we get this correct for the culling mode we'll be using. For
    back-face culling (so faces that are away from the camera are not rendered) we
    need the vertex order to be in anti-clockwise order for the first triangle specified.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 规定顶点的顺序是最重要的考虑因素，因为我们必须确保我们得到正确的裁剪模式。对于背面裁剪（即远离相机的面不会被渲染），我们需要第一个指定的三角形顶点的顺序为逆时针。
- en: As we are using triangle strips, the order of the vertices actually alternates
    between anti-clockwise and clockwise. Normally we don't have to worry about this
    too much since the natural order of the vertices in the strip takes care of it,
    but it can cause problems when you try to join together triangle strips that contain
    an odd number of vertices.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用三角形带，顶点的顺序实际上在逆时针和顺时针之间交替。通常我们不必太担心这一点，因为带中顶点的自然顺序会处理它，但当你尝试将包含奇数个顶点的三角形带连接起来时，这可能会引起问题。
- en: Note
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The general rule for joining triangle strips with degenerate triangles is that
    a strip with an odd number of points will require the order of the points in the
    next strip to be reversed. For example, if your first triangle strip contains
    an odd number of points, the first triangle of the next strip will need to be
    specified in clockwise rather than anti-clockwise order; otherwise it will not
    be culled correctly.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 将三角形带与退化三角形连接的一般规则是，具有奇数个点的带需要反转下一个带中点的顺序。例如，如果你的第一个三角形带包含奇数个点，下一个带的第一个三角形需要按顺时针而不是逆时针顺序指定；否则它将不会被正确裁剪。
- en: The view matrix
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图矩阵
- en: When rendering 3D graphics, we need to be able to provide a position and direction
    that we want to view our game world from. We do this by supplying a view or camera
    matrix; in Marmalade this can be done using an instance of the `CIwFMat` class.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染3D图形时，我们需要能够提供我们想要从哪个位置和方向查看游戏世界的信息。我们通过提供视图或相机矩阵来实现这一点；在Marmalade中，可以使用`CIwFMat`类的实例来完成。
- en: The `CIwFMat` class represents a 4 x 4 matrix using a 3 x 3 array of `float`
    for the rotation part, and `CIwFVec3` for the translation part. The remaining
    elements of the 4 x 4 matrix (that is, the right-most column of numbers) are fixed
    to be the same as the identity matrix (0, 0, 0, and 1 from top to bottom of the
    column). These values never have any influence on normal 3D transformations; so
    by leaving them out we save memory, and also the matrix multiplication code can
    be made slightly more efficient by not having to perform multiplications for these
    parts of the matrix.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`CIwFMat` 类使用一个 3 x 3 的 `float` 数组来表示旋转部分，以及 `CIwFVec3` 来表示平移部分，来表示一个 4 x 4
    矩阵。4 x 4 矩阵的其余元素（即最右侧的数字列）被固定为与单位矩阵相同（从列的顶部到底部依次为 0, 0, 0, 和 1）。这些值对正常的 3D 变换没有任何影响；因此，通过省略它们，我们可以节省内存，并且可以通过不执行这些矩阵部分的乘法来使矩阵乘法代码稍微更高效。'
- en: 'Time to create a suitable view matrix. For the purposes of our spinning cube,
    it would be good if we could specify a position for the camera and then calculate
    the correct rotation for the matrix to view our cube. Luckily the matrix classes
    have a method called `LookAt` that makes this easy to do:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候创建一个合适的视图矩阵了。为了我们旋转立方体的目的，如果我们能够指定摄像机的位置，然后计算矩阵的正确旋转来查看我们的立方体，那将很好。幸运的是，矩阵类有一个名为
    `LookAt` 的方法，这使得这变得容易实现：
- en: '[PRE10]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The previous code declares a new `CIwMat` instance and sets its translation
    to (0, 0, -400). We then call the `LookAt` method, which is passed the position
    we want the camera to be placed at, the point in space we want it to be orientated
    towards, and a unit vector in the vertically up direction.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码声明了一个新的 `CIwMat` 实例，并将其平移设置为 (0, 0, -400)。然后我们调用 `LookAt` 方法，该方法传递我们想要放置摄像机的位置，我们想要它朝向的空间中的点，以及垂直向上的单位向量。
- en: Marmalade's default coordinate system when rendering in 3D has the x axis positive
    direction running from left to right across the screen, while the z axis positive
    direction runs into the screen. However, the positive y axis runs in a direction
    from the top of the screen to the bottom, which may not be what you initially
    expect. We are used to thinking about the height above the ground as a positive
    number, but in Marmalade it would be negative.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Marmalade 在 3D 渲染时的默认坐标系中，x 轴的正方向从屏幕的左侧到右侧运行，而 z 轴的正方向进入屏幕。然而，正 y 轴的方向是从屏幕顶部到底部，这可能不是你最初预期的。我们习惯于将地面以上的高度视为正数，但在
    Marmalade 中，它将是负数。
- en: Once we have a view matrix, we can call the function `IwGxSetViewMatrix` with
    a `const` pointer to the matrix.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了视图矩阵，我们就可以使用一个指向矩阵的 `const` 指针调用函数 `IwGxSetViewMatrix`。
- en: The model matrix
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型矩阵
- en: The model matrix is used to position our 3D model in the world and allow it
    to be rotated or scaled as desired. As with the view matrix, the model matrix
    can be specified using a `CIwFMat` instance.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 模型矩阵用于在世界上定位我们的 3D 模型，并允许它按需旋转或缩放。与视图矩阵一样，可以使用 `CIwFMat` 实例指定模型矩阵。
- en: For our spinning cube we will create a matrix that spins the cube around the
    x and y axes. We do this by creating two matrices, one for x axis rotation and
    another for y axis rotation, which we then multiply together. We will be positioning
    our cube at the world origin.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的旋转立方体，我们将创建一个矩阵，使立方体围绕 x 和 y 轴旋转。我们通过创建两个矩阵来实现这一点，一个用于 x 轴旋转，另一个用于 y 轴旋转，然后将它们相乘。我们将立方体定位在世界的原点。
- en: '[PRE11]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The code shown declares two instances of `CIwFMat` and uses the methods `SetRotY`
    and `SetRotX` to generate the rotation matrices around the y and x axes respectively.
    The rotation angles are provided by two variables `lRotationY` and `lRotationX`,
    which are both of the type `float` and represent an angle (in radians) to rotate
    by. If we increase the values of these two variables with each iteration of the
    main game loop, it will change the orientation of the cube and make it appear
    to rotate when rendered.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 显示的代码声明了两个 `CIwFMat` 实例，并使用 `SetRotY` 和 `SetRotX` 方法生成围绕 y 和 x 轴的旋转矩阵。旋转角度由两个变量
    `lRotationY` 和 `lRotationX` 提供，这两个变量都是 `float` 类型，表示旋转的角度（以弧度为单位）。如果我们增加这两个变量的值，每次主游戏循环迭代，它将改变立方体的方向，使其在渲染时看起来在旋转。
- en: Note
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Be careful when using the `SetRotX`, `SetRotY`, and `SetRotZ` methods of the
    matrix classes. These methods take two further `bool` parameters that allow the
    translation part of the matrix and any elements of the 3 x 3 rotation part of
    the matrix that are not used in the rotation to be zeroed. Both of these parameters
    default to `true`; so, in particular, if you set up a translation in the matrix
    before calling one of these methods, it will get lost unless you specify `false`
    as the second parameter.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用矩阵类的 `SetRotX`、`SetRotY` 和 `SetRotZ` 方法时要小心。这些方法接受两个额外的 `bool` 参数，允许将矩阵的平移部分以及矩阵
    3x3 旋转部分中未使用的任何元素置零。这两个参数默认为 `true`；因此，特别是如果你在调用这些方法之前在矩阵中设置了平移，除非你指定第二个参数为 `false`，否则它将会丢失。
- en: Once we have our two rotation matrices, we multiply them together to generate
    the final model matrix using the `PreMult` method. The order in which matrices
    are multiplied together is very important as the end rotation will vary depending
    on the order used. Marmalade provides us with `PreMult` and `PostMult` methods
    to allow us to determine whether the calling matrix is the first matrix or the
    second in the multiplication.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了两个旋转矩阵，我们就可以使用 `PreMult` 方法将它们相乘以生成最终的模型矩阵。矩阵相乘的顺序非常重要，因为最终的旋转将取决于使用的顺序。Marmalade
    提供了 `PreMult` 和 `PostMult` 方法，使我们能够确定调用矩阵是乘法中的第一个矩阵还是第二个。
- en: When we have our model matrix ready, we just call `IwGxSetModelMatrix` to use
    it for rendering.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们准备好模型矩阵后，只需调用 `IwGxSetModelMatrix` 函数来用于渲染。
- en: Rendering the model
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型渲染
- en: 'All the hard work is now done and we can finally submit our cube for rendering.
    The following code will submit all our streams and our cube will be rendered.
    Hopefully you''ll see just how close it is to the code we used for rendering in
    2D:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 所有艰苦的工作现在都完成了，我们最终可以提交我们的立方体进行渲染。以下代码将提交所有流，我们的立方体将被渲染。希望你会看到它与我们用于 2D 渲染的代码是多么接近：
- en: '[PRE12]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Using a 3D modeling package to create model data
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 3D 建模包创建模型数据
- en: We've seen how to create the streams of data for a cube in code, and to be honest
    it's not pretty! Even a simple shape such as a cube requires so much data that
    it becomes very difficult for us to keep track of it all and almost impossible
    to create a more complex 3D shape.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何在代码中创建立方体的数据流，坦白说它并不美观！即使是像立方体这样简单的形状也需要如此多的数据，以至于我们很难跟踪所有这些数据，几乎不可能创建一个更复杂的
    3D 形状。
- en: Luckily there is an easier way. We can use a 3D modeling package to create,
    color, and texture a 3D model and export all the required data in a format that
    Marmalade can then load and use.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个更简单的方法。我们可以使用 3D 建模包来创建、着色和纹理 3D 模型，并将所有所需数据导出为 Marmalade 可以加载和使用的格式。
- en: The Marmalade 3D exporter plugins
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Marmalade 3D 导出插件
- en: Marmalade comes with exporter plugins for the two modeling packages used in
    most professional game development studios—Maya and 3DS Max. The details in the
    following sections apply equally to the exporters for both of these modeling packages.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Marmalade 随带提供了用于大多数专业游戏开发工作室中使用的两个建模包——Maya 和 3DS Max 的导出插件。以下各节中的详细信息同样适用于这两个建模包的导出插件。
- en: Installing the plugins
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装插件
- en: 'The exporter plugins are installed to your computer when you install the main
    SDK, but they are not automatically installed into the modeling package for use.
    In order to use the exporters, we must use the **Marmalade Launch Pad** program
    to set them up, as shown in the following steps:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当你安装主 SDK 时，导出插件会被安装到你的电脑上，但它们不会自动安装到建模包中以供使用。为了使用导出插件，我们必须使用 **Marmalade Launch
    Pad** 程序来设置，如下步骤所示：
- en: Start the **Marmalade LaunchPad** program. On Windows it can be found inside
    the **Marmalade** folder in the **Start** menu. You should see a window appear,
    containing a tabbed view.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 **Marmalade LaunchPad** 程序。在 Windows 上，它可以在 **开始** 菜单中的 **Marmalade** 文件夹内找到。你应该会看到一个窗口出现，其中包含一个标签页视图。
- en: Click on the tab labeled **Install Exporters**. The following screen shown should
    appear:![Installing the plugins](img/3363_04_05.jpg)
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击标签页上标记为 **安装导出插件** 的选项。以下屏幕应显示：![安装插件](img/3363_04_05.jpg)
- en: Use the tabs on this screen to select the version of the 3D modeling package
    you want to install. You must choose both the correct version of your package
    and whether it is a 32-bit or 64-bit installation. Maya 7.0 and 3DS Max 8.0 are
    the oldest supported versions. The older versions of the exporters are contained
    in the tabs labeled **Maya 32bit Legacy** and **Max 32bit legacy**.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用此屏幕上的选项卡选择您想要安装的3D建模软件版本。您必须选择您软件的正确版本，以及它是32位还是64位安装。Maya 7.0和3DS Max 8.0是最早支持的版本。旧版本的导出器包含在标记为**Maya
    32bit Legacy**和**Max 32bit legacy**的选项卡中。
- en: Click on the **Install…** button next to the required version of your modeling
    package and the exporter will be installed. Windows User Account Control will
    probably pop up a request first to ensure you want to proceed, so just click the
    **Yes** button in this dialog.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击所需建模软件版本旁边的**安装…**按钮，导出器将被安装。Windows用户账户控制可能会首先弹出一个请求，以确保您想要继续，所以只需在此对话框中点击**是**按钮。
- en: Exporting a model
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导出模型
- en: With the plugin installed, start up your 3D modeling package and create or load
    a model that you wish to export. Since this is a coding book, we won't be going
    into any details about how to create a 3D model.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 安装插件后，启动您的3D建模软件并创建或加载您想要导出的模型。由于这是一本编程书籍，我们不会详细介绍如何创建3D模型。
- en: Note
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are a programmer by trade and have no idea how to use a 3D modeling package,
    don't feel bad. I have seen some truly terrible "programmer art" over the years;
    so think of this lack of knowledge as a good thing and get a real artist involved
    in making the artwork for your game. You'll be glad you did!
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是从事编程工作且对如何使用3D建模软件毫无头绪，请不要感到难过。多年来，我见过一些真正糟糕的“程序员艺术”作品；所以，将这种知识的缺乏视为一件好事，并让真正的艺术家参与到您游戏的艺术作品中来。您会为您的决定感到高兴的！
- en: 'Assuming you have a 3D model ready to export, let''s get the Marmalade exporter
    plugin going. The exporter window itself is shown in the following figure:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一个准备导出的3D模型，让我们启动Marmalade导出器插件。导出器窗口本身如图所示：
- en: '![Exporting a model](img/3363_04_06.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![导出模型](img/3363_04_06.jpg)'
- en: The manner in which the exporter window will be displayed depends on the modeling
    package you are using.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 导出器窗口的显示方式取决于您使用的建模软件。
- en: 'In Maya you can access the exporter by using the menu option **Marmalade Tools**
    | **Marmalade Studio: Maya Exporter** or from the icon in the **Marmalade Studio**
    tab.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在Maya中，您可以通过使用菜单选项**Marmalade Tools** | **Marmalade Studio: Maya Exporter**或从**Marmalade
    Studio**标签中的图标来访问导出器。'
- en: In 3DS Max, the exporter can be opened by clicking on the **Utilities** tab,
    then clicking on the **Marmalade Studio Exporter** button to open the rollout
    section. Within the rollout, there is another button labeled **Marmalade Studio
    Exporter**, which will display the exporter window.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在3DS Max中，可以通过点击**实用工具**选项卡，然后点击**Marmalade Studio Exporter**按钮来打开导出器部分。在展开部分中，还有一个标记为**Marmalade
    Studio Exporter**的按钮，它将显示导出器窗口。
- en: The exporter window should now be on screen, and as you can see there are a
    great many options available. We can do without most of them for now, so we'll
    only cover the ones we need in order to export a non-animated 3D model.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 导出器窗口现在应该显示在屏幕上，如您所见，有许多可用的选项。现在我们可以不用大多数这些选项，所以我们只会介绍我们需要用来导出非动画3D模型的那些选项。
- en: The first thing we need to set is the **Current Project** field. The exporter
    maintains a list of projects that, at its simplest level, is just a quick way
    of choosing a directory where the exported model files will be created.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要设置的第一件事是**当前项目**字段。导出器维护一个项目列表，在其最简单的层面上，这是一个快速选择导出模型文件将创建的目录的方法。
- en: 'Since we''ve not yet created an exporter project, let''s do so by clicking
    on the button labeled **Set Project**. The following dialog will appear:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们尚未创建导出器项目，让我们通过点击标记为**设置项目**的按钮来创建一个。以下对话框将出现：
- en: '![Exporting a model](img/3363_04_07.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![导出模型](img/3363_04_07.jpg)'
- en: To create a new project click on the **Add…** button at the bottom of the dialog
    and you will be prompted to enter a name for the project. Once you've accepted
    the name, the project will appear in the **Projects:** list.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新项目，请点击对话框底部的**添加…**按钮，您将被提示输入项目的名称。一旦您接受名称，项目将出现在**项目：**列表中。
- en: Click on the **Browse…** button and locate the `data` directory in our code
    project. All resource files need to reside with our code project's `data` directory;
    this will make exporting model files to the correct place much easier.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**浏览…**按钮，定位到我们的代码项目中的`data`目录。所有资源文件都需要位于我们的代码项目的`data`目录中；这将使得将模型文件导出到正确的位置变得容易得多。
- en: For now we will ignore the other settings in this dialog as they are beyond
    the scope of this chapter; so click the **OK** button to return to the main exporter
    window, which should now have our newly created project selected in the **Current
    Project** drop-down list and the `data` directory we set above in the **Project
    Data Directory** field.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们将忽略此对话框中的其他设置，因为它们超出了本章的范围；因此，点击**确定**按钮返回主导出窗口，此时应该在新创建的项目在**当前项目**下拉列表中选中，并且我们在**项目数据目录**字段中设置的`data`目录。
- en: 'With the project set, we can now follow these steps to export the model:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 设置好项目后，我们现在可以按照以下步骤导出模型：
- en: First locate the **Export Type** field. Next to this field is a button with
    a greater-than symbol. Click this button and choose **model** from the pop-up
    menu that appears. The **Export Type** field should change to **scene (model)**.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先定位到**导出类型**字段。此字段旁边有一个带有大于符号的按钮。点击此按钮，从出现的弹出菜单中选择**模型**。**导出类型**字段应更改为**场景（模型**）。
- en: Now look at the first set of checkboxes labeled **Enable export of**. We only
    need the **geometry** and **exportgroup** options to be ticked to export the correct
    set of files.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在看看第一组标记为**启用导出**的复选框。我们只需要勾选**几何形状**和**导出组**选项来导出正确的文件集。
- en: The next set of checkboxes is labeled **Export Flags**. We don't need to have
    any of these settings checked.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个标记为**导出标志**的复选框组。我们不需要勾选任何这些设置。
- en: Now we reach the **Asset Name** field. This specifies the base filename that
    will be used when the exporter generates the various output files.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们到达了**资产名称**字段。这个字段指定了导出器生成各种输出文件时将使用的基准文件名。
- en: The **Save To Location** field allows a directory path relative to the **Project
    Data Directory** field to be provided. All files generated will be created within
    this directory, which will itself be created if it does not already exist.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**保存位置**字段允许提供相对于**项目数据目录**字段的目录路径。所有生成的文件都将创建在这个目录中，如果该目录不存在，它将被创建。'
- en: '**Scale Factor** allows us to provide a numeric scaling factor that will be
    applied to the x, y, and z components of every exported vertex. This allows artists
    to create their models using familiar units such as meters in the modeling package,
    but then convert those units into a different scale for use in the game, such
    as the ever popular "number that is a power of 2" so beloved of us programmer
    types. Note, however, that it is vital to ensure that all artists working on a
    project use the same units and scale factors as each other, otherwise you''ll
    have real problems trying to get all these models to work together properly in
    the game!'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**缩放因子**允许我们提供一个数值缩放因子，该因子将应用于每个导出顶点的x、y和z分量。这使得艺术家可以使用熟悉的单位（如建模包中的米）来创建他们的模型，然后将这些单位转换为不同的比例用于游戏，例如我们程序员类型所喜爱的“2的幂”这样的常用比例。然而，请注意，确保所有参与项目的艺术家使用相同的单位和缩放因子至关重要，否则在尝试让所有这些模型在游戏中正确协同工作时会遇到真正的问题！'
- en: Next we can choose to export either everything in the current scene, just the
    selected objects, or just the visible objects using the drop-down list labeled
    **Export**.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以通过标签为**导出**的下拉列表选择导出当前场景中的所有内容、仅选定的对象，或仅可见对象。
- en: The **Transform Type** drop-down box lets us choose whether the exported vertices
    should be in model space or world space. In most cases, when exporting individual
    models we would choose the **local** option (another way of saying model space!).
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**变换类型**下拉框让我们选择导出的顶点是在模型空间还是世界空间中。在大多数情况下，当我们导出单个模型时，我们会选择**局部**选项（这也是模型空间的一种说法！）。'
- en: The final setting we may be interested in is the **Texture Dir** field. This
    allows a directory to be specified, from which any textures to be used on the
    model will be exported. It can be either an absolute path or relative to the **Project
    Data Directory**.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可能感兴趣的最后设置是**纹理目录**字段。这个字段允许指定一个目录，模型上要使用的任何纹理都将从这个目录导出。它可以是绝对路径，也可以是相对于**项目数据目录**的相对路径。
- en: That completes all the fields we currently need to be concerned with. All that
    is left to do is click on the **Export!** button, which will generate the necessary
    files and then display a window listing all the files that were created during
    the export process.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就完成了我们目前需要关注的全部字段。接下来要做的就是点击 **导出**！按钮，这将生成必要的文件，并显示一个窗口，列出导出过程中创建的所有文件。
- en: The Blender plugin
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Blender 插件
- en: There's no doubt that both Maya and 3DS Max are superb products, but it's also
    true that they carry a fairly hefty price tag. Unfortunately, Marmalade does kind
    of rely on using one of these two heavyweight packages.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，Maya 和 3DS Max 都是出色的产品，但它们的价格也相当昂贵。不幸的是，Marmalade 似乎依赖于使用这两个重量级软件包之一。
- en: Admittedly, Marmalade does also ship with a converter for **Collada** , a file
    format that was created to enable the interchange of 3D models between different
    packages. I hesitate to recommend this approach however, as at the time of writing,
    the Collada converter that ships with Marmalade is known to be a little buggy,
    particularly when it comes to exporting animations.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 承认，Marmalade 也附带了一个用于 **Collada** 的转换器，这是一种创建用于在不同软件包之间交换 3D 模型的文件格式。然而，我犹豫是否推荐这种方法，因为在撰写本文时，Marmalade
    附带的 Collada 转换器已知存在一些问题，尤其是在导出动画时。
- en: Luckily there is a cheaper alternative. There is a 3D modeling package by the
    name of Blender, which is free to download and use; however, the Blender team
    is always happy to accept donations to continuously improve the product, so if
    you find it useful do consider helping them out.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个更便宜的替代方案。有一个名为 Blender 的 3D 建模软件包，可以免费下载和使用；然而，Blender 团队总是乐于接受捐赠以持续改进产品，所以如果您觉得它有用，请考虑帮助他们。
- en: The Marmalade SDK does not come with support for Blender, but thankfully due
    to the efforts of Benoit Muller there is a rather groovy exporter plugin that
    does a great job of replacing the 3DS Max and Maya exporters.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Marmalade SDK 并不自带对 Blender 的支持，但幸亏有 Benoit Muller 的努力，有一个相当酷的导出插件，它能很好地替代 3DS
    Max 和 Maya 的导出器。
- en: Installing Blender and the exporter plugin
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 Blender 和导出插件
- en: 'If you do not already have Blender installed, head over to the Blender website
    and download a copy. The URL is as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有安装 Blender，请访问 Blender 网站，下载一个副本。URL 如下：
- en: '[http://www.blender.org/](http://www.blender.org/)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.blender.org/](http://www.blender.org/)'
- en: Installing Blender is just a case of executing the downloaded installer and
    following the on-screen instructions.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Blender 只需执行下载的安装程序并遵循屏幕上的说明。
- en: 'With Blender installed, we now need to get hold of the exporter plugin, which
    can be found at the following URL:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Blender 后，我们现在需要获取导出插件，该插件可以在以下 URL 中找到：
- en: '[http://wiki.blender.org/index.php/Extensions:2.6/Py/Scripts/Import-Export/Marmalade_Exporter](http://wiki.blender.org/index.php/Extensions:2.6/Py/Scripts/Import-Export/Marmalade_Exporter)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://wiki.blender.org/index.php/Extensions:2.6/Py/Scripts/Import-Export/Marmalade_Exporter](http://wiki.blender.org/index.php/Extensions:2.6/Py/Scripts/Import-Export/Marmalade_Exporter)'
- en: 'The plugin is a Python script that can be installed into Blender using the
    following steps:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 该插件是一个 Python 脚本，可以使用以下步骤安装到 Blender 中：
- en: Copy the downloaded plugin file `io_export_marmalade.py` into the Blender plugins
    directory. On Windows this will normally be something like `C:\Program Files\Blender
    Foundation\Blender\2.63\scripts\addons`.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将下载的插件文件 `io_export_marmalade.py` 复制到 Blender 插件目录中。在 Windows 上，这通常类似于 `C:\Program
    Files\Blender Foundation\Blender\2.63\scripts\addons`。
- en: Start Blender and go to **File** | **User Preferences…**.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Blender 并转到 **文件** | **用户首选项…**。
- en: Click on the **Addons** tab at the top of the preferences window.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击首选项窗口顶部的 **插件** 选项卡。
- en: In the **Categories** list on the left-hand side of the window, click on **Import-Export**.
    You should see a screen that looks something like the one shown in the following
    figure:![Installing Blender and the exporter plugin](img/3363_04_08.jpg)
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在窗口左侧的 **类别** 列表中，点击 **导入-导出**。您应该看到一个类似于以下图所示的屏幕：![安装 Blender 和导出插件](img/3363_04_08.jpg)
- en: 'Find the **Import-Export: Marmalade Cross-platform Apps (.group)** entry and
    click the checkbox on the right-hand side of it to enable the plugin.'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到 **导入-导出：Marmalade 跨平台应用 (.group**) 条目，并点击其右侧的复选框以启用插件。
- en: Exporting a model
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导出模型
- en: 'To export a 3D model using the Blender exporter, follow these steps:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Blender 导出器导出 3D 模型，请按照以下步骤操作：
- en: Create or load the model you wish to export into Blender.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Blender 中创建或加载您希望导出的模型。
- en: Go to **File** | **Export** | **Marmalade cross-platform Apps (.group)**. The
    main 3D view will be replaced with a filename requester. The bottom-left corner
    of the window should contain the exporter options and look like the following
    image:![Exporting a model](img/3363_04_09.jpg)
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**文件** | **导出** | **Marmalade跨平台应用(.group)**。主3D视图将被文件名请求器替换。窗口的左下角应包含导出选项，并看起来像以下图像：![导出模型](img/3363_04_09.jpg)
- en: First choose the location you want to export the datafiles to, using the file
    requester. There are two text edit boxes at the top of the screen; the topmost
    is the directory to save to and the bottom specifies the filename we want to use
    for exporting. This filename should be a GROUP file, so its extension should always
    be `.group`.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先使用文件请求器选择要导出数据文件的位置。屏幕顶部有两个文本编辑框；最上面的用于保存目录，下面的指定了导出时想要使用的文件名。这个文件名应该是GROUP文件，因此其扩展名始终是`.group`。
- en: In the exporter settings, first use the **Export** drop-down list to select
    whether you want just the selected models to be exported or all models in the
    current scene.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在导出设置中，首先使用**导出**下拉列表选择是要导出所选模型还是当前场景中的所有模型。
- en: The **Merge** option controls what happens when there are several models in
    the scene to be exported. The default option, **None**, exports each model individually
    with its coordinates in model space, and is the option we require for now. The
    other two options allow multiple models to be merged as either a single big mesh
    of polygons or as a number of separate meshes, with all vertices specified in
    world space coordinates.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**合并**选项控制当场景中有多个模型要导出时会发生什么。默认选项**无**将每个模型单独导出，其坐标在模型空间中，这是我们目前需要的选项。其他两个选项允许将多个模型合并为一个大的多边形网格或作为多个单独的网格导出，所有顶点都指定在世界空间坐标中。'
- en: The **Scale Percent** value allows model vertices to be scaled up or down so
    that the artist can build the models using the most convenient measurement units
    in Blender, yet still allow the exported model to have vertices scaled to a set
    of units that may be more useful in the game.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**缩放百分比**值允许模型顶点进行放大或缩小，以便艺术家可以使用Blender中最方便的测量单位来构建模型，同时仍然允许导出的模型具有顶点缩放到一组可能对游戏更有用的单位。'
- en: The **Flip Normals** checkbox will reverse the direction of all exported normals.
    Normally this can be left unchecked, but it can be useful to fix models that have
    been lit incorrectly and have their normals pointing in the wrong direction.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**翻转法线**复选框将反转所有导出法线的方向。通常情况下可以不勾选，但有时可以用来修复被错误照明且法线指向错误方向的模型。'
- en: The **Apply** **Modifiers** checkbox will cause any mesh modifiers applied to
    the model in Blender to be evaluated before the export data is created. This defaults
    to being switched off.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**应用** **修改器**复选框会在创建导出数据之前评估Blender中应用于模型的任何网格修改器。默认情况下是关闭的。'
- en: If vertex colors have been applied to the model, they will only be exported
    if the **Export Vertices Colors** checkbox is selected.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果模型已应用顶点颜色，则只有在选择**导出顶点颜色**复选框时才会导出。
- en: The next checkbox, **Export Material Colors**, determines whether materials
    created during the export process will be exported with their defined colors.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个复选框，**导出材质颜色**，确定在导出过程中创建的材质是否带有其定义的颜色导出。
- en: The **Export Textures and UVs** checkbox should be checked if you have texture-mapped
    polygons in your model.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您的模型中有纹理映射的多边形，则应勾选**导出纹理和UVs**复选框。
- en: Since Marmalade will need access to any images used in texturing the model,
    the **Copy Textures Files** checkbox can be selected to ensure image files are
    also copied across to the export directory.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于Marmalade需要访问用于模型纹理化的任何图像，因此可以选择**复制纹理文件**复选框以确保图像文件也被复制到导出目录中。
- en: The remaining settings are mostly concerned with exporting animations, so we
    can ignore them for now; however, it is worth mentioning the **Verbose** checkbox
    which logs information about the export process to Blender's console window. This
    may help you solve problems with your models when the export process doesn't work
    exactly as expected.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 剩余的设置大多与导出动画有关，因此现在可以忽略它们；然而，值得提及的是**详细**复选框，它将导出过程的信息记录到Blender的控制台窗口中。这可能会帮助您解决导出过程不按预期工作时的模型问题。
- en: When all settings have been made, click on the **Export Marmalade** button,
    which is at the top right of the Blender window. Alternatively, if you wish to
    cancel the export process, there is a **Cancel** button underneath the export
    button.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当所有设置都完成后，点击位于Blender窗口右上角的**导出Marmalade**按钮。或者，如果您想取消导出过程，导出按钮下方有一个**取消**按钮。
- en: The Marmalade 3D model datafile formats
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Marmalade 3D模型数据文件格式
- en: We've now seen how we can export 3D model data from a modeling package, but
    we haven't yet looked at the files themselves that are generated as part of the
    export process.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何从建模软件包中导出3D模型数据，但我们还没有查看作为导出过程一部分生成的文件。
- en: While we shouldn't need to make manual changes to these files, it is useful
    to know a little about them as it can help to discover why a model hasn't been
    exported quite as expected to.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可能不需要手动修改这些文件，但了解一些关于它们的信息是有用的，因为它可以帮助我们发现为什么模型没有像预期的那样导出。
- en: Let's take a look at the files that would be generated for a cube model similar
    to the one we created in code earlier in this chapter.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看与我们在本章早期代码中创建的类似立方体模型将生成的文件。
- en: The GROUP file
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GROUP文件
- en: 'The first file generated is a GROUP file that will be created in the directory
    specified in the exporter settings. The GROUP file contains a list of the individual
    model files (called **GEO files**) that were exported. Here''s what the GROUP
    file for the example cube model would look like:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的第一个文件是一个GROUP文件，它将在导出设置中指定的目录中创建。GROUP文件包含导出的单个模型文件（称为**GEO文件**）的列表。以下是示例立方体模型的GROUP文件可能的样子：
- en: '[PRE13]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The exporter helpfully includes the name of the source modeling package file
    that was used to do the export, details about when the export was made, and by
    whom.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 导出器有帮助地包括了用于导出的源建模软件包文件的名称，以及导出时间和导出者信息。
- en: It then just declares a new `CIwResGroup` instance, named based on the asset
    name specified at export time. The resource group is populated by a list of the
    GEO files that need to be loaded.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它只是声明了一个新的`CIwResGroup`实例，其名称基于导出时指定的资产名称。资源组由需要加载的GEO文件列表填充。
- en: The MTL file
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MTL文件
- en: 'We''ve already created an MTL file by hand when working with 2D graphics, so
    it should already look familiar. Here is what the file might look like for the
    cube:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理2D图形时，我们已经手动创建了一个MTL文件，所以它应该已经很熟悉了。以下是对于立方体的文件可能的样子：
- en: '[PRE14]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Again the exporter includes the name of the source modeling package file used
    to generate the MTL file. The `CIwMaterial` instances defined in this file are
    all generated from the materials used in the modeling package, so it's easy for
    an artist to change colors and other material attributes in the comfort of their
    favorite modeling tool.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，导出器包括了用于生成MTL文件的源建模软件包文件的名称。在此文件中定义的`CIwMaterial`实例都是从建模软件包中使用的材料生成的，因此艺术家可以在他们最喜欢的建模工具中轻松更改颜色和其他材料属性。
- en: The exporter creates a sub-directory called `models` in the specified export
    directory and the MTL files are written into this directory.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 导出器在指定的导出目录中创建一个名为`models`的子目录，并将MTL文件写入此目录。
- en: The GEO file
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GEO文件
- en: The most important file type to be exported is the GEO file, as this is the
    file that actually contains all the data to describe our 3D model. In common with
    all Marmalade resources, this file is yet another use of the ITX file format.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要导出的最重要的文件类型是GEO文件，因为这个文件实际上包含了描述我们的3D模型所需的所有数据。与所有Marmalade资源一样，此文件是ITX文件格式的另一种用途。
- en: GEO files are processed by way of a resource handler class called `CIwResHandlerGEO`.
    This class takes care of loading all the data from the GEO file and submitting
    it to a singleton class called `CIwModelBuilder`. This class processes the model
    data and generates an optimized version of the data for fast rendering, which
    is then serialized to a file.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: GEO文件通过一个名为`CIwResHandlerGEO`的资源处理类进行处理。这个类负责从GEO文件中加载所有数据并将其提交给一个名为`CIwModelBuilder`的单例类。这个类处理模型数据并生成用于快速渲染的数据优化版本，然后将其序列化到文件中。
- en: The `CIwModelBuilder` class is only available in debug builds, so you can only
    load model data in a release build by loading the serialized version of the GROUP
    file that references the GEO file.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`CIwModelBuilder`类仅在调试构建中可用，因此您只能通过加载引用GEO文件的GROUP文件的序列化版本来在发布构建中加载模型数据。'
- en: The exporter will write the GEO files into the model's sub-directory in the
    same way as it does with MTL files.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 导出器将以与MTL文件相同的方式将GEO文件写入模型的子目录中。
- en: Note
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may have noticed that the GROUP file shown earlier only references the GEO
    files, not the MTL files. The GEO resource handler takes care of loading the MTL
    files automatically by checking to see if an MTL file exists with the same base
    filename as the GEO file.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，之前显示的GROUP文件只引用了GEO文件，而没有引用MTL文件。GEO资源处理程序会自动处理MTL文件的加载，通过检查是否存在与GEO文件具有相同基本名称的MTL文件。
- en: Let's look at the innards of the GEO file for our cube model.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们的立方体模型的GEO文件的内部结构。
- en: '[PRE15]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Yet again the exporter will include a comment referencing the source modeling
    package file before beginning to define an instance of `CIwModel`, which is the
    class used by Marmalade to represent a complete collection of 3D model data.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，导出器将在开始定义`CIwModel`实例之前包含一个注释，引用源建模包文件。`CIwModel`是Marmalade用来表示完整3D模型数据集合的类。
- en: The `CIwModel` instance is first given a name. This name actually comes from
    the name given to the model in the modeling package and is the name used to access
    the model in our code, so it is important for the artist to name things sensibly.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 首先给`CIwModel`实例起一个名字。这个名字实际上来自建模包中给出的模型名称，并且是我们代码中访问模型时使用的名称，因此对于艺术家来说，合理命名是很重要的。
- en: A `CMesh` instance is declared next, which is a class that groups together all
    the various bits of model data. This class, and all the other classes we are about
    to see that are contained within it, are only ever used internally to the model
    builder. Once the model has been processed these classes will no longer exist
    in memory, so we can't use them in our code to access the raw model data.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来声明一个`CMesh`实例，这是一个将所有各种模型数据组合在一起的类。这个类以及我们即将看到的包含在其内的所有其他类，仅用于模型构建器内部。一旦模型被处理，这些类将不再存在于内存中，因此我们无法在代码中使用它们来访问原始模型数据。
- en: The `scale` value used to export the vertex data is listed first in the `CMesh`
    instance, and this is followed by classes which declare the various types of model
    data. In the cube example we can see `CVerts`, `CVertNorms`, and `CVertCols`,
    which are little more than big lists of vertex, normal, and color data respectively.
    A similar class called `CUVs` also exists to provide texture information.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 用于导出顶点数据的`scale`值首先列在`CMesh`实例中，随后是声明各种模型数据类型的类。在立方体示例中，我们可以看到`CVerts`、`CVertNorms`和`CVertCols`，它们分别只是包含顶点、法线和颜色数据的大列表。还有一个类似的类`CUVs`，它用于提供纹理信息。
- en: Next we see a class called `CSurface`. This class provides polygon information
    for the model, and an instance will exist for every material used in the model.
    The material used is specified first, and then comes the polygon information.
    A `CQuads` instance is used to provide a list of all the quadrilateral polygons
    using the material, and a `CTris` instance lists the triangular polygons.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们看到一个名为`CSurface`的类。这个类为模型提供多边形信息，并且对于模型中使用的每种材质都会存在一个实例。使用的材质首先被指定，然后是多边形信息。`CQuads`实例用于提供使用该材质的所有四边形多边形的列表，而`CTris`实例列出三角形多边形。
- en: 'A polygon is defined by supplying a collection of data for each vertex in the
    polygon. The polygon is supplied as a group of five numbers enclosed in curly
    braces. These numbers are indices into the blocks of data specified earlier in
    the file and occur in the following order:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 多边形通过为多边形中的每个顶点提供一组数据来定义。多边形以一组五个数字的形式提供，这些数字是文件中之前指定的数据块的索引，并按以下顺序出现：
- en: '[PRE16]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There are two UV values as it is possible for a material to specify two textures
    that will be blended together at render time, and each of these textures can have
    its own UV stream.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 由于材质可以指定两个将在渲染时混合在一起的纹理，因此存在两个UV值。每个纹理都可以有自己的UV流。
- en: Once all this data has been loaded, the model builder class will analyze it
    and create a version of the data that is far more optimal for real-time rendering
    purposes.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有这些数据都被加载，模型构建类将分析它们并创建一个针对实时渲染目的远更优化的数据版本。
- en: Loading and rendering an exported 3D model
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载和渲染导出的3D模型
- en: OK, so now we've got the model data exported, how do we go about loading it
    into our program and rendering it? It's actually surprisingly easy, as these next
    sections will show.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们已经导出了模型数据，那么我们如何将其加载到我们的程序中并进行渲染呢？实际上，这出奇地简单，接下来的几节将会展示这一点。
- en: Adding the IwGraphics API to a project
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将IwGraphics API添加到项目中
- en: Marmalade's 3D model rendering code is part of the IwGraphics API, so before
    we can draw anything we need to add this library to our project. This is done
    by adding `iwgraphics` to the `subprojects` section of the MKB file.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Marmalade的3D模型渲染代码是IwGraphics API的一部分，因此在我们能够绘制任何东西之前，我们需要将这个库添加到我们的项目中。这是通过在MKB文件的
    `subprojects` 部分添加 `iwgraphics` 来实现的。
- en: We then need to add a call to `IwGraphicsInit` at the start of our program,
    and `IwGraphicsTerminate` at the end. This API relies on both IwGx and IwResManager,
    so we must call the initialization functions for both of these APIs before calling
    the IwGraphics one.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在程序的开始处添加对 `IwGraphicsInit` 的调用，并在结束时添加 `IwGraphicsTerminate`。这个API依赖于IwGx和IwResManager，因此我们必须在调用IwGraphics之前调用这两个API的初始化函数。
- en: Loading and accessing an exported 3D model
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载和访问导出的3D模型
- en: 'You''ve probably already guessed that this is almost trivially easy. The exporter
    generated a GROUP file, so all we have to do is load it into memory and then dig
    the model out of the resource group. Here''s a block of code which does just that:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经猜到了，这几乎是微不足道的简单。导出器生成了一个GROUP文件，所以我们只需要将其加载到内存中，然后从资源组中提取模型。以下是一段执行此操作的代码块：
- en: '[PRE17]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Or alternatively you could do the following if you don''t want to be bothered
    with retaining a pointer to the resource group instance:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你不想保留资源组实例的指针，你可以这样做：
- en: '[PRE18]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: That's it. The model is now loaded into memory and ready to render.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。模型现在已加载到内存中，并准备好渲染。
- en: Rendering an exported 3D model
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染导出的3D模型
- en: 'It is time to render the model on the screen and this too is incredibly easy.
    All we have to do is set our view and model matrices using `IwGxSetViewMatrix`
    and `IwGxSetModelMatrix`, then execute the following:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候在屏幕上渲染模型了，这同样非常简单。我们只需要使用 `IwGxSetViewMatrix` 和 `IwGxSetModelMatrix` 设置我们的视图和模型矩阵，然后执行以下操作：
- en: '[PRE19]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The variable `lpCube` is the pointer to the `CIwModel` instance that we retrieved
    from the resource manager in the previous section.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `lpCube` 是指向我们从上一节资源管理器中检索到的 `CIwModel` 实例的指针。
- en: In actual fact the `Render` method can take two optional parameters. The first
    parameter is a `bool` value that tells Marmalade to check a bounding sphere for
    the model against the clipping planes to see if it actually needs to be rendered.
    This parameter defaults to `true`, so the check is done by default. The bounding
    sphere is generated automatically for us by the model builder code.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`Render` 方法可以接受两个可选参数。第一个参数是一个 `bool` 值，它告诉Marmalade检查模型的边界球体是否与裁剪平面相交，以确定它是否实际上需要被渲染。此参数默认为
    `true`，因此默认情况下会进行此检查。边界球体是由模型构建器代码自动为我们生成的。
- en: The second parameter is a flags field. Aside from one flag that is supposed
    to have something to do with a 2D screen rotation (I say "supposed" because I
    can't say it did very much when I tried it), the other flags are only relevant
    when dealing with animated 3D models that contain normal data, so we will not
    worry over these for now.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是标志字段。除了一个与2D屏幕旋转有关（我说“有关”是因为我在尝试时并没有发现它做了很多）的标志之外，其他标志仅在与包含法线数据的动画3D模型处理时相关，所以我们现在不必担心这些。
- en: Releasing 3D model data
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 释放3D模型数据
- en: 'Since our 3D model data has been loaded into memory using the resource group
    system, we can make use of the same mechanism of destroying groups to release
    model data from memory that we no longer need. As a recap, we just do the following
    if we have a pointer to the `CIwResGroup` containing the 3D data:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的3D模型数据已经使用资源组系统加载到内存中，我们可以利用相同的销毁组机制来释放不再需要的模型数据。作为一个回顾，如果我们有一个指向包含3D数据的
    `CIwResGroup` 的指针，我们只需做以下操作：
- en: '[PRE20]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Alternatively we can release a group from memory by destroying it by name,
    like this:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以通过按名称销毁它来从内存中释放一个组，如下所示：
- en: '[PRE21]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Example code
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例代码
- en: Here are some details about the example projects that accompany this chapter.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些关于本章附带示例项目的详细信息。
- en: The Cube project
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: The Cube project
- en: 'This is a complete example of the first spinning cube project discussed in
    this chapter, where we generate the model data in code and submit it to IwGx for
    rendering using `IwGxDrawPrims`. See the following screenshot:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本章讨论的第一个旋转立方体项目的完整示例，其中我们在代码中生成模型数据，并使用 `IwGxDrawPrims` 将其提交给IwGx进行渲染。请参见以下截图：
- en: '![The Cube project](img/3363_04_10.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![The Cube project](img/3363_04_10.jpg)'
- en: The Cube2 project
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cube2项目
- en: This project is almost identical to the previous project, except that the model
    data for the cube has been exported as a GEO file from a 3D modeling package.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目几乎与上一个项目完全相同，只是将立方体的模型数据从3D建模软件导出为GEO文件。
- en: The Skiing project
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 滑雪项目
- en: 'For this chapter the Skiing game waves goodbye to its old bitmapped graphics
    and instead says hello to some new 3D models instead. A screenshot of the game
    with its new 3D skin can be seen in the following figure:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，滑雪游戏告别了其旧的位图图形，转而迎来了一些新的3D模型。以下图中可以看到带有新3D外观的游戏截图：
- en: '![The Skiing project](img/3363_04_11.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![滑雪项目](img/3363_04_11.jpg)'
- en: The following sections describe some of the other more interesting changes to
    the game code for this chapter.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几节描述了本章游戏代码的一些其他更有趣的更改。
- en: Migration to 3D
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迁移到3D
- en: The first step was to change all position and velocity information from being
    2D vectors to 3D vectors, which meant changing `CIwVec2` instances to `CIwFVec3`
    and making sure that the extra component in the vector was initialized.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是将所有位置和速度信息从二维向量更改为三维向量，这意味着将`CIwVec2`实例更改为`CIwFVec3`，并确保向量的额外分量被初始化。
- en: Since we tend to think about the y axis being the height above the ground, the
    y component was used for height in the game too. However, since the skier and
    trees are stuck to the floor, this means the y component of all position vectors
    is always zero.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们倾向于将y轴视为地面以上的高度，所以在游戏中y分量也被用来表示高度。然而，由于滑雪者和树木都粘在了地面上，这意味着所有位置向量的y分量始终为零。
- en: The game therefore scrolls the trees along the z axis and the camera is placed
    high in the air and orientated to look at the skier. This still provides the effect
    of the trees moving up the screen.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，游戏沿着z轴滚动树木，并将摄像机放置在空中并朝向滑雪者。这仍然提供了树木向上移动屏幕的效果。
- en: The second step was to get rid of all the old 2D textures and replace them with
    3D models. Since the `GameObject` class dealt with all the rendering, all that
    had to be done was to change this class to use `CIwModel` instances instead of
    `CIwMaterial` instances. The child classes then just provided a pointer to a model
    instead of a pointer to the material.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是去除所有旧的2D纹理，并用3D模型替换它们。由于`GameObject`类处理所有渲染，所以只需将这个类更改为使用`CIwModel`实例而不是`CIwMaterial`实例。子类随后只需提供一个指向模型的指针而不是指向材质的指针。
- en: The `GameObject` class also had a y axis rotation added to it. This is used
    to rotate the skier model, which leads to a far smoother motion than we had previously.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameObject`类还添加了一个y轴旋转。这用于旋转滑雪者模型，这比我们之前的方法运动更加平滑。'
- en: The trees also use the rotation feature. The game features only one tree model,
    but by rotating it at random angles it makes the game look far more interesting
    without having to add more game resources.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 树木也使用了旋转功能。游戏只包含一个树模型，但通过在随机角度旋转它，可以在不增加更多游戏资源的情况下使游戏看起来更加有趣。
- en: Addition of a collision detection system
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加碰撞检测系统
- en: The code now features a very simple collision detection system. The `GameObject`
    class now allows a collision radius to be set, which is then used to perform sphere
    intersection tests.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 代码现在具有一个非常简单的碰撞检测系统。`GameObject`类现在允许设置碰撞半径，然后用于执行球体相交测试。
- en: The `ModeGame::Update` method now steps through every game object (currently
    just trees, of course) in the game world and finds out how far away it is from
    the skier. If the distance is less than the combined collision radius of the skier
    and the other game object, a collision has occurred.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`ModeGame::Update`方法现在遍历游戏世界中的每个游戏对象（目前当然是树木），并找出它距离滑雪者的距离。如果距离小于滑雪者和另一个游戏对象的碰撞半径之和，则发生了碰撞。'
- en: So, to act on these collisions, a virtual method called `OnCollide` has been
    added to the `GameObject` class. Child objects can override this class and then
    react accordingly whenever they collide with another object. The `Skier` class
    implements this method so that whenever the skier collides with a tree, the game
    is over.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了处理这些碰撞，在`GameObject`类中添加了一个名为`OnCollide`的虚方法。子对象可以重写这个类，并在与另一个对象发生碰撞时相应地做出反应。`Skier`类实现了这个方法，因此每当滑雪者与树木碰撞时，游戏就结束了。
- en: Summary
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We now know how to render 3D graphics that have either been generated in code
    or have been exported from a 3D modeling package. Which method we eventually use
    depends on what we are trying to do.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道如何渲染由代码生成或从3D建模软件导出的3D图形。我们最终使用哪种方法取决于我们想要做什么。
- en: If rendering in game characters or scenery, the exported model route is definitely
    the best way to go; but creating our own polygon data in code is a much better
    and more efficient way of creating effects such as particle systems, since it
    is much easier to batch a large number of individual polygons into a single draw
    call.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是在游戏角色或场景中进行渲染，那么导出模型路径无疑是最好的选择；但通过代码创建自己的多边形数据是一种更好、更高效的方法来创建如粒子系统等效果，因为它更容易将大量单独的多边形批量合并成一个单独的绘制调用。
- en: We've also learnt how to export 3D model data from three different modeling
    packages—Maya, 3DS Max, and Blender—and load this exported data into our program
    and render it.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学会了如何从三个不同的建模软件——Maya、3DS Max和Blender——导出3D模型数据，并将这些导出的数据加载到我们的程序中并对其进行渲染。
- en: We'll be sticking with 3D rendering for a little while longer as the next chapter
    is all about making our models animated.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将暂时继续使用3D渲染，因为下一章全部是关于使我们的模型动画化的内容。
