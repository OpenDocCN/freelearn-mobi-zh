- en: Chapter 4. Enhancing your Apps with Audio, Video, and the Camera
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章：使用音频、视频和相机增强应用
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Choosing your capture device using an OptionDialog
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OptionDialog选择捕获设备
- en: Capturing photos from the camera
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从相机捕获照片
- en: Choosing existing photos from the photo library
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从照片库中选择现有照片
- en: Displaying photos using ScrollableView
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ScrollableView显示照片
- en: Saving your captured photo to the device filesystem
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将捕获的照片保存到设备文件系统
- en: Capturing and playing audio via the audio recorder
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过音频录制器捕获和播放音频
- en: Capturing video via the video recorder
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过视频录制器捕获视频
- en: Playing video files from the filesystem
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文件系统播放视频文件
- en: Safely deleting saved files from the filesystem
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全地从文件系统中删除保存的文件
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: While it may be hard to believe, snapping photographs and sharing them wirelessly
    using a phone first happened only in 1997, and wasn't popularized until around
    2004\. By 2010, almost all phones contained a digital camera and many mid-range
    to high-end devices also sported audio and video camcorder capabilities. Most
    iPhone and Android models now have these capabilities, and they have opened new
    pathways for entrepreneurial developers.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能难以相信，但使用手机无线拍摄照片并分享照片首次发生在1997年，直到大约2004年才流行起来。到2010年，几乎所有的手机都内置了数码相机，许多中端到高端设备也配备了音频和视频摄像机功能。现在，大多数iPhone和Android型号都具备这些功能，并为创业开发者开辟了新的途径。
- en: Titanium contains APIs that let you access all of the phone interfaces required
    to take photos or video with the built-in camera, record audio, and scroll through
    the device's saved image and video galleries.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Titanium包含API，允许你访问所有必需的接口，使用内置相机拍照或录像，录制音频，以及浏览设备中保存的图片和视频库。
- en: Throughout this chapter we will introduce all of these concepts and use them
    to put together a basic ''Holiday Memories'' app which will allow our users to
    capture photographs, videos, and audio from their device, save those files to
    the local file storage, and read them back again.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍所有这些概念，并使用它们来构建一个基本的“假日回忆”应用，该应用将允许我们的用户从设备中捕获照片、视频和音频，将这些文件保存到本地文件存储，并再次读取它们。
- en: Pre-requisites
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 前提条件
- en: You should already be familiar with Titanium basics, including creating UI objects
    and using Titanium Studio. Additionally, to test camera functionality you are
    going to need either an iPhone or Android device capable of both recording photographs
    and video. An iPhone 3GS model or up will suffice, and all Android phones apart
    from the very bottom-end of the market should be OK.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经熟悉Titanium基础知识，包括创建UI对象和使用Titanium Studio。此外，为了测试相机功能，你需要一部能够录制照片和视频的iPhone或Android设备。iPhone
    3GS型号或更高版本就足够了，除了市场上最底端的Android手机外，所有Android手机都应该没问题。
- en: Choosing your capture device using an OptionDialog
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OptionDialog选择捕获设备
- en: The OptionDialog is a modal-only component that allows you to show one or more
    options to a user, usually along with a *cancel* option, which closes the dialog.
    We are going to create this component and use it to present the user with an option
    to choose an image from the camera or the device's photo library.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: OptionDialog是一个仅模态的组件，允许你向用户展示一个或多个选项，通常还会包括一个*取消*选项，用于关闭对话框。我们将创建这个组件，并使用它向用户提供从相机或设备的照片库中选择图片的选项。
- en: If you are intending to follow the entire chapter and build the Holiday Memories
    app, then pay careful attention to the first *Getting ready* section for this
    recipe, as it will guide you through setting up the project.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算跟随整个章节并构建假日回忆应用，那么请仔细注意这个食谱的第一个*准备工作*部分，因为它将指导你设置项目。
- en: Getting ready
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To prepare for this recipe, open up Titanium Studio and log in if you have not
    already done so. If you need to register a new account, you can do so for free
    directly from within the application. Once you are logged in, click on **New Project**,
    and the details window for creating a new project will appear. Enter in **Holiday
    Memories** as the name of the app, and fill in the rest of the details with your
    own information.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备这个食谱，打开Titanium Studio并登录（如果你还没有登录的话）。如果你需要注册新账户，你可以在应用程序内部免费注册。登录后，点击**新建项目**，创建新项目的详细信息窗口将出现。将应用名称输入为**假日回忆**，并使用你自己的信息填写其余的详细信息。
- en: 'Pay attention to the app identifier, which is written normally in reverse domain
    notation (that is *com.packtpub.holidaymemories)*. This identifier cannot be easily
    changed after the project is created and you will need to match it *exactly* when
    creating provisioning profiles for distributing your apps later on. You can obtain
    all of the images used in this recipe, and indeed the entire chapter, by downloading
    the following source files:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意应用程序标识符，它通常以反向域名表示法书写（即 *com.packtpub.holidaymemories*）。在项目创建后，此标识符不能轻易更改，并且您在创建用于分发应用的配置文件时需要**精确**匹配它。您可以通过下载以下源文件来获取本食谱中使用的所有图像，以及整个章节的所有内容：
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Complete source code for this recipe can be found in the `/Chapter 4/Recipe
    1` folder.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的完整源代码可以在`/Chapter 4/Recipe 1`文件夹中找到。
- en: Complete source code for this entire chapter can be found in the `/Chapter 4/Holiday
    Memories` folder.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 整个章节的完整源代码可以在`/Chapter 4/Holiday Memories`文件夹中找到。
- en: How to do it...
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Now our project has been created using Titanium Studio. Let''s get down to
    business! Open up the `app.js` file in your editor and remove all existing code.
    After you have done that, type in the following and then hit save:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用Titanium Studio创建了项目。让我们开始工作！在您的编辑器中打开`app.js`文件，并删除所有现有代码。完成此操作后，输入以下内容并保存：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now we need to create our first Window''s JavaScript file that we will call
    `photo.js`. Create this blank file in your `Resources` folder and open it in your
    IDE. Enter in the following code to create the "Choose Photo" button which will
    instantiate your OptionDialog:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要创建我们的第一个窗口的JavaScript文件，我们将称之为`photo.js`。在您的`Resources`文件夹中创建此空白文件，并在您的IDE中打开它。输入以下代码以创建“选择照片”按钮，该按钮将实例化您的OptionDialog：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works…
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作…
- en: The code in the first block of code is creating our Navigation view with tabs
    and windows, all of which has been covered in [Chapter 1](ch01.html "Chapter 1. Building
    Apps using Native UI Components"), *Building Apps using Native UI Components*
    and [Chapter 2](ch02.html "Chapter 2. Working with Local and Remote Data Sources"),
    *Working with Local and Remote Data Sources*. Our first tab and window use the
    *photo.js* file, the contents of which are visible here in our second block of
    code on the previous page.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 第一段代码中的代码正在创建我们的带有标签和窗口的导航视图，所有这些内容都在[第1章](ch01.html "第1章. 使用原生UI组件构建应用")、*使用原生UI组件构建应用*和[第2章](ch02.html
    "第2章. 与本地和远程数据源一起工作")、*与本地和远程数据源一起工作*中有所介绍。我们的第一个标签和窗口使用*photo.js*文件，其内容在本页前面的第二段代码中可见。
- en: The OptionDialog itself is created using the `Titanium.UI.createOptionDialog()`
    method and only requires a few simple parameters. The `title` parameter, in this
    case, appears at the top of your button options and is there to just give your
    user a brief message about what their chosen option will be used for. In our case,
    we're simply notifying them that we'll be using their chosen option to launch
    the appropriate image capture application. The options array is the important
    property here and contains all of the button selections you wish to present to
    the user. Note that we have also included a `cancel` item in our array, and there
    is a corresponding `cancel` property with the same index as part of our `createOptionDialog()`.
    This will draw the button style for cancel a little differently when our OptionDialog
    is presented on screen.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: OptionDialog本身是通过`Titanium.UI.createOptionDialog()`方法创建的，并且只需要几个简单的参数。`title`参数，在这种情况下，出现在按钮选项的顶部，目的是向用户简要说明他们选择的选项将用于什么。在我们的情况下，我们只是通知他们我们将使用他们选择的选项来启动相应的图像捕获应用程序。选项数组是这里的重要属性，它包含您希望向用户展示的所有按钮选择。请注意，我们还在我们的数组中包含了一个`cancel`项，并且有一个相应的`cancel`属性，其索引与我们的`createOptionDialog()`中的相同。当我们的OptionDialog在屏幕上显示时，这将绘制不同的按钮样式以取消操作。
- en: 'Finally, we added an event listener to our OptionDialog and we are outputting
    the chosen button index to the Titanium Studio console, using the `e.index` property.
    We will use this flag in our next recipe to launch either the camera or photo
    gallery depending on the user''s selection. The OptionDialog shown next provides
    the user with two image source options:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在我们的OptionDialog中添加了一个事件监听器，并使用`e.index`属性将所选按钮索引输出到Titanium Studio控制台。我们将在下一个食谱中使用这个标志来根据用户的选择启动相机或照片库。下面的OptionDialog为用户提供两个图像源选项：
- en: '![How it works…](img/3968EXP_04_01.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/3968EXP_04_01.jpg)'
- en: Capturing photos from the camera
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从相机捕获照片
- en: To use the device camera we need to access the `Titanium.Media` namespace, and
    specifically the `showCamera` method. This will display the native operating system
    interface for taking photographs, and expose the three events which will help
    us decide what needs to be done with the captured image. We will also check whether
    the user's device is capable of taking camera shots before attempting to do so,
    as some devices (including iPod Touch and the emulator) don't have this capability.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用设备相机，我们需要访问 `Titanium.Media` 命名空间，特别是 `showCamera` 方法。这将显示用于拍照的本地操作系统界面，并公开三个事件，这些事件将帮助我们决定对捕获的图像进行什么操作。我们还将检查用户的设备是否能够拍摄照片，然后再尝试这样做，因为一些设备（包括
    iPod Touch 和模拟器）没有这种功能。
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that this recipe will only work if you are using a physical device! The
    emulators for both Android and the iPhone don't have camera functionality built
    in. If you attempt to run this on the emulator you will just be presented with
    an error dialog.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此菜谱仅在您使用物理设备时才会生效！Android 和 iPhone 的模拟器都没有内置相机功能。如果您尝试在模拟器上运行此代码，您将只会看到一个错误对话框。
- en: Complete source code for this recipe can be found in the `/Chapter 4/Recipe
    2` folder.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的完整源代码可以在 `/Chapter 4/Recipe 2` 文件夹中找到。
- en: How to do it...
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We are going to extend the event listener of our OptionDialog using the following
    code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下代码扩展我们的 OptionDialog 的事件监听器：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Run your app on a physical device now and you should be able to select the
    camera button from our OptionDialog and take a photograph with your device. This
    image should then appear in our temporary ImageView like it does in the following
    screenshot:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将您的应用运行在物理设备上，您应该能够从我们的 OptionDialog 中选择相机按钮，并用您的设备拍摄一张照片。这张图片应该随后出现在我们的临时
    ImageView 中，就像以下截图所示：
- en: '![How to do it...](img/3968EXP_04_02.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/3968EXP_04_02.jpg)'
- en: How it works…
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Getting an image from the camera is actually pretty straightforward. First,
    you'll notice that we've extended the OptionDialog with an if statement. If the
    index property of our dialog is 0 (the first button) then we are launching the
    camera. We do this via the `Titanium.Media.showCamera()` method. This fires three
    events, which we are capturing here, called **success, error**, and **cancel**.
    We are ignoring the cancel event, as there is no processing required if the user
    opts to cancel out of the image capture. In the error event, we are going to display
    an AlertDialog that explains that the camera cannot be initiated. This is the
    dialog you will see if you happen to run this code using an emulator.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 从相机获取图片实际上相当简单。首先，您会注意到我们已经通过一个 if 语句扩展了 OptionDialog。如果我们的对话框的索引属性为 0（第一个按钮），那么我们正在启动相机。我们通过
    `Titanium.Media.showCamera()` 方法来完成此操作。这将触发三个事件，我们在这里捕获它们，称为 **成功、错误** 和 **取消**。我们忽略取消事件，因为如果用户选择取消图像捕获，则不需要进行任何处理。在错误事件中，我们将显示一个
    AlertDialog，解释说无法启动相机。如果您使用模拟器运行此代码，您将看到此对话框。
- en: The majority of our processing takes place in the success event. First, we save
    the captured photograph into a new variable called `image`. We then check that
    the chosen media was actually a photograph by comparing its `mediaType` property.
    It is at this point that the chosen media could actually be a video, so we must
    double check what it is before we use it, as we don't know whether the user has
    taken a photo or video shot until after it has happened. Finally, to show that
    we have actually captured an image with our camera to the user, we create an ImageView
    and set its `image` property to the captured image file, before adding the entire
    thing to our window.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的大部分处理都在成功事件中完成。首先，我们将捕获的照片保存到一个名为 `image` 的新变量中。然后，我们通过比较其 `mediaType` 属性来检查所选媒体实际上是否为照片。正是在这一点上，所选媒体实际上可能是一段视频，因此在使用它之前，我们必须再次确认它是什么，因为我们不知道用户是在拍照还是拍摄视频，直到事件发生后。最后，为了向用户展示我们实际上已经用我们的相机捕获了一张图片，我们创建了一个
    ImageView 并将其 `image` 属性设置为捕获的图片文件，然后再将整个内容添加到我们的窗口中。
- en: Choosing existing photos from the photo library
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从相册中选择现有照片
- en: The process of choosing an image from the photo library on the device is very
    similar to that of the camera. We are still using the `Titanium.Media` namespace,
    however, this time we are going to execute the method called `openPhotoLibrary()`,
    which does exactly as the name suggests. As with the previous recipe, once we
    have retrieved an image from the Photo Gallery, we will display it on screen to
    the user using a simple ImageView control.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在设备上从相册中选择图片的过程与使用摄像头的非常相似。然而，我们仍然使用 `Titanium.Media` 命名空间，但这次我们将执行名为 `openPhotoLibrary()`
    的方法，正如其名所示。与之前的配方一样，一旦我们从相册中检索到一张图片，我们将使用简单的 ImageView 控件将其显示在屏幕上供用户查看。
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Complete source code for this recipe can be found in the `/Chapter 4/Recipe
    3` folder.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方的完整源代码可在 `/Chapter 4/Recipe 3` 文件夹中找到。
- en: How to do it...
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We are going to further extend our OptionDialog to now choose an image from
    the photo library, if the `index` property of 1 (the second button) is selected.
    Add the following code into your dialog''s event listener:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扩展我们的 OptionDialog，以便现在可以选择从相册中选择一张图片，如果 `index` 属性为 1（第二个按钮）被选中。将以下代码添加到对话框的事件监听器中：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Run your app in the emulator or device and choose the second option from our
    dialog. The photo library should appear and allow you to select an image. This
    selection screen will look something like the following screenshot:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟器或设备上运行您的应用，并从我们的对话框中选择第二个选项。相册库应该会出现，并允许您选择一张图片。此选择屏幕看起来可能如下截图所示：
- en: '![How to do it...](img/3968EXP_04_03.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/3968EXP_04_03.jpg)'
- en: How it works…
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'This recipe follows more or less the same pattern as when we used the camera
    to obtain our image. First, we extended the `OptionDialog` event listener to perform
    an action when the button index selected equals 1, which in this case is our Photo
    Gallery button. Our `openPhotoGallery()` method also fires three events: **success,
    error**, and **cancel**.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方基本上遵循了我们使用摄像头获取图片时的相同模式。首先，我们扩展了 `OptionDialog` 事件监听器，以便在按钮索引选中的等于 1 时执行操作，在这种情况下是我们的相册按钮。我们的
    `openPhotoGallery()` 方法也会触发三个事件：**成功、错误**和**取消**。
- en: Just like the previous recipe, the majority of our processing takes place in
    the success event. We check that the chosen media was actually a photograph by
    comparing its `mediaType` property, and finally we create an ImageView and set
    its `image` property to the captured image file, before adding the entire thing
    to our window.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前的配方一样，我们的大部分处理都在成功事件中完成。我们通过比较其 `mediaType` 属性来检查所选媒体是否实际上是一张照片，并最终创建一个
    ImageView 并将其 `image` 属性设置为捕获的图片文件，然后将整个内容添加到我们的窗口中。
- en: There's more...
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Now, let's explore media types.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索媒体类型。
- en: Understanding Media Types
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解媒体类型
- en: 'There are two main media types available to you via the `mediaType` enumeration
    when capturing photographs or videos via the in-built camera. These are:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过内置摄像头捕获照片或视频时，您可以通过 `mediaType` 枚举获得两种主要的媒体类型。这些是：
- en: '`MEDIA_TYPE_PHOTO`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MEDIA_TYPE_PHOTO`'
- en: '`MEDIA_TYPE_VIDEO`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MEDIA_TYPE_VIDEO`'
- en: 'In addition, there are also numerous other sets of more specific `mediaType''s`
    in the enumeration, which include the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有许多其他更具体的 `mediaType` 枚举集，包括以下内容：
- en: '`MUSIC_MEDIA_TYPE_ALL`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MUSIC_MEDIA_TYPE_ALL`'
- en: '`MUSIC_MEDIA_TYPE_ANY_AUDIO`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MUSIC_MEDIA_TYPE_ANY_AUDIO`'
- en: '`MUSIC_MEDIA_TYPE_AUDIOBOOK`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MUSIC_MEDIA_TYPE_AUDIOBOOK`'
- en: '`MUSIC_MEDIA_TYPE_MUSIC`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MUSIC_MEDIA_TYPE_MUSIC`'
- en: '`MUSIC_MEDIA_TYPE_PODCAST`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MUSIC_MEDIA_TYPE_PODCAST`'
- en: '`VIDEO_MEDIA_TYPE_AUDIO`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VIDEO_MEDIA_TYPE_AUDIO`'
- en: '`VIDEO_MEDIA_TYPE_NONE`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VIDEO_MEDIA_TYPE_NONE`'
- en: '`VIDEO_MEDIA_TYPE_VIDEO`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VIDEO_MEDIA_TYPE_VIDEO`'
- en: These types are generally only applicable when utilizing the `mediaType` property
    from within the `VideoPlayer` or `AudioPlayer` components.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型通常仅在利用 `VideoPlayer` 或 `AudioPlayer` 组件中的 `mediaType` 属性时适用。
- en: Saving to photos
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保存到照片
- en: You can run this code in the emulator, but you'll probably notice that there
    are no images in the library and no obvious way to get them there! Thankfully,
    this is actually fairly easy to overcome. Simply open the web browser and find
    an image you want to test with using Google Images or a similar service. Click
    and hold on an image in the browser and you should see an option **save to photos**.
    You can then use these images to test out your code in the emulator.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在模拟器中运行此代码，但您可能会注意到库中没有图片，也没有明显的获取图片的方法！幸运的是，这实际上相当容易克服。只需打开网络浏览器，并使用 Google
    Images 或类似服务找到您想要测试的图片。在浏览器中点击并按住图片，您应该会看到一个选项**保存到照片**。然后您可以使用这些图片在模拟器中测试您的代码。
- en: Displaying photos using ScrollableView
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ScrollableView 显示照片
- en: One of the most common methods of displaying multiple photographs and images
    on mobile devices is the `ScrollableView`. This view type allows for pictures
    to be swiped left and right, and is common among many applications including Facebook
    mobile. The method of showing images in this way is reminiscent of "flipping"
    through a book or album, and is very popular due to the natural feel and simple
    implementation.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动设备上显示多张照片和图像的最常见方法之一是 `ScrollableView`。这种视图类型允许图片左右滑动，在许多应用中都很常见，包括 Facebook
    移动应用。以这种方式显示图片的方式让人联想到“翻书”或“翻相册”，因为它自然的感觉和简单的实现而非常受欢迎。
- en: In this recipe we will implement a `ScrollableView` which will contain any number
    of images that can be chosen from the camera or photo gallery. Complete source
    code for this recipe can be found in the `/Chapter 4/Recipe 4` folder.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将实现一个 `ScrollableView`，它将包含可以从相机或照片库选择的任意数量的图片。这个食谱的完整源代码可以在 `/Chapter
    4/Recipe 4` 文件夹中找到。
- en: Note
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that this recipe should work for both Android and iPhone devices. However,
    a recent bug in the latest version of Titanium SDK (1.7.2) may cause it to fail
    on Android. You should check whether you are using the latest version of Titanium
    SDK if you wish to test this on the Android emulator.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个食谱应该适用于 Android 和 iPhone 设备。然而，Titanium SDK 最新版本（1.7.2）中的一个最近发现的错误可能会导致它在
    Android 上失败。如果你想在 Android 模拟器上测试这个，你应该检查你是否在使用 Titanium SDK 的最新版本。
- en: How to do it...
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'First, let''s create our ScrollableView object, which we will call `scrollingView`,
    and add it to our `photo.js` window:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建我们的 ScrollableView 对象，我们将称之为 `scrollingView`，并将其添加到我们的 `photo.js` 窗口中：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now we are going to alter the dialog event listener in order to assign our selected
    photos to the ScrollableView, instead of the temporary ImageView we created earlier.
    Replace all of the code within and including your `if(event.mediaType == Ti.Media.MEDIA_TYPE_PHOTO)`
    with the following code. Note you need to do this for both the images gathered
    from the photo library and from the device camera.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将修改对话框事件监听器，以便将我们选定的照片分配给 ScrollableView，而不是我们之前创建的临时 ImageView。将你的 `if(event.mediaType
    == Ti.Media.MEDIA_TYPE_PHOTO)` 代码块及其内部的所有代码替换为以下代码。注意，你需要对从照片库和设备相机收集的图像都这样做。
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now run your app in either the emulator or your device, and select a couple
    of images one after the other. You can use a combination of images from the camera
    or the photo gallery. Once you have selected at least two images, you should be
    able to swipe between them using a left-to-right or right-to-left gesture.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在你的模拟器或设备上运行你的应用，并依次选择一些图片。你可以使用来自相机或照片库的图片组合。一旦你选择了至少两张图片，你应该能够通过左右滑动来在它们之间切换。
- en: How it works…
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The ScrollableView is really just a collection of views that has a number of
    special events and properties built into it, as you can probably tell by the empty
    array value we have given to the property called `views` in the `createScrollableView()`
    method. It is necessary to set this property on instantiating the ScrollableView
    object, and a good idea to set the `currentPage` index property to 0; our first
    view. We are still creating an ImageView as per the previous recipes. However,
    this time we are not adding that View to our window, but to our `ScrollableView`
    component. We do this by adding a view using the `addView()` method. Finally,
    we have also created an event that attaches to our ScrollableView called `scroll`,
    and we are outputting the `currentPage` property to the Titanium console for debugging
    and testing.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ScrollableView 实际上只是一个包含许多特殊事件和属性的视图集合，正如你可能通过我们在 `createScrollableView()` 方法中给
    `views` 属性赋予的空数组值所察觉到的。在实例化 ScrollableView 对象时设置此属性是必要的，将 `currentPage` 索引属性设置为
    0（即我们的第一个视图）也是一个好主意。我们仍然按照之前的食谱创建 ImageView。然而，这次我们不是将这个视图添加到窗口中，而是添加到 `ScrollableView`
    组件中。我们通过使用 `addView()` 方法添加视图来实现这一点。最后，我们还创建了一个事件，将其附加到我们的 ScrollableView 上，并输出
    `currentPage` 属性到 Titanium 控制台以进行调试和测试。
- en: As you can see, the ScrollableView is an easy and simple component and is very
    useful for photo gallery applications or any other apps where you want to display
    a series of similar views. You could extend this by adding a blank View object
    and putting any number of text fields, labels, or image views you want in each
    of those blank views"the only limit here is your imagination!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，ScrollableView 是一个简单且易于使用的组件，非常适合用于相册应用或任何其他需要显示一系列相似视图的应用。您可以通过添加空白 View
    对象并放置任意数量的文本字段、标签或图像视图来扩展它，每个空白视图中都可以放置您想要的任何内容——“这里的唯一限制就是您的想象力！”
- en: '![How it works…](img/3968EXP_04_04.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/3968EXP_04_04.jpg)'
- en: Saving your captured photo to the device filesystem
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将捕获的图片保存到设备文件系统中
- en: Taking pictures is all well and good, but what about when we wish to save an
    image to the filesystemso we can retrieve it again later? In this recipe we will
    do exactly that and also introduce you to the `toImage()` method which is inbuilt
    in many of the Titanium controls. This method takes a flattened image of the entire
    view it is called upon and is extremely useful for taking screenshots or grabbing
    an image of many controls lumped together in a single view.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 拍照固然很好，但当我们希望将图像保存到文件系统中以便稍后再次检索时怎么办？在这个菜谱中，我们将做这件事，并介绍内置在许多 Titanium 控件中的 `toImage()`
    方法。此方法接受被调用视图的整个视图的扁平化图像，对于截图或抓取单个视图中组合在一起的多个控件图像非常有用。
- en: Note
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Complete source code for this recipe can be found in the `/Chapter 4/Recipe
    5` folder.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的完整源代码可以在 `/Chapter 4/Recipe 5` 文件夹中找到。
- en: How to do it...
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Type in the following code after your `btnGetPhoto` object is created. You can
    replace the existing code that we've written to add the `btnGetPhoto` object to
    the navigation bar, as this code repeats that code and also extends it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 `btnGetPhoto` 对象之后，输入以下代码。您可以替换我们编写的将 `btnGetPhoto` 对象添加到导航栏的现有代码，因为这段代码重复了那段代码并进行了扩展。
- en: '[PRE6]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works…
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `Titanium.FileSystem` namespace opens up a range of file manipulation capabilities,
    but most importantly, gives us the basic tools in order to read and write a file
    to the application's storage space on the device. In this recipe we are using
    the `toImage()` method of the `scrollingView` to return a blob of the view's image
    representation.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Titanium.FileSystem` 命名空间提供了一系列文件操作功能，但最重要的是，它为我们提供了基本工具，以便将文件读写到设备上应用程序的存储空间。在这个菜谱中，我们使用
    `scrollingView` 的 `toImage()` 方法来返回视图图像表示的 blob。'
- en: We can then get a reference to the folder we wish to store the image file data
    in. As you can see in the code, we are getting a reference to that folder by creating
    a new variable such as `var newDir = Titanium.Filesystem.getFile(Titanium.Filesystem.applicationDataDirectory,'photos')`;
    and then ensuring that the folder exists. If it doesn't exist, we can create the
    folder by calling the `createDirectory()` method on our `newDir` object.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以获取我们希望存储图像文件数据的文件夹的引用。如您在代码中所见，我们通过创建一个新变量，例如 `var newDir = Titanium.Filesystem.getFile(Titanium.Filesystem.applicationDataDirectory,'photos')`
    来获取该文件夹的引用；然后确保该文件夹存在。如果不存在，我们可以通过在 `newDir` 对象上调用 `createDirectory()` 方法来创建该文件夹。
- en: Finally, our image data is saved in much the same way. First, we create a variable
    called `writeFile`, which is referencing our file name within the `newDir` object
    folder we have already created. We can then output the file to the filesystem
    using `writeFile's "write()"` method, passing in the image media variable as the
    file data to save.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的图像数据以类似的方式保存。首先，我们创建一个名为 `writeFile` 的变量，它引用我们已创建的 `newDir` 对象文件夹中的文件名。然后，我们可以使用
    `writeFile` 的 `"write()"` 方法将文件输出到文件系统，并将图像媒体变量作为要保存的文件数据传递。
- en: Capturing and playing audio via the audio recorder
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过音频录制器捕获和播放音频
- en: Another handy feature of the iPhone and most Android handsets is the ability
    to record audio data—perfect for taking audible notes during meetings or those
    long, boring lectures! In this recipe we are going to capture some audio using
    the `Titanium.Media.AudioRecorder` class, and then allow the user to play back
    the recorded sound file.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: iPhone 和大多数 Android 手机的一个方便功能是能够录制音频数据——非常适合在会议或那些漫长、无聊的讲座中做可听笔记！在这个菜谱中，我们将使用
    `Titanium.Media.AudioRecorder` 类捕获一些音频，然后允许用户播放录制的声音文件。
- en: Complete source code for this recipe can be found in the `/Chapter 4/Recipe
    6` folder.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的完整源代码可以在 `/Chapter 4/Recipe 6` 文件夹中找到。
- en: Note
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that this recipe will only work for the iPhone. You will also require a
    physical device for this recipe. Later versions of the Titanium framework should
    support audio recording for Android via the use of intents. In addition, the iPhone
    3G models may not be capable of recording in some of the following compression
    formats, particularly high fidelity formats such as AAC. When in doubt, you should
    try using MP4A or WAV formats.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个菜谱只适用于iPhone。您还需要一个物理设备来完成这个菜谱。Titanium框架的后续版本应该可以通过使用意图来支持Android的音频录制。此外，iPhone
    3G型号可能无法录制以下某些压缩格式，尤其是高保真格式，如AAC。如有疑问，您应该尝试使用MP4A或WAV格式。
- en: Getting ready
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new JavaScript file called `audio.js` and save it into your resources
    directory. Then back in your `app.js` file, add the URL property of window3, and
    give it a value of `audio.js`. This will load up our video JavaScript file for
    the third tab window of our application.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`audio.js`的新JavaScript文件，并将其保存到您的资源目录中。然后在`app.js`文件中，添加window3的URL属性，并给它一个值为`audio.js`。这将加载我们的视频JavaScript文件，用于应用程序的第三个选项卡窗口。
- en: How to do it...
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Type in the following code into your `audio.js` file and save. This will set
    up the interface with a set of buttons and labels so we can start, stop, and playback
    our recorded audio.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码输入到您的`audio.js`文件中并保存。这将设置一个带有按钮和标签的界面，以便我们可以开始、停止和播放我们的录音音频。
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now run your application in the emulator and switch to the **Audio** tab. You
    should see a screen that looks just like the following screenshot:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在模拟器中运行您的应用程序，并切换到**音频**选项卡。你应该会看到一个看起来就像以下截图的屏幕：
- en: '![How to do it...](img/3968EXP_04_05.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/3968EXP_04_05.jpg)'
- en: 'Now we''re going to create an object instance of the `AudioRecorder` method
    called `recording`, and give it a compression value and format value. We will
    also add event listeners to watch out for when the volume, audio line, and recording
    properties change, along with event handlers to capture and process these changes.
    Type in the following directly after the code you created from the previous page:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个名为`recording`的`AudioRecorder`方法的对象实例，并给它一个压缩值和格式值。我们还将添加事件监听器以监视音量、音频线路和录音属性何时发生变化，以及事件处理程序来捕获和处理这些变化。在上一页创建的代码之后直接输入以下内容：
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Finally, add the section of code after your `Ti.Media` event listeners that
    you created previously. This code will handle all of the events for the audio
    input controls (the stop/start buttons and our high-fidelity switch).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在您之前创建的`Ti.Media`事件监听器之后添加代码部分。此代码将处理音频输入控制的所有事件（停止/开始按钮和我们的高保真开关）。
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now run your application on a device (the simulator may not be capable of recording
    audio) and you should be able to start, stop, and then playback your audio recording,
    while the high fidelity switch will change the audio compression to a higher fidelity
    format.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在设备上运行您的应用程序（模拟器可能无法录制音频），你应该能够开始、停止，然后播放您的音频录音，同时高保真开关将改变音频压缩为更高保真度的格式。
- en: How it works…
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe we are creating an instance of the `AudioRecorder` object, and
    we have called this new object `recording`. We're giving this object a compression
    and audio format. For now, we have set these to the default (PCM compression and
    standard CAF format). Listeners from the `Titanium.Media` namespace are then added,
    which when fired will change the line type or volume labels respectively.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们正在创建一个`AudioRecorder`对象的实例，并将其命名为`recording`。我们给这个对象设置了压缩和音频格式。目前，我们将其设置为默认值（PCM压缩和标准CAF格式）。然后，我们添加了来自`Titanium.Media`命名空间的事件监听器，当它们被触发时，将分别更改线条类型或音量标签。
- en: The main processing for this recipe happens within the event handlers for the
    "Start/Stop" and "Playback" buttons called `b1` and `b2` respectively. Our first
    button, `b1`, is first checking its title to determine whether to stop or start
    recording via a simple if statement. If recording has not started, then we kick
    off the process by calling the `start` method of our `recording` object. To do
    so, we also need to start the microphone monitor, which is done by executing the
    line `Ti.Media.startMicrophoneMonitor()`. Our device will then begin recording.
    Tapping the `b1` button again will execute the stop code and simultaneously set
    our file object (the resulting sound-audio file) to the output from our `recording`
    object.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱的主要处理发生在“开始/停止”和“播放”按钮的事件处理器中，分别称为`b1`和`b2`。我们的第一个按钮`b1`首先检查其标题以确定是停止还是开始录音，通过一个简单的if语句。如果没有开始录音，那么我们通过调用我们的`recording`对象的`start`方法启动这个过程。为此，我们还需要启动麦克风监控器，这是通过执行`Ti.Media.startMicrophoneMonitor()`行来完成的。然后我们的设备将开始录音。再次点击`b1`按钮将执行停止代码，并同时将我们的文件对象（生成的声音音频文件）设置为`recording`对象的输出。
- en: The `b2` button event handler checks whether we have a valid sound file, and
    whether it is already playing. If we have a valid file and it's playing, then
    the playback will stop. Otherwise, if there is a valid sound file and it hasn't
    already been played back through the speaker, we are creating a new object called
    `sound`, using the `Titanium.Media.createSound` method. This method requires a
    `sound` parameter. We passed the `file` object to it that was created during our
    recording session. Executing the `sound` object's `play` method then kicks off
    the playback, while the event listener/handler for the playback completion resets
    our `b2` button title when the playback has completed.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`b2`按钮事件处理器检查我们是否有一个有效的声音文件，以及它是否已经在播放。如果我们有一个有效的文件并且它正在播放，那么播放将停止。否则，如果有有效的声音文件并且它还没有通过扬声器播放过，我们将创建一个新的对象，称为`sound`，使用`Titanium.Media.createSound`方法。此方法需要一个`sound`参数。我们将创建于我们的录音会话期间的`file`对象传递给它。然后执行`sound`对象的`play`方法开始播放，同时播放完成的事件监听器/处理器在播放完成后重置我们的`b2`按钮标题。'
- en: Finally, the switch (called `switcher` in this example) simply changes the recording
    format from high fidelity compression to a low one. The lower the quality and
    compression, the smaller the resulting audio file will end up being.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，开关（在这个例子中称为`switcher`）只是将录制格式从高保真压缩更改为低压缩。质量和压缩越低，最终生成的音频文件将越小。
- en: Capturing video via the video recorder
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过视频录制捕获视频
- en: You can also use the inbuilt camera of your iPhone (3GS and above) or Android
    device to record video. The quality and length of the video that you can record
    is dependant on both your device's memory capabilities and the type of camera
    that's included in the hardware. However, you should at least be able to capture
    short video clips in VGA resolution as a minimum.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用iPhone（3GS及以上）或Android设备的内置相机录制视频。您可以录制的视频质量和长度取决于您的设备内存能力和硬件中包含的相机类型。然而，您至少应该能够以VGA分辨率捕获短视频剪辑作为最低要求。
- en: 'In this recipe we will create a basic interface for our **Video** tab consisting
    of a record button, which will launch the camera and record video on your device.
    We''ll also perform this in two separate ways: using standard Titanium code for
    the iPhone and using intents for Android.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将为我们的**视频**标签创建一个基本界面，包括一个录制按钮，该按钮将启动相机并在您的设备上录制视频。我们还将以两种不同的方式执行此操作：使用iPhone的标准Titanium代码和使用Android的意图。
- en: Note
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that this recipe will require a physical device for testing. In addition,
    the iPhone 3G models are not be capable of recording video, but all models from
    the 3GS and upwards should be fine.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此菜谱将需要一个物理设备进行测试。此外，iPhone 3G型号无法录制视频，但所有从3GS开始的型号应该都没有问题。
- en: Getting ready
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new JavaScript file called `video.js` and save it into your resources
    folder. Then, back in your `app.js` file, add the URL property of window2 and
    give it a value of `video.js`. This will load up our video JavaScript file for
    the second tab window of our application.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`video.js`的新JavaScript文件，并将其保存到您的资源文件夹中。然后，在`app.js`文件中，添加window2的URL属性并给它一个值为`video.js`。这将加载我们的视频JavaScript文件作为应用程序第二个标签窗口的文件。
- en: Note
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Complete source code for this recipe can be found in the `/Chapter 4/Recipe
    7` folder.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱的完整源代码可以在`/Chapter 4/Recipe 7`文件夹中找到。
- en: How to do it...
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: First of all, let's set up the basic interface to have a record button (in the
    navigation bar section for the iPhone and as a normal button for Android), along
    with the `videoFile` variable. This will hold the path to our recorded video as
    a string.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们设置基本界面，添加一个录制按钮（在iPhone的导航栏部分作为正常按钮，在Android上作为正常按钮），以及`videoFile`变量。这个变量将保存我们录制视频的路径作为一个字符串。
- en: '[PRE10]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now let''s create the event listener and handler code for the record button.
    This will check our current platform (either iPhone or Android) and execute the
    record video code for the correct platform:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为录制按钮创建事件监听器和处理代码。这将检查我们的当前平台（iPhone或Android），并执行正确平台的录制视频代码：
- en: '[PRE11]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works…
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Let's work through the code for recording on iPhone devices first, which is
    encapsulated within the `if(Titanium.Plaform.osname == 'iphone')` statement as
    mentioned in the previous code. Here, we are executing the camera in the same
    way you would for capturing plain photos, however, we're passing additional parameters.
    The first of these is called `mediaType`, and it tells the device we want to capture
    a `mediaType` of `MEDIA_TYPE_VIDEO`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从iPhone设备的录制代码开始，如前一段代码中提到的`if(Titanium.Plaform.osname == 'iphone')`语句封装。在这里，我们以与捕获普通照片相同的方式执行相机，但是传递了额外的参数。第一个参数称为`mediaType`，它告诉设备我们想要捕获一个`mediaType`为`MEDIA_TYPE_VIDEO`的媒体类型。
- en: The other two parameters define how long and what quality to capture the video
    in. The parameter `videoMaximumDuration` float defines the duration (how long
    in milliseconds to allow capture before completing,) while the `videoQuality`
    constant indicates the video quality during capture. We have set these to 10 seconds
    (10,000 milliseconds) and a video quality of "high" respectively.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 其他两个参数定义了录制视频的时长和质量。参数`videoMaximumDuration`是一个浮点数，定义了录制时长（在完成前允许捕获的毫秒数），而`videoQuality`常量表示捕获期间的视频质量。我们将其设置为10秒（10,000毫秒）和“高”质量。
- en: On successful video capture, we save the `event.media` (our video in its raw
    format) to the filesystem, using pretty much the same method as we did when saving
    a photograph. The final step is to set the `videoFile` path to the location of
    our newly saved video file on the filesystem.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功录制视频后，我们使用与保存照片时几乎相同的方法将`event.media`（我们的原始格式视频）保存到文件系统。最后一步是将`videoFile`路径设置为文件系统中新保存的视频文件的位置。
- en: For Android, we are capturing the video in a different way, using an *intent*.
    In this case, we're using the video capture intent called `android.media.action.VIDEO_CAPTURE`.
    Objects of type `android.content.Intent` are used to send asynchronous messages
    within your application or between applications. Intents allow the application
    to send or receive data to and from other activities or services. They also allow
    it to broadcast that a certain event has occurred. In our recipe's code, we are
    executing our Intent and then capturing the result—if the `resultCode` equals
    `Titanium.Android.RESULT_OK` then we know that we've managed to record a video
    clip. We can then move this file from its temporary storage location to a new
    destination of our choosing.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Android，我们以不同的方式捕获视频，使用一个*intent*。在这种情况下，我们使用名为`android.media.action.VIDEO_CAPTURE`的视频捕获intent。`android.content.Intent`类型的对象用于在您的应用程序内或应用程序之间发送异步消息。Intents允许应用程序向其他活动或服务发送或接收数据。它们还允许它广播某个事件已发生。在我们的食谱代码中，我们执行我们的Intent并捕获结果——如果`resultCode`等于`Titanium.Android.RESULT_OK`，那么我们知道我们已经成功录制了一段视频。然后我们可以将此文件从其临时存储位置移动到我们选择的新位置。
- en: Note
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we are capturing video in 3GP format for Android while it was in MP4/MOV
    format on the iPhone.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在Android上以3GP格式捕获视频，而在iPhone上则是MP4/MOV格式。
- en: Playing video files from the filesystem
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从文件系统播放视频文件
- en: Now that we have recorded video, what about playing it back? Titanium has an
    inbuilt video player component that can play both local files and remote video
    URLs. In this recipe we'll show you how to create the video player control and
    pass the local file URL of the video we captured in the previous recipe to it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经录制了视频，那么如何播放它呢？Titanium内置了一个视频播放组件，可以播放本地文件和远程视频URL。在本食谱中，我们将向您展示如何创建视频播放控件，并将之前食谱中捕获的视频的本地文件URL传递给它。
- en: Note
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Complete source code for this recipe can be found in the `/Chapter 4/Recipe
    8` folder.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的完整源代码可以在`/Chapter 4/Recipe 8`文件夹中找到。
- en: How to do it...
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'In our `videos.js` file, underneath the declaration for the `videoFile` object,
    create the following function:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `videos.js` 文件中，在 `videoFile` 对象声明下方，创建以下函数：
- en: '[PRE12]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, in your event listener for `btnGetVideo`, extend the code so that it
    checks the button title and plays the recorded video when it has been saved:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在你的 `btnGetVideo` 事件监听器中扩展代码，以便它检查按钮标题，并在视频已保存时播放记录的视频：
- en: '[PRE13]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works…
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Creating a video player object is no different than creating Labels or Buttons
    as many of the same properties are utilized for positioning and layout. The player
    can be embedded into any other view as you would do with a normal control, meaning
    you could have video thumbnails playing directly from within the rows of a TableView
    if you wanted. Additionally, the Video Player can play both local and remote videos
    (using the Video `url` property). In this recipe, we are uploading a saved video
    from the filesystem that was captured by the camcorder on our device.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 创建视频播放器对象与创建标签或按钮没有区别，因为许多相同的属性都用于定位和布局。播放器可以被嵌入到任何其他视图中，就像使用正常控件一样，这意味着如果你愿意，可以在TableView的行中直接播放视频缩略图。此外，视频播放器可以播放本地和远程视频（使用视频
    `url` 属性）。在本菜谱中，我们正在上传由设备上的摄像机捕获的已保存视频。
- en: You could just as easily load a video from a URL or directly from within your
    `Resources` folder. There is a 10 second video attached to the source code for
    this chapter in both `mp4` and `3gp` formats for you to test with, called `video-test.mp4`.
    You can also attempt to load it remotely using the web address [http://boydlee.com/video-test.mp4](http://boydlee.com/video-test.mp4).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你同样可以从URL或直接从你的 `Resources` 文件夹中加载视频。本章源代码中附有一个10秒的视频，格式为 `mp4` 和 `3gp`，你可以用来测试，名为
    `video-test.mp4`。你也可以尝试使用以下网络地址远程加载它：[http://boydlee.com/video-test.mp4](http://boydlee.com/video-test.mp4)。
- en: Note
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that some web video formats such as FLV are not supported.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，某些网络视频格式，如FLV，不受支持。
- en: There's more…
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: If you want your video to play using the full screen dimensions and not just
    within a view, then you can set its `fullscreen` property to `true`. This will
    automatically load the video into fullscreen mode when it starts playing.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望视频使用全屏尺寸播放，而不仅仅是视图内，那么你可以将其 `fullscreen` 属性设置为 `true`。这将在视频开始播放时自动将其加载到全屏模式。
- en: '![There''s more…](img/3968EXP_04_06.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多…](img/3968EXP_04_06.jpg)'
- en: Safely deleting saved files from the filesystem
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全地从文件系统中删除已保存的文件
- en: We can create these files and write them to our local phone storage, but what
    about deleting them? In this recipe we'll explain how to safely check for and
    delete files using the `Titanium.Filesystem.File` namespace.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建这些文件并将它们写入我们的本地手机存储，但删除它们怎么办？在本菜谱中，我们将解释如何使用 `Titanium.Filesystem.File`
    命名空间安全地检查和删除文件。
- en: Note
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Complete source code for this recipe can be found in the `/Chapter 4/Recipe
    9` folder.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的完整源代码可以在 `/Chapter 4/Recipe 9` 文件夹中找到。
- en: How to do it...
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Back in your `photos.js` file, add the following button code with an event listener
    at the end of the file. This will be our "trash" button and will call the delete
    function on the current selected image.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 `photos.js` 文件中，在文件末尾添加以下按钮代码，并添加一个事件监听器。这将是我们“垃圾桶”按钮，它将在当前选定的图像上调用删除函数。
- en: '[PRE14]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add an extra line to our existing `btnSaveCurrentPhoto` click event to make
    our trash button visible only after a photo has actually been saved to the disk:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们现有的 `btnSaveCurrentPhoto` 点击事件中添加一个额外的行，以便在照片实际上已保存到磁盘后，我们的垃圾桶按钮才可见：
- en: '[PRE15]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, extend your button''s event listener to delete the file, only after
    making sure that it already exists, before adding our button to the window:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，扩展按钮的事件监听器以删除文件，但在添加按钮到窗口之前，确保它已经存在：
- en: '[PRE16]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works…
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: File manipulation is all done using methods on the file object, unlike many
    other languages where a "delete" function normally means passing the file object
    into said function to be deleted. In our recipe, you can see we're simply creating
    the file object as we did previously in the recipe on saving photos to the filesystem.
    But instead of writing the object to disk, we're checking its existence and then
    calling `[file-object].deleteFile()`. All file manipulations in Titanium is done
    in this manner. For example, if you wanted to rename the file, you would simply
    create the object and call the `rename()` method, passing in the new value as
    a string parameter.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 文件操作全部是通过文件对象上的方法完成的，与许多其他语言中通常意味着将文件对象传递到删除函数中删除的情况不同。在我们的配方中，你可以看到我们像之前在保存照片到文件系统配方中那样简单地创建文件对象。但是，我们不是将对象写入磁盘，而是检查其存在，然后调用
    `[file-object].deleteFile()`。在 Titanium 中所有文件操作都是以这种方式完成的。例如，如果你想重命名文件，你只需创建对象并调用
    `rename()` 方法，传入新的字符串参数。
- en: You may have also noticed that we gave the trash button a parameter called `zIndex`,
    which we have set to `2`. The `zIndex` defines the stack order of a component.
    Components with a higher `zIndex` will always appear above those with a lower
    `zIndex`. In this case, we've given the trash button an index of `2`, so that
    it appears above the other elements whose default `zIndex` value is `0`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也注意到了，我们给垃圾按钮设置了一个名为 `zIndex` 的参数，并将其设置为 `2`。`zIndex` 定义了组件的堆叠顺序。`zIndex`
    较高的组件将始终显示在 `zIndex` 较低的组件之上。在这种情况下，我们给垃圾按钮分配了一个 `2` 的索引，这样它就会显示在其他默认 `zIndex`
    值为 `0` 的元素之上。
- en: 'The following screenshot shows the trash icon visible on our newly saved file,
    and the message alert that appears confirming it''s deletion from the filesystem:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了新保存的文件上可见的垃圾箱图标，以及确认从文件系统中删除的消息提示：
- en: '![How it works…](img/3968EXP_04_07.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/3968EXP_04_07.jpg)'
- en: There's more...
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'A full list of the `Titanium.Filesystem.File` methods is available at the Appcelerator''s
    website under the current API documentation, at: [http://developer.appcelerator.com/apidoc/mobile/latest/Titanium.Filesystem.File-object](http://developer.appcelerator.com/apidoc/mobile/latest/Titanium.Filesystem.File-object)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`Titanium.Filesystem.File` 方法的完整列表可以在 Appcelerator 的网站上找到，位于当前 API 文档下，网址为：[http://developer.appcelerator.com/apidoc/mobile/latest/Titanium.Filesystem.File-object](http://developer.appcelerator.com/apidoc/mobile/latest/Titanium.Filesystem.File-object)'
