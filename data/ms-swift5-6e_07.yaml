- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Functions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: When I first learned to program with BASIC, my first few programs were written
    in one long block of code. I quickly realized that I was repeating the same code
    over and over. I thought that there must be a better way to do this, which was
    when I learned about subroutines and functions. Functions are one of the key concepts
    that you need to understand to write good code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当我最初用BASIC学习编程时，我的前几个程序都是用一大块代码编写的。我很快意识到我一直在重复相同的代码。我想一定有更好的方法来做这件事，也就是我学习子程序和函数的时候。函数是编写良好代码时需要理解的关键概念之一。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: What are functions?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是函数？
- en: How to return values from a function
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何从函数返回值
- en: How to use parameters in a function
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在函数中使用参数
- en: What are variadic parameters?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是可变参数？
- en: What are `inout` parameters?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是`inout`参数？
- en: In Swift, a function is a self-contained block of code that performs a specific
    task. Functions are generally used to logically break our code into reusable named
    blocks. The function's name is used to call the function.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，函数是一个执行特定任务的独立代码块。函数通常用于将我们的代码逻辑地分解成可重用的命名块。函数的名称用于调用函数。
- en: When we define a function, we can also optionally define one or more parameters.
    Parameters are named values that are passed into the function by the code that
    calls it. These parameters are generally used within the function to perform the
    task of the function. We can also define default values for the parameters to
    simplify how the function is called.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义一个函数时，我们还可以选择性地定义一个或多个参数。参数是通过调用它的代码传递给函数的命名值。这些参数通常在函数内部用于执行函数的任务。我们还可以为参数定义默认值，以简化函数的调用方式。
- en: Every Swift function has a type associated with it. This type is referred to
    as the return type and it defines the types of data returned from the function
    to the code that called it. If a value is not returned from a function, the return
    type is `Void`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Swift函数都有一个与其关联的类型。这个类型被称为返回类型，它定义了从函数返回到调用它的代码的数据类型。如果一个函数没有返回值，则返回类型为`Void`。
- en: Let's look at how to define functions in Swift.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在Swift中定义函数。
- en: Using a single-parameter function
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用单参数函数
- en: 'The syntax that''s used to define a function in Swift is very flexible. This
    flexibility makes it easy for us to define simple C-style functions, or more complex
    functions with local and external parameter names, which we will see later in
    this chapter. Let''s look at some examples of how to define functions. The following
    example accepts one parameter and does not return any value to the code that called
    it:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中定义函数的语法非常灵活。这种灵活性使得我们能够轻松地定义简单的C风格函数，或者更复杂的具有局部和外部参数名称的函数，我们将在本章后面看到。让我们看看一些定义函数的例子。以下示例接受一个参数，但不向调用它的代码返回任何值：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding example, we defined a function named `sayHello()` that accepted
    one parameter, named `name`. Inside the function, we printed out a greeting to
    the person. Once the code within the function is executed, the function exits,
    and control is returned to the code that called it. Rather than printing out the
    greeting, we could return it to the code that called it by adding a return type,
    as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们定义了一个名为`sayHello()`的函数，它接受一个名为`name`的参数。在函数内部，我们打印了一条问候信息给这个人。一旦函数内部的代码执行完毕，函数就会退出，控制权返回到调用它的代码。我们不仅可以将问候信息打印出来，还可以通过添加返回类型将其返回给调用它的代码，如下所示：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `->` string defines the return type associated with the function as a string.
    This means that the function must return an instance of the `String` type to the
    code that calls it. Inside the function, we build a string constant, named `retString`,
    with the greeting message and then return it using the `return` statement.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`->`字符串定义了与函数关联的返回类型为字符串。这意味着该函数必须返回一个`String`类型的实例给调用它的代码。在函数内部，我们构建了一个名为`retString`的字符串常量，其中包含问候信息，然后使用`return`语句返回它。'
- en: 'Calling a Swift function is a similar process to calling functions or methods
    in other languages, such as C or Java. The following example shows how to call
    the `sayHello(name:)` function, which prints the greeting message to the screen:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 调用Swift函数的过程与其他语言（如C或Java）中调用函数或方法的过程类似。以下示例展示了如何调用`sayHello(name:)`函数，该函数将问候信息打印到屏幕上：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, let''s look at how to call the `sayHello2(name:)` function, which returns
    a value to the code that called it:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何调用`sayHello2(name:)`函数，该函数将值返回给调用它的代码：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding example, we called the `sayHello2(name:)` function and inputted
    the value that was returned in the `message` variable. If a function defines a
    return type as the `sayHello2(name:)` function does, it must return a value of
    that type to the code that called it. Therefore, every possible conditional path
    within the function must end by returning a value of the specified type. This
    does not mean that the code that called the function is required to retrieve the
    returned value. As an example, both lines in the following snippet are valid:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们调用了`sayHello2(name:)`函数，并将返回值赋给了`message`变量。如果一个函数定义了返回类型，就像`sayHello2(name:)`函数那样，它必须向调用它的代码返回该类型的一个值。因此，函数中每个可能的条件路径都必须以返回指定类型的值结束。这并不意味着调用函数的代码必须检索返回的值。以下是一个示例，以下两个语句都是有效的：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you do not specify a variable for the return value to go into, the value
    is dropped. When the code is compiled, you will receive a warning if a function
    returns a value and you do not put it into a variable or a constant. You can avoid
    this warning by using an underscore, as shown in the following example:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有指定变量来存储返回值，该值将被丢弃。当代码编译时，如果你没有将函数返回的值放入变量或常量中，你会收到一个警告。你可以通过使用下划线来避免这个警告，如下面的示例所示：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The underscore tells the compiler that you are aware of the return value, but
    you do not want to use it. Using the `@discardableResult` attribute when declaring
    a function will also silence the warning. This attribute is used as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 下划线告诉编译器你已经知道返回值，但不想使用它。在声明函数时使用`@discardableResult`属性也会消除警告。该属性的使用方法如下：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With SE-0255 in Swift 5.1, we can omit the `return` statement in single expression
    functions. Let''s look at the following code as an example of what this would
    look like:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift 5.1的SE-0255中，我们可以省略单表达式函数中的`return`语句。以下代码将展示这种情况：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This function is defined similarly to the previous hello functions with a `String`
    return type; however, you will notice that there is no return statement in the
    function. With SE-0255, if we have a function with a single expression, like the
    `sayHello4(name:)` function, the value of the expression can be returned without
    the need of the `return` statement. If we called the function like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数与之前的hello函数定义类似，具有`String`返回类型；然而，你会注意到函数中没有返回语句。根据SE-0255，如果我们有一个像`sayHello4(name:)`函数这样的单表达式函数，表达式的值可以在不需要`return`语句的情况下返回。如果我们像这样调用函数：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `message` constant would contain the string `"Hello Kara"`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`message`常量将包含字符串`"Hello Kara"`。'
- en: Let's look at how we would define multiple parameters for our functions.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何为我们的函数定义多个参数。
- en: Using a multi-parameter function
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多参数函数
- en: 'We are not limited to just one parameter with our functions; we can also define
    multiple parameters. To create a multi-parameter function, we list the parameters
    in parentheses and separate the parameter definitions with commas. Let''s look
    at how to define multiple parameters in a function:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的函数不仅限于只有一个参数；我们还可以定义多个参数。要创建一个多参数函数，我们在括号中列出参数，并用逗号分隔参数定义。让我们看看如何在函数中定义多个参数：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the preceding example, the function accepts two arguments: `name` and `greeting`.
    We then print a greeting to the console using both parameters.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，该函数接受两个参数：`name`和`greeting`。然后我们使用这两个参数在控制台打印问候语。
- en: 'Calling a multi-parameter function is a little different from calling a single-parameter
    function. When calling a multi-parameter function, we separate the parameters
    with commas. We also need to include the parameter name for all the parameters.
    The following example shows how to call a multi-parameter function:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 调用一个多参数函数与调用一个单参数函数略有不同。在调用多参数函数时，我们用逗号分隔参数。我们还需要为所有参数包含参数名称。以下示例显示了如何调用多参数函数：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We do not need to supply an argument for each parameter of the function if we
    define default values. Let's look at how to configure default values for our parameters.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为函数的每个参数定义了默认值，我们就不需要为每个参数提供一个参数。让我们看看如何为我们的参数配置默认值。
- en: Defining a parameter's default values
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义参数的默认值
- en: 'We can define default values for any parameter by using the equal to operator
    (`=`) within the function definition when we declare the parameters. The following
    example shows how to declare a function with a parameter''s default values:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在函数定义中声明参数时使用等于运算符（`=`）来为任何参数定义默认值。以下示例展示了如何声明一个具有参数默认值的函数：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the function declaration, we have defined one parameter without a default
    value `(name:String)` and one parameter with a default value `(greeting: String
    = "Bonjour")`. When a parameter has a default value declared, we can call the
    function with or without setting a value for that parameter. The following example
    shows how to call the `sayHello()` function without setting the `greeting` parameter,
    and also how to call it when you do set the `greeting` parameter:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '在函数声明中，我们定义了一个没有默认值的参数 `(name:String)` 和一个有默认值的参数 `(greeting: String = "Bonjour")`。当一个参数有默认值声明时，我们可以带或不带设置该参数的值来调用函数。以下示例展示了如何不带设置
    `greeting` 参数来调用 `sayHello()` 函数，以及如何设置 `greeting` 参数来调用它：'
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the `sayHello(name:"Jon")` line, the function will print out the message
    `Bonjour Jon` since it uses the default value for the `greeting` parameter. In
    the `sayHello(name:"Jon", greeting: "Hello")` line, the function will print out
    the message `Hello Jon` since we have overridden the default value for the `greeting`
    parameter.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '在 `sayHello(name:"Jon")` 这一行，函数将打印出消息 `Bonjour Jon`，因为它使用了 `greeting` 参数的默认值。在
    `sayHello(name:"Jon", greeting: "Hello")` 这一行，函数将打印出消息 `Hello Jon`，因为我们已经覆盖了 `greeting`
    参数的默认值。'
- en: 'We can declare multiple parameters with default values and override only the
    ones we want by using the parameter names. The following example shows how we
    would do this by overriding one of the default values when we call it:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用参数名称来声明多个具有默认值的参数，并且只覆盖我们想要的那些。以下示例展示了我们如何通过在调用时覆盖其中一个默认值来实现这一点：
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding example, we declared a function with three parameters, each
    with a default value. We then called the function, leaving the `name2` parameter
    with its default value, while overriding the default values for the remaining
    two parameters.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们声明了一个有三个参数的函数，每个参数都有一个默认值。然后我们调用该函数，将 `name2` 参数保留为其默认值，同时覆盖了剩余两个参数的默认值。
- en: The preceding example will print out the message `Hello Jon and Kailey`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子将打印出消息 `Hello Jon and Kailey`。
- en: Now, let's see how we can return multiple values from a function.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何从函数中返回多个值。
- en: Returning multiple values from a function
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从函数中返回多个值
- en: There are a couple of ways to return multiple values from a Swift function.
    One of the most common ways is to put the values into a collection type (an array
    or dictionary) and then return the collection.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Swift 函数中返回多个值有几种方法。其中最常见的一种是将值放入一个集合类型（数组或字典）中，然后返回该集合。
- en: 'The following example shows how to return a collection type from a Swift function:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何从 Swift 函数中返回一个集合类型：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding example, we declared the `getNames()` function with no parameters
    and a return type of `[String]`. The return type of `[String]` specifies the return
    type to be an array of string types.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们声明了 `getNames()` 函数，它没有参数，返回类型为 `[String]`。`[String]` 的返回类型指定了返回类型为字符串类型的数组。
- en: In the preceding example, our array could only return string types. If we needed
    to return numbers with our strings, we could return an array of the `Any` type
    and then use typecasting to specify the `object` type. However, this would not
    be a good design for our application, as it would be prone to errors. A better
    way to return values of different types would be to use a `tuple` type.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们的数组只能返回字符串类型。如果我们需要返回包含数字的字符串，我们可以返回一个 `Any` 类型的数组，然后使用类型转换来指定 `object`
    类型。然而，这并不是我们应用程序的好设计，因为它容易出错。返回不同类型值的一个更好的方法是用 `tuple` 类型。
- en: 'When we return a tuple from a function, it is recommended that we use a named
    tuple to allow us to use the dot syntax to access the returned values. The following
    example shows how to return a named tuple from a function and access the values
    from the named tuple that is returned:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从函数中返回一个元组时，建议我们使用命名元组，这样我们可以使用点语法来访问返回的值。以下示例展示了如何从函数中返回一个命名元组并访问返回的命名元组的值：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding example, we defined the `getTeam()` function, which returned
    a named tuple that contains three values: `String`, `Int`, and `Double`. Within
    the function, we created the tuple that we were going to return. Notice that we
    did not need to define the tuple that we were going to return as a named tuple,
    as the value types within the tuple matched the value types in the function definition.
    We can now call the function as we would any other function, and use the dot syntax
    to access the values of the tuple that is returned. In the preceding example,
    the code would print out the following line:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们定义了`getTeam()`函数，该函数返回一个包含三个值的命名元组：`String`、`Int`和`Double`。在函数内部，我们创建了将要返回的元组。请注意，我们不需要将将要返回的元组定义为命名元组，因为元组内的值类型与函数定义中的值类型相匹配。现在我们可以像调用其他函数一样调用这个函数，并使用点语法来访问返回的元组的值。在先前的例子中，代码将打印出以下行：
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the previous sections, we returned non-nil values from our function; however,
    that is not always what we need our code to do. What happens if we need to return
    a nil value from a function? The following code would not be valid and would cause
    a `Nil is incompatible with return type String` exception:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们从函数中返回了非`nil`值；然而，这并不总是我们需要我们的代码做的事情。如果我们需要从函数中返回一个`nil`值，会发生什么？以下代码将无效并引发`Nil
    is incompatible with return type String`异常：
- en: '[PRE17]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This code throws an exception because we have defined the return type as a
    string value, but we are attempting to return a `nil` value. If there is a reason
    to return nil, we need to define the return type as an optional type to let the
    code calling it know that the value may be nil. To define the return type as an
    optional type, we use the question mark (`?`) in the same way as we did when we
    defined a variable as an optional type. The following example shows how to define
    an optional return type:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码抛出异常，因为我们已将返回类型定义为字符串值，但我们尝试返回一个`nil`值。如果有理由返回`nil`，我们需要将返回类型定义为可选类型，以便调用它的代码知道该值可能是`nil`。要定义返回类型为可选类型，我们使用与定义变量为可选类型时相同的方式使用问号（`?`）。以下示例显示了如何定义可选返回类型：
- en: '[PRE18]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding code would not cause an exception.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码不会引发异常。
- en: 'We can also set a tuple as an optional type, or any value within a tuple as
    an optional type. The following example shows how we would return a tuple as an
    optional type:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将元组设置为可选类型，或者将元组内的任何值设置为可选类型。以下示例显示了如何将元组作为可选类型返回：
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the following example, we could return a tuple as it was defined within
    our function definition or `nil`; either option is valid. If we needed an individual
    value within our tuple to be `nil`, we would need to add an optional type within
    our tuple. The following example shows how to return a value of nil within the
    tuple:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们可以返回一个元组，就像它在函数定义中定义的那样，或者`nil`；两种选择都是有效的。如果我们需要一个元组内的单个值是`nil`，我们需要在元组内添加一个可选类型。以下示例显示了如何在元组内返回`nil`值：
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding example, we set the `percent` value to either `Double` or `nil`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的例子中，我们将`percent`值设置为`Double`或`nil`。
- en: Now, let's see how we can add external parameter names for our functions.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何为我们的函数添加外部参数名称。
- en: Adding external parameter names
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加外部参数名称
- en: In the preceding examples in this section, we defined the parameters' names
    and value types in the same way we would define parameters in C code. In Swift,
    we are not limited to this syntax as we can also use external parameter names.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的前几个例子中，我们以与在C代码中定义参数相同的方式定义了参数的名称和值类型。在Swift中，我们不受此语法的限制，因为我们还可以使用外部参数名称。
- en: External parameter names are used to indicate the purpose of each parameter
    when we call a function. An external parameter name for each parameter needs to
    be defined in conjunction with its local parameter name. The external parameter
    name is added before the local parameter name in the function definition. The
    external and local parameter names are separated by a space.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 外部参数名称用于在调用函数时指示每个参数的目的。每个参数的外部参数名称需要与本地参数名称一起定义。外部参数名称添加在函数定义中的本地参数名称之前。外部和本地参数名称之间用空格分隔。
- en: 'Let''s look at how to use external parameter names. But before we do, let''s
    review how we have previously defined functions. In the following two examples,
    we will define a function without external parameter names, and then redefine
    it with external parameter names:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用外部参数名称。但在我们这样做之前，让我们回顾一下我们之前是如何定义函数的。在以下两个示例中，我们将定义一个没有外部参数名称的函数，然后使用外部参数名称重新定义它：
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the preceding example, the `winPercentage()` function has three parameters.
    These parameters are `team`, `wins`, and `loses`. The `team` parameter should
    be a `String` type, while the `wins` and `loses` parameters should be `Int` types.
    The following line of code shows how to call the `winPercentage()` function:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`winPercentage()` 函数有三个参数。这些参数是 `team`、`wins` 和 `loses`。`team` 参数应该是
    `String` 类型，而 `wins` 和 `loses` 参数应该是 `Int` 类型。以下行代码展示了如何调用 `winPercentage()` 函数：
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, let''s define the same function with external parameter names:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用外部参数名称定义相同的函数：
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the preceding example, we redefined the `winPercentage()` function with
    external parameter names. In this redefinition, we have the same three parameters:
    `team`, `wins`, and `losses`. The difference is how we have defined the parameters.
    When using external parameters, we define each parameter with both an external
    parameter name and a local parameter name, separated by a space.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用外部参数名称重新定义了 `winPercentage()` 函数。在这个重新定义中，我们有相同的三个参数：`team`、`wins`
    和 `losses`。区别在于我们如何定义参数。当使用外部参数时，我们使用外部参数名称和局部参数名称（用空格分隔）来定义每个参数。
- en: In the preceding example, the first parameter had an external parameter name
    of `baseballTeam` and an internal parameter name of `team`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，第一个参数的外部参数名称为 `baseballTeam`，内部参数名称为 `team`。
- en: 'When we call a function with external parameter names, we need to include the
    external parameter names in the function call. The following code shows how to
    call this function:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用外部参数名称调用函数时，需要在函数调用中包含外部参数名称。以下代码展示了如何调用此函数：
- en: '[PRE24]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: While using external parameter names requires more typing, it does make your
    code easier to read. In the preceding example, it is easy to see that the function
    is looking for the name of a baseball team, the second parameter is the number
    of wins, and the last parameter is the number of losses.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用外部参数名称需要更多的输入，但它确实使你的代码更容易阅读。在前面的例子中，很容易看出该函数正在寻找一个棒球队的名称，第二个参数是胜利次数，最后一个参数是失败次数。
- en: Using variadic parameters
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用可变参数
- en: 'A **variadic** parameter is one that accepts zero or more values of a specified
    type. Within the function''s definition, we define a variadic parameter by appending
    three periods (`...`) to the parameter''s type name. The values of a variadic
    parameter are made available to the function as an array of the specified type.
    The following example shows how we would use a variadic parameter with a function:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 可变参数是指可以接受零个或多个指定类型的值的参数。在函数定义中，我们通过在参数类型名称后附加三个点（`...`）来定义可变参数。可变参数的值以指定类型的数组形式提供给函数。以下示例展示了我们如何使用函数的可变参数：
- en: '[PRE25]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding example, the `sayHello()` function takes two parameters. The
    first parameter is of the `String` type, which is the greeting to use. The second
    parameter is a variadic parameter of the `String` type, which is the names to
    send the greeting to. Within the function, a variadic parameter is an array that
    contains the type specified; therefore, in our example, the `names` parameter
    is an array of `String` values. In this example, we used a `for-in` loop to access
    the values within the `names` parameter.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`sayHello()` 函数接受两个参数。第一个参数是 `String` 类型，用于指定要使用的问候语。第二个参数是 `String`
    类型的可变参数，用于指定要发送问候语的人名。在函数内部，可变参数是一个包含指定类型的数组；因此，在我们的例子中，`names` 参数是一个 `String`
    值的数组。在这个例子中，我们使用了一个 `for-in` 循环来访问 `names` 参数中的值。
- en: 'The following line of code shows how to call the `sayHello()` function with
    a variadic parameter:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行代码展示了如何使用可变参数调用 `sayHello()` 函数：
- en: '[PRE26]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The preceding line of code prints a greeting to each of the names, as shown
    here:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 上一行代码将问候语打印到每个名字上，如下所示：
- en: '[PRE27]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, let's take a look at what `inout` parameters are.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `inout` 参数是什么。
- en: inout parameters
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入输出参数
- en: If we want to change the value of a parameter and we want those changes to persist
    once the function ends, we need to define the parameter as an `inout` parameter.
    Any changes made to an `inout` parameter are passed back to the variable that
    was used in the function call.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想更改参数的值，并且希望这些更改在函数结束时仍然保持，我们需要将参数定义为`inout`参数。对`inout`参数所做的任何更改都会传递回函数调用中使用的变量。
- en: Two things to keep in mind when we use `inout` parameters are that these parameters
    cannot have default values and that they cannot be variadic parameters.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`inout`参数时有两个需要注意的事项：这些参数不能有默认值，并且它们不能是可变参数。
- en: 'Let''s look at how to use `inout` parameters to swap the values of two variables:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`inout`参数交换两个变量的值：
- en: '[PRE28]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This function will accept two parameters and swap the values of the variables
    that are used in the function call. When we make the function call, we put an
    ampersand (`&`) in front of the variable name, indicating that the function can
    modify its value. The following example shows how to call the `reverse` function:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将接受两个参数，并交换函数调用中使用的变量的值。当我们调用函数时，我们在变量名前放置一个反引号（`&`），表示函数可以修改其值。以下示例显示了如何调用`reverse`函数：
- en: '[PRE29]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding example, we set variable `one` to a value of `One` and variable
    `two` to a value of `Two`. We then called the `reverse()` function with the `one`
    and `two` variables. Once the `reverse()` function has returned, the variable
    named `one` will contain the value `Two`, while the variable named `two` will
    contain the value `One`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们将变量`one`设置为`One`的值，将变量`two`设置为`Two`的值。然后我们使用`one`和`two`变量调用`reverse()`函数。一旦`reverse()`函数返回，名为`one`的变量将包含`Two`的值，而名为`two`的变量将包含`One`的值。
- en: 'Two things to note about `inout` parameters: a variadic parameter cannot be
    an `inout` parameter and an `inout` parameter cannot have a default value.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`inout`参数的两个注意事项：可变参数不能是`inout`参数，并且`inout`参数不能有默认值。
- en: Omitting argument labels
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 省略参数标签
- en: 'All the functions in this chapter have used labels when passing arguments into
    the functions. If we do not want to use labels, we can omit them by using an underscore.
    The following example illustrates this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有函数在将参数传递给函数时都使用了标签。如果我们不想使用标签，我们可以通过使用下划线来省略它们。以下示例说明了这一点：
- en: '[PRE30]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Notice the underscore prior to the `name` label in the parameter list. This
    indicates that the `name` label should not be used when calling this function.
    Now, we are able to call this function without using the `name` label:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意参数列表中`name`标签前的下划线。这表示在调用此函数时不应使用`name`标签。现在，我们能够不使用`name`标签来调用此函数：
- en: '[PRE31]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This call would print out `Hi Jon`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此调用将输出`Hi Jon`。
- en: Now, let's put what we have covered together and see a more complex example.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将我们所学的内容综合起来，看看一个更复杂的例子。
- en: Putting it all together
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有这些放在一起
- en: 'To reinforce what we have learned in this chapter, let''s look at one more
    example. For this example, we will create a function that will test whether a
    string value contains a valid IPv4 address. An IPv4 address is the address assigned
    to a computer that uses the **Internet Protocol** (**IP**) to communicate. An
    IP address consists of four numeric values that range from `0-255`, separated
    by a dot (period). The following is a code example of a valid IP address; that
    is, `10.0.1.250`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了巩固我们在本章学到的内容，让我们再看一个例子。对于这个例子，我们将创建一个函数来测试一个字符串值是否包含有效的IPv4地址。IPv4地址是分配给使用**互联网协议**（**IP**）进行通信的计算机的地址。IP地址由四个范围从`0-255`的数值组成，由点（句号）分隔。以下是一个有效IP地址的代码示例；即`10.0.1.250`：
- en: '[PRE32]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Since the sole parameter in the `isValidIp()` function is an optional type,
    the first thing we do is verify that the `ipAddR` parameter is not `nil`. To do
    this, we use a `guard` statement with optional binding. If the optional binding
    fails, we return a Boolean `false` value because `nil` is not a valid IP address.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在`isValidIp()`函数中，唯一的参数是可选类型，我们首先做的事情是验证`ipAddR`参数不是`nil`。为此，我们使用带有可选绑定的`guard`语句。如果可选绑定失败，我们返回一个布尔值`false`，因为`nil`不是一个有效的IP地址。
- en: If the `ipAddr` parameter contains a non-nil value, we split the string into
    an array of strings, using the dots as delimiters. Since an IP address is supposed
    to contain four numbers separated by a dot, we use the `guard` statement again
    to check whether the array contains four elements. If it does not, we return `false`
    because we know that the `ipAddr` parameter did not contain a valid IP address.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`ipAddr`参数包含非空值，我们将使用点作为分隔符将字符串拆分成一个字符串数组。由于IP地址应该包含由点分隔的四个数字，我们再次使用`guard`语句来检查数组是否包含四个元素。如果不包含，我们返回`false`，因为我们知道`ipAddr`参数没有包含有效的IP地址。
- en: We then use the `split()` function of the `String` type to split the string
    into four substrings, where each substring contains one `octet` of the address.
    These substrings are stored in the `octets` array.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后使用`String`类型的`split()`函数将字符串拆分成四个子字符串，其中每个子字符串包含地址的一个`octet`。这些子字符串存储在`octets`数组中。
- en: 'Then, we loop through the values in the array that we created by splitting
    the original `ipAddr` parameter at the dots and passing the values to the `validOctet()`
    function. If all four values are verified by the `validOctet()` function, we have
    a valid IP address and we return a Boolean `true` value; however, if any of the
    values fail the `validOctet()` function, we return a Boolean `false` value. Now,
    let''s look at the code for the `validOctet()` function:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们遍历通过在点处拆分原始的`ipAddr`参数并传递给`validOctet()`函数创建的数组中的值。如果所有四个值都通过`validOctet()`函数的验证，我们就有一个有效的IP地址，并返回一个布尔值`true`；然而，如果任何一个值未能通过`validOctet()`函数的验证，我们返回一个布尔值`false`。现在，让我们看看`validOctet()`函数的代码：
- en: '[PRE33]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `validOctet()` function has one `String` parameter, named `octet`. This
    function will verify that the `octet` parameter contains a numeric value between
    `0` and `255`; if it does, the function will return a Boolean `true` value. Otherwise,
    it will return a Boolean `false` value.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`validOctet()`函数有一个名为`octet`的`String`参数。这个函数将验证`octet`参数是否包含介于`0`和`255`之间的数值；如果是，函数将返回一个布尔值`true`。否则，它将返回一个布尔值`false`。'
- en: Summary
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered what functions are and how to use them. You will
    use functions in every serious application that you write. In the next chapter,
    we will look at classes and structures. Classes and structures can contain functions,
    but these functions are known as methods.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了函数是什么以及如何使用它们。你将在你编写的每一个严肃的应用程序中使用函数。在下一章中，我们将探讨类和结构。类和结构可以包含函数，但这些函数被称为方法。
