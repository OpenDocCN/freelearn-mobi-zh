- en: Chapter 9. Integrating your Apps with External Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章。将您的应用程序与外部服务集成
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Connecting to APIs that use basic authentication
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到使用基本身份验证的 API
- en: Fetching data from the Google Places API
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Google Places API 获取数据
- en: Connecting to FourSquare using OAuth
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 OAuth 连接到 FourSquare
- en: Posting a check-in to FourSquare
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 FourSquare 上发布签到
- en: Searching and retrieving data via Yahoo! YQL
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 Yahoo! YQL 搜索和检索数据
- en: Integrating push notifications with UrbanAirship.com
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将推送通知与 UrbanAirship.com 集成
- en: Testing push notifications using PHP and HTTP POST
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 PHP 和 HTTP POST 测试推送通知
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Many mobile applications are self-contained programs (such as a Calculator app)
    and have no need to interact with other services or systems. However, will find
    that as you build more and more, it will start to become necessary to integrate
    with external vendors and systems in order to keep your users happy. The recent
    trend towards integrating Facebook "like" buttons and the ability to Tweet from
    within an app are excellent examples of this.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 许多移动应用程序是自包含的程序（例如计算器应用程序），并且不需要与其他服务或系统交互。然而，您会发现随着您构建的越来越多，开始变得有必要与外部供应商和系统集成，以保持您的用户满意。最近将
    Facebook "赞" 按钮集成以及能够在应用程序内推文的趋势是这一点的绝佳例子。
- en: In this chapter, we are going to be concentrating on talking to a variety of
    different service providers in a number of common ways, including basic authorization,
    open authorization, and using a service provider (such as Urban Airship), coupled
    with some PHP code, to make push notifications work on your iPhone.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将集中讨论以多种常见方式与各种不同的服务提供商进行通信，包括基本授权、开放授权以及使用服务提供商（如 Urban Airship），结合一些
    PHP 代码，使推送通知在您的 iPhone 上工作。
- en: Connecting to APIs that use basic authentication
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到使用基本身份验证的 API
- en: Basic authentication is a method for gaining access to a system by way of Base64
    encoding using the username and password credentials before sending them over
    HTTP. For example, given the username 'Aladdin' and password 'open sesame', the
    string 'Aladdin:open sesame' is Base64 encoded, resulting in 'QWxhZGRpbjpvcGVuIHNlc2FtZQ=='.
    This Base64 string is then decoded by the receiving server, resulting in the original
    username-password string separated by a colon. While this is not the most secure
    of authentication schemes, it is unreadable to the human eye, and for small APIs
    or private systems it is very easily implemented. All web browsers from the HTTP/1.1
    support basic authentication, so it can be widely implemented across both the
    Web and mobile devices without being concerned about browser support.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 基本身份验证是一种通过在发送到 HTTP 之前使用 Base64 编码用户名和密码凭据来获取系统访问权限的方法。例如，给定用户名 'Aladdin' 和密码
    'open sesame'，字符串 'Aladdin:open sesame' 被Base64编码，结果为 'QWxhZGRpbjpvcGVuIHNlc2FtZQ=='。这个Base64字符串随后被接收服务器解码，结果为用冒号分隔的原始用户名-密码字符串。虽然这不是最安全的身份验证方案，但对于人类眼睛来说是不可读的，并且对于小型
    API 或私有系统来说非常容易实现。从 HTTP/1.1 开始，所有网络浏览器都支持基本身份验证，因此可以在 Web 和移动设备上广泛实现，无需担心浏览器支持。
- en: Many external services use basic authentication and session keys in order for
    you to access and interact with their APIs. In this example, I will show you how
    to access the Blurtit API using the basic authentication mechanism. The basic
    principles of this recipe should work for any other standard API that uses basic
    authentication as well.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 许多外部服务使用基本身份验证和会话密钥，以便您访问和交互它们的 API。在这个例子中，我将向您展示如何使用基本身份验证机制访问 Blurtit API。这个食谱的基本原理也适用于任何其他使用基本身份验证的标准
    API。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Blurtit is a free online question and answer system, much like Yahoo! Answers,
    or many of the other Q&A style message boards that are on the Web. You will need
    to set up an account with Blurtit.com and register for their API, which is at
    [http://api.blurtit.com](http://api.blurtit.com). After registering, you will
    be given a user ID, API key, login name, and password. You'll need these four
    items in order to connect to the API and retrieve data.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Blurtit 是一个免费的在线问答系统，类似于 Yahoo! Answers，或者许多其他在网上的问答风格论坛。您需要在与 Blurtit.com 的账户设置中注册并申请他们的
    API，该 API 位于 [http://api.blurtit.com](http://api.blurtit.com)。注册后，您将获得一个用户 ID、API
    密钥、登录名和密码。您需要这四项内容才能连接到 API 并检索数据。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The complete source code for this recipe can be found in the `/Chapter 9/Recipe
    1` folder.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的完整源代码可以在 `/Chapter 9/Recipe 1` 文件夹中找到。
- en: How to do it…
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a new project in Titanium Studio, and open up the `app.js` file, removing
    all of the existing code. First, we''ll create some variables which will contain
    your API key, user ID, username, password, and the URL to the API. Make sure you
    replace the `loginName` and `loginPassword` variable values in the following code
    with the login information given to you when you signed up for the API in the
    *Getting ready* section:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在Titanium Studio中创建一个新的项目，并打开`app.js`文件，删除所有现有的代码。首先，我们将创建一些变量，这些变量将包含你的API密钥、用户ID、用户名、密码以及API的URL。确保你将以下代码中的`loginName`和`loginPassword`变量值替换为在*准备工作*部分注册API时提供的登录信息：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, to do the basic authentication, we need to create a request header. This
    information gets sent after your **xhr** `httpClient` object is declared, but
    before you execute the `send` method:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了进行基本认证，我们需要创建一个请求头。这个信息在声明**xhr** `httpClient`对象之后发送，但在你执行`send`方法之前：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, create your parameter array based on the Blurtit API. In this case, we''re
    passing in our `login_name` and `password` variables to perform a `signin` request.
    Attach the `params` array to your `xhr.send()` method like so:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，根据Blurtit API创建你的参数数组。在这种情况下，我们将`login_name`和`password`变量传递进去以执行`signin`请求。将`params`数组附加到你的`xhr.send()`方法，如下所示：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, in the `xhr.onload()` method, read in the `responseText` and assign
    it to a JSON object. We can then read in the returned data (in this case, a session
    ID) and we''ll assign it to a label for display purposes:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`xhr.onload()`方法中，读取`responseText`并将其分配给一个JSON对象。然后我们可以读取返回的数据（在这个例子中是一个会话ID），并将其分配给一个标签以供显示：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that we have authorized and stored our session variable, we can call the
    functions available to us on the Blurtit API. The following is a sample which
    asks the API a simple question and then logs the JSON response to the console:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经授权并存储了我们的会话变量，我们可以调用Blurtit API提供的函数。以下是一个示例，它向API提出一个简单的问题，然后将JSON响应记录到控制台：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works…
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The basic authentication system works on the principle of authenticating and
    receiving a session token which can then be used in every following API call as
    a means of indentifying yourself to the server. This session variable is passed
    in as a parameter for every call to the system you will make. This can be seen
    in our previous code where we are calling the search questions method (`questions/search.json?query=xxx`).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 基本认证系统基于认证和接收一个会话令牌的原则，然后这个令牌可以在每个后续的API调用中用作识别自己的手段。这个会话变量作为参数传递给你要对系统进行的每个调用。这可以从我们之前的代码中看到，我们正在调用搜索问题方法（`questions/search.json?query=xxx`）。
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It should be noted that security is not the purpose of encoding the username
    and password variables into a Base64 string. Rather, it is done to ensure that
    possible non-HTTP compatible characters are encoded into values that are HTTP
    compatible. The basic authentication method is still widely in use on the Internet.
    However, it is being replaced with OAuth in many cases today. We will look at
    integrating with OAuth in one of the next recipes of this chapter.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 应当注意的是，将用户名和密码变量编码为Base64字符串的目的并非是为了安全，而是为了确保可能的不兼容HTTP字符被编码成HTTP兼容的值。基本认证方法目前在互联网上仍然广泛使用。然而，在今天，它在许多情况下正被OAuth所取代。我们将在本章的下一个菜谱中查看如何与OAuth集成。
- en: Fetching data from the Google Places API
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Google Places API获取数据
- en: The Google Places API is a new part of Google Maps and returns information about
    places (for example, banks, cash machines, services, airports, and more). It marks
    an attempt by Google to connect users directly to shops or items of interest near
    their location, and is heavily geared towards mobile usage. In this recipe, we
    will create a new module which will contain all of the code required to connect
    to, and return data from, the Google Places API.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Google Places API是Google Maps的一个新部分，它返回有关地点的信息（例如，银行、自动取款机、服务、机场等）。它标志着Google试图直接将用户与其位置附近的商店或感兴趣的项目连接起来，并且高度针对移动使用。在本菜谱中，我们将创建一个新的模块，其中包含连接到Google
    Places API并返回数据的所有代码。
- en: Getting ready
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'You will require an API key from Google in order to perform requests against
    the Places API. You can obtain a key from Google''s developer website here: [https://code.google.com/apis/console](http://https://code.google.com/apis/console).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对Places API进行请求，你需要从Google获取一个API密钥。你可以从这里获取密钥：[https://code.google.com/apis/console](http://https://code.google.com/apis/console)。
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Complete source code for this recipe can be found in the `/Chapter 9/Recipe
    2` folder.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的完整源代码可以在 `/Chapter 9/Recipe 2` 文件夹中找到。
- en: How to do it…
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Create a new project in Titanium Studio, which you can give any name you want.
    Then, create a new file called `placesapi.js` file, and save it to your project''s
    `Resources` directory. Type the following code into this new JavaScript file:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在Titanium Studio中创建一个新的项目，你可以给它任何你想要的名称。然后，创建一个名为 `placesapi.js` 的新文件，并将其保存到你的项目的
    `Resources` 目录中。将以下代码输入到这个新的JavaScript文件中：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now open your `app.js` file (or wherever you intend to call the Places module
    from), removing all of the existing code. Type in the following sample code in
    order to get data back using our API wrapper. Note that you can return XML data
    from this API in this example only using JSON, which should really be your de-facto
    standard for any mobile development. You will also need to replace the XXXXXXXXXXXXXXXXXXX
    API key with your own valid API key from Google.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开你的 `app.js` 文件（或你打算从那里调用地点模块的地方），删除所有现有的代码。输入以下示例代码以使用我们的API包装器获取数据。请注意，在这个例子中，你可以使用JSON格式从该API返回XML数据，这应该是你移动开发的实际标准。你还需要将XXXXXXXXXXXXXXXX
    API密钥替换为你自己的有效API密钥，来自Google。
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Run the sample application in the emulator and you should be able to get a
    JSON formatted list returned, and the first item in that list logged to the console.
    Try extending this sample to integrate with Google Maps using real-time location
    data! You can also get more detailed place information by calling the `getPlaceDetails()`
    method of the API, for example:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟器中运行示例应用程序，你应该能够获取一个JSON格式的列表返回，并将列表中的第一个项目记录到控制台。尝试扩展这个示例以使用实时位置数据与Google
    Maps集成！你还可以通过调用API的 `getPlaceDetails()` 方法获取更详细的位置信息，例如：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works…
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Tip
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The Places API is probably the simplest kind of service integration available.
    With it, there is no authentication method except requiring an API key and all
    of the parameters are passed via the query string using a HTTP GET.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 地点API可能是最简单的服务集成类型。使用它，除了需要API密钥外，没有其他认证方法，所有参数都通过查询字符串使用HTTP GET传递。
- en: The request header is one important feature of this method. Note that we need
    to set the content type to `application/json` before performing our `send()` call
    on the xhr object. Without setting the content type you run the risk of the data
    being returned to you in HTML or some other format that won't be 100 percent JSON
    compatible. Therefore, it would probably not load into a JSON object.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请求头是这个方法的一个重要特性。请注意，在我们对xhr对象执行 `send()` 调用之前，我们需要将内容类型设置为 `application/json`。如果不设置内容类型，你将面临数据以HTML或其他格式返回的风险，这些格式可能不是100%与JSON兼容。因此，它可能无法加载到JSON对象中。
- en: When the Places service returns JSON results from a search, it places them within
    a results array. Even if the service returns no results, it still returns an empty
    results array. Each element of the response contains a single place result from
    the area you specified by the latitude and longitude inputs, ordered by prominence.
    Many things, including the number of check-ins, can affect the prominence of results
    and therefore its popularity. The Google documentation provides the following
    information on the data returned for each place result (see [http://code.google.com/apis/maps/documentation/places/):](http://code.google.com/apis/maps/documentation/places/))
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当地点服务从搜索返回JSON结果时，它将它们放置在结果数组中。即使服务没有返回结果，它仍然返回一个空的结果数组。响应中的每个元素都包含一个从你通过纬度和经度输入指定的区域获取的单个地点结果，按突出度排序。许多事情，包括签到次数，都会影响结果的突出度及其受欢迎程度。Google文档提供了有关每个地点结果返回数据的以下信息（见
    [http://code.google.com/apis/maps/documentation/places/]）：](http://code.google.com/apis/maps/documentation/places/)
- en: '**name** contains the human-readable name for the returned result. For **establishment**
    results, this is usually the business name.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**name** 包含返回结果的易读名称。对于 **establishment** 结果，这通常是商业名称。'
- en: '**vicinity** contains a feature name of a nearby location. This feature often
    refers to a street or neighborhood within the given results.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**vicinity** 包含一个附近位置的名称。这个特征通常指的是给定结果中的街道或社区。'
- en: '**types[]** contains an array of feature types describing the given result.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**types[]** 包含一个特征类型的数组，描述了给定的结果。'
- en: '**geometry** contains geometry information about the result, generally including
    the **location** (geocode) of the Place and (optionally) the **viewport** identifying
    its general area of coverage.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**geometry** 包含关于结果的位置信息，通常包括位置（geocode）和（可选）标识其一般覆盖范围的 **viewport**。'
- en: '**icon** contains the URL of a recommended icon, which may be displayed to
    the user when indicating this result.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**icon** 包含推荐图标的 URL，当指示此结果时可能会显示给用户。'
- en: '**reference** contains a unique token that you can use to retrieve additional
    information about this place. You can store this token and use it at any time
    in the future to refresh cached data about this Place, but the same token is not
    guaranteed to be returned for any given Place across different searches.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**reference** 包含一个唯一的令牌，你可以使用它来检索有关此位置的其他信息。你可以存储这个令牌，并在将来任何时间使用它来刷新有关此位置缓存的资料，但同一位置在不同搜索中返回的相同令牌并不保证。'
- en: '**id** contains a unique stable identifier denoting this place.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**id** 包含一个唯一的稳定标识符，表示这个位置。'
- en: There are many other features within the Places API, including the ability to
    "check-in" to a place and more. Additionally, you should also note that when including
    this recipe into a live application, part of Google's terms is that you must show
    the "powered by Google" logo in your application, unless the results you're displaying
    are already on a Google branded map.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Places API 中有许多其他功能，包括“签到”到位置的能力等。此外，你还应该注意，当将此菜谱集成到实际应用程序中时，谷歌的条款之一是你必须在你的应用程序中显示“由谷歌提供”的标志，除非你显示的结果已经在谷歌品牌的地图上。
- en: Connecting to FourSquare using OAuth
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 OAuth 连接到 FourSquare
- en: Open Authorization (known normally by its shortened name, OAuth) is an open
    standard developed for authorization, which allows a user to share private data
    stored on one site or device (e.g. your mobile phone) with another site. Instead
    of using credentials such as a username and password, OAuth relies on tokens instead.
    Each token has encoded within in it a series of details for a specific site (e.g.
    FourSquare or Twitter), using specific resources or permissions (for example,
    photos or your personal information) for a specific duration of time (for example,
    two hours).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 开放授权（通常通过其缩写名 OAuth 闻名）是一个为授权而开发的开放标准，它允许用户将存储在一个网站或设备（例如你的手机）上的私有数据与另一个网站共享。OAuth
    不使用凭据（例如用户名和密码），而是依赖于令牌。每个令牌都包含了一系列特定网站（例如 FourSquare 或 Twitter）的详细信息，使用特定的资源或权限（例如照片或你的个人信息）在特定时间段内（例如两小时）。
- en: FourSquare is a popular location-based social networking site specifically made
    for GPS-enabled mobile devices. It allows you to check-in to various locations,
    and in doing so, earn points and rewards in the form of "badges". In this recipe,
    we will use OAuth to connect to FourSquare and retrieve an access token that we
    can use later on to enable our application to "check-in" to various locations
    within the FourSquare community.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: FourSquare 是一个流行的基于位置的社会化网络平台，专门为具有 GPS 功能的移动设备设计。它允许你签到到各种位置，并在这样做的同时，以“徽章”的形式获得积分和奖励。在这个菜谱中，我们将使用
    OAuth 连接到 FourSquare 并检索一个访问令牌，我们可以在以后使用这个令牌来使我们的应用程序能够在 FourSquare 社区内的各种位置进行“签到”。
- en: Getting ready
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'You will need a Client ID key from FourSquare in order to perform requests
    against the FourSquare API. You can obtain a key from the developer website for
    free here: [http://developer.foursquare.com](http://developer.foursquare.com).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对 FourSquare API 进行请求，你需要从 FourSquare 获取一个客户端 ID 密钥。你可以在这里免费从开发者网站获取一个密钥：[http://developer.foursquare.com](http://developer.foursquare.com)。
- en: Note
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The complete source code for this recipe can be found in the `/Chapter 9/Recipe
    3` folder.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱的完整源代码可以在 `/第 9 章/菜谱 3` 文件夹中找到。
- en: How to do it…
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a new project in Titanium Studio, which you can give any name you want.
    Then, create a new file called `fsq_module.js` and save it to your projects `Resources`
    directory. This file will contain all of the needed source code to create a module
    that we can include anywhere in our Titanium app. Open your new `fsq_module.js`
    file in your editor and type in the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Titanium Studio 中创建一个新的项目，你可以给它任何你想要的名字。然后，创建一个名为 `fsq_module.js` 的新文件，并将其保存到你的项目
    `Resources` 目录中。这个文件将包含创建模块所需的所有源代码，我们可以在我们的 Titanium 应用程序中的任何地方包含这个模块。在你的新 `fsq_module.js`
    文件中打开你的编辑器，并输入以下内容：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, back in your `app.js` file, type in the following code to include the
    new FourSquare module and execute the sign-in function:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到你的 `app.js` 文件中，输入以下代码以包含新的 FourSquare 模块并执行登录函数：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Try running your application in either the Android or iPhone emulator. You
    should get a login screen appear on startup that looks similar to the one in the
    following screenshot:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在 Android 或 iPhone 模拟器中运行您的应用程序。您应该在启动时看到一个登录屏幕出现，其外观类似于以下截图：
- en: '![How to do it…](img/3968_09_01.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](img/3968_09_01.jpg)'
- en: How it works…
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The module we have built in this recipe follows a pattern and style that is
    very similar to others found on the Web, including modules that have been built
    for Titanium against Facebook, Twitter, and others. It consists of creating a
    modal view that "pops" up over top of the existing window, and contains a webview
    to the mobile version of the FourSquare login page. Once the user has logged into
    the system, we can then grab the access token from the response in the `authorizeCallBack()`
    method, and save the resulting token to our module's `ACCESS_TOKEN` property.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中构建的模块遵循与 Web 上其他模块非常相似的图案和风格，包括为 Titanium 构建的针对 Facebook、Twitter 等其他模块。它包括创建一个覆盖现有窗口的模态视图，并包含指向
    FourSquare 登录页面的移动版本的网络视图。一旦用户登录到系统，我们就可以从 `authorizeCallBack()` 方法中的响应中获取访问令牌，并将生成的令牌保存到模块的
    `ACCESS_TOKEN` 属性中。
- en: Posting a check-in to FourSquare
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将签到发布到 FourSquare
- en: Now that we have created the basic module in order to authenticate against FourSquare,
    we are going to extend it in order to let the user "check-in" to a particular
    location. This works by sending details of your current place (for example, a
    bar, cinema, park, or museum) along with its latitude and longitude values to
    the FourSquare servers. From there, you can then tell which of your friends are
    nearby, or alternatively, make your location and activities public for everyone
    to see.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了用于验证 FourSquare 的基本模块，我们将扩展它，以便用户可以“签到”到特定位置。这是通过发送您当前位置的详细信息（例如，酒吧、电影院、公园或博物馆）以及其纬度和经度值到
    FourSquare 服务器来实现的。从那里，您可以告诉哪些朋友在附近，或者，您可以选择将您的位置和活动对所有人公开。
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Complete source code for this recipe can be found in the `/Chapter 9/Recipe
    4` folder.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方完整的源代码可以在 `/Chapter 9/Recipe 4` 文件夹中找到。
- en: How to do it…
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Open your `fsq_module.js` file and extend the existing module so that it has
    the extra method as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的 `fsq_module.js` 文件，扩展现有模块，使其具有以下额外方法：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now back in your `app.js` file, we are going to extend the "login" call we
    wrote in the previous recipe to now post a FourSquare check-in after a successful
    authorization:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到您的 `app.js` 文件，我们将扩展之前配方中编写的“登录”调用，现在在成功授权后发布 FourSquare 签到：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now try running your app in the emulator. After logging into the FourSquare
    system, you should automatically have posted a test check-in titled "This is my
    check-in message!" and the FourSquare system should send you a successful response
    message and log it to the console.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试在模拟器中运行您的应用程序。登录到 FourSquare 系统后，您应该自动发布了一个标题为“这是我的签到消息！”的测试签到，FourSquare
    系统应该发送一个成功的响应消息并将其记录到控制台。
- en: How it works…
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The `callMethod()` function of our FourSquare module does all of the work here.
    It is essentially taking in the method name to call, along with whether it is
    a GET or POST call and the parameters required to make that method work. Our example
    code is calling the `checkins/add` method, which is a POST, and passing it through
    the parameters of `shout, broadcast`, and `ll`. These are our message, privacy
    setting, and current location respectively. All of the authorization work, including
    saving our access token, is done via the previous recipe. The following console
    output shows our response from FourSquare after a successful checkin post:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 FourSquare 模块的 `callMethod()` 函数在这里完成了所有工作。它基本上是接收要调用的方法名称，以及它是 GET 还是 POST
    调用，以及使该方法工作所需的参数。我们的示例代码正在调用 `checkins/add` 方法，这是一个 POST 调用，并通过 `shout`、`broadcast`
    和 `ll` 参数传递。这些分别是我们的消息、隐私设置和当前位置。所有授权工作，包括保存我们的访问令牌，都是通过之前的配方完成的。以下控制台输出显示了在成功签到发布后
    FourSquare 的响应：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Searching and retrieving data via Yahoo! YQL
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 Yahoo! YQL 搜索和检索数据
- en: YQL is an SQL-like language that allows you to query, filter, and combine data
    from multiple sources across both the Yahoo! Network and other open data sources.
    Normally, developer access to data from multiple resources is disparate and requires
    calls to multiple APIs from different providers, often with varying feed formats.
    YQL eliminates this problem by providing a single endpoint to query and shape
    the data you request. You may remember that we briefly touched on the usage of
    YQL via standard HTTP Request calls in [Chapter 2](ch02.html "Chapter 2. Working
    with Local and Remote Data Sources"), however, in this chapter, we will be utilizing
    the built-in Titanium YQL methods.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: YQL是一种类似于SQL的语言，允许您查询、过滤和组合来自Yahoo!网络和其他公开数据源的多源数据。通常，开发者访问多个资源的数据是分散的，需要从不同提供商的多个API中进行调用，通常具有不同的数据格式。YQL通过提供一个单一的端点来查询和塑造您请求的数据，从而消除了这个问题。您可能还记得，我们在[第2章](ch02.html
    "第2章。处理本地和远程数据源")中简要介绍了通过标准HTTP请求调用YQL的使用，然而，在本章中，我们将利用内置的Titanium YQL方法。
- en: Titanium has built-in support for YQL, and in this recipe we will create a simple
    application that searches for stock data on the YQL network, and then displays
    that data in a simple label.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 钛金属内置了对YQL的支持，在这个菜谱中，我们将创建一个简单的应用程序，用于在YQL网络上搜索股票数据，然后以简单的标签形式显示这些数据。
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that when using YQL in an un-authenticated manner (such as we are doing
    here), there is a usage limit imposed of 100,000 calls per day. For most applications,
    this is a more than generous limit. However, if you do wish to have it increased,
    you will need to authenticate your calls via OAuth. You can do this by signing
    up with Yahoo! and registering your application.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当以未认证的方式使用YQL（如我们在这里所做的那样）时，每天会施加100,000次调用的使用限制。对于大多数应用程序来说，这是一个非常慷慨的限制。但是，如果您希望将其增加，您将需要通过OAuth对您的调用进行认证。您可以通过在Yahoo!上注册并注册您的应用程序来完成此操作。
- en: The complete source code for this recipe can be found in the `/Chapter 9/Recipe
    5` folder.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的完整源代码可以在`/Chapter 9/Recipe 5`文件夹中找到。
- en: How to do it…
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a new project, and then open the `app.js` file, removing any existing
    content. Now type in the following code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的项目，然后打开`app.js`文件，删除任何现有内容。现在输入以下代码：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You should now be able to run the app in your emulator and search for a stock
    symbol (such as ''AAPL'' for Apple Inc.), and have some of the results listed
    out to a label on the screen, as seen next:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该能够在模拟器中运行应用程序，并搜索股票符号（例如，'AAPL'代表苹果公司），并将一些结果列在屏幕上的标签中，如下所示：
- en: '![How to do it…](img/3968_09_02.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![如何做到这一点…](img/3968_09_02.jpg)'
- en: How it works…
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: What is actually going on here within the `searchYQL()` function? First, we're
    doing a very basic validation on the text field to ensure the user has entered
    in a stock symbol before pressing search. If a stock symbol is found, we use the
    `blur()` method of the text field to ensure the keyboard becomes hidden. The meat
    of the code revolves around creating a Yahoo! YQL query using the correct syntax
    and providing the text field value as the symbol parameter. This YQL query is
    simply a string, joined together using the + symbol, much like you would do with
    any other string manipulation in JavaScript.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在`searchYQL()`函数中实际上发生了什么？首先，我们对文本字段进行非常基本的验证，以确保用户在按下搜索按钮之前已经输入了股票符号。如果找到股票符号，我们使用文本字段的`blur()`方法来确保键盘被隐藏。代码的核心部分围绕使用正确的语法创建Yahoo!
    YQL查询，并将文本字段值作为符号参数提供。这个YQL查询只是一个字符串，使用+符号连接起来，就像您在JavaScript中的任何其他字符串操作一样。
- en: We then execute our query using the `Titanium.Yahoo.yql()` method, which returns
    the results within the 'e' object of the inline response function. We can then
    manipulate and use this JSON data in any way we wish. In this case, we're assigning
    a subsection of it to a label on the screen so the user can view the daily opening
    and closing figures of the stock in question.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后使用`Titanium.Yahoo.yql()`方法执行我们的查询，该方法返回内联响应函数的'e'对象中的结果。然后我们可以以任何我们希望的方式操纵和使用这些JSON数据。在这种情况下，我们将它的一个子部分分配给屏幕上的标签，以便用户可以查看相关股票的每日开盘价和收盘价。
- en: Integrating push notifications with UrbanAirship.com
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将推送通知与UrbanAirship.com集成
- en: Push notifications is a constantly-open IP connection used to forward notifications
    from the servers of third party applications to your iOS device. They are used
    as an alternative to "always running" applications, and allow your device to receive
    notifications from a specific app even when it is not running. If you have ever
    received an SMS on your iPhone, then you'll aready know what push notifications
    looks like. They are essentially a message box that consists of a title, a message,
    and both a "Close" button and an "Action" button. The "Action" button can be defined
    by your code, in both appearance and the underlying action and data that you want
    to be passed to your application when that button is pushed.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 推送通知是一个始终开启的IP连接，用于将第三方应用的服务器上的通知转发到你的iOS设备。它们作为“始终运行”应用的替代品，允许你的设备在应用未运行时接收特定应用的通知。如果你曾在你的iPhone上收到过短信，那么你已经知道推送通知的样子了。它们本质上是一个包含标题、消息以及“关闭”按钮和“操作”按钮的消息框。你可以通过代码定义“操作”按钮的外观以及当按钮被点击时传递给应用的底层动作和数据。
- en: Getting ready
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: You will need to register for an account with Urban Airship at [https://go.urbanairship.com/accounts/register/](http://https://go.urbanairship.com/accounts/register/).
    Once you have registered and verified your account via the email link sent to
    you from Urban Airship, you will need to add a new app to your account at [https://go.urbanairship.com/apps/](http://https://go.urbanairship.com/apps/).
    If you haven't already done so, create and download a new Apple Push Certificate
    from your Apple Developer account. You can do this by creating a new App ID under
    "Provisioning" in your iOS Developer account, and then in the list of apps find
    the one you just created, and click on the "configure" link.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在Urban Airship上注册一个账户，网址是[https://go.urbanairship.com/accounts/register/](http://https://go.urbanairship.com/accounts/register/)。一旦你注册并通过Urban
    Airship发送给你的电子邮件链接验证了账户，你需要在[https://go.urbanairship.com/apps/](http://https://go.urbanairship.com/apps/)的账户中添加一个新的应用。如果你还没有这样做，请从你的Apple开发者账户创建并下载一个新的Apple推送证书。你可以在iOS开发者账户的“配置”下创建一个新的App
    ID，然后在应用列表中找到你刚刚创建的应用，点击“配置”链接。
- en: 'A new page should then show up and allow you to select the push notifications
    option, such as the one in the following screenshot:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后应该会出现一个新页面，允许你选择推送通知选项，如下面的截图所示：
- en: '![Getting ready](img/3968_09_03.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/3968_09_03.jpg)'
- en: You will need to create an application-specific client SSL certificate, which
    can be done through keychain. Click on the **Configure** button next to the **Development
    SSL Certificate** option, and work through the step-by-step wizard. When it is
    finished, you should be able to download a new Apple Push Notification certificate.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要创建一个特定于应用的客户端SSL证书，这可以通过密钥链完成。点击“开发SSL证书”选项旁边的“配置”按钮，然后按照逐步向导操作。完成之后，你应该能够下载一个新的Apple推送通知证书。
- en: Save this certificate to your computer's hard drive and then double-click the
    saved file to open it in Keychain Access. In Keychain Access, click on **My Certificates**,
    and then find the new Apple Push Notification certificate you just created, right-click
    on it, and select **Export**. You will need to give your new P12 certificate a
    name. After clicking **Save** you'll also be asked to provide a password, as seen
    in the following screenshot. This can be anything you like, such as **packt**.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 将此证书保存到你的计算机硬盘上，然后双击保存的文件在密钥链访问中打开它。在密钥链访问中，点击“我的证书”，然后找到你刚刚创建的新Apple推送通知证书，右键单击它，选择“导出”。你需要给你的新P12证书命名。点击“保存”后，你还将被要求提供密码，如下面的截图所示。这可以是任何你喜欢的，例如**packt**。
- en: '![Getting ready](img/3968_09_04.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/3968_09_04.jpg)'
- en: Now go back to the Urban Airship page where you are creating your new application
    and upload the new P12 certificate, providing the password in the box as requested.
    Save your application and you are now ready to send push notifications!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到你创建新应用的Urban Airship页面，上传新的P12证书，并在要求的框中提供密码。保存你的应用，你现在就可以发送推送通知了！
- en: Note
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The complete source code for this recipe can be found in the `/Chapter 9/Recipe
    6` folder.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的完整源代码可以在`/第9章/食谱6`文件夹中找到。
- en: How to do it…
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Create a new development provisioning profile for your application in the provisioning
    section of the Developer website, and download it to your computer. Next, create
    a new Titanium project and ensure the app identifier you use matches the identifier
    you just used to create the provisioning certificate in the Developer Portal.
    Urban Airship has already created a basic registration sample for you, so we are
    also going to use that.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发者网站的配置文件部分为您的应用程序创建一个新的开发配置文件，并将其下载到您的计算机。接下来，创建一个新的Titanium项目，并确保您使用的应用程序标识符与您在开发者门户中创建配置文件时使用的标识符相匹配。Urban
    Airship已经为您创建了一个基本的注册示例，因此我们也将使用它。
- en: 'Next, open the `app.js` file, removing any existing content. Type in the following
    code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开`app.js`文件，删除任何现有内容。输入以下代码：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, in order to test this code, you must run the application on a device. The
    emulator simply does not have the push capability and so will not work for this
    recipe. Go to the **Run on Device** tab in Titanium Studio and provide the screen
    with the debug provision profile you created in the first steps of this recipe.
    Next, click on the **Install Now** button to compile and push the application
    package to your device using iTunes.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了测试此代码，您必须在设备上运行应用程序。模拟器根本不具有推送功能，因此不会适用于此食谱。转到Titanium Studio中的**运行在设备上**选项卡，并提供您在食谱的第一步中创建的调试配置文件。接下来，点击**立即安装**按钮，使用iTunes编译并将应用程序包推送到您的设备。
- en: 'Once your application has launched on the device and it is running, go to your
    web browser and, in your Urban Airship''s app page, click on **Push** and then
    **Device Tokens**. Your new token should be listed on this page. If it is not,
    double check all of your steps again and ensure you are using the correct mobile
    provisioning profiles to build your app. You can now click on **Send Broadcast**
    in order to send a sample push notification to your device directly from the Urban
    Airship website. Try this now, and you should receive a message on your iPhone
    that looks very similar to the one shown in the following screenshots:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的应用程序在设备上启动并运行，请转到您的网络浏览器，在Urban Airship的应用程序页面中，点击**推送**然后**设备令牌**。您的新令牌应该列在此页面上。如果不在，请再次检查所有步骤，并确保您使用正确的移动配置文件来构建您的应用程序。现在，您可以点击**发送广播**，直接从Urban
    Airship网站向您的设备发送示例推送通知。现在尝试一下，您应该在iPhone上收到一条看起来非常类似以下截图的消息：
- en: '![How to do it…](img/3968_09_05.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](img/3968_09_05.jpg)'
- en: How it works…
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'There are a number of key factors in ensuring you are successful in getting
    Push Notifications to work with your Titanium application. Keep these points in
    mind:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您在将推送通知与Titanium应用程序一起使用时成功，有几个关键因素。请记住以下要点：
- en: Remember that each application you create needs its own Push Certificate, you
    cannot use wildcard certificates when integrating Push.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记住，您创建的每个应用程序都需要自己的推送证书，在集成推送时不能使用通配符证书。
- en: Always create the Push Certificate under your Application settings in the developer
    console first, and then create your provisioning profiles. Doing it the other
    way around will mean your profile will be invalid and your app will not accept
    any push notification requests.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是在开发者控制台中的应用程序设置下首先创建推送证书，然后创建您的配置文件。如果反过来操作，意味着您的配置文件将无效，您的应用程序将不接受任何推送通知请求。
- en: Push notifications can only be tested on actual iPhone or iPod Touch devices,
    they will not work under the emulator.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推送通知只能在真实的iPhone或iPod Touch设备上进行测试，它们在模拟器下不会工作。
- en: The `Titanium.Network.registerForPushNotifications` method requires the types
    of notifications you wish to use as the first parameter. If you do not request
    a specific permission from the user upfront, you may not be able to send them
    that kind of notification in the future. Furthermore, users must always agree
    to allow you to send push notifications to their device. You will not be able
    to do so if they do not allow the process to occur.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Titanium.Network.registerForPushNotifications`方法需要您希望使用的通知类型作为第一个参数。如果您在最初没有请求用户的特定权限，您可能无法在将来发送此类通知。此外，用户必须始终同意允许您向他们的设备发送推送通知。如果他们不允许此过程发生，您将无法这样做。'
- en: You need to create separate profiles and certificates for push notifications
    in both the Apple iOS Developer console and Urban Airship. You cannot use a development
    profile in production and vice versa.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要在Apple iOS开发者控制台和Urban Airship中为推送通知创建单独的配置文件和证书。在生产环境中不能使用开发配置文件，反之亦然。
- en: Testing push notifications using PHP and HTTP POST
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 PHP 和 HTTP POST 测试推送通知
- en: In order for our server application to programmatically push notifications to
    a user or group of users, we will need to create a script that can push the notifications
    to the Urban Airship servers. This can be done in a variety of methods (via desktop
    app, .NET application, web application and so on), but for the purposes of this
    recipe we will use PHP, which is simple, fast, and freely available.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的服务器应用程序能够以编程方式向用户或一组用户推送通知，我们需要创建一个可以将通知推送到 Urban Airship 服务器的脚本。这可以通过多种方法完成（通过桌面应用程序、.NET
    应用程序、Web 应用程序等等），但为了本菜谱的目的，我们将使用 PHP，因为它简单、快速且免费可用。
- en: Note
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The complete source code for this recipe can be found in the `/Chapter 9/Recipe
    7` folder.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的完整源代码可在 `/第 9 章/菜谱 7` 文件夹中找到。
- en: How to do it…
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: First, we need to create the PHP script which will communicate with the Urban
    Airship servers to send a push notification. Create the following PHP script,
    save it as `airship.php`, and upload it to a server capable of running PHP and
    with CURL installed. There are plenty of free PHP/Apache hosting accounts available
    online if you don't already have one capable of doing this.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个 PHP 脚本，该脚本将与 Urban Airship 服务器通信以发送推送通知。创建以下 PHP 脚本，将其保存为 `airship.php`，并将其上传到能够运行
    PHP 且已安装 CURL 的服务器上。如果你还没有一个能够执行此操作的 PHP/Apache 主机账户，网上有很多免费的 PHP/Apache 主机账户。
- en: 'The following sample is taken from the Urban Airship website:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例取自 Urban Airship 网站：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: All that is left to do now is run the PHP script in a browser, and when you
    do, you should see a success message echoed out to the browser page, and you should
    also be able to see a new push notification delivered to your device that was
    set up in the previous recipe, as seen in the following screenshot:.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的只是在一个浏览器中运行 PHP 脚本，当你这样做时，你应该在浏览器页面上看到一条成功消息被回显出来，你也应该能够看到一条新的推送通知被发送到你在上一个菜谱中设置的设备上，如下面的截图所示：
- en: '![How to do it…](img/3968_09_06.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作…](img/3968_09_06.jpg)'
- en: How it works…
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The PHP script in this recipe is doing much the same job as the actual Urban
    Airship website does when you can perform tests via their console. Here, we are
    using PHP to build a CURL request in JSON and post it to the Urban Airship server.
    That request is in turn received and then pushed out to your device or devices
    as a Push Notification by the Urban Airship system.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱中的 PHP 脚本所做的与实际 Urban Airship 网站在你可以通过他们的控制台进行测试时所做的几乎相同的工作。在这里，我们使用 PHP
    构建一个 CURL 请求，以 JSON 格式发送到 Urban Airship 服务器。该请求随后被接收，然后由 Urban Airship 系统将其作为推送通知推送到你的设备或设备上。
- en: In a production environment, you would want to extend your PHP script to either
    receive the badge and message variables as POST variables, or perhaps hook up
    the script directly to a database with whatever business logic your app requires.
    You should also note that Urban Airship provides samples for languages other than
    PHP. So if your system is built in .NET or another platform, the same principles
    of sending out broadcasts still apply.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，你可能希望扩展你的 PHP 脚本来接收徽章和消息变量作为 POST 变量，或者可能直接将脚本连接到数据库，使用你的应用程序所需的任何业务逻辑。你还应该注意，Urban
    Airship 为除 PHP 之外的语言提供了示例。所以如果你的系统是用 .NET 或其他平台构建的，发送广播的相同原则仍然适用。
