- en: Chapter 9. Threading Tasks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。线程任务
- en: In the previous chapter, we took a look at the basics of using threads within
    an iOS application and the pitfalls that may confront you if you use them. In
    this chapter, I'll be carrying it on and we'll have a look at the other aspects
    of threading as well as asynchronous calls.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了在 iOS 应用程序中使用线程的基本知识以及使用它们可能遇到的陷阱。在这一章中，我将继续这一主题，并探讨线程的其它方面以及异步调用。
- en: 'In this chapter we will be covering the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Using background threading and `System.Threading.Tasks` within your code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的代码中使用后台线程和 `System.Threading.Tasks`
- en: Using asynchronous code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用异步代码
- en: Problems that using tasks may have on the threading model
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用任务可能对线程模型产生的问题
- en: A brief introduction to threading
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程简介
- en: Threading moved on from its humble beginnings when developers discovered its
    power, and with that created background threading and task threading. Background
    threads are just that—you set something running in the background and look in
    on it sometimes, or when it's finished it will report back to you. On the college
    analogy I used in the previous chapter, the background threads are the admin staff—they're
    there in the background working away and report when they are done.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 线程从其不起眼的起点发展起来，当开发者发现了它的力量时，就创造了后台线程和任务线程。后台线程正是如此——你设置一些在后台运行的任务，有时检查它，或者当它完成时，它会向你报告。在上一章中我使用的大学类比中，后台线程是行政人员——他们在后台工作，完成时报告。
- en: Threading tasks need to be thought of as almost miniature applications in themselves.
    They start, end, and can continue with the next task on the list—all this time,
    the app is free to be working on other tasks. There is an overhead to be considered
    with any threading operation, but unless you're doing something insanely complex,
    it's not going to be horrible.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 线程任务需要被视为几乎独立的微型应用程序。它们开始、结束，并且可以在列表中的下一个任务上继续——在这整个过程中，应用程序可以自由地处理其他任务。任何线程操作都会有一些开销需要考虑，但除非你正在做非常复杂的事情，否则它不会很糟糕。
- en: Using background threading within your app
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在你的应用程序中使用后台线程
- en: Background threading comes from the `System.ComponentModel` namespace and is
    known as a `BackgroundWorker` thread. Alternatively, `ThreadPool.QueueUserWorkItem()`
    does the same thing (as `ThreadPool` is from `System.Threading`).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 后台线程来自 `System.ComponentModel` 命名空间，被称为 `BackgroundWorker` 线程。或者，`ThreadPool.QueueUserWorkItem()`
    也做同样的事情（因为 `ThreadPool` 来自 `System.Threading`）。
- en: BackgroundWorker
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BackgroundWorker
- en: The `BackgroundWorker` thread is recommended when you don't want to tie up the
    UI, so creating large files or sending a large amount of data to a server can
    be considered to be used with `BackgroundWorker`. When the thread is complete,
    the `WorkerCompleted` event is raised. During the operation of `BackgroundWorker`,
    the UI can be updated with the `ProgressChanged` event. A background lasts for
    a finite amount of time. It is important to remember that `BackgroundWorker` is
    an asynchronous task.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当你不想占用 UI 时，建议使用 `BackgroundWorker` 线程，因此创建大文件或将大量数据发送到服务器可以考虑使用 `BackgroundWorker`。当线程完成时，将触发
    `WorkerCompleted` 事件。在 `BackgroundWorker` 的操作过程中，可以通过 `ProgressChanged` 事件更新 UI。后台操作持续一定的时间。重要的是要记住
    `BackgroundWorker` 是一个异步任务。
- en: When you use a `BackgroundWorker` thread, you need to write a code using three
    events (`ProgressChanged` can be omitted if you don't want to use it).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `BackgroundWorker` 线程时，你需要编写使用三个事件（如果你不想使用 `ProgressChanged`，则可以省略）的代码。
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code demonstrates using `BackgroundWorker` within an app. It's
    simple enough; it puts a counter on the screen, which will carry on counting while
    it downloads a picture that is then displayed when the `RunWorkerCompleted` event
    is raised.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码演示了在应用程序中使用 `BackgroundWorker`。这很简单；它在屏幕上显示一个计数器，在下载图片的同时继续计数，当 `RunWorkerCompleted`
    事件被触发时，显示下载的图片。
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding code is simple enough to follow, it creates the `BackgroundWorker`
    object and it also creates the handles and a click event for the button. Inside
    the button, it sets up a timer to update the counter every second and start `BackgroundWorker`.
    When `BackgroundWorker` `DoWork` thread is completed, the image is displayed and
    scaled. The result of the preceding code is shown in the form of the following
    image:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码足够简单，易于理解，它创建了`BackgroundWorker`对象，并为按钮创建了句柄和点击事件。在按钮内部，它设置了一个定时器，每秒更新计数器并启动`BackgroundWorker`。当`BackgroundWorker`的`DoWork`线程完成时，将显示并缩放图像。上述代码的结果以以下图像的形式展示：
- en: '![BackgroundWorker](img/00041.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![BackgroundWorker](img/00041.jpeg)'
- en: Remember though, this is a background task—the UI can't act on the data until
    the data is ready. When you run the application, the counter value will differ
    as well, depending on if you're on a wireless network or outside, using 3G or
    4G.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这是一个后台任务——UI无法对数据进行操作，直到数据准备就绪。当你运行应用程序时，计数器的值也会有所不同，这取决于你是否在无线网络或户外，使用3G或4G。
- en: ThreadPool.QueueUserWorkItem
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ThreadPool.QueueUserWorkItem
- en: 'Having seen how the background worker operates, let us consider using `ThreadPool.QueueUserWorkItem`
    for the same task:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了后台工作线程的工作方式后，让我们考虑使用`ThreadPool.QueueUserWorkItem`来完成相同任务：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The **callback** is a piece of code passed as an argument, which needs to be
    executed at some point in time. In threading terms, it is typically executed within
    the thread being called or created. The callback tells the thread when it has
    called the thread back to the main thread. The end result is the same, but the
    `QueueUserWorkItem` method can be used for both foreground and background tasks.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**回调**是一段作为参数传递的代码，需要在某个时间点执行。在多线程术语中，它通常在被调用或创建的线程中执行。回调告诉线程何时将其回调到主线程。最终结果是相同的，但`QueueUserWorkItem`方法可以用于前台和后台任务。'
- en: Using System.Threading.Tasks
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用System.Threading.Tasks
- en: The `System.Threading.Tasks` namespace sets up tasks within a thread, so a thread
    can perform a type of mini program and then report back. It can also be used to
    start a task.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Threading.Tasks`命名空间在线程内设置任务，因此线程可以执行一种小型程序，然后报告结果。它还可以用于启动任务。'
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The call starts a new thread task that calls `GetMessage`. Once that has returned,
    the task continues with `ShowResults`. The scheduler prevents the timing from
    getting out of hand.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 调用启动了一个新的线程任务，该任务调用`GetMessage`。一旦返回，任务将继续执行`ShowResults`。调度器防止时间失控。
- en: '![Note](img/00001.gif)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![注意](img/00001.gif)'
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While the code available at [http://www.gregshackles.com/2011/04/using-background-threads-in-mono-for-android-applications/](http://www.gregshackles.com/2011/04/using-background-threads-in-mono-for-android-applications/)
    is for Android, the same code can (more or less) be used in Xamarin.iOS and gives
    a fantastic cover of the different types of threading and how they're used.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在[http://www.gregshackles.com/2011/04/using-background-threads-in-mono-for-android-applications/](http://www.gregshackles.com/2011/04/using-background-threads-in-mono-for-android-applications/)上可用的代码是为Android设计的，但相同的代码（或多或少）可以用于Xamarin.iOS，并提供了不同类型的线程及其使用方式的出色覆盖。
- en: '![Note](img/00001.gif)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![注意](img/00001.gif)'
- en: Problems while using Tasks on threads
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在线程上使用任务时遇到的问题
- en: Whenever an additional task is created, the processor has to start swapping
    between the tasks themselves, which slows the code down. You have the additional
    problem of tracking the tasks and how they work with the main UI thread. In general,
    they shouldn't cause a problem, but you also have to consider that unless you
    explicitly program the threads to run synchronously, they run asynchronously.
    To prevent the code from getting out of hand, locks or callbacks need to be used.
    **Locks** may lead to **deadlock** conditions, so be careful! Refer back to [Chapter
    8](../Text/part0040.html#page "Chapter 8. Threading"), *Threading*, for an overview
    of deadlocks and avoiding them.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 每当创建一个额外任务时，处理器必须开始在任务之间进行交换，这会减慢代码的执行速度。你还有跟踪任务以及它们如何与主UI线程协同工作的问题。一般来说，它们不应该引起问题，但你也要考虑到，除非你明确编程线程以同步方式运行，否则它们是异步运行的。为了防止代码失控，需要使用锁或回调。**锁**可能导致**死锁**条件，所以请小心！请参阅[第8章](../Text/part0040.html#page
    "第8章。线程")，*线程*，以了解死锁及其避免的概述。
- en: Using Asynchronous code
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用异步代码
- en: Async is one of the big changes to .NET and was released in .NET v4, but has
    only quite recently landed within the Mono framework, and therefore within Xamarin.Android
    and Xamarin.iOS. As I explained in a previous chapter, asynchronous code can be
    a bit of a handful, but thankfully that bit of a handful is simple to understand.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 异步是.NET的重大变化之一，并在.NET v4中发布，但直到最近才在Mono框架中实现，因此也在Xamarin.Android和Xamarin.iOS中实现。正如我在前一章中解释的，异步代码可能有点棘手，但幸运的是，这部分棘手的内容很容易理解。
- en: Tasks and EventHandlers
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务和事件处理器
- en: 'Take the following code as an example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下代码为例：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The handler for `LoadStarted` is a synchronous process—in other words, it is
    like a walk to the pub in a straight line. The problem is that while `webView`
    is loading a page, everything is being held up—so if it's a slow page or you need
    something else to be running (say a piece of music to play), there are going to
    be sticking points. This is where an asynchronous `LoadStarted` event can be used.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoadStarted`事件的处理程序是一个同步过程——换句话说，它就像直线上去酒吧一样。问题是，当`webView`正在加载页面时，所有事情都会被阻塞——所以如果页面加载缓慢或者你需要运行其他东西（比如播放音乐），就会出现瓶颈。这就是异步`LoadStarted`事件可以发挥作用的地方。'
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `async` method looks different from a normal method as shown in the following
    code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`async`方法与普通方法在以下代码中看起来不同：'
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: A more practical example
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个更实际的例子
- en: 'Prior to the `async` method being implemented, a system of events had to be
    implemented so that once the data had been returned it can be handled by the method
    (say, from a web data download). For example (the following is a psuedo code,
    so you get the idea):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现`async`方法之前，必须实现一个事件系统，以便一旦数据返回，就可以由方法处理（例如，从网络数据下载）。例如（以下是一个伪代码，以便你理解这个概念）：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding code can now be handled in a single `async` method, as shown
    in the following code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码现在可以由单个`async`方法处理，如下所示：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The key here is `await`—this prevents the next line from executing until `callLoginService`
    has returned. This greatly improves responsiveness—less code, fewer events to
    listen to, and far less messing about.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里关键是`await`——这会阻止下一行执行，直到`callLoginService`方法返回。这大大提高了响应速度——代码更少，需要监听的事件更少，而且几乎不需要做额外的事情。
- en: If a method returns a value, the `Task<T>` parameter needs to be used prior
    to the method name. If there isn't a return value (as, when responding to a button
    click), `void` needs to be used.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个方法返回一个值，需要在方法名之前使用`Task<T>`参数。如果没有返回值（例如，响应按钮点击），则需要使用`void`。
- en: Summary
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: There are many uses for background threads as well as asynchronous calls, and
    the general recommendation is that if a process takes a long time, throw it at
    the background. Be careful when using threads. While for the majority of the time
    they are fine, you still need to test all apps on a real device to ensure the
    threads are working. Remember, the simulator is buggy (for example, the simulator
    works on a **Just In Time** processor model rather than **Ahead Of Time**, which
    the phone uses—the results are that web services may not work as planned) and
    doesn't work the same way as a phone.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 背景线程和异步调用有许多用途，一般建议如果某个过程耗时较长，就将其放在后台执行。使用线程时要小心。虽然大多数时候它们都很好，但你仍然需要在真实设备上测试所有应用程序，以确保线程正常工作。记住，模拟器是有缺陷的（例如，模拟器在**即时编译**处理器模型上工作，而不是手机使用的**预编译**，结果是网络服务可能不会按计划工作）并且与手机的工作方式不同。
