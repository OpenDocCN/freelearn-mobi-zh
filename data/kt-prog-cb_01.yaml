- en: Installation and Working with Environment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和与环境的交互
- en: 'The following recipes will be covered in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Creating Kotlin Android project
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 Kotlin Android 项目
- en: How to use Gradle to run Kotlin code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Gradle 运行 Kotlin 代码
- en: How to run a Kotlin compiled class
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何运行 Kotlin 编译后的类
- en: How to build a self-executable jar with Gradle and Kotlin
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Gradle 和 Kotlin 构建可执行的 jar 文件
- en: Reading console input in Kotlin
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Kotlin 中读取控制台输入
- en: Converting Java code to Kotlin and vice versa
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Java 代码转换为 Kotlin 以及相反操作
- en: How to write an idiomatic logger with Kotlin
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Kotlin 编写惯用日志记录器
- en: Escaping for Java identifiers that are keywords in Kotlin
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 Kotlin 中的关键字转义 Java 标识符
- en: Disambiguating using the "as" keyword to locally rename the clashing entity
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 "as" 关键字消除歧义，以局部重命名冲突实体
- en: Doing bit manipulations in Kotlin
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Kotlin 中进行位操作
- en: Parsing String to Long, Double, or Int
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将字符串解析为 Long、Double 或 Int
- en: Using String templates in Kotlin
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Kotlin 中使用字符串模板
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Android apps are a fascinating piece of technology. The apps developed on Android
    have worldwide appeal and audience. However, that has posed serious challenges
    for developers. The challenge is with updating APIs, platforms, and varied device
    capabilities. For example, if you are an Android developer, you have to rely on
    Java 6 if you want to support all API levels in Android. Java 6 is obsolete now,
    so much so that even its successor, Java 7, is kind of obsolete today. There was
    a great need for modern language for Android, which has built a trillion dollar
    industry around it and has influenced billions of lives. True, we have Java 8
    now, but we can only use it if we are developing Android apps for API level 24
    and above. However, that’s equivalent to targeting only 9% of Android devices
    as of 2017; clearly, this isn’t the way to go.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Android 应用是一项迷人的技术。在 Android 上开发的应用具有全球的吸引力和受众。然而，这也给开发者带来了严峻的挑战。挑战在于更新 API、平台和多样化的设备功能。例如，如果你是一名
    Android 开发者，如果你想支持 Android 中的所有 API 级别，你必须依赖 Java 6。Java 6 现在已经过时，甚至它的继任者 Java
    7 也有些过时。对于 Android，现代语言的需求非常迫切，它围绕 Android 建立了一个价值万亿美元的行业，并影响了数十亿人的生活。诚然，我们现在有
    Java 8，但我们只能用它来开发 API 级别 24 及以上的 Android 应用。然而，这相当于只针对 2017 年的 9% 的 Android 设备；显然，这不是正确的做法。
- en: All is not lost though, and thanks to the JVM, we can write Android apps using
    any language that produces JVM compatible bytecode on compilation. So theoretically,
    we can use Clojure, Groovy, Scala, and Kotlin, but Kotlin is the best alternative
    among all, why? It's because in April 2017, Google announced Kotlin as an official
    language for Android development.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，并没有失去一切，多亏了 JVM，我们可以使用任何在编译时产生 JVM 兼容字节码的语言来编写 Android 应用。所以从理论上讲，我们可以使用
    Clojure、Groovy、Scala 和 Kotlin，但 Kotlin 是所有替代方案中最好的，为什么？因为它在 2017 年 4 月，谷歌宣布 Kotlin
    为 Android 开发的官方语言。
- en: Some of the biggest tech companies such as Pinterest, Uber, Atlassian, Coursera,
    and Evernote are now using Kotlin in their Android apps. This wide adoption by
    them already speaks a huge volume for Kotlin. The 100% interoperability with Android
    and Java has helped Kotlin in its adoption. Kotlin is much easier to work with
    than Java and, apart from Android apps, you can also build web-apps with it. So,
    this chapter will introduce you to Kotlin and help you get started with this awesome
    piece of technology.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一些最大的科技公司，如 Pinterest、Uber、Atlassian、Coursera 和 Evernote，现在正在它们的 Android 应用中使用
    Kotlin。他们对此的广泛采用已经为 Kotlin 赢得了巨大的声誉。与 Android 和 Java 的 100% 兼容性有助于 Kotlin 的采用。与
    Java 相比，Kotlin 更易于使用，除了 Android 应用，你还可以用它来构建 Web 应用。因此，本章将向您介绍 Kotlin，并帮助您开始使用这项令人惊叹的技术。
- en: In this chapter, we will first see how to set up the environment to begin working
    with Kotlin.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先了解如何设置环境以开始使用 Kotlin。
- en: Creating Kotlin Android project
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Kotlin Android 项目
- en: Getting started with Kotlin is really easy, especially after Google has added
    official support for the language. You can use Kotlin directly with Android Studio
    3\. Android Studio 3 is still in Beta version at the time of writing this book.
    The best thing about using Kotlin for Android is that it is interoperable with
    your existing code, be it Java or C++. While working with Kotlin, you will realize
    that code in Kotlin is concise, extensible, and powerful. It really makes Android
    development more fun. Let's see how we can start working in Kotlin by first creating
    a Kotlin project in Android Studio 3.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Kotlin 入门非常简单，尤其是在 Google 为该语言添加了官方支持之后。您可以直接使用 Kotlin 与 Android Studio 3
    一起使用。撰写本书时，Android Studio 3 仍处于测试版本。使用 Kotlin 进行 Android 开发的最佳之处在于，它与现有的代码兼容，无论是
    Java 还是 C++。在用 Kotlin 开发时，您会发现 Kotlin 代码简洁、可扩展且强大。它确实让 Android 开发变得更加有趣。让我们看看如何通过在
    Android Studio 3 中首先创建 Kotlin 项目来开始使用 Kotlin 进行开发。
- en: Getting ready
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: To get started with this recipe, you will need Android Studio installed on your
    computer. Android Studio has both Android SDK and Android Virtual device in it.
    Ensure that you have Java Development Kit installed on your system. You will need
    an android phone or Emulator for debugging your project. You will also need at
    least one Android Virtual Device installed, of your desired specifications if
    you are not using an Android phone.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始此菜谱，您需要在您的计算机上安装 Android Studio。Android Studio 包含 Android SDK 和 Android 虚拟设备。请确保您已安装
    Java 开发工具包。您需要一个安卓手机或模拟器来调试您的项目。如果您不使用安卓手机，您还需要至少安装一个符合您所需规格的 Android 虚拟设备。
- en: 'So basically, here''s the checklist of the things that need to be installed
    before you move on to the next section:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，基本上，以下是需要安装的清单，在您进入下一节之前需要完成：
- en: Java Development Kit (use the latest)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 开发工具包（使用最新版本）
- en: Android Studio 3+
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android Studio 3+
- en: Android phone or emulator
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安卓手机或模拟器
- en: How to do it...
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Creating a project in Android Studio is very simple and to create it in Kotlin
    just requires one extra click. Here''s a step-by-step process of doing it:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建项目非常简单，要在 Kotlin 中创建它只需多点击一次。以下是进行此操作的步骤：
- en: In Android Studio, in the menu, click on File | New | New Project. Alternatively,
    if you've just opened Android Studio and see the Welcome to Android Studio window,
    click on Start a new Android Studio project.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Android Studio 中，在菜单中点击文件 | 新建 | 新建项目。或者，如果您刚刚打开 Android Studio 并看到 Android
    Studio 欢迎窗口，请点击开始新的 Android Studio 项目。
- en: 'In the wizard, add your Application name and Company domain, and simply check
    the box that says Include Kotlin support. Click on Next:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在向导中，添加您的应用程序名称和公司域名，并简单地勾选包含 Kotlin 支持的复选框。点击“下一步”：
- en: '![](img/e23ddc9d-c1b0-4248-8e32-bf979557e1ce.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e23ddc9d-c1b0-4248-8e32-bf979557e1ce.png)'
- en: 'On the next screen, you will be asked to choose your target devices and the
    minimum SDK support. So basically, it asks things like, "Do you want the application
    to run on both phone and android wear?" and "Do you want to support from Jelly
    Bean up or KitKat and up?":'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一屏幕上，您将被要求选择目标设备和最低 SDK 支持。基本上，它会询问类似的问题：“您希望应用程序在手机和 Android Wear 上运行吗？”以及“您希望支持从
    Jelly Bean 开始还是从 KitKat 开始？”
- en: '![](img/5d8bb3e1-e242-4760-ba2f-f20abf887a58.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5d8bb3e1-e242-4760-ba2f-f20abf887a58.png)'
- en: 'On the next screen, you will be prompted to Add an Activity to the project.
    You can also skip this step and add an activity later, but for now, just click
    on a Basic Activity and click on Next. If you have also chosen Wear or any other
    option, you will be prompted to add activity for those components as well:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一屏幕上，您将被提示向项目中添加活动。您也可以跳过此步骤，稍后添加活动，但在此阶段，只需点击基本活动并点击“下一步”。如果您还选择了可穿戴设备或任何其他选项，您将被提示为这些组件添加活动：
- en: '![](img/0f91044d-30db-4b81-8ea1-68c51d218031.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0f91044d-30db-4b81-8ea1-68c51d218031.png)'
- en: Next, you will be prompted to **Configure the Activity** you added. Basically,
    what you have to do is to provide **Activity Name, Layout Name,** and **Title**.
    After this, click on Finish, because you are done with creating your first project
    in Kotlin.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您将被提示**配置**您添加的活动。基本上，您需要做的是提供**活动名称、布局名称**和**标题**。完成这些后，点击“完成”，因为您已经完成了在
    Kotlin 中创建第一个项目的操作。
- en: 'Run project on your device: You need to follow these steps:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的设备上运行项目：您需要按照以下步骤操作：
- en: Connect your device to your development machine with a USB cable.
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 USB 线缆将您的设备连接到您的开发机器。
- en: Enable USB debugging on your device by going to Settings | Developer options.
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到设置 | 开发者选项来在您的设备上启用 USB 调试。
- en: On Android 4.2 and newer, Developer options are hidden by default. To make it
    available, go to Settings | About phone and tap on Build number seven times. Return
    to the previous screen to find Developer options.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 4.2 及更高版本中，开发者选项默认隐藏。要使其可用，转到设置 | 关于手机，然后连续点击 Build number 七次。返回上一屏幕以找到开发者选项。
- en: Now in your Android Studio, click on the app module in the Project window and
    then select Run (or click on Run in the toolbar).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在你的 Android Studio 中，点击项目窗口中的 app 模块，然后选择运行（或在工具栏中点击运行）。
- en: In the Select Deployment Target window, select your device, and click on OK.
    After a while, you will see the application running on your mobile or an emulator.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择部署目标窗口中，选择你的设备，然后点击 OK。过了一会儿，你将在你的手机或模拟器上看到应用程序正在运行。
- en: There's more...
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'After clicking on the Finish button in the Create New Project window, Android
    Studio will configure things and create your project. If you added an activity
    as mentioned in Step 4, you will be greeted with the boilerplate code of the activity.
    It looks something like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新项目窗口中点击完成按钮后，Android Studio 将配置一些设置并创建你的项目。如果你在步骤 4 中添加了活动，你将看到活动的样板代码。它看起来可能如下所示：
- en: '![](img/0776d959-584c-41fd-aef4-f9e92cdade26.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0776d959-584c-41fd-aef4-f9e92cdade26.png)'
- en: How to use Gradle to run Kotlin code
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使用 Gradle 运行 Kotlin 代码
- en: '**Gradle** has now become the de facto build tool for Android, and it is very
    powerful. It’s great for automating tasks without compromising on maintainability,
    usability, flexibility, extensibility, or performance. In this recipe, we will
    see how to use Gradle to run Kotlin code.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**Gradle** 现在已经成为 Android 的默认构建工具，并且非常强大。它非常适合自动化任务，同时不牺牲可维护性、可用性、灵活性、可扩展性或性能。在本菜谱中，我们将看到如何使用
    Gradle 运行 Kotlin 代码。'
- en: Getting ready
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will be using IntelliJ IDEA because it provides great integration of Gradle
    with Kotlin, and it is a really great IDE to work on. You can also use Android
    Studio for it.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 IntelliJ IDEA，因为它提供了 Gradle 与 Kotlin 的出色集成，并且是一个非常出色的 IDE 来进行工作。你也可以用它来使用
    Android Studio。
- en: How to do it...
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做这件事...
- en: 'In the following steps, we will be creating a Kotlin project with the Gradle
    build system. First, we will select the Create New Project option from the menu.
    Then, follow these steps:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下步骤中，我们将使用 Gradle 构建系统创建一个 Kotlin 项目。首先，从菜单中选择创建新项目选项。然后，按照以下步骤操作：
- en: '![](img/3f365cbe-4d7e-4147-9b7c-8ab6cb9e8958.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3f365cbe-4d7e-4147-9b7c-8ab6cb9e8958.png)'
- en: 'Create the project with the Gradle build system:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Gradle 构建系统创建项目：
- en: '![](img/31bbd90b-193b-4c21-8e2c-0ff266d2f928.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/31bbd90b-193b-4c21-8e2c-0ff266d2f928.png)'
- en: 'After you have created the project, you will have the `build.gradle` file,
    which will look something like the following:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你创建了项目之后，你将拥有 `build.gradle` 文件，它看起来可能如下所示：
- en: '[PRE0]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now we will create a `HelloWorld` class, which will have a simple main function:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将创建一个 `HelloWorld` 类，它将有一个简单的 main 函数：
- en: '![](img/297f7877-9347-49c1-9d96-2049609d8a66.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/297f7877-9347-49c1-9d96-2049609d8a66.png)'
- en: 'Now, it would be really cool to run this code directly. To do so, we will use
    the `gradle run` command. However, before that, we need to enable the application
    plugin, which will allow us to directly run this code. We need to add two lines
    in the `build.gradle` file to set it up:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，能够直接运行此代码将非常酷。为了做到这一点，我们将使用 `gradle run` 命令。然而，在这样做之前，我们需要启用应用程序插件，这将允许我们直接运行此代码。我们需要在
    `build.gradle` 文件中添加两行来设置它：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After this, you can type `gradle run` in the terminal to execute this file,
    and you will see the output of the method, as shown:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此之后，你可以在终端中输入 `gradle run` 来执行此文件，你将看到方法的输出，如图所示：
- en: '![](img/96d5b511-9231-47b9-92de-750161d4a402.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/96d5b511-9231-47b9-92de-750161d4a402.png)'
- en: There's more...
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The default structure of the project, when you create a new project in IntelliJ,
    is as illustrated:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 IntelliJ 中创建新项目时，项目的默认结构如图所示：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you want to have a different structure of the project, you should declare
    it in `build.gradle`. You can do it by adding the following lines in `build.gradle`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要项目有不同的结构，你应该在 `build.gradle` 中声明它。你可以通过在 `build.gradle` 中添加以下行来实现：
- en: 'The corresponding `sourceSets` property should be updated if not using the
    default convention:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不使用默认约定，应更新相应的 `sourceSets` 属性：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Though you can keep Kotlin and Java files under the same package, it’s a good
    practice to keep them separated.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以将 Kotlin 和 Java 文件放在同一个包下，但将它们分开是一个好的做法。
- en: See also
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Check out the *How to build a self-executable jar with Gradle and Kotlin* recipe
    in this chapter.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 查看本章中的 *如何使用 Gradle 和 Kotlin 构建可执行 jar* 菜单。
- en: How to run a Kotlin compiled class
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何运行编译后的 Kotlin 类
- en: Working with the command-line compiler for any language is one of the first
    steps to get a better understanding of the language, and this knowledge comes
    handy at a lot of times. In this recipe, we will run a Kotlin program using the
    command line, and we will also play a bit with the interactive shell of Kotlin.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用任何语言的命令行编译器是更好地理解该语言的第一步之一，这种知识在很多情况下都很有用。在这个菜谱中，我们将使用命令行运行 Kotlin 程序，并且我们还会在
    Kotlin 的交互式 shell 中玩一会儿。
- en: Getting ready
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To be able to perform this recipe, you need a Kotlin compiler installed on your
    development machine. Every Kotlin release ships with a standalone compiler. You
    can find the latest release at [https://github.com/JetBrains/kotlin/releases](https://github.com/JetBrains/kotlin/releases).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够执行此菜谱，你需要在你的开发机器上安装 Kotlin 编译器。每个 Kotlin 版本都附带一个独立编译器。你可以在 [https://github.com/JetBrains/kotlin/releases](https://github.com/JetBrains/kotlin/releases)
    找到最新版本。
- en: To manually install the compiler, unzip the standalone compiler into a directory
    and optionally, add the bin directory to the system path. The bin directory contains
    the scripts needed to compile and run Kotlin on Windows, OS X, and Linux.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要手动安装编译器，将独立编译器解压缩到目录中，并可选地将 bin 目录添加到系统路径。bin 目录包含在 Windows、OS X 和 Linux 上编译和运行
    Kotlin 所需的脚本。
- en: How to do it...
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Now we are ready to run our first program using the command line. First, we
    will create a simple application that displays Hello World! and then compile it:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备使用命令行运行我们的第一个程序。首先，我们将创建一个简单的应用程序，显示“Hello World!”，然后编译它：
- en: 'Create a file with the name `hello.kt` and add the following lines of code
    in that file:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `hello.kt` 的文件，并在该文件中添加以下代码行：
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now we compile the file using the following command:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们使用以下命令编译文件：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now we run the application using the following command:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们使用以下命令运行应用程序：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Suppose you want to create a library that can be used with other Kotlin applications;
    we can simply compile the Kotlin application in question into `.jar` executable
    without the `-include-runtime` option, that is, the new command will be as follows:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你想创建一个可以与其他 Kotlin 应用程序一起使用的库；我们可以简单地编译相关的 Kotlin 应用程序为 `.jar` 可执行文件，而不使用
    `-include-runtime` 选项，即新的命令如下：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, let''s check out the Kotlin interactive shell. Just run the Kotlin compiler
    without any parameters to have an interactive shell. Here''s how it looks:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看 Kotlin 交互式 shell。只需不带任何参数运行 Kotlin 编译器即可获得交互式 shell。下面是它的样子：
- en: '![](img/094ab1d4-fbc5-4ca7-99a6-ec234218c153.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/094ab1d4-fbc5-4ca7-99a6-ec234218c153.png)'
- en: Hopefully, you must have noticed the information I am always guilty of ignoring,
    that is, the command to quit interactive shell is `:quit` and for help, it is
    `:help`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你注意到了我总是忽略的信息，那就是退出交互式 shell 的命令是 `:quit`，获取帮助的命令是 `:help`。
- en: 'You can run any valid Kotlin code in the interactive shell. For example, try
    some of the following commands:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在交互式 shell 中运行任何有效的 Kotlin 代码。例如，尝试以下命令中的几个：
- en: '`3*2+(55/5)`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`3*2+(55/5)`'
- en: '`println("yo")`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`println("yo")`'
- en: '`println("check this out ${3+4}")`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`println("check this out ${3+4}")`'
- en: 'Here''s a screenshot of running the preceding code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是运行前面代码的截图：
- en: '![](img/49cfe315-be64-4674-92d7-315f31743215.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/49cfe315-be64-4674-92d7-315f31743215.png)'
- en: How it works...
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何工作...
- en: The `-include-runtime` option makes the resulting `.jar` file self-contained
    and runnable by including the Kotlin runtime library in it. Then, we use Java
    to run the `.jar` file generated.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`-include-runtime` 选项使得生成的 `.jar` 文件包含 Kotlin 运行时库，从而使其自包含并可运行。然后，我们使用 Java
    运行生成的 `.jar` 文件。'
- en: The `-d` option in the command indicates what we want the output of the compiler
    to be called and maybe either a directory name for class files or a `.jar` filename.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 命令中的 `-d` 选项表示编译器的输出应该被命名为什么，可能是类文件的目录名或 `.jar` 文件名。
- en: There's more...
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: Kotlin can also be used for writing shell scripts. A shell script has top-level
    executable code.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 也可以用于编写 shell 脚本。shell 脚本包含顶层可执行代码。
- en: Kotlin script files have the `.kts` extension as opposed to the usual `.kt`
    for Kotlin applications.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 脚本文件具有 `.kts` 扩展名，而不是 Kotlin 应用程序的常用 `.kt` 扩展名。
- en: 'To run a script file, just pass the `-script` option to the compiler:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行脚本文件，只需将 `-script` 选项传递给编译器：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How to build a self-executable JAR with Gradle and Kotlin
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使用 Gradle 和 Kotlin 构建可执行的 JAR 文件
- en: Kotlin is great for creating small command-line utilities, which can be packaged
    and distributed as normal JAR files. In this recipe, we will see how to do it
    using Gradle build system. Gradle build system is one of the most sophisticated
    build systems out there. It is the default build tool for Android and is designed
    to ease scripting of complex, multilanguage builds with a lot of dependencies
    (typical of big projects). It achieves the goal of automating your project without
    compromising on maintainability, usability, flexibility, extensibility, or performance.
    We will be using Gradle build system to create a self-extracting JAR file. This
    JAR file can be distributed to and run on any platform supporting Java.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 是创建小型命令行工具的绝佳选择，这些工具可以打包并作为正常的 JAR 文件分发。在本教程中，我们将看到如何使用 Gradle 构建系统来实现。Gradle
    构建系统是最复杂的构建系统之一。它是 Android 的默认构建工具，旨在简化复杂、多语言构建的脚本编写，这些构建通常具有许多依赖项（大型项目的典型特征）。它通过自动化项目而不会牺牲可维护性、可用性、灵活性、可扩展性或性能来实现目标。我们将使用
    Gradle 构建系统来创建自解压 JAR 文件。这个 JAR 文件可以在支持 Java 的任何平台上分发和运行。
- en: Getting ready
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'You need an IDE (preferably IntelliJ or Android Studio), and you need to tell
    it where your Kotlin files are present. You can do so by specifying it in the
    `build.gradle` file by adding the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个集成开发环境（最好是 IntelliJ 或 Android Studio），并且需要告诉它 Kotlin 文件所在的位置。您可以通过在 `build.gradle`
    文件中指定它来实现，添加以下内容：
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding lines are required if you have your Kotlin files separated from
    Java packages. This is optional, and you can continue working with Kotlin files
    under Java packages, but it’s a good practice to keep them separated.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的 Kotlin 文件与 Java 包分开，前面的这些行是必需的。这是可选的，您可以在 Java 包下继续使用 Kotlin 文件，但将它们分开是一个好的实践。
- en: We’ll be creating a very simple function that just prints `Hello World!` when
    executed. Since it’ll be a simple function, I am just adding it as a top-level
    `main()` function.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个非常简单的函数，当执行时只打印 `Hello World!`。由于它是一个简单的函数，我只是将其添加为一个顶级的 `main()` 函数。
- en: How to do it...
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s go through these steps, with which we can create a self-executable JAR:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步步来，这样我们可以创建一个可执行的 JAR 文件：
- en: 'We’ll create a simple class `HelloWorld.kt` having the main function, which
    just prints out “Hello world!”:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的类 `HelloWorld.kt`，其中包含主函数，该函数只打印出 “Hello world!”：
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now we need to configure a `jar` task, which Gradle build goes through to inform
    it of our entry to our project. In a Java project, this will be the path to the
    class where our `main()` function resides, so you will need to add this `jar`
    task in `build.gradle`:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要配置一个 `jar` 任务，Gradle 构建过程会通过它来告知我们的项目入口。在一个 Java 项目中，这将是我们 `main()` 函数所在类的路径，因此您需要在
    `build.gradle` 中添加此 `jar` 任务：
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After adding the preceding snippet to `build.gradle`, you need to run the following
    gradle command to create the jar file:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将前面的代码片段添加到 `build.gradle` 后，您需要运行以下 gradle 命令来创建 JAR 文件：
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The created jar file can be found in the `build/libs` folder. Now you can just
    run the `java -jar demo.jar` command to run the JAR file.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建的 JAR 文件可以在 `build/libs` 文件夹中找到。现在您只需运行 `java -jar demo.jar` 命令来运行 JAR 文件。
- en: 'After you do that, you can see the output in the console:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在您完成之后，您可以在控制台中看到输出：
- en: '![](img/58fe47ee-58b4-4d16-b62f-2510892deaa4.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/58fe47ee-58b4-4d16-b62f-2510892deaa4.png)'
- en: How it works...
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To make self-executable JARs, we need a manifest file called `MANIFEST.MF` in
    the `META-INF` directory. For our purposes here, we just need to specify the name
    of the Java class that contains the Java-based extractor program's `main()` method.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建可执行 JAR 文件，我们需要在 `META-INF` 目录中一个名为 `MANIFEST.MF` 的清单文件。对于我们的目的，我们只需要指定包含基于
    Java 的提取程序 `main()` 方法的 Java 类的名称。
- en: 'One might argue that even though we don’t have top-level class declaration,
    we are specifying it as `HelloWorldKt` in the code for the jar task:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能会争论，尽管我们没有顶级类声明，但我们已经在 jar 任务中的代码中将其指定为 `HelloWorldKt`：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The reason for putting the preceding code block in the jar task is that Kotlin
    compiler adds all top-level functions to respective classes for back-compatibility
    with JVM. So, the class generated by Kotlin compiler will have the filename, plus
    the `Kt` suffix, which makes it `HelloWorldKt`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的代码块放在 jar 任务中的原因是 Kotlin 编译器会将所有顶级函数添加到相应的类中，以实现与 JVM 的向后兼容性。因此，Kotlin 编译器生成的类将具有文件名，加上
    `Kt` 后缀，使其成为 `HelloWorldKt`。
- en: 'Also, the reason we added `from { configurations.compile.collect { it.isDirectory()
    ? it : zipTree(it) } }` in jar task is because we want Gradle to copy all of a
    JAR’s dependencies. The reason for doing so is that, by default, when Gradle (as
    well as Maven) packs some Java class files into a JAR file, it assumes that this
    JAR file will be referenced by an application, where all of its dependencies are
    also accessible in the classpath of the loading application. So, by specifying
    the preceding lines in jar task, we are telling gradle to take all of this JAR’s
    referenced dependencies and copy them as part of the JAR itself. In the Java community,
    this is known as a **fat JAR**. In a fat JAR, all the dependencies end up within
    the classpath of the loading application, so the code can be executed without
    problems. The only downside to creating fat JARs is their growing file size (which
    kind of explains the name), though it is not a big concern in most situations.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '此外，我们在 jar 任务中添加 `from { configurations.compile.collect { it.isDirectory()
    ? it : zipTree(it) } }` 的原因是因为我们希望 Gradle 复制 JAR 的所有依赖项。这样做的原因是，默认情况下，当 Gradle（以及
    Maven）将一些 Java 类文件打包到 JAR 文件中时，它假设这个 JAR 文件将被应用程序引用，其中所有依赖项都可以在加载应用程序的类路径中访问。因此，通过在
    jar 任务中指定前面的行，我们告诉 gradle 将这个 JAR 的所有引用依赖项作为 JAR 本身的一部分复制。在 Java 社区中，这被称为 **胖
    JAR**。在胖 JAR 中，所有依赖项最终都会出现在加载应用程序的类路径中，因此代码可以无问题地执行。创建胖 JAR 的唯一缺点是它们的文件大小会不断增长（这也解释了其名称），尽管在大多数情况下这并不是一个大问题。'
- en: Reading console input in Kotlin
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Kotlin 中读取控制台输入
- en: In many applications, user interaction is a very important part, and the most
    basic way of doing that is reading input entered by the user and giving output
    based on it. In this recipe, we will understand different ways of reading input
    and also provide output in the console.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多应用中，用户交互是一个非常重要的部分，而实现这一点的最基本方式是读取用户输入的内容，并根据它给出输出。在这个菜谱中，我们将了解读取输入的不同方式，并在控制台中提供输出。
- en: Getting ready
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to install a preferred development environment that compiles and runs
    Kotlin. You can also use the command line to compile and run your Kotlin code,
    for which you need Kotlin compiler installed along with JDK.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装一个首选的开发环境，该环境可以编译和运行 Kotlin。您也可以使用命令行来编译和运行您的 Kotlin 代码，这需要安装 Kotlin 编译器和
    JDK。
- en: How to do it...
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s go through the following steps by which we can read console input in
    Kotlin:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤了解如何在 Kotlin 中读取控制台输入：
- en: 'We will start simple and move to more advanced logic as we move forward. First,
    let''s start with simply printing a line as output in the console:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从一个简单的打印一行输出到控制台开始，随着我们的前进，我们将逐步转向更高级的逻辑：
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now we will try to take String input from the console and output it again:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将尝试从控制台读取字符串输入并将其再次输出：
- en: '[PRE15]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Okay, how about we repeat the process with Int:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，我们是否可以用 Int 重复这个过程？
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, let''s try a complicated code and then start with the explanations:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试一段复杂的代码，然后再开始解释：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here''s a screenshot of compiling and running the preceding code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是编译和运行前面代码的截图：
- en: '![](img/f7173076-e6a6-40dc-8193-85622cacf09f.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f7173076-e6a6-40dc-8193-85622cacf09f.png)'
- en: How it works...
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's try to understand the methods by which we were able to read input in Kotlin.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试理解我们能够通过 Kotlin 读取输入的方法。
- en: Behind the scenes, `Kotlin.io` uses `java.io` for the input-output. So `println`
    is basically `System.out.println`, but with additional power by Kotlin to use
    String templates and `inline` functions, which makes writing extremely simple
    and concise.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，`Kotlin.io` 使用 `java.io` 进行输入输出。所以 `println` 实际上是 `System.out.println`，但
    Kotlin 通过使用字符串模板和 `inline` 函数提供了额外的功能，这使得编写代码变得极其简单和简洁。
- en: 'This is a part of the actual code from Kotlin `stdlib` used for Console IO:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从 Kotlin `stdlib` 中用于控制台 I/O 的实际代码的一部分：
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Converting Java code to Kotlin and vice versa
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Java 代码转换为 Kotlin 以及相反
- en: The best part about Kotlin is its interoperability with Java. Also, with IntelliJ-based
    IDE, we can directly convert our Java code to Kotlin. In this recipe, we will
    see how to do it.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 最好的部分是它与 Java 的互操作性。此外，使用基于 IntelliJ 的 IDE，我们可以直接将我们的 Java 代码转换为 Kotlin。在这个菜谱中，我们将看到如何做到这一点。
- en: Getting ready
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe needs IntelliJ-based IDE installed, which compiles and runs Kotlin
    and Java.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱需要安装基于 IntelliJ 的 IDE，它可以编译和运行 Kotlin 和 Java。
- en: How to do it...
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s see the steps to convert a Kotlin file to a Java file:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看将 Kotlin 文件转换为 Java 文件的步骤：
- en: In your IntelliJ IDE, open the Java file that you want to convert to Kotlin.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的 IntelliJ IDE 中，打开您想要转换为 Kotlin 的 Java 文件。
- en: Note that it has a `.java` extension. Now, in the main menu, click on Code menu
    and choose the Convert Java File to Kotlin File option. Your Java file will be
    converted into Kotlin, and the extension will now be `.kt`.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，它有一个 `.java` 扩展名。现在，在主菜单中，点击代码菜单并选择“将 Java 文件转换为 Kotlin 文件”选项。您的 Java 文件将被转换为
    Kotlin，并且扩展名现在将是 `.kt`。
- en: 'Shown here is an example of a Java file:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个 Java 文件的示例：
- en: '![](img/59c2bb9a-cd5e-48d9-9d2a-6b08f5e0c991.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/59c2bb9a-cd5e-48d9-9d2a-6b08f5e0c991.png)'
- en: 'After converting to Kotlin, this is what we have:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为 Kotlin 后，这是我们的结果：
- en: '![](img/77c5efac-a454-4522-9b4d-42f2f6a789d2.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/77c5efac-a454-4522-9b4d-42f2f6a789d2.png)'
- en: 'A Kotlin file can be converted into Java, but it''s better if you can avoid
    it or find an alternative way to do it. If you have to absolutely convert your
    Kotlin code to Java, click on Tools | Kotlin | Show Kotlin Bytecode in the menu:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kotlin 文件可以转换为 Java，但最好避免这样做或找到其他替代方法。如果您必须绝对将 Kotlin 代码转换为 Java，请点击菜单中的“工具
    | Kotlin | 显示 Kotlin 字节码”：
- en: '![](img/074a57e3-c2e3-4d03-a6d7-ac39528d9c5f.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/074a57e3-c2e3-4d03-a6d7-ac39528d9c5f.png)'
- en: 'After clicking on Show Kotlin Bytecode, a window will open with the title Kotlin
    Bytecode:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“显示 Kotlin 字节码”后，将打开一个标题为“Kotlin 字节码”的窗口：
- en: '![](img/a11d5e08-d724-4c33-ad89-20f01060d707.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a11d5e08-d724-4c33-ad89-20f01060d707.png)'
- en: 'Click on Decompile and a `.java` file will be generated, containing a  decompiled
    Java bytecode from Kotlin code:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“反编译”，将生成一个 `.java` 文件，其中包含从 Kotlin 代码反编译的 Java 字节码：
- en: '![](img/f6636f42-ca0c-40fc-b957-425c4710445a.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f6636f42-ca0c-40fc-b957-425c4710445a.png)'
- en: Yes, it has a lot of unnecessary code that was not present in the original Java
    code, but that is the case with decompiled bytecode. At the moment, this is the
    only way to convert Kotlin code to Java. Copy the decompiled file into a `.java`
    file and remove the unnecessary code.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，它包含了很多在原始 Java 代码中不存在的多余代码，但这是反编译字节码的情况。目前，这是将 Kotlin 代码转换为 Java 的唯一方法。将反编译的文件复制到
    `.java` 文件中，并删除多余的代码。
- en: How it works...
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Kotlin is a statically-typed programming language that works on Java Virtual
    Machine and compiles into JVM compatible bytecode. This is the reason we can convert
    Java code to Kotlin and mix Java and Kotlin code together.  This is also the reason
    why you can, in a way, get Java code back from Kotlin (although the output is
    not completely desired).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 是一种静态类型编程语言，它在 Java 虚拟机上运行，并编译成 JVM 兼容的字节码。这就是我们可以将 Java 代码转换为 Kotlin
    并混合 Java 和 Kotlin 代码的原因。这也是为什么您可以从 Kotlin 中以某种方式获取 Java 代码（尽管输出并不完全符合预期）的原因。
- en: How to write an idiomatic logger in Kotlin
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何在 Kotlin 中编写惯用的日志记录器
- en: Kotlin has some great powerful features packed in it that we should be making
    use of to improve our code. This involves rethinking on our old best practices
    of coding. Many of our old coding practices can be replaced by better alternatives
    from Kotlin. One of them is how we write our logger. Though there are a lot of
    libraries out there that provide logging functionality, we will try to create
    our own logger in this recipe, just by using idiomatic Kotlin.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 中包含了一些非常强大的功能，我们应该利用这些功能来改进我们的代码。这涉及到重新思考我们旧的编码最佳实践。我们许多旧的编码实践可以用 Kotlin
    中的更好替代方案来替换。其中之一就是我们的日志记录器编写方式。尽管有许多库提供了日志功能，但我们将尝试在这个菜谱中仅使用惯用的 Kotlin 创建自己的日志记录器。
- en: Getting ready
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will be using IntelliJ IDE to write and execute our code.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 IntelliJ IDE 来编写和执行我们的代码。
- en: How to do it...
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Let''s go through the given steps to create an idiomatic logger in Kotlin:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照给定的步骤在 Kotlin 中创建一个惯用的日志记录器：
- en: 'First, let''s see how it was done in Java. In Java, SLF4J is used and considered
    de-facto, so much that logging seems like a solved problem in Java language. Here''s
    what a Java implementation would look like:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们看看在 Java 中是如何实现的。在 Java 中，使用 SLF4J，并且被认为是事实上的标准，以至于在 Java 语言中日志记录似乎是一个已经解决的问题。下面是一个
    Java 实现的样子：
- en: '[PRE19]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It also works fine with Kotlin, obviously with minor modifications:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显然，它也适用于 Kotlin，当然需要一些小的修改：
- en: '[PRE20]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'However, apart from this, we can utilize the power of Kotlin using **Delegates**
    for the logger. In this case, we will be creating the logger using the `lazy` keyword.
    This way, we will create the object only when we access it. Delegates are a great
    way to postpone object creation until we use it. This improves startup time (which
    is much needed and appreciated in Android). So let us explore a method using lazy
    delegates in Kotlin:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，除了这个之外，我们可以利用 Kotlin 的**委托**功能来增强 logger 的功能。在这种情况下，我们将使用 `lazy` 关键字来创建 logger。这样，我们只有在访问它时才会创建对象。委托是一种推迟对象创建直到使用它的好方法。这可以提高启动时间（这在
    Android 中非常需要且受欢迎）。让我们探索 Kotlin 中使用懒委托的方法：
- en: 'We''ll use `java.util.Logging` internally, but this works for any Logging library
    of your choice. So let’s use the Kotlin’s lazy delegate to get our logger:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将内部使用 `java.util.Logging`，但这适用于你选择的任何 Logging 库。所以，让我们使用 Kotlin 的懒委托来获取我们的
    logger：
- en: '[PRE21]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now in our class, we can simply call the method to get our logger and use it:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在我们的类中，我们可以简单地调用方法来获取我们的 logger 并使用它：
- en: '[PRE22]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When you run the code, you can see the following output:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行代码时，你可以看到以下输出：
- en: '[PRE23]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: So, as we can see in the output, we get the class name and method name too (if
    you are accessing logger inside a method).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如输出所示，我们还可以得到类名和方法名（如果你是在方法内部访问 logger）。
- en: How it works...
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Here, one thing to note is that we have put our logger inside a companion object.
    The reason for this is quite straightforward because we want to have only one
    instance of logger per class.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，需要注意的是，我们将 logger 放在了伴生对象中。这样做的原因很简单，因为我们希望每个类只有一个 logger 实例。
- en: Also, `logger()` returns a delegate object, which means that the object will
    be created on its first access and will return the same value (object) on subsequent
    accesses.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`logger()` 返回一个委托对象，这意味着对象将在第一次访问时创建，并在后续访问时返回相同的值（对象）。
- en: There's more...
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Anko is an Android library that uses Kotlin and makes Android development easier
    with the help of extension functions. It provides **Anko-logger**, which you can
    use if you don’t want to write your own logger. It is included in *anko-commons*,
    which also has a lot of interesting things to make it worthwhile to include it
    in your Android projects that use Kotlin.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Anko 是一个使用 Kotlin 的 Android 库，它通过扩展函数使 Android 开发更加容易。它提供了**Anko-logger**，如果你不想自己编写
    logger，可以使用它。它包含在 *anko-commons* 中，其中还有很多有趣的东西，使其值得将其包含在你的 Kotlin Android 项目中。
- en: 'In Anko, a standard implementation of logger will look something like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Anko 中，一个标准的 logger 实现看起来可能如下所示：
- en: '[PRE24]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, you just need to implement `AnkoLogger` and you are done.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你只需要实现 `AnkoLogger`，然后你就完成了。
- en: 'Each method has two versions: plain and lazy (inlined):'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 每个方法都有两种版本：普通和懒（内联）：
- en: '[PRE25]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The lambda result will be calculated only if `Log.isLoggable(tag, Log.INFO)`
    is true.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当 `Log.isLoggable(tag, Log.INFO)` 为 true 时，lambda 结果才会被计算。
- en: See also
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: To know more about delegated properties, refer to the **Working with delegated
    Properties** recipe in [Chapter 3](https://www.safaribooksonline.com/library/view/kotlin-programming-cookbook/9781788472142/9cdf4de5-7577-4bd5-ba2d-2bd38740957a.xhtml), *Classes
    and Objects*.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于委托属性的信息，请参考第 3 章**使用委托属性**的配方**“与委托属性一起工作”**，*类与对象*。
- en: Escaping for Java identifiers that are keywords in Kotlin
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin 中关键字作为 Java 标识符的转义
- en: Kotlin was designed with *interoperability* in mind. The existing code in Java
    can be called from Kotlin code smoothly, but since Java has different keywords
    than Kotlin, we sometimes run into issues when we call Java method with a name
    similar to Kotlin keyword. There is a workaround in Kotlin, which allows a method
    to be called having a name representing a Kotlin keyword.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 的设计理念是**互操作性**。现有的 Java 代码可以无缝地从 Kotlin 代码中调用，但由于 Java 和 Kotlin 有不同的关键字，我们在调用与
    Kotlin 关键字相似的 Java 方法时有时会遇到问题。Kotlin 中有一个解决方案，允许方法被调用时使用代表 Kotlin 关键字的名字。
- en: Getting ready
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Ensure that you have access to a code editor where you can write and run the
    code.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你有访问代码编辑器的权限，以便你可以编写和运行代码。
- en: How to do it...
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Create a Java class with a method name equal to any Kotlin keyword. I am using `is` as the
    method name, so my Java class looks as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个方法名等于任何 Kotlin 关键字的 Java 类。我使用 `is` 作为方法名，所以我的 Java 类如下所示：
- en: '[PRE27]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now try calling that method from Kotlin code. If you are using any code editor
    with the autocomplete feature, it automatically encloses the method name in backticks
    (`` ` ` ``):'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试从 Kotlin 代码中调用该方法。如果您使用的是具有自动完成功能的任何代码编辑器，它将自动将方法名称用反引号（`` ` ` ``）括起来：
- en: '[PRE28]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Similar is the case with other keywords in Kotlin that are qualified identifiers
    in Java.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 中的其他关键字（在 Java 中是合格标识符）也有类似的情况。
- en: How it works...
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'According to Kotlin’s documentation, some of the Kotlin keywords are valid
    identifiers in Java: `in`, `object`, `is`, and so on. If a Java library uses a
    Kotlin keyword for a method, you can still call the method, escaping it with the
    backtick (`` ` ``) character.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 Kotlin 的文档，一些 Kotlin 关键字在 Java 中也是有效的标识符：`in`、`object`、`is` 等。如果一个 Java 库使用
    Kotlin 关键字作为方法，您仍然可以调用该方法，使用反引号（`` ` ``）进行转义。
- en: 'The following are the keywords in Kotlin:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 Kotlin 中的关键字：
- en: '| package | as | typealias | class | this | super | val |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| package | as | typealias | class | this | super | val |'
- en: '| var | fun | for | null | true | false | is |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| var | fun | for | null | true | false | is |'
- en: '| in | throw | return | break | continue | object | if |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| in | throw | return | break | continue | object | if |'
- en: '| try | else | while | do | when | interface | typeof |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| try | else | while | do | when | interface | typeof |'
- en: Disambiguating using the "as" keyword to locally rename the clashing entity
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 "as" 关键字局部重命名冲突实体以消除歧义
- en: Disambiguation refers to the removal of ambiguity by making something clear. Importing
    a library or a class in code is a daily routine of a programmer. It’s pretty easy
    to import files into the code in every language, thanks to the great code editors
    nowadays.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 消除歧义是指通过使某事物清晰来消除歧义。在代码中导入库或类是程序员的日常任务。多亏了现在的优秀代码编辑器，将文件导入代码在每种语言中都变得非常容易。
- en: 'However, what happens if you try to import two classes into a file? Though
    you should always try to have different names for different classes, sometimes
    it’s unavoidable. For example, in the case of different libraries having the same
    name for their classes. In Java, there is a workaround; you have to use the full
    qualifier, which looks something like this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您尝试将两个类导入到一个文件中会发生什么？尽管您应该始终为不同的类使用不同的名称，但有时这是不可避免的。例如，在库的类具有相同名称的情况下。在
    Java 中，有一个解决方案；您必须使用完全限定符，看起来像这样：
- en: '[PRE29]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Dirty, isn’t it? Now, let’s see how Kotlin addresses it gracefully.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 脏，不是吗？现在，让我们看看 Kotlin 如何优雅地解决这个问题。
- en: Getting ready
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Ensure that you have a code editor on which you can write and run the code.
    To test things out, you can create two classes with the same name but under different
    packages. Refer to the example here:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您有一个代码编辑器，可以在其中编写和运行代码。为了测试，您可以创建两个具有相同名称但位于不同包中的类。请参考此处的示例：
- en: '![](img/34cb1dc3-38b1-47dd-ac11-5a20d76d0d2b.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/34cb1dc3-38b1-47dd-ac11-5a20d76d0d2b.png)'
- en: How to do it...
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: In the following steps and examples, we will see how we can disambiguate classes
    of the similar name using Kotlin's keyword.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下步骤和示例中，我们将看到如何使用 Kotlin 的关键字消除具有相似名称的类的歧义。
- en: 'In Kotlin, you can disambiguate using the `as` keyword to locally rename the
    clashing entity. So in Kotlin, it will look as shown:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，您可以使用 `as` 关键字来消除歧义，局部重命名冲突实体。所以，在 Kotlin 中，它看起来会像这样：
- en: '[PRE30]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, access their methods like this:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，像这样访问它们的方法：
- en: '[PRE31]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'For example, let''s see the use of the `as` keyword to disambiguate two classes
    having the same name (`SomeClass.kt`), but in different packages:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看如何使用 `as` 关键字消除两个具有相同名称（`SomeClass.kt`）但位于不同包中的类的歧义：
- en: '`SameClass.kt (packageA)`'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`SameClass.kt (packageA)`'
- en: '[PRE32]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`SameClass.kt (packageB)`'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`SameClass.kt (packageB)`'
- en: '[PRE33]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`HelloWorld.kt` is the class that uses classes with similar names:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`HelloWorld.kt` 是使用具有相似名称的类的类：'
- en: '[PRE34]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Doing bit manipulations in Kotlin
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Kotlin 中进行位操作
- en: Kotlin provides several functions (in infix form) to perform bitwise and bit
    shift operations. In this section, we will learn to perform bit-level operation
    in Kotlin with the help of examples.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 提供了几个函数（以中缀形式）来执行位和位移操作。在本节中，我们将通过示例学习如何在 Kotlin 中执行位级操作。
- en: Bitwise and bit shift operators are used on only two integral types—Int and
    Long—to perform bit-level operations.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 位和位移运算符仅用于两种整型——Int 和 Long——以执行位级操作。
- en: Getting ready
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Here''s the complete list of bitwise operations (available for Int and Long
    only):'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这是位操作（仅适用于 Int 和 Long）的完整列表：
- en: '`shr(bits)`: signed shift right (Java''s >>)'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shr(bits)`: 有符号右移（Java 的 >>）'
- en: '`ushr(bits)`: unsigned shift right (Java''s >>>)'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ushr(bits)`: 无符号右移（Java 的 >>>）'
- en: '`and(bits)`: bitwise and'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`and(bits)`: 按位与'
- en: '`or(bits)`: bitwise or'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`or(bits)`: 按位或'
- en: '`xor(bits)`: bitwise xor'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xor(bits)`: 位异或'
- en: '`inv()`: bitwise inversion'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inv()`: 位反转'
- en: How to do it...
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Let's check out a few examples to understand the bitwise operations.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个示例来理解位运算。
- en: Or
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 或者
- en: The `or` function compares the corresponding bits of two values. If either of
    the two bits is 1, it gives 1, and it gives 0 if not.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`or` 函数比较两个值的对应位。如果两个位中的任意一个是 1，则返回 1，如果不是，则返回 0。'
- en: 'Consider this example:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE35]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The following is the output:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是输出结果：
- en: '[PRE36]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here''s the explanation of the preceding example:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是前面示例的解释：
- en: 2 = 10 (Binary format)
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 2 = 10（二进制格式）
- en: 3 = 11 (Binary format)
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 3 = 11（二进制格式）
- en: Bitwise `OR` of 2 and 3 that is
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 2 和 3 的位或
- en: in binary
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制
- en: 10 `OR` 11
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 10 `OR` 11
- en: 11 = 3 (Decimal format)
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 11 = 3（十进制格式）
- en: and
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: and
- en: The `and` function compares the corresponding bits of two values. If either
    of the two bits is 0, it gives 0, if not and both bits are 1, it gives 1.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`and` 函数比较两个值的对应位。如果两个位中的任意一个是 0，则返回 0，如果不是且两个位都是 1，则返回 1。'
- en: 'Consider this example:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE37]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This is the output:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果：
- en: '[PRE38]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s look at the explanation:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看解释：
- en: 2 = 10 (Binary format)
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 2 = 10（二进制格式）
- en: 3 = 11 (Binary format)
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 3 = 11（二进制格式）
- en: Bitwise `AND` of 2 and 3
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 2 和 3 的位与
- en: in binary
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制
- en: 10 `AND` 11
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 10 `AND` 11
- en: 10 = 2 (Decimal format)
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 10 = 2（十进制格式）
- en: xor
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: xor
- en: The `xor` function compares the corresponding bits of two values. If the corresponding
    bits are the same, it gives 0, and if they are different, it gives 1.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`xor` 函数比较两个值的对应位。如果对应位相同，则返回 0，如果不同，则返回 1。'
- en: 'Look at this example:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个示例：
- en: '[PRE39]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Given is the output:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是输出结果：
- en: '[PRE40]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Here''s the explanation:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是解释：
- en: 2 = 10 (Binary format)
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 2 = 10（二进制格式）
- en: 3 = 11 (Binary format)
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 3 = 11（二进制格式）
- en: Bitwise `XOR` of 2 and 3
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 2 和 3 的位异或
- en: in binary
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制
- en: 10 `XOR` 11
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 10 `XOR` 11
- en: 01 = 1 (Decimal format)
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 01 = 1（十进制格式）
- en: inv
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: inv
- en: The `inv` function simply inverts the bit patterns. If the bit is 1, it makes
    it 0 and vice versa.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`inv` 函数简单地反转位模式。如果位是 1，则将其变为 0，反之亦然。'
- en: 'Here''s an example:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例：
- en: '[PRE41]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This is the output:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果：
- en: '[PRE42]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The following is the explanation:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是解释：
- en: 2 = 10 (Binary format)
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 2 = 10（二进制格式）
- en: Bitwise complement of 2 = 01, but the compiler shows 2’s complement of that
    number, which is the negative notation of the binary number.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 2 的位补码为 01，但编译器显示的是该数的 2 的补码，即二进制数的负表示法。
- en: 2’s complement of an integer *n* is equal to -(*n*+1).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 整数 *n* 的 2 的补码等于 -(*n*+1)。
- en: shl
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: shl
- en: The `shl` function shifts the bit pattern to the left by the specified number
    of bits.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`shl` 函数将位模式向左移动指定的位数。'
- en: 'Consider this example:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE43]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This is the output:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果：
- en: '[PRE44]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Here''s the explanation:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是解释：
- en: 5 = 101 (Binary format)
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 5 = 101（二进制格式）
- en: 101 Shift left by 0 bits = 101
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 101 左移 0 位 = 101
- en: 101 Shift left by 1 bits = 1010 (10 in Decimal)
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 101 左移 1 位 = 1010（十进制中的 10）
- en: 101 Shift left by 2 bits = 10100 (20 in Decimal)
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 101 左移 2 位 = 10100（十进制中的 20）
- en: shr
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: shr
- en: The `shr` function shifts the bit pattern to the right by the specified number
    of bits.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`shr` 函数将位模式向右移动指定的位数。'
- en: 'Take this example into consideration:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE45]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Given here is the output:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出结果：
- en: '[PRE46]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The following is the explanation:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是解释：
- en: 5 = 101 (Binary format)
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 5 = 101（二进制格式）
- en: 101 Shift right by 0 bits = 101
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 101 右移 0 位 = 101
- en: 101 Shift right by 1 bits = 010 (2 in Decimal)
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 101 右移 1 位 = 010（十进制中的 2）
- en: 101 Shift right by 2 bits = 001 (1 in Decimal)
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 101 右移 2 位 = 001（十进制中的 1）
- en: ushr
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ushr
- en: The `ushr` function shifts the bit pattern to the right by the specified number
    of bits, filling the leftmost with 0s.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`ushr` 函数将位模式向右移动指定的位数，用 0 填充最左边的位。'
- en: 'Here''s an example:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例：
- en: '[PRE47]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This will output the following:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE48]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This is its explanation:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它的解释：
- en: 5 = 101 (Binary format)
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 5 = 101（二进制格式）
- en: 101 Shift right by 0 bits = 101
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 101 右移 0 位 = 101
- en: 101 Shift right by 1 bits = 010 (2 in Decimal)
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 101 右移 1 位 = 010（十进制中的 2）
- en: 101 Shift right by 2 bits = 001 (1 in Decimal)
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 101 右移 2 位 = 001（十进制中的 1）
- en: How it works...
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The bitwise operators in Kotlin aren’t built-in operators like in Java, but
    they can still be used as an operator. Why? Look at its implementation:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 中的位运算符不是像 Java 中的内置运算符，但它们仍然可以用作运算符。为什么？看看它的实现：
- en: '[PRE49]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: You can see that the method has the `infix` notation, which enables it to be
    called as an `infix` expression.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到该方法具有 `infix` 表示法，这使得它可以作为 `infix` 表达式调用。
- en: Parsing String to Long, Double, or Int
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将字符串解析为 Long、Double 或 Int
- en: Kotlin makes it really easy to parse String into other data types, such as Long,
    Integer, or Double.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 使得将字符串解析为其他数据类型（如 Long、Integer 或 Double）变得非常容易。
- en: In JAVA, `Long.parseLong()`, or the `Long.valueOf()` static method is used,
    which parses the string argument as a signed decimal long and returns a long value,
    and similarly for other data types such as Int, Double, and Boolean. Let’s see
    how to achieve it in Kotlin.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JAVA 中，使用 `Long.parseLong()` 或 `Long.valueOf()` 静态方法，它将字符串参数解析为有符号的十进制长整型并返回一个长整型值，对于其他数据类型如
    Int、Double 和 Boolean 也是如此。让我们看看如何在 Kotlin 中实现它。
- en: Getting ready
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You just need a Kotlin editor to write and run your code. We’ll use conversion
    of Long as an example to discuss parsing with string. Conversion to other data
    types is quite similar.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 您只需要一个 Kotlin 编辑器来编写和运行您的代码。我们将使用长整型的转换作为示例来讨论使用字符串的解析。转换到其他数据类型相当类似。
- en: How to do it...
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: To parse the string to a Long data type, we use the `.toLong()` method with
    the string. It parses the string as a Long number and returns the result. It throws
    `NumberFormatException` if the string is not a valid representation of a number.
    Later, we will see examples for this.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 要将字符串解析为长整型数据类型，我们使用字符串的 `.toLong()` 方法。它将字符串解析为一个长整型数字并返回结果。如果字符串不是数字的有效表示，则会抛出
    `NumberFormatException`。稍后我们将看到这个示例的例子。
- en: Converting String to Long
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将字符串转换为 Long
- en: 'Here''s an example that shows parsing of string to Long:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例，展示了将字符串解析为长整型的过程：
- en: '[PRE50]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'When you run the preceding code, you will see this output:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行前面的代码时，您将看到以下输出：
- en: '[PRE51]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: If you don’t want to deal with the exceptions, you can use `.toLongOrNull()`.
    This method parses the string as a Long and returns the result, or null if the
    string is not a valid representation of a number.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想处理异常，可以使用 `.toLongOrNull()`。此方法将字符串解析为 Long 并返回结果，如果字符串不是数字的有效表示，则返回 null。
- en: Converting string to Long using string.toLongOrNull()
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 string.toLongOrNull() 将字符串转换为 Long
- en: 'In this example, we will see how we can parse a string using the `.toLongOrNull()`
    method:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看到如何使用 `.toLongOrNull()` 方法解析字符串：
- en: '[PRE52]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'On running the preceding program, the following output is generated:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的程序，将生成以下输出：
- en: '[PRE53]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Converting with special radix
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用特殊基数进行转换
- en: 'All the preceding examples use the base (radix) 10\. There are cases when we
    wish to convert a String to Long but using another base. Both `string.toLong()`
    and `string.toLongOrNull()` can receive a custom radix to be used in the conversion.
    Let''s take a look at its implementation:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前面示例都使用了基数（基数）10。有些情况下，我们希望将字符串转换为 Long，但使用另一个基数。`string.toLong()` 和 `string.toLongOrNull()`
    都可以接收一个自定义的基数用于转换。让我们看看它的实现：
- en: '`string.toLong(radix)`:'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string.toLong(radix)`:'
- en: This parses the string as a `[Long]` number and returns the result
  id: totrans-360
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这会将字符串解析为一个 `[Long]` 数字并返回结果
- en: '`@throws NumberFormatException` if the string is not a valid representation
    of a number'
  id: totrans-361
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果字符串不是数字的有效表示，则抛出 `NumberFormatException`
- en: '`@throws IllegalArgumentException` when `[radix]` is not a valid radix for
    string to number conversion'
  id: totrans-362
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 `[radix]` 不是字符串转换为数字的有效基数时，抛出 `IllegalArgumentException`
- en: '`string.toLongOrNull(radix)`:'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string.toLongOrNull(radix)`:'
- en: This parses the string as a `[Long]` number and returns the result or null if
    the string is not a valid representation of a number
  id: totrans-364
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这会将字符串解析为一个 `[Long]` 数字并返回结果，或者如果字符串不是数字的有效表示，则返回 null
- en: '`@throws IllegalArgumentException` when `[radix]` is not a valid radix for
    string to number conversion'
  id: totrans-365
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 `[radix]` 不是字符串转换为数字的有效基数时，抛出 `IllegalArgumentException`
- en: Parsing string to Long with special radix
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用特殊基数解析字符串到 Long
- en: In the preceding examples, we were parsing strings with radix 10, that is, decimals.
    By default, the radix is taken as 10, but there are certain situations where we
    need different radix. For example, in case of parsing a string into a binary or
    octal number. So now, we will see how to work with radix other than the decimal.
    Though you can use any valid radix, we will show examples that are most commonly
    used, such as binary and octal.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用基数 10 解析字符串，即十进制。默认情况下，基数取为 10，但在某些情况下我们需要不同的基数。例如，将字符串解析为二进制或八进制数字的情况。因此，现在我们将看到如何处理非十进制的基数。虽然您可以使用任何有效的基数，但我们将展示最常用的示例，如二进制和八进制。
- en: '**Binary**: Since a binary number is made from 0 and 1, the radix used is 2:'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**二进制**：由于二进制数由 0 和 1 组成，因此使用的基数是 2：'
- en: '[PRE54]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'On running the preceding program, the following output is generated:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的程序，将生成以下输出：
- en: '[PRE55]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '**Octal**: The octal numeral system, or oct for short, is the base-8 number
    system and uses the digits 0 to 7\. Hence, we will use 8 as a radix:'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**八进制**：八进制数制，简称八进制，是基数为 8 的数制，使用数字 0 到 7。因此，我们将使用 8 作为基数：'
- en: '[PRE56]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'On running the preceding program, this output is generated:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的程序，将生成以下输出：
- en: '[PRE57]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '**Decimal**: The decimal system has 10 numbers in it (0-9); hence, we will
    use 10 as radix. Note that radix as 10 is used by default in the methods without
    the radix arguments (`.toLong() , .toLongOrNull()`):'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**十进制**：十进制系统中有 10 个数字（0-9）；因此，我们将使用 10 作为基数。请注意，没有基数参数的方法（`.toLong() , .toLongOrNull()`）默认使用基数
    10：'
- en: '[PRE58]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'On running the preceding program, the following output is generated:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的程序，将生成以下输出：
- en: '[PRE59]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: How it works...
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Kotlin uses String’s extension functions such as `.toLong()` and `toLongOrNull()`
    to make things easier. Let’s dive into their implementation.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 使用如 `.toLong()` 和 `toLongOrNull()` 这样的字符串扩展函数来简化操作。让我们深入了解它们的实现。
- en: 'For `Long`, use this:'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `Long` 类型，使用此方法：
- en: '[PRE60]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As you can see, internally, it also calls the `Long.parseLong(string)` Java
    static method, and it is similar to the other data types.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它内部也调用了 `Long.parseLong(string)` Java 静态方法，并且与其他数据类型类似。
- en: 'For `Short`, it''s the following:'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `Short` 类型，它是以下内容：
- en: '[PRE61]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Use this for `Int`:'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用此方法进行 `Int` 解析：
- en: '[PRE62]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'For parsing with Radix, use the following:'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于使用基数进行解析，请使用以下方法：
- en: '[PRE63]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `checkRadix` method checks whether the given `[radix]` is valid radix for
    string to number and number to string conversion.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkRadix` 方法检查给定的 `[radix]` 是否是字符串到数字和数字到字符串转换的有效基数。'
- en: There's more...
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Let’s quickly see a few other extension functions provided by Kotlin to parse
    String:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速查看 Kotlin 提供的几个其他扩展函数，用于解析字符串：
- en: '`toBoolean()`: Returns `` `true` `` if the content of this string is equal
    to the word *true*, ignoring case, and `` `false` `` otherwise.'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toBoolean()`: 如果此字符串的内容等于单词 *true*（忽略大小写），则返回 `` `true` ``，否则返回 `` `false`
    ``。'
- en: '`toShort()`: Parses the string as a `[Short]` number and returns the result.
    Also, it throws `NumberFormatException` if the string is not a valid representation
    of a number.'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toShort()`: 将字符串解析为 `[Short]` 数字并返回结果。如果字符串不是数字的有效表示，则抛出 `NumberFormatException`。'
- en: '`toShort(radix)`: Parses the string as a `[Short]` number and returns the result,
    throws `NumberFormatException` if the string is not a valid representation of
    a number, and throws `IllegalArgumentException` when `[radix]` is not a valid
    radix for the string to number conversion.'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toShort(radix)`: 将字符串解析为 `[Short]` 数字并返回结果，如果字符串不是数字的有效表示，则抛出 `NumberFormatException`，如果
    `[radix]` 不是字符串到数字转换的有效基数，则抛出 `IllegalArgumentException`。'
- en: '`toInt()`: Parses the string as an `[Int]` number and returns the result and
    throws `NumberFormatException` if the string is not a valid representation of
    a number.'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toInt()`: 将字符串解析为 `[Int]` 数字并返回结果，如果字符串不是数字的有效表示，则抛出 `NumberFormatException`。'
- en: '`toIntOrNull()`: Parses the string as an `[Int]` number and returns the result
    or `` `null` `` if the string is not a valid representation of a number.'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toIntOrNull()`: 将字符串解析为 `[Int]` 数字并返回结果，如果字符串不是数字的有效表示，则返回 `` `null` ``。'
- en: '`toIntOrNull(radix)`: Parses the string as an `[Int]` number and returns the
    result or `` `null` `` if the string is not a valid representation of a number,
    or `@throws IllegalArgumentException` when `[radix]` is not a valid radix for
    string to number conversion.'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toIntOrNull(radix)`: 将字符串解析为 `[Int]` 数字并返回结果，如果字符串不是数字的有效表示，则返回 `` `null`
    ``，如果 `[radix]` 不是字符串到数字转换的有效基数，则抛出 `IllegalArgumentException`。'
- en: '`toFloat()`: Parses the string as a `[Float]` number and returns the result,
    and `@throws NumberFormatException` if the string is not a valid representation
    of a number.'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toFloat()`: 将字符串解析为 `[Float]` 数字并返回结果，如果字符串不是数字的有效表示，则抛出 `NumberFormatException`。'
- en: '`toDouble()` : Parses the string as a `[Double]` number and returns the result,
    and `@throws NumberFormatException` if the string is not a valid representation
    of a number.'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toDouble()` : 将字符串解析为 `[Double]` 数字并返回结果，如果字符串不是数字的有效表示，则抛出 `NumberFormatException`。'
- en: Using String templates in Kotlin
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Kotlin 中使用字符串模板
- en: Kotlin packs great features with commonly used data type String. One of the
    really cool features is String templates. This feature allows Strings to contain
    template expression.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 将许多常用数据类型字符串的强大功能打包在一起。其中一个非常酷的特性是字符串模板。此功能允许字符串包含模板表达式。
- en: 'In Java, you had to use **StrSubstitutor** ([https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/StrSubstitutor.html](https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/StrSubstitutor.html))
    and a map to go with it. A template expression in Java will look as follows:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，你必须使用 **StrSubstitutor** ([https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/StrSubstitutor.html](https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/StrSubstitutor.html))
    和相应的映射。Java 中的模板表达式将如下所示：
- en: '[PRE64]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Kotlin eases out the pain in writing template expressions and makes it fun,
    concise, and a lot less verbose.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 简化了编写模板表达式的痛苦，使其变得有趣、简洁，并且不那么冗长。
- en: Using String templates, you can embed a variable or expression inside a string
    without string concatenation. So, let’s get started!
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字符串模板，你可以在不进行字符串连接的情况下将变量或表达式嵌入到字符串中。所以，让我们开始吧！
- en: How to do it...
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In the following steps, we will learn how to use String templates:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们将学习如何使用字符串模板：
- en: In Kotlin, the template expression starts with a `$` sign.
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，模板表达式以 `$` 符号开始。
- en: 'The syntax of string templates is as follows:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字符串模板的语法如下：
- en: '[PRE65]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Alternatively, it is this:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，它也可以是这样的：
- en: '[PRE66]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Let''s check out a few examples:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看几个例子：
- en: 'Consider the example of a String template with variable:'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑一个带有变量的字符串模板的例子：
- en: '[PRE67]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The output of the preceding code will be `foo = 5`.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出将是`foo = 5`。
- en: 'Consider the example of a String template with expression:'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑一个带有表达式的字符串模板的例子：
- en: '[PRE68]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Consider the example of a String template with raw string:'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑一个带有原始字符串的字符串模板的例子：
- en: '**Raw string**: A string consisting of newlines without writing `\n` and arbitrary
    string. It''s a raw string and is placed in triple quotes (`"""`):'
  id: totrans-422
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原始字符串**：一个由换行符组成且没有使用 `\n` 的任意字符串。它是一个原始字符串，并放置在三个引号（`"""`）中：'
- en: '[PRE69]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'When you run the program, the output will be `Bigger number is: 6`.'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '当你运行程序时，输出将是`Bigger number is: 6`。'
- en: How it works...
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The use of String template with a variable name is quite straightforward. Earlier,
    we used to concatenate the strings, but now we can just specify the variable with
    the `$`  symbol before it.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 使用变量名称的字符串模板的使用相当简单。以前，我们通常使用字符串连接，但现在我们只需在变量前指定 `$` 符号即可。
- en: When the string template is used as an expression, the expression inside the
    `${..}` is evaluated first and the value is concatenated with the string. In the
    preceding example (String template with raw string), the `${if (a > b) a else
    b}` expression is evaluated and its value, that is 6, is printed with the string.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 当字符串模板用作表达式时，`${..}` 内的表达式首先被评估，然后将值与字符串连接。在先前的例子（带有原始字符串的字符串模板）中，`${if (a >
    b) a else b}` 表达式被评估，其值，即 6，与字符串一起打印。
- en: There’s more...
  id: totrans-428
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'String templates also come in handy with String properties and functions. Here''s
    an example:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串模板在字符串属性和函数中也很有用。以下是一个例子：
- en: '[PRE70]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Here''s the output:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出结果：
- en: '[PRE71]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
