- en: '*Chapter* 2: Understanding Test-Driven Development'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第二章*：理解测试驱动开发'
- en: Now that we have seen what unit tests are and how they can help in development,
    we are going to learn about **test-driven development** (**TDD**).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了单元测试是什么以及它们如何有助于开发，我们将学习**测试驱动开发**（**TDD**）。
- en: After giving you some insights into the origin and objective of TDD, we will
    move ahead and have a look at the benefits and drawbacks of it. By the end of
    the chapter, you will have a clear idea about the relevance of TDD and what should
    be or can be tested using it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在向您介绍TDD的起源和目标之后，我们将继续前进，看看它的利弊。到本章结束时，你将清楚地了解TDD的相关性以及可以使用它测试什么。
- en: 'These are the main topics that we will cover in the chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖的主要内容包括：
- en: The origin of TDD
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TDD的起源
- en: The TDD workflow
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TDD工作流程
- en: Advantages of TDD
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TDD的优势
- en: Disadvantages of TDD
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TDD的缺点
- en: What to test
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要测试什么
- en: The origin of TDD
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TDD的起源
- en: In 1996, Kent Beck, Ward Cunningham, and Ron Jeffries introduced a new software
    development methodology called **Extreme Programming** while they were working
    on the project *Comprehensive Compensation System* at Chrysler. The word *Extreme* indicates
    that the concepts behind Extreme Programming are totally different from the concepts
    used in software development back then. For many people, these concepts sound
    extreme even today.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 1996年，Kent Beck、Ward Cunningham和Ron Jeffries在克莱斯勒公司进行*综合薪酬系统*项目时，引入了一种新的软件开发方法论，称为**极限编程**。单词*极限*表明，极限编程背后的概念与当时软件开发的观念完全不同。对于许多人来说，这些概念即使在今天听起来也有些极端。
- en: The methodology is based on 12 rules or practices. One of the rules states that
    developers have to write unit tests and all parts of the software have to be thoroughly
    tested. All tests have to pass before the software (or a new feature) can be released
    to customers. The tests should be written before the production code that they
    test.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法论基于12条规则或实践。其中一条规则指出，开发者必须编写单元测试，并且软件的所有部分都必须经过彻底的测试。在软件（或新功能）可以发布给客户之前，所有测试都必须通过。测试应该在它们所测试的生产代码之前编写。
- en: This so-called test-first programming led to TDD. As the name suggests, in TDD,
    tests drive the development. This means that the developer writes code only because
    there is a test that fails. The tests dictate whether the code has to be written,
    and they also provide a measure when a feature is "done" – it is done when all
    tests for the feature pass.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这种所谓的“测试驱动编程”导致了TDD。正如其名所示，在TDD中，测试驱动开发。这意味着开发者只有在有失败的测试时才会编写代码。测试决定了代码是否需要编写，它们还提供了一个衡量标准，以确定一个功能是否“完成”——当所有该功能的测试都通过时，它就算完成了。
- en: This might sound silly to you if you haven't done any TDD before. You have to
    try and keep with it for some time to see the advantages and that it's not silly
    but rather quite clever. In TDD you always focus on one feature of the product
    you are building. And as you have tests for all the features you have built before,
    you don't have to keep the details of the rest of the code in mind. You can trust
    in the existing tests and that you won't break something that worked before.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前没有做过任何TDD，这可能会让你觉得有些荒谬。你必须尝试并坚持一段时间，以看到其优势，并认识到它并不荒谬，而是一种相当聪明的做法。在TDD中，你总是专注于你正在构建的产品的一个功能。由于你有所有之前构建的功能的测试，你不必记住其余代码的细节。你可以信任现有的测试，并且不会破坏之前已经工作的东西。
- en: Because of the focus on just one feature at a time, you will have a working
    piece of software almost all the time. So, when your boss enters your office and
    asks you for a demonstration of the current status of the project, you are only
    a few minutes away from a presentable (that is, compiled) and thoroughly tested
    piece of software.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每次只关注一个功能，你几乎总是会有一个可以工作的软件片段。所以，当你的老板走进你的办公室并要求你展示项目的当前状态时，你只需几分钟就能展示一个可展示的（即编译的）并且经过彻底测试的软件片段。
- en: Now that we know what TDD refers to, let's look into its workflow.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了TDD的含义，让我们来看看其工作流程。
- en: The TDD workflow – red, green, refactor
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TDD工作流程 – 红色、绿色、重构
- en: The normal workflow of TDD comprises three steps – *red*, *green*, *refactor*.
    The following sections describe these steps in detail.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: TDD的正常工作流程包括三个步骤 – *红色*、*绿色*、*重构*。以下各节将详细描述这些步骤。
- en: Red
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 红色
- en: 'You start by writing a failing test. It needs to test a required feature of
    the software product that is not already implemented or an edge case that you
    want to make sure is covered. The name red comes from the way most IDEs indicate
    a failing test. Xcode uses a red diamond with a white x on it as shown in the
    following figure:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你从编写一个失败的测试开始。它需要测试软件产品中尚未实现的功能或你想要确保覆盖的边缘情况。红色这个名字来源于大多数 IDE 指示失败测试的方式。Xcode
    使用带有白色 x 的红色菱形，如下图所示：
- en: '![Figure 2.1 – Xcode marks a failing test with a white cross in a red diamond'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.1 – Xcode 在红色菱形中用白色叉号标记失败测试'
- en: '](img/Figure_2.01_B18127.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.01_B18127.jpg)'
- en: Figure 2.1 – Xcode marks a failing test with a white cross in a red diamond
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – Xcode 在红色菱形中用白色叉号标记失败测试
- en: It is very important that the test you write in this step initially fails. Otherwise,
    you can't ensure that the test works and really tests the feature that you want
    to implement. It could be that you have written a test that always passes and
    is, therefore, useless. Or, it is possible that the feature is already implemented.
    Either way, you gain insight into your code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个步骤中编写的测试最初失败非常重要。否则，你无法确保测试正常工作并真正测试你想要实现的功能。可能你编写了一个总是通过且因此无用的测试。或者，可能该功能已经实现。无论如何，你都能对你的代码有更深入的了解。
- en: Green
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绿色
- en: In the green step, you write the simplest code that makes the test pass. It
    doesn't matter whether the code you write is good and clean. The code can also
    be silly and even wrong. It is enough when all the tests pass. The name green
    refers to how most IDEs indicate a passing test. Xcode uses a green diamond with
    a white checkmark.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在绿色步骤中，你编写最简单的代码以使测试通过。你编写的代码是否良好和整洁并不重要。代码也可以很愚蠢，甚至错误。只要所有测试都通过就足够了。绿色这个名字指的是大多数
    IDE 如何指示通过测试。Xcode 使用带有白色勾号的绿色菱形。
- en: '![Figure 2.2 – Xcode marks a passing test with a white checkmark in a green
    diamond'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.2 – Xcode 在绿色菱形中用白色勾号标记通过测试'
- en: '](img/Figure_2.02_B18127.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.02_B18127.jpg)'
- en: Figure 2.2 – Xcode marks a passing test with a white checkmark in a green diamond
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – Xcode 在绿色菱形中用白色勾号标记通过测试
- en: It is very important that you try to write the simplest code that makes the
    test pass. By doing so, you only write code that you actually need and that is
    the simplest implementation possible. When I say simple, I mean that it should
    be easy to read, understand, and change. Test code should always be easy to understand.
    Try to write your tests such that you understand them even when you haven't worked
    on them for months. When tests break, it's often while you are working on something
    completely different. A clear and easy-to-understand test helps you to find the
    problem quickly and get back to the context you were working on.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试编写最简单的代码以使测试通过非常重要。通过这样做，你只编写你真正需要的代码，这是可能的最简单实现。当我提到简单时，我的意思是它应该易于阅读、理解和修改。测试代码应该始终易于理解。尝试编写你的测试，即使你已经几个月没有工作过，你也能理解它们。当测试失败时，通常是在你做完全不同的事情时。清晰易懂的测试帮助你快速找到问题并回到你正在工作的上下文中。
- en: Often the simplest implementation will not be enough for the feature you're
    trying to implement, but still enough to make all the tests pass. This just means
    that you need another failing test to further drive the development of that feature.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，最简单的实现可能不足以实现你试图实现的功能，但仍然足以使所有测试通过。这仅仅意味着你需要另一个失败的测试来进一步推动该功能的开发。
- en: Refactor
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构
- en: During the green step, you write just enough code to make all the tests pass
    again. As I just mentioned, it doesn't matter what the code looks like in the
    green step. In the refactor step you improve the code. You remove duplication,
    extract common values, and so on. Do what is needed to make the code as good as
    possible. The tests help you to not break already implemented features while refactoring.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在绿色步骤中，你只需编写足够的代码再次使所有测试通过。正如我刚才提到的，绿色步骤中的代码看起来如何并不重要。在重构步骤中，你改进代码。你移除重复，提取公共值，等等。做你需要做的事情，使代码尽可能好。测试帮助你避免在重构过程中破坏已实现的功能。
- en: Important Note
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Don't skip this step. Always try to think about how you can improve the code
    after you have implemented a feature. Doing so helps to keep the code clean and
    maintainable. This ensures that it is always in good shape.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 不要跳过这个步骤。始终尝试思考在实现功能后如何改进代码。这样做有助于保持代码的整洁和可维护性。这确保了它始终保持良好的状态。
- en: As you have written only a few lines of code since the last refactor step, the
    changes needed to make the code clean shouldn't take much time.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于自上次重构步骤以来你只编写了几行代码，因此使代码变得整洁所需的变化不应花费太多时间。
- en: The advantages of TDD
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TDD 的优点
- en: 'TDD comes with advantages and disadvantages. These are the main advantages:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: TDD 具有优点和缺点。以下是主要优点：
- en: '**You only write code that is needed**: You should stop writing production
    code when all your tests pass and you can''t think of another test to write. If
    your project needs another feature, you need a test to drive the implementation
    of that feature. The code you write is the simplest code possible. So, all the
    code ending up in the product is actually needed to implement the features.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**只编写所需的代码**：当所有测试通过且你无法再想出另一个测试来编写时，你应该停止编写生产代码。如果你的项目需要另一个功能，你需要一个测试来驱动该功能的实现。你编写的代码是最简单的代码。因此，最终产品中的所有代码实际上都是实现功能所需的。'
- en: '**More modular design**: In TDD, you concentrate on one microfeature at a time.
    And as you write the test first, the code automatically becomes easy to test.
    Code that is easy to test has a clear interface. This results in a modular design
    for your app.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更模块化的设计**：在 TDD 中，你一次专注于一个微功能。由于你首先编写测试，代码自然会变得易于测试。易于测试的代码具有清晰的接口。这导致你的应用程序具有模块化设计。'
- en: '**Easier to maintain**: As the different parts of your app are decoupled from
    each other and have clear interfaces, the code becomes easier to maintain. You
    can exchange the implementation of a microfeature with a better implementation
    without affecting another module. You could even keep the tests and rewrite the
    complete app. When all the tests pass, you are done.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更容易维护**：由于你的应用程序的不同部分彼此解耦并且具有清晰的接口，代码变得更容易维护。你可以用更好的实现来替换微功能的实现，而不会影响另一个模块。你甚至可以保留测试并重写整个应用程序。当所有测试通过时，你就完成了。'
- en: '**Easier to refactor**: Every feature is thoroughly tested. You don''t need
    to be afraid to make drastic changes because if all the tests still pass, everything
    is fine. This point is very important because you, as a developer, improve your
    skills each and every day. If you open the project after 6 months of working on
    something else, most probably, you''ll have many ideas on how to improve the code.
    But your memory about all the different parts and how they fit together won''t
    be fresh anymore. So, making changes can be dangerous. With a complete test suite,
    you can easily improve the code without the fear of breaking your app.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更容易重构**：每个功能都经过彻底测试。你不必害怕做出重大改变，因为如果所有测试仍然通过，一切都会好。这一点非常重要，因为作为开发者，你每天都在提高自己的技能。如果你在六个月后重新打开项目，你很可能会有很多改进代码的想法。但你对所有不同部分以及它们如何组合的记忆可能已经不再新鲜。因此，做出改变可能是危险的。有了完整的测试套件，你可以轻松地改进代码，而不用担心破坏你的应用程序。'
- en: '**High test coverage**: There is a test for every feature. This results in
    high test coverage. High test coverage helps you gain confidence in your code.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高测试覆盖率**：每个功能都有一个测试。这导致高测试覆盖率。高测试覆盖率有助于你对自己的代码建立信心。'
- en: '**Tests document the code**: Test code shows how your code is meant to be used.
    As such, it documents your code. Test code is sample code that shows what the
    code does and how the interface has to be used.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试记录了代码**：测试代码显示了你的代码应该如何使用。因此，它记录了你的代码。测试代码是示例代码，显示了代码的功能以及接口应该如何使用。'
- en: '**Less debugging**: How often have you wasted a day finding a nasty bug? How
    often have you copied an error message from Xcode and searched for it on the internet?
    With TDD, you write fewer bugs because the tests tell you early on whether you''ve
    made a mistake. And the bugs you write are found much earlier. You can concentrate
    on fixing bugs when your memory is still fresh about what the code is supposed
    to do and how it does it.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更少的调试**：你有多少次浪费一整天来寻找一个讨厌的虫子？你有多少次从 Xcode 复制错误信息并在互联网上搜索它？在 TDD 中，你编写的错误更少，因为测试会尽早告诉你是否犯了错误。你编写的错误发现得也早。当你的记忆仍然清晰关于代码应该做什么以及它是如何做的时，你可以专注于修复错误。'
- en: In the next section, we'll discuss the disadvantages of TDD.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论 TDD 的缺点。
- en: The disadvantages of TDD
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TDD 的缺点
- en: 'Just like everything else in the world, TDD has some disadvantages. The main
    ones are listed here:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如世界上的一切事物一样，TDD 也有一些缺点。主要缺点如下：
- en: '**No silver bullet**: Tests help to find bugs, but they can''t find all bugs
    that you introduce in the test code and implementation code. If you haven''t understood
    the problem you need to solve, writing tests most probably won''t help.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**没有银弹**：测试有助于发现错误，但它们不能发现你在测试代码和实现代码中引入的所有错误。如果你没有理解你需要解决的问题，编写测试很可能会帮不上忙。'
- en: '**It seems slower at the beginning**: When you start TDD, you will get the
    feeling that it takes longer to make easy implementations. You need to think about
    the interfaces, write the test code, and run the tests before you can finally
    start writing the code.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一开始似乎更慢**：当你开始使用TDD时，你会感觉到实现简单的功能需要更长的时间。在最终开始编写代码之前，你需要思考接口、编写测试代码并运行测试。'
- en: '**All the members of a team need to do it**: As TDD influences the design of
    code, it is recommended that either all the members of a team use TDD or no one
    at all. In addition to this, it''s sometimes difficult to justify TDD to management
    because they often have the feeling that the implementation of new features takes
    longer if developers write code that won''t end up in the product half of the
    time. It helps if the whole team agrees on the importance of unit tests.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**团队中的所有成员都需要这样做**：由于TDD影响代码的设计，建议团队的所有成员都使用TDD，或者根本不使用。此外，有时很难向管理层证明TDD的合理性，因为他们常常有一种感觉，即如果开发者编写的代码有一半的时间不会最终进入产品，那么实现新功能会花费更长的时间。如果整个团队都同意单元测试的重要性，这会有所帮助。'
- en: '**Tests need to be maintained when requirements change**: Probably, the strongest
    argument against TDD is that the tests have to be maintained just as the code
    has to. Whenever requirements change, you need to change the code and tests. But
    you are working with TDD. This means that you need to change the tests first,
    and then make the tests pass. So, in reality, tests help you to understand the
    new requirements and implement the code without breaking other features.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当需求变化时，测试需要维护**：可能反对TDD的最有力的论据是，测试的维护工作就像代码的维护工作一样。每当需求发生变化时，你需要更改代码和测试。但是你正在使用TDD。这意味着你需要首先更改测试，然后让测试通过。所以，实际上，测试帮助你理解新的需求，并在不破坏其他功能的情况下实现代码。'
- en: Beginners often ask which part of their code they should write tests for. The
    following section tries to find an answer to that.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 初学者经常询问他们应该为代码的哪一部分编写测试。接下来的部分试图找到这个问题的答案。
- en: What to test
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要测试什么
- en: What should be tested? When using TDD and following its ideology, the answer
    is easy – everything. You only write production code because there is a failing
    test.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 应该测试什么？在使用TDD并遵循其理念时，答案很简单——一切。你只编写生产代码，因为有一个失败的测试。
- en: In practice, it's not that easy. For example, should the position and color
    of a button be tested? Should the view hierarchy be tested? Probably not; the
    color and exact position of the button is not important for the functioning of
    an app. In the early stages of development, these kinds of things tend to change.
    With Auto Layout, different screen sizes, and different localizations of apps,
    the exact position of buttons and labels depends on many parameters.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，这并不那么容易。例如，按钮的位置和颜色是否需要测试？视图层次结构是否需要测试？可能不需要；按钮的颜色和确切位置对于应用程序的功能并不重要。在开发的早期阶段，这类事情往往会发生变化。随着自动布局、不同的屏幕尺寸和应用程序的不同本地化，按钮和标签的确切位置取决于许多参数。
- en: In general, you should test the features that make the app useful for a user
    and those that need to work. Users don't care whether the button is exactly 20
    points from the rightmost edge of the screen. Users seek apps that are easy to
    understand and a joy to use.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你应该测试那些使应用程序对用户有用的功能和那些需要工作的功能。用户并不关心按钮是否正好位于屏幕最右侧边缘20点处。用户寻求的是易于理解且使用愉快的应用程序。
- en: In addition to this, you should not test the whole app at once using unit tests.
    Unit tests are meant to test small units of computation. They need to be fast
    and reliable. Things such as database access and networking should be tested using
    integration tests, where the tests drive the real finished app. Integration tests
    are allowed to be slow because they are run a lot less often than unit tests.
    Usually, they are run with the help of a continuous integration system each night
    on a server, where it doesn't matter that the complete test suite takes several
    minutes (or even hours) to execute.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个之外，你不应该一次性使用单元测试来测试整个应用。单元测试的目的是测试计算的小单元。它们需要快速且可靠。像数据库访问和网络这样的东西应该使用集成测试来测试，在集成测试中，测试驱动着真正的完成应用。集成测试可以允许运行得慢，因为它们比单元测试运行得少得多。通常，它们会在服务器上每晚通过持续集成系统运行，而完整的测试套件需要几分钟（甚至几个小时）来执行并不重要。
- en: Summary
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we dipped our toes into the new waters of TDD in general. The
    chapter showed the workflow of TDD – red, green, refactor – which we will use
    throughout this book to build an app. In addition, we have seen what the advantages
    and the disadvantages of TDD are.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们初步涉入了TDD的新领域。本章展示了TDD的工作流程——红、绿、重构——我们将在这本书中用它来构建应用。此外，我们还看到了TDD的优点和缺点。
- en: In the following chapter, we will explore how TDD works in Xcode, the tool most
    of us use to build iOS apps.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨在Xcode中如何进行TDD，这是我们大多数人用来构建iOS应用的工具。
