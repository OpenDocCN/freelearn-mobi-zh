- en: '*Chapter 1*: Your First Unit Tests'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第一章*：你的第一个单元测试'
- en: When the iPhone platform was first introduced, applications were small and focused
    only on one feature. It was easy to make money with an app that only did one thing
    (for example, a flashlight app that only showed a white screen). The code of these
    early apps only had a few hundred lines and could easily be tested by tapping
    the screen for a few minutes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当iPhone平台首次推出时，应用程序很小，只关注一个功能。制作一个只做一件事的应用程序（例如，只显示白色屏幕的手电筒应用程序）很容易赚钱。这些早期应用程序的代码只有几百行，可以通过在屏幕上轻敲几分钟轻松测试。
- en: Since then, the App Store and the available apps have changed a lot. There are
    still small apps with a clear focus in the App Store, but it's much harder to
    make money from them. A common app has many features but still needs to be easy
    to use. There are companies with several developers working on one app full-time.
    These apps sometimes have a feature set that is normally found in desktop applications.
    It is very difficult and time-consuming to test all the features in such apps
    manually for every update.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从那时起，App Store和可用的应用程序已经发生了很大变化。App Store中仍然有一些专注于明确功能的较小应用程序，但从中赚钱变得困难得多。一个常见的应用程序具有许多功能，但仍需要易于使用。有一些公司有多个开发者全职工作在一个应用程序上。这些应用程序有时具有通常在桌面应用程序中找到的功能集。手动测试这些应用程序的所有功能非常困难且耗时。对于每次更新，都需要手动测试所有功能。
- en: One reason for this is that manual testing needs to be done through a **user
    interface** (**UI**), and it takes time to load the app to be tested. In addition
    to this, human beings are very slow compared to the capabilities of computers
    for tasks such as testing and verifying computer programs. Most of the time, a
    computer (or a smartphone) waits for the user's next input. If we could let a
    computer insert values, testing could be drastically accelerated. In fact, a computer
    can run several hundred tests within a few seconds. This is exactly what unit
    tests are all about.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这其中的一个原因是手动测试需要通过**用户界面**（**UI**）进行，加载要测试的应用程序需要时间。除此之外，与计算机在测试和验证计算机程序等任务上的能力相比，人类非常慢。大多数时候，计算机（或智能手机）都在等待用户的下一个输入。如果我们能让计算机插入值，测试可以大大加速。事实上，计算机可以在几秒钟内运行几百次测试。这正是单元测试的全部内容。
- en: A unit test is a piece of code that executes some other code and checks whether
    the result is what the developer expected. The word "unit" means that the test
    executes a small unit of code. Usually, that is one function of a class or some
    similar type of structure. How big the unit actually is depends on the feature
    to be tested and on the person who is writing the test.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是一段执行其他代码并检查结果是否符合开发者预期的代码。单词“单元”意味着测试执行一小块代码。通常，那是一个类的一个函数或类似类型的结构。单元实际上有多大取决于要测试的功能和编写测试的人。
- en: Writing unit tests seems hard at first because for most developers, it's a new
    concept. This chapter is aimed at helping you get started with writing your first
    simple unit tests.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 起初编写单元测试似乎很难，因为对大多数开发者来说，这是一个新的概念。本章旨在帮助你开始编写你的第一个简单的单元测试。
- en: 'These are the main topics we will cover in the chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖的主要主题包括：
- en: Building your first automatic unit test
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建你的第一个自动单元测试
- en: Assert functions in the `XCTest` framework
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XCTest`框架中的断言函数'
- en: Understanding the difference from other kinds of tests
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解与其他测试类型的区别
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'All the code in this chapter is uploaded (in complete form) here:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有的代码都已上传（完整形式）在此：
- en: '[https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter01](https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter01)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter01](https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter01)'
- en: Building your first automatic unit test
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建你的第一个自动单元测试
- en: If you have done some iOS development (or application development in general)
    already, the following example might seem familiar to you.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经进行了一些iOS开发（或一般的应用程序开发），以下示例可能对你来说很熟悉。
- en: You are planning to build an app. You start collecting features, drawing some
    sketches, or your project manager hands the requirements to you. At some point,
    you start coding. You set up the project and start implementing the required features
    of the app.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在计划构建一个应用程序。你开始收集功能，绘制一些草图，或者你的项目经理将需求交给你。在某个时候，你开始编码。你设置项目并开始实现应用程序所需的功能。
- en: Let's say the app has an input form, and the values the user puts in have to
    be validated before the data can be sent to the server. The validation checks,
    for example, whether the email address and the phone number have a valid format.
    After implementing the form, you want to check whether everything works. But before
    you can test it manually, you need to write code that presents the form on the
    screen. Then, you build and run your app in the iOS simulator. The form is somewhere
    deep in the view hierarchy, so you navigate to the view and put the values into
    the form. It doesn't work—something is wrong with the phone number validation
    code. You go back to the code and try to fix the problem. Sometimes, this also
    means starting the debugger and stepping through the code to find the bug.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 假设该应用有一个输入表单，用户输入的值在数据发送到服务器之前必须经过验证。验证检查，例如，电子邮件地址和电话号码是否有有效的格式。在实现表单后，你想要检查一切是否正常工作。但在你可以手动测试之前，你需要编写代码在屏幕上显示表单。然后，你在iOS模拟器中构建并运行你的应用。表单在视图层次结构的深处，所以你导航到视图并将值放入表单。它不起作用——电话号码验证代码有问题。你回到代码中并尝试修复问题。有时，这也意味着启动调试器并逐步通过代码来找到错误。
- en: Eventually, the validation works for the test data you put in. Normally, you
    would need to test for all possible values to make sure that the validation not
    only works for your name and your data, but also for all valid data. But there
    is this long list of requirements on your desk, and you are already running late.
    The navigation to the form takes three taps in the simulator and putting in all
    the different values just takes too long. You are a coder, after all.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，验证将适用于你放入的测试数据。通常，你需要测试所有可能的值以确保验证不仅适用于你的姓名和你的数据，而且适用于所有有效数据。但是，你桌上有这么长的需求列表，而你已经开始晚了。在模拟器中导航到表单需要三次点击，输入所有不同的值需要太长时间。毕竟，你是一名程序员。
- en: If only a robot could perform this testing for you.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个机器人能为你进行这项测试就好了。
- en: What are unit tests?
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试是什么？
- en: Automatic unit tests act like this robot for you. They execute code, but without
    having to navigate to the screen with the feature to test. Instead of running
    the app over and over again, you write tests with different input data and let
    the computer test your code in the blink of an eye. Let's see how this works in
    a simple example.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 自动单元测试就像这个机器人为你做的那样。它们执行代码，但不需要导航到要测试的功能屏幕。而不是一次又一次地运行应用，你用不同的输入数据编写测试，让计算机在眨眼间测试你的代码。让我们看看在简单示例中它是如何工作的。
- en: Implementing a unit test example
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现单元测试示例
- en: 'In this example, we write a simple function that counts the number of vowels
    in a string. Proceed as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们编写了一个简单的函数，用于计算字符串中的元音数量。按照以下步骤进行：
- en: Open Xcode and go to **File** | **New** | **Project**.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Xcode并转到**文件** | **新建** | **项目**。
- en: Navigate to **iOS** | **Application** | **App** and click on **Next**.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**iOS** | **应用程序** | **App**并点击**下一步**。
- en: Put in the name `FirstDemo`, select `Storyboard` for the `Swift` for the **Language**
    field, and check **Include Tests**.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入名称`FirstDemo`，选择**语言**字段中的`Swift`，并勾选**包含测试**。
- en: 'Uncheck **Use Core Data** and click on **Next**. The following screenshot shows
    the options in Xcode:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消选择**使用Core Data**并点击**下一步**。以下截图显示了Xcode中的选项：
- en: '![Figure 1.1 – Setting up your new project'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.1 – 设置你的新项目'
- en: '](img/Figure_1.01_B18127.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.01_B18127.jpg)'
- en: Figure 1.1 – Setting up your new project
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – 设置你的新项目
- en: Xcode sets up a project ready for development, in addition to two test targets
    for your unit and your UI tests.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode设置了一个用于开发的项目，此外还为你设置了两个单元测试和UI测试的目标。
- en: 'Open the `FirstDemoTests` folder in the project navigator. Within the folder,
    there is one file: `FirstDemoTests.swift`.'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目导航器中打开`FirstDemoTests`文件夹。在文件夹内，有一个文件：`FirstDemoTests.swift`。
- en: Select `FirstDemoTests.swift` to open it in the editor.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`FirstDemoTests.swift`以在编辑器中打开它。
- en: What you see here is a test case. A test case is a class comprising several
    tests. In the beginning, it's a good practice to have one test case for each class
    in the main target.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里看到的是一个测试用例。测试用例是一个包含几个测试的类。一开始，为每个主要目标类创建一个测试用例是一个好习惯。
- en: 'Let''s go through this file step by step, as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地查看这个文件，如下所示：
- en: 'The file starts with the import of the test framework and the main target,
    as illustrated here:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 文件从导入测试框架和主要目标开始，如下所示：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Every test case needs to import the `XCTest` framework. It defines the `XCTestCase`
    class and the test assertions that you will see later in this chapter.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试用例都需要导入`XCTest`框架。它定义了`XCTestCase`类以及你将在本章后面看到的测试断言。
- en: The second line imports the `FirstDemo` module. All the code you write for the
    demo app will be in this module. By default, classes, structs, enums, and their
    methods are defined with internal access control. This means that they can be
    accessed only from within the module. But the test code lives outside of the module.
    To be able to write tests for your code, you need to import the module with the
    `@testable` keyword. This keyword makes the internal elements of the module accessible
    in the test case.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行导入了`FirstDemo`模块。你为演示应用编写的所有代码都将在这个模块中。默认情况下，类、结构体、枚举及其方法使用内部访问控制定义。这意味着它们只能从模块内部访问。但是测试代码存在于模块之外。为了能够编写测试代码，你需要使用`@testable`关键字导入模块。这个关键字使得模块的内部元素在测试用例中可访问。
- en: 'Next, we''ll take a look at the class declaration, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看类声明，如下所示：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Nothing special here. This defines the `FirstDemoTests` class as a subclass
    of `XCTestCase`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有特别之处。这定义了`FirstDemoTests`类为`XCTestCase`的子类。
- en: 'The first two methods in the class are shown in the following code snippet:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 类中的前两种方法在以下代码片段中显示：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `setUpWithError()` method is called before the invocation of each test method
    in the class. Here, you can insert the code that should run before each test.
    You will see an example of this later in this chapter.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`setUpWithError()`方法在类中每个测试方法调用之前被调用。在这里，你可以插入应该在每次测试之前运行的代码。你将在本章后面的例子中看到这个例子。'
- en: The opposite of `setUpWithError()` is `tearDownWithError()`. This method is
    called after the invocation of each test method in the class. If you need to clean
    up after your tests, put the necessary code in this method.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`setUpWithError()`的对立面是`tearDownWithError()`。这个方法在类中每个测试方法调用之后被调用。如果你需要在测试后进行清理，请将必要的代码放在这个方法中。'
- en: 'The next two methods are template tests provided by the template authors at
    Apple:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的两个方法是苹果模板作者提供的模板测试：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first method is a normal unit test. You will use this kind of test a lot
    in the course of this book.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是常规单元测试。在这本书的过程中，你将大量使用这种测试。
- en: The second method is a performance test. It is used to test methods or functions
    that perform time-critical computations. The code you put into the measure closure
    is called 10 times, and the average duration is measured. Performance tests can
    be useful when implementing or improving complex algorithms and to make sure that
    their performance does not decline. We will not use performance tests in this
    book.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是性能测试。它用于测试执行时间关键计算的方法或函数。你放入度量闭包中的代码被调用10次，并测量平均持续时间。性能测试在实现或改进复杂算法时非常有用，并确保它们的性能不会下降。我们在这本书中不会使用性能测试。
- en: All the test methods that you write have to have the `test` prefix; otherwise,
    the test runner can't find and run them. This behavior allows easy disabling of
    tests—just remove the `test` prefix of the method name. Later, you will take a
    look at other possibilities to disable some tests without renaming or removing
    them.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你编写的所有测试方法都必须有`test`前缀；否则，测试运行器找不到并运行它们。这种行为允许轻松禁用测试——只需移除方法名称中的`test`前缀。稍后，你将了解其他在不重命名或删除的情况下禁用一些测试的可能性。
- en: 'Now, let''s implement our first test. Let''s assume that you have a method
    that counts the vowels of a string. A possible implementation looks like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现我们的第一个测试。假设你有一个计算字符串中元音的方法。一个可能的实现如下：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: I guess this code makes you feel uncomfortable. Please keep calm. Don't throw
    this book into the corner—we will make this code more "swifty" soon. Add this
    method to the `ViewController` class in `ViewController.swift`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我猜这段代码让你感到不舒服。请保持冷静。不要把这本书扔到角落里——我们很快就会让这段代码变得更加“Swift式”。将此方法添加到`ViewController`类中的`ViewController.swift`。
- en: 'This method does the following things:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法执行以下操作：
- en: First, an array of characters is defined containing all the vowels in the English
    alphabet.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，定义了一个包含英语字母表中所有元音的字符数组。
- en: Next, we define a variable to store the number of vowels. The counting is done
    by looping over the characters of the string. If the current character is contained
    in the `vowels` array, `numberOfVowels` is increased by one.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个变量来存储元音的数量。计数是通过遍历字符串中的字符来完成的。如果当前字符包含在`vowels`数组中，`numberOfVowels`就增加一。
- en: Finally, `numberOfVowels` is returned.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，返回`numberOfVowels`。
- en: 'Open `FirstDemoTests.swift` and delete the methods with the `test` prefix.
    Then, add the following method:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `FirstDemoTests.swift` 并删除带有 `test` 前缀的方法。然后，添加以下方法：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This test creates an instance of `ViewController` and assigns it to the `viewController`
    constant. It calls the function that we want to test and assigns the result to
    a constant. Finally, the code in the test method calls the `XCTAssertEqual(_:,
    _:)` function to check whether the result is what we expected. If the two first
    parameters in `XCTAssertEqual` are equal, the test passes; otherwise, it fails.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试创建了一个 `ViewController` 实例并将其分配给 `viewController` 常量。它调用我们想要测试的函数并将结果分配给一个常量。最后，测试方法中的代码调用
    `XCTAssertEqual(_:, _:)` 函数来检查结果是否是我们预期的。如果 `XCTAssertEqual` 中的前两个参数相等，则测试通过；否则，它失败。
- en: 'To run the tests, select a simulator of your choice and go to **Product** |
    **Test**, or use the *![](img/Symbol_01.png)U* shortcut. Xcode compiles the project
    and runs the test. You will see something similar to this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行测试，选择您选择的模拟器，然后转到**产品** | **测试**，或使用 *![](img/Symbol_01.png)U* 快捷键。Xcode
    编译项目并运行测试。您将看到类似以下内容：
- en: '![Figure 1.2 – Xcode shows a green diamond with a checkmark when a test passes'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.2 – Xcode 在测试通过时显示带有勾选标记的绿色菱形'
- en: '](img/Figure_1.02_B18127.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 1.02 - B18127](img/Figure_1.02_B18127.jpg)'
- en: Figure 1.2 – Xcode shows a green diamond with a checkmark when a test passes
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – Xcode 在测试通过时显示带有勾选标记的绿色菱形
- en: The green diamond with a checkmark on the left-hand side of the editor indicates
    that the test passed. So, that's it—your first unit test. Step back for a moment
    and celebrate. This could be the beginning of a new development paradigm for you.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑器左侧的带有勾选标记的绿色菱形表示测试通过。所以，这就完成了——你的第一个单元测试。退后一步，庆祝一下。这可能对你来说是一个新的开发范式的开始。
- en: 'Now that we have a fast test that proves that the `numberOfVowels(in:)` method
    does what we intended, we are going to improve the implementation. The method
    looks like it has been translated from `ViewController.swift`, and replace the
    `numberOfVowels(in:)` method with this more "swifty" implementation:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个快速的测试，证明了 `numberOfVowels(in:)` 方法确实做了我们想要的事情，我们将改进实现。这个方法看起来像是被从 `ViewController.swift`
    转换过来的，并用这个更“Swift式”的实现替换了 `numberOfVowels(in:)` 方法：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we make use of the `reduce` function, which is defined on the array type.
    The `reduce` function combines all the elements of a sequence into one value using
    the provided closure. `$0` and `$1` are anonymous shorthand arguments representing
    the current value of the combination and the next item in the sequence. Run the
    tests again (*![](img/Symbol_01.png)U*) to make sure that this implementation
    works the same as the one earlier.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了定义在数组类型上的 `reduce` 函数。`reduce` 函数使用提供的闭包将序列的所有元素组合成一个值。`$0` 和 `$1`
    是代表组合的当前值和序列中的下一个项目的匿名简写参数。再次运行测试 (*![](img/Symbol_01.png)U*) 以确保这个实现与之前的实现工作相同。
- en: Disabling slow UI tests
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 禁用缓慢的 UI 测试
- en: 'You might have realized that Xcode also runs the UI test in the `FirstDemoUITests`
    target. UI tests are painfully slow. We don''t want to run those tests every time
    we type the *![](img/Symbol_01.png)U* shortcut. To disable the UI tests, proceed
    as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经意识到 Xcode 也会在 `FirstDemoUITests` 目标中运行 UI 测试。UI 测试非常慢。我们不希望在每次输入 *![](img/Symbol_01.png)U*
    快捷键时都运行这些测试。要禁用 UI 测试，请按照以下步骤操作：
- en: 'Open the scheme selection and click on **Edit Scheme…**, as shown in the following
    screenshot:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开方案选择并点击**编辑方案…**，如下截图所示：
- en: '![Figure 1.3 – Selecting the target selector to open the scheme editor'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.3 – 选择目标选择器以打开方案编辑器'
- en: '](img/Figure_1.03_B18127.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 1.03 - B18127](img/Figure_1.03_B18127.jpg)'
- en: Figure 1.3 – Selecting the target selector to open the scheme editor
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.3 – 选择目标选择器以打开方案编辑器'
- en: 'Xcode opens the scheme editor. Select the `FirstDemoUITests` target, as shown
    in the following screenshot:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Xcode 打开方案编辑器。选择 `FirstDemoUITests` 目标，如下截图所示：
- en: '![Figure 1.4 – Deselecting the UI test target'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.4 – 取消选择 UI 测试目标'
- en: '](img/Figure_1.04_B18127.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 1.04 - B18127](img/Figure_1.04_B18127.jpg)'
- en: Figure 1.4 – Deselecting the UI test target
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.4 – 取消选择 UI 测试目标'
- en: This disables the UI tests for this scheme, and running tests becomes fast.
    Check yourself and run the tests using the *![](img/Symbol_01.png)U* shortcut.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这将禁用此方案的 UI 测试，运行测试变得快速。检查自己并使用 *![](img/Symbol_01.png)U* 快捷键运行测试。
- en: Before we move on, let's recap what we have seen so far. First, you learned
    that you could easily write code that tests your code. Secondly, you saw that
    a test helped improve the code because now, you don't have to worry about breaking
    the feature when changing the implementation.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们回顾一下到目前为止我们所看到的内容。首先，你了解到你可以轻松编写测试代码来测试你的代码。其次，你看到测试有助于改进代码，因为现在，你不必担心在更改实现时破坏功能。
- en: To check whether the result of the method is as we expected, we used `XCTAssertEqual(_:,
    _:)`. This is one of many `XCTAssert` functions that are defined in the XCTest
    framework. The next section shows the most important ones.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查方法的结果是否符合我们的预期，我们使用了`XCTAssertEqual(_:, _:)`。这是在XCTest框架中定义的许多`XCTAssert`函数之一。下一节将展示最重要的几个。
- en: Assert functions in the XCTest framework
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XCTest框架中的断言函数
- en: Each test needs to assert some expected behavior. The use of `XCTAssert` functions
    tells Xcode what is expected.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试都需要断言一些预期的行为。使用`XCTAssert`函数告诉Xcode预期的内容。
- en: A test method without an `XCTAssert` function that doesn't throw an error will
    always pass.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一个没有`XCTAssert`函数且不抛出错误的测试方法将始终通过。
- en: 'The most important assert functions are listed here:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的断言函数列在这里：
- en: '`XCTAssertTrue(_:_:file:line:)`: This asserts that an expression is true.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XCTAssertTrue(_:_:file:line:)`: 这条断言表示一个表达式是真的。'
- en: '`XCTAssert(_:_:file:line:)`: This assertion is the same as `XCTAssertTrue(_:_:file:line:)`.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XCTAssert(_:_:file:line:)`: 这条断言与`XCTAssertTrue(_:_:file:line:)`相同。'
- en: '`XCTAssertFalse(_:_:file:line:)`: This asserts that an expression is false.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XCTAssertFalse(_:_:file:line:)`: 这条断言表示一个表达式是假的。'
- en: '`XCTAssertEqual(_:_:_:file:line:)`: This asserts that two expressions are equal.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XCTAssertEqual(_:_:_:file:line:)`: 这条断言表示两个表达式相等。'
- en: '`XCTAssertEqual(_:_:accuracy:_:file:line:)`: This asserts that two expressions
    are the same, taking into account the accuracy defined in the `accuracy` parameter.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XCTAssertEqual(_:_:accuracy:_:file:line:)`: 这条断言表示两个表达式相同，考虑到`accuracy`参数中定义的精度。'
- en: '`XCTAssertNotEqual(_:_:_:file:line:)`: This asserts that two expressions are
    not equal.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XCTAssertNotEqual(_:_:_:file:line:)`: 这条断言表示两个表达式不相等。'
- en: '`XCTAssertNotEqual(_:_:accuracy:_:file:line:)`: This asserts that two expressions
    are not the same, taking into account the accuracy defined in the `accuracy` parameter.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XCTAssertNotEqual(_:_:accuracy:_:file:line:)`: 这条断言表示两个表达式不相同，考虑到`accuracy`参数中定义的精度。'
- en: '`XCTAssertNil(_:_:file:line:)`: This asserts that an expression is nil.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XCTAssertNil(_:_:file:line:)`: 这条断言表示一个表达式是nil。'
- en: '`XCTAssertNotNil(_:_:file:line:)`: This asserts that an expression is not nil.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XCTAssertNotNil(_:_:file:line:)`: 这条断言表示一个表达式不是nil。'
- en: '`XCTFail(_:file:line:)`: This always fails.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XCTFail(_:file:line:)`: 这条断言总是失败。'
- en: 'To take a look at a full list of the available `XCTAssert` functions, press
    *Ctrl* and click on the `XCTAssertEqual` word in the test that you have just written.
    Then, select **Jump to Definition** in the pop-up menu, as shown in the following
    screenshot:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看可用的`XCTAssert`函数的完整列表，请按*Ctrl*并点击您刚刚编写的测试中的`XCTAssertEqual`单词。然后，在弹出菜单中选择**跳转到定义**，如图下所示：
- en: '![Figure 1.5 – Jump to Definition of a selected function'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.5 – 跳转到所选函数的定义'
- en: '](img/Figure_1.05_B18127.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.05_B18127.jpg)'
- en: Figure 1.5 – Jump to Definition of a selected function
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 – 跳转到所选函数的定义
- en: 'Note that most `XCTAssert` functions can be replaced with `XCTAssert(_:_:file:line)`.
    For example, the following assert functions are asserting the same thing:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，大多数`XCTAssert`函数都可以用`XCTAssert(_:_:file:line)`替换。例如，以下断言函数断言的是同一件事情：
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'But you should use more precise assertions whenever possible, as the log output
    of the more precise assertion methods tells you exactly what happened in case
    of a failure. For example, look at the log output of the following two assertions:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 但你应该尽可能使用更精确的断言，因为更精确的断言方法的日志输出会告诉你失败时确切发生了什么。例如，看看以下两个断言的日志输出：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the first case, you don't need to look at the test to understand what happened.
    The log tells you exactly what went wrong.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，你不需要查看测试就能理解发生了什么。日志会告诉你确切出了什么问题。
- en: Custom assert functions
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义断言函数
- en: 'But sometimes, even the more precise assert function is not precise enough.
    In this case, you can write your own assert functions. As an example, let''s assume
    we have a test that asserts that two dictionaries have the same content. If we
    used `XCTAssertEqual` to test that, the log output would look like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时，即使是更精确的断言函数也可能不够精确。在这种情况下，你可以编写自己的断言函数。例如，假设我们有一个断言两个字典具有相同内容的测试。如果我们使用
    `XCTAssertEqual` 来测试，日志输出将如下所示：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For the short dictionaries in this example, finding the difference is quite
    easy. But what if the dictionary has 20 entries or even more? When we add the
    following assert function to the test target, we get better log outputs:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本例中的短字典，找到差异相当容易。但如果字典有 20 个条目甚至更多呢？当我们向测试目标添加以下断言函数时，我们得到更好的日志输出：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This method compares the values for each key and fails if one of the values
    differs. Additionally, this assert function should check whether the dictionaries
    have the same keys. This functionality is left as an exercise for the reader.
    Here, we focus this example on how to write a custom assert function. By keeping
    the example short, the main point is easier to understand.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法比较每个键的值，如果其中一个值不同则失败。此外，此断言函数还应检查字典是否具有相同的键。此功能留给读者作为练习。在这里，我们专注于如何编写自定义断言函数。通过保持示例简短，主要观点更容易理解。
- en: 'When we run this test with the preceding dictionaries, we see the following
    output in Xcode:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用前面的字典运行此测试时，我们在 Xcode 中看到以下输出：
- en: '![Figure 1.6 – Xcode showing the failure at two different places'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.6 – Xcode 显示两个不同位置的失败'
- en: '](img/Figure_1.06_B18127.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.06_B18127.jpg)'
- en: Figure 1.6 – Xcode showing the failure at two different places
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6 – Xcode 显示两个不同位置的失败
- en: 'As you can see in the preceding screenshot, Xcode shows the test failure in
    the assert function. In the test method, it only shows a redirect to the failure.
    Fortunately, there is an easy fix for that. All we have to do is to pass `file`
    and `line` parameters to the custom assert function and use these in the `XCTFail`
    call, like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图所示，Xcode 在断言函数中显示测试失败。在测试方法中，它只显示对失败的引用。幸运的是，有一个简单的解决方案。我们只需要将 `file`
    和 `line` 参数传递给自定义断言函数，并在 `XCTFail` 调用中使用这些参数，如下所示：
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Note that our assert function now has two new parameters: `file` and `line`,
    with the default values `#filePath` and `#line`, respectively. When the function
    is called in a test method, these default parameters make sure that the file path
    and the line of the call site are passed into that assert function. These parameters
    are then forwarded into the `XCTAssert` functions (`XCTFail` in our case, but
    this works with all XCT... functions). As a result, the failure is now shown in
    the line in which the `DDHAssertEqual` function is called, and we didn''t have
    to change the call of the assert function. The following screenshot illustrates
    this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的断言函数现在有两个新的参数：`file` 和 `line`，分别具有默认值 `#filePath` 和 `#line`。当在测试方法中调用该函数时，这些默认参数确保将调用点的文件路径和行传递给该断言函数。然后，这些参数被转发到
    `XCTAssert` 函数（在我们的情况下是 `XCTFail`，但这适用于所有 XCT... 函数）。因此，失败现在显示在调用 `DDHAssertEqual`
    函数的行中，我们不需要更改断言函数的调用。以下截图说明了这一点：
- en: '![](img/Figure_1.07_B18127.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_1.07_B18127.jpg)'
- en: Figure 1.7 – Improved failure reporting
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7 – 改进的失败报告
- en: This example shows how easy it is to write your own assert functions that behave
    like the ones that come with Xcode. Custom assert functions can improve the readability
    of the test code, but keep in mind that this is also code you have to maintain.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 本例展示了编写自己的断言函数，使其行为类似于 Xcode 中的函数是多么容易。自定义断言函数可以提高测试代码的可读性，但请记住，这也是你必须维护的代码。
- en: Understanding the difference from other kinds of tests
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解与其他类型测试的区别
- en: Unit tests are just one piece of a good test suite. In my opinion, they are
    the most important tests because when carried out correctly, they are fast, focused,
    and easy to understand. But to increase your confidence in your code, you should
    additionally add integration, UI/snapshot, and manual tests. What are those?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是良好测试套件的一部分。在我看来，它们是最重要的测试，因为当正确执行时，它们是快速、专注且易于理解的。但为了增加你对代码的信心，你还应该添加集成、UI/快照和手动测试。那些是什么？
- en: Integration tests
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成测试
- en: In integration tests, the feature that is being tested is not isolated from
    the rest of the code. With these kinds of tests, the developer tries to figure
    out if the different units (that are thoroughly tested with unit tests) interact
    with each other as required. As a result, integration tests execute real database
    queries and fetch data from live servers, which makes them significantly slower
    than unit tests. They are not run as often as unit tests and failures are more
    difficult to understand as the error has to be tracked down in all involved code
    units.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在集成测试中，正在测试的功能没有从其余代码中隔离出来。使用这些类型的测试，开发者试图弄清楚不同的单元（这些单元已经通过单元测试彻底测试）是否按要求相互交互。因此，集成测试执行真实的数据库查询并从实时服务器获取数据，这使得它们比单元测试慢得多。它们不像单元测试那样经常运行，并且失败更难以理解，因为错误必须在所有涉及的代码单元中追踪。
- en: UI tests
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UI测试
- en: As the name suggests, UI tests run on the UI of an app. A computer program (the
    test runner) executes the app as a user would do. Usually, this means that in
    such a test assertion, we also have to use information accessible on screen. This
    means a UI test can only test whether a feature works as required when the result
    is visible on screen. In addition, these tests are usually quite slow as the test
    runner often has to wait until animations and screen updates are finished.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，UI测试在应用的UI上运行。一个计算机程序（测试运行器）以用户的方式执行应用。通常，这意味着在这种测试断言中，我们也必须使用屏幕上可访问的信息。这意味着UI测试只能测试当结果在屏幕上可见时，功能是否按预期工作。此外，这些测试通常相当慢，因为测试运行器通常必须等待动画和屏幕更新完成。
- en: Snapshot tests
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快照测试
- en: Snapshot tests compare the UI with previously taken snapshots. If a defined
    percentage of pixels differs from the snapshot image, the test fails. This makes
    them a perfect fit for situations where the UI of one app screen is already finished
    and you want to make sure that it won't change for given test data.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 快照测试比较UI与之前拍摄的快照。如果定义的像素百分比与快照图像不同，则测试失败。这使得它们非常适合在某个应用屏幕的UI已经完成，并且你想要确保它不会在给定的测试数据中发生变化的情况。
- en: Manual tests
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动测试
- en: The final kind of test in the development of an app is a manual test. Even if
    you have hundreds of unit and integration tests, real people using your app will
    most probably find a bug. To minimize the number of bugs your users can find,
    you need testers in your team or to ask some users for feedback on the beta version
    of your app. The more diverse the group of beta testers is, the more bugs they
    will find before your app ships.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用开发中，最后的测试类型是手动测试。即使你有数百个单元和集成测试，真实用户使用你的应用时很可能会发现一个错误。为了最小化用户可以发现的错误数量，你需要在团队中拥有测试人员或要求一些用户对你的应用测试版提供反馈。测试人员群体越多样化，他们在你的应用发货前发现的错误就越多。
- en: In this book, we will only cover unit tests because **test-driven development**
    (**TDD**) only works reasonably well with fast reliable feedback.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们只涵盖单元测试，因为**测试驱动开发**（**TDD**）只有在快速可靠的反馈下才能合理地工作。
- en: Summary
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed what unit tests are and saw some easy unit tests
    in action. We learned about the different assert functions available in `XCTest`,
    the testing framework provided by Apple. By writing our own assert function, we
    learned to improve the log output and what needs to be done to make it behave
    like built-in functions. This chapter concluded with other kinds of tests and
    how they differ from unit tests.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了单元测试是什么，并看到了一些简单的单元测试实例。我们了解了在Apple提供的测试框架`XCTest`中可用的不同断言函数。通过编写我们自己的断言函数，我们学会了如何改进日志输出以及需要做什么才能使其表现得像内置函数。本章以其他类型的测试以及它们与单元测试的不同之处结束。
- en: In the next chapter, we will learn what TDD is, and what its advantages and
    disadvantages are.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习什么是TDD（测试驱动开发），以及它的优缺点。
- en: Exercises
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Write an assert function that only fails when the keys in two dictionaries differ.
    This assert function should also fail if a key is missing in one of the dictionaries.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个断言函数，该函数仅在两个字典中的键不同时失败。如果其中一个字典中缺少键，该断言函数也应失败。
- en: 'Improve `DDHAssertEqual<A: Equatable, B: Equatable>(_:_:file:line:)` such that
    it also checks the keys of the dictionaries.'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '改进`DDHAssertEqual<A: Equatable, B: Equatable>(_:_:file:line:)`，使其也检查字典的键。'
