- en: Chapter 4. Managing RecyclerViews and Their Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章. 管理 RecyclerView 和其数据
- en: In the previous chapter, we saw how to work with more than one Activity, but
    the data displayed in both was static. To progress, we need a way to apply a choice
    of data to a predefined layout and ideally present this as part of a list. Android
    5 has introduced the RecyclerView-a more efficient and flexible version of the
    previously used ListView. To implement a RecyclerView, we will need a LayoutManager,
    an Adapter and some data to work with. In this chapter, we will start a new app
    that creates a list of CardViews, each displaying the relevant data and serving
    as a link to more detailed information.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何处理多个 Activity，但显示在两者中的数据都是静态的。为了进步，我们需要一种将数据选择应用于预定义布局的方法，并理想情况下将其作为列表的一部分展示。Android
    5 引入了 RecyclerView——这是之前使用的 ListView 的更高效和灵活的版本。要实现 RecyclerView，我们需要一个 LayoutManager、一个
    Adapter 和一些数据来工作。在本章中，我们将启动一个新应用程序，创建一个 CardView 列表，每个都显示相关数据，并作为获取更详细信息链接。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating a RecyclerView
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 RecyclerView
- en: Designing a CardView Layout
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计 CardView 布局
- en: Including a LayoutManager
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含 LayoutManager
- en: Creating Data and an Adapter
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建数据和适配器
- en: Adding a ViewHolder
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加 ViewHolder
- en: Responding to the RecyclerView selections
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应 RecyclerView 的选择
- en: Connecting a View to a web page
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将视图连接到网页
- en: Creating a RecyclerView
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 RecyclerView
- en: 'The main Activity of our new project will consist entirely of a RecyclerView
    nested inside the root Layout, and is very quick and simple to construct. However,
    similar to the CardView, it is new to Android 5 and therefore, a part of the V7
    Support Libraries and also, one of the Gradle build files will need to be modified,
    for it to work. The following steps demonstrate how to create a RecyclerView:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们新项目的 MainActivity 将完全由嵌套在根布局中的 RecyclerView 组成，构建起来非常快且简单。然而，与 CardView 类似，它是
    Android 5 的新特性，因此，它是 V7 支持库的一部分，并且还需要修改一个 Gradle 构建文件，以便它能够工作。以下步骤演示了如何创建 RecyclerView：
- en: Start a new project in the Android studio. Give it an **Application name:**
    of `Ancient Britain`; check the Phone and Tablet checkbox and select **Blank Activity**.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Android Studio 中启动一个新项目。给它一个**应用程序名称**为 `Ancient Britain`；勾选手机和平板电脑复选框并选择**空白活动**。
- en: 'Open the Gradle script file, `build.gradle` (Module app) and add the following
    two dependencies:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Gradle 脚本文件，`build.gradle`（模块 app）并添加以下两个依赖项：
- en: '[PRE0]'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Open the `activity_main.xml` file in `res/layout` and replace the `TextView`
    tag with the following code:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `res/layout` 中的 `activity_main.xml` 文件中，将 `TextView` 标签替换为以下代码：
- en: '[PRE1]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Create a color theme in the same way as we did in previous chapters.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以我们之前章节中的方式创建一个颜色主题。
- en: Rebuild the project.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新构建项目。
- en: That's all there is to it! Our RecyclerView now fills the screen, apart from
    the margins, which are set automatically to Google's recommended design standards.
    Adding dependencies to the Gradle build scripts is something we are already familiar
    with and needs no explanation. The `text_secondary` color name will set smaller
    text to a dark gray.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 就这么简单！我们的 RecyclerView 现在填充了屏幕，除了自动设置为 Google 推荐设计标准的边距之外。在 Gradle 构建脚本中添加依赖项是我们已经熟悉的事情，无需解释。`text_secondary`
    颜色名称将设置较小的文本为深灰色。
- en: Adding a CardView with layout
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加带有布局的 CardView
- en: 'Our Recycler list will be comprised of CardViews, each conforming to the layout
    that we will design next. By the end of this section, our main Activity will look
    like this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Recycler 列表将由 CardViews 组成，每个都符合我们接下来要设计的布局。在本节结束时，我们的主 Activity 将看起来像这样：
- en: '![Adding a CardView with layout](img/B04321_04_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![添加带有布局的 CardView](img/B04321_04_01.jpg)'
- en: The first thing we need to do is design our CardView.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是设计我们的 CardView。
- en: Right-click on **layout** in the project explorer and select **New** | **Layout
    resource file** from the menu.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目资源管理器中的 **layout** 上右键单击，然后从菜单中选择 **新建** | **布局资源文件**。
- en: Call it `card_main` and make sure its root element is a horizontal `LinearLayout`.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名为 `card_main` 并确保其根元素是一个水平的 `LinearLayout`。
- en: Design a card layout similar to those in the image above, with the following
    component structure and IDs.![Adding a CardView with layout](img/B04321_04_02.jpg)
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计一个类似于上图中的卡片布局，具有以下组件结构和 ID。![添加带有布局的 CardView](img/B04321_04_02.jpg)
- en: Tip
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The layout components can be moved and reordered directly from the Component
    Tree by dragging and dropping them.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以通过拖放直接从组件树中移动和重新排序布局组件。
- en: Position the two inner `LinearLayout` and `ImageView` instances to match the
    following:![Adding a CardView with layout](img/B04321_04_03.jpg)
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个内部的 `LinearLayout` 和 `ImageView` 实例定位如下：![添加带有布局的 CardView](img/B04321_04_03.jpg)
- en: For the rest of this section, set the margins and/or padding to your own liking.
    Where `layout_width` and `layout_height` are not mentioned, use `wrap_content`.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本节的剩余部分，根据您的喜好设置边距和/或填充。当 `layout_width` 和 `layout_height` 没有提及时，使用 `wrap_content`。
- en: 'Set the corner radius and elevation as you like, but make sure that the following
    properties are included in the `CardView` element:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据您的喜好设置圆角半径和高度，但请确保以下属性包含在 `CardView` 元素中：
- en: '[PRE2]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Ensure that the `ImageView` has the following properties:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保以下属性包含在 `ImageView` 中：
- en: '[PRE3]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: android:layout_width="0dp"
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: android:layout_width="0dp"
- en: android:layout_height="match_parent"
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: android:layout_height="match_parent"
- en: android:layout_weight="5"
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: android:layout_weight="5"
- en: android:orientation="vertical"
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: android:orientation="vertical"
- en: '[PRE4]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: android:id="@+id/card_name"
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: android:id="@+id/card_name"
- en: android:textAppearance="?android:attr/textAppearanceLarge"
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: android:textAppearance="?android:attr/textAppearanceLarge"
- en: '[PRE5]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: android:id="@+id/card_info"
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: android:id="@+id/card_info"
- en: android:textAppearance="?android:attr/textAppearanceSmall"
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: android:textAppearance="?android:attr/textAppearanceSmall"
- en: '[PRE6]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Most of the properties set here are the ones we are familiar with: most importantly
    the `id` property, which allows us access through Java. However, one or two things
    may need explaining.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里设置的属性大多数是我们熟悉的：最重要的是 `id` 属性，它允许我们通过 Java 访问。然而，一两个东西可能需要解释。
- en: '`LinearLayout` allows us to allocate proportional amounts of screen space to
    individual views, according to their `layout_weight` property. Instead of telling
    a view to take up as much space as it can (`match_parent`), or as little (`wrap_content`),
    using `layout_weight` allows us to allocate a certain proportion of the parent
    view group. Two views each with a weight of 1 will both take up 50% of the space,
    weights of 1 and 4 would take up 20% and 80% respectively. Here, we used weights
    of 2 and 5, meaning that 2/7 of the available space is allocated to the image
    and 5/7 to the vertical layout. We set the layout widths to `0dp` so as not to
    interfere with the weighting.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinearLayout` 允许我们根据每个视图的 `layout_weight` 属性分配成比例的屏幕空间。使用 `layout_weight`
    而不是告诉视图尽可能多地占用空间（`match_parent`），或者尽可能少地占用空间（`wrap_content`），允许我们分配父视图组的特定比例。两个权重为
    1 的视图将各自占用 50% 的空间，权重为 1 和 4 的视图将分别占用 20% 和 80%。在这里，我们使用了权重 2 和 5，这意味着 2/7 的可用空间分配给了图像，5/7
    分配给了垂直布局。我们将布局宽度设置为 `0dp` 以避免干扰权重。'
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The drawable `ic_launcher.png` was simply used as a placeholder to facilitate
    designing the layout; it will be replaced in the code later.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 可绘制资源 `ic_launcher.png` 仅被用作占位符，以方便设计布局；它将在代码中稍后替换。
- en: We used `textAppearanceSmall` and `textAppearanceLarge` to set our text sizes.
    This is often preferable to using specific dp amounts, as these settings automatically
    adjust to suit the size of the user's screen.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 `textAppearanceSmall` 和 `textAppearanceLarge` 来设置我们的文本大小。这通常比使用特定的 dp
    数量更可取，因为这些设置会自动调整以适应用户屏幕的大小。
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Despite the obvious advantages of using weights in our layouts, it does need
    pointing out that this can have an adverse effect on performance, as the system
    has to recalculate its/the position more often.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用权重在我们的布局中具有明显的优势，但需要指出的是，这可能会对性能产生不利影响，因为系统需要更频繁地重新计算其/他们的位置。
- en: Now that we have a `RecyclerView` and a `CardView` layout, we can go ahead and
    bring the two together with a `LayoutManager`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了 `RecyclerView` 和 `CardView` 布局，我们可以继续使用 `LayoutManager` 将两者结合起来。
- en: Adding a LayoutManager
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加布局管理器
- en: Views are positioned in the `RecyclerView` by a `RecyclerView.LayoutManager`,
    which in turn communicates with a `RecyclerView.Adapter`, and this binds our data
    to our views. First, let's set up a `LayoutManager`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `RecyclerView.LayoutManager` 将视图定位在 `RecyclerView` 中，它反过来与 `RecyclerView.Adapter`
    通信，并将我们的数据绑定到视图。首先，让我们设置一个 `LayoutManager`。
- en: Open the `MainActivity.Java` file.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainActivity.Java` 文件。
- en: 'At the top of the class, declare the following fields:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的顶部声明以下字段：
- en: '[PRE7]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Inside the `onCreate()` method, add these lines:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onCreate()` 方法内部，添加以下这些行：
- en: '[PRE8]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: By now, the use of `findViewById()` should be familiar to us. The use of the
    `setFixedSize()` method is very useful. If you know that your list will remain
    the same length during runtime, then setting it to true will improve the performance
    of your app, as it cleverly recycles items when they are out of view, hence the
    name `RecyclerView`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，`findViewById()`的使用应该对我们来说已经很熟悉了。`setFixedSize()`方法的使用非常有用。如果你知道你的列表在运行时将保持相同的长度，那么将其设置为true将提高你应用程序的性能，因为它在项目不可见时巧妙地回收项目，这就是为什么它被称为`RecyclerView`。
- en: 'Giving the RecyclerView a LayoutManager is as simple as declaring a new `LinearLayoutManager`,
    passing it the current context and using `RecyclerView.setLayoutManager()` to
    set the connection. The `LayoutManager` can be thought of as belonging to the
    RecyclerView and it is the view''s way of communicating with the data adapter,
    which in turn accesses a dataset, as can be seen in this diagram:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 给RecyclerView一个LayoutManager就像声明一个新的`LinearLayoutManager`，传递当前上下文，并使用`RecyclerView.setLayoutManager()`来设置连接。可以将`LayoutManager`视为属于RecyclerView的，它是视图与数据适配器通信的方式，而数据适配器反过来访问数据集，如这张图所示：
- en: '![Adding a LayoutManager](img/B04321_04_04.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![添加LayoutManager](img/B04321_04_04.jpg)'
- en: Before we move on to create our `Adapter` class, we will set up some data for
    it to work with.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续创建我们的`Adapter`类之前，我们将为它设置一些数据来工作。
- en: Adding a dataset
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加数据集
- en: 'The Android system utilizes SQLite for use with large and complex datasets,
    and we will return to this later in the book. For the purposes of this project,
    we will create the data arrays we need with Java. here''s how this is done:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Android系统利用SQLite来处理大型和复杂的数据集，我们将在本书的后续章节中回到这一点。对于这个项目，我们将使用Java创建我们所需的数据数组。以下是这样做的方法：
- en: Create a new Java class by right-clicking on **MainActivity** on the project
    explorer and selecting **New** | **Java Class** from the menu. Call it `MainDataDef`.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在项目资源管理器中右键单击**MainActivity**并从菜单中选择**New** | **Java Class**来创建一个新的Java类。将其命名为`MainDataDef`。
- en: 'Fill it out as follows:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下内容填写它：
- en: '[PRE9]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you have downloaded the project files from the Packt website, then the dataset
    will contain ten records. However, the app will work just fine with any number
    and just the first five are included here. Create another Java class called `MainData`
    and complete it as follows:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你已经从Packt网站下载了项目文件，那么数据集将包含十个记录。然而，应用程序将能够很好地处理任何数量的记录，这里只包括前五个。创建另一个名为`MainData`的Java类，并按照以下内容完成它：
- en: '[PRE10]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you have downloaded the project files, you will see that the `drawable`
    directory contains images: if not, you will need to add your own. If you are using
    the dataset seen above, then you will need ten images, with the names shown below.
    Make sure the `*_icon.png` files are roughly 160 x 160 px and the `*_large.png`
    files are about 640 x 480 px.![Adding a dataset](img/B04321_04_05.jpg)'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你已经下载了项目文件，你会看到`drawable`目录包含图像：如果没有，你需要添加自己的。如果你正在使用上面看到的数据集，那么你需要十张图像，名称如下所示。确保`*_icon.png`文件大约是160
    x 160 px，而`*_large.png`文件大约是640 x 480 px。![添加数据集](img/B04321_04_05.jpg)
- en: 'The final part of the data consists of rather long strings. If you have downloaded
    the project files these can be found in the `strings.xml` resource file, if not,
    then you will need five strings of about 100 words a piece, with the following
    names:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据的最后一部分是由相当长的字符串组成。如果你已经下载了项目文件，这些可以在`strings.xml`资源文件中找到，如果没有，那么你需要大约100个单词的五个字符串，名称如下：
- en: '[PRE11]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Putting our data arrays together was quite straightforward, but it is interesting
    to note how we used integers to refer to images and strings, using the automatically
    generated `R` class, which associates each individual resource with a static integer.
    This can be found by selecting **Packages** under **app** | **package name**.
    It cannot be edited, but it is helpful to see how it works.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的数据数组组合起来相当直接，但值得注意的是我们如何使用整数来引用图像和字符串，利用自动生成的`R`类，该类将每个单独的资源与一个静态整数关联。这可以通过在**app**
    | **package name**下选择**Packages**来找到。它不能被编辑，但查看其工作原理是有帮助的。
- en: We used the `strings.xml` file to store the long strings. This is not practical
    for lengthy text and usually we would store these resources as text files in the
    raw resource folder, and this is something we will cover later in the book.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`strings.xml`文件来存储长字符串。对于长文本来说，这并不实用，我们通常会把这些资源作为文本文件存储在原始资源文件夹中，这一点我们将在本书的后续章节中介绍。
- en: 'Android TextViews are able to handle basic markup formatting tags, such as
    `<b></b>` and `<i></i>`. Below is a list of some of the formatting tags available:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Android TextView 能够处理基本的标记格式化标签，如 `<b></b>` 和 `<i></i>`。以下是一些可用的格式化标签列表：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With our data in place, we can now get around to creating our data adapter.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据就绪后，我们现在可以着手创建我们的数据适配器。
- en: Creating an Adapter
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个 Adapter
- en: 'The `RecyclerView.Adapter` is responsible for binding our data to our views.
    We control how this happens through another `RecyclerView` sub-class, the `ViewHolder`,
    which we will create inside our Adapter. This can be achieved by following these
    steps:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`RecyclerView.Adapter` 负责将我们的数据绑定到我们的视图上。我们通过另一个 `RecyclerView` 子类，即 `ViewHolder`
    来控制这一过程，我们将在 Adapter 内部创建它。这可以通过以下步骤实现：'
- en: Create a new Java class alongside the others in our project called `MainAdapter`.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的项目中创建一个名为 `MainAdapter` 的新 Java 类，与其它类并列。
- en: 'Change the class declaration to this:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类声明更改为以下内容：
- en: '[PRE13]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Directly under this, type:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 直接在此之下，键入：
- en: '[PRE14]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This last line will generate an error, indicated by a red underline. Place the
    cursor somewhere on the class declaration and press *Alt* + *Enter*.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这最后一行将生成一个错误，由红色下划线指示。将光标放在类声明上的某个位置并按 *Alt* + *Enter*。
- en: Select **Implement Methods** from the drop-down list and then all three methods
    shown here:![Creating an Adapter](img/B04321_04_06.jpg)
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下拉列表中选择 **Implement Methods** 并然后选择这里显示的所有三个方法：![创建一个 Adapter](img/B04321_04_06.jpg)
- en: 'Beneath this, add the following class:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此之下，添加以下类：
- en: '[PRE15]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Complete the `onCreateViewHolder()` method like this:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成以下 `onCreateViewHolder()` 方法：
- en: '[PRE16]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, the `onBindViewHolder()` method:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，`onBindViewHolder()` 方法：
- en: '[PRE17]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And, the `getItemCount()` method:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，`getItemCount()` 方法：
- en: '[PRE18]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Open the `MainActivity` file.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainActivity` 文件。
- en: 'At the bottom of the `onCreate()` method, add this code:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onCreate()` 方法的底部添加以下代码：
- en: '[PRE19]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can now test the project on an emulator or a handset.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在可以在模拟器或手机上测试项目。
- en: Most of the work of the Adapter is carried out by the ViewHolder. This class
    is responsible, as its name suggests, for holding information about each of the
    views in our RecyclerView, including a view's metadata and its position in the
    list. We use the class definition and constructor to define three views that are
    associated with those in our card layout. The ViewHolder requires three callback
    methods, `onCreateViewHolder()`, which inflates the CardView and performs any
    other operations on it such as adding an `onClickListener`, `onBindViewHolder()`.
    This takes the ViewHolder's version of our card's inner views and connects them
    to our data, and `getItemCount()`, which returns the length of our list.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Adapter 的大部分工作由 ViewHolder 执行。这个类负责，正如其名称所暗示的，保存关于我们 RecyclerView 中每个视图的信息，包括视图的元数据和它在列表中的位置。我们使用类定义和构造函数来定义与我们的卡片布局相关联的三个视图。ViewHolder
    需要三个回调方法，`onCreateViewHolder()`，它膨胀 CardView 并执行任何其他操作，如添加 `onClickListener`、`onBindViewHolder()`。这个方法接受
    ViewHolder 的卡片内部视图版本并将它们连接到我们的数据，以及 `getItemCount()`，它返回我们列表的长度。
- en: Finally, to connect the data to the RecyclerView, we build our ArrayList `mainData`
    and then set up a new `MainAdapter` from `mainData` and connect the RecyclerView
    to its Adapter with the `setAdapter()` method.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了将数据连接到 RecyclerView，我们构建我们的 `ArrayList mainData`，然后从 `mainData` 设置一个新的
    `MainAdapter` 并使用 `setAdapter()` 方法将 RecyclerView 连接到其 Adapter。
- en: With our RecyclerView in place and connected to our dataset with an Adapter,
    we are ready to add a click listener and a second activity.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RecyclerView 就位并连接到我们的数据集与 Adapter 后，我们准备添加一个点击监听器和第二个 Activity。
- en: Responding to the RecyclerView selections
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应 RecyclerView 选择
- en: Having successfully produced a RecyclerView, and populated it with CardViews
    containing our data, we need to be able to select individual items and do something
    with them. Next, we will provide the RecyclerView with a **click listener** and
    add a new Activity that will present our records in greater detail on a separate
    screen.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 成功创建了一个 RecyclerView，并用包含我们数据的 CardViews 填充后，我们需要能够选择单个项目并对它们进行操作。接下来，我们将为 RecyclerView
    提供一个 **点击监听器** 并添加一个新的 Activity，该 Activity 将在单独的屏幕上以更详细的方式展示我们的记录。
- en: Creating the OnClickListener
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 OnClickListener
- en: 'Before we create our new Activity, we need an `OnClickListener` that can tell
    which CardView was clicked on. Here''s how it''s done:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建新的 Activity 之前，我们需要一个 `OnClickListener`，它可以告诉我们哪个 CardView 被点击了。以下是实现方式：
- en: Open the `MainActivity` class.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainActivity` 类。
- en: 'Add the following class member:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下类成员：
- en: '[PRE20]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Assign the listener in the `onCreate()` method like this:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onCreate()` 方法中分配监听器，如下所示：
- en: '[PRE21]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create the following class:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下类：
- en: '[PRE22]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is very similar to the way that we implemented the `OnClickListener` before,
    only here, rather than assigning it to just a single view, we made it available
    to the whole class. This means that we must construct the listener in such a way
    as to pass the `Context` object of the calling view. The `onClick()` method is
    a good time to record which view was clicked on with the RecyclerView's `getChildPosition()`
    method. With this done, it is now a matter of creating the new Activity.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们之前实现 `OnClickListener` 的方式非常相似，只是在这里，我们不是将其分配给单个视图，而是使其对整个类可用。这意味着我们必须以某种方式构建监听器，以便传递调用视图的
    `Context` 对象。在 `onClick()` 方法中，我们可以使用 RecyclerView 的 `getChildPosition()` 方法记录哪个视图被点击。完成此操作后，现在只需创建新的
    Activity。
- en: Adding the new Activity
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加新的 Activity
- en: The last method we entered will have generated an error message, as the class
    `DetailActivity` does not yet exist. The Activity will display greater detail
    about our ancient sites and provide a web link to each site's Wikipedia page.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后输入的方法将生成一个错误消息，因为类 `DetailActivity` 尚未存在。该 Activity 将显示有关我们古代遗址的更多详细信息，并为每个遗址的维基百科页面提供网页链接。
- en: Creating the portrait layout
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建肖像布局
- en: 'As is often the case, there are two parts to creating an Android Activity,
    and before we can write the code, we need to define its layouts. To do this, follow
    these steps:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如常，创建 Android Activity 有两个部分，在我们编写代码之前，我们需要定义其布局。为此，请按照以下步骤操作：
- en: Create a new vertical `LinearLayout` XML file in the `layout` directory and
    call it `activity_detail`.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `layout` 目录中创建一个新的垂直 `LinearLayout` XML 文件，并将其命名为 `activity_detail`。
- en: In the design mode, create a layout to match the following component tree and
    provide the views with the IDs and contents, as shown:![Creating the portrait
    layout](img/B04321_04_07.jpg)
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设计模式下，创建一个与以下组件树匹配的布局，并为视图提供ID和内容，如下所示：![创建肖像布局](img/B04321_04_07.jpg)
- en: If you have not downloaded the project files, find or create a small image,
    suitable for use as a web icon, about 48 x 48 px. Call it `web_icon.png` and place
    it in your `drawable` directory.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您尚未下载项目文件，找到一个或创建一个适合用作网页图标的小图像，大小约为 48 x 48 px。将其命名为 `web_icon.png` 并将其放置在您的
    `drawable` 目录中。
- en: Adjust the view's properties to match the structure shown here:![Creating the
    portrait layout](img/B04321_04_08.jpg)
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整视图的属性以匹配此处显示的结构：![创建肖像布局](img/B04321_04_08.jpg)
- en: 'Set the following properties on the ImageView `detail_image`:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 ImageView `detail_image` 上设置以下属性：
- en: '[PRE23]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Add `android:textAppearance="?android:attr/textAppearanceLarge"` to the `detail_name`
    TextView:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `android:textAppearance="?android:attr/textAppearanceLarge"` 添加到 `detail_name`
    TextView：
- en: The TextView `detail_distance` should have `android:textAppearance="?android:attr/textAppearanceMedium"`
    set.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TextView `detail_distance` 应设置 `android:textAppearance="?android:attr/textAppearanceMedium"`。
- en: 'The `detail_text` TextView needs these properties:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`detail_text` TextView 需要以下属性：'
- en: '[PRE24]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: With the `detail_web_icon` ImageView, set `layout_gravity` to `"right"`.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `detail_web_icon` ImageView，将 `layout_gravity` 设置为 `"right"`。
- en: There is nothing in this process that we have not encountered before, apart
    from the two properties in the `detail_text` TextView, `maxLines` and `scrollbars`,
    and these are self-explanatory. The text we have allocated to this view may well
    be too long for many smaller screens and so we have set this view up to be scrollable.
    There is still a line of code we need to add in Java to fully implement this,
    but we will come to that shortly.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中，我们没有遇到之前未遇到的内容，除了 `detail_text` TextView 中的两个属性 `maxLines` 和 `scrollbars`，这些属性是自解释的。我们分配给此视图的文本可能对于许多较小的屏幕来说可能太长，因此我们已设置此视图为可滚动。我们还需要在
    Java 中添加一行代码以完全实现此功能，但我们将很快介绍这一点。
- en: The use of `layout_weight` to define our layout means that, even when we rotate
    the screen, all of the views will remain in view. Nevertheless, if you test this
    on a device, you will see that this is not an attractive or space efficient layout.
    Next, we will redesign the landscape layout to more suitably fit the orientation.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `layout_weight` 定义我们的布局意味着，即使我们旋转屏幕，所有视图都将保持可见。尽管如此，如果您在设备上测试此布局，您会发现这并不是一个吸引人或者空间效率高的布局。接下来，我们将重新设计横幅布局，使其更适合适应方向。
- en: Creating the landscape layout
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建横幅布局
- en: 'The vertical linear layout we designed is not at all well suited to a landscape
    screen. To best fill the space, it is not enough to simply rearrange the views,
    we will need to change the root layout to a horizontal orientation and insert
    a vertical layout for the text and web icon. Follow these steps to create the
    layout:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计的垂直线性布局并不适合横屏屏幕。为了最佳地填充空间，仅仅重新排列视图是不够的，我们需要将根布局更改为水平方向，并插入一个垂直布局来放置文本和网页图标。按照以下步骤创建布局：
- en: If it is not open already, open the `activity_detail.xml` file in design mode
    or in text mode with the preview pane open.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未打开，请以设计模式或文本模式（预览窗格打开）打开 `activity_detail.xml` 文件。
- en: Select **Create Landscape Variation** from the preview drop-down, as follows:![Creating
    the landscape layout](img/B04321_04_09.jpg)
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从预览下拉菜单中选择 **创建横屏变体**，如下所示：![创建横屏布局](img/B04321_04_09.jpg)
- en: Open the `detail_activity.xml` (land) file in the text mode.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以文本模式打开 `detail_activity.xml`（横屏）文件。
- en: 'In `detail_image` ImageView, change the following lines:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `detail_image` ImageView 中，修改以下行：
- en: '[PRE25]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Insert the following vertical linear layout, so that it contains the three
    TextViews and the other ImageView:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插入以下垂直线性布局，使其包含三个 TextView 和其他 ImageView：
- en: '[PRE26]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Change these lines in the `detail_text` TextView:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `detail_text` TextView 中的这些行：
- en: '[PRE27]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And, add this one:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加以下内容：
- en: '[PRE28]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The landscape layout should now look like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的横屏布局应该看起来像这样：
- en: '![Creating the landscape layout](img/B04321_04_10.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![创建横屏布局](img/B04321_04_10.jpg)'
- en: There is nothing here that we have not encountered before. However, it is worth
    noting that, although it would have taken more time, we could have used a `RelativeLayout`
    for this purpose and had we done so, we would not have needed the inner vertical
    `LinearLayout`. ViewGroups, such as Layouts, require a considerable amount of
    memory, and although it does not matter for a small app such as this one, it is
    a good practice to keep the number of view containers to a minimum. Rebuilding
    `activity_detail.xml` (land) as a `RelativeLayout` is left as an exercise for
    the reader.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有我们之前没有遇到的内容。然而，值得注意的是，虽然这将花费更多时间，但我们本可以使用 `RelativeLayout` 来实现这个目的，如果我们那样做了，我们就不需要内部的垂直
    `LinearLayout`。ViewGroup，如布局，需要相当多的内存，尽管对于像这样的小应用程序来说这并不重要，但将视图容器的数量保持在最低限度是一个好的做法。将
    `activity_detail.xml`（横屏）重构成 `RelativeLayout` 作为读者的练习。
- en: All that remains now is to create the Java Activity class `ActivityDetail`,
    which will select and display its content according to the card that was clicked
    on.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只剩下创建 Java Activity 类 `ActivityDetail`，它将根据点击的卡片选择并显示其内容。
- en: Connecting Views to web pages
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接视图到网页
- en: 'The `ActivityDetail` class is not at all complicated, although we do get to
    add the Java component of the code, which will make our TextView scrollable and
    we also get to see how we can use an `Intent` object to launch the browser and
    open a specific web page. Follow these steps to complete the Activity:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActivityDetail` 类并不复杂，尽管我们确实需要添加代码的 Java 组件，这将使我们的 TextView 可滚动，并且我们还可以看到如何使用
    `Intent` 对象来启动浏览器并打开特定的网页。按照以下步骤完成 Activity：'
- en: From the project explorer, by right-clicking any of the classes we have already
    constructed, create a new Activity by selecting **New** | **Activity** | **Blank
    Activity**, calling the file `DetailActivity` and accepting the other values the
    dialog suggests.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目资源管理器中，通过右键单击我们已构建的任何类，通过选择 **新建** | **Activity** | **空白 Activity** 创建一个新的
    Activity，将文件命名为 `DetailActivity` 并接受对话框中建议的其他值。
- en: Open the `DetailActivity` Java code.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `DetailActivity` Java 代码。
- en: 'Change the line `setContentView(R.layout.activity_detail2);` in `onCreate()`
    to the following:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `onCreate()` 方法中的这一行 `setContentView(R.layout.activity_detail2);` 改为以下内容：
- en: '[PRE29]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When you created the Activity, the IDE will have created a matching layout file
    `activity_detail2`. Delete this file by selecting it in the project explorer and
    pressing *Delete*.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你创建 Activity 时，IDE 将创建一个匹配的布局文件 `activity_detail2`。通过在项目资源管理器中选择该文件并按 *Delete*
    键来删除此文件。
- en: 'Add the following class wide fields:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下全局字段：
- en: '[PRE30]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Assign them like this:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式分配它们：
- en: '[PRE31]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Still in `onCreate()`, add these lines to link our views to our data:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在 `onCreate()` 中，添加以下行以将我们的视图链接到我们的数据：
- en: '[PRE32]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Beneath that, add these lines to program the web link:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此之下，添加以下行以编程方式设置网页链接：
- en: '[PRE33]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Run the app on an emulator or a handset. Hopefully, the second activity will
    look like this:![Connecting Views to web pages](img/B04321_04_11.jpg)
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器或手机上运行应用程序。希望第二个 Activity 将看起来像这样：![连接视图到网页](img/B04321_04_11.jpg)
- en: The Activity wizard automatically created a layout file for us, even though
    we had already created one, which is why we had to edit the `ContentView` of the
    Activity and delete the unwanted XML file. We could have of course constructed
    our class from scratch and avoided doing this, but the Activity wizard builds
    a time saving class template for us, including all the required members.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 活动向导自动为我们创建了一个布局文件，即使我们之前已经创建了一个，这也是为什么我们必须编辑 Activity 的 `ContentView` 并删除不需要的
    XML 文件。当然，我们可以从头开始构建我们的类并避免这样做，但活动向导为我们构建了一个节省时间的类模板，包括所有必需的成员。
- en: The naming and assigning of our views requires no explanation. However, this
    section of code also provides the final part of our scrollable TextView by calling
    its `setMovementMethod(new ScrollingMovementMethod())`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们视图的命名和分配不需要解释。然而，这段代码还通过调用其 `setMovementMethod(new ScrollingMovementMethod())`
    方法提供了我们可滚动 TextView 的最后一部分。
- en: We used the public field `currentItem` to access our data, which we kept in
    the same array list for convenience. We filled the distance field with a random
    number for now, but we will return to make this function operate correctly when
    we get to geo-locations later in the book.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用公共字段 `currentItem` 来访问我们的数据，我们为了方便将其保存在同一个数组列表中。我们现在用随机数填充距离字段，但稍后当我们到达本书中的地理位置时，我们将返回并使这个功能正确运行。
- en: Linking views to web pages is new and requires explanation. This is the only
    view in the layout that is clickable, so it is a simple matter to provide it with
    its own `OnClickListener`. Here, we get to see the `Intent` object in more detail
    and also just how useful it can be. The `setAction()` method tells the Intent
    which action to perform, in the form of a static, final String which here is `ACTION_VIEW`,
    the most widely used **Intent action**, and it tells the Intent to display the
    data in the most appropriate way. This means that, more often than not, the system
    will select the correct way to display the data, such as displaying images in
    an ImageView, contacts in the contacts app, and web pages in the default browser.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 将视图链接到网页是新的功能，需要解释说明。这是布局中唯一可以点击的视图，因此为它提供自己的 `OnClickListener` 是一件简单的事情。在这里，我们可以更详细地看到
    `Intent` 对象，以及它有多么有用。`setAction()` 方法告诉 Intent 要执行哪个操作，形式为一个静态的、最终的 String，在这里是
    `ACTION_VIEW`，这是最广泛使用的 **Intent 操作**，并且它告诉 Intent 以最合适的方式显示数据。这意味着，在大多数情况下，系统将选择正确的方式来显示数据，例如在
    ImageView 中显示图片，在联系人应用中显示联系人，以及在默认浏览器中显示网页。
- en: Note
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that, there is a corresponding `Intent.getAction()` method for when we
    need to know what action has been set to an Intent.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们需要知道已设置到 Intent 中的操作时，有一个相应的 `Intent.getAction()` 方法。
- en: 'The `addCategory(Intent.CATEGORY_BROWSABLE)` call is not strictly necessary
    and the app will run fine without it in most circumstances. **Intent categories**
    cause the Intent to only consider apps (or more accurately, activities), that
    are labeled with that category when resolving the action. To place an app in one
    or more categories, add them to the `<intent-filter>` tab in the manifest file
    like so: `<category android:name="android.intent.category.CATEGORY"/>`. The `Intent`
    object defines a wide selection of category constants, such as, `APP_MUSIC, APP_MESSAGING`,
    and `APP_CALENDAR`.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`addCategory(Intent.CATEGORY_BROWSABLE)` 调用并非绝对必要，在大多数情况下，即使没有它应用程序也能正常运行。**Intent
    类别**使得 Intent 只考虑那些带有该类别的应用程序（或更准确地说，活动）来解析操作。要将应用程序放入一个或多个类别中，请将它们添加到清单文件中的 `<intent-filter>`
    标签，如下所示：`<category android:name="android.intent.category.CATEGORY"/>`。`Intent`
    对象定义了一系列类别常量，例如，`APP_MUSIC, APP_MESSAGING`, 和 `APP_CALENDAR`。'
- en: With the second Activity and its layout files in place, we can now display detailed
    information about each of our ancient sites and provide a link to the web page
    with further information. With this done, we have completed the exercise.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在放置了第二个 Activity 及其布局文件之后，我们现在可以显示有关我们古代遗址的详细信息，并提供一个链接到包含更多信息的网页。完成这些后，我们就完成了这个练习。
- en: Summary
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have constructed a small but complete app. The structure
    is by no means dictated by the subject matter and is such that it could be applied
    to any number of apps. We took advantage of both of Android's latest widgets and
    produced a RecyclerView list of CardViews, which displayed a simple dataset. In
    doing this, we saw how to connect our data to our views with an Adapter and how
    this in turn uses a ViewHolder to maintain our individual views and layouts. Adding
    an `OnClickListener` allowed the user to select data items and navigate to a new
    screen with further information and a link to a website.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们构建了一个小但完整的应用程序。其结构并非由主题内容决定，而是可以应用于任何数量的应用程序。我们利用了Android最新的小部件，并生成了一个CardView的RecyclerView列表，展示了简单的数据集。在这个过程中，我们看到了如何通过适配器将我们的数据连接到我们的视图，以及适配器如何反过来使用ViewHolder来维护我们的单个视图和布局。添加`OnClickListener`允许用户选择数据项，并通过链接到网站的新屏幕导航到更多信息。
- en: Next, we will delve deeper into the RecyclerView and see how to move items up
    and down the list. To do this, we will first have to learn how to detect a swipe
    gesture from the user, using an `OnTouchListener`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更深入地探讨RecyclerView，看看如何移动列表中的项目上下移动。为此，我们首先需要学习如何使用`OnTouchListener`检测用户的滑动手势。
