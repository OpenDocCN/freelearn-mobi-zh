- en: Designing Material Layouts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计材料布局
- en: When designing and creating the layout for a screen, there are many different
    schools of thought about how it should be done. Modern layouts are often complex
    systems that change their shape dynamically as the user interacts with them. In
    the past, layouts tended to be quite rigid structures with only specialized areas
    such as windows or slit panels that could be adjusted by the user. However, a
    mobile application must make better use of their available space, since they're
    typically used on physically smaller devices. The direct interaction of a touch
    interface also changes how the user expects an application to behave; you need
    to not only react to the users gestures, but also be mindful of where their hand
    and fingers are likely to be on the screen as they might be obscuring some part
    of the screen, as they drag to scroll through your application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计和创建屏幕布局时，关于如何进行有许多不同的观点。现代布局通常是复杂的系统，它们会根据用户的交互动态地改变形状。在过去，布局往往是相当刚性的结构，只有像窗口或狭缝面板这样的特定区域可以被用户调整。然而，移动应用程序必须更好地利用它们可用的空间，因为它们通常用于物理尺寸较小的设备上。触摸界面的直接交互也改变了用户对应用程序行为的期望；你需要不仅对用户的操作做出反应，还要注意他们的手和手指可能在哪里，因为它们可能会遮挡屏幕的一部分，当他们拖动以滚动应用程序时。
- en: 'The easiest way to see how a layout can change and adjust is with a jumbo collapsing
    toolbar. When the screen opens, the toolbar is full sized and takes up enough
    space to contain various additional widgets and information. As the screen is
    scrolled, the action button vanishes, and the toolbar collapses in size. Then,
    the toolbar pins itself to the top of the screen and remains visible as just the
    title and possibly some action buttons, as shown here:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解布局如何改变和调整，最简单的方法是使用巨型折叠工具栏。当屏幕打开时，工具栏是全尺寸的，占据足够的空间来容纳各种附加的小部件和信息。当屏幕滚动时，操作按钮消失，工具栏缩小。然后，工具栏将自己固定在屏幕顶部，并仅以标题和可能的一些操作按钮的形式保持可见，如下所示：
- en: '![](img/02822db6-d361-47d1-9253-4b2e52ddd52a.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/02822db6-d361-47d1-9253-4b2e52ddd52a.png)'
- en: This collapsing behavior is something you see commonly in material applications--various
    parts of the user interface being shown or hidden as the user scrolls or changes
    what they are doing. These layouts often coordinate the moving, resizing, showing,
    and hiding of many different widgets at the same time, and there's a special class
    for that--the `CoordinatorLayout`.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这种折叠行为在材料应用程序中很常见——用户界面的各个部分在用户滚动或更改操作时显示或隐藏。这些布局通常同时协调许多不同小部件的移动、调整大小、显示和隐藏，为此有一个特殊的类——`CoordinatorLayout`。
- en: 'In this chapter, we''ll take a look at the `CoordinatorLayout` and some other
    specialist Android layout classes in order to do the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨`CoordinatorLayout`和其他一些专业的Android布局类，以便完成以下任务：
- en: Create layouts that change based on user actions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建基于用户操作的动态布局
- en: Create layouts on flexible grids
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在灵活的网格上创建布局
- en: Allow the user to take actions using gestures
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户通过手势执行操作
- en: Highlight some widgets above others using elevation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用高度突出显示一些小部件，使其高于其他小部件
- en: Looking at material structure
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看材料结构
- en: 'Material layouts have a selection of patterns that applications should follow
    for every screen they build. This sort of template is often called the **scaffolding**,
    and for mobile, it looks like this:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 材料布局有一系列模式，应用程序应该遵循每个它们构建的屏幕。这种类型的模板通常被称为**框架**，对于移动设备来说，它看起来是这样的：
- en: '![](img/3f0a7b7a-4c05-4b04-9dc4-bcc3e84a7eb7.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3f0a7b7a-4c05-4b04-9dc4-bcc3e84a7eb7.png)'
- en: 'What is important about the scaffolding is that while it defines the basic
    layout of virtually every screen, it doesn''t define how you should achieve this
    design, and even on Android, you''ll find that there are several different ways
    of creating a screen with the preceding layout structure. Several elements are
    also optional: the Bottom Bar and floating action button are often left out because
    they aren''t useful to a screen. The App Bar appears on most screens, but can
    be much larger and can also be folded away to provide the user with more reading
    space in the content area.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 框架的重要性在于，尽管它定义了几乎所有屏幕的基本布局，但它并没有定义你应该如何实现这种设计，甚至在Android上，你会发现有几种不同的方式来创建具有前述布局结构的屏幕。一些元素也是可选的：底部栏和浮动操作按钮通常被省略，因为它们对屏幕没有帮助。应用栏几乎出现在所有屏幕上，但它可以更大，也可以折叠起来，为用户提供更多阅读空间的内容区域。
- en: 'It''s also important to understand that by default, the platform theming will
    put the App Bar (presented by the `ActionBar` class) into an `Activity` for you;
    it''s also common to create your own App Bar using the `Toolbar` class and the
    `NoActionBar` theme on the `Activity`. In fact, in [Chapter 2](6ed5cfcb-b233-4bf0-b6fd-012432897224.xhtml),
    *Designing Form Screens*, when you created the `CaptureClaimActivity`, the Android
    Studio template did exactly this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 还很重要的一点是，默认情况下，平台主题会将App Bar（由`ActionBar`类呈现）放入一个`Activity`中为你处理；使用`Toolbar`类和`NoActionBar`主题在`Activity`中创建自己的App
    Bar也是常见的。实际上，在[第2章](6ed5cfcb-b233-4bf0-b6fd-012432897224.xhtml)，*设计表单屏幕*中，当你创建`CaptureClaimActivity`时，Android
    Studio模板正是这样做的：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the `CaptureClaimActivity` class, near the top of the `onCreate` method,
    you''ll be able to find the following code snippet:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CaptureClaimActivity`类中，在`onCreate`方法顶部附近，你可以找到以下代码片段：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code allows your application to take complete control of the `Toolbar`,
    from what it looks like, to what widgets it contains. Setting it as the `SupportActionBar`
    tells the `AppCompatActivity` to delegate any calls to `Activity.setTitle` and
    similar methods to the `Toolbar`, but in no other way changes how the `Toolbar`
    interacts with the layout system. This is still firmly under your control now.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码允许你的应用程序完全控制`Toolbar`的外观和包含的小部件。将其设置为`SupportActionBar`会告诉`AppCompatActivity`将任何对`Activity.setTitle`和类似方法的调用委托给`Toolbar`，但不会以任何方式改变`Toolbar`与布局系统的交互方式。现在，这仍然完全在你的控制之下。
- en: Introducing CoordinatorLayout
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍`CoordinatorLayout`
- en: 'Android has a small family of layouts designed to work together to achieve
    the dynamic movement effects when the user scrolls. At the core of this group
    is the `CoordinatorLayout` class, which allows complex behaviors to be attached
    to any number of floating sibling widgets that can depend on and react to each
    other''s position and size. To illustrate how a `CoordinatorLayout` actually works,
    take a look at this diagram:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Android有一系列布局，旨在协同工作以在用户滚动时实现动态移动效果。这个系列的核心是`CoordinatorLayout`类，它允许将复杂的行为附加到任意数量的浮动兄弟小部件上，这些小部件可以相互依赖并对其位置和大小做出反应。为了说明`CoordinatorLayout`的实际工作原理，请看以下这张图：
- en: '![](img/ea7ef32e-740a-40e3-8cf6-e0885b1d0d5c.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ea7ef32e-740a-40e3-8cf6-e0885b1d0d5c.png)'
- en: Even though the `FloatingActionButton` appears to be floating above the other
    widgets, it's a direct child of the `CoordinatorLayout`. It remains in place because
    it is anchored to the bottom of the toolbar. If the toolbar changes its size or
    position, the `CoordinatorLayout` will move the `FloatingActionButton` so that
    it appears to be attached to the bottom of the toolbar. These movements are all
    done together as part of the layout process, resulting in every frame being pixel
    perfect and everything appearing to move and resize together.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管看起来`FloatingActionButton`似乎浮在其它小部件之上，但实际上它是`CoordinatorLayout`的直接子元素。它之所以保持在原位，是因为它被锚定在工具栏的底部。如果工具栏改变其大小或位置，`CoordinatorLayout`将会移动`FloatingActionButton`，使其看起来像是附着在工具栏的底部。这些移动都是作为布局过程的一部分一起完成的，从而确保每一帧都是像素完美的，并且所有元素看起来像是一起移动和调整大小。
- en: '`CoordinatorLayout` defines two major ways to manipulate its child widgets--anchors
    and behaviors:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`CoordinatorLayout`定义了两种主要的操纵子小部件的方式——锚点和行为：'
- en: '**Anchors** are by far the simpler of these two; they simply attach one widget
    to another widget. The anchors respond to the `layout_gravity` attribute and a
    special `layout_anchorGravity` attribute to determine exactly where the anchored
    widget should appear relatively to the widget it''s attached to.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**锚点**是这两种方式中较为简单的一种；它只是将一个小部件附着到另一个小部件上。锚点响应`layout_gravity`属性和特殊的`layout_anchorGravity`属性，以确定锚定小部件相对于它所附着的小部件应该出现在哪个位置。'
- en: '**Behaviors** are more complex; they are entire classes that can be used to
    manipulate the widget in any way based on other widgets (known as its **dependencies**).
    Several classes define their own behavior classes that should be used when they
    are declared within a `CoordinatorLayout`. For example, `FloatingActionButton`
    declares a `FloatingActionButton.Behavior` class that will hide the button if
    its anchor-point approaches too close to the end of the screen, and make it reappear
    when there is enough space again. This showing and hiding behavior is even accompanied
    by an animation.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行为**更复杂；它们是完整的类，可以根据其他小部件（称为其**依赖项**）以任何方式操作小部件。几个类定义了自己的行为类，当它们在`CoordinatorLayout`内声明时应该使用。例如，`FloatingActionButton`声明了一个`FloatingActionButton.Behavior`类，当其锚点接近屏幕末端时，将隐藏按钮，并在有足够空间时再次出现。这种显示和隐藏行为甚至伴随着动画。'
- en: Coordinating the Overview Screen
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协调概览屏幕
- en: The Overview screen you built in [Chapter 7](22614b94-ebc1-40cb-8f19-3bd00ee2478b.xhtml),
    *Creating Overview Screens*, is a perfect candidate for a `CoordinatorLayout`.
    To start with, the allowance overview bar can be made to collapse, and unfold
    as the user scrolls. This allows more space for the claim items on the screen
    as they are scrolling, and by expanding the overview again when they scroll upward,
    the user doesn't have to scroll all the way to the top to get the overview back.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你在[第7章](22614b94-ebc1-40cb-8f19-3bd00ee2478b.xhtml)，*创建概览屏幕*中构建的概览屏幕是`CoordinatorLayout`的完美候选者。首先，允许概览栏可以折叠，并在用户滚动时展开。这为屏幕上的索赔项提供了更多空间，当他们向上滚动时再次展开概览，用户不需要滚动到顶部以获取概览。
- en: 'This behavior won''t just use the `CoordinatorLayout`, but will also need the
    help of the `AppBarLayout` and `CollapsingToolbarLayout` classes as you''ll need
    to take control of the Material Design scaffolding to make it work. Follow these
    steps to move the allowance overview into the header bar and make it collapse:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为不仅会使用`CoordinatorLayout`，还需要`AppBarLayout`和`CollapsingToolbarLayout`类的帮助，因为你需要控制Material
    Design脚手架以使其工作。按照以下步骤将允许概览移动到标题栏并使其折叠：
- en: First, open the `AndroidManifest` file from the manifests folder in the project
    tree (use the Android perspective).
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，从项目树中的`manifests`文件夹打开`AndroidManifest`文件（使用Android视角）。
- en: 'Find the `OverviewActivity` entry and add a theme attribute that will tell
    the system not to provide a system `ActionBar`, because you''ll be adding your
    own:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到`OverviewActivity`条目并添加一个主题属性，告诉系统不要提供系统`ActionBar`，因为你会添加自己的：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, open the `activity_overview` layout file and change to the text mode. Remove
    the `FrameLayout` and all of its contents; you'll need to completely rewrite this
    file.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`activity_overview`布局文件，切换到文本模式。删除`FrameLayout`及其所有内容；你需要完全重写这个文件。
- en: 'Create the `CoordinatorLayout` root element with all the standard namespaces
    and context. Note that this time you''ll tell the system that this widget will
    fit to the root window, and not act as *contents*:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用所有标准命名空间和上下文创建`CoordinatorLayout`根元素。请注意，这次你需要告诉系统这个小部件将适应根窗口，而不是作为*内容*：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, create the `AppBarLayout` element within the `CoordinatorLayout`; again,
    you''ll tell the system that the `AppBarLayout` fits to the system window and
    is not to be treated as normal *content* widgets:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`CoordinatorLayout`中创建`AppBarLayout`元素；再次提醒系统，`AppBarLayout`应适应系统窗口，不应被视为普通*内容*小部件：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Use the code-assistance for the `layout_height` to create a new dimension resource
    named `app_bar_height`, and assign it a value of `180dp`:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`layout_height`的代码辅助功能创建一个名为`app_bar_height`的新维度资源，并分配一个值为`180dp`：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Within the `AppBarLayout`, you need to declare the `CollapsingToolbarLayout`.
    This will handle the collapsing and expanding of the toolbar and other widgets
    as the user scrolls. You use the `layout_scrollFlags` to tell it how to collapse
    and expand, but it''s important to note that it''s actually the `AppBarLayout`
    that takes care of these, so any children of `AppBarLayout` can use these flags.
    In this particular case, we''ll be telling it to collapse when the user scrolls
    down the list of items, but not to exit (vanish) completely, and to reenter as
    soon as the user starts to scroll up the list again:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AppBarLayout`内部，你需要声明`CollapsingToolbarLayout`。这将处理工具栏和其他小部件的折叠和展开，当用户滚动时。你使用`layout_scrollFlags`来告诉它如何折叠和展开，但重要的是要注意，实际上是`AppBarLayout`负责这些操作，所以`AppBarLayout`的任何子项都可以使用这些标志。在这种情况下，我们将告诉它，当用户滚动查看项目列表时进行折叠，但不要完全退出（消失），当用户开始向上滚动列表时立即重新进入：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, the `CollapsingToolbarLayout` declares its `contentScrim`
    as `?attr/colorPrimary`. The attributes `?` syntax is a type of lookup that is
    used with theming. It tells the resource-system to look up that attribute in the
    theme, rather than directly referencing the attribute.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`CollapsingToolbarLayout`将其`contentScrim`声明为`?attr/colorPrimary`。属性`?`语法是与主题一起使用的一种查找类型。它告诉资源系统在主题中查找该属性，而不是直接引用属性。
- en: 'Within the `CollapsingToolbarLayout`, you''ll need to declare a `Toolbar` widget.
    This widget will take the place of the system `ActionBar`. We use the `layout_collapseMode`
    to tell the `CollapsingToolbarLayout` to *pin* the `Toolbar` to the top of the
    screen once it has been collapsed (rather than having it vanish completely):'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CollapsingToolbarLayout`内部，你需要声明一个`Toolbar`小部件。这个小部件将取代系统`ActionBar`的位置。我们使用`layout_collapseMode`来告诉`CollapsingToolbarLayout`，一旦折叠，就将`Toolbar`固定在屏幕顶部（而不是让它完全消失）：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After the `Toolbar` widget, you can declare the `AllowanceOverviewFragment`;
    it will use the `parallax` collapse mode and will disappear as the use scrolls
    down the list of claim items:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Toolbar`小部件之后，你可以声明`AllowanceOverviewFragment`；它将使用`parallax`折叠模式，并在用户滚动查看索赔项目列表时消失：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'That concludes your new `AppBarLayout` structure; now you need to add the `RecyclerView`
    in after the `AppBarLayout` and tell the `CoordinatorLayout` that it is scrolling
    content using the `layout_behaviour` attribute. This will tell the `CoordinatorLayout`
    that when the `RecyclerView` is scrolled, the `AppBarLayout` should react to the
    scrolling:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就完成了你的新`AppBarLayout`结构；现在你需要在`AppBarLayout`之后添加`RecyclerView`，并告诉`CoordinatorLayout`使用`layout_behaviour`属性，它正在滚动内容。这将告诉`CoordinatorLayout`，当`RecyclerView`滚动时，`AppBarLayout`应该对滚动做出反应：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `RecyclerView` declared that its behavior references a string resource
    by the name `appbar_scrolling_view_behavior`, but you haven''t declared any such
    resource in your `strings.xml` file, so why doesn''t the code assistant complain?
    This is a string resource declared by the `CoordinatorLayout` support library,
    and it gets merged into your application resources during the build. Its contents
    is the full class-name for the scrolling view `Behaviour` implementation (that
    is: ).'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 声明的`RecyclerView`其行为引用了一个名为`appbar_scrolling_view_behavior`的字符串资源，但你没有在`strings.xml`文件中声明这样的资源，所以为什么代码助手没有抱怨？这是一个由`CoordinatorLayout`支持库声明的字符串资源，它在构建过程中合并到你的应用程序资源中。其内容是滚动视图`Behaviour`实现的完整类名（即：）。
- en: 'The final element in your `CoordinatorLayout` should be the `NewClaimItemFloatingActionButtonFragment`,
    which will automatically gain special behavior within the `CoordinatorLayout`
    because of how the `FloatingActionButton` class is written:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`CoordinatorLayout`中的最后一个元素应该是`NewClaimItemFloatingActionButtonFragment`，由于`FloatingActionButton`类的编写方式，它将在`CoordinatorLayout`中自动获得特殊行为：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `FloatingActionButton` class declares a default `Behaviour` class that
    the `CoordinatorLayout` looks for when any child is added to it. This defines
    how the `FloatingActionButton` is positioned on the screen, when it should disappear,
    reappear, and even move relative to panels that may appear at the bottom of the
    screen (such as snackbars). The declaration is made using a publicly accessible
    annotation:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`FloatingActionButton`类声明了一个默认的`Behaviour`类，当任何子项被添加到`CoordinatorLayout`中时，`CoordinatorLayout`会查找这个类。这定义了`FloatingActionButton`在屏幕上的位置，以及它应该在何时消失、重新出现，甚至相对于可能出现在屏幕底部的面板（如snackbars）移动。声明是通过一个公开可访问的注解来完成的：'
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Due to how your application has been structured, the `OverviewActivity` class
    doesn''t need to be modified for this new layout to work. It will still automatically
    populate the `RecyclerView` with the `ClaimItem` objects, and the fragments will
    communicate through the database. It is, however, useful to make the new `Toolbar`
    widget act as the `ActionBar` for the `OverviewActivity`; you can do this by changing
    the `onCreate` method to call `setSupportActionBar`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您的应用程序的结构，`OverviewActivity` 类不需要修改即可使新布局工作。它仍然会自动用 `ClaimItem` 对象填充 `RecyclerView`，并且片段将通过数据库进行通信。然而，使新的
    `Toolbar` 小部件充当 `OverviewActivity` 的 `ActionBar` 是有用的；您可以通过将 `onCreate` 方法更改为调用
    `setSupportActionBar` 来实现这一点：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Swiping to delete
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向右滑动删除
- en: While you have a way for your users to create claim items, the users have no
    way to delete the claim items that they have created. A common pattern in lists
    on mobile apps is to allow the user to swipe right to dismiss or delete items.
    `RecyclerView` provides some excellent and easy-to-use structures to enable this
    sort of behavior; however, it's always important to ensure that users don't delete
    items by mistake.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您的用户有创建索赔项的方法，但他们没有删除自己创建的索赔项的方法。在移动应用列表中，一个常见的模式是允许用户向右滑动来删除或删除项目。`RecyclerView`
    提供了一些优秀且易于使用的结构来启用这种行为；然而，始终确保用户不会意外删除项目是非常重要的。
- en: In the past, most user interfaces used confirmation dialogs when executing destructive
    actions. However, these "are you sure" dialogs are a horrible distraction for
    most users, because such messages violate a key principle--the application assumes
    that the user probably doesn't want to perform an action that they just took.
    In reality, the user probably did mean to delete the item, but the application
    interrupts them to ask whether they're sure about their choice. A much better
    behavior is to assume that the user does want to take the action, but then to
    give them a way to undo their action if they have made a mistake. Material Design
    has a design pattern and widget dedicated specifically to this sort of task--the
    `Snackbar`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，大多数用户界面在执行破坏性操作时都会使用确认对话框。然而，这些“你确定吗”对话框对大多数用户来说都是一种糟糕的干扰，因为这些消息违反了一个关键原则——应用程序假设用户可能不想执行他们刚刚采取的操作。实际上，用户可能确实打算删除该项目，但应用程序会打断他们，询问他们是否确定自己的选择。更好的行为是假设用户确实想要采取行动，但如果他们犯了错误，则提供一种撤销操作的方法。Material
    Design 有一个专门针对此类任务的设计模式和控件——`Snackbar`。
- en: 'In Material Design language, the `Snackbar` is a small bar that can appear
    at the bottom of the screen, providing the user with information and possible
    actions that they can take based on the information given. The most commonly seen
    use is when something is deleted, and the user is given the chance to undo the
    delete. Undo actions might appear to be challenging, but they''re actually very
    simple to carry out if correctly wrapped in a `Command` class. Follow these steps
    to add a swipe-to-delete action and an undo option to the travel claims application:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Material Design 术语中，`Snackbar` 是一个可以出现在屏幕底部的小栏，向用户提供信息以及基于所提供信息的可能操作。最常见的用法是在删除某物时，用户有机会撤销删除。撤销操作可能看起来很复杂，但如果正确地封装在
    `Command` 类中，实际上执行起来非常简单。按照以下步骤向旅行索赔应用程序添加向右滑动删除操作和撤销选项：
- en: Open the `DataBoundViewHolder` class in the ui package.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 ui 包中的 `DataBoundViewHolder` 类。
- en: 'Your new classes will need a simple way to access the items from the `DataBoundViewHolder`,
    but the `ViewDataBinding` doesn''t offer a `getVariable` method, so you''ll need
    to keep it in a class field and provide a getter method:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的新类将需要一个简单的方法来访问 `DataBoundViewHolder` 中的项目，但 `ViewDataBinding` 并没有提供 `getVariable`
    方法，因此您需要将其保存在类字段中并提供一个获取方法：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You''ll also need to modify the `setItem` method to capture this field:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还需要修改 `setItem` 方法以捕获此字段：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Open the `OverviewActivity` source file in Android Studio.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Android Studio 中打开 `OverviewActivity` 的源文件。
- en: 'At the bottom of the `OverviewActivity` class, you''ll need to declare a new
    `ActionCommand` class that will encapsulate both the delete action and the undo
    operation. Unlike most other `ActionCommand` classes, this one is not reusable
    and takes no arguments:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `OverviewActivity` 类的底部，您需要声明一个新的 `ActionCommand` 类，该类将封装删除操作和撤销操作。与大多数其他
    `ActionCommand` 类不同，这个类是不可重用的，并且不接受任何参数：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The new `DeleteClaimItemCommand` class will need a reference to the `ClaimDatabase`,
    and will also have a `ClaimItem` field that it will delete and optionally restore:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新的 `DeleteClaimItemCommand` 类需要一个对 `ClaimDatabase` 的引用，并且还将有一个 `ClaimItem` 字段，它将删除并可选地恢复：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `onBackground` implementation deletes the `ClaimItem` object from the database,
    but the `DeleteClaimItemCommand` keeps a reference to the in-memory implementation
    if the user decides to restore it:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`onBackground` 的实现将从数据库中删除 `ClaimItem` 对象，但 `DeleteClaimItemCommand` 会保留对内存中实现的引用，如果用户决定恢复它：'
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This code does not delete the `Attachments` related to the `ClaimItem`, which
    will cause the application to leak attachment files and database rows. In practice,
    you would also want to ensure that the attachments are cleaned up as well by copying
    the behavior used for `ClaimItem`, but that is beyond the scope of this example.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码不会删除与 `ClaimItem` 相关的 `Attachments`，这会导致应用程序泄漏附件文件和数据库行。在实际应用中，你还希望确保附件也被清理，就像对
    `ClaimItem` 使用的行为一样，但这超出了本例的范围。
- en: 'The `onForeground` implementation will need to display a `Snackbar` notification
    telling the user that the item was deleted; for that, you''ll need a localizable
    message. The `Context` class offers a convenience `getString` method that will
    generate a formatted string from the application resources:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`onForeground` 的实现需要显示一个 `Snackbar` 通知，告诉用户项目已被删除；为此，你需要一个可本地化的消息。`Context`
    类提供了一个方便的 `getString` 方法，它将从应用程序资源生成格式化的字符串：'
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Use the code assistance to create a new string resource named `msg_claim_item_deleted`:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用代码辅助功能创建一个名为 `msg_claim_item_deleted` 的新字符串资源：
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: These strings follow the formatting rules defined in `java.util.Formatter` or
    `String.format`, allowing you to create relatively complex formatting rules. By
    providing different `strings.xml` files for different languages and formats like
    this, you can very easily localize most strings in your application.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字符串遵循 `java.util.Formatter` 或 `String.format` 中定义的格式化规则，允许你创建相对复杂的格式化规则。通过为不同语言和格式提供不同的
    `strings.xml` 文件，你可以非常容易地本地化应用程序中的大多数字符串。
- en: 'In the `onForeground` method, you''ll need to grab a reference to the `CoordinatorLayout`
    as a base for the `Snackbar`:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onForeground` 方法中，你需要获取 `CoordinatorLayout` 的引用作为 `Snackbar` 的基础：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, create the `Snackbar` object, specifying its undo action text, and use
    the `DeleteClaimItemCommand` as the action handler (`OnClickListener`):'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建 `Snackbar` 对象，指定其撤销动作文本，并使用 `DeleteClaimItemCommand` 作为动作处理程序（`OnClickListener`）：
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Use the code assistance on the `R.string.undo` reference to create a new string
    resource for the text of the `undo` action:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用代码辅助功能在 `R.string.undo` 引用上创建一个新的字符串资源，用于 `undo` 动作的文本：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If the user clicks on the undo action, the `DeleteClaimItemCommands` and `onClick`
    methods will be invoked. It can then use its cached reference to the deleted `ClaimItem`
    to restore it in the database:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户点击撤销动作，将调用 `DeleteClaimItemCommands` 和 `onClick` 方法。然后，它可以使用其缓存的已删除 `ClaimItem`
    引用将其恢复到数据库中：
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As another inner-class to the `OverviewActivity`, you''ll need a class to provide
    the action definition and handling for the *swipe-to-delete* behavior. This new
    class will extend the `SimpleCallback` class of the `ItemTouchHelper` class, which
    provides the handling for the movement gesture recognition:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为 `OverviewActivity` 的另一个内部类，你需要一个类来提供对 *滑动删除* 行为的动作定义和处理。这个新类将扩展 `ItemTouchHelper`
    类中的 `SimpleCallback` 类，该类提供了对移动手势识别的处理：
- en: '[PRE24]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `SimpleCallback` constructor takes two sets of "flags" in the form of `int`
    values. These are simply a number of numbers that you can binary "or" (using the
    `|` operator) together. These define the different gestures to allow and manage.
    The first of these are the flags for different types of "move" gestures that can
    be used to reorder the items in a `RecyclerView` (leaving this as zero indicates
    that no move gestures should be recognized). The second flag''s argument is for
    "swipe" gestures, which are what we''re interested in here:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SimpleCallback` 构造函数接受两套以 `int` 值形式表示的“标志”。这些标志实际上是一系列可以二进制“或”操作（使用 `|` 操作符）的数字。这些定义了允许和管理不同手势。其中第一个是用于不同类型的“移动”手势的标志，这些手势可以用来重新排列
    `RecyclerView` 中的项目（将此设置为零表示不应识别任何移动手势）。第二个标志的参数是用于“滑动”手势的，这是我们在这里感兴趣的内容：'
- en: '[PRE25]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `SimpleCallback` class requires that you declare handler methods for moving
    and swiping, even though the class will not deal with movement gestures. You''ll
    need to declare `onMove`, but the class can just return `false` as its implementation:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SimpleCallback`类要求你声明用于移动和滑动的处理方法，即使该类不会处理移动手势。你需要声明`onMove`，但该类可以简单地返回`false`作为其实现：'
- en: '[PRE26]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, you can define the implementation of the `onSwipe` method, which will
    create a `DeleteClaimItemCommand` and execute it:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你可以定义`onSwipe`方法的实现，这将创建一个`DeleteClaimItemCommand`并执行它：
- en: '[PRE27]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, to attach the `SwipeToDeleteCallback` to the `RecyclerView`, you need
    to wrap it using the `ItemTouchHelper` class, and attach that to your `RecyclerView`
    instance at the bottom of the `onCreate` method:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，要将`SwipeToDeleteCallback`附加到`RecyclerView`上，你需要使用`ItemTouchHelper`类将其包装，并在`onCreate`方法的底部将其附加到你的`RecyclerView`实例上：
- en: '[PRE28]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Elevating widgets
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提升小部件
- en: An excellent way of highlighting one widget over the others on the screen is
    to make it appear over the others on the screen, not two-dimensionally, but floating
    above them as though in three-dimensions. This is already a clear pattern if you
    look at the `FloatingActionButton` classes; they don't just overlap other widgets,
    but they have a shadow and appear to float in space (hence the class name `FloatingActionButton`).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕上突出显示一个小部件而不是其他小部件的一个很好的方法是让它出现在其他小部件之上，不是二维的，而是像在三维空间中一样浮在它们之上。如果你查看`FloatingActionButton`类，这已经是一个清晰的模式；它们不仅仅重叠其他小部件，而且它们有阴影，看起来像在空间中浮动（因此类名为`FloatingActionButton`）。
- en: One of the great features in the Android widget library is that the `View` class
    defines the notion of elevation, which makes it usable by every widget in the
    toolkit. The elevation of a widget doesn't affect its two-dimensional position
    or size, but does cause it to produce a shadow that will be correctly shaded as
    though the widget is floating in three-dimensions. This can be used to create
    an amazing effect when you need to draw attention to a message, or when the user
    is repositioning a widget on the screen (for example, reorganizing a list of reminders).
    Given that most of a Material Design user interface is flat, adding a three-dimensional
    elevation instantly makes a widget stand out for the user.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Android小部件库中的伟大功能之一是`View`类定义了海拔的概念，这使得它可以通过工具包中的每个小部件使用。小部件的海拔不会影响其二维位置或大小，但它会导致它产生一个阴影，该阴影将正确着色，就像小部件在三维空间中浮动一样。这可以在你需要吸引对消息的注意，或者当用户在屏幕上重新定位小部件时（例如，重新组织提醒列表）时创建惊人的效果。鉴于大多数Material
    Design用户界面都是平面的，添加三维海拔可以立即让小部件在用户面前脱颖而出。
- en: Much like the borders and shadow of a `CardView` widget, when you use elevation,
    you need to ensure that the shadow is not clipped by the parent widget or the
    padding attributes. Use the `clipChildren` and `clipToPadding` attributes to control
    this.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与`CardView`小部件的边框和阴影类似，当你使用海拔时，你需要确保阴影不会被父小部件或填充属性裁剪。使用`clipChildren`和`clipToPadding`属性来控制这一点。
- en: 'Follow these steps to add an elevation effect to the swipe-to-delete behavior
    callback:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤向滑动删除行为回调添加海拔效果：
- en: Open the `OverviewActivity` and find the `SwipeToDeleteCallback` inner class.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`OverviewActivity`并找到`SwipeToDeleteCallback`内部类。
- en: 'The class will need to be able to reset the elevation if the user "drops" an
    item after picking it up to delete it. For this, the `SwipeToDeleteCallback` class
    will need a field with the default card elevation:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户在拾起项目后“放下”项目以删除它，则该类需要能够重置海拔。为此，`SwipeToDeleteCallback`类需要一个具有默认卡片海拔的字段：
- en: '[PRE29]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Every time a child of the `RecyclerView` is drawn after being picked up, the
    `ItemTouchHelper` allows you to override the drawing behavior. In your case, you
    want to adjust the elevation of the card relative to how far right the user has
    dragged it. In order to work on older versions of Android, this code uses the
    `ViewCompat` class to change the elevation:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次在`RecyclerView`的子项被拾起后绘制，`ItemTouchHelper`允许你覆盖绘制行为。在你的情况下，你想要根据用户拖动的距离调整卡片相对于右侧的海拔。为了在旧版本的Android上工作，此代码使用`ViewCompat`类来更改海拔：
- en: '[PRE30]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Once the card is released by the user, we need to clear the elevation value
    by setting it back to its default; the `ItemTouchHelper` will invoke the `clearView`
    callback when the user drops an item:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦用户释放卡片，我们需要通过将其重置为默认值来清除海拔值；当用户放下一个项目时，`ItemTouchHelper`将调用`clearView`回调：
- en: '[PRE31]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Once you''ve implemented this behavior, the user will receive secondary visual
    feedback on the swipe to delete gesture, as the card they drag will appear to
    rise above the others as they pull it to the right. It''ll also do the reverse
    and appear to descend back to its normal elevation if they drag it to the left
    again. This elevation feedback can be even more useful on interfaces where the
    user can change the position of the cards in a list (for example, in a to-do list).
    Note that as the card''s elevation increases, it casts a shadow on the cards both
    below and above it:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦实现了这种行为，用户在滑动删除手势时将收到二级视觉反馈，因为当他们将卡片向右拖动时，卡片看起来会升到其他卡片之上。如果他们再次将卡片向左拖动，它也会反向动作，看起来会下降回到正常的高度。这种高度反馈在用户可以改变列表中卡片位置的用户界面（例如，待办事项列表）上会更加有用。注意，随着卡片高度的增加，它会在其下方和上方的卡片上投下阴影：
- en: '![](img/6ba8e1ad-4842-451f-b1f0-df6616b8cf26.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6ba8e1ad-4842-451f-b1f0-df6616b8cf26.png)'
- en: Building layouts using grids
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用网格构建布局
- en: When building screens, it's common to want specific widgets to appear the same
    size and shape as other widgets. This is often achieved using flexible grid models
    for the layout. By dividing the screen into a number of cells, and having each
    widget occupy one or more cells, you can create very complex layouts that will
    stretch to any screen size. However, this traditional model is completely outdated
    when faced with `ConstraintLayout`, which is capable of maintaining complex relationships
    between widgets without the need for a grid.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建屏幕时，通常希望特定的部件与其它部件具有相同的大小和形状。这通常是通过使用灵活的网格模型来实现布局的。通过将屏幕划分为若干个单元格，并让每个部件占据一个或多个单元格，你可以创建非常复杂的布局，这些布局可以扩展到任何屏幕大小。然而，当面对`ConstraintLayout`时，这种传统模型就显得完全过时了，因为`ConstraintLayout`能够在不使用网格的情况下维护部件之间的复杂关系。
- en: In most situations, `ConstraintLayout` should be more than capable of managing
    any complex layout you choose to design, and will be much more flexible than a
    grid/table layout manager. Unlike a grid-based layout engine, `ConstraintLayout`
    is much more flexible when dealing with widgets that are sized based on a font
    or images that can be various sizes, depending on the physical screen size and
    pixel-density. While `GridLayout` will adjust the size of the cells to accommodate
    such widgets, they are still confined by grid lines.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，`ConstraintLayout`应该能够管理你选择的任何复杂布局，并且会比网格/表格布局管理器更加灵活。与基于网格的布局引擎不同，`ConstraintLayout`在处理基于字体大小或图像大小的部件时更加灵活，这些图像的大小取决于物理屏幕大小和像素密度。虽然`GridLayout`会调整单元格的大小以适应这些部件，但它们仍然受限于网格线。
- en: However, every now and then, you'll need to build a layout based on grid cells.
    For situations like this, you'll want to use the `GridLayout` class. `GridLayout`
    allows you to define layouts based on an invisible grid, where each widget can
    take up one or more cells, and the size of each row and column is flexible; that
    is, each column can be a different width, and each row can be a different height.
    It's important to remember that `GridLayout` is not intended for displaying large
    tables of data, but rather for laying out screens that favor a grid-like structure.
    If you need to present your user with a scrolling grid (for example, of icon images),
    then a better model to be used is the `RecyclerView` with a `GridLayoutManager`,
    as this will scale to virtually any number of child components.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，时不时地，你可能需要基于网格单元格构建布局。对于这种情况，你将希望使用`GridLayout`类。`GridLayout`允许你基于一个不可见的网格定义布局，其中每个部件可以占据一个或多个单元格，每一行和每一列的大小都是灵活的；也就是说，每一列可以有不同的宽度，每一行可以有不同的高度。重要的是要记住，`GridLayout`并不适用于显示大量数据的大表格，而是用于布局那些偏好网格结构的屏幕。如果你需要向用户展示一个可滚动的网格（例如，图标图像的网格），那么更好的模型是使用带有`GridLayoutManager`的`RecyclerView`，因为它可以扩展到几乎任何数量的子组件。
- en: 'There are two different implementations of `GridLayout` in Android: one is
    in the platform core APIs, and the other is in the support v7 APIs. For compatibility
    reasons, it''s typically best to use the class from the support package as it
    includes many of the more recently added features that might not appear on the
    platform implementation.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，`GridLayout`有两种不同的实现：一种是在平台核心API中，另一种是在支持v7 API中。出于兼容性的原因，通常最好使用支持包中的类，因为它包括了最近添加的许多可能不在平台实现中出现的特性。
- en: 'To explore the `GridLayout` a bit, let''s take a look at how you will implement
    the *Capture Claim Details* card using `GridLayout` instead of `ConstraintLayout`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索`GridLayout`，让我们看看您将如何使用`GridLayout`而不是`ConstraintLayout`来实现*捕获索赔详情*卡片：
- en: First, you'll need to add the `GridLayout` implementation to your project. Open
    the Gradle Scripts in the project tree and open the build.gradle for the app module
    (use the Android perspective).
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要将`GridLayout`实现添加到您的项目中。在项目树中打开Gradle脚本，并打开app模块的build.gradle文件（使用Android视角）。
- en: 'In the dependencies list, add a dependency for the grid-layout module:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在依赖项列表中，添加对grid-layout模块的依赖项：
- en: '[PRE32]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The version number at the end (in this case, `26.0.0`) must exactly match the
    version number of the `appcompat` module your application references. If these
    versions don't match exactly, it can lead to instabilities and in some cases,
    your application won't even compile. Change the version number to match the one
    declared on the `appcompat` reference in your `build.gradle` before continuing
    to the next step.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 末尾的版本号（在本例中为`26.0.0`）必须与您的应用程序引用的`appcompat`模块的版本号完全匹配。如果这些版本不匹配，可能会导致不稳定，在某些情况下，甚至无法编译应用程序。在继续下一步之前，将版本号更改为与您的`build.gradle`中声明的`appcompat`引用上的版本号相匹配。
- en: Save the file, and synchronize the project using the Sync Now link that appears
    at the top of the editor.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，并使用编辑器顶部的Sync Now链接同步项目。
- en: Right-click on the res | layout directory in the project file tree, and select
    New | Layout resource file.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目文件树中，右键单击res | layout目录，然后选择New | Layout resource file。
- en: Name the new file `fragment_capture_claim_grid`.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新文件命名为`fragment_capture_claim_grid`。
- en: 'Change the root element to `android.support.v7.widget.GridLayout`:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将根元素更改为`android.support.v7.widget.GridLayout`：
- en: '![](img/d0713e73-432f-47b0-96f3-47fb7083ee73.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d0713e73-432f-47b0-96f3-47fb7083ee73.png)'
- en: Change to the Text mode editor.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到文本模式编辑器。
- en: 'As you''re using the support libraries `GridLayout` implementation, several
    of the XML attributes will be in the `app` namespace rather than the platform
    (`android`) namespace. You''ll need to add the `app` namespace to the `GridLayout`
    declaration:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于您正在使用`GridLayout`的支持库实现，XML属性中的许多将位于`app`命名空间而不是平台（`android`）命名空间中。您需要将`app`命名空间添加到`GridLayout`声明中：
- en: '[PRE33]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '**9.  `GridLayout` sets many of the layout attributes by default, and assumes,
    by default, that each child is in the cell, following the one before it (starting
    at the top-left cell). It allows you to specify the `columnWeight` and `rowWeight`
    attributes to define how much of the available space each cell should take up.
    Declare a `TextInputLayout` to take up 70% of the available space:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**9.  `GridLayout`默认设置了许多布局属性，并默认假设每个子元素都在单元格中，跟随其前面的单元格（从左上角的单元格开始）。它允许您指定`columnWeight`和`rowWeight`属性来定义每个单元格应占用多少可用空间。声明一个`TextInputLayout`来占用70%的可用空间：**'
- en: '[PRE34]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The preceding `TextInputLayout` widget only occupies a single cell within the
    `GridLayout`, but that cell has been told to take up 70% of the available horizontal
    space when rendering.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`TextInputLayout`小部件仅占用`GridLayout`中的一个单元格，但该单元格已被告知在渲染时占用70%的可用水平空间。
- en: 'Next, declare the amount `TextInputLayout`; this will also only occupy a single
    cell, but we''ll want it to occupy the remaining 30% of the horizontal space:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，声明`TextInputLayout`的数量；这将仅占用单个单元格，但我们希望它占用剩余的30%水平空间：
- en: '[PRE35]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, we want to declare a `DatePickerLayout` for the user to select the date,
    but we need to tell the `GridLayout` to put it on the next row. You do this using
    the `row` and `column` attributes. This widget also needs to take up the full
    width of the `GridLayout`, which means it needs to occupy two columns, which is
    done using the `columnSpan` attribute:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们想要声明一个`DatePickerLayout`供用户选择日期，但我们需要告诉`GridLayout`将其放在下一行。您可以使用`row`和`column`属性来完成此操作。此小部件还需要占用`GridLayout`的整个宽度，这意味着它需要占用两个列，这是通过使用`columnSpan`属性来完成的：
- en: '[PRE36]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If you take a look in the Design view, you''ll note that this layout looks
    almost identical to the one you wrote in [Chapter 2](6ed5cfcb-b233-4bf0-b6fd-012432897224.xhtml),
    *Designing Form Screens*, for capturing the claims. The biggest difference is
    that the `ConstraintLayout` uses a fixed minimum size for the Amount, while this
    layout uses relative sizes by manipulating the weights of the grid cells. The
    resulting layout should look like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看设计视图，你会注意到这个布局几乎与你写在[第2章](6ed5cfcb-b233-4bf0-b6fd-012432897224.xhtml)，“设计表单屏幕”，中捕获索赔的那个布局一模一样。最大的区别是，`ConstraintLayout`为金额使用了一个固定的最小尺寸，而此布局通过操作网格单元的权重使用相对尺寸。生成的布局应该看起来像这样：
- en: '![](img/7947bd9d-6e56-49b9-a984-c0f0eb3c159f.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7947bd9d-6e56-49b9-a984-c0f0eb3c159f.png)'
- en: Stack view
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈视图
- en: 'Sometimes, it''s useful to be able to display long lists of items with only
    one item visible at a time, for example, the list of attachments for a `ClaimItem`.
    In this case, you can use the side-to-side `ViewPager` as you''ve already done,
    but there is another option--the `StackView`. The `StackView` class presents its
    contents as a three-dimensional stack of cards, with the "top" card fully visible,
    and some of the cards "behind it," as shown:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，能够只显示一次一个项目的同时显示长列表的项目是有用的，例如，`ClaimItem`的附件列表。在这种情况下，你可以使用你之前已经使用过的侧向`ViewPager`，但还有一个选项——`StackView`。`StackView`类将其内容呈现为三维卡片堆叠，其中“顶部”卡片完全可见，而一些卡片“在其后面”，如下所示：
- en: '![](img/97eae5f4-0729-43ca-af85-4007e5f7ab7b.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/97eae5f4-0729-43ca-af85-4007e5f7ab7b.png)'
- en: This is often a very useful pattern, as it provides the user with plenty of
    screen space to view the top item, while also being able to see that there are
    other items that can be viewed. This makes it ideal for displaying photos or large
    cards of data. It's very similar to how Android displays the list of running applications
    when you tap on the "Recent Apps" button on a device.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是一个非常有用的模式，因为它为用户提供足够的屏幕空间来查看顶部项目，同时也能看到还有其他可以查看的项目。这使得它非常适合显示照片或大型数据卡片。这与你在设备上点击“最近应用”按钮时Android显示正在运行的应用程序列表的方式非常相似。
- en: 'The `StackView` is a classic `Adapter` view, and works using the same `Adapter`
    implementations as `ListView` or `GridView`. If done correctly, you can write
    code that can be used in any of these classes; follow these steps to build a simple
    `StackView` and `Adapter` implementation that can be used to preview the `Attachment`
    differently:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`StackView`是一个经典的`Adapter`视图，它使用与`ListView`或`GridView`相同的`Adapter`实现。如果做得正确，你可以编写可以在这些类中使用的代码；按照以下步骤构建一个简单的`StackView`和`Adapter`实现，以便以不同的方式预览`附件`：'
- en: Right-click on the ui.attachments package in the project tree, and select New|
    Java Class.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目树中右键单击`ui.attachments`包，然后选择“新建| Java类”。
- en: Name the new class `AttachmentListAdapter`.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新类命名为`AttachmentListAdapter`。
- en: Change the Superclass to `android.widget.BaseAdapter`.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将超类改为`android.widget.BaseAdapter`。
- en: Click on OK to create the new class.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“确定”以创建新类。
- en: 'In the new `AttachmentListAdapter` class, declare a `List` of `Attachment`
    objects to present to the user:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的`AttachmentListAdapter`类中，声明一个用于向用户呈现的`Attachment`对象`List`：
- en: '[PRE37]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Create a constructor to observe a `LiveData` and assign the `List` of attachments
    and notify the `StackView` when things change:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个构造函数来观察`LiveData`并分配附件的`List`，并在事情发生变化时通知`StackView`：
- en: '[PRE38]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Much like a `RecyclerView.Adapter` implementation, the `BaseAdapter` needs
    a method to access the number of items it''s expected to present:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与`RecyclerView.Adapter`实现类似，`BaseAdapter`需要一个方法来访问它预期呈现的项目数量：
- en: '[PRE39]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Unlike the `RecyclerView.Adapter` implementations, however, a `BaseAdapter`
    is expected to expose the underlying data directly. It''s also required to expose
    a unique ID for each element of data:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，与`RecyclerView.Adapter`实现不同，`BaseAdapter`预期直接暴露底层数据。它还必须暴露每个数据元素的唯一ID：
- en: '[PRE40]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Also, unlike a `RecylcerView.Adapter`, there is only a single method to create
    and reuse the existing view items, as well as bind the data to them. In this method,
    the second argument may be `null`, but can also be an existing view that is expecting
    to be recycled:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，与`RecyclerView.Adapter`不同，创建和重用现有视图项以及将数据绑定到它们的方法只有一个。在此方法中，第二个参数可以是`null`，也可以是一个期望被回收的现有视图：
- en: '[PRE41]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To use a `StackView` from a layout XML file, you simply need to declare the
    `StackView` as you would a `RecyclerView` or `ViewPager`:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从布局XML文件中使用`StackView`，你只需像声明`RecyclerView`或`ViewPager`一样声明`StackView`：
- en: '[PRE42]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, from the enclosing `Activity` or `Fragment`, you will need to set its
    `Adapter`. Much like the `RecyclerView`, the `Adapter` can also be specified from
    a data-bound layout. Here''s how the code might look in an `Activity`:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，从封装的 `Activity` 或 `Fragment` 中，您需要设置其 `Adapter`。与 `RecyclerView` 类似，`Adapter`
    也可以从数据绑定布局中指定。以下是在 `Activity` 中的代码示例：
- en: '[PRE43]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `StackView` class is an excellent way to present the user with a large number
    of larger and more visual items. It's excellent for browsing things such as photographs
    or preview graphics, and provides you with an easy-to-use three-dimensional transformation.
    Before using `StackView`, you should always consider whether the user will need
    to see the data from more than one item at a time. Sometimes, it's best to combine
    a `RecyclerView` as an "overview" with a `StackView` for viewing the individual
    items.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`StackView` 类是向用户展示大量更大、更视觉化的项目的一种极好方式。它非常适合浏览照片或预览图形，并提供易于使用的三维变换。在使用 `StackView`
    之前，您应该始终考虑用户是否需要同时查看多个项目中的数据。有时，最好将 `RecyclerView` 作为“概览”与 `StackView` 结合使用，以查看单个项目。'
- en: Test your knowledge
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: Elevation should be used for which of the following?
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该使用提升（Elevation）来做什么？
- en: When the user selects an item in a list
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户在列表中选择一个项目时
- en: To selectively highlight one item above a flat layout
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了选择性地突出显示平铺布局上方的单个项目
- en: When a user swipes to delete items
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户滑动删除项目时
- en: '`CoordinatorLayout` can be used to coordinate movement and size between which
    of these?'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CoordinatorLayout` 可以用来协调以下哪些之间的移动和大小？'
- en: The components nested in an `AppBarLayout`
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套在 `AppBarLayout` 中的组件
- en: Any of its direct child widgets
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何其直接子小部件
- en: '`Fragment` in different activities'
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同活动中的 `Fragment`
- en: To change elevation of a widget in a backward-compatible way, you need to do
    which of the mentioned?
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要以向后兼容的方式更改小部件的提升，您需要执行以下提到的哪些操作？
- en: Nest the widget in a `CardView`
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将小部件嵌套在 `CardView` 中
- en: Use the `ViewCompat` class
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ViewCompat` 类
- en: Use Java reflection to call `setElevation`
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Java 反射来调用 `setElevation`
- en: The `GridLayout` class should be used in which of the following conditions?
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下哪种情况下应使用 `GridLayout` 类？
- en: When `ConstraintLayout` is not available
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 `ConstraintLayout` 不可用时
- en: To display large tables of data
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示大量数据表格
- en: To lay out screens along grid lines
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 沿着网格线排列屏幕
- en: Summary
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Taking ownership of what is normally the system's decorations for your application
    provides you with a huge variety of additional flexibility and power. By using
    the `CoordinatorLayout` to host the scaffolding and content of your screens, you
    further extend your flexibility by allowing widgets to dynamically interact with
    each other, even when being animated. This provides you with a way to produce
    pixel-perfect screens with minimal additional work.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握通常属于系统装饰的应用程序提供了巨大的额外灵活性和功能。通过使用 `CoordinatorLayout` 来托管屏幕的框架和内容，您通过允许小部件在动画过程中动态交互进一步扩展了您的灵活性。这为您提供了以最少的额外工作制作像素完美屏幕的方法。
- en: Using layouts that cannot only dynamically change their shape, but also change
    their content using gestures such as swipe-to-dismiss to further enhance the direct
    manipulation aspects of a touchscreen user interface have been covered. At the
    same time, it's important to always consider the interactions of your user and
    when to interrupt them, especially around destructive actions. While there are
    still times where you might want to use a confirmation dialog, it's generally
    better to give users a method to undo their actions. It's often a very simple
    thing to keep the deleted entity objects in-memory until the `Snackbar` vanishes
    and is released from memory. Inserting entities that you have deleted from Room
    will actually maintain their IDs, meaning that their rows are restored exactly
    as they were before they were deleted.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不仅可以动态改变形状，还可以使用如滑动删除等手势来改变内容的布局，以进一步增强触摸屏用户界面的直接操作方面。同时，始终考虑用户的交互和何时中断它们，尤其是在破坏性行动周围非常重要。虽然有时您可能仍然想使用确认对话框，但通常更好的方法是给用户提供一种撤销操作的方法。通常，将已删除的实体对象保留在内存中，直到
    `Snackbar` 消失并从内存中释放，这是一个非常简单的事情。实际上，从 Room 中插入您已删除的实体将保持它们的 ID，这意味着它们的行将恢复到删除之前的状态。
- en: In the next chapter, we'll take a look at navigation in Android applications,
    and explore various user interface features that are provided for your user to
    navigate your application. We'll also take a look at some techniques that allow
    you to take more control of your application's navigation flow. Providing consistent
    and quality navigation makes a huge difference to your user's experience.**
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨 Android 应用程序中的导航，并了解为用户导航应用程序提供的各种用户界面功能。我们还将研究一些允许您更好地控制应用程序导航流程的技术。提供一致且高质量的导航对用户体验有着巨大的影响。**
