- en: '*Chapter 1*: Getting Started with Clean Architecture'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第一章*：开始使用清洁架构'
- en: In this chapter, we'll take you back and show you how a feature would have been
    implemented in the past while analyzing the potential issues and problems with
    that approach. Then, we'll look at some key design principles for software development
    and apply those principles to our legacy examples. After that, we'll cover the
    evolution of the Android platform and the various libraries and frameworks that
    have emerged. We'll also see how they can be integrated while adhering to various
    software design principles.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回顾过去如何实现一个功能，同时分析该方法可能存在的问题和问题。然后，我们将探讨软件开发的一些关键设计原则，并将这些原则应用于我们的遗留示例。之后，我们将介绍
    Android 平台的演变以及出现的各种库和框架。我们还将看到它们如何在遵守各种软件设计原则的同时进行集成。
- en: After that, we'll introduce clean architecture so that we know what our system
    needs to be improved and what questions we must ask, as developers, so that we
    can create a robust, scalable, maintainable, and testable application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将介绍清洁架构，以便我们知道我们的系统需要改进什么，以及作为开发者，我们必须提出哪些问题，以便我们可以创建一个健壮、可扩展、可维护和可测试的应用程序。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主要主题：
- en: The architecture of a legacy app
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遗留应用程序的架构
- en: Software design principles
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件设计原则
- en: Exploring the evolution of Android
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 Android 的演变
- en: Enter clean architecture
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进入清洁架构
- en: By the end of this chapter, you will know about the evolution of Android development,
    its architecture, and its design concepts, as well as the concept of clean architecture
    and how it can be used to build flexible, maintainable, and testable applications.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解 Android 开发的演变、其架构和设计概念，以及清洁架构的概念以及如何用它来构建灵活、可维护和可测试的应用程序。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you will need Android Studio Arctic Fox 2020.3.1 Patch 3.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您需要 Android Studio Arctic Fox 2020.3.1 补丁 3。
- en: 'The following are the hardware requirements for this chapter:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章的硬件要求：
- en: 'Windows:'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Windows:'
- en: 64-bit Microsoft® Windows® 8/10
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 64 位 Microsoft® Windows® 8/10
- en: x86_64 CPU architecture; 2nd generation Intel Core or newer, or an AMD CPU with
    support for a Windows Hypervisor
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: x86_64 CPU 架构；第二代 Intel Core 或更新的处理器，或支持 Windows Hypervisor 的 AMD CPU
- en: 8 GB of RAM or more
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少 8 GB 的 RAM 或更多
- en: 8 GB of available disk space minimum (IDE + Android SDK + Android Emulator)
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少 8 GB 的可用磁盘空间（IDE + Android SDK + Android 模拟器）
- en: 1,280 x 800 minimum screen resolution
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小屏幕分辨率 1,280 x 800
- en: 'Mac:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Mac:'
- en: macOS® 10.14 (Mojave) or higher
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: macOS® 10.14 (Mojave) 或更高版本
- en: ARM-based chips, or 2nd generation Intel Core or newer with support for Hypervisor.Framework
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于 ARM 的芯片，或支持 Hypervisor.Framework 的第二代 Intel Core 或更新的处理器
- en: 8 GB of RAM or more
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少 8 GB 的 RAM 或更多
- en: 8 GB of available disk space minimum (IDE + Android SDK + Android Emulator)
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少 8 GB 的可用磁盘空间（IDE + Android SDK + Android 模拟器）
- en: 1,280 x 800 minimum screen resolution
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小屏幕分辨率 1,280 x 800
- en: 'Linux:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Linux:'
- en: Any 64-bit Linux distribution that supports Gnome, KDE, or Unity DE; GNU C Library
    (glibc) 2.31 or later
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持 Gnome、KDE 或 Unity DE 的任何 64 位 Linux 发行版；GNU C Library (glibc) 2.31 或更高版本
- en: x86_64 CPU architecture; 2nd generation Intel Core or newer, or AMD processor
    with support for AMD Virtualization (AMD-V) and SSSE3
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: x86_64 CPU 架构；第二代 Intel Core 或更新的处理器，或支持 AMD 虚拟化 (AMD-V) 和 SSSE3 的 AMD 处理器
- en: 8 GB of RAM or more
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少 8 GB 的 RAM 或更多
- en: 8 GB of available disk space minimum (IDE + Android SDK + Android Emulator)
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少 8 GB 的可用磁盘空间（IDE + Android SDK + Android 模拟器）
- en: 1,280 x 800 minimum screen resolution
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小屏幕分辨率 1,280 x 800
- en: The architecture of a legacy app
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遗留应用程序的架构
- en: In this section, we will look at how Android applications used to be built in
    the past and what difficulties developers had with the approach taken.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾 Android 应用程序过去是如何构建的，以及开发者在使用该方法时遇到的困难。
- en: Before we start analyzing an older application, we must distinguish the architecture
    and design of an application. To borrow from the construction industry, we can
    define architecture as a plan for the structure of a building; a design would
    be a plan to create each part of the building. Translating this into the world
    of software engineering, we can say that the architecture of an application or
    a system would be defining a plan that would incorporate the business and technical
    requirements, while software design deals with integrating all the components,
    modules, and frameworks into this plan. In an ideal world, you would want to recognize
    the architecture of an application in the same way you would recognize the architecture
    of your house.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始分析一个较老的应用程序之前，我们必须区分应用程序的架构和设计。借用建筑行业的术语，我们可以将架构定义为建筑结构的计划；设计则是指创建建筑每个部分的计划。将这一概念转化为软件工程领域，我们可以认为应用程序或系统的架构是定义一个计划，该计划将包含业务和技术需求，而软件设计则涉及将所有组件、模块和框架整合到这个计划中。在一个理想的世界里，你希望以识别你房屋架构的方式识别应用程序的架构。
- en: 'Now, let''s look at the four main components of an Android application:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看Android应用程序的四个主要组件：
- en: '**Activities**: These represent the entry points for interacting with the user.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**活动**：这些代表与用户交互的入口点。'
- en: '**Services**: These represent the entry points for having an app run in the
    background for all kinds of reasons, such as large downloads or audio playback.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务**：这些代表应用程序在后台运行的原因入口点，例如大型下载或音频播放。'
- en: '**Broadcast Receivers**: These allow the system to interact with an application
    for a variety of reasons.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**广播接收器**：这些允许系统以各种原因与应用程序交互。'
- en: '**Content Providers**: These represent a way for an application to manage application
    data.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内容提供者**：这些代表应用程序管理应用数据的方式。'
- en: Using and relying on these components created a challenge for developers because
    an app's architecture became dependent on the Android framework, mainly when it
    came to implementing unit tests. To understand why this is a problem, let's look
    at an example of what some older application code would look like. Let's suppose
    you have been asked to fetch some data from a backend service. The data would
    be served in the form of JSON through an HTTP connection.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用和依赖这些组件给开发者带来了挑战，因为应用程序的架构变得依赖于Android框架，尤其是在实现单元测试时。为了理解为什么这是一个问题，让我们看看一些较老的应用程序代码的例子。假设你被要求从一个后端服务获取一些数据。这些数据将通过HTTP连接以JSON的形式提供。
- en: 'It wasn''t uncommon to see a class such as `BaseRequest.java`, which would
    execute the request and depend on abstraction in the form of `JsonMapper.java`,
    to convert the data from a `String` into a **Plain Old Java Object** (**POJO**).
    The following code represents an example of how fetching the data might be implemented:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 看到一个像`BaseRequest.java`这样的类并不罕见，它会执行请求并依赖于`JsonMapper.java`这种形式的抽象来将数据从`String`转换为**普通Java对象**（**POJO**）。以下代码展示了如何实现获取数据的一个示例：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the `execute` method, we would use `HttpURLConnection` to connect to the
    backend service and retrieve the data. Then, we would read it into a `String`,
    which would then be converted into a `JSONObject` and then passed to `JsonMapper`
    to be converted into a POJO.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在`execute`方法中，我们会使用`HttpURLConnection`连接到后端服务并检索数据。然后，我们会将其读取到一个`String`中，接着将其转换为`JSONObject`，然后传递给`JsonMapper`以转换为POJO。
- en: 'The `JsonMapper.java` interface would look something like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`JsonMapper.java`接口可能看起来像这样：'
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This interface represents the abstraction of converting a `JSONObject` into
    any POJO.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口代表了将`JSONObject`转换为任何POJO的抽象。
- en: 'The use of generics allows us to apply this logic to any POJO. In our case,
    the POJO should look something like `ConcreteData.java`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型使用允许我们将这种逻辑应用于任何POJO。在我们的案例中，POJO应该看起来像`ConcreteData.java`：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `ConcreteData` class will be responsible for holding the data we will receive
    from the backend service. In this case, we just have two `String` instance variables.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcreteData`类将负责存储我们从后端服务接收到的数据。在这种情况下，我们只有两个`String`实例变量。'
- en: 'Now, we need to create a concrete `JsonMapper.java` that will be responsible
    for converting a `JSONObject` into `ConcreteData`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个具体的`JsonMapper.java`，它将负责将`JSONObject`转换为`ConcreteData`：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `convert` method creates a new `ConcreteData` object, extracts the data
    from the `JSONObject` object, and populates the `field1` and `field2` values.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`convert`方法创建一个新的`ConcreteData`对象，从`JSONObject`对象中提取数据，并填充`field1`和`field2`的值。'
- en: 'Next, we must create a `ConcreteRequest.java` that will extend `BaseRequest`
    and use `ConcreteMapper`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须创建一个扩展`BaseRequest`并使用`ConcreteMapper`的`ConcreteRequest.java`：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This class will inherit the `execute` method from `BaseRequest` and supply a
    new `ConcreteMapper` object so that we can convert the backend data into `ConcreteData`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类将从`BaseRequest`继承`execute`方法，并提供一个新的`ConcreteMapper`对象，以便我们可以将后端数据转换为`ConcreteData`。
- en: Finally, we can use this in our `Activity` to execute the request and update
    our `AsyncTask` class, which offers a set of methods for doing work on a separate
    thread and then processing the results on the main thread. However, we risk creating
    a context leak (if, for any reason, the `Activity` object is destroyed, then the
    garbage collector will not be able to collect the `Activity` object while `AsyncTask`
    is running since `Activity` has a dependency on `AsyncTask`) by using an inner
    `AsyncTask` class. To circumvent this, the recommended approach is to create a
    `WeakReference` for our `Activity`. This way, if the `Activity` object is destroyed
    either by the user or the system, its reference can be collected by the garbage
    collector.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在我们的`Activity`中使用这个方法来执行请求并更新我们的`AsyncTask`类，该类提供了一套在单独的线程上执行工作并在主线程上处理结果的方法。然而，使用内部`AsyncTask`类可能会创建上下文泄露的风险（如果由于任何原因，`Activity`对象被销毁，那么在`AsyncTask`运行时垃圾收集器将无法收集`Activity`对象，因为`Activity`依赖于`AsyncTask`）。为了避免这种情况，建议的方法是为我们的`Activity`创建一个`WeakReference`。这样，如果`Activity`对象被用户或系统销毁，其引用可以被垃圾收集器收集。
- en: 'Now, let''s look at the code for our `MainActivity`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们的`MainActivity`的代码：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This class is responsible for loading the UI and starting `LoadConcreteDataTask`.
    The `update` method will then be called by `LoadConcreteDataTask` to show the
    data in the user interface.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类负责加载UI并启动`LoadConcreteDataTask`。然后，`LoadConcreteDataTask`将调用`update`方法来在用户界面中显示数据。
- en: '`LoadConcreteDataTask` must be an inner class of `MainActivity`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoadConcreteDataTask`必须是`MainActivity`的内部类：'
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In `LoadConcreteDataTask`, we take advantage of the `doInBackground` method,
    which is executed on a separate thread to load our data and then update our UI
    in the `onPostExecute` method. We also hold a `WeakReference` to `MainActivity`
    so that it can be safely garbage collected when destroyed. This also means that
    we will need to check if the reference still exists before updating the user interface.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在`LoadConcreteDataTask`中，我们利用`doInBackground`方法，它在单独的线程上执行以加载数据，然后在`onPostExecute`方法中更新我们的UI。我们还持有`MainActivity`的`WeakReference`，以便在销毁时可以安全地垃圾回收。这也意味着在更新用户界面之前，我们需要检查引用是否仍然存在。
- en: 'The class diagram for the preceding code looks as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的类图如下所示：
- en: '![Figure 1.1 – A class diagram for an older Android app'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.1 – 一个较老Android应用的类图'
- en: '](img/Figure_1.01_B18320.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.01_B18320.jpg)'
- en: Figure 1.1 – A class diagram for an older Android app
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – 一个较老Android应用的类图
- en: Here, we can see how the dependencies move from `MainActivity` toward the `ConcreteRequest`
    class, with one exception between `MainActivity` and `LoadConcreteDataTask`, where
    both classes depend on each other. This is a problem because the classes are then
    coupled together and making a change to one implies making a change to the other.
    Later in this chapter, we will look at some principles that can help us avoid
    such dependencies.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到依赖关系如何从`MainActivity`移动到`ConcreteRequest`类，其中`MainActivity`和`LoadConcreteDataTask`之间存在一个例外，这两个类相互依赖。这是一个问题，因为类之间耦合在一起，对其中一个的更改意味着对另一个的更改。在本章的后面部分，我们将探讨一些可以帮助我们避免此类依赖关系的原则。
- en: Now that we have an idea of what a legacy application looks like, let's see
    what issues we may encounter if we follow this path.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了遗留应用程序的样子，让我们看看如果我们遵循这条路径可能会遇到哪些问题。
- en: Legacy analysis
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遗留分析
- en: In this section, we will analyze some of the problems that legacy applications
    have.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将分析遗留应用程序中的一些问题。
- en: 'Let''s ask ourselves the following questions:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们提出以下问题：
- en: What can we unit test?
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以单元测试什么？
- en: What happens if, instead of showing the value of `field1` from `ConcreteData`,
    we need to show `field1+field2`?
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果不是显示`ConcreteData`中`field1`的值，而是需要显示`field1+field2`，会发生什么？
- en: What happens when the requirements for this particular screen change and data
    needs to be retrieved from another endpoint on top of this one?
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当这个特定屏幕的需求发生变化并且需要从另一个端点检索数据时会发生什么？
- en: What happens if we need to introduce caching or SQLite persistence?
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们需要引入缓存或 SQLite 持久性会发生什么？
- en: What happens if another activity needs this particular use case?
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果另一个活动需要这个特定的用例会发生什么？
- en: 'Let''s answer these questions:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来回答这些问题：
- en: '`androidTest` and `test` directories. Theoretically, we can write our unit
    tests so that they can run on the emulator, but that takes more time and instability.
    We can now execute these types of tests in the cloud using technologies such as
    Firebase Test Lab, but that would inevitably cost us money and it''s in our interest
    to avoid taking in such costs. Realistically, we are left with one option and
    that is to test as much as possible using local unit tests instead of instrumented
    ones. To solve this, we will need to separate the Android components we use from
    the Java components.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`androidTest` 和 `test` 目录。从理论上讲，我们可以编写我们的单元测试，以便它们可以在模拟器上运行，但这需要更多的时间和稳定性。现在，我们可以使用
    Firebase Test Lab 等技术将这些类型的测试在云中执行，但这不可避免地会花费我们金钱，并且避免此类成本符合我们的利益。实际上，我们只剩下一种选择，那就是尽可能多地使用本地单元测试而不是受仪器化的测试。为了解决这个问题，我们需要将我们使用的
    Android 组件与 Java 组件分开。'
- en: '`MainActivity` or add a method into the `ConcreteData` class that will return
    the concatenated result. But either of these will come with downsides. If we move
    the concatenation into `MainActivity`, we will put logic that can be unit tested
    into a class that is very hard and shouldn''t be unit tested. If we create a method
    to concatenate in `ConcreteData`, we risk giving responsibility to this class
    that it shouldn''t have since it''s related more to the UI than the actual representation
    of the JSON itself. What if, in the future, the networking aspect is developed
    by another team? You would need to rely on that particular team to create this
    update.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MainActivity` 或在 `ConcreteData` 类中添加一个返回连接结果的方法。但任何一种方法都会带来不利因素。如果我们把连接移动到
    `MainActivity`，我们将把可以单元测试的逻辑放入一个很难测试且不应该进行单元测试的类中。如果我们创建一个在 `ConcreteData` 中连接的方法，我们可能会给这个类赋予它不应该有的责任，因为它更多地与
    UI 相关，而不是 JSON 本身的实际表示。如果将来网络方面是由另一个团队开发的，你将需要依赖那个特定的团队来创建这个更新。'
- en: '`AsyncTask` or execute both requests in the same `LoadConcreteData` class and
    then update the UI. If we create a separate `AsyncTask`, then we will need to
    make the activity responsible for managing the results and balance the two `AsyncTasks`,
    which again creates a problem concerning testing. If we execute the requests in
    the same `AsyncTask`, then the responsibility of `AsyncTask` increases, which
    we may want to avoid.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AsyncTask` 或在同一个 `LoadConcreteData` 类中执行两个请求然后更新 UI。如果我们创建一个单独的 `AsyncTask`，那么我们将需要让活动负责管理结果并平衡两个
    `AsyncTask`，这再次产生了关于测试的问题。如果我们在一个 `AsyncTask` 中执行请求，那么 `AsyncTask` 的责任增加，我们可能想要避免这种情况。'
- en: '`LoadConcreteDataTask`. Here, we run into the same issues that we did in the
    previous questions. If we used the request classes, we would end up being more
    responsible for dealing with HTTP connections than handling calls to the database.
    If we use `LoadConcreteDataTask`, we make the answer to the fifth question even
    harder.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoadConcreteDataTask`。在这里，我们遇到了与前面问题相同的问题。如果我们使用了请求类，我们最终将承担比处理数据库调用更多的责任来处理
    HTTP 连接。如果我们使用 `LoadConcreteDataTask`，我们将使第五个问题的答案变得更加困难。'
- en: '`LoadConcreteDataTask` class. Now, let''s imagine that another activity with
    a completely different UI and a different interpretation of that data will rely
    on the same use case. One solution is to duplicate `LoadConcreteDataTask` into
    the new activity. This is not a great idea because a change in the requirements
    will make the developers change all the tasks. A better approach would be to create
    a new abstraction that will remove the dependency between `LoadConcreteDataTask`
    and `Activity`. This would allow us to reuse the same class for both activities.
    Let''s say that the activities would need different types of data for each interpretation.
    Here, we could follow the `JsonMapper` example and create an interface that would
    convert `ConcreteData` into a generic type, provide two implementations for each
    activity, and create the necessary POJOs to convert into.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoadConcreteDataTask` 类。现在，让我们想象另一个具有完全不同 UI 和对数据进行不同解释的活动将依赖于相同的用例。一个解决方案是将
    `LoadConcreteDataTask` 复制到新的活动中。这不是一个好主意，因为需求的变化将迫使开发者更改所有任务。更好的方法是创建一个新的抽象，这将消除
    `LoadConcreteDataTask` 和 `Activity` 之间的依赖关系。这将使我们能够为两个活动重用相同的类。假设活动需要为每种解释提供不同类型的数据。在这里，我们可以遵循
    `JsonMapper` 的例子，创建一个接口，将 `ConcreteData` 转换为通用类型，为每个活动提供两种实现，并创建必要的 POJO 以进行转换。'
- en: Another question that can be asked here is, "What amount of work would be necessary
    to export the business logic into another project?" This is an important question
    because it highlights how we should structure our code so that it can be reused
    by others without making it a pain for them to integrate. If we were to answer
    this, we must first ask, "Where's the business logic?" The answer would probably
    be `LoadConcreteDataTask`. Can we export that and publish it somewhere where other
    developers can get it?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在这里提出的一个问题是，“将业务逻辑导出到另一个项目需要多少工作量？”这是一个重要的问题，因为它突出了我们应该如何构建我们的代码，以便其他人可以重用它，而不会给他们集成带来痛苦。如果我们回答这个问题，我们必须首先问，“业务逻辑在哪里？”答案可能是
    `LoadConcreteDataTask`。我们能将其导出并发布到其他开发者可以获取的地方吗？
- en: The answer is no, because of its dependency on `MainActivity`. This question
    highlights an important aspect of defining an architecture, namely drawing the
    boundaries around your components. A component can be defined as the smallest
    piece of deliverable code. In our case, it would be the equivalent of a module.
    Now, let's say we were in a place where we could ship out our `LoadConcreteDataTask`.
    A follow-up question would be, "Would the data be hosted on the same service?"
    followed by, "Is it in the same JSON format?" Here, we would need to draw a boundary
    between `LoadConcreteDataTask` and `BaseRequest` and remove such dependencies
    on how the data is retrieved.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是否定的，因为它依赖于 `MainActivity`。这个问题突出了定义架构的一个重要方面，即确定组件的边界。组件可以被定义为最小的可交付代码片段。在我们的情况下，它相当于一个模块。现在，假设我们处于可以交付我们的
    `LoadConcreteDataTask` 的位置。一个后续问题是，“数据是否托管在相同的服务上？”接着是，“它是否是相同的 JSON 格式？”在这里，我们需要在
    `LoadConcreteDataTask` 和 `BaseRequest` 之间划清界限，并消除对数据检索方式的这种依赖。
- en: The reason these questions were raised and answered is that all those scenarios
    have happened in the past and they will all likely happen in the life cycle of
    an application. We, as developers, tend to answer those questions in our code
    differently based either on time constraints, the rigor imposed on the team we
    work in, our ambition to deliver something fast by constantly challenging ourselves,
    and our experience or the team's experience. The fact that we had the option to
    make a less desirable solution or to be stuck in a situation where we had to pick
    between the frying pan or the fire represents a problem. Sometimes, it is good
    to take a step back from our daily routine, ask ourselves some of these questions,
    do mind experiments to see how our code may end up in those scenarios, and assess
    what would happen if that would happen now or 1 or 2 years from now.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 提出并回答这些问题的原因是，所有这些场景都已经在过去发生过，它们很可能在应用程序的生命周期中再次发生。作为开发者，我们倾向于根据时间限制、我们所在团队施加的严谨性、我们通过不断挑战自己快速交付东西的雄心，以及我们的经验或团队的经验，以不同的方式回答这些问题。我们有机会选择一个不那么理想的解决方案，或者陷入一个我们必须在煎锅和火之间做出选择的情况，这代表了一个问题。有时，从我们的日常工作中退一步，问自己这些问题，进行心智实验，看看我们的代码可能如何结束在这些场景中，并评估如果现在发生或
    1 或 2 年后会发生什么，这是有益的。
- en: A common scenario a lot of Android developers found themselves in was having
    a lack of businesses investing in testing because it would take too much time
    and there was a need to go to market. In many of these cases, the apps became
    harder to maintain over time, so more developers needed to be hired to keep the
    same productivity as a team compared to when they had fewer developers. When code
    is written with the notion that it needs to be unit tested, then the way we write
    that code becomes more rigorous and more maintainable. We start keeping track
    of how we create instances and separate the things we can test from the things
    we can't, we apply creational design patterns, and we also shorten the sizes of
    the methods in our classes, among other things.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Android开发者发现自己处于的一个常见场景是，由于测试需要花费太多时间，并且需要尽快上市，导致缺乏对测试的投资。在这些案例中，随着时间的推移，应用程序变得越来越难以维护，因此需要雇佣更多的开发者来保持与较少开发者时的相同团队生产力。当代码以需要单元测试的概念编写时，我们编写代码的方式就会变得更加严谨和可维护。我们开始跟踪我们如何创建实例，区分我们可以测试和不能测试的事物，我们应用创建型设计模式，并且我们还缩短了我们类中方法的长度，以及其他一些事情。
- en: We now have an idea of how applications used to be written in the past and the
    problems that were caused by the approaches that were taken, such as issues with
    the testability and maintainability of an application due to dependencies on the
    Android framework. Next, we will look at some design principles that will prove
    useful in how we write an application.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了过去应用程序是如何编写的，以及由于采取的方法（例如，由于依赖Android框架而导致的测试性和可维护性问题）所引起的问题。接下来，我们将探讨一些将证明对我们编写应用程序有用的设计原则。
- en: Software design principles
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件设计原则
- en: In this section, we will analyze a set of design principles that are adopted
    by developers worldwide to improve their systems and can also be applied to Android
    development. We will mainly focus on the principles defined by *Robert C Martin*
    (also known as Uncle Bob) for classes and components because they are well suited
    to Android development.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将分析一套被全球开发者采用的、用于改进他们系统的设计原则，这些原则也可以应用于Android开发。我们将主要关注由*罗伯特·马丁*（也称为Uncle
    Bob）为类和组件定义的原则，因为它们非常适合Android开发。
- en: Based on the examples in the previous section, we understand that our code bases
    should be maintainable, understandable, and flexible. There is a set of software
    design principles that we can turn to for help when we develop classes or components.
    Think of a component as the minimum amount of code that can be released as part
    of a system. In Android, you can view them as individual modules. They don't necessarily
    need to be modules, but they can be organized as if they are.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上一节中的示例，我们了解到我们的代码库应该是可维护的、可理解的和灵活的。有一套软件设计原则，当我们在开发类或组件时，可以寻求帮助。将组件视为可以作为系统一部分发布的最小代码量。在Android中，你可以将它们视为独立的模块。它们不一定需要是模块，但可以组织成仿佛它们是模块的样子。
- en: SOLID principles
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SOLID原则
- en: 'These are some of the most known design principles. The name is an acronym
    for a set of design principles that were collected by *Robert C Martin*. These
    principles are as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些最知名的设计原则。这个名字是一个缩写，代表了一组由*罗伯特·马丁*收集的设计原则。这些原则如下：
- en: Single responsibility principle
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: Open-closed principle
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开放封闭原则
- en: Liskov substitution principle
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 李斯克替换原则
- en: Interface segregation principle
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口隔离原则
- en: Dependency inversion principle
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖倒置原则
- en: 'Let''s look at these principles in detail:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看这些原则：
- en: '`BaseRequest` class to change how the HTTP request is executed. Let''s assume
    that we now have two different AsyncTasks that will load the data. Both of these
    will be impacted by the change in the `BaseRequest` class. A solution would be
    to delegate the execution of the request to different classes for each particular
    use case. This would also allow developers to work on different features related
    to backend communication without changing the same source file.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`BaseRequest`类来改变HTTP请求的执行方式。假设我们现在有两个不同的AsyncTasks将会加载数据。这两个AsyncTasks都将受到`BaseRequest`类变化的影响。一个解决方案是为每个特定的用例委托请求的执行给不同的类。这也会允许开发者在不更改相同源文件的情况下，工作于与后端通信相关的不同特性。
- en: '**Open-Closed Principle**: This states that a class should be open for extension
    and closed for modification. Thinking back to our example, this principle would
    answer the question, "What would happen if an activity requires this particular
    use case?" The abstractions we discussed in how to answer that question would
    serve as a good example of implementing this principle.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开放-封闭原则**：这表示一个类应该对扩展开放，对修改封闭。回顾我们的例子，这个原则会回答“如果一个活动需要这个特定的用例会发生什么？”这个问题。我们讨论的如何回答这个问题的抽象将作为实现此原则的好例子。'
- en: '`Bird` and a sub-class called `Duck`. If you are using references of `Bird`
    in your code and substitute those usages with `Duck`, then your code should remain
    unchanged. A famous example of a violation of this principle is having a `Rectangle`
    class with two members named `width` and `height` and a sub-class named `Square`.
    In reality, a square is a rectangle, but our modeling of a square wouldn''t be
    a rectangle because the rules in `Square` would mean that the width and height
    will always have to be the same. If you were to swap these two dependencies, then
    your code would break.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bird` 和一个名为 `Duck` 的子类。如果你在代码中使用 `Bird` 的引用，并将这些用法替换为 `Duck`，那么你的代码应该保持不变。一个违反此原则的著名例子是有一个名为
    `Rectangle` 的类，它有两个名为 `width` 和 `height` 的成员，以及一个名为 `Square` 的子类。实际上，正方形是矩形的一种，但我们对正方形的建模不会是矩形，因为
    `Square` 中的规则意味着宽度和高度将始终必须相同。如果你要交换这两个依赖项，那么你的代码就会出错。'
- en: '`OnClickListener`, `OnLongClickListener`, and `OnTouchListener`.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnClickListener`、`OnLongClickListener` 和 `OnTouchListener`。'
- en: '**Dependency Inversion Principle**: This states that we should depend on abstractions
    rather than concretions. The idea here is to depend as much as possible on abstract
    classes and interfaces. This can be very difficult to achieve considering that
    we rely on concretions a lot of the time. Here, we should identify parts of the
    code that are constantly developed and subject to change and introduce layers
    of abstractions between our code and these classes. A good way to protect against
    this is through dependency injection frameworks such as Dagger and Hilt, which
    generate factories to create volatile components.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖倒置原则**：这表示我们应该依赖于抽象而不是具体实现。这里的想法是尽可能多地依赖于抽象类和接口。考虑到我们很多时候都依赖于具体实现，这可能会非常困难。在这里，我们应该确定代码中那些经常开发和需要变更的部分，并在我们的代码和这些类之间引入抽象层。一种保护方法是通过依赖注入框架，如
    Dagger 和 Hilt，这些框架生成工厂来创建易变组件。'
- en: SOLID principles are used across the **object-oriented programming** (**OOP**)
    field to create applications that are flexible and able to incorporate new features
    and requirements. The principles that follow represent an expansion of SOLID.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID原则在**面向对象编程**（**OOP**）领域被广泛应用，以创建灵活的应用程序，能够融入新的功能和需求。以下原则是对SOLID原则的扩展。
- en: Component cohesion principles
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件内聚原则
- en: We can define cohesion by how well the classes in a component belong together
    or what classes belong in a certain component. In the past, components were assembled
    based on the context without any particular guiding principle. This would cause
    issues such as a change in the dependencies of a component triggering a change
    in the dependants of this component, without this having any relevance to the
    dependants.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过组件中类的归属程度或哪些类属于某个特定组件来定义内聚性。在过去，组件是根据上下文组装的，没有任何特定的指导原则。这会导致问题，例如，组件依赖项的变化会触发此组件依赖项的变化，而这对依赖项没有任何相关性。
- en: 'The three principles are as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下三个原则如下：
- en: '**Reuse/Release Equivalence Principle** (**REP**): This states that we group
    classes in a component that can be released together. In Android development,
    this would translate to making sure that every module you create should be able
    to be published and used by other developers.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重用/发布等价原则**（**REP**）：这表示我们应该将可以一起发布的类分组到组件中。在Android开发中，这会转化为确保你创建的每个模块都能够被其他开发者发布和使用。'
- en: '**Common Closure Principle** (**CCP**): This states that components should
    have one reason to change. This principle is an application of the single responsibility
    principle for components.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**共同封闭原则**（**CCP**）：这表示组件应该只有一个改变的理由。这个原则是组件单职责原则的应用。'
- en: '**Common Reuse Principle** (**CRP**): This states that a component should only
    have classes that should be used together. This represents the interface segregation
    principle for your component. In Android, this would mean that you should make
    sure that the users of your Android modules depend on all your classes in the
    module, not just some.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用重用原则**（**CRP**）：这一原则指出，一个组件应该只包含应该一起使用的类。这代表了你的组件的接口分离原则。在Android中，这意味着你应该确保你的Android模块的用户依赖于该模块中的所有类，而不仅仅是其中的一些。'
- en: When these principles are incorporated, they end up conflicting with each other.
    REP and CCP tend to make components bigger, while CRP tends to make them smaller.
    The idea is to always match the current requirements of the application and find
    the middle ground between these principles. After that, you should constantly
    monitor how new requirements would affect this middle ground.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些原则被整合时，它们之间可能会产生冲突。REP和CCP倾向于使组件更大，而CRP则倾向于使它们更小。理念是始终匹配当前的应用需求，并在这些原则之间找到平衡点。之后，你应该持续监控新需求如何影响这一平衡点。
- en: Now that we've seen how SOLID can be applied to building a particular component
    through the component cohesion principles, let's learn how to manage a set of
    components.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到如何通过组件内聚原则将SOLID应用于构建特定的组件，接下来让我们学习如何管理一组组件。
- en: Component coupling principles
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件耦合原则
- en: 'These principles deal with how to manage the relationships between our components
    in an Android application. In Android, this would be represented by how to manage
    the Gradle dependencies between different modules. The principles are as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这些原则处理的是如何在Android应用程序中管理组件之间的关系。在Android中，这可以通过如何管理不同模块之间的Gradle依赖来表示。原则如下：
- en: '**Acyclic Dependencies Principle**: This states that we should avoid cyclic
    dependencies between components. Applying this to Android would mean that the
    dependencies that our modules have most not be cyclical (for example, module A
    depends on module B, which depends on module A). Fortunately, this rule is currently
    enforced by the build system, which doesn''t allow cyclical dependencies. A solution
    to this would be to create a new module in which we apply the dependency inversion
    principle and make one of the modules depend on the abstraction and create the
    implementation in the second module. If this is not possible, we can create a
    new module that can depend on both existing modules. An example of this can be
    seen in the following diagram:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无环依赖原则**：这一原则指出，我们应该避免组件之间的循环依赖。将这一原则应用于Android，意味着我们的模块之间的依赖不应该形成循环（例如，模块A依赖于模块B，而模块B又依赖于模块A）。幸运的是，当前构建系统强制执行了这一规则，不允许循环依赖。解决这一问题的方法之一是创建一个新的模块，在其中应用依赖倒置原则，并使其中一个模块依赖于抽象，在第二个模块中创建实现。如果这不可能实现，我们可以创建一个新的模块，它可以依赖于现有的两个模块。以下图表中可以看到这一示例：'
- en: '![Figure 1.2 – Cyclic module dependency'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.2 – 循环模块依赖]'
- en: '](img/Figure_1.02_B18320.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.2 – 循环模块依赖](img/Figure_1.02_B18320.jpg)'
- en: Figure 1.2 – Cyclic module dependency
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 – 循环模块依赖
- en: '**Stable Dependencies Principle**: This states that less stable modules should
    depend on more stable modules. A component''s stability is defined as the ratio
    between outgoing dependencies (dependency on other components) and the total number
    of dependencies. The closer the number is to 0, the more stable a component becomes.
    This means that stable components should avoid having changes made because this
    will cause potential issues for the components that depend on the stable ones.
    One solution to avoid the dependencies between stable components and volatile
    components would be using abstract components. These are components that will
    contain nothing but abstractions.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**稳定依赖原则**：这一原则指出，稳定性较低的模块应该依赖于稳定性较高的模块。一个组件的稳定性定义为输出依赖（对其他组件的依赖）与总依赖数的比率。这个数字越接近0，组件就越稳定。这意味着稳定的组件应该避免因变更而引起潜在问题，因为这将对依赖于稳定组件的组件造成问题。避免稳定组件和易变组件之间依赖的一种解决方案是使用抽象组件。这些组件将只包含抽象。'
- en: '**Stable Abstractions Principle**: This states that components that are likely
    to change should be more concrete and that stable components should be more abstract.
    This principle represents an application of the open-closed principle. We would
    want our high-level architecture decisions to be flexible enough to be changed
    without having to modify existing source code. We can achieve this using abstract
    classes. The abstractness of a component is defined as the ratio between the number
    of abstract classes and interfaces inside a component and the total number of
    classes in the component. The closer to 1 the value gets, the more abstract the
    component becomes. A component with 0 stability and 0 abstractness represents
    a **zone of pain** because it is very hard to change. A component with 1 stability
    and 1 abstractness is called a **zone of uselessness** because we have an independent
    component with no implementations. The aim is to get as many components as possible
    in either the 0 stability and 1 abstractness or 1 stability and 0 abstractness
    range.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**稳定抽象原则**：这一原则指出，可能发生变化的组件应该更加具体，而稳定的组件应该更加抽象。这一原则代表了开放封闭原则的应用。我们希望我们的高级架构决策足够灵活，以便在不修改现有源代码的情况下进行更改。我们可以通过使用抽象类来实现这一点。组件的抽象程度定义为组件内部抽象类和接口的数量与组件中类总数的比率。该值越接近1，组件的抽象程度就越高。稳定性和抽象性都为0的组件代表了一个**痛苦区域**，因为它很难更改。稳定性和抽象性都为1的组件被称为**无用区域**，因为我们有一个没有实现的独立组件。目标是尽可能多地让组件处于0稳定性和1抽象性或1稳定性和0抽象性的范围内。'
- en: With that, we have looked at some of the key design principles that should help
    us tackle problems that we face while developing an application. The SOLID principles
    show us how we should structure our code into classes, while the component cohesion
    principles and component coupling principles show us how we should structure our
    classes into separate modules, as well as how we should establish the relationships
    between those modules. In the next section, we will see how these principles lead
    to the evolution of the Android platform and what an application may look like
    now.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经探讨了应该帮助我们解决在开发应用程序时遇到的一些关键设计原则。SOLID原则告诉我们如何将代码结构化为类，而组件内聚原则和组件耦合原则则告诉我们如何将类结构化为独立的模块，以及如何建立这些模块之间的关系。在下一节中，我们将看到这些原则如何导致Android平台的演变，以及应用程序现在可能的样子。
- en: Exploring the evolution of Android
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Android的演变
- en: In this section, we will look at key releases and changes that have been made
    to the Android framework and supporting libraries that have shaped the development
    of applications and how applications have evolved because of these changes.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨对Android框架及其支持库的关键发布和变更，这些变更塑造了应用程序的开发，以及应用程序如何因为这些变更而发展演变。
- en: We started by looking at an example of what the code in an older Android application
    looked like before looking at the design principles we should incorporate into
    our work. Now, let's see how the Android framework evolved and how some of our
    questions from the beginning have been answered. We will analyze some of the newer
    libraries, frameworks, and technologies that we can incorporate into an Android
    application.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先查看了一个较老Android应用程序中的代码示例，然后讨论我们应该融入我们工作的设计原则。现在，让我们看看Android框架是如何演变的，以及我们最初的一些问题是如何得到解答的。我们将分析一些可以融入Android应用程序的新库、框架和技术。
- en: Fragments
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 碎片
- en: The introduction of fragments was meant to solve important issues developers
    were facing – that is, the activity code would become too big and hard to manage.
    They were released on Android Honeycomb, which was an Android release that only
    targeted tablets. The introduction of fragments was also meant to solve the issue
    of having different displays for activities in landscape versus activities in
    portrait. Fragments are meant to control portions of an activity's user interface.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 碎片的引入旨在解决开发者面临的重要问题——即活动代码会变得太大且难以管理。它们是在Android Honeycomb上发布的，这是一个仅针对平板电脑的Android版本。引入碎片还旨在解决在横屏和竖屏活动中显示不同内容的问题。碎片旨在控制活动用户界面的部分。
- en: 'Another improvement fragments brought was the ability to change and replace
    fragments at runtime. There was even a separate back stack for Fragments that
    the activity would be responsible for. This comes at a couple of costs: the life
    cycle of the fragment was even more complex than the life cycle of the activity,
    where you would have fragments that had their views destroyed but the fragments
    themselves weren''t. Another cost was the communication between two fragments.
    If you needed to update the user interface being handled by Fragment1 because
    of a change in Fragment2, you would need to communicate through the activity.
    This meant that every time a Fragment needed to be reused by a different activity,
    then the activity would be forced to adapt to this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 另一项由片段带来的改进是能够在运行时更改和替换片段。甚至还有一个专门的后退栈用于片段，活动将负责这些片段。这带来了一些成本：片段的生命周期比活动的生命周期更加复杂，其中会有片段的视图被销毁，但片段本身并未被销毁。另一个成本是两个片段之间的通信。如果你需要更新由Fragment1处理的用户界面，因为Fragment2发生了变化，那么你需要通过活动进行通信。这意味着每次一个片段需要被不同的活动重用时，活动就必须适应这种情况：
- en: '![Figure 1.3 – Activity and fragment life cycle'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.3 – Activity and fragment life cycle]'
- en: '](img/Figure_1.03_B18320.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.03_B18320.jpg]'
- en: Figure 1.3 – Activity and fragment life cycle
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.3 – Activity and fragment life cycle]'
- en: In the preceding figure, we can see the difference between the lifecycle of
    activities and the lifecycle of fragments. We can observe how fragments have their
    own internal lifecycle for managing the views that they display between the `onCreateView`
    method and `onDestroyView` methods. This is often the reason why in many applications,
    you will see these methods used to load data and on the opposite site unsubscribing
    from any operations that might trigger a change in the user interface.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到活动生命周期和片段生命周期的区别。我们可以观察到片段在`onCreateView`方法和`onDestroyView`方法之间有自己的内部生命周期，用于管理它们显示的视图。这通常是为什么在许多应用程序中，你会看到这些方法被用来加载数据，并在另一端取消订阅可能触发用户界面变化的任何操作。
- en: The Gradle build system
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Gradle构建系统
- en: 'Initially, Android development used the Eclipse IDE and Ant as its build system.
    This came with certain limitations for applications. Things such as flavors were
    not available at the time. The release of Android Studio, along with the Gradle
    build system, provided new opportunities and features. This allows us to write
    extra scripts and easily integrate plugins and tools, such as performance monitoring
    of an application, Google Play services, Firebase Crashlytics, and more. This
    is often done through `".gradle"` files. These files are written in a language
    called Groovy. Another improvement that was added was the usage of the `".gradle.kts"`
    extensions, where we can provide the same configurations using the Kotlin language.
    The following code shows what the `build.gradle` file for a module looks like:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，Android开发使用Eclipse IDE和Ant作为其构建系统。这为应用程序带来了一些限制。当时，如flavors这样的功能是不可用的。Android
    Studio的发布，以及Gradle构建系统的引入，提供了新的机会和功能。这使我们能够编写额外的脚本，并轻松集成插件和工具，例如应用程序的性能监控、Google
    Play服务、Firebase Crashlytics等。这通常是通过`".gradle"`文件完成的。这些文件是用一种叫做Groovy的语言编写的。另一个添加的改进是使用`".gradle.kts"`扩展，其中我们可以使用Kotlin语言提供相同的配置。以下代码显示了模块的`build.gradle`文件看起来像什么：
- en: '[PRE7]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the `plugins` section, we can define external plugins that will provide certain
    methods and scripts that our project can use. Examples include annotation processing
    plugins, the `Parcelize` plugin, and Room plugins. In this case, the `com.android.application`
    plugin offers us the `android` configuration, which we can then use to specify
    the app version, what Android versions we want the app to be accessible from,
    various compilation options, and configurations for how the app should be built
    for the end user. In the `dependencies` section, we specify which external libraries
    we want to add to the project.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在`plugins`部分，我们可以定义外部插件，这些插件将提供某些方法和脚本，我们的项目可以使用。例如，包括注解处理插件、`Parcelize`插件和Room插件。在这种情况下，`com.android.application`插件为我们提供了`android`配置，然后我们可以使用它来指定应用程序版本、我们希望应用程序能够访问的Android版本、各种编译选项以及应用程序应该如何为最终用户构建的配置。在`dependencies`部分，我们指定要添加到项目中的外部库。
- en: Networking
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络连接
- en: Quite a few popular networking libraries have emerged, mainly in the open sourcing
    community. A large proportion of the applications in Google Play rely on HTTP
    communication and a large proportion of them use JSON data. With the addition
    of networking libraries, JSON serialization/deserialization to POJOs also became
    adopted. What this means for developers is that the communication with the backend
    is simplified – we no longer need to concern ourselves with how the actual communication
    is done; we only point to where we want the data from and provide the models that
    are required for this communication. The libraries will take care of the rest.
    Some of the most popular libraries include Volley and Retrofit. In terms of object
    serialization, we have libraries such as Moshi and GSON.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 许多流行的网络库已经出现，主要是在开源社区中。在 Google Play 中的应用程序中，很大一部分依赖于 HTTP 通信，其中很大一部分使用 JSON
    数据。随着网络库的加入，JSON 序列化/反序列化到 POJOs 也被采纳。这意味着对开发者来说，与后端的通信被简化了——我们不再需要关心实际的通信是如何进行的；我们只需指向我们想要的数据来源，并提供进行此通信所需的模型。库将处理其余部分。一些最受欢迎的库包括
    Volley 和 Retrofit。在对象序列化方面，我们有如 Moshi 和 GSON 这样的库。
- en: Humble objects
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 谦逊的物体
- en: 'Because activities and fragments are difficult to unit test, the code inside
    them needed to be split into testable sections and untestable sections. Because
    of this necessity, two patterns emerged: **Model View Presenter** (**MVP**) and
    **Model View ViewModel** (**MVVM**). Sometimes, these patterns are referred to
    as architecture patterns. This shouldn''t be confused with the entire architecture
    of the app. The idea is to turn activities and fragments into humble objects with
    no logic, keep the references to the user interface objects, and shift the logic
    into the presenter and ViewModel, which we can write unit tests for. We will focus
    more on the particularities of each in [*Chapter 8*](B18320_08_ePub.xhtml#_idTextAnchor090)*,*
    *Implementing an MVVM Architecture*.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于活动和片段难以进行单元测试，它们内部的代码需要分成可测试部分和不可测试部分。由于这种必要性，出现了两种模式：**模型视图演示者**（**MVP**）和**模型视图视图模型**（**MVVM**）。有时，这些模式被称为架构模式。这不应该与整个应用程序的架构相混淆。想法是将活动和片段转变为没有逻辑的谦逊对象，保留对用户界面对象的引用，并将逻辑转移到演示者和视图模型中，我们可以为它们编写单元测试。我们将在[*第
    8 章*](B18320_08_ePub.xhtml#_idTextAnchor090)*，*实现 MVVM 架构*中更多地关注每个模式的特定细节。
- en: Functional paradigms
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能性范式
- en: Just like objected-oriented languages have adopted paradigms from functional
    programming, so has the Android development world in the form of RxJava. Functional
    programming works on the premise that programs are built from composing functions
    rather than imperative statements such as the ones in Java. RxJava is a library
    that allows developers to implement event-driven applications. It offers observables
    (for emitting data) and subscribers (for subscribing to that data). What made
    this library appealing to developers was how it deals with threading. Let's assume
    you wanted an operation to be executed on a separate thread, and then you wanted
    to transform your data – all you need to do here is invoke the data you want,
    apply mapping functions, and then subscribe to get the final result. The added
    benefit is that you can chain different operations, have them processed, and get
    the result with all of the operations. All of this removes the need for creating
    and managing different AsyncTasks or threads.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 正如面向对象的语言已经从函数式编程中采纳了范式，Android 开发世界也以 RxJava 的形式采纳了这种范式。函数式编程基于这样的前提：程序是由函数的组合而不是像
    Java 中的命令式语句构建的。RxJava 是一个库，允许开发者实现事件驱动应用程序。它提供了可观察对象（用于发射数据）和订阅者（用于订阅该数据）。这个库对开发者有吸引力的是它处理线程的方式。假设你想要在一个单独的线程上执行操作，然后你想要转换你的数据——在这里你需要做的就是调用你想要的数据，应用映射函数，然后订阅以获取最终结果。额外的优势是你可以链式调用不同的操作，让它们被处理，并获取所有操作的结果。所有这些都消除了创建和管理不同的
    AsyncTasks 或线程的需求。
- en: Kotlin adoption
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kotlin 的采用
- en: RxJava introduced some aspects of functional programming. Its adoption and transition
    into Kotlin programming has added others. One of the most important is the concept
    of mutability. In Java, all variables are mutable unless they're declared otherwise
    through the `final` keyword. In Kotlin, all the variables must have their mutability
    declared. Why is this important? Because of multi-threading. If you had an application
    where multiple threads were executed at the same time and they all interacted
    with the same object, you would end up in a situation where you would either modify
    the same value at the same time or create deadlocks in which a thread would wait
    for another thread to release a resource, but the second thread would need access
    to a resource that the first thread is currently holding. This introduction helps
    developers aim for a greater degree of immutability, which would increase thread
    safety because immutable variables are thread-safe. Lambdas represent another
    great feature of Kotlin that allows boilerplate code to be reduced when you're
    dealing with callbacks. Other benefits of the adoption of Kotlin include that
    you can remove boilerplate code by introducing data classes, which represent POJOs,
    and introducing sealed classes, which allow developers to define enum-like structures
    that can carry data.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: RxJava 引入了函数式编程的一些方面。其采用和过渡到 Kotlin 编程语言又增加了其他方面。其中最重要的一个是可变性的概念。在 Java 中，所有变量都是可变的，除非通过
    `final` 关键字声明为不可变。在 Kotlin 中，所有变量都必须声明其可变性。这为什么很重要？因为多线程。如果你有一个应用程序，其中多个线程同时执行并且它们都与同一个对象交互，你最终会陷入同时修改相同值或创建死锁的情况，其中一个线程会等待另一个线程释放资源，但第二个线程需要访问第一个线程当前持有的资源。这种引入有助于开发者追求更高的不可变性，这将增加线程安全性，因为不可变变量是线程安全的。Lambda
    代表了 Kotlin 的另一个伟大特性，它允许在处理回调时减少样板代码。采用 Kotlin 的其他好处包括，你可以通过引入数据类来移除样板代码，数据类代表
    POJOs，以及引入密封类，这允许开发者定义类似枚举的结构，可以携带数据。
- en: Dependency injection
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖注入
- en: 'Dependency injection represents the decoupling of object invocation and object
    creation. Why is this important? Mainly because of testing. It''s easier to write
    unit tests for classes that have their dependencies injected rather than adding
    extra responsibilities, such as creating new instances for all of the dependencies
    in that class. Another benefit is in situations where we depend on abstractions.
    If we have a dependency on an abstraction, we can easily switch between different
    implementations, depending on different circumstances. Several libraries have
    emerged to tackle this issue: Dagger, Koin, and Hilt. Dagger is more of a general
    library that is not only Android applicable, but also applicable for other Java-based
    platforms. It aims to manage our dependencies using components and modules. Components
    are responsible for how the dependencies are managed, while modules are responsible
    for providing the appropriate dependencies. It relies on annotation processors,
    which generate the necessary code that will be responsible for managing our dependencies.
    Koin is what''s referred to as a service locator library. It keeps a collection
    of all the dependencies and when a particular dependency is required, it will
    look it up and provide it. Koin is an Android-specific library, and it provides
    support for injecting specific Android dependencies. Hilt is the newest of these
    libraries and it is built on top of Dagger. It removes the boilerplate code that
    was required for Dagger and provides support for Android dependencies as well.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入代表了对象调用和对象创建的解耦。为什么这很重要？主要是因为测试。为具有依赖注入的类编写单元测试比添加额外责任更容易，例如为该类中的所有依赖项创建新实例。另一个好处是在我们依赖于抽象的情况下。如果我们依赖于一个抽象，我们可以根据不同的情况轻松地在不同的实现之间切换。已经出现了几个库来解决这个问题：Dagger、Koin
    和 Hilt。Dagger 更像是一个通用库，不仅适用于 Android，也适用于其他基于 Java 的平台。它旨在使用组件和模块来管理我们的依赖项。组件负责管理依赖项的方式，而模块负责提供适当的依赖项。它依赖于注解处理器，这些处理器生成负责管理我们依赖项的必要代码。Koin
    被称为服务定位器库。它保存所有依赖项的集合，当需要特定的依赖项时，它会查找并提供它。Koin 是一个特定于 Android 的库，它提供了注入特定 Android
    依赖项的支持。Hilt 是这些库中最新的，它是建立在 Dagger 之上的。它移除了 Dagger 所需的样板代码，并提供了对 Android 依赖项的支持。
- en: Android architecture components
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android 架构组件
- en: This is represented by a set of libraries that help developers make their apps
    scalable, testable, and maintainable. These libraries affect components that deal
    with activity and fragment life cycles, persisting data, background work, and
    UIs. Here, we have seen the introduction of concepts such as life cycle owners
    (such as activities and fragments), the Android ViewModel, and LiveData. These
    are meant to solve problems developers had with managing the state of a life cycle
    owner when it's destroyed and recreated by the system. It puts the logic that,
    in the past, was handled by the life cycle owners and delegated to the Android
    ViewModel. The combination of the Android ViewModel and LiveData has helped developers
    implement the MVVM pattern, which is also life cycle aware. This means that developers
    no longer have to concern themselves with stopping a background task when the
    life cycle owner is destroyed.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过一系列帮助开发者使他们的应用可扩展、可测试和可维护的库来表示。这些库影响处理活动、片段生命周期、数据持久化、后台工作和 UI 的组件。在这里，我们看到了生命周期所有者（如活动和片段）的概念引入，Android
    ViewModel 和 LiveData。这些是为了解决开发者在使用系统销毁和重新创建生命周期所有者时管理生命周期所有者状态的问题。它将过去由生命周期所有者处理并委托给
    Android ViewModel 的逻辑放在了其中。Android ViewModel 和 LiveData 的组合帮助开发者实现了 MVVM 模式，这也是生命周期感知的。这意味着开发者不再需要在生命周期所有者被销毁时停止后台任务。
- en: 'The introduction of Room means that developers no longer have to deal with
    interacting with the SQLite framework, which caused a lot of boilerplate code
    to be written to define tables and various queries. Developers no longer need
    to deal with the SQLite interaction and the many dependencies that come with it;
    instead, they can focus on creating their own models and providing the abstractions
    for what needs to be queried, deleted, updated, and deleted; Room will take care
    of the actual implementations. DataStore does for SharedPreferences what Room
    does for SQLite. This is for when we want to store data in key-value pairs instead
    of using an entire table. DataStore provides two options for storing data: safely
    typed data and no type safety data.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Room 的引入意味着开发者不再需要与 SQLite 框架进行交互，这导致了大量样板代码的编写，用于定义表和各种查询。开发者不再需要处理 SQLite
    交互及其带来的众多依赖；相反，他们可以专注于创建自己的模型，并提供需要查询、删除、更新和删除的抽象；Room 将负责实际的实现。DataStore 对 SharedPreferences
    的作用类似于 Room 对 SQLite 的作用。这是在我们想要以键值对的形式存储数据而不是使用整个表时的情况。DataStore 提供了两种存储数据的方式：安全类型数据和无类型安全数据。
- en: With the addition of these new persistence libraries, the Repository pattern
    was adopted. The idea behind this pattern is to create a class that will interact
    with all the data sources we have in our application. As an example, let's imagine
    we have some data we will need to fetch from our backend that will then need to
    be stored locally in case we want the user to view it offline. Our repository
    would be responsible for fetching the data from the network class and then storing
    it using the persistence class. The repository would sit in between the local
    and remote classes and the classes that would want access to that data.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 随着这些新持久化库的添加，采用了 Repository 模式。这个模式背后的想法是创建一个将与我们应用中所有数据源进行交互的类。例如，让我们假设我们有一些数据需要从后端获取，然后可能需要存储在本地，以便用户可以离线查看。我们的仓库将负责从网络类获取数据，然后使用持久化类进行存储。仓库将位于本地和远程类以及希望访问这些数据的类之间。
- en: Regarding the UI, we now have access to view binding and data binding. Both
    of these deal with how activities and fragments deal with the views that are declared
    in our XML layout files. View binding generates references for each view we defined
    in our XML. This solves an issue that developers would have in the past where
    a view would be deleted from your XML file, but your application would still run
    because of another view with the same name in another file. This would cause crashes
    in the past because the `findViewById` function would return `null`. With view
    binding, we know at compile time what views we have in our hierarchy and what
    views we don't. Data binding allows us to bind our views to data sources. For
    example, we can bind a `TextView` in our XML file directly to a field in our source
    code. This approach tends to work well with the MVVM pattern, in which the ViewModel
    updates certain fields that are bound by views in our XML. This would update what
    the view would display without it interacting with the activity.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 UI，我们现在可以访问视图绑定和数据绑定。这两者都处理活动（activities）和片段（fragments）如何处理在 XML 布局文件中声明的视图。视图绑定为我们在
    XML 中定义的每个视图生成引用。这解决了开发者过去可能会遇到的问题，即从 XML 文件中删除了一个视图，但由于另一个文件中存在同名视图，应用程序仍然可以运行。这过去会导致崩溃，因为
    `findViewById` 函数会返回 `null`。使用视图绑定，我们在编译时就知道我们的层次结构中有哪些视图，以及没有哪些视图。数据绑定允许我们将视图绑定到数据源。例如，我们可以将
    XML 文件中的 `TextView` 直接绑定到源代码中的一个字段。这种方法通常与 MVVM 模式配合良好，其中 ViewModel 更新由 XML 中的视图绑定的某些字段。这将更新视图将显示的内容，而无需与活动交互。
- en: Coroutines and flows
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协程和流
- en: Coroutines came as a feature of the Kotlin language. The idea behind coroutines
    is to execute data asynchronously in a very simplified manner. We no longer have
    to create threads or AsyncTasks (which have been deprecated) and manage concurrency
    because it's managed under the hood. Other features include that it's not bound
    to a particular thread, and it can be suspended and resumed. Flows represent an
    extension of coroutines where we can have multiple emissions of data, such as
    RxJava, providing similar benefits.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 协程是 Kotlin 语言的一个特性。协程背后的想法是以非常简化的方式异步执行数据。我们不再需要创建线程或 AsyncTasks（已被弃用）来管理并发，因为这一切都在底层管理。其他特性包括它不受特定线程的约束，并且可以被挂起和恢复。流是协程的扩展，我们可以有多次数据发射，例如
    RxJava，提供类似的好处。
- en: Jetpack Compose
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Jetpack Compose
- en: 'This allows developers to build UIs directly in Kotlin without the use of XML
    files through composable functions. This removes the amount of code that needs
    to be written for building your UI. Compatibility with the other Android architecture
    component libraries is provided, allowing for easier integration into your application.
    The following is an example of what Compose looks like:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许开发者通过组合函数直接在 Kotlin 中构建 UI，而不需要使用 XML 文件。这减少了构建 UI 需要编写的代码量。提供了与其他 Android
    架构组件库的兼容性，使得更容易集成到您的应用程序中。以下是一个 Compose 的示例：
- en: '[PRE8]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, we can see a screen that contains an input field, some text
    that displays `Example Text`, and a button with the text `Button`. The layout
    of the screen is defined as a function annotated with the `@Compose` annotation.
    This content is then set in an activity through the `setContent` method, where
    a theme is provided. We will expand on how Jetpack Compose works later in this
    book.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们可以看到一个包含输入字段、显示 `Example Text` 的文本和一些带有 `Button` 文本的按钮的屏幕。屏幕布局被定义为带有
    `@Compose` 注解的函数。然后通过 `setContent` 方法将这些内容设置在活动中，其中提供了一个主题。我们将在本书的后面部分进一步介绍 Jetpack
    Compose 的工作原理。
- en: Now, let's look at what our example code from the *The architecture of a legacy
    app* section will look like after we transition it through some of the aforementioned
    Android frameworks and updates. All our code will now be migrated to Kotlin. We
    will be using libraries such as Retrofit and Moshi for networking and JSON serialization
    and Hilt for dependency injection, as well as ViewModel, LiveData, and Compose
    for the UI layer. We will discuss how these libraries work in the following chapters.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看在将示例代码通过上述一些 Android 框架和更新转换后，*遗留应用程序架构*部分的代码将如何看起来。我们所有的代码现在都将迁移到 Kotlin。我们将使用
    Retrofit 和 Moshi 库进行网络和 JSON 序列化，以及 Hilt 进行依赖注入，以及 ViewModel、LiveData 和 Compose
    进行 UI 层。我们将在接下来的章节中讨论这些库的工作原理。
- en: 'The `ConcreteData` class will look this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcreteData` 类将看起来像这样：'
- en: '[PRE9]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `ConcreteData` class is now a Kotlin data class and will use the Moshi
    library for JSON conversion. Next, let''s see what our HTTP request will look
    like when we use something such as Retrofit to handle our HTTP communication:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcreteData`类现在是一个Kotlin数据类，并使用Moshi库进行JSON转换。接下来，让我们看看当我们使用Retrofit等工具处理HTTP通信时，我们的HTTP请求将是什么样子：'
- en: '[PRE10]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Because we use Retrofit and OkHttp, we only need to define the template for
    the endpoint we want to connect to and the data we want; the libraries will handle
    the rest. The `suspend` keyword will come in handy for Kotlin flows.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用Retrofit和OkHttp，我们只需要定义我们想要连接的端点模板和我们想要的数据；库将处理其余部分。`suspend`关键字对于Kotlin
    flows来说将非常有用。
- en: 'Now, let''s define a repository class that will be responsible for invoking
    this HTTP call on a separate thread:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义一个负责在单独线程上调用此HTTP调用的存储库类：
- en: '[PRE11]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`ConcreteDataRepository` will have a dependency on `ConcreteDataService`, which
    it will call to fetch the data. It will be responsible for retrieving the data
    on a separate thread by using Kotlin flows. The constructor will be annotated
    with the `@Inject` annotation because we are using Hilt, which will inject `ConcreteDataService`
    into `ConcreteDataRepository`.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcreteDataRepository`将依赖于`ConcreteDataService`，它将调用以获取数据。它将负责通过使用Kotlin
    flows在单独的线程上检索数据。构造函数将使用`@Inject`注解，因为我们使用Hilt，它将`ConcreteDataService`注入到`ConcreteDataRepository`中。'
- en: 'Now, let''s create a `ViewModel` that will depend on the repository to load
    the appropriate data:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个`ViewModel`，它将依赖于存储库来加载适当的数据：
- en: '[PRE12]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`MainViewModel` will then use `ConcreteDataRepository` to retrieve the data,
    subscribe to the result, and post the result in `LiveData`, which `MainActivity`
    will subscribe to.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainViewModel`将使用`ConcreteDataRepository`检索数据，订阅结果，并在`LiveData`中发布结果，`MainActivity`将订阅此`LiveData`。'
- en: 'Now, let''s create `MainActivity`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建`MainActivity`：
- en: '[PRE13]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`MainActivity` is now written using Jetpack Compose. It will trigger the data
    load when the screen is created and then subscribe to `LiveData` from `ViewModel`,
    which will update the text on the screen when the data is loaded.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainActivity`现在使用Jetpack Compose编写。它将在屏幕创建时触发数据加载，然后订阅`ViewModel`的`LiveData`，当数据加载时，将在屏幕上更新文本。'
- en: 'Since we are using Hilt for dependency injection, we will need to define our
    external dependencies in a module, as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用Hilt进行依赖注入，因此我们需要在模块中定义我们的外部依赖项，如下所示：
- en: '[PRE14]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: First, we must provide the `OkHttp` client, which is used to make the HTTP requests.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须提供`OkHttp`客户端，它用于发出HTTP请求。
- en: 'Next, we will need to provide the JSON serialization:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要提供JSON序列化：
- en: '[PRE15]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We are using the Moshi library for JSON serialization, so we will have to provide
    a Factory that will be used by Retrofit for JSON conversion.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Moshi库进行JSON序列化，因此我们需要提供一个工厂，该工厂将被Retrofit用于JSON转换。
- en: 'Next, we need to provide a Retrofit object:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要提供一个Retrofit对象：
- en: '[PRE16]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The Retrofit object will need a base URL that will act as the host for our backend
    service, `OkHttpClient`, and the JSON converter factory, which were provided earlier.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Retrofit对象需要一个基础URL，它将作为我们后端服务的宿主，`OkHttpClient`，以及之前提供的JSON转换器工厂。
- en: 'Finally, we will need to provide the template we defined previously:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要提供之前定义的模板：
- en: '[PRE17]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we will use Retrofit to create an instance of `ConcreteDataService` that
    will be injected into `ConcreteDataRepository` by Hilt.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用Retrofit创建`ConcreteDataService`的实例，该实例将通过Hilt注入到`ConcreteDataRepository`中。
- en: 'Finally, we need to initialize Hilt in the `Application` class:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在`Application`类中初始化Hilt：
- en: '[PRE18]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This code represents a 10-year jump in time when it comes to Android development.
    Going back to the questions we asked for the initial example in the Legacy analysis
    section, we can see that we answered quite a few. If we want to introduce persistence
    into the application, we now have a repository that can manage that for us. We
    also have a lot of classes that can be individually unit tested because of the
    introduction of Hilt and because we have delimited separated from the Android
    framework dependencies. We have also introduced flows, which allow us to manipulate
    and handle the data in case we need to connect to multiple sources and handle
    multi-threading more easily. The introduction of Kotlin and Retrofit also allowed
    us to reduce the amount of code. If we were to make a diagram of this, it would
    look as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码代表了 Android 开发在时间上10年的跳跃。回到我们在遗留分析部分提出的初始示例问题，我们可以看到我们回答了很多。如果我们想在应用中引入持久性，我们现在有一个可以为我们管理这一点的仓库。我们还拥有许多可以单独进行单元测试的类，因为
    Hilt 的引入以及我们将 Android 框架依赖项分离开来。我们还引入了流程，这允许我们在需要连接到多个源并更轻松地处理多线程时操纵和处理数据。Kotlin
    和 Retrofit 的引入也使我们能够减少代码量。如果我们绘制这个图，它看起来会如下所示：
- en: '![Figure 1.4 – A class diagram for a newer Android application'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.4 – 一个较新 Android 应用的类图'
- en: '](img/Figure_1.04_B18320.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.4 – 一个较新 Android 应用的类图](img/Figure_1.04_B18320.jpg)'
- en: Figure 1.4 – A class diagram for a newer Android application
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – 一个较新 Android 应用的类图
- en: Here, we can see that the dependencies between the classes go from one direction
    to the other, which is another positive. The introduction of Retrofit saved us
    a lot of hassle when dealing with HTTP requests. But an issue remains with regards
    to how `ConcreteData` is handled. We can see that it travels from `ConcreteDataService`
    into `MainActivity`. Imagine if we wanted to provide the data from a different
    URL with a different POJO representation. This means that all of the classes will
    have to be changed to accommodate for this. This violates the single responsibility
    principle because the `ConcreteData` class is used to serve multiple actors in
    our application. In the next section, we will try to seek a solution to this problem
    and address ways to properly structure our classes and components.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到类之间的依赖关系是从一个方向到另一个方向，这是另一个积极的方面。Retrofit 的引入在处理 HTTP 请求时为我们节省了很多麻烦。但是，关于如何处理
    `ConcreteData` 的问题仍然存在。我们可以看到它从 `ConcreteDataService` 流向 `MainActivity`。想象一下，如果我们想从不同的
    URL 提供数据，并且使用不同的 POJO 表示，这意味着所有类都必须进行更改以适应这一点。这违反了单一职责原则，因为 `ConcreteData` 类被用来服务于我们应用中的多个角色。在下一节中，我们将尝试寻求解决这个问题的方法，并讨论如何正确地构建我们的类和组件。
- en: With that, we have explored the evolution of the Android platform and tools,
    what an application may look like using the latest tools and libraries, and how
    this evolution solved many problems developers had in the past. However, we still
    haven't solved all of them. In the next section, we will talk about the concept
    of clean architecture and how we can use it to make our application flexible and
    more adaptable to changes.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以上内容，我们已经探讨了 Android 平台和工具的演变，使用最新工具和库的应用可能的样子，以及这种演变如何解决了开发者过去遇到的一些问题。然而，我们仍未解决所有问题。在下一节中，我们将讨论清洁架构的概念以及我们如何利用它使我们的应用更加灵活，并能更好地适应变化。
- en: Enter clean architecture
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进入清洁架构
- en: In this section, we will discuss the concept of clean architecture, the problems
    it solves, and how it can be applied to an Android application.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论清洁架构的概念、它解决的问题以及如何将其应用于 Android 应用。
- en: Architecture can be viewed as the high-level solution that's required to build
    a system that can solve business and technical requirements. The goal should be
    to keep as many options on the table for as long as we can. From an Android development
    perspective, we've seen the platform grow a lot, and to balance the new changes
    that have been added to the platform with the addition of new features for our
    application and its maintenance, we will need to give our application a very good
    foundation so that it will adapt to changes. A common approach to architecture
    in Android development was the layered architecture, where apps would be split
    into three layers – the user interface, domain, and data layers. The problem here
    was that the domain layer depended on the data layer, so when the data layer changed,
    the domain layer needed to change too.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 架构可以看作是构建一个能够解决业务和技术需求的高层次解决方案。目标应该是尽可能长时间地保留尽可能多的选项。从Android开发的角度来看，我们已经看到平台发展壮大，为了平衡平台新增的功能和我们的应用程序及其维护的新变化，我们需要为我们的应用程序提供一个非常好的基础，以便它能够适应变化。Android开发中架构的常见方法是将应用程序分为三个层次——用户界面、领域和数据层。这里的问题是领域层依赖于数据层，因此当数据层发生变化时，领域层也需要进行相应的更改。
- en: 'Clean architecture represents an integration of multiple types of architecture
    that provide independence from frameworks, user interfaces, and databases, as
    well as being testable. The shape resembles that of an onion, where dependencies
    go toward the inner layers. These layers are as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 清洁架构代表了多种架构的集成，这些架构提供了对框架、用户界面和数据库的独立性，同时也能进行测试。其形状类似于洋葱，其中依赖关系指向内层。这些层如下：
- en: '**Entity Layer**: This layer is the innermost layer and is represented by objects
    that hold data or business-critical functions.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实体层**：这一层是最内层，由持有数据或业务关键功能的对象表示。'
- en: '**Use Case Layer**: This layer implements the business logic of the system.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用例层**：这一层实现了系统的业务逻辑。'
- en: '**Interface Adapter Layer**: This layer is responsible for converting the data
    between the frameworks and drivers and the use case. This will hold components
    such as ViewModels and presenters, as well as various converters that are responsible
    for converting network and persistence-related data into entities.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口适配层**：这一层负责在框架和驱动程序与用例之间转换数据。这一层将包含诸如ViewModels和演示者等组件，以及各种转换器，这些转换器负责将网络和持久性相关的数据转换为实体。'
- en: '**Frameworks and Drivers Layer**: This layer is the outermost layer and is
    comprised of components such as activities, fragments, networking components,
    and persistence components.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**框架和驱动层**：这一层是最外层，由活动、片段、网络组件和持久性组件等组成。'
- en: 'Let''s consider a scenario: you''ve recently been hired by a start-up company
    as their first Android engineer. You have been given a basic idea of what the
    app that you''ve been asked to develop should do, but there isn''t anything too
    concrete; the user interface has not been finalized, the teams working on the
    backend are new themselves, and there isn''t anything too concrete on their side
    either. What you do know is a set of use cases that specify what the app does:
    log into a system, load a list of tasks and add new tasks, delete tasks, and edit
    existing tasks. The product owner tells you that you should work on something
    while using mock data so that they can get a feel of the product and consult with
    the user interface and user experience teams to discuss improvements and modifications.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个场景：你最近被一家初创公司雇佣为他们的首位Android工程师。你已经得到了一个关于你被要求开发的应用程序应该做什么的基本想法，但并没有什么具体的内容；用户界面尚未确定，负责后端的团队本身也是新手，他们那边也没有什么具体的内容。你所知道的是一组用例，这些用例指定了应用程序的功能：登录系统、加载任务列表并添加新任务、删除任务和编辑现有任务。产品负责人告诉你，你应该使用模拟数据来工作，这样他们可以感受到产品的感觉，并与用户界面和用户体验团队讨论改进和修改。
- en: 'You are faced with a choice here: you can build the product that''s been requested
    by the product owner as fast as possible and then constantly refactor your code
    for each new integration and the change in requirements, or you can take a little
    bit more time and factor in the future changes that will come into your approach.
    If you were to take the first approach, then you would find yourself in a situation
    where many developers found themselves, which is to go back and change things
    properly. Let''s assume you chose the second approach. What would you need to
    do then? You can start decoupling your code into separate layers. You know that
    the UI will change, so you will need to keep it isolated so that when it is changed,
    the change will only be isolated to that particular section. Often, the UI is
    referred to as the presentation layer.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里面临一个选择：你可以尽可能快地构建产品所有者请求的产品，然后不断地重构代码以适应每个新的集成和需求的变化，或者你可以花更多的时间，考虑到未来可能对你的方法产生的影响。如果你选择第一种方法，那么你可能会发现自己处于许多开发者都曾遇到的情况，那就是回去正确地更改事物。让我们假设你选择了第二种方法。那么你需要做什么呢？你可以开始将你的代码解耦成单独的层。你知道UI会变化，所以你需要将其隔离，以便当它发生变化时，变化只会局限于那个特定的部分。通常，UI被称为表示层。
- en: Next, you want to decouple the business logic. This is something specific to
    processing the data that your app will use. This is often done in the domain layer.
    Finally, you want to decouple how the data is loaded and stored. This will be
    the part where you deal with integrating libraries such as Room and Retrofit and
    it's often called the data layer. Because the requirements aren't definitive yet,
    you also want to decouple how you want to handle use cases so that if a use case
    changes, you can protect the others from that change. If you were to rotate the
    class diagram from *Figure 1.4*, you would see a layered approach to this example.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你想要解耦业务逻辑。这是处理你的应用程序将使用的数据的具体事情。这通常在领域层完成。最后，你想要解耦数据的加载和存储方式。这将是你处理集成库（如Room和Retrofit）的部分，通常被称为数据层。因为需求尚未确定，你还想要解耦你想要处理用例的方式，以便如果用例发生变化，你可以保护其他部分不受该变化的影响。如果你旋转*图1.4*中的类图，你会看到对这个示例的分层方法。
- en: As we've mentioned previously, the fact that `ConcreteData` shows up in all
    the classes in our example is not a good idea. This is because, at the end of
    the day, the fact that we chose Retrofit and Moshi shouldn't impact the rest of
    the application. This is similar if it was the opposite way around and the activity
    or `ViewModel` would've done the same. At the end of the day, the way we choose
    to implement our UI or what networking library we should use represent details.
    Our domain layer shouldn't be impacted by any of these choices.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，`ConcreteData`出现在我们示例中的所有类中并不是一个好主意。这是因为，最终，我们选择Retrofit和Moshi的事实不应该影响到应用程序的其他部分。如果情况相反，活动或`ViewModel`会做同样的事情。最终，我们选择实现UI或我们应该使用哪个网络库代表细节。我们的领域层不应该受到这些选择中的任何影响。
- en: What we are doing here is establishing boundaries between the components in
    our system so that a change in a component doesn't impact a change in another
    component. In Android, even if we use the latest libraries and frameworks, we
    should still make sure that our domain is still protected by changes in those
    frameworks. Going back to the start-up example, and assuming you've chosen to
    decouple your components and pick the appropriate boundaries, after many demos
    and iterations, your company decides to hire additional developers to work on
    new, separate features. If those developers follow the guidelines you've set up,
    they can work with a minimal level of overlap.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是在我们系统的组件之间建立边界，以便一个组件的变化不会影响到另一个组件的变化。在Android中，即使我们使用了最新的库和框架，我们也应该确保我们的领域仍然受到这些框架变化的保护。回到启动示例，假设你已经选择了解耦你的组件并选择合适的边界，经过多次演示和迭代后，你的公司决定雇佣额外的开发者来开发新的、独立的功能。如果这些开发者遵循你设定的指南，他们可以以最小的重叠程度进行工作。
- en: The recommendation from Android development documentation is to take advantage
    of modules. One of the arguments is that it improves build speed because when
    you work on a certain module, it won't rebuild the others when you build the application
    – it caches them instead. Splitting your application into multiple modules serves
    another purpose.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Android 开发文档的建议是利用模块化。其中一个论点是它提高了构建速度，因为当你在一个特定的模块上工作时，构建应用程序时不会重建其他模块 – 相反，它会缓存它们。将你的应用程序拆分为多个模块还有另一个目的。
- en: Let's go back to the start-up. Things are going great and people love your product,
    so your company decides to open your APIs for other businesses to integrate into
    their systems. Your company also wants to provide an Android library so that it's
    easier for businesses to access your APIs. You already have this logic integrated
    into your application; you just need to export it. What features do you want to
    export? All? None? Do they want to persist data locally? Do they want some of
    the UI or not? If your modules were split with proper boundaries, then you would
    be able to accommodate all of those features. What we want to do is have a system
    where we can easily plug things in and easily plug them out.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到启动阶段。一切都很顺利，人们都很喜欢你的产品，所以你的公司决定向其他业务开放你的 API，以便它们可以集成到自己的系统中。你的公司还希望提供一个
    Android 库，以便业务更容易访问你的 API。你已经在应用程序中集成了这个逻辑；你只需要导出它。你想要导出哪些功能？全部？没有？他们想要本地持久化数据吗？他们想要一些
    UI 还是不要？如果你的模块是以适当的边界拆分的，那么你将能够容纳所有这些功能。我们想要的是一个可以轻松插入和拔出的系统。
- en: 'Transitioning our previous example to this approach, we would have something
    like this. The `ConcreteData` class and `ConcreteDataService` would remain the
    same:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们之前的示例过渡到这种方法，我们会有如下内容。`ConcreteData` 类和 `ConcreteDataService` 将保持不变：
- en: '[PRE19]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we will need to isolate the Retrofit library and create the interface
    adapter for it. But to do that, we will need to define our entity:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要隔离 Retrofit 库并为它创建接口适配器。但要做到这一点，我们需要定义我们的实体：
- en: '[PRE20]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It looks like it's a duplicate of `ConcreteData`, but this is a case of fake
    duplication. In reality, as things evolve, the two classes may contain different
    data, so they will need to be separated.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来像是 `ConcreteData` 的重复，但这是一种虚假重复的情况。实际上，随着事物的演变，这两个类可能包含不同的数据，因此它们需要被分离。
- en: 'To isolate the Retrofit call, we need to invert the dependency of our repository.
    So, let''s create a new interface that will return `ConcreteEntity`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了隔离 Retrofit 调用，我们需要反转我们仓库的依赖。所以，让我们创建一个新的接口，它将返回 `ConcreteEntity`：
- en: '[PRE21]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In our implementation, we will invoke the Retrofit service interface:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的实现中，我们将调用 Retrofit 服务接口：
- en: '[PRE22]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we have invoked `ConcreteDataService` and then converted the network model
    into an entity.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经调用了 `ConcreteDataService` 并将网络模型转换为实体。
- en: 'Now, our repository will change into the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的仓库将变成以下形式：
- en: '[PRE23]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`ConcreteDataRepository` will depend on `ConcreteDataSource` to avoid the dependencies
    on the networking layer.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcreteDataRepository` 将依赖于 `ConcreteDataSource` 以避免对网络层的依赖。'
- en: 'Now, we need to build the use case to retrieve `ConcreteEntity`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要构建用例来检索 `ConcreteEntity`：
- en: '[PRE24]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`ConcreteDataUseCase` will depend on `ConcreteDataRepository` to retrieve the
    data and emit it using Kotlin flows.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcreteDataUseCase` 将依赖于 `ConcreteDataRepository` 来检索数据并使用 Kotlin 流发射数据。'
- en: 'Now, `MainViewModel` will need to be changed to invoke the use case. To do
    so, it will use the `field1` object from `ConcreteEntity`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`MainViewModel` 需要被修改以调用用例。为此，它将使用 `ConcreteEntity` 中的 `field1` 对象：
- en: '[PRE25]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`MainViewModel` will now depend on `ConcreteDataUseCase` and retrieve `ConcreteEntity`,
    where it will extract `field1`. This will then be set in `LiveData`.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainViewModel` 现在将依赖于 `ConcreteDataUseCase` 并检索 `ConcreteEntity`，其中它将提取 `field1`。然后这将设置在
    `LiveData` 中。'
- en: '`MainActivity` will be updated to use the `textData` object from `MainViewModel`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainActivity` 将被更新以使用来自 `MainViewModel` 的 `textData` 对象：'
- en: '[PRE26]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: With that, `MainActivity` has been updated to use `LiveData`, which emits a
    `String` instead of a `ConcreteData` object.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`MainActivity` 就被更新为使用 `LiveData`，它发射一个 `String` 而不是 `ConcreteData` 对象。
- en: 'Finally, the Hilt module will be updated as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Hilt 模块将被更新如下：
- en: '[PRE27]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, we can see that `ConcreteDataUseCase` just invokes `ConcreteDataRepository`,
    which just invokes `ConcreteDataSource`. You may be wondering why this boilerplate
    is necessary. In this case, we have a bit of fake duplication. As the code grows,
    `ConcreteDataRepository` may connect to other data sources, and `ConcreteDataUseCase`
    may need to connect to multiple repositories to combine the data. The same can
    be said about `ConcreteData` and `ConcreteEntity`. Another benefit of this approach
    is the imposition of more rigor when it comes to development, and it creates consistency.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到 `ConcreteDataUseCase` 只调用了 `ConcreteDataRepository`，而 `ConcreteDataRepository`
    又只调用了 `ConcreteDataSource`。你可能想知道为什么这个样板代码是必要的。在这种情况下，我们有一点点虚假的重复。随着代码的增长，`ConcreteDataRepository`
    可能会连接到其他数据源，而 `ConcreteDataUseCase` 可能需要连接到多个存储库来合并数据。对于 `ConcreteData` 和 `ConcreteEntity`
    也是如此。这种方法的另一个好处是在开发过程中强制执行更多的严谨性，并创造了一致性。
- en: 'Let''s look at the following diagram and see how it compares to *Figure 1.4*:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下下面的图表，看看它与 *图 1.4* 的比较：
- en: '![Figure 1.5 – Clean architecture'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.5 – 清洁架构'
- en: '](img/Figure_1.05_B18320.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.05_B18320.jpg)'
- en: Figure 1.5 – Clean architecture
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5 – 清洁架构
- en: If we look at the top row, we will see the use case and the entity. We can also
    see that the dependencies go from the classes at the bottom toward the classes
    at the top, similar to how the dependencies go from the outer layers toward the
    inner layers here. A difference you may have noticed is that our example doesn't
    mention the usage of modules. Later in this book, we will explore how to apply
    clean architecture to multiple modules and how to manage them.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看最上面的一行，我们会看到用例和实体。我们还可以看到依赖关系是从底部的类到顶部的类，这与这里从外部层到内部层的依赖关系相似。你可能注意到的不同之处在于，我们的示例没有提到模块的使用。在本书的后面部分，我们将探讨如何将清洁架构应用于多个模块以及如何管理它们。
- en: We are now back in the start-up, and you started working on the application,
    where you have defined a few entities and use cases and have put a simple UI in
    place. The product owner has asked you to deliver a demo with some mock data for
    tomorrow. What can you do? You can create a new implementation of your data source
    and plug in some mock objects that you can use to satisfy the conditions for the
    demo. You show the demo of the application and you receive some feedback about
    your UI. This means you can change your activities and fragments to render the
    data appropriately, and this won't impact any of the other components. What would
    happen if the use case were to change? In that situation, this would propagate
    into the rest of the other layers. This depends on the change, though, but this
    scenario is to be expected in this situation.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们回到了初创公司，你开始着手开发应用程序，其中你定义了一些实体和用例，并放置了一个简单的用户界面。产品负责人要求你明天提供一个带有一些模拟数据的演示。你能做什么？你可以创建一个新的数据源实现，并插入一些你可以用来满足演示条件的模拟对象。你展示了应用程序的演示，并收到了一些关于你用户界面的反馈。这意味着你可以更改你的活动和片段以适当地渲染数据，而这不会影响任何其他组件。如果用例发生变化会怎样？在这种情况下，这将传播到其他层。但这取决于变化，但这种情况是可以预料的。
- en: Summary
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored what an Android app used to look like and all the
    problems developers would face at the time. We've looked at some of the most important
    software design principles, such as SOLID, to get a better understanding of how
    to improve our code and how these principles helped the Android platform evolve.
    We also looked at the adoption of a new programming language that came with the
    introduction of new software paradigms, the addition of event-based libraries
    and frameworks, the introduction of architecture components to help developers
    write more testable applications, and a new way to build user interfaces. Finally,
    we introduced clean architecture, which helps us build maintainable, testable,
    and more independent applications. We looked at all of these changes through a
    small example, where we saw them transition from what they may have looked like
    in 2010 to what they may look like now.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 Android 应用过去的样子以及开发者当时可能会遇到的所有问题。我们研究了最重要的软件设计原则，例如 SOLID，以更好地理解如何改进我们的代码以及这些原则如何帮助
    Android 平台发展。我们还探讨了随着新软件范式的引入而采用的新编程语言，事件库和框架的添加，引入架构组件以帮助开发者编写更可测试的应用程序，以及构建用户界面的新方法。最后，我们介绍了清洁架构，它帮助我们构建可维护、可测试且更独立的应用程序。我们通过一个小示例来观察所有这些变化，从它们可能在
    2010 年的样子到它们现在的样子。
- en: In the next chapter, we will deep dive into the libraries that are required
    for loading, storing, and managing data on Android. We will combine them to build
    an app using clean architecture.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨在Android上加载、存储和管理数据的库。我们将结合它们使用干净的架构来构建一个应用程序。
