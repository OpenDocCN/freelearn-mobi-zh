- en: Chapter 7. Troubleshooting and Best Practices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 故障排除和最佳实践
- en: Primarily, this chapter will explore how to enhance the quality of games and
    applications using different techniques and physically-based shaders. Secondly,
    this chapter will describe global illumination in Unity 5\. At the end of the
    chapter, you will optimize a shader code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 主要地，本章将探讨如何使用不同的技术和基于物理的着色器来提高游戏和应用程序的质量。其次，本章将描述Unity 5中的全局照明。在本章结束时，你将优化着色器代码。
- en: 'The topics that will be covered in the chapter are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Measuring performance with the built-in Android profiler
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内置Android分析器测量性能
- en: Debugging Android devices with the Unity profiler tool
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Unity分析器工具调试Android设备
- en: Best practices in scripts and shaders
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本和着色器中的最佳实践
- en: Measuring performance with the built-in Android profiler
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内置Android分析器测量性能
- en: Let's look at what kind of information we can see from the built-in Android
    profiler in Unity 5.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们可以从Unity 5的内置Android分析器中看到哪些信息。
- en: General CPU activity
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一般CPU活动
- en: Next, we're going to talk about the information we can get from the built-in
    profiler. To make it easier to understand the structure of these messages, we'll
    cover them in groups. The first group includes the general information or in other
    words the overall performance statistics on the CPU.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论我们可以从内置分析器中获得的信息。为了更容易理解这些消息的结构，我们将它们分为几个组。第一个组包括一般信息，换句话说，是CPU的整体性能统计信息。
- en: You will see the total time that was spent by the CPU in the parameter value
    called `cpu-player`. The time that was spent on the CPU side by the OpenGLES driver
    code will be seen in the value of the parameter called `cpu-ogles-drv`. Next,
    let's consider the following parameter, known as `cpu-waits-gpu`. This option
    will not appear in the built-in profiler for very small values. This value shows
    how much CPU time was spent waiting for the end of rendering on the GPU side.
    Next, let's consider the following parameter, known as `msaa-resolve`. This value
    shows how much CPU time was spent on anti-aliasing methods. Let's consider the
    following parameter, known as `cpu-present`. This value shows how much CPU time
    was spent on executing the OpenGLES `presentRenderbuffer` function. Let's also
    look at the value of the last parameter in this group, known as `frametime`. This
    value shows the time spent on the CPU side for frame execution.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到在参数值`cpu-player`中消耗的总CPU时间。在CPU端由OpenGLES驱动代码消耗的时间将在名为`cpu-ogles-drv`的参数值中看到。接下来，让我们考虑以下参数，称为`cpu-waits-gpu`。对于非常小的值，此选项不会出现在内置分析器中。此值显示了在GPU端等待渲染结束所消耗的CPU时间。接下来，让我们考虑以下参数，称为`msaa-resolve`。此值显示了在抗锯齿方法上消耗的CPU时间。让我们考虑以下参数，称为`cpu-present`。此值显示了在执行OpenGLES的`presentRenderbuffer`函数上消耗的CPU时间。让我们也看看这个组中最后一个参数的值，称为`frametime`。此值显示了在CPU端执行帧所花费的时间。
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Refresh rate of the Android hardware is locked at about 60 Hz, so you will have
    the frame time at about ~16.7 ms (approximately 16.7 milliseconds we get from
    computing—1000 milliseconds divided by 60 Hz).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Android硬件的刷新率锁定在大约60 Hz，因此你将得到大约~16.7 ms的帧时间（大约是16.7毫秒，我们通过计算得到——1000毫秒除以60
    Hz）。
- en: Rendering statistics
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染统计信息
- en: Now let's consider the following group of statistics based on the rendering.
    This group contains only four parameters. The first parameter is called a `draw
    call`. The true meaning of this value is to show draw calls quantified per frame.
    The second parameter of this group is known as `tris`. This value indicates how
    many triangles the renderer will process. The third parameter of this group is
    known as `verts`. This value shows how many vertices the renderer will process.
    The upper limit number for static geometry is 10,000 vertices and much lower for
    skinned geometry. Finally, the last parameter, which we will study in this group,
    is called `batched`. The value of this parameter greatly affects your performance,
    so try to reduce this value as much as possible. This value demonstrates the number
    of automatically batched draw calls, triangles, and vertices by the Unity engine.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑以下基于渲染的统计信息组。这个组中只包含四个参数。第一个参数被称为`draw call`。这个值的真正含义是显示每帧的绘制调用量。这个组的第二个参数被称为`tris`。这个值表示渲染器将处理的三角形数量。这个组的第三个参数被称为`verts`。这个值显示了渲染器将处理的顶点数量。静态几何体的上限数量为10,000个顶点，而皮肤几何体的上限则要低得多。最后，这个组中的最后一个参数，我们将在这个组中研究，被称为`batched`。这个参数的值对你的性能有很大影响，所以尽量尽可能减少这个值。这个值展示了Unity引擎自动批处理的绘制调用、三角形和顶点的数量。
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In order to improve Unity engine batching, you should use shared materials everywhere
    possible for all available objects.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高Unity引擎的批处理效率，你应该尽可能地为所有可用的对象使用共享材质。
- en: Detailed Unity player statistics
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 详细Unity玩家统计信息
- en: Now, consider the following group of statistics, which is more detailed. The
    first parameter in the detailed statistics of the built-in profiler is known as
    `physx`. This value indicates the time spent on physics engine execution. The
    text parameter is called `animation`. This value indicates the time spent on bone
    animations. The third parameter in the detailed statistics is called `culling`.
    This value indicates how much time was spent culling the object's execution. The
    fourth parameter in the detailed statistics of the built-in profiler is known
    as `skinning`. This value indicates the time we need to apply animations to skinned
    meshes. The fifth parameter in this detailed statistics is called `batching`.
    This value shows the time spent on batching geometry execution.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑以下更详细的统计信息组。在内置分析器的详细统计信息中，第一个参数被称为`physx`。这个值表示物理引擎执行所花费的时间。文本参数被称为`animation`。这个值表示骨骼动画所花费的时间。详细统计信息中的第三个参数被称为`culling`。这个值表示花费在对象执行剔除上的时间。内置分析器详细统计信息中的第四个参数被称为`skinning`。这个值表示将动画应用到皮肤网格所需的时间。在这个详细统计信息中的第五个参数被称为`batching`。这个值显示了在批处理几何体执行上花费的时间。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Batching static geometry is less expensive versus batching dynamic geometry.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 与批处理动态几何体相比，批处理静态几何体成本较低。
- en: The sixth parameter in the detailed statistics is called `render`. This value
    represents the execution time spent on rendering visible objects. The seventh
    parameter is called `fixed-update-count`. This value shows the upper and lower
    values of the `FixedUpdate` execution time for the current frame. Try to decrease
    this value as much as possible because it can decrease your performance.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在详细统计信息中的第六个参数被称为`render`。这个值代表了渲染可见对象所花费的执行时间。第七个参数被称为`fixed-update-count`。这个值显示了当前帧`FixedUpdate`执行时间的上下限值。尽量尽可能减少这个值，因为它可以降低你的性能。
- en: Detailed script statistics
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脚本详细统计信息
- en: There are just three obtainable parameters. The first one is known as `update`.
    This value determines the time used for execution per `Update` function in your
    scripts. The next parameter is called `fixedUpdate`. This value demonstrates the
    time used for all executions per `FixedUpdate` function in your scripts. The following
    parameter is known as `coroutines`. This value determines the time utilized for
    coroutines execution in your scripts.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 只有三组可获取的参数。第一个参数被称为`update`。这个值决定了你的脚本中每个`Update`函数执行的用时。下一个参数被称为`fixedUpdate`。这个值展示了你的脚本中每个`FixedUpdate`函数执行的用时。接下来的参数被称为`coroutines`。这个值决定了你的脚本中协程执行的用时。
- en: Detailed statistics on memory allocated by scripts
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脚本分配内存的详细统计信息
- en: Let's cover the following group of statistics based on detailed statistics for
    memory allocation by your scripts. There are only four parameters. The first parameter
    is called `allocated heap`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们根据您脚本内存分配的详细统计信息来介绍以下一组统计数据。这里只有四个参数。第一个参数被称为`分配堆`。
- en: This value represents available memory for allocation. If we need more memory
    than is available in the heap, a garbage collector will be called. However, if
    the garbage collector cannot free up more memory for us, then the heap will be
    increased in size. The next parameter is known as `used heap`. This value indicates
    the allocated heap by objects. It will be increased for each new class instance,
    and not for structs before the garbage collector will be called one more time.
    The following parameter is known as `max numbers of collections`. This value shows
    the quantity of the garbage collector calls within the last 30 frames. The last
    parameter in this group, and the last one in the built-in profiler, is called
    `collection total duration`. This value displays the summarized milliseconds used
    for the garbage collector calls within the last 30 frames.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此值表示可用于分配的内存。如果我们需要的内存超过了堆中可用的内存，垃圾回收器将被调用。然而，如果垃圾回收器无法为我们释放更多内存，那么堆的大小将会增加。下一个参数被称为`已用堆`。此值表示对象分配的堆大小。每次创建新的类实例时，它都会增加，但在垃圾回收器再次被调用之前，结构体不会增加。下一个参数被称为`最大收集次数`。此值显示了在过去30帧中垃圾回收器调用的数量。在这个组中的最后一个参数，也是内置分析器的最后一个参数，被称为`收集总持续时间`。此值显示了在过去30帧中垃圾回收器调用所使用的总毫秒数。
- en: Debugging Android devices with the Unity profiler tool
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Unity分析器工具调试Android设备
- en: We can open the Unity profiler window from the menu, which presents the whole
    Unity profiler tool. In the upcoming sections, we will explore more about the
    Unity profiler areas.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从菜单中打开Unity分析器窗口，它展示了整个Unity分析器工具。在接下来的章节中，我们将更深入地探讨Unity分析器区域。
- en: 'Before starting, we need to know how this tool is works and how simple it is
    to use. Firstly, let''s look more at the Unity profiler tool window structure
    and separate its parts. As we can see in the next screenshot, there are four main
    visual parts:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，我们需要了解这个工具是如何工作的，以及它有多么简单易用。首先，让我们更详细地看看Unity分析器工具窗口的结构，并分别介绍其各个部分。正如我们可以在下一张截图中所看到的，有四个主要视觉部分：
- en: Profiler controls
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析器控件
- en: Usage area
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用区域
- en: Profiler timeline
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析器时间线
- en: Information table
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信息表
- en: The upcoming sections focus on these distinctive parts of the Unity profiler
    tool. Let's dive into the most interesting thing in this instrument.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的章节将专注于Unity分析器工具的独特部分。让我们深入探讨这个工具中最有趣的部分。
- en: Regarding the visual profiler, you can connect to access devices on which your
    application is performing in order to further analyze the performance of your
    software. In order to connect to the other device, it is necessary (but not just
    sufficient) for the profiler to be on the same local network. The **Active Profiler**
    option allows you to select your device from a list of the desired connections.
    Besides that, your application should be launched with the **Development Build
    enabled** checkbox from **Build Settings**. Also in these settings, you will see
    the **Autoconnect profiler** option, which is necessary to signal whether Unity
    should or should not be connected to the profiler every time you start your application.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 关于可视化分析器，您可以连接到运行您应用程序的设备，以进一步分析您软件的性能。为了连接到其他设备，分析器必须在同一本地网络中（但这不是必要的充分条件）。**活动分析器**选项允许您从所需连接的列表中选择您的设备。除此之外，您应该通过**构建设置**中的**开发构建启用**复选框启动应用程序。在这些设置中，您还会看到**自动连接分析器**选项，这是必要的，以指示Unity每次启动应用程序时是否应该连接到分析器。
- en: 'The following are the Unity profiler buttons:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些Unity分析器按钮：
- en: '**Record**'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**记录**'
- en: '**Deep Profiler**'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**深度分析器**'
- en: '**Profile Editor**'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置文件编辑器**'
- en: '**Active Profiler**'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**活动分析器**'
- en: '**Clear**'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清除**'
- en: '![Debugging Android devices with the Unity profiler tool](img/9191OT_07_01.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![使用Unity分析器工具调试Android设备](img/9191OT_07_01.jpg)'
- en: If you look at the top of the profiler window, you will see there is a toolbar,
    which we will examine in more detail later in the chapter. Using the buttons on
    the toolbar, you can enable or disable the profiler recording data. Also, you
    can clear the collected information or navigate in the frame set and much more;
    we will talk more about this later. Right in the toolbar, we see the **Current**
    button. After clicking on this button, we will automatically get on a frame and
    the last detail of its implementation. If your game was played in the Unity editor,
    it will be suspended, meaning it will be paused. It will also be suspended when
    switching frames forward or backward, using the arrows buttons, which are not
    far away from the **Current** button. Also, be aware that the profiler does not
    preserve all the frames, but only a certain number of the most recent frames.
    Furthermore, if you go from left to right on the toolbar profiler, we see a **Clear**
    button to clear all the data that was collected. After this, we see a **Active
    Profiler** button, which allows you to select a device or the Unity editor for
    further performance analysis.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看性能分析器窗口的顶部，你会看到一个工具栏，我们将在本章后面更详细地探讨它。通过工具栏上的按钮，你可以启用或禁用性能分析器记录数据。此外，你可以清除收集到的信息或在帧集中导航，还有更多功能；我们稍后会详细讨论。在工具栏中，我们可以看到**当前**按钮。点击此按钮后，我们将自动进入一个帧，并查看其实现的最后细节。如果你的游戏是在Unity编辑器中运行的，它将被挂起，这意味着它将被暂停。当你使用箭头按钮向前或向后切换帧时，它也会被挂起，这些箭头按钮离**当前**按钮不远。此外，请注意，性能分析器不会保留所有帧，而只保留最近的一定数量的帧。此外，如果你从左到右在工具栏的性能分析器上滑动，我们会看到一个**清除**按钮，用于清除收集到的所有数据。之后，我们会看到一个**活动性能分析器**按钮，它允许你选择设备或Unity编辑器进行进一步的性能分析。
- en: Next, we see a button called **Profile Editor**; if you click on this button,
    you will begin to get detailed statistics execution for the Unity editor. To the
    left of this button, you will see the **Deep Profile** button. When this button
    is activated, it will provide information about all of your scripts and function
    calls. Deep profiling can significantly slow down your application or your game,
    as it will be necessary to spend most of the time processing and requires a huge
    amount of memory space. Remember that very deep profiling will only work if you
    use it for small projects, otherwise you run the risk that Unity will not be able
    to obtain the necessary resources and hang, following which you will have to restart
    the Unity editor. Also, deep profiling is well suited not only for small projects,
    but is also very useful for testing key aspects of your game or application. You
    can use the code in deep profiling, and that is switched ON and OFF for specific
    pieces of code in your scripts. Only the necessary parts of the code will be profiled
    and analyzed.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到一个名为**性能编辑器**的按钮；如果你点击此按钮，你将开始获取Unity编辑器的详细执行统计信息。在此按钮的左侧，你会看到一个**深度分析**按钮。当此按钮被激活时，它将提供关于你所有脚本和函数调用的信息。深度分析可能会显著减慢你的应用程序或游戏，因为它需要花费大部分时间进行处理，并需要大量的内存空间。请记住，非常深入的深度分析只有在用于小型项目时才会有效，否则你可能会面临Unity无法获取必要资源并挂起的风险，随后你将不得不重新启动Unity编辑器。此外，深度分析不仅适用于小型项目，对于测试游戏或应用程序的关键方面也非常有用。你可以在深度分析中使用代码，并为你脚本中的特定代码片段打开和关闭它。只有必要的代码部分将被分析。
- en: 'The `Profiler.BeginSample` and `Profiler.EndSample` calls are the beginning
    and endpoints, respectively, of profiling your code, which means that the code
    between these two function calls will be profiled and detailed statistics will
    be displayed in the bottom profiler window. We will talk about profiler scripting
    a little later in this chapter. On the left from the **Deep Profile** button is
    a button that is called **Record**, and it is needed to enable or disable profiling
    as we mentioned earlier. Well, the left-most button in the toolbar is called **Add
    Profiler,** and it is needed to display different profiler areas: **CPU**, **GPU**,
    **Rendering**, **Memory**, **Audio**, **Physics 3D**, and **Physics2D**. We will
    talk about these profiler areas later in this chapter.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`Profiler.BeginSample`和`Profiler.EndSample`调用是代码性能分析的起点和终点，这意味着这两个函数调用之间的代码将被分析，并在底部性能分析器窗口中显示详细统计信息。我们将在本章稍后讨论性能分析脚本。从**深度分析**按钮的左侧是一个名为**记录**的按钮，它用于启用或禁用性能分析，正如我们之前提到的。好吧，工具栏中最左侧的按钮被称为**添加性能分析器**，它用于显示不同的性能分析区域：**CPU**、**GPU**、**渲染**、**内存**、**音频**、**3D物理**和**2D物理**。我们将在本章稍后讨论这些性能分析区域。'
- en: If your game or your application is running at a specific frame rate or is synchronized
    with the vertical blank, then Unity will keep the average time waiting for the
    synchronization of all frames in a parameter called `Wait For Target FPS`, which
    is displayed in the profiler. By default, the information on waiting times will
    not be published in the Unity profiler. To change the specified default behavior,
    you need to enable `View SyncTime`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的游戏或应用程序以特定的帧率运行或与垂直空白同步，那么Unity将保持平均等待所有帧同步的时间，这被称为`Wait For Target FPS`参数，并在性能分析器中显示。默认情况下，等待时间的信息不会发布在Unity性能分析器中。要更改指定的默认行为，你需要启用`View
    SyncTime`。
- en: Profiler timeline
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能分析器时间线
- en: In the upper part of the profiler window is a graph that shows the profiler
    load data in real time. Statistics are processed in each frame and are saved only
    in the history of the last couple of hundred frames. If you select one of the
    frames for further consideration, you will see details at the bottom profiler,
    which in turn will depend on the selected timeline area (for example, **CPU**,
    **GPU,** or **Audio**). You can both add and remove various timeline areas. Also,
    note that the colored squares on the left display different timeline areas. In
    fact, it is not just the colored squares; they are radio buttons. Thus, it will
    be much easier to eliminate unnecessary data when optimizing your application.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在性能分析器窗口的上方是一个图表，它实时显示性能分析器的负载数据。统计数据在每个帧中处理，并且只保存在最后几百帧的历史记录中。如果你选择其中一个帧进行进一步考虑，你将在底部性能分析器中看到细节，这反过来又取决于所选的时间线区域（例如，**CPU**、**GPU**或**音频**）。你可以添加和删除各种时间线区域。此外，请注意，左侧的彩色方块显示不同的时间线区域。实际上，不仅仅是彩色方块；它们是单选按钮。因此，在优化应用程序时，消除不必要的数据将会更容易。
- en: The CPU area
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CPU区域
- en: 'The CPU area clearly shows which specific place and how much total time was
    spent on the CPU side of course. If you choose it, then you will have hit on the
    CPU area. After that, you will see that the bottom profiler displays enough details
    solely about the execution of your application on the CPU. Also, you can choose
    two different modes of displaying detailed information:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: CPU区域清楚地显示了在CPU侧具体位置和总共花费了多少时间。如果你选择它，那么你就已经触发了CPU区域。之后，你将看到底部性能分析器仅显示关于应用程序在CPU上执行的足够详细的信息。此外，你可以选择两种不同的显示详细信息的模式：
- en: The **Hierarchy** mode displays the information in a hierarchy, by grouping
    the data
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**层次结构**模式通过分组数据来显示信息'
- en: The **Group Hierarchy** mode displays information on groups that were distributed
    logically; for example, the **Rendering** group, the **Scripts** group, the **Physics**
    group, and many more groups
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组层次结构**模式显示逻辑上分布的组信息；例如，**渲染**组、**脚本**组、**物理**组以及许多其他组'
- en: The **Others** area of the CPU profiler incorporates **Loading**, **Audio**,
    **Animation**, **Particles**, **Playerloop**, **AI**, and **Networking**.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: CPU性能分析器的**其他**区域包括**加载**、**音频**、**动画**、**粒子**、**玩家循环**、**AI**和**网络**。
- en: The Rendering area
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染区域
- en: 'The **Rendering** area displays rendering statistics as shown in the following
    screenshot. The timeline graphically presents the number of rendered **Draw Calls**,
    **Triangles**, and **Vertices**. As we can see, the bottom part of the following
    screenshot and **Game View Rendering Statistics** shown in the next figure are
    very similar. Further, we will cover the information shown in the following screenshot
    in details:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**渲染**区域显示了如下截图所示的渲染统计信息。时间线图示了渲染的**绘制调用**、**三角形**和**顶点**的数量。正如我们所见，以下截图的下半部分和下一张图中显示的**游戏视图渲染统计**非常相似。进一步地，我们将详细说明以下截图中的信息：'
- en: '![The Rendering area](img/9191OT_07_02.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![渲染区域](img/9191OT_07_02.jpg)'
- en: 'The following screenshot is very similar to the same statistics information:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图与相同的统计信息非常相似：
- en: '![The Rendering area](img/9191OT_07_03.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![渲染区域](img/9191OT_07_03.jpg)'
- en: '| Time per frame and FPS | The time spent rendering one frame in milliseconds;
    represents quantity of frames per second. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 每帧时间和FPS | 渲染一帧所花费的时间（以毫秒计）；表示每秒帧数。 |'
- en: '| Draw calls | The amount of rendered meshes. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 绘制调用 | 渲染网格的数量。 |'
- en: '| Batched (draw Calls) | The number of batched draw calls. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 批处理（绘制调用） | 批处理绘制调用的数量。 |'
- en: '| Tris and verts | The amount of drawn geometry (triangles and vertices). |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 三角形和顶点 | 绘制的几何形状（三角形和顶点）的数量。 |'
- en: '| Used textures | This indicates how many textures were used and the amount
    of memory needed per frame. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 使用的纹理 | 这表示每帧使用了多少个纹理以及每个纹理所需的内存量。 |'
- en: '| Render textures | This shows the amount of times active render texture was
    switched per frame; furthermore it demonstrates how much memory is used to render
    texture, and how many render textures there were. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 渲染纹理 | 这显示了每帧激活的渲染纹理切换的次数；此外，它还展示了渲染纹理使用的内存量以及渲染纹理的数量。 |'
- en: '| Screen | This shows the screen size with its anti-aliasing level and memory
    usage. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 屏幕 | 这显示了屏幕大小及其抗锯齿级别和内存使用情况。 |'
- en: '| VRAM usage | This roughly indicates the amount of video memory (VRAM) usage;
    furthermore, represents how much memory your graphic card has. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| VRAM使用量 | 这大致表示了视频内存（VRAM）的使用量；此外，还表示了你的显卡有多少内存。 |'
- en: '| VBO total | **Vertex Buffers Objects** (**VBO**) is the number of uploaded
    meshes to the graphics card. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| VBO总数 | **顶点缓冲区对象**（**VBO**）是上传到显卡的网格数量。 |'
- en: '| Visible Skinned Meshes | This shows the amount of rendered skinned meshes.
    |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 可见皮肤网格 | 这显示了渲染的皮肤网格的数量。 |'
- en: '| Animations | This represents how many animations can be played. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 动画 | 这表示可以播放多少个动画。 |'
- en: The Memory area
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存区域
- en: 'While profiling this area, you can choose one of the two available modes for
    different displaying modes. The first mode is to display very simple statistics,
    and the second mode is for displaying very detailed statistics. We cover these
    two modes in more detail in the following sections:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析这个区域时，你可以选择两种可用的模式之一，以不同的显示模式。第一种模式是显示非常简单的统计信息，第二种模式是显示非常详细的统计信息。我们将在以下章节中更详细地介绍这两种模式：
- en: The simple view
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单视图
- en: 'We begin with the simplest display mode statistics (as shown in the following
    screenshot). This shows the usage of memory for each profiled frame in a simpler
    form than it does in the detailed statistics:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从最简单的显示模式统计信息开始（如下截图所示）。这以比详细统计信息更简单的方式显示了每个分析帧的内存使用情况：
- en: '![The simple view](img/9191OT_07_04.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![简单视图](img/9191OT_07_04.jpg)'
- en: The simple view of the Unity profiler
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Unity性能分析器的简单视图
- en: 'In order to use memory efficiently, Unity tries to keep a certain amount of
    memory in advance in the form of a pool, or in other words, as a backup buffer,
    which greatly improves performance. Statistics memory, or rather information about
    how much memory is consumed, and for what is the described method of reservation,
    will be shown at the bottom profiler window. Here are the parameters of these
    statistics:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地使用内存，Unity试图提前保留一定量的内存，以池的形式，或者说作为备份缓冲区，这大大提高了性能。统计内存，或者说关于内存消耗多少以及用于什么的描述方法，将在底部性能分析窗口中显示。以下是这些统计参数：
- en: '**Unity**: This indicates the amount of memory used for allocations in the
    native Unity code'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Unity**：这表示在原生Unity代码中分配使用的内存量'
- en: '**Mono**: This shows how big the heap size was, and the amount of memory used
    for the garbage collector'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mono**：这显示了堆的大小以及垃圾回收器使用的内存量'
- en: '**Gfx Driver**: This indicates the amount of memory used by the driver on shaders,
    meshes, render targets, and textures'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Gfx Driver**：这表示驱动程序在着色器、网格、渲染目标和纹理上使用的内存量'
- en: '**FMOD**: This shows the amount of memory used on audio drivers'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FMOD**：这显示了音频驱动器使用的内存量'
- en: '**Profiler**: This indicates the amount of memory used for the Unity''s profiler'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**剖析器**：这表示 Unity 剖析器使用的内存量'
- en: 'The memory area displays information for fundamental types of objects and assets:
    textures, meshes, materials, animations, audio, and object count.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 内存区域显示基本类型对象和资产的信息：纹理、网格、材质、动画、音频和对象计数。
- en: The detailed view
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 详细视图
- en: In a detailed view, you can save the current state for further analysis using
    the **Take Sample** button. In order to obtain such detailed information about
    the memory usage, the Unity profiler should take time to collect all information
    needed, and that's why you should not think that you can receive information in
    real time.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在详细视图中，您可以使用 **获取样本** 按钮保存当前状态以供进一步分析。为了获得有关内存使用的如此详细的信息，Unity 剖析器需要花费时间收集所有必要的信息，这就是为什么您不应该认为您可以实时接收信息的原因。
- en: '![The detailed view](img/9191OT_07_05.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![详细视图](img/9191OT_07_05.jpg)'
- en: 'The profiler will show information about where and on what the memory was consumed.
    The following is a list of groups of objects that will be spent in memory:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 剖析器将显示有关内存消耗位置和内容的信息。以下是一个将消耗内存的对象组列表：
- en: Referenced from native code
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自原生代码的引用
- en: Scene object
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 场景对象
- en: Built-in resources
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置资源
- en: Marked as don't save
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记为不保存
- en: After you click on one of the objects in the list, Unity will highlight the
    selected items in the **Project** view or in the **Scene** view. When profiling
    your application in the Unity editor, the statistics will be less accurate than
    it could be on a particular device. Some of the costs associated with the Unity
    editor execution will also be displayed in the average values that will not be
    true for your application. Therefore, for a more precise analysis of your application,
    it is the best decision to connect to real devices and profile statistics in that
    case.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在您点击列表中的某个对象后，Unity 将在 **项目** 视图或 **场景** 视图中突出显示所选项目。当在 Unity 编辑器中分析您的应用程序时，统计信息将不如在特定设备上准确。与
    Unity 编辑器执行相关的某些成本也会显示在平均值中，这些平均值对您的应用程序并不真实。因此，为了更精确地分析您的应用程序，连接到真实设备并在该情况下分析统计数据是最佳决定。
- en: The audio area
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 音频区域
- en: This shows the information displayed in the audio area.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了音频区域显示的信息。
- en: The physics area
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 物理区域
- en: 'The following is a list of information displayed in the Physics 3D area (as
    shown in following screenshot):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在物理 3D 区域显示的信息列表（如以下截图所示）：
- en: '**Active Bodies**: This indicates the number of awake Rigidbodies'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**活动物体**：这表示唤醒的 Rigidbodies 的数量'
- en: '**Sleeping Bodies**: This displays the number of sleeping Rigidbodies'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**睡眠物体**：这显示了睡眠的 Rigidbodies 的数量'
- en: '**Number of Contacts**: This shows the total amount of contact points in the
    scene between all colliders'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接触点数量**：这显示了场景中所有碰撞体之间的总接触点数'
- en: '**Static Colliders**: This represents how many colliders were attached on non-Rigidbody
    objects'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态碰撞体**：这表示有多少碰撞体附加在非 Rigidbody 对象上'
- en: '**Dynamic Colliders**: This demonstrates how many colliders were attached on
    Rigidbody objects'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态碰撞体**：这展示了有多少碰撞体附加在 Rigidbody 对象上'
- en: '![The physics area](img/9191OT_07_06.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![物理区域](img/9191OT_07_06.jpg)'
- en: The detailed view of the Unity profiler
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 剖析器的详细视图
- en: The GPU area
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GPU 区域
- en: Statistics that are displayed in the profiler window for the GPU area are very
    similar to the displayed statistics for CPU area.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GPU 区域的剖析窗口中显示的统计信息与 CPU 区域显示的统计信息非常相似。
- en: Note
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On the Mac, only OSX 10.7 Lion and later versions support GPU profiling.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mac 上，只有 OSX 10.7 狮子版及更高版本支持 GPU 剖析。
- en: Real-practice techniques
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践技巧
- en: There are two different performance optimization techniques that are used by
    many professional developers from all over the world.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 全世界许多专业开发者都使用两种不同的性能优化技术。
- en: The high-speed, off-screen particles technique in Unity
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unity 中的高速、离屏粒子技术
- en: 'The next technique is to optimize the particle system, which was introduced
    by NVIDIA, GPU Gems 3\. The first step in order to achieve the goal is to render
    particles into `RenderTexture` or, in other words, into another render target
    with smaller size than screen. The second step in this idea is to blend the particles
    back into screen. First, we need depth buffer. When we render into another render
    target, we need depth buffer for its z-testing. In the following line of code,
    you can register in the `Awake` or `Start` callbacks just as examples:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 下一技术是优化由NVIDIA在GPU Gems 3中引入的粒子系统。为了实现目标的第一步是将粒子渲染到`RenderTexture`或换句话说，渲染到比屏幕尺寸小的另一个渲染目标。这个想法的第二步是将粒子重新混合到屏幕上。首先，我们需要深度缓冲区。当我们渲染到另一个渲染目标时，我们需要深度缓冲区来进行z测试。以下代码行中，你可以在`Awake`或`Start`回调中注册，例如：
- en: '[PRE0]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s consider following code for high-speed, off-screen particles:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下代码用于高速、离屏粒子：
- en: '[PRE1]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `yourLowerResolutionIntegerValue` determines the quality. The highest value
    means the worst quality and the best performance and vice versa.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`yourLowerResolutionIntegerValue`确定质量。最高值意味着最差的质量和最佳的性能，反之亦然。'
- en: 'The second part is very simple and means just tuning your main camera''s properties
    as shown here:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分非常简单，就是调整你的主相机的属性，如图所示：
- en: '[PRE2]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The next step includes rendering and blending particles into the scene:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步骤包括将粒子渲染和混合到场景中：
- en: '[PRE3]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Always release the particles render texture for better performance.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 总是释放粒子渲染纹理以获得更好的性能。
- en: 'You can render (after postprocessing) your `RenderTexture` to your destination
    as shown here:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将你的`RenderTexture`渲染到目的地，如图所示：
- en: '[PRE4]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The pool technique
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 池化技术
- en: 'The next technique is a basic pooling system (as shown in Listing 3-1) for
    Unity in addition for Shuriken particles. Put the pool component on your GameObject
    and set the name and prefab. The pool summons the `OnCreateEvent` strategy on
    entities when they are *made* in the pool (so put your initialization that typically
    will go in the `Start` or `Awake` callback) and an `OnLiberationEvent` system
    when reused items go into the pool. The `OnCreateEvent` strategy provides the
    pool that made the occurrence so that you can store it away and reuse your **GameObject**
    later:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 下一技术是一个基本的池化系统（如列表3-1所示），用于Unity以及Shuriken粒子。将池组件放在你的GameObject上，设置名称和预制体。池在实体被*创建*时调用`OnCreateEvent`策略（因此将你的初始化代码放在`Start`或`Awake`回调中），当重用项目进入池时调用`OnLiberationEvent`系统。`OnCreateEvent`策略为池提供了创建事件，以便你可以存储它并在以后重用你的**GameObject**：
- en: '[PRE5]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is how to use this pooling system:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使用此池化系统的方法：
- en: '[PRE6]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In event of using a particle system with `YourPoolClass`, you should use the
    following code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`YourPoolClass`粒子系统的情况下，你应该使用以下代码：
- en: '[PRE7]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The scriptable profiler tool
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可脚本化分析器工具
- en: The fact that developers can use the Unity profiler for profiling their own
    code or certain pieces of code is very important. In order to display statistics
    information about some of your function or for some part of your code in the Unity
    profiler, you just need to include your code between two calls, `Profiler.BeginSample`
    and `Profiler.EndSample`. After that you can use the visual Unity profiler tool
    to search for bottlenecks and spikes in your code.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以使用Unity分析器来分析自己的代码或某些代码片段，这一点非常重要。为了在Unity分析器中显示有关某些函数或代码部分的统计信息，你只需要在两个调用`Profiler.BeginSample`和`Profiler.EndSample`之间包含你的代码。之后，你可以使用可视化的Unity分析器工具来搜索代码中的瓶颈和峰值。
- en: Note
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The profiler is only available in Unity Pro. In standalone games, the profiler
    can dump all profiling information using `Profiler.log` and `Profiler.enabled`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 分析器仅在Unity Pro中可用。在独立游戏中，分析器可以使用`Profiler.log`和`Profiler.enabled`将所有分析信息转储。
- en: 'To create your own tool, you can utilize the following Unity API calls:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建自己的工具，你可以使用以下Unity API调用：
- en: '`FindObjectsOfTypeAll`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FindObjectsOfTypeAll`'
- en: '`FindObjectsOfType`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FindObjectsOfType`'
- en: '`GetRuntimeMemorySize`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetRuntimeMemorySize`'
- en: '`GetMonoHeapSize`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetMonoHeapSize`'
- en: '`GetMonoUsedSize`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetMonoUsedSize`'
- en: '`Profiler.BeginSample`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Profiler.BeginSample`'
- en: '`Profiler.EndSample`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Profiler.EndSample`'
- en: '`UnloadUnusedAssets`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UnloadUnusedAssets`'
- en: '`System.GC.GetTotalMemory`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.GC.GetTotalMemory`'
- en: '`Profiler.usedHeapSize`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Profiler.usedHeapSize`'
- en: Unity profiler tricks
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unity分析器技巧
- en: 'There is the capability to export the profiling information to a binary file,
    which can then be imported again later. This is empowered through scripting by
    means of:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有能力将分析信息导出为二进制文件，稍后可以再次导入。这是通过以下方式通过脚本实现的：
- en: '[PRE8]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And reimported into the profiler:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 并重新导入到分析器中：
- en: '[PRE9]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The API to get to the profiler frame information into the script is uncovered
    in:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 获取分析器帧信息到脚本的API在以下地方未公开：
- en: '[PRE10]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Not documented, yet totally open in the `UnityEditorInternal` namespace. Other
    suitable APIs:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 尚未记录，但在`UnityEditorInternal`命名空间中完全开放。其他合适的API：
- en: '[PRE11]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Creating a simple profiler
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个简单的分析器
- en: 'Now is the time to develop our own simple and very useful profiler tool from
    scratch. In the future, you will be able to use these scripts from our simple
    profiler for all of your projects as well as any other examples discussed in this
    book. Of course, you can modify all methods to meet your specific problem if you
    have a strong desire or if you have to do it, or you can use them all in their
    original form if this functionality will be enough for your tasks. First, let''s
    look at a very simple class, which is a core class in our simple code profiler
    tool. In the following code you can see a very simple `ExampleProfilerClass`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候从头开始开发我们自己的简单且非常有用的分析器工具了。在未来，您将能够使用我们简单分析器中的这些脚本为您所有的项目以及本书中讨论的任何其他示例。当然，如果您有强烈的愿望或必须这样做，您可以修改所有方法以满足您特定的需求，或者如果您这项功能足够满足您的任务，您也可以以原始形式使用它们。首先，让我们看看一个非常简单的类，这是我们的简单代码分析器工具的核心类。在下面的代码中，您可以看到一个非常简单的`ExampleProfilerClass`：
- en: Listing 1-3\. ExampleProfilerClass.cs
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1-3\. ExampleProfilerClass.cs
- en: '[PRE12]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You need to attach the `ExampleProfilerClass` script to one of the objects
    in your scene. The code is very straightforward and simple, as are all the other
    examples in this book. The entire code of our profiler is shown in Listing 1-4:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要将`ExampleProfilerClass`脚本附加到场景中的某个对象上。代码非常直接和简单，正如本书中所有其他示例一样。我们的分析器代码的整个代码在列表1-4中展示：
- en: Listing 1-4\. SimpleProfiler.cs
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1-4\. SimpleProfiler.cs
- en: '[PRE13]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The following is a simple test code, which performs mathematical operations
    in a cycle. You can hang this script on any object (or on multiple objects simultaneously)
    in your scene, just for testing your `SimpleCodeProfiler` tool.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的测试代码，它在循环中执行数学运算。您可以将此脚本挂载到场景中的任何对象（或同时挂载到多个对象）上，仅用于测试您的`SimpleCodeProfiler`工具。
- en: Listing 1-5\. TestProfilerCode.cs
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1-5\. TestProfilerCode.cs
- en: '[PRE14]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we researched our choices for optimization in Unity. We first
    discovered different Unity performance areas. We explored the in-built Unity profiler
    and it's log information structure. In this chapter, we particularly discussed
    the Unity's profiler tool and its window parts. We discovered how to attach the
    profiler to different platforms and devices. At the end of this chapter, we talked
    about best practices that are used by many professionals. We also discovered the
    Unity profiler programming area and created our own very simple profiler tool.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了Unity中优化的选择。我们首先发现了不同的Unity性能区域。我们探索了内置的Unity分析器和它的日志信息结构。在本章中，我们特别讨论了Unity的分析器工具及其窗口部分。我们发现了如何将分析器附加到不同的平台和设备。在本章末尾，我们讨论了许多专业人士使用的最佳实践。我们还发现了Unity分析器编程区域，并创建了我们自己的非常简单的分析器工具。
- en: In the bonus chapter, which is available online, I will show you how easy it
    is to develop the most popular game on Android Play Store (Glow Hockey has about
    100,000,000–500,000,000 downloads at [https://play.google.com/store/apps/details?id=com.natenai.glowhockey&hl=en](https://play.google.com/store/apps/details?id=com.natenai.glowhockey&hl=en))
    in Unity 5 from scratch. You will see how to create a camera for any screen resolutions
    and any screen sizes. Also, there you will see, in practice, how easy it is to
    use physics. You will learn in practice how to design beautiful effects, animations,
    physical behaviors, and other different real-world features and techniques for
    your Android games and applications. You will see how to optimize your project
    and any other real-world projects for Android devices. Many more useful things
    and features will be covered in the chapter.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在附加章节中，该章节可在网上获取，我将向您展示如何从零开始轻松开发在Android Play Store上最受欢迎的游戏（Glow Hockey在[https://play.google.com/store/apps/details?id=com.natenai.glowhockey&hl=en](https://play.google.com/store/apps/details?id=com.natenai.glowhockey&hl=en)）的Unity
    5版本，该游戏下载量约为1亿至5亿。您将看到如何为任何屏幕分辨率和任何屏幕尺寸创建相机。此外，您还将看到在实践中使用物理是多么简单。您将通过实践学习如何设计美观的效果、动画、物理行为以及其他不同真实世界的功能和技巧，用于您的Android游戏和应用。您将看到如何优化您的项目以及任何其他真实世界的Android设备项目。章节中还将涵盖更多有用的功能和特性。
