- en: Home Screen Widgets, Search, and the System UI
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主屏幕小部件、搜索和系统UI
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating a shortcut on the Home screen
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主屏幕上创建快捷方式
- en: Creating a Home screen widget
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建主屏幕小部件
- en: Adding Search to the Action Bar
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将搜索添加到操作栏
- en: Showing your app full-screen
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示你的应用全屏
- en: Lock screen shortcuts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁屏快捷方式
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: With an understanding of Fragments from the previous chapter, we're ready to
    expand on our discussion of widgets. In [Chapter 3](3adebbef-b8f1-41ca-ba6c-c56329c9ea53.xhtml),* Views,
    Widgets, and Styles*, we discussed how to add widgets to your own app. Now, we'll
    look at how to create an App Widget so users can add your app on their Home screen.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中了解了片段之后，我们准备扩展对小部件的讨论。在[第3章](3adebbef-b8f1-41ca-ba6c-c56329c9ea53.xhtml)，“视图、小部件和样式”中，我们讨论了如何将小部件添加到自己的应用中。现在，我们将探讨如何创建一个App
    Widget，以便用户可以在他们的主屏幕上添加应用。
- en: The remaining recipes in this chapter will explore System UI options. There's
    a recipe for adding a Search option to the Action Bar using the Android SearchManager API.
    Another recipe will explore Full Screen mode and several additional variations
    on altering the System UI. The final recipe will showcase the new Lock Screen
    shortcuts introduced in Android O (API 26).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章剩余的食谱将探讨系统UI选项。有一个食谱是使用Android SearchManager API将搜索选项添加到操作栏。另一个食谱将探讨全屏模式以及改变系统UI的几种额外变体。最后一个食谱将展示Android
    O（API 26）中引入的新锁屏快捷方式。
- en: Creating a shortcut on the Home screen
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在主屏幕上创建快捷方式
- en: This recipe explains how to create a link or create a shortcut for your app
    on the user's Home screen. So as not to be too obtrusive, it's generally best
    to make this an option for the user to initiate, such as in the settings.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱解释了如何在用户的主屏幕上创建链接或创建快捷方式。为了不过于突兀，通常最好将其作为用户可以启动的选项，例如在设置中。
- en: 'The following is a screenshot showing our shortcut on the Home screen:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个显示我们主屏幕快捷方式的屏幕截图：
- en: '![](img/c0c71732-d9bd-4752-af84-086fd7d0bbab.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c0c71732-d9bd-4752-af84-086fd7d0bbab.png)'
- en: As you can see, this is just a shortcut to your app. The next recipe will go
    deeper by creating a Home screen (AppWidget).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这只是一个到应用的快捷方式。下一个食谱将通过创建主屏幕（AppWidget）来进一步深入。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in Android Studio and call it `HomeScreenShortcut`. Use
    the default Phone & Tablet options and select the Empty Activity option when prompted
    for the Activity Type.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中创建一个新的项目，并将其命名为`HomeScreenShortcut`。使用默认的`Phone & Tablet`选项，并在被提示选择`Activity
    Type`时选择`Empty Activity`。
- en: How to do it...
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'For an app to create a shortcut, it must have the `INSTALL_SHORTCUT` permission.
    With the appropriate permission, it''s a simple matter of calling an intent with
    your app properties. The following are the steps:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建快捷方式，应用必须具有`INSTALL_SHORTCUT`权限。有了适当的权限，只需调用一个带有应用属性的intent即可。以下步骤：
- en: 'Open the `AndroidManifest` file and add the following permission:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`AndroidManifest`文件并添加以下权限：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, open `activity_main.xml` and replace the existing TextView with the following
    button:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开`activity_main.xml`并将现有的TextView替换为以下按钮：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the following method to `ActivityMain.java`:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '将以下方法添加到`ActivityMain.java`:'
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Run the program on a device or emulator. Notice that, each time you press the
    button, the app will make a shortcut on the Home screen.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备或模拟器上运行程序。注意，每次你按下按钮，应用都会在主屏幕上创建一个快捷方式。
- en: How it works...
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Once you set up the proper permission, this is a rather straightforward task.
    When the button is clicked, the code creates two intents. The first intent broadcasts
    to the OS that you want a shortcut created. The second intent is the intent that
    launches your app when the icon is pressed. One important consideration to keep
    in mind is that Home screens vary and may not support the `INSTALL_SHORTCUT` intent.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了适当的权限，这便是一个相当直接的任务。当按钮被点击时，代码会创建两个intent。第一个intent向操作系统广播你想要创建快捷方式。第二个intent是当图标被按下时启动应用的intent。一个需要记住的重要考虑因素是，主屏幕各不相同，可能不支持`INSTALL_SHORTCUT`
    intent。
- en: There's more...
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: 'If you also wanted to remove the shortcut, you would need the following permission:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还想删除快捷方式，你需要以下权限：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Instead of using the `INSTALL_SHORTCUT` action, you would set the following
    action instead:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用`INSTALL_SHORTCUT`动作，你可以设置以下动作：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Creating a Home screen widget
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建主屏幕小部件
- en: 'Before we dig into the code for creating an App Widget, let''s cover the basics.
    There are three required and one optional component:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入到创建App Widget的代码之前，让我们先了解基础知识。有三个必需组件和一个可选组件：
- en: 'The `AppWidgetProviderInfo` file: It''s an XML resource (described later)'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AppWidgetProviderInfo`文件：这是一个XML资源（稍后描述）'
- en: 'The `AppWidgetProvider class`: This is a Java class'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AppWidgetProvider`类：这是一个Java类'
- en: 'The `View layout` file: It''s a standard layout XML file, with some restrictions
    (explained later)'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`View layout`文件：这是一个标准的布局XML文件，有一些限制（稍后解释）'
- en: 'The App Widget configuration Activity (optional): This is an Activity the OS
    will launch when placing the widget to provide configuration options'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: App Widget配置Activity（可选）：这是一个操作系统在放置小部件时启动的活动，以提供配置选项
- en: 'The `AppWidgetProvider` must also be declared in the `AndroidManifest` file.
    Since `AppWidgetProvider` is a helper class based on the Broadcast Receiver, it
    is declared in the manifest with the `<receiver>` element. Here is an example
    manifest entry:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppWidgetProvider`必须在`AndroidManifest`文件中声明。由于`AppWidgetProvider`是基于广播接收器的辅助类，它使用`<receiver>`元素在Manifest中声明。以下是一个Manifest条目示例：'
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The metadata points to the `AppWidgetProviderInfo` file, which is placed in
    the `res/xml` directory. Here is a sample `AppWidgetProviderInfo.xml` file:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据指向放置在`res/xml`目录中的`AppWidgetProviderInfo`文件。以下是一个示例`AppWidgetProviderInfo.xml`文件：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following is a brief overview of the available attributes:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对可用属性的简要概述：
- en: '`minWidth`: The default width when placed on the Home screen'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minWidth`: 放置在主屏幕上的默认宽度'
- en: '`minHeight`: The default height when placed on the Home screen'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minHeight`：放置在主屏幕上的默认高度'
- en: '`updatePeriodMillis`: It''s part of the `onUpdate()` polling interval (in milliseconds)'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updatePeriodMillis`：它是`onUpdate()`轮询间隔的一部分（以毫秒为单位）'
- en: '`initialLayout`: The AppWidget layout'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initialLayout`：App Widget布局'
- en: '`previewImage` (optional): The image shown when browsing App Widgets'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`previewImage`（可选）：浏览App Widget时显示的图像'
- en: '`configure` (optional): The activity to launch for configuration settings'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`configure`（可选）：用于配置设置的启动活动'
- en: '`resizeMode` (optional): The flags indicate resizing options: horizontal, vertical, none'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resizeMode`（可选）：标志表示调整大小选项：水平、垂直、无'
- en: '`minResizeWidth` (optional): The minimum width allowed when resizing'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minResizeWidth`（可选）：调整大小时的最小宽度'
- en: '`minResizeHeight` (optional): The minimum height allowed when resizing'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minResizeHeight`（可选）：调整大小时的最小高度'
- en: '`widgetCategory` (optional): Android 5+ only supports Home screen widgets'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`widgetCategory`（可选）：Android 5+仅支持主屏幕小部件'
- en: 'The `AppWidgetProvider` extends the `BroadcastReceiver` class, which is why the `<receiver>` element is
    used when declaring the AppWidget in the Manifest. As it''s `BroadcastReceiver`,
    the class still receives OS broadcast events, but the helper class filters those
    events down to those applicable for an App Widget. The `AppWidgetProvider` class
    exposes the following methods:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppWidgetProvider`类扩展了`BroadcastReceiver`类，这就是为什么在Manifest中声明AppWidget时使用`<receiver>`元素。由于它是`BroadcastReceiver`，该类仍然接收操作系统广播事件，但辅助类会过滤这些事件，只保留适用于App
    Widget的事件。`AppWidgetProvider`类公开以下方法：'
- en: '`onUpdate()`: It''s called when initially created and at the interval specified.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onUpdate()`：当首次创建和指定的时间间隔时调用。'
- en: '`onAppWidgetOptionsChanged()`: It''s called when initially created and any
    time the size changes.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onAppWidgetOptionsChanged()`: 当首次创建和任何时间大小改变时调用。'
- en: '`onDeleted()`: It''s called any time a widget is removed.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onDeleted()`: 任何时间移除小部件时都会调用。'
- en: '`onEnabled()`: It''s called the first time a widget is placed (it isn''t called
    when adding second and subsequent widgets).'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onEnabled()`: 当第一个小部件被放置时调用（添加第二个和后续小部件时不会调用）。'
- en: '`onDisabled()`: It''s called when the last widget is removed.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onDisabled()`: 当最后一个小部件被移除时调用。'
- en: '`onReceive()`: It''s called on every event received, including the preceding
    event. Usually not overridden as the default implementation only sends applicable
    events.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onReceive()`: 每当接收到事件时都会调用此方法，包括前一个事件。通常不需要重写，因为默认实现只发送适用的事件。'
- en: 'The last required component is the layout. An App Widget uses a Remote View,
    which only supports a subset of the available layouts:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个必需组件是布局。App Widget使用Remote View，它只支持可用布局的子集：
- en: AdapterViewFlipper
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AdapterViewFlipper
- en: FrameLayout
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FrameLayout
- en: GridLayout
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GridLayout
- en: GridView
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GridView
- en: LinearLayout
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LinearLayout
- en: ListView
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ListView
- en: RelativeLayout
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RelativeLayout
- en: StackView
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: StackView
- en: ViewFlipper
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ViewFlipper
- en: 'And it supports the following widgets:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 它支持以下小部件：
- en: AnalogClock
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AnalogClock
- en: Button
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Button
- en: Chronometer
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chronometer
- en: ImageButton
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ImageButton
- en: ImageView
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ImageView
- en: ProgressBar
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ProgressBar
- en: TextClock
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TextClock
- en: TextView
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TextView
- en: With App Widget basics covered, it's now time to start coding. Our example will
    cover the basics so you can expand the functionality as needed. This recipe uses
    a View with a clock, which, when pressed, opens our activity.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了App Widget的基础知识后，现在是时候开始编码了。我们的示例将涵盖基础知识，以便您可以根据需要扩展功能。这个配方使用了一个带有时钟的视图，按下时将打开我们的活动。
- en: 'The following screenshot shows the widget in the widget list when adding it
    to the Home screen:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了添加到主屏幕时小部件在小部件列表中的样子：
- en: '![](img/24cd27b9-b7e1-4ac7-b7b3-b5634da66d8a.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/24cd27b9-b7e1-4ac7-b7b3-b5634da66d8a.png)'
- en: The purpose of the image is to show how to add a widget to the home screen
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图片的目的是展示如何将小部件添加到主屏幕
- en: The widget list's appearance varies by the launcher used.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件列表的外观因使用的启动器而异。
- en: 'Here''s a screenshot showing the widget after it is added to the Home screen:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是添加到主屏幕后小部件的截图：
- en: '![](img/acaa88e4-26cc-4f86-8bb8-623eddeaeda4.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/acaa88e4-26cc-4f86-8bb8-623eddeaeda4.png)'
- en: Getting ready
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in Android Studio and call it AppWidget. Use the default Phone
    & Tablet options and select the Empty Activity option when prompted for the Activity
    Type.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中创建一个新的项目，命名为`AppWidget`。使用默认的`Phone & Tablet`选项，并在提示活动类型时选择`Empty
    Activity`选项。
- en: How to do it...
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We'll start by creating the widget layout, which resides in the standard layout
    resource directory. Then, we'll create the XML resource directory to store the `AppWidgetProviderInfo` file.
    We'll add a new Java class and extend `AppWidgetProvider`, which handles the `onUpdate()` call
    for the widget. With the receiver created, we can then add it to the Android Manifest.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建小部件布局，它位于标准布局资源目录中。然后，我们将创建XML资源目录以存储`AppWidgetProviderInfo`文件。我们将添加一个新的Java类并扩展`AppWidgetProvider`，该类处理小部件的`onUpdate()`调用。创建接收器后，我们可以将其添加到Android
    Manifest中。
- en: 'Here are the detailed steps:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是详细的步骤：
- en: 'Create a new file in `res/layout` called `widget.xml` using the following XML:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`res/layout`中创建一个名为`widget.xml`的新文件，使用以下XML：
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Create a new directory called XML in the resource directory. The final result
    will be `res/xml`.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在资源目录中创建一个名为`XML`的新目录。最终结果将是`res/xml`。
- en: 'Create a new file in `res/xml` called `appwidget_info.xml` using the following
    XML:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`res/xml`中创建一个名为`appwidget_info.xml`的新文件，使用以下XML：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you cannot see the new XML directory, switch from Android view to Project
    view in the Project panel drop-down.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看不到新的XML目录，请从项目面板下拉菜单中切换到Android视图。
- en: Create a new Java class called `HomescreenWidgetProvider`, extending from `AppWidgetProvider`.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`HomescreenWidgetProvider`的新Java类，并从`AppWidgetProvider`扩展。
- en: 'Add the following `onUpdate()` method to the `HomescreenWidgetProvider` class:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`onUpdate()`方法添加到`HomescreenWidgetProvider`类中：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add the `HomescreenWidgetProvider` to the AndroidManifest using the following
    XML declaration within the `<application>` element:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下XML声明在`<application>`元素中向AndroidManifest添加`HomescreenWidgetProvider`：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Run the program on a device or emulator. After first running the application,
    the widget will then be available to add to the Home screen.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备或模拟器上运行程序。在首次运行应用程序后，小部件将可供添加到主屏幕。
- en: How it works...
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Our first step is to create the layout file for the widget. This is a standard
    layout resource with the restrictions based on the App Widget being a Remote View,
    as discussed in the recipe introduction. Although our example uses an Analog Clock
    widget, this is where you'd want to expand the functionality based on your application
    needs.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是创建小部件的布局文件。这是一个标准的布局资源，其限制基于App Widget是一个远程视图，如配方介绍中所述。尽管我们的示例使用的是模拟时钟小部件，但这是您根据应用程序需求扩展功能的地方。
- en: The XML resource directory serves to store the AppWidgetProviderInfo, which
    defines the default widget settings. The configuration settings determine how
    the widget is displayed when initially browsing the available widgets. We use
    very basic settings for this recipe, but they can easily be expanded to include
    additional features, such as a preview image to show
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: XML资源目录用于存储`AppWidgetProviderInfo`，它定义了默认的小部件设置。配置设置决定了在浏览可用小部件时小部件的显示方式。我们在这个配方中使用非常基本的设置，但它们可以很容易地扩展以包括其他功能，例如显示预览图像
- en: a functioning widget and sizing options. The `updatePeriodMillis` attribute
    sets the update frequency. Since the update will wake up the device, it's a trade-off
    between having up-to-date data and battery life. (This is where the optional Settings
    Activity is useful by letting the user decide.)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一个功能正常的widget和尺寸选项。`updatePeriodMillis`属性设置更新频率。由于更新会唤醒设备，这需要在最新的数据和电池寿命之间做出权衡。（这就是可选的设置Activity有用的地方，因为它允许用户做出决定。）
- en: The `AppWidgetProvider` class is where we handle the `onUpdate()` event triggered
    by the `updatePeriodMillis` polling. Our example doesn't need any updating so
    we set the polling to zero. The update is still called when initially placing
    the widget. `onUpdate()` is where we set the pending intent to open our app when
    the clock is pressed.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppWidgetProvider`类是我们处理由`updatePeriodMillis`轮询触发的`onUpdate()`事件的场所。我们的示例不需要任何更新，所以我们把轮询设置为零。当最初放置widget时，更新仍然会被调用。`onUpdate()`是我们设置挂起intent以在按下时钟时打开我们的app的地方。'
- en: Since the `onUpdate()` method is probably the most complicated aspect of AppWidgets,
    we'll explain this in some detail. First, it's worth noting that `onUpdate() `will
    occur only once each polling interval for all the widgets is created by this provider.
    (All additional widgets created will use the same cycle as the first widget created.)
    This explains the for loop, as we need it to iterate through all the existing
    widgets. This is where we create a pending intent, which calls our app when the
    clock widget is pressed. As discussed earlier, an AppWidget is a Remote View.
    Therefore, to get the layout, we call `RemoteViews()` with our fully qualified
    package name and the layout ID. Once we have the layout, we can attach the pending
    intent to the clock view using `setOnClickPendingIntent()`. We call the AppWidgetManager named `updateAppWidget()` to
    initiate the changes we made.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`onUpdate()`方法可能是AppWidgets中最复杂的一部分，我们将对此进行详细解释。首先，值得注意的是，`onUpdate()`方法将在每个由该提供程序创建的widget的轮询间隔内只发生一次。（所有额外创建的widget将使用与第一个创建的widget相同的周期。）这解释了for循环，因为我们需要它来遍历所有现有的widget。这就是我们创建挂起intent的地方，当时钟widget被按下时，它会调用我们的app。如前所述，AppWidget是一个远程视图。因此，为了获取布局，我们使用我们的完全限定包名和布局ID调用`RemoteViews()`。一旦我们有了布局，我们就可以使用`setOnClickPendingIntent()`将挂起intent附加到时钟视图。我们调用名为`updateAppWidget()`的`AppWidgetManager`来启动我们所做的更改。
- en: 'The last step to make all this work is to declare the widget in the Android
    Manifest. We identify the action we want to handle with the `<intent-filter>`.
    Most App Widgets will likely want to handle the Update event, as ours does. The
    other item to note in the declaration is the following line:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使所有这些工作完成的最后一步是在Android Manifest中声明widget。我们使用`<intent-filter>`标识我们想要处理的操作。大多数App
    Widgets可能希望处理更新事件，正如我们的那样。声明中需要注意的另一个项目是以下行：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This tells the system where to find our configuration file.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉系统在哪里可以找到我们的配置文件。
- en: There's more...
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Adding an App Widget configuration Activity allows greater flexibility with
    your widget. Not only can you offer polling options, but you could offer different
    layouts, click behaviors, and so on. Users tend to really appreciate flexible
    App Widgets.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 添加App Widget配置Activity可以让你的widget更加灵活。不仅你可以提供轮询选项，还可以提供不同的布局、点击行为等。用户通常非常欣赏灵活的App
    Widgets。
- en: 'Adding a configuration Activity requires a few additional steps. The Activity
    needs to be declared in the Manifest as usual, but needs to include the `APPWIDGET_CONFIGURE` action,
    as shown in the following example:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 添加配置Activity需要几个额外的步骤。Activity需要像往常一样在Manifest中声明，但需要包含`APPWIDGET_CONFIGURE`操作，如下例所示：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The Activity also needs to be specified in the `AppWidgetProviderInfo` file
    using the configure attribute, as shown in this example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 该Activity还需要在`AppWidgetProviderInfo`文件中使用configure属性进行指定，如下例所示：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The configure attribute requires the fully qualified package name as this Activity
    will be called from outside of your application.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`configure`属性需要完全限定的包名，因为这个Activity将从应用程序外部被调用。'
- en: Remember, the `onUpdate()` method will not be called when using a configuration
    Activity. The configuration Activity is responsible for handling any initial setup
    if required.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当使用配置Activity时，`onUpdate()`方法不会被调用。配置Activity负责处理任何所需的初始设置。
- en: See also
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For App Widget Design Guidelines, visit Google's page: [http://developer.android.com/design/patterns/widgets.html](http://developer.android.com/design/patterns/widgets.html)
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于App Widget设计指南，请访问Google的页面：[http://developer.android.com/design/patterns/widgets.html](http://developer.android.com/design/patterns/widgets.html)
- en: For detailed information on RemoteViews, visit [https://developer.android.com/reference/android/widget/RemoteViews](https://developer.android.com/reference/android/widget/RemoteViews)
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关RemoteViews的详细信息，请访问[https://developer.android.com/reference/android/widget/RemoteViews](https://developer.android.com/reference/android/widget/RemoteViews)
- en: Adding Search to the Action Bar
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将搜索添加到动作栏
- en: Along with the Action Bar, Android 3.0 introduced the SearchView widget, which can
    be included as a menu item when creating a menu. This is now the recommended UI
    pattern to provide a consistent user experience.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 除了动作栏，Android 3.0还引入了`SearchView`小部件，它可以在创建菜单时作为菜单项包含。现在，这是提供一致用户体验的推荐UI模式。
- en: 'The following screenshot shows the initial appearance of the Search icon in
    the Action Bar:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了动作栏中搜索图标的初始外观：
- en: '![](img/bd37bc6b-7747-4d27-abca-bccde619583d.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bd37bc6b-7747-4d27-abca-bccde619583d.png)'
- en: 'The following screenshot shows how the Search option expands when pressed:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了按下搜索选项时的展开情况：
- en: '![](img/d8e33142-60e2-4c0f-b107-de4e0c850759.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d8e33142-60e2-4c0f-b107-de4e0c850759.png)'
- en: If you want to add Search functionality to your application, this recipe will
    walk you through the steps to set up your User Interface and properly configure
    the Search Manager API.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在你的应用程序中添加搜索功能，这个菜谱将指导你设置用户界面并正确配置搜索管理器API的步骤。
- en: Getting ready
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in Android Studio and call it `SearchView`. Use the default Phone
    & Tablet options and select Empty Activity when prompted for the Activity Type.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中创建一个新的项目，命名为`SearchView`。使用默认的`Phone & Tablet`选项，并在提示活动类型时选择`Empty
    Activity`。
- en: How to do it...
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To set up the Search UI pattern, we need to create the Search menu item and
    a resource called searchable. We''ll create a second activity to receive the search
    query. Then, we''ll hook it all up in the `AndroidManifest` file. To get started,
    open the `strings.xml` file in `res/values` and follow these steps:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置搜索UI模式，我们需要创建搜索菜单项和一个名为`searchable`的资源。我们将创建第二个活动来接收搜索查询。然后，我们在`AndroidManifest`文件中将它们全部连接起来。要开始，打开`res/values`中的`strings.xml`文件并按照以下步骤操作：
- en: 'Add the following string resources:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下字符串资源：
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Create the menu directory: `res/menu`.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建菜单目录：`res/menu`。
- en: 'Create a new menu resource called `menu_search.xml` in `res/menu` using the
    following XML:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`res/menu`中创建一个名为`menu_search.xml`的新菜单资源，使用以下XML：
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Open ActivityMain and add the following `onCreateOptionsMenu()` to inflate
    the menu and set up the Search Manager:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`ActivityMain`并添加以下`onCreateOptionsMenu()`以填充菜单并设置搜索管理器：
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Create a new XML resource directory: `res/xml`.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的XML资源目录：`res/xml`。
- en: 'Create a new file in `res/xml` called `searchable.xml` using the following
    XML:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`res/xml`中创建一个名为`searchable.xml`的新文件，使用以下XML：
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create a new layout called `activity_search_result.xml` using this XML:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下XML创建一个名为`activity_search_result.xml`的新布局：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Add a new Empty Activity to the project called `SearchResultActivity`.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目中添加一个新的空活动，命名为`SearchResultActivity`。
- en: 'Add the following variable to the class:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中添加以下变量：
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Change `onCreate()` to load our layout, set the TextView, and check for the QUERY action:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`onCreate()`改为加载我们的布局，设置TextView，并检查QUERY动作：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add the following method to handle the search:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下方法来处理搜索：
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'With the User Interface and code now complete, we just need to hook everything
    up correctly in the AndroidManifest. Here is the complete manifest, including
    both activities:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户界面和代码现在已经完成，我们只需要在`AndroidManifest`中正确连接一切。以下是完整的清单，包括两个活动：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Run the application on a device or emulator. Type in a search query and hit
    the Search button (or press *Enter*). The SearchResultActivity will be displayed,
    showing the search query entered.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备或模拟器上运行应用程序。输入搜索查询并点击搜索按钮（或按*Enter*）。将显示`SearchResultActivity`，显示输入的搜索查询。
- en: How it works...
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Since the New Project Wizard uses the AppCompat library, our example uses the
    support library API. Using the support library provides the greatest device compatibility
    as it allows the use of modern features (such as the Action Bar) on older versions
    of the Android OS. This can sometimes provide an extra challenge as often the
    official documentation focuses on the framework API. Although usually the support
    library closely follows the framework API, they are not always interchangeable.
    The Search UI pattern is one of those situations, so it's worth paying extra attention
    to the steps outlined previously.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 由于新项目向导使用`AppCompat`库，我们的例子使用支持库API。使用支持库提供了最大的设备兼容性，因为它允许在较旧的Android OS版本上使用现代功能（如操作栏）。这有时会带来额外的挑战，因为官方文档通常关注框架API。尽管支持库通常遵循框架API，但它们并不总是可以互换。搜索UI模式就是这样一种情况，因此值得特别注意之前概述的步骤。
- en: We start by creating string resources for the Search View (which is declared
    later in step 6.)
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先为搜索视图（在步骤6中声明）创建字符串资源。
- en: In step 3, we create the menu resource, as we've done many times. One difference
    is that we use the app namespace for the `showAsAction` and `actionViewClass` attributes.
    The earlier versions of the Android OS don't include these attributes in the Android
    namespace, which is why we create an app namespace. This serves as a way to bring
    new functionality to older versions of the Android OS.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3步中，我们创建菜单资源，就像我们之前多次做的那样。一个不同之处在于我们使用`app`命名空间为`showAsAction`和`actionViewClass`属性。Android
    OS的早期版本不包括Android命名空间中的这些属性，这就是我们创建`app`命名空间的原因。这为将新功能引入较旧的Android OS版本提供了一种方式。
- en: In step 4, we set up the SearchManager, using the support library APIs.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4步中，我们使用支持库API设置`SearchManager`。
- en: Step 6 is where we define the searchable XML resource, which is used by the SearchManager.
    The only required attribute is the label, but a hint is recommended so the user
    will have an idea of what they should type in the field.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 第6步是我们定义可搜索的XML资源，该资源由搜索管理器使用。唯一必需的属性是标签，但建议添加一个提示，以便用户知道应该在字段中输入什么。
- en: The `android:label` must match the application name or the activity name and
    must use a string resource (as it does not work with a hardcoded string).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`android:label`必须与应用程序名称或活动名称匹配，并且必须使用字符串资源（因为它不适用于硬编码的字符串）。'
- en: Steps 7-11 are for the `SearchResultActivity`. Calling the second activity is
    not a requirement of the SearchManager, but is commonly done to provide a single
    activity for all searches initiated in your application.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 第7步到第11步是为`SearchResultActivity`的。调用第二个活动不是`SearchManager`的要求，但通常这样做是为了提供一个活动来处理应用程序中启动的所有搜索。
- en: 'If you ran the application at this point, you would see the search icon, but
    nothing would work. Step 12 is where we put it all together in the `AndroidManifest` file.
    The first item to note is the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在这个时候运行应用程序，你会看到搜索图标，但什么都不会工作。第12步是我们将所有内容整合到`AndroidManifest`文件中的地方。首先要注意的是以下内容：
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Notice this is in the `<application>` element and not in either of the `<activity>` elements.
    By defining it at the `<application>` level, it will automatically apply to all
    `<activities>`. If we moved it to the `MainActivity` element, it would behave
    exactly the same in our example.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这一点是在`<application>`元素中，而不是在任何一个`<activity>`元素中。通过在`<application>`级别定义它，它将自动应用于所有`<activities>`。如果我们将其移动到`MainActivity`元素，它在我们这个例子中的行为将完全相同。
- en: You can define styles for your application in the `<application>` node and still
    override individual activity styles in the `<activity>` node.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`<application>`节点中为你的应用程序定义样式，同时仍然可以在`<activity>`节点中覆盖单个活动样式。
- en: 'We specify the searchable resource in the SearchResultActivity `<meta-data>` element:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`SearchResultActivity`的`<meta-data>`元素中指定可搜索的资源：
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We also need to set the intent filter for `SearchResultActivity` as we do here:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要设置`SearchResultActivity`的意图过滤器，就像我们在这里做的那样：
- en: '[PRE25]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The SearchManager broadcasts the SEARCH intent when the user initiates the
    search. This declaration directs the intent to the SearchResultActivity activity.
    Once the search is triggered, the query text is sent to the SearchResultActivity using
    the SEARCH intent. We check for the SEARCH intent in the `onCreate()` and extract
    the query string using the following code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户启动搜索时，`SearchManager`会广播`SEARCH`意图。这个声明将意图指向`SearchResultActivity`活动。一旦搜索被触发，查询文本就会通过`SEARCH`意图发送到`SearchResultActivity`。我们在`onCreate()`中检查`SEARCH`意图，并使用以下代码提取查询字符串：
- en: '[PRE26]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You now have the Search UI pattern fully implemented. With the UI pattern complete,
    what you do with the search results is specific to your application needs. Depending
    on your application, you might search a local database or maybe a web service.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已完全实现了搜索UI模式。随着UI模式的完成，您对搜索结果的处理将具体取决于您的应用需求。根据您的应用，您可能需要搜索本地数据库或可能是一个网络服务。
- en: See also
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: To take your search to the internet, see internet queries in [Chapter 13](d130c363-73b4-48bd-aa87-e4398aef7664.xhtml),* Telephony,
    Networks, and the Web.*
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要将您的搜索扩展到互联网，请参阅[第13章](d130c363-73b4-48bd-aa87-e4398aef7664.xhtml)中的网络查询，*电话、网络和互联网*。
- en: Showing your app full-screen
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示您的应用全屏
- en: 'Android 4.4 (API 19) introduced a UI feature called Immersive Mode. Unlike
    the previous full-screen flag, your app receives all touch events while in Immersive
    Mode. This mode is ideal for certain activities, such as reading books and news,
    full-screen drawing, gaming, or watching a video. There are several different
    approaches to full-screen, and each has a best use case:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Android 4.4（API 19）引入了一个名为沉浸模式的UI功能。与之前的全屏标志不同，您的应用在沉浸模式下会接收到所有触摸事件。此模式适用于某些活动，例如阅读书籍和新闻、全屏绘图、游戏或观看视频。有几种不同的全屏方法，每种方法都有最佳使用案例：
- en: 'Reading books/articles, and so on: Immersive Mode with easy access to the'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读书籍/文章等：带有轻松访问的沉浸模式
- en: System UI
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 系统UI
- en: 'Game/drawing app: Immersive Mode for full-screen use but minimal System UI'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏绘图应用：用于全屏使用的沉浸模式，但系统UI最小化
- en: 'Watching video: Full-screen and normal System UI'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观看视频：全屏和正常系统UI
- en: The key difference between the modes is how the System UI responds. In the first
    two scenarios, your app is expecting user interaction, so the System UI is hidden
    to make it easier for your user (such as not hitting the back button while playing
    a game). While using full-screen with a normal System UI, such as watching a video,
    you wouldn't expect your user to use the screen at all, so when they do the System
    UI should respond normally. In all modes, the user can bring back the System UI
    with a swipe inward across the hidden System Bar.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 模式之间的主要区别在于系统UI的响应方式。在前两种情况下，您的应用期望用户交互，因此系统UI被隐藏，以便用户使用更方便（例如，在玩游戏时不会误按返回按钮）。在使用全屏和正常系统UI的情况下，例如观看视频，您不会期望用户使用屏幕，因此当用户这样做时，系统UI应该正常响应。在所有模式下，用户可以通过在隐藏的系统栏上向内滑动来恢复系统UI。
- en: Since watching a video doesn't require the new Immersive Mode, full-screen mode
    can be achieved using two flags, `SYSTEM_UI_FLAG_FULLSCREEN` and `SYSTEM_UI_FLAG_HIDE_NAVIGATION`,
    available since Android 4.0 (API 14).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由于观看视频不需要新的沉浸模式，可以使用两个标志`SYSTEM_UI_FLAG_FULLSCREEN`和`SYSTEM_UI_FLAG_HIDE_NAVIGATION`来实现全屏模式，这两个标志自Android
    4.0（API 14）以来可用。
- en: Our recipe will demonstrate setting up Immersive Mode. We're also going to add
    the ability to toggle the System UI with a tap on the screen.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的菜谱将演示设置沉浸模式。我们还将添加通过屏幕点击切换系统UI的功能。
- en: Getting ready
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in Android Studio and call it `ImmersiveMode`. Use the
    default Phone & Tablet options and select Empty Activity when prompted for the Activity
    Type. When selecting the Minimum API Level, choose API 19 or higher.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中创建一个新的项目，并将其命名为`ImmersiveMode`。使用默认的`Phone & Tablet`选项，并在提示活动类型时选择`Empty
    Activity`。在选择最小API级别时，选择`API 19`或更高。
- en: How to do it...
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'We''ll create two functions for handling the System UI visibility, then we''ll
    create a gesture listener to detect when the user taps on the screen. All the
    steps for this recipe are adding code to `MainActivity.java`, so open the file
    and let''s begin:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建两个用于处理系统UI可见性的函数，然后创建一个手势监听器来检测用户是否在屏幕上点击。此菜谱的所有步骤都是向`MainActivity.java`添加代码，因此请打开文件，让我们开始：
- en: 'Add the following method to hide the System UI:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下方法以隐藏系统UI：
- en: '[PRE27]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Add the following method to show the System UI:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下方法以显示系统UI：
- en: '[PRE28]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add the following class variable:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下类变量：
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Add the following `GestureListener` class at the class level, below the previous
    class variable:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类级别添加以下`GestureListener`类，在之前的类变量下方：
- en: '[PRE30]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Override the `onTouchEvent()` callback with the following:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下代码覆盖`onTouchEvent()`回调：
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Add the following code to the `onCreate()` method to set the GestureListener and
    hide the System UI:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`onCreate()`方法中，以设置`GestureListener`并隐藏系统UI：
- en: '[PRE32]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Run the application on a device or emulator. Tapping the screen will toggle
    the System UI. Depending on your version of the Android OS, you can either swipe
    up from the bottom or swipe down from the top to reveal the System UI.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备或模拟器上运行应用程序。轻触屏幕将切换系统 UI。根据你的 Android OS 版本，你可以从底部向上滑动或从顶部向下滑动以显示系统 UI。
- en: How it works...
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We call `setSystemUiVisibility()` with the appropriate flags in the `showSystemUI()` and `hideSystemUI()` methods
    to set the application window state. The flags we set (and don't set) control
    what is visible and what is hidden. When we set the visibility without the `SYSTEM_UI_FLAG_IMMERSIVE` flag,
    we in effect disable Immersive Mode.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `showSystemUI()` 和 `hideSystemUI()` 方法中使用适当的标志调用 `setSystemUiVisibility()`
    来设置应用程序窗口状态。我们设置的（和未设置的）标志控制着哪些内容可见，哪些内容隐藏。当我们设置可见性而不使用 `SYSTEM_UI_FLAG_IMMERSIVE`
    标志时，实际上我们禁用了沉浸模式。
- en: If all we wanted to do was hide the System UI, we could just add `hideSystemUI()` to `onCreate()` and
    we'd be done. The problem is it wouldn't stay hidden. Once the user left Immersive
    Mode, it would stay in the regular display mode. That's why we created the `GestureListener`.
    (We'll discuss gestures again in [Chapter 9](9ec1f7c4-f4c5-4cb3-b10a-59915ba73449.xhtml), *Using
    the Touchscreen and Sensors*.) Since we only want to respond to the `onSingleTapUp()` gesture,
    we don't implement the full range of gestures. When `onSingleTapUp` is detected,
    we toggle the System UI.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想隐藏系统 UI，我们只需将 `hideSystemUI()` 添加到 `onCreate()` 中即可完成。问题是它不会保持隐藏。一旦用户离开沉浸模式，它将保持在常规显示模式。这就是我们创建
    `GestureListener` 的原因。（我们将在[第 9 章](9ec1f7c4-f4c5-4cb3-b10a-59915ba73449.xhtml)，*使用触摸屏和传感器*中再次讨论手势。）由于我们只想响应
    `onSingleTapUp()` 手势，所以我们不实现完整的手势范围。当检测到 `onSingleTapUp` 时，我们切换系统 UI。
- en: There's more...
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let's look at some other important tasks that can be performed.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些其他可以执行的重要任务。
- en: Sticky Immersion
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 粘性沉浸
- en: There's another option we can use if we want the System UI to stay hidden automatically.
    Instead of using `SYSTEM_UI_FLAG_IMMERSIVE` to hide the UI, we can use `SYSTEM_UI_FLAG_IMMERSIVE_STICKY`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要系统 UI 自动保持隐藏，还有一个选项可以使用。我们不是使用 `SYSTEM_UI_FLAG_IMMERSIVE` 来隐藏 UI，而是使用
    `SYSTEM_UI_FLAG_IMMERSIVE_STICKY`。
- en: Dimming the System UI
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 降低系统 UI 的亮度
- en: If all you need is to reduce the visibility of the Navigation bar, there's also `SYSTEM_UI_FLAG_LOW_PROFILE` to
    dim the UI.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只需要减少导航栏的可见性，还可以使用 `SYSTEM_UI_FLAG_LOW_PROFILE` 来降低 UI 的亮度。
- en: 'Use this flag with the same `setSystemUiVisibility()` call as the Immersive
    Mode flag:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此标志与 Immersive 模式标志相同的 `setSystemUiVisibility()` 调用：
- en: '[PRE33]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Call `setSystemUiVisibility()` with 0 to clear all flags:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 0 作为参数调用 `setSystemUiVisibility()` 以清除所有标志：
- en: '[PRE34]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Setting the Action Bar as an overlay
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将操作栏设置为叠加层
- en: 'If you just need to hide or show the Action Bar, use these methods:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只需要隐藏或显示操作栏，请使用以下方法：
- en: '[PRE35]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'One problem with this approach is that the system resizes the layout each time
    either method is called. Instead, you might want to consider using a theme option
    to make the System UI behave as an overlay. To enable overlay mode, add the following
    to the theme:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个问题是，每次调用任一方法时系统都会调整布局的大小。相反，你可能希望考虑使用主题选项来使系统 UI 表现为一个叠加层。要启用叠加模式，请将以下内容添加到主题中：
- en: '[PRE36]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Translucent system bars
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 透明系统栏
- en: 'The following two themes enable translucent settings:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个主题可以启用透明设置：
- en: '[PRE37]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If you are creating your own theme, use the following theme settings:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在创建自己的主题，请使用以下主题设置：
- en: '[PRE38]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: See also
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: For more on handling gestures, refer to [Chapter 9](9ec1f7c4-f4c5-4cb3-b10a-59915ba73449.xhtml),* Using
    the Touchscreen and Sensors*.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于处理手势的信息，请参阅[第 9 章](9ec1f7c4-f4c5-4cb3-b10a-59915ba73449.xhtml)，*使用触摸屏和传感器*。
