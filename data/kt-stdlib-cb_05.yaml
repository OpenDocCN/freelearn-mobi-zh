- en: Tasteful Design Patterns Adopting Kotlin Concepts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 精美的设计模式采用 Kotlin 概念
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Implementing the Strategy pattern
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现策略模式
- en: Exploring the power of the Delegation pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索委托模式的强大功能
- en: Implementing delegated class properties
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现委托类属性
- en: Tracking state with the Observer pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用观察者模式跟踪状态
- en: Restricting property updates with the Vetoable delegate
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可撤销委托限制属性更新
- en: Implementing the advanced Observer pattern by defining a custom property delegate
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过定义自定义属性委托实现高级观察者模式
- en: Working with the Lazy delegate
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Lazy 委托
- en: Implementing builders the smart way
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 智能方式实现构建器
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: The following chapter is going to present popular, general-purpose design patterns
    applicable to a range of programming problems. The following recipes focus on
    exploiting Kotlin's built-in language support for implementing specific concepts
    and patterns. Apart from basic design patterns, such as Strategy or Builder, the
    chapter will focus on different usages of Delegation in a diverse set of applications
    and scenarios. Once you get familiar with the concepts presented in this chapter,
    you will be able to utilize the language's built-in features while designing and
    developing elegant and reliable systems.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节将介绍适用于各种编程问题的流行通用设计模式。以下食谱专注于利用 Kotlin 内置的语言支持来实现特定概念和模式。除了基本设计模式，如策略或构建器之外，该章节将重点介绍在多种应用程序和场景中不同用途的委托。一旦你熟悉了本章中介绍的概念，你将能够在设计和开发优雅且可靠系统时利用语言内置的功能。
- en: Implementing the Strategy pattern
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现策略模式
- en: 'The Strategy design pattern is used to provide an interchangeable set of strategies
    that can be applied to a given input and return an output of a specific type.
    We can understand the concept of a strategy as an action or an algorithm that
    can be applied to the input. A mechanism responsible for processing input should
    be able to switch between provided strategies at runtime. To illustrate the Strategy pattern,
    we are going to implement a text-formatting mechanism that allows us to apply
    a transformation to the input text and print it to the console. We are going to
    implement a class called `Printer`, which will provide a `printText(text: String)`
    function for printing the text to the console. Before printing out the text to
    the console, the `Printer` class will perform a transformation of the given `text`
    parameter according to the selected text formatting strategy.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '策略设计模式用于提供一组可互换的策略，这些策略可以应用于给定的输入并返回特定类型的输出。我们可以将策略的概念理解为可以应用于输入的动作或算法。负责处理输入的机制应该能够在运行时在提供的策略之间切换。为了说明策略模式，我们将实现一个文本格式化机制，允许我们对输入文本进行转换并将其打印到控制台。我们将实现一个名为`Printer`的类，它将为打印文本到控制台提供一个`printText(text:
    String)`函数。在将文本打印到控制台之前，`Printer`类将根据所选的文本格式化策略对给定的`text`参数进行转换。'
- en: How to do it...
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Implement the `Printer` class:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`Printer`类：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add sample strategies:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加示例策略：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s start by testing how our `Printer` class works in action. First, declare
    two instances of the `Printer` class—the first one with the `lowerCaseFormattingStrategy`
    for the `textFormattingStrategy` property, and the second one with `upperCaseFormattingStrategy`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先测试一下我们的`Printer`类在实际操作中的工作情况。首先，声明两个`Printer`类的实例——第一个实例使用`lowerCaseFormattingStrategy`作为`textFormattingStrategy`属性的值，第二个实例使用`upperCaseFormattingStrategy`：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, let''s use them to format and display the following text:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用它们来格式化和显示以下文本：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following output will print to the console:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出将打印到控制台：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `Printer.textFormattingStrategy` property is a function that takes a single
    `String` argument and returns a `String` type as the output. It is invoked inside
    the `printText(text: String)` function with the `text` parameter, and its output
    is returned by the function.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`Printer.textFormattingStrategy`属性是一个函数，它接受一个`String`类型的单个参数，并返回一个`String`类型的输出。它在`printText(text:
    String)`函数内部使用`text`参数调用，并且其输出由该函数返回。'
- en: There's more...
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You can practice by implementing your own text-formatting strategies. Try to
    implement a new text formatting strategy, called `capitalizeFormattingStrategy`,
    that will be responsible for capitalizing the first letter of the input text.
    Once you're done, create a new strategy be composed of the two implemented earlier—`lowerCaseFormattingStrategy`
    and `capitalizeFormattingStrategy`. You can refer to the *Function composition*
    recipe in [Chapter 3](28b29d37-7b8b-4812-9cc8-532d92b99068.xhtml), *Shaping Code
    with Kotlin Functional Programming Features*to learn more about the generic way
    of composing functions together.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过实现自己的文本格式化策略来练习。尝试实现一个新的文本格式化策略，称为`capitalizeFormattingStrategy`，它将负责将输入文本的首字母大写。完成后，创建一个新的策略，由之前实现的两个策略——`lowerCaseFormattingStrategy`和`capitalizeFormattingStrategy`——组合而成。你可以参考[第3章](28b29d37-7b8b-4812-9cc8-532d92b99068.xhtml)中的*函数组合*配方，*用Kotlin函数式编程特性塑造代码*来了解更多关于组合函数的通用方法。
- en: See also
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: If you are not familiar with the concept of higher-order functions used to declare
    the `Printer.textFormattingStrategy` property, you can explore the *Working with
    higher-order functions* recipe from [Chapter 3](28b29d37-7b8b-4812-9cc8-532d92b99068.xhtml),
    *Shaping Code with Kotlin Functional Programming Features*
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你不太熟悉用于声明`Printer.textFormattingStrategy`属性的更高阶函数的概念，你可以探索[第3章](28b29d37-7b8b-4812-9cc8-532d92b99068.xhtml)中的*使用高阶函数工作*配方，*用Kotlin函数式编程特性塑造代码*。
- en: Exploring the power of the Delegation pattern
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索委托模式的强大功能
- en: The Delegation pattern is a great alternative to typical inheritance of classes.
    Delegation allows a certain class to be derived from another one or to implement
    an interface. However, under the hood, the derived class is not a subclass of
    the base class but the composition is used instead to provide the properties of
    the base class to the derived one. Whenever a request to the properties of the
    base class part is made, it is being redirected to a delegated object. This is
    comparable to subclasses deferring a request to parent classes. However, delegation
    not only allows us to achieve the same code reusability as inheritance does, it's
    also much more powerful and customizable. Kotlin makes the Delegation pattern
    even more impressive because it provides a built-in support for declaring delegates
    using the `by` keyword.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 委托模式是典型类继承的一个很好的替代方案。委托允许一个类从另一个类派生或实现一个接口。然而，在底层，派生类不是基类的子类，而是使用组合来提供基类的属性给派生类。每当对基类部分的属性发出请求时，它会被重定向到委托对象。这类似于子类将请求委派给父类。然而，委托不仅允许我们实现与继承相同的代码重用性，而且它还更加强大和可定制。Kotlin通过提供使用`by`关键字声明委托的内置支持，使得委托模式更加引人注目。
- en: In this recipe, we are going to implement a combination of dependent classes
    modeling a simple book library system. We are going to write a code of a given
    UML class diagram that describes a set of dependent classes using inheritance.
    However, we are going to use the delegation pattern instead of any inheritance
    occurrences.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将实现一个组合依赖类，模拟一个简单的图书管理系统。我们将编写一个UML类图的代码，该类图描述了一组使用继承的依赖类。然而，我们将使用委托模式而不是任何继承出现。
- en: Getting ready
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We are going to work on implementing a set of the following classes using the
    Delegate pattern instead of inheritance:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用委托模式而不是继承来实现以下类集：
- en: '![](img/dc7b5ea9-ac66-4714-8eee-1964080ba13e.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dc7b5ea9-ac66-4714-8eee-1964080ba13e.jpg)'
- en: In this class diagram, you can see two base classes that are being derived from
    the `BasePublication` class with its  `Book` and `Magazine` subclasses, and the
    `BaseUser` class, which is extended by the `Member` and `Librarian` subclasses.
    Note that those base classes are implementing corresponding interfaces declaring
    their properties. The `BaseUser` class implements the `User` interface, and the
    `BasePublication` class implements the `Publication` interface. There is also
    the `Rental` interface, which declares methods implemented by the `Book` subclass.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类图中，你可以看到两个基类，它们从`BasePublication`类派生，该类有`Book`和`Magazine`子类，以及`BaseUser`类，它被`Member`和`Librarian`子类扩展。请注意，这些基类正在实现声明其属性的相应接口。`BaseUser`类实现了`User`接口，而`BasePublication`类实现了`Publication`接口。还有一个`Rental`接口，它声明了由`Book`子类实现的方法。
- en: 'In order to implement the delegation using the language''s built-in language
    features, we are going to operate on interfaces directly and remove any existing
    inheritance. Instead of extending the `BaseUser` and `BasePublication` base classes,
    we are going to use them as the properties of the final `User`, `Librarian`, `Book`,
    and `Magazine` classes, as presented in the following diagram:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用语言内置的语言特性来实现委托，我们将直接操作接口并移除任何现有的继承。我们不会扩展 `BaseUser` 和 `BasePublication`
    基类，而是将它们用作最终 `User`、`Librarian`、`Book` 和 `Magazine` 类的属性，如下面的图所示：
- en: '![](img/86204b5c-5743-49f3-8602-05eaebd4aa3d.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/86204b5c-5743-49f3-8602-05eaebd4aa3d.jpg)'
- en: How to do it...
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Declare the `Magazine` class implementing the `Publication` interface:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明实现 `Publication` 接口的 `Magazine` 类：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Delegate the `Publication` interface to the class property of the `Publication`
    type:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Publication` 接口委托给 `Publication` 类型的类属性：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Implement the `Rentable` interface:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `Rentable` 接口：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Implement the `Book` class, delegating its `Publication` interface functionality
    to the class member:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `Book` 类，将其 `Publication` 接口功能委托给类成员：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Implement the `Member` and `Librarian` classes, implementing the `User` interface
    and delegating it to their class properties:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `Member` 和 `Librarian` 类，实现 `User` 接口并将其委托给它们的类属性：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Using the `by` keyword, we have delegated the implementation of the `User`
    and `Publication` interfaces to specialized objects defined as class members.
    In the case of the `Book` and `Magazine` classes, the responsibilities for the
    `Publication` interface were delegated to the `publication: Publication` class
    properties, and, in the case of the `Member` and `Librarian` classes, the responsibilities
    for the `User` interface were delegated to the `user: User` properties.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '使用 `by` 关键字，我们将 `User` 和 `Publication` 接口的实现委托给作为类成员定义的专用对象。在 `Book` 和 `Magazine`
    类的情况下，`Publication` 接口的责任被委托给 `publication: Publication` 类属性，而在 `Member` 和 `Librarian`
    类的情况下，`User` 接口的责任被委托给 `user: User` 属性。'
- en: 'Now, let''s explore how we can work with delegated types. Let''s start by creating
    an instance of the `Book` class. We provide a `Book.publication`  property of
    the `Publication` type by reusing the original `BasePublication` class declaration:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索如何使用委托类型。让我们首先创建一个 `Book` 类的实例。我们通过重用原始的 `BasePublication` 类声明提供了一个
    `Book.publication` 属性，其类型为 `Publication`：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Note that we are able to access all the public members of the `Publication`
    interface directly from the `Book` class instance. Any requests to those `Publication`
    interface properties are being redirected to the `val publication` property of
    the `Book` class:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们能够直接从 `Book` 类实例访问 `Publication` 接口的所有公共成员。对这些 `Publication` 接口属性的任何请求都被重定向到
    `Book` 类的 `val publication` 属性：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the result, the preceding code should print the following output to the
    console:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在结果中，前面的代码应该在控制台输出以下内容：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: See also
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Another great type of Delegation design pattern is related to delegating class
    properties. You can find out more in the *Implementing delegated class properties *recipe.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一种优秀的委托设计模式与委托类属性相关。你可以在 *实现委托类属性* 章节中了解更多信息。
- en: Implementing delegated class properties
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现委托类属性
- en: 'Class properties in Kotlin are more than just plain class fields. The key characteristic
    of Kotlin properties is the fact that their values are specified by accessor functions
    automatically. Each class property in Kotlin has a dedicated set of accessor functions
    available out of the box. By default, the Kotlin compiler generates a field storing
    the value of the property and its getters or setters as well. Each immutable `val`
    property has a corresponding `get()` function provided and the mutable one declared
    with `var` keyword has the `set()` function in addition to a `get()` as well.
    We are also able to override a default implementation of the accessor function,
    which makes a property highly customizable and powerful. For example, we can override
    the `get()` function of the property and provide a custom implementation for it,
    which can stop the compiler from storing the value of the property in a field.
    Moreover, the fact that properties are represented by their accessor functions
    and not by the fields values makes *property delegation* possible.  The basic
    use cases for the property delegation include:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin中的类属性不仅仅是普通的类字段。Kotlin属性的关键特性是它们的值由自动生成的访问器函数指定。Kotlin中的每个类属性都有一组专用的访问器函数可用。默认情况下，Kotlin编译器会生成一个字段来存储属性的值及其getter或setter。每个不可变的`val`属性都有一个相应的`get()`函数，而用`var`关键字声明的可变属性除了`get()`函数外，还有一个`set()`函数。我们还可以覆盖访问器函数的默认实现，这使得属性高度可定制且功能强大。例如，我们可以覆盖属性的`get()`函数并提供一个自定义实现，这样就可以阻止编译器在字段中存储属性的值。此外，属性由其访问器函数表示而不是由字段值表示，这使得*属性委托*成为可能。属性委托的基本用例包括：
- en: Implementing lazy properties—providing the value that gets computed only upon
    first access
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现惰性属性——仅在首次访问时计算其值的属性
- en: Observable properties—listeners get notified about changes to the property
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可观察属性——监听器会在属性发生变化时收到通知
- en: Storing properties in a map, instead of a separate field for each property
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将属性存储在映射中，而不是为每个属性单独存储一个字段
- en: In this recipe, we are going to learn how to create a function allowing us to
    easily serialize class instance into JSON format by to delegating its properties
    to be stored in a map.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何创建一个函数，通过委托其属性以存储在映射中来轻松地将类实例序列化为JSON格式。
- en: Getting ready
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Similar to the interface delegation, the class property delegation is achieved
    using the `by` keyword in the following manner:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于接口委托，类属性委托是通过以下方式使用`by`关键字实现的：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The object which is delegated to should implement one of the following interfaces—`ReadWriteProperty`
    or `ReadOnlyProperty` from the `kotlin.properties` package. Those interfaces expose
    the `getValue()` and `setValue()` functions, which provide values for the property.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 被委托的对象应实现以下接口之一——来自`kotlin.properties`包的`ReadWriteProperty`或`ReadOnlyProperty`。这些接口公开了`getValue()`和`setValue()`函数，它们为属性提供值。
- en: 'We are going to use the `Gson` library to convert objects into their JSON format
    representation. It''s a widely used Java library for working with JSON-formatted
    objects.  You can learn more about the library on its GitHub site ([https://github.com/google/gson](https://github.com/google/gson)).
    If you''re using the Gradle build tool, you need to add the Gson artifact to the
    project dependencies:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`Gson`库将对象转换为它们的JSON格式表示。这是一个广泛使用的Java库，用于处理JSON格式的对象。您可以在其GitHub网站上了解更多关于该库的信息（[https://github.com/google/gson](https://github.com/google/gson)）。如果您使用Gradle构建工具，您需要将Gson工件添加到项目依赖项中：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How to do it...
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Implement the `Client` class containing a data property of a `Map<String, Any>`
    type:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现包含`Map<String, Any>`类型数据属性的`Client`类：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Implement the `CreditCard` class:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现以下`CreditCard`类：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add the `name`, `email`, and `creditCards` properties to the `Client` class
    and delegate them to the `data` property:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`name`、`email`和`creditCards`属性添加到`Client`类中，并将它们委托给`data`属性：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Implement the `toJson(): String` member function, allowing us to serialize
    a `Client` type object into JSON format, and the `fromJson(json: String): Client`
    utility function responsible for the opposite operation:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '实现成员函数`toJson(): String`，允许我们将`Client`类型对象序列化为JSON格式，以及负责相反操作的实用函数`fromJson(json:
    String): Client`：'
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Class properties can be delegated to a `Map` or `MutableMap` instance, which
    contains keys of the `String` type and values of the `Any` type. The map's keys
    correspond to the names of the class properties and the map's values associated
    with them store the properties values. The map that is delegated to is being updated
    dynamically whenever the delegated property is updated.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 类属性可以被委派给一个 `Map` 或 `MutableMap` 实例，该实例包含 `String` 类型的键和 `Any` 类型的值。映射的键对应于类属性的名称，与它们关联的映射值存储属性值。委派给映射的映射将在委派属性更新时动态更新。
- en: 'Let''s take a look at how we can make use of the `Client` class implemented
    in this recipe. We can instantiate the `Client` class by passing the `Map` instance
    to the class constructor:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何利用这个菜谱中实现的 `Client` 类。我们可以通过将 `Map` 实例传递给类构造函数来实例化 `Client` 类：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can also instantiate the `Client` class using the `fromJson()` function,
    passing a string containing a JSON representation of the sample `Client` type
    object:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `fromJson()` 函数实例化 `Client` 类，传递一个包含样本 `Client` 类型对象 JSON 表示的字符串：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you are working with IntelliJ IDE, you can use a cool *Language injection* feature
    that allows us to inject another language's code snippet as a String type and
    provides support for the language-specific syntax for editing and formatting. 
    You can use it to inject JSON snippets as a Kotlin String. You can learn more
    about it at the official JetBrains tutorial ([https://www.jetbrains.com/help/idea/using-language-injections.html](https://www.jetbrains.com/help/idea/using-language-injections.html)).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 IntelliJ IDE，你可以使用一个酷炫的*语言注入*功能，该功能允许我们将另一个语言的代码片段作为字符串类型注入，并提供对特定语言语法进行编辑和格式化的支持。你可以用它来将
    JSON 片段注入为 Kotlin 字符串。你可以在官方 JetBrains 教程中了解更多信息（[https://www.jetbrains.com/help/idea/using-language-injections.html](https://www.jetbrains.com/help/idea/using-language-injections.html)）。
- en: Under the hood, the `Client.fromJson()` function uses Gson to convert JSON data
    to the `Map<String, Any>` instance.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，`Client.fromJson()` 函数使用 Gson 将 JSON 数据转换为 `Map<String, Any>` 实例。
- en: 'We can now test those two ways and print the contents of both the `client1`
    and `client2` objects to the console:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以测试这两种方法，并将 `client1` 和 `client2` 对象的内容打印到控制台：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As the result, we are going to get the following output printed to the console:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 作为结果，我们将得到以下输出打印到控制台：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In both cases, all the class properties are stored in the `data` map object,
    no matter which way of instantiating the `Client` class was chosen. The delegation
    of the properties to the map allowed us to implement a mechanism that exports
    the state of the `Client` object to the map automatically. The map object was
    stored internally in the `Client` class, however, it could be declared anywhere
    else as well.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，无论选择哪种方式实例化 `Client` 类，所有类属性都存储在 `data` 映射对象中。将属性委派给映射允许我们实现一个机制，自动将
    `Client` 对象的状态导出到映射中。映射对象在 `Client` 类中内部存储，但也可以在别处声明。
- en: There's more...
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: In this recipe, we have created the `Client` class, which contains immutable
    `val` properties. In order to store mutable `var` properties, we can use a `MutableMap`
    instance instead of a read-only `Map`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们创建了包含不可变 `val` 属性的 `Client` 类。为了存储可变的 `var` 属性，我们可以使用 `MutableMap`
    实例而不是只读的 `Map`。
- en: Built-in support for class properties is a powerful feature of the language.
    It brings awesome possibilities to shape your code in a neat way. You should definitely
    give it a try when working on a more complex project. For example, you can delegate
    the properties of your entities to be read and written directly to and from the
    database. There is also a group of ready-to-use delegates built into the standard
    library, such as the *Lazy* or *Observable* delegates. You can learn more about
    their application in the next recipes in this chapter. You can explore the full
    set of built-in delegates in the official standard library docs: [https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-delegates/index.html.](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-delegates/index.html)
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 内置对类属性的支持是语言的一个强大功能。它为以整洁的方式塑造代码带来了惊人的可能性。当你在一个更复杂的项目上工作时，你绝对应该尝试一下。例如，你可以将你的实体属性委派给直接从数据库读取和写入。标准库中也内置了一些现成的委托，如
    *Lazy* 或 *Observable* 委托。你可以在本章的下一节中了解更多关于它们应用的信息。你可以在官方标准库文档中探索内置委托的全套：[https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-delegates/index.html.](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-delegates/index.html)
- en: See also
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: If you'd like to explore the concept of interface delegation, you can take a
    look at the *Exploring the power of Delegation pattern* recipe
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想探索接口委托的概念，可以查看*探索委托模式的强大功能*配方
- en: You should also learn about the standard property delegates provided by the
    standard library
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你还应该了解标准库提供的标准属性委托
- en: Tracking state with the Observer pattern
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用观察者模式跟踪状态
- en: 'The Observer pattern is a concept in which an object allows us to subscribe
    to the changes of its state and notifies a set of its observers automatically
    whenever there is a change of the object state. The implementation of the Observer
    pattern in Kotlin is pretty easy with the help of the built-in `Observable` property
    delegate offered by the standard library. In this recipe, we are going to implement
    an observable variable that will allow us to subscribe to the changes in its state.
    The subscribed listener should be notified immediately after any state updates.
    In the following example, we are going to declare the `temperature: Int` variable
    and subscribe to its changes.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '观察者模式是一个概念，其中一个对象允许我们订阅其状态的变化，并在对象状态发生变化时自动通知一组观察者。借助标准库提供的内置`Observable`属性委托，在Kotlin中实现观察者模式非常简单。在这个配方中，我们将实现一个可观察变量，允许我们订阅其状态的变化。订阅的监听器应在任何状态更新后立即被通知。在以下示例中，我们将声明`temperature:
    Int`变量并订阅其变化。'
- en: How to do it...
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Define an initial value for the temperature variable:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义温度变量的初始值：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Declare the listener for the variable that will be observed:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明将被观察的变量的监听器：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Declare the `temperature` variable, delegating its value to the `ReadWriteProperty`
    instance returned by the `Delegates.observable()` function:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`temperature`变量，将其值委托给由`Delegates.observable()`函数返回的`ReadWriteProperty`实例：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works...
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We are delegating the `var temperature` variable to the result of the `Delegates.observable()`
    function, which returns an instance of the `ReadWriteProperty` class. That fact
    makes it possible to declare `temperature` as a mutable variable. The `observe()`
    function takes two arguments—the initial value, and an instance of the hook function
    that is going to be invoked on every change made to the delegated variable. In
    our case, we are instantiating the function as the lambda block, which is supposed
    to print the new `temperature` value to the console.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`var temperature`变量委托给`Delegates.observable()`函数的结果，该函数返回一个`ReadWriteProperty`类的实例。这一事实使得我们可以将`temperature`声明为一个可变变量。`observe()`函数接受两个参数——初始值和一个钩子函数的实例，该函数将在对委托变量进行每次更改时被调用。在我们的例子中，我们将该函数实例化为lambda块，其目的是将新的`temperature`值打印到控制台。
- en: 'Let''s test how our implementation is going to work. We are going to modify
    the value of the temperature directly a couple of times:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试我们的实现将如何工作。我们将直接修改温度值几次：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As the result, we get the following output:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们得到以下输出：
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: On each change of the temperature value, the listener function is being invoked
    with the previous and new values of the property passed to its parameters.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在温度值每次更改时，监听器函数都会被调用，并将属性的前一个和新的值作为参数传递。
- en: See also
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: If you'd like to explore how the property delegates are working under the hood,
    take a look at the *Implementing delegated class properties* recipe
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想探索属性委托在底层是如何工作的，可以查看*实现委托类属性*配方
- en: Restricting property updates with the Vetoable delegate
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用可撤销委托限制属性更新
- en: In this recipe, we are going to explore the usage of the Vetoable delegate offered
    by the standard library. Similar to the Observable, the Vetoable tracks the changes
    applied to the delegated property. However, the Vetoable delegate is able to refuse
    to update the delegated property if a predefined update condition is not met.
    We are going to declare a variable of the `Int` type and specify the update condition,
    allowing us to update the variable only if the absolute value of change is greater
    than or equal to `10`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将探索标准库提供的可撤销委托的使用。与Observable类似，Vetoable跟踪对委托属性的更改。然而，如果未满足预定义的更新条件，可撤销委托可以拒绝更新委托属性。我们将声明一个`Int`类型的变量并指定更新条件，这样我们只能在变化的绝对值大于或等于`10`时更新变量。
- en: How to do it...
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s start by defining an initial value for the temperature variable:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从为温度变量定义一个初始值开始：
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Define the update condition for the observed variable:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义观察变量的更新条件：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Declare the `temperature: Int` variable and delegate it to the result of the
    `Delegates.vetoable()` function:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '声明 `temperature: Int` 变量并将其委派给 `Delegates.vetoable()` 函数的结果：'
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works...
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We are delegating the `var temperature` variable to the result of the `Delegates.vetoable()`
    function, which returns an instance of the `ReadWriteProperty` class. That fact
    makes it possible to declare `temperature` as a mutable variable. The `vetoable()` function
    takes two arguments—the initial value, and an instance of the hook function that
    is going to be invoked on every change made to the delegated variable.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `var temperature` 变量委派给 `Delegates.vetoable()` 函数的结果，该函数返回一个 `ReadWriteProperty`
    类的实例。这一事实使得将 `temperature` 声明为可变变量成为可能。`vetoable()` 函数接受两个参数——初始值和将被调用的钩子函数的实例，该函数将在对委派变量进行的每次更改上被调用。
- en: 'That function provides the current value of the delegated variable and a candidate
    for the new value. As the result, the function returns the Boolean—`true` if the
    value can be updated, and `false` if the update condition is not met. In our case,
    we are instantiating the function as the lambda block in which we check whether
    the absolute value of change is greater than or equal to `10`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数提供了委派变量的当前值和新值的候选者。作为结果，该函数返回一个布尔值——如果值可以更新，则返回 `true`，如果更新条件不满足，则返回 `false`。在我们的情况下，我们将该函数实例化为
    lambda 块，在其中检查变化的绝对值是否大于或等于 `10`：
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let''s test how our implementation is going to work. We are going to modify
    the value of `temperature` directly a couple of times with different values and
    verify whether the update was approved by printing the `temperature` state to
    the console:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试我们的实现将如何工作。我们将直接修改 `temperature` 的值几次，使用不同的值，并通过将 `temperature` 状态打印到控制台来验证更新是否被批准：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As the result, we get the following output printed out:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们得到以下输出打印出来：
- en: '[PRE33]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see, the value of temperature remains unchanged whenever we are assigning
    it with values that don't satisfy the specified condition.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，每次我们用不满足指定条件的值赋值给温度时，温度的值都保持不变。
- en: See also
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: In the next recipe, *Implementing the advanced observer using a custom property
    delegate, *we are going to combine together the functionalities of the Observable
    and Vetoable delegates by implementing our custom delegate. Read on to explore
    how to both filter updates of the property and implement the Observer pattern
    in one property delegate.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在下一个菜谱中，*使用自定义属性代理实现高级观察者*，我们将通过实现我们的自定义代理来结合 Observable 和 Vetoable 代理的功能。继续阅读，了解如何在一个属性代理中同时过滤属性更新并实现观察者模式。
- en: Implementing the advanced Observer pattern by defining a custom property delegate
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过定义自定义属性代理实现高级观察者模式
- en: 'In this recipe, we are going to implement a custom, generic property delegate
    combining features of the Observable and Vetoable delegates available in the standard
    library. In other words, we want to implement a property delegate that allows
    us to notify a subscribed listener about any changes made to the observed property.
    At the same time, we also want the delegate to allow filtering of the updates
    made to the delegated property. In this example, we are going to declare the `temperature:
    Int` variable delegated to our custom implementation of the `ObservableVetoable`
    delegate class. We are going to create a generic class that allows us to pass
    the initial value, a function responsible for filtering property updates and a
    function that will be invoked immediately after the change to the property is
    made.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个菜谱中，我们将实现一个自定义的、通用的属性代理，结合标准库中可用的 Observable 和 Vetoable 代理的功能。换句话说，我们希望实现一个属性代理，允许我们通知订阅的监听器关于观察属性所做的任何更改。同时，我们还想让代理允许过滤对委派属性的更新。在这个例子中，我们将声明
    `temperature: Int` 变量，并将其委派给我们的 `ObservableVetoable` 代理类的自定义实现。我们将创建一个通用类，允许我们传递初始值、负责过滤属性更新的函数以及将在属性更改后立即调用的函数。'
- en: How to do it...
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Define the custom property delegate called `ObservableVetoableDelegate` as
    a subclass of the `ObservableProperty` class:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为 `ObservableVetoableDelegate` 的自定义属性代理，作为 `ObservableProperty` 类的子类：
- en: '[PRE34]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Define the `initialTemperature`, `updatePrecondition`, and `updateListener` arguments
    required by the `ObservableVetoable` class:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `ObservableVetoable` 类所需的 `initialTemperature`、`updatePrecondition` 和 `updateListener`
    参数：
- en: '[PRE35]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Declare the `temperature: Int` variable by delegating it to the `ObservableVetoable`
    class instance:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '通过委托给`ObservableVetoable`类实例来声明`temperature: Int`变量：'
- en: '[PRE36]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How it works...
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We have defined the `ObservableVetoable` class and delegated the `var temperature:
    Int` variable to the `ObservableVetoable` instance. Our `ObservableVetoable` class
    extends the `ObservableProperty` class, which implements the `ReadWriteProperty`
    interface under the hood. Thanks to this, `ObservableProperty` allows us to delegate
    mutable properties to it. The `ObservableProperty` class also has the `beforeChange():
    Boolean` and `afterChange(): Unit` open functions, which are being invoked inside
    the `setValue()` function:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '我们已经定义了`ObservableVetoable`类，并将`var temperature: Int`变量委托给`ObservableVetoable`实例。我们的`ObservableVetoable`类扩展了`ObservableProperty`类，后者在底层实现了`ReadWriteProperty`接口。正因为如此，`ObservableProperty`允许我们将可变属性委托给它。`ObservableProperty`类还具有`beforeChange():
    Boolean`和`afterChange(): Unit`公开函数，这些函数在`setValue()`函数内部被调用：'
- en: '[PRE37]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As you can see, whenever the delegated property is assigned to a new value,
    the `beforeChange()` function is invoked to check whether the new value meets
    specified conditions. If the conditions are met, the property gets updated and
    the `afterChange()` function is called. In fact, our `ObservableVetoable` class
    takes instances of the function implementations, `updatePrecondition` and `updateListener`, which
    override the `beforeChange()` and `afterChange()` base functions. This way, we
    are able to both observe the changes made to the delegated property and notify
    the changes listener immediately to filter the changes being made to it.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，每当委托属性被分配给新值时，`beforeChange()`函数就会被调用以检查新值是否符合指定条件。如果条件满足，属性将被更新，并且会调用`afterChange()`函数。实际上，我们的`ObservableVetoable`类接受函数实现的实例，`updatePrecondition`和`updateListener`，这些函数覆盖了`beforeChange()`和`afterChange()`基函数。这样，我们既能观察委托属性的变化，又能立即通知变化监听器以过滤对其所做的更改。
- en: 'For example, we can test our implementation by updating the `temperature` variable
    five times with different values:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以通过用不同的值更新`temperature`变量五次来测试我们的实现：
- en: '[PRE38]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As a result, we are going to have only two lines printed to the console:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，我们将在控制台输出只有两行：
- en: '[PRE39]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This means that our mechanism is working properly because our update precondition
    function is checking whether the absolute value of change is greater than or equal
    to `10`. `updateListener()` is called only when the new value is accepted by the
    `updatePrecondition()` function.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的机制正在正常工作，因为我们的更新前提条件函数正在检查变化的绝对值是否大于或等于`10`。只有当新值被`updatePrecondition()`函数接受时，才会调用`updateListener()`。
- en: See also
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: If you'd like to get familiar with the basics of property-delegation support
    in Kotlin, take a look at the *Implementing delegated class properties *recipe,
    which contains an in-depth introduction and explanation of the language support
    for the delegation concept
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想熟悉 Kotlin 中属性委托支持的基础知识，请查看*实现委托类属性*配方，其中包含对语言对委托概念的深入介绍和解释。
- en: You can also explore the *Restricting property's updates with Vetoable* delegate
    and the *Tracking state with Observer pattern *recipes to get familiar with the
    Observer and Vetoable delegates provided by the standard library
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你还可以探索*使用 Vetoable 委托限制属性更新*和*使用观察者模式跟踪状态*配方，以熟悉标准库提供的观察者和Vetoable委托。
- en: Working with the Lazy delegate
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用懒委托
- en: Lazy initialization is another design pattern that has its dedicated delegate
    implementation included in the standard library. The concept of lazy initialization
    refers to the strategy of delaying the creation of an object, calculation of a
    value, or execution of some expensive operation until the first time it's needed.
    In this recipe, we are going to define a sample class, `CoffeeMaker`, and declare
    an object of its type via the Lazy delegate. Then we are going to perform example
    operations on the object to explore how the lazy delegate is working in action.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 懒初始化是另一种有专用委托实现的设计模式，该实现包含在标准库中。懒初始化的概念指的是延迟创建对象、计算值或执行某些昂贵操作，直到第一次需要时。在这个配方中，我们将定义一个示例类，`CoffeeMaker`，并通过`Lazy`委托声明其类型的对象。然后我们将对该对象执行示例操作，以探索懒委托在实际操作中的工作方式。
- en: How to do it...
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s start with defining the `CoffeeMaker` class:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从定义`CoffeeMaker`类开始：
- en: '[PRE40]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Declare a variable of the `CoffeMaker` type using the `lazy` delegate:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`lazy`委托声明一个`CoffeMaker`类型的变量：
- en: '[PRE41]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: How it works...
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s test out how the `coffeeMaker` instance is going to behave by running
    the following code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过运行以下代码来测试 `coffeeMaker` 实例的行为：
- en: '[PRE42]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'And here is the output printed out to the console:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是打印到控制台的结果：
- en: '[PRE44]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As you might have imagined, the constructor of the `CoffeeMaker` class is being
    called only upon the first request to the `coffeeMaker` variable. In fact, the
    lambda block passed to the lazy function is invoked on the call to the `coffeeMaker.makeEspresso()`
    function. Once the `CoffeeMaker` object is instantiated, it's reused for any consecutive
    operations performed on it.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所想象的那样，`CoffeeMaker` 类的构造函数仅在第一次请求 `coffeeMaker` 变量时被调用。实际上，传递给懒函数的 lambda
    块是在调用 `coffeeMaker.makeEspresso()` 函数时被调用的。一旦 `CoffeeMaker` 对象被实例化，它将被用于对该对象进行的任何连续操作。
- en: By default, the evaluation of lazy properties is synchronized; the value is
    computed only in one thread, and all threads will see the same value. If the synchronization
    of the initialization delegate is not required so that multiple threads can execute
    it simultaneously, pass `LazyThreadSafetyMode.PUBLICATION` as a parameter to the
    `lazy()` function. And if you're sure that the initialization will always happen
    on a single thread, you can use the `LazyThreadSafetyMode.NONE` mode, which doesn't
    incur any thread-safety guarantees and the related overhead ([https://kotlinlang.org/docs/reference/delegated-properties.html#lazy](https://kotlinlang.org/docs/reference/delegated-properties.html#lazy)).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，懒属性的评估是同步的；值仅在单个线程中计算，所有线程都将看到相同的值。如果不需要初始化代理的同步，以便多个线程可以同时执行它，请将 `LazyThreadSafetyMode.PUBLICATION`
    作为参数传递给 `lazy()` 函数。如果您确信初始化总是在单个线程上发生，您可以使用 `LazyThreadSafetyMode.NONE` 模式，它不提供任何线程安全保证，也没有相关的开销（[https://kotlinlang.org/docs/reference/delegated-properties.html#lazy](https://kotlinlang.org/docs/reference/delegated-properties.html#lazy)）。
- en: 'The `lazy()` function creates and returns an instance of the `Lazy<T>` interface:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`lazy()` 函数创建并返回 `Lazy<T>` 接口的实例：'
- en: '[PRE45]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As you can see, the `value` property is immutable and it's not possible to declare
    a mutable variable or property using the lazy delegate. Under the hood, the `Lazy` implementation
    returns a specific value of the object it holds and is checking internally if
    it has been already evaluated. During the first access to the object, the `initializer`
    function passed to the lazy function as an argument is being executed and its
    result is being assigned to the dedicated property. Later, the cached value is
    going to be used instead of re-evaluating the value each time.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`value` 属性是不可变的，并且无法使用懒代理声明可变变量或属性。在底层，`Lazy` 实现返回它所持有的对象的特定值，并内部检查它是否已经被评估。在第一次访问对象时，传递给懒函数作为参数的
    `initializer` 函数正在执行，并且其结果被分配给专用属性。之后，将使用缓存的值而不是每次重新评估值。
- en: See also
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考也
- en: If you'd like to explore how the property delegates are working under the hood,
    take a look at the *Implementing delegated class properties* recipe
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想探索属性代理在底层是如何工作的，请查看 *实现委托类属性* 菜单
- en: Implementing builders the smart way
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 智能地实现构建器
- en: The Builder design pattern is one of the most commonly used mechanisms for instantiating
    complex types in the Java language. It was strongly recommended by Joshua Bloch
    in the *Effective Java* book. Bloch says the builders should be used when we need
    to implement multiple constructors. He also mentions that builder pattern simulates
    named optional parameters. However, in Kotlin, those arguments for implementing
    a specialized builder class are no longer valid. Kotlin allows us to provide default
    values to the class constructor arguments and properties and it has built-in support
    for named arguments. Given those Kotlin features, there is no need to implement
    the builders in most scenarios since we can simply achieve their functionality
    using the language's built-in concepts. However, in Kotlin, we can adapt the Builder
    pattern to achieve even more. We are going to utilize the concept of the builder,
    together with higher-order functions and the possibility of inlining lambda parameters,
    to define the DSL-like syntax for instantiating instances of a given class.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 建造者设计模式是 Java 语言中用于实例化复杂类型最常用的机制之一。它在 Joshua Bloch 的《*Effective Java*》一书中被强烈推荐。Bloch
    表示，当我们需要实现多个构造函数时，应该使用构建器。他还提到，构建器模式模拟了命名可选参数。然而，在 Kotlin 中，那些实现专用构建器类的论据不再有效。Kotlin
    允许我们为类构造函数参数和属性提供默认值，并且它具有内置的命名参数支持。鉴于这些 Kotlin 特性，在大多数情况下，我们无需实现构建器，因为我们可以直接使用语言内置的概念来实现其功能。然而，在
    Kotlin 中，我们可以将构建器模式适应得更加灵活。我们将利用构建器的概念，结合高阶函数和内联 lambda 参数的可能性，为给定类的实例化定义类似 DSL
    的语法。
- en: Getting ready
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s assume we have the `Dialog` class specified in some external dependency
    with an interface provided as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个 `Dialog` 类在外部依赖中指定，提供的接口如下：
- en: '[PRE46]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `Dialog` class exposes the following properties—`title: String`, `message:
    String`, `messageColor: String`, and `image: File`. We are going to implement
    a `DialogBuilder` class, which allows us to instantiate the `Dialog` class using
    the builder pattern. As the result, we would like to create a mechanism that allows
    us to instantiate the `Dialog` type using a DSL-like syntax similar to the JSON
    format:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dialog` 类公开以下属性——`title: String`、`message: String`、`messageColor: String`
    和 `image: File`。我们将实现一个 `DialogBuilder` 类，它允许我们使用构建器模式实例化 `Dialog` 类。作为结果，我们希望创建一个机制，允许我们使用类似于
    JSON 格式的 DSL 语法实例化 `Dialog` 类型：'
- en: '[PRE47]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: How to do it...
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create the `DialogBuilder` class containing properties responsible for holding
    values needed by the `Dialog` class properties:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含 `Dialog` 类属性所需值的 `DialogBuilder` 类：
- en: '[PRE48]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Add the `title()`, `message()`, and `image()` functions, allowing us to modify
    the `titleHolder`, `message`, and `image` properties:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `title()`、`message()` 和 `image()` 函数，允许我们修改 `titleHolder`、`message` 和 `image`
    属性：
- en: '[PRE49]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Add the `build()` function, returning the `Dialog` class instance:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `build()` 函数，返回 `Dialog` 类实例：
- en: '[PRE50]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Declare a constructor taking a function responsible for initialization of the `DialogBuilder` class:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个构造函数，它接受一个负责初始化 `DialogBuilder` 类的函数：
- en: '[PRE51]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Implement the `dialog()` helper function, taking a function responsible for
    initializing `DialogBuilder` and returning the `Dialog` class instance:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个 `dialog()` 辅助函数，它接受一个负责初始化 `DialogBuilder` 的函数，并返回 `Dialog` 类实例：
- en: '[PRE52]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: How it works...
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s start by testing how we can use our `dialog()` function in action. Let''s
    use it to define a sample `Dialog` class instance:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先测试一下如何在实际操作中使用我们的 `dialog()` 函数。让我们用它来定义一个示例 `Dialog` 类实例：
- en: '[PRE53]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, we can invoke the `show()` function on the `dialog` variable, which is
    going print the following output to the console:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在 `dialog` 变量上调用 `show()` 函数，这将打印以下输出到控制台：
- en: '[PRE54]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: That's pretty cool! The `DialogBuilder` class allows us to compose instances
    of the `Dialog` type in a readable and natural way.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常酷！`DialogBuilder` 类允许我们以可读和自然的方式组合 `Dialog` 类型的实例。
- en: Implementing the new syntax for the `Dialog` class composition was possible
    by the use of higher-order functions and inline notation for lambda arguments.
    Note that each of the `DialogBuilder` functions, `title()`, `message()`, and `image()`,
    that are preparing information about the state of the target class properties,
    take a single functional parameter. The functional arguments are passed in the
    form of lambda blocks. There are two kinds of function types being used as parameters
    in the builder methods—the first one, which simply returns a specific value for
    the property, and the second one, which returns a function with a receiver type.
    The second type of the function returns `Unit` but takes an instance of the receivertype.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用高阶函数和 lambda 参数的内联表示法，实现了 `Dialog` 类组合的新语法。请注意，每个准备目标类属性状态信息的 `DialogBuilder`
    函数，如 `title()`、`message()` 和 `image()`，都接受一个单一的功能参数。功能参数以 lambda 块的形式传递。在构建方法中作为参数使用的有两种类型的函数类型——第一种简单地返回属性的特定值，第二种返回带有接收者类型的函数。第二种类型的函数返回
    `Unit` 但接受接收者类型的一个实例。
- en: Function types are allowed to have an additional receiver type, which is declared
    before the dot. In the following notation—the `A.(B) -> C` type represents a function
    that can be invoked on a receiver object of `A` type with a parameter of `B` type
    and return a value of `C`. Inside the body of the function literal, the receiver
    object passed to a call becomes an implicit `this`, so that you can access the
    members of that receiver object without any additional qualifiers, or access the
    receiver object using  `this` keyword. You can read more about the available function
    types and their applications on the official Kotlin reference: [https://kotlinlang.org/docs/reference/lambdas.html#function-types](https://kotlinlang.org/docs/reference/lambdas.html#function-types).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 函数类型允许有一个额外的接收者类型，该类型在点号之前声明。在以下表示法中，`A.(B) -> C` 类型代表一个可以在 `A` 类型接收者对象上调用，带有
    `B` 类型参数并返回 `C` 类型值的函数。在函数字面量的主体内部，传递给调用的接收者对象成为隐式的 `this`，这样你就可以无需任何额外的限定符访问该接收者对象的成员，或者使用
    `this` 关键字访问接收者对象。你可以在官方 Kotlin 参考[https://kotlinlang.org/docs/reference/lambdas.html#function-types](https://kotlinlang.org/docs/reference/lambdas.html#function-types)中了解更多关于可用函数类型及其应用的信息。
- en: 'For example, the `title(block: () -> String)` function simply invokes the block
    function and assigns the result to the `DialogBuilder.titleHolder` property. On
    the other hand, whenever we are dealing with complex types, such as `StyleableText`,
    we are using the second approach using a function with a receiver type function''s
    argument. For example, let''s analyze the `message(block: StyleableText.() ->
    Unit)` function:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，`title(block: () -> String)` 函数简单地调用块函数并将结果分配给 `DialogBuilder.titleHolder`
    属性。另一方面，当我们处理复杂类型，如 `StyleableText` 时，我们使用带有接收者类型函数参数的第二种方法。例如，让我们分析 `message(block:
    StyleableText.() -> Unit)` 函数：'
- en: '[PRE55]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Under the hood, it is executing the `block: StyleableText.() -> Unit` argument
    to modify the `messageHolder: StyleableText` property instance directly. The `block` argument
    is being invoked using the `()` modifier inside the `apply` function, which in
    this case provides the access to the `messageHolder` instance via a local `this`
    keyword. The same approach is used in the constructor of the `DialogBuilder` class:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '在底层，它执行的是 `block: StyleableText.() -> Unit` 参数来直接修改 `messageHolder: StyleableText`
    属性实例。`block` 参数通过 `apply` 函数内部的 `()` 修饰符被调用，在这种情况下，它通过局部 `this` 关键字提供了对 `messageHolder`
    实例的访问。同样的方法也用于 `DialogBuilder` 类的构造函数中：'
- en: '[PRE56]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The receiver of the `DialogBuilder` type is being provided to the functional
    parameter and the function passed as `initBlock` is invoked inside the constructor,
    allowing us to modify its state.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`DialogBuilder` 类的接收者被提供给功能参数，并且作为 `initBlock` 传递的函数在构造函数内部被调用，这允许我们修改其状态。'
- en: There's more...
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The concept of DSL-style builders is used extensively in many Kotlin libraries
    and frameworks. It is also employed by the standard library. For example, we can
    use the `html` function from the `kotlinx.html` library ([https://github.com/Kotlin/kotlinx.html](https://github.com/Kotlin/kotlinx.html))
    to generate the HTML code:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: DSL 风格构建器的概念在许多 Kotlin 库和框架中被广泛使用。它也被标准库所采用。例如，我们可以使用 `kotlinx.html` 库中的 `html`
    函数([https://github.com/Kotlin/kotlinx.html](https://github.com/Kotlin/kotlinx.html))来生成
    HTML 代码：
- en: '[PRE57]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The preceding code is going to generate a valid HTML code and print it to the
    console:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将生成有效的 HTML 代码并将其打印到控制台：
- en: '[PRE58]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: You can explore even more awesome applications of the Builders in Kotlin at [https://kotlinlang.org/docs/reference/type-safe-builders.html.](https://kotlinlang.org/docs/reference/type-safe-builders.html)
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://kotlinlang.org/docs/reference/type-safe-builders.html.](https://kotlinlang.org/docs/reference/type-safe-builders.html)探索
    Kotlin 中 Builders 的更多精彩应用。
- en: See also
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: If you'd like to learn more about the technical details of higher-order functions
    and inline notation for functional parameters, you can investigate the *Inlining
    parameters of closure type* recipe from [Chapter 2](b9f006c0-470d-4daa-9d55-7f7c0c8fea52.xhtml),
    *E**xpressive Functions and Adjustable Interfaces* and the *Working with higher
    order functions* recipe from [Chapter 3](28b29d37-7b8b-4812-9cc8-532d92b99068.xhtml), *Shaping
    Code with Kotlin Functional Programming Features*
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于高阶函数和函数参数内联表示法的技术细节，你可以研究[第2章](b9f006c0-470d-4daa-9d55-7f7c0c8fea52.xhtml)中的“*闭包类型参数的内联*”配方，*表达性函数和可调整接口*，以及[第3章](28b29d37-7b8b-4812-9cc8-532d92b99068.xhtml)中的“*使用高阶函数进行工作*”配方，*使用
    Kotlin 函数式编程特性塑造代码*。
