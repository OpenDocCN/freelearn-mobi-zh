- en: Chapter 11. Case Study – Developing an iOS Application with the FP and OOP Paradigms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章 案例研究 - 使用FP和OOP范式开发iOS应用程序
- en: In the previous chapters, we covered a variety of concepts and techniques. We
    started with FP paradigms and explored related topics in detail. Also, in the
    previous chapter, we covered other paradigms such as OOP, FRP, and POP, and mixing
    them together. In this chapter, we will create a simple application using those
    paradigms.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们介绍了各种概念和技术。我们从FP范式开始，并详细探讨了相关主题。此外，在前一章中，我们还介绍了其他范式，如OOP、FRP和POP，并将它们混合在一起。在本章中，我们将使用这些范式创建一个简单的应用程序。
- en: Most of iOS applications need a backend to be able to provide advanced functionalities
    such as integration with other systems. In this chapter, we will create a simple
    backend with Swift that is going to be used as a Todo application rest API. Then,
    we will develop an iOS application that will leverage our backend and provide
    some essential functionality such as listing and updating Todo items coming from
    the backend. Also, iOS application will be able to create new Todo items. Our
    iOS application development will include FP, OOP, POP, and FRP paradigms.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数iOS应用程序需要一个后端来提供与其他系统集成的先进功能。在本章中，我们将使用Swift创建一个简单的后端，该后端将用作待办事项应用的REST API。然后，我们将开发一个iOS应用程序，该应用程序将利用我们的后端并提供一些基本功能，例如列出和更新来自后端的后待办事项。此外，iOS应用程序还将能够创建新的待办事项。我们的iOS应用程序开发将包括FP、OOP、POP和FRP范式。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Requirement specifications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需求规范
- en: High-level design
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级设计
- en: Backend development
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后端开发
- en: Environment configuration
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境配置
- en: Swift Package Manager
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift包管理器
- en: Vapor
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vapor
- en: Application development
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序开发
- en: Frontend development
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端开发
- en: CocoaPods dependency management configuration
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: CocoaPods依赖管理配置
- en: Third-party libraries
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三方库
- en: Backend communication
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后端通信
- en: JSON parsing and model mapping
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON解析和模型映射
- en: State management
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态管理
- en: Listing items with a UITableView
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用UITableView列出项目
- en: Updating and creating items
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新和创建项目
- en: Filtering items
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤项目
- en: Requirements
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要求
- en: This section presents the requirements for our case study. Since the focus of
    this book is not requirement engineering, we will define very simple requirements.
    This section does not present best practices for requirements engineering.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了案例研究的需求。由于本书的重点不是需求工程，我们将定义非常简单的需求。本节不介绍需求工程的最佳实践。
- en: 'The requirements for the iOS application user are as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: iOS应用程序用户的要求如下：
- en: Users should be able to list Todo items
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应能够列出待办事项
- en: Users should be able to see the details of each item
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应能够查看每个项目的详细信息
- en: Users should be able to modify items
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应能够修改项目
- en: Users should be able to create a new item
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应能够创建新项目
- en: Users should be able to filter items by their status
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应能够根据其状态过滤项目
- en: High-level design
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级设计
- en: This section explains the high-level design of the frontend and backend.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了前端和后端的高级设计。
- en: Frontend
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 前端
- en: Application design follows a slightly different version of the **Model-View-Controller**
    (**MVC**) pattern, with the addition of the `Actions` , `Store`, `State`, and
    `Communication` layers to simplify the controller layer of traditional iOS application
    MVC pattern. All application layers are explained in the following sections.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序设计遵循**模型-视图-控制器**（**MVC**）模式的一个略微不同的版本，增加了`Actions`、`Store`、`State`和`Communication`层以简化传统iOS应用程序MVC模式的控制器层。所有应用程序层将在以下各节中解释。
- en: Models
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模型
- en: 'Plain old model structures. These models do not have any logic and only consist
    of properties. There are four types of models:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的模型结构。这些模型没有任何逻辑，仅由属性组成。有四种类型的模型：
- en: '**TodoRequest**: This is a struct that is used in backend request calls and
    conforms to `RequestProtocol`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TodoRequest**：这是一个用于后端请求调用并符合`RequestProtocol`的结构体'
- en: '**Todo**: This is a struct that represents the Todo data, and uses the **Argo**
    and **Curry** libraries to decode the object from JSON'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**待办事项**：这是一个表示待办事项数据的结构体，并使用**Argo**和**Curry**库从JSON解码对象'
- en: '**TodoViewModel and TodosViewModel**: These structs represent data and are
    used in views and shown to the user'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TodoViewModel和TodosViewModel**：这些结构体表示数据，并在视图中使用，并展示给用户'
- en: '**TodoLens**: These lenses modify the Todo model'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TodoLens**：这些透镜修改待办事项模型'
- en: All the aforementioned models are immutable value types.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 所述所有模型都是不可变值类型。
- en: Views
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 视图
- en: 'We have two View subclasses: one to provide a custom `UITableViewCell` called
    `TodoTableViewCell` and a subclass of `UIView` named `FooterView`.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个视图子类：一个提供自定义的`UITableViewCell`，称为`TodoTableViewCell`，以及一个名为`FooterView`的`UIView`子类。
- en: Both of these Views are subclasses of iOS SDK-provided classes. Besides these
    classes, we will have our `UIViewController` scenes in the storyboard.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个视图都是iOS SDK提供的类的子类。除了这些类，我们还将有我们的`UIViewController`场景在Storyboard中。
- en: ViewController
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ViewController
- en: '`ViewController` is a subclass of `UIViewController` or `UITableViewController`,
    and it connects views to logic:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewController`是`UIViewController`或`UITableViewController`的子类，它将视图与逻辑连接起来：'
- en: '**MasterViewController:** This is a subclass of `UITableViewController` to
    present Todo items'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MasterViewController:** 这是一个`UITableViewController`的子类，用于展示待办事项'
- en: '**DetailsViewController:** This is a subclass of `UIViewController` to present
    details of each Todo item to the user'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DetailsViewController:** 这是一个`UIViewController`的子类，用于向用户展示每个待办事项的详细信息'
- en: To develop iOS applications, we have to rely on iOS SDK-provided classes such
    as `UIViewController` and `UITableViewController`. The `ViewController` and `UIView`
    subclasses are the only classes that will be used in this case study.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要开发iOS应用程序，我们必须依赖于iOS SDK提供的类，如`UIViewController`和`UITableViewController`。在这种情况下，我们将只使用`ViewController`和`UIView`的子类。
- en: State
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: State
- en: In iOS application development, we need to handle states. We use the Delta and
    ReactiveCocoa libraries to manage our `Todo` App's state.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS应用程序开发中，我们需要处理状态。我们使用Delta和ReactiveCocoa库来管理我们的待办事项应用程序的状态。
- en: Delta takes an App that has custom state management spread throughout all the
    `ViewControllers` and simplifies it by providing a simple interface to change
    state and subscribe to its changes.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Delta接受一个应用程序，该应用程序在所有`ViewControllers`中具有分散的自定义状态管理，并通过提供一个简单的接口来更改状态和订阅其变化来简化它。
- en: ReactiveCocoa is a FRP cocoa framework that provides APIs for composing and
    transforming streams of values over time.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ReactiveCocoa是一个FRP cocoa框架，它提供了在时间上组合和转换值流的API。
- en: We will implement a `State` struct that will provide the `observable` properties.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个`State`结构体，它将提供`可观察`属性。
- en: Store
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Store
- en: Our `Store` struct will wrap the `State` struct and provide properties to observe
    its changes. `Store` conforms to the Delta library's `StoreType` protocol, which
    defines the storage of an observable state and dispatch methods to modify it.
    Also, `Store` uses ReactiveCocoa's `MutableProperty` value and allows observation
    of its changes in a thread-safe manner.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Store`结构体会包装`State`结构体，并提供属性以观察其变化。`Store`遵循Delta库的`StoreType`协议，该协议定义了可观察状态的存储和修改它的分发方法。此外，`Store`使用ReactiveCocoa的`MutableProperty`值，并允许以线程安全的方式观察其变化。
- en: Actions
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Actions
- en: Actions are structs that conform to the `ActionType` protocol from the Delta
    library. `ActionType` is used when we want to make modifications to the store's
    state. All changes to the store go through this type.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 操作是遵循Delta库的`ActionType`协议的结构体。当我们要对存储的状态进行修改时使用`ActionType`。所有对存储的更改都通过此类型进行。
- en: 'We will develop the following actions in the application:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在应用程序中开发以下操作：
- en: '`ClearCompletedTodosAction`: This is used to delete completed Todo items from
    the list'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClearCompletedTodosAction`: 用于从列表中删除已完成的待办事项'
- en: '`CreateTodoAction`: This is used to create a new Todo item'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreateTodoAction`: 用于创建新的待办事项'
- en: '`DeleteTodoAction`: This is used to delete a Todo item'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DeleteTodoAction`: 用于删除待办事项'
- en: '`DetailsTodoAction`: This is used to present the details of an item'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DetailsTodoAction`: 用于展示项目的详细信息'
- en: '`LoadTodosAction`: This is used to list all Todo items'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoadTodosAction`: 用于列出所有待办事项'
- en: '`SetFilterAction`: This is used to filter Todo items'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetFilterAction`: 用于过滤待办事项'
- en: '`ToggleCompletedAction`: This is used to mark a Todo item as completed'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ToggleCompletedAction`: 用于标记待办事项为完成'
- en: '`UpdateTodoAction`: This is used to update a Todo item'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UpdateTodoAction`: 用于更新待办事项'
- en: Manager
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理员
- en: '`TodoManager` provides global functions to handle backend API calls and JSON
    payload mapping. `TodoManager` uses `WebServiceManager` for backend calls and
    the Argo library to map JSON payloads to the `Todo` model. Also, `TodoManager`
    will update the `State` in the `Store` through `Lenses` and `Action`.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`TodoManager`提供全局函数来处理后端API调用和JSON有效负载映射。`TodoManager`使用`WebServiceManager`进行后端调用，并使用Argo库将JSON有效负载映射到`Todo`模型。此外，`TodoManager`将通过`Lenses`和`Action`更新`Store`中的`State`。'
- en: Communication
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Communication
- en: 'The communication layer is responsible for backend communication. It includes
    the following components:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通信层负责后端通信。它包括以下组件：
- en: '`WebServiceManager`: This provides a global function named `sendRequest` that
    is used by `TodoManager` to call the backend API. Also, it uses `configureHeaders` to
    perform a reflection on request to get its properties and respective values.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebServiceManager`：它提供了一个名为 `sendRequest` 的全局函数，该函数被 `TodoManager` 用于调用后端
    API。它还使用 `configureHeaders` 来对请求进行反射，以获取其属性和相应的值。'
- en: '`Urls`: This enum provides a proper HTTP request method and a full URL address
    by pattern matching and extension.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Urls`：这个枚举通过模式匹配和扩展提供了一个适当的 HTTP 请求方法和完整的 URL 地址。'
- en: '`Alamofire`: This is a library that is used by `WebServiceManager` for HTTP
    request handling.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Alamofire`：这是一个库，由 `WebServiceManager` 用于 HTTP 请求处理。'
- en: '`Argo`: This library maps model objects from and to JSON functionally.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Argo`：这个库以功能方式将模型对象映射到 JSON。'
- en: Communication between layers
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 层之间的通信
- en: Application uses closures and `ReactiveCocoa` signals for communication between
    layers.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序使用闭包和 `ReactiveCocoa` 信号进行层之间的通信。
- en: Third-party libraries
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第三方库
- en: 'The following third-party libraries/frameworks are used in our iOS application:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下第三方库/框架被用于我们的 iOS 应用程序中：
- en: '**Alamofire**: This is a web service calling and management framework'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Alamofire**：这是一个用于调用和管理网络服务的框架'
- en: '**Argo**: This is a functional JSON parsing library'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Argo**：这是一个功能性的 JSON 解析库'
- en: '**CocoaPods**: This is responsible for dependency management'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CocoaPods**：它负责依赖管理'
- en: '**Delta**: This is the state management library'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Delta**：这是一个状态管理库'
- en: '**ReactiveCocoa**: This is a **Functional Reactive Programming** (**FRP**)
    library to handle signals and streams'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ReactiveCocoa**：这是一个用于处理信号和流的 **函数式响应式编程**（**FRP**）库'
- en: '**Quick**: This is a behavior-driven development framework used for unit testing'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Quick**：这是一个用于单元测试的行为驱动开发框架'
- en: Cross-cutting concerns
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跨切面关注点
- en: This section explains cross-cutting concerns such as error management, exception
    handling, and so on.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了跨切面关注点，如错误管理、异常处理等。
- en: Error management and exception handling
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 错误管理和异常处理
- en: As discussed in previous chapters of this book.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如本书前几章所讨论的。
- en: Crash reporting
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 崩溃报告
- en: We will use **Crashlytics**, which is a part of `fabric.io` offering by Twitter.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 **Crashlytics**，它是 Twitter 提供的 `fabric.io` 服务的一部分。
- en: Analytics
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 分析
- en: We will use `fabric.io` **Answers** to monitor application usage. There are
    other analytics services such as **Google Analytics**, **Flurry**, and Mixpanel
    that can be used for this case study. We are going to use Answers for the sake
    of simplicity.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `fabric.io` **Answers** 来监控应用程序的使用情况。还有其他分析服务，如 **Google Analytics**、**Flurry**
    和 Mixpanel，也可以用于本案例研究。为了简化，我们将使用 Answers。
- en: Tools
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工具
- en: Tools We will use Xcode to develop our application. AppCode by JetBrains is
    another IDE for iOS application development with better refactoring capabilities
    that can be used for this case study.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 工具 我们将使用 Xcode 来开发我们的应用程序。JetBrains 的 AppCode 是另一个用于 iOS 应用程序开发的 IDE，它具有更好的重构功能，也可以用于本案例研究。
- en: Backend
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后端
- en: There are various web framework and HTTP servers for Swift, which are works-in-progress.
    **Kitura**, **Perfect**, and Vapor are three of the most popular ones. None of
    them are designed and developed in FP style. We will use Vapor in our example
    to provide a backend that can be leveraged by our frontend application.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Swift，有各种网络框架和 HTTP 服务器，它们仍在开发中。**Kitura**、**Perfect** 和 Vapor 是其中最受欢迎的三个。它们都不是以函数式编程风格设计和开发的。在我们的示例中，我们将使用
    Vapor 来提供一个可以被我们的前端应用程序利用的后端。
- en: Vapor
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Vapor
- en: Vapor ([https://github.com/qutheory/vapor](https://github.com/qutheory/vapor))
    is a popular Laravel/Lumen-inspired web framework that is MIT-licensed. It is
    purely written in Swift and is modular.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Vapor ([https://github.com/qutheory/vapor](https://github.com/qutheory/vapor))
    是一个流行的 Laravel/Lumen 启发的 MIT 许可的 Web 框架。它完全用 Swift 编写，并且是模块化的。
- en: Vapor provides CLI tools to simplify building and running Vapor applications.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Vapor 提供了 CLI 工具来简化构建和运行 Vapor 应用程序。
- en: '`vapor new <project-name>` can be used to create a new project, `vapor build`
    can be used to build the project and download dependencies, `vapor xcode` can
    be used to create Xcode project, and `vapor run` can be used to run the project.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`vapor new <project-name>` 可以用来创建一个新项目，`vapor build` 可以用来构建项目并下载依赖项，`vapor
    xcode` 可以用来创建 Xcode 项目，`vapor run` 可以用来运行项目。'
- en: 'Vapor uses **Swift Package Manager** (**SPM**) as the dependency manager and
    starting an application with Vapor is as easy as importing Vapor and adding the
    following lines to the `main` file:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Vapor 使用 **Swift Package Manager**（**SPM**）作为依赖管理器，使用 Vapor 启动应用程序就像导入 Vapor
    并在 `main` 文件中添加以下行一样简单：
- en: '[PRE0]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Routing
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 路由
- en: 'Routing in Vapor is simple:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vapor中进行路由很简单：
- en: '[PRE1]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Adding the preceding code to the main file will make our web application respond
    to all `GET` requests to `localhost:8080/welcome` with the string `Hello, World`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 将上述代码添加到主文件中，将使我们的Web应用程序对所有`localhost:8080/welcome`的`GET`请求响应字符串`Hello, World`。
- en: JSON
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: JSON
- en: 'It is easy to respond with JSON:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以JSON形式响应很容易：
- en: '[PRE2]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding code responds to all `GET` requests to `localhost:8080/version`
    with the JSON dictionary `{"version": "0.1"}` and `Content-Type: application/json`.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '上述代码响应了所有对`localhost:8080/version`的`GET`请求，返回JSON字典`{"version": "0.1"}`和`Content-Type:
    application/json`。'
- en: Requesting data
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 请求数据
- en: Every route call gets passed a `request` object that can be used to grab query
    and path parameters.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 每个路由调用都会传递一个`request`对象，可以用来获取查询和路径参数。
- en: 'The following example shows how to access JSON, Query, and form-encoded data
    from the request:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何从请求中访问JSON、查询和表单编码的数据：
- en: '[PRE3]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, we read the request data and return a string.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们读取请求数据并返回一个字符串。
- en: Vapor also provides the means for session management, database connection, and
    view responses with HTML or Stencil template-included HTML pages. There is an
    example Vapor project ([https://github.com/qutheory/vapor-example](https://github.com/qutheory/vapor-example))
    that can be used and modified for our purposes. We are not going to explore Vapor
    in depth since it is still in a work-in-progress.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Vapor还提供了会话管理、数据库连接以及使用HTML或包含HTML模板的Stencil模板的视图响应的途径。有一个示例Vapor项目([https://github.com/qutheory/vapor-example](https://github.com/qutheory/vapor-example))，可以用于我们的目的并进行修改。由于Vapor仍在开发中，我们不会深入探讨Vapor。
- en: SPM
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SPM
- en: SPM is an open source build and dependency management tool provided for Swift
    3.0\. It is integrated with the Swift build system to automate the process of
    downloading, compiling, and linking dependencies.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: SPM是一个为Swift 3.0提供的开源构建和依赖管理工具。它与Swift构建系统集成，以自动化下载、编译和链接依赖项的过程。
- en: 'Vapor uses SPM and to create a Vapor project we need to add the following dependency
    to the `Packages.swift` file:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Vapor使用SPM，要创建一个Vapor项目，我们需要在`Packages.swift`文件中添加以下依赖项：
- en: '[PRE4]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As stated in the *Vapor* section, we can use Vapor CLI tools to build and run
    the application with SPM.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如*Vapor*部分所述，我们可以使用Vapor CLI工具，结合SPM来构建和运行应用程序。
- en: It is recommended to read more about Vapor and SPM since we do not cover most
    of the related topics in this book. In the following section, we will develop
    a very simple backend with Vapor.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 建议阅读更多关于Vapor和SPM的内容，因为我们在这本书中没有涵盖大多数相关主题。在下一节中，我们将使用Vapor开发一个非常简单的后端。
- en: Backend development
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 后端开发
- en: We want to develop a very simple backend for a Todo application.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想为Todo应用程序开发一个非常简单的后端。
- en: Model
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型
- en: 'We will start by creating our model. The code is as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建我们的模型。代码如下：
- en: '[PRE5]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This class imports Vapor and includes some of the `Todo`-related properties
    as well as an `init` method.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类导入了Vapor，并包含了一些与`Todo`相关的属性以及一个`init`方法。
- en: 'To be able to pass this model into JSON arrays and dictionaries, we need to
    extend a protocol called `JsonRepresentable`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够将此模型传递到JSON数组和字典中，我们需要扩展一个名为`JsonRepresentable`的协议：
- en: '[PRE6]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Store
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储
- en: 'Then we want to store list of Todo items in memory. To be able to achieve this,
    we will create a new class called `TodoStore`. The code is as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们想在内存中存储Todo项的列表。为了实现这一点，我们将创建一个新的类，称为`TodoStore`。代码如下：
- en: '[PRE7]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For the sake of simplicity, we make this class a singleton that stores a list
    of Todo items. Also, we make the `init` method `private` to avoid non-shared instance
    initiation.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们将这个类设计为单例，存储一个Todo项的列表。同时，我们将`init`方法设置为`private`以避免非共享实例的初始化。
- en: 'To allow instances of Todo to be passed into JSON arrays and dictionaries as
    if it were a native JSON type, we will need to extend our `TodoStore` by conforming
    to `JSONRepresentable` as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许Todo实例被传递到JSON数组和中，就像它是原生JSON类型一样，我们需要通过遵循以下方式扩展我们的`TodoStore`以符合`JSONRepresentable`协议：
- en: '[PRE8]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we add the following methods:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加以下方法：
- en: '[PRE9]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As the names suggest, these methods will be used for adding and listing items.
    We will need a very simple find method, so let''s develop it:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，这些方法将用于添加和列出项目。我们需要一个非常简单的查找方法，让我们来开发它：
- en: '[PRE10]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we use `index` and `map` higher-order functions to find the index and
    return the respective array element.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`index`和`map`高阶函数来查找索引并返回相应的数组元素。
- en: 'Then, we will need to develop `update` and `delete` methods:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要开发`update`和`delete`方法：
- en: '[PRE11]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Also, we can combine add and update as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以将添加和更新合并如下：
- en: '[PRE12]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: At this point, our `TodoStore` is capable of all CRUD operations.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的`TodoStore`能够执行所有CRUD操作。
- en: Controller
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制器
- en: The next step will be developing routing, request, and response handling. For
    the sake of simplicity, we will modify `main.swift` in the Vapor example.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步将是开发路由、请求和响应处理。为了简单起见，我们将修改Vapor示例中的`main.swift`。
- en: 'We will need to make our changes after the following definition:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在以下定义之后进行更改：
- en: '[PRE13]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Posting a new Todo item
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发布新的待办事项
- en: 'The first step will be to develop a post method to create a Todo item as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步将是开发一个POST方法来创建待办事项，如下所示：
- en: '[PRE14]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding example is going to create a Todo item. First, we check if the
    API user is provided with all the necessary HTTP headers with a guard expression
    and then we use our `addItem()` method in the `TodoStore` class to add that specific
    item. In the preceding code example, we needed to convert `completed` from `Bool`
    to `String`, so we extended the `String` function as follows and we called `toBool()`
    on `completed`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例将创建一个待办事项。首先，我们使用保护表达式检查API用户是否提供了所有必要的HTTP标题，然后我们使用`TodoStore`类中的`addItem()`方法来添加该特定项。在前面的代码示例中，我们需要将`completed`从`Bool`转换为`String`，所以我们扩展了`String`函数如下，并在`completed`上调用`toBool()`：
- en: '[PRE15]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We will need to build and run our backend app with the `vapor build` and `vapor
    run` directives in the terminal application. At this point, we should get the
    following prompt:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在终端应用程序中使用`vapor build`和`vapor run`指令来构建和运行我们的后端应用程序。此时，我们应该得到以下提示：
- en: '![Posting a new Todo item](img/image_11_001.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![发布新的待办事项](img/image_11_001.jpg)'
- en: 'If we point to localhost 8080 in a web browser, we should see Vapor up and
    running. Also, we can use the **curl** tool to test our post method in the terminal
    by copying and pasting the following code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在网页浏览器中指向localhost 8080，我们应该看到Vapor正在运行。此外，我们还可以使用**curl**工具在终端中通过复制和粘贴以下代码来测试我们的POST方法：
- en: '[PRE16]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The result will resemble the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将类似于以下内容：
- en: '![Posting a new Todo item](img/image_11_002.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![发布新的待办事项](img/image_11_002.jpg)'
- en: As we can see from the screenshot, we received a JSON response that includes
    our added Todo item.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如从截图所示，我们收到了一个包含我们添加的待办事项的JSON响应。
- en: Getting a list of Todo items
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取待办事项列表
- en: 'Our post call returns the list of items. Also, we can get items with this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的POST调用返回项目列表。此外，我们还可以这样获取项目：
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We will build and run our application with Vapor CLI again and we can test
    this get request like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用Vapor CLI构建和运行我们的应用程序，并且我们可以这样测试这个GET请求：
- en: '[PRE18]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Getting a specific Todo item
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取特定待办事项
- en: 'The preceding call retrieves all the items. If we want to get a specific item,
    we can do that too:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的调用检索所有项。如果我们想获取特定项，我们也可以这样做：
- en: '[PRE19]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, we check for the existence of headers and use the `listItems()` method
    in our `TodoStore` class to retrieve that specific item. We can test it in curl
    by executing the following commands in the terminal:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们检查是否存在标题，并使用我们的`TodoStore`类中的`listItems()`方法来检索特定项。我们可以在curl中通过在终端执行以下命令来测试它：
- en: '[PRE20]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Deleting an item and deleting all Todo items
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除单个事项和删除所有待办事项
- en: 'The next operation that we need to implement is deleting items from our `TodoStore`.
    Let''s implement the `delete` and `deleteAll` methods:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现的下一个操作是从我们的`TodoStore`中删除项。让我们实现`delete`和`deleteAll`方法：
- en: '[PRE21]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To test the delete functionality, we can execute the following commands in
    the terminal:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试删除功能，我们可以在终端中执行以下命令：
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To test the `deleteAll` functionality, we can execute the following commands
    in the terminal:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试`deleteAll`功能，我们可以在终端中执行以下命令：
- en: '[PRE23]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Updating a Todo item
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新待办事项
- en: 'Finally, we want to be able to update an item in our Todo list to complete
    it or take some notes:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们希望能够更新待办事项列表中的项以完成它或添加一些笔记：
- en: '[PRE24]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here, we check for the headers first and, if they are present, we use the update
    method in `TodoStore` to update a specific item in our store. We can test it like
    this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先检查标题是否存在，如果存在，我们就在`TodoStore`中使用更新方法来更新存储中的特定项。我们可以这样测试：
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: At this point, we should have a simple backend API to create, list, update,
    and delete todo items in memory. In the next section, we will develop an iOS application
    to leverage this API.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们应该有一个简单的后端API来在内存中创建、列出、更新和删除待办事项。在下一节中，我们将开发一个iOS应用程序来利用这个API。
- en: iOS application development
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: iOS应用程序开发
- en: So far, we looked into requirements, discussed a high-level design, and developed
    a simple backend API. Now, we are going to develop an iOS application that will
    leverage the latter.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们探讨了需求，讨论了高级设计，并开发了一个简单的后端 API。现在，我们将开发一个利用后端的应用程序。
- en: Configuration
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置
- en: 'We will start our application development using CocoaPods ([https://cocoapods.org/](https://cocoapods.org/)).
    We can install it by executing the following command in the terminal:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 CocoaPods ([https://cocoapods.org/](https://cocoapods.org/)) 开始我们的应用程序开发。我们可以在终端中执行以下命令来安装它：
- en: '[PRE26]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, we will create a folder using **Finder** or simply execute the following
    command in the terminal:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用 **Finder** 创建一个文件夹，或者在终端中简单地执行以下命令：
- en: '[PRE27]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, we will create a **Single View Application** project in Xcode:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在 Xcode 中创建一个 **单视图应用程序** 项目：
- en: '![Configuration](img/image_11_003.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![配置](img/image_11_003.jpg)'
- en: We are going to name it `TodoApp` and provide an organization name and identifier.
    The programming language is going to be **Swift**, and **Devices** will be **Universal**.
    Now, we can close the project and go back to the terminal.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将将其命名为 `TodoApp` 并提供组织名称和标识符。编程语言将是 **Swift**，**设备**将是 **通用**。现在，我们可以关闭项目并返回到终端。
- en: 'In the terminal, we will execute the following code:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，我们将执行以下代码：
- en: '[PRE28]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This will create a file named `Podfile`. This is where we define our dependencies.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为 `Podfile` 的文件。这是我们定义依赖项的地方。
- en: 'Uncomment the first and third line so it becomes like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 取消注释第一行和第三行，使其变为如下所示：
- en: '[PRE29]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we need to define dependencies for our target. We can go to [https://cocoapods.org/](https://cocoapods.org/)
    and search for any dependency, copy the definition, and paste it into our `Podfile`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要为我们的目标定义依赖项。我们可以访问 [https://cocoapods.org/](https://cocoapods.org/) 并搜索任何依赖项，复制定义，并将其粘贴到我们的
    `Podfile` 中：
- en: '[PRE30]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, we can save and close our `Podfile` and move on to the terminal application.
    In the terminal application, we will execute the following command:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以保存并关闭我们的 `Podfile`，然后转到终端应用程序。在终端应用程序中，我们将执行以下命令：
- en: '[PRE31]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This directive will create a workspace, download all dependencies, and link
    them as frameworks into our project. Now, we can open `TodoApp.xcworkspace` with
    Xcode.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 此指令将创建一个工作区，下载所有依赖项，并将它们作为框架链接到我们的项目中。现在，我们可以使用 Xcode 打开 `TodoApp.xcworkspace`。
- en: 'In the workspace, we will see two projects: `TodoApp` and `Pods`. Pods will
    contain all the dependencies.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在工作区中，我们将看到两个项目：`TodoApp` 和 `Pods`。Pods 将包含所有依赖项。
- en: 'Next, let''s create a folder hierarchy to organize our workspace. In the workspace,
    right-click on a folder and select **Show In Finder**. Here, we will create the
    following folders and files:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个文件夹层次结构来组织我们的工作区。在工作区中，右键单击一个文件夹并选择 **在 Finder 中显示**。在这里，我们将创建以下文件夹和文件：
- en: '`Actions`'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`动作`'
- en: '`Communication`'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`通信`'
- en: '`Controllers`'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`控制器`'
- en: '`Extensions`'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`扩展`'
- en: '`Managers`'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`管理人员`'
- en: '`Models`'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`模型`'
- en: '`Resources`'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`资源`'
- en: '`State`'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`状态`'
- en: '`Views`'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`视图`'
- en: 'Next, we will add these folders to our project by right-clicking on the `TodoApp`
    folder and selecting **Add Files to "TodoApp"**, as shown in the following screenshot:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过在 `TodoApp` 文件夹上右键单击并选择 **将文件添加到 "TodoApp"** 来将这些文件夹添加到我们的项目中，如下面的截图所示：
- en: '![Configuration](img/image_11_004.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![配置](img/image_11_004.jpg)'
- en: At this point, we can move `ViewController` to `Controllers` and any images
    to the `Resources` folder.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以将 `ViewController` 移动到 `Controllers` 文件夹，并将任何图像移动到 `Resources` 文件夹。
- en: 'When we are done with our application, the folder and file hierarchy will be
    as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成我们的应用程序后，文件夹和文件层次结构将如下所示：
- en: '![Configuration](img/image_11_005.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![配置](img/image_11_005.jpg)'
- en: Since our backend does not comply with security policies enforced by Apple,
    we will need to set the `NSAllowsArbitraryLoads` key to `YES` under the `NSAppTransportSecurity`
    dictionary in our `.plist` file.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的后端不符合苹果强制实行的安全策略，我们需要在 `.plist` 文件中的 `NSAppTransportSecurity` 字典下将 `NSAllowsArbitraryLoads`
    键设置为 `YES`。
- en: Models
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型
- en: 'Obviously, we can use the `Todo` model we have used in our backend example,
    but we want to make our frontend application as functional as possible. There
    is a great functional JSON parsing library named Argo that we can leverage. Let''s
    define our `Todo` model with Argo:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们可以使用我们在后端示例中使用的 `Todo` 模型，但我们希望使我们的前端应用程序尽可能功能强大。有一个名为 Argo 的优秀功能 JSON
    解析库，我们可以利用。让我们使用 Argo 定义我们的 `Todo` 模型：
- en: '[PRE32]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'First of all, we import two libraries: Argo and Curry. Curry provides convenient
    currying functionalities. Although currying is going to be removed from Swift
    and returning closures will be the norm, it will be safe to use the Curry library.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入两个库：Argo 和 Curry。Curry 提供方便的 currying 功能。尽管 currying 将从 Swift 中移除，返回闭包将成为规范，但使用
    Curry 库将是安全的。
- en: Our `Todo` model becomes a `struct`, and then we extend our `struct` by conforming
    to a `protocol` named `Decodable`. To conform to this protocol, we need to implement
    the `decode` function. This function takes a `JSON` payload and returns a decoded
    `Todo` object.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Todo` 模型变为一个 `struct`，然后我们通过遵守名为 `Decodable` 的 `protocol` 来扩展我们的 `struct`。为了遵守此协议，我们需要实现
    `decode` 函数。此函数接受一个 `JSON` 负载数据并返回解码后的 `Todo` 对象。
- en: 'In the body of the function, we will use the currying and custom operators.
    According to the Argo documentation, currying allows us to partially apply the
    `init` function over the course of the decoding process. This basically means
    that we can build up the `init` function call bit by bit, adding one parameter
    at a time, if (and only if) Argo can successfully decode them. If any of the parameters
    do not meet our expectations, Argo will skip the `init` call and return a special
    failure state. Let''s check the syntax of Curry:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体中，我们将使用 currying 和自定义操作符。根据 Argo 文档，currying 允许我们在解码过程中部分应用 `init` 函数。这基本上意味着我们可以逐步构建
    `init` 函数调用，每次添加一个参数，如果（并且仅当）Argo 成功解码它们。如果任何参数不符合我们的预期，Argo 将跳过 `init` 调用并返回一个特殊的失败状态。让我们检查
    Curry 的语法：
- en: '[PRE33]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `curry` function takes a function that has five parameters `A` to `E` and
    returns `F`, that is, `curry` returns *A -> B -> C -> D -> E -> F*.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`curry` 函数接受一个具有五个参数 `A` 到 `E` 的函数并返回 `F`，即 `curry` 返回 *A -> B -> C -> D ->
    E -> F*。'
- en: This enables us to partially apply our `init` method.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够部分应用我们的 `init` 方法。
- en: Operators
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作符
- en: 'We will discuss the different custom infix operators now:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将讨论不同的自定义中缀操作符：
- en: '`<^>` to map a function over a value conditionally'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<^>` 用于有条件地将函数映射到值'
- en: '`<*>` to apply a function with context to a value with context'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<*>` 用于将带有上下文的功能应用于带有上下文的值'
- en: '`<|` to decode a value at the specific key into the requested type'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<|` 用于将特定键的值解码为请求的类型'
- en: '`<|?` to decode an optional value at the specific key into the requested type'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<|?` 用于将特定键的可选值解码为请求的类型'
- en: '`<||` to decode an array of values at the specific key into the requested type'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<||` 用于将特定键的值数组解码为请求的类型'
- en: <^>
  id: totrans-237
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <^>
- en: 'Our first operator in the decoding process, `<^>`, is used to map our curried
    `init` method over a value. The definition is as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在解码过程中的第一个操作符 `<^>`，用于将我们的 curried `init` 方法映射到值。定义如下：
- en: '[PRE34]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: <*>
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <*>
- en: 'The `<*>` operator is used to conditionally apply the other parameters to our
    curried init method. The definition is as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`<*>` 操作符用于有条件地将其他参数应用于我们的 curried init 方法。定义如下：'
- en: '[PRE35]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: <|
  id: totrans-243
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <|
- en: 'The `<|` operator is used to decode a value at the specified key path into
    the requested type. This operator uses a function named `flatReduce` that reduces
    and flattens the sequence:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`<|` 操作符用于将指定键路径的值解码为请求的类型。此操作符使用名为 `flatReduce` 的函数来减少和扁平化序列：'
- en: '[PRE36]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: <|?
  id: totrans-246
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <|?
- en: 'The `<|?` operator is used to decode an optional value at the specified key
    path into the requested type:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`<|?` 操作符用于将指定键路径的可选值解码为请求的类型：'
- en: '[PRE37]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: <||
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <||
- en: 'The `<||` operator is used to decode an array of values at a specific key into
    the requested type:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`<||` 操作符用于将特定键的值数组解码为请求的类型：'
- en: '[PRE38]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Using Argo models
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Argo 模型
- en: 'Whenever we receive a JSON payload from the backend, we will be able to use
    the `decode` function to decode our `JSON` payload to our model:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们从后端接收到 JSON 负载数据时，我们将能够使用 `decode` 函数将我们的 `JSON` 负载数据解码到我们的模型：
- en: '[PRE39]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We can see that Argo is a great FP library that can be leveraged as an example
    to master lots of FP paradigms. Using Argo, Curry, and custom operators, we are
    able to parse and decode JSON payloads to our model objects declaratively. Also,
    our models become immutable value types that we can use in our applications without
    being concerned about mutability.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 Argo 是一个优秀的 FP 库，可以作为掌握许多 FP 范例的示例。使用 Argo、Curry 和自定义操作符，我们能够声明性地解析和解码
    JSON 负载数据到我们的模型对象。此外，我们的模型成为不可变值类型，我们可以在应用程序中使用它们而不用担心可变性。
- en: Also, we defined an `enum` called `TodoFilter`. We will use this `enum` to filter
    items.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还定义了一个名为 `TodoFilter` 的 `enum`。我们将使用此 `enum` 来过滤项目。
- en: ViewModel
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ViewModel
- en: We will have two `viewModel`, one for each `ViewController`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将有两个 `viewModel`，每个 `ViewController` 一个。
- en: '[PRE40]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We will use `TodosViewModel` to list `Todo` items in our table view.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`TodosViewModel`在我们的表格视图中列出`Todo`项。
- en: '[PRE41]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We will use `TodoViewModel` to present each `Todo` item's details.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`TodoViewModel`来展示每个`Todo`项的详细信息。
- en: Communication
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通信
- en: So far, we have a backend API that we can use to CRUD `Todo` items and we have
    models in our iOS application. Let's examine how we can communicate with our backend
    and populate our models with received payloads.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个后端API可以用来CRUD `Todo` 项，并且我们在iOS应用程序中有模型。让我们看看我们如何与后端通信并将接收到的有效载荷填充到我们的模型中。
- en: Request protocol
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 请求协议
- en: 'First, we need to define a protocol for our request models:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要为我们的请求模型定义一个协议：
- en: '[PRE42]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here, we defined `protocol` and we extended the protocol to be able to reflect
    the object and get properties and their values.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了`protocol`，并扩展了该协议以能够反映对象并获取属性及其值。
- en: Also, we added `subscript` to our protocol, which any `struct` that wants to
    conform to this protocol should implement.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还向我们的协议中添加了`subscript`，任何想要遵守此协议的`struct`都应该实现它。
- en: Conforming to a request protocol
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遵守请求协议
- en: 'Now, let''s create a request model named `TodoRequest`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个名为`TodoRequest`的请求模型：
- en: '[PRE43]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As shown in the preceding code, this `struct` conforms to `RequestProtocol`.
    You might wonder why we have done this. First of all, this is an example of POP and
    second we will use this request model in our post web service call.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的代码所示，此`struct`遵守`RequestProtocol`。你可能会想知道我们为什么这样做。首先，这是一个POP的例子，其次我们将在我们的后端服务调用中使用这个请求模型。
- en: WebServiceManager
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: WebServiceManager
- en: 'We will create a file named `WebServiceManager` and add a function in it:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为`WebServiceManager`的文件并在其中添加一个函数：
- en: '[PRE44]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Our `sendRequest` function takes two parameters. The first one is the HTTP request
    method and the second one is the type of `RequestProtocol`. Here, using the implemented
    protocol function called `getPropertyNames`, we prepare the header and send a
    request to our backend using `Alamofire`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`sendRequest`函数接受两个参数。第一个是HTTP请求方法，第二个是`RequestProtocol`的类型。在这里，我们使用实现的协议函数`getPropertyNames`来准备头信息，并使用`Alamofire`向我们的后端发送请求。
- en: So far, we have a working communication layer. At this point, we need to develop
    managers and `viewController` to handle the logic and show the results to the
    user.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经有一个工作的通信层。在这个时候，我们需要开发管理器和`viewController`来处理逻辑并向用户展示结果。
- en: We will start by testing our communication layer in our `MasterViewController`
    and will move the respective code to our `managers`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先在我们的`MasterViewController`中测试我们的通信层，并将相应的代码移动到我们的`managers`中。
- en: Creating a Todo item
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建待办事项
- en: 'To create a Todo item, we can call the `sendRequest` function in our `MasterViewController
    viewDidLoad()` method to be sure that it is working:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建待办事项，我们可以在`MasterViewController viewDidLoad()`方法中调用`sendRequest`函数以确保其工作：
- en: '[PRE45]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This should add a new `Todo` item to our backend.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在我们的后端添加一个新的`Todo`项。
- en: 'Our `sendRequest` method is incomplete and it does not provide a call back
    to receive the data. Let''s improve it:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`sendRequest`方法是不完整的，它不提供回调来接收数据。让我们改进它：
- en: '[PRE46]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We added a closure as the function argument and called the closure in the body
    of the function. To test it, we will update our call in `MasterViewController`:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将闭包作为函数参数添加，并在函数体中调用该闭包。为了测试它，我们将更新我们的`MasterViewController`中的调用：
- en: '[PRE47]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Here, we pass a trailing closure in our call; once it is called, we receive
    the response or error. Importing and using Argo, we can map the payload to our
    model. We called this function only for testing and we need to move this call
    to the proper place. After all, none of our `MasterViewController` classes will
    be able to call this function directly and they have to go through other objects.
    Also, we will need to improve our `sendRequest` function to take the proper `url`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在调用中传递一个尾随闭包；一旦它被调用，我们就收到响应或错误。通过导入和使用Argo，我们可以将有效载荷映射到我们的模型。我们只调用此函数进行测试，我们需要将其移动到适当的位置。毕竟，我们的`MasterViewController`类中的任何类都无法直接调用此函数，它们必须通过其他对象。此外，我们还需要改进我们的`sendRequest`函数以接受正确的`url`：
- en: '[PRE48]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here, we define an `enum` and extend it. In our `httpMethodUrl` function, we
    perform pattern matching to return a tuple consisting of an HTTP request method
    and the full `url`. We need to change our `sendRequest` function as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个`enum`并扩展了它。在我们的`httpMethodUrl`函数中，我们执行模式匹配以返回一个由HTTP请求方法和完整的`url`组成的元组。我们需要将我们的`sendRequest`函数更改如下：
- en: '[PRE49]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Our function call should be changed as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的功能调用应该如下更改：
- en: '[PRE50]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Listing Todo items
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列出待办事项
- en: 'To retrieve all Todo items, unlike our post call, we do not need to pass any
    header parameters, just cookie information. So, we add the following `struct`
    to handle this scenario:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索所有`Todo`项，与我们的post调用不同，我们不需要传递任何头参数，只需cookie信息。因此，我们添加以下`struct`来处理这种情况：
- en: '[PRE51]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Then, we can retrieve the list of `Todo` items using the following code:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下代码检索`Todo`项的列表：
- en: '[PRE52]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Although we added better error printing, we need to improve it further.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们添加了更好的错误打印，但我们还需要进一步改进它。
- en: 'Let''s extract the preceding function calls, create a Swift file named `TodoManager`,
    and put these functions in it:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们提取前面的函数调用，创建一个名为`TodoManager`的Swift文件，并将这些函数放入其中：
- en: '[PRE53]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Finally, we will develop two other functions: one adds or updates a `Todo`
    item and the other only updates a specific `Todo` item. Deleting items will be
    easy to implement as well. The code is as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将开发两个其他函数：一个用于添加或更新一个`Todo`项，另一个仅更新特定的`Todo`项。删除项也将很容易实现。代码如下：
- en: '[PRE54]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In these functions, there are concepts that we have not yet covered in detail:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些函数中，有一些我们尚未详细讨论的概念：
- en: '`dispatch`: This function dispatches an action (here, `UpdateTodoAction`) by
    settings the state''s value to the result of calling its `reduce` method.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dispatch`：这个函数通过设置状态的值为其`reduce`方法的调用结果来分发一个动作（在这里，是`UpdateTodoAction`）。'
- en: '`todoSyncedLens`: This is a `Lens` to modify the synced property of the `todo`
    item. We will define these lenses in an upcoming section.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`todoSyncedLens`：这是一个用于修改`todo`项同步属性的`Lens`。我们将在下一节中定义这些镜头。'
- en: '`UpdateTodoAction`: This is a `struct` that conforms to `ActionType`, which
    is used when we want to make modifications to the `State` of the `Store`. All
    changes to the `Store` go through this type. We will define our actions in an
    upcoming section.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UpdateTodoAction`：这是一个符合`ActionType`的`struct`，当我们想要修改`Store`的`State`时使用。所有对`Store`的更改都通过此类型进行。我们将在下一节中定义我们的动作。'
- en: '`State`: This is a `struct` that will be used to manage the `State`. We will
    define it later.'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`State`：这是一个将用于管理`State`的`struct`。我们将在稍后定义它。'
- en: '`Store`: As the name suggests, this is where we store the `State`. We will
    define it later.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Store`：正如其名所示，这是我们存储`State`的地方。我们将在稍后定义它。'
- en: Lens
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 镜头
- en: 'We will use lenses to modify our `Todo` item. Each of the following lenses
    will be used to modify a part of the `Todo` item:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用镜头来修改我们的`Todo`项。以下每个镜头都将用于修改`Todo`项的一部分：
- en: '[PRE55]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: State
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态
- en: In our application, we need to manage states to keep the state management code
    as declarative as possible. We will use a library named `Delta`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们需要管理状态以使状态管理代码尽可能声明式。我们将使用一个名为`Delta`的库。
- en: 'Delta will be used along with ReactiveCocoa to manage states and state changes
    reactively. The code is as follows:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: Delta将与ReactiveCocoa一起用于管理状态和状态变化。代码如下：
- en: '[PRE56]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In the preceding code, we extend the ReactiveCocoa library's `MutableProperty`
    by conforming to `Delta.ObservablePropertyType`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们通过遵循`Delta.ObservablePropertyType`扩展了ReactiveCocoa库的`MutableProperty`。
- en: The `ObservablePropertyType` protocol must be implemented by the `State` that
    is held by `Store`. To use a custom `State` type, this protocol must be implemented
    on that object.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`ObservablePropertyType`协议必须由`Store`持有的`State`实现。要使用自定义的`State`类型，必须在该对象上实现此协议。'
- en: '`MutableProperty` creates a mutable property of type value and allows observation
    of its changes in a thread-safe way.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`MutableProperty`创建一个可变属性，其类型为值，并允许以线程安全的方式观察其变化。'
- en: 'Using extended `MutableProperty`, our `State` objects become the following:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 使用扩展的`MutableProperty`，我们的`State`对象变为以下：
- en: '[PRE57]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Store
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储
- en: 'We will store the state in our `Store` object:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的`Store`对象中存储状态：
- en: '[PRE58]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '`Store` conforms to the `StoreType` protocol declared in the `Delta` library.
    The `StoreType` protocol defines the storage of an observable state and dispatch
    methods to modify it.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`Store`遵循在`Delta`库中声明的`StoreType`协议。`StoreType`协议定义了可观察状态的存储和修改它的分发方法。'
- en: Here, we create a `MutableProperty` as `state` and store it in `Store`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们创建一个`MutableProperty`作为`state`并将其存储在`Store`中。
- en: 'We need to define properties to access and modify our state properly, so we
    extend our `Store` as follows:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要定义属性来正确地访问和修改我们的状态，因此我们按如下方式扩展我们的`Store`：
- en: '[PRE59]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In our store, we use ReactiveCocoa's `SignalProducer` to create observable signals.
    We will observe these signals in other objects and react to signal changes.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的存储中，我们使用ReactiveCocoa的`SignalProducer`来创建可观察的信号。我们将在其他对象中观察这些信号并对信号变化做出反应。
- en: Action
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动作
- en: 'Actions are structs that conform to the `ActionType` protocol from the `Delta`
    library. `ActionType` is used when we want to make modifications to the store''s
    state. All changes to the `Store` go through this type. Let''s examine one example:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 动作是符合 `Delta` 库中的 `ActionType` 协议的结构体。当我们要对存储的状态进行修改时使用 `ActionType`。所有对 `Store`
    的更改都通过此类型进行。让我们看看一个例子：
- en: '[PRE60]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In our manager, we had a call like this:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的管理器中，我们有一个这样的调用：
- en: '[PRE61]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `dispatch` method call on `store` with the `UpdateTodoAction` will call
    the `reduce` method of `UpdateTodoAction`. It will also make modifications on
    the state and return a new version of it. This is the only place where changes
    to `State` are permitted; therefore, any changes to state should go through an
    action.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `store` 上调用 `dispatch` 方法并传入 `UpdateTodoAction` 将会调用 `UpdateTodoAction` 的
    `reduce` 方法。它还会对状态进行修改并返回一个新的状态版本。这是唯一允许修改 `State` 的地方；因此，任何对状态的修改都应该通过一个动作进行。
- en: 'Let''s define other actions as well:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义其他动作：
- en: '[PRE62]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Views
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图
- en: The user will be able to list `Todo` items from the backend, toggle to mark
    an item as complete, or swipe left to access functionalities such as **Details**
    and **Delete**.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 用户将能够从后端列出 `Todo` 项目，切换以标记项目为完成，或向左滑动以访问如 **详情** 和 **删除** 等功能。
- en: 'Our application will look like this:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序将看起来像这样：
- en: '![Views](img/image_11_006.jpg)![Views](img/image_11_007.jpg)![Views](img/image_11_008.jpg)![Views](img/image_11_009.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![视图](img/image_11_006.jpg)![视图](img/image_11_007.jpg)![视图](img/image_11_008.jpg)![视图](img/image_11_009.jpg)'
- en: 'We can design these screens in the storyboard. We will need to implement a
    custom `UITableViewCell` as shown here to be able to show the proper data on TableView:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在故事板中设计这些屏幕。为了能够在表格视图中显示适当的数据，我们需要实现一个自定义的 `UITableViewCell`，如下所示：
- en: '[PRE63]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The only interesting piece in this class is the `configure` method. It will
    be called in our `cellForRowAtIndexPath` method of `TableViewController` to create
    a `Signal` from the producer, then to add exactly one observer to the `Signal`,
    which will invoke the given callback when next events are received.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类中唯一有趣的部分是 `configure` 方法。它将在我们的 `TableViewController` 的 `cellForRowAtIndexPath`
    方法中被调用，以从生产者创建一个 `Signal`，然后添加一个精确的观察者到 `Signal` 中，当收到下一个事件时将调用给定的回调。
- en: ViewController
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ViewController
- en: 'We will have two ViewController subclasses:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将有两个 ViewController 子类：
- en: '`MasterViewController`: This will list the `Todo` items'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MasterViewController`：这将列出 `Todo` 项目'
- en: '`DetailViewController`: This will present and modify the details of each item'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DetailViewController`：这将展示和修改每个项目的详情'
- en: MasterViewController
  id: totrans-349
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MasterViewController
- en: 'We will present a list of items to the user in `MasterViewController`:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `MasterViewController` 中向用户展示项目列表：
- en: '[PRE64]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We have `viewModel`, which is a computed property. In `viewDidLoad`, we list
    the `Todo` items from our backend and we store them in `State` using `LoadTodosAction`.
    Then, we define observations to change our `viewModel` and to sync changed items
    with the backend.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有 `viewModel`，这是一个计算属性。在 `viewDidLoad` 中，我们从后端列出 `Todo` 项目并将它们存储在 `State`
    中，使用 `LoadTodosAction`。然后，我们定义观察来更改我们的 `viewModel` 并与后端同步更改的项目。
- en: IBActions
  id: totrans-353
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: IBActions
- en: 'We will need to define two `IBAction`, one to add a new item to the list and
    the other to filter the items:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要定义两个 `IBAction`，一个用于向列表添加新项目，另一个用于过滤项目：
- en: '[PRE65]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In the `addTapped` method, we use `createTodoAction` to add an item to the list
    with the `completed` and `synced` values as `false`. Therefore, `store.notSyncedWithBackend.startWithNext`
    in `viewDidLoad` will observe this item as not synced and will sync it with the
    backend.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `addTapped` 方法中，我们使用 `createTodoAction` 将项目添加到列表中，并将 `completed` 和 `synced`
    的值设置为 `false`。因此，`store.notSyncedWithBackend.startWithNext` 在 `viewDidLoad` 中会观察这个项目为未同步，并将其与后端同步。
- en: TableView Delegates and DataSource
  id: totrans-357
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: TableView Delegates 和 DataSource
- en: 'Finally, we need to implement the `delegates` and `datasource` methods for
    `UITableViewController`. The code is as follows:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要为 `UITableViewController` 实现相应的 `delegates` 和 `datasource` 方法。代码如下：
- en: '[PRE66]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: In the preceding code, we use `DeleteTodoAction` to delete an item by swiping
    to the left and selecting **Delete**. We use `ToggleCompletedAction` to mark an
    item as completed when we tap on any item on the list, and we use `DetailsTodoAction`
    to navigate to the details page when we swipe to the left and select **Details**.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用 `DeleteTodoAction` 通过向左滑动并选择 **删除** 来删除一个项目。我们使用 `ToggleCompletedAction`
    在我们点击列表中的任何项目时将其标记为完成，并使用 `DetailsTodoAction` 在我们向左滑动并选择 **详情** 时导航到详情页面。
- en: DetailsViewController
  id: totrans-361
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DetailsViewController
- en: 'We will use `viewController` to present the details of a `Todo` item and modify
    it. We will have three `textField` and a switch. We will observe the changes in
    the UI and modify the `State` and backend. The code is as follows:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `viewController` 来展示和修改 `Todo` 项的详细信息。我们将有三个 `textField` 和一个开关。我们将观察 UI
    的变化，并通过 `UpdateTodoAction` 修改 `State` 和后端。以下是代码：
- en: '[PRE67]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: In our `viewDidLoad` method, we look for the selected item in `MasterViewController`
    before navigating to `DetailsViewController`. We will also set the `UITextField`
    and `UISwitch` initial values. We will subscribe to changes in the UI, use lenses
    to update the `Todo` item, and change the state via `UpdateTodoAction`. Any item
    change will set synced as false. Since this property is observed in `MasterViewController`,
    any changes to the UI in `DetailsViewController` will be synced with the backend
    without any extra effort.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `viewDidLoad` 方法中，在导航到 `DetailsViewController` 之前，我们会在 `MasterViewController`
    中查找选定的项。我们还将设置 `UITextField` 和 `UISwitch` 的初始值。我们将订阅 UI 的变化，使用 lenses 更新 `Todo`
    项，并通过 `UpdateTodoAction` 改变状态。任何项目更改都会将同步设置为 false。由于这个属性在 `MasterViewController`
    中被观察，`DetailsViewController` 中 UI 的任何更改都将与后端同步，无需额外努力。
- en: Summary
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we developed a backend with Swift Vapor library that handles
    the `Todo` items `POST`, `GET`, and `DELETE`. Then, we developed a frontend iOS
    application that leverages functional programming, reactive programming, and state
    management techniques declaratively. We started by developing our `Todo` model
    in a functional style, and then we developed `Store` and its extensions to handle
    `State` storage and `Action` to handle `State` changes. We defined and used `Lens`
    to modify our properties and a `WebServiceManager` with reflection techniques
    to request for backend resources.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用 Swift Vapor 库开发了一个后端，该后端处理 `Todo` 项目的 `POST`、`GET` 和 `DELETE` 操作。然后，我们开发了一个前端
    iOS 应用程序，该应用程序利用函数式编程、响应式编程和状态管理技术进行声明式开发。我们首先以函数式风格开发我们的 `Todo` 模型，然后开发了 `Store`
    及其扩展来处理 `State` 存储和 `Action` 以处理 `State` 变化。我们定义并使用了 `Lens` 来修改我们的属性，并使用反射技术创建了一个
    `WebServiceManager` 来请求后端资源。
- en: In this case study, we were able to use value types such as `struct` and `enum`
    and avoid classes. In fact, the only four classes in this case study are related
    to the iOS SDK (`UIViewController`, `UITableViewController`, `UITableViewCell`,
    and `UIView` subclasses). We were able to centralize all state mutations into
    `Store` only using `Action` to change the `State` in the `Store`. Although we
    did not develop any unit test cases, it is recommended that you explore functional
    programming unit testing libraries such as **Quick** to ensure the quality of
    code.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个案例研究中，我们能够使用 `struct` 和 `enum` 等值类型，并避免使用类。实际上，本案例研究中的四个类都与 iOS SDK 相关（`UIViewController`、`UITableViewController`、`UITableViewCell`
    和 `UIView` 子类）。我们能够仅使用 `Action` 来更改 `Store` 中的 `State`，将所有状态突变集中到 `Store` 中。尽管我们没有开发任何单元测试用例，但建议您探索函数式编程单元测试库，如
    **Quick**，以确保代码质量。
