- en: Miscellaneous
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 杂项
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Kotlin and Java interoperability issues
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin 和 Java 互操作性问题和解决方案
- en: Kotlin and JavaScript interoperability issues
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin 和 JavaScript 互操作性问题和解决方案
- en: Renaming of generated classes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成类的重命名
- en: Decompiling Kotlin code to JVM bytecode
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Kotlin 代码反编译为 JVM 字节码
- en: Adding custom names for imports
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为导入添加自定义名称
- en: Wrapping complex type declarations with type aliases
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类型别名包装复杂类型声明
- en: Expressive `try…catch` declarations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式的`try…catch`声明
- en: Safe type-casting
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全的类型转换
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter is going to focus on presenting handy solutions to various problems
    and issues that Kotlin developers deal with on a daily basis. Here, you will find
    useful tips and solutions for issues related to interoperability with Java and
    JavaScript and neat tricks that will help you write code more effectively.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将专注于展示各种问题的实用解决方案，这些问题是 Kotlin 开发者在日常工作中遇到的。在这里，你可以找到有关与 Java 和 JavaScript
    互操作性的问题和解决方案的有用提示，以及一些帮助你更有效地编写代码的巧妙技巧。
- en: Kotlin and Java interoperability
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin 和 Java 互操作性
- en: This recipe is going to show how to combine both Java and Kotlin classes together
    and use them in the same application component. We will declare a Kotlin data
    class, called `ColoredText`, that holds two properties of the `String` and `Color`
    types. Apart from the properties, it is also going to expose a utility function
    inside a companion object responsible for text-processing. We are going to learn
    how to make use of those properties and how to declare the function from the `ColoredText`
    class to be visible as a JVM static method inside the Java class.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱将展示如何将 Java 和 Kotlin 类结合起来，并在同一应用程序组件中使用它们。我们将声明一个名为`ColoredText`的 Kotlin
    数据类，它包含两种类型的`String`和`Color`属性。除了属性之外，它还将在伴随对象中暴露一个用于文本处理的实用函数。我们将学习如何使用这些属性，以及如何声明`ColoredText`类中的函数，使其在
    Java 类中作为 JVM 静态方法可见。
- en: How to do it...
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Declare the `ColoredText` class:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`ColoredText`类：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Implement a static JVM method inside the `companion` object:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`companion`对象中实现一个静态 JVM 方法：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add a member function that enables you to print the `text` property to the
    console:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个成员函数，允许你将`text`属性打印到控制台：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Implement a Java class that makes use of Kotlin class functions and properties:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个使用 Kotlin 类函数和属性的 Java 类：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As the result, the main function from the `JavaApp` Java class is going to
    print the following wisdom to the console:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，`JavaApp` Java 类中的主函数将打印以下智慧到控制台：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Kotlin and Java interoperability is absolutely painless, thanks to the fact
    that both Kotlin and Java classes are compiled to the same JVM bytecode included
    in a common codebase. However, there are a few special cases that require additional
    attention when we want to make Kotlin declarations available on the Java side
    in a specific way.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Kotlin 和 Java 类都编译为包含在公共代码库中的相同 JVM 字节码，因此 Kotlin 和 Java 互操作性绝对无缝。然而，有一些特殊情况需要我们在将
    Kotlin 声明以特定方式在 Java 侧可用时给予额外关注。
- en: First of all, in the `ColoredText` class, we are marking the constructor with
    the `@JvmOverloads` annotation, which tells the compiler to generate multiple
    instances of the constructor in case there are any default property values declared.
    Thanks to this, we could instantiate the `ColoredText` class in some Java classes
    without passing the `text` and/or `color` property values.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`ColoredText`类中，我们使用`@JvmOverloads`注解标记构造函数，这告诉编译器在声明任何默认属性值的情况下生成多个构造函数实例。多亏了这一点，我们可以在某些
    Java 类中实例化`ColoredText`类，而无需传递`text`和/或`color`属性值。
- en: Next annotation we are using is `@JvmField`, which tells the Kotlin compiler
    not to generate getter and setter functions for this property and expose it as
    a field. It provides a cleaner syntax for accessing the values on the Java side
    when we expose a constant value through Kotlin objects.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们使用的注解是`@JvmField`，它告诉 Kotlin 编译器不要为这个属性生成 getter 和 setter 函数，并将其作为字段暴露。当通过
    Kotlin 对象暴露一个常量值时，它提供了一个更简洁的语法来访问 Java 侧的值。
- en: 'Another commonly used annotation is `@JvmStatic`. Its aim is to tell the compiler
    that an additional static method needs to be generated for this function in order
    to make it available in Java as a direct static function of the outer class. For
    example, in our case, we are able to access the `processText()` function in Java
    in the following manner, by omitting the `Companion` element:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常用的注解是 `@JvmStatic`。它的目的是告诉编译器需要为这个函数生成一个额外的静态方法，以便在 Java 中作为外部类的直接静态方法使用。例如，在我们的案例中，我们可以通过以下方式在
    Java 中访问 `processText()` 函数，省略 `Companion` 元素：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Kotlin and JavaScript interoperability
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin 和 JavaScript 互操作性
- en: In the following recipe, we are going to configure and implement a sample web
    app project in order to explore how Kotlin can be compiled to JavaScript. We are
    going to implement a simple web app that will open an alert dialog when the app
    starts. The following example is going to present a way of combining Kotlin and
    JavaScript code together and configuring a JavaScript compilation with the Gradle
    build script.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的菜谱中，我们将配置并实现一个示例 Web 应用程序项目，以探索 Kotlin 如何编译成 JavaScript。我们将实现一个简单的 Web 应用程序，当应用程序启动时将打开一个警告对话框。以下示例将展示如何将
    Kotlin 和 JavaScript 代码结合在一起，并使用 Gradle 构建脚本配置 JavaScript 编译。
- en: Getting ready
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In order to set up the project to compile Kotlin files into JavaScript, we
    need to add the following properties to the module-level Gradle build script.
    First, we need to apply the Kotlin2Js plugin. We can do it with the following
    declaration:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置项目以将 Kotlin 文件编译成 JavaScript，我们需要在模块级别的 Gradle 构建脚本中添加以下属性。首先，我们需要应用 Kotlin2Js
    插件。我们可以通过以下声明来完成：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'At this point, whenever we execute the Gradle `build` task, the Kotlin2JS compiler
    is going to generate JavaScript code with the corresponding functions and classes
    from the Kotlin files and write them under the `build/classes/kotlin/` directory
    to the JS file named after the project name. However, we can modify this default
    behavior by specifying the output file parameter:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，每次我们执行 Gradle 的 `build` 任务时，Kotlin2JS 编译器都会生成来自 Kotlin 文件的相应函数和类，并将它们写入
    `build/classes/kotlin/` 目录下的 JS 文件，该文件以项目名称命名。然而，我们可以通过指定输出文件参数来修改此默认行为：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As the result, the output of the Kotlin files' compilation will be available
    under `web/js directory`, in the `app.js` file.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Kotlin 文件编译的输出将位于 `web/js 目录` 下的 `app.js` 文件中。
- en: 'However, in order to execute the translated Kotlin code, we need to link the
    Kotlin JS standard library to it as well. We can modify the Gradle build script
    to include the required libraries in the `web/js` output directory:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了执行转换后的 Kotlin 代码，我们还需要将其与 Kotlin JS 标准库链接起来。我们可以修改 Gradle 构建脚本，将所需的库包含在
    `web/js` 输出目录中：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can examine the configuration of the Kotlin2JS plugin in the sample project: [https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/tree/master/Kotlin-Samples-JS](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/tree/master/Kotlin-Samples-JS).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在示例项目中检查 Kotlin2JS 插件的配置：[https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/tree/master/Kotlin-Samples-JS](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/tree/master/Kotlin-Samples-JS).
- en: How to do it...
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a new kotlin file, `AlertDialogApp.kt`, that contains the `main()` function:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Kotlin 文件，`AlertDialogApp.kt`，其中包含 `main()` 函数：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Declare a reference to the JS `alert()` function:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明对 JS `alert()` 函数的引用：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Implement the `showAlert()` function and invoke it in the `main()` function:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个 `showAlert()` 函数并在 `main()` 函数中调用它：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As you can see, after running the Gradle build task, the `AlertDialogApp.kt` file
    is going to be translated into the `app.js` JavaScript code, available under the
    `web/js` directory, along with the `kotlin.js` file linked under the `web/js/lib`
    directory.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在运行 Gradle 构建任务后，`AlertDialogApp.kt` 文件将被转换为 `app.js` JavaScript 代码，位于
    `web/js` 目录下，以及链接在 `web/js/lib` 目录下的 `kotlin.js` 文件。
- en: 'We can test the JS-generated code by running it in the web browser. In order
    to do so, we will create a sample HTML file under the project''s main directory,
    named `test_app.html`, which is going to link the `kotlin.js` standard library
    file and run the `app.js` file that contains the `main()` function implementation
    generated from the `AlertDialogApp.kt` file:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在网页浏览器中运行它来测试生成的 JS 代码。为了做到这一点，我们将在项目的主目录下创建一个名为 `test_app.html` 的示例 HTML
    文件，该文件将链接 `kotlin.js` 标准库文件并运行包含从 `AlertDialogApp.kt` 文件生成的 `main()` 函数实现的 `app.js`
    文件：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As the result, when we open the `test_app.html` file in a web browser, we are
    going to encounter the following pop-up dialog:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，当我们在一个网络浏览器中打开 `test_app.html` 文件时，我们将遇到以下弹出对话框：
- en: '![](img/5840543c-882b-48dd-ab51-02c17c8ac10d.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5840543c-882b-48dd-ab51-02c17c8ac10d.png)'
- en: Inside the `showAlert()` function in the `AlertDialogApp.kt` file, we are using
    the JavaScript `Math.floor()` and `Math.random()` functions to generate a random
    integer value from 0-1,000\. We are using the `js()` function available in the
    Kotlin standard library to inline JS code in the Kotlin code. As you can see,
    the result returned by `js()` is declared as a `dynamic` type.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `AlertDialogApp.kt` 文件中的 `showAlert()` 函数内部，我们使用 JavaScript 的 `Math.floor()`
    和 `Math.random()` 函数生成一个 0-1,000 之间的随机整数。我们使用 Kotlin 标准库中可用的 `js()` 函数在 Kotlin
    代码中内联 JS 代码。正如你所看到的，`js()` 返回的结果被声明为 `dynamic` 类型。
- en: The `dynamic` modifier is used to declare the dynamic type, which is characteristic
    for every JavaScript object. In Kotlin code, it can be used as an alternative
    to strongly-typed declarations. It makes sense to use it whenever we are dealing
    with third-party JS libraries that can return the results of not-specified types.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`dynamic` 修饰符用于声明动态类型，这是每个 JavaScript 对象的特征。在 Kotlin 代码中，它可以作为强类型声明的替代品使用。当我们处理可能返回未指定类型结果的第三方
    JS 库时，使用它是有意义的。'
- en: Next, we are using the random integer value generated using the JS-inlined code
    to compose the message that is going to be displayed. Finally, we are calling
    the JS `alert()` function and passing it the composed message. This time, we are
    using the `external` modifier, which tells the Kotlin compiler that the corresponding
    declaration is written in pure JavaScript and it should not generate the implementation
    for it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用通过内联的 JS 代码生成的随机整数来组合将要显示的消息。最后，我们调用 JS 的 `alert()` 函数，并将组合的消息传递给它。这次，我们使用了
    `external` 修饰符，它告诉 Kotlin 编译器相应的声明是用纯 JavaScript 编写的，它不应该为它生成实现。
- en: There's more...
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You may wonder whether there is a practical solution to working with `npm` JS
    dependencies within a Gradle-based project. There is a solution that allows you
    to integrate your Kotlin project with `npm` dependencies easily, called the Kotlin
    Frontend Gradle plugin. You can learn more about it in the official project guide: [https://github.com/Kotlin/kotlin-frontend-plugin](https://github.com/Kotlin/kotlin-frontend-plugin).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道是否有实际的方法可以在基于 Gradle 的项目中处理 `npm` JS 依赖项。有一个解决方案允许你轻松地将你的 Kotlin 项目与
    `npm` 依赖项集成，称为 Kotlin Frontend Gradle 插件。你可以在官方项目指南中了解更多信息：[https://github.com/Kotlin/kotlin-frontend-plugin](https://github.com/Kotlin/kotlin-frontend-plugin)。
- en: Renaming generated functions
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重命名生成的函数
- en: In this recipe, we are going to learn how to modify a Kotlin function's name
    when it is being compiled to the generated JVM bytecode. We need this feature
    because of the type-erasure that happens when generating the JVM bytecode. However,
    thanks to the `@JvmName` annotation, we can declare a number of different functions,
    but that has the same name and use their original name in the Kotlin code while
    keeping their JVM bytecode names distinct to satisfy the compiler.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何在 Kotlin 函数被编译成生成的 JVM 字节码时修改其名称。我们需要这个功能是因为在生成 JVM 字节码时会发生类型擦除。然而，多亏了
    `@JvmName` 注解，我们可以声明多个不同的函数，但它们具有相同的名称，并在 Kotlin 代码中使用它们的原始名称，同时保持它们的 JVM 字节码名称不同，以满足编译器的要求。
- en: How to do it...
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Declare two functions that have the same names:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明两个具有相同名称的函数：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Mark the functions with the proper annotations:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用适当的注解标记函数：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Thanks to providing the alternative function names, we were able to compile
    them to JVM bytecode. However, you can easily test that we can use their original
    names inside the Kotlin code. That's because the Kotlin compiler is able to recognize
    them correctly based on their return type and generic type argument value.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于提供了替代函数名，我们能够将它们编译成 JVM 字节码。然而，你可以轻松地测试我们可以在 Kotlin 代码中使用它们的原始名称。这是因为 Kotlin
    编译器能够根据它们的返回类型和泛型类型参数值正确地识别它们。
- en: 'You can test this by running the `join()` function both on the list of integers
    and on the list of strings:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在整数列表和字符串列表上运行 `join()` 函数来测试这一点：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As the result, the preceding code will print the following text to the console:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，前面的代码将打印以下文本到控制台：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Keep in mind that, when you want to invoke those functions from Java, you will
    need to use their alternative names: `joinStringList()` and `joinIntList()`.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当你想要从 Java 调用这些函数时，你需要使用它们的替代名称：`joinStringList()` 和 `joinIntList()`。
- en: There's more...
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There is also a corresponding `@JsName` annotation, which allows you to change
    the name of JavaScript functions and classes. You can use it if you are compiling
    your Kotlin files to JavaScript using the Kotlin2JS plugin. If you'd like to get
    familiar with the basics of the Kotlin2JS plugin, you can examine the *Kotlin
    and JavaScript interoperability* recipe.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个相应的 `@JsName` 注解，它允许你更改 JavaScript 函数和类的名称。如果你使用 Kotlin2JS 插件将 Kotlin
    文件编译到 JavaScript，你可以使用它。如果你想熟悉 Kotlin2JS 插件的基础知识，你可以检查 *Kotlin 和 JavaScript 互操作性*
    食谱。
- en: See also
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: If you'd like to learn how to explore the final JVM bytecode generated from
    Kotlin files, read the *Decompiling Kotlin code to Java and JVM bytecode* recipe
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要了解如何探索从 Kotlin 文件生成的最终 JVM 字节码，请阅读 *反编译 Kotlin 代码到 Java 和 JVM 字节码* 食谱
- en: Decompiling Kotlin code to Java and JVM bytecode
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反编译 Kotlin 代码到 Java 和 JVM 字节码
- en: In this recipe, we are going to learn how to easily decompile our Kotlin files
    to see how their corresponding JVM bytecode is implemented and what the bytecode's
    corresponding Java implementation would look like. This can help you to discover
    how various Kotlin concepts were implemented under the hood. It can also be helpful
    for code-debugging and optimization.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何轻松地将 Kotlin 文件反编译，以查看其对应的 JVM 字节码是如何实现的，以及字节码对应的 Java 实现看起来会是什么样子。这可以帮助你发现
    Kotlin 各种概念在底层是如何实现的。这也有助于代码调试和优化。
- en: Getting ready
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s create a new Kotlin file, named `Recipe4.kt`, that contains the following
    sample implementation in order to see its bytecode translation:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的 Kotlin 文件，命名为 `Recipe4.kt`，其中包含以下示例实现，以便查看其字节码转换：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How to do it...
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open the `Recipe4.kt` file in IntelliJ.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 IntelliJ 中打开 `Recipe4.kt` 文件。
- en: Choose the Show Kotlin Bytecode option from the Tools/Kotlin menu. The box will
    present the JVM bytecode implementation.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从工具/ Kotlin 菜单中选择“显示 Kotlin 字节码”选项。框将显示 JVM 字节码实现。
- en: Click the Decompile button in the Kotlin Bytecode view. The corresponding Java
    implementation will be decompiled from the bytecode and will appear in the new
    window.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 Kotlin 字节码视图中的“反编译”按钮。相应的 Java 实现将从字节码中反编译出来，并出现在新窗口中。
- en: How it works...
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The task of analyzing the Java implementation generated for `data class A` is
    left as an exercise for the reader. You can experiment by removing the `data`
    modifier from the Kotlin class definition and observing the changes in the bytecode
    and the decompiled Java implementation.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 分析为 `data class A` 生成的 Java 实现的任务留作读者练习。你可以通过从 Kotlin 类定义中移除 `data` 修饰符来实验，并观察字节码和反编译的
    Java 实现中的变化。
- en: Adding custom names for imports
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为导入添加自定义名称
- en: In this recipe, we are going to explore how to add custom names to the `import`
    declarations. We are going to import the `java.lang.StringBuilder` class, add
    a custom name to it and make use of it in the sample code to demonstrate it in
    action.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将探讨如何为 `import` 声明添加自定义名称。我们将导入 `java.lang.StringBuilder` 类，为其添加一个自定义名称，并在示例代码中使用它来演示其用法。
- en: How to do it...
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Import the `StringBuilder` class with a custom alias:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用自定义别名导入 `StringBuilder` 类：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Use the custom `StringBuilder` name in the sample code:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在示例代码中使用自定义的 `StringBuilder` 名称：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works...
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As you can see, we were able to use an alternative name instead of the `StringBuilder`
    class. It''s a small feature but sometimes can be used to make your code easier
    to read. Our sample code is going to print the following text to the console:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们能够使用替代名称而不是 `StringBuilder` 类。这是一个小功能，但有时可以用来使你的代码更容易阅读。我们的示例代码将打印以下文本到控制台：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Wrapping complex type declarations with type aliases
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类型别名包装复杂类型声明
- en: Sometimes we need to deal with long or verbose type declarations. Thankfully,
    in Kotlin, we are able to assign an alternative name to any existing type and
    use the shorter alternative name instead. It can also help you to write more understandable
    and elegant code. This recipe is going to demonstrate how to use type aliases.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要处理长或冗长的类型声明。幸运的是，在 Kotlin 中，我们能够为任何现有类型分配一个替代名称，并使用较短的替代名称。这也可以帮助你编写更易于理解的优雅代码。本食谱将演示如何使用类型别名。
- en: Getting ready
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s assume we have the following two classes predefined:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两个预定义的类：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We are going to define a type alias for the map of `Song` type values and a
    generic key type–`Map<T, List<Song>>`. Next, we are going to use it to define
    a function that will return the most popular `Artist` instance for a given `Map<Artist,
    List<Song>>` object.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个`Song`类型值的映射类型别名和一个泛型键类型–`Map<T, List<Song>>`。接下来，我们将使用它来定义一个函数，该函数将返回给定`Map<Artist,
    List<Song>>`对象的最受欢迎的`Artist`实例。
- en: How to do it...
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Declare a generic type alias for the `Map<T, List<Song>>` type:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`Map<T, List<Song>>`类型的泛型类型别名：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Implement the `getMostPopularArtist()` function using the type alias:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用类型别名实现`getMostPopularArtist()`函数：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works...
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Using the type alias, we were able to provide a custom name for the type and
    we could use it in `getMostPopularArtist(songs: GrouppedSongs<Artist>)` instead
    of `Map<Artist, List<Song>> type`, which resulted in a more meaningful declaration.
    We can test our implementation by invoking `getMostPopularArtist()` with sample
    data:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '使用类型别名，我们能够为类型提供一个自定义名称，并且可以在`getMostPopularArtist(songs: GrouppedSongs<Artist>)`中使用它，而不是使用`Map<Artist,
    List<Song>>`类型，这导致了一个更有意义的声明。我们可以通过用示例数据调用`getMostPopularArtist()`来测试我们的实现：'
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As a result, we are going to get the following text printed to the console:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将得到以下文本打印到控制台：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Expressive try…catch declarations
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式的try…catch声明
- en: Kotlin is advertised as an extremely expressive language. However, it's one
    of the characteristics of the language that is not obvious in the beginning, especially
    if you are used to other languages such as Java or JavaScript. In order to present
    the language style more clearly, in this recipe, we are going to discover how
    to work with the `try…catch` declaration in a Kotlin way, by treating it as an
    expression.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin被宣传为一种极其表达性的语言。然而，这是语言的一个特点，在开始时可能并不明显，尤其是如果你习惯了像Java或JavaScript这样的其他语言。为了更清楚地展示语言风格，在这个菜谱中，我们将通过将其视为表达式来发现如何在Kotlin中以`try…catch`声明的方式工作。
- en: Getting ready
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s consider the following Java code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下Java代码：
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It declares an int `result` variable. Next, it tries to parse the string value
    to the integer with the `Integer.parseInt()` function, and if it succeeds, it assigns the
    result to the `value` variable. If the `parseInt()` fails to parse the string,
    a default value of `0` is assigned to the `value` variable.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 它声明了一个`int`类型的`result`变量。接下来，它尝试使用`Integer.parseInt()`函数将字符串值解析为整数，如果成功，则将结果赋值给`value`变量。如果`parseInt()`无法解析字符串，则将默认值`0`赋值给`value`变量。
- en: How to do it...
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Invoke the `parseInt()` function in the `try…catch` declaration:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`try…catch`声明中调用`parseInt()`函数：
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Assign the result of the `try…catch` declaration to the `value` variable:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`try…catch`声明的结果赋值给`value`变量：
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How it works...
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: That's it. The `try…catch` declaration in Kotlin can be assigned to a variable.
    The reason is that it is, in fact, an expression!  In our example, `try…catch`
    returns the result of the `parseInt()` function, and when the function throws
    an exception, it returns `0`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。Kotlin中的`try…catch`声明可以被赋值给变量。原因是它实际上是一个表达式！在我们的例子中，`try…catch`返回`parseInt()`函数的结果，当函数抛出异常时，它返回`0`。
- en: There's more...
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: 'Similarly, we can treat other language declarations as expressions. It''s a
    common practice to assign a variable to the value returned by control flow statements,
    such as `if` and `when`. For example, we can use `when` as an expression in the
    following way:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以将其他语言声明视为表达式。将控制流语句（如`if`和`when`）返回的值赋给变量是一种常见的做法。例如，我们可以以下这种方式使用`when`作为表达式：
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Safe type-casting
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全的类型转换
- en: Whenever we perform type-casting, we should keep in mind that it is a potential
    source of exceptions. That's the reason why we should always perform type-checking
    using the `is` modifier or do the casting inside the `try…catch` block. However,
    in Kotlin, we have also a safe casting option that will not throw `ClassCastException`
    but will return `null` instead. In this recipe, we are going to test the safe
    casting in action.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时进行类型转换，我们都应该牢记这是一个潜在的异常来源。这就是为什么我们应该始终使用`is`修饰符进行类型检查，或者在`try…catch`块中进行转换的原因。然而，在Kotlin中，我们还有一个安全的转换选项，它不会抛出`ClassCastException`，而是返回`null`。在这个菜谱中，我们将测试安全转换的实际应用。
- en: How to do it...
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Let''s start by defining a function that returns a `Number` type of a random
    `Double` value:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先定义一个返回随机`Double`值的`Number`类型的函数：
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Try to cast the results of the function to different types using the safe-cast
    operator and print the casted values to the console:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试使用安全转换操作符将函数的结果转换为不同的类型，并将转换后的值打印到控制台：
- en: '[PRE31]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works...
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The preceding code will not fail nor throw any exceptions. It will just return
    the `null` value instead. Our casting test code is going to print the following
    output to the console:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码不会失败也不会抛出任何异常。它只会返回 `null` 值。我们的转换测试代码将打印以下输出到控制台：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Using the safe `as?` casting modifier is a neat alternative to the traditional
    way. You can use it if you are working with nullable types, that is while working
    with external libraries that don't provide the null safety. However, if you can
    benefit from the null safety, it's best to use the standard casting operation.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `as?` 转换修饰符是传统方式的整洁替代品。如果你正在处理可空类型，即在与不提供空安全的外部库一起工作时，可以使用它。然而，如果你能从空安全中受益，最好使用标准的转换操作。
