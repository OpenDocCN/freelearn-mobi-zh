- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Resolution-Independent UI
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分辨率无关的UI
- en: When working on mobile devices, one of the things that you’ll need to spend
    a fair bit of time on is the **user interface**(**UI**). Unlike when developing
    projects for a PC, where you only need to care about a single resolution or aspect
    ratio, there are many different devices out there with different resolutions and
    aspect ratios when building for mobile. For instance, we have phones that can
    fit in one of our pockets, and also tablets, which are huge. Not only that but
    mobile games can also be played horizontally or vertically. Some new phones even
    allow you to fold them to either increase or decrease the screen size dynamically.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当在移动设备上工作时，你需要花费相当一部分时间处理的事情之一是**用户界面**（**UI**）。与为PC开发项目不同，那时你只需要关心一个分辨率或纵横比，但在为移动设备构建时，有许多不同分辨率和纵横比的不同设备。例如，我们有一些可以放入我们口袋中的手机，还有平板电脑，它们非常大。不仅如此，移动游戏还可以水平或垂直玩游戏。一些新的手机甚至允许你折叠它们，以动态地增加或减少屏幕大小。
- en: A **graphical user interface**(**GUI**) is the way that players interact with
    games. You’ve actually used a GUI in all of the previous chapters (the Unity Editor)
    and also when interacting with your operating system. Without a GUI of some sort,
    the only way you’d be able to interact with a computer is with a **command-line
    interface** (**CLI**) – that is, Command Prompt in Windows and Terminal for Linux
    and macOS.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**图形用户界面**（**GUI**）是玩家与游戏互动的方式。实际上，你在所有前面的章节（Unity编辑器）以及与你的操作系统交互时都使用了GUI。如果没有某种形式的GUI，你与计算机的唯一交互方式将是**命令行界面**（**CLI**）——即在Windows中的命令提示符和在Linux和macOS中的终端。'
- en: When working on GUIs, we want them to contain only information that is important
    to the player at any given time while also being simple and intuitive. There are
    people whose main job is programming and/or designing UIs, and there are college
    degrees in the subject as well. So, while we won’t talk about everything to do
    with using GUIs, I do want to touch on the aspects that should be quite helpful
    when working on your own projects in the future.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理图形用户界面（GUIs）时，我们希望它们只包含对玩家在任何给定时间都重要的信息，同时也要简单直观。有些人主要的工作是编程和/或设计用户界面（UIs），而且这个领域也有大学学位。因此，虽然我们不会讨论与使用GUIs相关的所有内容，但我确实想谈谈在将来进行自己的项目时应该相当有帮助的方面。
- en: When building for mobile, it’s very important that you design your UI to be
    resolution-independent – that is, to ensure that the UI will scale and adjust
    itself to fit any screen size that is given to it. As a game developer, you will
    be able to target a large number of devices if your game is resolution-independent
    or responsive.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当为移动设备构建时，设计你的UI以实现分辨率无关性——也就是说，确保UI将缩放并调整自身以适应给定的任何屏幕大小——这一点非常重要。如果你游戏的UI是分辨率无关的或响应式的，作为游戏开发者，你将能够针对大量设备。
- en: 'This chapter will be split into a number of topics. The chapter is a simple
    step-by-step process from beginning to end. The following is the outline of our
    tasks:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将分为几个主题。本章是一个从头到尾的简单步骤过程。以下是我们任务的概述：
- en: Creating a title screen
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建标题屏幕
- en: Adding UI elements to the screen
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向屏幕添加UI元素
- en: Adding on-screen controls
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加屏幕控制
- en: Implementing a pause menu
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现暂停菜单
- en: Pausing the game
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暂停游戏
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This book utilizes Unity 2022.1.0b16 and Unity Hub 3.3.1, but the steps should
    work with minimal changes in future versions of the editor. If you would like
    to download the exact version used in this book, and there is a new version out,
    you can visit Unity’s download archive at [https://unity3d.com/get-unity/download/archive](https://unity3d.com/get-unity/download/archive).
    You can also find the system requirements for Unity at [https://docs.unity3d.com/2022.1/Documentation/Manual/system-requirements.html](https://docs.unity3d.com/2022.1/Documentation/Manual/system-requirements.html)
    in the **Unity Editor system** **requirements** section.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用Unity 2022.1.0b16和Unity Hub 3.3.1，但步骤应该在未来版本的编辑器中只需进行最小更改即可。如果你想下载本书中使用的确切版本，并且有新版本发布，你可以访问Unity的下载存档[https://unity3d.com/get-unity/download/archive](https://unity3d.com/get-unity/download/archive)。你还可以在**Unity编辑器系统**
    **要求**部分找到Unity的系统要求[https://docs.unity3d.com/2022.1/Documentation/Manual/system-requirements.html](https://docs.unity3d.com/2022.1/Documentation/Manual/system-requirements.html)。
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Unity-2022-Mobile-Game-Development-3rd-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/Unity-2022-Mobile-Game-Development-3rd-Edition/tree/main/Chapter04).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章中提供的代码文件，链接为[https://github.com/PacktPublishing/Unity-2022-Mobile-Game-Development-3rd-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/Unity-2022-Mobile-Game-Development-3rd-Edition/tree/main/Chapter04)。
- en: Creating a title screen
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建标题屏幕
- en: 'Now, before we start adding UI elements to our game, let’s first set up some
    groundwork and foundational knowledge by creating something that we will need
    anyway – a title screen:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始向游戏添加UI元素之前，让我们首先通过创建我们无论如何都需要的东西来设置一些基础和基础知识 – 一个标题屏幕：
- en: To start, we’ll go ahead and create a new scene for us to work with by going
    to **File** | **New Scene**. There will be a window that pops up asking which
    template should be used. In this case, we will select **Basic (Built-in)** and
    then click on the **Create** button.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个新的场景供我们使用，方法是转到**文件** | **新建场景**。会出现一个窗口询问应使用哪个模板。在这种情况下，我们将选择**基本（内置）**，然后点击**创建**按钮。
- en: '![Figure 4.1 – Creating a Basic scene](img/Figure_4.01_B18868.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1 – 创建基本场景](img/Figure_4.01_B18868.jpg)'
- en: Figure 4.1 – Creating a Basic scene
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – 创建基本场景
- en: When dealing with a UI, we will often want to see a visual representation of
    what will be drawn on the screen, so we will want to make use of 2D mode to have
    a better representation of what our UI will look like in the final version of
    the game.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理UI时，我们通常会想要看到屏幕上将要绘制的视觉表示，因此我们将想要使用2D模式以更好地表示我们的UI在游戏最终版本中的外观。
- en: 'To do that, go to the **Scene** view tab – you’ll see the control bar menu
    with a **2D** button on it underneath that. Click on it, and you should see the
    camera automatically move into something that looks similar to the following screenshot:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要做到这一点，请转到**场景**视图标签 – 您将看到带有下面带有**2D**按钮的控制栏菜单。点击它，您应该会看到摄像机自动移动到类似于以下截图的视图：
- en: '![Figure 4.2 – Selecting 2D mode](img/Figure_4.02_B18868.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2 – 选择2D模式](img/Figure_4.02_B18868.jpg)'
- en: Figure 4.2 – Selecting 2D mode
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 选择2D模式
- en: The `Gizmos` are gone due to the fact that the only option is to look perpendicularly
    at the *XY* plane (the *x* axis pointing to the right and the *y* axis pointing
    upward) and that our camera has changed to an orthographic view.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于唯一的选择是垂直于*XY*平面（*x*轴指向右侧，*y*轴向上）查看，并且我们的摄像机已更改为正交视图，因此**Gizmos**消失了。
- en: We have to create a **Text** object with the name of our game. Go to the menu
    and select **GameObject** | **UI** | **Text – Text** **Mesh Pro**.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建一个名为我们游戏的**Text**对象。转到菜单并选择**游戏对象** | **UI** | **Text – Text** **Mesh
    Pro**。
- en: If this is your first time using **TextMeshPro**, there may be a **TMP Importer**
    window that pops up. If so, click on the **Import TMP** **Essentials** button.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这是您第一次使用**TextMeshPro**，可能会弹出一个**TMP导入器**窗口。如果是这样，请点击**导入TMP** **Essentials**按钮。
- en: '![Figure 4.3 – TMP Importer window](img/Figure_4.03_B18868.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3 – TMP导入器窗口](img/Figure_4.03_B18868.jpg)'
- en: Figure 4.3 – TMP Importer window
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – TMP导入器窗口
- en: Tip
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that while this book uses **TextMesh Pro** for drawing text, the following
    steps from the scripting portion also work with the legacy Unity UI system and
    **Text** objects, and all the concepts in this chapter work the same with both
    systems.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然这本书使用**TextMesh Pro**来绘制文本，但以下脚本部分的步骤也适用于传统的Unity UI系统和**Text**对象，并且本章中的所有概念在这两种系统中都是相同的。
- en: 'You will see three new objects, in the **Hierarchy** view, **Canvas**, **Text
    (TMP)**, and **EventSystem**:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将在**层次**视图中看到三个新对象，**Canvas**、**Text (TMP**)和**EventSystem**：
- en: '**Canvas**: This is the area where all of the UI elements will reside, and
    if you try to create a UI element without one already existing, Unity will create
    one for you like it just did here. From the **Scene** view tab, it will draw a
    white rectangle around itself to show you how large it is and will resize itself
    depending on how large the **Game** view is:'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**画布**：这是所有UI元素将驻留的区域，如果您尝试创建一个没有已经存在的UI元素，Unity会像刚才那样为您创建一个。从**场景**视图标签，它将围绕自身绘制一个白色矩形以显示其大小，并根据**游戏**视图的大小进行调整：'
- en: '![Figure 4.4 – Zooming out to display the Canvas](img/Figure_4.04_B18868.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图4.4 – 缩放以显示画布](img/Figure_4.04_B18868.jpg)'
- en: Figure 4.4 – Zooming out to display the Canvas
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 – 缩放以显示画布
- en: Note
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you double-click on an object in the **Hierarchy** window, the camera will
    automatically move and zoom so you can see the object within the **Scene** window.
    The GameObject contains a **Canvas** component, which allows you to dictate how
    the image will be rendered (and a **Canvas Scaler** component to make your art
    scale, depending on the resolution of the device the game is running on and the
    **Graphic Raycaster** component, which determines whether any objects on the **Canvas**
    have been hit. We will dive into the **Canvas Scaler** component later on in this
    section.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在**层次结构**窗口中双击一个对象，摄像机将自动移动和缩放，以便您可以在**场景**窗口中看到该对象。GameObject 包含一个**Canvas**组件，它允许您指定图像的渲染方式（以及一个**Canvas
    Scaler**组件，根据游戏运行设备的分辨率调整您的艺术作品大小，以及一个**Graphic Raycaster**组件，它确定**Canvas**上的任何对象是否被击中。我们将在本节稍后深入了解**Canvas
    Scaler**组件）。
- en: Important note
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: For more information on the **Canvas** object, check out [http://docs.unity3d.com/Manual/UICanvas.html](http://docs.unity3d.com/Manual/UICanvas.html).
    In particular, the discussion on the render modes is quite useful in understanding
    the ways that UI elements can be rendered onto the screen.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 想要了解更多关于**Canvas**对象的信息，请查看[http://docs.unity3d.com/Manual/UICanvas.html](http://docs.unity3d.com/Manual/UICanvas.html)。特别是关于渲染模式的讨论对于理解
    UI 元素如何渲染到屏幕上的方式非常有用。
- en: '**Text (TMP)**: This object is our actual text object, which has all of the
    properties that allow us to position the object anywhere on the **Canvas** object
    and change the text, color, size, and so on that will be displayed.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Text (TMP)**：此对象是我们实际文本对象，它具有所有允许我们在**画布**对象上的任何位置定位对象以及更改将显示的文本、颜色、大小等属性。'
- en: Note
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more info on TextMesh Pro, check out [https://docs.unity3d.com/Packages/com.unity.textmeshpro@3.0/manual/index.html](https://docs.unity3d.com/Packages/com.unity.textmeshpro@3.0/manual/index.html)**.**
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 想要了解更多关于 TextMesh Pro 的信息，请查看[https://docs.unity3d.com/Packages/com.unity.textmeshpro@3.0/manual/index.html](https://docs.unity3d.com/Packages/com.unity.textmeshpro@3.0/manual/index.html)**。**
- en: '**EventSystem**: This object allows users to send events to objects in our
    game based on various input types, whether keyboard presses, touch events, or
    gamepads. There are properties in this object that allow you to specify how you’d
    like your users to interact with your UI, and if you try to create a UI element
    without one existing, Unity will create one for you as it did here. If you want
    to have any kind of interactive material in your level using Unity’s UI system,
    such as buttons, sliders, and so on, you must have an object with the **EventSystem**
    component attached within the level or the events will not trigger.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EventSystem**：此对象允许用户根据各种输入类型（如键盘按键、触摸事件或游戏手柄）向游戏中的对象发送事件。此对象中存在一些属性，允许您指定用户如何与您的
    UI 交互，如果您尝试创建一个没有存在的 UI 元素，Unity 将为您创建一个，就像这里所做的那样。如果您想在您的关卡中使用 Unity 的 UI 系统创建任何类型的交互式材料，例如按钮、滑块等，您必须在关卡中附加带有**EventSystem**组件的对象，否则事件将不会触发。'
- en: Note
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on the **EventSystem** object, check out [http://docs.unity3d.com/Manual/EventSystem.html](http://docs.unity3d.com/Manual/EventSystem.html).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 想要了解更多关于**EventSystem**对象的信息，请查看[http://docs.unity3d.com/Manual/EventSystem.html](http://docs.unity3d.com/Manual/EventSystem.html)。
- en: 'By default, you may or may not see where our textbox was created. If you aren’t
    able to see it, you can go to the **Hierarchy** window and then double-click on
    the **Text (TMP)** object. If all went well, we should have something like this:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，您可能看不到我们的文本框创建的位置。如果您看不到它，可以转到**层次结构**窗口，然后双击**Text (TMP)**对象。如果一切顺利，我们应该会有如下所示的内容：
- en: '![Figure 4.5 – Zooming in to the Text (TMP) object](img/Figure_4.05_B18868.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.5 – 放大查看 Text (TMP) 对象](img/Figure_4.05_B18868.jpg)'
- en: Figure 4.5 – Zooming in to the Text (TMP) object
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – 放大查看 Text (TMP) 对象
- en: The next thing we will do is make it easier to tell what this object is. So,
    with that in mind, scroll all the way up on the `Title Text`. To make it a bit
    easier to see, with the object selected, go to the **Inspector** tab and scroll
    down to the **TextMeshPro – Text (UI)** component, and then change the **Vertex
    Color** property to **black**.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步我们将做的是让识别这个对象变得更加容易。因此，考虑到这一点，滚动到`标题文本`的顶部。为了使其更易于查看，在选中对象后，转到**检查器**选项卡，并向下滚动到**TextMeshPro
    – 文本 (UI)**组件，然后将**顶点颜色**属性更改为**黑色**。
- en: We can tell whether the object is going to be visible in the game by seeing
    whether it is within the white box created for **Canvas**. One thing to note is
    that instead of the default **Transform** component that all of the game objects
    we’ve seen so far used, our **Text** object has a **Rect Transform** component
    in the same place.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过查看对象是否在为**画布**创建的白色框内来判断对象是否将在游戏中可见。需要注意的是，与迄今为止我们看到的所有游戏对象使用的默认**变换**组件不同，我们的**文本**对象在相同位置有一个**矩形变换**组件。
- en: The Rect Transform component
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 矩形变换组件
- en: The `Rect` `Transform` is different from the regular `Transform` in that while
    the Transform component represents a single point or the center of an object,
    Rect Transform represents a rectangle, in which the UI element will reside. If
    an object with a Rect Transform has a parent, which also has a Rect Transform,
    then the child will specify how the object should be positioned relative to its
    parent.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`矩形` `变换`与常规`变换`不同，因为变换组件代表一个点或对象的中心，而矩形变换代表一个矩形，其中UI元素将驻留。如果一个具有矩形变换的对象有一个父对象，该父对象也有矩形变换，那么子对象将指定对象相对于父对象的位置。'
- en: Note
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on positioning objects and information on **Rect Transform**,
    check out [http://docs.unity3d.com/Manual/UIBasicLayout.html](http://docs.unity3d.com/Manual/UIBasicLayout.html)**.**
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 有关对象定位和**矩形变换**的信息，请参阅[http://docs.unity3d.com/Manual/UIBasicLayout.html](http://docs.unity3d.com/Manual/UIBasicLayout.html)**。**
- en: 'To get a better idea of what the properties of the `0`, which will center our
    object around the object’s anchors; you can then double-click on the object in
    the **Hierarchy** tab to center the camera at its new position and can zoom in/out
    using the mouse wheel:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地了解`0`的属性，这些属性将围绕对象的锚点中心化我们的对象；然后你可以双击**层次结构**标签页中的对象，将相机定位到其新位置，并使用鼠标滚轮进行缩放/缩小：
- en: '![Figure 4.6 – Title Text centered on the Canvas](img/Figure_4.06_B18868.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图4.6 – 画布上居中的标题文本](img/Figure_4.06_B18868.jpg)'
- en: Figure 4.6 – Title Text centered on the Canvas
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 – 画布上居中的标题文本
- en: Our object’s anchors are visible from the **Scene** tab via four small rectangles,
    creating an X shape in the center of our **Scene** tab, if you have the **Title
    Text** object selected (double-click on it to center the object on the screen).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择了**标题文本**对象（双击以在屏幕上居中对象），我们的对象的锚点可以通过**场景**标签页中的四个小矩形看到，在**场景**标签页的中心形成一个X形状。
- en: Important note
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: As I mentioned previously, note that the white box that is displayed here for
    the **Canvas** may look different on your screen based on the aspect ratio you’ve
    set from the **Game** tab view (mine is set to **Free Aspect**, so it scales based
    on that to fill the space). If you go to the **Game** tab, you can select them
    from the drop-down menu on the left-hand side.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所述，请注意，这里显示的用于**画布**的白色框根据你在**游戏**标签页视图（我的设置为**自由宽高比**，因此根据此比例填充空间）中设置的宽高比可能看起来与你的屏幕不同。如果你转到**游戏**标签页，你可以从左侧的下拉菜单中选择它们。
- en: 'Next, we’ll take a look at the two main elements present that work differently
    in the **Rect Transform** component: anchors and pivots.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看在**矩形变换**组件中工作方式不同的两个主要元素：锚点和轴点。
- en: Anchors
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 锚点
- en: Found inside the `0`, the UI element would stick to the left edge of its parent.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在`0`中找到的UI元素会粘附到其父元素的左侧边缘。
- en: 'The properties above the anchors are your position relative to the anchor that
    has been set. This can be quite useful when it comes to things such as supporting
    multiple resolutions without scaling the art assets created. In our case, we will
    want to have our title position itself relative to the top of the camera. Let’s
    look at the steps to take when working with anchors:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 锚点之上的属性是相对于已设置的锚点的位置。这在支持多个分辨率而不缩放创建的艺术资源时非常有用。在我们的例子中，我们希望标题相对于相机的顶部定位。让我们看看使用锚点时的步骤：
- en: 'Click on the **Anchor Presets** menu in the upper-left corner of the **Rect
    Transform** component (the box to the left of the **Pos X** and **Width** values).
    From there, it shows some of the most common anchor positions used in games for
    easy selection. In our case, we will want to pick the top-center option:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**锚点预设**菜单（位于**矩形变换**组件的左上角，即**X轴位置**和**宽度**值左侧的框）。从那里，它显示了一些在游戏中常用的最常见锚点位置，以便于选择。在我们的例子中，我们将想要选择顶部居中选项：
- en: '![Figure 4.7 – Selecting the top-center option on the Anchor Presets menu](img/Figure_4.07_B18868.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.7 – 在锚点预设菜单中选择顶部居中选项](img/Figure_4.07_B18868.jpg)'
- en: Figure 4.7 – Selecting the top-center option on the Anchor Presets menu
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 – 在锚点预设菜单中选择顶部居中选项
- en: 'Note that after selecting it, the `-290`). This is saying that our object is
    positioned `0`, the object would be centered along the *y* **axis**’s anchor,
    which would place the object with half of it off the screen, which is not good,
    as you can see in the following example:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意在选中后，`-290`)。这意味着我们的对象位置为 `0`，对象将沿着 *y* **轴** 的锚点居中，这将使对象的一半位于屏幕之外，这并不好，如以下示例所示：
- en: '![Figure 4.8 – Changing Pos Y to 0](img/Figure_4.08_B18868.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.8 – 将 Pos Y 更改为 0](img/Figure_4.08_B18868.jpg)'
- en: Figure 4.8 – Changing Pos Y to 0
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 – 将 Pos Y 更改为 0
- en: I placed the tab to make it easier to see the issue; you can do this by dragging
    and dropping the tab to the edge of the screen.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我放置了标签以更容易看到问题；您可以通过将标签拖放到屏幕边缘来完成此操作。
- en: Tip
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: To reset any layout changes, you may go to the **Layout** menu in the top-right
    part of the screen and select **Default**.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要重置任何布局更改，您可以在屏幕右上角选择 **布局** 菜单并选择 **默认**。
- en: If we changed our object’s value to `-25` (subtracting half its value), it would
    be positioned correctly. However, hardcoding this value will be an issue if we
    decide we want to change the value later on, as we will have to remember to adjust
    this again. It would be a lot nicer if we had something to make at `0` the edge
    of the map relative to our height, and, thankfully, we have the property to fix
    that.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将对象的值更改为 `-25`（减去其一半值），它将被正确放置。然而，如果我们决定稍后更改此值，硬编码此值将是一个问题，因为我们必须记得再次调整它。如果我们可以使地图相对于我们的高度边缘在
    `0` 处，那就好多了，幸运的是，我们有这样的属性来解决这个问题。
- en: 'Next, change the `1` and then change `0` if you changed it previously and it
    doesn’t change automatically:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，更改 `1`，然后如果之前更改了 `0`，则更改 `0`：
- en: '![Figure 4.9 – Adjusting Pivot and Pos Y values](img/Figure_4.09_B18868.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.9 – 调整枢轴和 Pos Y 值](img/Figure_4.09_B18868.jpg)'
- en: Figure 4.9 – Adjusting Pivot and Pos Y values
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 – 调整枢轴和 Pos Y 值
- en: As you can see, the text is now hugging the top due to the pivot setting being
    changed.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，由于枢轴设置已更改，文本现在紧贴顶部。
- en: Pivots
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 枢轴
- en: '`0`, `0.5`, and `1`, and note the differences in how things are rotated.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`0`、`0.5` 和 `1`，并注意旋转的不同之处。'
- en: Important note
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Note that it is possible to set the **Pivot**, **Position**, and **Anchors settings**
    of an object via the **Anchors Preset** menu I mentioned previously if you hold
    down the *Alt* **+** *Shift*keys while clicking on the object. This way, all of
    the steps we discussed will happen all at once, but it’s a good idea to get a
    foundation of what everything means before jumping straight into using shortcuts.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果您在单击对象时按住 *Alt* **+** *Shift* 键，可以通过我之前提到的 **锚点预设** 菜单设置对象的 **枢轴**、**位置**
    和 **锚点** 设置。这样，我们讨论的所有步骤都会同时发生，但在直接使用快捷键之前，了解每一步的含义是一个好主意。
- en: Now that we have a basic understanding of how to work within the m space, let’s
    start finalizing our **Title** **Text** object.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经基本了解了如何在 m 空间中工作，让我们开始最终确定我们的 **标题** **文本** 对象。
- en: Adjusting and resizing the title text
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整和调整标题文本大小
- en: 'Now that we have our object positioned correctly, let’s give some visual flair
    to our title text using the following steps:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经正确放置了对象，让我们使用以下步骤给标题文本添加一些视觉效果：
- en: Select the `Endless Roller` and set the `40`. Note that now the text shows up
    in two lines and is not within the confines of the size that we defined in the
    **Rect** **Transform** component.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `Endless Roller` 并设置 `40`。注意现在文本显示为两行，并且不在我们定义的 **矩形** **变换** 组件的大小范围内。
- en: '![Figure 4.10 – Settings used for the TextMeshPro - Text (UI) component](img/Figure_4.10_B18868.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.10 – 用于 TextMeshPro - 文本 (UI) 组件的设置](img/Figure_4.10_B18868.jpg)'
- en: Figure 4.10 – Settings used for the TextMeshPro - Text (UI) component
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10 – 用于 TextMeshPro - 文本 (UI) 组件的设置
- en: 'With that in mind, scroll up to `300``50`. We will also want it to be offset
    from the top of the world, so let’s change `-30` to give it a little offset:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑到这一点，向上滚动到 `300``50`。我们还想让它从世界顶部偏移，所以让我们将 `-30` 更改为给它一点偏移：
- en: "![Figure 4.11 –\uFEFF Offsetting the title text](img/Figure_4.11_B18868.jpg)"
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.11 – 调整标题文本的偏移](img/Figure_4.11_B18868.jpg)'
- en: Figure 4.11 – Offsetting the title text
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11 – 调整标题文本的偏移
- en: 'Now, this looks great for this resolution; however, if we were to play the
    game at a larger resolution, it may look like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个分辨率来说，这看起来很棒；然而，如果我们以更高的分辨率玩游戏，它可能看起来像这样：
- en: '![Figure 4.12 – Current state of the title screen](img/Figure_4.12_B18868.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图4.12 – 标题屏幕当前状态](img/Figure_4.12_B18868.jpg)'
- en: Figure 4.12 – Current state of the title screen
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.12 – 标题屏幕当前状态
- en: Having a UI that doesn’t scale can be good if you’re trying to have a (component
    to adjust how the screen will change based on the resolution we give it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试调整屏幕如何根据我们提供的分辨率变化（组件以调整屏幕变化）的UI，那么UI不缩放可能是个好主意。
- en: Select the **Canvas** object from the **Hierarchy** component, and then from
    the **Inspector** window, go to the **Canvas Scaler** component. From there, change
    **UI Scale Mode** to **Scale with** **Screen Size**.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次结构**组件中选择**画布**对象，然后从**检查器**窗口中转到**画布缩放器**组件。从那里，将**UI缩放模式**更改为**与屏幕大小缩放**。
- en: The key property here is **Reference Resolution**. This is the resolution that
    we want to base our menu on—if the resolution is made bigger, it will scale up;
    if it’s made smaller, it will scale down. You will likely have a resolution in
    mind based on your mockups or an image file you’ve made; however, for reference,
    the following are some of the most common screen resolutions at the time of writing
    this book.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这里关键的性质是**参考分辨率**。这是我们想要基于我们的菜单的分辨率——如果分辨率变大，它将放大；如果它变小，它将缩小。您可能已经根据您的原型或您制作的图像文件有了分辨率的概念；然而，为了参考，以下是在撰写本书时的一些最常见的屏幕分辨率。
- en: 'Here are some sample Apple device resolutions:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些示例Apple设备分辨率：
- en: '| **Device Name** | **Resolution** |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| **设备名称** | **分辨率** |'
- en: '| iPhone 12 Pro Max/13 Pro Max | 2778 x 1284 |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| iPhone 12 Pro Max/13 Pro Max | 2778 x 1284 |'
- en: '| iPhone 12/12 Pro/13 Pro | 2532 x 1170 |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| iPhone 12/12 Pro/13 Pro | 2532 x 1170 |'
- en: '| iPhone 12/13 | 2532 x 1170 |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| iPhone 12/13 | 2532 x 1170 |'
- en: '| iPhone 12 mini/13 mini | 2340 x 1080 |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| iPhone 12 mini/13 mini | 2340 x 1080 |'
- en: '| iPhone 11 Pro Max | 2688 x 1242 |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| iPhone 11 Pro Max | 2688 x 1242 |'
- en: '| iPhone 11 Pro | 2436 x 1125 |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| iPhone 11 Pro | 2436 x 1125 |'
- en: '| iPhone 11 | 1792 x 828 |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| iPhone 11 | 1792 x 828 |'
- en: '| iPhone 14 Pro Max | 2796 x 1290 |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| iPhone 14 Pro Max | 2796 x 1290 |'
- en: '| iPhone 14 Pro | 2556 x 1179 |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| iPhone 14 Pro | 2556 x 1179 |'
- en: '| iPhone 14 | 2532 x 1170 (Same as 12/13) |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| iPhone 14 | 2532 x 1170 (与12/13相同) |'
- en: '| iPhone 14 Plus | 2778 x 1284 (Same as Phone 12 Pro Max/13 Pro Max) |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| iPhone 14 Plus | 2778 x 1284 (与Phone 12 Pro Max/13 Pro Max相同) |'
- en: '| iPhone SE (2020) | 1334 x 750 |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| iPhone SE (2020) | 1334 x 750 |'
- en: '| iPhone XS Max | 1242 x 2688 |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| iPhone XS Max | 1242 x 2688 |'
- en: '| iPhone XS | 1125 x 2436 |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| iPhone XS | 1125 x 2436 |'
- en: '| iPhone XR | 828 x 1792 |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| iPhone XR | 828 x 1792 |'
- en: '| iPhone X | 2436 x 1125 |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| iPhone X | 2436 x 1125 |'
- en: '| iPhone 7 Plus/8 Plus | 1080 x 1920 |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| iPhone 7 Plus/8 Plus | 1080 x 1920 |'
- en: '| iPhone 7/8 | 750 x 1334 |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| iPhone 7/8 | 750 x 1334 |'
- en: '| iPhone 6S Plus | 1080 x 1920 |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| iPhone 6S Plus | 1080 x 1920 |'
- en: '| iPhone 6S | 750 x 1334 |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| iPhone 6S | 750 x 1334 |'
- en: '| iPad Pro (1st-5th gen 12.9”) | 2048 x 2732 |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| iPad Pro (第1-5代 12.9英寸) | 2048 x 2732 |'
- en: '| iPad 9th gen | 2160 x 1620 |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| iPad 第9代 | 2160 x 1620 |'
- en: '| iPad Air 4th gen | 2388 x 1668 |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| iPad Air 第4代 | 2388 x 1668 |'
- en: '| iPad Mini (6th gen) | 2266 x 1488 |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| iPad Mini (第6代) | 2266 x 1488 |'
- en: 'Here are some sample Android device resolutions:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些示例Android设备分辨率：
- en: '| **Device Name** | **Resolution** |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| **设备名称** | **分辨率** |'
- en: '| Samsung Galaxy S22 Ultra | 3080 x 1440 |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 三星 Galaxy S22 Ultra | 3080 x 1440 |'
- en: '| Samsung Galaxy S22 | 2340 x 1080 |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 三星 Galaxy S22 | 2340 x 1080 |'
- en: '| Samsung Galaxy Z Fold3 | 2208 x 1768 |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 三星 Galaxy Z Fold3 | 2208 x 1768 |'
- en: '| Samsung Galaxy S20 Ultra/S21 Ultra | 3200 x 1440 |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 三星 Galaxy S20 Ultra/S21 Ultra | 3200 x 1440 |'
- en: '| Samsung Galaxy S20/S21 | 2400 x 1080 |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 三星 Galaxy S20/S21 | 2400 x 1080 |'
- en: '| Samsung Note 10+ | 2280 x1080 |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 三星 Note 10+ | 2280 x1080 |'
- en: '| Google Pixel 5 XL | 2960 x 1440 |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| Google Pixel 5 XL | 2960 x 1440 |'
- en: '| Google Pixel 5 | 2340 x 1080 |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| Google Pixel 5 | 2340 x 1080 |'
- en: '| Google Pixel 4 XL | 1440 x 2960 |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| Google Pixel 4 XL | 1440 x 2960 |'
- en: '| Google Pixel 4 | 2280 x 1080 |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| Google Pixel 4 | 2280 x 1080 |'
- en: '| Samsung Galaxy S10/S10+ | 3040 x 1440 |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 三星 Galaxy S10/S10+ | 3040 x 1440 |'
- en: '| Google Pixel 3 XL | 2960 x 1440 |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| Google Pixel 3 XL | 2960 x 1440 |'
- en: '| Google Pixel 3/3a XL | 2160 x 1080 |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| Google Pixel 3/3a XL | 2160 x 1080 |'
- en: '| Google Pixel 3a | 2220 x 1080 |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| Google Pixel 3a | 2220 x 1080 |'
- en: '| Samsung Galaxy S8/S8+ | 2960 x 1440 |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 三星 Galaxy S8/S8+ | 2960 x 1440 |'
- en: '| Google Pixel 2 XL | 2560 x 1312 |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| Google Pixel 2 XL | 2560 x 1312 |'
- en: '| Nexus 6P | 1440 x 2560 |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| Nexus 6P | 1440 x 2560 |'
- en: '| Nexus 5X | 1080 x 1920 |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| Nexus 5X | 1080 x 1920 |'
- en: '| Google Pixel/Pixel 2 | 1080 x 1920 |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| Google Pixel/Pixel 2 | 1080 x 1920 |'
- en: '| Google Pixel XL/Pixel 2 XL | 1440 x 2560 |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| Google Pixel XL/Pixel 2 XL | 1440 x 2560 |'
- en: '| Samsung Galaxy Note 5 | 1440 x 2560 |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 三星 Galaxy Note 5 | 1440 x 2560 |'
- en: '| LG G5 | 1440 x 2560 |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| LG G5 | 1440 x 2560 |'
- en: '| One Plus 3 | 1080 x 1920 |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 一加 3 | 1080 x 1920 |'
- en: '| Samsung Galaxy S7 | 1440 x 2560 |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 三星 Galaxy S7 | 1440 x 2560 |'
- en: '| Samsung Galaxy S7 Edge | 1440 x 2560 |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 三星 Galaxy S7 Edge | 1440 x 2560 |'
- en: '| Nexus 7 (2013) | 1200 x 1920 |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| Nexus 7 (2013) | 1200 x 1920 |'
- en: '| Nexus 9 | 1536 x 2048 |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| Nexus 9 | 1536 x 2048 |'
- en: '| Samsung Galaxy Tab 10 | 800 x 1280 |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 三星Galaxy Tab 10 | 800 x 1280 |'
- en: '| Chromebook Pixel | 2560 x 1700 |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| Chromebook Pixel | 2560 x 1700 |'
- en: Note
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To see a list of popular cell phone screen resolutions, check out [http://screensiz.es/phone](http://screensiz.es/phone)
    or [https://www.ios-resolution.com/](https://www.ios-resolution.com/).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看流行的手机屏幕分辨率列表，请查看[http://screensiz.es/phone](http://screensiz.es/phone)或[https://www.ios-resolution.com/](https://www.ios-resolution.com/)。
- en: I am using a Google Pixel 3a XL, which has a resolution of 2160 x 1080, and
    an iPhone 13 Pro Max, which has a 2778 x 1284 resolution, so I think that would
    be a good place to start. However, if you are creating art assets, it’s a good
    idea to create the UI at the largest resolution you plan on supporting and then
    build for other resolutions from there.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用的是Google Pixel 3a XL，分辨率为2160 x 1080，以及iPhone 13 Pro Max，分辨率为2778 x 1284，因此我认为这是一个不错的起点。然而，如果你正在创建艺术资产，最好在计划支持的最高分辨率上创建UI，然后从那里构建其他分辨率。
- en: Unity has some of the most common resolutions built in, which can be seen/changed
    from the dropdown in the window view mentioned previously.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Unity内置了一些最常见的分辨率，这些分辨率可以从之前提到的窗口视图中下拉菜单中查看/更改。
- en: 4. In the `1920 x 1080` if it isn’t there already.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 如果在`1920 x 1080`中还没有的话。
- en: 5. Next, under **Match**, move it all the way over to **Height**. This will
    ensure that when the height of our screen changes, that’s when we will modify
    the scale of our UI.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 接下来，在**匹配**下，将其全部移动到**高度**。这将确保当屏幕的高度发生变化时，我们将修改UI的缩放比例。
- en: '6. Next, let’s make the text a bit larger. Select the `1000` and `200`, and
    then change the `130`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 6. 接下来，让我们将文本放大一些。选择`1000`和`200`，然后更改`130`：
- en: "![Figure 4.13 – Adjusting the \uFEFFtitle text to be large](img/Figure_4.13_B18868.jpg)"
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图4.13 – 调整标题文本以放大](img/Figure_4.13_B18868.jpg)'
- en: Figure 4.13 – Adjusting the title text to be large
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.13 – 调整标题文本以放大
- en: '7. Now, if we play the game with a higher resolution, it will display our title
    nicely, scaling up to fit the larger size that we have:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 7. 现在，如果我们以更高的分辨率玩游戏，它将很好地显示我们的标题，并放大以适应更大的尺寸：
- en: '![Figure 4.14 – Scaling the title screen](img/Figure_4.14_B18868.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图4.14 – 调整标题屏幕](img/Figure_4.14_B18868.jpg)'
- en: Figure 4.14 – Scaling the title screen
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.14 – 调整标题屏幕
- en: '8. Go to the **Game** view control bar and pick a smaller resolution, such
    as **800x480 Landscape (800x480)**, and you’ll note that the text will scale down
    to fit nicely as well:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 8. 前往**游戏**视图控制栏并选择一个较小的分辨率，例如**800x480 横向（800x480）**，你会注意到文本会缩小以很好地适应：
- en: '![Figure 4.15 – Title screen at a smaller resolution](img/Figure_4.15_B18868.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图4.15 – 较小分辨率的标题屏幕](img/Figure_4.15_B18868.jpg)'
- en: Figure 4.15 – Title screen at a smaller resolution
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.15 – 较小分辨率的标题屏幕
- en: As you can see, the **Canvas Scaler** component will adjust the size of the
    text depending on the resolution of the device. Next, we will see how we can quickly
    test different resolutions as well.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，**画布缩放器**组件会根据设备的分辨率调整文本的大小。接下来，我们将看到如何快速测试不同的分辨率。
- en: Note
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on the **Canvas Scaler** component, check out [https://docs.unity3d.com/Manual/script-CanvasScaler.html](https://docs.unity3d.com/Manual/script-CanvasScaler.html).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于**画布缩放器**组件的信息，请查看[https://docs.unity3d.com/Manual/script-CanvasScaler.html](https://docs.unity3d.com/Manual/script-CanvasScaler.html)。
- en: Selecting different aspect ratios
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择不同的宽高比
- en: 'As I mentioned previously, in the **Game** view, if we go to the control bar
    and select the first option, there is a drop-down menu where we can pick different
    resolutions to test our game, so we can find potential issues before exporting
    it to our devices:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，在**游戏**视图中，如果我们进入控制栏并选择第一个选项，会出现一个下拉菜单，我们可以从中选择不同的分辨率来测试我们的游戏，这样我们就可以在导出到我们的设备之前找到潜在的问题：
- en: '![Figure 4.16 – Different resolution options](img/Figure_4.16_B18868.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图4.16 – 不同分辨率选项](img/Figure_4.16_B18868.jpg)'
- en: Figure 4.16 – Different resolution options
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.16 – 不同分辨率选项
- en: 'There are a number of resolutions built in for us by default, but we can also
    make our own using the **+** button at the bottom. I suggest that you make two
    new selections for your phone for landscape mode and for portrait mode at the
    resolutions you are trying to reach if they’re not included by default (in my
    case, 1920 x 1080, 1080 x 1920, 2778 x 1284, and 1284 x 2778):'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，已经为我们内置了多种分辨率，但我们也可以使用底部的**+**按钮创建自己的分辨率。我建议您为您的手机创建两个新的选择，用于横屏模式和竖屏模式，如果您默认情况下没有包含（在我的情况下，1920
    x 1080，1080 x 1920，2778 x 1284，和1284 x 2778）：
- en: 'So, at this point, we can see that in a landscape ratio, it works fairly well,
    but let’s try a portrait one:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，到目前为止，我们可以看到在横屏比例下，它工作得相当好，但让我们尝试一个竖屏的：
- en: '![Figure 4.17 – Current Portrait view](img/Figure_4.17_B18868.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图4.17 – 当前竖屏视图](img/Figure_4.17_B18868.jpg)'
- en: Figure 4.17 – Current Portrait view
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.17 – 当前竖屏视图
- en: 'Oops! Currently, the text is overflowing past the bounds of the screen. Looks
    like will have to fix that:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！目前，文本已经溢出了屏幕的边界。看起来我们需要修复这个问题：
- en: Select the `200`.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`200`。
- en: 'Now, go to the `0.25` and `0.75`:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，转到`0.25`和`0.75`：
- en: '![Figure 4.18 – Setting the Anchors values](img/Figure_4.18_B18868.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图4.18 – 设置锚点值](img/Figure_4.18_B18868.jpg)'
- en: Figure 4.18 – Setting the Anchors values
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.18 – 设置锚点值
- en: Note that the and values. They have now been replaced with the and properties,
    which are currently set to `-338` and `-338`. This means that the area being taken
    up by this is `-338` units away from our anchor at 25%, and `-338` units away
    from our max anchor at 75%. We want the screen to resize to be at those anchors,
    so we will change both the and values to `0`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到和值。它们现在已经被和属性所取代，这些属性目前设置为`-338`和`-338`。这意味着这个区域距离我们的锚点25%处`-338`个单位，并且距离我们的最大锚点75%处`-338`个单位。我们希望屏幕调整大小以适应这些锚点，因此我们将两个和值都更改为`0`。
- en: 'Save our Scene as a new file inside the `Scenes` folder called `MainMenu`,
    and then play the game:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的场景保存为`Scenes`文件夹中的新文件，命名为`MainMenu`，然后玩游戏：
- en: '![Figure 4.19 – The title text automatically adjusts to fit the screen](img/Figure_4.19_B18868.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图4.19 – 标题文本自动调整以适应屏幕](img/Figure_4.19_B18868.jpg)'
- en: Figure 4.19 – The title text automatically adjusts to fit the screen
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.19 – 标题文本自动调整以适应屏幕
- en: As you can see in the preceding screenshot, the text now fits a lot nicer. You’ll
    also note that no matter what resolution we are using, this text takes up an amount
    of room that’s fitting for the game’s title. Now that we have the text displaying
    correctly, let’s add the ability to move from the main menu into the game properly.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的截图中所见，文本现在更适合。您也会注意到，无论我们使用什么分辨率，这段文本所占的空间都适合游戏的标题。现在我们已经正确显示了文本，让我们添加从主菜单正确进入游戏的功能。
- en: Working with buttons
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与按钮一起工作
- en: 'Unlike our title, for things that we want our players to touch, it’s a good
    idea to make the buttons the same size in each device, as our fingers are the
    same size, no matter what device we are using. To show a possible solution for
    this, we will create a new Canvas using a different scaling technique:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的标题不同，对于我们希望玩家触摸的东西，使按钮在每个设备中具有相同的大小是个好主意，因为无论我们使用什么设备，我们的手指大小都是一样的。为了展示一个可能的解决方案，我们将使用不同的缩放技术创建一个新的Canvas：
- en: Stop the game if it is currently running. We will first rename our current `Canvas
    - Scale w/Screen`. This way, we can easily tell whether we are using the correct
    Canvas for this or not.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果游戏正在运行，请停止游戏。我们首先将当前的`Canvas - Scale w/Screen`重命名。这样，我们可以很容易地判断我们是否正在使用正确的Canvas。
- en: 'Now that we have that one ready, we can create our new one. Go to the top menu
    bar and then select `Canvas - Scale Physical`. Then, under the **Canvas Scaler**
    component, change **UI Scale Mode** to **Constant** **Physical Size**:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了这个，我们可以创建新的一个。转到顶部菜单栏，然后选择`Canvas - Scale Physical`。然后，在**Canvas Scaler**组件下，将**UI
    Scale Mode**更改为**Constant Physical Size**：
- en: '![Figure 4.20 – Creating a Physical Canvas](img/Figure_4.20_B18868.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图4.20 – 创建物理Canvas](img/Figure_4.20_B18868.jpg)'
- en: Figure 4.20 – Creating a Physical Canvas
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.20 – 创建物理Canvas
- en: Using this method, Unity will attempt to scale the size of this Canvas so that
    each element has the same physical size, regardless of the resolution. Since we’re
    going for buttons that we intend to press with our fingers, this makes a lot of
    sense.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，Unity将尝试调整Canvas的大小，以便每个元素都具有相同的物理大小，而不管分辨率如何。由于我们打算制作可以用手指按下的按钮，这很有意义。
- en: Now, with this Canvas (**Canvas - Scale Physical**) selected in the **Hierarchy**
    view, go to the menu and select **GameObject** | **UI** | **Button - TextMeshPro**
    to create a new button inside this Canvas.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在**层次结构**视图中选择此Canvas（**Canvas - Scale Physical**），然后转到菜单并选择**GameObject**
    | **UI** | **Button - TextMeshPro**以在此Canvas内创建一个新按钮。
- en: Note
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can also do this by right-clicking on the `Canvas - Scale Physical`object
    from the **Hierarchy** window and selecting **UI | Button -** **TextMeshPro**.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过在**层次结构**窗口中右键单击`Canvas - Scale Physical`对象并选择**UI | Button -** **TextMeshPro**来做到这一点。
- en: 'At this point, you will see a new child object to called child also:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你将看到一个名为child的新子对象：
- en: "![Figure 4.21 – Showing off the Te\uFEFFxt (TMP) object](img/Figure_4.21_B18868.jpg)"
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图4.21 – 展示Text (TMP)对象](img/Figure_4.21_B18868.jpg)'
- en: Figure 4.21 – Showing off the Text (TMP) object
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.21 – 展示Text (TMP)对象
- en: The next question is, what size should our buttons be? Google suggests in their
    Material guidelines for Android that at least 48 x 48 for short), whereas, at
    their (**WWDC**), Apple recommended at least 44 x 44 dp. Either way, that comes
    somewhere around 8mm x 8mm, or 0.3 inches x 0.3 inches.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个问题是什么尺寸的按钮才合适？谷歌在其为Android提供的材料指南中建议至少为48 x 48（短），而苹果在其（**WWDC**）上推荐至少44
    x 44 dp。无论如何，这大约是8mm x 8mm，或者0.3英寸 x 0.3英寸。
- en: Note
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To read the material guidelines, check out [https://material.io/design/layout/spacing-methods.html#touch-click-targets](https://material.io/design/layout/spacing-methods.html#touch-click-targets).
    Or for Material 3’s guidelines, check out [https://m3.material.io/components/buttons/specs#85e63496-f905-4978-ae35-69ab83b70536](https://m3.material.io/components/buttons/specs#85e63496-f905-4978-ae35-69ab83b70536)
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要阅读材料指南，请查看[https://material.io/design/layout/spacing-methods.html#touch-click-targets](https://material.io/design/layout/spacing-methods.html#touch-click-targets)。或者，要查看Material
    3的指南，请查看[https://m3.material.io/components/buttons/specs#85e63496-f905-4978-ae35-69ab83b70536](https://m3.material.io/components/buttons/specs#85e63496-f905-4978-ae35-69ab83b70536)
- en: 'If you were to look at the game right now and check out some of the different
    resolution options, you may be a bit scared due to the size of the button, depending
    on the resolution:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在查看游戏并检查一些不同的分辨率选项，你可能会因为按钮的大小而有点害怕，这取决于分辨率：
- en: '![Figure 4.22 – Small button](img/Figure_4.22_B18868.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图4.22 – 小按钮](img/Figure_4.22_B18868.jpg)'
- en: Figure 4.22 – Small button
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.22 – 小按钮
- en: 'That’s because our button size is assuming that the (value to to see something
    closer to what we’ll use on our device when we play there:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们的按钮大小假设的是（值）在玩游戏时，我们将在设备上看到的东西更接近：
- en: '![Figure 4.23 – Game at a 16:9 aspect ratio](img/Figure_4.23_B18868.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图4.23 – 16:9宽高比的游戏](img/Figure_4.23_B18868.jpg)'
- en: Figure 4.23 – Game at a 16:9 aspect ratio
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.23 – 16:9宽高比的游戏
- en: Stop the game if it is currently running. Afterward, from the `Play`.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果游戏正在运行，请停止游戏。之后，从`Play`。
- en: Note
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you’re interested in finding out what the DPI for your devi[c](http://dpi.lv/)e
    is, check out [http://dpi.lv/](http://dpi.lv/).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感兴趣，想了解你的设备的DPI是多少，请查看[http://dpi.lv/](http://dpi.lv/)。
- en: Next, let’s make some adjustments to the **Button** object itself.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们对**按钮**对象本身做一些调整。
- en: From the `Play Button` at the top of the **Inspector** window to make it clear
    what the object is.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 从**检查器**窗口顶部的`Play Button`，使其清楚对象是什么。
- en: 'Next, go to the `0` to center the button in the middle of the screen. Afterward,
    the size of the button is quite large, so let’s change the `75``35`:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，转到`0`以将按钮居中于屏幕中间。之后，按钮的大小相当大，所以让我们将`75``35`更改为：
- en: '![Figure 4.24 – Adjusting the button’s size](img/Figure_4.24_B18868.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图4.24 – 调整按钮的大小](img/Figure_4.24_B18868.jpg)'
- en: Figure 4.24 – Adjusting the button’s size
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.24 – 调整按钮的大小
- en: We now have a button, but it doesn’t actually do anything yet. Let’s fix that
    now.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个按钮，但它实际上还没有做任何事情。让我们现在修复它。
- en: Let’s create a script to contain the functionality that we want. From the `Scripts``MainMenuBehaviour`.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个脚本来包含我们想要的功能。从`Scripts``MainMenuBehaviour`。
- en: 'Once your IDE has opened, use the following code:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你的IDE已经打开，使用以下代码：
- en: '[PRE0]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `LoadLevel` function will load a level based on the name that we provide
    to it making use of Unity’s Scene Manager, which we added using a statement at
    the top of our code so that we would have access to that namespace.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoadLevel`函数将根据我们提供的名称加载一个级别，利用Unity的场景管理器，我们通过在代码顶部添加一个语句来添加它，以便我们可以访问该命名空间。'
- en: Save the script and go back to the Unity editor. To call Unity’s UI events from
    the editor, we will need to have a game object with the `MainMenuBehaviour` component
    attached to it to call this function. We could use one of the currently existing
    objects, but we’ll just create a new object, making it easier to be found in the
    future.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本并返回到 Unity 编辑器。要从编辑器调用 Unity 的 UI 事件，我们需要有一个附加了 `MainMenuBehaviour` 组件的游戏对象来调用此函数。我们可以使用当前现有的对象之一，但我们将创建一个新的对象，这样在未来更容易找到它。
- en: 'With that in mind, create an empty game object (`Main Menu` and then add the
    `MainMenuBehaviour` script to it. Then, drag and drop it to the top of the **Hierarchy**
    tab to make it easier to access in the future and reset its position for the sake
    of neatness:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑到这一点，创建一个空的游戏对象（`Main Menu`），然后将其添加到 `MainMenuBehaviour` 脚本中。然后，将其拖放到 **Hierarchy**
    选项卡顶部，以便将来更容易访问，并为了整洁重置其位置：
- en: '![Figure 4.25 – Creating the Main Menu object](img/Figure_4.25_B18868.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.25 – 创建主菜单对象](img/Figure_4.25_B18868.jpg)'
- en: Figure 4.25 – Creating the Main Menu object
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.25 – 创建主菜单对象
- en: Select your **Play Button** object from **Hierarchy**, go to the **Inspector**
    tab, and scroll down to the **Button** component from there. Then, in the **On
    Click ()** section, click on the **+** icon to add something for our button to
    do.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **Hierarchy** 中选择你的 **Play Button** 对象，转到 **Inspector** 选项卡，并从那里向下滚动到 **Button**
    组件。然后，在 **On Click ()** 部分，点击 **+** 图标为我们的按钮添加一些操作。
- en: Then, drag and drop the **Main Menu** object from the **Hierarchy** tab into
    the area that currently says **None (Object)**, which is added to the list.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将 **Hierarchy** 选项卡中的 **Main Menu** 对象拖放到当前显示为 **None (Object)** 的区域，该区域已添加到列表中。
- en: 'Click on the dropdown that currently says `Gameplay`:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击当前显示为 `Gameplay` 的下拉菜单：
- en: '![Figure 4.26 – Adding functionality to the button](img/Figure_4.26_B18868.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.26 – 为按钮添加功能](img/Figure_4.26_B18868.jpg)'
- en: Figure 4.26 – Adding functionality to the button
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.26 – 为按钮添加功能
- en: 'Save your scene by going to **File | Save**. Lastly, open **Build Settings**
    as we did before by going to **File** | **Build Settings** and add our **MainMenu
    scene** to the list at index **0** by selecting **Add Open Scenes** and then dragging
    the **MainMenu** level to the top, so that the main menu level will be the scene
    that starts off when we start the game:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过访问 **文件 | 保存** 来保存你的场景。最后，像之前一样，通过访问 **文件** | **构建设置** 打开 **构建设置**，并将我们的 **MainMenu**
    场景添加到索引 **0** 的列表中，通过选择 **添加打开的场景** 并将 **MainMenu** 级别拖到顶部，这样主菜单级别将成为我们开始游戏时启动的场景：
- en: '![Figure 4.27 – Starting the game with the main menu](img/Figure_4.27_B18868.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.27 – 使用主菜单开始游戏](img/Figure_4.27_B18868.jpg)'
- en: Figure 4.27 – Starting the game with the main menu
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.27 – 使用主菜单开始游戏
- en: 'Save your project and Scene, then click on the **Play** button:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的项目和场景，然后点击 **播放** 按钮：
- en: '![Figure 4.28 – Current state of the main menu](img/Figure_4.28_B18868.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.28 – 主菜单当前状态](img/Figure_4.28_B18868.jpg)'
- en: Figure 4.28 – Current state of the main menu
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.28 – 主菜单当前状态
- en: 'At this point, our main menu is working well, and we can get into the game
    without any issues by clicking on the **Play** button:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的主菜单运行良好，我们可以通过点击 **Play** 按钮来无问题地进入游戏：
- en: '![Figure 4.29 – Current state of the gameplay scene](img/Figure_4.29_B18868.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.29 – 游戏场景当前状态](img/Figure_4.29_B18868.jpg)'
- en: Figure 4.29 – Current state of the gameplay scene
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.29 – 游戏场景当前状态
- en: 'Now that we have a foundational knowledge of the UI system and we have our
    title screen, we will move on to building something else that most games will
    need: a pause menu.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对 UI 系统有了基础的了解，并且我们有标题屏幕，我们将继续构建大多数游戏都需要的东西：暂停菜单。
- en: Adding a pause menu
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加暂停菜单
- en: 'When playing games, especially mobile games, there may come a time when you
    need to stop playing them at any moment. Having a pause menu will allow our players
    the convenience of deciding when they want to stop the game in its current state
    and resume it at a time that is convenient for them. This will also allow us to
    dive into some additional concepts in using Unity’s UI system, so with that in
    mind, let’s start building one:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在玩游戏时，尤其是移动游戏，可能会有需要随时停止游戏的时候。拥有一个暂停菜单将允许我们的玩家方便地决定何时停止当前游戏状态，并在对他们来说方便的时间重新开始游戏。这还将使我们能够深入探讨使用
    Unity 的 UI 系统的一些额外概念，因此，考虑到这一点，让我们开始构建一个：
- en: 'Open up the `Assets/Scenes` folder, and double-clicking on **Gameplay**, saving
    the **MainMenu** level if you didn’t do so already:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Assets/Scenes` 文件夹，双击 **Gameplay**，如果你还没有这样做，保存 **MainMenu** 级别：
- en: '![Figure 4.30 – Opening the Gameplay scene](img/Figure_4.30_B18868.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.30 – 打开游戏玩法场景](img/Figure_4.30_B18868.jpg)'
- en: Figure 4.30 – Opening the Gameplay scene
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.30 – 打开游戏玩法场景
- en: Before we worry about how we are going to open our pause menu, let’s go ahead
    and create the pause menu that we’ll be opening first.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们担心如何打开暂停菜单之前，让我们先创建我们将首先打开的暂停菜单。
- en: The first thing we’ll do is dim our screen when we enter the pause menu. An
    easy way to do that is to have an image scale to cover our entire screen, which
    is what the **Panel** object does by default. We can create it by selecting **Game
    Object** | **UI** | **Panel**. Note that this creates a **Canvas** object and
    an **EventSystem** object in addition to the **Panel** object, as one doesn’t
    exist in this scene already.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先要做的是在我们进入暂停菜单时降低屏幕亮度。一个简单的方法是让一个图像缩放以覆盖整个屏幕，这就是**面板**对象默认所做的。我们可以通过选择**游戏对象**
    | **UI** | **面板**来创建它。请注意，这除了创建**面板**对象外，还会创建一个**Canvas**对象和一个**EventSystem**对象，因为在这个场景中已经不存在**面板**对象了。
- en: 'Rename the `Pause` `Menu`. Then, with the object selected from the`178`:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Pause` `Menu`重命名。然后，从`178`选择对象：
- en: '![Figure 4.31 – Setting the Panel’s color](img/Figure_4.31_B18868.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.31 – 设置面板的颜色](img/Figure_4.31_B18868.jpg)'
- en: Figure 4.31 – Setting the Panel’s color
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.31 – 设置面板的颜色
- en: The component works in a similar manner to for 2D games, with information on
    an image to draw and the color to use for it.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件的工作方式与 2D 游戏类似，包括要绘制的图像上的信息和用于它的颜色。
- en: 'Switch to the **Game** window to get a better look at what the **Panel** object
    is doing to the screen. The current image has a thin border, which I’m not a fan
    of, in this case. You may keep it if you’d like, but I’m going to remove it and
    change the **Source Image** value to **None (Sprite)** by selecting the current
    one and pressing the *Delete* key:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到**游戏**窗口以更好地查看**面板**对象对屏幕所做的工作。当前图像有一个细边框，在这种情况下我不太喜欢。如果你愿意，你可以保留它，但我会将其移除，并将**源图像**值更改为**无（精灵**）通过选择当前项并按*Delete*键：
- en: '![Figure 4.32 – Creating the backdrop](img/Figure_4.32_B18868.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.32 – 创建背景](img/Figure_4.32_B18868.jpg)'
- en: Figure 4.32 – Creating the backdrop
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.32 – 创建背景
- en: Now that we have this, we will need to populate the menu with content. In this
    case, we will have a object saying that the game is paused, and some buttons allowing
    the player to resume, restart, or return to the main menu.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这个，我们需要用内容填充菜单。在这种情况下，我们将有一个对象表示游戏已暂停，以及一些按钮允许玩家继续、重新开始或返回主菜单。
- en: 'Let’s create another panel to hold our pause menu contents. We want this panel
    to be a child of our **Pause Menu** object, so we can do this easily by going
    to the **Hierarchy** window, right-clicking on **Pause Menu**, and selecting **UI**
    | **Panel**:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再创建一个面板来存放我们的暂停菜单内容。我们希望这个面板是**暂停菜单**对象的子对象，因此我们可以通过转到**层次结构**窗口，右键单击**暂停菜单**，然后选择**UI**
    | **面板**来轻松完成此操作：
- en: '![Figure 4.33 – Creating a child via the Hierarchy window](img/Figure_4.33_B18868.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.33 – 通过层次结构窗口创建子对象](img/Figure_4.33_B18868.jpg)'
- en: Figure 4.33 – Creating a child via the Hierarchy window
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.33 – 通过层次结构窗口创建子对象
- en: Now, for this panel, I don’t want it to take up the entire screen, so I will
    use another component to modify its size based on the resolution we receive. In
    this case, I will use an **Aspect Ratio** **Fitter** component.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于这个面板，我不想让它占据整个屏幕，所以我将使用另一个组件根据我们收到的分辨率来修改其大小。在这种情况下，我将使用**纵横比** **适配器**组件。
- en: In the `Aspect`. From there, select **Aspect Ratio Fitter** and then press the
    *Enter* key.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Aspect`中。从那里，选择**纵横比适配器**然后按*Enter*键。
- en: Afterward, go to our newly added component and change the value to `Fit In Parent`
    to ensure that the panel will always fit within our screen and set to `0.5`. This
    means that the panel will be twice as high as it is wide (width over height, which
    means ½ or `0.5`).
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，转到我们新添加的组件，并将值更改为`Fit In Parent`以确保面板始终适合屏幕，并设置为`0.5`。这意味着面板的高度将是宽度的两倍（宽度超过高度，即`½`或`0.5`）。
- en: If you go to the **Game** window and switch aspect ratios, you’ll note that
    the menu will stay in a similar shape.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你进入**游戏**窗口并切换纵横比，你会注意到菜单将保持相似的形状。
- en: Note
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on the **Aspect Ratio Fitter** component, check out [https://docs.unity3d.com/Manual/script-AspectRatioFitter.html](https://docs.unity3d.com/Manual/script-AspectRatioFitter.html).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 有关**纵横比适配器**组件的更多信息，请参阅[https://docs.unity3d.com/Manual/script-AspectRatioFitter.html](https://docs.unity3d.com/Manual/script-AspectRatioFitter.html)。
- en: This is good, but I don’t want to have the panel stuck directly to the edge
    of our screen, so we will make this object invisible by clicking on the checkmark
    by the **Image** component. This will disable the component and stop the component’s
    functionality.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这很好，但我不想让面板直接粘附到屏幕边缘，所以我们将通过点击 **图像** 组件旁边的勾选标记使此对象不可见。这将禁用组件并停止组件的功能。
- en: Then, right-click on the `Pause Menu Contents` and then change the `10`to give
    us a border around the screen.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，右键单击 `暂停菜单内容` 并将 `10` 改为在屏幕周围添加边框。
- en: 'We will use physical buttons like last time, so let’s move to the **Canvas**
    object, and under the **Canvas Scaler** component, change **UI Scale Mode** to
    **Constant** **Physical Size**:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用和上次一样的物理按钮，所以让我们转到 **画布** 对象，并在 **画布缩放器** 组件下，将 **UI 缩放模式** 更改为 **常量**
    **物理大小**：
- en: '![Figure 4.34 – Pause Menu Contents setup](img/Figure_4.34_B18868.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.34 – 暂停菜单内容设置](img/Figure_4.34_B18868.jpg)'
- en: Figure 4.34 – Pause Menu Contents setup
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.34 – 暂停菜单内容设置
- en: 'We could place everything manually as we did previously, but in this case,
    we may want to use another feature that Unity’s UI system has: layout groups.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像之前一样手动放置所有内容，但在这个情况下，我们可能想使用 Unity UI 系统的另一个功能：布局组。
- en: will resize the children of an object so that a component will automatically
    fit the area of the parent. There are several different layout groups, including
    grid-based, horizontal, and vertical layout groups. In our case, the menu will
    probably be vertical.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 将调整对象的子项大小，以便组件可以自动适应父项的区域。有几种不同的布局组，包括基于网格的、水平和垂直布局组。在我们的情况下，菜单可能将是垂直的。
- en: Important note
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: For more information on Unity’s way of automatically creating layouts, check
    out [https://docs.unity3d.com/Manual/UIAutoLayout.html](https://docs.unity3d.com/Manual/UIAutoLayout.html).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 Unity 自动创建布局的信息，请参阅 [https://docs.unity3d.com/Manual/UIAutoLayout.html](https://docs.unity3d.com/Manual/UIAutoLayout.html)。
- en: Select the `Vertical Layout Group` and select **Vertical Layout Group** by pressing
    the *Enter* key.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `垂直布局组` 并按 *Enter* 键选择 **垂直布局组**。
- en: Let’s create some children to fit into our menu. From the **Hierarchy** window,
    right-click on the **Pause Menu Contents** object and select **UI** | **Button
    -** **TextMeshPro**.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一些子项以适应我们的菜单。从 **层次结构** 窗口，右键单击 **暂停菜单内容** 对象，并选择 **UI** | **按钮 -** **TextMeshPro**。
- en: This creates a button, but you’ll note that it looks pretty much like a normal
    button. Let’s open up its child `Resume`. Then, we’ll check the `0`. To keep all
    of the button text on one line, we can also change the `5`.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将创建一个按钮，但你会注意到它看起来几乎和普通按钮一样。让我们打开它的子项 `Resume`。然后，我们检查 `0`。为了使所有按钮文本都在一行上，我们也可以更改
    `5`。
- en: Afterward, select the **Pause Menu Contents** object, and under the **Inspector**
    window, go to the **Vertical Layout Group (Script)** component and change the
    **Child Alignment** value to **Middle Center**. Then, change the **Child Control
    Size** value to have **Width** toggled.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，选择 **暂停菜单内容** 对象，在 **检查器** 窗口中，转到 **垂直布局组（脚本）** 组件，并将 **子项对齐** 值更改为 **居中**。然后，将
    **子项控制大小** 值更改为 **宽度** 开关。
- en: 'Then, in the `5`:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在 `5`：
- en: This will add five pixels of padding in each direction within all of the children
    of the layout group.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在布局组的所有子项的每个方向添加五个像素的填充。
- en: '![Figure 4.35 – Adding padding](img/Figure_4.35_B18868.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.35 – 添加填充](img/Figure_4.35_B18868.jpg)'
- en: Figure 4.35 – Adding padding
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.35 – 添加填充
- en: Now, duplicate this button twice and change the text to `Restart``Main Menu`.
    Then, to make it easy to tell the difference between them, let’s change the objects’
    names to `Resume Button`, `Restart Button`, and `Main` `Menu Button`.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，复制这个按钮两次，并将文本更改为 `Restart` 和 `Main Menu`。然后，为了容易区分它们，让我们将对象的名称更改为 `Resume
    Button`、`Restart Button` 和 `Main Menu Button`。
- en: 'Next, right-click on the `Paused``0``30`. Note how the order in which the children
    are placed in the hierarchy changes the order in which they are displayed. With
    that in mind, drag the **Text** object to the top:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，右键单击 `Paused` `0` `30`。注意子项在层次结构中的放置顺序会改变它们显示的顺序。考虑到这一点，将 **文本** 对象拖到顶部：
- en: '![Figure 4.36 – Pause Menu setup](img/Figure_4.36_B18868.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.36 – 暂停菜单设置](img/Figure_4.36_B18868.jpg)'
- en: Figure 4.36 – Pause Menu setup
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.36 – 暂停菜单设置
- en: This looks nice, but there’s also a lot of spacing here. So, if we’d like, we
    can instead condense the contents of our menu to just fit what we have there.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来不错，但这里也有很多间距。所以，如果我们想的话，我们可以将菜单的内容压缩到只适合我们那里。
- en: To do this, we can go to **Hierarchy** and select the **Pause Menu Contents**
    object and then add a **Content Size Fitter** component. Once it is added, we
    will change **Vertical Fit** to **Preferred Size**.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要做到这一点，我们可以转到**层次**并选择**暂停菜单内容**对象，然后添加一个**内容大小适配器**组件。一旦添加，我们将更改**垂直适配**为**首选大小**。
- en: '![Figure 4.37 – Effect of the preferred size option](img/Figure_4.37_B18868.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.37 – 预设大小选项的影响](img/Figure_4.37_B18868.jpg)'
- en: Figure 4.37 – Effect of the preferred size option
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.37 – 预设大小选项的影响
- en: 'This will scrunch all the buttons together, so we can change the `5` and add
    some space between the buttons:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这会将所有按钮挤在一起，因此我们可以更改`5`并在按钮之间添加一些空间：
- en: '![Figure 4.38 – Current view of the pause menu](img/Figure_4.38_B18868.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.38 – 暂停菜单的当前视图](img/Figure_4.38_B18868.jpg)'
- en: Figure 4.38 – Current view of the pause menu
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.38 – 暂停菜单的当前视图
- en: Now that we have the buttons themselves, let’s actually make them do something.
    In the `Scripts` folder and create a new C# script called `PauseScreenBehaviour`**,**
    and double-click on it to open up the IDE of your choice.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经有了按钮本身，让我们实际上让它们做些事情。在`Scripts`文件夹中创建一个新的 C# 脚本，命名为`PauseScreenBehaviour`**，**并双击它以打开您选择的
    IDE。
- en: 'Once it’s opened, use the following code:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦打开，使用以下代码：
- en: '[PRE1]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this script, we will first use a `static` variable, which is called `paused`.
    When we declare a `static` variable, we ensure that there will only ever be one
    of those variables inside this class, which all instances will share. One of the
    advantages of this is that we can access the property in other scripts using the
    class name followed by a period and then the attribute’s name (in this case, `PauseScreenBehaviour.paused`).
    We will use this concept later on when we want to open the menu through code.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，我们首先使用一个`static`变量，它被称为`paused`。当我们声明一个`static`变量时，我们确保在这个类内部只有一个这样的变量，所有实例都将共享。这个优点之一是我们可以使用类名后跟一个点然后是属性名（在这种情况下，`PauseScreenBehaviour.paused`）来访问属性。我们将在稍后想要通过代码打开菜单时使用这个概念。
- en: We then have two public functions, which we will call via the UI elements. First,
    we have a `Restart` function, which will use Unity’s Scene Manager to return us
    to the currently loaded level, effectively restarting the game. It is important
    to note that `static` variables do not reset when restarting in Unity, so that’s
    why I set `paused` to `false` in the `Start` function to ensure that when we come
    to the level, it is unpaused.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有两个公共函数，我们将通过 UI 元素来调用它们。首先，我们有一个`Restart`函数，它将使用 Unity 的场景管理器带我们回到当前加载的水平，从而有效地重新启动游戏。需要注意的是，在
    Unity 中重新启动时，`static`变量不会重置，这就是为什么我在`Start`函数中将`paused`设置为`false`，以确保当我们到达水平时，它是未暂停的。
- en: Finally, we have a `SetPauseMenu` function, which will turn the pause menu on
    or off based on the value of `isPaused`. It also sets the `Time.timeScale` property,
    where `0` means that nothing will happen and `1` means normal time. This property
    will modify the `Time.deltaTime`variable, effectively canceling out movement that
    we have as long as we use it.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个`SetPauseMenu`函数，它将根据`isPaused`的值打开或关闭暂停菜单。它还设置`Time.timeScale`属性，其中`0`表示不会发生任何事情，而`1`表示正常时间。这个属性将修改`Time.deltaTime`变量，实际上取消我们在使用它时所有的移动。
- en: Save your script and dive back into Unity.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存您的脚本，然后回到 Unity。
- en: Then, we’ll create a new empty game object by going to `Pause Screen Handler`
    and then attach the **Pause Screen Behaviour (Script)** component to it.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将在“暂停屏幕处理程序”中创建一个新的空游戏对象，并将其**暂停屏幕行为（脚本）**组件附加到它上面。
- en: 'Next, assign the **Pause Menu** variable to the **Pause Menu** game object
    in the **Hierarchy** tab:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在“层次”选项卡中将**暂停菜单**变量分配给**暂停菜单**游戏对象：
- en: '![Figure 4.39 – Assigning the Pause Menu property](img/Figure_4.39_B18868.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.39 – 分配暂停菜单属性](img/Figure_4.39_B18868.jpg)'
- en: Figure 4.39 – Assigning the Pause Menu property
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.39 – 分配暂停菜单属性
- en: Now that we have the script, we can now change the buttons to actually do something.
    Go to the **Inspector** window with the **Resume Button** object selected, go
    to the **Button** component’s **On Click ()** section, and click on the **+**
    button to add an action to occur.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了脚本，我们就可以更改按钮以实际执行某些操作了。选择**Resume Button**对象，转到**检查器**窗口，然后转到**按钮**组件的**On
    Click ()**部分，点击**+**按钮以添加要执行的操作。
- en: 'Drag and drop the `false` due to not being checked, so this should work for
    us:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于未勾选，因此将`false`拖放到此处，这应该对我们适用：
- en: '![Figure 4.40 – Calling the SetPauseMenu function from the Resume button](img/Figure_4.40_B18868.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.40 – 从**继续**按钮调用 SetPauseMenu 函数](img/Figure_4.40_B18868.jpg)'
- en: Figure 4.40 – Calling the SetPauseMenu function from the Resume button
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.40 – 从**继续**按钮调用 SetPauseMenu 函数
- en: Likewise, do the same for the `Restart`function.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，对`Restart`函数也进行相同的操作。
- en: Next, do the same for the `LoadLevel` and put the name of our main menu level
    in the string place (`MainMenu`, in my case).
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，对`LoadLevel`也进行相同的操作，并将我们主菜单级别的名称放在字符串位置（在我的例子中是`MainMenu`）。
- en: Note
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `PauseScreenHandler` script already contains `LoadLevel``MainMenuBehaviour`
    class.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`PauseScreenHandler`脚本已经包含了`LoadLevel`和`MainMenuBehaviour`类。'
- en: 'Save our game and go ahead and run it:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存游戏并运行它：
- en: '![Figure 4.41 – The current state of the game](img/Figure_4.41_B18868.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.41 – 游戏当前状态](img/Figure_4.41_B18868.jpg)'
- en: Figure 4.41 – The current state of the game
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.41 – 游戏当前状态
- en: As you can see in the preceding screenshot, if we start the game, the menu appears
    correctly—we can click the **Main Menu** button to get to the main menu, and **Resume**
    continues the game.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个屏幕截图所示，如果我们开始游戏，菜单会正确显示——我们可以点击**主菜单**按钮进入主菜单，**继续**会继续游戏。
- en: 'At this point, we have some issues: once the menu is gone, there is no way
    to get it back; the game should start unpaused, and the game should actually pause.
    Let’s tackle these issues next.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一些问题：一旦菜单消失，就没有办法再恢复它；游戏应该从未暂停的状态开始，实际上游戏应该暂停。让我们接下来解决这些问题。
- en: Pausing the game
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暂停游戏
- en: 'To get the game to pause correctly, we will tweak some scripts we’ve written
    previously using the following steps:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 要正确暂停游戏，我们将使用以下步骤调整我们之前编写的一些脚本：
- en: 'Open the `PlayerBehaviour` script and add the code highlighted in bold to the
    `FixedUpdate` function:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`PlayerBehaviour`脚本，并将以下加粗代码添加到`FixedUpdate`函数中：
- en: '[PRE2]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The added code makes it so that if the game is paused, we will not do anything
    within the function.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 添加的代码使得如果游戏被暂停，我们将在函数内不执行任何操作。
- en: 'We then also need to add the same script to the top of the `Update` function
    as well:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们还需要将相同的脚本添加到`Update`函数的顶部：
- en: '[PRE3]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Save your script and return to the Unity editor. Now, the game, by default,
    should be unpaused, so let’s go ahead and select the **Pause Menu** object in
    the **Hierarchy** view and then click on the active button in the **Inspector**
    view to disable it:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的脚本并返回到 Unity 编辑器。现在，游戏默认应该是未暂停的，所以让我们继续在**层次结构**视图中选择**暂停菜单**对象，然后在**检查器**视图中点击活动按钮来禁用它：
- en: '![Figure 4.42 – Disabling the pause menu](img/Figure_4.42_B18868.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.42 – 禁用暂停菜单](img/Figure_4.42_B18868.jpg)'
- en: Figure 4.42 – Disabling the pause menu
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.42 – 禁用暂停菜单
- en: Save your scene and then go ahead and play the game. While playing, hit the
    *Esc* key and you should see the pause menu appear and the game is paused! We
    can also use **Resume** or hit *Esc* again to resume the game.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的场景，然后继续玩游戏。在游戏过程中，按*Esc*键，你应该会看到暂停菜单出现，游戏被暂停！我们也可以使用**继续**或再次按*Esc*来恢复游戏。
- en: '![Figure 4.43 – The current state of the game](img/Figure_4.43_B18868.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.43 – 游戏当前状态](img/Figure_4.43_B18868.jpg)'
- en: Figure 4.43 – The current state of the game
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.43 – 游戏当前状态
- en: This is great, but it will only work if our player has a keyboard or controller
    attached to it. In the next chapter, we will see how we can have a button that
    players can click to turn on the menu. In addition, we may want to be able to
    move the player using some visual on-screen UI menu. That’s what we will tackle
    next.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但这只会在我们的玩家连接了键盘或控制器时才起作用。在下一章中，我们将看到如何有一个玩家可以点击以打开菜单的按钮。此外，我们可能还希望能够通过一些屏幕上的视觉
    UI 菜单来移动玩家。这就是我们接下来要解决的问题。
- en: Summary
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: With that, we’ve got a good foundation to build on when creating UI elements
    for a mobile game. We first covered how to create a title screen, making use of
    buttons and **Text** objects. We then covered how to use panels, buttons, text,
    and layout groups to make your menus adapt to the size of your elements. We also
    touched on how layout groups can arrange our objects to fit in a pleasing manner.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就为创建移动游戏的 UI 元素打下了良好的基础。我们首先介绍了如何创建标题屏幕，利用按钮和**文本**对象。然后，我们介绍了如何使用面板、按钮、文本和布局组来使你的菜单适应元素的大小。我们还简要介绍了布局组如何以令人愉悦的方式排列我们的对象。
- en: In the next chapter, we will continue our exploration of UIs for games by seeing
    how we can add a pause screen button and an on-screen joystick, and adapting our
    GUIs for notch devices.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续探索游戏用户界面（UIs），通过了解如何添加暂停屏幕按钮和屏幕上的摇杆，以及调整我们的GUI以适应刘海屏设备。
