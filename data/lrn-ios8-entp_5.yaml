- en: Chapter 5. Frameworks Introduced with iOS 8
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章。iOS 8 中引入的框架
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Working with PhotoKit
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 PhotoKit 的工作
- en: Handoff for resuming activities seamlessly among all devices
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在所有设备之间无缝恢复活动的 Handoff 功能
- en: Working with PhotoKit
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 PhotoKit 的工作
- en: One new feature in iOS 8 has been revealed; it is named **PhotoKit**, also known
    as Photos Framework. It's a new extension that lets developers work more effectively
    with photos and videos stored in the device.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 8 中的一项新功能已被揭晓；它被称为 **PhotoKit**，也称为照片框架。这是一个新的扩展，允许开发者更有效地与设备中存储的照片和视频工作。
- en: 'PhotoKit consists of the following two new frameworks:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: PhotoKit 由以下两个新的框架组成：
- en: '**Photos Framework**: This will allow developers to retrieve and edit photos
    and videos. It is responsible for handling changes made from external apps and
    also provides the tools to build a complete app, such as the Photos app that is
    available in iOS by default.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**照片框架**：这将允许开发者检索和编辑照片和视频。它负责处理来自外部应用所做的更改，并提供构建完整应用（如iOS默认提供的照片应用）的工具。'
- en: '**Photos UI**: This is responsible for providing the ability to create editing
    extensions—in other words, to edit photos with our custom app directly from the
    iOS Camera roll.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**照片用户界面**：这负责提供创建编辑扩展的能力——换句话说，就是可以直接从 iOS 相册中用我们的自定义应用编辑照片。'
- en: Photos Framework
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 照片框架
- en: Photos Framework provides tools to access, add, edit, and remove the model objects
    (images, videos, albums, and moments).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 照片框架提供了访问、添加、编辑和删除模型对象（图像、视频、相册和时刻）的工具。
- en: These model instances have a key characteristic—that is, they're read-only.
    So, for example, we can edit an image, and it won't modify the original content;
    however, it will create a new one.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模型实例有一个关键特性——那就是它们是只读的。所以，例如，我们可以编辑一个图像，它不会修改原始内容；然而，它将创建一个新的。
- en: 'The different model objects are as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的模型对象如下：
- en: '**Assets**: They refer to images and videos, and are represented by the `PHAsset`
    class. It gives the ability to specify the type of media content (photo or video),
    the date of creation, location, and whether it''s a favorite or not.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资产**：它们指的是图像和视频，由 `PHAsset` 类表示。它提供了指定媒体内容类型（照片或视频）、创建日期、位置以及是否为收藏夹的能力。'
- en: '**Asset collections**: They''re also called moments, and they refer to ordered
    collections of assets, such as albums and smart albums. These objects are represented
    by `PHAssetCollection`, and its properties are title, type, and the start and
    end dates.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资产集合**：它们也被称为时刻，指的是有序的资产集合，例如相册和智能相册。这些对象由 `PHAssetCollection` 表示，其属性包括标题、类型以及开始和结束日期。'
- en: '**Collection lists**: They''re an ordered collection of collections, and they
    usually represent a folder or a moment year. The class that manages them, `PHCollectionList`,
    stores the type, title, and the start and end dates of the list.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集合列表**：它们是有序的集合集合，通常代表文件夹或年份时刻。管理它们的类 `PHCollectionList` 存储列表的类型、标题以及开始和结束日期。'
- en: 'Photos Framework also introduces **Transient collections**, which reference
    a group of assets that are the result of a search or user selection, and can be
    used to interchange with common collections. One more thing to take into account
    when using this framework is that we will need to make use of class methods such
    as the following ones to work with assets:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 照片框架还引入了 **瞬态集合**，它们引用一组由搜索或用户选择产生的资产，并且可以与普通集合进行交换。在使用此框架时，还需要注意的一点是，我们将需要使用以下类方法等来处理资产：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Photos UI
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 照片用户界面
- en: Photos UI is a very interesting framework that allows us to create photo-editing
    extensions in our apps that will be available in the built-in Photos app.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 照片用户界面是一个非常有趣的框架，它允许我们在应用中创建照片编辑扩展，这些扩展将在内置的照片应用中可用。
- en: 'This means that, when editing an image in the Camera roll, we can choose which
    app we want to use for this purpose; the result of this editing will be available
    for other apps and devices through iCloud and won''t modify the original as it''s
    read-only. To achieve this, we will need to create an app extension target that
    will provide a view controller that, in turn, will adopt the `PHContentEditingController`
    protocol. This is pretty simple, as the new version of Xcode provides a template
    to create photo-editing extensions; we just need to focus on the implementation
    of the following protocol methods:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，当在相册中编辑图片时，我们可以选择我们想要使用的应用程序；此编辑的结果将通过 iCloud 对其他应用程序和设备可用，而不会修改原始内容，因为它只读。为了实现这一点，我们需要创建一个应用程序扩展目标，该目标将提供一个视图控制器，该控制器将采用
    `PHContentEditingController` 协议。这很简单，因为 Xcode 的新版本提供了一个创建照片编辑扩展的模板；我们只需要关注以下协议方法的实现：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can use Photos Framework to work with the photo and video assets managed
    by the Photos app, including the **iCloud Photo Library**. Use this framework
    to retrieve assets for display and playback, edit their image or video content,
    or work with collections of assets, such as albums, moments, and iCloud shared
    albums.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用照片框架来处理照片应用管理的照片和视频资产，包括 **iCloud 照片库**。使用此框架检索用于显示和播放的资产，编辑它们的图像或视频内容，或者处理资产集合，例如相册、时刻和
    iCloud 共享相册。
- en: Features of PhotoKit
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PhotoKit 的功能
- en: 'The features of PhotoKit are as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: PhotoKit 的功能如下：
- en: '**Fetching entities and requesting changes**: Instances of the Photos Framework
    model classes (`PHAsset`, `PHAssetCollection`, and `PHCollectionList`) represent
    the entities on which a user works within the Photos app. These entities are assets
    (images or videos), collections of assets (such as albums or moments), and lists
    of collections (such as album folders or moment clusters). These objects, also
    called photo entities, are read-only, immutable, and contain only metadata such
    as the asset''s media type and its creation date.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**获取实体和请求更改**：Photos 框架模型类的实例（`PHAsset`、`PHAssetCollection` 和 `PHCollectionList`）代表了用户在照片应用中工作的实体。这些实体是资产（图像或视频）、资产的集合（例如相册或时刻），以及集合的列表（例如相册文件夹或时刻集群）。这些对象也称为照片实体，是只读的、不可变的，并且只包含诸如资产的媒体类型和创建日期之类的元数据。'
- en: We work with assets and collections by fetching the photo entities we're interested
    in and then using these objects to fetch the data we need to work with. To make
    changes to photo entities, we create change request objects and explicitly commit
    them to the shared `PHPhotoLibrary` object. This architecture makes it easy, safe,
    and efficient to work with the same assets from multiple threads or multiple apps
    and app extensions.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们通过获取我们感兴趣的图片实体，然后使用这些对象来获取我们处理所需的数据来处理资产和集合。要更改照片实体，我们创建更改请求对象，并明确地将它们提交到共享的
    `PHPhotoLibrary` 对象。这种架构使得从多个线程或多个应用程序和应用程序扩展中处理相同的资产变得容易、安全且高效。
- en: '**Change observing**: Use the shared `PHPhotoLibrary` object to register a
    change handler for the photo entities you fetch. PhotoKit tells your app whenever
    another app or device changes the content or metadata of an asset or the list
    of assets in a collection. The `PHChange` objects provide information on the object
    state before and after each change, with semantics that make it easy to update
    a collection view or a similar interface.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**观察变化**：使用共享的 `PHPhotoLibrary` 对象为获取的图片实体注册一个变化处理器。PhotoKit 会通知您的应用程序，当其他应用程序或设备更改了资产的内容或元数据，或者更改了集合中资产的列表时。`PHChange`
    对象提供了关于每个变化前后对象状态的信息，这些语义使得更新集合视图或类似界面变得容易。'
- en: '**Support for Photos app features**: Use the `PHCollectionList` class to find
    assets corresponding to the moments hierarchy in the Photos app. Use the `PHAsset`
    class to identify burst photos, panoramic photos, and high-frame-rate videos.
    When the iCloud Photo Library is enabled, assets and collections in Photos Framework
    reflect the content available across all the devices on the same iCloud account.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持照片应用功能**：使用 `PHCollectionList` 类来查找与照片应用中时刻层次结构对应的资产。使用 `PHAsset` 类来识别连拍照片、全景照片和高帧率视频。当启用
    iCloud 照片库时，Photos 框架中的资产和集合反映了同一 iCloud 账户下所有设备上的内容。'
- en: '**Asset and thumbnail loading and caching**: Use the `PHImageManager` class
    to request images of assets in a specified size or AV Foundation objects to work
    with video assets. Photos Framework automatically downloads or generates images
    according to your specification, caching them for quick reuse. For faster performance
    with a large numbers of assets—for example, when populating a collection view
    with thumbnails—the `PHCachingImageManager` subclass adds bulk preloading.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资产和缩略图加载和缓存**：使用 `PHImageManager` 类请求指定大小的资产图像或使用 AV Foundation 对象处理视频资产。Photos
    框架会根据您的指定自动下载或生成图像，并将它们缓存以供快速重用。对于大量资产（例如，当用缩略图填充集合视图时）的更快性能，`PHCachingImageManager`
    子类添加了批量预加载功能。'
- en: '**Asset content editing**: The `PHAsset` and `PHAssetChangeRequest` classes
    define the methods to request photo or video content to edit and to commit your
    edits to the photo library. To support continuity of editing between different
    apps and extensions, Photos keeps the current and previous versions of each asset,
    along with the `PHAdjusmentData` object that describes the last edit. If your
    app supports adjustment data from a previous edit, you can allow the user to revert
    or alter the edit.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资产内容编辑**：`PHAsset` 和 `PHAssetChangeRequest` 类定义了请求编辑照片或视频内容的方法，并将您的编辑提交到照片库。为了支持在不同应用程序和扩展之间保持编辑的连续性，Photos
    会保留每个资产的当前版本和上一个版本，以及描述最后编辑的 `PHAdjusmentData` 对象。如果您的应用程序支持来自先前编辑的调整数据，您可以允许用户撤销或更改编辑。'
- en: 'There are a lot of classes for PhotoKit; we will discuss them in this table:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多 PhotoKit 类；我们将在下表中讨论它们：
- en: '| Classes | Description |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 类别 | 描述 |'
- en: '| --- | --- |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `PHAdjustmentData` | When a user edits an asset, Photos saves this object
    along with the modified image or video data |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `PHAdjustmentData` | 当用户编辑资产时，Photos 会保存此对象以及修改后的图像或视频数据 |'
- en: '| `PHAssetChangeRequest` | You can create and use this object within a photo
    library and change the block to create, delete, or modify `PHAsset` objects |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `PHAssetChangeRequest` | 您可以在照片库中创建和使用此对象，并更改块以创建、删除或修改 `PHAsset` 对象 |'
- en: '| `PHAssetCollectionChangeRequest` | You can create and use this object within
    a photo library and change the block to create, delete, or modify `PHAssetCollection`
    objects |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `PHAssetCollectionChangeRequest` | 您可以在照片库中创建和使用此对象，并更改块以创建、删除或修改 `PHAssetCollection`
    对象 |'
- en: '| `PHChange` | Photos provides this object to notify your app of any changes
    to the assets and collections managed by the Photos app |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `PHChange` | Photos 提供此对象以通知您的应用程序 Photos 应用程序管理的资产和集合的任何更改 |'
- en: '| `PHCollectionListChangeRequest` | You can create and use this object within
    a photo library and change the block to create, delete, or modify `PHCollectionList`
    objects |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `PHCollectionListChangeRequest` | 您可以在照片库中创建和使用此对象，并更改块以创建、删除或修改 `PHCollectionList`
    对象 |'
- en: '| `PHContentEditingInput` | This object describes an asset to be used for editing
    |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `PHContentEditingInput` | 此对象描述了用于编辑的资产 |'
- en: '| `PHContentEditingInputRequestOptions` | You can use this object to specify
    options when requesting to edit the image or video content of a `PHAsset` object
    |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `PHContentEditingInputRequestOptions` | 您可以使用此对象在请求编辑 `PHAsset` 对象的图像或视频内容时指定选项
    |'
- en: '| `PHContentEditingOutput` | This object represents the results of editing
    the photo or video content of a Photos asset |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `PHContentEditingOutput` | 此对象表示编辑 Photos 资产的照片或视频内容的结果 |'
- en: '| `PHFetchOptions` | You can use this object to specify options when using
    class methods on the `PHAsset`, `PHCollection`, `PHAssetCollection`, and `PHCollectionList`
    classes to retrieve photo entities |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `PHFetchOptions` | 您可以使用此对象在调用 `PHAsset`、`PHCollection`、`PHAssetCollection`
    和 `PHCollectionList` 类的方法时指定选项，以检索照片实体 |'
- en: '| `PHFetchResult` | This object is a container for an ordered list of photo
    entity objects |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `PHFetchResult` | 此对象是一个有序照片实体对象的容器 |'
- en: '| `PHFetchResultChangeDetails` | This object provides detailed information
    about the differences between two fetch results—the one that you previously obtained
    and the updated one that would be the result if you performed the same fetch again
    |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `PHFetchResultChangeDetails` | 此对象提供了有关两个检索结果之间差异的详细信息——您之前获得的那个和您再次执行相同检索将得到的更新后的那个
    |'
- en: '| `PHImageManager` | This is a shared object, and it provides methods to load
    images or video data associated with a `PHAsset` object |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `PHImageManager` | 这是一个共享对象，它提供了加载与 `PHAsset` 对象关联的图像或视频数据的方法 |'
- en: '| `PHCachingImageManager` | This object fetches or generates image data for
    photo or video assets. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `PHCachingImageManager` | 此对象用于获取或生成照片或视频资产的图像数据 |'
- en: '| `PHImageRequestOptions` | You can use this object to specify options when
    requesting image representations of photo assets from a `PHImageManager` object
    |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `PHImageRequestOptions` | 您可以使用此对象在从 `PHImageManager` 对象请求照片资源的图像表示时指定选项
    |'
- en: '| `PHObject` | This class is the abstract base class for photo-entity objects
    |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `PHObject` | 此类是照片实体对象的抽象基类 |'
- en: '| `PHAsset` | This object represents an image or video file that appears in
    the Photos app, including the iCloud Photos content |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `PHAsset` | 此对象表示在照片应用中出现的图像或视频文件，包括iCloud照片内容 |'
- en: '| `PHCollection` | This class is an abstract class that defines the behavior
    shared between the Photos collection classes |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `PHCollection` | 此类是一个抽象类，定义了照片集合类之间共享的行为 |'
- en: '| `PHAssetCollection` | This object represents a collection of photos or video
    assets |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `PHAssetCollection` | 此对象表示一组照片或视频资源 |'
- en: '| `PHCollectionList` | This object represents a group of asset collections
    |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `PHCollectionList` | 此对象表示一组资产集合 |'
- en: '| `PHObjectPlaceholder` | This object is a read-only proxy that represents
    an object yet to be created |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `PHObjectPlaceholder` | 此对象是一个只读代理，表示尚未创建的对象 |'
- en: '| `PHObjectChangeDetails` | This object provides detailed information about
    the differences between two states of a photo entity—one that you previously obtained
    and the updated state that would be the result if you fetched this entity again
    |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `PHObjectChangeDetails` | 此对象提供了关于照片实体两个状态之间差异的详细信息——一个是您之前获取的状态，另一个是您再次获取此实体时的更新状态
    |'
- en: '| `PHPhotoLibrary` | This is a shared object that represents the user''s Photos
    library—the entire set of assets and collections managed by the Photos app, including
    the objects stored in the local device and (if enabled) in iCloud Photos |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `PHPhotoLibrary` | 这是一个共享对象，表示用户的照片库——由照片应用管理的整个资产和集合集，包括存储在本地设备上的对象以及（如果启用）在iCloud照片中存储的对象
    |'
- en: '| `PHVideoRequestOptions`  | You can use this object to specify options when
    requesting video assets from a `PHImageManager` object |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `PHVideoRequestOptions`  | 您可以使用此对象在从 `PHImageManager` 对象请求视频资源时指定选项 |'
- en: 'PhotoKit makes it easy to query model data through a variety of fetch methods.
    For example, to retrieve all images, you can call `PFAsset.Fetch,` passing the
    `PHAssetMediaType.Image` media type:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: PhotoKit通过多种获取方法使查询模型数据变得简单。例如，要检索所有图像，您可以调用 `PFAsset.Fetch`，传递 `PHAssetMediaType.Image`
    媒体类型：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `PHFetchResult` instance will then contain all the `PFAsset` instances that
    represent images. To get the images themselves, you can use `PHImageManager` (or
    the caching version, `PHCachingImageManager`) to make a request for the image
    by calling `requestImageForAsset`. For example, the following code retrieves an
    image for each asset in `PHFetchResult` to display in a collection view cell.
    This example is in the Swift language, so we need to understand Swift. To begin
    with Swift in a better way, you can go to [http://www.raywenderlich.com/tutorials](http://www.raywenderlich.com/tutorials).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`PHFetchResult` 实例将包含所有代表图像的 `PFAsset` 实例。要获取图像本身，您可以使用 `PHImageManager`（或缓存版本，`PHCachingImageManager`）通过调用
    `requestImageForAsset` 来请求图像。例如，以下代码为 `PHFetchResult` 中的每个资产检索图像，以在集合视图单元格中显示。此示例使用Swift语言，因此我们需要了解Swift。为了更好地开始Swift，您可以访问
    [http://www.raywenderlich.com/tutorials](http://www.raywenderlich.com/tutorials)。'
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is how you handle querying and reading data. You can also write changes
    back to the library. Since multiple interested applications are able to interact
    with the system''s photo library, you can register an observer to be notified
    of any changes using `PhotoLibraryObserver`. Then, when changes come in, your
    application can update accordingly. For example, here''s a simple implementation
    for reloading the collection view:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是处理查询和读取数据的方式。您还可以将更改写回库中。由于多个感兴趣的应用程序能够与系统的照片库交互，您可以使用 `PhotoLibraryObserver`
    注册观察者以通知任何更改。然后，当有更改发生时，您的应用程序可以相应地更新。例如，以下是一个简单的实现，用于重新加载集合视图：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To actually write changes back from your application, you can create a change
    request. Each of the model classes has an associated change request class. For
    example, to change `PHAsset`, you can create `PHAssetChangeRequest`. The steps
    to perform changes that are written back to the photo library and sent to observers,
    like the preceding code, are as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际将更改从您的应用程序写回，您可以创建一个更改请求。每个模型类都有一个相关的更改请求类。例如，要更改 `PHAsset`，您可以创建 `PHAssetChangeRequest`。执行写回照片库并发送到观察者的更改的步骤如下：
- en: Perform the editing operation.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行编辑操作。
- en: Save the filtered image data to a `PHContentEditingOutput` instance.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将过滤后的图像数据保存到`PHContentEditingOutput`实例。
- en: Make a change request to publish the changes form the editing output.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提出更改请求以发布从编辑输出中更改的内容。
- en: 'Here''s an example that writes back a change to an image that applies a core
    image noir filter. You can also refer to [http://blog.xamarin.com/build-great-photo-experiences-in-ios-8-with-photokit/](http://blog.xamarin.com/build-great-photo-experiences-in-ios-8-with-photokit/)
    to understand in more detail:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例，将更改写回应用核心图像noir滤镜的图像。您还可以参考[http://blog.xamarin.com/build-great-photo-experiences-in-ios-8-with-photokit/](http://blog.xamarin.com/build-great-photo-experiences-in-ios-8-with-photokit/)以更详细地了解：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When the user selects the button, the filter is applied, as shown in the following
    screenshot:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择按钮时，应用过滤器，如下面的截图所示：
- en: '![Features of PhotoKit](img/1829OT_05_01.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![PhotoKit的功能](img/1829OT_05_01.jpg)'
- en: Thanks to `PHPhotoLibraryChangeObserver`, the change is reflected in the collection
    view when the user navigates back to the photo library.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了`PHPhotoLibraryChangeObserver`，当用户导航回照片库时，更改会在集合视图中反映出来。
- en: You can download the sample project from [https://github.com/mikebluestein/PhotoKitDemo](https://github.com/mikebluestein/PhotoKitDemo).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://github.com/mikebluestein/PhotoKitDemo](https://github.com/mikebluestein/PhotoKitDemo)下载示例项目。
- en: Handoff for seamlessly resuming activities
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无缝恢复活动的Handoff
- en: Handoff is a feature in OS X and iOS that extends the user experience of continuity
    across devices. Handoff enables users to begin an activity on one device and then
    switch to another device and resume the same activity there. For example, a user
    who is browsing a long article in Safari moves to an iOS device that's signed
    in to the same Apple ID; the same webpage now automatically opens in Safari on
    iOS, with the same scroll position as on the original device. Handoff makes this
    experience as seamless as possible.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Handoff是OS X和iOS中的一个功能，它扩展了跨设备的用户体验的连续性。Handoff允许用户在一个设备上开始一项活动，然后切换到另一个设备并继续在同一设备上完成该活动。例如，一个在Safari中浏览长篇文章的用户移动到已登录相同Apple
    ID的iOS设备；现在相同的网页在iOS的Safari中自动打开，滚动位置与原始设备相同。Handoff使这种体验尽可能无缝。
- en: To participate in Handoff, an app adopts a small API in foundation. Each ongoing
    activity in an app is represented by a user activity object that contains the
    data needed to resume an activity on another device. When the user chooses to
    resume this activity, the object is sent to the resuming device. Each user activity
    object has a delegate object that is invoked to refresh the activity state at
    opportune times, such as just before the user activity object is sent between
    devices.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要参与Handoff，一个应用采用基础库中的一个小API。应用中的每个持续活动都由一个包含恢复活动所需数据的用户活动对象表示。当用户选择恢复此活动时，该对象被发送到恢复设备。每个用户活动对象都有一个委托对象，在适当的时候被调用以刷新活动状态，例如在用户活动对象在设备之间发送之前。
- en: If continuing an activity requires more data than is easily transferred by the
    user activity object, the resuming app has the option to open a stream to the
    originating app. Document-based apps automatically support activity continuation
    for users working with iCloud-based documents. Apple apps use public APIs to implement
    Handoff for iOS 8 and OS X v10.10\. A third-party developer can use the same APIs
    to implement Handoff in apps that share the developer's team ID. Such apps must
    either be distributed through the App Store or signed by the registered developer.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果继续活动需要比用户活动对象容易传输的数据更多，恢复应用有选项打开到原始应用的流。基于文档的应用自动支持使用iCloud文档的用户的活动继续。Apple应用使用公共API实现iOS
    8和OS X v10.10的Handoff。第三方开发者可以使用相同的API在共享开发者团队ID的应用中实现Handoff。此类应用必须通过App Store分发或由注册的开发者签名。
- en: Compatibility with Handoff
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Handoff的兼容性
- en: 'First, let''s see what is compatible with Handoff:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看什么与Handoff兼容：
- en: iOS devices with a Lightning connector along with 2012 or later Mac models support
    Handoff. Both have radio chips that support both Bluetooth Low Energy and Wi-Fi
    Direct.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配备Lightning连接器的iOS设备和2012年或更新的Mac型号支持Handoff。两者都有支持蓝牙低功耗和Wi-Fi Direct的无线电芯片。
- en: If your device is compatible, you can enable Handoff in the **General** system
    preference on your Mac and in the **General** pane under the **Settings** app
    in iOS; in both cases, look for an option that includes the **Handoff** word.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您的设备兼容，您可以在Mac的**通用**系统偏好设置中以及iOS的**设置**应用下的**通用**面板中启用Handoff；在两种情况下，寻找包含**Handoff**一词的选项。
- en: All the devices have to be signed in to the same iCloud account. Handoff doesn't
    work with other users (this is what AirDrop is for).
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有设备都必须登录到相同的iCloud账户。Handoff不与其他用户一起工作（这是AirDrop的作用）。
- en: Finally, make sure that both Bluetooth and Wi-Fi are turned on for all devices.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，确保所有设备都打开了蓝牙和Wi-Fi。
- en: 'So far, Apple has announced that Handoff will work with the following apps:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，苹果公司宣布Handoff将与以下应用一起工作：
- en: Mail
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 邮件
- en: Safari
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Safari
- en: Pages
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 页面
- en: Numbers
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字
- en: Keynote
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 演示文稿
- en: Maps
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地图
- en: Messages
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息
- en: Reminders
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提醒
- en: Calendar
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日历
- en: Contacts
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联系人
- en: With them, we can start composing or reading an e-mail or website; editing a
    document, spreadsheet, or keynote; finding a location; typing a text; picking
    a reminder; entering an appointment; or looking up an address on your Mac and
    continuing or finishing it on your iPhone (iPad, or vice versa).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它们，我们可以开始撰写或阅读电子邮件或网站；编辑文档、电子表格或演示文稿；查找位置；输入文本；选择提醒；输入约会；或在您的Mac上查找地址，然后在iPhone（iPad或反之亦然）上继续或完成。
- en: App framework support
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用框架支持
- en: '**UIKit** and **AppKit** provide support for Handoff in the document, responder,
    and app delegate classes. Although there are minor behavioral differences between
    the platforms, the basic mechanism that enables the apps to save and restore user
    activities is the same, and the APIs are the same.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**UIKit**和**AppKit**在文档、响应者和应用代理类中提供了对Handoff的支持。尽管在不同平台之间存在一些行为上的细微差异，但使应用能够保存和恢复用户活动的根本机制是相同的，并且API也是相同的。'
- en: Handoff interactions
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Handoff交互
- en: 'Handing off a user activity involves the following three steps:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 传递用户活动涉及以下三个步骤：
- en: Create a user activity object for each activity in which the user is engaged.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为用户参与的每个活动创建一个用户活动对象。
- en: Update the user activity object regularly with information on what the user
    is doing.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定期更新用户活动对象，以包含用户正在执行的信息。
- en: Continue the user activity on a different device when the user requests it.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户请求时，在另一台设备上继续用户活动。
- en: Implementing Handoff directly
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 直接实现Handoff
- en: Adopting Handoff in your app requires you to write the code that use APIs in
    UIKit and AppKit to create a user activity object, update the state of the object
    to track the activity, and continue the activity on another device.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的应用中采用Handoff需要您编写使用UIKit和AppKit中的API创建用户活动对象、更新对象状态以跟踪活动，并在另一台设备上继续活动的代码。
- en: Creating the user activity object
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建用户活动对象
- en: Every user activity that can be handed off to a continuing device is represented
    by a user activity object instantiated from the `NSUserActivity` class. This class
    creates a user activity object for each user activity it supports. The types of
    those user activities depend on the app. For example, Safari lets the user to
    continue with the browser on the same site.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 每个可以被传递给继续使用的设备用户活动都由从`NSUserActivity`类实例化的用户活动对象表示。这个类为它支持的每个用户活动创建一个用户活动对象。这些用户活动的类型取决于应用。例如，Safari允许用户在相同网站上继续使用浏览器。
- en: The following code creates the instance of `NSUserActivity`. The `myacitvity.userinfo`
    object stores the current URL with the scroll position. The `becomeCurrent` object
    contains the current state of our project, and it is updating every second. Creating
    an object for the current state is necessary; otherwise, other devices won't understand
    from where to start.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码创建了`NSUserActivity`实例。`myactivity.userinfo`对象存储了当前的URL和滚动位置。`becomeCurrent`对象包含我们项目的当前状态，并且每秒更新一次。创建当前状态的对象是必要的；否则，其他设备将无法理解从哪里开始。
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After terminating or finishing the app, the user activity object will release
    automatically. Then the object is removed from all the devices.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在终止或完成应用后，用户活动对象将自动释放。然后该对象将从所有设备中删除。
- en: Specifying an activity type
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定活动类型
- en: The activity type identifier is a short string that appears in your app's `Info.plist`
    property list file in its `NSUserActivityTypes` array, which lists all the activity
    types that your app supports. The same string is passed when you create the activity,
    where the activity object is created with the activity type of `com.myCompany.myBrowser.browsing`,
    a reverse-DNS-style notation intended to avoid collisions. When the user chooses
    to continue the activity, the activity type (along with the app's team ID) determines
    which app to launch on the receiving device to continue the activity.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 活动类型标识符是一个短字符串，它出现在你的应用的`Info.plist`属性列表文件中的`NSUserActivityTypes`数组中，该数组列出了你的应用支持的所有活动类型。当你创建活动时，传递相同的字符串，此时活动对象以`com.myCompany.myBrowser.browsing`的活动类型创建，这是一种反向DNS风格的表示法，旨在避免冲突。当用户选择继续活动时，活动类型（以及应用的团队ID）确定在接收设备上启动哪个应用以继续活动。
- en: Note
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can specify the activity type of an `NSUserActivity` object when you create
    the instance. You cannot change the activity type of the object after it is created.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在创建实例时指定`NSUserActivity`对象的活动类型。创建后，你不能更改对象的活动类型。
- en: For example, a Reminders-style app serializes the reminder list the user is
    looking at. When the user clicks on a new reminder list, the app tracks that activity
    in `NSUserActivityDelegate`. The following code shows a possible implementation
    of a method that gets called whenever the user switches to a different reminder
    list. This app appends an activity name to the app's bundle identifier to create
    the activity type to use when it creates its `NSUserActivity` object.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个类似提醒事项的应用序列化用户正在查看的提醒列表。当用户点击新的提醒列表时，应用在`NSUserActivityDelegate`中跟踪该活动。以下代码显示了在用户切换到不同的提醒列表时被调用的方法的可能实现。此应用将活动名称追加到应用的捆绑标识符中，以创建在创建其`NSUserActivity`对象时使用的活动类型。
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding code uses the `setNeedsSave`: accessor method to mark the user
    activity object when it needs to be updated. This enables the system to coalesce
    updates and perform them lazily.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码使用了`setNeedsSave`访问器方法来标记用户活动对象，当它需要更新时。这使系统能够合并更新并延迟执行。
- en: Populating the activity object's user info dictionary
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 填充活动对象的用户信息字典
- en: 'The activity object has a user info dictionary that contains whatever data
    is needed to hand off the activity to the continuing app. The user info dictionary
    can contain `NSArray`, `NSDate`, `NSDictionary`, `NSNull`, `NSNumber`, `NSSet`,
    `NSString`, and `NSUrl` objects. The system modifies the `NSUrl` objects that
    use the `file:` scheme and point at iCloud documents to point to the same items
    in the corresponding container on the receiving device:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 活动对象有一个包含所需数据的用户信息字典，以便将活动传递给继续应用。用户信息字典可以包含`NSArray`、`NSDate`、`NSDictionary`、`NSNull`、`NSNumber`、`NSSet`、`NSString`和`NSUrl`对象。系统修改使用`file:`方案的`NSUrl`对象，并指向指向接收设备上相应容器中相同项的iCloud文档：
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Adopting Handoff in responders
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在响应者中采用手势传递
- en: 'You can associate responder objects (inheriting from `NSResponder` on OS X
    or `UIResponder` on iOS) with a given user activity if you set the activity as
    the responder''s `userActivity` property. The system automatically saves the `NSUserActivity`
    object at appropriate times, calling the responder''s `updateUserActivityState`:
    override to add current data to the user activity object using the activity object''s
    `userInfoEntriesFromDictionary`: method:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将活动设置为响应者的`userActivity`属性，你可以将响应者对象（在OS X上继承自`NSResponder`或在iOS上继承自`UIResponder`）与给定的用户活动关联。系统会在适当的时候自动保存`NSUserActivity`对象，调用响应者的`updateUserActivityState:`重写方法，使用活动对象的`userInfoEntriesFromDictionary:`方法将当前数据添加到用户活动对象中：
- en: '[PRE9]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Continuing an activity
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 继续活动
- en: Handoff automatically advertises user activities that are available to be continued
    on iOS and OS X devices that are in physical proximity to the originating device
    and signed in to the same iCloud account as the originating device. When the user
    chooses to continue a given activity, Handoff launches the appropriate app and
    sends the app delegate messages that determine how the activity is resumed using
    the `AppDelegate`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 手势传递自动宣传可在iOS和OS X设备上继续的活动，这些设备与原始设备物理邻近，并登录到与原始设备相同的iCloud账户。当用户选择继续某个活动时，手势传递启动相应的应用，并通过`AppDelegate`发送消息来确定如何使用`AppDelegate`恢复活动。
- en: Implement the `application:willContinueUserActivityWithType:` method to let
    the user know that the activity will continue shortly. Use the `application:continueUserActivity:restorationHandler:`
    method to configure the app to continue the activity. The system calls this method
    when the activity object, including the activity state data in its `userInfo`
    dictionary, is available to the continuing app.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 实现方法 `application:willContinueUserActivityWithType:` 以让用户知道活动将很快继续。使用 `application:continueUserActivity:restorationHandler:`
    方法来配置应用以继续活动。当活动对象及其 `userInfo` 字典中的活动状态数据对继续应用可用时，系统会调用此方法。
- en: Note
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For URLs transferred in the `userinfo` dictionary of an `NSUserActivity` object,
    we must call `startAccessingSecurityScopedResource`, and it must return `YES`
    before we can access the URL. Call `stopAccessingSecurityScopedResource` when
    you are done using the file.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在 `NSUserActivity` 对象的 `userinfo` 字典中传输的URL，我们必须调用 `startAccessingSecurityScopedResource`，并且它必须在我们可以访问URL之前返回
    `YES`。在完成文件使用后，调用 `stopAccessingSecurityScopedResource`。
- en: Exceptions to this requirement are URLs of `UIDocument` documents and those
    of `NSDocument` that are automatically created for `specifyingNSUbiquitousDocumentUserActivityType`
    apps and return NO from the `:continueUserActivity:restorationHandler:` application
    (or leave it unimplemented). See *Adopting Handoff in Document-Based Apps* at
    [https://developer.apple.com/library/mac/documentation/UserExperience/Conceptual/Handoff/AdoptingHandoff/AdoptingHandoff.html#//apple_ref/doc/uid/TP40014338-CH2-SW17](https://developer.apple.com/library/mac/documentation/UserExperience/Conceptual/Handoff/AdoptingHandoff/AdoptingHandoff.html#//apple_ref/doc/uid/TP40014338-CH2-SW17).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此要求的例外是 `UIDocument` 文档的URL和为 `specifyingNSUbiquitousDocumentUserActivityType`
    应用自动创建的 `NSDocument` 的URL，这些URL从 `:continueUserActivity:restorationHandler:` 应用返回
    NO（或者留空不实现）。请参阅 [https://developer.apple.com/library/mac/documentation/UserExperience/Conceptual/Handoff/AdoptingHandoff/AdoptingHandoff.html#//apple_ref/doc/uid/TP40014338-CH2-SW17](https://developer.apple.com/library/mac/documentation/UserExperience/Conceptual/Handoff/AdoptingHandoff/AdoptingHandoff.html#//apple_ref/doc/uid/TP40014338-CH2-SW17)
    中的 *在基于文档的应用中采用Handoff*。
- en: 'Additional configuration of your app to continue the activity can optionally
    be performed by objects you give to the restoration handler block that is passed
    in with the `application:continueUserActivity:restorationHandler:` message. The
    following code shows a simple implementation of this method:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将对象传递给与 `application:continueUserActivity:restorationHandler:` 消息一起传递的恢复处理程序块来选择性地执行应用以继续活动的额外配置。以下代码展示了此方法的简单实现：
- en: '[PRE10]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this case, the app delegate has an array of `NSWindowController` objects,
    `windowControllers`. These window controllers know how to configure all of the
    app's windows to resume the activity. After you pass this array to the `restorationHandler`
    block, Handoff sends each of those objects a `restoreUserActivityState:` message,
    passing in the resuming activity's `NSUserActivity` object. The window controllers
    inherit the `restoreUserActivityState:` method from `NSResponder`; each controller
    object overrides this method to configure its window, using the information in
    the activity object's `userInfo` dictionary.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，应用代理有一个 `NSWindowController` 对象数组 `windowControllers`。这些窗口控制器知道如何配置应用的所有窗口以恢复活动。在将此数组传递给
    `restorationHandler` 块之后，Handoff 会向这些对象中的每一个发送一个 `restoreUserActivityState:` 消息，传递恢复活动的
    `NSUserActivity` 对象。窗口控制器从 `NSResponder` 继承了 `restoreUserActivityState:` 方法；每个控制器对象都重写此方法以配置其窗口，使用活动对象
    `userInfo` 字典中的信息。
- en: To support graceful failure, the app delegate should implement the `application:didFailToContinueUserActivityWithType:error:`
    method. If you don't implement this method, the app framework, nonetheless, displays
    diagnostic information contained in the passed-in `NSError` object.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持优雅的失败，应用代理应该实现 `application:didFailToContinueUserActivityWithType:error:`
    方法。如果您不实现此方法，应用框架仍然会显示包含在传入的 `NSError` 对象中的诊断信息。
- en: Note
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `UIApplicationDelegate` methods for Handoff described in this section are
    not called when either of the application delegate methods, `application:willFinishLaunchingWithOptions:`
    or `application:didFinishLaunchingWithOptions:`, returns NO.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中描述的用于Handoff的 `UIApplicationDelegate` 方法，当任一应用代理方法 `application:willFinishLaunchingWithOptions:`
    或 `application:didFinishLaunchingWithOptions:` 返回 NO 时，不会被调用。
- en: Native App-to-Web Browser Handoff
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原生应用到网页浏览器Handoff
- en: When using a native app on the originating device, the user might want to continue
    the activity on a corresponding native app. If there is a web page that corresponds
    to the activity, it can still be handed off. For example, video library apps enable
    users to browse movies available for viewing, and mail apps enable users to read
    and compose e-mails. In many cases, users can perform the same activity through
    a web page interface. In this case, the native app knows the URL for the web interface,
    possibly including syntax that designates a particular video being browsed or
    message being read. So, when the native app creates the `NSUserActivity` object,
    it sets the `webpageURL` property. If the receiving device doesn't have an app
    that supports the user activity's `activityType` property, it can resume the activity
    in the default web browser of the continuing platform.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当在原始设备上使用原生应用时，用户可能希望在相应的原生应用中继续活动。如果有与活动相对应的网页，它仍然可以被传递。例如，视频库应用允许用户浏览可观看的电影，而邮件应用允许用户阅读和撰写电子邮件。在许多情况下，用户可以通过网页界面执行相同的活动。在这种情况下，原生应用知道网页界面的URL，可能包括指定正在浏览的视频或正在阅读的消息的语法。因此，当原生应用创建`NSUserActivity`对象时，它会设置`webpageURL`属性。如果接收设备没有支持用户活动`activityType`属性的应用，它可以在继续平台的默认网络浏览器中恢复活动。
- en: A web browser on OS X that wants to continue an activity in this way should
    claim the `NSUserActivityTypeBrowsingWeb` activity type (by entering this string
    in its `NSUserActivityTypes` array in the app's `Info.plist` property list file).
    This ensures that, if the user selects any other browser as their default browser,
    it receives the activity object instead of Safari.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 想以这种方式继续活动的OS X网络浏览器应声明`NSUserActivityTypeBrowsingWeb`活动类型（通过在应用的`Info.plist`属性列表文件中的`NSUserActivityTypes`数组中输入此字符串）。这确保了，如果用户选择任何其他浏览器作为他们的默认浏览器，它将接收活动对象而不是Safari。
- en: Web Browser-to-Native App Handoff
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络浏览器到原生应用的手动传递
- en: In the opposite case, if the user is using a web browser on the originating
    device and the receiving device is an iOS device with a native app that claims
    the domain portion of the `webpageURL` property, then iOS launches the native
    app and sends it an `NSUserActivity` object with an `activityType` value of `NSUserActivityTypeBrowsingWeb`.
    The `webpageURL` property contains the URL that the user was visiting, while the
    `userInfo` dictionary is empty.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在相反的情况下，如果用户在原始设备上使用网络浏览器，而接收设备是一个具有声明`webpageURL`属性域名部分的原生应用（iOS设备），那么iOS将启动原生应用并向其发送一个`activityType`值为`NSUserActivityTypeBrowsingWeb`的`NSUserActivity`对象。`webpageURL`属性包含用户正在访问的URL，而`userInfo`字典为空。
- en: The native app on the receiving device must adapt to this behavior by claiming
    a domain in the `com.apple.developer.associated-domains` entitlement. The value
    of this entitlement has the `<service>:<fully qualified domain name>` format,
    for example, `activitycontinuation:example.com`. In this case, the service must
    be `activitycontinuation`. Add the value for the `com.apple.developer.associated-domains`
    entitlement in Xcode in the **Associated Domains** section under the **Capabilities**
    tab of the **Target** settings.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接收设备上的原生应用必须通过在`com.apple.developer.associated-domains`权限中声明一个域名来适应这种行为。此权限的值具有`<service>:<fully
    qualified domain name>`格式，例如，`activitycontinuation:example.com`。在这种情况下，服务必须是`activitycontinuation`。在Xcode中，在**Target**设置的**Capabilities**标签下的**Associated
    Domains**部分添加`com.apple.developer.associated-domains`权限的值。
- en: If this domain matches the `webpageURL` property, Handoff downloads a list of
    approved app IDs from the domain. Domain-approved apps are authorized to continue
    the activity. On your website, you can list the approved apps in a signed JSON
    file named `apple-app-site-association`; for example, the web address becomes
    `https://example.com/apple-app-site-association` (you must use an actual device
    rather than the simulator to test download the JSON file).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此域名与`webpageURL`属性匹配，手动传递将下载来自域的批准应用ID列表。域批准的应用有权继续活动。在您的网站上，您可以在名为`apple-app-site-association`的签名JSON文件中列出批准的应用；例如，网页地址变为`https://example.com/apple-app-site-association`（您必须使用实际设备而不是模拟器来测试下载JSON文件）。
- en: 'The JSON file contains a dictionary that specifies a list of app identifiers
    in the `<team identifier>.<bundle identifier>` format in the **General** tab of
    the **Target** settings—for example, `YWBN8XTPBJ.com.example.myApp`. The following
    code shows an example of such a JSON file formatted for reading:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 文件包含一个字典，该字典指定了在 **目标** 设置的 **常规** 选项卡中 `<team identifier>.<bundle identifier>`
    格式的应用程序标识符列表，例如 `YWBN8XTPBJ.com.example.myApp`。以下代码显示了一个格式化的 JSON 文件示例，用于读取：
- en: '[PRE11]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To sign the JSON file (so that it is returned from the server with the correct
    content-type of `application/pkcs7-mime`), put the content in a text file and
    sign it. You can perform this task with terminal commands such as those shown
    in the following code, by removing the whitespace from the text for ease of manipulation.
    Use the `openssl` command with the certificate and key for an identity issued
    by a certificate authority trusted by iOS (which is listed at [http://support.apple.com/kb/ht5012](http://support.apple.com/kb/ht5012)).
    It need not be the same identity that hosts the web credentials (`https://example.com`
    in the example code), but it must be a valid TLS certificate for the domain name
    in question:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要对 JSON 文件进行签名（以便它从服务器返回时带有正确的 `application/pkcs7-mime` 内容类型），请将内容放入一个文本文件并对其进行签名。您可以使用以下代码中显示的终端命令等执行此任务，通过删除文本中的空白字符以方便操作。使用
    `openssl` 命令和由受 iOS 信任的证书颁发机构签发的身份证书和密钥（在 [http://support.apple.com/kb/ht5012](http://support.apple.com/kb/ht5012)
    中列出）。它不必是托管 Web 凭证的同一身份（例如示例代码中的 `https://example.com`），但它必须是针对所涉及域名的有效 TLS 证书：
- en: '[PRE12]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The output of the `openssl` command is the signed JSON file that you put on
    your website at the `apple-app-site-association` URL—in this example, `https://example.com/apple-app-site-association`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`openssl` 命令的输出是您放在网站上的签名 JSON 文件，位于 `apple-app-site-association` URL 上——在本例中为
    `https://example.com/apple-app-site-association`。'
- en: An app can set the `webpageURL` property to any web URL, but it only receives
    activity objects whose `webpageURL` domain is in the `com.apple.developer.associated-domains`
    entitlement. Also, the scheme of the `webpageURL` must be `http` or `https`. Any
    other scheme throws an exception.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以将 `webpageURL` 属性设置为任何 Web URL，但它只能接收 `webpageURL` 域在 `com.apple.developer.associated-domains`
    权限中的活动对象。此外，`webpageURL` 的方案必须是 `http` 或 `https`。任何其他方案都会抛出异常。
- en: Using continuation streams
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用延续流
- en: 'If resuming an activity requires more data than can be efficiently transferred
    by the initial Handoff payload, a continuing app can call back to the originating
    app''s activity object to open streams between the apps and transfer more data.
    In this case, the originating app sets its `NSUserActivity` object''s Boolean
    property, `supportsContinuationStreams`, to `YES`, sets the user activity delegate,
    and then calls `becomeCurrent`, as shown in the following code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果恢复活动需要比初始 Handoff 有效载荷能够有效传输的数据更多，则延续应用程序可以回调到原始应用程序的活动对象以在应用程序之间打开流并传输更多数据。在这种情况下，原始应用程序将其
    `NSUserActivity` 对象的布尔属性 `supportsContinuationStreams` 设置为 `YES`，设置用户活动代理，然后调用
    `becomeCurrent`，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'On the continuing device, after users indicate that they want to resume the
    activity, the system launches the appropriate app and begins sending messages
    to the app delegate. The app delegate can then request streams back to the originating
    app by sending the `getContinuationStreamsWithCompletionHandler` message to its
    user activity object, as shown in the override implementation in the following
    code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续使用的设备上，在用户表示他们想要恢复活动后，系统将启动相应的应用程序并开始向应用程序代理发送消息。然后应用程序代理可以通过向其用户活动对象发送 `getContinuationStreamsWithCompletionHandler`
    消息来请求将流返回到原始应用程序，如下面的代码覆盖实现所示：
- en: '[PRE14]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: On the originating device, the user activity delegate receives the streams in
    a callback to its `userActivity:didReceiveInputStream:outputStream` method, which
    it implements to provide the data needed to continue the user activity on the
    resuming device using the streams.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始设备上，用户活动代理在其 `userActivity:didReceiveInputStream:outputStream` 方法的回调中接收流，它实现了该方法以提供在恢复设备上使用流继续用户活动所需的数据。
- en: '`NSInputStream` provides read-only access to stream data, and `NSOutputStream`
    provides write-only access. Therefore, data written to the output stream on the
    originating side is read from the input stream on the continuing side; and vice
    versa. Streams are meant to be used in a request-and-response fashion, that is,
    the continuing side uses the streams to request more continuation data from the
    originating side, which then uses the streams to provide the requested data.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSInputStream` 提供了对流数据的只读访问，而 `NSOutputStream` 提供了只写访问。因此，在原始端写入输出流的数据，将在继续端从输入流中读取；反之亦然。流设计用于请求-响应模式，也就是说，继续端使用流从原始端请求更多续传数据，然后原始端使用流提供所需数据。'
- en: Continuation streams are an optional feature of Handoff; most user activities
    do not need them for successful continuation. Even when streams are needed, in
    most cases there should be minimal back-and-forth between the apps. A simple request
    from the continuing app accompanied by a response from the originating app should
    be enough for most continuation events. You can download the sample project from
    [https://github.com/dokterdok/Continuity-Activation-Tool](https://github.com/dokterdok/Continuity-Activation-Tool).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 续传流是 Handoff 的一个可选功能；大多数用户活动不需要它们来实现成功的续传。即使需要流，在大多数情况下，应用之间应该有最少的来回交互。一个简单的请求来自继续应用，并伴随来自原始应用的响应，对于大多数续传事件来说应该就足够了。你可以从
    [https://github.com/dokterdok/Continuity-Activation-Tool](https://github.com/dokterdok/Continuity-Activation-Tool)
    下载示例项目。
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed the new iOS 8 APIs and little code snippets of
    Swift. You learned about the PhotoKit framework and Handoff with some code snippets.
    In the next chapter, we will discuss iCloud and security services in iOS, together
    with their implementations.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了新的 iOS 8 API 和 Swift 的简短代码片段。你学习了 PhotoKit 框架和 Handoff，并附带了一些代码片段。在下一章中，我们将讨论
    iOS 中的 iCloud 和安全服务，以及它们的实现。
