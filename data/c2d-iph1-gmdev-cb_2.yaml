- en: Chapter 2. User Input
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. 用户输入
- en: 'In this chapter, we will cover the following points:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: Tap, hold, and drag input
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击、长按和拖动输入
- en: Depth testing input
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深度测试输入
- en: Creating buttons
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建按钮
- en: Creating a directional pad
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建方向盘
- en: Creating an analog stick
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建模拟摇杆
- en: Using the accelerometer for steering
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用加速度计进行转向
- en: Using the accelerometer for 3D rotation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用加速度计进行 3D 旋转
- en: Pinch zooming
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捏合缩放
- en: Performing gestures
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行手势
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Without user input a video game is merely a tech demo. iOS touch devices allow
    limitless customization of user input. In this chapter, we will cover the most
    common input methods using both the **touch screen** and the **accelerometer**.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 没有用户输入，视频游戏仅仅是一个技术演示。iOS 触摸设备允许对用户输入进行无限定制的自定义。在本章中，我们将介绍使用 **触摸屏** 和 **加速度计**
    的最常见输入方法。
- en: Tap, hold, and drag input
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点击、长按和拖动输入
- en: '**Tapping, holding**, and **dragging** are the most commonly used input techniques.
    They form the basic building blocks of input for user interfaces as well as for
    interacting with game objects. In this recipe, we subclass `CCSprite` in order
    to create a sprite which can process touch events and maintain some custom state
    information. This, plus some logic, allows us to touch, hold, and drag this sprite.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**点击、长按** 和 **拖动** 是最常用的输入技术。它们构成了用户界面输入以及与游戏对象交互的基本构建块。在本菜谱中，我们通过继承 `CCSprite`
    来创建一个可以处理触摸事件并保持一些自定义状态信息的精灵。这，加上一些逻辑，使我们能够触摸、长按和拖动这个精灵。'
- en: '![Tap, hold, and drag input](img/4002_02_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![点击、长按和拖动输入](img/4002_02_01.jpg)'
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection01* for full working code of this
    recipe.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目 *RecipeCollection01* 以获取此菜谱的完整工作代码。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Execute the following code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works...
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'First, we create the `ColorTouchSprite` class by sub-classing `CCSprite`. Here
    is where we maintain state variables to let us differentiate between a tap, a
    hold, and a drag. We also specify a `(CGRect)rect` method. This is used to determine
    whether or not the sprite was touched. The main recipe layer passes touch event
    information to this sprite using the following three methods:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过继承 `CCSprite` 创建 `ColorTouchSprite` 类。在这里，我们维护状态变量，以便我们能够区分点击、长按和拖动。我们还指定了一个
    `(CGRect)rect` 方法。这个方法用于确定精灵是否被触摸。主菜谱层使用以下三个方法将触摸事件信息传递给这个精灵：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These methods are fairly straightforward. Whenever we touch the layer we call
    `ccTouchesBegan`. When we move we call `ccTouchesMoved`. Finally, when we lift
    a finger up we call `ccTouchesEnded`. Each method does a `pointIsInRect` check
    and then calls the requisite touches method on the sprite. Finally, the sprite
    runs some simple logic to determine state and to allow dragging of the sprite.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法相当直接。每次我们触摸层时，我们调用 `ccTouchesBegan`。当我们移动时，我们调用 `ccTouchesMoved`。最后，当我们抬起手指时，我们调用
    `ccTouchesEnded`。每个方法都执行 `pointIsInRect` 检查，然后调用精灵上的相应触摸方法。最后，精灵运行一些简单的逻辑来确定状态，并允许拖动精灵。
- en: There's more...
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The technique used previously is not the only way to capture input. Cocos2d
    also provides the `CCTouchDispatcher` class. With this you can implement methods
    in the `CCTargetedTouchDelegate` protocol and assign a delegate object to automatically
    handle your touch input.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 之前使用的技术并非捕获输入的唯一方式。Cocos2d 还提供了 `CCTouchDispatcher` 类。使用这个类，你可以实现 `CCTargetedTouchDelegate`
    协议中的方法，并将代理对象分配给自动处理你的触摸输入。
- en: See also...
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容...
- en: For more information on this method please consult the official Cocos2d documentation
    and the Cocos2d forum.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此方法的更多信息，请参阅官方 Cocos2d 文档和 Cocos2d 论坛。
- en: Depth testing input
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深度测试输入
- en: Handling input manually like in the previous recipe gives us the opportunity
    to manage touchable objects at a high level. Using an array of sprites sorted
    by Z order we can "swallow the input" so that background sprites aren't affected.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 手动处理输入，如前一个菜谱所示，给我们提供了在高级别管理可触摸对象的机会。使用按 Z 轴顺序排序的精灵数组，我们可以“吞没输入”，这样背景精灵就不会受到影响。
- en: '![Depth testing input](img/4002_02_02.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![深度测试输入](img/4002_02_02.jpg)'
- en: Getting ready
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection01* for full working code of this
    recipe.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目 *RecipeCollection01* 以获取此菜谱的完整工作代码。
- en: How to do it...
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Execute the following code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Our array of sprites has a **node order** which corresponds directly to their
    **Z order**. So, looping through these sprites does implicit **depth testing**.
    When a sprite touch begins we swallow the input allowing only that sprite to be
    touched.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的精灵数组有一个**节点顺序**，这直接对应于它们的**Z**顺序。因此，遍历这些精灵会进行隐式的**深度测试**。当一个精灵触摸开始时，我们吞下输入，只允许触摸那个精灵。
- en: 'Caveats:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意事项：
- en: The only caveat to this technique is that input depth testing is tied to sprite
    array order. Any modification of sprite **Z** order requires a **re-sorting**
    of nodes in the array.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种技术的唯一注意事项是，输入深度测试与精灵数组顺序相关联。任何对精灵**Z**顺序的修改都需要对数组中的节点进行**重新排序**。
- en: Creating buttons
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建按钮
- en: '**Buttons** in one form or another are used in most games. It is easy to implement
    a simple button solution using Cocos2d but creating one that supports **multiple
    simultaneous button touches** is more difficult. In this recipe, we will implement
    a simple but effective solution to this problem.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**按钮**以某种形式被用于大多数游戏中。使用Cocos2d实现一个简单的按钮解决方案很容易，但创建一个支持**多指同时触摸**的按钮则更困难。在这个菜谱中，我们将实现一个简单但有效的解决方案来解决这个问题。'
- en: '![Creating buttons](img/4002_02_03.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![创建按钮](img/4002_02_03.jpg)'
- en: Getting ready
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection01* for full working code of this
    recipe.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅项目*RecipeCollection01*以获取此菜谱的完整工作代码。
- en: How to do it...
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Execute the following code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe uses a couple of different classes, all derived from `CCSprite`,
    to create realistic buttons. These buttons can all be touched independently.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱使用几个不同的类，所有这些类都从`CCSprite`派生，来创建逼真的按钮。这些按钮都可以独立触摸。
- en: 'Touching multiple buttons independently:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立触摸多个按钮：
- en: 'To get multiple-button touching working, first we call the following method
    on our main `UIWindow` in our `AppDelegate` file:'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要使多按钮触摸工作，我们首先在我们的`AppDelegate`文件中的主`UIWindow`上调用以下方法：
- en: '[PRE4]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Then our `TouchableSprite` class uses the hash variable that uniquely identifies
    each `UITouch` object that passes through a `ccTouches` method. This way we can
    keep track of each unique touch. A touch can even be used to touch two buttons
    at once.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们的`TouchableSprite`类使用唯一标识通过`ccTouches`方法的每个`UITouch`对象的哈希变量。这样我们就可以跟踪每个独特的触摸。触摸甚至可以用来同时触摸两个按钮。
- en: 'Touching two buttons with one touch:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用一个触摸点触摸两个按钮：
- en: Our `(CGRect)rect` method uses a `scaleMod` of `1.5f`. This, along with using
    `pointInCircle` for touch detection, allows us to press two buttons with one well
    placed touch. This is vital for many games. For example, the original Super Mario
    Brothers required the user to hold down the B button to run while pressing the
    A button to jump. This technique allows a similar use of the Y and A buttons.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的`(CGRect)rect`方法使用`scaleMod`为`1.5f`。这，加上使用`pointInCircle`进行触摸检测，允许我们用一个放置得当的触摸点同时按下两个按钮。这对许多游戏至关重要。例如，原始超级马里奥兄弟要求用户按下B按钮来跑步，同时按下A按钮来跳跃。这种技术允许类似地使用Y和A按钮。
- en: Creating a directional pad
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建方向垫
- en: Another fundamental form of video game input is the **directional pad**. In
    this recipe, you will see how to create a convincing 3D-ish directional pad and
    you will see how to properly process directional pad information in a game situation.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种视频游戏输入的基本形式是**方向垫**。在这个菜谱中，你将看到如何创建一个令人信服的3D方向垫，你将看到如何在游戏场景中正确处理方向垫信息。
- en: '![Creating a directional pad](img/4002_02_04.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![创建方向垫](img/4002_02_04.jpg)'
- en: Getting ready
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection01* for full working code of this
    recipe. Also, note that some code has been omitted for brevity.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅项目*RecipeCollection01*以获取此菜谱的完整工作代码。此外，请注意，为了简洁起见，一些代码已被省略。
- en: How to do it...
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Execute the following code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe uses a few simple tricks to make a compelling directional pad effect.
    First, we must look at the `DPad` class.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱使用一些简单的技巧来制作令人信服的方向垫效果。首先，我们必须看看`DPad`类。
- en: 'The `DPad` class:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DPad`类：'
- en: The `DPad` class determines touch direction by first creating a 2D vector from
    the center of the DPad image to the point where it is touched. It then divides
    the image into eight directional slices. Each direction corresponds to a different
    sprite frame. When everything is put together we get a nice looking pseudo-3D
    effect.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`DPad`类通过首先从DPad图像的中心创建一个2D向量到触摸点的位置来确定触摸方向。然后它将图像分成八个方向切片。每个方向对应于不同的精灵帧。当一切组合在一起时，我们得到一个看起来很棒的伪3D效果。'
- en: Processing DPad state and `pressedVector:`
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理 DPad 状态和 `pressedVector`：
- en: The `DPad` class maintains both a direction enumeration and a direction vector.
    This allows us to determine which of the eight directions our "gunman" sprite
    should be facing and how we should set his `velocity` variable to instigate movement.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`DPad` 类维护一个方向枚举和一个方向向量。这使我们能够确定我们的“枪手”精灵应该面向哪个方向，以及我们应该如何设置他的 `velocity` 变量以引发移动。'
- en: 'DPad dead zone:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DPad 死区：
- en: Our DPad has a roughly 10 percent **dead zone** right in the middle. This makes
    the control feel a little more natural to the user. We do this because, on a real
    directional pad, pressing directly in the middle results in no movement.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的 DPad 在中间大约有 10% 的 **死区**。这使得控制感觉对用户来说更加自然。我们这样做是因为，在真实的方向板上，直接按下中间会导致没有移动。
- en: Creating an analog stick
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模拟摇杆
- en: By building on the last recipe, we can create a more sophisticated virtual **analog
    stick**. This input method measures vector magnitude as well as direction. We've
    also created a cool looking visual effect for the analog stick.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在上一个菜谱的基础上构建，我们可以创建一个更复杂的虚拟 **模拟摇杆**。这种输入方法测量向量的大小以及方向。我们还为模拟摇杆创建了一个酷炫的视觉效果。
- en: '![Creating an analog stick](img/4002_02_05.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![创建模拟摇杆](img/4002_02_05.jpg)'
- en: Getting ready
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection01* for full working code of this
    recipe.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅项目 *RecipeCollection01* 以获取此菜谱的完整工作代码。
- en: How to do it...
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Execute the following code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Using the `AnalogStick` class provides the user with more precise control.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `AnalogStick` 类为用户提供更精确的控制。
- en: 'The `AnalogStick` class:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AnalogStick` 类：'
- en: 'Like the `DPad` class the `AnalogStick` class determines direction. Unlike
    `DPad` it also determines **magnitude** using the following lines:'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与 `DPad` 类一样，`AnalogStick` 类确定方向。与 `DPad` 不同，它还使用以下行确定**大小**：
- en: '[PRE7]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This touched position also determines the position and orientation of the "nub"
    and the "bar". Without going into too much detail, this creates a nice analog
    stick visual effect. Like our `DPad` class from the previous recipe, our `AnalogStick`
    class also includes a dead zone.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个触摸位置也决定了“小突起”和“杆”的位置和方向。不深入细节，这创建了一个很好的模拟摇杆视觉效果。像上一个菜谱中的 `DPad` 类一样，我们的 `AnalogStick`
    类也包括一个死区。
- en: '`AnalogStick` dead zone:'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AnalogStick` 死区：'
- en: This time, the dead zone involves making the outer 25 percent of the touchable
    area max out the vector's magnitude. To achieve this we store an internal_`pressedVector`
    variable and give `readonly` access to a `pressedVector` property. This points
    to a method that does the proper calculations. The reason we provide this zone
    is so the user can comfortably make the 'gunman' run at top-speed.
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这次，死区涉及到使可触摸区域的 25% 外围达到向量的最大值。为了实现这一点，我们存储一个内部 `_pressedVector` 变量，并给 `readonly`
    访问权限的 `pressedVector` 属性。它指向一个执行正确计算的方法。我们提供这个区域的原因是让用户能够舒适地让“枪手”以最高速度奔跑。
- en: Using the accelerometer for steering
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用加速度计进行转向
- en: 'iOS applications also have another form of input: the **accelerometer**. This
    measures the **orientation** of the iOS device on the **X, Y**, and **Z planes**.
    Device orientation is a dynamic (if slightly delayed) input mechanism with a variety
    of uses. One of these uses is steering in racing video games.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 应用程序还有另一种形式的输入：**加速度计**。它测量 iOS 设备在 **X, Y** 和 **Z 平面**上的**方向**。设备方向是一个动态（如果稍微延迟）的输入机制，具有多种用途。其中一种用途是赛车视频游戏中的转向。
- en: '![Using the accelerometer for steering](img/4002_02_06.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![使用加速度计进行转向](img/4002_02_06.jpg)'
- en: Getting ready
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection01* for full working code of this
    recipe.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅项目 *RecipeCollection01* 以获取此菜谱的完整工作代码。
- en: How to do it...
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Execute the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Rotating your iPhone left or right while looking directly at the screen will
    result in seeing the steering wheel rotate. The 3D vector contained within the
    `UIAcceleration` variable goes up or down by 1 for every 90 degrees the iOS device
    rotates. So, by multiplying this rotation by 180 degrees, we equate a 45-degree
    tilt with a 90-degree turn of the steering wheel.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当你直接看着屏幕时，左右旋转你的 iPhone 将导致看到方向盘旋转。包含在 `UIAcceleration` 变量中的 3D 向量在 iOS 设备旋转
    90 度时上升或下降 1。因此，通过将这个旋转乘以 180 度，我们将 45 度的倾斜等同于方向盘的 90 度转向。
- en: 'Accelerometer delay:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加速度计延迟：
- en: Mechanically the accelerometer has a slight delay compared to the touch screen.
    This makes its application impractical for some gametypes where absolute split
    second control is required.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在机械上，加速度计与触摸屏相比有轻微的延迟。这使得它在需要绝对瞬间控制的某些游戏类型中的应用变得不切实际。
- en: Using the accelerometer for 3D rotation
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用加速度计进行3D旋转
- en: Using multiple accelerometer values at once can allow the user to manipulate
    the rotation of a 3D object in space. This is used to great effect in the Super
    Monkey Ball series of iOS games.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 同时使用多个加速度计值可以允许用户在空间中操纵3D对象的旋转。这在iOS游戏的《超级猴子球》系列中得到了很好的应用。
- en: '![Using the accelerometer for 3D rotation](img/4002_02_07.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![使用加速度计进行3D旋转](img/4002_02_07.jpg)'
- en: Getting ready
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection01* for full working code of this
    recipe. Please note that the `IphoneCube` class code was omitted from this example
    as it is similar to the 3D cube code in [Chapter 1](ch01.html "Chapter 1. Graphics"),
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目 *RecipeCollection01* 以获取此菜谱的完整工作代码。请注意，此示例中省略了 `IphoneCube` 类代码，因为它与[第1章](ch01.html
    "第1章。图形")中的3D立方体代码类似，
- en: How to do it...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Execute the following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Rotating your device on the **X** or **Y** planes will result in rotating the
    virtual iPhone onscreen. We multiply the `acceleration` variable by 180 to once
    again rotate our object twice as much as the device itself. The `IphoneCube` variable
    `rotation3DAxis` rotates the textured box in 3D space using `glRotatef`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在**X**或**Y**平面上旋转您的设备将导致屏幕上的虚拟iPhone旋转。我们将`acceleration`变量乘以180，再次将我们的对象旋转得比设备本身多一倍。`IphoneCube`变量`rotation3DAxis`使用`glRotatef`在3D空间中旋转纹理盒。
- en: Pinch zooming
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捏合缩放
- en: Apple's touch devices popularized using two fingers to zoom in and out and this
    method remains the most popular way to zoom on any widely available touch screen
    device. In this recipe, we will see how to zoom a scene in and out by **pinching**.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果的触摸设备普及了使用两个手指进行缩放和缩小的操作，这种方法仍然是任何广泛可用的触摸屏设备上缩放的最流行方式。在本菜谱中，我们将看到如何通过**捏合**来缩放场景。
- en: '![Pinch zooming](img/4002_02_08.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![捏合缩放](img/4002_02_08.jpg)'
- en: Getting ready
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection01* for full working code of this
    recipe. Also note that the arrow effect shown in the previous screenshot has been
    omitted from the following code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目 *RecipeCollection01* 以获取此菜谱的完整工作代码。另外请注意，前一个屏幕截图所示的箭头效果在以下代码中已被省略。
- en: How to do it...
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Execute the following code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE10]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'This recipe processes two separate touches and determines their respective
    distance. It maintains this variable to determine whether or not the touches have
    grown closer or farther apart. Then, this distance is used to calculate the new
    zoom level. The following line of code does this while also keeping the zoom effect
    smooth:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱处理两个独立的触摸并确定它们各自的距离。它保持这个变量以确定触摸是否变得更近或更远。然后，使用这个距离来计算新的缩放级别。以下代码行执行此操作，同时保持缩放效果平滑：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This achieves the desired effect.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这实现了预期的效果。
- en: 'Processing multiple simultaneous touches:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理多个同时触摸：
- en: As you can see, processing **multiple touches** is similar to processing a single
    touch. The `touches` variable contains every touch at that specific moment. If
    two touches move together this one method can easily process them.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，处理**多个触摸**与处理单个触摸类似。`touches`变量包含那个特定时刻的每个触摸。如果两个触摸一起移动，这个方法可以轻松地处理它们。
- en: There's more...
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: If you want to add to this technique, try implementing iPhoto-esque image panning.
    This pan/zoom combination has become standard on all document and image viewers
    and is a natural UI enhancement for many iOS games.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想增加这项技术，尝试实现类似iPhoto的图像平移功能。这种平移/缩放组合已成为所有文档和图像查看器的标准，并且是许多iOS游戏的自然用户界面增强。
- en: Performing gestures
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行手势
- en: '**Gestures** can act as functional input shortcuts. Simple gestures like swiping
    and scrolling are built into many Apple UI tools. Some games, notably Castlevania:
    Dawn of Sorrow (DS) and Okami (PS2, Wii) use gestures as core gameplay mechanics.
    In this recipe, we will implement a simple and admittedly crude gesture system.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**手势**可以作为功能输入快捷键。简单的手势，如滑动和滚动，已内置到许多苹果UI工具中。一些游戏，特别是《恶魔城：悲叹之晨》（DS）和《大野狼》（PS2、Wii），将手势用作核心游戏玩法机制。在本菜谱中，我们将实现一个简单且坦白说是粗略的手势系统。'
- en: '![Performing gestures](img/4002_02_09.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![执行手势](img/4002_02_09.jpg)'
- en: Getting ready
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection01* for full working code of this
    recipe. Also note that the `GestureLine` and `GestureShapeLayer` classes have
    been omitted for brevity. `GestureLine` simply contains two `CGPoint` structures.
    `GestureShapeLayer` draws a circle or an array of lines.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅项目*RecipeCollection01*以获取此菜谱的完整工作代码。此外，请注意，为了简洁，省略了`GestureLine`和`GestureShapeLayer`类。`GestureLine`仅包含两个`CGPoint`结构。`GestureShapeLayer`绘制一个圆或一组线。
- en: How to do it...
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Execute the following code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE12]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works...
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This gesture system tracks each individual point of user input. Each pair of
    points creates a **2D vector**. When the current vector's angle is different enough
    from the previous one, then we consider that this is a new vertex of a shape the
    user is drawing. We then take this vertex and the last one, and create a line.
    By storing every point and line we can determine what the user is attempting to
    draw.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个手势系统跟踪用户输入的每个单独的点。每对点创建一个**2D向量**。当当前向量的角度与上一个向量足够不同时，我们认为这是用户正在绘制的形状的新顶点。然后我们取这个顶点和上一个顶点，创建一条线。通过存储每个点和线，我们可以确定用户试图绘制的内容。
- en: There's more...
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This system, as implemented, leaves much to be desired. However, it provides
    the conceptual groundwork for a more complex and functional system. By looking
    at the succession of points in a certain light we can see patterns emerge. In
    this example, we looked for successive vectors with vastly different angles to
    determine drawn lines. Other things like curves, direction, and point distance
    can lead to the identification of more complex shapes.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 实现的这个系统还有很多不足之处。然而，它为更复杂和功能更强大的系统提供了概念基础。从某种角度看一系列的点，我们可以看到模式的出现。在这个例子中，我们寻找角度差异很大的连续向量来确定绘制的线条。其他如曲线、方向和点距离等因素可以导致更复杂形状的识别。
