- en: Chapter 2. Standard Library and Collections
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. 标准库和集合
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Creating HTML manually
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动创建HTML
- en: Printing your object description
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印你的对象描述
- en: Quizzing the user
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对用户进行测验
- en: Searching for perfect numbers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找完美数
- en: Sorting an array of products
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对产品数组进行排序
- en: Finding the way out
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找出路
- en: Creating your own set
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建你自己的集合
- en: Organizing a dinner room
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织餐厅
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: It's important to know the usage of collections and standard library, mainly
    for those people who come from Objective-C because there are some differences
    here.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 了解集合和标准库的使用很重要，尤其是对于来自Objective-C的人，因为这里有一些差异。
- en: In this chapter, we will create some apps to use these features. After these
    recipes, you should have a good understanding about the Swift programming language.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一些应用程序来使用这些功能。在这些食谱之后，你应该对Swift编程语言有一个很好的理解。
- en: As mentioned in the previous chapter, most of our recipes will be created on
    iOS, but you can develop them on Mac OS X if you want.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，我们的大部分食谱将在iOS上创建，但如果你愿意，也可以在Mac OS X上开发它们。
- en: Creating HTML manually
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动创建HTML
- en: HTML started as a simple format for displaying web pages and links. Nowadays,
    this format has become very common and it is used everywhere. There are even frameworks
    such as PhoneGap that create applications with this file type.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: HTML最初是一种简单的网页和链接显示格式。如今，这种格式已经变得非常普遍，并且被广泛使用。甚至有像PhoneGap这样的框架，可以创建使用此文件类型的应用程序。
- en: In this recipe, we will create HTML using only strings; the main idea is to
    know about string manipulation. In this case, we will create the HTML code for
    a visiting card.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将仅使用字符串创建HTML；主要思想是了解字符串操作。在这种情况下，我们将创建名片HTML代码。
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Open your Xcode and create a single view project called `Chapter2 HTML`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的Xcode，创建一个名为`Chapter2 HTML`的单视图项目。
- en: How to do it…
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Let''s create HTML manually by following these steps:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤手动创建HTML：
- en: Click on the storyboard and add the following layout:![How to do it…](img/00024.jpeg)
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击故事板并添加以下布局：![如何操作…](img/00024.jpeg)
- en: 'Then, connect the text fields with the following properties on the view controller:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将文本框与视图控制器上的以下属性连接：
- en: '[PRE0]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Link these properties with the corresponding text field on the view, and before
    creating an action button, we will create a `Card` class with the following code:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些属性与视图上的相应文本框相关联，在创建动作按钮之前，我们将使用以下代码创建一个`Card`类：
- en: '[PRE1]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, we are creating a class with the same information as our application.
    The main difference is that we have a constant called `TEMPLATE`, which has a
    model of our HTML.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，我们正在创建一个与我们的应用程序具有相同信息的类。主要区别是我们有一个名为`TEMPLATE`的常量，它具有我们的HTML模型。
- en: Note
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that this constant is private because it's something that we shouldn't
    see (for example, from the view controller). Also notice that we have a plus sign
    at the end of each line that needs to continue on the next line. The reason is
    that we can't concatenate strings without using an operator as we used in Objective-C.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，这个常量是私有的，因为这是我们不应该看到的东西（例如，从视图控制器中）。此外，请注意，在需要继续到下一行的每一行末尾都有一个加号。原因是，我们不能像在Objective-C中使用操作符那样不使用操作符来连接字符串。
- en: Swift doesn't need a semicolon at the instruction end. However, if you have
    a huge line, you have to tell the compiler that the line is going to continue,
    with a plus sign, for example, or by indicating on the next line that it is continuing
    from the previous one, with a dot operator, for example.
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Swift在指令末尾不需要分号。然而，如果你有一行非常长的代码，你必须告诉编译器这一行将要继续，例如，使用加号，或者在下一条线上使用点操作符来表示它从上一行继续。
- en: 'If you''ve been programming with Objective-C or C++, you may be asking why
    we''ve created an empty initializer. The reason is: it is not necessary; theoretically,
    because we only have constants and optional values. However, some Swift versions,
    for whatever reason, don''t detect it and force you to create an empty initializer.'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你曾经使用Objective-C或C++进行编程，你可能想知道为什么我们创建了一个空的初始化器。原因是：它不是必需的；理论上，因为我们只有常量和可选值。然而，某些Swift版本，出于任何原因，无法检测到它，并强制你创建一个空的初始化器。
- en: What are the attributes' initial values? The answer is *nil*. Have a look to
    see whether all of them are optional; otherwise, we will have to set their values
    to something.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 属性的初始值是什么？答案是*nil*。看看是否所有这些属性都是可选的；如果不是，我们将不得不将它们的值设置为某些内容。
- en: Tip
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Avoid using empty values such as empty strings to initialize an attribute; it
    is better to use optional attributes.
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 避免使用空值，例如空字符串来初始化属性；最好使用可选属性。
- en: 'At this time, we have the basic structure. Now we need to create the button
    event, so link the touch up event with the following action on the view controller:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们有了基本结构。现在我们需要创建按钮事件，所以将视图控制器上的触摸事件与以下动作链接：
- en: '[PRE2]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now we will have a look at whether this action is very clear. We will start
    creating a `card` object, then we will receive the information we need from our
    view, and at the end, display it.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将看看这个动作是否非常清晰。我们将开始创建一个`card`对象，然后从我们的视图中获取所需的信息，最后显示它。
- en: Tip
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Avoid spaghetti code; do not create an enormous action and try to divide it
    into classes and methods. Have a look at the Model-View-Controller pattern on
    Wikipedia.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 避免面条代码；不要创建一个巨大的动作，并尝试将其分解为类和方法。看看维基百科上的模型-视图-控制器模式。
- en: 'Everything is fine except for one detail: the `Card` class has no method called
    `toHtml`. No problem, let''s implement it. Go back to our `Card` class and add
    the following method:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了一个细节外，一切都很正常：`Card`类没有名为`toHtml`的方法。没问题，让我们实现它。回到我们的`Card`类，并添加以下方法：
- en: '[PRE3]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now it's time to test it; just press play on your Xcode IDE, fill in the fields
    and press the button, and you should see a message like the one shown here:![How
    to do it…](img/00025.jpeg)
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候测试它了；只需在Xcode IDE中按播放，填写字段并按按钮，你应该会看到一个像这里显示的消息：![如何做…](img/00025.jpeg)
- en: How it works…
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Strings have a lot of methods; some of them are used to modify the current string,
    while others only return values, and others create a new string based on the original
    one. In our case, we used `stringByReplacingOccurrencesOfString`, which generates
    a new string by replacing our marks `(#something#`) with the corresponding attribute.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串有很多方法；其中一些用于修改当前字符串，而另一些仅返回值，还有一些基于原始字符串创建新的字符串。在我们的例子中，我们使用了`stringByReplacingOccurrencesOfString`，通过替换我们的标记`(#something#`)来生成一个新的字符串，对应于相应的属性。
- en: We can chain the result of each replacement to do the next one, preventing reassignment
    on each line.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将每个替换的结果链式调用，以进行下一个替换，防止每行重新赋值。
- en: Tip
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Nowadays, iPhones and iPads have 1 gigabyte or more of RAM, which should be
    enough for most of the traditional HTML templates. However, if you have a very
    big template with lots of replacements, you might need to look for a more optimized
    method for it. Replacing strings on big string variables allocates a lot of memory
    and you might get a poor performance.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，iPhone和iPad拥有1GB或更多的RAM，这对于大多数传统的HTML模板来说应该足够了。然而，如果你有一个非常大的模板，有很多替换，你可能需要寻找更优化的方法。在大型字符串变量上替换字符串会分配大量内存，你可能会得到较差的性能。
- en: There's more...
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If you look at this method documentation, you will see that there are two additional
    arguments, one called `options` and another one called `range`. They are used
    to specify a special comparator to search our string mark, and the other one uses
    only part of our string. As we didn't have to use them and they are optional,
    we've just omitted them; it wasn't necessary to fill them with nil values as we
    used to do in Objective-C.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看这个方法文档，你会看到有两个额外的参数，一个叫做`options`，另一个叫做`range`。它们用于指定一个特殊的比较器来搜索我们的字符串标记，另一个则只使用我们字符串的一部分。由于我们不需要使用它们，它们是可选的，所以我们只是省略了它们；没有必要用nil值填充，就像我们以前在Objective-C中做的那样。
- en: Tip
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If your project has objects that need to create HTML, XML, or JSON code, you
    can create a base object with a method specific to the corresponding casting to
    standardize it.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的项目中有需要创建HTML、XML或JSON代码的对象，你可以创建一个具有特定于相应类型转换的方法的基础对象，以实现标准化。
- en: Printing your object description
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印你的对象描述
- en: The idea of this recipe is to see the Swift way of creating a string using variable
    values. In Objective-C, we have a class method called `stringWithFormat`, but
    this method isn't used in Swift with the same frequency as it is used in Objective-C
    because now we have interpolation. In this example, we will create an app, which
    will show the user three possible products. When the user chooses one of them,
    the app must show the information of this product and also its price, if it's
    available.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱的目的是看看使用变量值创建字符串的Swift方法。在Objective-C中，我们有一个名为`stringWithFormat`的类方法，但在Swift中，这个方法不像在Objective-C中那样频繁使用，因为现在我们有插值。在这个例子中，我们将创建一个应用程序，它将向用户展示三种可能的产品。当用户选择其中之一时，应用程序必须显示该产品的信息，如果有的话，还要显示其价格。
- en: How to do it…
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Create a new single view project called `Chapter2 Product Value`. Now, let's
    click on the storyboard and add three buttons, as shown here:![How to do it…](img/00026.jpeg)
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Chapter2 Product Value`的新单视图项目。现在，让我们点击故事板并添加三个按钮，如图所示：![如何操作…](img/00026.jpeg)
- en: Once you've done this, you can add a new swift file called `Product`. Now we
    will create a class with a product name, its price, and the manufacturer name.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成此操作后，你可以添加一个名为`Product`的新swift文件。现在我们将创建一个包含产品名称、其价格和制造商名称的类。
- en: In this case, the only information that can be omitted is the product price;
    the other attributes are not optional. This means that we will need an initializer
    with at least the product name and the manufacturer name.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，唯一可以省略的信息是产品价格；其他属性是必需的。这意味着我们需要一个初始化器，至少包含产品名称和制造商名称。
- en: 'As we would like to use our product with interpolation, we need to implement
    the `CustomStringConvertable` protocol, which forces us to implement a property
    called `description`. Once we have this information, we can implement our class
    with the following code:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们希望使用插值功能来使用我们的产品，我们需要实现`CustomStringConvertable`协议，这迫使我们实现一个名为`description`的属性。一旦我们有了这些信息，我们就可以使用以下代码实现我们的类：
- en: '[PRE4]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now we can go to the view controller and create three products as attributes;
    following our examples, we will create `television`, `gabion`, and `locker`. So,
    let''s add the following attributes:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以转到视图控制器并创建三个产品作为属性；按照我们的示例，我们将创建`television`、`gabion`和`locker`。所以，让我们添加以下属性：
- en: '[PRE5]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The next step is to create an auxiliary function, which is going to convert
    a double into a string with two digits of precision. I will create this function
    on the view controller file but outside its class. If in a project you are going
    to use this function in more than one file, I recommend you create another file
    for this function using the following code:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是创建一个辅助函数，该函数将把双精度浮点数转换为具有两位精度的字符串。我将在视图控制器文件中创建此函数，但不在其类内部。如果在项目中你打算在多个文件中使用此函数，我建议你使用以下代码创建另一个文件：
- en: '[PRE6]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Tip
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It is a good idea to have one or more files dedicated to auxiliary functions
    and class extensions. This will make your code maintenance easier.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将一个或多个文件专门用于辅助函数和类扩展是一个好主意。这将使你的代码维护更容易。
- en: The last thing we need to do is to create the button action. As you know, we
    have three buttons, and all of them will perform the same function; the only difference
    is the product that will be displayed. For this reason, we will create only one
    function and differentiate the product according to its sender.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是创建按钮动作。正如你所知，我们有三个按钮，它们都将执行相同的功能；唯一的区别是显示的产品。因此，我们将创建一个函数，并根据发送者区分产品。
- en: Tip
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Avoid repeating code, even if they are next to each other or if they are small
    code. This is because when the project starts receiving changes, it will generate
    new bugs.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 避免重复代码，即使它们相邻或很小。这是因为当项目开始接收更改时，它将生成新的错误。
- en: 'Another detail that I would like to mention is that, in this example, I will
    show the product price after adding VAT (20%). This is to make you aware of the
    power of Swift string interpolation:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我想提到的另一个细节是，在这个例子中，我将在添加增值税（20%）后显示产品价格。这是为了让你了解Swift字符串插值的强大功能：
- en: '[PRE7]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In this sample, we used the buttons' titles to know the product chosen, but
    it's a bad practice. It was done this way only to create a small example focused
    on string interpolation. Imagine that you need to translate your program to other
    languages or if you have to add a small amount of information to this label; it
    will make you fix a lot of code.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用了按钮的标题来知道选择的产品，但这是一种不好的做法。这样做只是为了创建一个专注于字符串插值的小示例。想象一下，你需要将你的程序翻译成其他语言，或者如果你需要向这个标签添加少量信息，这将使你修复大量的代码。
- en: Now our app is complete; try to press play and then the app buttons. You should
    see an alert view like this one:![How to do it…](img/00027.jpeg)
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们的应用已经完成；尝试按下播放按钮，然后点击应用按钮。你应该看到一个类似于这样的警告视图：![如何操作…](img/00027.jpeg)
- en: How it works...
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: One of the greatest features of Swift is string interpolation; it allows you
    to have expressions like the one we did while calculating the price with VAT included.
    This also allows you to call functions like we called `doubleFormatter` to have
    our number shown with two digits. This also allows us to print an object.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Swift最伟大的功能之一是字符串插值；它允许你拥有我们在计算包含增值税的价格时所做的表达式。这也允许你调用像`doubleFormatter`这样的函数，使我们的数字以两位数显示。这也允许我们打印一个对象。
- en: If we wanted to, we can even call object methods or property, for example. We
    can show the manufacturer name in uppercase, changing our description to `\(self.name)
    \(self.manufacturer.uppercaseString))`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们愿意，甚至可以调用对象的方法或属性，例如。我们可以将制造商名称显示为大写，将我们的描述更改为`\(self.name) \(self.manufacturer.uppercaseString))`。
- en: Remember that if you want to print your own object, it must follow the `CustomStringConvertable`
    protocol and implement the property called `description`. Some languages such
    as Java have the equivalent method (`toString` in case of Java) on a base class
    and you only need to override it. However, Swift has no base if you don't specify
    it, and this is the reason you can't overwrite the `description` property without
    specifying the usage of the `CustomStringConvertable` protocol.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果你想打印自己的对象，它必须遵循`CustomStringConvertable`协议并实现名为`description`的属性。一些语言，例如Java，在基类中有一个等效的方法（Java中的`toString`），你只需要重写它。然而，Swift如果没有指定基类，就没有基类，这就是为什么你必须在指定了`CustomStringConvertable`协议的使用后才能覆盖`description`属性。
- en: To use string interpolation, just create a string and when you need an external
    value, just |wrap it between `\(` (backslash and open parenthesis) and `)` (closed
    parenthesis), for example, `\(variable)`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用字符串插值，只需创建一个字符串，当你需要外部值时，只需将其用`\(`（反斜杠和左括号）和`)`（右括号）包裹起来，例如，`\(variable)`。
- en: Tip
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If the expression is getting too complex in a way that makes it difficult to
    use, just create a new variable with its value inside the string. This is also
    a good practice in terms of software maintenance. Objective-C doesn't have this
    feature; you have to create a new string using a class method named `stringWithFormat`.
    We used the Swift equivalent one, which is now an initializer.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表达式变得过于复杂，以至于难以使用，只需在字符串内部创建一个新的变量并设置其值。这在软件维护方面也是一种良好的实践。Objective-C没有这个功能；你必须使用名为`stringWithFormat`的类方法创建一个新的字符串。我们使用了Swift的等效方法，现在是一个初始化器。
- en: I would also like to point out that we created a constant inside our `if` statement.
    In this case, we are not verifying whether the price is true or if it is greater
    than zero, we are just checking that it does not have a nil value. In case of
    a product that costs 0, for example, it would also evaluate to true.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我还想指出，我们在`if`语句中创建了一个常量。在这种情况下，我们不是验证价格是否为真或是否大于零，我们只是检查它没有nil值。例如，对于价格为0的产品，它也会评估为真。
- en: Last but not least, notice that our variable message is not optional but that
    it wasn't initialized where declared. The reason for this is that the compiler
    will check it before reading it and setting it, and there is no possibility of
    having it uninitialized.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，请注意，我们的`message`变量不是可选的，但它并没有在声明的地方初始化。原因是编译器会在读取和设置它之前检查它，并且没有未初始化的可能性。
- en: The initial value for this variable depends on the product value, which can't
    be nil; this is the reason we were forced to add an `else` statement and `exit`
    from our function. Otherwise, the compiler would find a possible way to have the
    product set to nil and it would fail due to our interpolation.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变量的初始值取决于产品值，它不能为nil；这就是我们被迫添加`else`语句和从我们的函数中退出的原因。否则，编译器会找到一个可能的方法将产品设置为nil，并且由于我们的插值，它将失败。
- en: There's more...
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Another good solution for our `doubleFormatter` function is to create an extension.
    To do this, just change our formatter code to the following one:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`doubleFormatter`函数提供的另一个良好解决方案是创建一个扩展。为此，只需将我们的格式化代码更改为以下代码：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This means that now we''ve added a new method to double types, and we can call
    it whenever we want. Of course, we also have to change the interpolation that
    uses our double value. Now, we can use the class extension replacing the corresponding
    line with this one:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们现在为双精度类型添加了一个新方法，我们可以随时调用它。当然，我们还得改变使用我们的双精度值的插值。现在，我们可以使用类扩展，用以下一行替换相应的行：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Quizzing the user
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对用户进行测验
- en: Sometimes, we need to add some icons on our application, but depending on the
    icon you want, it's not necessary to add an image; you can use Unicode characters.
    Let's create a quiz app using strings alone.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们需要在我们的应用程序中添加一些图标，但根据您想要的图标，不一定需要添加图片；您可以使用 Unicode 字符。让我们创建一个仅使用字符串的测验应用。
- en: The idea for this app is to create an app where the user needs to answer a question
    in 12 seconds. After the quiz, the app will show the user his score, such as the
    number of right and wrong questions.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用的想法是创建一个应用，用户需要在12秒内回答一个问题。在测验结束后，应用将显示用户的得分，例如正确和错误问题的数量。
- en: Getting ready
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: Once we know the concept of this program, let's create a new project and name
    it `Chapter 2 Unicode`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们了解了这个程序的概念，让我们创建一个新的项目，并将其命名为 `第2章 Unicode`。
- en: How to do it...
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create a quiz app, follow these steps:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个测验应用，请按照以下步骤操作：
- en: 'First, let''s create a new file called `Quiz` and add a class with a question
    to it, with three possible answers and the right answer, as follows:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个名为 `Quiz` 的新文件，并向其中添加一个带有问题、三个可能答案和正确答案的类，如下所示：
- en: '[PRE10]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tip
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To add Unicode characters to your code, you can copy from a website or go to
    **Edit** | **Special characters**.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要将 Unicode 字符添加到您的代码中，您可以从网站复制或转到 **编辑** | **特殊字符**。
- en: 'Now that we''ve got this happy class, we need to create another one to store
    our quizzes and manage the user''s answers:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了这个愉快的类，我们需要创建另一个类来存储我们的测验并管理用户的答案：
- en: '[PRE11]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The next step is to add one label for the question, three buttons for the possible
    answers, and one label to show the timer. Don't forget to hide the navigation
    bar if you don't want to show it. Your screen should look similar to this:![How
    to do it...](img/00028.jpeg)
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是添加一个用于问题的标签、三个用于可能答案的按钮和一个用于显示计时器的标签。如果您不想显示导航栏，别忘了将其隐藏。您的屏幕应该看起来类似于这个：![如何操作...](img/00028.jpeg)
- en: 'Now it''s time to create the corresponding properties on our view controller
    and link them. Besides these components, we will also need a timer and another
    variable to know how much time has passed. Call these properties as shown here:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候在我们的视图控制器上创建相应的属性并将它们链接起来。除了这些组件，我们还需要一个计时器和另一个变量来知道已经过去了多少时间。将这些属性命名为如下所示：
- en: '[PRE12]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Ok, now it''s time to initialize these components. This is the reason we will
    create an initializer. In Objective-C, we used to set up the `viewDidLoad` method,
    as this method is called after the controller''s view has been loaded in memory,
    but now on Swift, every object must have each non-optional property initialized.
    This is the reason we will overwrite the `init` method. Don''t worry about the
    meaning of each line; it will be explained soon:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，现在是我们初始化这些组件的时候了。这就是我们为什么要创建一个初始化器的原因。在 Objective-C 中，我们曾经设置 `viewDidLoad`
    方法，因为这个方法是在控制器的视图被加载到内存后调用的，但现在在 Swift 中，每个对象都必须初始化每个非可选属性。这就是我们要重写 `init` 方法的原因。不要担心每行代码的含义；很快就会解释：
- en: '[PRE13]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The first question you might have is: why did we use `required` instead of
    `override`? This is because the initializer was defined as required on the base
    class (`UIViewController`); in this case, we must re-implement this method.'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可能首先会问：为什么我们使用 `required` 而不是 `override`？这是因为初始化器在基类（`UIViewController`）中被定义为
    `required`；在这种情况下，我们必须重新实现这个方法。
- en: The next step is to set `elapsedTime`. We will not use it now, but as it is
    not optional, we must set it here. Note that both `elapsedTime` and `quizManager`
    are initialized before the super class. After initializing the super class, we
    can add the questions to the quiz manager; which is the reason we have a call
    to `setupQuizManager`.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是设置 `elapsedTime`。我们现在不会使用它，但由于它不是可选的，我们必须在这里设置它。请注意，`elapsedTime` 和 `quizManager`
    都在超类之前初始化。在初始化超类之后，我们可以将问题添加到测验管理器中；这就是为什么我们有 `setupQuizManager` 的调用。
- en: 'Ok, now we can show the first question on screen. To do this, we need the famous
    `viewDidLoad` function. We can''t do it on the initializer because the labels
    and the buttons haven''t been instantiated. You can also see the `prepareNextQuestion`
    method, which verifies whether there are more questions. If so, this shows the
    next question; if not, then it shows your score:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，现在我们可以将第一个问题显示在屏幕上了。为此，我们需要著名的 `viewDidLoad` 函数。我们无法在初始化器中做这件事，因为标签和按钮还没有被实例化。您还可以看到
    `prepareNextQuestion` 方法，该方法验证是否有更多的问题。如果有，则显示下一个问题；如果没有，则显示您的得分：
- en: '[PRE14]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You will notice that we are using the new `guard` keyword introduced in Swift
    2.0\. Using guard will allow you to define an exit strategy if a particular condition
    is not met. This really comes in handy when unwrapping optionals; all code after
    the guard condition will contain the unwrapped value(s) without indentation and
    scope issues.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会注意到我们正在使用Swift 2.0中引入的新`guard`关键字。使用`guard`将允许你在特定条件未满足时定义一个退出策略。这确实在解包可选值时非常有用；`guard`条件之后的代码将包含未包裹的值（无缩进和作用域问题）。
- en: 'There is something that is still missing, it''s the timer callback. Remember
    that we would like to show the user how much time he has left to answer the question,
    and after this, we have to skip to the next question. As you can see in the preceding
    method, we call a method named `tick`; this means that with each second, we have
    to increase the value of `elapsedTime`, and when the timer is over, we will consider
    that the question was answered incorrect:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还有一些东西是缺失的，那就是计时器回调。记住，我们希望向用户显示他还有多少时间来回答问题，然后我们必须跳到下一个问题。正如你在前面的方法中看到的那样，我们调用了一个名为`tick`的方法；这意味着每过一秒，我们必须增加`elapsedTime`的值，当计时器结束时，我们将认为问题被错误地回答了：
- en: '[PRE15]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you press play now, you can see the app working except for one small detail.
    The user can''t answer! Notice that there is no button action, so we need to add
    it, and remember that once the user has pressed the button, it will go to the
    next question:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在按播放，你可以看到应用程序正在运行，除了一个小细节。用户不能回答！注意，没有按钮动作，所以我们需要添加它，并且记住一旦用户按下按钮，它将跳到下一个问题：
- en: '[PRE16]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Cool, now we have our app working!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，现在我们的应用程序正在运行！
- en: How it works…
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this recipe, we learned some ways of using Unicode happy characters. Now
    you can create you own WhatsApp-like program. We saw that we can have variable
    names with Unicode characters; if you want, you can name your variables in Japanese!
    You can also create strings with Unicode values using `String(Character(UnicodeScalar(UNICODE_VALUE)))`,
    or you can also use it with interpolations such as `Total \u{1F44D}`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们学习了一些使用Unicode表情字符的方法。现在你可以创建你自己的WhatsApp-like程序。我们看到了我们可以使用带有Unicode字符的变量名；如果你想，你可以用日语给你的变量命名！你也可以使用`String(Character(UnicodeScalar(UNICODE_VALUE)))`创建带有Unicode值的字符串，或者你也可以用它进行插值，如`Total
    \u{1F44D}`。
- en: Tip
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Take care while using Unicode characters; you may be complicating the other
    team members' lives. Remember that not everybody speaks Japanese or Chinese, and
    sometimes symbols are similar to others.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Unicode字符时要小心；你可能会让其他团队成员的生活变得复杂。记住，并不是每个人都讲日语或中文，有时符号可能与其他符号相似。
- en: We also learned that it's possible to write an integer in hexadecimal; it's
    only necessary to add the prefix `0x`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还了解到，可以以十六进制形式编写整数；只需要添加前缀`0x`。
- en: There's more…
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: If you want to see more Unicode symbols, there are some pages that can help
    us. I recommend [http://unicode-table.com](http://unicode-table.com) and [http://www.alanwood.net/demos/wingdings.html](http://www.alanwood.net/demos/wingdings.html).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想看到更多的Unicode符号，有一些页面可以帮助我们。我推荐[http://unicode-table.com](http://unicode-table.com)和[http://www.alanwood.net/demos/wingdings.html](http://www.alanwood.net/demos/wingdings.html)。
- en: Searching for perfect numbers
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索完美数
- en: Believe it or not, computers were born as giant calculators, and until now,
    their main function was to do powerful calculations. Let's add a little bit of
    math to our Swift project to create an app that will look for the first perfect
    number and show it to the user.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 信不信由你，计算机最初是作为大型计算器出现的，直到现在，它们的主要功能是进行强大的计算。让我们在我们的Swift项目中添加一点数学知识，创建一个应用程序来寻找第一个完美数并将其显示给用户。
- en: 'The main question you probably have now is: what''s a perfect number? A perfect
    number is a positive integer that is equal to the sum of its divisors. For example,
    6 is a perfect number because if you sum its divisors (1 + 2 + 3), its result
    is 6.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可能有的主要问题是：什么是完美数？完美数是一个正整数，它等于其因数的和。例如，6是一个完美数，因为如果你将其因数相加（1 + 2 + 3），其结果是6。
- en: In this recipe, we will learn how to use the range operators.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用范围运算符。
- en: Getting ready
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's start by creating a new Swift project called `Chapter2 Perfect Number`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个名为`Chapter2 Perfect Number`的新Swift项目开始。
- en: How to do it…
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Follow these steps to search for perfect numbers:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤搜索完美数：
- en: Click on the storyboard and create a layout similar to the one shown here:![How
    to do it…](img/00029.jpeg)
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击故事板并创建一个类似于这里显示的布局：![如何操作…](img/00029.jpeg)
- en: 'Now, let''s link the text fields with the following properties:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将文本字段与以下属性链接：
- en: '[PRE17]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Good, before we create the button action, we will create a function called
    `isPerfect`, which will check whether the number passed as an argument is a perfect
    number or not. After this, we will create the button action:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，在我们创建按钮动作之前，我们将创建一个名为`isPerfect`的函数，该函数将检查作为参数传递的数字是否为完美数。之后，我们将创建按钮动作：
- en: '[PRE18]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works…
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As you can see, we used a `for` loop twice. The first time we used the closed-range
    operator (`…`), which was used to include the last number (`rangeEnd`), because
    we want to check the last number the user entered.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用了两次`for`循环。第一次我们使用了闭区间运算符(`…`)，它用于包含最后一个数字(`rangeEnd`)，因为我们想检查用户输入的最后一个数字。
- en: The second time we used the half-open operator (`..<`) to exclude the last number
    because we don't want to include the last number into the sum.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次我们使用了半开区间运算符(`..<`)来排除最后一个数字，因为我们不想将最后一个数字包含在总和内。
- en: Note
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The first version of Swift, the half-open operator, was only two dots (`..`).
    After some beta versions, it was renamed to `..<`. For this reason, you can find
    some code on the Internet that does not work anymore.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Swift的第一个版本中，半开区间运算符仅由两个点(`..`)组成。经过一些测试版本后，它被重命名为`..<`。因此，您可以在互联网上找到一些不再工作的代码。
- en: You can also use these operators on `switch` statements; they are very handy
    sometimes, mainly when you don't want to write the typical C `for` loop.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在`switch`语句中使用这些运算符；有时它们非常方便，尤其是在您不想编写典型的C语言`for`循环时。
- en: Sorting an array of products
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序产品数组
- en: In this recipe, we will learn how to manage an array in Swift. Here, we will
    create an array of products (very typical), add products to it, remove unavailable
    products, and sort the array by price.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何在Swift中管理数组。在这里，我们将创建一个产品数组（非常典型），向其中添加产品，删除不可用的产品，并按价格排序数组。
- en: Getting ready
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new Swift single view project called `Chapter 2 SortingProduct`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`Chapter 2 SortingProduct`的新Swift单视图项目。
- en: How to do it…
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s create and sort an array of products by following these steps:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤创建和排序产品数组：
- en: 'Before we start with the view part, let''s create the model part of our application.
    In our case, we will create the `Product` class. So, create a new file called
    `Product.swift` and type the following code:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们开始视图部分之前，让我们创建应用程序的模型部分。在我们的例子中，我们将创建`Product`类。因此，创建一个名为`Product.swift`的新文件，并输入以下代码：
- en: '[PRE19]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, the idea of this class is to create objects with their name,
    price, and availability. We also inherited it from `CustomStringConvertable` to
    make use of its `description` property.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，这个类的想法是创建具有其名称、价格和可用性的对象。我们还从`CustomStringConvertable`继承，以利用其`description`属性。
- en: Now you can click on the storyboard and add two labels, one for the full catalog,
    which means that it will show every product in its original order, no matter how
    much it costs or whether it's available or not.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以在故事板中点击并添加两个标签，一个用于完整目录，这意味着它将按原始顺序显示每个产品，无论其价格如何或是否可用。
- en: 'The other label will show the same products but filtered for availability and
    sorted by price. So, now link your labels with the following properties and also
    create a product array as a property:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个标签将显示相同的产品，但根据可用性进行过滤并按价格排序。因此，现在将您的标签与以下属性链接，并创建一个产品数组属性：
- en: '[PRE20]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can create additional labels if you want to know their meaning. I created
    one with the title `Catalog` and another one with the title `Available Products`.
    It is also important to set a new number of lines on `catalogLabel` and `availableLabel`;
    otherwise, it will display only the first product.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想了解它们的含义，可以创建额外的标签。我创建了一个标题为`Catalog`的标签，另一个标题为`Available Products`的标签。在`catalogLabel`和`availableLabel`上设置新的行数也很重要；否则，它将只显示第一个产品。
- en: 'The next step is to create the initialize; here, we only need to add some products
    to our array. As it''s just a sample, the products will be hardcoded, but in real
    apps, we should retrieve them from a database or from the Internet:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是创建初始化；在这里，我们只需要向我们的数组中添加一些产品。由于这是一个示例，产品将是硬编码的，但在实际应用程序中，我们应该从数据库或互联网上检索它们：
- en: '[PRE21]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After this, we can display our catalog when the view has loaded so that we
    can start using our `catalog` label:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此之后，当视图加载完成后，我们可以显示我们的目录，这样我们就可以开始使用我们的`catalog`标签：
- en: '[PRE22]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Okay, now it is time to add a button and create its action:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，现在是我们添加按钮并创建其动作的时候了：
- en: '[PRE23]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The application is done; once you click on the button, you will see a result
    similar to the one shown here:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序已完成；一旦你点击按钮，你将看到类似于这里所示的结果：
- en: '![How to do it…](img/00030.jpeg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](img/00030.jpeg)'
- en: How it works…
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Arrays in Swift are very similar to mutable arrays in Objective-C; they can
    add objects, remove them, and so on, but there are some differences. In the Swift
    programming language, you have to specify the object type that the array contains,
    like we did when we wrote the type between brackets.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Swift中的数组与Objective-C中的可变数组非常相似；它们可以添加对象、删除对象等等，但也有一些区别。在Swift编程语言中，你必须指定数组包含的对象类型，就像我们在括号中写类型时做的那样。
- en: Tip
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can create an array of any kind of object, as we used to do in Objective-C,
    by declaring a variable as `[AnyObject]`. However, this should be avoided if it's
    not necessary. There is also the possibility of using NSArray instead of Array;
    in this case, we will have the same methods that we have for Objective-C.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建任何类型的对象数组，就像我们以前在Objective-C中做的那样，通过声明一个变量为`[AnyObject]`。然而，如果这不是必要的，应该避免这样做。还有使用`NSArray`而不是`Array`的可能性；在这种情况下，我们将拥有与Objective-C相同的函数。
- en: You can also see something new on the `viewDidLoad` method; we called a closure
    named `map`, and this is because we want to create a big string with every product
    from our catalog delimited by a new line character (`\n`). To do this, we had
    to convert our `Product` array to a `String` array. The `map` function helps us
    with this because we can pass one function as an argument function that converts
    each element into the desired new type.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在`viewDidLoad`方法中看到一些新的内容；我们调用了一个名为`map`的闭包，这是因为我们想要创建一个包含我们目录中每个产品的大字符串，每个产品由一个换行符（`\n`）分隔。为了做到这一点，我们必须将我们的`Product`数组转换为`String`数组。`map`函数帮助我们做到这一点，因为我们可以将一个函数作为参数传递，该函数将每个元素转换为所需的新类型。
- en: Another new function is the `filter` function; this function receives another
    function as an argument, which returns a Boolean value. If the returned value
    is true, it means that the current element is valid and shouldn't be filtered;
    if the returned value is false, of course the new array will not contain this
    element.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个新函数是`filter`函数；这个函数接收另一个函数作为参数，该函数返回一个布尔值。如果返回的值是true，这意味着当前元素是有效的，不应该被过滤；如果返回的值是false，当然新的数组将不包含这个元素。
- en: Last but not least, we have the `sort` function. This function doesn't create
    a new array; it modifies the current one. Consider that, in this case, we have
    an array of our own class, something that the compiler doesn't know how to order.
    In this case, we have to tell this function when two objects are ordered and when
    they are not.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们有`sort`函数。这个函数不会创建一个新的数组；它修改当前的数组。考虑这种情况，我们有一个我们自己的类数组，这是编译器不知道如何排序的。在这种情况下，我们必须告诉这个函数何时两个对象是有序的，何时不是。
- en: Tip
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Take care when using functions that modify an array; once it's done, you can't
    roll back.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用修改数组的函数时要小心；一旦完成，就无法回滚。
- en: There's more...
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are two ways of declaring an array, one of them is the way we did using
    brackets, and the other form of declaring an array is using `Array<Product>`.
    There is no difference; they create the same kind of object. In both cases, you
    can't inherit from this type.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 声明数组有两种方式，其中一种是我们使用括号的方式，另一种声明数组的方式是使用`Array<Product>`。它们没有区别；它们创建相同类型的对象。在两种情况下，你都不能从这个类型继承。
- en: Tip
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Arrays were declared such as `Type[]` on the first version of Swift, then it
    was replaced by `[Type]`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Swift中数组的声明最初是`Type[]`，然后被替换为`[Type]`。
- en: There are more array functions that can help us to manipulate the array such
    as `reduce`, `reverse`, or `removeRange`. If you've worked with NoSQL databases,
    you might be habituated to this kind of function. You can also create an array
    extension to manipulate arrays in your own way.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 有更多数组函数可以帮助我们操作数组，例如`reduce`、`reverse`或`removeRange`。如果你与NoSQL数据库合作过，你可能已经习惯了这类函数。你还可以创建一个数组扩展，以你自己的方式操作数组。
- en: Finding the way out
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找出路的方法
- en: In this recipe, you will learn about tuples. This new type didn't exist in Objective-C
    and it's very useful in Swift, mainly when it's necessary to return more than
    one value. For example, there are a lot of functions that need to return a value
    and an error code. In other languages, we usually return the value and the error
    value is returned as an argument.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将了解元组。这种新类型在 Objective-C 中不存在，在 Swift 中非常有用，尤其是在需要返回多个值时。例如，有很多函数需要返回一个值和一个错误代码。在其他语言中，我们通常返回值，而错误值作为参数返回。
- en: You will also learn how to use a two-dimensional array, which in Objective-C
    was more complicated. In this case, we will use an array of an enumeration.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将学习如何使用二维数组，在 Objective-C 中这要复杂得多。在这种情况下，我们将使用枚举类型的数组。
- en: So, this time, we will create an application that will find the way out of a
    maze. Of course, we will not waste our time designing a maze; we will present
    the result into a text view.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这次我们将创建一个应用程序，它将找到迷宫的出口。当然，我们不会浪费时间设计迷宫；我们将结果展示在文本视图中。
- en: Getting ready
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new Swift single view project called `Chapter 2 Maze`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 Swift 单视图项目，命名为 `Chapter 2 Maze`。
- en: How to do it…
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'First, let''s create the model part of this maze. The maze for us is an array
    with four different possibilities: walls that we can''t pass through, aisles where
    we can walk through, a way out that is our goal, and used, which means that we''ve
    already used this path so we shouldn''t use it again; this will prevent walking
    around in circles. So, the first thing we will do is to create a file called `Maze`
    and add the following code:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建这个迷宫的模型部分。对我们来说，迷宫是一个有四种不同可能性的数组：我们不能穿过的墙壁，我们可以穿过的通道，我们的目标出口，以及已使用，这意味着我们已经使用过这条路径，所以不应该再次使用它；这将防止我们绕圈子走。所以，我们首先要做的是创建一个名为
    `Maze` 的文件，并添加以下代码：
- en: '[PRE24]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Before we start implementing our `maze` class, we know that we will need a
    type to store one coordinate of the maze and another one to know whether the path
    was found, and in the case it is found, we should have the path that is found:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们开始实现 `maze` 类之前，我们知道我们需要一个类型来存储迷宫的一个坐标，另一个类型来知道路径是否找到，如果找到了，我们应该有找到的路径：
- en: '[PRE25]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Good, now it''s time to create our class; in this case, we will need a two-dimensional
    array that represents the maze, another array that will contain the path to the
    way out, and two properties to know the width and the height of the maze:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，现在是我们创建我们的类的时候了；在这种情况下，我们需要一个二维数组来表示迷宫，另一个数组将包含通往出口的路径，以及两个属性来知道迷宫的宽度和高度：
- en: '[PRE26]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The first method that we will create is the initializer; in this case, it will
    be necessary to create a maze specifying its size. When we create the two-dimensional
    array, we will fill it with `AISLE`; to create walls, we will use another method
    that we will create afterwards:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将要创建的第一个方法是初始化器；在这种情况下，我们需要创建一个指定其大小的迷宫。当我们创建二维数组时，我们将用 `AISLE` 填充它；为了创建墙壁，我们将使用稍后创建的另一个方法：
- en: '[PRE27]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now we need methods to create the walls and the way out. In a more completed
    case, we should check whether the position is valid or not, but in this case,
    we will not bother ourselves with every detail. So, here are the methods:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要创建创建墙壁和出口的方法。在更完整的情况下，我们应该检查位置是否有效，但在这个例子中，我们不会纠结于每一个细节。所以，这里有一些方法：
- en: '[PRE28]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The next operation is to create the main method that will try to figure out
    one way to exit from the maze. In this case, the programmer shouldn''t give the
    start point so that this method will have no argument, but we need to walk through
    the maze. However, the idea is to create a recursive function that will receive
    a new position and look for the next position, which is why this second function
    is private:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个操作是创建主方法，该方法将尝试找出一种从迷宫中退出的方法。在这种情况下，程序员不应该给出起点，因此这个方法将没有参数，但我们需要在迷宫中行走。然而，想法是创建一个递归函数，该函数将接收一个新的位置并寻找下一个位置，这就是为什么第二个函数是私有的：
- en: '[PRE29]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may have noticed by this code that Swift has lazy evaluation. This is a
    good thing because we didn't have to create a nested `if` function when we had
    to check whether the position was inside the array bound.
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能已经注意到，Swift 有懒加载。这是一件好事，因为我们不必在检查位置是否在数组边界内时创建嵌套的 `if` 函数。
- en: 'Now it''s time to complete our sample. Go to the storyboard and add a text
    view and a button to it. Link the text view with your code, calling it `textView`.
    Then, create an action for your button, adding the following code:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候完成我们的示例了。转到故事板，并向其中添加一个文本视图和一个按钮。将文本视图与你的代码链接，命名为 `textView`。然后，为你的按钮创建一个动作，添加以下代码：
- en: '[PRE30]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works…
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: A lot of code needs some explanation. Let's start from the beginning. We've
    created an enumeration with four possible values. It is better to use enumerations
    than an integer or a string because you prevent the usage of non-existing values.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 许多代码需要一些解释。让我们从开始讲起。我们创建了一个包含四个可能值的枚举。使用枚举比使用整数或字符串更好，因为这样可以防止使用不存在的值。
- en: After this, we've declared two type aliases; the idea of this instruction is
    to rename a type like we did with `Position` and `Way`. This doesn't create a
    new type but helps us in terms of software maintenance; for example, if you use
    an array of integers that has a possibility of being changed to an array of doubles,
    it's a better idea to use a `typealias` than replace every declaration to `[Double]`.
    This feature is equivalent to `typedef` on the C programming language.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们声明了两个类型别名；这个指令的想法是将类型重命名，就像我们之前对 `Position` 和 `Way` 做的那样。这不会创建一个新的类型，但有助于我们在软件维护方面；例如，如果你使用一个可能被更改为双精度浮点数数组的整数数组，使用
    `typealias` 比替换每个声明为 `[Double]` 更好。这个特性与 C 编程语言中的 `typedef` 相当。
- en: Now, let's talk about the attributes. The first attribute is not optional and
    this is inside double brackets, which means that it is a two-dimensional array.
    Usually, by human definition, we say that the first dimension of an array is the
    row and the second is the column.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们谈谈属性。第一个属性不是可选的，它位于双括号内，这意味着它是一个二维数组。通常，根据人类的定义，我们说数组的第一个维度是行，第二个是列。
- en: When we talk about positions, for example, in a Cartesian plane, we refer to
    `x` as the columns and `y` as the rows, and this is the reason why you will see
    the `y` coordinate coming before the `x` one, such as `maze[position.y][position.x+1]
    == .AISLE`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论位置时，例如，在笛卡尔平面上，我们将 `x` 称为列，将 `y` 称为行，这也是为什么你会看到 `y` 坐标在 `x` 前面的原因，例如 `maze[position.y][position.x+1]
    == .AISLE`。
- en: 'The stack is also a non-optional attribute because we don''t need the nil value,
    but this means that we must initialize it with something. As we initialize every
    time when `findWayOut` is called, and the first time it will be initialized twice:
    one on the initializer and another inside the function itself. To prevent this
    double initialization, we will add the `lazy` modifier, which means that it should
    be initialized with the same value in the declaration only the first time that
    this variable is going to be read if it wasn''t initialized before.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 栈也是一个非可选属性，因为我们不需要 nil 值，但这意味着我们必须用某些东西来初始化它。由于我们每次调用 `findWayOut` 时都会初始化它，第一次初始化将会两次：一次在初始化器中，另一次在函数内部。为了防止这种双重初始化，我们将添加
    `lazy` 修饰符，这意味着它只应该在变量第一次被读取且之前未初始化时，使用声明中相同的值进行初始化。
- en: Note
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It used to be `@lazy` instead of just `lazy` on the first version of Swift.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 的第一个版本中，它曾经是 `@lazy` 而不是仅仅 `lazy`。
- en: Let's talk about the initializer; to create a maze, it's necessary to receive
    the width and the height as arguments. As the arguments have the same name as
    the attributes, it's necessary to differentiate between them. In this case, the
    attributes are called `self.width` and `self.height`, and the arguments are called
    `width` and `height`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈初始化器；要创建一个迷宫，必须接收宽度和高度作为参数。由于参数与属性具有相同的名称，因此有必要区分它们。在这种情况下，属性被称为 `self.width`
    和 `self.height`，而参数被称为 `width` 和 `height`。
- en: The next step is the wildcard expression, which means that the current value
    of the `for` loop is not used. In this case, instead of assigning it to a variable,
    we just use an underscore. Notice that the underscore is used in both loops and
    the inner loop doesn't affect the outer loop, and vice versa.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是通配符表达式，这意味着 `for` 循环的当前值没有被使用。在这种情况下，我们不是将其分配给一个变量，而是直接使用下划线。请注意，下划线在两个循环中都使用，并且内循环不会影响外循环，反之亦然。
- en: 'There is another way to create an array in only one line; this should be even
    more efficient because it''s different when you create an array with a capacity
    rather than adding each element one by one. Try replacing both the `for` loops
    with this single line:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 创建数组还有另一种只在一行中完成的方法；这应该更加高效，因为当你创建具有容量的数组时，它与逐个添加每个元素是不同的。尝试用这行代码替换两个 `for`
    循环：
- en: '[PRE31]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The next two methods are very similar, but one of them has the prefix `add`
    and the other one has the prefix `set`. It's only for software maintenance; we
    can have lots of walls, but only one way out. In this code, we are not checking
    it but it should be checked in the future. In cases like this, instead of a setter,
    we can use a property.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个方法非常相似，但一个有前缀 `add`，另一个有前缀 `set`。这只是为了软件维护；我们可以有很多墙壁，但只有一个出口。在这段代码中，我们没有检查它，但将来应该进行检查。在这种情况下，我们不是使用设置器，而是可以使用属性。
- en: Another thing to add here is that when the attributes were assigned, it wasn't
    necessary to specify the enumeration type, such as `BlockType.WALL`, but only
    its value, for example, `.WALL`. The reason for this is that Swift knows the assigned
    type and that it can be omitted.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一点要补充的是，当属性被分配时，没有必要指定枚举类型，例如 `BlockType.WALL`，只需指定其值，例如，`.WALL`。原因是 Swift
    知道分配的类型，并且可以省略。
- en: Then, we have the method that will be called to find the way out. It only initializes
    the stack to ensure that it is an empty array and then it calls the `next` function.
    Note that this looks like we have a function with double parentheses, but it's
    not true, we are passing a tuple as an argument.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有将用于找到出口的方法。它只初始化栈以确保它是一个空数组，然后调用 `next` 函数。请注意，这看起来像我们有一个双圆括号函数，但事实并非如此，我们正在将一个元组作为参数传递。
- en: Tuples are like arrays with a fixed size. To create it, use parenthesis instead
    of brackets. The interesting feature about tuples in Swift is that you can name
    the values as if it were a dictionary or an object. So, it's up to you to create
    a tuple as `(0,0)` or `(x:0, y:0)`. In cases like the `Way` type, where the elements
    have different meaning, I would suggest that you name the values; otherwise, it
    would be very difficult to remember what the element on the first position represents,
    if there is a path for way out or not, and that the second one represents the
    path itself.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 元组类似于固定大小的数组。创建它时，使用圆括号而不是方括号。Swift 中元组的一个有趣特性是你可以像字典或对象一样命名值。因此，你可以选择将元组创建为
    `(0,0)` 或 `(x:0, y:0)`。在像 `Way` 类型这样的情况下，其中元素有不同的含义，我建议你命名这些值；否则，如果有一个通往出口的路径，或者第二个元素代表路径本身，那么很难记住第一个位置上的元素代表什么。
- en: Also, have a look at the view controller when the `findWayOut` method returns
    its values. This looks like that they are assigned to a tuple, but it's not true,
    they are assigned to two variables; this feature we didn't have on C or Objective-C.
    This means that if you want to swap the values of two variables, you can just
    use a sentence, for example, `(var1, var2) = (var2, var1)`, without creating any
    auxiliary variable as we used to do on Objective-C.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，当 `findWayOut` 方法返回其值时，查看视图控制器。这看起来像它们被分配给一个元组，但事实并非如此，它们被分配给两个变量；这是我们在
    C 或 Objective-C 上没有的特性。这意味着如果你想要交换两个变量的值，你只需使用一个语句，例如 `(var1, var2) = (var2, var1)`，而不需要创建任何辅助变量，就像我们在
    Objective-C 上所做的那样。
- en: In this recipe, we used an array as a stack to store the path that we've already
    walked through, and using the `removeLast` method we could return back a step,
    as if we had some kind of breadcrumb and that is the secret to finding the way
    out. We just need to follow a path, and if we get lost, we only need to collect
    the breadcrumbs and try another one.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用数组作为栈来存储我们已经走过的路径，并使用 `removeLast` 方法返回一步，就像我们有一些面包屑一样，这是找到出口的秘密。我们只需要遵循一条路径，如果我们迷路了，我们只需要收集面包屑并尝试另一条。
- en: 'After finding the goal, the user will see the path as shown in the following
    screenshot:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在找到目标后，用户将看到如下截图所示的路径：
- en: '![How it works…](img/00031.jpeg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/00031.jpeg)'
- en: There's more…
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Tuples in Swift can be used in different ways; they are also very useful in
    some switch cases; however, don't try to substitute dictionaries or arrays with
    tuples, each type has its own function.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 中的元组可以用不同的方式使用；它们在某些 `switch` 情况下也非常有用；然而，不要尝试用元组替换字典或数组，每种类型都有自己的功能。
- en: Note
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Swift 1.2 introduced a native type called `Set` that does what this recipe does.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 1.2 引入了一种称为 `Set` 的本地类型，它执行这个菜谱所做的工作。
- en: Creating your own set
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自己的集合
- en: Sometimes the included set type in Swift is not enough to solve our problems,
    so in this recipe, we will create our own set. The goal of this recipe is not
    only to show how you could create your own set, but also how to overload operators.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 有时 Swift 中包含的集合类型不足以解决我们的问题，因此在这个菜谱中，我们将创建自己的集合。这个菜谱的目标不仅是展示如何创建自己的集合，还包括如何重载运算符。
- en: For this recipe, we will create a simple shopping list program where the user
    can write the product that he needs to buy and its quantity. If he tries to add
    it twice, the product will not appear twice, rather it will sum the quantity to
    the existing product.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将创建一个简单的购物列表程序，用户可以写下他需要购买的产品及其数量。如果他尝试添加两次，产品不会出现两次，而是将数量加到现有产品上。
- en: There will be a switch button that when disabled means the user won't be able
    to add the product to the shopping list if it already exists, and of course, there
    will be a button to display our list.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 将会有一个开关按钮，当它被禁用时，意味着如果产品已经存在于购物列表中，用户将无法将其添加到购物列表中，当然，也会有一个按钮来显示我们的列表。
- en: Getting ready
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: As usual, create a new project called `Chapter2 ShoppingList`, and then create
    a Swift file called `ShoppingList`. The idea here is to create our container and
    the type that it will store; in this case, the `Product` class.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，创建一个名为 `Chapter2 ShoppingList` 的新项目，然后创建一个名为 `ShoppingList` 的 Swift 文件。这里的想法是创建我们的容器以及它将存储的类型；在这种情况下，是
    `Product` 类。
- en: How to do it…
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Product is something that is related with our container; we can even say that
    this is like a part of it. So, in this case, we can create a nested class to work
    with it. In this class, we will need only two attributes: its name and its quantity.
    Follow these steps to create your own sets:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 产品是与我们的容器相关的东西；我们甚至可以说这是它的一部分。因此，在这种情况下，我们可以创建一个嵌套类来与之一起工作。在这个类中，我们只需要两个属性：它的名称和它的数量。按照以下步骤创建自己的集合：
- en: 'In this case, we will create its description, and it will implement the `Comparable`
    protocol. We will use this protocol to know whether two objects represent the
    same product. Let''s start coding:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将创建其描述，并实现 `Comparable` 协议。我们将使用这个协议来确定两个对象是否代表相同的产品。让我们开始编码：
- en: '[PRE32]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now we need to create the shopping list attributes. We only need an array to
    store our products:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要创建购物列表的属性。我们只需要一个数组来存储我们的产品：
- en: '[PRE33]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As the shopping list is a set, we should implement the basic methods. One method
    is used to add a product and another one is used to know whether the shopping
    list already has a product. And, of course, we will also add the `description`
    property:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于购物列表是一个集合，我们应该实现基本的方法。一个方法用于添加产品，另一个方法用于知道购物列表是否已经包含该产品。当然，我们还会添加 `description`
    属性：
- en: '[PRE34]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we compared a product with another using the double equality operator
    (`==`). The main question is how does the compiler make the comparison? Actually,
    the compiler can't make this comparison without the programmer's help. First of
    all, as you can see, we used the `Comparable` protocol in this program. This is
    not really necessary, but it's good to implement this protocol in case we also
    need to use a product with other containers.
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们使用双等号运算符（`==`）比较了一个产品与另一个。主要问题是编译器是如何进行比较的？实际上，没有程序员的帮助，编译器无法进行这种比较。首先，正如你所看到的，我们在程序中使用了
    `Comparable` 协议。这并不是必需的，但如果我们还需要使用产品与其他容器一起使用，实现这个协议是好的。
- en: 'Even if it''s a comparable, we have to implement a function that will tell
    the runtime whether two products are equals or not. This function must be called
    `==` (yes, double equals), and it must be declared on the global scope: outside
    classes and functions. So, here we have the corresponding code:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 即使它是一个比较，我们也必须实现一个函数，该函数将告诉运行时两个产品是否相等。这个函数必须命名为 `==`（是的，双等号），并且必须在全局范围内声明：在类和函数之外。因此，这里我们有相应的代码：
- en: '[PRE35]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If we were implementing only the `Equatable` protocol, we wouldn''t need to
    implement any other method; however, as we are implementing `Comparable`, we will
    also need to implement the operators `<`, `<=`, `>`, and `>=`:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们只实现 `Equatable` 协议，我们就不需要实现任何其他方法；然而，由于我们正在实现 `Comparable`，我们还需要实现运算符 `<`、`<=`、`>`
    和 `>=`：
- en: '[PRE36]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As we are creating some operators, let''s continue with them. Let''s overload
    the `+=` operator twice, once to add more units to a product and another to add
    a product into the shopping list:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们正在创建一些运算符，让我们继续。让我们重载 `+=` 运算符两次，一次用于向产品添加更多单位，另一次用于将产品添加到购物列表中：
- en: '[PRE37]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that it wasn't necessary to implement any protocol to overload this operator,
    and it wasn't even necessary for the previous operators, but it's a good idea
    to implement the `Comparable` protocol to use with other functions or algorithms.
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，重载这个操作符不需要实现任何协议，甚至之前的操作符也不需要，但实现`Comparable`协议以与其他函数或算法一起使用是一个好主意。
- en: Tip
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Implement the `Comparable` or `Equatable` protocols when you can use it with
    other generic objects, for example, when you think the object could be ordered.
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你可以使用它与其他泛型对象一起时，实现`Comparable`或`Equatable`协议，例如，当你认为对象可以被排序时。
- en: 'A good feature of Swift is that you don''t need to overload only existing operators;
    you can also create new operators. In this case, we will create two new operators:
    `=>` that will tell us whether a product is in our shopping list and `!=>`, which
    is the opposite operator. I will explain this in detail later. Use these operators
    in the following code:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Swift的一个好特性是，你不需要仅重载现有操作符；你还可以创建新的操作符。在这种情况下，我们将创建两个新的操作符：`=>`，它将告诉我们一个产品是否在我们的购物清单中，以及`!=>`，这是相反的操作符。我将在稍后详细解释。在以下代码中使用这些操作符：
- en: '[PRE38]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now that the model is done, let''s create the view. Enter two text fields:
    one for the product name and another one for the quantity; one switch to allow
    appending products or not; two buttons, one to add the product to the list and
    another one to display the list; and a text view. Let''s connect them, except
    the buttons with the following attributes:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在模型已经完成，让我们创建视图。输入两个文本字段：一个用于产品名称，另一个用于数量；一个开关，允许添加产品或不添加；两个按钮，一个用于将产品添加到列表中，另一个用于显示列表；以及一个文本视图。让我们将它们连接起来，除了按钮具有以下属性：
- en: '[PRE39]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Add an attribute that represents the application shopping list:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个表示应用程序购物清单的属性：
- en: '[PRE40]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now we need to add the button actions. Let''s start with the easiest thing:
    the display button that will show the description of the shopping list into the
    text view:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要添加按钮动作。让我们从最容易的事情开始：显示按钮，它将购物清单的描述显示到文本视图中：
- en: '[PRE41]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now we have to create the add button action. In this case, it will be necessary
    to check whether the user introduced a number on the quantity text field and also
    whether it was possible to add the product to the shopping list:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们必须创建添加按钮的动作。在这种情况下，将需要检查用户是否在数量文本字段中输入了数字，以及是否可能将产品添加到购物清单中：
- en: '[PRE42]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `clear` function is just an auxiliary method to empty the text fields every
    time we press the add button:'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`clear`函数只是一个辅助方法，每次我们按下添加按钮时都会清空文本字段：'
- en: '[PRE43]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now you can click on play and add some products, repeat some products, and display
    them. You should have a result like the one shown here:![How to do it…](img/00032.jpeg)
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你可以点击播放并添加一些产品，重复一些产品，并显示它们。你应该得到一个像这里显示的结果：![如何操作…](img/00032.jpeg)
- en: How it works…
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Overloading operators is something very common in Swift; you can overload existing
    operators and you can create your own operator. If you want to create your own
    operator, the first thing you have to do is to report some properties of your
    operator. First, you have to choose if you type the usage:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，重载操作符是非常常见的；你可以重载现有操作符，也可以创建你自己的操作符。如果你想创建自己的操作符，你必须首先报告一些关于你的操作符的属性。首先，你必须选择你想要的使用类型：
- en: '**Infix**: This means that the operator is used between two objects; for example,
    in our sample, we created the `!=>` operator to be used between a product and
    a set.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中缀**：这意味着操作符用于两个对象之间；例如，在我们的示例中，我们创建了`!=>`操作符，用于在产品和集合之间使用。'
- en: '**Prefix**: This means that the operator will operate only with the object
    that is on its right. For example, let''s imagine that we would like to create
    the `!!!` operator, which could mean that we would like to empty the shopping
    list; in this case, we should use it as `!!!shoppingList`.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前缀**：这意味着操作符将只与它右边的对象一起操作。例如，让我们想象我们想要创建一个`!!!`操作符，这可能意味着我们想要清空购物清单；在这种情况下，我们应该将其用作`!!!shoppingList`。'
- en: '**Postfix**: This operator will operate only with the object that is on its
    left, such as `shoppingList!!!`.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后缀**：这个操作符将只与它左边的对象一起操作，例如`shoppingList!!!`。'
- en: 'The next step is to write the word `operator` and the name you''ve chosen for
    it. After this, you have to add between parentheses the properties of this operator.
    Associativity values are left, right, and none. This is as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是写下`operator`和为其选择的名字。之后，你必须在这个操作符的属性之间添加括号。结合值是左结合、右结合和无结合。如下所示：
- en: '**Left-associative**: This means that when there''s more than one operator
    with the same precedence, the one that is furthest left is going to be evaluated
    first'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**左关联性**：这意味着当有多个具有相同优先级的运算符时，最左边的一个将被首先评估'
- en: '**Right-associative**: This, as you can imagine, is the opposite of the left-associative'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**右关联性**：正如您所想象的那样，这是左关联性的相反'
- en: '**None-associative**: This means that it''s not permitted to have more than
    one operator with the same precedence'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非关联性**：这意味着不允许有多个具有相同优先级的运算符'
- en: Precedence is like a priority. Higher precedence is evaluated first.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 优先级就像优先级。优先级高的先被评估。
- en: There's more…
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Swift allows changing the function of existing operators, for example, you
    can declare the following function:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Swift允许改变现有运算符的功能，例如，您可以声明以下函数：
- en: '[PRE44]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This will make every integer sum operator return `10`. This is something curious,
    but I wouldn''t do that in sane conditions. Even worse than this is if you create
    recursive calls like this code:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使每个整数求和运算符返回`10`。这很有趣，但在正常情况下我不会这样做。更糟糕的是，如果你创建递归调用，就像这样：
- en: '[PRE45]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Organizing a dinner room
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织宴会厅
- en: In this recipe, we will learn how to use other features from the Swift programming
    language. We will copy the range of elements from an array, use dictionaries,
    subscripts, switches, and name a loop.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用Swift编程语言的其他功能。我们将从数组中复制元素的范围，使用字典，下标，switch，并命名循环。
- en: For this app, we will create a dinner for a company. In this case, it's not
    a wedding table where couples must be seated next to each other, rather we only
    need people of the same group sat together on the same table, probably because
    they are from the same team or something similar.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个应用，我们将为一家公司举办一场晚宴。在这种情况下，这并不是一个婚礼餐桌，夫妻必须坐在一起，而是我们只需要同一组的人坐在同一张桌子上，可能是因为他们来自同一个团队或类似的原因。
- en: We will create a class that represents a room. To add a new guest into this
    room, we will need to specify the name of someone who belongs to this group, which
    is already inside the room. If the person we want to add to this room is the first
    one, we will use the nil value as the name of the person who belongs to this group.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个表示房间的类。要将新客人添加到这个房间，我们需要指定属于这个组的人的名字，这个人已经在房间里了。如果我们想添加到这个房间的人是第一个，我们将使用nil值作为属于这个组的人的名字。
- en: In the case of adding someone to a table that is full, one person from this
    table must be reallocated to another table. Of course, we won't use the most optimized
    algorithm because that's not our main goal.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要向已满的桌子添加某人，则必须将此桌上的一个人重新分配到另一张桌子上。当然，我们不会使用最优化算法，因为这不是我们的主要目标。
- en: Getting ready
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new Swift single view project called `Chapter2 DinnerRoom`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的Swift单视图项目，命名为`Chapter2 DinnerRoom`。
- en: How to do it…
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: As usual, we need to start with the model part of the Model-View-Controller.
    For this code, we will need a class for the room, another for a table that will
    store the seats with the person that is seated there, a group, which is the range
    of the table of people that belongs to the same team, and of course, we will also
    need a class to represent a person.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我们需要从模型部分的模型-视图-控制器开始。对于这段代码，我们需要一个表示房间的类，另一个表示存储坐在那里的人的座位和桌子，一个组，这是属于同一团队的桌子的人的范围，当然，我们还需要一个表示个人的类。
- en: 'Let''s start with the `person` class; in this case, we only need to store his
    name and the group he belongs to. As there is a period where the person can be
    without any group, this attribute should be optional. So, create a new Swift file
    called `person.swift` and add the following code:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从`person`类开始；在这种情况下，我们只需要存储他的名字和他所属的组。由于有一个人可以没有任何组的时间段，这个属性应该是可选的。因此，创建一个新的Swift文件，命名为`person.swift`，并添加以下代码：
- en: '[PRE46]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As you can see, this class inherits from the `Equatable` protocol, which means
    that we must implement the `==` operator, as follows:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，这个类继承自`Equatable`协议，这意味着我们必须实现`==`运算符，如下所示：
- en: '[PRE47]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Good, now let''s create the `Group` class. Remember that a group doesn''t have
    a name; it''s just a range of people who are sitting together. In this case, we
    need to store where the range starts, where it finishes, and its table. As you
    may imagine, we need to create a file called `group.swift` and add the following
    code:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，现在让我们创建`Group`类。记住，一个组没有名字；它只是坐在一起的人的范围。在这种情况下，我们需要存储范围开始的地方，结束的地方，以及它的桌子。正如您所想象的那样，我们需要创建一个名为`group.swift`的文件，并添加以下代码：
- en: '[PRE48]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the `size` property has no setters, only a getter, and it's not related
    with a new attribute; that's what is called a `computed` property. Also, note
    that we had to add an `unowned` modifier to the `table` attribute; this is because
    if we had a UML class diagram, we can see that a room contains tables that contain
    people who belong to a group that knows its table. As you can see, we have a cycle,
    which by default would prevent the reference counter from reaching zero, and as
    a consequence, it would create a memory leak. Adding `unowned` will help us to
    avoid this problem.
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`size`属性没有setter，只有getter，并且它与新属性无关；这就是所谓的`computed`属性。此外，注意我们不得不给`table`属性添加一个`unowned`修饰符；这是因为如果我们有一个UML类图，我们可以看到房间包含桌子，桌子上有属于一个知道其桌子的小组成员。正如你所看到的，我们有一个循环，默认情况下会阻止引用计数器达到零，因此会创建内存泄漏。添加`unowned`将帮助我们避免这个问题。
- en: 'The next class is `Room`. This class needs to store its tables and also the
    guests that are already in the room. This second attribute is not mandatory, but
    it is faster for the computer looking into a dictionary than searching for it,
    and it is also faster for the programmer because he will write less code. Add
    `room.swift` to your project and start adding the following code:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个类是`Room`。这个类需要存储其桌子和已经进入房间的客人。第二个属性不是强制的，但计算机在字典中查找它比搜索它要快，对于程序员来说，这也更快，因为他将编写更少的代码。将`room.swift`添加到你的项目中，并开始添加以下代码：
- en: '[PRE49]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, look at the `guests` attribute, as we have two types between brackets
    and separated by a colon; this means that it''s not an array, it''s a dictionary.
    Alternatively, you can also write `Dictionary<String,Person>` instead of `[String:
    Person]`. One difference with dictionaries from Objective-C to Swift is that you
    must specify the key and the value types.'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在，看看`guests`属性，因为我们有两个类型在括号内，并用冒号分隔；这意味着它不是一个数组，而是一个字典。或者，你也可以写成`Dictionary<String,Person>`而不是`[String:
    Person]`。与Objective-C到Swift的字典相比，有一个区别是你必须指定键和值类型。'
- en: Note
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When possible, try to use dictionaries instead of searching for elements, as
    you will have a better performance.
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当可能时，尽量使用字典而不是搜索元素，因为这样会有更好的性能。
- en: If you are a good observer, you can see that we repeated the `add` function.
    The difference is on the arguments type. This means that you can overload methods
    and functions in Swift.
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你是一个好的观察者，你会看到我们重复了`add`函数。区别在于参数类型。这意味着你可以在Swift中重载方法和函数。
- en: 'Now, to check whether someone is already in this room, we will use the brackets
    operator so we can type code such as `if room["Harry Potter"] == true {...`. To
    enable it in Swift, we have to write some kind of special function called subscript.
    In this case, we will write a read-only `subscript`:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了检查某人是否已经在这个房间里，我们将使用方括号操作符，这样我们就可以编写类似`if room["Harry Potter"] == true
    {...}`的代码。为了在Swift中启用它，我们必须编写一种特殊函数，称为subscript。在这种情况下，我们将编写一个只读的`subscript`：
- en: '[PRE50]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now we only need to use the same idea to add someone in the room; remember
    that we have to specify someone''s name from the same group or nil when it''s
    the first person. Following this idea, we can add someone into the room with a
    code similar to `room["Harry Potter"] = Person("David Copperfield")`:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们只需要使用相同的方法来添加一个人到房间中；记住，我们必须指定来自同一组的人的名字或当是第一个人时为nil。按照这个想法，我们可以用类似`room["Harry
    Potter"] = Person("David Copperfield")`的代码添加一个人到房间中：
- en: '[PRE51]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: As you can see, we added an assertion into the getter method of the subscript;
    the reason is that subscripts can be read-only or read-write but they can't be
    write-only. In this case, there is no sense in asking for a return value, so the
    only thing we can do is to create an assertion to prevent problems.
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们在subscript的getter方法中添加了一个断言；原因是subscripts可以是只读的或读写，但不能是只写的。在这种情况下，请求返回值是没有意义的，所以我们唯一能做的就是创建一个断言来防止问题。
- en: Tip
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Don't use `assertionFailure` regularly; try to create code that can detect errors
    and continue to work.
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不要经常使用`assertionFailure`；尽量创建可以检测错误并继续工作的代码。
- en: 'Create a new file called `table.swift`. Before we start coding the `Table`
    class, we need to know that a table will have an array of seats. We can have a
    free seat or an occupied one. If it''s occupied, it''s by someone, so we need
    to know who is occupying the seat. For cases such as this, Swift allows us to
    use enumerations:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`table.swift`的新文件。在我们开始编写`Table`类之前，我们需要知道一个桌子将有一个座位数组。我们可以有一个空座位或被占用的座位。如果它被占用，那么它是由某人占用的，因此我们需要知道谁占用了这个座位。对于这种情况，Swift允许我们使用枚举：
- en: '[PRE52]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The only problem with enumeration is that we need to use `switch` cases a lot
    of times, so in this case, where we want to know whether one seat is free or occupied
    by someone, it''s a good idea to overload the operators `==` and `!=`:'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 枚举的唯一问题是我们需要多次使用`switch`分支，所以在这种情况下，当我们想知道一个座位是否空闲或被某人占用时，重载运算符`==`和`!=`是一个好主意：
- en: '[PRE53]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now we can start typing the `Table` class. Basically, we need to store an array
    of seats, but we can have some auxiliary computed properties and methods, as follows:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以开始编写`Table`类了。基本上，我们需要存储一个座位数组，但我们可以有一些辅助的只读计算属性和方法，如下所示：
- en: '[PRE54]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Before giving much explanation, we will test the previous code by adding `textView`
    to our view controller and some people into `room.swift`:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在进行过多解释之前，我们将通过将`textView`添加到我们的视图控制器以及一些人员添加到`room.swift`中来测试之前的代码：
- en: '[PRE55]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: How it works...
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As you can see, we used some new features here. We were able to copy a range
    of seats using the `…` operator, which is an awesome feature that can save us
    from typing a lot of loops that do the same thing.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们在这里使用了一些新的特性。我们能够使用`…`运算符复制一系列座位，这是一个很棒的功能，可以节省我们编写大量执行相同操作的循环。
- en: Note
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that this slice operator (`…`), when working with a part of an array, the
    compiler can create a good optimization for a better performance.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个切片运算符（`…`），当与数组的一部分一起使用时，编译器可以为更好的性能创建一个良好的优化。
- en: 'Another good feature is the `switch` statement that can work with a combination
    of values. Look at the `==` operator and you''ll see that we don''t need to create
    inner switched cases for each case. Talking about the equalities operator, have
    a look at the `add` method that we used: `!==` instead of `!=`. The reason is
    that when we need to check whether two objects have the same instance, we have
    to use the operator `===` or `!==` to check whether they don''t share the same
    instance.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个很好的特性是能够与值组合使用的`switch`语句。看看`==`运算符，你会发现我们不需要为每个情况创建内部的switch分支。谈到等式运算符，看看我们使用的`add`方法：使用`!==`而不是`!=`。原因是当我们需要检查两个对象是否具有相同的实例时，我们必须使用运算符`===`或`!==`来检查它们是否不共享相同的实例。
- en: We also used a label to name a loop (searching), the reason for that is, by
    default, the `break` statement will exit from the switch, not from our loop. We
    can control this situation with some Boolean variables, but we can avoid it breaking
    with `break searching`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了一个标签来命名一个循环（搜索），这样做的原因是，默认情况下，`break`语句将退出`switch`，而不是我们的循环。我们可以通过一些布尔变量来控制这种情况，但我们可以通过`break
    searching`来避免它中断。
- en: Another good trick was walking in the reverse way on our arrays. We did it using
    the method reverse. Of course, we did it knowing that we have a small array; I
    can't imagine a table for one million people. Using reverse with big arrays is
    not a good idea because a new array will be created internally.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个很好的技巧是在我们的数组中以相反的顺序遍历。我们使用`reverse`方法做到了这一点。当然，我们知道我们有一个小数组；我无法想象一个有一百万人的表格。使用`reverse`处理大数组不是一个好主意，因为内部会创建一个新的数组。
- en: There's more…
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You can still use the old `NSDictionary` class, but I will follow the same rule
    that we saw with `NSArray`. Swift dictionaries are safer, and if you need a dictionary,
    store completely different object types. It would be better to review your code
    as it could be very painful to maintain this code.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然可以使用旧的`NSDictionary`类，但我会遵循我们在`NSArray`中看到的相同规则。Swift字典更安全，如果你需要一个字典，存储完全不同的对象类型。最好审查你的代码，因为这可能会非常痛苦地维护。
- en: You have only just started learning about assertions, but further on in this
    book, you will learn how to deal with assertions.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚开始学习断言，但在本书的后面部分，你将学习如何处理断言。
- en: When you need to work with functions without specifying the input or output
    type, Swift gives you the feature of generics. We will learn more about this in
    the next chapter.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要处理没有指定输入或输出类型的函数时，Swift为你提供了泛型的功能。我们将在下一章中了解更多关于这个内容。
