- en: More on Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多关于函数的内容
- en: In the previous chapters, we covered many features of Kotlin's functions. But
    now we'll expand on these many features, most of them borrowed from other languages,
    but with a new twist to fully accommodate them into Kotlin's overall goals and
    flavour—type-safety and pragmatical conciseness.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们介绍了Kotlin函数的许多特性。但现在我们将扩展这些特性，其中大多数是从其他语言借用的，但它们在Kotlin的整体目标和风格中有一个新的转折——类型安全和实用简洁。
- en: Some features, such as **Domain Specific Languages** (**DSLs**), let developers
    extend the language to domains that were not considered when Kotlin was first
    designed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一些特性，例如**领域特定语言**（**DSLs**），允许开发者扩展语言以适应在Kotlin最初设计时未考虑到的领域。
- en: 'At the end of this chapter, you''ll have a big picture of all function features,
    including:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将有一个关于所有函数特性的整体概念，包括：
- en: Extension functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展函数
- en: Operator overloading
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作符重载
- en: Type-safe builders
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型安全的构建器
- en: Inline functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内联函数
- en: Recursion and corecursion
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归和核心递归
- en: Single-expression functions
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单表达式函数
- en: Until now, all our examples were declared in a normal way.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有我们的例子都是以常规方式声明的。
- en: 'The function sum takes two `Int` values and adds them. Declared in a normal
    way, we must provide a body with curly braces and an explicit `return`:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum`函数接受两个`Int`类型的值并将它们相加。以常规方式声明，我们必须提供一个带有花括号和显式`return`的主体：'
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Our `sum` function has its body declared inside curly braces with a `return`
    clause. But if our function is just one expression, it could have been written
    in a single line:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`sum`函数其主体在花括号内声明，并包含一个`return`子句。但如果我们的函数只是一个表达式，它也可以写成一行：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So, no curly braces, no `return` clause, and an equals (`=`) symbol. If you
    pay attention, it just looks similar to a lambda.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，没有花括号，没有`return`子句，并且有一个等于（`=`）符号。如果你注意的话，它看起来与lambda非常相似。
- en: 'If you want to cut even more characters, you can use type inference too:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要减少更多字符，你还可以使用类型推断：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Use type inference for a function's return when it is very evident which type
    you are trying to return. A good rule of thumb is to use it for simple types such
    as numeric values, Boolean, string, and simple `data class` constructors. Anything
    more complicated, especially if the function does any transformation, should have
    explicit types. Your future self will be glad!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当返回类型非常明显时，可以使用类型推断来指定函数的返回类型。一个很好的经验法则是对于简单类型，如数值、布尔值、字符串和简单的`data class`构造函数使用它。任何更复杂的事情，特别是如果函数执行任何转换，都应该有显式的类型。你未来的自己会为此感到高兴！
- en: Parameters
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数
- en: 'A function can have zero or more parameters. Our function, `basicFunction`,
    takes two parameters, as shown in the following code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数可以有零个或多个参数。我们的函数`basicFunction`接受两个参数，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Each parameter is defined as `parameterName: ParameterType`, in our example, `name:
    String` and `size: Int`. Nothing new here.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '每个参数都定义为`parameterName: ParameterType`，在我们的例子中，`name: String`和`size: Int`。这里没有什么新的。'
- en: vararg
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: vararg
- en: 'It gets interesting when parameters have two types that we have already covered—`vararg`
    and lambdas:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当参数有两种我们已经讨论过的类型时，事情变得有趣——`vararg`和lambda：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A function with a parameter marked with the modifier, `vararg` can be called
    with zero or more values:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一个带有`vararg`修饰符的参数的函数可以用零个或多个值来调用：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A function can't have multiple `vararg` parameters, not even with different
    types.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数不能有多个`vararg`参数，即使是不同类型的也不行。
- en: Lambda
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda
- en: We already discussed how, if a function's last parameter is a lambda, it can't
    be passed outside the parenthesis and inside curly braces, as if the lambda itself
    is the body of a control structure.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了如果函数的最后一个参数是一个lambda，它不能放在括号外和花括号内，就像lambda本身是控制结构的主体一样。
- en: 'We covered this `unless` function in [Chapter 2](cd9fb97b-d5f0-41d6-b9fb-87259d07a390.xhtml),
    *Getting Started with Functional Programming*, in the section, *First-class and
    high-order functions*. Let''s have a look at the following code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第2章](cd9fb97b-d5f0-41d6-b9fb-87259d07a390.xhtml)“开始函数式编程”的“一等和高级函数”部分介绍了这个`unless`函数。让我们看看以下代码：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, what happens if we combine `vararg` and lambda? Let''s check it in the
    following code snippet:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们结合`vararg`和lambda会发生什么？让我们在下面的代码片段中检查一下：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Lambdas can be at the end of a function with a `vararg` parameter:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda可以放在带有`vararg`参数的函数的末尾：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s get a little adventurous, a `vararg` parameter of lambdas:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微冒险一点，一个lambda的`vararg`参数：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can''t pass a lambda outside of the parenthesis, but we can pass many lambdas
    inside:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能将lambda放在括号外，但我们可以将多个lambda放在括号内：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Named parameters
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名参数
- en: Ideally, our functions should not have too many parameters, but this isn't always
    the case. Some functions tend to be big, for example, the `data class` constructors
    (constructors are technically a function that returns a new instance).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们的函数不应该有太多的参数，但这并不总是如此。一些函数倾向于很大，例如，`data class` 构造函数（构造函数在技术上是一个返回新实例的函数）。
- en: What is the problem with functions with many parameters?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 参数众多的函数有什么问题？
- en: They are hard to use. This can be alleviated or fixed with default parameters
    that we will cover in the next section, *Default parameters*.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们很难使用。这可以通过下一节中将要介绍的默认参数来缓解或修复。
- en: They are hard to read—named parameters to the rescue.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们很难阅读——命名参数来拯救。
- en: They are probably doing too much. Are you sure that your function isn't too
    big? Try to refactor it and clean up. Look for possible side effects and other
    harmful practices. A special case is `data class` constructors, as they are just
    autogenerated assignments.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可能做得太多。你确定你的函数不是太大了吗？尝试重构它并清理。寻找可能的副作用和其他有害做法。一个特殊情况是 `data class` 构造函数，因为它们只是自动生成的赋值。
- en: With named parameters, you can add readability to any function invocation.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命名参数，你可以增加任何函数调用的可读性。
- en: 'Let''s use a `data class` constructor as an example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以 `data class` 构造函数为例：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'A normal invocation will look like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正常调用将看起来像这样：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'But including named parameters will increase the information available for
    the reader/maintainer and reduce mental work. We can also pass the parameters
    in any order that is more convenient or meaningful for the actual context:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 但包括命名参数将增加读者/维护者可获得的信息量，并减少心理工作。我们也可以以更方便或更有意义的顺序传递参数：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Named parameters are very useful when they are combined with a `vararg` parameter:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当与 `vararg` 参数结合使用时，命名参数非常有用：
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Named parameters on high-order functions
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高阶函数上的命名参数
- en: 'Usually when we define a high-order function, we never name the parameters
    for the lambda(s):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通常当我们定义高阶函数时，我们从不为 lambda(s) 命名参数：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'But it is possible to add them. So, the `f` lambda now has its parameters named—`age`
    and `name`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 但可以添加它们。因此，`f` lambda 现在有了命名的参数——`age` 和 `name`：
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This doesn''t change any behavior, it is just to give more clarity on the intended
    use of this lambda:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会改变任何行为，只是为了更清晰地说明这个 lambda 的预期用途：
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: But it isn't possible to call a lambda with named parameters. In our example,
    invoking `f` with names produces a compilation error.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 但使用命名参数调用 lambda 是不可能的。在我们的例子中，使用名称调用 `f` 会导致编译错误。
- en: Default parameters
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认参数
- en: 'In Kotlin, function parameters can have default values. For the `Programmer`,
    the `favouriteLanguage` and `yearsOfExperience` data classes have default values
    (remember that a constructor is a function too):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，函数参数可以有默认值。对于 `Programmer`，`favouriteLanguage` 和 `yearsOfExperience`
    数据类有默认值（记住，构造函数也是一个函数）：
- en: '[PRE18]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'So, `Programmer` can be created with just two parameters:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`Programmer` 可以只使用两个参数来创建：
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'But if you want to pass `yearsOfExperience`, it must be as a named parameter:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你想要传递 `yearsOfExperience`，它必须作为一个命名参数：
- en: '[PRE20]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can still pass all parameters if you want to, but they must be provided
    in the right order if you aren''t using named arguments:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要传递所有参数，你仍然可以这样做，但如果你不使用命名参数，它们必须以正确的顺序提供：
- en: '[PRE21]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Extension functions
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展函数
- en: 'Definitively, one of the best features of Kotlin is extension functions. Extension
    functions let you modify existing types with new functions:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，Kotlin 最好的特性之一是扩展函数。扩展函数允许你使用新函数修改现有类型：
- en: '[PRE22]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: To add an extension function to an existing type, you must write the function's
    name next to the type's name, joined by a dot (`.`).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要向现有类型添加扩展函数，你必须将函数的名称写在类型名称旁边，并用点 (`.`) 连接。
- en: In our example, we add an extension function (`sendToConsole()`) to the `String`
    type. Inside the function's body, `this` refers the instance of `String` type
    (in this extension function, `string` is the receiver type).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们向 `String` 类型添加了一个扩展函数 (`sendToConsole()`)。在函数体内部，`this` 指的是 `String`
    类型的实例（在这个扩展函数中，`string` 是接收器类型）。
- en: 'Apart from the dot (`.`) and `this`, extension functions have the same syntax
    rules and features as a normal function. Indeed, behind the scenes, an extension
    function is a normal function whose first parameter is a value of the receiver
    type. So, our `sendToConsole()` extension function is equivalent to the next code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 除了点（`.`）和`this`，扩展函数与普通函数具有相同的语法规则和功能。实际上，在幕后，扩展函数是一个普通函数，其第一个参数是接收者类型的值。因此，我们的`sendToConsole()`扩展函数等同于以下代码：
- en: '[PRE23]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'So, in reality, we aren''t modifying a type with new functions. Extension functions
    are a very elegant way to write utility functions, easy to write, very fun to
    use, and nice to read—a win-win. This also means that extension functions have
    one restriction—they can''t access private members of `this`, in contrast with
    a proper member function that can access everything inside the instance:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，实际上我们并没有通过新函数修改类型。扩展函数是一种非常优雅地编写实用函数的方法，易于编写，使用起来非常有趣，阅读起来也很愉快——双赢。这也意味着扩展函数有一个限制——它们不能访问`this`的私有成员，而一个合适的成员函数可以访问实例内的所有内容：
- en: '[PRE24]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Invoking an extension function is the same as a normal function—with an instance
    of the receiver type (that will be referenced as `this` inside the extension),
    invoke the function by name.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 调用扩展函数与调用普通函数相同——使用接收者类型的实例（在扩展函数内部将引用为`this`），通过名称调用函数。
- en: Extension functions and inheritance
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展函数与继承
- en: There is a big difference between member functions and extension functions when
    we talk about inheritance.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论继承时，成员函数和扩展函数之间有很大的区别。
- en: 'The open class `Canine` has a subclass, `Dog`. A standalone function, `printSpeak`,
    receives a parameter of type `Canine` and prints the content of the result of
    the function `speak(): String`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '开放类`Canine`有一个子类`Dog`。一个独立的函数`printSpeak`接收一个类型为`Canine`的参数，并打印函数`speak():
    String`的结果内容：'
- en: '[PRE25]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We already covered this in [Chapter 1](6fd42581-3c3e-4471-b103-22a571a138a4.xhtml),
    *Kotlin – Data Types, Objects and Classes*, in the *Inheritance *section. Open
    classes with `open` methods (member functions) can be extended and alter their
    behavior. Invoking the `speak` function will act differently depending on which
    type is your instance.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第1章](6fd42581-3c3e-4471-b103-22a571a138a4.xhtml)，“Kotlin – 数据类型、对象和类”，在*继承*部分中讨论了这一点。具有`open`方法的开放类（成员函数）可以被扩展并改变其行为。调用`speak`函数的行为将根据实例的类型而有所不同。
- en: 'The `printSpeak` function can be invoked with any instance of a class that
    *is-a* `Canine`, either `Canine` itself or any subclass:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`printSpeak`函数可以用任何`is-a` `Canine`类的实例调用，无论是`Canine`本身还是任何子类：'
- en: '[PRE26]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If we execute this code, we can see this on the console:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行此代码，我们可以在控制台上看到以下内容：
- en: '![](img/07ebfddd-9372-4688-aa65-a4baba259a7a.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/07ebfddd-9372-4688-aa65-a4baba259a7a.png)'
- en: Although both are `Canine`, the behavior of `speak` is different in both cases,
    as the subclass overrides the parent implementation.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然两者都是`Canine`，但在两种情况下`speak`的行为都不同，因为子类覆盖了父类实现。
- en: But with extension functions, many things are different.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 但与扩展函数不同，许多事情都不同。
- en: 'As with the previous example, `Feline` is an open class extended by the `Cat`
    class. But `speak` is now an extension function:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的示例一样，`Feline`是一个由`Cat`类扩展的开放类。但现在`speak`是一个扩展函数：
- en: '[PRE27]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Extension functions don''t need to be marked as override, because we aren''t
    overriding anything:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展函数不需要标记为`override`，因为我们没有覆盖任何内容：
- en: '[PRE28]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If we execute this code, we can see this on the console:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行此代码，我们可以在控制台上看到以下内容：
- en: '![](img/0d28f873-ad11-4f56-a174-1b3c0bd91f3e.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0d28f873-ad11-4f56-a174-1b3c0bd91f3e.png)'
- en: 'In this case, both invocations produce the same result. Although in the beginning
    it seems confusing, once you analyse what is happening, it becomes clear. We''re
    invoking the `Feline.speak()` function twice; this is because each parameter that
    we pass is a `Feline` to the `printSpeak(Feline)` function:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，两次调用都产生相同的结果。虽然一开始看起来很混乱，但一旦分析清楚，就会变得清晰。我们调用了两次`Feline.speak()`函数；这是因为我们传递给`printSpeak(Feline)`函数的每个参数都是一个`Feline`：
- en: '[PRE29]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If we execute this code, we can see this on the console:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行此代码，我们可以在控制台上看到以下内容：
- en: '![](img/50f03c90-318c-4fec-9028-d4d9de9d9372.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/50f03c90-318c-4fec-9028-d4d9de9d9372.png)'
- en: In this case, it is still the same behavior as with the previous examples, but
    using the right value for `name`. Speaking of which, we can reference `name` with
    `name` and `this.name`; both are valid.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，行为与前面的示例相同，但使用了正确的`name`值。说到这里，我们可以用`name`和`this.name`来引用`name`；两者都是有效的。
- en: Extension functions as members
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展函数作为成员
- en: Extension functions can be declared as members of a class. An instance of a
    class with extension functions declared is called the **dispatch receiver.**
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展函数可以声明为类的成员。声明了扩展函数的类的实例称为**调度接收器**。
- en: 'The `Caregiver` open class internally defines, extension functions for two
    different classes, `Feline` and `Primate`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`Caregiver`公开类内部定义了针对两个不同类`Feline`和`Primate`的扩展函数：'
- en: '[PRE30]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Both extension functions are meant to be used inside an instance of `Caregiver`.
    Indeed, it is a good practice to mark member extension functions as private, if
    they aren't open.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个扩展函数都打算在`Caregiver`的实例内部使用。实际上，如果它们不是公开的，将成员扩展函数标记为私有是一个好习惯。
- en: In the case of `Primate.react()`, we are using the `name` value from `Primate`
    and the `name` value from `Caregiver`. To access members with a name conflict,
    the extension receiver (`this`) takes precedence and to access members of the
    dispatcher receiver, the qualified `this` syntax must be used. Other members of
    the dispatcher receiver that don't have a name conflict can be used without qualified
    `this`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Primate.react()`的情况下，我们使用了`Primate`和`Caregiver`中的`name`值。要访问具有名称冲突的成员，扩展接收器（`this`）具有优先级，要访问调度接收器的成员，必须使用限定`this`语法。调度接收器的其他没有名称冲突的成员可以使用而不需要限定`this`。
- en: 'Don''t get confused by the various means of `this` that we have already covered:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被我们已经覆盖的各种`this`的用法所迷惑：
- en: Inside a class, `this` means the instance of that class
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类内部，`this`意味着该类的实例
- en: 'Inside an extension function, `this` means the instance of the receiver type
    like the first parameter in our utility function with nice syntax:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在扩展函数内部，`this`意味着接收器类型的实例，就像我们工具函数中第一个参数的优雅语法一样：
- en: '[PRE31]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Going back to our *Zoo* example, we instantiate a `Caregiver`, a `Cat`, and
    a `Primate`, and we invoke the function `Caregiver.takeCare` with both animal
    instances:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的*动物园*示例，我们实例化了一个`Caregiver`，一个`Cat`和一个`Primate`，并且我们使用这两个动物实例调用了`Caregiver.takeCare`函数：
- en: '[PRE32]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If we execute this code, we can see this on the console:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行此代码，我们可以在控制台上看到以下内容：
- en: '![](img/8cad2a39-09ef-4755-963c-d27ae0a94429.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8cad2a39-09ef-4755-963c-d27ae0a94429.png)'
- en: 'Any zoo needs a veterinary surgeon. The class `Vet` extends `Caregiver`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 任何动物园都需要兽医。类`Vet`扩展了`Caregiver`：
- en: '[PRE33]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We override the `Feline.react()` function with a different implementation.
    We are also using the `Vet` class''s name directly, as the `Feline` class doesn''t
    have a property name:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用不同的实现覆盖了`Feline.react()`函数。我们还直接使用了`Vet`类的名称，因为`Feline`类没有属性名：
- en: '[PRE34]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'After which, we get the following output:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们得到以下输出：
- en: '![](img/25274a35-6b26-4563-a986-33c61c6b238b.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/25274a35-6b26-4563-a986-33c61c6b238b.png)'
- en: Extension functions with conflicting names
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 具有冲突名称的扩展函数
- en: What happens when an extension function has the same name as a member function?
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当扩展函数与成员函数具有相同的名称时会发生什么？
- en: 'The `Worker` class has a function `work(): String` and a private function `rest():
    String`. We also have two extension functions with the same signature, `work`
    and `rest`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`Worker`类有一个`work(): String`函数和一个私有函数`rest(): String`。我们还有两个具有相同签名的扩展函数，`work`和`rest`：'
- en: '[PRE35]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Having extension functions with the same signature isn''t a compilation error,
    but a warning: `Extension is shadowed by a member: public final fun work(): String`'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '具有相同签名的扩展函数不会导致编译错误，但会发出警告：“扩展函数被成员覆盖：public final fun work(): String”'
- en: It is legal to declare a function with the same signature as a member function,
    but the member function always takes precedence, therefore, the extension function
    is never invoked. This behavior changes when the member function is private, in
    this case, the extension function takes precedence.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 声明一个与成员函数具有相同签名的函数是合法的，但成员函数始终具有优先级，因此扩展函数永远不会被调用。当成员函数是私有的时，这种行为会改变，在这种情况下，扩展函数具有优先级。
- en: 'It is also possible to overload an existing member function with an extension
    function:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用扩展函数也可以重载现有的成员函数：
- en: '[PRE36]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'On execution, `work()` invokes the member function and `work(String)` and `rest()` are
    extension functions:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行时，`work()`调用成员函数，而`work(String)`和`rest()`是扩展函数：
- en: '![](img/6eaa0a12-3eb0-4256-98c1-1e54da9793c8.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6eaa0a12-3eb0-4256-98c1-1e54da9793c8.png)'
- en: Extension functions for objects
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象的扩展函数
- en: In Kotlin, objects are a type, therefore they can have functions, including
    extension functions (among other things, such as extending interfaces and others).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，对象是一种类型，因此它们可以有函数，包括扩展函数（以及其他一些功能，如扩展接口等）。
- en: 'We can add a `buildBridge` extension function to the object, `Builder`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向对象 `Builder` 添加一个 `buildBridge` 扩展函数：
- en: '[PRE37]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can include companion objects. The class `Designer` has two inner objects,
    the `companion` object and `Desk` object:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以包含伴随对象。类 `Designer` 有两个内部对象，`companion` 对象和 `Desk` 对象：
- en: '[PRE38]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Calling this functions works like any normal object member function:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此函数的工作方式与任何正常对象成员函数一样：
- en: '[PRE39]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Infix functions
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中缀函数
- en: Functions (normal or extension) with just one parameter can be marked as `infix`
    and used with the `infix` notation. The `infix` notation is useful to express
    the code naturally for some domains, for example, math and algebra operations.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个参数的函数（普通或扩展）可以标记为 `中缀` 并使用 `中缀` 表示法。对于某些领域，例如数学和代数运算，`中缀` 表示法有助于自然地表达代码。
- en: 'Let''s add an `infix` extension function to the `Int` type, `superOperation`
    (which is just a regular sum with a fancy name):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `Int` 类型上添加一个 `中缀` 扩展函数，`superOperation`（这只是一个带有花哨名称的常规求和）：
- en: '[PRE40]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We can use the `superOperation` function with the `infix` notation or normal
    notation.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `superOperation` 函数以及 `中缀` 表示法或常规表示法。
- en: Another area where the `infix` notation is commonly used, is on assertion libraries,
    such as **HamKrest** ([https://github.com/npryce/hamkrest](https://github.com/npryce/hamkrest))
    or **Kluent** ([https://github.com/MarkusAmshove/Kluent](https://github.com/MarkusAmshove/Kluent)).
    Writing specification code in a natural, easy to understand language is a huge
    advantage.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个 `中缀` 表示法常用领域是断言库，例如 **HamKrest** ([https://github.com/npryce/hamkrest](https://github.com/npryce/hamkrest))
    或 **Kluent** ([https://github.com/MarkusAmshove/Kluent](https://github.com/MarkusAmshove/Kluent))。用自然、易于理解的语言编写规范代码是一个巨大的优势。
- en: 'Kluent assertions look like natural English expressions:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Kluent 断言看起来像自然的英语表达：
- en: '[PRE41]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Kluent also comes with a backtick version for even greater readability:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Kluent 还提供了一个反引号版本，以增强可读性：
- en: '[PRE42]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Backticks (`` ` ``) let you write arbitrary identifiers, including words that
    are reserved in Kotlin. Now, you can write your own kaomoji functions:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 反引号（`` ` ``）允许你编写任意标识符，包括 Kotlin 中保留的单词。现在，你可以编写自己的表情包函数：
- en: '![](img/12e0fde8-446a-469c-8fa6-855d64ec3c1a.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12e0fde8-446a-469c-8fa6-855d64ec3c1a.png)'
- en: 'You can chain many `infix` functions to produce internal DSLs, or recreate
    classic memes:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将许多 `中缀` 函数链式调用以生成内部 DSL，或者重新创建经典梗：
- en: '[PRE43]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `your`  function, receives `Pair<Base, Us>` as a parameter (a kind of tuple
    that comes with and is widely used on the Kotlin standard library) and the `infix`
    extension function `<K, V> K.to(v: V)` returns a `Pair<K, V>` using the receiver
    as the first member and the parameter as the second parameter (`to` can be invoked
    with any combination of types).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`your` 函数接收 `Pair<Base, Us>` 作为参数（这是一种元组，它随 Kotlin 标准库提供并广泛使用）和 `中缀` 扩展函数 `<K,
    V> K.to(v: V)` 使用接收者作为第一个成员，参数作为第二个参数（`to` 可以用任何类型的组合调用）。'
- en: Operator overloading
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作符重载
- en: '**Operator overloading** is a form of polymorphism. Some operators change behaviors
    on different types. The classic example is the operator plus (`+`). On numeric
    values, plus is a sum operation and on `String` is a concatenation. Operator overloading
    is a useful tool to provide your API with a natural surface. Let''s say that we''re
    writing a `Time` and `Date` library; it''ll be natural to have the plus and minus
    operators defined on time units.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**操作符重载** 是一种多态形式。一些操作符在不同类型上会改变行为。经典的例子是操作符加 (`+`)。在数值上，加是求和操作，在 `String`
    上是连接。操作符重载是提供自然表面 API 的有用工具。假设我们正在编写 `Time` 和 `Date` 库；在时间单位上定义加法和减法操作符将是自然的。'
- en: 'Kotlin lets you define the behavior of operators on your own or existing types
    with functions, normal or extension, marked with the `operator` modifier:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 允许你使用函数定义自己的或现有类型的操作行为，无论是普通函数还是扩展函数，只要使用 `operator` 修饰符标记即可：
- en: '[PRE44]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The operator function plus returns a `Pack` value. To invoke it, you can use
    the `infix` operator way (`Wolf + Wolf`) or the normal way (`Wolf.plus(Wolf)`).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符函数加返回一个 `Pack` 值。要调用它，你可以使用 `中缀` 操作符方式（`Wolf + Wolf`）或常规方式（`Wolf.plus(Wolf)`）。
- en: Something to be aware of about operator overloading in Kotlin—the operators
    that you can override in Kotlin are limited; you can't create arbitrary operators.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Kotlin 中操作符重载需要注意的一点是——你可以在 Kotlin 中重载的操作符是有限的；你不能创建任意的操作符。
- en: Binary operators
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二元操作符
- en: Binary operators receive a parameter (there are exceptions to this rule—`invoke`
    and indexed access).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 二元操作符接收一个参数（有一些例外——`invoke` 和索引访问）。
- en: 'The `Pack.plus` extension function receives a `Wolf` parameter and returns
    a new `Pack`. Note that `MutableMap` also has a plus (`+`) operator:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pack.plus` 扩展函数接收一个 `Wolf` 参数并返回一个新的 `Pack`。注意，`MutableMap` 也具有加号（`+`）操作符：'
- en: '[PRE45]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The following table will show you all the possible binary operators that can
    be overloaded:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 下表将展示所有可能的可重载的二进制操作符：
- en: '| **Operator** | **Equivalent** | **Notes** |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| **操作符** | **等效** | **说明** |'
- en: '| `x + y` | `x.plus(y)` |  |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `x + y` | `x.plus(y)` |  |'
- en: '| `x - y` | `x.minus(y)` |  |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `x - y` | `x.minus(y)` |  |'
- en: '| `x * y` | `x.times(y)` |  |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `x * y` | `x.times(y)` |  |'
- en: '| `x / y` | `x.div(y)` |  |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `x / y` | `x.div(y)` |  |'
- en: '| `x % y` | `x.rem(y)` | From Kotlin 1.1, previously `mod`. |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `x % y` | `x.rem(y)` | 从 Kotlin 1.1 版本开始，之前为 `mod`. |'
- en: '| `x..y` | `x.rangeTo(y)` |  |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `x..y` | `x.rangeTo(y)` |  |'
- en: '| `x in y` | `y.contains(x)` |  |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `x in y` | `y.contains(x)` |  |'
- en: '| `x !in y` | `!y.contains(x)` |  |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `x !in y` | `!y.contains(x)` |  |'
- en: '| `x += y` | `x.plussAssign(y)` | Must return `Unit`. |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `x += y` | `x.plussAssign(y)` | 必须返回 `Unit`. |'
- en: '| `x -= y` | `x.minusAssign(y)` | Must return `Unit`. |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `x -= y` | `x.minusAssign(y)` | 必须返回 `Unit`. |'
- en: '| `x *= y` | `x.timesAssign(y)` | Must return `Unit`. |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `x *= y` | `x.timesAssign(y)` | 必须返回 `Unit`. |'
- en: '| `x /= y` | `x.divAssign(y)` | Must return `Unit`. |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `x /= y` | `x.divAssign(y)` | 必须返回 `Unit`. |'
- en: '| `x %= y` | `x.remAssign(y)` | From Kotlin 1.1, previously `modAssign`. Must
    return `Unit`. |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `x %= y` | `x.remAssign(y)` | 从 Kotlin 1.1 版本开始，之前为 `modAssign`。必须返回 `Unit`.
    |'
- en: '| `x == y` | `x?.equals(y) ?: (y === null)` | Checks for `null`. |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `x == y` | `x?.equals(y) ?: (y === null)` | 检查 `null`. |'
- en: '| `x != y` | `!(x?.equals(y) ?: (y === null))` | Checks for `null`. |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `x != y` | `!(x?.equals(y) ?: (y === null))` | 检查 `null`. |'
- en: '| `x < y` | `x.compareTo(y) < 0` | Must return `Int`. |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `x < y` | `x.compareTo(y) < 0` | 必须返回 `Int`. |'
- en: '| `x > y` | `x.compareTo(y) > 0` | Must return `Int`. |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `x > y` | `x.compareTo(y) > 0` | 必须返回 `Int`. |'
- en: '| `x <= y` | `x.compareTo(y) <= 0` | Must return `Int`. |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `x <= y` | `x.compareTo(y) <= 0` | 必须返回 `Int`. |'
- en: '| `x >= y` | `x.compareTo(y) >= 0` | Must return `Int`. |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `x >= y` | `x.compareTo(y) >= 0` | 必须返回 `Int`. |'
- en: Invoke
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用
- en: 'Back in [Chapter 2](cd9fb97b-d5f0-41d6-b9fb-87259d07a390.xhtml), *Getting Started
    with Functional Programming*, in the section *First-class and high-order functions*, when
    we introduced lambda functions, we show the definition of `Function1`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 [第 2 章](cd9fb97b-d5f0-41d6-b9fb-87259d07a390.xhtml)，*开始函数式编程*，在 *一等和高级函数*
    部分，当我们介绍 lambda 函数时，展示了 `Function1` 的定义：
- en: '[PRE46]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `invoke` function is an operator, a curious one. The `invoke` operator can
    be called without `name`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`invoke` 函数是一个操作符，一个有趣的操作符。`invoke` 操作符可以在没有 `name` 的情况下被调用。'
- en: 'The class `Wolf` has an `invoke` operator:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`Wolf` 类有一个 `invoke` 操作符：'
- en: '[PRE47]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: That's why we can call a lambda function directly with parenthesis; we are,
    indeed, calling the `invoke` operator.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，我们可以直接用括号调用 lambda 函数；实际上，我们是在调用 `invoke` 操作符。
- en: 'The following table will show you different declarations of `invoke` with a
    number of different arguments:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 下表将展示 `invoke` 函数的不同声明及其不同参数数量：
- en: '| **Operator** | **Equivalent** | **Notes** |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| **操作符** | **等效** | **说明** |'
- en: '| `x()` | `x.invoke()` |  |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `x()` | `x.invoke()` |  |'
- en: '| `x(y)` | `x.invoke(y)` |  |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `x(y)` | `x.invoke(y)` |  |'
- en: '| `x(y1, y2)` | `x.invoke(y1, y2)` |  |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `x(y1, y2)` | `x.invoke(y1, y2)` |  |'
- en: '| `x(y1, y2..., yN)` | `x.invoke(y1, y2..., yN)` |  |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `x(y1, y2..., yN)` | `x.invoke(y1, y2..., yN)` |  |'
- en: Indexed access
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引访问
- en: The indexed access operator is the array read and write operations with square
    brackets (`[]`), that is used on languages with C-like syntax. In Kotlin, we use
    the `get` operators for reading and `set` for writing.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 索引访问操作符是使用方括号（`[]`）的数组读写操作，用于具有类似 C 语法语法的语言。在 Kotlin 中，我们使用 `get` 操作符进行读取，使用
    `set` 进行写入。
- en: 'With the `Pack.get` operator, we can use `Pack` as an array:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Pack.get` 操作符，我们可以将 `Pack` 当作数组使用：
- en: '[PRE48]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Most of Kotlin data structures have a definition of the `get` operator, in this
    case, the `Map<K, V>` returns a `V?`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Kotlin 数据结构都有一个 `get` 操作符的定义，在这种情况下，`Map<K, V>` 返回一个 `V?`。
- en: 'The following table will show you different declarations of `get` with a different
    number of arguments:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 下表将展示 `get` 函数的不同声明及其不同参数数量：
- en: '| **Operator** | **Equivalent** | **Notes** |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| **操作符** | **等效** | **说明** |'
- en: '| `x[y]` | `x.get(y)` |  |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `x[y]` | `x.get(y)` |  |'
- en: '| `x[y1, y2]` | `x.get(y1, y2)` |  |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| `x[y1, y2...]` | `x.get(y1, y2...)` |  |'
- en: '| `x[y1, y2..., yN]` | `x.get(y1, y2..., yN)` |  |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `x[y1, y2...]` | `x.get(y1, y2...)` |  |'
- en: 'The `set` operator has similar syntax:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`set` 操作符具有类似的语法：'
- en: '[PRE49]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The operators `get` and `set` can have any arbitrary code, but it is a very
    well-known and old convention that indexed access is used for reading and writing.
    When you write these operators (and by the way, all the other operators too),
    use the principle of *least surprise*. Limiting the operators to their natural
    meaning on a specific domain, makes them easier to use and read in the long run.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`get` 和 `set` 运算符可以包含任意代码，但有一个非常著名且古老的约定，即索引访问用于读写。当你编写这些运算符（顺便说一下，所有其他运算符也是如此）时，使用“最小惊讶”原则。将运算符限制在其特定领域的自然含义上，从长远来看，使它们更容易使用和阅读。'
- en: 'The following table will show you different declarations of `set` with a different
    number of arguments:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 下表将展示不同数量参数的 `set` 的不同声明：
- en: '| **Operator** | **Equivalent** | **Notes** |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **等效** | **说明** |'
- en: '| `x[y] = z` | `x.set(y, z)` | Return value is ignored |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `x[y] = z` | `x.set(y, z)` | 返回值被忽略 |'
- en: '| `x[y1, y2] = z` | `x.set(y1, y2, z)` | Return value is ignored |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `x[y1, y2] = z` | `x.set(y1, y2, z)` | 返回值被忽略 |'
- en: '| `x[y1, y2..., yN] = z` | `x.set(y1, y2..., yN, z)` | Return value is ignored
    |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `x[y1, y2..., yN] = z` | `x.set(y1, y2..., yN, z)` | 返回值被忽略 |'
- en: Unary operators
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一元运算符
- en: '**Unary operators** don''t have parameters and act directly in the dispatcher.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**一元运算符**没有参数，并直接作用于分发器。'
- en: 'We can add a `not` operator to the `Wolf` class:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向 `Wolf` 类添加一个 `not` 运算符：
- en: '[PRE50]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The following table will show you all the possible unary operators that can
    be overloaded:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 下表将展示所有可能被重载的一元运算符：
- en: '| **Operator** | **Equivalent** | **Notes** |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **等效** | **说明** |'
- en: '| `+x` | `x.unaryPlus()` |  |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| `+x` | `x.unaryPlus()` |  |'
- en: '| `-x` | `x.unaryMinus()` |  |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| `-x` | `x.unaryMinus()` |  |'
- en: '| `!x` | `x.not()` |  |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| `!x` | `x.not()` |  |'
- en: '| `x++` | `x.inc()` | Postfix, it must be a call on a `var`, should return
    a compatible type with the dispatcher type, shouldn''t mutate the dispatcher.
    |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| `x++` | `x.inc()` | 后缀，它必须是对 `var` 的调用，应该返回与分发器类型兼容的类型，不应该修改分发器。 |'
- en: '| `x--` | `x.dec()` | Postfix, it must be a call on a `var`, should return
    a compatible type with the dispatcher type, shouldn''t mutate the dispatcher.
    |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| `x--` | `x.dec()` | 后缀，它必须是对 `var` 的调用，应该返回与分发器类型兼容的类型，不应该修改分发器。 |'
- en: '| `++x` | `x.inc()` | Prefix, it must be a call on a `var`, should return a
    compatible type with the dispatcher type, shouldn''t mutate the dispatcher. |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| `++x` | `x.inc()` | 前缀，它必须是对 `var` 的调用，应该返回与分发器类型兼容的类型，不应该修改分发器。 |'
- en: '| `--x` | `x.dec()` | Prefix, it must be a call on a `var`, should return a
    compatible type with the dispatcher type, shouldn''t mutate the dispatcher. |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| `--x` | `x.dec()` | 前缀，它必须是对 `var` 的调用，应该返回与分发器类型兼容的类型，不应该修改分发器。 |'
- en: Postfix (increment and decrement) returns the original value and then changes
    the variable with the operator returned value. Prefix returns the operator's returned
    value and then changes the variable with that value.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 后缀（递增和递减）返回原始值，然后更改变量为运算符返回的值。前缀返回运算符的返回值，然后更改变量为该值。
- en: Type-safe builders
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型安全的构建器
- en: With the two previous sections (`infix` functions and operator overloading),
    we have a good foundation for building fantastic DSLs. A **DSL** is a language
    that is specialized to a particular domain, in contrast to **general-purpose language** (**GPL**).
    Classic examples of DSLs (even when people don't realize it) are HTML (markup)
    and SQL (relational database queries).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两个部分（中缀函数和运算符重载）之后，我们为构建出色的 DSL 打下了良好的基础。**DSL** 是一种针对特定领域专门化的语言，与 **通用语言**（**GPL**）相对。经典的
    DSL 示例（即使人们没有意识到）是 HTML（标记）和 SQL（关系数据库查询）。
- en: Kotlin provides many features to create internal DSLs (a DSL that runs internally
    inside a host GPL), but there is one feature that we still need to cover, type-safe
    builders. Type-safe builders let us define data in a (semi) declarative way and
    are very useful to define GUIs,  HTML markup, XML, and others.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 提供了许多功能来创建内部 DSL（在宿主 GPL 内部运行的 DSL），但我们仍需要介绍一个特性，即类型安全的构建器。类型安全的构建器允许我们以（半）声明性的方式定义数据，并且对于定义
    GUI、HTML 标记、XML 等非常有用。
- en: An example of a beautiful Kotlin DSL is TornadoFX. **TornadoFX** ([https://tornadofx.io/](https://tornadofx.io/))
    is DSL for creating JavaFX applications.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 一个漂亮的 Kotlin DSL 示例是 TornadoFX。**TornadoFX** ([https://tornadofx.io/](https://tornadofx.io/))
    是用于创建 JavaFX 应用程序的 DSL。
- en: 'We write an `FxApp` class that extends `tornadofx.App` and receives a `tornadofx.View`
    class (a class reference, not an instance):'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写一个 `FxApp` 类，它扩展了 `tornadofx.App` 并接收一个 `tornadofx.View` 类（一个类引用，而不是一个实例）：
- en: '[PRE51]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In less than 20 lines of code, including imports and main function, we can
    create a GUI application:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在不到 20 行代码中，包括导入和主函数，我们可以创建一个 GUI 应用程序：
- en: '![](img/aa2565c7-bdb1-44e8-bb59-e574a6cd5318.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/aa2565c7-bdb1-44e8-bb59-e574a6cd5318.png)'
- en: Of course, right now, it doesn't do anything, but it is simple to create a JavaFX
    Application with TornadoFX, if you compare it with Java. People with JavaFX experience
    could say that you can achieve something similar with FXML (a declarative XML
    language designed to build JavaFX layouts), but as with any other XML file, writing
    and maintaining is hard, and TornadoFX's DSL is simpler, flexible, and is compiled
    with Kotlin's type-safety.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，现在它什么也不做，但用 TornadoFX 创建一个 JavaFX 应用程序很简单，如果你与 Java 进行比较。有 JavaFX 经验的人可能会说，你可以用
    FXML（一种用于构建 JavaFX 布局的声明性 XML 语言）达到类似的效果，但就像任何其他 XML 文件一样，编写和维护都很困难，而 TornadoFX
    的 DSL 更简单、更灵活，并且使用 Kotlin 的类型安全性进行编译。
- en: But how do type-safe builders work?
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 但类型安全的构建器是如何工作的呢？
- en: 'Let''s start with an example from the Kotlin Standard Library:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 Kotlin 标准库的一个例子开始：
- en: '[PRE52]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We can find `with` blocks in other languages, such as JavaScript and Visual
    Basic (including .Net). A `with` block is a language construct that lets us use
    any property or method on the value that we pass as a parameter. But in Kotlin,
    `with` is not a reserved keyword but rather a normal function with a special type
    of parameter.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在其他语言中找到 `with` 块，例如 JavaScript 和 Visual Basic（包括 .Net）。`with` 块是一种语言结构，它允许我们使用传递为参数的值上的任何属性或方法。但在
    Kotlin 中，`with` 不是一个保留关键字，而是一个具有特殊参数类型的普通函数。
- en: 'Let''s have a look at the `with` declaration:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `with` 声明：
- en: '[PRE53]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The first parameter is any value of type `T`, a receiver (as in extension function?)
    and the second one, `block`, is a function of type `T.() -> R`. In Kotlin's documentation,
    this kind of function is named **function type** with receiver and with any instance
    of `T,` we can call the `block` function. No worries about the `inline` modifier,
    we'll cover it in the next section.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是类型 `T` 的任何值，一个接收器（就像扩展函数一样？），第二个参数 `block` 是类型 `T.() -> R` 的函数。在 Kotlin
    的文档中，这种函数被称为具有接收器的 **函数类型**，并且对于 `T` 的任何实例，我们都可以调用 `block` 函数。不用担心 `inline` 修饰符，我们将在下一节中介绍它。
- en: A trick to understanding the function type with receiver is to think of it as
    an extension function. Have a look at the declaration with that familiar dot (`.`),
    and inside the function, we can use any member of the receiver type using `this`,
    as in extension functions.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 理解具有接收器的函数类型的一个技巧是将它想象成一个扩展函数。看看那个熟悉的点（`.`）声明，并在函数内部，我们可以使用 `this` 来使用接收器类型的任何成员，就像扩展函数一样。
- en: 'What about another example? Let''s have a look at it:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 再举一个例子怎么样？让我们看看它：
- en: '[PRE54]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `buildString` function receives a `StringBuilder.() -> Unit` parameter
    and returns a `String`; the declaration is astonishingly simple:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`buildString` 函数接收一个 `StringBuilder.() -> Unit` 参数并返回一个 `String`；其声明非常简单：'
- en: '[PRE55]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `apply` function is an extension function similar to `with` but instead
    of returning `R`, returns the receiver instance. Usually, `apply` is used for
    *initializing* and *instance*:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply` 函数是一个类似于 `with` 的扩展函数，但它返回的是接收器实例，而不是 `R`。通常，`apply` 用于 *初始化* 和 *实例*：'
- en: '[PRE56]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: As you can see, all these functions are very simple to understand, but they
    increase Kotlin's usefulness and readability a great deal.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，所有这些函数都非常容易理解，但它们极大地增加了 Kotlin 的实用性和可读性。
- en: Creating a DSL
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 DSL
- en: One of my big passions is cycling. The emotion of movement, the effort, the
    health benefits, and enjoying the landscape are some of the benefits (and I can
    keep going on and on).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我的一大爱好是骑自行车。运动的情感、努力、健康益处以及欣赏风景都是一些好处（我可以继续说下去）。
- en: 'I want to create a way to have a registry of my bikes and their components.
    For the prototype phase, I''ll use XML, but later on we can change to a different
    implementation:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我想创建一种方式来记录我的自行车及其组件。在原型阶段，我会使用 XML，但以后我们可以改为不同的实现：
- en: '[PRE57]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This is the perfect scenario to create a type-safe builder in Kotlin.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在 Kotlin 中创建类型安全构建器的完美场景。
- en: 'In the end, my `bicycle` DSL should look like this:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我的 `bicycle` DSL 应该看起来像这样：
- en: '[PRE58]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: My DSL is regular Kotlin code, is compiled fast, and my IDE will help me to
    autocomplete, and will complain when I make a mistake—a win-win situation.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我的 DSL 是常规的 Kotlin 代码，编译速度快，我的 IDE 会帮我自动完成代码，并在我出错时提醒我——这是一个双赢的局面。
- en: 'Let''s start with the program:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从程序开始：
- en: '[PRE59]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'All parts of my `bicycle` in my DSL will extend/implement the `Element` interface:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的 DSL 中的 `bicycle` 的所有部分都将扩展/实现 `Element` 接口：
- en: '[PRE60]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '`Part` is the base class for all my parts; it has `children` and `attributes`
    properties; it also inherits the `Element` interface with an XML implementation.
    Changing to a different format (JSON, YAML, and others) should not be too difficult.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`Part` 是所有我的部分的基类；它有 `children` 和 `attributes` 属性；它还继承了具有 XML 实现的 `Element`
    接口。改为不同的格式（JSON、YAML 等）不应太难。'
- en: The `initElement` function receives two parameters, an element `T` and an `init`
    function with receiver `T.() -> Unit`. Internally, the `init` function is executed
    and the element is added as children.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`initElement` 函数接收两个参数，一个元素 `T` 和一个接收器为 `T.() -> Unit` 的 `init` 函数。内部，`init`
    函数被执行，并将元素添加为子元素。'
- en: '`Part` is annotated with an `@ElementMarker` annotation, that is itself annotated
    with `@DslMarker`. It prevents inner elements from reaching outer elements.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`Part` 使用 `@ElementMarker` 注解，该注解本身使用 `@DslMarker` 注解。它防止内部元素到达外部元素。'
- en: 'In this example, we can use `frame`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以使用 `frame`：
- en: '[PRE61]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'It is still possible to do it explicitly with `this` qualified:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然可以使用 `this` 来显式执行：
- en: '[PRE62]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, several enumerations to describe materials, bar types, and brakes:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，几个枚举来描述材料、杆类型和刹车：
- en: '[PRE63]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Some of these parts have a `material` attribute:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些部分有 `material` 属性：
- en: '[PRE64]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We use a `material` property of type `Material` enumeration, and we store it
    inside the `attributes` map, transforming the value back and forth:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `Material` 枚举的 `material` 属性，并将其存储在 `attributes` 映射中，转换值来来回回：
- en: '[PRE65]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '`Bicycle` defines a `description` function and functions for `frame`, `fork`,
    and `bar`. Each function receives an `init` function that we pass directly to
    `initElement`.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bicycle` 定义了一个 `description` 函数和 `frame`、`fork` 和 `bar` 的函数。每个函数接收一个 `init`
    函数，我们直接将其传递给 `initElement`。'
- en: '`Frame` has a function for the back wheel:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`Frame` 有一个后轮的函数：'
- en: '[PRE66]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '`Wheel` has a property `brake` using the `Brake` enumeration:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`Wheel` 有一个使用 `Brake` 枚举的 `brake` 属性：'
- en: '[PRE67]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '`Bar` has a property for its type, using the `BarType` enumeration:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bar` 有一个用于其类型的属性，使用 `BarType` 枚举：'
- en: '[PRE68]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '`Fork` defines a function for the front wheel:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`Fork` 定义了一个前轮的函数：'
- en: '[PRE69]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We are close to the finish, the only thing that we need now is an entry function
    for our DSL:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接近完成，我们现在需要的只是我们的 DSL 的入口函数：
- en: '[PRE70]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: And that's all. DSLs in Kotlin with the `infix` functions, operator overloading,
    and type-safe builders are extremely powerful, and the Kotlin community is creating
    new and exciting libraries every day.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。在 Kotlin 中使用 `infix` 函数、操作符重载和类型安全的构建器，DSL 非常强大，Kotlin 社区每天都在创建新的和令人兴奋的库。
- en: Inline functions
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内联函数
- en: High-order functions are very useful and fancy, but they come with a caveat—performance
    penalties. Remember, from [Chapter 2](cd9fb97b-d5f0-41d6-b9fb-87259d07a390.xhtml),
    *Getting Started with Functional Programming*, in the section, *First-class and
    high-order functions*, that on compilation time, a lambda gets translated into
    an object that is allocated, and we are calling its `invoke` operator; those operations
    consume CPU power and memory, regardless of how small they are.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数非常有用且复杂，但它们伴随着一个缺点——性能惩罚。记住，从 [第 2 章](cd9fb97b-d5f0-41d6-b9fb-87259d07a390.xhtml)，“开始使用函数式编程”，在“一等和高级函数”部分，lambda
    在编译时被转换为一个分配的对象，我们调用它的 `invoke` 操作符；这些操作消耗 CPU 力和内存，无论它们有多小。
- en: 'A function like this:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的函数：
- en: '[PRE71]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Once compiled, it will look like this:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦编译，它将看起来像这样：
- en: '[PRE72]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'If performance is a priority for you (mission critical application, games,
    video streaming), you can mark a high-order function as `inline`:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果性能对你来说很重要（关键任务应用、游戏、视频流），你可以将高阶函数标记为 `inline`：
- en: '[PRE73]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Once compiled, it will look like this:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦编译，它将看起来像这样：
- en: '[PRE74]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The whole function execution is replaced by the high-order function''s body
    and the lambda''s body. The `inline` functions are faster, albeit generating more
    bytecode:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 整个函数执行被高阶函数的体和 lambda 的体所替换。`inline` 函数更快，尽管会生成更多的字节码：
- en: '![](img/0dfad12f-a9ed-4580-9e9e-c085050fbfcf.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0dfad12f-a9ed-4580-9e9e-c085050fbfcf.png)'
- en: 2.3 milliseconds per execution doesn't look like a lot, but in the long run
    and with more optimizations, can create a noticeable compound effect.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 每次执行 2.3 毫秒看起来并不多，但长期来看，并且随着更多的优化，可以产生明显的复合效应。
- en: Inline restrictions
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内联限制
- en: Inline lambda functions have an important restriction—they can't be manipulated
    in any way (stored, copied, and others).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 内联 lambda 函数有一个重要的限制——它们不能以任何方式被操作（存储、复制等）。
- en: 'The `UserService` stores a list of listeners `(User) -> Unit`:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserService` 存储了一个监听器列表 `(User) -> Unit`：'
- en: '[PRE75]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Changing `addListener` into an `inline` function will produce a compilation
    error:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 将`addListener`改为内联函数将产生编译错误：
- en: '[PRE76]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: If you think about it, it makes sense. When we inline a lambda, we're replacing
    it for its body, and that isn't something that we can store on a `Map`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细想想，这是有道理的。当我们内联一个lambda表达式时，我们实际上是在替换它的主体，而这并不是我们可以在`Map`上存储的东西。
- en: 'We can fix this problem with the `noinline` modifier:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`noinline`修饰符来解决这个问题：
- en: '[PRE77]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Using `noinline` on an `inline` function will inline just the high-order function
    body but not the `noinline` lambda parameters (an `inline` high-order function
    can have both: `inline` and `noinline` lambdas). The resulting bytecode isn''t
    as fast as a fully inline function, and the compiler will show a warning.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在内联函数上使用`noinline`只会内联高阶函数的主体，但不会内联`noinline` lambda参数（内联高阶函数可以同时有：`inline`和`noinline`
    lambda）。生成的字节码不如完全内联的函数快，编译器会显示警告。
- en: Inline lambda functions can't be used inside another execution context (local
    object, nested lambda).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 内联lambda函数不能用于另一个执行上下文中（局部对象，嵌套lambda）。
- en: 'In this example, we can''t use `transform` inside the `buildUser` lambda:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们无法在`buildUser` lambda中使用`transform`：
- en: '[PRE78]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'To fix this problem, we need a `crossinline` modifier (alternatively, we can
    use `noinline` but with the associated performance lost):'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要一个`crossinline`修饰符（或者我们可以使用`noinline`，但会损失相关的性能）：
- en: '[PRE79]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The generated code is quite complex. Many pieces are generated:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的代码相当复杂。生成了许多部分：
- en: A class that extends `(String) -> User` to represent `buildUser` and internally
    creates `User` using `String::toLowerCase` to transform the name
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个扩展`(String) -> User`的类来表示`buildUser`，并在内部使用`String::toLowerCase`来转换名称
- en: A normal inline code to execute `List<User>.map()` using an instance of the
    class that represents `buildUser`
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个普通的内联代码，用于执行使用`buildUser`类的实例来执行`List<User>.map()`
- en: '`List<T>.map()` is `inline`, so that code gets generated too'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List<T>.map()`是内联的，所以相应的代码也会被生成'
- en: Once you're aware of its restrictions, inline high-order functions are a great
    way to increase the execution speed of your code. Indeed, a lot of the high-order
    functions inside the Kotlin Standard Library are `inline`.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你意识到它的限制，内联高阶函数是提高你代码执行速度的绝佳方式。确实，Kotlin标准库中的许多高阶函数都是`inline`的。
- en: Recursion and corecursion
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归和核心递归
- en: In [Chapter 2](cd9fb97b-d5f0-41d6-b9fb-87259d07a390.xhtml), *Getting Started
    with Functional Programming*, in the section, *Recursion*, we cover recursion
    extensively (albeit there are recursion topics that are outside the scope of this
    book).
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](cd9fb97b-d5f0-41d6-b9fb-87259d07a390.xhtml)，“函数式编程入门”，在“递归”部分，我们广泛地介绍了递归（尽管本书的范围不包括所有递归主题）。
- en: 'We used recursion to write classic algorithms such as Fibonacci (we''re reusing
    `tailrecFib` from [Chapter 2](cd9fb97b-d5f0-41d6-b9fb-87259d07a390.xhtml), *Getting
    Started with Functional Programming*):'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用递归编写了经典算法，如斐波那契（我们正在重用[第2章](cd9fb97b-d5f0-41d6-b9fb-87259d07a390.xhtml)，“函数式编程入门”中的`tailrecFib`）：
- en: '[PRE80]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'And Factorial (same here, reusing `tailrecFactorial` from [Chapter 2](cd9fb97b-d5f0-41d6-b9fb-87259d07a390.xhtml),
    *Getting Started with Functional Programming*):'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 以及阶乘（同样，这里重用[第2章](cd9fb97b-d5f0-41d6-b9fb-87259d07a390.xhtml)，“函数式编程入门”中的`tailrecFactorial`）：
- en: '[PRE81]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: In both cases, we started with a number, and we reduced it to reach a base condition.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，我们从一个数字开始，并减少它以达到基本条件。
- en: 'Another example that we looked at was `FunList`:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还考虑了另一个例子，即`FunList`：
- en: '[PRE82]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The functions, `forEach` and `fold`, are recursive. Starting with the complete
    list, we reduce it until we reach the end (represented with a `Nil`), the base
    case. The other functions—`reverse`, `foldRight`, and `map` are just using `fold`
    with different variations.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`forEach`和`fold`是递归的。从完整的列表开始，我们减少它直到达到末尾（用`Nil`表示），这是基本条件。其他函数——`reverse`、`foldRight`和`map`只是使用不同变体的`fold`。
- en: So, on one hand, recursion takes a complex value and reduces it to the desired
    answer and on the other hand, corecursion takes a value and builds on top of it
    to produce a compound value (including potentially infinite data structures such
    as `Sequence<T>`).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一方面，递归将一个复杂值减少到所需的答案，另一方面，核心递归从一个值开始，在此基础上构建以产生复合值（包括可能的无穷数据结构，如`Sequence<T>`）。
- en: 'As we use a `fold` function for recursive operations, we can use an `unfold`
    function:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用`fold`函数进行递归操作，我们可以使用`unfold`函数：
- en: '[PRE83]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The `unfold` function takes two parameters, an initial `S` value that represents
    the starting or base step, and an `f` lambda that takes that `S` step and produces
    a `Pair<T, S>?` (a nullable `Pair`) of the `T` value to add to the sequence and
    the next `S` step.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`unfold` 函数接受两个参数，一个初始的 `S` 值，它表示起始或基本步长，以及一个 `f` lambda，该 lambda 接受该 `S` 步长并生成一个
    `Pair<T, S>?`（一个可空的 `Pair`），其中包含要添加到序列中的 `T` 值和下一个 `S` 步长。'
- en: If the result of `f(s)` is null, we return an empty sequence, else we create
    a single value sequence and add the result of `unfold` with the new step.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `f(s)` 的结果是 `null`，我们返回一个空序列，否则我们创建一个单值序列并添加 `unfold` 的新步长的结果。
- en: 'Using `unfold,` we can create a function that repeats a single element many
    times:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `unfold`，我们可以创建一个函数，多次重复单个元素：
- en: '[PRE84]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The `elements` function takes the element to repeat any number of values. Internally,
    it uses `unfold`, passing `1` as the initial step and a lambda that takes the
    current step and compares it with `numOfValues`, returning `Pair<T, Int>` with
    the same element and the current step `+ 1` or `null.`
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '`elements` 函数接受一个元素并重复任意数量的值。内部，它使用 `unfold`，传递 `1` 作为初始步长和一个 lambda，该 lambda
    接受当前步长并与 `numOfValues` 进行比较，返回包含相同元素和当前步长 `+ 1` 或 `null` 的 `Pair<T, Int>`。'
- en: 'It is okay, but not very interesting. What about returning a Factorial sequence?
    We have you covered:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可以的，但并不非常有趣。那么返回一个阶乘序列怎么样？我们为你准备好了：
- en: '[PRE85]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Same principle, the only difference is that our initial step is `Pair<Long,
    Int>` (the first element to carry the calculation and the second to evaluate against
    size) and therefore, our lambda should return `Pair<Long, Pair<Long, Int>>`.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的原理，唯一的区别是，我们的初始步长是 `Pair<Long, Int>`（第一个元素用于携带计算，第二个用于与大小进行比较）因此，我们的 lambda
    应该返回 `Pair<Long, Pair<Long, Int>>`。
- en: 'Fibonacci will look similar:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 斐波那契序列看起来类似：
- en: '[PRE86]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Except that in this case, we use `Triple<Long, Long, Int>`.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个情况，我们使用 `Triple<Long, Long, Int>`。
- en: The corecursive implementations to generate Factorial and Fibonacci sequences
    are a mirror of the recursive implementations to calculate a Factorial or a Fibonacci
    number, respectively—and some people can argue that is easier to understand.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 生成阶乘和斐波那契序列的核心递归实现是计算阶乘或斐波那契数的递归实现的镜像——有些人可能会认为这更容易理解。
- en: Summary
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: With this chapter, we have already covered most of the Kotlin features for functional
    programming. We reviewed how to write shorter functions with single-expression
    functions, the different kind of parameters, how to extend our types with extension
    functions, and how to write natural and readable code with `infix` functions and
    operators. We also covered the basics of DSL authoring with type-safe builders
    and how to write efficient high-order functions. Last, but not least, we learned
    about recursion and corecursion.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章，我们已经涵盖了 Kotlin 函数式编程的大部分特性。我们回顾了如何使用单表达式函数编写更短的函数，不同类型的参数，如何使用扩展函数扩展我们的类型，以及如何使用
    `infix` 函数和运算符编写自然易读的代码。我们还涵盖了使用类型安全构建器的 DSL 基础知识以及如何编写高效的高阶函数。最后，但同样重要的是，我们学习了递归和核心递归。
- en: In the next chapter, we will learn about Kotlin delegates.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习 Kotlin 代理。
