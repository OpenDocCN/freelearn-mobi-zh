- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Design with Material Design 3
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Material Design 3 进行设计
- en: Material Design is a design system developed by Google. It helps us create beautiful
    UIs. It provides a set of guidelines and components for us to use as we’re developing
    our Android apps.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Material Design 是由 Google 开发的设计系统。它帮助我们创建美观的 UI。它提供了一套指南和组件，供我们在开发 Android 应用时使用。
- en: In this chapter, we’ll introduce ourselves to **Material 3**. We will also cover
    the features that Material 3 offers. Lastly, we will learn how to use Material
    3 in our Android apps and some of the components in Material 3.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍**Material 3**。我们还将介绍 Material 3 提供的功能。最后，我们将学习如何在我们的 Android 应用中使用
    Material 3 以及 Material 3 中的某些组件。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主要内容：
- en: Material Design 3 and its features
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Material Design 3 及其功能
- en: Using Material Design 3 in our apps
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的应用中使用 Material Design 3
- en: Building for large screens and foldables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为大屏幕和可折叠设备构建
- en: Making our app accessible
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使我们的应用易于访问
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the instructions in this chapter, you will need to have Android Studio
    Hedgehog or later ([https://developer.android.com/studio](https://developer.android.com/studio))
    downloaded.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章中的说明，您需要下载 Android Studio Hedgehog 或更高版本 ([https://developer.android.com/studio](https://developer.android.com/studio))。
- en: You can find the code for this chapter at [https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterfour](https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterfour).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterfour](https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterfour)
    找到本章的代码。
- en: Material Design 3 and its features
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Material Design 3 及其功能
- en: 'The release of **Material Design 3** (**Material 3**) came with lots of new
    features to help us build UIs for our apps. Here are some of the features of Material
    Design 3:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**Material Design 3**（**Material 3**）的发布带来了许多新功能，帮助我们为应用构建 UI。以下是 Material
    Design 3 的部分功能：'
- en: '**Dynamic color**: This is a color system that sets the color of our apps to
    the color of the user’s wallpaper. The System UI also adapts to this color. This
    enables users to have that personalized feel for their apps. Please note that
    dynamic color only works for Android 12 and above devices.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态色彩**：这是一个将我们应用的颜色设置为用户壁纸颜色的色彩系统。系统界面也会适应这种颜色。这使得用户能够拥有个性化的应用体验。请注意，动态色彩仅适用于
    Android 12 及以上设备。'
- en: '**More components**: Material 3 has a new set of improved components that are
    available for use. Some components have new UIs and others have been added to
    the APIs.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更多组件**：Material 3 提供了一组新的改进组件，可供使用。一些组件具有新的 UI，而其他组件已被添加到 API 中。'
- en: '**Simplified typography**: Material 3 has a much more simplified naming and
    grouping for typography. We have the following types: **display**, **headline**,
    **title**, **body**, and **label**, with each supporting *small*, *medium*, and
    *large* sizes. This makes it easier for us to define styles all across our apps.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化排版**：Material 3 对排版进行了更简化的命名和分组。我们有以下类型：**展示**、**标题**、**标题**、**正文**和**标签**，每种类型都支持**小**、**中**和**大**尺寸。这使得我们更容易在应用中定义样式。'
- en: '**Improved color scheme**: The color scheme has undergone a lot of improvements
    with the addition of more color schemes to fine-grain color customization. It’s
    also way easier for us to support both dark and light color schemes in our apps.
    In addition to that, they created a new tool, Material Theme Builder ([https://m3.material.io/theme-builder](https://m3.material.io/theme-builder)),
    which allows us to generate and export dark and light theme colors for our apps.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**改进的色彩方案**：通过添加更多色彩方案以实现精细的色彩定制，色彩方案已经经历了许多改进。这也使得我们更容易在我们的应用中支持深色和浅色主题。此外，他们还创建了一个新的工具，Material
    Theme Builder ([https://m3.material.io/theme-builder](https://m3.material.io/theme-builder))，它允许我们为我们的应用生成和导出深色和浅色主题颜色。'
- en: '**Simplified shapes**: Similar to typography, shapes have also been simplified
    to the following: **Extra Small**, **Small**, **Medium**, **Large**, and **Extra
    Large**. All these shapes come with default values, which we can always override
    to use our own.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化形状**：与排版类似，形状也被简化为以下几种：**极小**、**小**、**中**、**大**和**极大**。所有这些形状都带有默认值，我们可以随时覆盖以使用自己的值。'
- en: The good news for us is that from Android Studio Hedgehog onward, we have project
    templates that come set up with Material 3, which makes things easier for us.
    Even the project we created in [*Chapter 2*](B19779_02.xhtml#_idTextAnchor031)
    comes with Material 3 set up already.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们来说，好消息是从 Android Studio Hedgehog 版本开始，我们有了预配置了 Material 3 的项目模板，这使得事情变得更容易。甚至我们在
    [*第 2 章*](B19779_02.xhtml#_idTextAnchor031) 中创建的项目也已经预配置了 Material 3。
- en: Material 3 APIs and their predecessors offer a wide range of components for
    us to use in our apps. In the next subsection, we will be looking at some of the
    common ones.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Material 3 API 及其前身为我们提供了广泛的可用于我们应用的组件。在下一个子节中，我们将查看一些常见的组件。
- en: Material components
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 材料组件
- en: The Material library comes with prebuilt components that we can use to build
    common UI components. Let us look at some of the commonly used components and
    some of the updates they had in Material 3.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Material 库包含预构建的组件，我们可以使用它们来构建常见的 UI 组件。让我们看看一些常用的组件以及它们在 Material 3 中的更新。
- en: Top app bars
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 顶部应用栏
- en: 'This is a component displayed at the top of the screen. It has a title and
    can also have some actions that are related to the screen the user is on. Some
    of the common actions are the settings icon normally at the top right of the screen.
    In Material 3, we have four types of top app bars: **center-aligned**, **small**,
    **medium**, and **large**, as shown in the following figures.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个显示在屏幕顶部的组件。它有一个标题，还可以包含与用户所在的屏幕相关的某些操作。一些常见的操作是屏幕右上角的设置图标。在 Material 3 中，我们有四种类型的顶部应用栏：**居中对齐**、**小号**、**中等**和**大号**，如图所示。
- en: '![Figure 4.1 – Small top app bar](img/B19779_04_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 小号顶部应用栏](img/B19779_04_01.jpg)'
- en: Figure 4.1 – Small top app bar
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 小号顶部应用栏
- en: '![Figure 4.2 – Center-aligned top app bar](img/B19779_04_02.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – 居中对齐的顶部应用栏](img/B19779_04_02.jpg)'
- en: Figure 4.2 – Center-aligned top app bar
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 居中对齐的顶部应用栏
- en: '![Figure 4.3 – Medium top app bar](img/B19779_04_03.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3 – 中等顶部应用栏](img/B19779_04_03.jpg)'
- en: Figure 4.3 – Medium top app bar
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – 中等顶部应用栏
- en: '![Figure 4.4 – Large top app bar](img/B19779_04_04.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4 – 大号顶部应用栏](img/B19779_04_04.jpg)'
- en: Figure 4.4 – Large top app bar
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – 大号顶部应用栏
- en: As seen in *Figures 4.1* to *4.4*, all the top bars have the same width and
    only differ in height and positioning of the title text.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 4.1* 到 *图 4.4* 所示，所有顶部栏的宽度相同，只是在高度和标题文本的位置上有所不同。
- en: 'Let us look at the sample code for one of these top app bars:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些顶部应用栏的示例代码：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we have our custom composable and, inside it, we are using the `CenterAlignedTopBar`
    composable from Material 3 and passing in `Text` to the `title` composable. The
    other three (`LargeTopAppBar`, `MediumTopAppBar`, and `TopAppBar`) are similar;
    the only difference is the composable that you will use. Notice that we have the
    `@OptIn` annotation as these components are still experimental.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了自定义的可组合组件，并在其中使用了 Material 3 的 `CenterAlignedTopBar` 可组合组件，并将 `Text`
    传递给 `title` 可组合组件。其他三个（`LargeTopAppBar`、`MediumTopAppBar` 和 `TopAppBar`）类似；唯一的区别是您将使用的可组合组件。请注意，我们使用了
    `@OptIn` 注解，因为这些组件仍然是实验性的。
- en: Next, let us look at the `FloatingActionButton` component.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 `FloatingActionButton` 组件。
- en: FloatingActionButton
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FloatingActionButton
- en: 'Most apps use the component to represent a call to action that is frequently
    used in the app. For example, create a new chat in a chat app. It is normally
    positioned at the bottom right of the screen or elsewhere, depending on your use
    case. This is how we create the component:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用都使用该组件来表示在应用中经常使用的操作调用。例如，在聊天应用中创建一个新的聊天。它通常位于屏幕的右下角或其他位置，具体取决于您的用例。这就是我们创建组件的方式：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We use the `FloatingActionButton` component from the Material 3 library. We
    have the `onclick` argument on the composable and, inside the `content` lambda,
    we pass in an `Icon` composable that has an *add* icon. The preview should be
    the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Material 3 库中的 `FloatingActionButton` 组件。在可组合组件中，我们有 `onclick` 参数，并在 `content`
    lambda 中传递一个具有 *add* 图标的 `Icon` 可组合组件。预览应该是以下内容：
- en: '![Figure 4.5 – FloatingActionButton](img/B19779_04_05.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.5 – FloatingActionButton](img/B19779_04_05.jpg)'
- en: Figure 4.5 – FloatingActionButton
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – FloatingActionButton
- en: 'The `FloatingActionButton` component has these sizes: large, normal, and small,
    and you can use whichever fits your purpose.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`FloatingActionButton` 组件有以下几种尺寸：大号、常规和小号，您可以使用适合您目的的任意一种。'
- en: 'We have another type of `FloatingActionButton` component known as `ExtendedFloatingActionButton`,
    which looks like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一种名为 `ExtendedFloatingActionButton` 的 `FloatingActionButton` 组件，其外观如下：
- en: '![Figure 4.6 – ExtendedFloatingActionButton](img/B19779_04_06.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.6 – 扩展浮动操作按钮](img/B19779_04_06.jpg)'
- en: Figure 4.6 – ExtendedFloatingActionButton
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 – 扩展浮动操作按钮
- en: 'As seen in the preceding figure, an `ExtendedFloatingActionButton` component
    allows us to add more items to our FAB. They are wider than the normal `FloatActionButton`
    components. In this case, we have a `Text` composable with the text **New Chat**
    in addition to the icon. You can use it with or without the icon. The implementation
    for this is as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，`ExtendedFloatingActionButton` 组件允许我们向我们的 FAB 添加更多项目。它们比正常的 `FloatActionButton`
    组件更宽。在这种情况下，我们有一个带有文本 **新聊天** 的 `Text` 组合组件，以及图标。你可以带图标或不带图标使用它。这个实现的代码如下：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we used the `ExtendedFloatingActionButton` component and still passed
    in the same parameters as before. The only difference is that inside the content,
    we pass in a text since the `content` lambda exposes `RowScope`, which means children
    composables will be arranged in a row.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用了 `ExtendedFloatingActionButton` 组件，并且仍然传递了之前的相同参数。唯一的区别是，在内容内部，我们传递了一个文本，因为
    `content` 漏斗函数暴露了 `RowScope`，这意味着子组合组件将按行排列。
- en: Next, let us look at the bottom app bar components.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看底部应用栏组件。
- en: Bottom app bars
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 底部应用栏
- en: The bottom app bar components display navigation items at the bottom of the
    screen. They are normally useful for apps that have three to five primary destinations.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 底部应用栏组件在屏幕底部显示导航项。它们通常对具有三个到五个主要目的地的应用程序非常有用。
- en: 'Let us look at the code for a bottom app bar:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看底部应用栏的代码：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We use the `BottomAppBar` component and, inside the `actions` lambda, we pass
    in three `Icon` composables to represent the items we are supposed to show. This
    is how the preview of the composable will look:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `BottomAppBar` 组件，并在 `actions` 漏斗函数中传递三个 `Icon` 组合组件来表示我们应该显示的项目。这就是组合组件预览将看起来像这样：
- en: '![Figure 4.7 – BottomAppBar](img/B19779_04_07.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.7 – 底部应用栏](img/B19779_04_07.jpg)'
- en: Figure 4.7 – BottomAppBar
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 – 底部应用栏
- en: In *Figure 4**,7*, we can see we have three icons arranged horizontally.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 4*，7* 中，我们可以看到有三个图标水平排列。
- en: 'Additionally, in `BottomAppBar`, we can also provision a `FloatingActionButton`
    component. We are going to use the `FloatingActionButton` component that we used
    early on. The updated component code is as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在 `BottomAppBar` 中，我们还可以提供 `FloatingActionButton` 组件。我们将使用我们早期使用的 `FloatingActionButton`
    组件。更新的组件代码如下：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the preceding code, we have used the `floatingActionButton` parameter and
    passed in `PacktFloatingActionButton()` that we created earlier. The updated preview
    will be as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了 `floatingActionButton` 参数，并传递了我们之前创建的 `PacktFloatingActionButton()`。更新的预览将如下所示：
- en: '![Figure 4.8 – BottomAppBar with FloatingActionButton](img/B19779_04_08.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.8 – 带有浮动操作按钮的底部应用栏](img/B19779_04_08.jpg)'
- en: Figure 4.8 – BottomAppBar with FloatingActionButton
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 – 带有浮动操作按钮的底部应用栏
- en: As seen in the preceding figure, our `BottomAppBar` now has a nice `FloatingActionButton`
    to its right. The FAB is automatically positioned for you to the right.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，我们的 `BottomAppBar` 现在右侧有一个漂亮的 `FloatingActionButton`。FAB 会自动为你定位到右侧。
- en: We have looked at the different components in isolation, but what happens when
    we want to place them on one screen together? Next, we are going to look at `Scaffold`,
    which is meant for this.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经单独看了不同的组件，但当我们将它们一起放置在同一个屏幕上时会发生什么？接下来，我们将要看看 `Scaffold`，它是为此而设计的。
- en: Scaffold
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Scaffold
- en: This is a layout provided by Material Design that helps place all components
    on your screen in their desired positions with ease.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个由 Material Design 提供的布局，它有助于轻松地将所有组件放置在屏幕上它们期望的位置。
- en: 'Let us look at a sample of `Scaffold` that has a top app bar, a floating action
    button, text center-aligned on the screen, and a bottom navigation bar:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个具有顶部应用栏、浮动操作按钮、屏幕居中文本和底部导航栏的 `Scaffold` 示例：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'A lot is happening here, so let us break it down:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了很多事情，所以让我们分解一下：
- en: The `Scaffold` composable is used to create a layout that implements the Material
    Design guidelines. It is a container that contains the top bar, bottom bar, floating
    action button, and the content.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Scaffold` 组合组件用于创建一个实现 Material Design 指南的布局。它是一个包含顶部栏、底部栏、浮动操作按钮和内容的容器。'
- en: The `topBar` parameter is used to specify the top bar. In this case, we are
    using the `PacktSmallTopAppBar` composable that we created earlier.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`topBar` 参数用于指定顶部栏。在这种情况下，我们使用的是我们之前创建的 `PacktSmallTopAppBar` 组合组件。'
- en: The `bottomBar` parameter is used to specify the bottom bar. In this case, we
    are using the `PacktBottomNavigationBar` composable.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bottomBar` 参数用于指定底部栏。在这种情况下，我们使用的是 `PacktBottomNavigationBar` 组合器。'
- en: The `floatingActionButton` parameter is used to specify the floating action
    button. In this case, we are using the `PacktFloatingActionButton` composable.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`floatingActionButton` 参数用于指定浮动操作按钮。在这种情况下，我们使用的是 `PacktFloatingActionButton`
    组合器。'
- en: The `content` parameter is used to specify the content of the screen. In this
    case, we are using a `Column` composable that contains a `Text` composable. The
    text is centered in the column using the `verticalArrangement` and `horizontalAlignment`
    parameters. Notice that inside `Column`, we are using the `paddingValues` parameter
    to add padding to the column. This is because the `Scaffold` composable passes
    the `padding` values to the `content` parameter.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`content` 参数用于指定屏幕的内容。在这种情况下，我们使用了一个包含 `Text` 组合器的 `Column` 组合器。文本通过 `verticalArrangement`
    和 `horizontalAlignment` 参数在列中居中。请注意，在 `Column` 内部，我们使用 `paddingValues` 参数为列添加填充。这是因为
    `Scaffold` 组合器将 `padding` 值传递给了 `content` 参数。'
- en: 'With our `Scaffold` composable ready, let us see how its preview looks:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Scaffold` 组合器已经准备好了，让我们看看它的预览效果：
- en: '![Figure 4.9 – Scaffold](img/B19779_04_09.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.9 – Scaffold](img/B19779_04_09.jpg)'
- en: Figure 4.9 – Scaffold
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 – Scaffold
- en: In *Figure 4**.9*, we can see that the `Scaffold` composable has added the top
    bar, bottom bar, and the floating action button to the screen. The components
    are also placed in the correct positions as per the Material Design guidelines.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 4**.9* 中，我们可以看到 `Scaffold` 组合器已经将顶部栏、底部栏和浮动操作按钮添加到了屏幕上。组件也按照 Material Design
    指南放置在了正确的位置。
- en: We have learned about a bunch of components so far; Material 3 still offers
    more components out of the box for us. We will be using some of these components
    in the upcoming chapters of this book. To view the full list of all the components,
    go to the Material 3 Components website (https://m3.material.io/components) to
    see them and their guidelines.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了许多组件；Material 3 仍然为我们提供了更多开箱即用的组件。我们将在本书的后续章节中使用一些这些组件。要查看所有组件的完整列表，请访问
    Material 3 组件网站（https://m3.material.io/components）以查看它们及其指南。
- en: Now that we understand Material 3 and its features, let us look at how to add
    it to our apps.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Material 3 及其特性，让我们看看如何将其添加到我们的应用中。
- en: Using Material Design in our apps
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的应用中使用 Material Design
- en: 'To take advantage of the Material 3 features that we looked at in the previous
    section, we need to add it to our app. Luckily, with Android Studio Hedgehog,
    we have Material 3 templates. Even the sample apps we have been using already
    use Material 3\. So cool, right? Let us quickly scan the dependencies to understand
    what is happening:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用上一节中我们查看的 Material 3 特性，我们需要将其添加到我们的应用中。幸运的是，随着 Android Studio Hedgehog
    的推出，我们有 Material 3 模板。甚至我们一直在使用的示例应用也已经使用了 Material 3。真是太酷了！让我们快速扫描依赖项，了解正在发生的事情：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This dependencies block sets up several for us, including the `compose` dependencies.
    The most important one is the `androidx.compose.material3:material3` dependency.
    This is the dependency that contains the Material 3 components. We are using the
    Compose **Bill of Materials** (**BOM**) to manage our dependencies. This means
    that we do not have to specify the version of each dependency. Instead, we specify
    the version of the BOM, and it will manage the versions of the dependencies for
    us. This is the recommended way of managing dependencies in Compose. That is why
    we have not specified the version of each dependency.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个依赖项块为我们设置了几项，包括 `compose` 依赖项。其中最重要的是 `androidx.compose.material3:material3`
    依赖项。这是包含 Material 3 组件的依赖项。我们使用 Compose **物料清单**（**BOM**）来管理我们的依赖项。这意味着我们不需要指定每个依赖项的版本。相反，我们指定
    BOM 的版本，它将为我们管理依赖项的版本。这是在 Compose 中管理依赖项的推荐方式。这就是为什么我们没有指定每个依赖项的版本。
- en: With that, our project is ready to take advantage of the Material 3 features.
    In the next subsection, we will be adding more color schemes to the app.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们的项目就准备好利用 Material 3 的特性了。在下一小节中，我们将为应用添加更多配色方案。
- en: Adding Material Design 3 color schemes
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 Material Design 3 配色方案
- en: As mentioned earlier, Material 3 comes with a lot of fine-grained color schemes
    and introduces **dynamic color**. However, they are not set up with the templates
    that Android Studio generates. We will be setting them up in the next few steps.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Material 3 带来了许多精细的配色方案，并引入了 **动态颜色**。然而，它们并不是与 Android Studio 生成的模板一起设置的。在接下来的几个步骤中，我们将设置它们。
- en: 'Head over to the `ui/theme` package and open the `Color.kt` file, which has
    the following code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 转到`ui/theme`包并打开`Color.kt`文件，其中包含以下代码：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: So far, this file only has a few colors defined. These colors do not cover all
    the color tokens provided by Material 3\. We will add more colors as we need them
    in the app.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，此文件只定义了少量颜色。这些颜色并没有涵盖Material 3提供的所有颜色标记。随着我们在应用程序中需要更多颜色时，我们将添加更多颜色。
- en: 'We will be using the **Material Theme Builder** tool to generate these colors.
    Let us open our browser and go to the Material Theme Builder tool ([https://m3.material.io/theme-builder](https://m3.material.io/theme-builder)).
    We will be presented with the following screen:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用**材料主题构建器**工具来生成这些颜色。让我们打开我们的浏览器并转到材料主题构建器工具([https://m3.material.io/theme-builder](https://m3.material.io/theme-builder))。我们将看到以下屏幕：
- en: '![Figure 4.10 – Material Theme Builder tool](img/B19779_04_10.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图4.10 – 材料主题构建器工具](img/B19779_04_10.jpg)'
- en: Figure 4.10 – Material Theme Builder tool
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10 – 材料主题构建器工具
- en: 'This tool helps us visualize the color schemes for our apps and shows how different
    components will be themed. It makes it easier for us to customize and produce
    a consistent color scheme for our app. It has two tabs: **Dynamic** and **Custom**.
    In the **Dynamic** tab, we can select one of the preloaded colors or wallpapers
    to see how the color changes. One useful feature is that we can also add your
    own wallpaper and generate the colors based on the wallpaper.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此工具帮助我们可视化应用程序的颜色方案，并显示不同组件的主题化效果。它使我们更容易自定义并生成一致的颜色方案。它有两个选项卡：**动态**和**自定义**。在**动态**选项卡中，我们可以选择预加载的颜色或壁纸来查看颜色变化。一个有用的功能是，我们还可以添加自己的壁纸并根据壁纸生成颜色。
- en: 'In the **Custom** tab, we can select a color and the tool generates all the
    complementary colors for us based on the color we select, ensuring a harmonious
    color palette:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在**自定义**选项卡中，我们可以选择一种颜色，工具会根据我们选择的颜色为我们生成所有互补色，确保色彩搭配和谐：
- en: '![Figure 4.11 – Material Theme Builder tool custom color](img/B19779_04_11.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图4.11 – 材料主题构建器工具自定义颜色](img/B19779_04_11.jpg)'
- en: Figure 4.11 – Material Theme Builder tool custom color
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11 – 材料主题构建器工具自定义颜色
- en: On the left, we have the **Core colors** section where we can select either
    **Primary**, **Secondary**, **Tertiary**, or **Neutral** colors for our app.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，我们有**核心颜色**部分，我们可以为我们的应用程序选择**主色**、**次色**、**三级色**或**中性色**。
- en: 'We are going to select the **Primary** color option, which opens a **Color**
    **Picker** dialog:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将选择**主色**选项，这将打开一个**颜色选择器**对话框：
- en: '![Figure 4.12 – Color Picker](img/B19779_04_12.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图4.12 – 颜色选择器](img/B19779_04_12.jpg)'
- en: Figure 4.12 – Color Picker
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.12 – 颜色选择器
- en: 'As we are changing the primary color, we will be able to see the visual preview
    change to match the color we have. Now we have our primary color ready, we are
    going to export the files so that we can use them in our project:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在更改主色，我们将能够看到视觉预览会相应地更改以匹配我们选择的颜色。现在我们已经准备好了主色，我们将导出文件以便在项目中使用：
- en: '![Figure 4.13 – Export option](img/B19779_04_13.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图4.13 – 导出选项](img/B19779_04_13.jpg)'
- en: Figure 4.13 – Export option
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.13 – 导出选项
- en: As seen in *Figure 4**.13*, the visual preview has changed to the color we chose.
    Click on the `ui` folder that has a `theme` folder inside containing `Color.kt`
    and `Theme.kt` files.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如**图4.13**所示，视觉预览已更改为我们选择的颜色。点击包含`Color.kt`和`Theme.kt`文件的`ui`文件夹中的`theme`文件夹。
- en: 'Let us open the `Color.kt` file, which contains the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开`Color.kt`文件，其中包含以下代码：
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can now see, we have more color additions. Let us copy these colors to
    the `Color.kt` file in our project. Next, let us open the `Theme.kt` from the
    unzipped folder.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如你现在所看到的，我们添加了更多的颜色。让我们将这些颜色复制到我们项目中的`Color.kt`文件中。接下来，让我们打开解压文件夹中的`Theme.kt`文件。
- en: 'We will notice it is similar to the `Theme.kt` file but it defines all the
    Material 3 color schemes. Copy the contents of this file and paste them into the
    `Theme.kt` file in our project. We are going to make minor edits to the code to
    make sure we maintain the `ChapterFourTheme` name and dynamic color logic that
    was in our theme. Next, we need to change the `DarkColorScheme` variable values
    to the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会注意到它与`Theme.kt`文件类似，但它定义了所有Material 3颜色方案。复制此文件的全部内容并将其粘贴到我们项目中的`Theme.kt`文件中。我们将对代码进行一些小的编辑，以确保我们保持主题中的`ChapterFourTheme`名称和动态颜色逻辑。接下来，我们需要将`DarkColorScheme`变量的值更改为以下内容：
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the preceding code, we are using the `DarkColorScheme` function to create
    a dark color scheme. We are passing the colors that we generated using the Material
    Theme Builder tool. We will use this color scheme to create a dark theme. The
    dark color scheme variable is defined in a similar manner, and we can copy the
    values from the `Theme.kt` file from the tool and add it there too. Let us now
    look at our theme composable in wholesome:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用 `DarkColorScheme` 函数来创建一个深色颜色方案。我们传递了使用 Material Theme Builder
    工具生成的颜色。我们将使用此颜色方案来创建深色主题。深色颜色方案变量以类似的方式定义，并且我们可以从工具的 `Theme.kt` 文件中复制值并添加到那里。现在让我们看看我们的主题可组合项：
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let us break down the preceding code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解前面的代码：
- en: 'The `ChapterFourTheme` composable is used to create a theme for our app. It
    takes three parameters:'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ChapterFourTheme` 可组合项用于为我们的应用创建主题。它接受三个参数：'
- en: The `darkTheme` parameter is used to specify whether the theme is dark or light.
    By default, we are using the system theme.
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`darkTheme` 参数用于指定主题是深色还是浅色。默认情况下，我们使用系统主题。'
- en: The `dynamicColor` parameter is used to specify whether the theme should use
    dynamic colors. By default, we are using dynamic colors.
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dynamicColor` 参数用于指定主题是否应使用动态颜色。默认情况下，我们使用动态颜色。'
- en: The `content` parameter is used to specify the content of the theme. In this
    case, we are using the `MaterialTheme` composable to create a theme for our app.
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`content` 参数用于指定主题的内容。在这种情况下，我们使用 `MaterialTheme` 可组合项来为我们的应用创建主题。'
- en: The `colorScheme` variable is used to specify the color scheme to use. We are
    using a `when` expression to determine the color scheme to use. If the `dynamicColor`
    parameter is `true` and the device is running Android 12 or higher, we are using
    the `dynamicDarkColorScheme` or `dynamicLightColorScheme` function to create a
    dynamic color scheme. When not using dynamic colors, we fall back to the normal
    themes. If the `darkTheme` parameter is `true`, we are using the `DarkColorScheme`
    variable to create a dark color scheme. Otherwise, we are using the `LightColorScheme`
    variable to create a light color scheme.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`colorScheme` 变量用于指定要使用的颜色方案。我们使用 `when` 表达式来确定要使用的颜色方案。如果 `dynamicColor` 参数为
    `true` 且设备正在运行 Android 12 或更高版本，我们使用 `dynamicDarkColorScheme` 或 `dynamicLightColorScheme`
    函数来创建动态颜色方案。当不使用动态颜色时，我们回退到正常主题。如果 `darkTheme` 参数为 `true`，我们使用 `DarkColorScheme`
    变量来创建深色颜色方案。否则，我们使用 `LightColorScheme` 变量来创建浅色颜色方案。'
- en: The `view` variable is used to get the view that is using the theme.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`view` 变量用于获取正在使用该主题的视图。'
- en: The `SideEffect` composable is used to execute a side effect. In this case,
    we are using it to set the status bar color and the status bar icons’ color. We
    are using the `WindowCompat` class to get `InsetsController` and set the status
    bar color and the status bar icons’ color. We are using the `colorScheme.primary`
    color to set the status bar color. We are using the `darkTheme` parameter to determine
    whether the status bar icons’ color should be light or dark.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SideEffect` 可组合项用于执行副作用。在这种情况下，我们使用它来设置状态栏颜色和状态栏图标颜色。我们使用 `WindowCompat` 类来获取
    `InsetsController` 并设置状态栏颜色和状态栏图标颜色。我们使用 `colorScheme.primary` 颜色来设置状态栏颜色。我们使用
    `darkTheme` 参数来确定状态栏图标颜色应该是浅色还是深色。'
- en: The `MaterialTheme` composable is used to create a theme for our app. We are
    using the `colorScheme` parameter to specify the color scheme to use. We are using
    the `typography` variable to specify the typography to use.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `MaterialTheme` 可组合项来为我们的应用创建主题。我们使用 `colorScheme` 参数来指定要使用的颜色方案。我们使用 `typography`
    变量来指定要使用的排版。
- en: 'To be able to see the changes we have made, we need to call `PacktScaffold`,
    which we created earlier inside the `MainActivity.kt` file in the `ChapterFourTheme`
    block:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够看到我们所做的更改，我们需要调用我们之前在 `ChapterFourTheme` 块中 `MainActivity.kt` 文件内创建的 `PacktScaffold`：
- en: '[PRE11]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let us build and run the app. We should be able to see the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建并运行应用。我们应该能够看到以下内容：
- en: '![Figure 4.14 – Chapter 4 app](img/B19779_04_14.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.14 – 第 4 章应用](img/B19779_04_14.jpg)'
- en: Figure 4.14 – Chapter 4 app
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.14 – 第 4 章应用
- en: 'Like me, you might be wondering why the app does not have the greenish color
    we set on the Material Theme Builder tool. Remember the dynamic color logic in
    our `ChapterFourTheme` composable? It is responsible for the brownish color we
    see. Look at my wallpaper settings:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我一样，你可能想知道为什么应用没有我们在 Material Theme Builder 工具上设置的那种绿色。还记得我们 `ChapterFourTheme`
    可组合项中的动态颜色逻辑吗？它负责我们看到的那种棕色。看看我的壁纸设置：
- en: '![Figure 4.15 – Wallpaper settings](img/B19779_04_15.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.15 – 壁纸设置](img/B19779_04_15.jpg)'
- en: Figure 4.15 – Wallpaper settings
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.15 – 壁纸设置
- en: As seen in *Figure 4**.15*, my wallpaper has a brown color set. This means our
    dynamic color logic is working, and our app can adapt well to my wallpaper settings!
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图 4.15*所示，我的壁纸设置了棕色。这意味着我们的动态颜色逻辑正在工作，我们的应用可以很好地适应我的壁纸设置！
- en: We have seen how to use the Material 3 features in our app. In the next section,
    we will see how we can design UIs that work for large screens and foldables in
    Jetpack Compose.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何在我们的应用中使用 Material 3 功能。在下一节中，我们将看到如何在 Jetpack Compose 中设计适用于大屏幕和可折叠设备的
    UI。
- en: Designing UIs for large screens and foldables
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计大屏幕和可折叠设备的 UI
- en: In recent years and with the release of Material 3, there has been an increased
    focus on tablets and foldable devices. As such, we, as developers, must make our
    apps work well on these devices. In this section, we will look at how we can make
    our apps work well on large screens and foldables. We need to ensure our apps
    adapt to the different screen sizes. Making our apps responsive provides a good
    user experience.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，随着 Material 3 的发布，对平板电脑和可折叠设备的关注有所增加。因此，作为开发者，我们必须确保我们的应用在这些设备上运行良好。在本节中，我们将探讨如何使我们的应用在大屏幕和可折叠设备上运行良好。我们需要确保我们的应用适应不同的屏幕尺寸。使我们的应用具有响应性可以提供良好的用户体验。
- en: 'Material 3 offers **canonical layouts** to serve as guidelines for creating
    UIs for large screens and foldables. These layouts are as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Material 3 提供了**规范布局**作为创建大屏幕和可折叠设备 UI 的指南。这些布局如下：
- en: '**List-detail view**: Here, we place a list of items on the left and, on the
    right, we show the details of a single item.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列表详情视图**：在这里，我们在左侧放置一个项目列表，在右侧显示单个项目的详细信息。'
- en: '**Feed**: Here, we arrange content elements such as cards in a customizable
    grid, which provides a good view of a large amount of content.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态内容**：在这里，我们将内容元素（如卡片）排列在一个可定制的网格中，这为大量内容提供了一个良好的视图。'
- en: '**Supporting pane**: Here, we organize app content into primary and secondary
    display areas. The primary area shows the main content while the secondary area
    shows the supporting content. The primary area occupies most of the screen while
    the secondary area occupies a smaller portion.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持面板**：在这里，我们将应用内容组织成主要和次要显示区域。主要区域显示主要内容，而次要区域显示辅助内容。主要区域占据屏幕的大部分，而次要区域占据较小的一部分。'
- en: For us to show the different layouts, we must know the screen size of the device
    the user is using. Luckily for us, Jetpack Compose provides us with a way to get
    the screen size. We have the Material 3 **WindowSizeClass** to help us determine
    which layout to show in our app.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示不同的布局，我们必须知道用户使用的设备的屏幕尺寸。幸运的是，Jetpack Compose 为我们提供了一种获取屏幕尺寸的方法。我们有 Material
    3 的 **WindowSizeClass** 来帮助我们确定在应用中显示哪种布局。
- en: We are going to learn how to use `WindowSizeClass` next.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何使用 `WindowSizeClass`。
- en: Using WindowSizeClass
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 WindowSizeClass
- en: 'For us to use `WindowSizeClass`, we must add the following dependency to our
    app:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 `WindowSizeClass`，我们必须在我们的应用中添加以下依赖项：
- en: '[PRE12]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is the Material 3 dependency that adds `WindowSizeClass` to our project.
    Notice we are not providing a version for this dependency. This is because we
    are using the Compose BOM to manage our dependencies. The BOM will manage the
    version of this dependency for us.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Material 3 依赖项，它将 `WindowSizeClass` 添加到我们的项目中。请注意，我们没有为这个依赖项提供版本号。这是因为我们正在使用
    Compose BOM 来管理我们的依赖项。BOM 将为我们管理这个依赖项的版本。
- en: '`WindowSizeClass` classifies the available screen width into three categories:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`WindowSizeClass` 将可用的屏幕宽度分为三个类别：'
- en: '`Compact`: This is for devices whose width is less than 600 dp. Commonly, these
    are devices in portrait mode.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`紧凑型`：适用于宽度小于 600 dp 的设备。通常，这些设备处于纵向模式。'
- en: '`Medium`: This is for devices whose width is between 600 dp and 840 dp. Devices
    such as tablets and foldables in portrait mode fall into this category.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`中等`：适用于宽度在 600 dp 和 840 dp 之间的设备。属于这一类别的设备包括纵向模式下的平板电脑和可折叠设备。'
- en: '`Expanded`: This is for devices whose width is greater than 840 dp. Devices
    such as tablets and foldables in landscape mode, phones in landscape mode, and
    desktops fall into this category.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`扩展型`：适用于宽度大于 840 dp 的设备。属于这一类别的设备包括平板电脑和横向模式下的可折叠设备、横向模式下的手机和桌面电脑。'
- en: '`WindowSizeClass` uses `widthSizeClass` to get the width of the screen. In
    addition to `widthSizeClass`, it also has `heightSizeClass` to help us determine
    the height of the screen.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`WindowSizeClass` 使用 `widthSizeClass` 来获取屏幕宽度。除了 `widthSizeClass`，它还有 `heightSizeClass`
    来帮助我们确定屏幕高度。'
- en: 'Let us look at `widthSizeClass` in action:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `widthSizeClass` 的实际应用：
- en: '[PRE13]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here is an explanation of what the preceding code is doing:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是对前面代码所做解释：
- en: The `calculateWindowSizeClass` function is used to calculate `WindowSizeClass`.
    We are passing the activity as the parameter. The function is from the `WindowSizeClass`
    APIs. It has the `widthSizeClass` and `heightSizeClass` properties, which we can
    use to get the width and height of the screen, respectively.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calculateWindowSizeClass` 函数用于计算 `WindowSizeClass`。我们将活动作为参数传递。该函数来自 `WindowSizeClass`
    API。它有 `widthSizeClass` 和 `heightSizeClass` 属性，我们可以使用它们来分别获取屏幕的宽度和高度。'
- en: 'We use `widthSizeClass` to customize our display options:'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `widthSizeClass` 来自定义我们的显示选项：
- en: For the `WindowWidthSizeClass.Compact` case, we are using `BottomNavigation`
    for navigation, and the UI should only show the list of characters
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `WindowWidthSizeClass.Compact` 的情况，我们使用 `BottomNavigation` 进行导航，UI 应仅显示角色列表
- en: For the `WindowWidthSizeClass.Medium` case, we are using `NavigationRail` for
    navigation, and the UI should show the list of characters and the details of the
    selected character
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `WindowWidthSizeClass.Medium` 的情况，我们使用 `NavigationRail` 进行导航，UI 应显示角色列表和所选角色的详细信息
- en: For the `WindowWidthSizeClass.Expanded` case, we are using `NavigationDrawer`
    for navigation. and the UI should show the list of characters and the details
    of the selected character
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `WindowWidthSizeClass.Expanded` 的情况，我们使用 `NavigationDrawer` 进行导航，UI 应显示角色列表和所选角色的详细信息
- en: We have a default case where we are using `BottomNavigation` for navigation,
    and the UI should only show the list of characters
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个默认情况，其中我们使用 `BottomNavigation` 进行导航，UI 应仅显示角色列表
- en: At a glance, you can see how we take advantage of `WindowSizeClass` to customize
    our UI and navigation type based on the screen size. This is an immensely powerful
    feature that we can use to make our apps responsive. This makes sure we take advantage
    of the screen size and provide a good user experience.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一眼就能看出我们如何利用 `WindowSizeClass` 来根据屏幕大小自定义我们的 UI 和导航类型。这是一个非常强大的功能，我们可以用它来使我们的应用程序响应。这确保了我们充分利用屏幕大小，并提供良好的用户体验。
- en: The example shown in this section was a simple one. In [*Chapter 7*](B19779_07.xhtml#_idTextAnchor092)
    of this book, we will have a more detailed example where we will use `WindowSizeClass`
    to customize our UI based on the screen size.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中展示的示例很简单。在本书的[*第7章*](B19779_07.xhtml#_idTextAnchor092)中，我们将有一个更详细的示例，其中我们将使用
    `WindowSizeClass` 来根据屏幕大小自定义我们的 UI。
- en: Now that we know how to design and build apps for large screens and foldables,
    let us look at yet another important topic in this chapter, which is accessibility.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何设计和构建适用于大屏幕和可折叠设备的应用程序，让我们看看本章的另一个重要主题，即无障碍性。
- en: Making our app accessible
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使我们的应用程序无障碍
- en: 'Making the apps that we develop accessible is extremely important. It ensures
    that our apps can be used by everyone. In this section, we will look at how we
    can make our apps accessible. Jetpack Compose uses **semantics** to make our apps
    accessible. Semantics are used to describe the UI elements in our apps. They are
    used by accessibility services to make our apps accessible. Semantics are also
    used by automated testing tools to test our apps. Some of the best practices for
    making our apps accessible are as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使我们开发的应用程序无障碍非常重要。它确保我们的应用程序可以被每个人使用。在本节中，我们将探讨我们如何使我们的应用程序无障碍。Jetpack Compose
    使用 **语义** 来使我们的应用程序无障碍。语义用于描述我们应用程序中的 UI 元素。它们被辅助功能服务用来使我们的应用程序无障碍。语义也被自动化测试工具用来测试我们的应用程序。使我们的应用程序无障碍的一些最佳实践如下：
- en: We should always ensure that all clickable or touchable elements or those that
    require user interaction are large enough to be easily tapped or clicked. Most
    Material components out of the box have a default size that is large enough to
    be easily tapped or clicked. If we must size by ourselves, we should ensure that
    the size is at least 48 dp by 48 dp.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应始终确保所有可点击或可触摸的元素或需要用户交互的元素足够大，以便容易点击或触摸。大多数 Material 组件默认大小已经足够大，可以轻松点击或触摸。如果我们必须自行设置大小，我们应该确保大小至少为
    48 dp x 48 dp。
- en: 'We should add content descriptions to our composables. Components such as `Icon`
    and `Image` provide this argument to describe visual elements to accessibility
    services. We should always provide a content description for these components.
    The following is an example:'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该为我们的可组合元素添加内容描述。例如，`Icon`和`Image`组件提供了这个参数来描述视觉元素以供辅助服务使用。我们应该始终为这些组件提供内容描述。以下是一个示例：
- en: '[PRE14]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can see in the preceding code that we are using the `contentDescription`
    parameter to provide a description for `Icon`. This is a good practice that we
    should always follow.
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在前面的代码中看到，我们正在使用`contentDescription`参数为`Icon`提供描述。这是一个我们应该始终遵循的良好实践。
- en: 'We should label our clickable elements. We can pass a clickable label to the
    clickable modifiers. This enables us to add descriptions to our clickable elements.
    The following is an example:'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该为可点击元素添加标签。我们可以将可点击标签传递给可点击修饰符。这使得我们能够为我们的可点击元素添加描述。以下是一个示例：
- en: '[PRE15]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding example, we are using the `onClickLabel` parameter to add a
    description to the `Text` composable. This is a good practice that we should always
    follow.
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们正在使用`onClickLabel`参数为`Text`可组合元素添加描述。这是一个我们应该始终遵循的良好实践。
- en: 'By using semantics, we can also describe headers. Headers are used to describe
    the content that follows them. We can use semantics to add a header to our composables.
    The following is an example:'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用语义，我们还可以描述标题。标题用于描述其后的内容。我们可以使用语义为我们的可组合元素添加标题。以下是一个示例：
- en: '[PRE16]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can additionally provide information about the state of our composables.
    For example, we can provide information about the state of a button. We can use
    semantics to provide this information. The following is an example:'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以提供关于我们可组合元素状态的信息。例如，我们可以提供关于按钮状态的信息。我们可以使用语义来提供这些信息。以下是一个示例：
- en: '[PRE17]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This helps us inform our users about the state of our composables.
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这有助于我们向用户告知我们可组合元素的状态。
- en: 'For some groups of components, we can also use the `mergeDescendants` parameter
    to merge the semantics of the children composables. The following is an example:'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于某些组件组，我们也可以使用`mergeDescendants`参数合并子可组合元素的语义。以下是一个示例：
- en: '[PRE18]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Merging descendants is useful when we want to provide a description for a group
    of composables. In the preceding example, we are using the `mergeDescendants`
    parameter to merge the semantics of the `Text` composables. However, we should
    be careful when using this parameter. We should only use it when we want to provide
    a description for a group of composables. If we use it for a large group of composables,
    it can lead to performance issues and can also be confusing for the users.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们想要为多个可组合元素提供描述时，合并后裔是有用的。在前面的示例中，我们正在使用`mergeDescendants`参数合并`Text`可组合元素的语义。然而，在使用此参数时我们应该小心。我们只应该在想要为多个可组合元素提供描述时使用它。如果我们为大量可组合元素使用它，可能会导致性能问题，也可能使用户感到困惑。
- en: To learn more about accessibility in Jetpack Compose, visit the official documentation
    ([https://developer.android.com/jetpack/compose/accessibility](https://developer.android.com/jetpack/compose/accessibility)).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于Jetpack Compose的辅助功能信息，请访问官方文档([https://developer.android.com/jetpack/compose/accessibility](https://developer.android.com/jetpack/compose/accessibility))。
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced Material 3\. We also covered the features that
    Material 3 offers. We saw how to use Material 3 in our apps. Additionally, we
    covered how to design and develop our apps for large screens and, finally, we
    saw how to make our Jetpack Compose UIs accessible.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Material 3。我们还涵盖了Material 3提供的功能。我们看到了如何在我们的应用程序中使用Material 3。此外，我们还介绍了如何为大型屏幕设计和开发我们的应用程序，最后，我们看到了如何使我们的Jetpack
    Compose UI易于访问。
- en: In the next chapter, we will continue building upon the skills that we’ve gained
    from the previous chapters. We will be looking at how to architect our app and
    the different architectures available. We will learn how to use Jetpack libraries
    in our apps and how to tackle dependency injection.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续构建从前几章中获得的知识。我们将探讨如何构建我们的应用程序以及可用的不同架构。我们将学习如何在我们的应用程序中使用Jetpack库以及如何处理依赖注入。
- en: 'Part 2: Using Advanced Features'
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：使用高级功能
- en: Building upon the foundational knowledge gained in *Part 1*, this part propels
    you into advanced concepts, providing a deeper understanding of Android development.
    Delving into diverse architectures, the focus shifts toward mastering the MVVM
    architecture for your applications. Furthermore, you will unravel the intricacies
    of making network calls by incorporating the Retrofit networking library. Taking
    it a step further, you will harness the power of Kotlin coroutines to seamlessly
    execute asynchronous network requests. Your navigational prowess will be honed
    using the Jetpack Navigation library, exploring techniques for efficient navigation
    on large screens and foldable devices. The journey continues with insights into
    handling long-running tasks in the background and leveraging Room for local data
    storage. Wrapping up, we will demystify runtime permissions, and you will comprehend
    their significance and master the art of requesting permissions dynamically within
    your app.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了*第一部分*的基础知识之后，本部分将带你进入高级概念，为你提供对Android开发的深入理解。深入各种架构，重点转向掌握你应用的MVVM架构。此外，你将通过整合Retrofit网络库来揭示进行网络调用的复杂性。更进一步，你将利用Kotlin协程的力量，无缝执行异步网络请求。你的导航技巧将通过使用Jetpack
    Navigation库得到磨练，探索在大屏幕和可折叠设备上高效导航的技术。旅程继续，你将了解如何处理后台长时间运行的任务，并利用Room进行本地数据存储。最后，我们将揭开运行时权限的神秘面纱，你将理解其重要性，并掌握在应用中动态请求权限的技巧。
- en: 'This section contains the following chapters:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含以下章节：
- en: '[*Chapter 5*](B19779_05.xhtml#_idTextAnchor067), *Architect Your App*'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B19779_05.xhtml#_idTextAnchor067), *构建你的应用*'
- en: '[*Chapter 6*](B19779_06.xhtml#_idTextAnchor084), *Network Calls with Kotlin
    Coroutines*'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B19779_06.xhtml#_idTextAnchor084), *使用Kotlin协程进行网络调用*'
- en: '[*Chapter 7*](B19779_07.xhtml#_idTextAnchor092), *Navigating within Your App*'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B19779_07.xhtml#_idTextAnchor092), *在应用内导航*'
- en: '[*Chapter 8*](B19779_08.xhtml#_idTextAnchor101), *Persisting Data Locally and
    Doing Background Work*'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B19779_08.xhtml#_idTextAnchor101), *本地持久化数据和后台工作*'
- en: '[*Chapter 9*](B19779_09.xhtml#_idTextAnchor112), *Runtime Permissions*'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B19779_09.xhtml#_idTextAnchor112), *运行时权限*'
