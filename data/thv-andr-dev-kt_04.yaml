- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Backing Up Your WhatsPackt Messages
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 备份您的WhatsPackt消息
- en: In any chat application, data handling is a significant concern – we need to
    ensure that messages sent and received are stored correctly, quickly retrieved
    when needed, and resilient to potential losses due to unforeseen circumstances
    such as device failures or accidental deletions. This requires a robust data persistence
    strategy. We also need to consider performance and user experience, which calls
    for effective caching mechanisms, as well as making sure that we have backups
    in the event of data loss or when the user changes devices.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何聊天应用中，数据处理都是一个重要的问题——我们需要确保发送和接收的消息被正确存储，在需要时能够快速检索，并且对潜在的损失具有弹性，如设备故障或意外删除等不可预见的情况。这需要一个强大的数据持久化策略。我们还需要考虑性能和用户体验，这需要有效的缓存机制，并确保在数据丢失或用户更换设备时我们有备份。
- en: In this chapter, we will start by introducing you to Room, a persistence library
    that provides an abstraction layer over SQLite and makes it easier to work with
    databases in Android. You’ll learn about its architecture and components and how
    to use it to store and retrieve chat conversations and messages.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先向您介绍Room，这是一个持久化库，它提供了一个在SQLite之上的抽象层，使得在Android中处理数据库变得更加容易。您将了解其架构和组件，以及如何使用它来存储和检索聊天对话和消息。
- en: Next, we will tackle the creation of a cache mechanism orchestrating the use
    of Room locally and the use of the API to gather data from the backend.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将处理创建一个缓存机制，协调Room在本地使用以及使用API从后端获取数据。
- en: Moving forward, we’ll get you up to speed with Firebase Storage. You’ll learn
    to set it up, understand its benefits, and how to secure data stored in it. We’ll
    then use Firebase Storage to create a backup of our chat conversations, an essential
    feature for any chat application.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将让您熟悉Firebase存储。您将学习如何设置它，了解其优势，以及如何确保存储在其中的数据安全。然后我们将使用Firebase存储来创建聊天对话的备份，这对于任何聊天应用来说都是一个基本功能。
- en: Finally, we’ll explore how to use `WorkManager`, an API that makes it easy to
    schedule deferrable, asynchronous tasks even if the app exits or the device restarts.
    You’ll learn how it can be used to schedule chat backups and how to upload these
    backups to **Amazon Simple Storage Service** (**Amazon S3**), ensuring data safety.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将探讨如何使用`WorkManager` API，它使得即使在应用退出或设备重启的情况下也能轻松安排可延迟的异步任务。您将了解它如何用于安排聊天备份，以及如何将这些备份上传到**Amazon
    Simple Storage Service**（**Amazon S3**），确保数据安全。
- en: 'So, in this chapter, we will be covering the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将涵盖以下主题：
- en: Understanding Room
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Room
- en: Implementing Room in WhatsPackt
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在WhatsPackt中实现Room
- en: Getting to know Firebase Storage
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Firebase存储
- en: Scheduling **WorkManager** to send backups
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安排**WorkManager**发送备份
- en: Using Amazon S3 for storage
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Amazon S3进行存储
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: As in the previous chapter, you will need to have installed Android Studio (or
    another editor of your preference).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，您需要已安装Android Studio（或您偏好的其他编辑器）。
- en: 'We are also going to assume that you followed along with the previous chapter.
    You can download this chapter’s complete code from here: [https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-3](https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-3).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还假设您已经跟随了前一章的内容。您可以从这里下载本章的完整代码：[https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-3](https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-3)。
- en: Understanding Room
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Room
- en: When it comes to Android development, one of the most essential tasks is managing
    your application’s data in a local database. The **Room** persistence library,
    part of Android Jetpack, is an abstraction layer over SQLite, a popular database
    that comes with Android. Room offers more robust database access while harnessing
    SQLite’s full power.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android开发中，最基本的一项任务就是管理您应用的数据在本地数据库中的存储。Android Jetpack的一部分，**Room**持久化库，是在Android中自带的一个流行数据库SQLite之上的抽象层。Room提供了更健壮的数据库访问，同时利用了SQLite的全部功能。
- en: Key features of Room
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Room的关键特性
- en: Before Room, developers primarily used **SQLite** directly or other **object-relational
    mapping** (**ORM**) libraries. While SQLite is powerful, it can be cumbersome
    to work with because it requires writing a lot of boilerplate code. Additionally,
    errors in SQL queries often aren’t detected until runtime, which can lead to crashes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在Room之前，开发者主要直接使用**SQLite**或其他**对象关系映射（ORM**）库。虽然SQLite功能强大，但使用起来可能很繁琐，因为它需要编写大量的样板代码。此外，SQL查询中的错误通常直到运行时才会被发现，这可能导致崩溃。
- en: 'Room solves these issues by providing a simpler and more robust API over the
    standard SQLite for managing local data storage. Here are some of its key features:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Room通过提供一个比标准SQLite更简单、更健壮的API来解决这些问题，用于管理本地数据存储。以下是它的一些关键特性：
- en: '**Compile-time verification of SQL queries**: Room verifies your SQL queries
    at compile time, not at runtime. This means if there’s an error in one of your
    queries, you’ll know as soon as you compile your app, not after you’ve shipped
    it to users. This leads to more robust and reliable code.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SQL查询的编译时验证**：Room在编译时验证您的SQL查询，而不是在运行时。这意味着如果您的查询中存在错误，您将在编译应用时立即知道，而不是在将应用发布给用户之后。这导致更健壮和可靠的代码。'
- en: '**Reduced boilerplate code**: With Room, you don’t need to write as much code
    to perform simple database operations. This leads to cleaner, more readable code.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少样板代码**：使用Room，您不需要编写太多代码来执行简单的数据库操作。这导致代码更清晰、更易于阅读。'
- en: '**Integration with other architecture components**: Room is designed to integrate
    seamlessly with other **Android Architecture Components** (**AAC**) library components,
    such as **LiveData** and **ViewModel**. This means you can create a well-architected,
    robust app that follows best practices for Android development.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与其他架构组件的集成**：Room被设计成与其他**Android架构组件（AAC**）库组件无缝集成，例如**LiveData**和**ViewModel**。这意味着您可以创建一个结构良好、健壮的应用，遵循Android开发的最佳实践。'
- en: '**Easy migration paths**: Room offers robust migration support, including migration
    paths and testing. As your app’s data needs evolve, Room makes it easy to adapt
    your database structure to meet those needs.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于迁移路径**：Room提供了强大的迁移支持，包括迁移路径和测试。随着您的应用数据需求的发展，Room使您能够轻松地调整数据库结构以满足这些需求。'
- en: '**Supports complex queries**: Despite simplifying interaction with SQLite,
    Room still allows you to perform complex SQL queries when you need more flexibility
    and power.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持复杂查询**：尽管简化了与SQLite的交互，但Room仍然允许您在需要更多灵活性和功能时执行复杂的SQL查询。'
- en: As you can see, Room offers an efficient and streamlined approach to managing
    your app’s local data. It’s a powerful tool that can make your Android development
    experience much more pleasant and productive.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Room提供了一种高效且简化的方法来管理您应用的本地区域数据。它是一个强大的工具，可以使您的Android开发体验更加愉快和高效。
- en: Room’s architecture and components
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Room的架构和组件
- en: 'Room’s architecture is based on three main components:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 房间架构基于三个主要组件：
- en: '**Database**'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库**'
- en: '**Entity**'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实体**'
- en: '**Data Access** **Object** (**DAO**)'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据访问对象（DAO**）'
- en: 'Here, you can see how every Room component interacts with the rest of the app:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到每个Room组件如何与整个应用交互：
- en: '![Figure 3.1: Diagram of Room architecture](img/B19443_03_001.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1：Room架构图](img/B19443_03_001.jpg)'
- en: 'Figure 3.1: Diagram of Room architecture'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：Room架构图
- en: Understanding these components is crucial when using Room effectively, so let’s
    dive into them deeper.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这些组件对于有效地使用Room至关重要，因此让我们更深入地探讨它们。
- en: Database
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据库
- en: The `Database` class in Room is a high-level class that works as the main access
    point to your app’s persisted data. It’s an abstract class where you define an
    abstract method for each `@Dao` annotation in your app. When you create an instance
    of the `Database` class, Room generates the implementation code of these DAO methods
    (DAO will be explored in more detail in a moment).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Room中的`Database`类是一个高级类，作为您应用持久数据的主体访问点。它是一个抽象类，您在其中为应用中的每个`@Dao`注解定义一个抽象方法。当您创建`Database`类的实例时，Room会生成这些DAO方法的实现代码（DAO将在稍后详细介绍）。
- en: 'The `Database` class is annotated with `@Database`, specifying the entities
    it comprises and the database version. If you modify the database schema, you
    need to update the version number and define a migration strategy, as in the following
    example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`Database`类使用`@Database`注解，指定其包含的实体和数据库版本。如果您修改数据库模式，您需要更新版本号并定义一个迁移策略，如下例所示：'
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we’ve defined a `ChatAppDatabase` Room `Database` class with two entities,
    `Message` and `Conversation`. We’ve also defined abstract methods to access our
    DAOs – `messageDao()` and `conversationDao()`. The `entities` parameter in the
    `@Database` annotation takes an array of all entities in the database, while the
    `version` parameter is used for database migration purposes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个包含两个实体`Message`和`Conversation`的`ChatAppDatabase` Room `Database`类。我们还定义了访问我们的DAO的抽象方法
    - `messageDao()`和`conversationDao()`。`@Database`注解中的`entities`参数接受数据库中所有实体的数组，而`version`参数用于数据库迁移目的。
- en: Entity
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实体
- en: '**Entities** in Room represent the tables in a database. Each entity corresponds
    to a table, and each instance of an entity represents a row in the table. Room
    uses the class fields in an entity to define the columns in a table.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**实体**在Room中表示数据库中的表。每个实体对应一个表，每个实体的实例代表表中的一行。Room使用实体中的类字段来定义表中的列。'
- en: 'You declare an entity by annotating a data class with `@Entity`. Each `@Entity`
    class represents a table in your database, and you can define the table name.
    If you don’t define a table name, Room uses the class name as the table name,
    as in the following example:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在数据类上标注`@Entity`来声明一个实体。每个`@Entity`类代表数据库中的一个表，并且您可以定义表名。如果您没有定义表名，Room将使用类名作为表名，如下例所示：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, `Message` is an entity that represents a `"messages"` table in our database.
    Each instance of `Message` will represent a row within the `"messages"` table.
    Each property in the `Message` class represents a column in the table. The `@PrimaryKey`
    annotation is used to denote a primary key, and the `@ColumnInfo` annotation is
    used to specify the column name in the database. If not specified, Room uses the
    variable name as the column name.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Message`是一个实体，代表我们数据库中的`"messages"`表。`Message`的每个实例将代表`"messages"`表中的一行。`Message`类中的每个属性代表表中的一列。`@PrimaryKey`注解用于表示主键，而`@ColumnInfo`注解用于指定数据库中的列名。如果没有指定，Room将使用变量名作为列名。
- en: DAO
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DAO
- en: DAOs are interfaces that define all the database operations that you want to
    perform. For each DAO, you can define methods for different operations such as
    insertion, deletion, and querying.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: DAO是定义您想要执行的所有数据库操作的接口。对于每个DAO，您可以定义不同的操作方法，例如插入、删除和查询。
- en: 'You should annotate an interface with `@Dao`, and then annotate each method
    with the corresponding operation you want to perform, such as `@Insert`, `@Delete`,
    `@Update`, or `@Query` for custom queries. Then, Room will autogenerate the necessary
    code to perform these operations at compile time. Here’s an example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该使用`@Dao`注解一个接口，然后使用相应的操作注解每个方法，例如`@Insert`、`@Delete`、`@Update`或`@Query`用于自定义查询。然后，Room将在编译时自动生成执行这些操作所需的代码。以下是一个示例：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this `MessageDao` interface, we’ve defined two methods – `insert()` for inserting
    a `Message` object into our database and `getMessagesForConversation()` to retrieve
    all messages related to a specific conversation from our database. The `@Insert`
    annotation is a convenience annotation for inserting an entity into a table. The
    `@Query` annotation allows us to write SQL queries to perform complex reads and
    writes.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`MessageDao`接口中，我们定义了两个方法 - `insert()`用于将`Message`对象插入到我们的数据库中，以及`getMessagesForConversation()`从我们的数据库中检索与特定对话相关的所有消息。`@Insert`注解是一个方便的注解，用于将实体插入到表中。`@Query`注解允许我们编写SQL查询以执行复杂的读写操作。
- en: Understanding these components will allow us to leverage the power of Room effectively.
    The following sections will guide you through the process of implementing Room
    in our WhatsPackt application, starting from setting it up in Android Studio to
    creating entities and DAOs.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这些组件将使我们能够有效地利用Room的强大功能。以下几节将指导您在WhatsPackt应用中实现Room的过程，从在Android Studio中设置它开始，到创建实体和DAO。
- en: Implementing Room in WhatsPackt
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在WhatsPackt中实现Room
- en: In this section, you will be guided through the practical steps of implementing
    Room in our chat application. We will begin by setting up Room in Android Studio,
    followed by creating entities and DAOs and eventually using these components to
    interact with our database.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将指导我们在我们的聊天应用中实现Room的实际步骤。我们将从在Android Studio中设置Room开始，然后创建实体和DAO，最终使用这些组件与我们的数据库进行交互。
- en: Adding dependencies
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加依赖项
- en: 'To start using Room, we first need to include the necessary dependencies in
    our project. Open your `build.gradle` file and add the following dependencies
    under `dependencies`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 Room，我们首先需要在项目中包含必要的依赖项。打开你的 `build.gradle` 文件，并在 `dependencies` 下添加以下依赖项：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `room-runtime` dependency includes the core Room library, while the `room-compiler`
    dependency is required for Room’s annotation-processing capabilities. Room’s Kotlin
    extensions and coroutines support are provided by `room-ktx`, while `room-testing`
    provides useful classes for testing your Room setup.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`room-runtime` 依赖项包括 Room 的核心库，而 `room-compiler` 依赖项是 Room 注解处理能力的必需品。Room
    的 Kotlin 扩展和协程支持由 `room-ktx` 提供，而 `room-testing` 提供了用于测试 Room 设置的有用类。'
- en: 'After adding these lines, sync your project. You can do it using the `build.gradle`
    file:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这些行后，同步你的项目。你可以通过 `build.gradle` 文件来完成：
- en: '![Figure 3.2: The Sync Now option that appears in Android Studio when it detects
    any changes to Gradle files](img/B19443_03_002.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2：当 Android Studio 检测到 Gradle 文件有任何更改时出现的“同步现在”选项](img/B19443_03_002.jpg)'
- en: 'Figure 3.2: The Sync Now option that appears in Android Studio when it detects
    any changes to Gradle files'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2：当 Android Studio 检测到 Gradle 文件有任何更改时出现的“同步现在”选项
- en: We are ready now to create our database.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好创建我们的数据库。
- en: Creating the database
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建数据库
- en: 'As discussed before, the `Database` component is the main access point for
    our app’s data. So, let’s create a `ChatAppDatabase` class:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`Database` 组件是我们应用程序数据的主要访问点。因此，让我们创建一个 `ChatAppDatabase` 类：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `@Database` annotation marks this class as a Room database. It takes two
    parameters:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Database` 注解将这个类标记为 Room 数据库。它接受两个参数：'
- en: '**entities** is an array of classes that are annotated with **@Entity**, representing
    the tables within the database. In this case, the **Message** and **Conversation**
    classes are entities of **ChatAppDatabase**.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**entities** 是一个被 **@Entity** 注解的类数组，代表数据库中的表。在这种情况下，**Message** 和 **Conversation**
    类是 **ChatAppDatabase** 的实体。'
- en: '**version** is the database version. If you make changes to the database schema,
    you’ll need to increment this version number and define a migration strategy.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**version** 是数据库版本。如果你对数据库模式进行了更改，你需要增加这个版本号并定义一个迁移策略。'
- en: 'Next, `abstract fun messageDao(): MessageDao` and `abstract fun conversationDao():
    ConversationDao` are abstract methods that return the respective DAOs. They do
    not have method bodies because Room generates their implementations.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，`abstract fun messageDao(): MessageDao` 和 `abstract fun conversationDao():
    ConversationDao` 是返回相应 DAO 的抽象方法。它们没有方法体，因为 Room 会生成它们的实现。'
- en: Then, we declare a companion object to hold a singleton instance of `ChatAppDatabase`,
    by using the `@Volatile` annotation. This annotation means `INSTANCE` can be accessed
    by multiple threads at once but always in a consistent state, meaning a change
    made by one thread to `INSTANCE` is immediately visible to all other threads.
    `INSTANCE` is marked as nullable because it might not be initialized immediately.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过使用 `@Volatile` 注解声明一个伴随对象来持有 `ChatAppDatabase` 的单例实例。这个注解意味着 `INSTANCE`
    可以被多个线程同时访问，但总是处于一致的状态，这意味着一个线程对 `INSTANCE` 的更改会立即对所有其他线程可见。`INSTANCE` 被标记为可空，因为它可能不会立即初始化。
- en: In the `getDatabase()` function, we’re implementing a common pattern for creating
    a singleton instance of a class in a thread-safe way. This pattern ensures that
    only one instance of `ChatAppDatabase` is ever created.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `getDatabase()` 函数中，我们正在实现创建类单例实例的常见模式，以线程安全的方式。这个模式确保 `ChatAppDatabase` 只会创建一个实例。
- en: We use the `?:` operator to check whether `INSTANCE` is not `null`, and if it
    is, we enter the synchronized block. This block ensures that only one thread can
    enter this block of code at a time, preventing the creation of multiple instances
    of `ChatAppDatabase` if the function is called concurrently from multiple threads.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `?:` 操作符来检查 `INSTANCE` 是否不是 `null`，如果是，则进入同步块。这个块确保一次只有一个线程可以进入这段代码，防止在多个线程从多个线程并发调用该函数时创建多个
    `ChatAppDatabase` 实例。
- en: Within the synchronized block, we’re calling `Room.databaseBuilder()` to create
    a new instance of `ChatAppDatabase`. We provide the application context to avoid
    memory leaks, the class of the database, and the name of the database.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在同步块内，我们调用 `Room.databaseBuilder()` 来创建 `ChatAppDatabase` 的新实例。我们提供应用程序上下文以避免内存泄漏，数据库的类以及数据库的名称。
- en: Finally, we call `build()` to create the `ChatAppDatabase` instance.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用 `build()` 来创建 `ChatAppDatabase` 实例。
- en: After creating the new instance, we assign it to `INSTANCE` to cache it and
    then return the instance. The next time `getDatabase` is called, it will return
    the cached database instance instead of creating a new one. This is important
    because creating a Room database instance is an expensive operation, and having
    multiple instances would be a waste of resources.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新实例后，我们将其分配给`INSTANCE`以缓存它，然后返回实例。下次调用`getDatabase`时，它将返回缓存的数据库实例而不是创建一个新的实例。这很重要，因为创建Room数据库实例是一个昂贵的操作，拥有多个实例将会浪费资源。
- en: This structure is essential for creating a database instance that will allow
    us to store messages and conversations.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构对于创建一个数据库实例至关重要，这将使我们能够存储消息和对话。
- en: The next step is to create entity classes.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建实体类。
- en: Creating entity classes
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建实体类
- en: 'The first entity class we are going to create is the `Message` class:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要创建的第一个实体类是`Message`类：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this code, we are including quite a lot of instructions in the annotations,
    so let’s go through them.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们在注解中包含了相当多的指令，所以让我们逐一解释它们。
- en: 'The `@Entity` annotation tells Room to treat this class as a table in the database.
    It comes with optional arguments, some of which are used here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Entity`注解告诉Room将这个类作为数据库中的表处理。它带有可选参数，其中一些在这里使用：'
- en: '**tableName**: This sets the name of the table as it will appear in the database.
    In this case, our table will be named **"messages"**.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**tableName**: 这设置了表在数据库中的名称。在这种情况下，我们的表将命名为**"messages"**。'
- en: '**foreignKeys**: This sets up a foreign key relationship with another table.
    A **ForeignKey** instance takes four main arguments:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**foreignKeys**: 这设置了与另一个表的外键关系。一个**ForeignKey**实例接受四个主要参数：'
- en: '**entity**: This represents the class of the parent table that this entity
    has a relationship with. In this case, it’s **Conversation::class**.'
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**entity**: 这表示与该实体有关系的父表类。在这种情况下，它是**Conversation::class**。'
- en: '**parentColumns**: This specifies the column(s) in the parent entity that the
    foreign key references. Here, it’s the **id** field of **Conversation**.'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**parentColumns**: 这指定了父实体中外键引用的列。在这里，它是**Conversation**的**id**字段。'
- en: '**childColumns**: This specifies the column(s) in the child entity that holds
    the foreign key. Here, it’s the **conversation_id** field in **Message**.'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**childColumns**: 这指定了子实体中包含外键的列。在这里，它是**Message**中的**conversation_id**字段。'
- en: '**onDelete**: This represents the action that will be taken if the referenced
    row in the parent table is deleted. Here, **ForeignKey.CASCADE** is used, which
    means that if a **Conversation** instance is deleted, all messages that have a
    **conversation_id** value referencing the conversation’s ID will be deleted as
    well.'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**onDelete**: 这表示如果父表中的引用行被删除，将采取的操作。在这里，使用**ForeignKey.CASCADE**，这意味着如果删除**Conversation**实例，所有具有**conversation_id**值引用对话ID的消息也将被删除。'
- en: '**indices**: This is used to create an index on **conversation_id** to speed
    up your queries. An index makes data retrieval faster at the cost of additional
    disk space and slower write speed. An index is particularly useful here because
    we will often perform operations related to a specific conversation, and indexing
    **conversation_id** will make these operations more efficient.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**indices**: 这用于在**conversation_id**上创建索引以加快查询速度。索引以额外的磁盘空间和较慢的写入速度为代价加快数据检索速度。索引在这里特别有用，因为我们经常会执行与特定对话相关的操作，对**conversation_id**进行索引将使这些操作更高效。'
- en: 'Then, we have also added annotations to the properties of the class:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们还添加了注解到类的属性中：
- en: '**@PrimaryKey**: This annotation indicates that the **id** field is the primary
    key for the **Message** table. A primary key uniquely identifies each row in the
    table. We could use here **autoGenerate = true**, which means that this field
    will be automatically filled with an incrementing integer for each new row.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**@PrimaryKey**: 这个注解表示**id**字段是**Message**表的唯一键。主键唯一标识表中的每一行。这里我们可以使用**autoGenerate
    = true**，这意味着这个字段将为每一行新行自动填充一个递增的整数。'
- en: '**@ColumnInfo(name = "column_name")**: This annotation lets you specify a custom
    column name in the database. If not specified, Room will use the variable name
    as the column name.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**@ColumnInfo(name = "column_name")**: 这个注解允许你在数据库中指定自定义列名。如果没有指定，Room将使用变量名作为列名。'
- en: 'Now, let’s create a `Conversation` entity:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个`Conversation`实体：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `Conversation` entity is very simple – we will just store the `Conversation`
    ID and the time of the last message in the conversation.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`Conversation`实体非常简单——我们只需在数据库中存储`Conversation` ID和对话中最后一条消息的时间。'
- en: Now that we have created and defined our entities, it’s time to create DAOs
    in order to obtain and update data.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建并定义了我们的实体，是时候创建DAO以获取和更新数据了。
- en: Creating DAOs
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建DAO
- en: A DAO is an interface that serves as a communication layer between the application
    code and the database. It defines methods for each operation we might perform
    on the entities in our database.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: DAO是一个接口，它作为应用程序代码和数据库之间的通信层。它定义了我们在数据库中的实体可能执行的所有操作的函数。
- en: 'Let’s start with the DAO for the `Message` entity:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`Message`实体的DAO开始：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Breaking down the code, we have the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 分析代码，我们有以下内容：
- en: '**@Dao**: This annotation identifies the interface as a DAO.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**@Dao**：这个注解用于标识接口作为DAO。'
- en: '**@Query**: This annotation is used to specify SQL statements for complex data
    retrieval tasks.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**@Query**：这个注解用于指定复杂数据检索任务的SQL语句。'
- en: '**@Insert**: This annotation is used to define a method that inserts its argument
    into the database. **OnConflictStrategy.REPLACE** means that if a message with
    the same primary key already exists, it will be replaced by a new one.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**@Insert**：这个注解用于定义一个方法，将它的参数插入到数据库中。**OnConflictStrategy.REPLACE**意味着如果已经存在具有相同主键的消息，它将被新的消息替换。'
- en: '**@Delete**: This annotation is used to define a method that deletes its argument
    from the database.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**@Delete**：这个注解用于定义一个方法，从数据库中删除它的参数。'
- en: 'Now, let’s create a DAO for the `Conversation` entity:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为`Conversation`实体创建一个DAO：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The annotations function the same way as they did in `MessageDao`. Here, we’re
    retrieving all conversations ordered by the time of their last message, and we
    have methods for inserting and deleting conversations.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注解在这里的作用与在`MessageDao`中一样。在这里，我们正在按最后一条消息的时间顺序检索所有对话，并且我们有插入和删除对话的方法。
- en: 'We now need to provide these DAOs for other app components so that they can
    be injected. With that in mind, we will create the following module:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要为其他应用组件提供这些DAO，以便它们可以被注入。考虑到这一点，我们将创建以下模块：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As we have previously covered the creation of Hilt modules in the previous
    chapters, we won’t go over all the code again. Instead, here are the key parts
    of the code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在之前的章节中介绍了Hilt模块的创建，我们不会再次遍历所有代码。相反，以下是代码的关键部分：
- en: We are using **@Singleton** to indicate that only a single instance of the object
    should be created and provided as a dependency.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用**@Singleton**来表示应该只创建一个对象实例，并将其作为依赖项提供。
- en: The `Context` we want to use, we can get confused or provide one that is not
    suitable for this situation. Using the `@ApplicationContext` qualifier will assure
    us that the `Context` injected will be the expected one (the `Application Context`,
    in this case).
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们想要使用的`Context`可能会让我们感到困惑或提供一个不适合这种情况的`Context`。使用`@ApplicationContext`限定符将确保注入的`Context`将是预期的（在这种情况下是`Application
    Context`）。
- en: 'Now, as we already did in the previous chapter for the API or WebSocket, we
    are going to create a data source to connect with the database: `LocalMessagesDataSource`.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，就像我们在上一章中为API或WebSocket所做的那样，我们将创建一个数据源来连接数据库：`LocalMessagesDataSource`。
- en: Creating a LocalMessagesDataSource data source
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个LocalMessagesDataSource数据源
- en: We need to create a `LocalMessagesDataSource` data source that will wrap the
    DAO and expose the specific database operations our app needs. This way, if we
    decide to change the database in the future, we will only have to change it here
    (not in the rest of consumers). This class will serve as a DAO at a higher level
    of abstraction, simplifying the API for the rest of our app and making it easier
    to mock the database in tests.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个`LocalMessagesDataSource`数据源，它将封装DAO并暴露我们应用需要的特定数据库操作。这样，如果我们将来决定更改数据库，我们只需在这里更改（而不是在其他消费者中更改）。这个类将在更高层次的抽象中作为DAO，简化我们应用其余部分的API，并使在测试中模拟数据库变得更加容易。
- en: 'In the following code, we are just calling the functions we already defined
    in the DAO:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们只是调用我们在DAO中已经定义的函数：
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As we said before, we will use this data source to wrap the database and provide
    an additional abstraction layer.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说的，我们将使用这个数据源来封装数据库并提供额外的抽象层。
- en: Now, it’s time to combine this local data source with the remote one. This will
    force us to think about a caching strategy.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候将这个本地数据源与远程数据源结合起来。这将迫使我们考虑缓存策略。
- en: Handling two data sources in the MessagesRepository component
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 MessagesRepository 组件中处理两个数据源
- en: Up until now, we only had one data source (the WebSocket one), but we would
    like our users to be able to retrieve their messages even if they have no connection
    for a short time. That’s the reason why we have just created a database and have
    it ready to be populated.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只有一个数据源（WebSocket 数据源），但我们希望用户即使在短时间内没有连接也能检索到他们的消息。这就是我们刚刚创建数据库并使其准备就绪的原因。
- en: As our use case is to provide a fallback for the WebSocket so that the user
    can continue checking their messages, we will follow a strategy where the main
    source of truth will continue being the WebSocket, but we will store a copy of
    the messages in the app database. Also, we don’t want the records of this database
    to grow infinitely, so we are setting a cap of `100` messages per conversation.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的用例是为 WebSocket 提供后备，以便用户可以继续检查他们的消息，我们将遵循一种策略，其中主要的事实来源将继续是 WebSocket，但我们将在应用数据库中存储消息的副本。此外，我们不想让这个数据库的记录无限增长，所以我们为每场对话设置了
    `100` 条消息的上限。
- en: 'The component responsible for combining both data sources is `MessagesRepository`,
    which we already implemented to be connected to `WebsocketDataSource` in the previous
    chapter. Let’s now modify it to include both data sources and to orchestrate the
    data retrieval and local storage:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 负责组合两个数据源的组件是 `MessagesRepository`，我们在上一章中已经实现，使其连接到 `WebsocketDataSource`。现在让我们修改它以包含两个数据源，并协调数据检索和本地存储：
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we will modify the `getMessages()` method to include the logic to store
    the information retrieved from `MessagesSocketDataSource` (remote data source)
    in `DatabaseDataSource` (local data source):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将修改 `getMessages()` 方法，以包含将来自 `MessagesSocketDataSource`（远程数据源）的信息存储到
    `DatabaseDataSource`（本地数据源）的逻辑：
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As can be seen, we have connected to the socket data source, but we have wrapped
    this action in a `try`-`catch` block. So, if everything goes correctly, we will
    store in our database every new message and then emit it in the flow.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如所见，我们已经连接到套接字数据源，但我们把这个动作包裹在一个 `try`-`catch` 块中。所以，如果一切顺利，我们将把每条新消息存储到我们的数据库中，然后将其在流程中发出。
- en: At the same time, we call `manageDatabaseSize()`, which will check and keep
    the size of the database under the limit we have set (100 maximum messages per
    conversation). If the socket fails, we will retrieve messages from the database
    directly.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们调用 `manageDatabaseSize()`，这将检查并保持数据库的大小在我们设定的限制之下（每场对话最多100条消息）。如果套接字失败，我们将直接从数据库中检索消息。
- en: 'Now, we will also modify the `sendMessage` method, where we will also store
    every new message sent:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们还将修改 `sendMessage` 方法，其中我们将存储每条新发送的消息：
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The disconnect will be kept the same as we don’t need to do anything related
    to the new data source:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 断开连接将与之前保持一致，因为我们不需要做任何与新的数据源相关的事情：
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, here is the mechanism that we will implement to keep the size of the
    database under the agreed number of messages per conversation:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是我们将实施的机制，以保持数据库的大小在商定的每场对话消息数量之下：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We will obtain all messages related to the conversation and check if the size
    is more than 100\. Then, we will order them based on their timestamp and remove
    the oldest ones.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将获取与对话相关的所有消息，并检查其大小是否超过100。然后，我们将根据它们的时间戳对它们进行排序，并移除最旧的那些。
- en: Now, we have the Room database integrated into our app. Our last messages will
    be available even if we lose the connection. In the following section, let’s see
    how we can also send a backup of those messages to be stored in the cloud. For
    that, we will use Firebase Storage.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经将 Room 数据库集成到我们的应用中。即使我们失去连接，我们最后的消息也将可用。在下一节中，让我们看看我们如何也将这些消息的备份发送到云端存储。为此，我们将使用
    Firebase 存储。
- en: Getting to know Firebase Storage
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解 Firebase 存储
- en: '**Firebase Storage**, also known as Cloud Storage for Firebase, is a powerful
    object storage service built for Google scale. It enables developers to store
    and retrieve user-generated content, such as photos, videos, or other forms of
    user data. Firebase Storage is backed by **Google Cloud Storage** (**GCS**), making
    it robust and scalable for any size of data, from small text files to large video
    files.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**Firebase 存储**，也称为 Firebase 云存储，是一个为 Google 规模构建的强大对象存储服务。它使开发者能够存储和检索用户生成的内容，如照片、视频或其他形式用户数据。Firebase
    存储由 **Google Cloud Storage**（**GCS**）支持，使其对任何大小的数据都稳健且可扩展，从小型文本文件到大型视频文件。'
- en: 'Here are some of the key features and capabilities of Firebase Storage:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 Firebase 存储的一些关键特性和功能：
- en: '**User-generated content**: Firebase Storage allows your users to upload their
    own content directly from their devices. This could include anything from profile
    pictures to blog posts.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户生成内容**：Firebase Storage允许你的用户直接从他们的设备上传自己的内容。这可能包括从个人资料图片到博客文章的任何内容。'
- en: '**Integration with Firebase and Google Cloud**: Firebase Storage integrates
    smoothly with the rest of the Firebase ecosystem, including Firebase Authentication
    and Firebase Security Rules. It’s also a part of the larger Google Cloud ecosystem,
    which opens up possibilities for using Google Cloud’s advanced features, such
    as Cloud Functions.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与Firebase和Google Cloud的集成**：Firebase Storage与Firebase生态系统的其余部分无缝集成，包括Firebase身份验证和Firebase安全规则。它也是更大Google
    Cloud生态系统的一部分，这为使用Google Cloud的高级功能，如Cloud Functions，提供了可能性。'
- en: '**Security**: Firebase Storage provides robust security features. Using Firebase
    Security Rules, you can control who has access to what data. You can restrict
    access based on a user’s authentication state, identity, and claims, as well as
    data patterns and metadata.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：Firebase Storage提供了强大的安全功能。使用Firebase安全规则，你可以控制谁可以访问哪些数据。你可以根据用户的认证状态、身份和声明、数据模式和元数据来限制访问。'
- en: '**Scalability**: Firebase Storage is designed to handle a large number of uploads,
    downloads, and storage of data. It automatically scales with your user base and
    traffic, meaning you don’t need to worry about capacity planning.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：Firebase Storage被设计用来处理大量的上传、下载和数据存储。它能够根据你的用户基础和流量自动扩展，这意味着你不需要担心容量规划。'
- en: '**Offline capabilities**: Firebase **software development kits** (**SDKs**)
    for Cloud Storage add Google security to file uploads and downloads for your Firebase
    apps, regardless of network quality. You can use it to pause, resume, and cancel
    transfers.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**离线功能**：Firebase Cloud Storage的**软件开发工具包**（**SDKs**）为你的Firebase应用添加了Google安全，无论网络质量如何，都可以用于文件的上传和下载。你可以用它来暂停、恢复和取消传输。'
- en: '**Rich media**: Firebase Storage supports rich media content. This means you
    can use it to store images, audio, video, or even other binary data.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**丰富媒体**：Firebase Storage支持丰富媒体内容。这意味着你可以用它来存储图片、音频、视频，甚至是其他二进制数据。'
- en: '**Strong consistency**: Firebase Storage guarantees strong consistency, meaning
    that once an upload or download is completed, the data is immediately available
    from all Google Cloud Storage locations, and any subsequent reads will return
    the latest updated data.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强一致性**：Firebase Storage保证强一致性，这意味着一旦上传或下载完成，数据将立即从所有Google Cloud Storage位置可用，并且后续的读取将返回最新更新的数据。'
- en: In our context, a messaging application, Firebase Storage could be used to store
    and retrieve message history or backups, shared files, or even multimedia content
    within conversations. This could serve as a reliable backup solution or a means
    of synchronizing chat history across multiple devices. However, you need to ensure
    you handle privacy and security concerns, especially since chat conversations
    can contain sensitive data.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的上下文中，一个消息应用，Firebase Storage可以用来存储和检索消息历史或备份、共享文件，甚至在对话中存储多媒体内容。这可以作为可靠的备份解决方案或跨多个设备同步聊天历史的方法。然而，你需要确保你处理隐私和安全问题，特别是由于聊天对话可能包含敏感数据。
- en: How Firebase Storage works
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何使用Firebase Storage
- en: In Firebase Storage, data is stored as objects within a hierarchical structure.
    The full path to an object in Firebase Storage includes the project ID and the
    object’s location within the storage bucket.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在Firebase Storage中，数据以对象的形式存储在分层结构中。Firebase Storage中对象的完整路径包括项目ID和对象在存储桶中的位置。
- en: Note
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In the context of cloud storage, a **bucket** is a basic container that holds
    data. It’s the primary parent in the hierarchy of data organization. All data
    in cloud storage is stored in buckets. The concept of a bucket is used by many
    cloud storage systems, including GCS, Amazon S3, and Firebase Storage. These systems
    typically allow you to create one or more buckets in your storage space and then
    upload data as objects or files to these buckets. Each bucket has a unique name
    within the cloud storage system, and it contains data objects, or files, each
    of which is identified by a key or a name.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在云存储的上下文中，一个**桶**是一个基本容器，用于存储数据。它是数据组织层次结构中的主要父容器。云存储中的所有数据都存储在桶中。桶的概念被许多云存储系统使用，包括GCS、Amazon
    S3和Firebase Storage。这些系统通常允许你在存储空间中创建一个或多个桶，然后将数据作为对象或文件上传到这些桶中。每个桶在云存储系统中都有一个唯一的名称，它包含数据对象或文件，每个对象或文件都由一个键或名称标识。
- en: The object’s location is defined by a path that you specify. This path is similar
    to a filesystem path and includes both the directories and the filename. For example,
    in the `images/profiles/user123.jpg` path, `images` and `profiles` are directories,
    and `user123.jpg` is the filename.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的位置由您指定的路径定义。此路径类似于文件系统路径，包括目录和文件名。例如，在 `images/profiles/user123.jpg` 路径中，`images`
    和 `profiles` 是目录，而 `user123.jpg` 是文件名。
- en: 'When you upload a file to Firebase Storage, you create a reference to the location
    where you’re going to store the file. This reference is represented by a `StorageReference`
    object, which you create by calling the `child()` method on a reference to your
    Firebase Storage bucket and passing the path as an argument, as in the following
    example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将文件上传到 Firebase 存储时，您创建一个指向您将要存储文件的位置的引用。此引用由一个 `StorageReference` 对象表示，您通过在指向您的
    Firebase 存储 bucket 的引用上调用 `child()` 方法并传递路径作为参数来创建它，如下例所示：
- en: '[PRE16]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, `fileRef` is a reference to the `user123.jpg` file in the profile’s directory
    within the `images` directory.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`fileRef` 是 `images` 目录中 `profiles` 目录内 `user123.jpg` 文件的引用。
- en: You can use this reference to perform various operations, such as uploading
    a file, downloading a file, or getting a URL to the file. Each of these operations
    returns a `Task` object that you can use to monitor the operation’s progress or
    get its result.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用此引用执行各种操作，例如上传文件、下载文件或获取文件的 URL。这些操作中的每一个都返回一个 `Task` 对象，您可以使用它来监控操作进度或获取其结果。
- en: 'The paths in Firebase Storage are flexible, and you can structure them in a
    way that makes sense for your application. For instance, in a messaging application,
    you might store conversation logs in a `chat_logs` directory, with each log’s
    filename being the chat’s ID. The path to a chat log might look like this: `chat_logs/chat123.txt`.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase 存储中的路径是灵活的，您可以根据应用程序的需要对其进行结构化。例如，在消息传递应用程序中，您可能将对话记录存储在 `chat_logs`
    目录中，每个日志的文件名是聊天 ID。聊天日志的路径可能如下所示：`chat_logs/chat123.txt`。
- en: Finally, it’s worth noting that Firebase Storage uses rules to control who can
    read and write to your storage bucket. By default, only authenticated users can
    read and write data. You can customize these rules to suit your application’s
    needs.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，值得注意的是，Firebase 存储使用规则来控制谁可以读取和写入您的存储 bucket。默认情况下，只有经过身份验证的用户可以读取和写入数据。您可以根据应用程序的需求自定义这些规则。
- en: Let’s start setting up Firebase Storage in our project.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始在我们的项目中设置 Firebase 存储。
- en: Setting up Firebase Storage
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 Firebase 存储
- en: 'To start using Firebase Storage, we’ll first need to add the Cloud Storage
    for Firebase Android library to our app. This can be done by adding the following
    line to our module’s `build.gradle` file:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 Firebase 存储，我们首先需要将 Firebase Cloud Storage Android 库添加到我们的应用程序中。这可以通过将以下行添加到我们的模块的
    `build.gradle` 文件中完成：
- en: '[PRE17]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As for the chat messages, one approach would be to save the chat logs as text
    files in Firebase Storage. Each conversation could have its own text file, and
    each message would be a line in that file. So, we are going to create a data source
    to upload those files:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 关于聊天消息，一种方法是将聊天记录保存为 Firebase Storage 中的文本文件。每个对话可以有自己的文本文件，每条消息都是该文件中的一行。因此，我们将创建一个数据源来上传这些文件：
- en: '[PRE18]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we’ve added the Firebase storage instance as a parameter to the constructor,
    allowing it to be injected when the class is instantiated using Hilt. The `uploadFile`
    and `downloadFile` methods suspend the coroutine until the upload or download
    operation completes, using the `await()` extension function.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将 Firebase 存储实例作为构造函数的参数添加，允许在通过 Hilt 实例化类时注入。`uploadFile` 和 `downloadFile`
    方法使用 `await()` 扩展函数挂起协程，直到上传或下载操作完成。
- en: 'To be able to use the Firebase storage instance, we would need to provide the
    `FirebaseStorage` dependency. For that, we will need to create the following module
    so that Hilt is aware of how it can obtain it:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够使用 Firebase 存储实例，我们需要提供 `FirebaseStorage` 依赖项。为此，我们需要创建以下模块，以便 Hilt 了解如何获取它：
- en: '[PRE19]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we need to create those files, to then be uploaded using this data source.
    We are going to do it in a newly created repository: `BackupRepository`.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建这些文件，然后使用此数据源上传。我们将在新创建的存储库中完成此操作：`BackupRepository`。
- en: The `BackupRepository` repository will serve as an intermediary between different
    data sources (such as local databases via DAOs and remote data sources such as
    Firebase Storage) and the rest of the application. It retrieves data from the
    sources, processes it if necessary, and provides it to the calling code in a convenient
    form.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`BackupRepository`仓库将在不同数据源（如通过DAO的本地数据库和远程数据源，如Firebase存储）与应用程序的其余部分之间充当中介。它从源检索数据，如有必要，对其进行处理，并以方便的形式将其提供给调用代码。'
- en: 'Here is the code for this repository:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这是此存储库的代码：
- en: '[PRE20]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As can be seen in the code, it uses `ConversationDao` to fetch all conversations
    in the local database. Each conversation represents a distinct chat thread.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如代码所示，它使用`ConversationDao`从本地数据库中检索所有对话。每个对话代表一个独特的聊天线程。
- en: Then, for each conversation, it fetches the associated messages using `MessageDao`,
    converts the messages to a JSON string using the Gson library, writes this JSON
    string to a temporary file, and then uploads the file to Firebase Storage through
    `StorageDataSource`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对于每个对话，它使用`MessageDao`检索相关的消息，使用Gson库将消息转换为JSON字符串，将此JSON字符串写入临时文件，然后通过`StorageDataSource`将文件上传到Firebase存储。
- en: Once the upload to Firebase Storage is complete, it deletes the local temporary
    file to clean up the storage space on the device.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Firebase存储的上传完成，它将删除本地临时文件以清理设备上的存储空间。
- en: '`BackupRepository` handles all the details of data retrieval, processing, and
    storage. Other parts of the application don’t need to know how the data is stored
    or retrieved. They only interact with `BackupRepository`, which provides a simple
    interface for these operations. This makes the code easier to maintain, understand,
    and test.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`BackupRepository`处理所有数据检索、处理和存储的细节。应用程序的其他部分不需要知道数据是如何存储或检索的。它们只需与`BackupRepository`交互，该仓库为这些操作提供了一个简单的接口。这使得代码更容易维护、理解和测试。'
- en: Finally, we will create `UploadMessagesUseCase`, which will be the use case
    or domain interactor responsible for executing the upload action.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将创建`UploadMessagesUseCase`，它将负责执行上传操作。
- en: Creating UploadMessagesUseCase
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建`UploadMessagesUseCase`
- en: 'The responsibility of `UploadMessagesUseCase` will be to execute the backup
    using `BackupRepository`. As most of the logic is already in the repository, the
    code will be simpler and will look like this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`UploadMessagesUseCase`的责任将是使用`BackupRepository`执行备份。由于大部分逻辑已经在仓库中，代码将更简单，看起来像这样：'
- en: '[PRE21]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, we are ready to retrieve and upload these backups. As it can be a time-
    and resource-consuming task, the idea will be to do it periodically, once per
    week or once per day. This is where `WorkManager` comes in handy.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好检索和上传这些备份。由于这可能是一个耗时且资源消耗的任务，所以想法是定期执行，每周或每天一次。这就是`WorkManager`派上用场的地方。
- en: Scheduling WorkManager to send backups
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安排`WorkManager`发送备份
- en: '`WorkManager` is the recommended tool for tasks that require guaranteed and
    efficient execution.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkManager`是用于需要保证和高效执行的任务的推荐工具。'
- en: '`WorkManager` uses an underlying job dispatching service based on the following
    criteria:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkManager`使用基于以下标准的底层作业调度服务：'
- en: It uses **JobScheduler** for devices with API 23 and above
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用**JobScheduler**为API 23及以上的设备
- en: For devices with API 14 to 22, it uses a combination of **BroadcastReceiver**
    (for system broadcasts) and **AlarmManager**
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于API 14至22的设备，它使用**BroadcastReceiver**（用于系统广播）和**AlarmManager**的组合。
- en: If the app includes the optional **WorkManager** dependency on Firebase **JobDispatcher**
    and Google Play services are available on the device, **WorkManager** uses Firebase
    **JobDispatcher**
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果应用程序包含可选的**WorkManager**依赖项Firebase **JobDispatcher**，并且设备上可用的Google Play服务，**WorkManager**将使用Firebase
    **JobDispatcher**
- en: '`WorkManager` chooses the appropriate way to schedule a background task, depending
    on the device API level and included dependencies. To use `WorkManager`, we need
    first to understand how we can create `Worker` and `WorkRequest` instances.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkManager`根据设备API级别和包含的依赖项选择安排后台任务的最佳方式。要使用`WorkManager`，我们首先需要了解如何创建`Worker`和`WorkRequest`实例。'
- en: Introducing the Worker class
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍`Worker`类
- en: A `Worker` class (or `CoroutineWorker` if you’re using Kotlin coroutines) and
    override the `doWork()` method to define what the task should do.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`Worker`类（如果你使用Kotlin协程，则为`CoroutineWorker`），并重写`doWork()`方法来定义任务应该执行的操作。
- en: The `doWork()` method is where you put the code that needs to be executed in
    the background. This is where you define the operation that needs to be performed,
    such as fetching data from the server, uploading a file, processing an image,
    and so on.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`doWork()` 方法是放置需要在后台执行代码的地方。这是你定义需要执行的操作的地方，例如从服务器获取数据、上传文件、处理图像等等。'
- en: 'Each `Worker` instance is given a maximum of 10 minutes to finish its execution
    and return a `Result` instance. The `Result` instance can be one of three types:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `Worker` 实例有最多10分钟的时间来完成其执行并返回一个 `Result` 实例。`Result` 实例可以是三种类型之一：
- en: '**Result.success()**: Indicates that the work completed successfully. You can
    optionally return a **Data** object that can be used as the output data of this
    work.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Result.success()**: 表示工作成功完成。你可以选择返回一个 **Data** 对象，该对象可以用作此工作的输出数据。'
- en: '**Result.failure()**: Indicates that the work failed. You can optionally return
    a **Data** object that can describe the failure.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Result.failure()**: 表示工作失败。你可以选择返回一个 **Data** 对象来描述失败。'
- en: '**Result.retry()**: Indicates that the work failed and should be tried at another
    time according to its retry policy.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Result.retry()**: 表示工作失败，应该根据其重试策略在另一时间尝试。'
- en: A unique feature of `Worker` is that it’s `Worker` instance is running and the
    app goes to the background, the `Worker` instance can continue to run, whereas
    if the device restarts while the `Worker` instance is running, the task can resume
    when the device is back up. This ensures that the work will be performed under
    the constraints specified when creating a `WorkRequest` instance, even if your
    app process is not around.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`Worker` 的一个独特特性是，当 `Worker` 实例正在运行且应用进入后台时，`Worker` 实例可以继续运行，而如果设备在 `Worker`
    实例运行时重启，任务可以在设备恢复后继续。这确保了即使在你的应用进程不存在的情况下，工作也会在创建 `WorkRequest` 实例时指定的约束下执行。'
- en: 'Here is an example of a basic `Worker` class:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个基本的 `Worker` 类的示例：
- en: '[PRE22]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the example, we extend the `Worker` class and override the `doWork()` method
    to specify the task to be performed. In this case, we are just returning the result
    as successful, but the code to do the actual work would be where the `// Code
    to execute in the background` comment is placed.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我们扩展了 `Worker` 类并重写了 `doWork()` 方法来指定要执行的任务。在这种情况下，我们只是返回成功的结果，但实际工作的代码将放在
    `// Code to execute in the background` 注释所在的位置。
- en: 'To make our `Worker` instances work, we need another component: `WorkRequest`.
    Let’s see how we can configure and use it.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要使我们的 `Worker` 实例工作，我们需要另一个组件：`WorkRequest`。让我们看看我们如何配置和使用它。
- en: Configuring the WorkRequest component
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 WorkRequest 组件
- en: '`WorkRequest` is the class that defines an individual unit of work. It encapsulates
    your `Worker` class, along with any constraints that must be satisfied for the
    work to run and any input data it needs.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkRequest` 是一个定义单个工作单元的类。它封装了你的 `Worker` 类，以及工作运行必须满足的任何约束以及它需要的任何输入数据。'
- en: 'There are two concrete implementations of `WorkRequest` that you can use:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种具体的 `WorkRequest` 实现你可以使用：
- en: '**OneTimeWorkRequest**: As the name suggests, this represents a one-off job.
    It will only be executed once.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OneTimeWorkRequest**: 如其名所示，这代表一个一次性作业。它只会执行一次。'
- en: '**PeriodicWorkRequest**: This is used for repeating jobs that run periodically.
    The minimum repeat interval that can be defined is 15 minutes. This constraint
    is discussed further in the official documentation: [https://developer.android.com/reference/androidx/work/PeriodicWorkRequest](https://developer.android.com/reference/androidx/work/PeriodicWorkRequest).'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PeriodicWorkRequest**: 这用于执行周期性任务的重复作业。可以定义的最小重复间隔是15分钟。这个限制在官方文档中有进一步的讨论：[https://developer.android.com/reference/androidx/work/PeriodicWorkRequest](https://developer.android.com/reference/androidx/work/PeriodicWorkRequest).'
- en: '`WorkRequest` has several options for setting conditions for the execution
    of work and for scheduling multiple pieces of work to run in a particular order:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkRequest` 有几个选项可以设置工作执行的条件以及安排多个工作按特定顺序运行：'
- en: '**Constraints**: A **WorkRequest** instance can have a **Constraints** object
    set on it, which allows you to specify conditions that must be met for the work
    to be eligible to run. For example, you might require that the device is idle
    or charging, or that it has a certain type of network connectivity. We will learn
    about these conditions in detail in a few paragraphs.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**约束**：**WorkRequest**实例可以设置**Constraints**对象，这允许您指定工作必须满足的条件才能有资格运行。例如，您可能需要设备处于空闲或充电状态，或者具有某种类型的网络连接。我们将在接下来的几段中详细了解这些条件。'
- en: '**Input data**: You can attach input data to a **WorkRequest** instance using
    the **setInputData()** method, providing your **Worker** instance with all the
    information it needs to do its work.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入数据**：您可以使用**setInputData()**方法将输入数据附加到**WorkRequest**实例，为您的**Worker**实例提供完成工作所需的所有信息。'
- en: '**Backoff criteria**: You can set backoff criteria for the **WorkRequest**
    instance to control retry timing when the work fails.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回退标准**：您可以设置**WorkRequest**实例的回退标准，以控制工作失败时的重试时间。'
- en: '**Tags**: You can also add tags to your **WorkRequest** instance, which will
    make it easier to track, observe, or cancel specific groups of work.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标签**：您还可以向您的**WorkRequest**实例添加标签，这将使跟踪、观察或取消特定工作组的任务变得更加容易。'
- en: '**Chaining work**: **WorkManager** allows you to create dependent chains of
    work. This means that you can ensure certain pieces of work are executed in a
    certain order. You can create complex chains that run a series of **WorkRequest**
    objects in a specific order.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作链式化**：**WorkManager**允许您创建依赖的工作链。这意味着您可以确保某些工作以特定的顺序执行。您可以创建复杂的链，以特定的顺序运行一系列**WorkRequest**对象。'
- en: '`WorkManager` offers several types of constraints that you can set on a `WorkRequest`
    object to specify when your task should run. This is done using the `Constraints.Builder`
    class. Here are the available constraints you can set:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkManager`提供了几种类型的约束，您可以在`WorkRequest`对象上设置这些约束，以指定任务应在何时运行。这是通过使用`Constraints.Builder`类来完成的。以下是您可以设置的可用约束：'
- en: '**Network type** (**setRequiredNetworkType**): This constraint specifies the
    type of network that must be available for the work to run. Options include **NetworkType.NOT_REQUIRED**,
    **NetworkType.CONNECTED**, **NetworkType.UNMETERED**, **NetworkType.NOT_ROAMING**,
    and **NetworkType.METERED**.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络类型**（**setRequiredNetworkType**）：此约束指定必须可用的网络类型，以便工作可以运行。选项包括**NetworkType.NOT_REQUIRED**、**NetworkType.CONNECTED**、**NetworkType.UNMETERED**、**NetworkType.NOT_ROAMING**和**NetworkType.METERED**。'
- en: '**Battery not low** (**setRequiresBatteryNotLow**): If this constraint is set
    to **true**, the work will only run when the battery isn’t low.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电池电量不高**（**setRequiresBatteryNotLow**）：如果此约束设置为**true**，则工作仅在电池电量不高时运行。'
- en: '**Device idle** (**setRequiresDeviceIdle**): If this constraint is set to **true**,
    the work will only run when the device is in idle mode. This is usually when the
    user hasn’t interacted with the device for a period of time.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设备空闲**（**setRequiresDeviceIdle**）：如果此约束设置为**true**，则工作仅在设备处于空闲模式时运行。这通常是在用户一段时间内未与设备交互时。'
- en: '**Storage not low** (**setRequiresStorageNotLow**): If set to **true**, the
    work will only run when the storage isn’t low.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储空间不高**（**setRequiresStorageNotLow**）：如果设置为**true**，则工作仅在存储空间不高时运行。'
- en: '**Device charging** (**setRequiresCharging**): If set to **true**, the work
    will only run when the device is charging.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设备充电**（**setRequiresCharging**）：如果设置为**true**，则工作仅在设备充电时运行。'
- en: 'Here is an example of how we can configure a `WorkRequest` instance:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个配置`WorkRequest`实例的示例：
- en: '[PRE23]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this example, `MyWorker` will only run when the device is charging, connected
    to a network, and the battery level is not low. It will also have a tag, which
    will allow us to identify it easily.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`MyWorker`仅在设备充电、连接到网络且电池电量不高时运行。它还将有一个标签，这将使我们能够轻松识别它。
- en: 'Here is a diagram with the flow followed for the `Worker` and `WorkRequest`
    instances to be executed:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个流程图，展示了执行`Worker`和`WorkRequest`实例时遵循的流程：
- en: '![Figure 3.3: Diagram of WorkManager flow to execute a WorkRequest instance](img/B19443_03_003.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3：执行WorkRequest实例的WorkManager流程图](img/B19443_03_003.jpg)'
- en: 'Figure 3.3: Diagram of WorkManager flow to execute a WorkRequest instance'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3：执行WorkRequest实例的WorkManager流程图
- en: We now have the tools to build our own `Worker` instance and configure the `WorkRequest`
    instance to retrieve and upload the backup. So, let’s actually create them.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了构建自己的`Worker`实例和配置`WorkRequest`实例以检索和上传备份的工具。那么，让我们实际创建它们。
- en: Creating our Worker instance
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的Worker实例
- en: 'First, to support the `WorkManager` API, we need to include the related dependencies
    in our code:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了支持`WorkManager` API，我们需要在我们的代码中包含相关的依赖项：
- en: '[PRE24]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As we have seen before, the `Worker` class will execute the task that can run
    in the background even when the app is not being used. In other words, it’s a
    unit of work that can be scheduled to run under certain conditions. In our case,
    we have just created the logic for that (in `UploadMessagesUseCase`), so our `Worker`
    class will need to have access to that class.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，`Worker`类将在应用未被使用时执行后台可运行的任务。换句话说，它是一个可以在特定条件下安排运行的工作单元。在我们的案例中，我们刚刚创建了相应的逻辑（在`UploadMessagesUseCase`中），因此我们的`Worker`类需要访问这个类。
- en: That’s the reason we will start adding `HiltWorker` is an annotation provided
    by Hilt’s `androidx.hilt` extension library. This annotation tells Hilt that it
    should create an injectable Worker instance (that is, Hilt should manage the dependencies
    of this `Worker` instance).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是为什么我们将开始添加`HiltWorker`，这是由Hilt的`androidx.hilt`扩展库提供的注解。这个注解告诉Hilt它应该创建一个可注入的`Worker`实例（即，Hilt应该管理这个`Worker`实例的依赖项）。
- en: 'Here’s the complete code for our `Worker` class:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们`Worker`类的完整代码：
- en: '[PRE25]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We are also using a new annotation: `AssistedInject`. Now, `AssistedInject`
    is a Dagger Hilt feature that helps with scenarios where you need to inject some
    dependencies but also need to provide some arguments at runtime. Here, the `appContext`
    and `workerParams` arguments to the constructor are provided at runtime (when
    the `Worker` instance is created by `WorkManager`), while `uploadMessagesUseCase`
    is a dependency that should be injected.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了一个新的注解：`AssistedInject`。现在，`AssistedInject`是Dagger Hilt的一个特性，它有助于处理需要注入一些依赖项但同时在运行时还需要提供一些参数的场景。在这里，构造函数的`appContext`和`workerParams`参数在运行时提供（当`Worker`实例由`WorkManager`创建时），而`uploadMessagesUseCase`是一个应该被注入的依赖项。
- en: The `doWork()` function is where the work that this `Worker` instance should
    perform is defined. This function is a suspend function and runs within a coroutine
    scope. This means it can perform long-running operations such as network requests
    or database operations without blocking the main thread.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`doWork()`函数是定义这个`Worker`实例应该执行的工作的地方。这个函数是一个挂起函数，并在协程作用域内运行。这意味着它可以执行长时间运行的操作，如网络请求或数据库操作，而不会阻塞主线程。'
- en: In `doWork()`, `uploadMessagesUseCase.execute()` is called to perform the actual
    work of uploading messages. If this operation is successful, `Result.success()`
    is returned. If an `Exception` error is thrown, `Result.retry()` is returned if
    `runAttemptCount` is less than `MAX_RETRIES`, which means the work should be retried.
    If `runAttemptCount` equals or exceeds `MAX_RETRIES`, `Result.failure()` is returned,
    which means the work should not be retried.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在`doWork()`中，调用`uploadMessagesUseCase.execute()`来执行上传消息的实际工作。如果此操作成功，则返回`Result.success()`。如果抛出`Exception`错误，并且`runAttemptCount`小于`MAX_RETRIES`，则返回`Result.retry()`，这意味着应该重试工作。如果`runAttemptCount`等于或超过`MAX_RETRIES`，则返回`Result.failure()`，这意味着不应该重试工作。
- en: As we want it to only retry three times, we are using `runAttemptCount`, which
    is a property provided by `ListenableWorker` (the superclass of `CoroutineWorker`)
    that keeps track of how many times the work has been attempted.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望它只重试三次，我们使用了`runAttemptCount`，这是由`ListenableWorker`（`CoroutineWorker`的父类）提供的属性，它跟踪工作尝试了多少次。
- en: Finally, `MAX_RETRIES` is a constant that defines the maximum number of retries.
    It is set to `3` in this example.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`MAX_RETRIES`是一个定义最大重试次数的常量。在这个例子中，它被设置为`3`。
- en: To summarize, this `Worker` instance uploads messages by calling `uploadMessagesUseCase.execute()`,
    and it can retry the operation up to three times in case of failure. The actual
    dependencies of this `Worker` instance (`UploadMessagesUseCase`) are provided
    via `WorkRequest` class.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，这个`Worker`实例通过调用`uploadMessagesUseCase.execute()`来上传消息，并且在失败的情况下可以重试操作最多三次。这个`Worker`实例的实际依赖项（`UploadMessagesUseCase`）是通过`WorkRequest`类提供的。
- en: Setting up the WorkRequest class
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置`WorkRequest`类
- en: 'In the case of the `WorkRequest` class, we will have to think about how frequently
    we want our messages to be backed up; for example, we can do a backup once per
    week. Also, we are going to configure the `WorkRequest` class to be only called
    when the user has a Wi-Fi connection. Here is how we do it:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在`WorkRequest`类的情况下，我们需要考虑我们希望消息备份的频率；例如，我们可以每周备份一次。此外，我们将配置`WorkRequest`类，使其仅在用户有Wi-Fi连接时被调用。以下是我们的做法：
- en: '[PRE26]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We use `PeriodicWorkRequestBuilder` to create a `WorkRequest` instance that
    runs `UploadMessagesWorker` once every week. The `WorkRequest` instance has a
    constraint that requires an unmetered network connection (Wi-Fi). It also specifies
    a linear backoff policy for retries – this means that each retry attempt is delayed
    by a fixed amount of time, increasing linearly with each subsequent retry.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`PeriodicWorkRequestBuilder`创建一个`WorkRequest`实例，该实例每周运行一次`UploadMessagesWorker`。`WorkRequest`实例有一个约束条件，要求有一个非计费的网络连接（Wi-Fi）。它还指定了一个线性退避策略用于重试——这意味着每次重试尝试都会延迟固定的时间，并且随着后续重试的进行而线性增加。
- en: The `enqueue()` method schedules the `WorkRequest` instance to run. If the constraints
    are met and there’s no other work ahead of it in the queue, it will start running
    immediately. Otherwise, it will wait until the constraints are met and it’s the
    `WorkRequest` instance’s turn in the queue.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`enqueue()`方法安排`WorkRequest`实例运行。如果满足约束条件，并且队列中没有其他工作在其前面，它将立即开始运行。否则，它将等待直到满足约束条件，并且它是队列中的`WorkRequest`实例的轮次。'
- en: Please note that due to OS restrictions, a `PeriodicWorkRequest` instance may
    not run exactly when the period elapses; it may have some delay, but it will run
    at least once within that time period.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于操作系统限制，`PeriodicWorkRequest`实例可能不会在周期结束时正好运行；它可能会有一些延迟，但至少会在该时间段内运行一次。
- en: 'We can call this code and enqueue the `WorkRequest` instance from any place
    in our app, but to ensure it gets scheduled, the most convenient place is when
    we start up the app, in the `WhatsPacktApplication.onCreate` method:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从应用中的任何地方调用此代码并将`WorkRequest`实例入队，但要确保它被安排，最方便的地方是在我们启动应用时，在`WhatsPacktApplication.onCreate`方法中：
- en: '[PRE27]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: With all this, we would have our app ready to periodically back up messages,
    and our work well could have finished here. However, to explore a different approach,
    let’s see what happens if we need to integrate another storage provider – for
    example, Amazon S3.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些准备就绪之后，我们的应用可以定期备份消息，我们的工作可能就已经完成了。然而，为了探索不同的方法，让我们看看如果我们需要集成另一个存储提供商会发生什么——例如，Amazon
    S3。
- en: Using Amazon S3 for storage
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Amazon S3进行存储
- en: '**Amazon S3** is a scalable, high-speed, web-based cloud storage service designed
    for online backup and archiving of data and applications on **Amazon Web Services**
    (**AWS**). It’s a well-known alternative to Firebase Storage.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**Amazon S3**是一个可扩展、高速、基于网络的云存储服务，旨在为**Amazon Web Services**（**AWS**）上的数据和应用提供在线备份和存档。它是Firebase
    Storage的一个知名替代品。'
- en: 'Here’s a brief overview of some key features and capabilities of Amazon S3:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是Amazon S3一些关键功能和能力的简要概述：
- en: '**Storage**: Amazon S3 can store any amount of data and access it from anywhere
    on the web. It provides virtually limitless storage.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储**：Amazon S3可以存储任何数量的数据，并可以从网络上的任何地方访问它。它提供了几乎无限的存储空间。'
- en: '**Durability and availability**: Amazon S3 is designed for 99.999999999% (11
    9s) of durability, and it stores redundant copies of data across multiple geographically
    separated data centers. It also provides 99.99% availability of objects over a
    given year.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久性和可用性**：Amazon S3被设计为99.999999999%（11个9）的持久性，并在多个地理上分离的数据中心存储数据的冗余副本。它还提供在给定一年内的99.99%对象可用性。'
- en: '**Security**: Amazon S3 provides advanced security features such as encryption
    for data at rest and in transit, and fine-grained access controls to resources
    using AWS **Identity and Access Management** (**IAM**), **access control lists**
    (**ACLs**), and bucket policies.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：Amazon S3提供了高级安全功能，如静态数据和传输中的加密，以及使用AWS **身份和访问管理**（**IAM**）、**访问控制列表**（**ACLs**）和存储桶策略对资源的细粒度访问控制。'
- en: '**Scalability**: Amazon S3 is designed to scale storage, requests, and users
    to support an unlimited number of web-scale applications.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：Amazon S3被设计用于扩展存储、请求和用户，以支持无限数量的网络规模应用程序。'
- en: '**Performance**: AWS storage makes sure that when you add or delete files,
    you can immediately read the latest version of your files. If you overwrite a
    file or delete it, there might be a short delay before these changes are fully
    updated everywhere.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：AWS存储确保在您添加或删除文件时，您可以立即读取文件的最新版本。如果您覆盖文件或删除它，这些更改可能需要一些时间才能在所有地方完全更新。'
- en: '**Integration**: Amazon S3 integrates well with other AWS services, such as
    AWS CloudTrail for logging and monitoring, Amazon CloudFront for content delivery,
    AWS Lambda for serverless compute, and many more.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成**：Amazon S3与其他AWS服务很好地集成，例如AWS CloudTrail用于日志记录和监控、Amazon CloudFront用于内容分发、AWS
    Lambda用于无服务器计算等。'
- en: '**Management features**: S3 provides functionalities for management tasks such
    as organizing data and configuring finely-tuned access controls to meet specific
    business, organizational, and compliance requirements.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理功能**：S3提供了用于管理任务的功能，例如组织数据和配置精细的访问控制以满足特定的业务、组织和合规性要求。'
- en: '**Data transfer**: S3 Transfer Acceleration enables fast, easy, and secure
    transfers of files over long distances between your client and your Amazon S3
    bucket.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据传输**：S3传输加速允许在您的客户端和Amazon S3存储桶之间快速、轻松且安全地在长距离上传输文件。'
- en: '**Storage classes**: Amazon S3 provides several storage classes for different
    types of data storage needs, such as S3 Standard for general-purpose storage of
    frequently accessed data, S3 Intelligent-Tiering for data with unknown or changing
    access patterns, S3 Standard-IA for long-lived but infrequently accessed data,
    and S3 Glacier for long-term archive and digital preservation.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储类别**：Amazon S3为不同类型的存储需求提供了几种存储类别，例如S3 Standard用于频繁访问数据的通用存储，S3 Intelligent-Tiering用于访问模式未知或变化的存储，S3
    Standard-IA用于长期但很少访问的数据，以及S3 Glacier用于长期归档和数字保存。'
- en: '**Query-in-place functionality**: S3 Select enables applications to retrieve
    only a subset of data from an object by using simple SQL expressions.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地查询功能**：S3 Select允许应用程序通过使用简单的SQL表达式从对象中检索仅部分数据。'
- en: These features make Amazon S3 a robust and versatile choice for various use
    cases, ranging from web applications to backup and restore, archive, enterprise
    applications, IoT devices, and big data analytics.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能使Amazon S3成为各种用例的强大且灵活的选择，从Web应用程序到备份和恢复、归档、企业应用程序、物联网设备和大数据分析。
- en: To implement our storage solution based on Amazon S3, we first need to integrate
    the AWS SDK into our app.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现基于Amazon S3的存储解决方案，我们首先需要将AWS SDK集成到我们的应用程序中。
- en: Integrating the AWS S3 SDK
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成AWS S3 SDK
- en: 'We can integrate the AWS S3 SDK into our Android project by adding the following
    dependencies in our `build.gradle` file:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在`build.gradle`文件中添加以下依赖项将AWS S3 SDK集成到我们的Android项目中：
- en: '[PRE28]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We have added here dependencies for the AWS SDK and the dependency needed to
    use Amazon Cognito.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里添加了AWS SDK和用于使用Amazon Cognito的依赖项。
- en: We’ll also need to provide our AWS credentials (access key ID and secret access
    key) to the SDK. For mobile applications, it is recommended to use Amazon Cognito
    for credential management.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要向SDK提供我们的AWS凭证（访问密钥ID和秘密访问密钥）。对于移动应用程序，建议使用Amazon Cognito进行凭证管理。
- en: Setting up Amazon Cognito
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置Amazon Cognito
- en: '**Amazon Cognito** is a service that provides user sign-up and sign-in services,
    as well as access control for mobile and web applications. When you use Amazon
    Cognito for your user pool, you have the option to secure your data in AWS services
    (such as Amazon S3 for file storage) without having to embed AWS keys in your
    application code, which is a significant security risk.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**Amazon Cognito**是一项提供用户注册和登录服务以及移动和Web应用程序访问控制的服务。当您为用户池使用Amazon Cognito时，您可以选择在AWS服务（如用于文件存储的Amazon
    S3）中安全地存储您的数据，而无需在应用程序代码中嵌入AWS密钥，这是一个重大的安全风险。'
- en: 'Here are the instructions to set up Amazon Cognito in our Android application:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是在我们的Android应用程序中设置Amazon Cognito的说明：
- en: 'First, go to the Amazon Cognito console: [https://console.aws.amazon.com/cognito/home](https://console.aws.amazon.com/cognito/home).'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，转到Amazon Cognito控制台：[https://console.aws.amazon.com/cognito/home](https://console.aws.amazon.com/cognito/home)。
- en: From there, click **Identity Pools**, then **Create new** **identity pool**.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从那里，点击**身份池**，然后点击**创建新的** **身份池**。
- en: Check **Guest Access** under the **Authentication** section, and click **Next**.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**认证**部分下检查**访客访问**，然后点击**下一步**。
- en: Select **Create a New IAM Role**, create a name for it, and click **Next**.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**创建新的IAM角色**，为其创建一个名称，然后点击**下一步**。
- en: Then create a new name for the identity pool and click **Next**.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后为身份池创建一个新的名称并点击**下一步**。
- en: 'Review the summary (as in *Figure 3**.4*), then click **Create** **identity
    pool**:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看摘要（如*图3.4*），然后点击**创建** **身份池**：
- en: '![Figure 3.4: New identity pool configuration](img/B19443_03_004.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4：新的身份池配置](img/B19443_03_004.jpg)'
- en: 'Figure 3.4: New identity pool configuration'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4：新的身份池配置
- en: Note
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Here, we are enabling access to unauthenticated identities. You also have the
    option to give access only to authenticated identities, but note that you will
    have to create every user in Amazon Cognito. Nevertheless, this approach is more
    secure than using the S3 SDK to store keys in our app code.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在启用对未认证身份的访问。您还可以选择仅对认证身份提供访问权限，但请注意，您将不得不在 Amazon Cognito 中创建每个用户。尽管如此，这种方法比使用
    S3 SDK 在我们的应用代码中存储密钥更安全。
- en: 'Next, in our app, we’ll need to obtain the AWS credentials provider. For that,
    we will initialize **CognitoCachingCredentialsProvider** with our **IdentityPoolId**
    class, in the region we configured it:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在我们的应用中，我们需要获取 AWS 凭证提供者。为此，我们将使用我们的 **IdentityPoolId** 类初始化 **CognitoCachingCredentialsProvider**，在配置的区域：
- en: '[PRE29]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we can use the credentials provider instance while creating a client for
    the AWS service. For example, to use it with Amazon S3, use this code:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在创建 AWS 服务客户端时使用凭证提供者实例。例如，要与其配合使用 Amazon S3，请使用以下代码：
- en: '[PRE30]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now, it is time to create a new storage provider.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候创建一个新的存储提供者了。
- en: Creating an AWS S3 Storage provider and integrating it into our code
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 AWS S3 存储提供者并将其集成到我们的代码中
- en: 'Now, we need to do the same thing we did for Firebase Storage but with the
    AWS SDK: create a provider. This provider will be `AWSS3Provider` and will be
    used to handle the upload of files to AWS S3\. It will take a `Context` object
    and a `CognitoCachingCredentialsProvider` object as constructor parameters.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要做与 Firebase Storage 相同的事情，但使用 AWS SDK：创建一个提供者。这个提供者将是 `AWSS3Provider`，并用于处理文件上传到
    AWS S3。它将接受一个 `Context` 对象和一个 `CognitoCachingCredentialsProvider` 对象作为构造函数参数。
- en: 'This is how we can implement it:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们可以这样实现的方式：
- en: '[PRE31]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `uploadFile` function is a suspending function, meaning it can be called
    from any coroutine scope. The `withContext(Dispatchers.IO)` function is used to
    switch the coroutine context to the I/O dispatcher, which is optimized for I/O-related
    tasks, such as network calls or disk operations.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`uploadFile` 函数是一个挂起函数，这意味着它可以从任何协程作用域中调用。`withContext(Dispatchers.IO)` 函数用于将协程上下文切换到
    I/O 分派器，该分派器针对 I/O 相关任务进行了优化，例如网络调用或磁盘操作。'
- en: Let’s delve into the `uploadFile` function, which is the core of this class.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨 `uploadFile` 函数，这是这个类的核心。
- en: The `TransferUtility` class simplifies the process of uploading and downloading
    files to/from Amazon S3\. Here, we’re building a `TransferUtility` instance, providing
    it with the Android context, AWS configuration, and an `AmazonS3Client` instance
    initialized with the provided `CognitoCachingCredentialsProvider` class.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`TransferUtility` 类简化了将文件上传到/从 Amazon S3 的过程。在这里，我们正在构建一个 `TransferUtility`
    实例，向其提供 Android 上下文、AWS 配置以及使用提供的 `CognitoCachingCredentialsProvider` 类初始化的 `AmazonS3Client`
    实例。'
- en: The `transferUtility.upload()` method is used to upload a file to the specified
    bucket in S3\. We provide the name of the bucket (`bucketName`), the key under
    which to store the new object (`objectKey`), and the file we want to upload (`File(filePath)`).
    This function returns a `UploadObserver` instance.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `transferUtility.upload()` 方法将文件上传到 S3 中指定的存储桶。我们提供存储桶的名称（`bucketName`）、存储新对象的键（`objectKey`）以及我们想要上传的文件（`File(filePath)`）。此函数返回一个
    `UploadObserver` 实例。
- en: '`UploadObserver` is used to monitor the progress of the upload.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`UploadObserver` 用于监控上传进度。'
- en: We attach`TransferListener` to the observer to get callbacks when the upload
    state changes, the upload makes progress, or an error occurs.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `TransferListener`附加到观察者，以便在上传状态改变、上传进度或发生错误时获取回调。
- en: The `onStateChanged()` method is called when the state of the transfer changes.
    If the state is `TransferState.COMPLETED`, it means the file has been uploaded
    successfully.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当传输状态改变时，会调用 `onStateChanged()` 方法。如果状态是 `TransferState.COMPLETED`，这意味着文件已成功上传。
- en: The `onProgressChanged()` method is called when more bytes have been transferred.
    Here, we calculate the progress as a percentage and log it.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 当传输的字节数增加时，会调用 `onProgressChanged()` 方法。在这里，我们计算进度作为百分比并记录它。
- en: The `onError()` method is called if an error occurs during the transfer. We
    will throw an error when it happens, to be handled by the consumers or this provider.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在传输过程中发生错误，将调用 `onError()` 方法。当发生这种情况时，我们将抛出一个错误，由消费者或此提供者处理。
- en: The `uploadFile` function is called from within a coroutine, and since the actual
    upload operation is a network I/O operation, it’s wrapped in `withContext(Dispatchers.IO)`.
    This ensures the operation doesn’t block the main thread, as the I/O dispatcher
    uses a separate thread pool that’s optimized for disk and network I/O.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`uploadFile` 函数是在协程内部调用的，由于实际的上传操作是一个网络 I/O 操作，因此它被包装在 `withContext(Dispatchers.IO)`
    中。这确保了操作不会阻塞主线程，因为 I/O 分派器使用一个针对磁盘和网络 I/O 优化的单独线程池。'
- en: Now, we will need to create a data source to connect our `BackupRepository`
    instance to this new provider. The best way to do it is by implementing `IStorageDataSource,`
    a common interface for both data sources. This way, you’re able to swap the underlying
    implementation (Firebase Storage, AWS S3, and so on) without changing the rest
    of your code. (This is an application of the **Dependency Inversion Principle**
    (**DIP**), one of the SOLID principles of **object-oriented** (**OO**) design,
    which helps make your code more flexible and easier to maintain.)
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个数据源来将我们的 `BackupRepository` 实例连接到这个新的提供者。最佳做法是通过实现 `IStorageDataSource`，这是一个适用于两个数据源的通用接口。这样，你就可以在不改变其余代码的情况下交换底层实现（Firebase
    Storage、AWS S3 等）。（这是 **依赖倒置原则**（**DIP**）的应用，它是 **面向对象**（**OO**）设计的 SOLID 原则之一，有助于使你的代码更加灵活且易于维护。）
- en: 'This is how we will implement `S3StorageDataSource`:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们实现 `S3StorageDataSource` 的方法：
- en: '[PRE32]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this code, we are implementing the `uploadFile` function calling the `awsProvider.uploadFile`
    function, which will upload the file to the bucket with the `our-bucket-name`
    name.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们正在实现 `uploadFile` 函数，调用 `awsProvider.uploadFile` 函数，该函数将文件上传到名为 `our-bucket-name`
    的存储桶。
- en: 'This new `S3StorageDataSource` class can be provided via Hilt in a similar
    way to the previous `FirebaseStorageDataSource` class:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的 `S3StorageDataSource` 类可以通过 Hilt 以类似的方式提供，就像之前的 `FirebaseStorageDataSource`
    类一样：
- en: '[PRE33]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, we create a `@Module` annotation that includes a `@Provides` or `@Binds`
    method for `IStorageDataSource`, and Hilt will take care of injecting the right
    implementation based on your configuration. If you want to switch from Firebase
    Storage to AWS S3, you’d modify this module to provide `S3StorageDataSource` instead
    of `FirebaseStorageDataSource`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个 `@Module` 注解，它包括一个 `@Provides` 或 `@Binds` 方法用于 `IStorageDataSource`，Hilt
    将根据你的配置注入正确的实现。如果你想从 Firebase Storage 切换到 AWS S3，你需要修改这个模块以提供 `S3StorageDataSource`
    而不是 `FirebaseStorageDataSource`。
- en: 'Finally, we need to integrate it into our `BackupRepository` class. It is as
    easy as replacing the `StorageDataSource` dependency for the `IStorageDataSource`
    dependency:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将其集成到我们的 `BackupRepository` 类中。这就像替换 `StorageDataSource` 依赖项为 `IStorageDataSource`
    依赖项一样简单：
- en: '[PRE34]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: And that’s all. Depending on what we are providing in our Hilt module to satisfy
    the `IStorageDataSource` dependency, it will use the Firebase Storage one or the
    AWS S3 one.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。根据我们在 Hilt 模块中提供的什么来满足 `IStorageDataSource` 依赖项，它将使用 Firebase Storage 或
    AWS S3。
- en: And with this change, we finish this chapter and also our work in the WhatsPackt
    application!
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 随着这个变化，我们完成了本章，也完成了在 WhatsPackt 应用中的工作！
- en: '![Figure 3.5: WhatsPackt’s final appearance](img/B19443_03_005.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5：WhatsPackt 的最终外观](img/B19443_03_005.jpg)'
- en: 'Figure 3.5: WhatsPackt’s final appearance'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5：WhatsPackt 的最终外观
- en: Summary
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we centered our efforts on creating a good offline experience
    for our user (storing the messages in a local database using Room) and providing
    a mechanism to store the messages backup, in case something fails. We have also
    learned how to use different providers to store our files in the cloud using Firebase
    Firestore and AWS S3.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们致力于为我们的用户创建良好的离线体验（使用 Room 在本地数据库中存储消息）并提供一种机制来存储消息备份，以防出现故障。我们还学习了如何使用不同的提供者将我们的文件存储在云端，使用
    Firebase Firestore 和 AWS S3。
- en: 'Now, we have finished our work in the WhatsPackt app. In the next chapter,
    we will start building a new app: Packtagram. It will be an app to share photos
    and videos with our friends that will provide new and different challenges when
    creating it, such as capturing video. These are challenges that we will learn
    to overcome.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经完成了在 WhatsPackt 应用中的工作。在下一章中，我们将开始构建一个新的应用：Packtagram。它将是一个与朋友分享照片和视频的应用，在创建过程中将提供新的和不同的挑战，例如捕获视频。这些是我们将学会克服的挑战。
