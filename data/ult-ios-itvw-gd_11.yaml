- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: SwiftUI and Declarative Programming
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SwiftUI和声明式编程
- en: The previous chapter was highly intensive. We discussed the most critical framework
    in iOS development besides **Foundation**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 前一章内容非常密集。我们讨论了iOS开发中最关键的框架，除了**Foundation**之外。
- en: This chapter is more than just discussing a framework – we will discuss an idea,
    a **programming paradigm**.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不仅仅讨论一个框架——我们将讨论一个理念，一个**编程范式**。
- en: We can’t approach a job interview today in iOS without a basic knowledge of
    declarative programming, a topic that was no more than “nice to have” a few years
    ago.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 现在要在iOS领域参加面试，如果没有对声明式编程的基本了解，那几乎是不可能的，而几年前这个话题还只是“锦上添花”。
- en: If you have gaps in your knowledge or limited experience, read this chapter
    thoroughly to fill that knowledge gap before you start your interview.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知识体系中有空白或经验有限，在开始面试之前，请仔细阅读本章，以填补这些知识空白。
- en: 'This chapter covers these exciting topics in declarative programming:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了声明式编程中的这些令人兴奋的话题：
- en: Exploring a new era in the development
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索开发新时代
- en: Understanding declarative programming
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解声明式编程
- en: Learning states and observable objects
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习状态和可观察对象
- en: Navigating SwiftUI views
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航SwiftUI视图
- en: Expertise with the SwiftUI life cycle
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精通SwiftUI的生命周期
- en: Expertise with Combine
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精通Combine
- en: Let’s start with a brief background about declarative programming.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从声明式编程的简要背景开始。
- en: Entering a new era of development
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进入一个新开发时代
- en: SwiftUI and Combine are not only interesting frameworks but also symbolize a
    new direction that Apple is leading us toward. This direction is not disconnected
    from the current industry standards, as we can observe from the presence of **React**,
    **Flutter**, and RxJava in the everyday work of many developers.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: SwiftUI和Combine不仅是有趣的框架，而且象征着苹果引领我们走向的新方向。这个方向并非与当前行业标准脱节，正如我们从许多开发者的日常工作中观察到的**React**、**Flutter**和**RxJava**的存在。
- en: The reason why I chose to dedicate a whole chapter to two frameworks that are
    still not widely used is that these two frameworks mark how iOS projects will
    look in the following decade.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择将整整一章内容献给这两个尚未被广泛使用的框架的原因是，这两个框架标志着iOS项目在未来十年将呈现出的样子。
- en: If you haven’t gained any experience with SwiftUI and Combine until now, the
    minimum you should do is understand the basic terms and concepts, which are part
    of the current chapter goal.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你到目前为止还没有任何关于SwiftUI和Combine的经验，你应该至少做到理解基本术语和概念，这些都是本章目标的一部分。
- en: First, let’s go over the most critical concept – declarative programming.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们回顾最重要的概念——声明式编程。
- en: Understanding declarative programming
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解声明式编程
- en: Declarative programming is a whole new programming paradigm that provides us
    with more readable and robust code. Declarative programming is not a new concept
    at all – in fact, we can find the roots of declarative programming 30–40 years
    ago. But only in the last decade has declarative programming gained popularity.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式编程是一种全新的编程范式，它为我们提供了更易读和更健壮的代码。实际上，声明式编程根本不是什么新概念——事实上，我们可以在30-40年前找到声明式编程的根源。但只有在过去十年中，声明式编程才变得流行起来。
- en: Let’s try to get into more detail about declarative programming by answering
    some questions we may encounter during an interview.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过回答我们可能在面试中遇到的一些问题，来更详细地了解声明式编程。
- en: “What’s the difference between declarative programming and the “classic” programming
    paradigm, also known as imperative programming?”
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “声明式编程与‘经典’编程范式（也称为命令式编程）有什么区别？”
- en: '*Why is this* *question important?*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要？*'
- en: If the workplace we interview for uses Combine or SwiftUI in its projects, we
    will probably have to answer some variant of this question. The reason is that
    the difference in how we approach code is so big that we cannot avoid restructuring
    our thoughts to answer that.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们面试的公司在其项目中使用Combine或SwiftUI，我们可能不得不回答这个问题的某个变体。原因是我们在处理代码的方式上的差异如此之大，以至于我们无法避免重组我们的思维来回答这个问题。
- en: '*What is* *the answer?*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: In declarative programming, we *focus on the outcome and results of our code*.
    We observe changes and define precisely what the results would be on other objects
    and how data will be manipulated.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明式编程中，我们**关注代码的输出和结果**。我们观察变化，并精确地定义其他对象的结果以及数据如何被操作。
- en: In imperative programming, we *focus on the steps that lead to* *our results*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令式编程中，我们**关注导致我们结果的一系列步骤**。
- en: At first glance, the difference doesn’t look clear. What does “focus on the
    results and not the steps” mean?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '初看起来，这种差异并不明显。什么是“关注结果而不是步骤”？ '
- en: Let’s try to explain that in code examples.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试用代码示例来解释。
- en: 'We have a screen with a button (`UIButton`) and a text field (`UITextField`),
    and we want to enable or disable the button based on the text field input. Let’s
    see how we do that in imperative programming:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个带有按钮（`UIButton`）和文本字段（`UITextField`）的屏幕，我们希望根据文本字段输入启用或禁用按钮。让我们看看我们如何在命令式编程中做到这一点：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The code should be straightforward, as we wrote this pattern hundreds of times
    while working with imperative programming. Connecting a delegate to a test field
    is common in iOS development. But look how unclear it is – when we set up the
    text field, we define *what function will be called* when the user changes the
    text, not what will happen. It means we focus on the steps and implementation,
    not the final result.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 代码应该是直接的，因为我们与命令式编程一起编写了这个模式数百次。在iOS开发中，将委托连接到文本字段是常见的。但看看它有多不清楚——当我们设置文本字段时，我们定义的是当用户更改文本时将调用哪个函数，而不是会发生什么。这意味着我们关注的是步骤和实现，而不是最终结果。
- en: In the text field delegate function, we indeed update the `isEnabled` property
    of the button, but that piece of code is called in another function in another
    place, perhaps even in another file.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本字段委托函数中，我们确实更新了按钮的`isEnabled`属性，但这段代码是在另一个函数的另一个地方调用的，可能甚至在另一个文件中。
- en: 'Let’s see a declarative approach to the problem:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看对这个问题的声明式方法：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code, we can see a much clearer solution to enable a button
    based on a text field input. We observe the text field “editing changed” event,
    map the `isEmpty` property to another Boolean, and assign it to the button’s `isEnabled`
    property.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到一个更清晰的解决方案，可以根据文本字段输入启用按钮。我们观察文本字段的“编辑改变”事件，将`isEmpty`属性映射到另一个布尔值，并将其分配给按钮的`isEnabled`属性。
- en: This means we declare what happens when a particular value is changed without
    any control flows or delegates.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们声明当特定值更改时会发生什么，而不涉及任何控制流或委托。
- en: The two coding paradigms contrast significantly when dealing with more complex
    workflows.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理更复杂的流程时，这两种编程范式之间的差异非常明显。
- en: “How does declarative programming help handle state management in iOS apps?”
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “如何使用声明式编程帮助处理iOS应用中的状态管理？”
- en: '*Why is this* *question important?*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要？*'
- en: There’s a strong relationship between declarative programming and state management.
    Before we answer that question, it is essential to understand what is considered
    a state and think about how you ever used a state in your apps.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式编程和状态管理之间存在紧密的关系。在我们回答这个问题之前，了解什么是状态以及您如何在您的应用中使用状态是至关重要的。
- en: Generally, a state is a condition of our app, screen, or view.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，状态是我们应用、屏幕或视图的条件。
- en: For example, a state can be a Boolean variable that represents whether the user
    is logged in to your app. Another example of a state is whether a button should
    be visible.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个状态可以是一个布尔变量，表示用户是否已登录到您的应用。另一个状态示例是按钮是否应该可见。
- en: It is clear that a state is something we all used in our apps before, and in
    declarative programming, the state is a primary topic.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，状态是我们都在我们的应用中使用过的东西，在声明式编程中，状态是一个主要话题。
- en: '*What is* *the answer?*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: Look at my last example – “whether a button should be visible.” It seems like
    a great idea to have a state for button visibility. The problem is that every
    time we change the state value, we must also ensure that the button is updated.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我的最后一个例子——“按钮是否应该可见。”为按钮可见性设置状态似乎是个好主意。问题是每次我们更改状态值时，我们必须确保按钮也被更新。
- en: 'One option is to use a `didSet` property observer:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选择是使用`didSet`属性观察者：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Even though a `didSet` property observer is a simple way to bind the state
    to button visibility, it’s not the ideal solution for a few reasons:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用`didSet`属性观察者将状态绑定到按钮可见性是一种简单的方法，但它并不是一个理想的解决方案，原因有几个：
- en: '**Separation of concerns**: A variable can only have one property observer,
    meaning we cannot separate different concerns or responsibilities. For instance,
    we cannot have one **didSet** block for analytics and another **didSet** block
    for UI updates.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关注点分离**：一个变量只能有一个属性观察者，这意味着我们无法分离不同的关注点或责任。例如，我们不能为分析有一个`didSet`块，为UI更新有另一个`didSet`块。'
- en: '**Not testable**: This relates to the previous point. Because the **didSet**
    block contains multiple actions, including possible UI changes, testing it can
    be challenging because it can have additional possible side effects.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可测试性**: 这与前面的观点相关。因为**didSet**块包含多个动作，包括可能的UI更改，测试它可能具有挑战性，因为它可能有额外的可能副作用。'
- en: '**Can’t observe multiple variables**: It’s nice to observe one property, but
    what if we want to observe changes in numerous properties and perform one action
    based on that change? **didSet** is not suitable for that.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无法观察多个变量**: 观察一个属性是很好的，但如果我们想观察多个属性的变化并根据这些变化执行一个动作怎么办？**didSet**不适合这种情况。'
- en: 'Now, here’s the Combine example version:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这里有一个Combine示例版本：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The Combine version is a much more elegant way of handling a state. We bind
    the state to button enablement just like we did with the `didSet` example. But
    this time, we also earn more benefits, such as the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Combine版本是处理状态的一种更加优雅的方式。我们就像在`didSet`示例中那样将状态绑定到按钮启用。但这次，我们还获得了更多的好处，例如以下内容：
- en: We can observe the **buttonVisible** variable in *multiple places* for different
    purposes
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在*多个地方*观察**buttonVisible**变量，用于不同的目的
- en: We can use multiple instances of **buttonVisible** *along with* *more variables*
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用多个**buttonVisible**实例以及*更多变量*
- en: We can perform *async operations* more efficiently and add sophisticated operators
    to the stream
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以更高效地执行异步操作，并向流中添加复杂的操作符
- en: Declarative programming is suitable for handling states because it lets us explain
    precisely what to do each time the state changes, and that’s ideal for state management.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式编程适合处理状态，因为它让我们精确地说明每次状态更改时应该做什么，这对于状态管理来说是非常理想的。
- en: Speaking of states – let’s dive in and go over states in SwiftUI, as they play
    a significant role in screen updates and layout.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 说到状态 – 让我们深入探讨SwiftUI中的状态，因为它们在屏幕更新和布局中起着重要作用。
- en: Learning states and observable objects
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习状态和可观察对象
- en: “States” is a primary topic in SwiftUI and declarative programming. Unlike imperative
    programming, where we can directly update UI elements on the screen, declarative
    programming *works in the opposite way* – we update the state, and the UI is updated
    according to our changes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: “状态”是SwiftUI和声明式编程的一个主要主题。与我们可以直接在屏幕上更新UI元素的命令式编程不同，声明式编程*以相反的方式工作* – 我们更新状态，UI会根据我们的更改进行更新。
- en: In fact, using states is the only way to create dynamic views in SwiftUI.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，使用状态是创建SwiftUI中动态视图的唯一方法。
- en: SwiftUI uses something called a property wrapper to mark certain variables as
    states.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: SwiftUI使用一种称为属性包装器的机制来标记某些变量为状态。
- en: 'Here are some of them:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些例子：
- en: '**@State**: To manage simple UI state'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**@State**: 用于管理简单的UI状态'
- en: '**@Binding**: To allow two directional updates between the view and its children'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**@Binding**: 允许视图与其子视图之间进行双向更新'
- en: '**@ObservedObject**: To share data between views'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**@ObservedObject**: 用于在视图之间共享数据'
- en: '**@EnvironmentObject**: To share data between views across an app'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**@EnvironmentObject**: 用于在应用程序中跨视图共享数据'
- en: When asked about SwiftUI, these different property wrappers play a significant
    role in understanding how SwiftUI works and building a full-featured app with
    SwiftUI.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当被问及SwiftUI时，这些不同的属性包装器在理解SwiftUI的工作原理以及使用SwiftUI构建功能齐全的应用程序中起着重要作用。
- en: If you want to read more about managing user interface state in SwiftUI, you
    can visit [https://developer.apple.com/documentation/swiftui/managing-user-interface-state](https://developer.apple.com/documentation/swiftui/managing-user-interface-state).
    For an overview of property wrappers, check out the link at [https://www.swift.org/blog/property-wrappers/](https://www.swift.org/blog/property-wrappers/).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于在SwiftUI中管理用户界面状态的信息，你可以访问[https://developer.apple.com/documentation/swiftui/managing-user-interface-state](https://developer.apple.com/documentation/swiftui/managing-user-interface-state)。有关属性包装器的概述，请查看[https://www.swift.org/blog/property-wrappers/](https://www.swift.org/blog/property-wrappers/)上的链接。
- en: Now, let’s look at two critical questions about that topic.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看关于这个主题的两个关键问题。
- en: “Can you explain the differences and use cases for the @State and @Binding property
    wrappers in SwiftUI?”
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “你能解释@State和@Binding属性包装器在SwiftUI中的区别和使用场景吗？”
- en: '*Why is this* *question important?*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要？*'
- en: These two property wrappers are fundamental to understanding how SwiftUI works.
    Going back to the *Understanding declarative programming* section, `@State` and
    `@Binding` are pure implementations of the concept of declarative programming.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个属性包装器对于理解 SwiftUI 的工作方式至关重要。回到**理解声明式编程**部分，`@State` 和 `@Binding` 是声明式编程概念的纯实现。
- en: '`@State` and `@Binding` are essential wrappers to create complex and reusable
    views.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`@State` 和 `@Binding` 是创建复杂和可重用视图的基本包装器。'
- en: '*What is* *the answer?*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案是什么**？'
- en: '`@State` is a property wrapper used to manage local states within a view. It’s
    used for simple values managed by a single view, such as toggles or form data.
    When the value of a `@State` property changes, **SwiftUI** will automatically
    update the view to reflect the new state. Here’s an example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`@State` 是一个属性包装器，用于在视图内部管理本地状态。它用于由单个视图管理的简单值，例如开关或表单数据。当 `@State` 属性的值发生变化时，SwiftUI
    会自动更新视图以反映新的状态。以下是一个示例：'
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `toggleIsOn` variable is wrapped in `@State`, allowing the SwiftUI to observe
    and update `MyView` if needed. Within the view, there is `Toggle` that is linked
    to the `toggleIsOn` state. As the state value changes, a corresponding text is
    updated.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`toggleIsOn` 变量被 `@State` 包装，允许 SwiftUI 在需要时观察和更新 `MyView`。在视图内部，有一个与 `toggleIsOn`
    状态链接的 `Toggle`。随着状态值的改变，相应的文本也会更新。'
- en: '`@Binding` is a property wrapper that provides a two-way connection between
    the child’s and parent’s views. It’s used to pass the state down the view hierarchy,
    allowing child views to modify values stored in a parent view. When the value
    of a `@Binding` property changes, both the child and parent views will be updated
    to reflect the new state. Here’s an example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Binding` 是一个属性包装器，它为子视图和父视图之间提供双向连接。它用于将状态向下传递到视图层次结构，允许子视图修改存储在父视图中的值。当
    `@Binding` 属性的值发生变化时，子视图和父视图都会更新以反映新的状态。以下是一个示例：'
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, `MyParentView` manages the `toggleIsOn` state and passes it
    down to `MyChildView` using a `@Binding` property. `MyChildView` can then modify
    the state by updating the `toggleIsOn` property. Both views are automatically
    updated to reflect the new state when this happens.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`MyParentView` 管理着 `toggleIsOn` 状态，并通过一个 `@Binding` 属性将其传递给 `MyChildView`。`MyChildView`
    可以通过更新 `toggleIsOn` 属性来修改状态。当发生这种情况时，两个视图都会自动更新以反映新的状态。
- en: We can see that `@State` and `@Binding` have a strong relationship. `@State`
    is `@Binding` of its child view. If we compare this to imperative programming
    with UIKit, the `@Binding` feature is similar to the delegate pattern we know
    and love but much more powerful, simple, and mainly declarative.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 `@State` 和 `@Binding` 之间有着紧密的联系。`@State` 是其子视图的 `@Binding`。如果我们将其与 UIKit
    的命令式编程进行比较，`@Binding` 功能类似于我们熟悉和喜爱的代理模式，但更强大、更简单，主要是声明式的。
- en: “What is the purpose of @ObservedObject in SwiftUI, and in what situations would
    you use it instead of @State or @Binding?”
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “在 SwiftUI 中，@ObservedObject 的作用是什么？在什么情况下你会用它来代替 @State 或 @Binding？”
- en: '*Why is this* *question important?*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**这个问题为什么重要**？'
- en: Now that we know what `@State` and `@Bining` roles are in SwiftUI, we must understand
    how `@ObservedObject` fits into our app architecture and how it differs from other
    view property wrappers.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了 `@State` 和 `@Binding` 在 SwiftUI 中的作用，我们必须了解 `@ObservedObject` 如何融入我们的应用架构，以及它与其他视图属性包装器的区别。
- en: '*What is* *the answer?*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案是什么**？'
- en: The `@ObservedObject` property wrapper in `@ObservedObject` will also automatically
    be updated.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ObservedObject` 属性包装器在 `@ObservedObject` 中也会自动更新。'
- en: Can the observed object be a singleton? Definitely. More importantly, it should
    be the same instance we inject into the different views.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 观察对象可以是单例吗？当然可以。更重要的是，它应该是我们注入到不同视图中的相同实例。
- en: 'Let’s look at *Figure 8**.1*:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看**图 8**.1*：
- en: '![Figure 8.1: The role of an observed object in our app architecture](img/Figure_8.1_B18653.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1：观察对象在我们应用架构中的作用](img/Figure_8.1_B18653.jpg)'
- en: 'Figure 8.1: The role of an observed object in our app architecture'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1：观察对象在我们应用架构中的作用
- en: '*Figure 8**.1* shows the different dependencies when using an observed object.
    It is an excellent practice to add more layers to our app that manage stuff such
    as persistent data and networking, and keep the observed object to share the data
    between the views.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 8**.1* 展示了使用观察对象时的不同依赖关系。在应用中添加更多层来管理持久数据和网络等，并保持观察对象在视图之间共享数据是一种很好的实践。'
- en: Let’s see a SwiftUI code example of a contacts list with the observed object.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个使用观察对象的 SwiftUI 代码示例，展示联系人列表。
- en: 'First, the contacts list view:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，是联系人列表视图：
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can see that the contacts list uses an observed object named `viewModel`
    that can be injected into the view or used as a `@ObservedObject` is that SwiftUI
    doesn’t recreate it whenever it needs to refresh the view, so it can safely store
    data.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到联系人列表使用了一个名为 `viewModel` 的观察对象，它可以注入到视图中或用作 `@ObservedObject`，因为 SwiftUI
    在需要刷新视图时不会重新创建它，所以它可以安全地存储数据。
- en: 'Now, let’s see what the `ContactViewModel` class looks like:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `ContactViewModel` 类的样子：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There are three important things to note in this code example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中有三个重要的事项需要注意：
- en: '**Conforming to the** **ObservableObject** **protocol**: If we want the class
    to be an observed object, we need it to conform to the **ObservableObject** protocol.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**遵循** **ObservableObject** **协议**：如果我们想让类成为观察对象，我们需要它遵循 **ObservableObject**
    协议。'
- en: '**Using** **@Published** **for the contacts list**: The contacts list variable
    has a **@Published** property wrapper, which lets the view observe changes in
    the contacts list.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用** **@Published** **为联系人列表**：联系人列表变量有一个 **@Published** 属性包装器，它允许视图观察联系人列表的变化。'
- en: '**DataLayer as a dependency**: To adhere to the separation of concerns principle,
    we separate the actual fetching and storing from the sharing class. The only responsibility
    of the **ContactViewModel** class is to share data between views. The **ContactDataLayer**
    class does the persistent operations.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据层作为依赖项**：为了遵循关注点分离原则，我们将实际的获取和存储与共享类分开。**ContactViewModel** 类的唯一责任是在视图之间共享数据。**ContactDataLayer**
    类执行持久操作。'
- en: To summarize, `ObservedObject` is a mechanism that facilitates data sharing
    among views. It is easy to grasp and incorporate and can help divide a project’s
    structure into distinct layers.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`ObservedObject` 是一种促进视图之间数据共享的机制。它易于理解和整合，可以帮助将项目的结构划分为不同的层。
- en: Navigating SwiftUI views
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 SwiftUI 视图中导航
- en: Navigation in mobile apps was always a critical issue. UIKit supported navigation
    from day one, and SwiftUI launched with essential support from `NavigationView`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动应用中，导航一直是关键问题。UIKit 从一开始就支持导航，而 SwiftUI 伴随着 `NavigationView` 的基本支持推出。
- en: Navigation in SwiftUI is quite different than UIKit. While in UIKit, we had
    to create a new view controller and push it to a stack using `UINavigationController`,
    in SwiftUI, it works slightly differently.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SwiftUI 中，导航与 UIKit 非常不同。在 UIKit 中，我们必须创建一个新的视图控制器，并使用 `UINavigationController`
    将其推送到堆栈中，而在 SwiftUI 中，它的工作方式略有不同。
- en: Remember we discussed declarative programming earlier in this chapter? This
    is how navigation works in SwiftUI. Instead of creating and pushing a new view,
    we use the state to present sheets, modals, and links to navigate to a new view.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们在这章前面讨论了声明式编程吗？这就是 SwiftUI 中导航的工作方式。我们不是创建和推送一个新的视图，而是使用状态来呈现表单、模态和链接以导航到新视图。
- en: 'Let’s see how to present a modal view using state modification in SwiftUI:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在 SwiftUI 中使用状态修改来呈现模态视图：
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, we have a state variable called `isModalPresented`. When a
    user taps the `Present Modal` button, we set `isModalPresented` to `true`, which
    triggers the view modifier `ModalView`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个名为 `isModalPresented` 的状态变量。当用户点击“呈现模态”按钮时，我们将 `isModalPresented`
    设置为 `true`，这会触发视图修改器 `ModalView`。
- en: Presenting a modal using a state may feel weird for developers who worked years
    with imperative programming, but this pattern fits naturally into declarative
    programming.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些多年来一直使用命令式编程的开发者来说，使用状态来呈现模态可能感觉有些奇怪，但这种模式自然地融入了声明式编程。
- en: Now, let’s move on to some interesting questions about SwiftUI navigation.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续探讨一些关于 SwiftUI 导航的有趣问题。
- en: “How do you pass data between views using the SwiftUI navigation system?”
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “你如何使用 SwiftUI 导航系统在视图之间传递数据？”
- en: '*Why is this* *question important?*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要？*'
- en: Passing data between views is critical to implementing an effective navigation
    pattern.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图之间传递数据对于实现有效的导航模式至关重要。
- en: And this is not a trivial question – other patterns enable us to navigate to
    a new view without passing data. We can use the observed object pattern, which
    we reviewed in the previous section, or we can use some global state manager to
    understand what data to present.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个简单的问题——其他模式使我们能够在不传递数据的情况下导航到新视图。我们可以使用我们在上一节中回顾的观察对象模式，或者我们可以使用一些全局状态管理器来了解要呈现哪些数据。
- en: However, it is considered a best practice to pass data to a new screen for better
    separation and modularity.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将数据传递给新屏幕被认为是最佳实践，以实现更好的分离和模块化。
- en: '*What is* *the answer?*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: The answer is that there are no tricks here that we don’t already know from
    other patterns in UIKit.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是这里没有我们不知道的 UIKit 中其他模式中的技巧。
- en: The best way to pass data between views is to *inject the data when initiating
    the* *new view*.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图之间传递数据最好的方式是在初始化**新视图**时注入数据。
- en: 'Let’s create a screen with a list of countries:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个包含国家列表的屏幕：
- en: '[PRE9]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, let’s create `CountryDetailView` with the `country` property:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建具有 `country` 属性的 `CountryDetailView`：
- en: '[PRE10]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `CountryDetailView` struct has a property named `country`. In Swift, the
    compiler automatically generates a member-wise initializer for their properties.
    We use that to pass the `country` object when initializing `CountryDetailView`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`CountryDetailView` 结构体有一个名为 `country` 的属性。在 Swift 中，编译器会自动为它们的属性生成成员初始化器。我们使用它来在初始化
    `CountryDetailView` 时传递 `country` 对象。'
- en: As we can see, it is straightforward to pass data between views just by using
    dependency injection. We can also evaluate that pattern and pass a state on one
    side and a binding on the next view to create a two-directional update between
    the two views, such as a delegate pattern in UIKit.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，仅通过依赖注入就可以轻松地在视图之间传递数据。我们还可以评估该模式，并在一个视图传递状态，在下一个视图传递绑定，以在两个视图之间创建双向更新，例如
    UIKit 中的代理模式。
- en: “Can you explain how to use @Environment(\.presentationMode) to dismiss a presented
    view in SwiftUI navigation?”
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “你能解释一下如何在 SwiftUI 导航中使用 @Environment(\.presentationMode) 来关闭展示视图吗？”
- en: '*Why is this* *question important?*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要？*'
- en: Using `NavigationLink` to move to a new place is easy, but how do we dismiss
    or navigate back?
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `NavigationLink` 移动到新位置很容易，但我们是怎样关闭或导航回的呢？
- en: This question tests our understanding of navigation and a property wrapper called
    `@Environment`, which can expose environment variables that provide more capabilities.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题测试了我们对于导航和名为 `@Environment` 的属性包装器的理解，它可以暴露环境变量，提供更多功能。
- en: '*What is* *the answer?*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个答案是什么？*'
- en: '`@Environment(\.presentationMode`) is a property wrapper that provides access
    to a view’s presentation mode, allowing us to dismiss a presented view in SwiftUI
    navigation.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Environment(\.presentationMode)` 是一个属性包装器，它提供了对视图的展示模式的访问权限，允许我们在 SwiftUI
    导航中关闭展示的视图。'
- en: 'Here’s an example of how to use `@Environment(\.presentationMode)` to dismiss
    a presented view:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个如何使用 `@Environment(\.presentationMode)` 来关闭展示视图的例子：
- en: '[PRE11]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, we have `DetailView` currently presented on the screen. We
    use the `@Environment(\.presentationMode)` property wrapper to access the view’s
    presentation mode.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们当前在屏幕上展示的是 `DetailView`。我们使用 `@Environment(\.presentationMode)` 属性包装器来访问视图的展示模式。
- en: Once the user taps the `presentationMode` to dismiss the function, which takes
    us back to the previous screen.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击 `presentationMode` 来关闭函数时，它会带我们回到上一个屏幕。
- en: 'Note that if the view is not currently presented, we’ll get a runtime error
    trying to do that. Therefore, if we are not sure whether the view is presented
    before we dismiss it, we can check using the same presentation mode:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果视图当前没有展示，尝试这样做将会导致运行时错误。因此，如果我们不确定在关闭视图之前视图是否展示，我们可以使用相同的展示模式进行检查：
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this code example, the **Dismiss** button appears only if the view is presented,
    and since it’s declarative, it will be hidden when it’s not.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中，**关闭**按钮仅在视图展示时出现，由于它是声明式的，所以当它不展示时将会被隐藏。
- en: Navigation is a crucial component of any mobile app, and in a way, it becomes
    even more straightforward with SwiftUI. The preceding two questions should be
    enough for us to prepare for this part of the interview.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 导航是任何移动应用的关键组件，在某种程度上，它通过 SwiftUI 变得更加简单。前两个问题应该足以让我们为这个面试部分做好准备。
- en: Expertise with the SwiftUI life cycle
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 熟悉 SwiftUI 生命周期
- en: We can’t build UI screens without fully understanding the UI life cycle. States
    and modifiers such as `onChange` and `onAppear` are integral to the SwiftUI life
    cycle and essential to building a functional application.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不完全理解 UI 生命周期，我们就无法构建 UI 屏幕。状态和 `onChange`、`onAppear` 等修改器是 SwiftUI 生命周期的核心，对于构建一个功能性的应用程序至关重要。
- en: We already went on some of the things related to the SwiftUI life cycle in the
    previous sections – for example, observed objects and states are part of the SwiftUI
    life cycle. Now, we must understand how they work when a view needs to reload,
    change, or move to a new screen.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面几节中已经讨论了一些与 SwiftUI 生命周期相关的内容——例如，观察对象和状态是 SwiftUI 生命周期的一部分。现在，我们必须了解当视图需要重新加载、更改或移动到新屏幕时，它们是如何工作的。
- en: “How does SwiftUI handle state changes during the view life cycle?”
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “SwiftUI 如何处理视图生命周期中的状态变化？”
- en: '*Why is this* *question important?*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要？*'
- en: SwiftUI’s approach to state management differs from traditional UIKit or AppKit
    approaches, and it’s crucial to understand how SwiftUI handles state changes and
    updates to avoid unexpected behavior in our app.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: SwiftUI 的状态管理方法与传统 UIKit 或 AppKit 方法不同，理解 SwiftUI 如何处理状态变化和更新对于避免我们应用中的意外行为至关重要。
- en: '*What is* *the answer?*'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: SwiftUI generates the view hierarchy based on the current state. SwiftUI generates
    a new view hierarchy whenever the state changes and compares it to the current
    displayed hierarchy.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: SwiftUI 根据当前状态生成视图层次结构。每当状态发生变化时，SwiftUI 都会生成一个新的视图层次结构，并将其与当前显示的层次结构进行比较。
- en: This means that all the variables are regenerated each time, except for the
    property wrappers such as `@State` and `@Binding`. The comparison to the current
    view tells SwiftUI what views it needs to update to reflect the new state. SwiftUI
    applies the changes to the user interface by adding, removing, or updating current
    views.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着每次都会重新生成所有变量，除了像 `@State` 和 `@Binding` 这样的属性包装器。将当前视图与比较，告诉 SwiftUI 需要更新哪些视图以反映新状态。SwiftUI
    通过添加、删除或更新当前视图来将更改应用于用户界面。
- en: This process is very efficient because SwiftUI only updates the parts of the
    user interface that need to be changed.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程非常高效，因为 SwiftUI 只更新需要更改的用户界面部分。
- en: 'Look at the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的代码：
- en: '[PRE13]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When the user taps the button, it changes the `labelText` state. In this case,
    SwiftUI generates a new view with a new value for the label (`Text`) and compares
    it to the current view hierarchy. Since only `Text` was changed and the button
    stayed the same, SwiftUI will only update `Text` and won’t render the whole screen
    to keep it much more efficient.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击按钮时，它改变了 `labelText` 状态。在这种情况下，SwiftUI 生成一个新的视图，其中标签（`Text`）的新值，并将其与当前视图层次结构进行比较。由于只有
    `Text` 发生了变化，而按钮保持不变，SwiftUI 将只更新 `Text`，而不会渲染整个屏幕，以保持其效率更高。
- en: “How do you use the onChange modifier in SwiftUI, and what state changes does
    it respond to?”
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “如何在 SwiftUI 中使用 `onChange` 修饰符，它响应哪些状态变化？”
- en: '*Why is this* *question important?*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要？*'
- en: This question is important because it assesses our understanding of responding
    to state changes in SwiftUI. Responding to state changes is a fundamental aspect
    of building user interfaces in SwiftUI, and an `onChange` modifier is a key tool
    to accomplish this task.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题很重要，因为它评估了我们对于在 SwiftUI 中响应状态变化的理解。响应状态变化是构建 SwiftUI 用户界面的基本方面，而 `onChange`
    修饰符是实现这一任务的关键工具。
- en: '*What is* *the answer?*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: We use the `onChange` modifier to respond to changes in a specific state variable.
    When applied to a view, the `onChange` modifier will execute a closure when the
    specified state variable changes.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `onChange` 修饰符来响应特定状态变量的变化。当应用于视图时，`onChange` 修饰符将在指定的状态变量发生变化时执行一个闭包。
- en: 'Look at the following syntax:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的语法：
- en: '[PRE14]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this syntax, `stateVariable` is the name of the state we want to observe,
    and `newValue` is the new value of that variable.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个语法中，`stateVariable` 是我们想要观察的状态的名称，而 `newValue` 是该变量的新值。
- en: 'Here are some use cases we can think of for the preceding:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些我们可以考虑的前一个用例：
- en: Updating a view’s layout in response to changes in a user’s input
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据用户输入的变化更新视图的布局
- en: Changing the button color when it is tapped
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当按钮被点击时，改变按钮的颜色
- en: Updating the layout in response to an environmental change
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据环境变化更新布局
- en: Responding to changes in a data model and presenting a banner
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应数据模型的变化并显示横幅
- en: Navigating to a new screen when networking loading has finished
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当网络加载完成时导航到新屏幕
- en: 'Here’s an example of the last use case – navigating to a new screen when network
    loading has finished and the model updates:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个最后一个用例的示例——在网络加载完成和模型更新后导航到新屏幕：
- en: '[PRE15]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We can see that the code observes the `viewModel` detail property, and once
    it is populated, it navigates to a new view.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到代码观察了 `viewModel` 的详细属性，一旦它被填充，它就会导航到新的视图。
- en: Expertise in Combine
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Combine 的专业知识
- en: We already discussed declarative programming throughout this chapter, so now,
    let’s focus on the Combine framework for a second.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中已经讨论了声明式编程，所以现在，让我们专注于 Combine 框架一段时间。
- en: Apple introduced Combine in WWDC 2019 as part of the iOS 13 version. Combine
    is Apple’s response to other popular reactive frameworks, such as React and **RxSwift**.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果在 2019 年的 WWDC 上作为 iOS 13 版本的一部分引入了 Combine。Combine 是苹果对其他流行响应式框架，如 React
    和 **RxSwift** 的回应。
- en: The Combine framework helps developers build reactive applications with robust
    async operations and data updates.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Combine 框架帮助开发者构建具有强大异步操作和数据更新的响应式应用程序。
- en: 'There are three main components in Combine:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Combine 有三个主要组件：
- en: '**Publishers**: A publisher is an object that emits a stream of values over
    time. Publishers can be thought of as a source of data, which can come from various
    sources, such as user input, network requests, or timers. Publishers can emit
    values of different types, such as integers, strings, or custom data types, and
    can emit an unlimited number of values or a finite number of values.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布者**：发布者是一个对象，它会在一段时间内发出一系列值。发布者可以被视为数据源，数据可以来自各种来源，例如用户输入、网络请求或计时器。发布者可以发出不同类型的值，如整数、字符串或自定义数据类型，并且可以发出无限数量的值或有限数量的值。'
- en: '**Operators**: Operators are functions that can be used to transform, filter,
    or combine streams of values emitted by publishers. Operators can take one or
    more publishers as input and return a new publisher that emits transformed values.
    Some examples of operators are **map**, **filter**, **flatMap**, and **zip**.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作符**：操作符是一类函数，可以用来转换、过滤或组合由发布者发出的值流。操作符可以接受一个或多个发布者作为输入，并返回一个新的发布者，该发布者会发出转换后的值。一些操作符的例子包括
    **map**、**filter**、**flatMap** 和 **zip**。'
- en: '**Subscribers**: A subscriber is an object that receives and processes values
    emitted by a publisher. Subscribers can be considered consumers of data, which
    can handle the values emitted by a publisher in various ways, such as printing
    to a console, updating a user interface, or storing in a database. A subscriber
    can receive values of different types, requesting a certain number of values or
    receiving an unlimited number.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**订阅者**：订阅者是一个接收并处理发布者发出的值的对象。订阅者可以被视为数据消费者，可以以各种方式处理发布者发出的值，例如打印到控制台、更新用户界面或存储到数据库中。订阅者可以接收不同类型的值，请求一定数量的值或接收无限数量的值。'
- en: By combining publishers, operators, and subscribers, we can create powerful
    data streams between the different parts of our app.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 通过组合发布者、操作符和订阅者，我们可以在我们应用程序的不同部分之间创建强大的数据流。
- en: 'Let’s see an example of Combine usage:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Combine 的一个使用例子：
- en: '[PRE16]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this example, we will demonstrate the different components in Combine, as
    previously described:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将演示 Combine 中不同的组件，正如之前所描述的：
- en: We have two different publishers (**numbersPublisher** and **lettersPublisher**)
    that send different values over time.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有两个不同的发布者（**numbersPublisher** 和 **lettersPublisher**），它们在一段时间内发送不同的值。
- en: We *combine* these two publishers using the **combineLatest** operator, which
    returns a publisher with the two most updated values each time one of the publishers
    is updated.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 **combineLatest** 操作符将这两个发布者 *组合* 在一起，每次其中一个发布者更新时，它都会返回两个最新值。
- en: We then *map the values* to one string using the **map** operator, followed
    by a filter operator that returns only strings with more than 10 characters.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们然后使用 **map** 操作符将值 *映射* 到一个字符串，接着是一个过滤操作符，它只返回超过 10 个字符的字符串。
- en: The **sink** method helps to *subscribe to the Combine stream* and print the
    output.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**sink** 方法有助于 *订阅 Combine 流* 并打印输出。'
- en: This complex yet interesting Combine stream demonstrates all the different Combine
    components effectively.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个复杂而有趣的 Combine 流有效地展示了所有不同的 Combine 组件。
- en: If you want to read more about Combine basics and principles, you can visit
    [https://developer.apple.com/documentation/combine#](https://developer.apple.com/documentation/combine#).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于 Combine 基本和原则的信息，你可以访问 [https://developer.apple.com/documentation/combine#](https://developer.apple.com/documentation/combine#)。
- en: Now, let’s move on to some questions about Combine.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续讨论一些关于 Combine 的问题。
- en: “Can you provide an example of how you would use Combine in an iOS app?”
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “你能提供一个在 iOS 应用中使用 Combine 的例子吗？”
- en: '*Why is this* *question important?*'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个问题为什么重要？*'
- en: The complex Combine example I just showed you is nice but not very practical,
    and it’s there only to explain Combine framework principles.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我刚才展示的复杂 Combine 示例很好，但并不实用，它只是为了解释 Combine 框架的原则。
- en: The real challenge is understanding where to implement Combine in our app architecture
    in a real-world use case.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的挑战是理解在现实世界的用例中，如何在我们的应用程序架构中实现 Combine。
- en: '*What is* *the answer?*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: 'Combine has many real-world use cases. Let’s name some of them:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Combine 有许多实际应用场景。让我们列举一些：
- en: Performing *network requests* and handling data or errors
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行 *网络请求* 并处理数据或错误
- en: Updating UI elements with *data bindings* or state changes
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 *数据绑定* 或状态变化更新 UI 元素
- en: Validating *user input* and showing feedback
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证 *用户输入* 并显示反馈
- en: Implementing *MVVM* or other architectural patterns
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 *MVVM* 或其他架构模式
- en: Working with timers, notifications, *key-value observing*, and so on
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与定时器、通知、*键值观察* 等一起工作
- en: Since we are requested to provide an example of where we would use Combine in
    our app, here’s one where we bind data to UI.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们被要求提供一个我们会在应用中使用 Combine 的示例，这里有一个将数据绑定到 UI 的示例。
- en: 'In the following example, we observe the number of notifications and update
    the notifications button with the relevant image:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们观察通知的数量并使用相关图像更新通知按钮：
- en: '[PRE17]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In our code example, we can see an excellent binding between data and a specific
    UI element. This example can also be used for other examples – title updates,
    color changes, button visibility, and so on.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码示例中，我们可以看到数据与特定 UI 元素之间出色的绑定。这个示例也可以用于其他示例——标题更新、颜色更改、按钮可见性等。
- en: Binding data as a UI element is also an excellent technique in the *MVVM design
    pattern*, where we can bind a state between the view model and the view.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据作为 UI 元素绑定是 *MVVM 设计模式* 中的优秀技术，其中我们可以在视图模型和视图之间绑定状态。
- en: 'Now, let’s see a more complex example of how to use Combine – to fetch data
    from a network request and update a table view while using the MVVM design pattern:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用 Combine 的一个更复杂的示例——从网络请求中获取数据并使用 MVVM 设计模式更新表格视图：
- en: '[PRE18]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `fetchArticles()` function does most of the job while requesting data, mapping
    it, decoding it to the `articles` array, moving it to the main thread, and assigning
    the data to the `articles` `published` variable.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetchArticles()` 函数在请求数据、映射它、将其解码到 `articles` 数组、移动到主线程并将数据分配给 `articles`
    的 `published` 变量时做了大部分工作。'
- en: 'Now, let’s look at the view controller:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看视图控制器：
- en: '[PRE19]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the view controller, we bind the `articles` array to the table view by observing
    changes and reloading the data each time we get an update.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图控制器中，我们通过观察变化并在每次收到更新时重新加载数据，将 `articles` 数组绑定到表格视图。
- en: The last example shows how to use Combine to chain different operators to perform
    a network request, parsing, moving to the main thread, and handling errors in
    a few lines of code.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个示例展示了如何使用 Combine 在几行代码中链式调用不同的操作符来执行网络请求、解析、移动到主线程和处理错误。
- en: I think these two examples represent many widespread use cases with Combine.
    We should learn them thoroughly, which will help us answer this question efficiently.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这两个示例代表了使用 Combine 的许多常见用例。我们应该彻底学习它们，这将帮助我们高效地回答这个问题。
- en: “How do you debug a Combine stream?”
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “你如何调试一个 Combine 流？”
- en: '*Why is this* *question important?*'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么这个问题很重要？*'
- en: We already know that debugging is critical for developers, not only iOS developers.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道，调试对于开发者来说至关重要，而不仅仅是 iOS 开发者。
- en: Most of our experience with debugging as iOS developers revolves around imperative
    programming and standard code flows. On the other hand, Combine brings something
    different to the table, with new challenges in the debugging area.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们作为 iOS 开发者的调试经验大多围绕命令式编程和标准代码流程。另一方面，Combine 在调试领域带来了不同的东西，带来了新的挑战。
- en: In this question, the interviewer wants to hear how we handle Combine issues
    we may encounter in our job.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，面试官想了解我们如何处理我们在工作中可能遇到的 Combine 问题。
- en: '*What is* *the answer?*'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*答案是什么？*'
- en: We can debug Combine streams using Xcode built-in debugging tools, such as setting
    breakpoints, inspecting variables, and stepping through code execution.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Xcode 内置的调试工具来调试 Combine 流，例如设置断点、检查变量和单步执行代码执行。
- en: However, the Combine framework offers additional tools to help us debug. Let’s
    list two of them.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Combine 框架提供了额外的工具来帮助我们调试。让我们列出其中的两个。
- en: Reading the console with print() and handleEvents()
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `print()` 和 `handleEvents()` 读取控制台
- en: The `print` operator is a debugging tool that allows us to print the events
    that flow through a Combine pipeline. We can use it to visualize the data transformations
    and identify unexpected behavior or errors. The `print` operator can be placed
    at any point in the pipeline and will print all events that occur downstream of
    it.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`print` 操作符是一个调试工具，它允许我们打印通过 Combine 管道流动的事件。我们可以使用它来可视化数据转换并识别意外的行为或错误。`print`
    操作符可以放置在管道的任何位置，并将打印所有在其下游发生的事件。'
- en: 'Here’s an example that demonstrates how to use the `print` operator:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个演示如何使用 `print` 操作符的例子：
- en: '[PRE20]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this example, we use the `print` operator to label the debug output with
    `"Debug:"`. This will help us distinguish the debug logs from any other output
    in the console. When we run this code, we will see the following output in the
    console:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用 `print` 操作符用 `"Debug:"` 标记调试输出。这将帮助我们区分控制台中的调试日志和其他任何输出。当我们运行此代码时，我们将在控制台看到以下输出：
- en: '[PRE21]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `handleEvents` operator is similar to the `print` operator, but instead
    of printing the events, it allows us to trigger side effects at specific points
    in the pipeline.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`handleEvents` 操作符类似于 `print` 操作符，但它不是打印事件，而是允许我们在管道的特定点触发副作用。'
- en: We can use it to perform actions such as logging, updating UI elements, or triggering
    notifications. The `handleEvents` operator can be placed at any point in the pipeline,
    and it will trigger the side effects for all events that occur downstream of it.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用它来执行诸如记录日志、更新 UI 元素或触发通知等操作。`handleEvents` 操作符可以放置在管道的任何位置，并且它将触发所有在其下游发生的事件的副作用。
- en: 'Here’s an example that demonstrates how to use the `handleEvents` operator:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个演示如何使用 `handleEvents` 操作符的例子：
- en: '[PRE22]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: With the `handleEvents` operator, we can print each event separately and have
    complete control of our printing operations.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `handleEvents` 操作符，我们可以单独打印每个事件，并对我们的打印操作有完全的控制。
- en: Including breakpoints in our stream
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在我们的流中包含断点
- en: The Combine framework provides additional operators to generate breakpoints
    in our streams.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Combine 框架提供了额外的操作符来生成流中的断点。
- en: 'The first and primary operator is `breakpoint()`, which can help us pause a
    program at specific events, similar to `handleEvents()`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个也是主要的操作符是 `breakpoint()`，它可以帮助我们在特定事件暂停程序，类似于 `handleEvents()`：
- en: '[PRE23]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this code, we pause the program on completion or when the output is bigger
    than eight by returning `true` in the corresponding places.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们通过在相应位置返回 `true` 来在程序完成或输出大于八时暂停程序。
- en: 'The second breakpoint operator is `breakpointOnError()`, which pauses the program
    when any of the upstream publishers throws an error:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个断点操作符是 `breakpointOnError()`，当任何上游发布者抛出错误时，它会暂停程序：
- en: '[PRE24]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This example is simple – the `tryMap` operator throws an error. Therefore, the
    program will pause, thanks to the `breakpointOnError()` command.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子很简单——`tryMap` 操作符抛出一个错误。因此，程序将暂停，多亏了 `breakpointOnError()` 命令。
- en: Both `breakpoint()` and `breakpointOnError()` are great ways to pause a program
    when we need to perform deep Combine issue investigations.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`breakpoint()` 和 `breakpointOnError()` 都是我们在需要执行深入的 Combine 问题调查时暂停程序的好方法。'
- en: Summary
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went over critical topics in declarative programming, SwiftUI,
    and Combine. We discussed the SwiftUI life cycle, debugging Combine, real-world
    examples, navigation, and states. By now, we should be fully covered for our interview
    when asked about SwiftUI and Combine.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了声明式编程、SwiftUI 和 Combine 的关键主题。我们讨论了 SwiftUI 生命周期、调试 Combine、现实世界的例子、导航和状态。到现在为止，当我们被问到
    SwiftUI 和 Combine 时，我们应该已经完全准备好了。
- en: The next chapter is a bit different. We will discuss a critical layer in our
    architecture – the data layer and, specifically, the persistent data layer.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将有所不同。我们将讨论我们架构中的一个关键层——数据层，特别是持久化数据层。
