- en: Chapter 6. Audio
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。音频
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Playing sounds and music
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放声音和音乐
- en: Modifying audio properties
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改音频属性
- en: Fading sounds and music
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 淡入淡出声音和音乐
- en: Using audio in a game
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在游戏中使用音频
- en: Using positional audio in a game
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在游戏中使用定位音频
- en: Metering background music
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计量背景音乐
- en: Metering dialogue for animation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为动画计量对话
- en: Recording audio
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 录音音频
- en: Streaming audio
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流式音频
- en: Using the iPod music library
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用iPod音乐库
- en: Creating a MIDI synthesizer
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建MIDI合成器
- en: Speech recognition and text to speech
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语音识别和语音合成
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Depending on what kind of game you're making, adding audio can be anything from
    a simple to a daunting task. In this chapter we will integrate sounds and music
    into game examples. We will also use advanced audio techniques like metering,
    recording, speech recognition, and more.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你制作的游戏类型，添加音频可能从简单到令人畏惧的任务。在本章中，我们将将声音和音乐集成到游戏示例中。我们还将使用诸如计量、录音、语音识别等高级音频技术。
- en: Playing sounds and music
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放声音和音乐
- en: Most games use a variety of sound effects and at most a few different background
    music tracks. **CocosDenshion** is the audio library built into Cocos2d. It provides
    a number of features including the **SimpleAudioEngine** API. In this recipe,
    we will use this API to play sounds and music.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数游戏使用各种音效，最多只有几条不同的背景音乐轨道。"**CocosDenshion**"是Cocos2d内置的音频库。它提供包括**SimpleAudioEngine**
    API在内的多项功能。在本食谱中，我们将使用此API来播放声音和音乐。
- en: '![Playing sounds and music](img/4002_06_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![播放声音和音乐](img/4002_06_01.jpg)'
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅项目*RecipeCollection02*以获取本食谱的完整工作代码。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Execute the following code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works...
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `SimpleAudioEngine` class provides the user with a very simple interface
    for basic audio playback. The `[SimpleAudioEngine sharedEngine]` singleton is
    merely a simplified wrapper over the `[CDAudioManager sharedManager]` singleton
    provided by CocosDenshion.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleAudioEngine`类为用户提供了一个非常简单的接口来进行基本的音频播放。`[SimpleAudioEngine sharedEngine]`单例仅仅是CocosDenshion提供的`[CDAudioManager
    sharedManager]`单例的一个简化包装。'
- en: 'Initialization:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化：
- en: No initialization of `SimpleAudioEngine` is necessary. In this recipe we simply
    maintain a pointer to `[SimpleAudioEngine sharedEngine]` to shorten some code.
    We set **resign behavior** using the following line. This changes audio behavior
    when the application is suspended or otherwise interrupted.
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不需要初始化`SimpleAudioEngine`。在本食谱中，我们只是维护对`[SimpleAudioEngine sharedEngine]`的指针以缩短一些代码。我们使用以下行设置**辞职行为**。这会改变应用挂起或被其他方式中断时的音频行为。
- en: '[PRE1]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This overrides the `applicationWillResignActive` method specified under the
    `UIApplicationDelegate` implemented by `CDAudioManager`. Other resign types are
    defined in `CDAudioManager.h`. This one stops background music on resign (pressing
    the home button on an iOS device) and plays the background music when the application
    becomes active.
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将覆盖由`CDAudioManager`实现的`UIApplicationDelegate`下指定的`applicationWillResignActive`方法。其他辞职类型在`CDAudioManager.h`中定义。这个方法会在辞职（在iOS设备上按下主页按钮）时停止背景音乐，并在应用变为活动状态时播放背景音乐。
- en: 'Playing sound effects:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放音效：
- en: 'Each sound effect that we''ll play is an instance of `CDSoundSource`. "Loading"
    a sound effect involves pre-loading it using `SimpleAudioEngine`. Playing a sound
    without pre-loading it will result in a delay and diminished sound quality. To
    pre-load a sound, use the following line:'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将要播放的每个音效都是`CDSoundSource`的一个实例。"加载"音效涉及使用`SimpleAudioEngine`预先加载它。不预先加载就播放声音会导致延迟和降低音质。要预先加载声音，请使用以下行：
- en: '[PRE2]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Initializing a `CDSoundSource` object:'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 初始化`CDSoundSource`对象：
- en: '[PRE3]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And finally, maintaining a reference to that object:'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，保持对该对象的引用：
- en: '[PRE4]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To play a sound, we simply get the reference and call the play method:'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要播放声音，我们只需获取引用并调用播放方法：
- en: '[PRE5]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`SimpleAudioEngine` hides all the complex aspects of this process.'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`SimpleAudioEngine`隐藏了此过程的复杂方面。'
- en: 'Playing background music:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放背景音乐：
- en: 'Playing background music is similar to playing sound effects except that there
    can only be one piece of background music playing at a given time:'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 播放背景音乐与播放音效类似，但一次只能播放一首背景音乐：
- en: '[PRE6]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If necessary you can obtain a reference to the actual background music `CDLongAudioSource`
    object:'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果需要，你可以获取实际背景音乐`CDLongAudioSource`对象的引用：
- en: '[PRE7]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This class is optimized for longer pieces of audio like music and narration.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此类优化用于较长的音频片段，如音乐和旁白。
- en: There's More...
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: Real time audio decoding and playback, especially on a mobile device, requires
    the use of specific audio formats.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 实时音频解码和播放，尤其是在移动设备上，需要使用特定的音频格式。
- en: 'CDSoundSource formats:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CDSoundSource 格式：
- en: The recommended encoding for sound effects is **16-bit Mono Wave** for uncompressed
    audio files and **IMA4** in a **CAF** container for lossy audio files.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 声音效果的推荐编码为未压缩音频文件的 **16 位单声道 Wave** 和在 **CAF** 容器中的 **IMA4**，用于有损音频文件。
- en: 'Converting to IMA4 audio files:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换为 IMA4 音频文件：
- en: 'On a Unix-based system, you can use the **afconvert** tool to convert from
    a number of formats to IMA4:'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在基于 Unix 的系统上，您可以使用 **afconvert** 工具将多种格式转换为 IMA4：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'CDLongAudioSource formats:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CDLongAudioSource 格式：
- en: For the playback of music and other long audio, any format supported by Apple's
    `AVAudioPlayer` will work. The format typically used is **MP3**.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于音乐和其他长音频的播放，任何由 Apple 的 `AVAudioPlayer` 支持的格式都可以使用。通常使用的格式是 **MP3**。
- en: 'Memory sizes:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存大小：
- en: Although compressing audio reduces disk space requirements, all sound effects
    are stored in memory as **16-bit uncompressed PCM**. So, compressing sound effects
    will not reduce your application's memory footprint. This becomes a factor for
    larger and more sound intensive games.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然压缩音频可以减少磁盘空间需求，但所有声音效果都以 **16 位未压缩 PCM** 格式存储在内存中。因此，压缩声音效果不会减少您应用程序的内存占用。这对于更大、声音更密集的游戏来说是一个因素。
- en: Modifying audio properties
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改音频属性
- en: CocosDenshion provides functionality to change the **pitch, gain**, and **pan**
    properties of an audio source. Pitch is the frequency, gain is volume, and pan
    is a way to shift volume between left and right speakers. In this example, we
    will create a music-bending instrument to display these properties being dynamically
    modified.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: CocosDenshion 提供了更改音频源 **音调、增益** 和 **声像** 属性的功能。音调是频率，增益是音量，声像是左右扬声器之间调整音量的方式。在本例中，我们将创建一个音乐弯曲乐器来显示这些属性被动态修改。
- en: '![Modifying audio properties](img/4002_06_02.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![修改音频属性](img/4002_06_02.jpg)'
- en: Getting ready
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目 *RecipeCollection02* 以获取此菜谱的完整工作代码。
- en: How to do it...
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Execute the following code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: 'The first thing needed for this recipe is a short, constant, mid-range synthesized
    tone. This was created in **GarageBand** and then modified using **Audacity**.
    When you touch the screen the note is played:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱所需的第一件事是一个短、恒定、中音范围的合成音。这是在 **GarageBand** 中创建的，然后使用 **Audacity** 进行修改。当您触摸屏幕时，音符就会播放：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now we need to set the `pitch` between 0 and 2 according to the X position
    of the touch:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要根据触摸的 X 位置设置 `pitch` 在 0 到 2 之间：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We set the `gain` property between 0 and 1 according to the Y position of the
    touch:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根据触摸的 Y 位置设置 `gain` 属性在 0 到 1 之间：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Tilting the device will set the `pan` property. Tilt to the left to hear all
    tones more in your left ear and to the right to hear them more in your right:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 摇动设备将设置 `pan` 属性。向左倾斜以在您的左耳听到更多音调，向右倾斜以在您的右耳听到更多音调：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see (and hear), audio properties can be modified in real time, while
    a sound is playing, to create really cool effects.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见（并可听到），在播放声音的同时，可以实时修改音频属性，以创建真正酷炫的效果。
- en: There's More...
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: The `@"synth_tone_mono.caf"` file used in this recipe is specifically encoded
    as a **mono** sound effect. This is because the **pan** property can only be set
    on a mono sound effect.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在此菜谱中使用的 `@"synth_tone_mono.caf"` 文件被特别编码为 **单声道** 音效。这是因为 **声像** 属性只能在单声道音效上设置。
- en: Fading sounds and music
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 淡化声音和音乐
- en: Taking a queue from Cocos2d actions, CocosDenshion provides a few classes for
    fading sounds and music. These are `CDLongAudioSourceFader` and `CDXPropertyModifierAction`.
    In this example, we will see how to fade in/out all sounds, individual sounds,
    and music. We will also see how to crossfade two music sources.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Cocos2d 动作中汲取灵感，CocosDenshion 提供了一些用于淡化声音和音乐的类。这些是 `CDLongAudioSourceFader`
    和 `CDXPropertyModifierAction`。在本例中，我们将看到如何淡化/取消淡化所有声音、单个声音和音乐，以及如何交叉淡化两个音乐源。
- en: '![Fading sounds and music](img/4002_06_03.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![淡化声音和音乐](img/4002_06_03.jpg)'
- en: Getting ready
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project RecipeCollection02 for full working code of this
    recipe.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目 RecipeCollection02 以获取此菜谱的完整工作代码。
- en: How to do it...
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Execute the following code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: In this recipe, we use `CDLongAudioSource` directly as opposed to using the
    `backgroundMusic` source provided by `SimpleAudioEngine`. This allows us to have
    more than one long audio source playing at a given time.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们直接使用 `CDLongAudioSource` 而不是使用 `SimpleAudioEngine` 提供的 `backgroundMusic`
    源。这允许我们在给定时间内播放多个长音频源。
- en: 'Crossfading long audio sources:'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交叉淡入长音频源：
- en: 'Crossfading involves fading one source in and one source out at the same time.
    First, we initialize a `CDLongAudioSourceFader` object to specify fading values
    and an interpolation type:'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 交叉淡入涉及同时淡入一个源和淡出一个源。首先，我们初始化一个 `CDLongAudioSourceFader` 对象来指定淡出值和插值类型：
- en: '[PRE15]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this case, we want to fade out linearly starting from the source''s current
    volume. We then create a `CDXPropertyModifierAction` object with specified duration.
    We also release the fader object at this point:'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，我们希望从源当前音量开始线性淡出。然后我们创建一个具有指定持续时间的 `CDXPropertyModifierAction` 对象。我们还在这一点上释放了淡出对象：
- en: '[PRE16]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After fading the track out, we want to stop it from playing. For this, we create
    a `CCCallFuncN` action:'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在淡出音轨后，我们希望停止其播放。为此，我们创建一个 `CCCallFuncN` 动作：
- en: '[PRE17]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, we run these actions in sequence:'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我们按顺序运行这些操作：
- en: '[PRE18]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Running this action, along with the "fade in" action for the other track, will
    create the desired crossfading effect.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行此操作，以及其他轨道的“淡入”操作，将创建所需的交叉淡入效果。
- en: 'Fading individual sound effects:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 淡出单个音效：
- en: 'The `CDXPropertyModifierAction` class has a convenience method for fading individual
    sound effects:'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`CDXPropertyModifierAction` 类提供了一个方便的方法来淡出单个音效：'
- en: '[PRE19]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the previous example, we fade out the specified sound source for 2 seconds
    and then stop the source from playing when we're finished.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在上一个例子中，我们淡出指定的音源 2 秒，然后在我们完成时停止音源播放。
- en: 'Fading out all sound effects:'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 淡出所有音效：
- en: 'All currently playing sound effects can be faded out as well using the following
    convenience method:'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所有当前正在播放的音效也可以使用以下方便方法淡出：
- en: '[PRE20]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This applies the same "fade out" effect to all playing sound effects.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将对所有正在播放的音效应用相同的“淡出”效果。
- en: Using audio in a game
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在游戏中使用音频
- en: While `SimpleAudioEngine` may be simple, it is efficient enough to be used in
    any type of game. In this recipe, we will add sounds and music to the **Bullets**
    demo from [Chapter 4](ch04.html "Chapter 4. Physics"),
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `SimpleAudioEngine` 可能很简单，但它足够高效，可以用于任何类型的游戏。在这个菜谱中，我们将向第 4 章中提到的 **子弹**
    演示（[ch04.html "第 4 章。物理"](ch04.html "Chapter 4. Physics")）添加音效和音乐，
- en: '![Using audio in a game](img/4002_06_04.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![在游戏中使用音频](img/4002_06_04.jpg)'
- en: Getting ready
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目 *RecipeCollection02* 以获取此菜谱的完整工作代码。
- en: How to do it...
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Execute the following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works...
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Using the techniques described in this chapter, we can breathe some life into
    our box-shooting demo by adding sounds and music.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本章中描述的技术，我们可以通过添加音效和音乐来给我们的射击盒演示增添一些活力。
- en: 'Sound buffers:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声音缓冲区：
- en: By default, `CDAudioManager` allocates one sound buffer per sound source. So,
    every time we play the `@"bullet_fire_no_shell.caf"` sound effect we effectively
    stop that sound effect from playing if it was already in the process of playing.
    This is adequate for the majority of in-game sound effect use cases.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认情况下，`CDAudioManager` 为每个音源分配一个声音缓冲区。因此，每次我们播放 `@"bullet_fire_no_shell.caf"`
    音效时，如果它已经在播放过程中，我们实际上会停止该音效的播放。这对于大多数游戏中的音效使用情况是足够的。
- en: There's more...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Finding sound effects to use in your game can be a fun yet tedious process.
    Even though there exists a large number of royalty free sound effects floating
    around, it''s often difficult to find the right one for a given situation. Alternatively,
    a microphone and some audio generation and manipulation software can go a long
    way. For example, the effect `@"bullet_casing_tink.caf"` was created by playing
    the highest note on a piano using GarageBand. Another program, **sfxr**, can be
    used to generate simple 8-bit style sound effects. The Cocoa version, **cfxr**,
    can be downloaded here: [http://thirdcog.eu/apps/cfxr](http://thirdcog.eu/apps/cfxr).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找适合你游戏使用的音效可能是一个既有趣又繁琐的过程。尽管存在大量的免费音效，但通常很难找到适合特定情况的正确音效。或者，一个麦克风和一些音频生成和操作软件可以大有帮助。例如，效果
    `@"bullet_casing_tink.caf"` 是通过使用 GarageBand 播放钢琴的最高音符创建的。另一个程序，**sfxr**，可以用来生成简单的
    8 位风格音效。Cocoa 版本，**cfxr**，可以在此处下载：[http://thirdcog.eu/apps/cfxr](http://thirdcog.eu/apps/cfxr)。
- en: Using positional audio in a game
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在游戏中使用位置音频
- en: To increase the realism of the sounds we use in a game, we can modify audio
    properties based on in-game factors. In this example, we use **source distance,
    audible range**, and **object size** to determine **gain, pitch**, and **pan**.
    We'll demonstrate this by adding sounds to the **TopDownIsometric** demo from
    [Chapter 4](ch04.html "Chapter 4. Physics"),
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加我们在游戏中使用的声音的真实感，我们可以根据游戏中的因素修改音频属性。在这个例子中，我们使用**源距离**、**可听范围**和**对象大小**来确定**增益**、**音调**和**声像**。我们将通过向[第4章](ch04.html
    "第4章。物理")中的**TopDownIsometric**演示添加声音来演示这一点，
- en: '![Using positional audio in a game](img/4002_06_05.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![游戏中使用位置音频](img/4002_06_05.jpg)'
- en: Getting ready
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅项目 *RecipeCollection02* 以获取此菜谱的完整工作代码。
- en: How to do it...
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Execute the following code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Creating a realistic soundscape involves changing audio properties in creative
    ways.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 创建逼真的声音环境涉及以创造性的方式改变音频属性。
- en: 'Forest ambience:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 森林氛围：
- en: 'For this recipe, we have a 30 second looping clip of forest ambience playing
    in place of background music. We determine the `gain` property of this sound source
    based on the player''s distance from the closest tree:'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们有一个30秒循环的森林氛围片段，代替背景音乐播放。我们根据玩家与最近树木的距离确定这个声音源的`增益`属性：
- en: '[PRE23]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If all trees are outside the audible range then we set the `gain` to zero.
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果所有树木都在可听范围内，则将`增益`设置为零。
- en: 'Ball bounce sounds:'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 球弹跳声音：
- en: 'To create a compelling ball bounce sound effect, we modify all three audio
    properties. The `gain` property is determined by distance:'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了创建一个引人入胜的球弹跳声音效果，我们修改了所有三个音频属性。`增益`属性由距离决定：
- en: '[PRE24]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `pan` property is determined by X plane distance:'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`声像`属性由X平面的距离决定：'
- en: '[PRE25]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, the `pitch` property is determined by the ball''s size:'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，`音调`属性由球的大小决定：
- en: '[PRE26]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Together, these modifications create a variety of unique sounds. This adds depth
    to the auditory experience.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些修改共同创造了一系列独特的声音。这增加了听觉体验的深度。
- en: 'Using multiple sound buffers:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多个声音缓冲区：
- en: 'Because we have multiple balls initiating bounce sound effects at the same
    time, a single buffer will no longer suffice. We now need the same sound to play
    over itself many times. To accomplish this we use a special **Source Group**.
    A source group is simply a way to group sounds together to manipulate how they
    get played. For example, you might want two sound sources to share a buffer. In
    this case, we specify a source group as being non-interruptible:'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们同时有多个球启动弹跳声音效果，单个缓冲区将不再足够。我们现在需要同一个声音多次播放。为了实现这一点，我们使用一个特殊的**源组**。源组只是将声音分组在一起以操纵它们如何播放的一种方式。例如，你可能希望两个声音源共享一个缓冲区。在这种情况下，我们指定源组为不可中断：
- en: '[PRE27]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, all sounds played using this source group will be given an open buffer.
    To specify a source group when playing a sound we use the following line:'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，使用此源组播放的所有声音都将获得一个开放缓冲区。要指定在播放声音时使用源组，我们使用以下行：
- en: '[PRE28]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, multiple ball bounce sound effects can be heard over each other with different
    audio properties.
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，可以听到多个具有不同音频属性的球弹跳声音效果相互重叠。
- en: 'Maximum number of buffers:'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓冲区最大数量：
- en: 'The maximum number of sound buffers available and the buffer increment is specified
    in `CDConfig.h`:'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可用的最大声音缓冲区数量和缓冲区增量在`CDConfig.h`中指定：
- en: '[PRE29]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the default case, after 64 buffers are filled up, another 16 are allocated.
    These can be customized for applications with specific audio requirements.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在默认情况下，在64个缓冲区填满后，再分配16个。这些可以根据具有特定音频要求的应用程序进行自定义。
- en: Metering background music
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测量背景音乐
- en: The `CDAudioManager` class wraps the `AVAudioPlayer` class. Using this class
    gives us access to lower level audio functions. In this recipe, we will dynamically
    read the **average level** and **peak level** of background music currently playing.
    We can use this information to sync or cue animations.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`CDAudioManager`类封装了`AVAudioPlayer`类。使用这个类我们可以访问更底层的音频功能。在这个菜谱中，我们将动态读取当前播放的背景音乐的**平均电平**和**峰值电平**。我们可以使用这些信息来同步或提示动画。'
- en: '![Metering background music](img/4002_06_06.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![测量背景音乐](img/4002_06_06.jpg)'
- en: Getting ready
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅项目 *RecipeCollection02* 以获取此菜谱的完整工作代码。
- en: How to do it...
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Execute the following code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works...
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Accessing the dynamic metering functionality requires the use of the `audioSourcePlayer`
    reference inside a `CDLongAudioSource` object, in this case, `backgroundMusic`.
    Before we can begin, we enable metering:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 访问动态计测功能需要在 `CDLongAudioSource` 对象内部使用 `audioSourcePlayer` 引用，在本例中，`backgroundMusic`。在我们开始之前，我们启用计测：
- en: '[PRE31]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, every cycle we collect the **average** and **peak** decibel levels for
    all playing channels. We average these numbers out:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们每周期收集所有播放通道的**平均**和**峰值**分贝水平。我们平均这些数字：
- en: '[PRE32]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: After that we convert our average and peak decibel levels to ratios between
    0 and 1\. This makes the numbers easier to apply to animations.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将平均和峰值分贝水平转换为0到1之间的比率。这使得数字更容易应用于动画。
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We also split the difference when setting the new `peakPower` and `avgPower`
    variables. This smooths out harsh changes in volume.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置新的 `peakPower` 和 `avgPower` 变量时，我们也分割差异。这使音量变化更加平滑。
- en: Metering dialogue for animation
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画计测对话框
- en: A `LongAudioSource` object can be any kind of audio, not just music. In this
    recipe, we will use the metering technique to animate the mouth of the gregarious
    Senator Beauregard Claghorn.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`LongAudioSource` 对象可以是任何类型的音频，而不仅仅是音乐。在这个配方中，我们将使用计测技术来动画化社交的参议员Beauregard
    Claghorn的嘴巴。'
- en: '![Metering dialogue for animation](img/4002_06_07.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![动画计测对话框](img/4002_06_07.jpg)'
- en: Getting ready
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅项目 *RecipeCollection02* 以获取此配方的完整工作代码。
- en: How to do it...
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Execute the following code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE34]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How it works...
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Like in the previous recipe, we use the information collected from `setPeakAndAveragePower`
    to run an animation. Unlike the previous recipe, we have a number of `CDLongAudioSource`
    objects to choose from. Here, we find the source that is currently playing and
    use it for metering:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的配方类似，我们使用从 `setPeakAndAveragePower` 收集的信息来运行动画。与之前的配方不同，我们有多个 `CDLongAudioSource`
    对象可供选择。在这里，我们找到当前正在播放的源，并用于计测：
- en: '[PRE35]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'After calculating `avgPower`, we then exaggerate the peaks and valleys of that
    number to help simulate the rapid opening and closing of Claghorn''s mouth:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算 `avgPower` 之后，我们然后夸大该数字的峰值和谷值，以帮助模拟Claghorn嘴巴的快速张合：
- en: '[PRE36]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In addition to this, we animate blinking, eye movement, and eyebrows. Put together,
    the linking of multiple animations with metering creates a nice mouth movement
    effect.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还动画化眨眼、眼球移动和眉毛。将这些动画与计测链接起来，可以创建一个很好的嘴巴运动效果。
- en: Streaming audio
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流式音频
- en: In [Chapter 1](ch01.html "Chapter 1. Graphics"), *Graphics*, we used the `MPMoviePlayerController`
    class to play full motion video. In this recipe, we will use a similar technique
    to create a streaming audio player.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章。图形")，*图形*中，我们使用了 `MPMoviePlayerController` 类来播放全动作视频。在这个配方中，我们将使用类似的技术来创建流式音频播放器。
- en: '![Streaming audio](img/4002_06_08.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![流式音频](img/4002_06_08.jpg)'
- en: Getting ready
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅项目 *RecipeCollection02* 以获取此配方的完整工作代码。
- en: How to do it...
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Link the `MediaPlayer` framework to your project. Now, execute the following
    code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `MediaPlayer` 框架链接到您的项目中。现在，执行以下代码：
- en: '[PRE37]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How it works...
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'This recipe works in a way similar to that of what we saw in [Chapter 1](ch01.html
    "Chapter 1. Graphics"), *Graphics*. One key difference is, here we specify the
    `mediaSourceType`, and we also hide the player from view:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的工作方式与我们之前在[第1章](ch01.html "第1章。图形")中看到的类似，即*图形*。一个关键的区别是，在这里我们指定了 `mediaSourceType`，并且我们还隐藏了播放器视图：
- en: '[PRE38]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This sets up the player for audio streaming.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这设置了播放器进行音频流。
- en: Reaching the `AppDelegate:`
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 达到 `AppDelegate:`
- en: 'In **Cocos2d**, the `AppDelegate` class is the top-level class that implements
    the `UIApplicationDelegate` protocol. This protocol specifies the delegate to
    which the main `UIApplication` singleton points to. This delegate handles important
    application events. To add our `moviePlayer` object to our view, we access this
    delegate through the `UIApplication` singleton:'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 **Cocos2d** 中，`AppDelegate` 类是实现 `UIApplicationDelegate` 协议的最高级类。该协议指定了主 `UIApplication`
    单例指向的委托。这个委托处理重要应用程序事件。为了将我们的 `moviePlayer` 对象添加到我们的视图中，我们通过 `UIApplication` 单例访问这个委托：
- en: '[PRE39]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As you can see, this involves **casting** the `delegate` property into the `AppDelegate*`
    type.
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，这涉及到将 `delegate` 属性**转换为** `AppDelegate*` 类型。
- en: 'Switching stations:'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切换电台：
- en: 'Changing the streaming source involves stopping playback and changing the `contentURL`
    property:'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更改流源涉及停止播放并更改`contentURL`属性：
- en: '[PRE40]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This way the user can change channels seamlessly while maintaining playback.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这样用户可以在保持播放的同时无缝切换频道。
- en: 'Live streaming formats:'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时流格式：
- en: 'The stream source examples used in this recipe use Apple''s **HTTP Live Streaming**
    protocol. This allows elegant live streaming over **HTTP** with minimum hassle.
    You can read more about this protocol here: [http://developer.apple.com/resources/http-streaming/](http://developer.apple.com/resources/http-streaming/).'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本食谱中使用的流源示例使用苹果的**HTTP实时流**协议。这允许通过**HTTP**进行优雅的实时流传输，且无需太多麻烦。您可以在此处了解更多关于此协议的信息：[http://developer.apple.com/resources/http-streaming/](http://developer.apple.com/resources/http-streaming/)。
- en: 'Streaming files:'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流式传输文件：
- en: Single files, using formats like **MP3**, can also be streamed over a simple
    **HTTP** server using this technique.
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 单个文件，使用如**MP3**的格式，也可以使用此技术通过简单的**HTTP**服务器进行流式传输。
- en: 'Streaming video:'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流式传输视频：
- en: By combining this recipe with the video playback recipe in Chapter 1, Graphics,
    you can also stream video. Compatible formats and other requirements are detailed
    at the aforementioned site. As a good rule of thumb, any file type or URL that
    can be played using the iOS device's built in **Safari** web browser can usually
    also be played using `MPMoviePlayerController`.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过将此食谱与第1章“图形”中的视频播放食谱相结合，您还可以进行视频流式传输。兼容格式和其他要求在上文提到的网站上详细说明。作为一个好的经验法则，任何可以使用iOS设备内置**Safari**网络浏览器播放的文件类型或URL通常也可以使用`MPMoviePlayerController`播放。
- en: There's more...
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Previously, we mentioned the `UIApplication` **singleton**. A singleton is a
    top-level global object instantiated at runtime. Cocos2d largely embraces the
    singleton pattern. Any object accessed by executing a class method starting with
    the word "shared" ([Class `sharedClass])` is, by convention, a singleton. You
    can create your own custom singleton objects using the **macro** encapsulated
    in the `SynthesizeSingleton.h` file. For more information about this, please consult
    the *More Recipes* section of the **Cocos2d Cookbook website** at [http://cocos2dcookbook.com/more_recipes](http://cocos2dcookbook.com/more_recipes).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 此前，我们提到了`UIApplication`**单例**。单例是在运行时实例化的顶级全局对象。Cocos2d在很大程度上采用了单例模式。按照惯例，通过以“shared”一词开头的类方法（[类`sharedClass`]）访问的任何对象都是单例。您可以使用包含在`SynthesizeSingleton.h`文件中的**宏**创建自己的自定义单例对象。有关更多信息，请参阅**Cocos2d食谱网站**的“更多食谱”部分，网址为[http://cocos2dcookbook.com/more_recipes](http://cocos2dcookbook.com/more_recipes)。
- en: Recording audio
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 录音音频
- en: A notable feature on most iOS devices is the ability to record audio. In this
    recipe, we will use the microphone to record audio and save it to a temporary
    location on the disk using the `AVAudioRecorder` class. We will then play it back
    with a modified pitch using the `CDSoundEngine` class.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数iOS设备的一个显著特性是能够录音。在这个食谱中，我们将使用麦克风录音并将音频保存到磁盘上的临时位置，使用`AVAudioRecorder`类。然后我们将使用`CDSoundEngine`类以修改后的音高播放它。
- en: '![Recording audio](img/4002_06_09.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![录音音频](img/4002_06_09.jpg)'
- en: Getting ready
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目*RecipeCollection02*以获取本食谱的完整工作代码。
- en: How to do it...
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Link the `CoreAudio` and `AVFoundation` frameworks to your project. Now, execute
    the following code:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 将`CoreAudio`和`AVFoundation`框架链接到您的项目中。现在，执行以下代码：
- en: '[PRE41]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: How it works...
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Recording and playing back audio will introduce us to a few new classes and
    concepts.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 录音和播放音频将向我们介绍一些新的类和概念。
- en: 'Initializing the audio session:'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化音频会话：
- en: 'Because we want to record audio, we have to set up a specific **audio session**.
    An audio session is a way of configuring the settings we will currently use for
    audio input and output. The `AVAudioSession` singleton encapsulates this functionality.
    First, we need to set up the **session category** to allow recording and playback:'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因为我们想录音，所以我们必须设置一个特定的**音频会话**。音频会话是一种配置我们将要使用的音频输入和输出设置的途径。`AVAudioSession`单例封装了这一功能。首先，我们需要设置**会话类别**以允许录音和播放：
- en: '[PRE42]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then we need to activate the session:'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后我们需要激活会话：
- en: '[PRE43]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: CocosDenshion normally does these things, but in this recipe, we need more granular
    control over the audio system.
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: CocosDenshion通常做这些事情，但在这个食谱中，我们需要对音频系统有更细粒度的控制。
- en: 'Initializing CDSoundEngine:'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化CDSoundEngine：
- en: 'Here we also initialize a `CDSoundEngine` object:'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们还初始化了一个`CDSoundEngine`对象：
- en: '[PRE44]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We will use this to play back our recorded audio.
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用它来播放我们录制的音频。
- en: 'Recording audio:'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 录制音频：
- en: 'The crux of the recipe, recording the audio, requires a few steps. First, we
    initialize the `AVAudioRecorder` object with the audio recording format and where
    we want to store our recorded audio:'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 配方的核心，录制音频，需要几个步骤。首先，我们使用音频录制格式和我们要存储录制的音频的位置初始化`AVAudioRecorder`对象：
- en: '[PRE45]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We specify our delegate object:'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们指定我们的代理对象：
- en: '[PRE46]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Finally, we start recording:'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我们开始录音：
- en: '[PRE47]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Recording will last until we call the stop routine:'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 录制将持续到我们调用停止例程：
- en: '[PRE48]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Recording will not stop until either the recorder receives a `stop` message
    or the delegate receives an error. For example, the disk could be full.
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记录将不会停止，直到记录器收到`stop`消息或代理收到错误。例如，磁盘可能已满。
- en: 'The `AVAudioRecorderDelegate` protocol:'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AVAudioRecorderDelegate`协议：'
- en: By specifying our `Ch6_RecordingAudio` class as adhering to the `AVAudioRecorderDelegate`
    protocol, we agree to handle a number of method calls including errors. If we
    fail to do so, these errors are thrown. In this example, we bypass this step for
    the sake of brevity, but in a professional app it is recommended that you handle
    any messages the `AVAudioRecorder` class might want to pass on.
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过指定我们的`Ch6_RecordingAudio`类遵循`AVAudioRecorderDelegate`协议，我们同意处理包括错误在内的一系列方法调用。如果我们未能这样做，这些错误将被抛出。在这个例子中，为了简洁起见，我们跳过了这一步，但在一个专业的应用程序中，建议您处理`AVAudioRecorder`类可能想要传递的任何消息。
- en: 'Playing our recorded audio:'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放我们录制的音频：
- en: 'Once the recorded audio is stored on the disk, we can play it back. On the
    iPhone the speaker output is re-routed to the earbud speaker when the audio session
    category is `AVAudioSessionCategoryPlayAndRecord`. So, before we can properly
    play back the recorded audio we must reroute playback to the speakers:'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦录制的音频存储在磁盘上，我们就可以播放它。在iPhone上，当音频会话类别为`AVAudioSessionCategoryPlayAndRecord`时，扬声器输出会被重定向到耳机扬声器。因此，在我们能够正确播放录制的音频之前，我们必须将播放重定向到扬声器：
- en: '[PRE49]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, using `CDSoundEngine`, we can load the recorded audio into a buffer and
    play it back:'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，使用`CDSoundEngine`，我们可以将录制的音频加载到缓冲区并播放它：
- en: '[PRE50]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In the above line, the **pitch, pan,** and **gain** properties can be modified.
    In this example, you can modify the pitch. Try recording your voice and then bending
    the pitch.
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在上述行中，可以修改**音调、平衡**和**增益**属性。在这个例子中，您可以修改音调。尝试录制您的声音，然后改变音调。
- en: Using the iPod music library
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用iPod音乐库
- en: Sometimes a user might want to substitute a musical track from his or her personal
    collection into the background of your game. In this example, we will create a
    simple music player that can load songs, albums, and playlists from the **iPod
    music library** on the device.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 有时用户可能希望将他们个人收藏中的音乐曲目添加到游戏的背景中。在这个例子中，我们将创建一个简单的音乐播放器，可以从设备上的**iPod音乐库**中加载歌曲、专辑和播放列表。
- en: '![Using the iPod music library](img/4002_06_10.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![使用iPod音乐库](img/4002_06_10.jpg)'
- en: Getting ready
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅项目*RecipeCollection02*以获取此配方的完整工作代码。
- en: How to do it...
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Link the `MediaPlayer` framework to your project. Now, execute the following
    code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 将`MediaPlayer`框架链接到您的项目中。现在，执行以下代码：
- en: '[PRE51]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: How it works...
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Pressing the green button opens the standard iPod media picker. Some games opt
    to create their own picker to better match their user interface. In this example,
    we chose the default media picker for the sake of simplicity.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 按下绿色按钮将打开标准iPod媒体选择器。有些游戏选择创建自己的选择器以更好地匹配他们的用户界面。在这个例子中，我们为了简单起见选择了默认媒体选择器。
- en: Initializing `MPMusicPlayerController:`
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化`MPMusicPlayerController`：
- en: 'First, we create our `MPMusicPlayerController` object:'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，我们创建我们的`MPMusicPlayerController`对象：
- en: '[PRE52]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We set our player to `MPMusicRepeatModeAll`, so our `nextSong` and `previousSong`methods
    can wrap playing songs.
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将播放器设置为`MPMusicRepeatModeAll`，这样我们的`nextSong`和`previousSong`方法就可以循环播放歌曲。
- en: 'Getting **Now Playing** audio information:'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取**现在播放**音频信息：
- en: 'Every time the **Now Playing** item changes, we would like to be notified so
    we can fetch media information. To do this, we set our recipe object as an observer
    of the `musicPlayer` object and allow this type of notification to be received:'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每当**现在播放**项目发生变化时，我们希望得到通知，以便我们可以获取媒体信息。为此，我们将我们的配方对象设置为`musicPlayer`对象的观察者，并允许接收此类通知：
- en: '[PRE53]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'As an observer, our class will be notified by a call to the `handleNowPlayingItemChanged`
    method. Here, we inspect the currently playing `MPMediaItem` object for information
    including song title, artist name, album name, and album art:'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 作为观察者，我们的类将通过调用 `handleNowPlayingItemChanged` 方法得到通知。在这里，我们检查当前播放的 `MPMediaItem`
    对象，以获取包括歌曲标题、艺术家姓名、专辑名称和专辑封面在内的信息：
- en: '[PRE54]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We then take this created `UIImage` object and place it into the scene using
    a technique described in Chapter 1, Graphics
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们将创建的 `UIImage` 对象放入场景中，使用第 1 章中描述的技术。
- en: Using `MPMediaPickerController:`
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '使用 `MPMediaPickerController:` '
- en: 'When a user touches the green button, then we initialize a `MPMediaPickerController`
    object and specify its delegate:'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当用户触摸绿色按钮时，我们初始化一个 `MPMediaPickerController` 对象并指定其代理：
- en: '[PRE55]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We then add the picker to the screen presenting it as a ''modal view''. This
    lets us animate the picker sliding onto the screen:'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们将选择器添加到屏幕上，以“模式视图”的形式展示它。这让我们可以动画化选择器滑入屏幕：
- en: '[PRE56]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: With the picker open the user can choose from songs, playlists, albums, and
    so on.
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当选择器打开时，用户可以从歌曲、播放列表、专辑等中进行选择。
- en: The `MPMediaPickerControllerDelegate:`
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MPMediaPickerControllerDelegate:` '
- en: 'In accordance with this delegate, we implement the following methods:'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 遵循此代理，我们实现了以下方法：
- en: '[PRE57]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'These correspond to picking at least one item and picking none respectively.
    Upon picking an item or more we dismiss the modal view, add items to our player,
    and then play the first item:'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些对应于至少选择一个项目和选择零个项目的情况。在选择一个或多个项目后，我们关闭模式视图，将项目添加到我们的播放器中，然后播放第一个项目：
- en: '[PRE58]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: If the user did not pick an item, we simple dismiss the modal view controller.
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果用户没有选择任何项目，我们简单地关闭模式视图控制器。
- en: There's more...
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `MPMusicPlayerController` class is actually accessing the iPod functionality
    of the device you''re currently using. Having your app access an external resource,
    adds a couple of extra conditions we need to account for:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`MPMusicPlayerController` 类实际上正在访问你当前使用的设备的 iPod 功能。让你的应用程序访问外部资源，增加了我们需要考虑的几个额外条件：'
- en: 'Determining the current device type:'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定当前设备类型：
- en: 'As you can see from the previous code, or if you tried running this recipe
    in the simulator, we disable this recipe entirely when not running on a real device.
    We do this because the iPod music player app is not installed on the simulator
    and this will cause errors to be thrown. Determining the device model is simple:'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您从前面的代码中看到的那样，或者如果您在模拟器中尝试运行此配方，我们将在非真实设备上完全禁用此配方。我们这样做是因为模拟器上没有安装 iPod 音乐播放器应用程序，这会导致抛出错误。确定设备型号很简单：
- en: '[PRE59]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This string will tell you what model your app is running on. In our case we
    check for the string @"iPhone Simulator".
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这条字符串会告诉你你的应用程序正在运行什么型号。在我们的例子中，我们检查字符串 @"iPhone Simulator"。
- en: 'The `UIApplicationDelegate` protocol:'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UIApplicationDelegate` 协议：'
- en: 'Another side effect of using the iPod resource is that music will continue
    to play after suspending our application. Although you can switch to the iPod
    app itself to stop the playing music, we would like to stop it when we suspend
    our app and resume it when we bring the app back. In AppDelegate.mm, our application
    implements some methods specified by the UIApplicationDelegate protocol:'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 iPod 资源的一个副作用是，在挂起我们的应用程序后，音乐将继续播放。虽然你可以切换到 iPod 应用本身来停止播放的音乐，但我们希望在挂起我们的应用程序时停止它，并在将应用程序恢复时继续播放。在
    AppDelegate.mm 中，我们的应用程序实现了由 UIApplicationDelegate 协议指定的某些方法：
- en: '[PRE60]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Normally, Cocos2d only calls pause and resume on the CCDirector singleton here.
    We will add code to pause the iPod music player upon suspension and play it upon
    activation:'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通常，Cocos2d 只在这里调用 pause 和 resume。我们将添加代码在挂起 iPod 音乐播放器时暂停它，在激活时播放它：
- en: '[PRE61]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Other code can go here as needed.
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据需要，可以在这里添加其他代码。
- en: Creating a MIDI synthesizer
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 MIDI 合成器
- en: With the release of iOS 4.0 the iPhone, iPad, and iPod Touch can now take advantage
    of the powerful **MIDI** protocol. For games that allow the user to generate their
    own sounds and music, or for a game that wants a cool retro sound without a large
    memory footprint, MIDI synthesization is the tool for the job. In this recipe,
    we will create a MIDI synthesizer using the great **MobileSynth** library.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 iOS 4.0 的发布，iPhone、iPad 和 iPod Touch 现在可以利用强大的 **MIDI** 协议。对于允许用户生成自己的声音和音乐的游戏，或者对于想要酷炫复古声音但内存占用不大的游戏，MIDI
    合成是完成这项工作的工具。在这个配方中，我们将使用出色的 **MobileSynth** 库创建 MIDI 合成器。
- en: '![Creating a MIDI synthesizer](img/4002_06_11.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![创建 MIDI 合成器](img/4002_06_11.jpg)'
- en: Getting ready
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目*RecipeCollection02*以获取此菜谱的完整工作代码。
- en: How to do it...
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Link the `AudioToolbox` framework to your project. Now, execute the following
    code:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 将`AudioToolbox`框架链接到你的项目中。现在，执行以下代码：
- en: '[PRE62]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: How it works...
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe lets you play two **octaves** of synthesized sounds on a virtual
    keyboard.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱让你能在虚拟键盘上播放两个**八度**的合成声音。
- en: 'The `MIDISampleGenerator` class:'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MIDISampleGenerator`类：'
- en: The `MIDISampleGenerator` class was created specifically for this recipe so
    as to obfuscate some of the grittier details of using MobileSynth. The MobileSynth
    library offers a dizzying array of sound synthesization options to generate sounds.
    These include, to name a few, Modulation, Oscillation, Filter, Arpeggio, and a
    few volume related effects. The **Randomize** button randomizes a number of these
    effects to quickly and easily allow the user to get a feel for the range of synthesization
    possibilities.
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`MIDISampleGenerator`类是专门为这个菜谱创建的，以便模糊使用MobileSynth的一些更粗糙的细节。MobileSynth库提供了一系列令人眼花缭乱的音效合成选项来生成声音。其中包括，仅举几个例子，调制、振荡、滤波、琶音以及一些与音量相关的效果。**随机化**按钮随机化这些效果中的一系列，以便用户能够快速轻松地了解合成化可能性的范围。'
- en: 'Extending the synthesizer:'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展合成器：
- en: Presumably, the synthesizer could be extended to record a song (a series of
    timed notes) to a data file that could then be fed into the synthesizer like a
    player piano. This acts as an easy solution for generating a large amount of retro
    sounding game music that doesn't take up much space (think Mega Man). The same
    thing goes for sound effects.
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 想象一下，合成器可以扩展到将一首歌（一系列定时音符）记录到数据文件中，然后像自动钢琴一样将其输入合成器。这可以作为生成大量复古风格的电子游戏音乐的一种简单解决方案，而这些音乐不会占用太多空间（想想《Mega
    Man》）。同样的情况也适用于音效。
- en: There's more...
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: 'For more information about **MobileSynth** you can visit their website: [http://code.google.com/p/mobilesynth/](http://code.google.com/p/mobilesynth/)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 关于**MobileSynth**的更多信息，您可以访问他们的网站：[http://code.google.com/p/mobilesynth/](http://code.google.com/p/mobilesynth/)
- en: Speech recognition and text-to-speech
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语音识别和文本到语音
- en: Until a fateful combination of machine learning, quantum computing, and 3D printing
    spawns tyrannical artificial lifeforms to rule over all mankind, we need to settle
    for semi-intelligent devices that we program by hand. An important piece of that
    puzzle is language processing. In this recipe, we will use the **OpenEars** library
    to have our iOS device speak and recognize some basic English dialogue.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器学习、量子计算和3D打印的宿命组合孕育出统治全人类的暴政人工智能生命体之前，我们需要满足于半智能设备，这些设备是我们手动编程的。这个谜团中的重要部分是语言处理。在这个菜谱中，我们将使用**OpenEars**库让我们的iOS设备说话并识别一些基本的英语对话。
- en: '![Speech recognition and text-to-speech](img/4002_06_12.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![语音识别和文本到语音](img/4002_06_12.jpg)'
- en: Getting ready
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Due to the size of the libraries required to use **OpenEars**, this recipe has
    its own project. Please refer to the project *Ch6_SpeechRecognition* for full
    working code of this recipe.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用**OpenEars**所需的库大小，这个菜谱有自己的项目。请参考项目*Ch6_SpeechRecognition*以获取此菜谱的完整工作代码。
- en: How to do it...
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The **OpenEars** installation process is complex. Among other things it requires
    the configuration of four other libraries: **flite, pocketsphinx, sphinxbase**,
    and **wince**. The OpenEars library is itself an embedded XCode project that is
    statically linked to your project.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '**OpenEars**的安装过程很复杂。其中之一是它需要配置四个其他库：**flite、pocketsphinx、sphinxbase**和**wince**。OpenEars库本身是一个嵌入的XCode项目，该项目与你的项目静态链接。'
- en: It is recommended that you take a look at the `Ch6_SpeechRecognition` project
    first. From there, you can carefully follow the steps listed at [http://www.politepix.com/openears/](http://www.politepix.com/openears/)
    to set up and configure the sample project.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 建议您首先查看`Ch6_SpeechRecognition`项目。从那里，您可以仔细遵循[http://www.politepix.com/openears/](http://www.politepix.com/openears/)上列出的步骤来设置和配置示例项目。
- en: 'After following the steps listed on the "Getting Started" and "Configuring
    Your App For OpenEars" pages you can move on to the "Using OpenEars In Your App"
    page. Here you will be instructed to create a **corpus** file. This is a file
    with all the words and phrases we want OpenEars to recognize. Our corpus file
    looks like this:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在遵循“入门”和“为OpenEars配置你的应用”页面上的步骤之后，你可以转到“在应用中使用OpenEars”页面。在这里，你将被告知创建一个**语料库**文件。这是一个包含我们希望OpenEars识别的所有单词和短语的文件。我们的语料库文件看起来像这样：
- en: '[PRE63]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We then upload this file to the **Sphinx** Knowledge Base creation tool hosted
    by Carnegie Mellon University at this URL: [http://www.speech.cs.cmu.edu/tools/lmtool-new.html](http://www.speech.cs.cmu.edu/tools/lmtool-new.html).
    The tool will generate a number of files for you. Take the `.lm` file and rename
    it to a `.languagemodel` file. Also download the `.dic` file. Add these files
    to your project as outlined here: [http://www.politepix.com/openears/yourapp/](http://www.politepix.com/openears/yourapp/).'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将此文件上传到卡内基梅隆大学提供的**Sphinx**知识库创建工具，网址为：[http://www.speech.cs.cmu.edu/tools/lmtool-new.html](http://www.speech.cs.cmu.edu/tools/lmtool-new.html)。该工具将为您生成多个文件。将`.lm`文件重命名为`.languagemodel`文件。同时下载`.dic`文件。按照以下说明将这些文件添加到您的项目中：[http://www.politepix.com/openears/yourapp/](http://www.politepix.com/openears/yourapp/)。
- en: 'We''re now ready to start coding. Our main piece of code will give the user
    some self-assured HAL 9000 responses:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好开始编码了。我们主要的代码片段将给用户一些自信的HAL 9000响应：
- en: '[PRE64]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: How it works...
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Try saying a few of the lines from the corpus file into the demo app. In a quiet
    room the results can be startlingly accurate.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将语料库文件中的几行话输入到演示应用中。在安静的房间里，结果可以非常准确。
- en: 'Instantiating the audio session, the controllers, and the observer:'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例化音频会话、控制器和观察者：
- en: 'Before we can do anything we need to instatiate the audio session as well as
    the three controllers that provide text to speech and speech recognition functionality:'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们能够做任何事情之前，我们需要实例化音频会话以及提供文本到语音和语音识别功能的三个控制器：
- en: '[PRE65]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The `PocketsphinxController` object provides the speech recognition API. The
    `FliteController` object provides the text to speech API. Finally, the `OpenEarsEventsObserver`
    provides a protocol that delegates callbacks on behalf of both controllers.
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`PocketsphinxController`对象提供了语音识别API。`FliteController`对象提供了文本到语音API。最后，`OpenEarsEventsObserver`提供了一个协议，代表两个控制器进行回调。'
- en: 'Using FliteController:'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用FliteController：
- en: The `FliteController` API is very straightforward. Simply call the say method
    and Flite will produce computer-generated speech through the default audio channels.
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`FliteController` API非常简单直接。只需调用say方法，Flite将通过默认音频通道生成计算机语音。'
- en: 'Using PocketsphinxController:'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PocketsphinxController：
- en: 'The `PocketsphinxController` API allows you to manage when Pocketsphinx is
    listening and when it is actively trying to recognize speech using the following
    four methods:'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`PocketsphinxController` API允许您使用以下四个方法来管理Pocketsphinx何时监听以及何时积极尝试识别语音：'
- en: '[PRE66]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This basic level of control lets you manage when processor time is used to actually
    attempt to recognize a speech pattern.
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种基本级别的控制让您能够管理何时使用处理器时间实际尝试识别语音模式。
- en: 'The `OpenEarsEventsObserverDelegate` protocol:'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OpenEarsEventsObserverDelegate`协议：'
- en: 'This protocol is in charge of calling a number of methods on behalf of `PocketsphinxController`
    and `FliteController`. The important method to take note of is the main Pocketsphinx
    speech recognition hypothesis method. This will tell you what Pocketsphinx heard
    and it will also give it a confidence score:'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此协议负责代表`PocketsphinxController`和`FliteController`调用多个方法。需要特别注意的重要方法是主Pocketsphinx语音识别假设方法。这将告诉你Pocketsphinx听到了什么，并且还会给它一个置信度分数：
- en: '[PRE67]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This method will be triggered by any discrete sound as long as Pocketsphinx
    is listening and attempting recognition. However, you can use the `recognitionScore`
    to weed out background noises and other
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当Pocketsphinx正在监听并尝试识别时，此方法将由任何离散声音触发。然而，您可以使用`recognitionScore`来过滤掉背景噪音和其他
