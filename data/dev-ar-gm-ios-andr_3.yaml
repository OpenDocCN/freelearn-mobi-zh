- en: Chapter 3. Understanding Vuforia
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 理解Vuforia
- en: In this chapter we will go over the components Vuforia provides with the SDK,
    and how to construct an AR scene. The addition of the SDK to a project will be
    covered, and how to include and activate the trackable data to be recognized in
    the app. We will create a very simple project from scratch similar to the example
    project provided by Vuforia to see how all the components fit together.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍Vuforia SDK提供的组件以及如何构建AR场景。将SDK添加到项目中的方法以及如何包含和激活应用中要识别的可追踪数据将得到介绍。我们将从头创建一个非常简单的项目，类似于Vuforia提供的示例项目，以了解所有组件是如何组合在一起的。
- en: Creating a Unity project with Vuforia
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Vuforia创建Unity项目
- en: From the previous chapter, we know how to create a project easily from Unity.
    Do not forget to exclude any spaces in the project name. This will create an empty
    project that we can build our AR app on.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一章，我们知道如何从Unity中轻松创建一个项目。不要忘记在项目名称中排除任何空格。这将创建一个空项目，我们可以在其上构建我们的AR应用。
- en: By default, Unity projects are created preset to the PC and Mac stand-alone
    platform. We need to change that to iOS. The current platform is always visible
    on the window title bar on the top.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Unity项目是预设为PC和Mac独立平台的。我们需要将其更改为iOS。当前平台始终在窗口标题栏的顶部可见。
- en: Tip
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.packtpub.com](http://www.packtpub.com)的账户下载您购买的所有Packt书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。
- en: The following screenshot shows platform switching.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了平台切换。
- en: '![Creating a Unity project with Vuforia](img/0032_3_1.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![使用Vuforia创建Unity项目](img/0032_3_1.jpg)'
- en: After switching the platform, it is time to add the Vuforia SDK to our project.
    To do that, click on the **Asset** menu in the menu bar, then inside **Import
    package ...**, click on **custom package**. This is exactly the same way we imported
    the sample project from Vuforia to our project.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在切换平台后，是时候将Vuforia SDK添加到我们的项目中了。为此，点击菜单栏中的**资产**菜单，然后在**导入包 ...**内部点击**自定义包**。这正是我们将Vuforia示例项目导入到我们项目中的方式。
- en: 'Now find where Vuforia SDK was installed and choose the Vuforia Unity package
    to be imported into the project. The following screenshot shows the importing
    of a Vuforia package:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在找到Vuforia SDK的安装位置，并选择要导入到项目中的Vuforia Unity包。以下截图显示了导入Vuforia包的过程：
- en: '![Creating a Unity project with Vuforia](img/0032_3_2.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![使用Vuforia创建Unity项目](img/0032_3_2.jpg)'
- en: Now that the entire Vuforia library has been added to the project, we can start
    looking at the components that comes with it. All that makes a Vuforia project
    is within the **Qualcomm Augmented Reality** folder inside the project. This folder
    will contain all the scripts that control the behavior of the AR experience. Not
    only scripts, but some shaders and textures as well. They are mainly used for
    the video background rendering of the AR app.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经将整个Vuforia库添加到项目中，我们可以开始查看它所包含的组件。所有构成Vuforia项目的组件都在项目中的**Qualcomm增强现实**文件夹内。这个文件夹将包含控制AR体验行为的所有脚本。不仅包括脚本，还有一些着色器和纹理。它们主要用于AR应用的视频背景渲染。
- en: Fortunately, we don't have to deal directly with most of those scripts, as Vuforia
    bundles the necessary components in Unity prefabs ready to be dropped into the
    scene.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们不必直接处理大多数这些脚本，因为Vuforia将必要的组件捆绑在Unity预制件中，可以直接将其拖放到场景中。
- en: Vuforia prefabs
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vuforia预制件
- en: A **prefab** is essentially a type of asset that is created in Unity to be a
    reusable game object stored in Project view. Prefabs can be inserted as many times
    as we want into the scene and with any object transformation applied to it. When
    added to the scene, they are basically an instance of the original prefab and
    linked to it. When a change is applied to the original prefab, all its instances
    will copy it, as they are essentially clones of it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**预制件**本质上是一种在Unity中创建的资产类型，用作可重复使用的游戏对象，存储在项目视图中。预制件可以插入到场景中任意多次，并应用任何对象变换。当添加到场景中时，它们基本上是原始预制件的实例，并与其链接。当对原始预制件应用更改时，所有其实例都将复制它，因为它们本质上是其克隆。'
- en: Prefabs are an indispensable tool for Unity. It makes the creation of standard
    scene components a much easier task. Imagine we are making a game with many enemy
    non-player characters. It will take a lot of time to manually construct every
    one of them, but if we create a single enemy prefab and then clone it multiple
    times, it will make constructing the scene much easier. Also if we want to edit
    the entire enemy NPCs, we only have to edit the prefab and the change will propagate.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 预制件是Unity不可或缺的工具。它使得创建标准场景组件变得容易得多。想象一下，如果我们正在制作一个包含许多非玩家角色敌人的游戏。手动构建每一个敌人将花费很多时间，但如果我们创建一个单独的敌人预制件并多次克隆它，这将使构建场景变得容易得多。此外，如果我们想要编辑整个敌人NPC，我们只需编辑预制件，更改就会传播。
- en: Unity prefabs also make it easier to share components between projects if they
    are to be exported into Unity packages. This is essentially what Qualcomm did
    with Vuforia components. All the components that make the AR scene are stored
    as prefabs that are ready to be dropped into the scene; we only needs its parameters
    adjusted.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Unity预制件还使得在项目之间共享组件变得容易，如果它们要导出为Unity包。这正是高通公司对Vuforia组件所做的事情。构成AR场景的所有组件都存储为预制件，随时可以拖放到场景中；我们只需调整其参数即可。
- en: 'All Vuforia prefabs can be found inside the **Prefabs** folder inside the **Qualcomm
    Augmented Reality** folder. The following screenshot shows the **Qualcomm Augmented
    Reality Prefabs** folder:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Vuforia预制件都可以在**Qualcomm Augmented Reality**文件夹中的**Prefabs**文件夹内找到。以下截图显示了**Qualcomm
    Augmented Reality Prefabs**文件夹：
- en: '![Vuforia prefabs](img/0032_3_3.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![Vuforia prefabs](img/0032_3_3.jpg)'
- en: Inside the **Prefabs** folder, we will find all the components explained before
    such as the **ImageTarget** prefab and the **FrameMarker** prefab. We will also
    find the **ARCamera** prefab, which is the common thing among any type of AR app.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Prefabs**文件夹内，我们将找到之前解释的所有组件，例如**ImageTarget**预制件和**FrameMarker**预制件。我们还将找到**ARCamera**预制件，这是任何类型AR应用中的共同点。
- en: By default, when Unity creates a new scene, it adds a camera to the scene such
    as the one in the **Hierarchy** panel. In our case, we will use Vuforia's special
    **ARCamera** prefab in our scene. So we need to first delete the **Main Camera**
    object from the **Hierarchy** panel.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当Unity创建一个新的场景时，它会向场景中添加一个相机，例如在**Hierarchy**面板中显示的那个。在我们的案例中，我们将使用Vuforia的专用**ARCamera**预制件。因此，我们需要首先从**Hierarchy**面板中删除**Main
    Camera**对象。
- en: 'Simply select the **Main Camera** from the scene **Hierarchy** and right click
    on it, then click on **Delete**. Now drag-and-drop the **ARCamera** prefab to
    the scene. Anywhere on the scene is fine. Now to focus on its position, select
    the **ARCamera** from the **Hierarchy** panel and hold the *F* keyboard key till
    the focus is on it. When holding the *F* key, make sure the mouse pointer is over
    the scene panel, or the focus will not work. The following screenshot shows **ARCamera**
    prefab added to the scene:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地从场景的**Hierarchy**中选择**Main Camera**，然后右键单击它，然后点击**Delete**。现在将**ARCamera**预制件拖放到场景中。场景的任何位置都可以。现在为了关注其位置，从**Hierarchy**面板中选择**ARCamera**，并按住*F*键盘键直到焦点在其上。当按住*F*键时，确保鼠标指针在场景面板上，否则焦点将不起作用。以下截图显示了添加到场景中的**ARCamera**预制件：
- en: '![Vuforia prefabs](img/0032_3_4.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![Vuforia prefabs](img/0032_3_4.jpg)'
- en: Adding the rest of the components is just as easy. Now that we have an **ARCamera**
    prefab added to the scene, we just need to add the **ImageTarget** prefab to the
    scene as well. Drag and drop the **ImageTarget** prefab anywhere on the scene.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 添加其余组件同样简单。现在我们已经将一个**ARCamera**预制件添加到场景中，我们还需要将**ImageTarget**预制件也添加到场景中。将**ImageTarget**预制件拖放到场景的任何位置。
- en: 'This prefab is the platform that we will add the 3D content to. It will also
    hold the image target that the app will track to orient `ARCamera` the way we
    saw in the sample app. The following screenshot shows **ImageTarget** prefab added
    to the scene:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个预制件是我们将添加3D内容的平台。它还将持有应用程序将跟踪以定位`ARCamera`的方式，正如我们在示例应用中看到的那样。以下截图显示了添加到场景中的**ImageTarget**预制件：
- en: '![Vuforia prefabs](img/0032_3_5.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![Vuforia prefabs](img/0032_3_5.jpg)'
- en: 'Depending on where the `ImageTarget` prefab was dropped in the scene, its position
    in the game world displayed in the transform section will differ. **Transform**
    is basically the position of the game object in the game world. Transform holds
    three different vectors for three different data about the position of the object.
    That data is as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 根据将 `ImageTarget` 预制体放置在场景中的位置，变换部分中显示的游戏世界中的位置将不同。**变换**基本上是游戏对象在游戏世界中的位置。变换包含三个不同的向量，分别代表对象位置的不同数据。这些数据如下：
- en: '**Position**: This is the position of the object in the three axes, x, y, and
    z'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位置**：这是对象在三个轴（x、y 和 z）上的位置'
- en: '**Rotation**: This is the rotation of the object in the three axes , x, y,
    and z'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**旋转**：这是对象在三个轴（x、y 和 z）上的旋转'
- en: '**Scale**: This is the size scale of the object compared to its original size
    in the game world'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缩放**：这是对象与游戏世界中原始大小相比的尺寸比例'
- en: 'Objects can be anywhere in the world, but it is recommended to keep the world''s
    floor at *y=0*. By keeping the floor to `0`, it simplifies a lot of other aspects
    of code when it comes to changing the transformation of object through scripts.
    So now change all the `ImageTarget`''s position to be (*x=0*, *y=0*, *z=0*). This
    will position the object in the origin of the world and simplifies the position
    aspect of subsequent game objects. The following screenshot shows the image target
    inspector:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对象可以在世界的任何地方，但建议将世界的地板保持在 *y=0*。通过将地板保持在 `0`，当通过脚本更改对象的变换时，它将大大简化代码的许多其他方面。因此，现在将所有
    `ImageTarget` 的位置更改为 (*x=0*，*y=0*，*z=0*)。这将使对象位于世界的原点，并简化后续游戏对象的定位方面。以下截图显示了图像目标检查器：
- en: '![Vuforia prefabs](img/0032_3_6.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![Vuforia 预制体](img/0032_3_6.jpg)'
- en: As it is noticeable from the inspector, there are a lot of settings for Image
    Target that might seem intimidating at first. One of those components is named
    **Image Target Behaviour (Script)**, which is highlighted in the image above;
    this is responsible for attaching the image target data to the image target object.
    Right now, it has no target defined in the app because we haven't added any yet,
    hence the white representation of the image target.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如检查器所示，有许多针对 Image Target 的设置，一开始可能会让人感到有些令人畏惧。其中之一是名为 **Image Target 行为（脚本）**
    的组件，如上图所示；它负责将图像目标数据附加到图像目标对象上。目前，它还没有在应用中定义任何目标，因为我们还没有添加任何，因此图像目标的表示是白色的。
- en: 'The first thing we need to do is to add the image target''s data into the app.
    We do that by importing the dataset''s Unity package that is available with the
    book content by the name `exampleDataset.unitypackage`. Import the package in
    the same way we imported all the other Unity packages. The following screenshot
    shows **exampleDataset.unityPackage**:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是将图像目标的数据添加到应用中。我们通过导入与书中内容一起提供的名为 `exampleDataset.unitypackage` 的数据集
    Unity 包来实现。以导入所有其他 Unity 包相同的方式导入该包。以下截图显示了 **exampleDataset.unityPackage**：
- en: '![Vuforia prefabs](img/0032_3_7.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![Vuforia 预制体](img/0032_3_7.jpg)'
- en: What this package essentially contains is the data of the target image that
    Vuforia's tracking algorithm can effectively look for from the camera's feed.
    It also carries a texture representation of the target image to be viewed inside
    Unity's editor while developing the app.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个包本质上包含的是目标图像的数据，Vuforia 的跟踪算法可以从摄像头的视频流中有效地查找这些数据。它还携带了目标图像的纹理表示，以便在开发应用时在
    Unity 编辑器中查看。
- en: Now that the project contains the tracking data, a new selection will appear
    inside the `ImageTarget` prefab for the **Image Target Behaviour**. We will be
    able to select any of the images imported from the target package and the `ImageTarget`
    prefab will instantly adopt it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在项目包含了跟踪数据，`ImageTarget` 预制体内部将出现一个新的选择，用于 **Image Target 行为**。我们将能够选择从目标包中导入的任何图像，并且
    `ImageTarget` 预制体会立即采用它。
- en: 'First we need to select the dataset that contains the images. From the dropdown
    menu, we can select the only dataset available, named **exampleDataset**. From
    the dropdown menu below, we can choose the specific target image. Choose the target
    image stones. Notice immediately the **ImageTarget** representation in the game
    world carries now the target image. The following screenshot shows the dataset
    selection:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要选择包含图像的数据集。从下拉菜单中，我们可以选择唯一的可用数据集，名为 **exampleDataset**。从下面的下拉菜单中，我们可以选择特定的目标图像。选择目标图像石头。注意，游戏世界中的
    **ImageTarget** 表示现在携带了目标图像。以下截图显示了数据集选择：
- en: '![Vuforia prefabs](img/0032_3_8.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![Vuforia 预制体](img/0032_3_8.jpg)'
- en: Datasets are essentially a collection of image targets that Vuforia will track
    simultaneously for any of the images inside it. Inside the dataset that we imported,
    we have images images from the Vuforia sample project. The app will track all
    three images at any given time till it finds any of the images to render the 3D
    material on top of it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集本质上是一组图像目标，Vuforia将同时跟踪其中任何图像。在我们导入的数据集中，我们有来自Vuforia示例项目的图像。应用将在任何给定时间跟踪所有三幅图像，直到找到任何图像来在其上渲染3D材质。
- en: The app can have multiple datasets with as many as 100 images in each one of
    them. That is a substantial number of images that Vuforia can track. We also have
    the ability to activate and deactivate any of the datasets from the editor or
    from script.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 应用可以有多个数据集，每个数据集中可以有多达100个图像。这是Vuforia可以跟踪的大量图像。我们还有能力从编辑器或脚本中激活和停用任何数据集。
- en: When we added the dataset to the `ImageTarget`, it represented the image target
    in the world right away, but that doesn't necessarily mean that `ARCamera` will
    be tracking that dataset. For that, we need to first activate the dataset and
    tell the `ARCamera` to start tracking that dataset.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将数据集添加到`ImageTarget`时，它立即在世界上表示了图像目标，但这并不一定意味着`ARCamera`会跟踪该数据集。为此，我们首先需要激活数据集，并告诉`ARCamera`开始跟踪该数据集。
- en: Click on the **ARCamera** object from the **Hierarchy** panel. In the inspector,
    we can find the **Script** component **Data Set Load Behaviour (Script)**. Inside
    the component, there will be one checkbox with the label **Load Data Set exampleDataset**.
    If we click on the checkbox, another one will appear with the label **Activate**.
    Click on that as well. Now the dataset is loaded and activated. The following
    screenshot shows the activated dataset in **ARCamera**.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 从**层次结构**面板中单击**ARCamera**对象。在检查器中，我们可以找到**脚本**组件**数据集加载行为（脚本）**。在该组件内部，将有一个带有标签**加载数据集exampleDataset**的复选框。如果我们点击复选框，将出现另一个带有标签**激活**的复选框。也点击它。现在数据集已加载并激活。以下截图显示了在**ARCamera**中激活的数据集。
- en: '![Vuforia prefabs](img/0032_3_9.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![Vuforia prefabs](img/0032_3_9.jpg)'
- en: There is a particular reason why we need to both load and activate the datasets
    as separate options. The datasets will be loaded but not necessarily tracked at
    the start of the scene if added to the `ARCamera` component. From script, we can
    then enable and disable tracking for any of them without the need for loading
    overhead. The process is very fast that way.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要分别加载和激活数据集，这有一个特别的原因。如果添加到`ARCamera`组件，数据集将在场景开始时加载但不一定跟踪。从脚本中，我们可以然后启用和禁用任何数据集的跟踪，而无需加载开销。这种方式下，过程非常快。
- en: Now we know that Vuforia both knows what trackables to track and is actively
    tracking them. We added the `ImageTarget` prefab and set it to the **Stones**
    image target. If we are to press play and present the camera with the stones image
    target, nothing will happen beyond a console log declaring it has detected the
    image target. We might even notice the `ARCamera` frantically moving around the
    game world in relation to the image target in the editor. That is simply because
    we do not have any 3D content attached to the target image just yet.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道Vuforia不仅知道要跟踪哪些可跟踪对象，而且正在积极跟踪它们。我们添加了`ImageTarget`预制件，并将其设置为**Stones**图像目标。如果我们按播放并给相机展示石头图像目标，除了控制台日志声明它已检测到图像目标外，不会发生任何事。我们甚至可能会注意到`ARCamera`在编辑器中疯狂地围绕图像目标在游戏世界中移动。这仅仅是因为我们还没有将任何3D内容附加到目标图像上。
- en: Importing and attaching 3D objects
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入和附加3D对象
- en: Unity is capable of importing 3D models from many well-established formats.
    Models can be created from any of the 3D modeling applications such as 3D max,
    Maya, and Blender. As long as the model is exported in a Unity-supported format,
    it is easily imported into the project.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Unity能够从许多成熟的格式导入3D模型。模型可以从任何3D建模应用程序创建，例如3D max、Maya和Blender。只要模型以Unity支持的格式导出，就可以轻松将其导入到项目中。
- en: 'Formats supported by Unity are as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Unity支持的格式如下：
- en: Maya (`.mb` and `.ma`)
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maya (`.mb`和`.ma`)
- en: 3D Studio Max (`.max`)
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3D Studio Max (`.max`)
- en: Cheetah 3D (`.jas`)
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cheetah 3D (`.jas`)
- en: Cinema 4D (`.c4d`)
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cinema 4D (`.c4d`)
- en: Blender (`.blend`)
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Blender (`.blend`)
- en: Modo (`.lxo`)
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Modo (`.lxo`)
- en: Autodesk (`.fbx`)
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Autodesk (`.fbx`)
- en: COLLADA
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: COLLADA
- en: Carrara
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Carrara
- en: Lightwave
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lightwave
- en: XSI 5.x
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XSI 5.x
- en: SketchUp Pro
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SketchUp Pro
- en: Wings 3D
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wings 3D
- en: 3D studio (`.3ds`, does not work on Mac OSX)
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3D studio (`.3ds`，在Mac OSX上不工作)
- en: Wavefront (`.obj`)
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wavefront (`.obj`)
- en: Drawing Interchange Files (`.dxf`)
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制交换文件（`.dxf`）
- en: The list is quite extensive. It is quite safe to assume that Unity will support
    most known 3D model formats. Notice though that Unity uses the 3D modeling application
    to convert the model format to FBX, which then can be imported by Unity. This
    process is mostly automatic and produces smooth results and streamlines the workflow
    considerably.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 列表相当广泛。可以相当安全地假设Unity将支持大多数已知的3D模型格式。注意，尽管如此，Unity使用3D建模应用程序将模型格式转换为FBX，然后可以被Unity导入。这个过程主要是自动的，并产生平滑的结果，大大简化了工作流程。
- en: Now it's time to add our own 3D model to the project. Firstly, we need to create
    a folder for models in our project. We will use it to include all models in our
    project. In the **Assets** root folder, create a folder and name it `Models`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将我们自己的3D模型添加到项目中了。首先，我们需要在项目中创建一个用于模型的文件夹。我们将使用它来包含项目中所有的模型。在**Assets**根文件夹中创建一个文件夹，并将其命名为`Models`。
- en: 'Importing assets is easily done from the **Assets** menu at the top. Click
    on **Import New Asset** from the menu, and point at the chapter''s assets folder
    and choose `frog.fbx` file. Unity will start importing the asset right away. The
    following screenshot shows Unity imported **Frog** asset:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 从**Assets**菜单的顶部导入资产很容易完成。从菜单中选择**Import New Asset**，然后指向章节的资产文件夹并选择`frog.fbx`文件。Unity将立即开始导入资产。以下截图显示了Unity导入的**Frog**资产：
- en: '![Importing and attaching 3D objects](img/0032_3_10.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![导入并附加3D对象](img/0032_3_10.jpg)'
- en: Now we have the 3D model in our project, it is that easy to add models to Unity
    projects. That is good news because for a game engine, adding models is one of
    the top chores done in projects. Are you wondering why the 3D model is a frog?
    It is because it's generally good for developers to have a sense of humor; it
    helps.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们已经在项目中有了3D模型，将模型添加到Unity项目是如此简单。这是一个好消息，因为对于游戏引擎来说，添加模型是项目中完成的最重要的任务之一。你在想为什么3D模型是青蛙吗？这是因为对于开发者来说，保持幽默感通常是件好事；这有助于。 '
- en: When importing the 3D model, it created two folders and one file for us. The
    folders contain materials for the 3D model and settings for the FBX import. The
    file is actually a Unity prefab of the model with the materials attached ready
    to be dropped to the scene. Unity creates the prefab automatically for us.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当导入3D模型时，它为我们创建了两个文件夹和一个文件。这些文件夹包含3D模型的材质和FBX导入的设置。文件实际上是一个带有附加材质的Unity预制件，可以直接拖放到场景中。Unity会自动为我们创建预制件。
- en: 'Now we can drag the **Frog** prefab and drop it in our scene. The frog 3D model
    will appear in our game world. The following screenshot shows the frog model added
    to the scene:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将**Frog**预制件拖动并放入我们的场景中。青蛙3D模型将出现在我们的游戏世界中。以下截图显示了添加到场景中的青蛙模型：
- en: '![Importing and attaching 3D objects](img/0032_3_11.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![导入并附加3D对象](img/0032_3_11.jpg)'
- en: Just as when we added the `ImageTarget` prefab, the frog's position in the scene
    is almost certainly not right. We need to position it on top of the `ImageTarget`
    and for it to face the right way, but first we need to approximate its position
    in relation to the `ImageTarget` better. Remember when we added the `ImageTarget`;
    we positioned it at the game world's origin at `(0,0,0)` position. We will do
    the same for the frog as a first step.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 就像当我们添加`ImageTarget`预制件时，青蛙在场景中的位置几乎肯定是不正确的。我们需要将其放置在`ImageTarget`的上方，并使其朝向正确的方向，但首先我们需要更好地估算其相对于`ImageTarget`的位置。记得当我们添加`ImageTarget`时，我们将其放置在游戏世界的原点`(0,0,0)`位置。我们将以青蛙作为第一步做同样的事情。
- en: 'Select the frog from the **Hierarchy**, and from the inspector panel in **Transform**
    position, set x, y and z to zero. The following screenshot shows the frog position
    at the origin point:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从**Hierarchy**中选择青蛙，然后在**Transform**位置检查器面板中，将x、y和z设置为零。以下截图显示了青蛙在原点位置：
- en: '![Importing and attaching 3D objects](img/0032_3_12.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![导入并附加3D对象](img/0032_3_12.jpg)'
- en: The first thing to notice wrong with the frog is that it is sunk in the `ImageTarget`.
    The other problem is that it is too small for the `ImageTarget`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意青蛙的错误是它沉入了`ImageTarget`中。另一个问题是它对于`ImageTarget`来说太小了。
- en: First we will try to position the frog above the `ImageTarget`. At the top left
    of Unity, make sure that you have the directional cross button selected. This
    allows us to change the position of the selected object. Notice the green, blue,
    and red axes coming out of the frog. They are the relative position of the object
    in the game world. Green is for the y axis, red for the x axis, and blue for the
    z axis. We will want to move the object in the y axis to get it above the `ImageTarget`.
    To do that, simply drag the green axis and move the mouse up; the object will
    move up with it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将尝试将青蛙放置在`ImageTarget`上方。在Unity的左上角，确保您已选择方向十字按钮。这允许我们更改选中对象的位罝。注意从青蛙中伸出的绿色、蓝色和红色轴。它们是对象在游戏世界中的相对位置。绿色代表y轴，红色代表x轴，蓝色代表z轴。我们希望将对象在y轴上移动以使其位于`ImageTarget`上方。为此，只需拖动绿色轴并将鼠标向上移动；对象将随之一同上升。
- en: 'Position the frog anywhere above the `ImageTarget`. It doesn''t have to be
    perfect for now. The following screenshot shows the frog positioned higher in
    the y axis:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 将青蛙放置在`ImageTarget`的任何上方。现在不必完美。以下截图显示了青蛙在y轴上方的位置：
- en: '![Importing and attaching 3D objects](img/0032_3_13.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![导入和附加3D对象](img/0032_3_13.jpg)'
- en: Now for the second problem, its size; we will need to scale it up considerably
    to fit the `ImageTarget`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看第二个问题，它的尺寸；我们需要将其放大很多才能适应`ImageTarget`。
- en: While the frog is selected from the scene, click on the **Scale** button from
    the top left menu. It is the last icon on the right of a square with arrows coming
    out of it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当青蛙被选中时，从左上角的菜单中点击**缩放**按钮。它是带有箭头从正方形中出来的最后一个图标右侧。
- en: 'The scaling button allows us to scale the object in the scene on any axis or
    all axes. Since we need the object to scale in every direction equally to avoid
    the frog being stretched in one direction more than the other, we need to click
    on the square at the origin of the three axes now represented on the object, and
    then drag the mouse over it. The following screenshot shows the scaled up the
    frog object:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放按钮允许我们在场景中的任意轴或所有轴上缩放对象。由于我们需要对象在所有方向上均匀缩放以避免青蛙在一个方向上比另一个方向拉伸得更多，因此我们需要点击现在表示在物体上的三个轴原点处的正方形，然后拖动鼠标经过它。以下截图显示了放大后的青蛙对象：
- en: '![Importing and attaching 3D objects](img/0032_3_14.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![导入和附加3D对象](img/0032_3_14.jpg)'
- en: Scaling up to `10` in the inspector should be sufficient, but since there are
    no constraints, we can make it as big or as small as we want it to be.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查器中将缩放值设置为`10`应该足够，但由于没有约束，我们可以将其放大或缩小到我们想要的大小。
- en: Now, we need to make the frog face the right way, opposite to where it's facing
    right now. To do that we need to activate the Rotation button in the top left
    menu.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要使青蛙面向正确的方向，与它现在面向的方向相反。为此，我们需要在左上角的菜单中激活旋转按钮。
- en: Once the Rotation button is activated, the axes over the object will look quite
    different. For a start they are spherical in nature, and there are more than just
    the (x, y, and z) axes.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦激活旋转按钮，物体上的轴将看起来相当不同。首先，它们在本质上呈球形，而不仅仅是(x, y, 和 z)轴。
- en: Rotation functions in a similar manner, despite the different look to the other
    transformation tools. By dragging on the (x, y, and z) axes, we can rotate the
    object around any of the three axes. The remaining white axes are diagonal rotations
    for easy access.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转功能与其他变换工具的外观不同，但工作方式相似。通过拖动(x, y, 和 z)轴，我们可以围绕任意一个轴旋转对象。剩余的白色轴是用于方便访问的对角旋转。
- en: 'Drag the green y axis to rotate the object to face the right way. Notice the
    rotation data in the inspector changing around the y axis. We need it to be around
    `180` or `-180` degrees. Note that we can just input that number in the rotation
    section of the inspector to reach the same result. The following screenshot shows
    the rotated frog object:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 拖动绿色y轴以使物体朝向正确的方向旋转。注意检查器中的旋转数据在y轴周围变化。我们需要它达到`180`或`-180`度。注意，我们只需在检查器的旋转部分输入那个数字即可达到相同的结果。以下截图显示了旋转后的青蛙对象：
- en: '![Importing and attaching 3D objects](img/0032_3_15.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![导入和附加3D对象](img/0032_3_15.jpg)'
- en: 'Now that the frog is rotated to face the right way in relation to the trackable,
    we only need to position it higher up to be right on top of the trackable. We
    can achieve that in the same way we positioned the frog before. Only this time
    with more care and we must rotate the editor camera several times to make sure
    the frog is positioned from all angles correctly. The following screenshot shows
    correctly the positioned frog:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在青蛙已经旋转到相对于可追踪对象的方向正确，我们只需要将其位置提高，使其正好位于可追踪对象上方。我们可以用与之前相同的方式做到这一点。但这次我们需要更加小心，并且必须旋转编辑器相机几次，以确保青蛙从所有角度都定位正确。以下截图显示了正确定位的青蛙：
- en: '![Importing and attaching 3D objects](img/0032_3_16.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![导入和附加3D对象](img/0032_3_16.jpg)'
- en: Now the frog is positioned perfectly fine on top of the image target, all is
    good. You would notice, though, that the frog seems to have dull colors. That
    is mainly due to the lack of any light sources in the scene; this is what we are
    going to add next.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在青蛙已经完美地定位在图像目标上方，一切正常。不过，你会注意到青蛙似乎颜色很暗淡。这主要是因为场景中没有任何光源；这正是我们接下来要添加的。
- en: 'From the top menu, choose **GameObject**. From the menu click on **Directional
    Light** from the **Create Other** menu. This adds an object called Directional
    Light to your scene. The following screenshot shows Directional Light added to
    scene:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 从顶部菜单中选择**GameObject**。从菜单中点击**Create Other**菜单下的**Directional Light**。这将在你的场景中添加一个名为Directional
    Light的对象。以下截图显示了添加到场景中的Directional Light：
- en: '![Importing and attaching 3D objects](img/0032_3_17.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![导入和附加3D对象](img/0032_3_17.jpg)'
- en: Directional Light is a type of scene light that is quite easy to add and cheap
    on device resources. It essentially acts like a sun, lighting up any object in
    the direction you point it at. All we need to do is adjust the object's rotation.
    Its position in the game world doesn't mean much, because its light is only based
    on its direction, not its position.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 方向光是一种场景光，很容易添加且对设备资源便宜。它本质上就像太阳一样，照亮你指向的方向上的任何对象。我们只需要调整对象的旋转。它在游戏世界中的位置并不重要，因为它的光仅基于其方向，而不是其位置。
- en: Now the frog is where we want it to be, and looking good. We might be tempted
    to press the **Play Button** now and test the AR experience. If we do that and
    present the camera with the trackable, the frog will appear correctly. But once
    the trackable is lost to the camera, we will find that the frog remains on the
    screen regardless. This happens because we did not parent the frog with the image
    target.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在青蛙已经定位在我们想要的位置，看起来也很不错。我们可能会想现在就按下**播放按钮**来测试AR体验。如果我们这样做，并将可追踪对象展示给相机，青蛙将正确显示。但一旦可追踪对象从相机中丢失，我们会发现青蛙仍然停留在屏幕上。这是因为我们没有将青蛙与图像目标进行父化。
- en: Parenting in Unity objects
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unity中的对象父化
- en: There is a good reason Unity's **Hierarchy** panel is named that way. That is
    because it represents the object's hierarchy in the scene. If we are to click
    on the arrow next to the frog object in the **Hierarchy** panel, it will reveal
    a number of objects below it. These objects are essentially children of the object
    frog.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的**层次结构**面板之所以被命名为这个名字，有一个很好的原因。那就是它代表了场景中对象的层次结构。如果我们点击**层次结构**面板中青蛙对象旁边的箭头，它将揭示其下的一组对象。这些对象实际上是青蛙对象的子对象。
- en: The parent object frog contains many children under it in **Hierarchy** that
    essentially means that the children's transformation will follow that of the parent.
    When we moved the frog object around, we didn't have to individually move the
    children as we did so; they automatically moved with the parent object. That is
    fortunate because it would have consumed a lot of time to do that.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 父对象青蛙在**层次结构**下包含许多子对象，这本质上意味着子对象的变换将跟随父对象。当我们移动青蛙对象时，我们不需要单独移动子对象，它们会自动与父对象一起移动。这是幸运的，因为那样会花费很多时间。
- en: Parenting in Unity happens for a number of reasons. Whether it's script access,
    transformation, or simple grouping, Unity parenting is a very important feature.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中进行父化有多个原因。无论是脚本访问、变换还是简单的分组，Unity的父化是一个非常重要的功能。
- en: For image targets to work correctly, we must parent them over any 3D content
    they will display. This is a must for Vuforia to be able to control when and how
    the 3D content is shown to match that of the image target.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使图像目标能够正确工作，我们必须将它们作为任何它们将要显示的3D内容的父对象。这对于Vuforia能够控制何时以及如何显示3D内容以匹配图像目标来说是一个必须的条件。
- en: 'To parent it, we simply need to drag the frog object and drop it over the `ImageTarget`
    object in the **Hierarchy** panel. The following screenshot shows the parented
    frog object:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要将其设置为父对象，我们只需将青蛙对象拖动并放置在**层次结构**面板中的`ImageTarget`对象上。以下截图显示了已设置为父对象的青蛙对象：
- en: '![Parenting in Unity objects](img/0032_3_17.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![Unity对象中的育儿](img/0032_3_17.jpg)'
- en: With that our AR project should be functional and displays the frog correctly
    once we click on the **Play Button** to test it. We can deploy it on the device
    if we follow the settings explained in the previous chapter.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击**播放按钮**来测试它后，我们的AR项目应该能够正常工作并正确显示青蛙。如果我们遵循上一章中解释的设置，我们可以在设备上部署它。
- en: Through this chapter, we have learned how to build a Vuforia project from scratch
    in Unity, how to import and present our 3D objects, and how to add and set up
    Vuforia components to correctly display it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章，我们学习了如何在Unity中从头开始构建Vuforia项目，如何导入和展示我们的3D对象，以及如何添加和设置Vuforia组件以正确显示它们。
- en: Summary
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started our new Unity project that we added Vuforia SDK
    to. We were introduced to the meaning of the term prefab and then explored the
    different prefabs that are packaged inside Vuforia SDK. We saw how to build up
    an AR scene using Vuforia prefabs, especially the `ARCamera` prefab and `ImageTarget`
    prefab. We then understood the method in which we add targets to the project and
    how to activate those datasets in our project. We also saw how easy it is to add
    a 3D model to a Unity project and position it in our scene however we like and
    add appropriate lightening.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始了我们的新Unity项目，并向我们介绍了添加Vuforia SDK后的项目。我们了解了术语prefab的含义，并探讨了Vuforia
    SDK内部包装的不同prefab。我们看到了如何使用Vuforia prefab构建AR场景，特别是`ARCamera` prefab和`ImageTarget`
    prefab。然后我们了解了将目标添加到项目中的方法以及如何在我们的项目中激活这些数据集。我们还看到了将3D模型添加到Unity项目并按我们的喜好在场景中定位以及添加适当光照的简便性。
- en: Next chapter, we will see how to create our own target datasets in the target
    manager, and understand how to obtain the best targeting results from the images
    we choose.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将了解如何在目标管理器中创建我们自己的目标数据集，以及如何从我们选择的照片中获得最佳的目标结果。
