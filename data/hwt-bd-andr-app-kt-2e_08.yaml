- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Services, WorkManager, and Notifications
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务、WorkManager和通知
- en: This chapter will introduce you to the concepts of managing long-running tasks
    in the background of an app. By the end of this chapter, you will be able to trigger
    a background task, create a notification for the user when a background task is
    complete, and launch an application from a notification. This chapter will give
    you a solid understanding of how to manage background tasks and keep the user
    informed about the progress of these tasks.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您介绍在应用后台管理长时间运行任务的概念。在本章结束时，您将能够触发后台任务，当后台任务完成时为用户创建一个通知，并从通知中启动一个应用。本章将为您提供一个关于如何管理后台任务并让用户了解这些任务进度的坚实基础。
- en: In the previous chapter, we learned how to request permissions from the user
    and use Google’s Maps API. With that knowledge, we obtained the user’s location
    and allowed them to deploy an agent on a local map. In this chapter, we will learn
    how to track a long-running process and report its progress to the user.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何请求用户权限并使用谷歌的地图API。有了这些知识，我们获取了用户的位置并允许他们在本地地图上部署一个代理。在本章中，我们将学习如何跟踪长时间运行的过程并向用户报告其进度。
- en: We will build an example app where we will assume that **Secret Cat Agents**
    (**SCAs**) get deployed in a record time of 15 seconds. When a cat successfully
    deploys, we will notify the user and let them launch the app, presenting them
    with a successful deployment message.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个示例应用，假设**秘密猫特工**（**SCAs**）在15秒内被部署。当一只猫成功部署后，我们将通知用户并让他们启动应用，向他们展示成功的部署消息。
- en: Note
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We will go with 15 seconds because that way, we will avoid having to wait for
    very long before our background task completes.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将选择15秒，这样我们就可以避免在后台任务完成之前等待很长时间。
- en: Ongoing background tasks are quite common in the mobile world. Background tasks
    run even when an application is not active. Examples of long-running background
    tasks include the downloading of files, resource clean-up jobs, playing music,
    and tracking the user’s location.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动世界中，持续的后台任务相当常见。即使应用未处于活动状态，后台任务也会运行。长时间运行的后台任务示例包括文件下载、资源清理作业、播放音乐和跟踪用户的位置。
- en: 'Historically, Google offered Android developers multiple ways of executing
    such tasks: `Services`, `JobScheduler`, and Firebase’s `JobDispatcher` and `AlarmManager`.
    With the fragmentation that existed in the Android world, it was quite a mess
    to cope with. Luckily for us, since March 2019, we have had a better (more stable)
    option.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，谷歌为Android开发者提供了多种执行此类任务的方式：`服务`、`JobScheduler`、Firebase的`JobDispatcher`和`AlarmManager`。由于Android世界的碎片化，处理起来相当混乱。幸运的是，自从2019年3月以来，我们有了更好的（更稳定的）选择。
- en: With the introduction of `WorkManager`, Google has abstracted the logic of choosing
    a background executing mechanism based on the API version away for us. We still
    use a foreground service, which is a special kind of service, for certain tasks
    that should be known to the user while running, such as playing music or tracking
    the user’s location in a running app.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 随着`WorkManager`的引入，谷歌已经为我们抽象了基于API版本选择后台执行机制的逻辑。我们仍然使用前台服务，这是一种特殊的服务，用于某些应该在运行时让用户知道的任务，例如播放音乐或在运行的应用中跟踪用户的位置。
- en: Note
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '**Services** are application components designed to run in the background,
    even when an app is not running. Except for foreground services, which are tied
    to a notification, services have no user interface.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务**是设计在后台运行的应用组件，即使在应用未运行时也是如此。除了与通知相关联的前台服务外，服务没有用户界面。'
- en: Before we proceed, take a quick step back. We have mentioned services, and we
    will be focusing on foreground services, but we haven’t quite explained what services
    are. Services are application components designed to run in the background, even
    when an app is not running.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，先退一步。我们提到了服务，我们将专注于前台服务，但我们还没有完全解释什么是服务。服务是设计在后台运行的应用组件，即使在应用未运行时也是如此。
- en: Services have no user interface, with foreground services being the exception.
    It is important to note that services run on the main thread of their hosting
    process. This means that their operations can block the app. It is up to us to
    start a separate thread from within a service to avoid that.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 服务没有用户界面，除了前台服务。需要注意的是，服务在其宿主进程的主线程上运行。这意味着它们的操作可能会阻塞应用。我们必须在服务内部启动一个单独的线程来避免这种情况。
- en: Let’s get started and look at the implementation of the multiple approaches
    available in Android for managing a background task.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始，看看Android中用于管理后台任务的多种方法的实现。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Starting a background task using `WorkManager`
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`WorkManager`启动后台任务
- en: Background operations noticeable to the user – using a Foreground Service
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对用户可见的后台操作 – 使用前台服务
- en: Technical requirements
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The complete code for all the exercises and the activity in this chapter is
    available on GitHub at [https://packt.link/i8IRQ](https://packt.link/i8IRQ)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章所有练习和活动的完整代码可在GitHub上找到，链接为[https://packt.link/i8IRQ](https://packt.link/i8IRQ)
- en: Starting a background task using WorkManager
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`WorkManager`启动后台任务
- en: The first question we will address here is should we opt for `WorkManager` or
    a foreground service? To answer that, a good rule of thumb is to ask whether you
    need the action to be tracked by the user in real time.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里要解决的第一个问题是是否选择`WorkManager`或前台服务？为了回答这个问题，一个好的经验法则是问你是否需要用户实时跟踪操作。
- en: If the answer is yes (for example, if you have a task such as responding to
    the user’s location or playing music in the background), then you should use a
    foreground service with its attached notification to give the user a real-time
    indication of state. When the background task can be delayed or does not require
    user interaction (for example, downloading a large file), use `WorkManager`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果答案是肯定的（例如，如果你有一个像响应用户的位置或播放背景音乐这样的任务），那么你应该使用带有附加通知的前台服务来给用户实时状态指示。当后台任务可以延迟或不需要用户交互（例如，下载大文件）时，使用`WorkManager`。
- en: Note
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Starting with version `2.3.0-alpha02` of `WorkManager`, you can launch a foreground
    service via the `WorkManager` singleton by calling `setForegroundAsync(ForegroundInfo)`.
    Our control over that foreground service is quite limited. It does allow you to
    attach a (predefined) notification to the work, which is why it is worth mentioning.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 从`WorkManager`的`2.3.0-alpha02`版本开始，你可以通过调用`setForegroundAsync(ForegroundInfo)`通过`WorkManager`单例启动前台服务。我们对那个前台服务的控制相当有限。它确实允许你将（预定义的）通知附加到工作，这就是为什么它值得提及。
- en: In our example app, we will track the SCAs’ preparation for deployment. Before
    an agent can head out, they need to stretch, groom their fur, visit the litter
    box, and suit up. Each one of these tasks takes some time. Because you can’t rush
    a cat, the agent will finish each step in its own time. All we can do is wait
    (and let the user know when the task is done). `WorkManager` is perfect for such
    a scenario.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例应用中，我们将跟踪SCAs的部署准备工作。在代理可以出发之前，他们需要拉伸，梳理毛发，访问猫砂盆，并穿戴装备。这些任务中的每一个都需要一些时间。因为不能催促猫，代理会根据自己的时间完成每个步骤。我们能做的只是等待（并通知用户任务何时完成）。`WorkManager`非常适合这种场景。
- en: 'To use `WorkManager`, we need to familiarize ourselves with its four main classes:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`WorkManager`，我们需要熟悉其四个主要类：
- en: '`WorkManager`: This receives work and enqueues it based on provided arguments
    and constraints (such as internet connectivity and the device charging).'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WorkManager`：它接收工作并根据提供的参数和约束（如网络连接和设备充电）对其进行排队。'
- en: '`Worker`: This is a wrapper around the work that needs doing. It has one function,
    `doWork()`, which we override to implement the background work code. The `doWork()`
    function will be executed in a background thread.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Worker`：这是需要执行的工作的包装器。它有一个函数`doWork()`，我们重写它来实现后台工作代码。`doWork()`函数将在后台线程中执行。'
- en: '`WorkRequest`: This class binds a `Worker` class to arguments and constraints.
    There are two types of `WorkRequest`: `OneTimeWorkRequest`, which runs the work
    once, and `PeriodicWorkRequest`, which can be used to schedule work to run at
    a fixed interval.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WorkRequest`：这个类将`Worker`类绑定到参数和约束。`WorkRequest`有两种类型：`OneTimeWorkRequest`，它只运行一次工作，和`PeriodicWorkRequest`，它可以用来安排工作在固定间隔运行。'
- en: '`ListenableWorker.Result`: You probably guessed it, but this is the class holding
    the result of the executed work. The result can be one of `Success`, `Failure`,
    or `Retry`.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ListenableWorker.Result`：你可能已经猜到了，但这是一个持有执行工作结果的类。结果可以是`Success`、`Failure`或`Retry`。'
- en: Other than these four classes, we also have the `Data` class, which holds data
    passed to and from the worker.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这四个类之外，我们还有一个`Data`类，它持有传递给工作者的数据和从工作者返回的数据。
- en: 'Let’s get back to our example. We want to define four tasks that need to occur
    in sequential order: the cat needs to stretch, then it needs to groom its fur,
    then visit the litter box, and, finally, it needs to suit up.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的例子。我们想要定义四个需要按顺序发生的任务：猫需要伸展，然后需要梳理毛发，然后去猫砂盆，最后需要穿上衣服。
- en: 'Before we can start using `WorkManager`, we have to first include its dependency
    in our app `build.gradle` file:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用 `WorkManager` 之前，我们必须首先将其依赖项包含在我们的应用 `build.gradle` 文件中：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'With `WorkManager` included in our project, we’ll go ahead and create our workers.
    The first worker will look something like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中包含 `WorkManager` 后，我们将继续创建我们的工作者。第一个工作者可能看起来像这样：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We start by extending `Worker` and overriding its `doWork()` function. We then
    read the SCA ID from the input data. Then, because we have no real sensors to
    track the progress of the cat stretching, we fake our wait by introducing a 3-second
    (3,000 milliseconds) `Thread.sleep(Long)` call. Finally, we construct an output
    `data` class with the ID we received in our input and return it with the successful
    result.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过扩展 `Worker` 并重写其 `doWork()` 函数来开始。然后，我们从输入数据中读取 SCA ID。然后，因为我们没有真实的传感器来跟踪猫伸展的进度，所以我们通过引入一个
    3 秒（3,000 毫秒）的 `Thread.sleep(Long)` 调用来伪造等待。最后，我们使用我们在输入中收到的 ID 构造一个输出 `data`
    类，并带着成功的结果返回它。
- en: 'Once we’ve created workers for all our tasks (`CatStretchingWorker`, `CatFurGroomingWorker`,
    `CatLitterBoxSittingWorker`, and `CatSuitUpWorker`), similarly to how we created
    the first one, we can call `WorkManager` to chain them. Let’s also assume we can’t
    tell the progress of the agent unless we’re connected to the internet. Our call
    would look something like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们为所有任务创建了工作者（`CatStretchingWorker`、`CatFurGroomingWorker`、`CatLitterBoxSittingWorker`
    和 `CatSuitUpWorker`），类似于我们创建第一个工作者那样，我们可以调用 `WorkManager` 来链式连接它们。假设除非我们连接到互联网，否则我们无法知道代理的进度。我们的调用可能看起来像这样：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code, we first construct a `Constraints` instance declaring
    we need to be connected to the internet for the work to execute. We then define
    our input data, setting it to the SCA ID. Next, we bind the constraints and input
    data to our `Worker` class by constructing `OneTimeWorkRequest`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先构建了一个 `Constraints` 实例，声明我们需要连接到互联网才能执行工作。然后我们定义我们的输入数据，将其设置为 SCA
    ID。接下来，我们通过构建 `OneTimeWorkRequest` 将约束和输入数据绑定到我们的 `Worker` 类。
- en: The construction of the other `WorkRequest` instances has been left out, but
    they are almost identical to the one shown here. We can now chain all the requests
    and enqueue them in the `WorkManager` class. You can enqueue a single `WorkRequest`
    instance by passing it directly to the `WorkManager` `enqueue()` function, or
    you can have multiple `WorkRequest` instances run in parallel by passing them
    all to the `WorkManager` `enqueue()` function as a list.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 其他 `WorkRequest` 实例的构建已被省略，但它们几乎与这里展示的实例相同。我们现在可以将所有请求链式连接，并在 `WorkManager`
    类中排队。你可以通过直接将 `WorkRequest` 实例传递给 `WorkManager` 的 `enqueue()` 函数来排队一个 `WorkRequest`
    实例，或者你可以通过将所有 `WorkRequest` 实例作为一个列表传递给 `WorkManager` 的 `enqueue()` 函数来使多个 `WorkRequest`
    实例并行运行。
- en: Our tasks will be executed by `WorkManager` when the constraints are met.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当满足约束条件时，我们的任务将由 `WorkManager` 执行。
- en: 'Each `Request` instance has a unique identifier. `WorkManager` exposes a `LiveData`
    property for each request, allowing us to track the progress of its work by passing
    its unique identifier, as shown in the following code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `Request` 实例都有一个唯一的标识符。`WorkManager` 为每个请求公开了一个 `LiveData` 属性，允许我们通过传递其唯一标识符来跟踪其工作进度，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The state of work can be `BLOCKED` (there is a chain of requests, and this one
    is not next in the chain), `ENQUEUED` (there is a chain of requests, and this
    work is next), `RUNNING` (the work in `doWork()` is executing), and `SUCCEEDED`.
    Work can also be canceled, leading to a `CANCELLED` state, or it can fail, leading
    to a `FAILED` state.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 工作状态可以是 `BLOCKED`（存在一个请求链，而这个请求不在链中），`ENQUEUED`（存在一个请求链，而这个工作在链中），`RUNNING`（`doWork()`
    中的工作正在执行），和 `SUCCEEDED`。工作也可以被取消，导致 `CANCELLED` 状态，或者它可能失败，导致 `FAILED` 状态。
- en: Finally, there’s `Result.retry`. Returning this result tells the `WorkManager`
    class to enqueue the work again. The policy governing when to run the work again
    is defined by a `backoff` criteria set on `WorkRequest` `Builder`. The default
    `backoff` policy is exponential, but we can set it to be linear instead. We can
    also define the initial `backoff` time.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有`Result.retry`。返回此结果会告诉`WorkManager`类再次入队工作。何时再次运行工作的策略由`WorkRequest` `Builder`上设置的`backoff`标准定义。默认的`backoff`策略是指数的，但我们可以将其设置为线性的。我们还可以定义初始的`backoff`时间。
- en: Let’s put the knowledge gained so far into practice in the following exercise.
    In this section, we will track our SCA from the moment we fire off the command
    to deploy it to the field to the moment it arrives at its destination.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将到目前为止获得的知识应用到以下练习中。在本节中，我们将从我们发出部署命令的那一刻开始跟踪我们的SCA，直到它到达目的地的那一刻。
- en: Exercise 8.01 – executing background work with the WorkManager class
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.01 – 使用WorkManager类执行后台工作
- en: 'In this first exercise, we will track the SCA as it prepares to head out by
    enqueuing the chained `WorkRequest` classes:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个练习中，我们将通过入队链式`WorkRequest`类来跟踪SCA在准备出发时的状态。
- en: Start by creating a new `Empty Activity` project (**File** | **New** | **New
    Project** | **Empty Activity**). Click **Next**.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建一个新的`Empty Activity`项目（**File** | **New** | **New Project** | **Empty Activity**）。点击**Next**。
- en: Name your application `Cat` `Agent Tracker`.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的应用程序命名为`Cat` `Agent Tracker`。
- en: Make sure your package name is `com.example.catagenttracker`.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你的包名是`com.example.catagenttracker`。
- en: Set the save location to where you want to save your project.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将保存位置设置为你要保存项目的地方。
- en: Leave everything else at its default values and click **Finish**.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其他所有内容保留为默认值，然后点击**完成**。
- en: Make sure you are on the Android view in your **Project** pane.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你在**项目**面板中处于Android视图。
- en: 'Open your app’s `build.gradle` file. In the `dependencies` block, add the `WorkManager`
    dependency:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的应用的`build.gradle`文件。在`dependencies`块中添加`WorkManager`依赖项：
- en: '[PRE4]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This will allow you to use `WorkManager` and its dependencies in your code.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许你在代码中使用`WorkManager`及其依赖项。
- en: Create a new package under your app package (right-click on `com.example.catagenttracker`,
    then `com.example.catagenttracker.worker`.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的应用包下创建一个新的包（在`com.example.catagenttracker`上右键点击，然后选择`com.example.catagenttracker.worker`。
- en: Create a new class under `com.example.catagenttracker.worker` named `CatStretchingWorker`
    (right-click on `worker`, then **New** | **New** **Kotlin File/Class**). Under
    **Kind**, choose **Class**.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`com.example.catagenttracker.worker`下创建一个新的类，命名为`CatStretchingWorker`（在`worker`上右键点击，然后选择**New**
    | **New** **Kotlin File/Class**）。在**Kind**下，选择**Class**。
- en: 'To define a `Worker` instance that will sleep for `3` seconds, update the new
    class like so:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要定义一个将睡眠`3`秒的`Worker`实例，更新新类如下：
- en: '[PRE5]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will add the required dependencies for a `Worker` implementation and then
    extend the `Worker` class. To implement the actual work, you will override `doWork():
    Result`, making it read the Cat Agent ID from the input, sleep for `3` seconds
    (`3,000` milliseconds), construct an output data instance with the Cat Agent ID,
    and pass it via a `Result.success` value.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '这将为`Worker`实现添加所需的依赖项，并扩展`Worker`类。要实现实际的工作，你需要重写`doWork(): Result`，使其从输入中读取猫代理ID，睡眠`3`秒（`3,000`毫秒），构建一个包含猫代理ID的输出数据实例，并通过`Result.success`值传递它。'
- en: Repeat *steps 9* and *10* to create three more identical workers named `CatFurGroomingWorker`,
    `CatLitterBoxSittingWorker`, and `CatSuitUpWorker`.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复*步骤9*和*步骤10*以创建三个更多相同的工作者，分别命名为`CatFurGroomingWorker`、`CatLitterBoxSittingWorker`和`CatSuitUpWorker`。
- en: 'Open `MainActivity`. Right before the end of the class, add the following:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainActivity`。在类末尾之前添加以下内容：
- en: '[PRE6]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This helper function constructs an input `Data` instance for you with the Cat
    Agent ID.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此辅助函数为你构建一个包含猫代理ID的输入`Data`实例。
- en: 'Add the following to the `onCreate(Bundle?)` function:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到`onCreate(Bundle?)`函数中：
- en: '[PRE7]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first line added defines a network constraint. It tells the `WorkManager`
    class to wait for an internet connection before executing work. Then, you define
    your Cat Agent ID. Finally, you define four requests, passing in your `Worker`
    classes, the network constraints, and the Cat Agent ID in the form of input data.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 添加的第一行定义了一个网络约束。它告诉`WorkManager`类在执行工作之前等待网络连接。然后，你定义你的猫代理ID。最后，你定义四个请求，传入你的`Worker`类、网络约束和以输入数据形式提供的猫代理ID。
- en: 'At the top of the class, define your `WorkManager`:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的顶部，定义你的`WorkManager`：
- en: '[PRE8]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add a chained `enqueue` request right below the code you just added, still
    within the `onCreate` function:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你刚刚添加的代码下方添加一个链式`enqueue`请求，仍然在`onCreate`函数内：
- en: '[PRE9]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Your `WorkRequests` are now enqueued to be executed in sequence when their constraints
    are met and the `WorkManager` class is ready to execute them.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你的`WorkRequests`现在已入队，在它们的约束条件满足且`WorkManager`类准备好执行它们时按顺序执行。
- en: 'Define a function to show a toast with a provided message. It should look like
    this:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数来显示带有提供消息的吐司。它应该看起来像这样：
- en: '[PRE10]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To track the progress of the enqueued `WorkRequest` instances, add the following
    after the `enqueue` call:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要跟踪入队`WorkRequest`实例的进度，请在`enqueue`调用之后添加以下内容：
- en: '[PRE11]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding code observes a `WorkInfo` observable provided by the `WorkManager`
    class for each `WorkRequest`. When each request is finished, a toast is shown
    with a relevant message.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码观察了`WorkManager`类为每个`WorkRequest`提供的`WorkInfo`可观察对象。当每个请求完成时，会显示一个包含相关信息的吐司（Toast）。
- en: 'Run your app:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行你的应用程序：
- en: '![Figure 8.1 – Toasts showing in order](img/B19411_08_01.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – 按顺序显示的吐司](img/B19411_08_01.jpg)'
- en: Figure 8.1 – Toasts showing in order
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 按顺序显示的吐司
- en: You should now see a simple `Hello World!` screen. However, if you wait a few
    seconds, you will start seeing toasts informing you of the progress of your SCA
    preparing to deploy to the field. You will notice that the toasts follow the order
    in which you enqueued the requests and execute their delays sequentially.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该会看到一个简单的`Hello World!`屏幕。然而，如果你等待几秒钟，你将开始看到通知吐司，告知你SCA准备部署到现场时的进度。你会注意到，吐司的顺序与你入队请求的顺序一致，并且它们会按顺序执行延迟。
- en: Background operations noticeable to the user – using a Foreground Service
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对用户可见的后台操作 – 使用前台服务
- en: With our SCA all suited up, they are now ready to get to the assigned destination.
    To track the SCA, we will periodically poll the location of the SCA using a Foreground
    Service and update the sticky notification (a notification that cannot be dismissed
    by the user) attached to that service with the new location.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的SCA（服务组件架构）全部准备就绪，现在它们已经准备好前往指定的目的地。为了跟踪SCA，我们将定期使用前台服务轮询SCA的位置，并更新附加到该服务上的粘性通知（用户无法取消的通知）以显示新的位置。
- en: Note
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For the sake of simplicity, we will fake the location. Following what you learned
    in [*Chapter 7*](B19411_07.xhtml#_idTextAnchor421), *Android Permissions and Google
    Maps*, you could later replace this implementation with a real one that uses a
    map.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化起见，我们将伪造位置。根据你在[*第7章*](B19411_07.xhtml#_idTextAnchor421)，“Android权限和Google
    Maps”中学到的知识，你可以稍后用使用地图的真实实现替换这个实现。
- en: Foreground services are another way of performing background operations. The
    name may be a bit counterintuitive. It is meant to differentiate these services
    from the base Android (background) services. The former are tied to a notification,
    while the latter run in the background with no user-facing representation built
    in.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 前台服务是执行后台操作的另一种方式。这个名字可能有点令人费解。它的目的是将这些服务与基本的Android（后台）服务区分开来。前者与一个通知相关联，而后者在后台运行，没有内置的用户界面表示。
- en: Another important difference between foreground services and background services
    is that the latter are candidates for termination when the system is low on memory,
    while the former are not.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 前台服务和后台服务之间的重要区别之一是，当系统内存不足时，后者是终止候选者，而前者则不是。
- en: As of Android 9 (Pie, or API level 28), we have to request the `FOREGROUND_SERVICE`
    permission to use foreground services. Since it is a normal permission, it will
    be granted to our app automatically.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 自Android 9（派，或API级别28）起，我们必须请求`FOREGROUND_SERVICE`权限才能使用前台服务。由于它是一个正常权限，它将自动授予我们的应用程序。
- en: Before we can launch a foreground service, we must first create one. A foreground
    service is a subclass of the Android abstract `Service` class. If we do not intend
    to bind to the service, and in our example, we do not, we can simply override
    `onBind(Intent)` so that it returns `null`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以启动前台服务之前，我们必须首先创建一个。前台服务是Android抽象`Service`类的子类。如果我们不打算绑定到服务，在我们的例子中我们也不这样做，我们可以简单地重写`onBind(Intent)`使其返回`null`。
- en: As a side note, binding is one of the ways for interested clients to communicate
    with a service. We will not focus on this approach in this book, as there are
    other, easier approaches, as you will discover.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，绑定是感兴趣客户端与服务通信的一种方式。在这本书中，我们不会关注这种方法，因为还有其他更简单的方法，你将会发现。
- en: A Foreground Service must be tied to a notification. On Android 8 (Oreo, or
    API level 26) and above, if a Foreground Service is not tied to one within the
    **Application Not Responding** (**ANR**) time window (around five seconds), the
    service is stopped, and the app is declared as not responding.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 前台服务必须与通知绑定。在Android 8（Oreo，或API级别26）及以上版本中，如果前台服务在**应用程序无响应**（**ANR**）时间窗口内（大约五秒）没有绑定到任何一个，服务将被停止，应用将被声明为无响应。
- en: 'Because of this requirement, it is best if we tie the service to a notification
    as soon as we can. The best place to do that would be in the `onCreate()` function
    of the service. A quick implementation would look something like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个要求，我们最好尽快将服务与通知绑定。最好的地方是在服务的`onCreate()`函数中这样做。一个快速实现可能看起来像这样：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Let’s break this down.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其分解。
- en: We start by defining the channel ID. This is only required for Android Oreo
    or above and is ignored in earlier versions of Android. In Android Oreo, Google
    introduced the concept of channels. Channels are used to group notifications and
    allow users to filter out unwanted notifications.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义通道ID。这对于Android Oreo或更高版本是必需的，在Android的早期版本中被忽略。在Android Oreo中，谷歌引入了通道的概念。通道用于分组通知，并允许用户过滤掉不想要的
    notifications。
- en: Next, we define `pendingIntent`. This will be the `Intent` launched if the user
    taps on the notification. In this example, the main activity would be launched.
    It is constructed by wrapping an `Intent` activity launching in a `PendingIntent`.
    The request code is set to `0` because this example doesn’t expect a result, so
    the code will not be used.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义`pendingIntent`。这将是在用户点击通知时启动的`Intent`。在这个例子中，主活动将被启动。它是通过将一个启动活动的`Intent`包装在`PendingIntent`中来构建的。请求代码被设置为`0`，因为在这个例子中我们不期望有结果，所以代码将不会被使用。
- en: The flag is set to `0` for APIs older than S (31). Otherwise, it is set to the
    recommended `PendingIntent.FLAG_IMMUTABLE`, which means that additional arguments
    passed to the `Intent` on send will be ignored.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于低于S（31）的API，标志被设置为`0`。否则，它被设置为推荐的`PendingIntent.FLAG_IMMUTABLE`，这意味着在发送时传递给`Intent`的额外参数将被忽略。
- en: 'With the channel ID and `pendingIntent`, we can construct our notification.
    We use `NotificationCompat`, which takes away some of the boilerplate around supporting
    older API levels. We pass in the context and the channel ID. We define the title,
    text, small icon, `Intent`, and ticker message and build the notification to complete
    the builder:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用通道ID和`pendingIntent`，我们可以构建我们的通知。我们使用`NotificationCompat`，它消除了支持旧API级别的一些样板代码。我们传入上下文和通道ID。我们定义标题、文本、小图标、`Intent`和滚动消息，并构建通知以完成构建器：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To start a service in the foreground, attaching the notification to it, we
    call it the `startForeground(Int, Notification)` function, passing in a notification
    ID (any unique `int` value to identify this service, which must not be 0) and
    a notification, which must have its priority set to `PRIORITY_LOW` or higher.
    In our case, we have not specified the priority, which sets it to `PRIORITY_DEFAULT`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要在前台启动一个服务，将通知附加到它，我们调用`startForeground(Int, Notification)`函数，传入一个通知ID（任何唯一的`int`值来标识这个服务，该值不能为0）和一个通知，该通知必须将其优先级设置为`PRIORITY_LOW`或更高。在我们的例子中，我们没有指定优先级，这将其设置为`PRIORITY_DEFAULT`：
- en: If launched, our service will now show a sticky notification. Clicking on the
    notification would launch our main activity.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果启动，我们的服务现在将显示一个粘性通知。点击通知将启动我们的主活动。
- en: Currently, our service doesn’t perform any operations aside from showing a notification.
    To add some functionality to it, we need to override `onStartCommand(Intent?,
    Int, Int)`. This function gets called when the service is launched via an Intent.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的服务除了显示通知外不执行任何操作。要向其中添加一些功能，我们需要重写`onStartCommand(Intent?, Int, Int)`。当服务通过Intent启动时，会调用这个函数。
- en: This also gives us the opportunity to read any extra data passed via that Intent.
    It also provides us with flags (which may be set to `START_FLAG_REDELIVERY` or
    `START_FLAG_RETRY`) and a unique request ID. We will get to reading the extra
    data later in this chapter. You don’t need to worry about the flags or the request
    ID in a simple implementation.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这也给了我们读取通过该Intent传递的任何额外数据的机会。它还提供了标志（可能设置为`START_FLAG_REDELIVERY`或`START_FLAG_RETRY`）和一个唯一的请求ID。我们将在本章的后面部分学习如何读取额外数据。在简单实现中，你不需要担心标志或请求ID。
- en: It is important to note that `onStartCommand(Intent?, Int, Int)` gets called
    on the UI thread, so don’t perform any long-running operations here, or your app
    will freeze, giving the user a poor experience. Instead, we could create a new
    handler using a new `HandlerThread` (a thread with a looper, a class used to run
    a message loop for a thread) and post our work to it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的一点是`onStartCommand(Intent?, Int, Int)`在UI线程上被调用，所以不要在这里执行任何长时间运行的操作，否则你的应用会冻结，给用户带来糟糕的体验。相反，我们可以创建一个新的`HandlerThread`（一个具有looper的线程，用于为线程运行消息循环）并把它的工作发送给它。
- en: This means we’ll have an infinite loop running, waiting for us to post to it
    via a `Handler`. When we receive a `start` command, we can post the work we want
    to be done to it. That work will then be executed on that thread.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们将有一个无限循环在运行，等待我们通过一个`Handler`来向其发送消息。当我们收到一个`start`命令时，我们可以将我们想要执行的工作发送给它。然后，这项工作将在那个线程上执行。
- en: When our long-running work is done, there are a few things we may want to happen.
    First, we may want to inform whoever is interested (our main activity, if it is
    running, for example) that we are done. Then, we probably want to stop running
    in the foreground. Lastly, if we do not expect to require the service again, we
    could stop it.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的长时间运行的工作完成时，我们可能希望发生几件事情。首先，我们可能希望通知任何感兴趣的人（例如，如果它正在运行，我们的主活动）我们已经完成。然后，我们可能想要停止在前台运行。最后，如果我们不期望再次需要该服务，我们可以停止它。
- en: 'An app has several ways to communicate with a service: binding, using broadcast
    receivers, using a bus architecture, or using a result receiver, to name just
    a few. For our example, we will use Google’s `LiveData`.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 应用有几种与服务通信的方式：绑定、使用广播接收器、使用总线架构或使用结果接收器，仅举几例。在我们的例子中，我们将使用Google的`LiveData`。
- en: Before we proceed, it is worth touching on broadcast receivers. Broadcast receivers
    allow our app to send and receive messages using a pattern much like the *publish-subscribe*
    *design pattern*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，值得简要提及广播接收器。广播接收器允许我们的应用使用类似于*发布-订阅*设计模式的模式发送和接收消息。
- en: The system broadcasts events such as the device booting up or charging having
    started. Our services can broadcast status updates as well. For example, they
    can broadcast a long calculation result on completion. If our app registers to
    receive a certain message, the system will inform it when that message is broadcast.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 系统会广播一些事件，例如设备启动或充电开始。我们的服务也可以广播状态更新。例如，它们可以在完成时广播一个长时间的计算结果。如果我们应用注册接收某个消息，系统将在该消息广播时通知我们。
- en: This used to be a common way to communicate with services, but the `LocalBroadcastManager`
    class is now deprecated as it was an application-wide event bus that encouraged
    anti-patterns.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这曾经是与服务通信的常见方式，但现在`LocalBroadcastManager`类已被弃用，因为它是一个应用级的事件总线，鼓励了反模式。
- en: 'Having said that, broadcast receivers are still useful for system-wide events.
    We first define a class overriding the `BroadcastReceiver` abstract class:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，广播接收器对于系统级事件仍然很有用。我们首先定义一个类，它覆盖了`BroadcastReceiver`抽象类：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When an event is received by `ToastBroadcastReceiver`, it will show a toast
    showing the action and URI of the event.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当`ToastBroadcastReceiver`接收到一个事件时，它将显示一个吐司，显示事件的动作和URI。
- en: 'We can register our receiver via the `Manifest.xml` file:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`Manifest.xml`文件注册我们的接收器：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Specifying `android:exported="true"` tells the system that this receiver can
    receive messages from outside of the application. The action defines the message
    we are interested in. We can specify multiple actions. In this example, we listen
    for when the device starts charging. Keep in mind that setting this value to `true`
    allows other apps, including malicious ones, to activate this receiver.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 指定`android:exported="true"`告诉系统这个接收器可以接收来自应用外部的消息。动作定义了我们感兴趣的消息。我们可以指定多个动作。在这个例子中，我们监听设备开始充电的情况。请注意，将此值设置为`true`允许其他应用，包括恶意应用，激活此接收器。
- en: 'We can also register for messages in code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以注册接收编码消息：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Adding this code to an activity or in our custom application class would register
    a new instance of our receiver as well. This receiver will live so long as the
    context (activity or application) is valid. So, correspondingly, if the activity
    or application is destroyed, our receiver will be freed to be garbage collected.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码添加到活动或我们的自定义应用程序类中也会注册我们的接收器的新实例。只要上下文（活动或应用）有效，这个接收器就会存在。因此，相应地，如果活动或应用被销毁，我们的接收器将被释放以进行垃圾回收。
- en: 'Now back to our implementation. `LiveData` already comes bundled with `androidx.appcompat`,
    saving us the trouble of having to manually include it in our project. We can
    define a `LiveData` instance in the companion object of the service, like so:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到我们的实现。`LiveData` 已经包含在 `androidx.appcompat` 中，这样我们就不必手动将其包含到我们的项目中。我们可以在服务的伴生对象中定义一个
    `LiveData` 实例，如下所示：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that we hide the `MutableLiveData` instance behind a `LiveData` interface.
    This is so that consumers can only read the data. We can now use the `mutableWorkCompletion`
    instance to report completion by assigning it a value. However, we must remember
    that values can only be assigned to the `LiveData` instances on the main thread.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将 `MutableLiveData` 实例隐藏在 `LiveData` 接口后面。这样做是为了确保消费者只能读取数据。现在我们可以使用 `mutableWorkCompletion`
    实例通过为其赋值来报告完成。然而，我们必须记住，值只能分配给主线程上的 `LiveData` 实例。
- en: This means once our work is done, we must switch back to the main thread. We
    can easily achieve that—all we need is a new handler with the main `Looper` (obtained
    by calling `Looper.getMainLooper()`), to which we can post our update.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着一旦我们的工作完成，我们必须切换回主线程。我们可以轻松实现这一点——我们只需要一个新的处理器，使用主 `Looper`（通过调用 `Looper.getMainLooper()`
    获取），然后我们可以向其发送更新。
- en: 'Now that our service is ready to do some work, we can finally launch it. Before
    we do, we must make sure we added the service to our `AndroidManifest.xml` file
    within the `<application></application>` block, as shown in the following code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好让服务开始工作，我们终于可以启动它了。在我们这样做之前，我们必须确保我们已经将服务添加到 `<application></application>`
    块中的 `AndroidManifest.xml` 文件中，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To launch the service we just added to our manifest, we create `Intent`, passing
    in any extra data required, as shown in the following code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动我们添加到清单中的服务，我们创建 `Intent`，传递任何所需的额外数据，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Then, we call `ContextCompat.startForegroundService(Context, Intent)` to fire
    off `Intent` and launch the service.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用 `ContextCompat.startForegroundService(Context, Intent)` 来触发 `Intent`
    并启动服务。
- en: Exercise 8.02 – tracking your SCA’s work with a Foreground Service
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 8.02 – 使用前台服务跟踪 SCA 的作业
- en: In the first exercise, you tracked the SCA as it was preparing to head out using
    the `WorkManager` class and multiple Worker instances showing toasts. In this
    exercise, you will track the SCA as it deploys to the field and moves toward the
    assigned target by showing a sticky notification counting down the time to arrival
    at the destination.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个练习中，你使用 `WorkManager` 类和多个 Worker 实例显示吐司来跟踪 SCA 准备出发的情况。在这个练习中，你将通过显示一个倒计时通知来跟踪
    SCA 部署到现场并向指定的目标移动。
- en: 'This notification will be driven by a Foreground Service, which will present
    and continuously update it. Clicking the notification at any time will launch
    your main activity if it’s not already running and will always bring it to the
    foreground:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个通知将由前台服务驱动，它将展示并持续更新它。在任何时候点击通知，如果主活动尚未运行，它将启动主活动，并始终将其带到前台：
- en: 'Start by adding the `WorkManager` dependency to your app’s `build.gradle` file:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将 `WorkManager` 依赖项添加到你的应用的 `build.gradle` 文件中：
- en: '[PRE20]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create a new class called `RouteTrackingService`, extending the abstract `Service`
    class:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `RouteTrackingService` 的新类，继承自抽象类 `Service`：
- en: '[PRE21]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You will not rely on binding in this exercise, so it is safe to simply return
    `null` in the `onBind(Intent)` implementation.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将不会依赖绑定，因此在 `onBind(Intent)` 实现中简单地返回 `null` 是安全的。
- en: 'In the newly created service, define some constants that you will later need,
    as well as the `LiveData` instance used to observe progress:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新创建的服务中，定义一些你稍后需要的常量，以及用于观察进度的 `LiveData` 实例：
- en: '[PRE22]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`NOTIFICATION_ID` has to be a unique identifier for the notification owned
    by this service and must not be `0`. Now, `EXTRA_SECRET_CAT_AGENT_ID` is the constant
    you will use to pass data to the service. `mutableTrackingCompletion` is private
    and is used to allow you to post completion updates internally via `LiveData`
    without exposing the mutability outside of the service. `trackingCompletion` is
    then used to expose the `LiveData` instance for observation in an immutable fashion.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`NOTIFICATION_ID` 必须是此服务拥有的通知的唯一标识符，且不能为 `0`。现在，`EXTRA_SECRET_CAT_AGENT_ID`
    是你将用于向服务传递数据的常量。`mutableTrackingCompletion` 是私有的，用于允许你通过 `LiveData` 内部发布完成更新，而不在服务外部暴露可变性。`trackingCompletion`
    然后用于以不可变的方式公开 `LiveData` 实例供观察。'
- en: 'Add a function to your `RouteTrackingService` class to provide `PendingIntent`
    to your sticky notification:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `RouteTrackingService` 类中添加一个函数，以提供 `PendingIntent` 给你的粘性通知：
- en: '[PRE23]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This will launch `MainActivity` whenever the user clicks on `Notification`.
    You call `PendingIntent.getActivity()`, passing a context, no request code (`0`),
    `Intent` that will launch `MainActivity`, and the `FLAG_IMMUTABLE` flag if available,
    otherwise no flags (`0`) to it. You get back a `PendingIntent`, which will launch
    that activity.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在用户点击`Notification`时启动`MainActivity`。您调用`PendingIntent.getActivity()`，传递一个上下文、没有请求代码（`0`）、将启动`MainActivity`的`Intent`以及如果可用则传递`FLAG_IMMUTABLE`标志，否则不传递任何标志（`0`）。您将获得一个`PendingIntent`，它将启动该活动。
- en: 'Add another function to create `NotificationChannel` on devices running Android
    Oreo or newer, and return a channel ID:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加另一个函数以在运行Android Oreo或更高版本的设备上创建`NotificationChannel`并返回通道ID：
- en: '[PRE24]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You start by checking the Android version. You only need to create a channel
    if it’s Android O or later. Otherwise, you can return an empty string. For Android
    O, you define the channel ID. This needs to be unique for a package. Next, you
    define a channel name that will be visible to the user.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您首先检查Android版本。只有在Android O或更高版本时才需要创建通道。否则，您可以返回一个空字符串。对于Android O，您定义通道ID。这需要对于包来说是唯一的。接下来，您定义一个用户可见的通道名称。
- en: This can (and should) be localized. We skipped that part for the sake of simplicity.
    A `NotificationChannel` instance is then created with the importance set to `IMPORTANCE_DEFAULT`.
    The importance dictates how disruptive the notifications posted to this channel
    are.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以（并且应该）进行本地化。为了简化，我们跳过了那部分。然后创建一个`NotificationChannel`实例，并将重要性设置为`IMPORTANCE_DEFAULT`。重要性决定了发送到该通道的通知的干扰程度。
- en: Lastly, a channel is created using `Notification Service` with the data provided
    in the `NotificationChannel` instance. The function returns the channel ID so
    that it can be used to construct the `Notification`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用`Notification Service`和`NotificationChannel`实例中提供的数据创建一个通道。该函数返回通道ID，以便可以用于构建`Notification`。
- en: 'Create a function to provide you with `Notification.Builder`:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数以提供`Notification.Builder`：
- en: '[PRE25]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This function takes the `pendingIntent` and `channelId` instances generated
    from the functions you created earlier and constructs a `NotificationCompat.Builder`
    class.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受您之前创建的函数生成的`pendingIntent`和`channelId`实例，并构建一个`NotificationCompat.Builder`类。
- en: The builder lets you define a title (the first row), text (the second row),
    a small icon (size differs based on the device) to use, the `Intent` to be triggered
    when the user clicks on **Notification**, and a ticker (used for accessibility;
    before Android Lollipop, this showed before the notification was presented).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 构建器允许您定义标题（第一行）、文本（第二行）、要使用的小图标（大小根据设备而异）、当用户点击**Notification**时触发的`Intent`以及一个标签（用于辅助功能；在Android
    Lollipop之前，在通知显示之前显示）。
- en: Setting the notification to ongoing prevents users from dismissing them. This
    also prevents Android from muting the notification due to frequent updates.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 将通知设置为持续状态可以防止用户将其取消。这也防止了Android因频繁更新而静音通知。
- en: You can set other properties, too. Explore the `NotificationCompat.Builder`
    class. In a real project, remember to use string resources from `strings.xml`
    rather than hardcoded strings.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以设置其他属性。探索`NotificationCompat.Builder`类。在实际项目中，请记住使用`strings.xml`中的字符串资源而不是硬编码的字符串。
- en: 'Implement the following code to introduce a function to start the foreground
    service:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现以下代码以引入一个启动前台服务的函数：
- en: '[PRE26]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You first get `PendingIntent` using the `getPendingIntent` function you introduced
    earlier. Then, depending on the API level of the device, you create a notification
    channel and get its ID or set an empty ID.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您首先使用您之前引入的`getPendingIntent`函数获取`PendingIntent`。然后，根据设备的API级别，您创建一个通知通道并获取其ID或设置一个空ID。
- en: You pass `pendingIntent` and `channelId` to the function that constructs a `NotificationCompat.Builder`
    and start the service as a Foreground Service, providing it with `NOTIFICATION_ID`
    and a notification built using the builder. The function returns `NotificationCompat.Builder`,
    to be used later to update the notification.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您将`pendingIntent`和`channelId`传递给构建`NotificationCompat.Builder`的函数，并以前台服务的方式启动服务，提供`NOTIFICATION_ID`和由构建器构建的通知。该函数返回`NotificationCompat.Builder`，稍后用于更新通知。
- en: 'Define two fields in your service—one to hold a reusable `NotificationCompat.Builder`
    class, and another to hold a reference to `Handler`, which you will later use
    to post work in the background:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的服务中定义两个字段——一个用于持有可重用的`NotificationCompat.Builder`类，另一个用于持有`Handler`的引用，您稍后将在后台使用它来发布工作：
- en: '[PRE27]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, override `onCreate()` to start the service as a foreground service and
    keep a reference of the `Notification.Builder`, and create `serviceHandler`:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，重写`onCreate()`以将服务作为前台服务启动，并保留`Notification.Builder`的引用，然后创建`serviceHandler`：
- en: '[PRE28]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note that to create the `Handler` instance, you must first initialize and start
    `HandlerThread`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，要创建`Handler`实例，你必须首先初始化并启动`HandlerThread`。
- en: 'Define a call that tracks your deployed SCA as it approaches its designated
    destination:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个跟踪你部署的SCA在接近其指定目的地时的调用：
- en: '[PRE29]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This will first obtain a reference to the `NotificationManager`. Then, it will
    count down from `10` to `0`, sleeping for 1 second between updates and then updating
    the notification with the remaining time. Note we set the notification to be silent.
    This avoids the notification playing a sound every second.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这将首先获取`NotificationManager`的引用。然后，它将从`10`倒数到`0`，在更新之间睡眠1秒，然后使用剩余时间更新通知。注意我们设置了静默通知。这避免了通知每秒播放声音。
- en: 'Add a function to notify observers of completion on the main thread:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个在主线程上通知观察者完成情况的函数：
- en: '[PRE30]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: By posting on a handler using the main `Looper`, you make sure that updates
    occur on the main (UI) app thread. When setting the value to the agent ID, you
    are notifying all observers that that agent ID has reached its destination.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在主`Looper`上发布消息，你确保更新发生在主（UI）应用线程上。当设置代理ID的值时，你是在通知所有观察者该代理ID已到达目的地。
- en: 'Override `onStartCommand(Intent?, Int, Int)` like so:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式重写`onStartCommand(Intent?, Int, Int)`：
- en: '[PRE31]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You first delegate the call to `super`, which internally calls `onStart()` and
    returns a backward-compatible state you could return. You store this returned
    value. Next, you obtain the SCA ID from the extras passed via the `Intent`. This
    service will not work without an agent ID, so you throw an exception if one is
    not provided.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先将调用委托给`super`，它内部调用`onStart()`并返回一个向后兼容的状态，你可以返回这个状态。你存储这个返回值。接下来，你从通过`Intent`传递的额外内容中获取SCA
    ID。如果没有提供代理ID，该服务将无法工作，因此你抛出一个异常。
- en: Next, you switch to the background thread defined in `onCreate` to track the
    agent to its destination in a blocking way. When tracking is done, you notify
    observers that the task is complete, stop the foreground service (removing the
    notification by passing `true`), and stop the service itself, as you don’t expect
    to require it again soon. You then return the earlier stored return value from
    `super`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你切换到`onCreate`中定义的背景线程，以阻塞方式跟踪代理到其目的地。当跟踪完成时，你通知观察者任务已完成，停止前台服务（通过传递`true`移除通知），并停止服务本身，因为你不期望很快再次需要它。然后你返回之前存储的从`super`返回的值。
- en: 'Update your `AndroidManifest.xml` file to request the necessary permissions
    and introduce the service:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新你的`AndroidManifest.xml`文件以请求必要的权限并引入服务：
- en: '[PRE32]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: First, we declare that our app requires the `FOREGROUND_SERVICE` permission.
    Unless we do so, the system will block our app from using foreground services.
    We also request the `POST_NOTIFICATIONS` permission, without which we cannot present
    notifications on SDK 33+. Next, we declare the service. Setting `android:enabled="true"`
    tells the system it can instantiate the service.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明我们的应用需要`FOREGROUND_SERVICE`权限。除非我们这样做，否则系统会阻止我们的应用使用前台服务。我们还请求`POST_NOTIFICATIONS`权限，没有这个权限，我们无法在SDK
    33+上显示通知。接下来，我们声明服务。设置`android:enabled="true"`告诉系统它可以实例化该服务。
- en: The default is `"true"`, so this is optional. Defining the service with `android:exported="true"`
    tells the system that other applications can start the service. In our case, we
    don’t need this extra functionality, but we have added it just so that you are
    aware of this capability.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值为`"true"`，因此这是可选的。使用`android:exported="true"`定义服务告诉系统其他应用程序可以启动该服务。在我们的情况下，我们不需要这个额外的功能，但我们添加它只是为了让你了解这种能力。
- en: 'Back to your `MainActivity`. Introduce a function to launch `RouteTrackingService`:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到你的`MainActivity`。引入一个用于启动`RouteTrackingService`的函数：
- en: '[PRE33]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This function first observes the `trackingCompletion` `LiveData` for completion
    updates, showing a result on completion. Then, it defines an `Intent` for launching
    the service, setting the SCA ID as an extra parameter for that `Intent`. It then
    launches the service as a foreground service using `ContextCompat`, which hides
    away compatibility-related logic for you.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数首先观察`trackingCompletion` `LiveData`以获取完成更新，并在完成时显示结果。然后，它定义一个用于启动服务的`Intent`，将SCA
    ID作为该`Intent`的额外参数。然后，它使用`ContextCompat`以前台服务的方式启动服务，这为您隐藏了兼容性相关的逻辑。
- en: Now, extract the logic from `onCreate()` (everything that comes after the `setContentView`
    call) to a private function named `dispatchCat`.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`onCreate()`中的逻辑（`setContentView`调用之后的所有内容）提取到一个名为`dispatchCat`的私有函数中。
- en: 'Update `dispatchCat` to start tracking the SCA as soon as it is suited up and
    ready to go:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`dispatchCat`更新为在SCA装备完毕并准备出发时立即开始跟踪：
- en: '[PRE34]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Create a new private function called `ensurePermissionGrantedAndDispatchCat`.
    In this function, make sure you have the `POST_NOTIFICATIONS` permission. Request
    it if you don’t. Refer to [*Chapter 7*](B19411_07.xhtml#_idTextAnchor421), *Android
    Permissions and Google Maps*, for the implementation details. If or when you have
    the permission, call `dispatchCat`.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ensurePermissionGrantedAndDispatchCat`的新私有函数。在这个函数中，确保你有`POST_NOTIFICATIONS`权限。如果没有，请请求它。有关实现细节，请参阅[*第7章*](B19411_07.xhtml#_idTextAnchor421)，*Android权限和Google
    Maps*。如果你或你有权限，请调用`dispatchCat`。
- en: 'Launch the app:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动应用程序：
- en: '![Figure 8.2 – The notification counting down](img/B19411_08_02.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – 通知倒计时](img/B19411_08_02.jpg)'
- en: Figure 8.2 – The notification counting down
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 通知倒计时
- en: After the notifications informing you of the SCA’s preparation steps, you should
    see a notification in your status bar. That notification should then count down
    from 10 to 0, disappear, and be replaced by a toast informing you that the agent
    arrived at its destination. Seeing that last toast tells you that you managed
    to communicate the SCA ID to the service as well as get it back on completion
    of the background task.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在通知告知你SCA的准备工作步骤之后，你应该在你的状态栏中看到一个通知。然后，该通知应从10倒数到0，消失，并替换为一个吐司通知，告知你代理已到达目的地。看到最后一个吐司通知告诉你，你成功将SCA
    ID传达给了服务，并在后台任务完成后将其返回。
- en: With all the knowledge gained from this chapter, let’s complete the following
    activity.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 利用本章获得的所有知识，让我们完成以下活动。
- en: Activity 8.01 – reminder to drink water
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动8.01 – 喝水提醒
- en: The average human loses about 2,500 **milliliters** (**ml**) of water per day.
    To stay healthy, we need to consume as much water as we lose. However, due to
    the busy nature of modern life, a lot of us forget to stay hydrated regularly.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 人类平均每天会流失大约2,500 **毫升**（**ml**）的水。为了保持健康，我们需要消耗与流失相等的水量。然而，由于现代生活的繁忙性质，我们很多人会忘记定期补充水分。
- en: Note
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: See [https://packt.link/90nbQ](https://packt.link/90nbQ) for more information
    on this.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此信息的更多信息，请参阅[https://packt.link/90nbQ](https://packt.link/90nbQ)。
- en: Suppose you wanted to develop an app that keeps track of your water loss (statistically)
    and gives you a constant update on your fluid balance. Starting from a balanced
    state, the app would gradually decrease the user’s tracked water level. The user
    could tell the app when they drank a glass of water, and it would update the water
    level accordingly.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想开发一个应用程序，该应用程序可以跟踪你的水分流失（统计上）并持续更新你的体液平衡。从平衡状态开始，应用程序会逐渐降低用户跟踪的水位。用户可以在喝了一杯水后告诉应用程序，应用程序会相应地更新水位。
- en: The continuous updating of the water level will leverage your knowledge of running
    a background task, and you will also utilize your knowledge of communicating with
    a service to update a balance in response to user interaction.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 水位持续更新的过程将利用你运行后台任务的知识，你还将利用与服务通信的知识来根据用户交互更新余额。
- en: 'The following steps will help you complete the activity:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成活动：
- en: Create an empty activity project and name your app `My` `Water Tracker`.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空的活动项目，并将你的应用程序命名为`My Water Tracker`。
- en: Add the foreground service and post notifications permissions to your `AndriodManifest.xml`
    file.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将前台服务和发布通知权限添加到你的`AndroidManifest.xml`文件中。
- en: Create a new service.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的服务。
- en: Define a variable in your service to track the water level.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的服务中定义一个变量来跟踪水位。
- en: Define constants for a notification ID and for an extra `Intent` data key.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义通知ID和额外的`Intent`数据键的常量。
- en: Set up the creation of the notification from the service.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从服务中设置通知的创建。
- en: Add functions to request the notification permissions (if required), start the
    Foreground Service and update the water level.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加请求通知权限（如果需要）、启动前台服务和更新水位的功能。
- en: Set the water level to decrease by 0.144 ml every 5 seconds.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将水位设置为每5秒降低0.144毫升。
- en: Handle the addition of fluids from outside the service.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理来自服务外部的液体添加。
- en: Make sure the service cleans up callbacks and messages when destroyed.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保服务在销毁时清理回调和消息。
- en: Register the service in the `Manifest.xml` file.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Manifest.xml`文件中注册服务。
- en: Start the service from `MainActivity` when the activity is created, after the
    notification permission is granted, if needed.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建活动并在必要时授予通知权限后，从`MainActivity`启动服务。
- en: Add a button to the main activity layout with a **Drank a Glass of** **Water**
    label.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主活动布局中添加一个带有**喝了一杯水**标签的按钮。
- en: When the user clicks the button, notify the service that it needs to increment
    the water level by 250 ml.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户点击按钮时，通知服务需要增加250毫升的水位。
- en: Note
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found at [https://packt.link/By7eE](https://packt.link/By7eE).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 该活动的解决方案可在[https://packt.link/By7eE](https://packt.link/By7eE)找到。
- en: Summary
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to execute long-running background tasks using
    `WorkManager` and foreground services. We discussed how to communicate progress
    to the user, and how to get the user back into an app once a task is finished
    executing. All the topics covered in this chapter are quite broad, and you could
    explore communicating with services, building notifications, and using the `WorkManager`
    class further.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用`WorkManager`和前台服务执行长时间运行的后台任务。我们讨论了如何向用户传达进度，以及如何在任务执行完成后将用户带回应用。本章涵盖的所有主题都非常广泛，你可以进一步探索与服务通信、构建通知和使用`WorkManager`类。
- en: For most common scenarios, you now have the tools you need. Common use cases
    include background downloads, the background cleaning up of cached assets, playing
    media while the app is not running in the foreground, and, combined with the knowledge
    we gained from [*Chapter 7*](B19411_07.xhtml#_idTextAnchor421), *Android Permissions
    and Google Maps*, tracking the user’s location over time.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数常见场景，你现在拥有了所需的工具。常见的用例包括后台下载、清理缓存资源、在应用不在前台运行时播放媒体，以及结合我们从[*第7章*](B19411_07.xhtml#_idTextAnchor421)学到的知识，即*Android权限和Google
    Maps*，跟踪用户随时间变化的位置。
- en: In the next chapter, we will look into making our apps more robust and maintainable
    by writing unit and integration tests. This is particularly helpful when the code
    you write runs in the background, and it is not immediately evident when something
    goes wrong.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨通过编写单元和集成测试来使我们的应用更加健壮和易于维护。这在你的代码在后台运行且错误发生时并不立即明显的情况下尤其有帮助。
