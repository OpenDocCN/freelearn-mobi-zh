- en: '*Chapter 5*: Using Kotlin Flows'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第五章*：使用 Kotlin Flows'
- en: In the previous three chapters, we dove into Kotlin coroutines and learned how
    we can use them for asynchronous programming in Android. We learned about coroutine
    builders, scopes, dispatchers, contexts, and jobs. We then learned how to handle
    coroutine cancelations, timeouts, and exceptions. We also learned how to create
    tests for coroutines in your code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前三章中，我们深入探讨了 Kotlin 协程，并学习了如何在 Android 中使用它们进行异步编程。我们学习了协程构建器、作用域、调度器、上下文和作业。然后我们学习了如何处理协程取消、超时和异常。我们还学习了如何在代码中对协程进行测试。
- en: In the next three chapters, we will focus on Kotlin Flow, a new asynchronous
    stream library built on top of Kotlin coroutines. A flow can emit multiple values
    over a length of time instead of just a single value. You can use Flows for streams
    of data, such as real-time location, sensor readings, and live database values.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的三章中，我们将重点关注 Kotlin Flow，这是一个基于 Kotlin 协程构建的新异步流库。Flow 可以在一段时间内发出多个值，而不仅仅是单个值。你可以使用
    Flows 来处理数据流，例如实时位置、传感器读数和实时数据库值。
- en: In this chapter, we will explore Kotlin Flows. We will start by building Kotlin
    Flows. Then, we will look into the various operators you can use for transforming,
    combining, buffering, and doing more with Flows. Finally, we will learn about
    StateFlows and SharedFlows.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探索 Kotlin Flows。我们将从构建 Kotlin Flows 开始。然后，我们将探讨你可以用于转换、组合、缓冲以及更多 Flows
    的各种操作符。最后，我们将了解 StateFlows 和 SharedFlows。
- en: 'This chapter covers the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主要主题：
- en: Using Flows in Android
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Android 中使用 Flows
- en: Creating Flows with Flow builders
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Flow 构建器创建 Flows
- en: Using operators with Flows
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Flows 的操作符
- en: Buffering and combining Flows
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓冲和组合 Flows
- en: Exploring StateFlow and SharedFlow
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 StateFlow 和 SharedFlow
- en: By the end of this chapter, you will have a deeper understanding of using Kotlin
    Flows. You will be able to use Flows for various cases in your Android apps. You
    will also learn about flow builders, operators, combining flows, StateFlow, and
    SharedFlow.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将更深入地了解使用 Kotlin Flows。你将能够在你 Android 应用程序的各种情况下使用 Flows。你还将了解流构建器、操作符、组合
    Flows、StateFlow 和 SharedFlow。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will need to download and install the latest version of Android Studio.
    You can find the latest version at [https://developer.android.com/studio](https://developer.android.com/studio).
    For an optimal learning experience, a computer with the following specifications
    is recommended:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要下载并安装 Android Studio 的最新版本。你可以在 [https://developer.android.com/studio](https://developer.android.com/studio)
    找到最新版本。为了获得最佳学习体验，建议使用以下配置的计算机：
- en: Intel Core i5 or equivalent or higher
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 英特尔酷睿 i5 或更高性能的处理器
- en: 4 GB RAM minimum
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少 4 GB RAM
- en: 4 GB available space
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 GB 可用空间
- en: The code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Simplifying-Android-Development-with-Coroutines-and-Flows/tree/main/Chapter05](https://github.com/PacktPublishing/Simplifying-Android-Development-with-Coroutines-and-Flows/tree/main/Chapter05).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码示例可以在 GitHub 上找到，地址为 [https://github.com/PacktPublishing/Simplifying-Android-Development-with-Coroutines-and-Flows/tree/main/Chapter05](https://github.com/PacktPublishing/Simplifying-Android-Development-with-Coroutines-and-Flows/tree/main/Chapter05)。
- en: Using Flows in Android
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Android 中使用 Flows
- en: In this section, we will start by using flows in Android for asynchronous programming.
    Flows are ideal for the parts of your application that involve live data updates.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将首先使用 Android 中的 Flows 进行异步编程。Flows 对于涉及实时数据更新的应用程序部分来说非常理想。
- en: A Flow of data is represented by the `Flow<String>` is a flow that emits string
    values.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 数据流由 `Flow<String>` 表示，这是一个发出字符串值的 Flow。
- en: Android Jetpack libraries such as Room, Paging, DataStore, WorkManager, and
    Jetpack Compose include built-in support for Flow.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Android Jetpack 库，如 Room、Paging、DataStore、WorkManager 和 Jetpack Compose，都内置了对
    Flow 的支持。
- en: The Room database library added support for Flows, starting with version 2.2\.
    This allows you to be notified of changes in the database values by using Flows.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Room 数据库库从 2.2 版本开始支持 Flows。这允许你通过使用 Flows 来通知数据库值的变化。
- en: 'If your Android application uses a **Data Access Object** (**DAO**) to display
    a list of movies, your project can have a DAO such as the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 Android 应用程序使用 **数据访问对象**（**DAO**）来显示电影列表，你的项目可以有一个如下所示的 DAO：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: By calling the `getMovies` function from `MovieDao`, you can get the list of
    movies from the database.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从 `MovieDao` 调用 `getMovies` 函数，你可以从数据库中获取电影列表。
- en: 'The preceding code will only fetch the list of movies once, after calling `getMovies`.
    You may want your application to automatically update the list of movies whenever
    a movie in the database has been added, removed, or updated. You can do that by
    using Room-KTX and changing your `MovieDao` to use Flow for `getMovies`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码在调用`getMovies`后只会获取一次电影列表。你可能希望你的应用程序在数据库中的电影被添加、删除或更新时自动更新电影列表。你可以通过使用Room-KTX并将你的`MovieDao`更改为使用Flow来`getMovies`来实现这一点：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With this code, every time the `movies` table has a change, `getMovies` will
    emit a new list containing the list of movies from the database. Your application
    can then use that to automatically update the movies displayed in your List or
    `RecyclerView`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此代码，每当`movies`表发生变化时，`getMovies`将发出一个包含数据库中电影列表的新列表。然后你的应用程序可以使用它来自动更新列表或`RecyclerView`中显示的电影。
- en: If you are using `LiveData` and want to convert `LiveData` to `Flow`, or `Flow`
    to `LiveData`, you can use the LiveData KTX.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`LiveData`并想将`LiveData`转换为`Flow`或`Flow`转换为`LiveData`，你可以使用LiveData KTX。
- en: 'To convert `LiveData` to `Flow`, you can use the `LiveData.asFlow()` extension
    function. With the `Flow.asLiveData()` extension function to convert `Flow` to
    `LiveData`. You can add LiveData KTX to your project by including the following
    to your `app/build.gradle` dependencies:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要将`LiveData`转换为`Flow`，你可以使用`LiveData.asFlow()`扩展函数。使用`Flow.asLiveData()`扩展函数将`Flow`转换为`LiveData`。你可以通过在你的`app/build.gradle`依赖项中包含以下内容将LiveData
    KTX添加到你的项目中：
- en: '[PRE12]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This adds the LiveData KTX to your project, allowing you to use the `asFlow()`
    and `asLiveData()` extension functions to convert `LiveData` to `Flow` and `Flow`
    to `LiveData`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这将LiveData KTX添加到你的项目中，允许你使用`asFlow()`和`asLiveData()`扩展函数将`LiveData`转换为`Flow`和`Flow`转换为`LiveData`。
- en: Third-party Android libraries now also support Flows; some functions can return
    Flow objects. If you are using RxJava 3 in your project, you can use the `Flow`
    to `Flowable` or `Observable` and vice versa.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方Android库现在也支持Flows；一些函数可以返回Flow对象。如果你在项目中使用RxJava 3，你可以使用`Flow`到`Flowable`或`Observable`，反之亦然。
- en: A flow will only start emitting values when you call the `collect` function.
    The `collect` function is a suspending function, so you should call it from a
    coroutine or another suspending function.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用`collect`函数时，Flow才会开始发出值。`collect`函数是一个挂起函数，所以你应该从协程或另一个挂起函数中调用它。
- en: 'In the following example, the `collect()` function was called from the coroutine
    created using the `launch` coroutine builder from `lifecycleScope`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，`collect()`函数是从使用`lifecycleScope`中的`launch`协程构建器创建的协程中调用的：
- en: '[PRE17]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this example, the `collect{}` function was called on `Flow<Movie>` and returned
    by calling `viewModel.fetchMovies()`. This will cause the Flow to start emitting
    values, and you can then process each value.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`collect{}`函数被调用在`Flow<Movie>`上，并通过调用`viewModel.fetchMovies()`返回。这将导致Flow开始发出值，然后你可以处理每个值。
- en: The collection of the flow occurs in `CoroutineContext` of the parent coroutine.
    In the previous example, the coroutine context is from `viewModelScope`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 流的收集发生在父协程的`CoroutineContext`中。在上面的例子中，协程上下文来自`viewModelScope`。
- en: 'To change `CoroutineContext` where the Flow is run, you can use the `flowOn()`
    function. If you want to change `Dispatcher` on the Flow in the previous example
    to `Dispatchers.IO)`, you can use `flowOn(Dispatchers.IO)`, as shown in the following
    example:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改Flow运行的`CoroutineContext`，你可以使用`flowOn()`函数。如果你想将前一个例子中的Flow的`Dispatcher`更改为`Dispatchers.IO`，你可以使用`flowOn(Dispatchers.IO)`，如下面的例子所示：
- en: '[PRE34]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here, before collecting the Flow, the dispatcher where the Flow is run was changed
    to `Dispatchers.IO` by calling `flowOn` with `Dispatchers.IO`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在收集Flow之前，通过调用`flowOn`并使用`Dispatchers.IO`，将Flow运行的调度器更改为`Dispatchers.IO`。
- en: 'When you call `flowOn`, it will only change the preceding functions or operators
    and not the ones after you called it. In the following example, a `map` operator
    was called after the `flowOn` call to change the dispatcher, so its context won’t
    be changed:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用`flowOn`时，它只会改变调用之前的函数或操作符，而不会改变调用之后的。在下面的例子中，在调用`flowOn`之后调用了`map`操作符来更改分发器，因此其上下文不会改变：
- en: '[PRE47]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In this example, `flowOn` will only change the context of the ones preceding
    the call, so the `map` call will not be changed. It will still use the original
    context (which is the one from `lifecycleScope`).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`flowOn`只会改变调用之前的上下文，所以`map`调用不会改变。它仍然会使用原始上下文（即来自`lifecycleScope`的上下文）。
- en: In Android, you can collect Flow in the Fragment or Activity classes to display
    the data in the UI. If the UI goes to the background, your Flow will keep on collecting
    the data. Your app must not continue collecting the Flow and updating the screen
    to prevent memory leaks and avoid wasting resources.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 中，你可以在 Fragment 或 Activity 类中收集 Flow 以在 UI 中显示数据。如果 UI 进入后台，你的 Flow
    将继续收集数据。你的应用必须停止收集 Flow 并更新屏幕，以防止内存泄漏和避免资源浪费。
- en: 'To safely collect flows in the Android UI layer, you would need to handle the
    lifecycle changes yourself. You can also use `Lifecycle.repeatOnLifecycle` and
    `Flow.flowWithLifecycle`, which are available in the `app/build.gradle` dependencies:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 Android UI 层面上安全地收集 Flows，你需要自己处理生命周期变化。你也可以使用 `Lifecycle.repeatOnLifecycle`
    和 `Flow.flowWithLifecycle`，这些在 `app/build.gradle` 依赖中可用：
- en: '[PRE61]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This adds the `Lifecycle.repeatOnLifecycle` and `Flow.flowWithLifecycle`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这添加了 `Lifecycle.repeatOnLifecycle` 和 `Flow.flowWithLifecycle`。
- en: '`Lifecycle.repeatOnLifecycle(state, block)` suspends the parent coroutine until
    the lifecycle is destroyed and executes the suspending `block` of code when the
    lifecycle is at least in `state` you set. When the lifecycle moves out of the
    state, `repeatOnLifecycle` will stop the Flow and restart it when the lifecycle
    moves back to the said state.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lifecycle.repeatOnLifecycle(state, block)` 将父协程挂起，直到生命周期被销毁，并在生命周期至少处于你设置的
    `state` 时执行挂起的 `block` 代码。当生命周期离开该状态时，`repeatOnLifecycle` 将停止 Flow 并在生命周期回到该状态时重新启动。'
- en: If you used `repeatOnLifecycle` will start collecting the Flow whenever the
    lifecycle is started. It will stop when the lifecycle is stopped, when the `onStop()`
    of the lifecycle is called.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用了 `repeatOnLifecycle`，它将在生命周期启动时开始收集 Flow。它将在生命周期停止、调用生命周期的 `onStop()`
    时停止。
- en: When you use `repeatOnLifecycle` will start collecting the Flow every time the
    lifecycle is resumed and will stop when the lifecycle is paused or when `onPause()`
    is called.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `repeatOnLifecycle` 时，它将在每次生命周期恢复时开始收集 Flow，并在生命周期暂停或调用 `onPause()` 时停止。
- en: It is recommended to call `Lifecycle.repeatOnLifecycle` on the activity’s `onCreate`
    or on the fragment’s `onViewCreated` functions.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 建议在活动的 `onCreate` 方法或片段的 `onViewCreated` 方法中调用 `Lifecycle.repeatOnLifecycle`。
- en: 'The following shows how you can use `Lifecycle.repeatOnLifecycle` in your Android
    project:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下展示了如何在你的 Android 项目中使用 `Lifecycle.repeatOnLifecycle`：
- en: '[PRE66]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Here, we used `repeatOnLifecycle` with **Lifecycle.State.STARTED** to start
    collecting the Flow of movies when the lifecycle is started and stop when the
    lifecycle is stopped.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用了 `repeatOnLifecycle` 与 **Lifecycle.State.STARTED** 来在生命周期启动时开始收集电影流，并在生命周期停止时停止。
- en: 'You can use `Lifecycle.repeatOnLifecycle` to collect more than one Flow. To
    do so, you must collect them in parallel in different coroutines:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `Lifecycle.repeatOnLifecycle` 收集多个 Flow。为此，你必须在不同协程中并行收集它们：
- en: '[PRE80]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Here, there are two Flows: one to collect the movies and the other to collect
    the TV shows. The collections of the Flow are started from separate `launch` coroutine
    builders.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个 Flows：一个用于收集电影，另一个用于收集电视剧。Flow 的收集是从不同的 `launch` 协程构建器开始的。
- en: 'If you only have one Flow to collect, you can also use `Flow.flowWithLifecycle`.
    This emits values from the upstream Flow (the Flow and operators preceding the
    call) when the lifecycle is at least in `Lifecycle.repeatOnLifecycle` internally.
    You can use `Flow.flowWithLifecycle` as shown in the following code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只有一个 Flow 要收集，你也可以使用 `Flow.flowWithLifecycle`。当生命周期至少处于 `Lifecycle.repeatOnLifecycle`
    内部时，它会从上游 Flow（调用之前的 Flow 和操作符）发出值。你可以像以下代码所示使用 `Flow.flowWithLifecycle`：
- en: '[PRE100]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: In this example, you used `flowWithLifecycle` with **Lifecycle.State.STARTED**
    to start collecting the Flow of movies when the lifecycle is started and stop
    if the lifecycle is stopped.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你使用了 `flowWithLifecycle` 与 **Lifecycle.State.STARTED** 来在生命周期启动时开始收集电影流，并在生命周期停止时停止。
- en: In this section, you have learned about using Kotlin Flows in your Android app.
    You can use Flow in Android Jetpack libraries such as Room and even in third-party
    libraries. To safely collect flows in the UI layer and prevent memory leaks and
    avoid wasting resources, you can use `Lifecycle.repeatOnLifecycle` and `Flow.flowWithLifecycle`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了如何在你的 Android 应用中使用 Kotlin Flows。你可以在 Room 等Android Jetpack 库以及第三方库中使用
    Flow。为了在 UI 层面上安全地收集 Flows 并防止内存泄漏以及避免资源浪费，你可以使用 `Lifecycle.repeatOnLifecycle`
    和 `Flow.flowWithLifecycle`。
- en: In the next section, we will be looking into the different Flow builders you
    can use to create Flows for your application.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨你可以用于为你的应用程序创建 Flows 的不同 Flow 构建器。
- en: Creating Flows with Flow builders
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Flow 构建器创建 Flows
- en: In this section, we will start by looking at creating Flows. To create a Flow,
    you can use a Flow builder.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将首先探讨创建 Flows。要创建一个 Flow，你可以使用 Flow 构建器。
- en: 'The Kotlin Flow API has flow builders that you can use to create Flows. The
    following are the Kotlin Flow builders you can use:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin Flow API 有你可以用来创建 Flows 的流构建器。以下是你可以使用 Kotlin Flow 构建器：
- en: '`flow {}`'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flow {}`'
- en: '`flowOf()`'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flowOf()`'
- en: '`asFlow()`'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asFlow()`'
- en: 'The `flow` builder function creates a new Flow from a suspendable lambda block.
    Inside the block, you can send values using the `emit` function. For example,
    this `fetchMovieTitles` function of `MovieViewModel` returns `Flow<String>`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`flow` 构建器函数从一个可挂起 lambda 块创建一个新的 Flow。在块内部，你可以使用 `emit` 函数发送值。例如，这个 `MovieViewModel`
    的 `fetchMovieTitles` 函数返回 `Flow<String>`：'
- en: '[PRE114]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: In this example, `fetchMovieTitles` created a Flow with the movie titles. It
    iterated over the list of movies from `fetchMoviesFromNetwork` and, for each movie,
    emitted the movie’s title with the `emit` function.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`fetchMovieTitles` 创建了一个包含电影标题的 Flow。它遍历了从 `fetchMoviesFromNetwork` 获取的电影列表，并为每部电影使用
    `emit` 函数发出电影的标题。
- en: 'With the `flowOf` function, you can create a Flow that produces the specified
    value or `vararg` values. In the following example, the `flowOf` function is used
    to create a Flow of the titles of the top three movies:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `flowOf` 函数，你可以创建一个生成指定值或 `vararg` 值的 Flow。在下面的示例中，`flowOf` 函数被用来创建一个包含前三部电影标题的
    Flow：
- en: '[PRE126]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Here, `fetchTop3Titles` uses `flowOf` to create a Flow containing the titles
    of the first three movies.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`fetchTop3Titles` 使用 `flowOf` 创建了一个包含前三部电影标题的 Flow。
- en: 'The `asFlow()` extension function allows you to convert a type into a Flow.
    You can use this on sequences, arrays, ranges, collections, and functional types.
    For example, this `MovieViewModel` has `fetchMovieIds` that returns `Flow<Int>`,
    containing the movie IDs:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`asFlow()` 扩展函数允许你将类型转换为 Flow。你可以在序列、数组、范围、集合和函数类型上使用它。例如，这个 `MovieViewModel`
    有 `fetchMovieIds` 返回 `Flow<Int>`，包含电影 ID：'
- en: '[PRE139]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: In this example, we used a `map` function on the list of movies to create a
    list of the movie IDs. The list of movie IDs was then converted to `Flow<String>`
    by using the `asFlow()` extension function on it.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们在电影列表上使用了一个 `map` 函数来创建一个电影 ID 的列表。然后，使用 `asFlow()` 扩展函数将该电影 ID 列表转换为
    `Flow<String>`。
- en: In this section, we learned how you can create Flows with Flow Builders. In
    the next section, we will check out the various Kotlin Flow operators you can
    use to transform, combine, and do more with Flows.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用 Flow 构建器创建 Flows。在下一节中，我们将检查你可以用于转换、组合和更多操作 Flows 的各种 Kotlin
    Flow 操作符。
- en: Using operators with Flows
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用操作符与 Flows 一起使用
- en: In this section, we will focus on the various Flow operators. Kotlin Flow has
    built-in operators that you can use with Flows. We can collect flows with terminal
    operators and transform Flows with Intermediate operators.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重点关注各种 Flow 操作符。Kotlin Flow 有内置的操作符，你可以与 Flows 一起使用。我们可以使用终端操作符收集 Flows，并使用中间操作符转换
    Flows。
- en: Collecting Flows with terminal operators
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用终端操作符收集 Flows
- en: In this section, we will explore the terminal operators you can use on Flows
    to start the collection of a Flow. The `collect` function we used in the previous
    examples is the most used terminal operator. However, there are other built-in
    terminal Flow operators.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨你可以用于在 Flows 上启动收集的终端操作符。我们在前面的示例中使用的 `collect` 函数是最常用的终端操作符。然而，还有其他内置的终端
    Flow 操作符。
- en: 'The following are the built-in terminal Flow operators you can use to start
    the collection of the Flow:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你可以使用以启动 Flow 收集的内置终端 Flow 操作符：
- en: '`toList`: Collects the Flow and converts it into a list'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toList`：收集 Flow 并将其转换为列表'
- en: '`toSet`: Collects the Flow and converts it into a set'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toSet`：收集 Flow 并将其转换为集合'
- en: '`toCollection`: Collects the Flow and converts it into a collection'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toCollection`：收集 Flow 并将其转换为集合'
- en: '`count`: Returns the number of elements in the Flow'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count`：返回 Flow 中的元素数量'
- en: '`first`: Returns the Flow’s first element or throws a **NoSuchElementException**
    if the Flow was empty'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`first`：返回 Flow 的第一个元素，如果 Flow 为空则抛出 **NoSuchElementException**'
- en: '`firstOrNull`: Returns the Flow’s first element or null if the Flow was empty'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`firstOrNull`：返回 Flow 的第一个元素，如果 Flow 为空则返回 null'
- en: '`last`: Returns the Flow’s last element or throws a **NoSuchElementException**
    if the Flow was empty'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`last`: 返回流的最后一个元素，如果流为空则抛出**NoSuchElementException**'
- en: '`lastOrNull`: Returns the Flow’s last element or null if the Flow was empty'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lastOrNull`: 返回流的最后一个元素，如果流为空则返回null'
- en: '`single`: Returns the single element emitted or throws an exception if the
    Flow was empty or had more than one value'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`single`: 返回流中发出的单个元素，如果流为空或包含多个值则抛出异常'
- en: '`singleOrNull`: Returns the single element emitted or null if the Flow was
    empty or had more than one value'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`singleOrNull`: 返回流中发出的单个元素，如果流为空或包含多个值则返回null'
- en: '`reduce`: Applies a function to each item emitted, starting from the first
    element, and returns the accumulated result'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reduce`: 对每个发出的项目应用一个函数，从第一个元素开始，并返回累积的结果'
- en: '`fold`: Applies a function to each item emitted, starting from the initial
    value set, and returns the accumulated result'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fold`: 对每个发出的项目应用一个函数，从初始值开始，并返回累积的结果'
- en: These terminal Flow operators work like the Kotlin collection functions with
    the same name in the standard Kotlin library.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这些终端流操作符与标准Kotlin库中具有相同名称的Kotlin集合函数类似。
- en: 'In the following example, the `firstOrNull` terminal operator is used instead
    of the `collect` operator to collect the Flow from `ViewModel`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，使用`firstOrNull`终端操作符代替`collect`操作符来从`ViewModel`收集流：
- en: '[PRE149]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: Here, `firstOrNull` was used on the Flow to get the first item (or null if the
    Flow was empty), which represents the top movie. It will then be displayed on
    the screen.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`firstOrNull`被用于流以获取第一个项目（如果流为空则为null），这代表顶级电影。然后它将在屏幕上显示。
- en: In this section, you learned about the Flow terminal operators you can use to
    start collecting from a Flow. In the next section, we will learn how to transform
    Flows with Intermediate operators.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你了解了可以使用哪些流的终端操作符来开始从流中收集数据。在下一节中，我们将学习如何使用中间操作符转换流。
- en: Transforming Flows with Intermediate operators
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用中间操作符转换流
- en: In this section, we will focus on Intermediate flow operators that you can use
    to transform Flows. With Intermediate operators, you can return a new Flow based
    on the original one.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将关注你可以用来转换流的中间流操作符。使用中间操作符，你可以根据原始流返回一个新的流。
- en: Intermediate operators allow you to modify a Flow and return a new one. You
    can chain various operators, and they will be applied sequentially.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 中间操作符允许你修改一个流并返回一个新的流。你可以链接各种操作符，并且它们将按顺序应用。
- en: 'You can transform the Flow by applying operators on them, as you can do with
    Kotlin collections. The following Intermediate operators work similarly to the
    Kotlin collection functions with the same name:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过对它们应用操作符来转换流，就像你可以对Kotlin集合做的那样。以下中间操作符与具有相同名称的Kotlin集合函数类似：
- en: '`filter`: Returns a Flow that selects only the values from the Flow that meet
    the condition you passed'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter`: 返回一个流，仅选择满足你传递的条件的流中的值'
- en: '`filterNot`: Returns a Flow that selects only the values from the Flow that
    do not meet the condition you passed'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filterNot`: 返回一个流，仅选择不满足你传递的条件的流中的值'
- en: '`filterNotNull`: Returns a Flow that only includes values from the original
    Flow that are not null'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filterNotNull`: 返回一个流，仅包含来自原始流且不为null的值'
- en: '`filterIsInstance`: Returns a Flow that only includes values from the Flow
    that are instances of the type you specified'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filterIsInstance`: 返回一个流，仅包含流中指定类型的实例'
- en: '`map`: Returns a Flow that includes values from the Flow transformed with the
    operation you specified'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map`: 返回一个流，包含使用你指定的操作转换的流中的值'
- en: '`mapNotNull`: Like `map` (transforms the Flow using the operation specified)
    but only includes values that are not null'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mapNotNull`: 类似于`map`（使用指定的操作转换流），但仅包括非null的值'
- en: '`withIndex`: Returns a Flow that converts each value to an **IndexedValue**
    containing the index of the value and the value itself'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`withIndex`: 返回一个流，将每个值转换为包含值的索引和值本身的**IndexedValue**'
- en: '`onEach`: Returns a Flow that performs the specified action on each value before
    they are emitted'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onEach`: 返回一个流，在发出每个值之前执行指定的操作'
- en: '`runningReduce`: Returns a Flow containing the accumulated values resulting
    from running the operation specified sequentially, starting with the first element'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runningReduce`: 返回一个包含从第一个元素开始按顺序运行操作所得到的累积值的流'
- en: '`runningFold`: Returns a Flow containing accumulated values resulting from
    running the operation specified sequentially, starting with the initial value
    set'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runningFold`: 返回一个包含从指定操作按顺序运行并从设置的初始值开始的累积值的 Flow'
- en: '`scan`: Like the `runningFold` operator'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scan`: 类似于 `runningFold` 操作符'
- en: There is also a `transform` operator that you can use to apply custom or complex
    operations. With the `transform` operator, you can emit values into the new Flow
    by calling the `emit` function with the value to send.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个 `transform` 操作符，您可以使用它来应用自定义或复杂的操作。使用 `transform` 操作符，您可以通过调用带有要发送值的 `emit`
    函数将值发射到新的 Flow 中。
- en: 'For example, this `MovieViewModel` has a `fetchTopMovieTitles` function that
    uses `transform` to return a Flow with the top movies:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这个 `MovieViewModel` 有一个 `fetchTopMovieTitles` 函数，它使用 `transform` 返回包含顶级电影的
    Flow：
- en: '[PRE162]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: In this example, the `transform` operator was used in the Flow of movies to
    return a new Flow. The `transform` operator was used to emit only the list of
    movies whose popularity is higher than `0.5`, which means a popularity of more
    than 50%.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，在电影的 Flow 中使用了 `transform` 操作符来返回一个新的 Flow。`transform` 操作符用于只发射流行度高于 `0.5`
    的电影列表，这意味着超过 50% 的流行度。
- en: 'There are also size-limiting operators that you can use with Flow. The following
    are some of these operators:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用大小限制操作符与 Flow 一起使用。以下是一些这些操作符：
- en: '`drop(x)`: Returns a Flow that ignores the first *x* elements'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drop(x)`: 返回一个忽略前 *x* 个元素的 Flow'
- en: '`dropWhile`: Returns a Flow that ignores the first elements that meet the condition
    specified'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dropWhile`: 返回一个忽略满足指定条件的第一个元素的 Flow'
- en: '`take(x)`: Returns a Flow containing the first *x* elements of the Flow'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`take(x)`: 返回包含 Flow 的前 *x* 个元素的 Flow'
- en: '`takeWhile`: Returns a Flow that includes the first elements that meet the
    condition specified'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`takeWhile`: 返回一个包含满足指定条件的第一个元素的 Flow'
- en: These size-limiting operators also function similarly to the Kotlin collection
    functions with the same name.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这些大小限制操作符的功能与 Kotlin 收集函数同名操作符类似。
- en: In this section, we learned about Intermediate flow operators. Intermediate
    operators transform a Flow into a new Flow. In the next section, we will learn
    how to buffer and combine Kotlin Flows.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了中间流操作符。中间操作符将 Flow 转换为新的 Flow。在下一节中，我们将学习如何缓冲和组合 Kotlin 流。
- en: Buffering and combining flows
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓冲和组合流
- en: In this section, we will learn about buffering and combining Kotlin Flows. You
    can buffer and combine Flows with Flow operators. Buffering allows Flow with long-running
    tasks to run independently and avoid race conditions. Combining allows you to
    join different sources of Flows before processing or displaying them on the screen.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习关于 Kotlin 流的缓冲和组合。您可以使用 Flow 操作符缓冲和组合 Flow。缓冲允许具有长时间运行任务的 Flow 独立运行并避免竞争条件。组合允许在处理或显示在屏幕上之前将不同的
    Flow 源连接起来。
- en: Buffering Kotlin Flows
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓冲 Kotlin 流
- en: In this section, we will learn about buffering Kotlin Flows. Buffering allows
    you to run data emission in parallel to the collection.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习关于 Kotlin 流的缓冲。缓冲允许您并行运行数据发射。
- en: Emitting and collecting data with Flow run sequentially. When a new value is
    emitted, it will be collected. Emission of a new value can only happen once the
    previous data has been collected. If the emission or the collection of data from
    the Flow takes a while to complete, the whole process will take a longer time.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Flow 运行时，数据发射和收集是顺序进行的。当发射新值时，它将被收集。只有当之前的数据被收集后，才能发射新值。如果从 Flow 发射或收集数据需要较长时间，整个过程将花费更长的时间。
- en: 'With buffering, you can make a Flow’s emission and collection of data run in
    parallel. There are three operators you can use to buffer Flows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 使用缓冲，可以使 Flow 的数据发射和收集并行运行。您可以使用以下三个操作符来缓冲 Flow：
- en: '`buffer`'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buffer`'
- en: '`conflate`'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`conflate`'
- en: '`collectLatest`'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collectLatest`'
- en: '`buffer()` allows the Flow to emit values while the data is still being collected.
    The emission and collection of data are run in separate coroutines, so it runs
    in parallel. The following is an example of how to use `buffer` with Flows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`buffer()` 允许 Flow 在数据仍在收集时发射值。发射和收集数据在单独的协程中运行，因此它是并行的。以下是如何使用 `buffer` 与
    Flow 的示例：'
- en: '[PRE171]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: Here, the `buffer` operator was added before calling `collect`. If the `processMovie(movie)`
    function in the collection takes longer, the Flow will emit and buffer the values
    before they are collected and processed.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在调用 `collect` 之前添加了 `buffer` 操作符。如果收集中的 `processMovie(movie)` 函数执行时间较长，Flow
    将在收集和处理之前发射并缓冲这些值。
- en: '`conflate()` is similar to the `buffer()` operator, except with `conflate`,
    the collector will only process the latest value emitted after the previous value
    has been processed. It will ignore the other values previously emitted. Here is
    an example of using `conflate` in a Flow:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`conflate()` 与 `buffer()` 操作符类似，但 `conflate` 中，收集器将只处理在处理完上一个值之后的最新发出的值。它将忽略之前发出的其他值。以下是在
    Flows 中使用 `conflate` 的示例：'
- en: '[PRE186]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: In this example, adding the `conflate` operator will allow us to only process
    the latest value from the Flow and call `processMovie` with that value.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，添加 `conflate` 操作符将允许我们只处理 Flows 的最新值，并使用该值调用 `processMovie`。
- en: '`collectLatest(action)` is a terminal operator that will collect the Flow the
    same way as `collect`, but whenever a new value is emitted, it will restart the
    action and use this new value. Here is an example of using `collectLatest` in
    a Flow:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`collectLatest(action)` 是一个终端操作符，它将以与 `collect` 相同的方式收集 Flows，但每当发出新值时，它将重新启动操作并使用这个新值。以下是在
    Flows 中使用 `collectLatest` 的示例：'
- en: '[PRE201]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: Here, `collectLatest` was used instead of the `collect` terminal operator to
    collect the flow from `viewModel.getTopMovie()`. Whenever a new value is emitted
    by this Flow, it will restart and call `displayMovie` with the new value.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`collectLatest` 被用来代替 `collect` 终端操作符来收集来自 `viewModel.getTopMovie()` 的 Flows。每当这个
    Flows 发出新值时，它将重新启动并使用新值调用 `displayMovie`。
- en: In this section, you learned how to buffer Kotlin Flows with `buffer`, `conflate`,
    and `collectLatest`. In the next section, you will learn about combining multiple
    Flows into a single Flow.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了如何使用 `buffer`、`conflate` 和 `collectLatest` 缓冲 Kotlin Flows。在下一节中，你将学习如何将多个
    Flows 合并成一个单一的 Flows。
- en: Combining Flows
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合并 Flows
- en: In this section, we will learn how we can combine Flows. The Kotlin Flow API
    has available operators that you can use to combine multiple flows.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何合并 Flows。Kotlin Flow API 提供了可用于合并多个 Flows 的操作符。
- en: 'If you have multiple flows and you want to combine them into one, you can use
    the following Flow operators:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有多条 Flows 并且想要将它们合并成一个，你可以使用以下 Flows 操作符：
- en: '`zip`'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zip`'
- en: '`merge`'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`merge`'
- en: '`combine`'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`combine`'
- en: '`merge` is a top-level function that combines the elements from multiple Flows
    of the same type into one. You can pass a `vararg` number of Flows to combine.
    This is useful when you have two or more sources of data that you want to merge
    first before collecting.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '`merge` 是一个顶级函数，它将来自多个相同类型的 Flows 的元素合并成一个。你可以传递任意数量的 Flows 来进行合并。当你有两个或更多数据源需要先合并后再收集时，这非常有用。'
- en: 'In the following example, there are two Flows from `viewModel.fetchMoviesFromDb`
    and `viewModel.fetchMoviesFromNetwork` combined using `merge`:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，有两个 Flows 来自 `viewModel.fetchMoviesFromDb` 和 `viewModel.fetchMoviesFromNetwork`，它们使用
    `merge` 进行合并：
- en: '[PRE215]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: In this example, `merge` was used to combine the Flows from `viewModel.fetchMoviesFromDb`
    and `viewModel.fetchMoviesFromNetwork` before they are collected.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，在收集之前，使用了 `merge` 来合并来自 `viewModel.fetchMoviesFromDb` 和 `viewModel.fetchMoviesFromNetwork`
    的 Flows。
- en: The `zip` operator pairs data from the first Flow to the second Flow into a
    new value using the function you specified. If one Flow has fewer values than
    the other, `zip` will end when the values of this Flow have all been processed.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip` 操作符使用你指定的函数将第一个 Flows 的数据与第二个 Flows 的数据配对成一个新的值。如果一个 Flows 的值比另一个少，`zip`
    将在处理完这个 Flows 的所有值后结束。'
- en: 'The following shows how you can use the `zip` operator to combine two Flows,
    `userFlow` and `taskFlow`:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 以下展示了如何使用 `zip` 操作符合并两个 Flows，`userFlow` 和 `taskFlow`：
- en: '[PRE230]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: In this example, you used `zip` to pair each value of `userFlow` to `taskFlow`
    and return a Flow of `AssignedTask` using the `user` and `task` values. This new
    Flow will be collected and then displayed with the `displayAssignedTask` function.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你使用了 `zip` 来将 `userFlow` 的每个值与 `taskFlow` 配对，并使用 `user` 和 `task` 的值返回一个
    `AssignedTask` 的 Flows。这个新的 Flows 将被收集，然后使用 `displayAssignedTask` 函数显示。
- en: '`combine` pairs data from the first flow to the second flow like `zip` but
    uses the most recent value emitted by each flow. It will continue to run as long
    as a Flow emits a value. There is also a top-level `combine` function that you
    can use for multiple flows.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '`combine` 将第一个 Flows 的数据与第二个 Flows 的数据配对，就像 `zip` 一样，但使用每个 Flows 发出的最新值。只要
    Flows 发出一个值，它就会继续运行。还有一个用于多个 Flows 的顶级 `combine` 函数。'
- en: 'The following example shows how you can use the `combine` operator to join
    two Flows in your application:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何使用 `combine` 操作符在你的应用程序中将两个 Flows 连接起来：
- en: '[PRE247]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: Here, you have two Flows, `yourMessage` and `friendMessage`. The `combine` function
    pairs the most recent value of `yourMessage` and `friendMessage` to create a `Conversation`
    object. Whenever a new value is emitted by either Flow, `combine` will pair the
    latest values and add that to the resulting Flow for collection.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你有两个流，`yourMessage` 和 `friendMessage`。`combine` 函数将 `yourMessage` 和 `friendMessage`
    的最新值配对，以创建一个 `Conversation` 对象。每当任一流发出新值时，`combine` 将配对最新值并将其添加到结果流中以进行收集。
- en: In this section, we have explored how to combine Flows. In the next section,
    we will focus on `StateFlow` and `SharedFlow` and how we can use them in your
    Android applications.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了如何组合流。在下一节中，我们将重点关注 `StateFlow` 和 `SharedFlow` 以及如何在您的 Android 应用程序中使用它们。
- en: Exploring StateFlow and SharedFlow
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 StateFlow 和 SharedFlow
- en: In this section, we will dive into `StateFlow` and `SharedFlow`. `SharedFlow`
    and `StateFlow` are Flows that are hot streams, unlike a normal Kotlin Flow, which
    are cold streams by default.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入了解 `StateFlow` 和 `SharedFlow`。`SharedFlow` 和 `StateFlow` 是热流，与默认为冷流的普通
    Kotlin 流不同。
- en: A Flow is a cold stream of data. Flows only emit values when the values are
    collected. With `SharedFlow` and `StateFlow` hot streams, you can run and emit
    values the moment they are called and even when they have no listeners. `SharedFlow`
    and `StateFlow` are Flows, so you can also use operators on them.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 流是一个冷数据流。流仅在值被收集时发出值。使用 `SharedFlow` 和 `StateFlow` 热流，您可以在调用它们时立即运行和发出值，甚至在它们没有监听器时也是如此。`SharedFlow`
    和 `StateFlow` 是流，因此您也可以在它们上使用操作符。
- en: A `SharedFlow` allows you to emit values to multiple listeners. `SharedFlow`
    can be used for one-time events. The tasks that will be done by the `SharedFlow`
    will only be run once and will be shared by the listeners.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '`SharedFlow` 允许您向多个监听器发出值。`SharedFlow` 可以用于一次性事件。`SharedFlow` 将执行的任务将只运行一次，并由监听器共享。'
- en: You can use `MutableSharedFlow` and then use the `emit` function to send values
    to all the collectors.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `MutableSharedFlow` 然后使用 `emit` 函数将值发送到所有收集器。
- en: 'In the following example, `SharedFlow` is used in `MovieViewModel` for the
    list of movies fetched:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，`SharedFlow` 用于 `MovieViewModel` 中获取的电影列表：
- en: '[PRE268]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: In this example, we used `SharedFlow` for the message. We used the `emit` function
    to send the error message to the Flow’s listeners.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们使用了 `SharedFlow` 来处理消息。我们使用 `emit` 函数将错误消息发送到流的监听器。
- en: '`StateFlow` is `SharedFlow`, but it only emits the latest value to its listeners.
    `StateFlow` is initialized with a value (an initial state) and keeps this state.
    You can change the value of `StateFlow` using the mutable version of `StateFlow`,
    `MutableStateFlow`. Updating the value sends the new value to the Flow.'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '`StateFlow` 是 `SharedFlow`，但它只向其监听器发出最新值。`StateFlow` 使用一个值（初始状态）初始化并保持此状态。您可以使用
    `StateFlow` 的可变版本 `MutableStateFlow` 来更改 `StateFlow` 的值。更新值会将新值发送到流。'
- en: 'In Android, `StateFlow` can be an alternative to `LiveData`. You can use `StateFlow`
    for `ViewModel`, and your activity or fragment can then collect the value. For
    example, in the following `ViewModel`, `StateFlow` is used for the list of movies:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 中，`StateFlow` 可以作为 `LiveData` 的替代方案。您可以为 `ViewModel` 使用 `StateFlow`，然后您的活动或片段可以收集值。例如，在以下
    `ViewModel` 中，使用了 `StateFlow` 来表示电影列表：
- en: '[PRE278]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: 'In the preceding code, the list of movies fetched from the repository will
    be set to `MutableStateFlow` of `_movies`, which will also change `StateFlow`
    of `movies`. You can then collect `StateFlow` of `movies` in an activity or fragment,
    as shown in the following:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，从仓库获取的电影列表将被设置为 `_movies` 的 `MutableStateFlow`，这也会改变 `movies` 的 `StateFlow`。然后您可以在活动或片段中收集
    `movies` 的 `StateFlow`，如下所示：
- en: '[PRE288]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '[PRE299]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '[PRE300]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: Here, `StateFlow` of `viewModel.movies` will be collected, and then the list
    of movies will be displayed on the screen with the `displayMovies` function.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`viewModel.movies` 的 `StateFlow` 将被收集，然后使用 `displayMovies` 函数将电影列表显示在屏幕上。
- en: In this section, we have learned about `StateFlow` and `SharedFlow` and how
    we can use them in our Android projects.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了 `StateFlow` 和 `SharedFlow` 以及我们如何在 Android 项目中使用它们。
- en: Let’s try what we have learned so far by adding Kotlin Flow to an Android project.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试到目前为止所学的内容，通过将 Kotlin Flow 添加到 Android 项目中。
- en: Exercise 5.01 – Using Kotlin Flow in an Android app
  id: totrans-458
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习 5.01 – 在 Android 应用中使用 Kotlin Flow
- en: 'For this exercise, you will be continuing the movie app you worked on in *Exercise
    4.01 – Adding tests to coroutines in an Android app*. This application displays
    the movies that are currently playing in cinemas. You will be adding Kotlin Flow
    to the project by following these steps:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个练习，你将继续在*Exercise 4.01 – 在Android应用程序中添加协程测试*中工作的电影应用程序。这个应用程序显示当前正在电影院上映的电影。你将通过以下步骤将Kotlin
    Flow添加到项目中：
- en: Open the movie app you worked on in *Exercise 4.01 – Adding tests to coroutines
    in an Android app* in Android Studio.
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你在*Exercise 4.01 – 在Android应用程序中添加协程测试*中工作的电影应用程序。在Android Studio中。
- en: 'Go to the `MovieRepository` class and add a new `fetchMoviesFlow()` function
    that uses a `flow` builder to return a Flow and emits the list of movies from
    `MovieService`, as shown in the following snippet:'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`MovieRepository`类，添加一个新的`fetchMoviesFlow()`函数，使用`flow`构建器返回一个Flow，并发出来自`MovieService`的电影列表，如下面的代码片段所示：
- en: '[PRE301]'
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE301]'
- en: This is the same as the `fetchMovies()` function, but this function uses Kotlin
    Flow and will return `Flow<List<Movie>>` to the function or class that will collect
    it. The Flow will emit the list of movies from `movieService.getMovies`, and it
    will flow on the `Dispatchers.IO` dispatcher.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`fetchMovies()`函数相同，但这个函数使用Kotlin Flow，并将返回`Flow<List<Movie>>`给将收集它的函数或类。Flow将从`movieService.getMovies`发出电影列表，并在`Dispatchers.IO`调度器上流动。
- en: 'Open the `MovieViewModel` class, and replace the initialization of the `movies`
    `LiveData` that gets the value from `movieRepository` with the following lines:'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MovieViewModel`类，将获取自`movieRepository`的`movies` `LiveData`的初始化替换为以下行：
- en: '[PRE302]'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE302]'
- en: This will allow you to use the value of the `_movies` `MutableStateFlow` as
    the value of the `movies` `StateFlow`, which you will change later when you have
    fetched the list of movies from the Flow in `movieRepository`.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许你使用`_movies` `MutableStateFlow`的值作为`movies` `StateFlow`的值，你将在从`movieRepository`的Flow中获取电影列表后稍后更改它。
- en: 'Do the same for the `error` `LiveData`, and replace its initialization with
    the value from `movieRepository` with the following lines:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`error` `LiveData`做同样的处理，并用以下行替换其初始化，从`movieRepository`获取的值：
- en: '[PRE303]'
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE303]'
- en: This will use the value of the `_error` `MutableStateFlow` for the `error` `StateFlow`.
    You will be able to change the value of this `StateFlow` later for handling the
    cases when the Flow encountered an exception.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用`_error` `MutableStateFlow`的值来设置`error` `StateFlow`。你将在稍后能够更改这个`StateFlow`的值，以处理Flow遇到异常的情况。
- en: 'Replace the `loading` and `_loading` variables with the following lines:'
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下行替换`loading`和`_loading`变量：
- en: '[PRE304]'
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE304]'
- en: This will use the value of the `_loading` `MutableStateFlow` for the `loading`
    `StateFlow`. You will update this later to indicate that the loading of movies
    is ongoing.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用`_loading` `MutableStateFlow`的值来设置`loading` `StateFlow`。你将在稍后更新这个值以指示电影加载正在进行。
- en: Remove the `fetchMovies()` function and its content. You will be replacing this
    in the next step.
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`fetchMovies()`函数及其内容。你将在下一步替换它。
- en: 'Add a new `fetchMovies()` function that will collect the Flow from the `movieRepository.fetchMoviesFlow`,
    as shown in the following code block:'
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的`fetchMovies()`函数，它将收集来自`movieRepository.fetchMoviesFlow`的Flow，如下面的代码块所示：
- en: '[PRE305]'
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE305]'
- en: This will collect the list of movies from `movieRepository.fetchMoviesFlow`
    and set it to the `_movies` `MutableStateFlow` and the `movies` `StateFlow`. This
    list of movies will then be displayed in `MainActivity`.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 这将收集来自`movieRepository.fetchMoviesFlow`的电影列表，并将其设置为`_movies` `MutableStateFlow`和`movies`
    `StateFlow`。然后，这个电影列表将在`MainActivity`中显示。
- en: 'Open the `app/build.gradle` file. Add the following lines in the dependencies:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`app/build.gradle`文件。在依赖项中添加以下行：
- en: '[PRE306]'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE306]'
- en: This will allow us to use `lifecycleScope` for collecting the flows in `MainActivity`
    later.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许我们在`MainActivity`稍后使用`lifecycleScope`收集flows。
- en: 'Open `MainActivity` and remove the lines of code that observe for the `movies`,
    `error`, and `loading` `LiveData`. Replace them with the following:'
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainActivity`，删除观察`movies`、`error`和`loading` `LiveData`的代码行。用以下代码替换它们：
- en: '[PRE307]'
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE307]'
- en: This will collect `movies` and add them to the list, collect the `error` and
    display a `SnackBar` message if `error` is not empty, and collect `loading` and
    update `progressBar` based on its value.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 这将收集`movies`并将它们添加到列表中，收集`error`并在`error`不为空时显示`SnackBar`消息，并收集`loading`并根据其值更新`progressBar`。
- en: 'Run the application. The app should still display a list of movies (with a
    poster and a title), as shown in the following screenshot:'
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序。应用程序应该仍然显示电影列表（带有海报和标题），如下面的截图所示：
- en: '![Figure 5.1 – The movie app with the list of movies'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.1 – 包含电影列表的电影应用'
- en: '](img/Figure_5.1_B17773.jpg)'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.1_B17773.jpg)'
- en: Figure 5.1 – The movie app with the list of movies
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 包含电影列表的电影应用
- en: In this exercise, we have added Kotlin Flow in an Android app by creating a
    `MovieRepository` function that returns the list of movies as a Flow. This Flow
    was then collected by `MovieViewModel`.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们通过创建一个返回电影列表作为 Flow 的 `MovieRepository` 函数，将 Kotlin Flow 添加到 Android
    应用中。然后，这个 Flow 被收集到 `MovieViewModel` 中。
- en: Summary
  id: totrans-488
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter focused on using Kotlin Flows for asynchronous programming in Android.
    Flows are built on top of Kotlin coroutines. A flow can emit multiple values sequentially,
    instead of just a single value.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍了在 Android 中使用 Kotlin Flows 进行异步编程。Flows 是建立在 Kotlin 协程之上的。一个 Flow 可以按顺序发出多个值，而不仅仅是单个值。
- en: We started with learning about how to use Kotlin Flows in your Android app.
    Jetpack libraries such as Room and some third-party libraries support Flow. To
    safely collect flows in the UI layer and prevent memory leaks and avoid wasting
    resources, you can use `Lifecycle.repeatOnLifecycle` and `Flow.flowWithLifecycle`.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从学习如何在您的 Android 应用中使用 Kotlin Flows 开始。Jetpack 库如 Room 和一些第三方库支持 Flow。为了在
    UI 层安全地收集 Flows、防止内存泄漏和避免资源浪费，您可以使用 `Lifecycle.repeatOnLifecycle` 和 `Flow.flowWithLifecycle`。
- en: We then moved on to creating Flows with Flow builders. The `flowOf` function
    creates a Flow that emits the value or `vararg` values you provided. You can convert
    collections and functional types to Flow with the `asFlow()` extension function.
    The `flow` builder function creates a new Flow from a suspending lambda block,
    inside which you can send values with `emit()`.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后转向使用 Flow 构建器创建 Flows。`flowOf` 函数创建一个发出您提供的值或 `vararg` 值的 Flow。您可以使用 `asFlow()`
    扩展函数将集合和函数类型转换为 Flow。`flow` 构建器函数从挂起 lambda 块中创建一个新的 Flow，在其中您可以使用 `emit()` 发送值。
- en: Then, we explored Flow operators and learned how you can use them with Kotlin
    Flows. With terminal operators, you can start the collection of the Flow. Intermediate
    operators allow you to transform a Flow into another Flow.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们探讨了 Flow 操作符，并学习了如何与 Kotlin Flows 一起使用它们。使用终端操作符，您可以开始 Flow 的收集。中间操作符允许您将一个
    Flow 转换为另一个 Flow。
- en: We then learned about buffering and combining Flows. With the `buffer`, `conflate`,
    and `collectLatest` operators, you can buffer Flows. You can combine Flows with
    the `merge`, `zip`, and `combine` Flow operators.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后学习了缓冲和组合 Flows。使用 `buffer`、`conflate` 和 `collectLatest` 操作符，您可以缓冲 Flows。您可以使用
    `merge`、`zip` 和 `combine` Flow 操作符组合 Flows。
- en: We then explored `SharedFlow` and `StateFlow`. These can be used in your Android
    projects. With `SharedFlow`, you can emit values to multiple listeners. `StateFlow`
    is `SharedFlow` that only emits the latest value to its listeners.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后探讨了 `SharedFlow` 和 `StateFlow`。这些可以在您的 Android 项目中使用。使用 `SharedFlow`，您可以向多个监听器发出值。`StateFlow`
    是只向其监听器发出最新值的 `SharedFlow`。
- en: Finally, we worked on an exercise to add Kotlin Flows to an Android application.
    We used a Flow in `MovieRepository`, which was then collected in `MovieViewModel`.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们进行了一个练习，将 Kotlin Flows 添加到 Android 应用程序中。我们在 `MovieRepository` 中使用了一个 Flow，然后它在
    `MovieViewModel` 中被收集。
- en: In the next chapter, we will focus on how to handle Kotlin Flows cancelations
    and exceptions in your application.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将关注如何在您的应用程序中处理 Kotlin Flows 的取消和异常。
