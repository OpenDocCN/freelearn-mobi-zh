- en: <st c="0">10</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">10</st>
- en: <st c="3">Swift Macros</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="3">Swift 宏</st>
- en: <st c="16">Developers frequently encounter various challenges with their IDEs,
    often related to missing functionalities, mostly about missing functionalities.</st>
    <st c="165">With each new Xcode or Swift version, Apple introduces additional
    features that enhance productivity and simplify tasks.</st> <st c="286">However,
    even Apple has a hard time fulfilling our needs and demands.</st> <st c="356">Fortunately,
    this time, we can create customized functionalities using</st> <st c="427">Swift
    Macros.</st>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16">开发者经常在他们的 IDE 中遇到各种挑战，通常与缺失的功能有关，大多数是关于缺失的功能。</st> <st c="165">随着每个新的
    Xcode 或 Swift 版本的发布，Apple 都会引入增强生产力和简化任务的新功能。</st> <st c="286">然而，即使是 Apple 也很难满足我们的需求和期望。</st>
    <st c="356">幸运的是，这次，我们可以使用</st> <st c="427">Swift 宏</st> <st c="356">来创建自定义功能。</st>
- en: '**<st c="440">Swift Macros</st>** <st c="453">is an</st> <st c="459">exciting
    new feature added to Xcode 15 and iOS 17, and this chapter will help us increase
    our productivity by achieving more from</st> <st c="590">our IDE.</st>'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="440">Swift 宏</st>** <st c="453">是 Xcode 15 和 iOS 17 中新增的一个令人兴奋的新功能，本章将帮助我们通过利用我们的
    IDE 来提高我们的生产力。</st>'
- en: <st c="598">In this chapter, we will cover the</st> <st c="634">following topics:</st>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="598">在本章中，我们将涵盖以下主题：</st> <st c="634">以下主题：</st>
- en: <st c="651">Learning about</st> <st c="667">Swift Macros</st>
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="651">了解</st> <st c="667">Swift 宏</st>
- en: <st c="679">Exploring the</st> `<st c="694">SwiftSyntax</st>` <st c="705">library,
    which stands behind</st> <st c="735">Swift Macros</st>
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="679">探索</st> `<st c="694">SwiftSyntax</st>` <st c="705">库，它是</st> <st
    c="735">Swift 宏</st> <st c="705">背后的</st>
- en: <st c="747">Creating our first</st> <st c="767">Swift macro</st>
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="747">创建我们的第一个</st> <st c="767">Swift 宏</st>
- en: <st c="778">Handling errors and providing more clarity when something</st> <st
    c="837">goes wrong</st>
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="778">处理错误并在出错时提供更多清晰度</st>
- en: <st c="847">Testing our macro, making sure it runs as expected</st> <st c="899">over
    time</st>
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="847">测试我们的宏，确保它按预期运行</st> <st c="899">随时间推移</st>
- en: <st c="908">But now, let’s start with the basics and discover</st> <st c="959">Swift
    Macros.</st>
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="908">但现在，让我们从基础知识开始，探索</st> <st c="959">Swift 宏。</st>
- en: <st c="972">Technical requirements</st>
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="972">技术要求</st>
- en: <st c="995">You must download Xcode version 16.0 or above for this chapter from
    Apple’s</st> <st c="1072">App Store.</st>
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="995">您必须从 Apple 的</st> <st c="1072">App Store</st> <st c="995">下载本章节所需的
    Xcode 16.0 或更高版本。</st>
- en: <st c="1082">You’ll also need to run the latest version of macOS (Ventura or
    above).</st> <st c="1155">Search for Xcode in the App Store and select and download
    the latest version.</st> <st c="1233">Launch Xcode and follow any additional installation
    instructions that your system may prompt you with.</st> <st c="1336">Once Xcode
    has fully launched, you’re ready</st> <st c="1380">to go.</st>
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1082">您还需要运行最新版本的 macOS (Ventura 或更高版本)。</st> <st c="1155">在 App Store
    中搜索 Xcode，选择并下载最新版本。</st> <st c="1233">启动 Xcode 并遵循系统可能提示的任何附加安装说明。</st> <st c="1336">一旦
    Xcode 完全启动，您就准备好了</st> <st c="1380">开始。</st>
- en: <st c="1386">What is a Swift macro?</st>
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1386">什么是 Swift 宏？</st>
- en: <st c="1409">You probably heard the term “macro” before in the context of programming.</st>
    <st c="1484">That’s perhaps because programming languages such as C/C++ have macros</st>
    <st c="1555">as well.</st>
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1409">您可能之前在编程的上下文中听说过“宏”这个术语。</st> <st c="1484">这可能是因为像 C/C++ 这样的编程语言也有宏</st>
    <st c="1555">。</st>
- en: <st c="1563">A</st> **<st c="1566">macro</st>** <st c="1571">is a</st> <st c="1576">structure
    that lets us define a code pattern that is being replaced by the compiler with
    a specific set</st> <st c="1681">of instructions.</st>
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1563">一个</st> **<st c="1566">宏</st>** <st c="1571">是一个结构，它允许我们定义一个代码模式，编译器会用一组特定的指令来替换它。</st>
- en: <st c="1697">Let’s see a short</st> <st c="1716">C example:</st>
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1697">让我们看看一个简短的</st> <st c="1716">C 示例：</st>
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <st c="1795">In our preceding code, we declare a macro called</st> `<st c="1845">SQUARE</st>`
    <st c="1851">that receives one parameter named</st> `<st c="1886">X</st>`<st c="1887">,
    and our compiler replaces it with</st> `<st c="1923">(</st>``<st c="1924">x) *(x)</st>`<st
    c="1931">.</st>
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1795">在我们的前一个代码中，我们声明了一个名为</st> `<st c="1845">SQUARE</st>` <st c="1851">的宏，它接收一个名为</st>
    `<st c="1886">X</st>`<st c="1887">的参数，并且我们的编译器将其替换为</st> `<st c="1923">(</st>``<st
    c="1924">x) *(x)</st>`<st c="1931">。</st>
- en: '<st c="1932">The initial question that comes to mind is this: why?</st> <st
    c="1987">Can’t we just define</st> <st c="2008">a function?</st>'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1932">首先出现在脑海中的问题是这个：为什么？</st> <st c="1987">我们不能只定义一个函数吗？</st>
- en: <st c="2019">So, in this case, a simple function that calculates a number’s
    square can be</st> <st c="2097">helpful here.</st>
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2019">因此，在这种情况下，一个简单的计算数字平方的函数可能会有所帮助。</st>
- en: <st c="2110">But a macro’s primary goal is not to</st> <st c="2147">replace
    functions, as they are great for</st> <st c="2189">several reasons:</st>
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2110">但宏的主要目标不是</st> <st c="2147">替换函数，因为它们有以下几个优点：</st> <st c="2189">：
- en: '**<st c="2205">Code reuse</st>**<st c="2216">: Notice that code reuse is not
    “functionality reuse.” Code reuse is where we take an actual code snippet and
    reuse it in different places.</st> <st c="2357">For example, if we constantly
    repeat the same line sequence when declaring a class, a macro can help us avoid</st>
    <st c="2467">repeating ourselves.</st>'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="2205">代码重用</st>**<st c="2216">：请注意，代码重用不是“功能重用”。代码重用是指我们取一个实际的代码片段，并在不同的地方重用它。</st>
    <st c="2357">例如，如果我们经常在声明类时重复相同的行序列，宏可以帮助我们避免</st> <st c="2467">重复自己。</st>'
- en: '**<st c="2487">Improve abstraction</st>**<st c="2507">: Macros can help us
    add another abstraction layer to our code.</st> <st c="2572">Imagine writing a
    macro that generates functions declaration.</st> <st c="2634">That’s another level
    we can construct</st> <st c="2672">our code.</st>'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="2487">提高抽象</st>**<st c="2507">：宏可以帮助我们在代码中添加另一个抽象层。</st> <st c="2572">想象一下编写一个生成函数声明的宏。</st>
    <st c="2634">这是我们可以构建的另一个代码构建</st> <st c="2672">层次。</st>'
- en: '**<st c="2681">Performance</st>**<st c="2693">: In some cases, macros can help
    us optimize our code.</st> <st c="2749">Sometimes, the trade-off between optimization
    and readability/simplicity can be solved using a macro.</st> <st c="2851">A macro
    can generate a piece of harder-to-read code and yet be optimized.</st> <st c="2925">One
    feature that macro can optimize code for is</st> **<st c="2973">loop unrolling</st>**
    <st c="2987">– a way to</st> <st c="2999">iterate a loop faster with instruction-level
    parallelism.</st> <st c="3057">Loop unrolling</st> <st c="3072">produces less</st>
    <st c="3086">readable code but is</st> <st c="3107">much quicker.</st>'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="2681">性能</st>**<st c="2693">：在某些情况下，宏可以帮助我们优化代码。</st> <st c="2749">有时，优化与可读性/简单性之间的权衡可以通过宏来解决。</st>
    <st c="2851">宏可以生成更难阅读的代码，但仍然可以进行优化。</st> <st c="2925">宏可以优化的一个特性是**<st c="2973">循环展开</st>**
    <st c="2987">——一种通过指令级并行性更快地迭代循环的方法。</st> <st c="3057">循环展开</st> <st c="3072">生成的代码可读性较低，但速度要快得多。</st>'
- en: <st c="3120">In the bottom line, a macro</st> <st c="3148">is just a tool that
    replaces one code with another and inserts a specific code snippet before the
    compile time.</st> <st c="3261">But C macros</st> <st c="3273">are full of issues.</st>
    <st c="3294">They are difficult to test, not type-safety, their errors are not
    clear enough, and sharing them with other developers is not trivial.</st> <st
    c="3429">As part of Xcode 15, the Swift team released a new tool called</st> **<st
    c="3492">Swift Macros</st>** <st c="3504">– the</st> <st c="3511">Swift version
    of macros that lets us create macros more efficiently</st> <st c="3579">and elegantly.</st>
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3120">最后，宏</st> <st c="3148">只是一个工具，它用另一段代码替换一段代码，并在编译前插入特定的代码片段。</st>
    <st c="3261">但C宏</st> <st c="3273">存在许多问题。</st> <st c="3294">它们难以测试，没有类型安全，错误不够清晰，并且与其他开发者共享它们并不简单。</st>
    <st c="3429">作为Xcode 15的一部分，Swift团队发布了一个名为</st> **<st c="3492">Swift宏</st>** <st
    c="3504">的新工具——这是Swift版本的宏，它允许我们更高效、更优雅地创建宏。</st>
- en: <st c="3593">Let’s go over a simple</st> <st c="3617">example of</st> <st c="3628">macro
    usage.</st>
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3593">让我们来看一个简单的</st> <st c="3617">宏使用</st> <st c="3628">例子。</st>
- en: <st c="3640">In our project, we want to add a macro that adds a function named</st>
    `<st c="3706">log(issue:String)</st>` <st c="3724">to classes and structs.</st>
    <st c="3749">That function prints an issue to our log and adds the class or the
    struct name.</st> <st c="3829">We can call that macro</st> `<st c="3852">@AddDebugLogger</st>`<st
    c="3867">, and we can use it</st> <st c="3887">as follows:</st>
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3640">在我们的项目中，我们想要添加一个宏，该宏将一个名为</st> `<st c="3706">log(issue:String)</st>`
    <st c="3724">的函数添加到类和结构体中。</st> <st c="3749">该函数将问题打印到我们的日志中，并添加类或结构体的名称。</st>
    <st c="3829">我们可以将这个宏命名为</st> `<st c="3852">@AddDebugLogger</st>`<st c="3867">，并且我们可以这样使用它：</st>
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <st c="3934">In the preceding code, we declared a class named</st> `<st c="3984">MyClass</st>`
    <st c="3991">and attached a macro named</st> `<st c="4019">@AddDebugerLogger</st>`<st
    c="4036">, which expands to the</st> <st c="4059">following code:</st>
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3934">在上面的代码中，我们声明了一个名为</st> `<st c="3984">MyClass</st>` <st c="3991">的类，并附加了一个名为</st>
    `<st c="4019">@AddDebugerLogger</st>`<st c="4036">的宏，它展开为以下代码：</st>
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: <st c="4185">The macro adds a function named</st> `<st c="4218">printLog()</st>`<st
    c="4228">, which prints an issue to the console while mentioning the class name
    as part of the log message.</st> <st c="4327">This serves as an example of primary
    macro usage, illustrating the capabilities of</st> <st c="4410">this tool.</st>
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4185">宏添加了一个名为</st> `<st c="4218">printLog()</st>`<st c="4228">的函数，该函数将问题打印到控制台，并在日志消息中提及类名。</st>
    <st c="4327">这作为主要宏使用的一个示例，展示了该工具的能力。</st>
- en: <st c="4420">But how is the macro familiar with the class name?</st> <st c="4472">How
    does it generate a new function in the right place inside the class?</st> <st
    c="4545">To answer these questions, we first need to meet</st> `<st c="4594">SwiftSyntax</st>`<st
    c="4605">, a</st> <st c="4609">library that stands in the heart of</st> <st c="4645">Swift
    Macros.</st>
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4420">但是宏是如何了解类名的呢？</st> <st c="4472">它是如何在类内部正确位置生成一个新函数的？</st> <st
    c="4545">为了回答这些问题，我们首先需要了解</st> `<st c="4594">SwiftSyntax</st>`<st c="4605">，这是一个</st>
    <st c="4609">位于Swift宏核心的</st> <st c="4645">库。</st>
- en: <st c="4658">Exploring SwiftSyntax</st>
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="4658">探索SwiftSyntax</st>
- en: '`<st c="4680">SwiftSyntax</st>` <st c="4692">is not a</st> <st c="4702">new
    library, and it’s part of Swift’s code base from its early beginnings.</st> <st
    c="4777">In fact, Swift Macros is part of</st> `<st c="4810">SwiftSyntax</st>`<st
    c="4821">, and it uses</st> <st c="4835">its capabilities.</st>'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="4680">SwiftSyntax</st>` <st c="4692">不是一个</st> <st c="4702">新库，它从Swift的早期版本开始就是Swift代码库的一部分。</st>
    <st c="4777">实际上，Swift宏是</st> `<st c="4810">SwiftSyntax</st>`<st c="4821">的一部分，并使用</st>
    <st c="4835">其功能。</st>'
- en: <st c="4852">Before we dive into</st> `<st c="4873">SwiftSyntax</st>` <st c="4884">(and
    there’s enough to dive into it), let’s learn about how the Swift compiler works
    (</st>*<st c="4971">Figure 10</st>**<st c="4981">.1</st>*<st c="4983">):</st>
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4852">在我们深入</st> `<st c="4873">SwiftSyntax</st>` <st c="4884">（而且有很多东西可以深入）之前，让我们了解一下Swift编译器是如何工作的（</st>*<st
    c="4971">图10</st>**<st c="4981">.1</st>*<st c="4983">）：</st>
- en: '![Figure 10.1: The Swift compiler process](img/B21795_figure_10.01.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 10.1: The Swift compiler process](img/B21795_figure_10.01.jpg)'
- en: '<st c="4988">Figure 10.1: The Swift compiler process</st>'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4988">图10.1：Swift编译器过程</st>
- en: <st c="5027">Don’t fear the different expressions you see in</st> *<st c="5076">Figure
    10</st>**<st c="5085">.1</st>*<st c="5087">. This figure is a high-level overview
    of how the compiler takes our source code and generates machine code our device
    can run (the</st> `<st c="5219">*.o</st>` <st c="5222">files).</st> <st c="5231">We
    don’t have to understand every step in that flow, but knowing how it works is
    essential, especially where</st> `<st c="5340">SwiftSyntax</st>` <st c="5351">fits
    in</st> <st c="5360">the process.</st>
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5027">不要害怕你在</st> *<st c="5076">图10</st>**<st c="5085">.1</st>*<st c="5087">中看到的不同的表达式。这个图展示了编译器如何将我们的源代码转换成设备可以运行的机器代码（即</st>
    `<st c="5219">*.o</st>` <st c="5222">文件）的概览。我们不需要理解这个流程中的每一个步骤，但了解它是如何工作的至关重要，尤其是在</st>
    `<st c="5340">SwiftSyntax</st>` <st c="5351">在过程中的位置。</st>
- en: <st c="5372">Let’s go over the</st> <st c="5391">steps together:</st>
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5372">让我们一起来回顾一下</st> <st c="5391">这些步骤：</st>
- en: '**<st c="5406">Parse and abstract syntax tree (AST)</st>**<st c="5443">: The</st>
    <st c="5449">compiler takes our source code and builds an AST.</st> <st c="5500">The
    AST represents our code hierarchical structure, including classes, structs, variables,</st>
    <st c="5591">and expressions.</st>'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<st c="5406">解析和抽象语法树（AST）</st>**<st c="5443">：编译器将我们的源代码转换成一个AST。</st> <st
    c="5449">AST代表我们的代码的层次结构，包括类、结构体、变量和表达式。</st>'
- en: '**<st c="5607">Semantic analysis (sema)</st>**<st c="5632">: In this</st> <st
    c="5643">phase, the compiler takes our generated AST and performs semantic analysis.</st>
    <st c="5719">The analysis looks out for semantic issues in our code and goes over
    issues such as type-checking name resolutions and more (when we see “semantic”
    issues in our build phase; that’s the result of</st> <st c="5915">this phase).</st>'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<st c="5607">语义分析（sema）</st>**<st c="5632">：在这个</st> <st c="5643">阶段，编译器对我们的生成的AST执行语义分析。</st>
    <st c="5719">分析检查我们的代码中的语义问题，并处理类型检查、名称解析等问题（当我们构建阶段看到“语义”问题时；这是该阶段的结果）。</st>'
- en: '**<st c="5927">Swift Intermediate Language Generation (SILGen)</st>**<st c="5975">:
    In this phase, the compiler</st> <st c="6005">generates a representation that
    captures the semantic structure of</st> <st c="6073">the code.</st>'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<st c="5927">Swift中间语言生成（SILGen）</st>**<st c="5975">：在这个阶段，编译器</st> <st c="6005">生成一个表示，它捕捉了代码的语义结构。</st>'
- en: '**<st c="6082">Intermediate Representation Generation (IRGen)</st>**<st c="6129">:
    In IRGen, the</st> <st c="6145">compiler takes the SILGen result and</st> <st
    c="6183">converts it to a binary close to machine-level code.</st> <st c="6236">This
    process is done with the help</st> <st c="6270">of</st> **<st c="6274">Low-Level
    Virtual Machine</st>** <st c="6299">(</st>**<st c="6301">LLVM</st>**<st c="6305">),
    and the code goes through</st> <st c="6335">several optimizations.</st>'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<st c="6082">中间表示生成 (IRGen)</st>**<st c="6129">：在 IRGen 中，编译器将 SILGen 的结果</st>
    <st c="6145">转换为接近机器级代码的二进制代码。</st> <st c="6236">这个过程是在</st> <st c="6270">**<st
    c="6274">低级虚拟机</st>** <st c="6299">(</st>**<st c="6301">LLVM</st>**<st c="6305">)
    的帮助下完成的，代码会经过</st> <st c="6335">几个优化。</st>'
- en: '**<st c="6357">LLVM linking</st>**<st c="6370">: The LLVM</st> <st c="6382">links
    everything together and prepares our code for the final</st> <st c="6444">binary
    creation.</st>'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<st c="6357">LLVM 链接</st>**<st c="6370">：LLVM</st> <st c="6382">将所有内容链接在一起，并为最终</st>
    <st c="6444">二进制创建做好准备。</st>'
- en: <st c="6460">The process may look scary and complex, but remember that this
    is a significant enrichment for us as iOS developers and is not required for Swift
    Macros understanding.</st> <st c="6629">I demonstrated it because of the first
    two steps – parse and AST.</st> <st c="6695">Let’s talk about them for</st> <st
    c="6721">a second.</st>
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6460">这个过程可能看起来令人恐惧且复杂，但请记住，这对我们作为 iOS 开发者来说是一项重要的丰富，并且对于理解 Swift 宏不是必需的。</st>
    <st c="6629">我演示它是因为前两个步骤 – 解析和 AST。</st> <st c="6695">让我们再谈一谈。</st>
- en: <st c="6730">Parsing and AST</st>
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="6730">解析和 AST</st>
- en: <st c="6746">Parsing Swift code</st> <st c="6765">is not an easy task.</st>
    <st c="6787">In addition, building the AST is even</st> <st c="6825">more complex.</st>
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6746">解析 Swift 代码</st> <st c="6765">不是一项容易的任务。</st> <st c="6787">此外，构建
    AST 甚至</st> <st c="6825">更加复杂。</st>
- en: <st c="6838">In the building process, we just saw the parsing, and the AST is
    handled by the</st> `<st c="6919">SwiftSyntax</st>` <st c="6930">library.</st>
    <st c="6940">So, when</st> <st c="6949">we work with the</st> `<st c="6966">SwiftSyntax</st>`
    <st c="6977">library, we have the full compiler capabilities.</st> <st c="7027">This
    means we can parse code, analyze it, and even generate new code like the compiler.</st>
    <st c="7115">The</st> `<st c="7119">SwiftSyntax</st>` <st c="7130">library is
    a powerful and essential tool when working with Swift macros because when we think
    of it, it is what Swift macros are all about – understanding the given code and
    generating a</st> <st c="7318">new one.</st>
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6838">在构建过程中，我们只看到了解析，AST 由</st> `<st c="6919">SwiftSyntax</st>` <st
    c="6930">库</st> <st c="6940">处理。</st> <st c="6949">因此，当我们与</st> `<st c="6966">SwiftSyntax</st>`
    <st c="6977">库</st> <st c="7027">一起工作时，我们拥有完整的编译器功能。</st> <st c="7115">这意味着我们可以解析代码，分析它，甚至像编译器一样生成新的代码。</st>
    <st c="7119">SwiftSyntax</st> <st c="7130">库是处理 Swift 宏时的强大且必要的工具，因为当我们想到它时，它就是
    Swift 宏的全部 – 理解给定的代码并生成一个</st> <st c="7318">新的代码。</st>
- en: <st c="7326">We understand that learning SwiftSyntax is a prerequisite for writing
    Swift macros, so let’s</st> <st c="7420">dive in.</st>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7326">我们理解学习 SwiftSyntax 是编写 Swift 宏的先决条件，所以让我们</st> <st c="7420">深入探讨。</st>
- en: <st c="7428">Setting up SwiftSyntax</st>
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="7428">设置 SwiftSyntax</st>
- en: '`<st c="7451">SwiftSyntax</st>` <st c="7463">is a</st> **<st c="7469">Swift
    package</st>**<st c="7482">, meaning</st> <st c="7492">it can be linked easily
    to an existing iOS or</st> <st c="7538">macOS project.</st>'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="7451">SwiftSyntax</st>` <st c="7463">是一个</st> **<st c="7469">Swift
    包</st>**<st c="7482">，这意味着</st> <st c="7492">它可以轻松地链接到现有的 iOS 或</st> <st c="7538">macOS
    项目。</st>'
- en: <st c="7552">What is a Swift package?</st>
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7552">什么是 Swift 包？</st>
- en: <st c="7577">A Swift package</st> <st c="7593">is a unit of code distribution
    in Swift.</st> <st c="7635">It’s a way to organize, share, and manage Swift code
    across</st> <st c="7695">different projects.</st>
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7577">Swift 包</st> <st c="7593">是 Swift 代码分发的单元。</st> <st c="7635">它是一种组织、共享和管理跨</st>
    <st c="7695">不同项目</st> 的 Swift 代码的方式。
- en: <st c="7714">To play with and</st> <st c="7731">learn</st> `<st c="7738">SwiftSyntax</st>`<st
    c="7749">, we will create a new project and add</st> `<st c="7788">SwiftSyntax</st>`
    <st c="7799">as a Swift package to that project, including a playground.</st>
    <st c="7860">To do so, follow</st> <st c="7877">these steps:</st>
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7714">为了玩转和学习</st> <st c="7731">SwiftSyntax</st> <st c="7749">，我们将创建一个新的项目，并将</st>
    `<st c="7788">SwiftSyntax</st>` <st c="7799">作为一个 Swift 包添加到该项目中，包括一个 playground。</st>
    <st c="7860">为此，请按照</st> <st c="7877">以下步骤</st> 进行操作：
- en: <st c="7889">Let’s start with opening Xcode and adding a</st> <st c="7934">new
    project.</st>
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="7889">让我们从打开 Xcode 并添加一个</st> <st c="7934">新项目</st> 开始。
- en: <st c="7946">Then, we’ll add our</st> `<st c="7967">SwiftSyntax</st>` <st c="7978">Swift
    package by selecting</st> **<st c="8006">File</st>** <st c="8010">|</st> **<st
    c="8013">Add</st>** **<st c="8017">Package Dependencies…</st>**<st c="8038">.</st>
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="7946">然后，我们将通过选择</st> `<st c="7967">SwiftSyntax</st>` <st c="7978">Swift
    包来添加我们的</st> **<st c="8006">文件</st>** <st c="8010">|</st> **<st c="8013">添加</st>
    **<st c="8017">包依赖…</st>**<st c="8038">。</st>
- en: <st c="8039">Now, we are in the adding dependencies window of Xcode (</st>*<st
    c="8096">Figure 10</st>**<st c="8106">.2</st>*<st c="8108">):</st>
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="8039">现在，我们处于 Xcode 的添加依赖项窗口中（</st>*<st c="8096">图 10</st>**<st c="8106">.2</st>*<st
    c="8108">）：</st>
- en: '![Figure 10.2: The adding dependencies Xcode window](img/B21795_figure_10.02.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.2：添加依赖项的 Xcode 窗口](img/B21795_figure_10.02.jpg)'
- en: '<st c="9048">Figure 10.2: The adding dependencies Xcode window</st>'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9048">图 10.2：添加依赖项的 Xcode 窗口</st>
- en: <st c="9097">Dependencies window?</st>
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9097">依赖项窗口？</st>
- en: <st c="9118">If that’s the first time you’ve seen that window, then this is
    an excellent chance to perform a short introduction.</st> <st c="9235">When Swift
    Package Manager had just started, its management was completely manual, using</st>
    <st c="9324">the Terminal.</st>
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9118">如果你第一次看到那个窗口，那么这是一个进行简要介绍的好机会。</st> <st c="9235">当 Swift 包管理器刚开始时，其管理完全是手动的，使用</st>
    <st c="9324">终端。</st>
- en: <st c="9337">Over the years, Swift Package Manager</st> <st c="9375">has become
    an integral part of Xcode, and now, it is even possible to manage collections
    and search for packages right</st> <st c="9495">from Xcode.</st>
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9337">多年来，Swift 包管理器</st> <st c="9375">已成为 Xcode 的一个重要组成部分，现在，甚至可以直接在
    Xcode 中管理集合和搜索包。</st> <st c="9495">:</st>
- en: <st c="9506">You can learn</st> <st c="9520">more</st> <st c="9526">at</st>
    [<st c="9529">https://www.swift.org/documentation/package-manager/</st>](https://www.swift.org/documentation/package-manager/)<st
    c="9581">.</st>
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9506">你可以在</st> [<st c="9529">https://www.swift.org/documentation/package-manager/</st>](https://www.swift.org/documentation/package-manager/)<st
    c="9581">了解更多。</st>
- en: <st c="9582">Back to</st> <st c="9591">Xcode – in the top-right corner of the
    adding dependencies window, we can fill the</st> `<st c="9674">SwiftSyntax</st>`
    <st c="9685">GitHub repository:</st>
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="9582">回到</st> <st c="9591">Xcode – 在添加依赖项窗口的右上角，我们可以填写</st> `<st c="9674">SwiftSyntax</st>`
    <st c="9685">GitHub 仓库：</st>
- en: '[PRE3]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <st c="9742">We will choose the</st> `<st c="9762">swift-syntax</st>` <st c="9774">package
    from the left column and click the</st> **<st c="9818">Add</st>** **<st c="9822">Package</st>**
    <st c="9829">button.</st>
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="9742">我们将从左侧列中选择</st> `<st c="9762">swift-syntax</st>` <st c="9774">包，并点击</st>
    **<st c="9818">添加</st> **<st c="9822">包</st> **<st c="9829">按钮。</st>
- en: <st c="9837">Xcode will now resolve the Swift package and present its libraries
    so we can choose what we want to import to our project (</st>*<st c="9961">Figure
    10</st>**<st c="9971">.3</st>*<st c="9973">):</st>
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="9837">现在，Xcode 将解析 Swift 包并展示其库，以便我们可以选择想要导入到项目中的内容（</st>*<st c="9961">图
    10</st>**<st c="9971">.3</st>*<st c="9973">）：</st>
- en: '![Figure 10.3: Choosing the SwiftSyntax package products](img/B21795_figure_10.03.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.3：选择 SwiftSyntax 包产品](img/B21795_figure_10.03.jpg)'
- en: '<st c="10391">Figure 10.3: Choosing the SwiftSyntax package products</st>'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10391">图 10.3：选择 SwiftSyntax 包产品</st>
- en: <st c="10445">We will choose the</st> `<st c="10465">SwiftSyntax</st>` <st c="10476">library
    and click on the</st> `<st c="10542">SwiftSyntax</st>` <st c="10553">to</st> <st
    c="10557">our project!</st>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10445">我们将选择</st> `<st c="10465">SwiftSyntax</st>` <st c="10476">库，并点击</st>
    `<st c="10542">SwiftSyntax</st>` <st c="10553">将其</st> <st c="10557">添加到我们的项目中！</st>
- en: <st c="10569">Now, let’s add a playground file (anywhere we like) and explore
    what</st> `<st c="10639">SwiftSyntax</st>` <st c="10650">is.</st>
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10569">现在，让我们添加一个 playground 文件（我们喜欢的任何地方）并探索</st> `<st c="10639">SwiftSyntax</st>`
    <st c="10650">是什么。</st>
- en: <st c="10654">Building our Abstract Syntax Tree</st>
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="10654">构建我们的抽象语法树</st>
- en: <st c="10688">To try and analyze a piece of</st> <st c="10719">Swift code using
    the</st> `<st c="10740">SwiftSyntax</st>` <st c="10751">library, we need to generate
    some Swift code and work</st> <st c="10806">on it.</st>
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10688">为了尝试使用</st> `<st c="10740">SwiftSyntax</st>` <st c="10751">库分析一段
    Swift 代码，我们需要生成一些 Swift 代码并对其进行处理。</st> <st c="10806">：</st>
- en: <st c="10812">We open the playground file we created in the previous section,
    and add the</st> <st c="10889">following code:</st>
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10812">我们打开上一节中创建的 playground 文件，并添加以下代码：</st>
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <st c="11011">Our code starts with importing two important libraries –</st>
    `<st c="11069">SwiftSyntax</st>` <st c="11080">and</st> `<st c="11085">SwiftSyntaxParser</st>`<st
    c="11102">. The</st> `<st c="11108">SwiftSyntaxParser</st>` <st c="11125">library
    contains the</st> `<st c="11147">SwiftParser</st>` <st c="11158">class, which
    helps convert a source code to a tree we can traverse</st> <st c="11226">and analyze.</st>
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11011">我们的代码从导入两个重要的库开始 –</st> `<st c="11069">SwiftSyntax</st>` <st c="11080">和</st>
    `<st c="11085">SwiftSyntaxParser</st>`<st c="11102">。</st> `<st c="11108">SwiftSyntaxParser</st>`
    <st c="11125">库包含</st> `<st c="11147">SwiftParser</st>` <st c="11158">类，它有助于将源代码转换为我们可以遍历和分析的树。</st>
- en: <st c="11238">We added a string</st> <st c="11257">constant named</st> `<st
    c="11272">sourceCode</st>` <st c="11282">with a simple</st> *<st c="11297">“Hello
    World”</st>* <st c="11310">function to see how it works.</st> <st c="11341">Imagine
    that</st> `<st c="11354">sourceCode</st>` <st c="11364">represents the content
    of a</st> <st c="11393">Swift file.</st>
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11238">我们添加了一个名为</st> <st c="11257">sourceCode</st> <st c="11272">的字符串</st>
    <st c="11282">常量，其中包含一个简单的</st> *<st c="11297">“Hello World”</st>* <st c="11310">函数，以查看其工作原理。</st>
    <st c="11341">想象一下</st> `<st c="11354">sourceCode</st>` <st c="11364">代表了一个</st>
    <st c="11393">Swift文件</st> 的内容。</st>
- en: <st c="11404">To parse the “Hello World” code, we’ll</st> <st c="11444">use</st>
    `<st c="11448">SwiftParser</st>`<st c="11459">:</st>
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11404">为了解析“Hello World”代码，我们将</st> <st c="11444">使用</st> `<st c="11448">SwiftParser</st>`<st
    c="11459">：</st>
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: <st c="11572">The parsing code is straightforward.</st> `<st c="11610">SyntaxParser</st>`
    <st c="11622">calls the parse method with our</st> `<st c="11655">sourceCode</st>`
    <st c="11665">constant from earlier and returns a syntax.</st> <st c="11710">But
    what is this syntax?</st> <st c="11735">Well, that’s our full code tree!</st>
    <st c="11768">The syntax variable is from the type</st> `<st c="11805">SourceFileSyntex</st>`<st
    c="11821">, and that type represents the syntax structure of our code.</st> <st
    c="11882">It’s the most high-level syntax node, encapsulating all our source code’s
    imports, classes,</st> <st c="11974">and functions.</st>
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11572">解析代码很简单。</st> `<st c="11610">SyntaxParser</st>` <st c="11622">调用解析方法，使用我们之前定义的</st>
    `<st c="11655">sourceCode</st>` <st c="11665">常量，并返回一个语法。</st> <st c="11710">但这是什么语法呢？</st>
    <st c="11735">嗯，那就是我们完整的代码树了！</st> <st c="11768">语法变量来自类型</st> `<st c="11805">SourceFileSyntex</st>`<st
    c="11821">，而这个类型代表了我们代码的语法结构。</st> <st c="11882">它是最高级别的语法节点，封装了所有源代码的导入、类、</st>
    <st c="11974">和函数。</st>
- en: <st c="11988">Now, it’s time to understand what this syntax tree</st> <st c="12040">looks
    like.</st>
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11988">现在，是时候了解这个语法树</st> <st c="12040">看起来是什么样子了。</st>
- en: <st c="12051">Investigating the tree</st>
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="12051">调查树</st>
- en: <st c="12074">One of</st> <st c="12081">the best things about working with</st>
    **<st c="12117">Swift Playgrounds</st>** <st c="12134">is that it’s not only great
    for playing with code</st> <st c="12185">snippets but also for examining their
    results without having to place breakpoints in</st> <st c="12270">our code.</st>
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12074">关于与**<st c="12117">Swift Playgrounds</st>** <st c="12134">一起工作的最好之处之一是，它不仅非常适合玩代码</st>
    <st c="12185">片段，而且还可以检查它们的结果，而无需在我们的代码中设置断点。</st>
- en: <st c="12279">After we run our</st> <st c="12297">Playground code, we can see
    the type</st> `<st c="12334">SourceFileSyntax</st>` <st c="12350">in the window’s
    right column.</st> <st c="12381">When we tap the small square next to it, we can
    see how the syntax constant is built (see</st> *<st c="12471">Figure 10</st>**<st
    c="12480">.4</st>*<st c="12482">):</st>
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12279">在我们运行我们的</st> <st c="12297">Playground代码</st> 后，我们可以在窗口的右侧列中看到类型</st>
    `<st c="12334">SourceFileSyntax</st>` <st c="12350">。</st> <st c="12381">当我们点击它旁边的方形图标时，我们可以看到语法常量是如何构建的（见</st>
    *<st c="12471">图10</st>**<st c="12480">.4</st>*<st c="12482">）：</st>
- en: '![Figure 10.4: The syntax object structure](img/B21795_figure_10.04.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 10.4: The syntax object structure](img/B21795_figure_10.04.jpg)'
- en: '<st c="13432">Figure 10.4: The syntax object structure</st>'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13432">图10.4：语法对象结构</st>
- en: <st c="13472">It’s an excellent time to take a moment, run it for yourself,
    and try to understand what we see in</st> *<st c="13572">Figure 10</st>**<st c="13581">.4</st>*<st
    c="13583">. Notice that I marked all the</st> <st c="13614">juicy parts.</st>
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13472">这是一个极佳的时刻，花点时间亲自运行它，并尝试理解我们在</st> *<st c="13572">图10</st>**<st
    c="13581">.4</st>*<st c="13583">中看到的内容。</st> 注意到我已经标记了所有</st> <st c="13614">有趣的部分。</st>
- en: <st c="13626">The</st> <st c="13630">syntax instance contains a list of statements.</st>
    <st c="13678">A</st> **<st c="13680">statement</st>** <st c="13689">is</st> <st
    c="13693">everything we can work with – an import, a class declaration, or even
    an expression.</st> <st c="13778">A statement can contain its</st> <st c="13806">own
    statements.</st>
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13626">语法实例包含一系列语句。</st> <st c="13630">一个</st> **<st c="13680">语句</st>**
    <st c="13689">是我们能处理的一切——一个导入、一个类声明，甚至是一个表达式。</st> <st c="13693">一个语句可以包含其</st>
    <st c="13806">自己的语句。</st>
- en: <st c="13821">The base statement class is</st> `<st c="13850">CodeBlockItemListSyntax</st>`<st
    c="13873">, and each statement type comes with a different subclass</st> <st c="13931">of</st>
    `<st c="13934">CodeBlockItemListSyntax</st>`<st c="13957">.</st>
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13821">基本语句类是</st> `<st c="13850">代码块项目列表语法</st>`<st c="13873">，每种语句类型都带有不同的</st>
    <st c="13931">子类</st> <st c="13934">CodeBlockItemListSyntax</st>`<st c="13957">。</st>
- en: <st c="13958">In our case, we have one statement from the type of</st> `<st
    c="14011">FunctionDeclSyntax</st>`<st c="14029">, which indicates a</st> <st c="14049">function
    declaration.</st>
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13958">在我们的情况下，我们有一个来自</st> `<st c="14011">函数声明语法</st>`<st c="14029">类型的语句，这表明一个</st>
    <st c="14049">函数声明。</st>
- en: <st c="14070">Expanding</st> `<st c="14081">FunctionDeclSyntax</st>` <st c="14099">reveals
    additional information about the function.</st> <st c="14151">For example, its
    name is represented by the</st> `<st c="14195">identifier</st>` <st c="14205">property
    (highlighted with a box in</st> *<st c="14242">Figure 10</st>**<st c="14251">.4</st>*<st
    c="14253">).</st>
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14070">展开</st> `<st c="14081">函数声明语法</st>` <st c="14099">可以揭示有关函数的更多信息。</st>
    <st c="14151">例如，它的名称由</st> `<st c="14195">标识符</st>` <st c="14205">属性表示（在*<st
    c="14242">图10</st>**<st c="14251">.4</st>*<st c="14253">中用框突出显示）。</st>
- en: '`<st c="14256">FunctionDeclSyntax</st>` <st c="14275">has a</st> `<st c="14282">body</st>`
    <st c="14286">property, which contains the property of a statement with all the
    function statements, including the call for the</st> `<st c="14401">print</st>`
    <st c="14406">function.</st>'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="14256">函数声明语法</st>` <st c="14275">有一个</st> `<st c="14282">体</st>` <st
    c="14286">属性，它包含具有所有函数语句的语句属性，包括对</st> `<st c="14401">print</st>` <st c="14406">函数的调用。</st>'
- en: <st c="14416">So, we can see that</st> `<st c="14437">SwiftParser</st>` <st
    c="14448">has done all the dirty work for us!</st> <st c="14485">Now that we have
    a tree, we can traverse it.</st> <st c="14530">Let’s extract the</st> <st c="14548">function
    statement:</st>
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14416">因此，我们可以看到</st> `<st c="14437">SwiftParser</st>` <st c="14448">已经为我们做了所有脏活。</st>
    <st c="14485">现在我们有一个树，我们可以遍历它。</st> <st c="14530">让我们提取</st> <st c="14548">函数语句：</st>
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: <st c="14677">In the preceding code, we are taking the first statement item
    and trying to convert it to a function</st> <st c="14779">declaration type.</st>
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们正在尝试将第一个语句项转换为函数声明类型。
- en: <st c="14796">There are various declaration types, each providing specific tools
    to help us traverse and extract more information.</st> <st c="14914">Here are
    some of the most common types we can try</st> <st c="14964">to extract:</st>
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14796">存在各种声明类型，每种类型都提供特定的工具来帮助我们遍历和提取更多信息。</st> <st c="14914">以下是一些我们可以尝试</st>
    <st c="14964">提取的最常见类型：</st>
- en: '`<st c="14975">VariableDeclSyntax</st>`<st c="14994">: This is</st> <st c="15005">for
    variables</st>'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="14975">变量声明语法</st>`<st c="14994">：这是用于</st> <st c="15005">变量的</st>'
- en: '`<st c="15018">EnumDeclSyntax</st>`<st c="15033">: This is for</st> <st c="15048">enum
    declaration</st>'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="15018">枚举声明语法</st>`<st c="15033">：这是用于</st> <st c="15048">枚举声明</st>'
- en: '`<st c="15064">ClassDeclSyntax</st>`<st c="15080">: This is for</st> <st c="15095">class
    declaration</st>'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="15064">类声明语法</st>`<st c="15080">：这是用于</st> <st c="15095">类声明</st>'
- en: '`<st c="15112">ProtocolDeclSyntax</st>`<st c="15131">: This is for</st> <st
    c="15146">protocol declaration</st>'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="15112">协议声明语法</st>`<st c="15131">：这是用于</st> <st c="15146">协议声明</st>'
- en: '`<st c="15166">TypealiasDeclSyntax</st>`<st c="15186">: This is for type</st>
    <st c="15206">alias declaration</st>'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="15166">类型别名声明语法</st>`<st c="15186">：这是用于类型</st> <st c="15206">别名声明</st>'
- en: '`<st c="15223">InitialzerDeclSyntax</st>`<st c="15244">: This is for</st> <st
    c="15259">construct declaration</st>'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="15223">初始化器声明语法</st>`<st c="15244">：这是用于</st> <st c="15259">构造声明</st>'
- en: '`<st c="15280">OperatorDeclSyntax</st>`<st c="15299">: This is for</st> <st
    c="15314">operator declaration</st>'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="15280">运算符声明语法</st>`<st c="15299">：这是用于</st> <st c="15314">运算符声明</st>'
- en: <st c="15334">These are just some</st> <st c="15354">syntax node types available
    in</st> `<st c="15386">SwiftSyntax</st>`<st c="15397">, and converting existing
    statement items to their corresponding types can provide us with the</st> <st
    c="15492">needed functionality.</st>
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15334">这些只是</st> <st c="15354">SwiftSyntax</st> <st c="15386">中可用的</st>
    <st c="15397">一些语法节点类型，将现有的语句项转换为它们对应的类型可以为我们提供所需的</st> <st c="15492">功能。</st>
- en: <st c="15513">Let’s continue our code example and see what we can get</st> <st
    c="15570">from</st> `<st c="15575">FunctionDeclSyntax</st>`<st c="15593">:</st>
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15513">让我们继续我们的代码示例，看看我们能得到什么</st> <st c="15570">来自</st> `<st c="15575">FunctionDeclSyntax</st>`<st
    c="15593">:</st>
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <st c="15729">Let’s dissect the preceding code snippet to understand what it
    accomplishes.</st> <st c="15807">With a function declaration, we can dig in and
    try to analyze the different statements that it contains.</st> <st c="15912">In
    this instance, we can find a statement from the type of</st> `<st c="15971">FunctionCallExprSyntax</st>`<st
    c="15993">. This type represents a function call, specifically, a call</st> <st
    c="16054">to</st> `<st c="16057">print()</st>`<st c="16064">.</st>
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15729">让我们剖析前面的代码片段，了解它完成了什么。</st> <st c="15807">有了函数声明，我们可以深入分析它包含的不同语句。</st>
    <st c="15912">在这个例子中，我们可以找到一个来自</st> `<st c="15971">FunctionCallExprSyntax</st>`<st
    c="15993">类型的语句。这种类型表示一个函数调用，具体来说，是调用</st> `<st c="16057">print()</st>`<st c="16064">。</st>
- en: <st c="16065">Now that we converted the statement to the right type, we can
    get more information</st> <st c="16149">about it:</st>
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16065">现在我们已经将语句转换为正确的类型，我们可以获取更多关于它的信息：</st>
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`<st c="16395">funcCallExpression</st>` <st c="16414">has a</st> `<st c="16421">calledExpression</st>`
    <st c="16437">property that encapsulates the information about actual</st> <st
    c="16494">expression components.</st>'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="16395">funcCallExpression</st>` <st c="16414">有一个</st> `<st c="16421">calledExpression</st>`
    <st c="16437">属性，它封装了关于实际</st> <st c="16494">表达式组件的信息。</st>'
- en: '`<st c="16516">firstToken</st>` <st c="16527">contains the</st> <st c="16540">function
    name itself.</st> <st c="16563">But what does “token” mean?</st> <st c="16591">Well,</st>
    `<st c="16736">text</st>` <st c="16740">property returns the</st> <st c="16762">function
    name.</st>'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="16516">firstToken</st>` <st c="16527">包含</st> <st c="16540">函数名本身。</st>
    <st c="16563">但“令牌”是什么意思呢？</st> <st c="16591">嗯，</st> `<st c="16736">text</st>`
    <st c="16740">属性返回</st> <st c="16762">函数名。</st>'
- en: <st c="16776">Next, we check if the function name is indeed</st> `<st c="16823">print</st>`<st
    c="16828">, and now we can check the value being printed by examining the function
    arguments list.</st> <st c="16917">Once we convert the first expression to</st>
    `<st c="16957">StringLiteralExprSyntax</st>`<st c="16980">, we can extract its
    first segment token and store it in the</st> `<st c="17041">value</st>` <st c="17046">constant.</st>
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16776">接下来，我们检查函数名是否确实是</st> `<st c="16823">print</st>`<st c="16828">，现在我们可以通过检查函数参数列表来检查被打印的值。</st>
    <st c="16917">一旦我们将第一个表达式转换为</st> `<st c="16957">StringLiteralExprSyntax</st>`<st
    c="16980">，我们就可以提取其第一个段令牌并将其存储在</st> `<st c="17041">value</st>` <st c="17046">常量中。</st>
- en: <st c="17056">Does it sound confusing and a little bit cumbersome?</st> <st
    c="17110">Well, we should remember that the</st> `<st c="17144">SwiftSyntax</st>`
    <st c="17155">library is not considered easy to work with.</st> <st c="17201">It
    has a steep learning curve with many options</st> <st c="17249">and features.</st>
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17056">听起来是不是有点混乱，有点繁琐？</st> <st c="17110">嗯，我们应该记住，</st> `<st c="17144">SwiftSyntax</st>`
    <st c="17155">库并不被认为容易使用。</st> <st c="17201">它有一个陡峭的学习曲线，有很多选项和功能。</st>
- en: <st c="17262">But this complexity is not a coincidence – parsing and analyzing
    programming language, especially an advanced and full-featured language such as
    Swift, is not simple.</st> <st c="17430">Just like we have</st> `<st c="17448">funcCallExpression</st>`<st
    c="17466">,</st> `<st c="17468">calledExpression</st>` <st c="17484">or</st> `<st
    c="17488">StringLiteralExprSyntax</st>`<st c="17511">, we have dozens of different
    types for different expressions.</st> <st c="17574">Looking at the</st> `<st c="17589">SwiftSyntax</st>`
    <st c="17600">documentation is the best way to learn to traverse and analyze more
    of</st> <st c="17672">the language.</st>
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17262">但这种复杂性并非巧合——解析和分析编程语言，尤其是像Swift这样的高级和功能齐全的语言，并不简单。</st> <st c="17430">就像我们有</st>
    `<st c="17448">funcCallExpression</st>`<st c="17466">，</st> `<st c="17468">calledExpression</st>`
    <st c="17484">或</st> `<st c="17488">StringLiteralExprSyntax</st>`<st c="17511">一样，我们为不同的表达式有数十种不同的类型。</st>
    <st c="17574">查看</st> `<st c="17589">SwiftSyntax</st>` <st c="17600">文档是学习遍历和分析更多</st>
    <st c="17672">语言的最佳方式。</st>
- en: <st c="17685">Now that we understand Swift code analysis using</st> `<st c="17735">SwiftSyntax</st>`<st
    c="17746">, let’s explore how we can leverage</st> `<st c="17782">SwiftSyntax</st>`
    <st c="17793">in the reverse direction – how to generate</st> <st c="17837">Swift
    code.</st>
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17685">现在我们了解了使用</st> `<st c="17735">SwiftSyntax</st>` <st c="17746">进行
    Swift 代码分析，让我们探索如何利用</st> `<st c="17782">SwiftSyntax</st>` <st c="17793">进行反向操作——如何生成</st>
    <st c="17837">Swift 代码。</st>
- en: <st c="17848">Generating Swift Code</st>
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="17848">生成 Swift 代码</st>
- en: <st c="17870">Generating</st> <st c="17881">code in</st> `<st c="17890">SwiftSyntax</st>`
    <st c="17901">is based on the built-in types and string literals.</st> <st c="17954">We
    can try and structure Swift code just by creating</st> <st c="18007">strings instances:</st>
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17870">在</st> <st c="17881">SwiftSyntax</st> <st c="17890">中生成代码基于内置类型和字符串字面量。</st>
    <st c="17954">我们可以尝试通过创建</st> <st c="18007">字符串实例来结构化 Swift 代码：</st>
- en: '[PRE9]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'let initSyntax = try <st c="18190">InitializerDeclSyntax</st>("init(title:
    String)") { <st c="18238">ExprSyntax</st>("self.title = title")'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 'let initSyntax = try <st c="18190">InitializerDeclSyntax</st>("init(title:
    String)") { <st c="18238">ExprSyntax</st>("self.title = title")'
- en: '}'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '@freestanding(expression)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '@独立的表达式'
- en: 'public macro stringify<T>(_ value: T) -> (T, String) = #externalMacro(module:
    "StructInitMacros",'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 'public macro stringify<T>(_ value: T) -> (T, String) = #externalMacro(module:
    "StructInitMacros",'
- en: 'type: "StringifyMacro")'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类型："StringifyMacro")
- en: '[PRE11]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '#URL("https://swift.org/")'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '#URL("https://swift.org/")'
- en: '[PRE12]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: <st c="23020">@StructInit</st> struct Book {
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="23020">@StructInit</st> struct Book {
- en: 'var id: Int'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'var id: Int'
- en: 'var title: String'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'var title: String'
- en: 'var subtitle: String'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'var subtitle: String'
- en: 'var description: String'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'var description: String'
- en: 'var author: String'
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'var author: String'
- en: '}'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE13]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '@attached(member)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '@附加的成员'
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '@attached(member, names: named(init))'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '@附加的成员，名称：命名（init）'
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '@attached(member, names: named(rawValue))'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '@附加的成员，名称：命名（rawValue）'
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '@attached(member, names: arbitrary)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '@附加的成员，名称：任意'
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '@attached(member, names: named(init))'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '@附加的成员，名称：命名（init）'
- en: 'public macro <st c="25373">StructInit</st>() = #externalMacro(module:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 'public macro <st c="25373">StructInit</st>() = #externalMacro(module:'
- en: '"<st c="25541">StructInit</st>.'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"<st c="25541">StructInit</st>.'
- en: <st c="25552">The macro is short but tells a lot about its goal and behavior.</st>
    <st c="25617">Here comes the important part – the</st> <st c="25653">macro implementation.</st>
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="25552">这个宏虽然简短，但讲述了它的目标和行为。</st> <st c="25617">接下来是重要的部分——</st> <st c="25653">宏的实现。</st>
- en: <st c="25674">Implementing the macro</st>
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="25674">实现宏</st>
- en: <st c="25697">Unlike other Swift types, in</st> <st c="25727">macros, we separate
    our declaration and implementation into different files.</st> <st c="25804">In
    a way, it resembles Objective-C or C++, when the header and the implementation
    were</st> <st c="25891">other parts.</st>
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="25697">与其他 Swift 类型不同，在</st> <st c="25727">宏中，我们将声明和实现分开到不同的文件中。</st>
    <st c="25804">从某种意义上说，这类似于 Objective-C 或 C++，当时头文件和实现是</st> <st c="25891">其他部分。</st>
- en: <st c="25903">We will open our</st> `<st c="25921">StructInitMacros</st>` <st
    c="25937">file and clear its content for a clean start.</st> <st c="25984">Afterward,
    we can proceed to import the</st> <st c="26024">relevant libraries:</st>
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="25903">我们将打开我们的</st> `<st c="25921">StructInitMacros</st>` <st c="25937">文件，并清除其内容以从头开始。</st>
    <st c="25984">之后，我们可以继续导入</st> <st c="26024">相关库：</st>
- en: '[PRE18]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: <st c="26140">These are the standard libraries in most macros we will write.</st>
    <st c="26204">Notice that we have</st> `<st c="26224">SwiftSyntax</st>` <st c="26235">and</st>
    `<st c="26240">SwiftSyntaxBuilder</st>` <st c="26258">as part of what we’ve learned
    in the</st> *<st c="26296">Exploring</st>* *<st c="26306">SwiftSyntax</st>* <st
    c="26317">section.</st>
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="26140">这些是我们将要编写的宏中的标准库。</st> <st c="26204">请注意，我们有</st> `<st c="26224">SwiftSyntax</st>`
    <st c="26235">和</st> `<st c="26240">SwiftSyntaxBuilder</st>` <st c="26258">作为我们在</st>
    *<st c="26296">探索</st> * *<st c="26306">SwiftSyntax</st> * <st c="26317">部分学到的内容的一部分。</st>
- en: <st c="26326">Now, let’s move on to the main dish – the</st> `<st c="26369">StructInit</st>`
    <st c="26379">struct.</st>
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="26326">现在，让我们进入主菜——</st> `<st c="26369">StructInit</st>` <st c="26379">结构体。</st>
- en: <st c="26387">Declaring the StructInit struct</st>
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="26387">声明 StructInit 结构体</st>
- en: <st c="26419">In Swift Macros, Apple</st> <st c="26443">continues its trend
    of working mainly with structs and protocols instead of classes</st> <st c="26527">and
    inheritance.</st>
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="26419">在 Swift 宏中，Apple</st> <st c="26443">继续其主要使用结构体和协议而不是类</st> <st
    c="26527">和继承的趋势。</st>
- en: <st c="26543">To implement a new macro, we will add a new struct with the macro
    name that conforms to a protocol</st> <st c="26643">named</st> `<st c="26649">MemberMacro</st>`<st
    c="26660">:</st>
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="26543">要实现一个新的宏，我们将添加一个新的结构体，其名称与名为</st> <st c="26649">MemberMacro</st>
    <st c="26660">的协议</st> <st c="26643">相符合</st>：
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: <st c="26796">The compiler looks for a struct with an identical name to the
    macro name we declared earlier under the</st> *<st c="26900">Adding a new Swift
    macro</st>* <st c="26924">section.</st> <st c="26934">We also declared the</st>
    `<st c="26955">StructInit</st>` <st c="26965">as</st> `<st c="26969">public</st>`
    <st c="26975">– remember that a macro is part of a Swift package, so we need to
    have it accessible from other modules</st> <st c="27080">as well.</st>
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="26796">编译器会在</st> *<st c="26900">添加新的 Swift 宏</st>* <st c="26924">部分下寻找与我们之前声明的宏名称相同的结构体。</st>
    <st c="26934">我们还声明了</st> `<st c="26955">StructInit</st>` <st c="26965">为</st>
    `<st c="26969">public</st>` <st c="26975"> – 记住，宏是 Swift 包的一部分，因此我们需要确保它可以从其他模块中访问。</st>
- en: <st c="27088">So, what is the</st> `<st c="27105">MemberMacro</st>` <st c="27116">protocol?</st>
    <st c="27127">The</st> `<st c="27131">MemberMacro</st>` <st c="27142">protocol
    contains one crucial function that performs the expansion operation, with the
    non-surprising name</st> <st c="27250">of</st> `<st c="27253">expansion()</st>`<st
    c="27264">.</st>
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="27088">那么，什么是</st> `<st c="27105">MemberMacro</st>` <st c="27116">协议呢？</st>
    <st c="27127">`<st c="27131">MemberMacro</st>` <st c="27142">协议包含一个执行展开操作的关键函数，其名称非同寻常，为</st>
    `<st c="27250">expansion()</st>`<st c="27264">。</st>
- en: <st c="27265">However, we won’t use</st> `<st c="27288">MemberMacro</st>` <st
    c="27299">every time we create a macro, as it is relevant only to the macro’s</st>
    `<st c="27368">attached(member)</st>` <st c="27384">role.</st> <st c="27391">Each
    role has a different protocol we need to</st> <st c="27437">conform to.</st>
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="27265">然而，我们不会在创建每个宏时都使用</st> `<st c="27288">MemberMacro</st>` <st c="27299">，因为它只与宏的</st>
    `<st c="27368">attached(member)</st>` <st c="27384">角色相关。</st> <st c="27391">每个角色都有一个我们需要</st>
    <st c="27437">遵守的协议。</st>
- en: <st c="27448">Here is the list of the different roles and their</st> <st c="27499">corresponding
    protocol:</st>
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="27448">以下是不同角色及其</st> <st c="27499">对应协议的列表：</st>
- en: '`<st c="27522">@freestanding(expression) -></st>` `<st c="27552">ExpressionMacro</st>`'
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="27522">@freestanding(expression) -></st>` `<st c="27552">ExpressionMacro</st>`'
- en: '`<st c="27567">@freestanding(declaration) -></st>` `<st c="27598">DeclarationMacro</st>`'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="27567">@freestanding(declaration) -></st>` `<st c="27598">DeclarationMacro</st>`'
- en: '`<st c="27614">@attached(peer) -></st>` `<st c="27634">PeerMacro</st>`'
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="27614">@attached(peer) -></st>` `<st c="27634">PeerMacro</st>`'
- en: '`<st c="27643">@attached(accessor) -></st>` `<st c="27667">AccessorMacro</st>`'
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="27643">@attached(accessor) -></st>` `<st c="27667">AccessorMacro</st>`'
- en: '`<st c="27680">@attached(memberAttribute) -></st>` `<st c="27711">MemberAttributeMacro</st>`'
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="27680">@attached(memberAttribute) -></st>` `<st c="27711">MemberAttributeMacro</st>`'
- en: '`<st c="27731">@attached(member) -></st>` `<st c="27753">MemberMacro</st>`'
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="27731">@attached(member) -></st>` `<st c="27753">MemberMacro</st>`'
- en: '`<st c="27764">@attached(conformance) -></st>` `<st c="27791">ConformanceMacro</st>`'
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="27764">@attached(conformance) -></st>` `<st c="27791">ConformanceMacro</st>`'
- en: <st c="27807">Since we are building a</st> <st c="27831">Swift macro with the</st>
    `<st c="27853">@attached(member)</st>` <st c="27870">role, we will focus only
    on</st> `<st c="27899">MemberMacro</st>`<st c="27910">, even though the concept
    is similar to the</st> <st c="27954">other protocols.</st>
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="27807">由于我们正在使用</st> <st c="27831">Swift 宏并具有</st> `<st c="27853">@attached(member)</st>`
    <st c="27870">角色，我们将只关注</st> `<st c="27899">MemberMacro</st>`<st c="27910">，尽管这个概念与其他协议类似。</st>
- en: <st c="27970">Let’s go over</st> <st c="27985">it together!</st>
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="27970">让我们一起来了解一下！</st>
- en: <st c="27997">Implementing the expansion function</st>
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="27997">实现展开函数</st>
- en: <st c="28033">I’ll start by</st> <st c="28048">showing you the</st> `<st c="28064">expansion</st>`
    <st c="28073">function:</st>
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="28033">我将首先</st> <st c="28048">向您展示</st> `<st c="28064">expansion</st>`
    <st c="28073">函数：</st>
- en: '[PRE20]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: <st c="28269">While the function may look a little bit complex, we need to remember</st>
    <st c="28340">two things:</st>
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="28269">虽然这个函数可能看起来有点复杂，但我们需要记住</st> <st c="28340">两件事：</st>
- en: <st c="28351">Most types mentioned in the function signature should already
    be recognizable to us, as they are components of the</st> `<st c="28467">SwiftSyntax</st>`
    <st c="28478">library.</st>
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="28351">在函数签名中提到的多数类型应该对我们来说已经熟悉，因为它们是</st> `<st c="28467">SwiftSyntax</st>`
    <st c="28478">库的组成部分。</st>
- en: <st c="28487">There’s only one function in this protocol.</st> <st c="28532">No
    need to implement</st> <st c="28553">another one!</st>
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="28487">这个协议中只有一个函数。</st> <st c="28532">无需实现</st> <st c="28553">另一个函数！</st>
- en: <st c="28565">The</st> `<st c="28570">expansion</st>` <st c="28579">function
    aims to receive information about the attached object or the macro parameters
    and return a piece of Swift code, represented by an array of</st> `<st c="28728">SwiftSyntax</st>`
    <st c="28739">expressions (</st>`<st c="28753">DeclSyntax</st>`<st c="28764">).</st>
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="28565">扩展函数的目的是接收有关附加对象或宏参数的信息，并返回一个表示为</st> `<st c="28728">SwiftSyntax</st>`
    <st c="28739">表达式数组（</st>`<st c="28753">DeclSyntax</st>`<st c="28764">）的Swift代码片段。</st>
- en: <st c="28767">The expansion function has</st> <st c="28795">three parameters:</st>
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="28767">扩展函数有三个参数：</st>
- en: '`<st c="28812">node: AtributeSyntax</st>`<st c="28833">: This node represents
    that actual macro in the original piece of</st> <st c="28900">Swift code.</st>'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<st c="28812">节点：AtributeSyntax</st>`<st c="28833">：此节点表示原始Swift代码中的实际宏。</st>'
- en: '`<st c="28911">declaration: some DeclGroupSyntax</st>`<st c="28945">: The declaration
    struct that describes the struct/class the macro is</st> <st c="29016">attached
    to.</st>'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<st c="28911">声明：some DeclGroupSyntax</st>`<st c="28945">：描述宏附加到的结构/类的声明结构。</st>'
- en: '`<st c="29028">context: some MacroExpansionContext</st>`<st c="29064">: The
    context provides us with more information about the compiler.</st> <st c="29133">Remember
    that the compiler serves as the “environment” in which the</st> <st c="29201">macro
    functions.</st>'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<st c="29028">上下文：some MacroExpansionContext</st>`<st c="29064">：上下文为我们提供了更多关于编译器的信息。</st>
    <st c="29133">记住，编译器作为宏函数的“环境”。</st>'
- en: <st c="29217">Now, we can start creating our struct</st> `<st c="29256">init</st>`
    <st c="29260">method.</st>
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="29217">现在，我们可以开始创建我们的结构</st> `<st c="29256">init</st>` <st c="29260">方法。</st>
- en: <st c="29268">First, we need to have a list of all the struct properties, including
    names and types.</st> <st c="29356">To do that, we need to analyze the code using</st>
    `<st c="29402">SwiftSyntax</st>`<st c="29413">, which we just learned in this
    chapter ( in the</st> *<st c="29462">Exploring</st>* *<st c="29472">SwiftSyntax</st>*
    <st c="29483">section).</st>
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="29268">首先，我们需要有一个包含所有结构属性的列表，包括名称和类型。</st> <st c="29356">为此，我们需要使用</st>
    `<st c="29402">SwiftSyntax</st>`<st c="29413">分析代码，这是我们本章刚刚学习的内容（在</st> *<st c="29462">探索</st>*
    *<st c="29472">SwiftSyntax</st>* <st c="29483">部分）。</st>
- en: <st c="29493">So, let’s get</st> <st c="29507">all the struct information that</st>
    <st c="29540">we need:</st>
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="29493">因此，让我们获取</st> <st c="29507">我们需要的所有结构信息：</st>
- en: '[PRE21]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: <st c="29855">Let’s explain the preceding code, line</st> <st c="29895">by line:</st>
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="29855">让我们逐行解释前面的代码：</st>
- en: <st c="29903">We use the declaration parameter to get all the</st> <st c="29952">struct
    members.</st>
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="29903">我们使用声明参数来获取所有</st> <st c="29952">结构成员。</st>
- en: <st c="29967">All the struct members also include their functions, so we filter
    it only</st> <st c="30042">to variables.</st>
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="29967">所有结构成员也包括它们的功能，所以我们只</st> <st c="30042">过滤变量。</st>
- en: <st c="30055">We create an array of all the variable’s names using their</st>
    `<st c="30115">pattern</st>` <st c="30122">attribute.</st>
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="30055">我们使用变量的</st> `<st c="30115">pattern</st>` <st c="30122">属性创建所有变量名的数组。</st>
- en: <st c="30133">We create another variety with all the variable types, using their</st>
    `<st c="30201">typeAnnotation</st>` <st c="30215">attribute.</st>
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="30133">我们使用变量的</st> `<st c="30201">typeAnnotation</st>` <st c="30215">属性创建所有变量类型的数组。</st>
- en: <st c="30226">Now that we have all the information we need, we can generate
    our Swift code for the</st> `<st c="30312">init</st>` <st c="30316">function.</st>
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="30226">现在我们有了所有需要的信息，我们可以生成</st> `<st c="30312">init</st>` <st c="30316">函数的Swift代码。</st>
- en: <st c="30326">First, we generate the</st> `<st c="30350">init</st>` <st c="30354">function
    signature based on the list of variable names</st> <st c="30410">and types:</st>
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="30326">首先，我们根据变量名</st> `<st c="30350">init</st>` <st c="30354">函数签名基于变量名列表和类型：</st>
- en: '[PRE22]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: <st c="30573">The preceding code starts by creating a mutable string, looping
    all the variable names and types, and adding them to the function signature.</st>
    <st c="30714">Once the code adds all the function parameters, it closes with a</st>
    <st c="30779">closing parenthesis.</st>
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="30573">前面的代码首先创建一个可变字符串，遍历所有变量名和类型，并将它们添加到函数签名中。</st> <st c="30714">一旦代码添加了所有函数参数，它就通过一个</st>
    <st c="30779">闭括号</st>结束。
- en: <st c="30799">Next, it’s time to</st> <st c="30819">add the function body.</st>
    <st c="30842">We can do that using a special</st> `<st c="30873">SwiftSyntax</st>`
    <st c="30884">struct that represents an initializer declaration</st> <st c="30935">called</st>
    `<st c="30942">InitializerDeclSyntax</st>`<st c="30963">:</st>
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="30799">接下来，是时候</st> <st c="30819">添加函数体了。</st> <st c="30842">我们可以使用一个特殊的</st>
    `<st c="30873">SwiftSyntax</st>` <st c="30884">结构体，它代表一个初始化器声明</st> <st c="30935">称为</st>
    `<st c="30942">InitializerDeclSyntax</st>`<st c="30963">：</st>
- en: '[PRE23]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: <st c="31121">The</st> `<st c="31126">InitializerDeclSyntax</st>` <st c="31147">“init”
    function receives two parameters – the function signature and a closure with the
    “init” body represented</st> <st c="31260">by</st> `<st c="31263">ExprSyntax</st>`<st
    c="31273">.</st>
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="31121">`<st c="31126">InitializerDeclSyntax</st>` <st c="31147">“init”函数接收两个参数——函数签名和一个包含“init”体</st>
    <st c="31260">的闭包，该体由</st> `<st c="31263">ExprSyntax</st>`<st c="31273">表示。</st>
- en: <st c="31274">Now that we have</st> `<st c="31292">initializer</st>`<st c="31303">,
    we can return an array</st> <st c="31328">of</st> `<st c="31331">DeclSyntax</st>`<st
    c="31341">:</st>
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="31274">现在我们有了</st> `<st c="31292">initializer</st>`<st c="31303">，我们可以返回一个</st>
    <st c="31328">DeclSyntax</st>`<st c="31331">数组：</st>
- en: '[PRE24]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: <st c="31376">Let’s see the</st> <st c="31391">full code:</st>
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="31376">让我们看看</st> <st c="31391">完整的代码：</st>
- en: '[PRE25]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: <st c="32030">The code takes the struct list of variables and generates its
    own</st> `<st c="32097">init</st>` <st c="32101">function.</st>
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="32030">该代码接受变量结构体列表并生成自己的</st> `<st c="32097">init</st>` <st c="32101">函数。</st>
- en: <st c="32111">How does it look?</st> <st c="32130">Let’s</st> <st c="32135">demonstrate
    that with a</st> <st c="32160">small struct:</st>
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="32111">它看起来怎么样？</st> <st c="32130">让我们</st> <st c="32135">用一个</st> <st
    c="32160">小的结构体</st> <st c="32165">来演示：</st>
- en: '[PRE26]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: <st c="32219">The</st> `<st c="32224">expansion</st>` <st c="32233">method</st>
    <st c="32241">creates the following</st> `<st c="32263">init</st>` <st c="32267">function:</st>
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="32219">`<st c="32224">expansion</st>` <st c="32233">方法</st> <st c="32241">创建了以下</st>
    `<st c="32263">init</st>` <st c="32267">函数：</st>
- en: '[PRE27]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: <st c="32342">But the fact that we just defined the macro behavior doesn’t mean
    we can use it.</st> <st c="32424">Remember that the macro runs as a compiler plugin.</st>
    <st c="32475">That’s our</st> <st c="32486">next step.</st>
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="32342">但我们定义宏行为的事实并不意味着我们可以使用它。</st> <st c="32424">记住，宏作为编译器插件运行。</st>
    <st c="32475">这是我们</st> <st c="32486">下一步要做的。</st>
- en: <st c="32496">Adding the compiler plugin</st>
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="32496">添加编译器插件</st>
- en: <st c="32523">The compiler plugin is our</st> <st c="32551">macro “product,”
    or, in other words, the macro</st> <st c="32598">entry point.</st>
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="32523">编译器插件是我们的</st> <st c="32551">宏“product”，或者换句话说，宏</st> <st c="32598">入口点。</st>
- en: '<st c="32610">In iOS, macros are invoked in a sandbox without network access
    and system file changes.</st> <st c="32699">The question is this: How does the
    compiler instantiate and store Swift macros to be used as</st> <st c="32792">a
    plugin?</st>'
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="32610">在 iOS 中，宏在无网络访问和系统文件更改的沙盒中调用。</st> <st c="32699">问题是这样的：编译器如何实例化和存储
    Swift 宏以用作</st> <st c="32792">插件？</st>
- en: <st c="32801">The answer is that it doesn’t.</st> <st c="32833">If we have another
    look at our code, we’ll notice that Swift Macros functions are all static, and
    that’s an important issue when creating a</st> <st c="32973">new macro.</st>
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="32801">答案是否定的。</st> <st c="32833">如果我们再次审视我们的代码，我们会注意到 Swift 宏函数都是静态的，这在创建一个</st>
    <st c="32973">新宏时是一个重要的问题。</st>
- en: <st c="32983">So, to create a compiler plugin, we need to define a new struct
    that conforms to the</st> `<st c="33069">CompilerPlugin</st>` <st c="33083">protocol
    and has the</st> `<st c="33105">@main</st>` <st c="33110">attribute mark:</st>
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="32983">因此，要创建一个编译器插件，我们需要定义一个新的符合</st> `<st c="33069">CompilerPlugin</st>`
    <st c="33083">协议并具有</st> `<st c="33105">@main</st>` <st c="33110">属性标记的</st>结构体：</st>
- en: '[PRE28]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: <st c="33243">The preceding code shows that</st> `<st c="33274">struct_initial_macroPlugin</st>`
    <st c="33300">implements one variable</st> `<st c="33325">get</st>` <st c="33328">method
    –</st> `<st c="33338">providingMacros</st>` <st c="33353">– and returns an array
    of macro types instead</st> <st c="33400">of instances.</st>
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="33243">前面的代码显示，`<st c="33274">struct_initial_macroPlugin</st>` <st c="33300">实现了一个变量</st>
    `<st c="33325">get</st>` <st c="33328">方法——</st> `<st c="33338">providingMacros</st>`
    <st c="33353">——并返回一个宏类型的数组而不是实例。</st>
- en: <st c="33413">Another essential thing to notice here is the struct name (</st>`<st
    c="33473">struct_initial_macroPlugin</st>`<st c="33500">).</st> <st c="33504">It
    doesn’t matter what name we give it as long as it conforms</st> <st c="33566">to
    the</st> `<st c="33573">CompilerPlugin</st>` <st c="33587">protocol and has the</st>
    `<st c="33609">@</st>``<st c="33610">main</st>` <st c="33614">attribute.</st>
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="33413">在此处需要注意的另一件重要事情是结构体名称（</st>`<st c="33473">struct_initial_macroPlugin</st>`<st
    c="33500">）。</st> <st c="33504">只要它符合</st> <st c="33566">`<st c="33573">CompilerPlugin</st>`</st>
    <st c="33587">协议并具有</st> `<st c="33609">@</st>``<st c="33610">main</st>` <st c="33614">属性，我们给它取什么名字都无关紧要。</st>
- en: <st c="33625">Now that we have a compiler plugin, our compiler is ready to</st>
    <st c="33687">run it.</st>
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="33625">现在我们有了编译器插件，我们的编译器已经准备好</st> <st c="33687">运行它。</st>
- en: <st c="33694">Running our macro using a client</st>
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="33694">使用客户端运行我们的宏</st>
- en: <st c="33727">Macro executables are</st> <st c="33749">different than apps or
    libraries since they run in a compiler environment.</st> <st c="33825">If we go
    back in our chapter to the section where we create the Swift Macros Swift package
    (</st>*<st c="33917">Examining our Swift Macros package structure</st>* <st c="33962">section),
    we see that the Swift macro has another folder</st> <st c="34020">called</st>
    `<st c="34027">StructInitClient</st>`<st c="34043">.</st>
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="33727">宏可执行文件与应用程序或库不同，因为它们在编译器环境中运行。</st> <st c="33825">如果我们回到本章中创建Swift宏Swift包的部分（</st>*<st
    c="33917">检查我们的Swift宏包结构</st>* <st c="33962">部分），我们会看到Swift宏还有一个名为</st> `<st c="34020">StructInitClient</st>`<st
    c="34043">的文件夹。</st>
- en: '`<st c="34044">StructInitClient</st>` <st c="34061">is our Swift macro executable,
    also defined in the macro’s</st> `<st c="34121">package.swift</st>` <st c="34134">manifest
    file:</st>'
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="34044">StructInitClient</st>` <st c="34061">是我们Swift宏可执行文件，也定义在宏的</st>
    `<st c="34121">package.swift</st>` <st c="34134">清单文件中：</st>'
- en: '[PRE29]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: <st c="34220">Now, we can change the code we have in the</st> `<st c="34264">main.swift</st>`
    <st c="34274">file to</st> <st c="34283">the following:</st>
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="34220">现在，我们可以将我们在</st> `<st c="34264">main.swift</st>` <st c="34274">文件中的代码改为</st>
    <st c="34283">以下内容：</st>
- en: '[PRE30]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: <st c="34455">In the preceding</st> <st c="34473">code, we have a simple struct
    named</st> `<st c="34509">Book</st>`<st c="34513">, but now, we have also attached
    the</st> `<st c="34550">@StructInit</st>` <st c="34561">macro we</st> <st c="34571">just
    created.</st>
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="34455">在前面</st> <st c="34473">的代码中，我们有一个名为</st> `<st c="34509">Book</st>`<st
    c="34513">的简单结构体，但现在，我们还附加了我们刚刚创建的</st> `<st c="34550">@StructInit</st>` <st c="34561">宏。</st>
- en: <st c="34584">Right-click on the macro itself and choose</st> **<st c="34628">Expand
    Macro</st>**<st c="34640">, which reveals the generated code (</st>*<st c="34676">Figure
    10</st>**<st c="34686">.8</st>*<st c="34688">):</st>
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="34584">右键单击宏本身并选择</st> **<st c="34628">展开宏</st>**<st c="34640">，这将揭示生成的代码（</st>*<st
    c="34676">图10</st>**<st c="34686">.8</st>*<st c="34688">）：</st>
- en: '![Figure 10.8: Swift macro expansion](img/B21795_figure_10.08.jpg)'
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图10.8：Swift宏展开](img/B21795_figure_10.08.jpg)'
- en: '<st c="35057">Figure 10.8: Swift macro expansion</st>'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="35057">图10.8：Swift宏展开</st>
- en: <st c="35091">Using our macro executable is a great way to see our macro in
    action!</st> <st c="35162">At this point, everything should work as expected.</st>
    <st c="35213">It’s time to level up our macro implementation with some</st> <st
    c="35270">error handling.</st>
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="35091">使用我们的宏可执行文件是查看宏实际运行效果的好方法！</st> <st c="35162">此时，一切应该都按预期工作。</st>
    <st c="35213">现在是时候通过一些</st> <st c="35270">错误处理</st>来提升我们的宏实现。</st>
- en: <st c="35285">Handling macros errors</st>
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="35285">处理宏错误</st>
- en: <st c="35308">When we create a</st> <st c="35326">Swift macro, things obvious
    to us, as the macro developers, are not obvious to our</st> <st c="35409">macro
    users.</st>
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="35308">当我们创建一个</st> <st c="35326">Swift宏时，对我们这些宏开发者来说显而易见的事情，对我们这些</st>
    <st c="35409">宏用户来说并不明显。</st>
- en: <st c="35421">Our</st> `<st c="35426">StructInit</st>` <st c="35436">macro is
    designed to function exclusively with structs, not classes.</st> <st c="35506">Therefore,
    we need to check whether the attached element is indeed</st> <st c="35573">a struct.</st>
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="35421">我们的</st> `<st c="35426">StructInit</st>` <st c="35436">宏设计为仅与结构体一起使用，而不是类。</st>
    <st c="35506">因此，我们需要检查附加的元素是否确实是</st> <st c="35573">一个结构体。</st>
- en: <st c="35582">Inside the</st> `<st c="35594">expansion()</st>` <st c="35605">function,
    we can perform a simple</st> `<st c="35640">guard</st>` <st c="35645">statement
    and throw an error in case the attached declaration is not</st> <st c="35715">a
    struct:</st>
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="35582">在</st> `<st c="35594">expansion()</st>` <st c="35605">函数内部，我们可以执行一个简单的</st>
    `<st c="35640">guard</st>` <st c="35645">语句，并在附加的声明不是</st> <st c="35715">结构体的情况下抛出一个错误：</st>
- en: '[PRE31]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: <st c="35828">In the preceding code,</st> `<st c="35852">StructInitError</st>`
    <st c="35867">is an enum that conforms</st> <st c="35893">to</st> `<st c="35896">Error</st>`<st
    c="35901">:</st>
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="35828">在上面的代码中，</st> `<st c="35852">StructInitError</st>` <st c="35867">是一个符合</st>
    <st c="35893">的枚举</st> `<st c="35896">Error</st>`<st c="35901">:</st>
- en: '[PRE32]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: <st c="36097">Having an enum</st> <st c="36113">with different error types and
    messages can make a developer’s life much easier.</st> <st c="36194">Remember
    that this error appears in compile time (</st>*<st c="36244">Figure 10</st>**<st
    c="36254">.9</st>*<st c="36256">):</st>
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="36097">拥有一个具有不同错误类型和消息的枚举可以使开发者的生活变得更加容易。</st> <st c="36194">记住，这个错误出现在编译时（</st>*<st
    c="36244">图10.9</st>**<st c="36254">.9</st>*<st c="36256">）：</st>
- en: '![Figure 10.9: An error message is thrown when implementing a Swift macro](img/B21795_figure_10.09.jpg)'
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图10.9：实现Swift宏时抛出一个错误信息](img/B21795_figure_10.09.jpg)'
- en: '<st c="36309">Figure 10.9: An error message is thrown when implementing a Swift
    macro</st>'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="36309">图10.9：实现Swift宏时抛出一个错误信息</st>
- en: <st c="36380">But sometimes, we want to handle more complex errors.</st> <st
    c="36435">For example, sometimes we want to show a warning, not just an error.</st>
    <st c="36504">Or, in other cases, we even want to offer our developer a fix for</st>
    <st c="36570">their problem.</st>
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="36380">但有时，我们想要处理更复杂的错误。</st> <st c="36435">例如，有时我们只想显示警告，而不仅仅是错误。</st>
    <st c="36504">或者，在其他情况下，我们甚至想为</st> <st c="36570">开发者的问题提供一个解决方案。</st>
- en: <st c="36584">In these cases, we can</st> <st c="36608">add something called
    a</st> `<st c="36631">Diagnostic</st>` <st c="36641">struct.</st> <st c="36650">A</st>
    `<st c="36652">Diagnostic</st>` <st c="36662">struct is more suitable for showing
    errors in a compiler environment and has more capabilities than just</st> <st
    c="36768">throwing errors.</st>
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="36584">在这些情况下，我们可以</st> <st c="36608">添加一个名为</st> `<st c="36631">Diagnostic</st>`
    <st c="36641">的结构体。</st> <st c="36650">一个</st> `<st c="36652">Diagnostic</st>`
    <st c="36662">结构体更适合在编译器环境中显示错误，并且比仅仅</st> <st c="36768">抛出错误</st> 具有更多功能。
- en: <st c="36784">Let’s create a</st> `<st c="36800">DiagnosticMessage</st>` <st
    c="36817">enum and a</st> `<st c="36829">Diagnostic</st>` <st c="36839">struct:</st>
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="36784">让我们创建一个</st> `<st c="36800">DiagnosticMessage</st>` <st c="36817">枚举和一个</st>
    `<st c="36829">Diagnostic</st>` <st c="36839">结构体：</st>
- en: '[PRE33]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: context.diagnose(diagnostic)
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: context.diagnose(diagnostic)
- en: '[PRE34]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: guard let structDecl = declaration.as(StructDeclSyntax.self) else {
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: guard let structDecl = declaration.as(StructDeclSyntax.self) else {
- en: 'let diagnostic = Diagnostic(node: node,'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'let diagnostic = Diagnostic(node: node,'
- en: 'message: MyLibDiagnostic.notAStruct) <st c="37870">context.diagnose(diagnostic)</st>
    throw StructInitError.onlyAStruct'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'message: MyLibDiagnostic.notAStruct) <st c="37870">context.diagnose(diagnostic)</st>
    throw StructInitError.onlyAStruct'
- en: '}'
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE35]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'let testMacros: [String: Macro.Type] = ['
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 'let testMacros: [String: Macro.Type] = ['
- en: '"StructInit": StructInit.self,'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"StructInit": StructInit.self,'
- en: ']'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: 'final class StructInitTests: XCTestCase {'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 'final class StructInitTests: XCTestCase {'
- en: func testMacro() {
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: func testMacro() {
- en: assertMacroExpansion(
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: assertMacroExpansion(
- en: '"""'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"""'
- en: '@StructInit'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@StructInit'
- en: struct Book {
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: struct Book {
- en: 'var id: Int'
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'var id: Int'
- en: 'var title: String'
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'var title: String'
- en: 'var subtitle: String'
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'var subtitle: String'
- en: '}'
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '""",'
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '""",'
- en: 'expandedSource:'
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'expandedSource:'
- en: '"""'
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"""'
- en: struct Book {
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: struct Book {
- en: 'var id: Int'
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'var id: Int'
- en: 'var title: String'
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'var title: String'
- en: 'var subtitle: String'
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'var subtitle: String'
- en: 'init(id: Int, title: String,'
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'init(id: Int, title: String,'
- en: 'subtitle: String) {'
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'subtitle: String) {'
- en: self.id = id
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: self.id = id
- en: self.title = title
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: self.title = title
- en: self.subtitle = subtitle
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: self.subtitle = subtitle
- en: '}'
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '""",'
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '""",'
- en: 'macros: testMacros'
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'macros: testMacros'
- en: )
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: )
- en: '}'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE36]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
